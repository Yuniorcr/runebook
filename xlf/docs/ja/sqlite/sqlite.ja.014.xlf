<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="3c67e89c578626f4a5845690f5e802d46290edfe" translate="yes" xml:space="preserve">
          <source>The &quot;ORDER BY 2&quot; (which means the same as &quot;ORDER BY under_alice.level+1&quot;) causes higher levels in the organization chart (with smaller &quot;level&quot; values) to be processed first, resulting in a breadth-first search. The output is:</source>
          <target state="translated">ORDER BY 2」(「ORDER BY under_alice.level+1」と同じ意味)は、組織図の上位レベル(「レベル」の値が小さい方)が先に処理され、結果的に幅優先の検索になります。出力は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="f957a1348139bb0e4f79cd1d2fbd5306c674fbde" translate="yes" xml:space="preserve">
          <source>The &quot;ORDER BY checkin.mtime DESC&quot; term in the recursive-select makes the query run much faster by preventing it from following branches that merge checkins from long ago. The ORDER BY forces the recursive-select to focus on the most recent checkins, the ones we want. Without the ORDER BY on the recursive-select, one would be forced to compute the complete set of thousands of ancestors, sort them all by mtime, then take the top twenty. The ORDER BY essentially sets up a priority queue that forces the recursive query to look at the most recent ancestors first, allowing the use of a LIMIT clause to restrict the scope of the query to just the checkins of interest.</source>
          <target state="translated">再帰的選択の中の &quot;ORDER BY checkin.mtime DESC &quot;という用語は、ずっと前からのチェックインをマージするブランチに追従しないようにすることで、クエリの実行をより速くします。ORDER BYは、再帰的選択では、私たちが望む最新のチェックインにフォーカスするように強制します。再帰的選択でORDER BYを使用しないと、何千もの先祖の完全なセットを計算し、mtimeでソートし、上位20番目のチェックインを取ることを余儀なくされるでしょう。これにより、LIMIT句を使用して、クエリの範囲を関心のあるチェックインだけに制限することができます。</target>
        </trans-unit>
        <trans-unit id="05aec33569483f3dc1a8463df38060dbf53e2c35" translate="yes" xml:space="preserve">
          <source>The &quot;PRAGMA cache_spill=</source>
          <target state="translated">PRAGMA cache_spill=」となっています。</target>
        </trans-unit>
        <trans-unit id="1a0a062742c0bea5342163f23635fff0e75751fe" translate="yes" xml:space="preserve">
          <source>The &quot;PRAGMA data_version&quot; command provides an indication that the database file has been modified. Interactive programs that hold database content in memory or that display database content on-screen can use the PRAGMA data_version command to determine if they need to flush and reload their memory or update the screen display.</source>
          <target state="translated">PRAGMA data_version」コマンドは、データベースファイルが変更されたことを示します。データベースコンテンツをメモリに保持しているインタラクティブプログラムや、データベースコンテンツを画面上に表示するインタラクティブプログラムでは、PRAGMA data_versionコマンドを使用して、メモリをフラッシュしてリロードする必要があるか、画面表示を更新する必要があるかを判断することができます。</target>
        </trans-unit>
        <trans-unit id="51c212d19062433a8ddb99b497e81dcefb5db939" translate="yes" xml:space="preserve">
          <source>The &quot;PRAGMA data_version&quot; value is a local property of each database connection and so values returned by two concurrent invocations of &quot;PRAGMA data_version&quot; on separate database connections are often different even though the underlying database is identical. It is only meaningful to compare the &quot;PRAGMA data_version&quot; values returned by the same database connection at two different points in time.</source>
          <target state="translated">PRAGMA data_version &quot;の値は、各データベース接続のローカルプロパティであるため、別々のデータベース接続で &quot;PRAGMA data_version &quot;を2つ同時に呼び出した場合に返される値は、基礎となるデータベースが同じであっても異なることがよくあります。2つの異なる時点で同じデータベース接続から返された &quot;PRAGMA data_version &quot;の値を比較することは意味があります。</target>
        </trans-unit>
        <trans-unit id="03965d42503dca17ab62ff9cad1d8a5c3c8ffdbb" translate="yes" xml:space="preserve">
          <source>The &quot;Page Count&quot; - The number of pages in the next segment of the journal, or -1 to mean all content to the end of the file</source>
          <target state="translated">ページ数」-ジャーナルの次のセグメントのページ数、または-1はファイルの最後までのすべてのコンテンツを意味します。</target>
        </trans-unit>
        <trans-unit id="48c6586de090c3bc2e13cc3b6a2a69ed36fa59fa" translate="yes" xml:space="preserve">
          <source>The &quot;USING TEMP B-TREE&quot; clause in the above output indicates that a temporary b-tree structure is used to implement the UNION of the results of the two sub-selects. An alternative method of computing a compound is to run each subquery as a co-routine, arrange for their outputs to appear in sorted order, and merge the results together. When the query planner chooses this latter approach, the EXPLAIN QUERY PLAN output looks like this:</source>
          <target state="translated">上記の出力の &quot;USING TEMP B-TREE &quot;句は、2つの副選択の結果のUNIONを実装するために一時的なB-TREE構造が使用されていることを示しています。複合体を計算する別の方法は、各副問い合わせをコ・ルーティンとして実行し、それらの出力がソートされた順序で表示されるように配置し、結果を一緒にマージすることです。クエリプランナがこの後者のアプローチを選択すると、EXPLAIN QUERY PLANの出力は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="a9bff9645401cb328b5613b5233bf3e5ba1e2eb1" translate="yes" xml:space="preserve">
          <source>The &quot;alternate-form-2&quot; flag (&quot;!&quot;) on the &lt;a href=&quot;printf&quot;&gt;built-in printf&lt;/a&gt; implementation now causes string substitutions to measure the width and precision in characters instead of bytes.</source>
          <target state="translated">&lt;a href=&quot;printf&quot;&gt;組み込みのprintf&lt;/a&gt;実装の「alternate-form-2」フラグ（「！」）により、文字列の置換により、バイトではなく文字の幅と精度が測定されるようになりました。</target>
        </trans-unit>
        <trans-unit id="e4319cae606348ce23e782f966b47ff645421643" translate="yes" xml:space="preserve">
          <source>The &quot;atom&quot; column is the SQL value corresponding to primitive elements - elements other than JSON arrays and objects. The &quot;atom&quot; column is NULL for a JSON array or object. The &quot;value&quot; column is the same as the &quot;atom&quot; column for primitive JSON elements but takes on the text JSON value for arrays and objects.</source>
          <target state="translated">atom」列は、プリミティブ要素、つまりJSON配列やオブジェクト以外の要素に対応するSQL値です。atom &quot;カラムは、JSON配列やオブジェクトの場合はNULLです。value&quot; カラムは、プリミティブな JSON 要素に対応する &quot;atom&quot; カラムと同じですが、配列やオブジェクトに対応するテキスト JSON 値を受け取ります。</target>
        </trans-unit>
        <trans-unit id="cb8a5773e6c48280d7fe42741f8b4a093d392533" translate="yes" xml:space="preserve">
          <source>The &quot;authorizer&quot; method</source>
          <target state="translated">認証者」メソッド</target>
        </trans-unit>
        <trans-unit id="d2039edadf3792f44d9f55f1e52e41e045647126" translate="yes" xml:space="preserve">
          <source>The &quot;authorizer&quot; method provides access to the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer&lt;/a&gt; C/C++ interface. The argument to authorizer is the name of a procedure that is called when SQL statements are being compiled in order to authorize certain operations. The callback procedure takes 5 arguments which describe the operation being coded. If the callback returns the text string &quot;SQLITE_OK&quot;, then the operation is allowed. If it returns &quot;SQLITE_IGNORE&quot;, then the operation is silently disabled. If the return is &quot;SQLITE_DENY&quot; then the compilation fails with an error.</source>
          <target state="translated">「authorizer」メソッドは、&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer&lt;/a&gt; C / C ++インターフェースへのアクセスを提供します。オーソライザーへの引数は、特定の操作を許可するためにSQLステートメントがコンパイルされるときに呼び出されるプロシージャーの名前です。コールバックプロシージャは、コード化される操作を説明する5つの引数を取ります。コールバックがテキスト文字列「SQLITE_OK」を返す場合、操作は許可されます。「SQLITE_IGNORE」が返された場合、操作は通知なしで無効になります。戻り値が「SQLITE_DENY」の場合、コンパイルはエラーで失敗します。</target>
        </trans-unit>
        <trans-unit id="d780e49acdf2e828a0e7b0580dfd96aff50cee2e" translate="yes" xml:space="preserve">
          <source>The &quot;automerge=N&quot; command (where N is an integer between 0 and 15, inclusive) is used to configure an FTS3/4 tables &quot;automerge&quot; parameter, which controls automatic incremental inverted index merging. The default automerge value for new tables is 0, meaning that automatic incremental merging is completely disabled. If the value of the automerge parameter is modified using the &quot;automerge=N&quot; command, the new parameter value is stored persistently in the database and is used by all subsequently established database connections.</source>
          <target state="translated">automerge=N &quot;コマンド(ここで、Nは0から15までの整数である)は、FTS3/4テーブルの &quot;automerge &quot;パラメータを設定するために使用され、自動インクリメンタル転置インデックスマージを制御する。新しいテーブルのデフォルトの自動マージ値は0であり、自動インクリメンタルマージは完全に無効であることを意味する。automergeパラメータの値が &quot;automerge=N &quot;コマンドを使用して変更された場合、新しいパラメータ値はデータベースに永続的に保存され、その後に確立されたすべてのデータベース接続で使用される。</target>
        </trans-unit>
        <trans-unit id="35cc018cff76ce7093039d6d69782515b8dd9cbd" translate="yes" xml:space="preserve">
          <source>The &quot;backup&quot; method</source>
          <target state="translated">バックアップ」の方法</target>
        </trans-unit>
        <trans-unit id="c005edd2de62803b18a4eb1743378927a517fad5" translate="yes" xml:space="preserve">
          <source>The &quot;backup&quot; method makes a backup copy of a live database. The command syntax is like this:</source>
          <target state="translated">backup」メソッドは、ライブデータベースのバックアップコピーを作成します。コマンドの構文は次のようになります。</target>
        </trans-unit>
        <trans-unit id="7652bc7646799c25c956b30319f71b75ca9a3e80" translate="yes" xml:space="preserve">
          <source>The &quot;bind_fallback&quot; method</source>
          <target state="translated">bind_fallback &quot;メソッド</target>
        </trans-unit>
        <trans-unit id="e31d9979cf6770ea07cdb2b87a23b0343179e30e" translate="yes" xml:space="preserve">
          <source>The &quot;bind_fallback&quot; method gives the application control over how to handle parameter binding when no TCL variable matches the parameter name.</source>
          <target state="translated">bind_fallback」メソッドは、TCL変数がパラメータ名にマッチしない場合に、パラメータのバインディングをどのように処理するかをアプリケーションに制御させます。</target>
        </trans-unit>
        <trans-unit id="d6fd78a195f0dd5acebc1e5d408aa889656042c4" translate="yes" xml:space="preserve">
          <source>The &quot;bind_fallback&quot; method has a single optional argument. If the argument is an empty string, then the bind_fallback is cancelled and the default behavior is restored. If the argument is a non-empty string, then the argument is a TCL command (usually the name of a proc) to invoke whenever an SQL parameter is seen that does not match any TCL variable. If the &quot;bind_fallback&quot; method is given no arguments, then the current bind_fallback command is returned.</source>
          <target state="translated">bind_fallback &quot;メソッドには、オプションの引数を1つ持ちます。引数が空の文字列の場合、bind_fallbackはキャンセルされ、デフォルトの動作が復元されます。引数が空でない文字列の場合、引数は、SQLパラメータが見られるときに、どのTCL変数にもマッチしない SQLパラメータが見られるたびに起動するTCLコマンド(通常は procの名前)である。bind_fallback」メソッドに引数が与えられない場合、現在の bind_fallback コマンドが返されます。</target>
        </trans-unit>
        <trans-unit id="50a08084b4de7b3f67549ffe53d83ec728fa3cca" translate="yes" xml:space="preserve">
          <source>The &quot;busy&quot; method</source>
          <target state="translated">忙しい」方法</target>
        </trans-unit>
        <trans-unit id="94cabb870539d2659c509ca5d30b8de78ce6a143" translate="yes" xml:space="preserve">
          <source>The &quot;busy&quot; method, like &quot;timeout&quot;, only comes into play when the database is locked. But the &quot;busy&quot; method gives the programmer much more control over what action to take. The &quot;busy&quot; method specifies a callback Tcl procedure that is invoked whenever SQLite tries to open a locked database. A single integer argument is appended to the callback before it is invoke. The argument is the number of prior calls to the busy callback for the current locking event. It is intended that the callback will do some other useful work for a short while (such as service GUI events) then return so that the lock can be tried again. The callback procedure should return &quot;0&quot; if it wants SQLite to try again to open the database and should return &quot;1&quot; if it wants SQLite to abandon the current operation.</source>
          <target state="translated">busy &quot;メソッドは、&quot;timeout &quot;のように、データベースがロックされている場合にのみ使用されます。しかし、&quot;busy &quot;メソッドを使用することで、プログラマはどのようなアクションを取るべきか、より多くのコントロールが可能になります。busy &quot;メソッドは、SQLiteがロックされたデータベースを開こうとしたときに呼び出されるコールバックTclプロシージャを指定します。コールバックが呼び出される前に、1つの整数の引数が追加されます。引数には、現在のロックイベントに対するビジーコールバックの呼び出し回数を指定します。これは、コールバックがしばらくの間、他の有用な作業(サービスGUIイベントなど)を行った後、ロックを再試行できるようにコールバックを返すことを意図しています。コールバックプロシージャは、SQLiteがデータベースを開くために再試行したい場合は &quot;0 &quot;を返し、SQLiteが現在の操作を放棄したい場合は &quot;1 &quot;を返さなければなりません。</target>
        </trans-unit>
        <trans-unit id="806dbf019d18a933c45ea06755b6a277743f61ae" translate="yes" xml:space="preserve">
          <source>The &quot;cache&quot; method</source>
          <target state="translated">キャッシュ」メソッド</target>
        </trans-unit>
        <trans-unit id="6c5d5ba4e30c1f02fb732b5f9e013dee90e5777d" translate="yes" xml:space="preserve">
          <source>The &quot;changes&quot; method</source>
          <target state="translated">変更」の方法</target>
        </trans-unit>
        <trans-unit id="94441f79eee4930e4324a3b4a4acbce248260c58" translate="yes" xml:space="preserve">
          <source>The &quot;changes&quot; method returns an integer which is the number of rows in the database that were inserted, deleted, and/or modified by the most recent &quot;eval&quot; method.</source>
          <target state="translated">changes &quot;メソッドは、データベース内で直近の &quot;eval &quot;メソッドによって挿入、削除、変更された行の数を整数で返します。</target>
        </trans-unit>
        <trans-unit id="a3fc353d826f676e72487db0fd8f37052f9b16c1" translate="yes" xml:space="preserve">
          <source>The &quot;close&quot; method</source>
          <target state="translated">閉じる」という方法</target>
        </trans-unit>
        <trans-unit id="b78db738260018e26bc56c431d7e164adb66bba3" translate="yes" xml:space="preserve">
          <source>The &quot;collate&quot; method</source>
          <target state="translated">照合」の方法</target>
        </trans-unit>
        <trans-unit id="3be1a86e589629a9a881a6da512b2ad6b5f62c78" translate="yes" xml:space="preserve">
          <source>The &quot;collation_needed&quot; method</source>
          <target state="translated">collation_needed」メソッドは</target>
        </trans-unit>
        <trans-unit id="6c32eeacd0b85ddcdef7035930e1a8c64bfad10b" translate="yes" xml:space="preserve">
          <source>The &quot;column&quot; mode is a tabular output format. Other tabular output formats as &quot;box&quot;, &quot;markdown&quot;, and &quot;table&quot;:</source>
          <target state="translated">column &quot;モードは表形式の出力形式です。他にも、&quot;BOX&quot;、&quot;MARKDOWN&quot;、&quot;TABLE &quot;などの表形式の出力形式があります。</target>
        </trans-unit>
        <trans-unit id="1035634e0e0ea333e6f8d753c7fa7091a7d755db" translate="yes" xml:space="preserve">
          <source>The &quot;column&quot; output mode automatically expands columns to contain the longest output row and automatically turns &quot;.header&quot; on if it has not been previously set.</source>
          <target state="translated">column」出力モードは、最長の出力行を含む列を自動的に展開し、事前に設定されていない場合は自動的に「.header」をオンにします。</target>
        </trans-unit>
        <trans-unit id="30f6089837a9332235ef1f677d9e2936edf51cae" translate="yes" xml:space="preserve">
          <source>The &quot;columns&quot; of a &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; or FROM-clause subquery are really the expressions in the result set of the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement that implements the VIEW or subquery. Thus, the affinity for columns of a VIEW or subquery are determined by the expression affinity rules above. Consider an example:</source>
          <target state="translated">&lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt;またはFROM句のサブクエリの「列」は、実際には、VIEWまたはサブクエリを実装する&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントの結果セット内の式です。したがって、VIEWまたはサブクエリの列の類似性は、上記の式類似性ルールによって決定されます。例を考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="6efc033d7171b4cae5dcc026d731d1abc23f16f8" translate="yes" xml:space="preserve">
          <source>The &quot;commit_hook&quot; method</source>
          <target state="translated">commit_hook &quot;メソッド</target>
        </trans-unit>
        <trans-unit id="075f9fcec0c51906d7830312bd2ffff7ac323743" translate="yes" xml:space="preserve">
          <source>The &quot;complete&quot; method</source>
          <target state="translated">完全な」方法</target>
        </trans-unit>
        <trans-unit id="36202288005d888ee9c02c9332ba422aac36a5b3" translate="yes" xml:space="preserve">
          <source>The &quot;complete&quot; method is useful when building interactive applications in order to know when the user has finished entering a line of SQL code. This is really just an interface to the &lt;a href=&quot;c3ref/complete&quot;&gt;&lt;b&gt;sqlite3_complete()&lt;/b&gt;&lt;/a&gt; C function.</source>
          <target state="translated">「complete」メソッドは、ユーザーがSQLコードの行の入力をいつ終了したかを知るためにインタラクティブなアプリケーションを構築するときに役立ちます。これは実際には&lt;a href=&quot;c3ref/complete&quot;&gt;&lt;b&gt;sqlite3_complete（）&lt;/b&gt;&lt;/a&gt; C関数への単なるインターフェースです。</target>
        </trans-unit>
        <trans-unit id="cb6d6b519cc240799d0eae2497f1b956b7749126" translate="yes" xml:space="preserve">
          <source>The &quot;complete&quot; method takes a string of supposed SQL as its only argument. It returns TRUE if the string is a complete statement of SQL and FALSE if there is more to be entered.</source>
          <target state="translated">complete &quot;メソッドは、SQLを想定した文字列を唯一の引数として受け取ります。その文字列が完全なSQL文であればTRUEを返し、さらに入力すべきSQL文があればFALSEを返します。</target>
        </trans-unit>
        <trans-unit id="46bbc7a4eaf4d4f9fe40b357ef388a365c9285df" translate="yes" xml:space="preserve">
          <source>The &quot;config&quot; method</source>
          <target state="translated">config&quot; メソッド</target>
        </trans-unit>
        <trans-unit id="d8bb4ff8aef62d6cb6272264cef7cda239984bc9" translate="yes" xml:space="preserve">
          <source>The &quot;config&quot; method queries or changes certain configuration settings for the database connection using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface. Run this method with no arguments to get a TCL list of available configuration settings and their current values:</source>
          <target state="translated">「config」メソッドは、&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;インターフェースを使用して、データベース接続の特定の構成設定を照会または変更します。引数なしでこのメソッドを実行し、利用可能な構成設定とその現在の値のTCLリストを取得します。</target>
        </trans-unit>
        <trans-unit id="b266e6a044670a6e3a5e4102b0820031cb7ab393" translate="yes" xml:space="preserve">
          <source>The &quot;configure&quot; scripts should now automatically configure Unix systems for large file support. Improved error messages for when large files are encountered and large file support is disabled.</source>
          <target state="translated">configure&quot; スクリプトは、ラージファイルをサポートするために Unix システムを自動的に設定するようになりました。ラージファイルに遭遇し、ラージファイルのサポートが無効になった場合のエラーメッセージを改善しました。</target>
        </trans-unit>
        <trans-unit id="577865d2c9835070772d4e94f47615cadfb2baec" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the T parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="translated">Tパラメーターが指す「const char *」変数は、X番目のループの&lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;記述を含むゼロで終了するUTF-8文字列に設定されます。</target>
        </trans-unit>
        <trans-unit id="2be51d012e0d49a380524a8121847e82af3226bf" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the T parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="translated">Tパラメーターが指す「const char *」変数は、X番目のループの&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;記述を含むゼロで終了するUTF-8文字列に設定されます。</target>
        </trans-unit>
        <trans-unit id="bac7414b87b280f152adca2a25c602ba20600788" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the T parameter will be set to a zero-terminated UTF-8 string containing the name of the index or table used for the X-th loop.</source>
          <target state="translated">Tパラメータが指す変数 &quot;const char *&quot;には、X番目のループで使用されるインデックスまたはテーブルの名前を含む終端ゼロのUTF-8文字列が設定されます。</target>
        </trans-unit>
        <trans-unit id="220e93adf7fc69205c340c5757886c63862916b5" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the V parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="translated">Vパラメーターが指す &quot;const char *&quot;変数は、X番目のループの&lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERYPLAN&lt;/a&gt;記述を含むゼロで終了するUTF-8文字列に設定されます。</target>
        </trans-unit>
        <trans-unit id="fcb2cfe6186a4a9c1039f7ec3e694a12e936a2d7" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the V parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="translated">Vパラメーターが指す &quot;const char *&quot;変数は、X番目のループの&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERYPLAN&lt;/a&gt;記述を含むゼロで終了するUTF-8文字列に設定されます。</target>
        </trans-unit>
        <trans-unit id="6993ddaa2434f289adeb086aed7ae04476a60ad7" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the V parameter will be set to a zero-terminated UTF-8 string containing the name of the index or table used for the X-th loop.</source>
          <target state="translated">Vパラメータが指す変数 &quot;const char *&quot;には、X番目のループで使用されるインデックスまたはテーブルの名前を含む終端ゼロのUTF-8文字列が設定されます。</target>
        </trans-unit>
        <trans-unit id="8aae3497dac443e109983b1c00a5960530139406" translate="yes" xml:space="preserve">
          <source>The &quot;content&quot; option, used to make the FTS5 table an &lt;a href=&quot;fts5#external_content_and_contentless_tables&quot;&gt;external content or contentless table&lt;/a&gt;.</source>
          <target state="translated">「コンテンツ」オプション。FTS5テーブルを&lt;a href=&quot;fts5#external_content_and_contentless_tables&quot;&gt;外部コンテンツまたはコンテンツ&lt;/a&gt;レステーブルにするために使用されます。</target>
        </trans-unit>
        <trans-unit id="e6c79f409b23d48e87e77e61ee87998224597bc3" translate="yes" xml:space="preserve">
          <source>The &quot;content_rowid&quot; option, used to set the rowid field of an &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content table&lt;/a&gt;.</source>
          <target state="translated">「content_rowid」オプション。&lt;a href=&quot;fts5#external_content_tables&quot;&gt;外部コンテンツテーブルの行&lt;/a&gt; IDフィールドを設定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="39cd9c81e20b57d6b78e1af2643005b4d6ac3fb3" translate="yes" xml:space="preserve">
          <source>The &quot;copy&quot; method</source>
          <target state="translated">コピー」の方法</target>
        </trans-unit>
        <trans-unit id="983ea0fee26b9222536bfed9a0514ad997e9a0a2" translate="yes" xml:space="preserve">
          <source>The &quot;copy&quot; method copies data from a file into a table. It returns the number of rows processed successfully from the file. The syntax of the copy method looks like this:</source>
          <target state="translated">copy &quot;メソッドは、ファイルからテーブルにデータをコピーします。ファイルから正常に処理された行数を返します。コピーメソッドの構文は次のようになります。</target>
        </trans-unit>
        <trans-unit id="dc3e7bd12c41305b3fc796bf145f478af20ae557" translate="yes" xml:space="preserve">
          <source>The &quot;cost&quot; here is logarithmic. With nested loops, the work is multiplied, not added. But it is customary to think of graphs with additive weights and so the graph shows the logarithm of the various costs. The graph shows a cost advantage of S being inside of L of about 6.87, but this translates into the query running about 963 times faster when S loop is inside of the L loop rather than being outside of it.</source>
          <target state="translated">ここでの「コスト」は対数です。入れ子になったループでは、作業は加算ではなく乗算になります。しかし、グラフは加重で考えるのが一般的なので、グラフは様々なコストの対数を示しています。グラフは、SがLの内側にある方が約6.87のコスト優位性を示していますが、これは、SループがLループの外側にあるよりも、SループがLループの内側にある方が、クエリの実行が約963倍速くなることを意味しています。</target>
        </trans-unit>
        <trans-unit id="350bdd92630f61bca90b3168c90039a63f7ced5e" translate="yes" xml:space="preserve">
          <source>The &quot;csv&quot; mode option in the shell puts strings inside double-quotes.</source>
          <target state="translated">シェルの &quot;csv&quot; モードオプションは文字列をダブルクォートで囲みます。</target>
        </trans-unit>
        <trans-unit id="1f521a5c994d919d955260e93be15342970bdf26" translate="yes" xml:space="preserve">
          <source>The &quot;db&quot; parameter is a pointer to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. The &quot;main&quot; argument is the name of the schema in which the imposter table is to be created. The &quot;1&quot; argument enables the imposter table mechanism. &quot;tnum&quot; is the root page of the index that the imposter table should mirror.</source>
          <target state="translated">「db」パラメータは、&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;へのポインタです。「メイン」の引数は、偽のテーブルが作成されるスキーマの名前です。&quot;1&quot;引数は、偽のテーブルメカニズムを有効にします。「tnum」は、詐称者テーブルがミラーリングする必要があるインデックスのルートページです。</target>
        </trans-unit>
        <trans-unit id="1d7867d45fc6532563a6e0e1052f994086d7d4d3" translate="yes" xml:space="preserve">
          <source>The &quot;deserialize&quot; method</source>
          <target state="translated">デシリアライズ」メソッド</target>
        </trans-unit>
        <trans-unit id="6f372f07e9e348fc01623f3016d82e06dd84212c" translate="yes" xml:space="preserve">
          <source>The &quot;deserialize&quot; method takes a TCL byte-array that contains an SQLite database file and adds it to the database connection. The syntax is:</source>
          <target state="translated">deserialize」メソッドは、SQLiteデータベースファイルを含むTCLバイト配列を取り、それをデータベース接続に追加します。構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="37b478850c0ef98b47e5a07304d319496a735ccd" translate="yes" xml:space="preserve">
          <source>The &quot;docid&quot; alias does not exist. Applications must use &quot;rowid&quot; instead.</source>
          <target state="translated">docid」エイリアスは存在しません。アプリケーションは代わりに &quot;rowid&quot; を使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="13cca21a87502057869d942479f833e57c886177" translate="yes" xml:space="preserve">
          <source>The &quot;double&quot; variable pointed to by the T parameter will be set to the query planner's estimate for the average number of rows output from each iteration of the X-th loop. If the query planner's estimates was accurate, then this value will approximate the quotient NVISIT/NLOOP and the product of this value for all prior loops with the same SELECTID will be the NLOOP value for the current loop.</source>
          <target state="translated">Tパラメータで指定された &quot;double &quot;変数には、X番目のループの各反復から出力される平均行数に対する問い合わせプランナの推定値が設定されます。クエリプランナの推定値が正確であれば、この値は商NVISIT/NLOOPに近似し、同じSELECTIDを持つ全ての先行ループのこの値の積が、現在のループのNLOOP値となります。</target>
        </trans-unit>
        <trans-unit id="ac86dc9fb240d8b577961e6fb339b312a7e8b6d2" translate="yes" xml:space="preserve">
          <source>The &quot;double&quot; variable pointed to by the V parameter will be set to the query planner's estimate for the average number of rows output from each iteration of the X-th loop. If the query planner's estimates was accurate, then this value will approximate the quotient NVISIT/NLOOP and the product of this value for all prior loops with the same SELECTID will be the NLOOP value for the current loop.</source>
          <target state="translated">Vパラメータで指定された &quot;double &quot;変数には、X番目のループの各反復から出力される平均行数に対する問い合わせプランナの推定値が設定される。クエリプランナの推定値が正確であれば、この値は商NVISIT/NLOOPに近似し、同じSELECTIDを持つ全ての先行ループのこの値の積が、現在のループのNLOOP値となります。</target>
        </trans-unit>
        <trans-unit id="91b47ab7441632c19a646d6f3d2e70bb71a8af6b" translate="yes" xml:space="preserve">
          <source>The &quot;ellipses&quot; text.</source>
          <target state="translated">楕円形」のテキスト。</target>
        </trans-unit>
        <trans-unit id="785dfb0eb14780fdc8609d7c7187bbcbf0dfe81b" translate="yes" xml:space="preserve">
          <source>The &quot;enable_load_extension&quot; method</source>
          <target state="translated">enable_load_extension &quot;メソッドは</target>
        </trans-unit>
        <trans-unit id="24181470839fe75a380a1959898a8b67107aab1a" translate="yes" xml:space="preserve">
          <source>The &quot;end match&quot; text.</source>
          <target state="translated">エンドマッチ」のテキストです。</target>
        </trans-unit>
        <trans-unit id="a4952b422a3c809d77afa1776609a2750c092857" translate="yes" xml:space="preserve">
          <source>The &quot;errorcode&quot; method</source>
          <target state="translated">エラーコード」メソッド</target>
        </trans-unit>
        <trans-unit id="79f7c0ddb2f3a3e97f9983c467d9c601808c789a" translate="yes" xml:space="preserve">
          <source>The &quot;eval&quot; method</source>
          <target state="translated">eval &quot;メソッド</target>
        </trans-unit>
        <trans-unit id="da370283ad69c2823d6201a69b7d1765374cb685" translate="yes" xml:space="preserve">
          <source>The &quot;eval&quot; method described &lt;a href=&quot;#eval&quot;&gt;above&lt;/a&gt; keeps a cache of &lt;a href=&quot;c3ref/prepare&quot;&gt;prepared statements&lt;/a&gt; for recently evaluated SQL commands. The &quot;cache&quot; method is used to control this cache. The first form of this command is:</source>
          <target state="translated">「エバール」の方法を説明&lt;a href=&quot;#eval&quot;&gt;上記&lt;/a&gt;のキャッシュ保持&lt;a href=&quot;c3ref/prepare&quot;&gt;プリペアドステートメント&lt;/a&gt;最近評価SQLコマンドのを。「キャッシュ」メソッドは、このキャッシュを制御するために使用されます。このコマンドの最初の形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="221bab33d21ea69f4dd52f3f0492767cb572de7f" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; method</source>
          <target state="translated">存在する」メソッド</target>
        </trans-unit>
        <trans-unit id="efdfc3e12d096d22035e667cf9f9a8fa50dec02d" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; method is often used to test for the existence of rows in a table. For example:</source>
          <target state="translated">exists &quot;メソッドは、テーブル内に行が存在するかどうかをテストするためによく使用されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="64883f01f5bafd4c69a4447377f37fc6c44868cb" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; method is similar to &quot;onecolumn&quot; and &quot;eval&quot; in that it executes SQL statements. The difference is that the &quot;exists&quot; method always returns a boolean value which is TRUE if a query in the SQL statement it executes returns one or more rows and FALSE if the SQL returns an empty set.</source>
          <target state="translated">exists &quot;メソッドは、SQL文を実行するという点では &quot;onecolumn &quot;や &quot;eval &quot;と似ています。違いは、&quot;exists &quot;メソッドは常にブーリアン値を返す点です。</target>
        </trans-unit>
        <trans-unit id="2fa39980ca4c6c390fc0963b907ef032a2115a04" translate="yes" xml:space="preserve">
          <source>The &quot;family&quot; table is similar to the earlier &quot;org&quot; table except that now there are two parents to each member. We want to know all living ancestors of Alice, from oldest to youngest. An ordinary common table expression, &quot;parent_of&quot;, is defined first. That ordinary CTE is a view that can be used to find all parents of any individual. That ordinary CTE is then used in the &quot;ancestor_of_alice&quot; recursive CTE. The recursive CTE is then used in the final query:</source>
          <target state="translated">ファミリー &quot;テーブルは、各メンバーの両親が二人いることを除いて、以前の &quot;org &quot;テーブルと似ています。私たちは、アリスの生きているすべての祖先を、最年長から最年少まで知りたいと考えています。まず、通常の一般的なテーブル表現である &quot;parent_of &quot;が定義されています。この通常のCTEは、任意の個人のすべての親を見つけるために使用することができるビューです。この通常の CTE は、&quot;ancestor_of_alice&quot; 再帰的 CTE で使用される。そして、その再帰的CTEは、最終的なクエリで使用される。</target>
        </trans-unit>
        <trans-unit id="e0decf38085a4ffc55fce2f25b175fd346628c61" translate="yes" xml:space="preserve">
          <source>The &quot;fast&quot; setting for secure_delete (added circa 2017-08-01) is an intermediate setting in between &quot;on&quot; and &quot;off&quot;. When secure_delete is set to &quot;fast&quot;, SQLite will overwrite deleted content with zeros only if doing so does not increase the amount of I/O. In other words, the &quot;fast&quot; setting uses more CPU cycles but does not use more I/O. This has the effect of purging all old content from &lt;a href=&quot;fileformat2#btree&quot;&gt;b-tree pages&lt;/a&gt;, but leaving forensic traces on &lt;a href=&quot;fileformat2#freelist&quot;&gt;freelist pages&lt;/a&gt;.</source>
          <target state="translated">secure_deleteの「高速」設定（2017年8月1日頃追加）は、「オン」と「オフ」の中間の設定です。secure_deleteが &quot;fast&quot;に設定されている場合、SQLiteはI / Oの量を増加させない場合にのみ、削除されたコンテンツをゼロで上書きします。言い換えると、「高速」設定はより多くのCPUサイクルを使用しますが、より多くのI / Oを使用しません。これは、&lt;a href=&quot;fileformat2#btree&quot;&gt;bツリーページ&lt;/a&gt;からすべての古いコンテンツをパージする効果がありますが、&lt;a href=&quot;fileformat2#freelist&quot;&gt;フリーリストページには&lt;/a&gt;フォレンジックトレースを残します。</target>
        </trans-unit>
        <trans-unit id="a5e5534bc0599c1bf3dbead2d2f44bed70807ce6" translate="yes" xml:space="preserve">
          <source>The &quot;fsync()&quot; that occurs after the header is written in a WAL reset now uses the sync settings for checkpoints. This means it will use a &quot;fullfsync&quot; on macs if &lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;PRAGMA checkpoint_fullfsync&lt;/a&gt; set on.</source>
          <target state="translated">WALリセットでヘッダーが書き込まれた後に発生する「fsync（）」は、チェックポイントの同期設定を使用するようになりました。これは、&lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;PRAGMA checkpoint_fullfsync&lt;/a&gt;がオンに設定されている場合、Macで「fullfsync」を使用することを意味します。</target>
        </trans-unit>
        <trans-unit id="80417a09b17dfee14228d5c4ecb3ba63e1360a53" translate="yes" xml:space="preserve">
          <source>The &quot;fts3tokenize&quot; virtual table can be used to directly access any tokenizer. The following SQL demonstrates how to create an instance of the fts3tokenize virtual table:</source>
          <target state="translated">fts3tokenize」仮想テーブルを使用して、任意のトークナイザーに直接アクセスすることができます。以下のSQLは、「fts3tokenize」仮想テーブルのインスタンスを作成する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="6cdf37fe2751376d1b848056d4ec78cc31cd8173" translate="yes" xml:space="preserve">
          <source>The &quot;fullkey&quot; column is a text path that uniquely identifies the current row element within the original JSON string. The complete key to the true top-level element is returned even if an alternative starting point is provided by the &quot;root&quot; argument.</source>
          <target state="translated">fullkey」列は、元のJSON文字列内の現在の行要素を一意に識別するテキストパスである。たとえ &quot;root &quot;引数で代替の開始点が提供された場合でも、真のトップレベル要素への完全なキーが返されます。</target>
        </trans-unit>
        <trans-unit id="81485590afed062476035ea78c2df833a07ce15c" translate="yes" xml:space="preserve">
          <source>The &quot;function&quot; method</source>
          <target state="translated">関数」メソッド</target>
        </trans-unit>
        <trans-unit id="982021b0dd51770755c9c9e39c1c765e77fbdd84" translate="yes" xml:space="preserve">
          <source>The &quot;function&quot; method accepts the following options:</source>
          <target state="translated">function &quot;メソッドは、以下のオプションを受け付けます。</target>
        </trans-unit>
        <trans-unit id="e581fe2aa68e5275a553b3adbf390b762a9e4053" translate="yes" xml:space="preserve">
          <source>The &quot;function&quot; method registers new SQL functions with the SQLite engine. The arguments are the name of the new SQL function and a TCL command that implements that function. Arguments to the function are appended to the TCL command before it is invoked.</source>
          <target state="translated">function &quot;メソッドは、SQLiteエンジンに新しいSQL関数を登録します。引数は、新しい SQL 関数の名前と、その関数を実装した TCL コマンドです。関数の引数は、呼び出される前に TCL コマンドに追加されます。</target>
        </trans-unit>
        <trans-unit id="ff9f7422b3d2ef0edf475eeb60798d293ddec7bd" translate="yes" xml:space="preserve">
          <source>The &quot;fuzzershell.c&quot; program is used to run some &lt;a href=&quot;#fuzztesting&quot;&gt;fuzz tests&lt;/a&gt;.</source>
          <target state="translated">「fuzzershell.c」プログラムは、いくつかの&lt;a href=&quot;#fuzztesting&quot;&gt;ファズテスト&lt;/a&gt;を実行するために使用されます。</target>
        </trans-unit>
        <trans-unit id="7c4947473658b4ae028d7e71df03314bb5d6e009" translate="yes" xml:space="preserve">
          <source>The &quot;iScanStatusOp&quot; parameter determines which status information to return. The &quot;iScanStatusOp&quot; must be one of the &lt;a href=&quot;#SQLITE_SCANSTAT_EST&quot;&gt;scanstatus options&lt;/a&gt; or the behavior of this interface is undefined. The requested measurement is written into a variable pointed to by the &quot;pOut&quot; parameter. Parameter &quot;idx&quot; identifies the specific loop to retrieve statistics for. Loops are numbered starting from zero. If idx is out of range - less than zero or greater than or equal to the total number of loops used to implement the statement - a non-zero value is returned and the variable that pOut points to is unchanged.</source>
          <target state="translated">「iScanStatusOp」パラメータは、返すステータス情報を決定します。「iScanStatusOp」は&lt;a href=&quot;#SQLITE_SCANSTAT_EST&quot;&gt;scanstatusオプションの&lt;/a&gt; 1つである必要があります。そうでない場合、このインターフェイスの動作は未定義です。要求された測定値は、「pOut」パラメーターが指す変数に書き込まれます。パラメータ「idx」は、統計を取得する特定のループを識別します。ループにはゼロから番号が付けられます。idxが範囲外の場合-0未満、またはステートメントの実装に使用されるループの総数以上-ゼロ以外の値が返され、pOutが指す変数は変更されません。</target>
        </trans-unit>
        <trans-unit id="82b3487c37966e4df98f8fc69e59c76eae09190d" translate="yes" xml:space="preserve">
          <source>The &quot;iScanStatusOp&quot; parameter determines which status information to return. The &quot;iScanStatusOp&quot; must be one of the &lt;a href=&quot;c_scanstat_est&quot;&gt;scanstatus options&lt;/a&gt; or the behavior of this interface is undefined. The requested measurement is written into a variable pointed to by the &quot;pOut&quot; parameter. Parameter &quot;idx&quot; identifies the specific loop to retrieve statistics for. Loops are numbered starting from zero. If idx is out of range - less than zero or greater than or equal to the total number of loops used to implement the statement - a non-zero value is returned and the variable that pOut points to is unchanged.</source>
          <target state="translated">「iScanStatusOp」パラメータは、返すステータス情報を決定します。「iScanStatusOp」は&lt;a href=&quot;c_scanstat_est&quot;&gt;scanstatusオプションの&lt;/a&gt; 1つである必要があります。そうでない場合、このインターフェイスの動作は未定義です。要求された測定値は、「pOut」パラメーターが指す変数に書き込まれます。パラメータ「idx」は、統計を取得する特定のループを識別します。ループにはゼロから番号が付けられます。idxが範囲外の場合-0未満、またはステートメントの実装に使用されるループの総数以上-ゼロ以外の値が返され、pOutが指す変数は変更されません。</target>
        </trans-unit>
        <trans-unit id="5abd56a3f33aa682cb5beed98f5ecb39cbd50edd" translate="yes" xml:space="preserve">
          <source>The &quot;id&quot; column is an integer that identifies a specific JSON element within the complete JSON string. The &quot;id&quot; integer is an internal housekeeping number, the computation of which might change in future releases. The only guarantee is that the &quot;id&quot; column will be different for every row.</source>
          <target state="translated">id&quot; カラムは、完全な JSON 文字列の中の特定の JSON 要素を識別する整数です。id&quot; 整数は、将来のリリースで計算が変更される可能性があります。唯一の保証は、&quot;id&quot; カラムが行ごとに異なるということです。</target>
        </trans-unit>
        <trans-unit id="ca8669e4db9525865c9346904ab8bb3b3eb055a9" translate="yes" xml:space="preserve">
          <source>The &quot;incrblob&quot; method</source>
          <target state="translated">incrblob」の方法</target>
        </trans-unit>
        <trans-unit id="8d184fd38641411539a264597b11e40c38841938" translate="yes" xml:space="preserve">
          <source>The &quot;index&quot; or staging area</source>
          <target state="translated">インデックス」または演出エリア</target>
        </trans-unit>
        <trans-unit id="c6e7f631fc9ab8b7e2eecdc6301a632079a07cf7" translate="yes" xml:space="preserve">
          <source>The &quot;input&quot; CTE defines the input puzzle. The &quot;digits&quot; CTE defines a table that holds all digits between 1 and 9. The work of solving the puzzle is undertaken by the &quot;x&quot; CTE. An entry in x(s,ind) means that the 81-character string &quot;s&quot; is a valid sudoku puzzle (it has no conflicts) and that the first unknown character is at position &quot;ind&quot;, or ind==0 if all character positions are filled in. The goal, then, is to compute entries for &quot;x&quot; with an &quot;ind&quot; of 0.</source>
          <target state="translated">input&quot; CTE は、入力パズルを定義します。digits&quot; CTEは、1から9までのすべての数字を保持するテーブルを定義する。パズルを解く作業は、&quot;x&quot; CTEによって行われる。x(s,ind)のエントリは、81文字の文字列 &quot;s &quot;が有効な数独パズル(競合がない)であり、最初の未知の文字が位置 &quot;ind &quot;にあることを意味します。そこで、目標は、&quot;x &quot;の &quot;ind &quot;が0であるエントリを計算することである。</target>
        </trans-unit>
        <trans-unit id="b6cb46f4a227f8313e332f23912dfe269a430a8c" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the T parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="translated">Tパラメータが指す「int」変数は、X番目のループの「select-id」に設定されます。select-idは、ループが含まれているクエリまたはサブクエリを識別します。メインクエリのselect-idはゼロです。select-idは、&lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;クエリの最初の列に出力される値と同じです。</target>
        </trans-unit>
        <trans-unit id="fd32578e68672fbb14bf7b3a04807a29e7c2c005" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the T parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="translated">Tパラメータが指す「int」変数は、X番目のループの「select-id」に設定されます。select-idは、ループが含まれているクエリまたはサブクエリを識別します。メインクエリのselect-idはゼロです。select-idは、&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;クエリの最初の列に出力される値と同じです。</target>
        </trans-unit>
        <trans-unit id="b8f1457987df7641bcada911e2bfe80eb91e9f5b" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the V parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="translated">Vパラメータが指す「int」変数は、X番目のループの「select-id」に設定されます。select-idは、ループが含まれるクエリまたはサブクエリを識別します。メインクエリのselect-idはゼロです。select-idは、&lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERYPLAN&lt;/a&gt;クエリの最初の列に出力される値と同じです。</target>
        </trans-unit>
        <trans-unit id="d0b31808af87fb1ca4f0d10efd9a5ba2a54012dd" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the V parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="translated">Vパラメータが指す「int」変数は、X番目のループの「select-id」に設定されます。select-idは、ループが含まれるクエリまたはサブクエリを識別します。メインクエリのselect-idはゼロです。select-idは、&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERYPLAN&lt;/a&gt;クエリの最初の列に出力される値と同じです。</target>
        </trans-unit>
        <trans-unit id="c47984da42c27787f28bd87d963296a6ecc85d38" translate="yes" xml:space="preserve">
          <source>The &quot;integrity-check&quot; command causes SQLite to read and verify the accuracy of all inverted indices in an FTS3/4 table by comparing those inverted indices against the original content. The &quot;integrity-check&quot; command silently succeeds if the inverted indices are all ok, but will fail with an SQLITE_CORRUPT error if any problems are found.</source>
          <target state="translated">integrity-check &quot;コマンドは、SQLiteにFTS3/4テーブル内のすべての転置インデックスを読み込ませ、それらの転置インデックスを元の内容と比較することで、その正確さを検証させる。整合性チェック &quot;コマンドは、転置インデックスがすべて正常であれば黙って成功しますが、何か問題が見つかった場合は、SQLITE_CORRUPTエラーで失敗します。</target>
        </trans-unit>
        <trans-unit id="d1ee1009fc8d7ceb03381f3a07a84d688fe06706" translate="yes" xml:space="preserve">
          <source>The &quot;integrity-check&quot; command is similar in concept to &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;. In a working system, the &quot;integrity-command&quot; should always be successful. Possible causes of integrity-check failures include:</source>
          <target state="translated">「integrity-check」コマンドは、概念的には&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integer_check&lt;/a&gt;と似ています。稼働中のシステムでは、「整合性コマンド」は常に成功するはずです。整合性チェックの失敗の考えられる原因は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="9351b7e4831f50f0cddfc49da3ef44df26240c27" translate="yes" xml:space="preserve">
          <source>The &quot;interrupt&quot; method</source>
          <target state="translated">割り込み」の方法</target>
        </trans-unit>
        <trans-unit id="1b5c7fcb603da939ee7df1123931389580f03242" translate="yes" xml:space="preserve">
          <source>The &quot;interrupt&quot; method invokes the &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; interface, causing any pending queries to halt.</source>
          <target state="translated">「interrupt」メソッドは&lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt（）&lt;/a&gt;インターフェースを呼び出し、保留中のクエリを停止させます。</target>
        </trans-unit>
        <trans-unit id="33827ff37e59286ea63b18a3b491ccd55fa35d36" translate="yes" xml:space="preserve">
          <source>The &quot;isInit&quot; flag. 1 when the shm file has been initialized.</source>
          <target state="translated">isInit &quot;フラグ。shmファイルが初期化されている場合は1。</target>
        </trans-unit>
        <trans-unit id="27d80d07107f3dd674071f8dcb5d66e927b93ae8" translate="yes" xml:space="preserve">
          <source>The &quot;isolation&quot; property of a database determines when changes made to the database by one operation become visible to other concurrent operations.</source>
          <target state="translated">データベースの &quot;分離 &quot;プロパティは、ある操作によってデータベースに加えられた変更が、他の並行操作から見えるようになるタイミングを決定します。</target>
        </trans-unit>
        <trans-unit id="ca6207f3c60486460fc150891b4e2b2ff184348d" translate="yes" xml:space="preserve">
          <source>The &quot;key&quot; column is the integer array index for elements of a JSON array and the text label for elements of a JSON object. The key column is NULL in all other cases.</source>
          <target state="translated">key&quot; カラムは、JSON 配列の要素の場合は整数の配列インデックス、JSON オブジェクトの要素の場合はテキストラベルである。それ以外の場合は、キーカラムはNULLとなります。</target>
        </trans-unit>
        <trans-unit id="f06bf7b5c9acc6e224eb6aebb494891b0b016a3d" translate="yes" xml:space="preserve">
          <source>The &quot;last_insert_rowid&quot; method</source>
          <target state="translated">last_insert_rowid」メソッドは</target>
        </trans-unit>
        <trans-unit id="b6bbfdca82da26696ded7dc7b5667ad95fba9734" translate="yes" xml:space="preserve">
          <source>The &quot;last_insert_rowid&quot; method returns an integer which is the ROWID of the most recently inserted database row.</source>
          <target state="translated">last_insert_rowid&quot; メソッドは、最近挿入されたデータベース行の ROWID を integer で返します。</target>
        </trans-unit>
        <trans-unit id="7284b909bd501ff8419335375b9cbd82855b5cf7" translate="yes" xml:space="preserve">
          <source>The &quot;localtime&quot; modifier (12) assumes the time string to its left is in Universal Coordinated Time (UTC) and adjusts the time string so that it displays localtime. If &quot;localtime&quot; follows a time that is not UTC, then the behavior is undefined. The &quot;utc&quot; modifier is the opposite of &quot;localtime&quot;. &quot;utc&quot; assumes that the string to its left is in the local timezone and adjusts that string to be in UTC. If the prior string is not in localtime, then the result of &quot;utc&quot; is undefined.</source>
          <target state="translated">localtime」修飾子(12)は、その左にある時間文字列が協定世界時(UTC)であると仮定して、ローカルタイムを表示するように時間文字列を調整する。もし &quot;localtime &quot;がUTCではない時刻に続く場合、その動作は未定義である。utc &quot;修飾子は、&quot;localtime &quot;の反対である。&quot;utc &quot;は、その左にある文字列がローカルタイムゾーンにあると仮定し、その文字列がUTCになるように調整する。前の文字列がローカルタイムゾーンにない場合、&quot;utc &quot;の結果は未定義である。</target>
        </trans-unit>
        <trans-unit id="15b3080063f65f5e859c8cbf90675f21f18f1993" translate="yes" xml:space="preserve">
          <source>The &quot;lost_and_found&quot; table contains one row for each orphaned row recovered from the database. Additionally, there is one row for each recovered index entry that cannot be attributed to any SQL index. This is because, in an SQLite database, the same format is used to store SQL index entries and WITHOUT ROWID table entries.</source>
          <target state="translated">lost_and_found&quot; テーブルには、データベースから復旧した孤児の行ごとに 1 行が含まれています。さらに、どのSQLインデックスにも帰属できない、回復したインデックス項目ごとに1つの行があります。これは、SQLiteデータベースでは、SQLインデックスエントリとWITHOUT ROWIDテーブルエントリを格納するために同じフォーマットが使用されるためです。</target>
        </trans-unit>
        <trans-unit id="9b9bb88fb1467415e1fd0ce3e886e98f2fabd9f8" translate="yes" xml:space="preserve">
          <source>The &quot;main&quot; argument to dbstat is default schema for which information is to be provided. The default is &quot;main&quot;, and so the use of &quot;main&quot; in the example above is redundant. For any particular query, the schema can be changed by specifying the alternative schema as a function argument to the virtual table name in the FROM clause of the query. (See further discussion of &lt;a href=&quot;lang_select#tabfunc1&quot;&gt;table-valued functions in the FROM clause&lt;/a&gt; for more details.)</source>
          <target state="translated">dbstatの「メイン」引数は、情報が提供されるデフォルトのスキーマです。デフォルトは「main」であるため、上記の例での「main」の使用は冗長です。特定のクエリの場合、クエリのFROM句で仮想テーブル名の関数引数として代替スキーマを指定することにより、スキーマを変更できます。（詳細については&lt;a href=&quot;lang_select#tabfunc1&quot;&gt;、FROM句&lt;/a&gt;のテーブル値関数の詳細を参照してください。）</target>
        </trans-unit>
        <trans-unit id="09862758c2c346b79031222c95f1cc2f0ca91ec9" translate="yes" xml:space="preserve">
          <source>The &quot;make&quot; utility, or optionally &quot;nmake&quot; on Windows.</source>
          <target state="translated">make&quot; ユーティリティ、または Windows ではオプションで &quot;nmake&quot;。</target>
        </trans-unit>
        <trans-unit id="658c3f95d62bc63b68f3b7aa685ee8fbc83d8cde" translate="yes" xml:space="preserve">
          <source>The &quot;matchinfo=fts3&quot; option is not available. The &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;columnsize=0&quot;&lt;/a&gt; option is equivalent.</source>
          <target state="translated">「matchinfo = fts3」オプションは使用できません。&lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;「ColumnSizeが= 0」&lt;/a&gt;オプションは等価です。</target>
        </trans-unit>
        <trans-unit id="d99f30c2d0e908e2cc3022d7fdccaca904765bb1" translate="yes" xml:space="preserve">
          <source>The &quot;merge&quot; command attempts to apply all the changes between circles (1) and (4) to the files in the local checkout. Note that circle (5) has not been created yet. You will need to run the &quot;commit&quot; to create circle (5).</source>
          <target state="translated">merge」コマンドは、円(1)と(4)の間のすべての変更をローカルチェックアウトのファイルに適用しようとします。円(5)はまだ作成されていないことに注意してください。サークル(5)を作成するには、&quot;commit &quot;を実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="9e41a414a4991da0955ad788ff392c91737d8599" translate="yes" xml:space="preserve">
          <source>The &quot;merge=X,Y&quot; command (where X and Y are integers) causes SQLite to do a limited amount of work toward merging the various inverted index b-trees of an FTS3/4 table together into one large b-tree. The X value is the target number of &quot;blocks&quot; to be merged, and Y is the minimum number of b-tree segments on a level required before merging will be applied to that level. The value of Y should be between 2 and 16 with a recommended value of 8. The value of X can be any positive integer but values on the order of 100 to 300 are recommended.</source>
          <target state="translated">merge=X,Y&quot; コマンド (ここで X と Y は整数)は、FTS3/4 テーブルの様々な転置インデックス b-tree を一つの大きな b-tree にマージするために、SQLite に限られた量の作業をさせる。X値はマージされる &quot;ブロック &quot;の目標数であり、Yはマージがそのレベルに適用される前に必要とされるレベル上のb-treeセグメントの最小数です。Yの値は2から16の間で、推奨値は8である。 Xの値は任意の正の整数であるが、100から300のオーダーの値が推奨される。</target>
        </trans-unit>
        <trans-unit id="7feb211cc64d1d7531c5d948598d752876b7262d" translate="yes" xml:space="preserve">
          <source>The &quot;missing&quot; parameter allows the user to specify the name of a &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database if it finds that the required database file is not present on disk. This provides the application with an opportunity to retrieve the required database from a remote source before swarmvtab attempts to open it. The only argument passed to the &quot;missing&quot; function is the name or URI that identifies the database being opened. Assuming:</source>
          <target state="translated">「missing」パラメーターを使用すると、ユーザーは、必要なデータベースファイルがディスクに存在しないことが判明した場合に、swarmvtabがデータベースを開く直前に呼び出される&lt;a href=&quot;appfunc&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;の名前を指定できます。これにより、swarmvtabがデータベースを開こうとする前に、リモートソースから必要なデータベースを取得する機会がアプリケーションに提供されます。 「missing」関数に渡される唯一の引数は、開かれているデータベースを識別する名前またはURIです。仮定：</target>
        </trans-unit>
        <trans-unit id="9e3f77712e8ba4f79aa6578b325009e072dd171a" translate="yes" xml:space="preserve">
          <source>The &quot;missing&quot; parameter allows the user to specify the name of a &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database if it finds that the required database file is not present on disk. This provides the application with an opportunity to retrieve the required database from a remote source before swarmvtab attempts to open it. The only argument passed to the &quot;missing&quot; function is the name or URI that identifies the database being opened. Assuming:</source>
          <target state="translated">「欠落」パラメーターを使用すると、必要なデータベースファイルがディスク上にないことが判明した場合にswarmvtabがデータベースを開く直前に呼び出される&lt;a href=&quot;c3ref/create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;の名前を指定できます。これにより、swarmvtabがデータベースを開こうとする前に、リモートソースから必要なデータベースを取得する機会がアプリケーションに提供されます。「見つからない」関数に渡される唯一の引数は、開かれているデータベースを識別する名前またはURIです。仮定：</target>
        </trans-unit>
        <trans-unit id="6f3a9546b734b773233219e3ac894021d9c4aea3" translate="yes" xml:space="preserve">
          <source>The &quot;mmap_size&quot; is the maximum number of bytes of the database file that SQLite will try to map into the process address space at one time. The mmap_size applies separately to each database file, so the total amount of process address space that could potentially be used is the mmap_size times the number of open database files.</source>
          <target state="translated">mmap_size」は、SQLite が一度にプロセスアドレス空間にマッピングしようとするデータベースファイルの最大バイト数です。mmap_sizeは各データベースファイルに個別に適用されるので、使用される可能性のあるプロセスアドレス空間の総量は、mmap_sizeに開いているデータベースファイルの数を掛けたものになります。</target>
        </trans-unit>
        <trans-unit id="d05f6ca4b8375a55040cbbe82e13d67e18ad454c" translate="yes" xml:space="preserve">
          <source>The &quot;mptester.c&quot; program is a stress test for multiple processes concurrently reading and writing a single database.</source>
          <target state="translated">mptester.c」プログラムは、1つのデータベースを複数のプロセスが同時に読み書きするストレステストです。</target>
        </trans-unit>
        <trans-unit id="aceceab4037b5385ba92b29e0b20a81e94146ade" translate="yes" xml:space="preserve">
          <source>The &quot;nullvalue&quot; method</source>
          <target state="translated">nullvalue」メソッド</target>
        </trans-unit>
        <trans-unit id="e3321ce8b4cd40cd33c761004ca598eb073646da" translate="yes" xml:space="preserve">
          <source>The &quot;nullvalue&quot; method changes the representation for NULL returned as result of the &quot;eval&quot; method.</source>
          <target state="translated">nullvalue &quot;メソッドは、&quot;eval &quot;メソッドの結果として返されるNULLの表現を変更します。</target>
        </trans-unit>
        <trans-unit id="afd7b6ac7a6da46e476f310a277a91923a4e7d04" translate="yes" xml:space="preserve">
          <source>The &quot;nullvalue&quot; method is useful to differ between NULL and empty column values as Tcl lacks a NULL representation. The default representation for NULL values is an empty string.</source>
          <target state="translated">nullvalue &quot;メソッドは、TclにはNULL表現がないので、NULLと空の列の値を区別するのに便利です。NULL値のデフォルトの表現は空の文字列です。</target>
        </trans-unit>
        <trans-unit id="0c64f6777879373881c2c98b6dbc2b30411e222a" translate="yes" xml:space="preserve">
          <source>The &quot;onecolumn&quot; method</source>
          <target state="translated">onecolumn」メソッド</target>
        </trans-unit>
        <trans-unit id="3506b602f0b2580a68e5b060067cc065e54d9b3f" translate="yes" xml:space="preserve">
          <source>The &quot;onecolumn&quot; method works like &quot;&lt;a href=&quot;#eval&quot;&gt;eval&lt;/a&gt;&quot; in that it evaluates the SQL query statement given as its argument. The difference is that &quot;onecolumn&quot; returns a single element which is the first column of the first row of the query result.</source>
          <target state="translated">「onecolumn」メソッドは、引数として指定されたSQLクエリステートメントを評価する点で「&lt;a href=&quot;#eval&quot;&gt;eval&lt;/a&gt;」と同様に機能します。違いは、「onecolumn」がクエリ結果の最初の行の最初の列である単一の要素を返すことです。</target>
        </trans-unit>
        <trans-unit id="a0182d08456ee166091bc283f720fe1e714fcddc" translate="yes" xml:space="preserve">
          <source>The &quot;onoff&quot; parameter is true to enable the tracking of memory statistics and false to disable statistics tracking.</source>
          <target state="translated">onoff &quot;パラメータは、メモリ統計情報のトラッキングを有効にするにはtrue、統計情報のトラッキングを無効にするにはfalseを指定します。</target>
        </trans-unit>
        <trans-unit id="e1f82fa30a955dc30a2b143e423d5902467689c7" translate="yes" xml:space="preserve">
          <source>The &quot;openclose&quot; parameter allows the user to specify the name of a &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database, and again just after it closes one. The first argument passed to the open close function is the filename or URI identifying the database to be opened or just recently closed (the same value returned in the leftmost column of the SQL statement provided to the CREATE VIRTUAL TABLE command). The second argument is integer value 0 when the function is invoked before opening a database, and 1 when it is invoked after one is closed. For example, if:</source>
          <target state="translated">「openclose」パラメーターを使用すると、ユーザーは、swarmvtabがデータベースを開く直前とデータベースを閉じた直後に呼び出される&lt;a href=&quot;appfunc&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;の名前を指定できます。open close関数に渡される最初の引数は、開くデータベースまたは最近閉じたデータベースを識別するファイル名またはURIです（CREATE VIRTUAL TABLEコマンドに提供されるSQLステートメントの左端の列に返される値と同じ値）。2番目の引数は、データベースを開く前に関数が呼び出された場合は整数値0であり、データベースが閉じられた後に呼び出された場合は1です。たとえば、次の場合：</target>
        </trans-unit>
        <trans-unit id="3c453be3bed80a3f6062f894d9c91b09f2a405f4" translate="yes" xml:space="preserve">
          <source>The &quot;openclose&quot; parameter allows the user to specify the name of a &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database, and again just after it closes one. The first argument passed to the open close function is the filename or URI identifying the database to be opened or just recently closed (the same value returned in the leftmost column of the SQL statement provided to the CREATE VIRTUAL TABLE command). The second argument is integer value 0 when the function is invoked before opening a database, and 1 when it is invoked after one is closed. For example, if:</source>
          <target state="translated">「openclose」パラメーターを使用すると、ユーザーは、swarmvtabがデータベースを開く直前と、データベースを閉じた直後に呼び出される&lt;a href=&quot;c3ref/create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;の名前を指定できます。 open close関数に渡される最初の引数は、開くデータベースまたは最近閉じたデータベースを識別するファイル名またはURIです（CREATE VIRTUAL TABLEコマンドに提供されるSQLステートメントの左端の列に返される同じ値）。 2番目の引数は、データベースを開く前に関数が呼び出された場合は整数値0、データベースが閉じられた後に呼び出された場合は1です。たとえば、次の場合：</target>
        </trans-unit>
        <trans-unit id="e12d49df2a6244cc1bdf5cf47d59be2df870804d" translate="yes" xml:space="preserve">
          <source>The &quot;optimize&quot; command causes FTS3/4 to merge together all of its inverted index b-trees into one large and complete b-tree. Doing an optimize will make subsequent queries run faster since there are fewer b-trees to search, and it may reduce disk usage by coalescing redundant entries. However, for a large FTS table, running optimize can be as expensive as running &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;. The optimize command essentially has to read and write the entire FTS table, resulting in a large transaction.</source>
          <target state="translated">「optimize」コマンドを使用すると、FTS3 / 4は、すべての逆索引bツリーを1つの大きく完全なbツリーにマージします。最適化を行うと、検索するBツリーが少なくなるため、後続のクエリの実行が速くなり、冗長なエントリを結合することでディスクの使用量を減らすことができます。ただし、大きなFTSテーブルの場合、optimizeを実行すると、&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;を実行するのと同じくらいのコストがかかります。最適化コマンドは基本的にFTSテーブル全体を読み書きする必要があるため、大きなトランザクションが発生します。</target>
        </trans-unit>
        <trans-unit id="8d4ccdc372ee3d695bbd6a513c0e6e7c13353814" translate="yes" xml:space="preserve">
          <source>The &quot;order&quot; option may be set to either &quot;DESC&quot; or &quot;ASC&quot; (in upper or lower case). If it is set to &quot;DESC&quot;, then FTS4 stores its data in such a way as to optimize returning results in descending order by docid. If it is set to &quot;ASC&quot; (the default), then the data structures are optimized for returning results in ascending order by docid. In other words, if many of the queries run against the FTS4 table use &quot;ORDER BY docid DESC&quot;, then it may improve performance to add the &quot;order=desc&quot; option to the CREATE VIRTUAL TABLE statement.</source>
          <target state="translated">order &quot;オプションは、&quot;DESC &quot;または &quot;ASC&quot;(大文字または小文字)のいずれかに設定することができる。DESC &quot;に設定されている場合、FTS4は、docidによる降順で結果を返すように最適化された方法でデータを格納する。これが &quot;ASC&quot;(デフォルト)に設定されている場合、データ構造はdocidの昇順で結果を返すように最適化される。言い換えれば、FTS4テーブルに対して実行されるクエリの多くが &quot;ORDER BY docid DESC &quot;を使用している場合、CREATE VIRTUAL TABLE文に &quot;ORDER=DESC &quot;オプションを追加するとパフォーマンスが向上する可能性があります。</target>
        </trans-unit>
        <trans-unit id="a820cd844c9df8619832ad41e29de304a643e275" translate="yes" xml:space="preserve">
          <source>The &quot;pBuf&quot; parameter is a pointer to memory space that will be used for the lookaside memory pool. If pBuf is NULL, then SQLite will obtain its own space for the memory pool using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The &quot;sz&quot; and &quot;cnt&quot; parameters are the size of each lookaside slot and the number of slots, respectively. If pBuf is not NULL, then it must point to at least sz*cnt bytes of memory.</source>
          <target state="translated">「pBuf」パラメータは、lookasideメモリプールに使用されるメモリ空間へのポインタです。 pBufがNULLの場合、SQLiteは&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;を使用してメモリプール用の独自のスペースを取得します。 「sz」パラメータと「cnt」パラメータは、それぞれのlookasideスロットのサイズとスロットの数です。 pBufがNULLでない場合は、少なくともsz * cntバイトのメモリを指す必要があります。</target>
        </trans-unit>
        <trans-unit id="96f961210acaa75affae517c15c72d34812d54b4" translate="yes" xml:space="preserve">
          <source>The &quot;parent&quot; column is always NULL for json_each(). For json_tree(), the &quot;parent&quot; column is the &quot;id&quot; integer for the parent of the current element, or NULL for the top-level JSON element or the element identified by the root path in the second argument.</source>
          <target state="translated">json_each()では、&quot;parent &quot;カラムは常にNULLである。json_tree()では、&quot;parent &quot;カラムは、現在の要素の親のための &quot;id &quot;整数であり、トップレベルのJSON要素または第2引数のルートパスで識別される要素の場合はNULLである。</target>
        </trans-unit>
        <trans-unit id="f4a41ee583b00942417f0c8c5f788e416b5fcd33" translate="yes" xml:space="preserve">
          <source>The &quot;path&quot; column describes the path taken from the root node of the btree structure to each page. The &quot;path&quot; of the root node itself is '/'. The &quot;path&quot; for the left-most child page of the root of a btree page is '/000/'. (Btrees store content ordered from left to right so the pages to the left have smaller keys than the pages to the right.) The next to left-most child of the root page is '/001', and so on, each sibling page identified by a 3-digit hex value. The children of the 451st left-most sibling have paths such as '/1c2/000/, '/1c2/001/' etc. Overflow pages are specified by appending a '+' character and a six-digit hexadecimal value to the path to the cell they are linked from. For example, the three overflow pages in a chain linked from the left-most cell of the 450th child of the root page are identified by the paths:</source>
          <target state="translated">path」欄には、btree構造体のルートノードから各ページまでのパスを記述します。ルートノード自体の &quot;パス &quot;は'/'である。btreeページのルートの左端の子ページの &quot;パス &quot;は'/000/'です。(btreeは左から右に順にコンテンツを格納するので、左のページは右のページよりもキーが小さい)。ルートページの次から左端の子は '/001' であり、このように、各兄弟ページは 3 桁の 16 進数値で識別されます。451番目の左端の兄弟ページの子は、「/1c2/000/」、「/1c2/001/」などのパスを持っています。オーバーフローページは、リンク元のセルへのパスに'+'文字と6桁の16進数値を付加して指定します。た と えば、 ルートページの 450 番目の子の左端のセルからリンクされたチェー ン内の 3 つのオーバーフローページは、パスによって識別されます。</target>
        </trans-unit>
        <trans-unit id="91195df7be82f506dcfbeb2cd0a2c8ea2909dc1a" translate="yes" xml:space="preserve">
          <source>The &quot;path&quot; column describes the path taken from the root node of the btree structure to each page. The &quot;path&quot; of the root node itself is '/'. The &quot;path&quot; is NULL when &quot;aggregate&quot; is TRUE. The &quot;path&quot; for the left-most child page of the root of a btree page is '/000/'. (Btrees store content ordered from left to right so the pages to the left have smaller keys than the pages to the right.) The next to left-most child of the root page is '/001', and so on, each sibling page identified by a 3-digit hex value. The children of the 451st left-most sibling have paths such as '/1c2/000/, '/1c2/001/' etc. Overflow pages are specified by appending a '+' character and a six-digit hexadecimal value to the path to the cell they are linked from. For example, the three overflow pages in a chain linked from the left-most cell of the 450th child of the root page are identified by the paths:</source>
          <target state="translated">path」欄には、btree構造体のルートノードから各ページまでのパスを記述します。ルートノードの &quot;path &quot;自体は'/'です。aggregate &quot;がTRUEの場合、&quot;path &quot;はNULLとなる。btreeページのルートの左端の子ページのパスは'/000/'です。(btree は左から右に順にコンテンツを格納しているので、左のページの方が右のページよりもキーが小さくなります)。ルートページの次から左端の子は '/001' であり、このように、各兄弟ページは 3 桁の 16 進数値で識別されます。451番目の左端の兄弟ページの子は、「/1c2/000/」、「/1c2/001/」などのパスを持っています。オーバーフローページは、リンク元のセルへのパスに'+'文字と6桁の16進数値を付加して指定します。た と えば、 ルートページの 450 番目の子の左端のセルからリンクされたチェー ン内の 3 つのオーバーフローページは、パスによって識別されます。</target>
        </trans-unit>
        <trans-unit id="2306ed00f4707f3494099d14093fb57dc4cef952" translate="yes" xml:space="preserve">
          <source>The &quot;path&quot; column is the path to the array or object container the holds the current row, or the path to the current row in the case where the iteration starts on a primitive type and thus only provides a single row of output.</source>
          <target state="translated">path」列は、現在の行を保持している配列やオブジェクトコンテナへのパスであり、反復処理がプリミティブ型で開始される場合は、現在の行へのパスであり、その結果、1行の出力しか得られない。</target>
        </trans-unit>
        <trans-unit id="9d4d6b26f49abb4a72a1bbdb1337cbe3b3abe73d" translate="yes" xml:space="preserve">
          <source>The &quot;pointer type&quot; in the last parameter to &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; is used to prevent pointers intended for one extension from being redirected to a different extension. For example, without the use of pointer types, an attacker could still get access to pointer information in a system that included both the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; and the &lt;a href=&quot;carray&quot;&gt;CARRAY extension&lt;/a&gt; using SQL like this:</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;、&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;、および&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;への最後のパラメーターの「ポインタータイプ」は、ある拡張機能向けのポインターが別の拡張機能にリダイレクトされないようにするために使用されます。たとえば、ポインタタイプを使用しなくても、攻撃者は次のようなSQLを使用して、&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;と&lt;a href=&quot;carray&quot;&gt;CARRAY拡張の&lt;/a&gt;両方を含むシステムのポインタ情報にアクセスする可能性があります。</target>
        </trans-unit>
        <trans-unit id="adee741afd091308ea52b91bf986798eb9c23f39" translate="yes" xml:space="preserve">
          <source>The &quot;pointer type&quot; string which is the last parameter to each of the pointer-passing interfaces should be a distinct, application-specific string literal that appears directly in the API call. The pointer type should not be a parameter passed in from a higher-level function.</source>
          <target state="translated">各ポインタ渡しインタフェースの最後のパラメータである &quot;ポインタ型 &quot;文字列は、APIコールに直接現れる、アプリケーション固有の明確な文字列リテラルでなければなりません。ポインタ型は、上位レベルの関数から渡されるパラメータであってはなりません。</target>
        </trans-unit>
        <trans-unit id="87d3095f178983c8a04814005e7e058687741b3d" translate="yes" xml:space="preserve">
          <source>The &quot;prefix&quot; option, used to add &lt;a href=&quot;fts5#prefix_indexes&quot;&gt;prefix indexes&lt;/a&gt; to an FTS5 table.</source>
          <target state="translated">FTS5テーブルに&lt;a href=&quot;fts5#prefix_indexes&quot;&gt;プレフィックスインデックス&lt;/a&gt;を追加するために使用される「プレフィックス」オプション。</target>
        </trans-unit>
        <trans-unit id="007337419b82fead3e9a4bb4ea6d17cd18d879d3" translate="yes" xml:space="preserve">
          <source>The &quot;price of California oranges&quot; query was made more efficient through the use of a two-column index. But SQLite can do even better with a three-column index that also includes the &quot;price&quot; column:</source>
          <target state="translated">カリフォルニアオレンジの価格」クエリは、2カラムのインデックスを使用することでより効率的になりました。しかし、SQLiteは「価格」列を含む3列インデックスを使用することで、さらに効率的なクエリを実現することができます。</target>
        </trans-unit>
        <trans-unit id="57afc82684ba8294d6cce9305c290f392e265962" translate="yes" xml:space="preserve">
          <source>The &quot;profile&quot; method</source>
          <target state="translated">プロファイル」メソッド</target>
        </trans-unit>
        <trans-unit id="a6a8d9f9ad6e3aababd749d5fdde2d82848ad996" translate="yes" xml:space="preserve">
          <source>The &quot;progress&quot; method</source>
          <target state="translated">プログレス」の方法</target>
        </trans-unit>
        <trans-unit id="588545c2f185476e9dee998a1b045a9b0c16cc70" translate="yes" xml:space="preserve">
          <source>The &quot;quote&quot; output mode honors &quot;.separator&quot;</source>
          <target state="translated">quote&quot; 出力モードは &quot;.separator&quot; を尊重します。</target>
        </trans-unit>
        <trans-unit id="d98ea4147c812e538b99bc21f1f6a4e8e90abfe0" translate="yes" xml:space="preserve">
          <source>The &quot;rbu_control&quot; column may also be set to integer value 2 for an INSERT. In this case, the new row silently replaces any existing row that has the same primary key values. This is equivalent to a DELETE followed by an INSERT with the same primary key values. It is not the same as an SQL REPLACE command, as in that case the new row may replace any conflicting rows (i.e. those that conflict due to UNIQUE constraints or indexes), not just those with conflicting primary keys.</source>
          <target state="translated">rbu_control &quot;列は、INSERTのために整数値2に設定することもできます。この場合、新しい行は、同じ主キー値を持つ既存の行を静かに置き換えます。これは、同じ主キー値を持つ DELETE に続いて INSERT が行われるのと同じです。これは、SQL REPLACEコマンドと同じではありません。この場合、新しい行は、競合する主キーを持つ行だけでなく、競合する行(すなわち、UNIQUE制約やインデックスによって競合する行)を置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="a26e076f35ba0ef194f00cabb02d8f0d110dbd9a" translate="yes" xml:space="preserve">
          <source>The &quot;rebuild&quot; command causes SQLite to discard the entire FTS3/4 table and then rebuild it again from original text. The concept is similar to &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;, only that it applies to an FTS3/4 table instead of an ordinary index.</source>
          <target state="translated">「再構築」コマンドを使用すると、SQLiteはFTS3 / 4テーブル全体を破棄し、元のテキストから再構築します。概念は&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;に似ていますが、通常のインデックスではなくFTS3 / 4テーブルに適用されるだけです。</target>
        </trans-unit>
        <trans-unit id="9dfe3ef5f9d0e5aefda4d198135af7dfc82b7ad7" translate="yes" xml:space="preserve">
          <source>The &quot;rebuild&quot; command should be run whenever the implementation of a custom tokenizer changes, so that all content can be retokenized. The &quot;rebuild&quot; command is also useful when using the &lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4 content option&lt;/a&gt; after changes have been made to the original content table.</source>
          <target state="translated">「rebuild」コマンドは、カスタムトークナイザーの実装が変更されるたびに実行する必要があります。これにより、すべてのコンテンツを再トークン化できます。「rebuild」コマンドは、元のコンテンツテーブルに変更を加えた後で&lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4コンテンツオプション&lt;/a&gt;を使用する場合にも役立ちます。</target>
        </trans-unit>
        <trans-unit id="c9e0f27230c23e1210b0f85831927b9fb4ed65b1" translate="yes" xml:space="preserve">
          <source>The &quot;restore&quot; method</source>
          <target state="translated">復元」の方法</target>
        </trans-unit>
        <trans-unit id="24c21c10984afe5581e89897013fce4a408ba45f" translate="yes" xml:space="preserve">
          <source>The &quot;restore&quot; method copies the content from a separate database file into the current database connection, overwriting any preexisting content. The command syntax is like this:</source>
          <target state="translated">リストア」メソッドは、別のデータベースファイルから現在のデータベース接続にコンテンツをコピーし、既存のコンテンツを上書きします。コマンド構文は次のようになります。</target>
        </trans-unit>
        <trans-unit id="9587ea916bf4a39318094206a7a32f2bcdfaa5ba" translate="yes" xml:space="preserve">
          <source>The &quot;rollback_hook&quot; method</source>
          <target state="translated">rollback_hook」メソッド</target>
        </trans-unit>
        <trans-unit id="e00d488bea46afaaecd75512057a1c66d8fe6370" translate="yes" xml:space="preserve">
          <source>The &quot;score&quot; for a comparison is the edit distance between the pattern and the word, adjusted down by the base-2 logarithm of the word rank. For example, a match with distance 100 but rank 1000 would have a score of 122 (= 100 - log2(1000) + 32) whereas a match with distance 100 with a rank of 1 would have a score of 131 (100 - log2(1) + 32). (NB: The constant 32 is added to each score to keep it from going negative in case the edit distance is zero.) In this way, frequently used words get a slightly lower cost which tends to move them toward the top of the list of alternative spellings.</source>
          <target state="translated">比較の「スコア」は、パターンと単語の間の編集距離で、単語のランクの基底2対数で調整されます。例えば、距離100でランク1000のマッチは122 (=100-log2(1000)+32)のスコアを持つのに対し、距離100でランク1のマッチは131 (100-log2(1)+32)のスコアを持つことになります。(注意:編集距離がゼロの場合に負の値にならないように、各スコアに定数32が追加されます)。このようにして、頻繁に使用される単語は、代替スペルのリストのトップに移動する傾向がある、わずかに低いコストを取得します。</target>
        </trans-unit>
        <trans-unit id="5c73b0b5b1beb7568fc6d18b01b575dea3734b9a" translate="yes" xml:space="preserve">
          <source>The &quot;serialize&quot; method</source>
          <target state="translated">シリアライズ」メソッド</target>
        </trans-unit>
        <trans-unit id="3d89d42c3828f01cc4451e3643a15ed26533dc51" translate="yes" xml:space="preserve">
          <source>The &quot;serialize&quot; method creates a BLOB which is a complete copy of an underlying database. The syntax is like this:</source>
          <target state="translated">serialize &quot;メソッドは、基礎となるデータベースの完全なコピーであるBLOBを作成します。構文は次のようになります。</target>
        </trans-unit>
        <trans-unit id="d8ecb1d818748f027a6df9d4ecf31fdb4abf6802" translate="yes" xml:space="preserve">
          <source>The &quot;size&quot; of a row value is the number of scalar values the row value contains. The size of a row value is always at least 2. A row value with a single column is just a scalar value. A row value with no columns is a syntax error.</source>
          <target state="translated">行値の「サイズ」は、行値が含むスカラー値の数です。行値のサイズは常に2以上であり、1列の列を持つ行値はスカラ値に過ぎません。列のない行値は構文エラーです。</target>
        </trans-unit>
        <trans-unit id="5edd5de6e6f1cc913259bc478dccfe21c6a5d5fb" translate="yes" xml:space="preserve">
          <source>The &quot;speedtest1.c&quot; program estimates the performance of SQLite under a typical workload.</source>
          <target state="translated">speedtest1.c」プログラムは、典型的な作業負荷の下でのSQLiteのパフォーマンスを推定します。</target>
        </trans-unit>
        <trans-unit id="94d1e1fa50bdc62251cad63515806a616cb08e98" translate="yes" xml:space="preserve">
          <source>The &quot;spellfix1&quot; term is the name of the spellfix module and must be entered as shown. The &quot;demo&quot; term is the name of the virtual table you will be creating and can be altered to suit the needs of your application. The virtual table is initially empty. In order for the virtual table to be useful, you will need to populate it with your vocabulary. Suppose you have a list of words in a table named &quot;big_vocabulary&quot;. Then do this:</source>
          <target state="translated">spellfix1」という用語は、spellfix モジュールの名前で、表示されているように入力する必要があります。demo&quot; は、これから作成する仮想テーブルの名前で、アプリケーションのニーズに合わせて変更できます。仮想テーブルは最初は空です。仮想テーブルが役に立つようにするためには、ボキャブラリーを入力する必要があります。例えば、&quot;big_vocabulary &quot;という名前のテーブルに単語のリストがあるとします。そして、次のようにします。</target>
        </trans-unit>
        <trans-unit id="1f251add4c0609e09930cd5b2e1c244e554f6696" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3.c&quot; code file contains default implementations of a VFS and of the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; functions that are appropriate for Unix, Windows, and OS/2. To prevent one of these default components from being loaded when sqlite3.c is compiled, it is necessary to add the following compile-time option:</source>
          <target state="translated">「sqlite3.c」コードファイルには、VFSのデフォルト実装と、Unix、Windows、およびOS / 2に適した&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;および&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;関数のデフォルトの実装が含まれています。sqlite3.cのコンパイル時にこれらのデフォルトコンポーネントの1つが読み込まれないようにするには、次のコンパイル時オプションを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="d25afe467d47fff3cdb66b829147595e777d2e30" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3.c&quot; make target will automatically construct the regular &quot;&lt;b&gt;sqlite3.c&lt;/b&gt;&quot; amalgamation source file, its header file &quot;&lt;b&gt;sqlite3.h&lt;/b&gt;&quot;, and the &quot;&lt;b&gt;tclsqlite3.c&lt;/b&gt;&quot; amalgamation source file that includes the TCL interface. Afterwards, the needed files can be copied into project directories and compiled according to the procedures outlined above.</source>
          <target state="translated">&quot;sqlite3.c&quot; makeターゲットは、通常の &quot; &lt;b&gt;sqlite3.c&lt;/b&gt; &quot; &lt;b&gt;アマルガメーション&lt;/b&gt;ソースファイル、そのヘッダーファイル &quot; &lt;b&gt;sqlite3.h&lt;/b&gt; &quot;、およびTCLインターフェースを含む&quot; &lt;b&gt;tclsqlite3.c&lt;/b&gt; &quot; &lt;b&gt;アマルガメーション&lt;/b&gt;ソースファイルを自動的に構築します。その後、上記の手順に従って、必要なファイルをプロジェクトディレクトリにコピーしてコンパイルできます。</target>
        </trans-unit>
        <trans-unit id="66d4d7e86561a6b1d54c81eff00582173909b3a6" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3_analyzer.exe&quot; utility program, available as source code in the SQLite source tree or as a precompiled binary on the &lt;a href=&quot;http://www.sqlite.org/download.html&quot;&gt;SQLite Download page&lt;/a&gt;, can be used to measure the average sizes of table rows in an existing SQLite database.</source>
          <target state="translated">「sqlite3_analyzer.exe」ユーティリティプログラムは、SQLiteソースツリーのソースコードとして、または&lt;a href=&quot;http://www.sqlite.org/download.html&quot;&gt;SQLiteダウンロードページの&lt;/a&gt;プリコンパイルされたバイナリとして利用でき、既存のSQLiteデータベースのテーブル行の平均サイズを測定するために使用できます。</target>
        </trans-unit>
        <trans-unit id="ff30531d333139aba53fa40d0cdd26055103901a" translate="yes" xml:space="preserve">
          <source>The &quot;start match&quot; text.</source>
          <target state="translated">スタートマッチ」のテキストです。</target>
        </trans-unit>
        <trans-unit id="b039029daf858be6adbac43c34475b31375cdd36" translate="yes" xml:space="preserve">
          <source>The &quot;start of&quot; modifiers (7 through 9) shift the date backwards to the beginning of the current month, year or day.</source>
          <target state="translated">開始」修飾子 (7 から 9)は、日付を現在の月、年、または日の最初に遡って移動させます。</target>
        </trans-unit>
        <trans-unit id="05b5d073f83b249218dde4220e351fdb9c81957d" translate="yes" xml:space="preserve">
          <source>The &quot;state&quot; index works just like the &quot;fruit&quot; index in that it is a new table with an extra column in front of the rowid and sorted by that extra column as the primary key. The only difference is that in Idx2, the first column is &quot;state&quot; instead of &quot;fruit&quot; as it is with Idx1. In our example data set, there is more redundancy in the &quot;state&quot; column and so they are more duplicate entries. The ties are still resolved using the rowid.</source>
          <target state="translated">state&quot; インデックスは、&quot;fruit&quot; インデックスと同じように動作しますが、rowid の前に余分なカラムを持つ新しいテーブルを作成し、その余分なカラムを主キーとしてソートします。唯一の違いは、Idx2 の場合、Idx1 と同様に最初のカラムが &quot;fruit&quot; ではなく &quot;state&quot; になっていることです。この例のデータセットでは、&quot;state&quot; カラムに冗長性があるため、重複エントリが多くなっています。同点はまだ rowid を使用して解決されています。</target>
        </trans-unit>
        <trans-unit id="cf055db4baca803941f56b418b3f79cd69d69f75" translate="yes" xml:space="preserve">
          <source>The &quot;status&quot; method</source>
          <target state="translated">ステータス」メソッド</target>
        </trans-unit>
        <trans-unit id="4cb7bc19f02c001a06f5cf0e9a288feeb79d31b6" translate="yes" xml:space="preserve">
          <source>The &quot;swarmvtab&quot; virtual table allows the user to query a large number of tables (hereafter &quot;component&quot; tables) with similar schemas but distinct ranges of rowid values as if they were a single database table. The tables may be (and usually are) located in different databases. Swarmvtab tables are read-only.</source>
          <target state="translated">仮想テーブル &quot;swarmvtab &quot;を使用すると、スキーマは似ていても行ID値の範囲が異なる多数のテーブル(以下、&quot;コンポーネントテーブル &quot;と呼ぶ)を、あたかも1つのデータベーステーブルであるかのように照会することができます。これらのテーブルは、異なるデータベースに存在する場合があります(通常は存在します)。Swarmvtabテーブルは読み取り専用です。</target>
        </trans-unit>
        <trans-unit id="dab19bcea20e3ab7d9ecf3510719cf0224e13f4a" translate="yes" xml:space="preserve">
          <source>The &quot;sz&quot; parameter is the size in bytes of each lookaside slot. The &quot;cnt&quot; parameter is the total number of lookaside memory slots per database connection. The total amount of lookaside memory allocated to each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is sz*cnt bytes.</source>
          <target state="translated">「sz」パラメータは、各ルックアサイドスロットのバイト単位のサイズです。「cnt」パラメータは、データベース接続ごとのルックアサイドメモリスロットの総数です。各&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続に&lt;/a&gt;割り当てられたルックアサイドメモリの総量は、sz * cntバイトです。</target>
        </trans-unit>
        <trans-unit id="21cc2584b07fb547745b9d5684016c88291d98ce" translate="yes" xml:space="preserve">
          <source>The &quot;sz=NNN&quot; argument (where NNN represents a sequence of 1 or more digits) means that the average row size over all records of the table or index is NNN bytes per row. The SQLite query planner might use the estimated row size information provided by the &quot;sz=NNN&quot; token to help it choose smaller tables and indexes that require less disk I/O.</source>
          <target state="translated">引数 &quot;sz=NNN&quot; (NNN は 1 桁以上の数字の列を表します)は、テーブルまたはインデックスの全レコードの平均行サイズが 1 行あたり NNN バイトであることを意味します。SQLite クエリプランナは、&quot;sz=NNN&quot; トークンが提供する推定行サイズの情報を使用して、ディスク I/O を必要としない小さなテーブルやインデックスを選択することができます。</target>
        </trans-unit>
        <trans-unit id="1f5faa11cc0f3cca617edc23b678832f22fc7469" translate="yes" xml:space="preserve">
          <source>The &quot;temp&quot; database (in which TEMP tables and indices are stored) and &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt; always uses exclusive locking mode. The locking mode of temp and &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt; cannot be changed. All other databases use the normal locking mode by default and are affected by this pragma.</source>
          <target state="translated">「temp」データベース（TEMPテーブルとインデックスが格納される）および&lt;a href=&quot;inmemorydb&quot;&gt;インメモリデータベースは、&lt;/a&gt;常に排他ロックモードを使用します。一時&lt;a href=&quot;inmemorydb&quot;&gt;データベースとメモリ内データベース&lt;/a&gt;のロックモードは変更できません。他のすべてのデータベースはデフォルトで通常のロックモードを使用し、このプラグマの影響を受けます。</target>
        </trans-unit>
        <trans-unit id="8cb92fbf85091b767df43e1863c69aa8515916b3" translate="yes" xml:space="preserve">
          <source>The &quot;test1.dir&quot; directory created above puts all the blobs into a single folder. It was conjectured that some operating systems would perform poorly when a single directory contains 100,000 objects. To test this, the kvtest program can also store the blobs in a hierarchy of folders with no more than 100 files and/or subdirectories per folder. The alternative on-disk representation of the blobs can be created using the --tree command-line option to the &quot;export&quot; command, like this:</source>
          <target state="translated">上で作成した &quot;test1.dir &quot;ディレクトリは、すべてのblobを1つのフォルダにまとめています。1つのディレクトリに100,000個のオブジェクトが含まれていると、一部のオペレーティングシステムではパフォーマンスが低下すると推測されていました。これをテストするために、kvtestプログラムは、フォルダごとに100個以下のファイルやサブディレクトリを持つフォルダの階層にブロブを格納することもできます。ディスク上の代替的なblobの表現は、&quot;export &quot;コマンドの--treeコマンドラインオプションを使用して、以下のように作成することができます。</target>
        </trans-unit>
        <trans-unit id="9e8c625e743111097d3b7602f25647d8fd5f0deb" translate="yes" xml:space="preserve">
          <source>The &quot;th3&quot; binary is run and the output checked for errors.</source>
          <target state="translated">th3&quot; バイナリが実行され、出力がエラーになっていないかチェックされます。</target>
        </trans-unit>
        <trans-unit id="405706da87374261dc84d98a92672d2aa3e6824d" translate="yes" xml:space="preserve">
          <source>The &quot;threadtest3.c&quot; program is a stress test for multiple threads using SQLite simultaneously.</source>
          <target state="translated">threadtest3.c」というプログラムは、SQLiteを使って複数のスレッドを同時に使用するストレステストです。</target>
        </trans-unit>
        <trans-unit id="c2ea8ab5c5050c4a238a6302498853dd2f689e62" translate="yes" xml:space="preserve">
          <source>The &quot;three&quot; column -- the key to the bucket</source>
          <target state="translated">さん」の欄--バケツの鍵を握る</target>
        </trans-unit>
        <trans-unit id="4fa8abbe4c1763e70302352dd8c5a5a17e072b27" translate="yes" xml:space="preserve">
          <source>The &quot;timeout&quot; method</source>
          <target state="translated">タイムアウト」メソッド</target>
        </trans-unit>
        <trans-unit id="7d44f83daf7e28e3193a3ecca21e30ba205796c2" translate="yes" xml:space="preserve">
          <source>The &quot;timeout&quot; method is used to control how long the SQLite library will wait for locks to clear before giving up on a database transaction. The default timeout is 0 millisecond. (In other words, the default behavior is not to wait at all.)</source>
          <target state="translated">timeout&quot; メソッドは、SQLite ライブラリがデータベーストランザクションをあきらめる前にロックが解除されるまでの時間を制御するために使用されます。デフォルトのタイムアウトは0ミリ秒です。(言い換えれば、デフォルトの動作は全く待たないということです)。</target>
        </trans-unit>
        <trans-unit id="7ac730ff83376aab14adb2a2686e6b4272b35baf" translate="yes" xml:space="preserve">
          <source>The &quot;tokenize&quot; option, used to configure a &lt;a href=&quot;fts5#tokenizers&quot;&gt;custom tokenizer&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts5#tokenizers&quot;&gt;カスタムトークナイザー&lt;/a&gt;を構成するために使用される「トークン化」オプション。</target>
        </trans-unit>
        <trans-unit id="5924f14d286c018a59c3ed95d3124a43c86bfc19" translate="yes" xml:space="preserve">
          <source>The &quot;total_changes&quot; method</source>
          <target state="translated">total_changes」メソッド</target>
        </trans-unit>
        <trans-unit id="67201b01d24a416fed46b29f515a9e7ed51080c3" translate="yes" xml:space="preserve">
          <source>The &quot;total_changes&quot; method returns an integer which is the number of rows in the database that were inserted, deleted, and/or modified since the current database connection was first opened.</source>
          <target state="translated">total_changes &quot;メソッドは、現在のデータベース接続が最初に開かれてから挿入、削除、変更されたデータベース内の行の数を整数で返します。</target>
        </trans-unit>
        <trans-unit id="7e6156617165c2bee31d2c34a55e3df2f7ee7cbc" translate="yes" xml:space="preserve">
          <source>The &quot;trace&quot; method</source>
          <target state="translated">トレース」の方法</target>
        </trans-unit>
        <trans-unit id="b2906df9327952a977291763abf36d4cd7917ee1" translate="yes" xml:space="preserve">
          <source>The &quot;trace&quot; method registers a callback that is invoked as each SQL statement is compiled. The text of the SQL is appended as a single string to the command before it is invoked. This can be used (for example) to keep a log of all SQL operations that an application performs.</source>
          <target state="translated">trace &quot;メソッドは、各SQL文がコンパイルされるたびに呼び出されるコールバックを登録します。SQLのテキストは、それが呼び出される前に、コマンドに1つの文字列として追加されます。これは、アプリケーションが実行するすべてのSQL操作のログを保持するために使用することができます(例えば)。</target>
        </trans-unit>
        <trans-unit id="ce50004a13c3fcabcb6ebda341338c2b6ecfb280" translate="yes" xml:space="preserve">
          <source>The &quot;trace_v2&quot; method</source>
          <target state="translated">trace_v2&quot; メソッド</target>
        </trans-unit>
        <trans-unit id="2fe37d0c891dddf24c1d50f2d3327a7f07cf31d0" translate="yes" xml:space="preserve">
          <source>The &quot;trace_v2&quot; method registers a callback that is invoked as each SQL statement is compiled. The syntax is as follows:</source>
          <target state="translated">trace_v2 &quot;メソッドは、各SQL文がコンパイルされるたびに呼び出されるコールバックを登録します。構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="e9e9294106d107e583dc783efd0d04b347f737f9" translate="yes" xml:space="preserve">
          <source>The &quot;transaction&quot; method</source>
          <target state="translated">トランザクション」メソッド</target>
        </trans-unit>
        <trans-unit id="839415a25e55cb5e0ba1d1d3bedbc6f8468c1f73" translate="yes" xml:space="preserve">
          <source>The &quot;transaction&quot; method is used to execute a TCL script inside an SQLite database transaction. The transaction is committed when the script completes, or it rolls back if the script fails. If the transaction occurs within another transaction (even one that is started manually using BEGIN) it is a no-op.</source>
          <target state="translated">transaction」メソッドは、SQLiteデータベースのトランザクション内でTCLスクリプトを実行するために使用されます。トランザクションは、スクリプトが完了するとコミットされ、スクリプトが失敗するとロールバックされます。トランザクションが別のトランザクション内で発生した場合(BEGINを使用して手動で開始されたトランザクションであっても)、それは実行されません。</target>
        </trans-unit>
        <trans-unit id="378f72a23dc895cffd3910e611b45425aeb46721" translate="yes" xml:space="preserve">
          <source>The &quot;type&quot; column is an SQL text value taken from ('null', 'true', 'false', 'integer', 'real', 'text', 'array', 'object') according to the type of the current JSON element.</source>
          <target state="translated">type」列は、現在のJSON要素の型に応じて('null','true','false','integer','real','text','array','object')から取得したSQLテキスト値です。</target>
        </trans-unit>
        <trans-unit id="135f2f5e5d2c30f651d7adf36038240ab6497277" translate="yes" xml:space="preserve">
          <source>The &quot;typical&quot; workload is generated by the &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; program in the canonical SQLite source tree. This program strives to exercise the SQLite library in a way that is typical of real-world applications. Of course, every application is different, and so no test program can exactly mirror the behavior of all applications.</source>
          <target state="translated">「標準的な」ワークロードは、正規SQLiteソースツリーの&lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt;プログラムによって生成されます。このプログラムは、実際のアプリケーションで一般的な方法でSQLiteライブラリを実行するように努めています。もちろん、アプリケーションはそれぞれ異なるため、すべてのアプリケーションの動作を正確に反映できるテストプログラムはありません。</target>
        </trans-unit>
        <trans-unit id="27bfc78b4ec7e83cf7c09ae529723bb27ae007c2" translate="yes" xml:space="preserve">
          <source>The &quot;ui&quot; command will cause fossil to run a miniature built-in webserver and to launch your web-browser pointing at that webserver. You can use your web-browser to configure your project in various ways. See the instructions on the fossil website for additional information.</source>
          <target state="translated">ui &quot;コマンドを実行すると、fossilはビルトインウェブサーバーのミニチュアを実行し、そのウェブサーバーを指すウェブブラウザーを起動します。ウェブブラウザを使って様々な方法でプロジェクトを設定できます。詳細はfossilウェブサイトの説明をご覧ください。</target>
        </trans-unit>
        <trans-unit id="d78919ab60690742844f0ae8327639ff7f7b254a" translate="yes" xml:space="preserve">
          <source>The &quot;unicode61&quot; tokenizer is available beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;version 3.7.13&lt;/a&gt; (2012-06-11). Unicode61 works very much like &quot;simple&quot; except that it does simple unicode case folding according to rules in Unicode Version 6.1 and it recognizes unicode space and punctuation characters and uses those to separate tokens. The simple tokenizer only does case folding of ASCII characters and only recognizes ASCII space and punctuation characters as token separators.</source>
          <target state="translated">「unicode61」トークナイザーは、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;バージョン3.7.13&lt;/a&gt;（2012-06-11）以降で使用できます。 Unicode61は、Unicodeバージョン6.1のルールに従って単純なUnicodeの大文字と小文字の変換を行い、Unicodeのスペースと句読文字を認識し、それらを使用してトークンを分離することを除いて、「simple」と非常によく似ています。単純なトークナイザーは、ASCII文字の大文字小文字の変換のみを行い、ASCIIスペースと句読点文字のみをトークンの区切り文字として認識します。</target>
        </trans-unit>
        <trans-unit id="53568b33d00330dcebc8eb48a597c612134f3558" translate="yes" xml:space="preserve">
          <source>The &quot;unixepoch&quot; modifier (11) only works if it immediately follows a timestring in the DDDDDDDDDD format. This modifier causes the DDDDDDDDDD to be interpreted not as a Julian day number as it normally would be, but as &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix Time&lt;/a&gt; - the number of seconds since 1970. If the &quot;unixepoch&quot; modifier does not follow a timestring of the form DDDDDDDDDD which expresses the number of seconds since 1970 or if other modifiers separate the &quot;unixepoch&quot; modifier from prior DDDDDDDDDD then the behavior is undefined. For SQLite versions before 3.16.0 (2017-01-02), the &quot;unixepoch&quot; modifier only works for dates between 0000-01-01 00:00:00 and 5352-11-01 10:52:47 (unix times of -62167219200 through 106751991167).</source>
          <target state="translated">「unixepoch」修飾子（11）は、DDDDDDDDDD形式のタイムストリングの直後にある場合にのみ機能します。この修飾子により、DDDDDDDDDDは通常のユリウス日数ではなく、&lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix Time&lt;/a&gt; -1970年からの秒数として解釈されます。「unixepoch」修飾子がDDDDDDDDDD形式のタイムストリングに続かない場合、 1970年からの秒数、または他の修飾子が「unixepoch」修飾子を以前のDDDDDDDDDDから分離している場合の動作は未定義です。 SQLiteバージョン3.16.0（2017-01-02）より前の場合、「unixepoch」修飾子は0000-01-01 00:00:00から5352-11-01 10:52:47（Unix回の-62167219200〜106751991167）。</target>
        </trans-unit>
        <trans-unit id="9a380264abb876efbc0e0abf2e6a2f4c233a20b1" translate="yes" xml:space="preserve">
          <source>The &quot;unlock_notify&quot; method</source>
          <target state="translated">unlock_notify」メソッド</target>
        </trans-unit>
        <trans-unit id="a59aa60915a8fc6bc6f97fdfa3c585be19ca1408" translate="yes" xml:space="preserve">
          <source>The &quot;update_hook&quot; method</source>
          <target state="translated">update_hook &quot;メソッド</target>
        </trans-unit>
        <trans-unit id="ad1e96bd97056b4fb89ac4a9d66b380d5f0978cd" translate="yes" xml:space="preserve">
          <source>The &quot;usable size&quot; of a database page is the page size specified by the 2-byte integer at offset 16 in the header less the &quot;reserved&quot; space size recorded in the 1-byte integer at offset 20 in the header. The usable size of a page might be an odd number. However, the usable size is not allowed to be less than 480. In other words, if the page size is 512, then the reserved space size cannot exceed 32.</source>
          <target state="translated">データベースページの「使用可能サイズ」は、ヘッダのオフセット16の2バイト整数で指定されたページサイズから、ヘッダのオフセット20の1バイト整数に記録された「予約済み」のスペースサイズを差し引いたものである。ページの使用可能サイズは奇数になる場合がある。しかし、使用可能サイズが480以下になることは許されない。つまり、ページサイズが512であれば、予約されたスペースサイズは32を超えることはできない。</target>
        </trans-unit>
        <trans-unit id="0117a41a4edb11977b96c0bfbaf5ae135dd4dc28" translate="yes" xml:space="preserve">
          <source>The &quot;user version&quot; as read and set by the &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_versionプラグマ&lt;/a&gt;によって読み取られ、設定される「ユーザーバージョン」。</target>
        </trans-unit>
        <trans-unit id="4f1221e2090e85cfaa0707db328c83c8e04e4462" translate="yes" xml:space="preserve">
          <source>The &quot;verb&quot; argument determines what statistic is accessed. There are &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;various verbs&lt;/a&gt; defined. The list is expected to grow as the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt; interface matures. The current value the selected parameter is written into integer &quot;current&quot; and the highest historical value is written into integer &quot;highwater&quot;. If resetflag is true, then the high-water mark is reset down to the current value after the call returns.</source>
          <target state="translated">「動詞」引数は、アクセスする統計を決定します。あり&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;、様々な動詞&lt;/a&gt;定義されたが。リストは、&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status（）&lt;/a&gt;インターフェースが成熟するにつれて大きくなると予想されます。選択したパラメーターの現在の値は整数「現在」に書き込まれ、最も高い履歴値は整数「高水」に書き込まれます。resetflagがtrueの場合、呼び出しが戻った後、最高水準点が現在の値にリセットされます。</target>
        </trans-unit>
        <trans-unit id="fa357090791a4202ebbb1affe438340a7edf58ef" translate="yes" xml:space="preserve">
          <source>The &quot;version&quot; method</source>
          <target state="translated">バージョン」メソッド</target>
        </trans-unit>
        <trans-unit id="cd6ed1a853164caf36a9ec472723c210aaf3324f" translate="yes" xml:space="preserve">
          <source>The &quot;wal_hook&quot; method</source>
          <target state="translated">wal_hook」メソッド</target>
        </trans-unit>
        <trans-unit id="13953b9d13af87a94ab5c5d6a6cf14aaf24d8b07" translate="yes" xml:space="preserve">
          <source>The &quot;weekday&quot; modifier advances the date forward, if necessary, to the next date where the weekday number is N. Sunday is 0, Monday is 1, and so forth. If the date is already on the desired weekday, the &quot;weekday&quot; modifier leaves the date unchanged.</source>
          <target state="translated">weekday&quot; 修飾子は、必要に応じて、曜日番号が N である次の日付に日付を進めます。日付がすでに希望する曜日になっている場合、&quot;weekday &quot;修飾子は日付を変更しません。</target>
        </trans-unit>
        <trans-unit id="fc5b825d3bb551c0ffab90d4aebeaa4b072d1ccb" translate="yes" xml:space="preserve">
          <source>The $nExtCode extended result codes are &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="translated">$ nExtCode拡張結果コードは&lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;sqlite3.h&lt;/a&gt;で定義されており、以下にアルファベット順にリストされています。</target>
        </trans-unit>
        <trans-unit id="d7c45544c374d408b5b737fa2b109d54d1a57530" translate="yes" xml:space="preserve">
          <source>The $nPrimCode result codes are &lt;a href=&quot;c3ref/c_abort&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="translated">$ nPrimCode結果コードは&lt;a href=&quot;c3ref/c_abort&quot;&gt;sqlite3.h&lt;/a&gt;で定義されており、以下にアルファベット順にリストされています。</target>
        </trans-unit>
        <trans-unit id="3ab512eff5b3fb377f299e58700487486d503855" translate="yes" xml:space="preserve">
          <source>The $prefix parameter may be NULL, in which case the prefix is deduced from $wholeline. Or, the $wholeline parameter may be NULL or omitted if context information is unavailable or if context-aware completion is not desired.</source>
          <target state="translated">prefix パラメータを NULL にすることもできます。あるいは、コンテキスト情報が得られない場合やコンテキストを考慮した補完を行いたくない場合は、 $wholeline パラメータを NULL あるいは省略することもできます。</target>
        </trans-unit>
        <trans-unit id="02bbc5a1a7e84666a4d4dd0cec4c28449ae27a6f" translate="yes" xml:space="preserve">
          <source>The %_content table contains the unadulterated data inserted by the user into the FTS virtual table by the user. If the user does not explicitly supply a &quot;docid&quot; value when inserting records, one is selected automatically by the system.</source>
          <target state="translated">コンテンツ・テーブルには、ユーザによって FTS 仮想テーブルに挿入された、ユーザによって FTS 仮想テーブルに挿入された無修正のデータが含まれます。レコードを挿入する際にユーザが明示的に &quot;docid &quot;値を指定しない場合、システムによって自動的に1つが選択されます。</target>
        </trans-unit>
        <trans-unit id="7ff27a5cb67628299a86678a48c0336fb247a12c" translate="yes" xml:space="preserve">
          <source>The %_stat and %_docsize tables are only created if the FTS table uses the FTS4 module, not FTS3. Furthermore, the %_docsize table is omitted if the FTS4 table is created with the &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;&quot;matchinfo=fts3&quot;&lt;/a&gt; directive specified as part of the CREATE VIRTUAL TABLE statement. If they are created, the schema of the two tables is as follows:</source>
          <target state="translated">％_statおよび％_docsizeテーブルは、FTSテーブルがFTS3ではなくFTS4モジュールを使用する場合にのみ作成されます。さらに、CREATE VIRTUAL TABLEステートメントの一部として&lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;「matchinfo = fts3」&lt;/a&gt;ディレクティブを指定してFTS4テーブルを作成した場合、％_ docsizeテーブルは省略されます。作成された場合、2つのテーブルのスキーマは次のようになります。</target>
        </trans-unit>
        <trans-unit id="c824e78a5796a4ada97aea7265fbe991ac4b8766" translate="yes" xml:space="preserve">
          <source>The %q and %Q substitutions are SQLite enhancements, not found in most other printf() implementations.</source>
          <target state="translated">q および %Q 置換は SQLite の拡張で、他のほとんどの printf()実装にはありません。</target>
        </trans-unit>
        <trans-unit id="38a9fc3133aa73e0b29b95de437699b671e4c4f6" translate="yes" xml:space="preserve">
          <source>The %s substitution is universal, but the %z substitution is an SQLite enhancement, not found in other printf() implementations.</source>
          <target state="translated">%s 置換は汎用的ですが、%z 置換は SQLite の拡張であり、他の printf()実装にはありません。</target>
        </trans-unit>
        <trans-unit id="4b87f6c99821c5908fd04958d29e2e7c01fcfa39" translate="yes" xml:space="preserve">
          <source>The %w substitution is an SQLite enhancements, not found in most other printf() implementations.</source>
          <target state="translated">w 置換は SQLite の拡張機能で、他のほとんどの printf()実装にはありません。</target>
        </trans-unit>
        <trans-unit id="05ed0c85ed4fa11e23eab78d700cba29a96e54ed" translate="yes" xml:space="preserve">
          <source>The '%' character is used in requirement H35300 to represent the modulo operator, just as it is in programming languages such as C, Java and Javascript.</source>
          <target state="translated">文字「%」は、要件 H35300 では、C、Java、Javascript などのプログラミング言語と同様に、モジュロ演算子を表すために使用されます。</target>
        </trans-unit>
        <trans-unit id="e9354cba92715c3a8151b0bdbb532432be7bdd61" translate="yes" xml:space="preserve">
          <source>The 'crisismerge' option is similar to 'automerge', in that it determines how and how often the component b-trees that make up the full-text index are merged together. Once there exist</source>
          <target state="translated">crisismerge' オプションは 'automerge' と似ていますが、このオプションは、全文インデックスを構成するコンポーネントの b-tree をどのように、どのくらいの頻度でマージするかを決定します。いったん</target>
        </trans-unit>
        <trans-unit id="139c169421eec1791495afdd3b65ecbf6f7f8622" translate="yes" xml:space="preserve">
          <source>The *+* operator on the *x* column will prevent that term from constraining an index. This would force the use of the ex2i2 index.</source>
          <target state="translated">x*列の*+*演算子は、その項がインデックスを制約することを防ぎます。これはex2i2インデックスの使用を強制します。</target>
        </trans-unit>
        <trans-unit id="fe65d357eb360ea29fe1d68436790805aab233d0" translate="yes" xml:space="preserve">
          <source>The *pHighwater parameter records the deepest parser stack. The *pCurrent value is undefined. The *pHighwater value is only meaningful if SQLite is compiled with &lt;a href=&quot;../compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt;.</source>
          <target state="translated">* pHighwaterパラメーターは、最も深いパーサースタックを記録します。* pCurrent値は未定義です。* pHighwater値は、SQLiteが&lt;a href=&quot;../compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt;でコンパイルされている場合にのみ意味があります。</target>
        </trans-unit>
        <trans-unit id="c1ea66787615c66d86376977b69791f61618b2a2" translate="yes" xml:space="preserve">
          <source>The *pHighwater parameter records the deepest parser stack. The *pCurrent value is undefined. The *pHighwater value is only meaningful if SQLite is compiled with &lt;a href=&quot;compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt;.</source>
          <target state="translated">* pHighwaterパラメーターは、最も深いパーサースタックを記録します。* pCurrent値は未定義です。* pHighwater値は、SQLiteが&lt;a href=&quot;compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt;でコンパイルされている場合にのみ意味があります。</target>
        </trans-unit>
        <trans-unit id="6a0209d4ffca3af22d05eab8c450129e95986f2c" translate="yes" xml:space="preserve">
          <source>The --blob-api option on the database read test causes kvtest to use the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; feature of SQLite to load the content of the blobs, rather than running pure SQL statements. This helps SQLite to run a little faster on read tests. You can omit that option to compare the performance of SQLite running SQL statements. In that case, the SQLite still out-performs direct reads, though by not as much as when using &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;. The --blob-api option is ignored for tests that read from individual disk files.</source>
          <target state="translated">データベース読み取りテストの--blob-apiオプションを使用すると、&lt;a href=&quot;c3ref/blob_read&quot;&gt;kvtest&lt;/a&gt;は、純粋なSQLステートメントを実行するのではなく、SQLiteのsqlite3_blob_read（）機能を使用して、BLOBのコンテンツをロードします。これは、SQLiteが読み取りテストで少し速く実行するのに役立ちます。このオプションを省略して、SQLステートメントを実行するSQLiteのパフォーマンスを比較できます。その場合、&lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;を使用する場合ほどではありませんが、SQLiteは依然として直接読み取りよりも優れています。--blob-apiオプションは、個々のディスクファイルから読み取るテストでは無視されます。</target>
        </trans-unit>
        <trans-unit id="aeee09a9fb263d7d0932e1687159faa31b022fff" translate="yes" xml:space="preserve">
          <source>The --deserialize option associated with opening a new database cause the database file to be read into memory and accessed using the &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; API. This simplifies running tests on a database without modifying the file on disk.</source>
          <target state="translated">新しいデータベースを開くことに関連する--deserializeオプションを指定すると、データベースファイルがメモリに読み込まれ、&lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize（）&lt;/a&gt; API を使用してアクセスされます。これにより、ディスク上のファイルを変更せずに、データベースでのテストの実行が簡素化されます。</target>
        </trans-unit>
        <trans-unit id="11d3b8386b1e3ccb1cc08c05d6ada4438f0769ba" translate="yes" xml:space="preserve">
          <source>The --primarykey flag changes the pairing algorithm slightly so that the schema-declared &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; is always used for pairing, even on tables that have a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;. This is often a better choice for finding differences, however it can lead to missed differences in the case of rows that have one or more PRIMARY KEY columns set to NULL.</source>
          <target state="translated">--primarykeyフラグはペアリングアルゴリズムをわずかに変更するため、&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;を持つテーブルでも、スキーマで宣言された&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;が常にペアリングに使用されます。多くの場合、これは違いを見つけるためのより良い選択ですが、1つ以上のPRIMARY KEY列がNULLに設定されている行の場合、違いを見逃す可能性があります。</target>
        </trans-unit>
        <trans-unit id="5cd46599c902c6e8fdb69c21ede0585852a486b3" translate="yes" xml:space="preserve">
          <source>The --update and --insert commands work like --create command, except that they do not delete the current archive before commencing. New versions of files silently replace existing files with the same names, but otherwise the initial contents of the archive (if any) remain intact.</source>
          <target state="translated">update コマンドと --insert コマンドは --create コマンドと同じように動作しますが、開始前に現在のアーカイブを削除しない点を除いては、 --update コマンドと --insert コマンドは --create コマンドと同じように動作します。新しいバージョンのファイルは、既存のファイルを同じ名前で静かに置き換えますが、それ以外の場合は、アーカイブの初期の内容 (もしあれば)はそのまま残ります。</target>
        </trans-unit>
        <trans-unit id="92d15467647a321ed86c3b0d4ddfb73a9334e61d" translate="yes" xml:space="preserve">
          <source>The -ldl library is needed to support dynamic loading, the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface and the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension() SQL function&lt;/a&gt;. If these features are not required, then they can be omitted using &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; compile-time option:</source>
          <target state="translated">-ldlライブラリは、動的ロード、&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;インターフェース、および&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）SQL関数&lt;/a&gt;をサポートするために必要です。これらの機能が必要ない場合は、&lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt;コンパイル時オプションを使用して省略できます。</target>
        </trans-unit>
        <trans-unit id="ff976c7e2e67ea0658ecbf1774cc0a53bba77580" translate="yes" xml:space="preserve">
          <source>The .selftest command reads the rows of the selftest table in selftest.tno order. For each 'memo' row, it writes the text in 'cmd' to the output. For each 'run' row, it runs the 'cmd' text as SQL and compares the result to the value in 'ans', and shows an error message if the results differ.</source>
          <target state="translated">.selftestコマンドは、selftestテーブルの行をselftest.tnoの順に読み込む。各 'memo' 行に対して、'cmd' のテキストを出力に書き込む。各 'run' 行に対して、'cmd' テキストを SQL として実行し、その結果を 'ans' の値と比較し、結果が異なる場合にはエラーメッセージを表示します。</target>
        </trans-unit>
        <trans-unit id="12dcfb8a7c514a22ec8efe2151085ef4fd8b43ec" translate="yes" xml:space="preserve">
          <source>The 100-byte database file header (found on page 1 only)</source>
          <target state="translated">100 バイトのデータベースファイルヘッダ (1 ページ目のみに記載)</target>
        </trans-unit>
        <trans-unit id="a17caaa0027df54644d9d8d5e0706c4b71db11b0" translate="yes" xml:space="preserve">
          <source>The 100-byte database file header is found only on page 1, which is always a table b-tree page. All other b-tree pages in the database file omit this 100-byte header.</source>
          <target state="translated">100バイトのデータベースファイルヘッダは1ページ目にのみ存在し、これは常にテーブルのb-treeページである。データベースファイル内の他のすべてのb-treeページは、この100バイトのヘッダを省略しています。</target>
        </trans-unit>
        <trans-unit id="3b6884cf3226327e79dce3b07ec790a620af6f29" translate="yes" xml:space="preserve">
          <source>The 12-step &lt;a href=&quot;lang_altertable#otheralter&quot;&gt;generalized ALTER TABLE procedure&lt;/a&gt; above will work even if the schema change causes the information stored in the table to change. So the full 12-step procedure above is appropriate for dropping a column, changing the order of columns, adding or removing a UNIQUE constraint or PRIMARY KEY, adding CHECK or FOREIGN KEY or NOT NULL constraints, or changing the datatype for a column, for example. However, a simpler and faster procedure can optionally be used for some changes that do no affect the on-disk content in any way. The following simpler procedure is appropriate for removing CHECK or FOREIGN KEY or NOT NULL constraints, or adding, removing, or changing default values on a column.</source>
          <target state="translated">上記の12ステップの&lt;a href=&quot;lang_altertable#otheralter&quot;&gt;一般化されたALTER TABLEプロシージャ&lt;/a&gt;は、スキーマの変更によりテーブルに格納されている情報が変更された場合でも機能します。したがって、上記の完全な12ステップの手順は、列の削除、列の順序の変更、UNIQUE制約またはPRIMARY KEYの追加または削除、CHECKまたはFOREIGN KEYまたはNOT NULL制約の追加、または列のデータ型の変更に適しています。例。ただし、ディスク上のコンテンツにまったく影響を及ぼさない変更については、オプションで簡単で高速な手順を使用できます。次の簡単な手順は、CHECK制約、FOREIGN KEY制約、またはNOT NULL制約を削除する場合、または列のデフォルト値を追加、削除、または変更する場合に適しています。</target>
        </trans-unit>
        <trans-unit id="3229fe36f5dbdb9bc16916270b8799663f2b4b3a" translate="yes" xml:space="preserve">
          <source>The 2nd argument to the sqlite3_exec() callback function is the number of columns in the result. The 3rd argument to the sqlite3_exec() callback is an array of pointers to strings obtained as if from &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, one for each column. If an element of a result row is NULL then the corresponding string pointer for the sqlite3_exec() callback is a NULL pointer. The 4th argument to the sqlite3_exec() callback is an array of pointers to strings where each entry represents the name of corresponding result column as obtained from &lt;a href=&quot;#sqlite3_column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_exec（）コールバック関数の2番目の引数は、結果の列の数です。sqlite3_exec（）コールバックに第3引数からかのようにして得られた文字列へのポインタの配列である&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text（） &lt;/a&gt;、各列に対して1つ。結果行の要素がNULLの場合、sqlite3_exec（）コールバックに対応する文字列ポインターはNULLポインターです。sqlite3_exec（）コールバックの4番目の引数は文字列へのポインターの配列で、各エントリは&lt;a href=&quot;#sqlite3_column_name&quot;&gt;sqlite3_column_name（）&lt;/a&gt;から取得した対応する結果列の名前を表します。</target>
        </trans-unit>
        <trans-unit id="f8004ad0fbc670903554e47567c2e9bf84a736bf" translate="yes" xml:space="preserve">
          <source>The 2nd argument to the sqlite3_exec() callback function is the number of columns in the result. The 3rd argument to the sqlite3_exec() callback is an array of pointers to strings obtained as if from &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, one for each column. If an element of a result row is NULL then the corresponding string pointer for the sqlite3_exec() callback is a NULL pointer. The 4th argument to the sqlite3_exec() callback is an array of pointers to strings where each entry represents the name of corresponding result column as obtained from &lt;a href=&quot;column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_exec（）コールバック関数の2番目の引数は、結果の列の数です。sqlite3_exec（）コールバックに第3引数からかのようにして得られた文字列へのポインタの配列である&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text（） &lt;/a&gt;、各列に対して1つ。結果行の要素がNULLの場合、sqlite3_exec（）コールバックに対応する文字列ポインターはNULLポインターです。sqlite3_exec（）コールバックの4番目の引数は文字列へのポインターの配列で、各エントリは&lt;a href=&quot;column_name&quot;&gt;sqlite3_column_name（）&lt;/a&gt;から取得した対応する結果列の名前を表します。</target>
        </trans-unit>
        <trans-unit id="1fbe9436fd9db92826bf0f5761a30ba124b84870" translate="yes" xml:space="preserve">
          <source>The 31 result codes are &lt;a href=&quot;c3ref/c_abort&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="translated">31個の結果コードは&lt;a href=&quot;c3ref/c_abort&quot;&gt;sqlite3.h&lt;/a&gt;で定義されており、以下にアルファベット順にリストされています。</target>
        </trans-unit>
        <trans-unit id="de71717ad00d5c6da7753059b7611f9841b1d459" translate="yes" xml:space="preserve">
          <source>The 32-bit integer value P1 is written into register P2.</source>
          <target state="translated">32ビットの整数値P1がレジスタP2に書き込まれる。</target>
        </trans-unit>
        <trans-unit id="0fa6dc01b797fc02e2f48692d3a39f9204d77ab0" translate="yes" xml:space="preserve">
          <source>The 32-bit unsigned integer at offset 128 in the WAL-index header is called the &quot;nBackfill&quot;. this field holds the number of frames in the WAL file which have been copied back into the main database.</source>
          <target state="translated">WAL-indexヘッダのオフセット128にある32ビット符号なし整数を &quot;nBackfill &quot;と呼びます。</target>
        </trans-unit>
        <trans-unit id="e3de01c332227a39275dbc5888bb606fa2949671" translate="yes" xml:space="preserve">
          <source>The 32-bit unsigned integer at offset 16 (and repeated at offset 64) is the number of valid frames in the WAL. Because WAL frame are numbered starting with 1, mxFrame is also the index of the last valid commit frame in the WAL. A commit frame is a frame that has a non-zero &quot;size of database&quot; value in bytes 4 through 7 of the frame header, and that indicates the end of a transaction.</source>
          <target state="translated">オフセット16の32ビット符号なし整数(オフセット64で繰り返される)は、WAL内の有効なフレーム数です。WALフレームには1から始まる番号が付けられているので、mxFrameはWAL内の最後の有効なコミットフレームのインデックスでもあります。コミットフレームは、フレームヘッダのバイト4〜7に0以外の「データベースのサイズ」値を持ち、トランザクションの終了を示すフレームである。</target>
        </trans-unit>
        <trans-unit id="ae0f85b04e7fa9cc6d6fac1b8bbc475f7f896833" translate="yes" xml:space="preserve">
          <source>The 35% figure is based on running tests on every machine that the author has easily at hand. Some reviewers of this article report that SQLite has higher latency than direct I/O on their systems. We do not yet understand the difference. We also see indications that SQLite does not perform as well as direct I/O when experiments are run using a cold filesystem cache.</source>
          <target state="translated">35%という数字は、筆者が簡単に手元にあるすべてのマシンでテストを実行したことに基づいています。この記事のレビュアーの中には、自分のシステムではSQLiteの方が直接I/Oよりも高いレイテンシを持っていると報告している人もいます。私たちはまだその違いを理解していません。また、コールドファイルシステムキャッシュを使用して実験を実行した場合、SQLiteは直接I/Oほどの性能を発揮しないという兆候も見られます。</target>
        </trans-unit>
        <trans-unit id="99484295a38d44d61a5164088be45dfe447bd6fb" translate="yes" xml:space="preserve">
          <source>The 3rd parameter of the built-in SUBSTR() function is now optional.</source>
          <target state="translated">組み込みの SUBSTR()関数の 3 番目のパラメータがオプションになりました。</target>
        </trans-unit>
        <trans-unit id="b03a25a4d8213505aa58b43a2a9ec61a89d8bd66" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 28 into the header stores the size of the database file in pages. If this in-header datasize size is not valid (see the next paragraph), then the database size is computed by looking at the actual size of the database file. Older versions of SQLite ignored the in-header database size and used the actual file size exclusively. Newer versions of SQLite use the in-header database size if it is available but fall back to the actual file size if the in-header database size is not valid.</source>
          <target state="translated">ヘッダのオフセット28にある4バイトのビッグエンディアン整数は、データベースファイルのサイズをページ単位で格納します。このヘッダ内データサイズが有効でない場合(次の段落を参照)、データベースのサイズはデータベースファイルの実際のサイズを見て計算されます。古いバージョンのSQLiteでは、ヘッダ内データベースサイズを無視して、実際のファイルサイズのみを使用していました。新しいバージョンのSQLiteでは、ヘッダ内データベースサイズが利用可能な場合はヘッダ内データベースサイズを使用しますが、ヘッダ内データベースサイズが有効でない場合は実際のファイルサイズに戻ります。</target>
        </trans-unit>
        <trans-unit id="ef2a0b06932c2dcd259f9b038635b5911a22f5bb" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 56 determines the encoding used for all text strings stored in the database. A value of 1 means UTF-8. A value of 2 means UTF-16le. A value of 3 means UTF-16be. No other values are allowed. The sqlite3.h header file defines C-preprocessor macros SQLITE_UTF8 as 1, SQLITE_UTF16LE as 2, and SQLITE_UTF16BE as 3, to use in place of the numeric codes for the text encoding.</source>
          <target state="translated">オフセット56にある4バイトのビッグエンディアン整数は、データベースに格納されているすべてのテキスト文字列に使用されるエンコーディングを決定します。値 1 は UTF-8 を意味します。値 2 は UTF-16le を意味します。3 の値は UTF-16be を意味します。それ以外の値は許されません。sqlite3.hヘッダファイルでは、テキストエンコーディングの数値コードの代わりに使用するCプリプロセッサマクロSQLITE_UTF8を1、SQLITE_UTF16LEを2、SQLITE_UTF16BEを3として定義しています。</target>
        </trans-unit>
        <trans-unit id="59780a9139eaaa69dc8ff8373215df2d27399d4a" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 60 is the user version which is set and queried by the &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt;. The user version is not used by SQLite.</source>
          <target state="translated">オフセット60の4バイトのビッグエンディアン整数は、&lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_versionプラグマ&lt;/a&gt;によって設定および照会されるユーザーバージョンです。ユーザーバージョンはSQLiteでは使用されません。</target>
        </trans-unit>
        <trans-unit id="b59b6e739385a58f0bfd59ff19b74ae1c97b3ca9" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 68 is an &quot;Application ID&quot; that can be set by the &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; command in order to identify the database as belonging to or associated with a particular application. The application ID is intended for database files used as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;. The application ID can be used by utilities such as &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file(1)&lt;/a&gt; to determine the specific file type rather than just reporting &quot;SQLite3 Database&quot;. A list of assigned application IDs can be seen by consulting the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt; file in the SQLite source repository.</source>
          <target state="translated">オフセット68の4バイトのビッグエンディアン整数は「アプリケーションID」であり、&lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt;コマンドで設定して、データベースを特定のアプリケーションに属している、または関連付けられているものとして識別できます。アプリケーションIDは、&lt;a href=&quot;appfileformat&quot;&gt;アプリケーションファイル形式&lt;/a&gt;として使用されるデータベースファイルを対象としています。アプリケーションIDを&lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file（1）&lt;/a&gt;などのユーティリティで使用して、「SQLite3データベース」を報告するだけでなく、特定のファイルタイプを判別できます。割り当てられたアプリケーションIDのリストは、SQLiteソースリポジトリの&lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt;ファイルを参照することで確認できます。</target>
        </trans-unit>
        <trans-unit id="07f0a53720eada7bca96ab5b1af017ecee35257f" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 96 stores the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; value for the SQLite library that most recently modified the database file. The 4-byte big-endian integer at offset 92 is the value of the &lt;a href=&quot;fileformat2#chngctr&quot;&gt;change counter&lt;/a&gt; when the version number was stored. The integer at offset 92 indicates which transaction the version number is valid for and is sometimes called the &quot;version-valid-for number&quot;.</source>
          <target state="translated">オフセット96の4バイトのビッグエンディアン整数は、データベースファイルを最後に変更したSQLiteライブラリの&lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;値を格納します。オフセット92の4バイトのビッグエンディアン整数は、バージョン番号が格納されたときの&lt;a href=&quot;fileformat2#chngctr&quot;&gt;変更カウンターの&lt;/a&gt;値です。オフセット92の整数は、バージョン番号が有効なトランザクションを示し、「version-valid-for番号」と呼ばれることもあります。</target>
        </trans-unit>
        <trans-unit id="b2d1137ce6ac9536674089958f7183c5cef074dd" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian signed integer at offset 48 is the suggested cache size in pages for the database file. The value is a suggestion only and SQLite is under no obligation to honor it. The absolute value of the integer is used as the suggested size. The suggested cache size can be set using the &lt;a href=&quot;pragma#pragma_default_cache_size&quot;&gt;default_cache_size pragma&lt;/a&gt;.</source>
          <target state="translated">オフセット48の4バイトのビッグエンディアン符号付き整数は、データベースファイルの推奨キャッシュサイズ（ページ単位）です。値は提案にすぎず、SQLiteはそれを尊重する義務を負いません。整数の絶対値が推奨サイズとして使用されます。推奨されるキャッシュサイズは、&lt;a href=&quot;pragma#pragma_default_cache_size&quot;&gt;default_cache_sizeプラグマ&lt;/a&gt;を使用して設定できます。</target>
        </trans-unit>
        <trans-unit id="4a28f7f4f27954a38f3fd9a37598b5ec1312b94e" translate="yes" xml:space="preserve">
          <source>The 61 extended result codes are &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="translated">61個の拡張結果コードは&lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;sqlite3.h&lt;/a&gt;で定義されており、以下にアルファベット順にリストされています。</target>
        </trans-unit>
        <trans-unit id="7632ae3463f74e8bc40ebd99c8e14ebcad0e1acf" translate="yes" xml:space="preserve">
          <source>The 8 or 12 byte b-tree page header</source>
          <target state="translated">8 バイトまたは 12 バイトの b-tree ページヘッダ</target>
        </trans-unit>
        <trans-unit id="f5b2d0b06ac8eecacdf1f9fc8ceb4463be132806" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; flag means the file should be deleted when it is closed. The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; will be set for TEMP databases and their journals, transient databases, and subjournals.</source>
          <target state="translated">&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSEの&lt;/a&gt;フラグは、それが閉じているときに、ファイルが削除されるべきであることを意味します。&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSEは、&lt;/a&gt; TEMPデータベースとそのジャーナル、過渡データベース、およびsubjournalsのために設定されます。</target>
        </trans-unit>
        <trans-unit id="113a719d1e8937c17801bea84f7fbfbe80a9d62b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; flag is always used in conjunction with the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; flag, which are both directly analogous to the O_EXCL and O_CREAT flags of the POSIX open() API. The SQLITE_OPEN_EXCLUSIVE flag, when paired with the SQLITE_OPEN_CREATE, is used to indicate that file should always be created, and that it is an error if it already exists. It is</source>
          <target state="translated">&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt;フラグは常にと一緒に使用される&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATEの&lt;/a&gt;両方POSIXオープン（）APIのO_EXCLとO_CREATフラグに直接類似しているフラグ。SQLITE_OPEN_EXCLUSIVEフラグは、SQLITE_OPEN_CREATEと組み合わせて使用​​すると、ファイルを常に作成する必要があること、およびファイルがすでに存在する場合はエラーであることを示します。です</target>
        </trans-unit>
        <trans-unit id="81aa4d01093839a3328717a25027872953f919a8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; C preprocessor macro in the sqlite3.h header evaluates to a string literal that is the SQLite version in the format &quot;X.Y.Z&quot; where X is the major version number (always 3 for SQLite3) and Y is the minor version number and Z is the release number. The &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; C preprocessor macro resolves to an integer with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the same numbers used in &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;. The SQLITE_VERSION_NUMBER for any given release of SQLite will also be larger than the release from which it is derived. Either Y will be held constant and Z will be incremented or else Y will be incremented and Z will be reset to zero.</source>
          <target state="translated">sqlite3.hヘッダーの&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; Cプリプロセッサマクロは、「XYZ」形式のSQLiteバージョンである文字列リテラルに評価されます。Xはメジャーバージョン番号（SQLite3の場合は常に3）、Yはマイナーバージョン番号、Zはリリース番号。&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; Cプリプロセッサ値を有する整数マクロ解決さ（X * 1000000 + Y&amp;times;1000 + Z）X、Y、及びZは、で使用したのと同じ数である&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;。 SQLiteの特定のリリースのSQLITE_VERSION_NUMBERは、それが派生したリリースよりも大きくなります。 Yが一定に保持され、Zがインクリメントされるか、Yがインクリメントされ、Zがゼロにリセットされます。</target>
        </trans-unit>
        <trans-unit id="f3c03446112462ee2b9d55caa1b76200b09c27b3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#dbsqlfuzz&quot;&gt;&lt;b&gt;dbsqlfuzz&lt;/b&gt;&lt;/a&gt; engine is a proprietary fuzz tester. Other &lt;a href=&quot;testing#fuzztesting&quot;&gt;fuzzers for SQLite&lt;/a&gt; mutate either the SQL inputs or the database file. Dbsqlfuzz mutates both the SQL and the database file at the same time, and is thus able to reach new error states. Dbsqlfuzz is built using the &lt;a href=&quot;http://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt; framework of LLVM with a custom mutator. Starting from 236 seed files, the dbsqlfuzz fuzzer has examined many tens of millions of mutations, resulting in 63493 distinct test cases that form the basis of each new fuzzing session. Dbsqlfuzz helps ensure that SQLite is robust against attack via malicious SQL or database inputs.</source>
          <target state="translated">&lt;a href=&quot;#dbsqlfuzz&quot;&gt;&lt;b&gt;dbsqlfuzzの&lt;/b&gt;&lt;/a&gt;エンジンは、独自のファズ・テスターです。&lt;a href=&quot;testing#fuzztesting&quot;&gt;SQLiteの&lt;/a&gt;他のファザーは、SQL入力またはデータベースファイルのいずれかを変更します。Dbsqlfuzzは、SQLとデータベースファイルの両方を同時に変更するため、新しいエラー状態に到達できます。Dbsqlfuzzは、カスタムミューテーターを備えたLLVMの&lt;a href=&quot;http://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt;フレームワークを使用して構築されています。236個のシードファイルから始めて、dbsqlfuzzファザーは数千万の突然変異を調べ、新しいファジングセッションごとの基礎を形成する63493個の異なるテストケースをもたらしました。Dbsqlfuzzは、SQLiteが悪意のあるSQLまたはデータベース入力を介した攻撃に対して堅牢であることを保証するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="f1c75916c07cfb8eae73aa66b68a34bf29c22777" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; pointer D in a call to &lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt(D,S)&lt;/a&gt; must refer to an open database connection and in particular must not be a NULL pointer.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;の呼び出しでポインタD &lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt（D、S）は&lt;/a&gt;、オープンデータベース接続を参照し、特定する必要があり、NULLポインタであってはなりません。</target>
        </trans-unit>
        <trans-unit id="5bf64bb75c15b60e54d733e7fb04737bfbdcc130" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object itself is partially threadsafe. Multiple threads may safely make multiple concurrent calls to sqlite3_backup_step(). However, the sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs are not strictly speaking threadsafe. If they are invoked at the same time as another thread is invoking sqlite3_backup_step() it is possible that they return invalid values.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;オブジェクト自体は、部分的にスレッドセーフです。複数のスレッドがsqlite3_backup_step（）への複数の同時呼び出しを安全に行うことができます。ただし、sqlite3_backup_remaining（）およびsqlite3_backup_pagecount（）APIは厳密にはスレッドセーフではありません。別のスレッドがsqlite3_backup_step（）を呼び出しているときに同時に呼び出された場合、無効な値を返す可能性があります。</target>
        </trans-unit>
        <trans-unit id="7b899c2433d199dbb7815bdf0ba2afb729910cf1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_zeroblob()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; interfaces and the built-in &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; SQL function may be used to create a zero-filled blob to read or write using the incremental-blob interface.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_zeroblob（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_zeroblob（）&lt;/a&gt;インターフェースと内蔵&lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblobの&lt;/a&gt; SQL関数は、読み取りまたはインクリメンタルブロブインタフェースを使用して書き込むためのゼロ充填BLOBを作成するために使用されてもよいです。</target>
        </trans-unit>
        <trans-unit id="243b1f5a94daea2d7cb3ce8a6e46d2fc0337bddb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; interface unregisters the initialization routine X that was registered using a prior call to &lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension(X)&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; routine returns 1 if initialization routine X was successfully unregistered and it returns 0 if X was not on the list of initialization routines.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension（X）&lt;/a&gt;インターフェースが前の呼び出し使用して登録された初期化ルーチンX登録解除&lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension（X）を&lt;/a&gt;。&lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension（X）&lt;/a&gt;初期化ルーチンXであれば、リターン1が正常に登録解除されたとXは、初期化ルーチンのリストに載っていなかった場合には0を返します。</target>
        </trans-unit>
        <trans-unit id="4d9c76fa5b1b1ce93415a995c6d4d84ffeb6d357" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;, ...) interface can register an alternative page cache implementation by passing in an instance of the sqlite3_pcache_methods2 structure. In many applications, most of the heap memory allocated by SQLite is used for the page cache. By implementing a custom page cache using this API, an application can better control the amount of memory consumed by SQLite, the way in which that memory is allocated and released, and the policies used to determine exactly which parts of a database file are cached and for how long.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;、...）インタフェースはsqlite3_pcache_methods2構造体のインスタンスを渡すことによって、代替ページキャッシュの実装を登録することができます。多くのアプリケーションでは、SQLiteによって割り当てられたヒープメモリのほとんどがページキャッシュに使用されます。このAPIを使用してカスタムページキャッシュを実装することにより、アプリケーションは、SQLiteによって消費されるメモリの量、そのメモリの割り当てと解放の方法、およびデータベースファイルのどの部分をキャッシュするかを正確に決定するために使用されるポリシーをより適切に制御できます。どれだけの時間。</target>
        </trans-unit>
        <trans-unit id="5d45a04d8212fde9c0874120a3960331ca779f2b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface makes a direct call to the xFileControl method for the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object associated with a particular database identified by the second argument. The name of the database is &quot;main&quot; for the main database or &quot;temp&quot; for the TEMP database, or the name that appears after the AS keyword for databases that are added using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL command. A NULL pointer can be used in place of &quot;main&quot; to refer to the main database file. The third and fourth parameters to this routine are passed directly through to the second and third parameters of the xFileControl method. The return value of the xFileControl method becomes the return value of this routine.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;インターフェースがためxFileControlメソッドを直接呼び出すことができる&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methodsが&lt;/a&gt;二番目の引数によって識別される特定のデータベースに関連付けられたオブジェクトを。データベースの名前は、メインデータベースの場合は「main」、TEMPデータベースの場合は「temp」、または&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQLコマンドを使用して追加されたデータベースのASキーワードの後に​​表示される名前です。 「main」の代わりにNULLポインタを使用して、メインデータベースファイルを参照できます。このルーチンの3番目と4番目のパラメーターは、xFileControlメソッドの2番目と3番目のパラメーターに直接渡されます。 xFileControlメソッドの戻り値は、このルーチンの戻り値になります。</target>
        </trans-unit>
        <trans-unit id="1190e60391b896900656c0ed0c45b80a24b61942" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64の&lt;/a&gt;変数は、Tパラメータは、行の合計数に設定することによって指さX番目のループのすべての反復によって調べ。</target>
        </trans-unit>
        <trans-unit id="68df0918aa353458edcd2a2adfa1d6ea97cffd5f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64の&lt;/a&gt;変数は、TパラメータがX番目のループが実行された回数の合計数に設定することによって指さ。</target>
        </trans-unit>
        <trans-unit id="a4d4c03ef6c7fed4df5e7b2b60cea13e3845bb99" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt;変数はVパラメータによって指される行の合計数に設定されるX番目のループのすべての反復によって調べ。</target>
        </trans-unit>
        <trans-unit id="950c7d09e714f7025b91b049ed110aaf3de8d496" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64の&lt;/a&gt;Vパラメータによって指される変数がX番目のループが実行された回数の合計数に設定されます。</target>
        </trans-unit>
        <trans-unit id="5e18bfb46029f881a46fabedb7acfaf5c4cc5dda" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; interface writes a message into the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; established by the &lt;a href=&quot;#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; option to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt;. If logging is enabled, the zFormat string and subsequent arguments are used with &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to generate the final output string.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log（）&lt;/a&gt;インタフェースは、にメッセージを書き込み&lt;a href=&quot;errlog&quot;&gt;、エラー・ログ&lt;/a&gt;によって確立された&lt;a href=&quot;#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt;にオプション&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（） &lt;/a&gt;。ログが有効になっている場合、zFormat文字列と後続の引数が&lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf（）で&lt;/a&gt;使用され、最終的な出力文字列が生成されます。</target>
        </trans-unit>
        <trans-unit id="a8d3a9c5e86973d6925c26336eb4b86036d70cb6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; routine returns the number of bytes of memory currently outstanding (malloced but not freed). The &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; routine returns the maximum value of &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; since the high-water mark was last reset. The values returned by &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; include any overhead added by SQLite in its implementation of &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, but not overhead added by the any underlying system library routines that &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; may call.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;リターンするメモリのバイト数は、現在未解決（mallocさが、解放されません）。&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;リターンの最大値&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;ハイウォーターマークが最後にリセットされたからです。返される値&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater（）は&lt;/a&gt;、任意のオーバーヘッドの実装でのSQLiteによって追加挙げ&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;が、オーバーヘッドこと任意の基礎となるシステム・ライブラリ・ルーチンによって追加されない&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="dc30f41b86e312b265eb4e71d4d9a6acf99b0d1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; interface takes a single argument which is one of these integer constants.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;インターフェースは、これらの整数の定数のいずれかである単一の引数を取ります。</target>
        </trans-unit>
        <trans-unit id="895178f8a3d57626d41012b259bf092ebaa065ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count(D)&lt;/a&gt; interface returns the number of columns in the row that is being inserted, updated, or deleted.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count（D）&lt;/a&gt;インターフェースは、挿入、更新、または削除されている列の列数を返します。</target>
        </trans-unit>
        <trans-unit id="92f98e455bc2921056f5d6b0ffb541ab9df1ffaf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth(D)&lt;/a&gt; interface returns 0 if the preupdate callback was invoked as a result of a direct insert, update, or delete operation; or 1 for inserts, updates, or deletes invoked by top-level triggers; or 2 for changes resulting from triggers called by top-level triggers; and so forth.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth（D）&lt;/a&gt;戻り0インターフェイス更新前コールバックは、直接挿入、更新、または削除操作の結果として呼び出された場合。または、トップレベルのトリガーによって呼び出される挿入、更新、または削除の場合は1。または2は、トップレベルのトリガーによって呼び出されたトリガーから生じる変更です。など。</target>
        </trans-unit>
        <trans-unit id="e08d4a7c0ce7457f9dab2dfa8af96af8deafb79d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; interface registers a callback function that is invoked prior to each &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operation on a database table. At most one preupdate hook may be registered at a time on a single &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;; each call to &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; overrides the previous setting. The preupdate hook is disabled by invoking &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; with a NULL pointer as the second parameter. The third parameter to &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; is passed through as the first parameter to callbacks.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook（）&lt;/a&gt;インターフェース前各々に呼び出されるコールバック関数を登録する&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;、&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;、および&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;データベーステーブルの動作を制御します。単一の&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;で一度に登録できるpreupdateフックは1つだけです。&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook（）を&lt;/a&gt;呼び出すたびに、以前の設定が上書きされます。 preupdateフックは、2番目のパラメーターとしてNULLポインターを指定して&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook（）&lt;/a&gt;を呼び出すことにより無効になります。&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook（）&lt;/a&gt;の3番目のパラメーターは、最初のパラメーターとしてコールバックに渡されます。</target>
        </trans-unit>
        <trans-unit id="76ad44c525d8f71caf7bed2b7e946c3d8c4e4d51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row after it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_INSERT and SQLITE_UPDATE preupdate callbacks; if it is used by an SQLITE_DELETE callback then the behavior is undefined. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new（D、N、P）&lt;/a&gt;インタフェースPへのポインタ書き込み&lt;a href=&quot;#sqlite3_value&quot;&gt;保護sqlite3_value&lt;/a&gt;それが更新された後、テーブルの行のN番目の列の値を含みます。 Nパラメータは0から列数よりも1少ない値でなければなりません。そうでない場合、動作は定義されません。これは、SQLITE_INSERTおよびSQLITE_UPDATE事前更新コールバック内でのみ使用する必要があります。 SQLITE_DELETEコールバックによって使用される場合、動作は未定義です。&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;更新前コールバックリターンPポイントが破壊されるすること。</target>
        </trans-unit>
        <trans-unit id="1c708fa87b4305f6c6c7b152f77487e32500d735" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth()&lt;/a&gt; interfaces provide additional information about a preupdate event. These routines may only be called from within a preupdate callback. Invoking any of these routines from outside of a preupdate callback or with a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; pointer that is different from the one supplied to the preupdate callback results in undefined and probably undesirable behavior.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old（） &lt;/a&gt;、&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new（） &lt;/a&gt;、&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count（） &lt;/a&gt;、及び&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth（）&lt;/a&gt;インターフェースは、更新前のイベントに関する追加情報を提供します。これらのルーチンは、更新前のコールバック内からのみ呼び出すことができます。これらのルーチンのいずれかを事前更新コールバックの外部から、または事前更新コールバックに提供されたものとは異なる&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;ポインターで呼び出すと、未定義の、おそらく望ましくない動作が発生します。</target>
        </trans-unit>
        <trans-unit id="62645acd92fc3d494d833d1a2acf99fc550b25a1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row before it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_UPDATE and SQLITE_DELETE preupdate callbacks; if it is used by an SQLITE_INSERT callback then the behavior is undefined. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old（D、N、P）&lt;/a&gt;インターフェースはPへのポインタ書き込み&lt;a href=&quot;#sqlite3_value&quot;&gt;保護sqlite3_value&lt;/a&gt;それが更新される前に、テーブルの行のN番目の列の値を含みます。Nパラメータは0から列数よりも1少ない値でなければなりません。そうしないと、動作は定義されません。これは、SQLITE_UPDATEおよびSQLITE_DELETE事前更新コールバック内でのみ使用する必要があります。SQLITE_INSERTコールバックによって使用される場合、動作は未定義です。&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;更新前コールバックリターンPポイントが破壊されるすること。</target>
        </trans-unit>
        <trans-unit id="73b2a32ae166fcb0b54e0a6a66b0c37e428124e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface does not change the values of any &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; on the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（S）&lt;/a&gt;インタフェースは、任意の値が変化しない&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;バインディング&lt;/a&gt;に&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt; S.</target>
        </trans-unit>
        <trans-unit id="24aaeaf525c4a02afa566b3b6fde01711f410b96" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface resets the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S back to the beginning of its program.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（S）&lt;/a&gt;インタフェースがリセットされ&lt;a href=&quot;#sqlite3_stmt&quot;&gt;、準備されたステートメントは、&lt;/a&gt;そのプログラムの先頭に戻るS。</target>
        </trans-unit>
        <trans-unit id="5ec7f66ae2478b5bf1fba7004c6f9eca0c47bbe3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;authorizer callback function&lt;/a&gt; must return either &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; or one of these two constants in order to signal SQLite whether or not the action is permitted. See the &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;authorizer documentation&lt;/a&gt; for additional information.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;承認者のコールバック関数は、&lt;/a&gt;いずれかを返す必要があり&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;アクションが許可されているか否かのSQLiteを通知するために、またはこれら2つの定数のいずれか。追加情報については、&lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;承認者のドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="de889cb07b2c7dd83d04327e082d9b8afd75421b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface registers a callback function that is invoked to authorize certain SQL statement actions. The second parameter to the callback is an integer code that specifies what action is being authorized. These are the integer action codes that the authorizer callback may be passed.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;インタフェースは、特定のSQLステートメントアクションを認可するために呼び出されるコールバック関数を登録します。コールバックの2番目のパラメーターは、どのアクションが許可されているかを指定する整数コードです。これらは、オーソライザーコールバックが渡される整数のアクションコードです。</target>
        </trans-unit>
        <trans-unit id="b20fbf1dd1eb586565d476c6ea4477e75271549a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object returned from a successful call to &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; must be freed using &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; to avoid a memory leak.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshotの&lt;/a&gt;に成功した呼び出しから返されたオブジェクト&lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;（）sqlite3_snapshot_getを&lt;/a&gt;使用して解放しなければならない&lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_freeを（）&lt;/a&gt;メモリリークを避けるために。</target>
        </trans-unit>
        <trans-unit id="775754ed627fe2a2cc8e3c07dc04d7c2771ef634" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; interface is only available when the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free（）&lt;/a&gt;ときインタフェースにのみ利用可能である&lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt;コンパイル時のオプションが使用されます。</target>
        </trans-unit>
        <trans-unit id="14be7fcf3129f0807a23ee14219023eee52d1a02" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free(P)&lt;/a&gt; interface destroys &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P. The application must eventually free every &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object using this routine to avoid a memory leak.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free（P）&lt;/a&gt;インターフェース破棄&lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P.アプリケーションは、最終的にすべての解放する必要があります&lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshotの&lt;/a&gt;メモリリークを避けるために、このルーチンを使用してオブジェクトを。</target>
        </trans-unit>
        <trans-unit id="3c246e9ef7aa9d8e18a838b47761936cd8a2acc5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; interface is only available when the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get（）&lt;/a&gt;ときインタフェースにのみ利用可能である&lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt;コンパイル時のオプションが使用されます。</target>
        </trans-unit>
        <trans-unit id="2146a577e5e49a77b490e29aca2d82e371ec702c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface attempts to make a new &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object that records the current state of schema S in database connection D. On success, the &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface writes a pointer to the newly created &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object into *P and returns SQLITE_OK. If there is not already a read-transaction open on schema S when this function is called, one is opened automatically.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get（D、S、P）&lt;/a&gt;新しいするためのインタフェース試み&lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshotの&lt;/a&gt;データベース接続D.オン成功のスキーマSの現在の状態を記録するオブジェクトを、&lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get（D、S、P）&lt;/a&gt;インターフェースは、新しく作成されたポインタを書き込みます。&lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt;オブジェクトを* Pに入れ、SQLITE_OKを返します。この関数が呼び出されたときにスキーマSで開いている読み取りトランザクションがまだない場合は、自動的に開きます。</target>
        </trans-unit>
        <trans-unit id="efd7fc3c3c9a64e738f23c02f6e6fbe25f03ae8e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface is only available when the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;ときインタフェースにのみ利用可能である&lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt;コンパイル時のオプションが使用されます。</target>
        </trans-unit>
        <trans-unit id="b4e3c98131317b43afc18d358e2869af93b46671" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; interface either starts a new read transaction or upgrades an existing one for schema S of &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D such that the read transaction refers to historical &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;snapshot&lt;/a&gt; P, rather than the most recent change to the database. The &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface returns SQLITE_OK on success or an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if it fails.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open（D、S、P）&lt;/a&gt;インタフェースのいずれかが新しいリードトランザクションを開始またはスキーマSのための既存のものをアップグレード&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;リードトランザクション履歴を意味するように、D &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;スナップショット&lt;/a&gt;ではなく、データベースへの最新の変化より、P。&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;インターフェースは、成功または適切にSQLITE_OKを返し&lt;a href=&quot;rescode&quot;&gt;、エラーコード&lt;/a&gt;が失敗した場合。</target>
        </trans-unit>
        <trans-unit id="83d565fd5c1ee3cccc1b5c10ce8ef575521cca40" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_append(X,S,N)&lt;/a&gt; method appends exactly N bytes from string S onto the end of the &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X. N must be non-negative. S must contain at least N non-zero bytes of content. To append a zero-terminated string in its entirety, use the &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall()&lt;/a&gt; method instead.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_append（X、S、N）&lt;/a&gt;方法Nはの端部に弦Sからのバイト正確付加&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;オブジェクトX. Nは非負でなければなりません。Sには、少なくともNバイトの非ゼロバイトのコンテンツが含まれている必要があります。ゼロで終了する文字列全体を追加するには、代わりに&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall（）&lt;/a&gt;メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="6917c29880e6eab55b32466b3048653ea9692486" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall(X,S)&lt;/a&gt; method appends the complete content of zero-terminated string S onto the end of &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall（X、S）&lt;/a&gt;メソッドは、の最後にゼロで終わる文字列Sの完全な内容を付加&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;オブジェクトX.</target>
        </trans-unit>
        <trans-unit id="8658941f24fcaee032cb73b6958282aac488a0c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendchar(X,N,C)&lt;/a&gt; method appends N copies of the single-byte character C onto the end of &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X. This method can be used, for example, to add whitespace indentation.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendchar（X、N、C）&lt;/a&gt;の方法は、端部に単一バイト文字CのN個のコピーを付加&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;この方法は、空白インデントを追加するために、例えば、使用することができるオブジェクトX.。</target>
        </trans-unit>
        <trans-unit id="5cf4ff61e78e32620c83211a0d5e1e3795abc7df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf(X,F,...)&lt;/a&gt; and &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_vappendf(X,F,V)&lt;/a&gt; interfaces uses the &lt;a href=&quot;printf&quot;&gt;built-in printf&lt;/a&gt; functionality of SQLite to append formatted text onto the end of &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf（X、F、...）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_vappendf（X、F、V）&lt;/a&gt;インターフェイスが使用&lt;a href=&quot;printf&quot;&gt;内蔵のprintf&lt;/a&gt;のSQLiteの機能の最後にフォーマットされたテキストを追加する&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;オブジェクトX.</target>
        </trans-unit>
        <trans-unit id="efc22c6c47d48b515ed10c7b3b7ca6cc54142437" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_reset(X)&lt;/a&gt; method resets the string under construction inside &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X back to zero bytes in length.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_reset（X）&lt;/a&gt;メソッドは、内部構造の下列リセット&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;長さはゼロバイトにオブジェクトXのバック。</target>
        </trans-unit>
        <trans-unit id="7f1ec747ece71d77c655f9a07fae8cab37f0a797" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; method returns the current length, in bytes, of the dynamic string under construction in &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X. The length returned by &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; does not include the zero-termination byte.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length（X）&lt;/a&gt;メソッドは、建設中の動的な列のバイト単位の現在の長さを返し&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;によって返される長さオブジェクトX. &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length（X）が&lt;/a&gt;ゼロ終端バイトを含みません。</target>
        </trans-unit>
        <trans-unit id="abad991ae0af361a9313d8cfba4c5223a9d4a389" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; method returns a pointer to the current content of the dynamic string under construction in X. The value returned by &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; is managed by the sqlite3_str object X and might be freed or altered by any subsequent method on the same &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object. Applications must not used the pointer returned &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; after any subsequent method call on the same object. Applications may change the content of the string returned by &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; as long as they do not write into any bytes outside the range of 0 to &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; and do not read or write any byte after any subsequent sqlite3_str method call.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value（X）&lt;/a&gt;メソッドは、によって返される値Xに建設動的文字列の現在の内容へのポインタを返す&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value（X）は&lt;/a&gt; sqlite3_strオブジェクトXによって管理され、同じ上の任意の後続の方法によって解放または変更されるかもしれません&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;オブジェクト。アプリケーションは、同じオブジェクトに対する後続のメソッド呼び出しの後に返されるポインター&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value（X）を&lt;/a&gt;使用してはなりません。アプリケーションは、0から&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length（X）&lt;/a&gt;の範囲外のバイトに書き込みを行わず、後続のsqlite3_strメソッド呼び出しの後にバイトを読み書きしない限り、&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value（X）&lt;/a&gt;によって返される文字列の内容を変更できます。</target>
        </trans-unit>
        <trans-unit id="9ed76b8571c1160c10dee5527b0d46210f6deae9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; that contains the constructed string. The calling application should pass the returned value to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; to avoid a memory leak. The &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface may return a NULL pointer if any errors were encountered during construction of the string. The &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface will also return a NULL pointer if the string in &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X is zero bytes long.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish（X）&lt;/a&gt;インタフェースはsqlite3_strオブジェクトXとリターンから得られたバッファメモリへのポインタ破壊&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;構築文字列を含みます。呼び出し元のアプリケーションは、メモリリークを回避するために、戻り値を&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;に渡す必要があります。&lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish（X）&lt;/a&gt;エラーがストリングの構築中に遭遇した場合のインタフェースは、NULLポインタを返すことができます。&lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish（X）&lt;/a&gt;の文字列場合インターフェイスもNULLポインタを戻します&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;オブジェクトXがゼロバイト長です。</target>
        </trans-unit>
        <trans-unit id="1a8bb7e6f2617ebce878cf41863558873c56dd1a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface allocates and initializes a new &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object. To avoid memory leaks, the object returned by &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt; must be freed by a subsequent call to &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（D）&lt;/a&gt;界面割り当て及び新しい初期化&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_strの&lt;/a&gt;オブジェクト。メモリリークを回避するには、&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;によって返されたオブジェクトを&lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish（X）&lt;/a&gt;への後続の呼び出しで解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="283dcdc6097ac99a155d31e274b76b664e287d7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface always returns a pointer to a valid &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object, though in the event of an out-of-memory error the returned object might be a special singleton that will silently reject new text, always return SQLITE_NOMEM from &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode()&lt;/a&gt;, always return 0 for &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length()&lt;/a&gt;, and always return NULL from &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;. It is always safe to use the value returned by &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; as the sqlite3_str parameter to any of the other &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; methods.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_new&quot;&gt;（D）sqlite3_str_new&lt;/a&gt;インターフェイスは常に有効にポインタを返す&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_strの&lt;/a&gt;メモリ不足エラーが発生した場合に返されるオブジェクトは黙って新しいテキストを拒否します、常にからSQLITE_NOMEMを返す特殊なシングルトンかもしれませんが、オブジェクトを&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode（）&lt;/a&gt;、常に&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length（）&lt;/a&gt;に対して0を返し、常に&lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish（X）&lt;/a&gt;からNULLを返します。&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（D）&lt;/a&gt;によって返された値を、他の&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;メソッドのsqlite3_strパラメータとして使用することは常に安全です。</target>
        </trans-unit>
        <trans-unit id="47a765f2716bbd0a7165479eb04c6ad3833cfd2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern P. The definition of &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern matching used in &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; is the same as for the &quot;X GLOB P&quot; operator in the SQL dialect understood by SQLite. The &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; function is case sensitive.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob（P、X）&lt;/a&gt;インタフェース戻る場合にのみ文字列Xが一致する場合ゼロ&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOBの&lt;/a&gt;パターンPの定義&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOBの&lt;/a&gt;に使用されるパターンマッチング&lt;a href=&quot;#sqlite3_strglob&quot;&gt;（P、X）sqlite3_strglobの&lt;/a&gt;中の「X GLOB P」演算子の場合と同じですSQLiteが理解するSQL方言。&lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob（P、X）&lt;/a&gt;関数は、大文字と小文字が区別されます。</target>
        </trans-unit>
        <trans-unit id="95615e5c78fed3ee43eff0e7b082843f593e6a31" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; APIs allow applications and extensions to compare the contents of two buffers containing UTF-8 strings in a case-independent fashion, using the same definition of &quot;case independence&quot; that SQLite uses internally when comparing identifiers.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt; APIは、識別子を比較するときのSQLiteが内部で使用する「ケース・自立」の同じ定義を使用して、アプリケーションや拡張機能は、ケースに依存しない形式でUTF-8文字列を含む二つのバッファの内容を比較することができます。</target>
        </trans-unit>
        <trans-unit id="51d8a3ef92ef4d7b314975584d8072e9206e198e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function matches Unicode characters, though only ASCII characters are case folded.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike（P、X、E）&lt;/a&gt; ASCII文字のみがケースに折り畳まれているものの関数は、Unicode文字に一致します。</target>
        </trans-unit>
        <trans-unit id="485ac31bffb8ac065daf3ba2a8161fbdf5039efd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern P with escape character E. The definition of &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern matching used in &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; is the same as for the &quot;X LIKE P ESCAPE E&quot; operator in the SQL dialect understood by SQLite. For &quot;X LIKE P&quot; without the ESCAPE clause, set the E parameter of &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; to 0. As with the LIKE operator, the &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function is case insensitive - equivalent upper and lower case ASCII characters match one another.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_strlike&quot;&gt;（P、X、E）sqlite3_strlike&lt;/a&gt;インターフェースリターン文字列Xが一致する場合と場合にのみ、ゼロ&lt;a href=&quot;lang_expr#like&quot;&gt;LIKEの&lt;/a&gt;エスケープ文字Eでの定義パターンPを&lt;a href=&quot;lang_expr#like&quot;&gt;LIKEの&lt;/a&gt;に使用されるパターンマッチング&lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike（P、X、Eは）&lt;/a&gt;と同じですSQLiteが理解するSQL方言の「X LIKE P ESCAPE E」演算子。ESCAPE句のない「X LIKE P」の場合、&lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike（P、X、E）&lt;/a&gt;のEパラメータを0 に設定します。LIKE演算子と同様に、&lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike（P、X、E）&lt;/a&gt;関数は大文字と小文字を区別しません-同等の大文字と小文字小文字のASCII文字は互いに一致します。</target>
        </trans-unit>
        <trans-unit id="67cdd83f23b0c9baf88d22cb2f2c082de3577118" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes(D)&lt;/a&gt; interface only reports the number of rows that changed due to SQL statement run against database connection D. Any changes by other database connections are ignored. To detect changes against a database file from other database connections use the &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command or the &lt;a href=&quot;#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file control&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes（D）&lt;/a&gt;インターフェイスは、唯一の他のデータベース接続により、任意の変更は無視され、データベース接続D.に対してSQL文の実行のために変更された行の数を報告します。他のデータベース接続からのデータベースファイルに対する変更を検出するには、&lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt;コマンドまたは&lt;a href=&quot;#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION &lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;ファイルコントロール&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="2dc4153435020e41ac99ab2b5b83d08f27b98c68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint(D,N)&lt;/a&gt; is a wrapper around &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; that causes any database on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to automatically &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; after committing a transaction if there are N or more frames in the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; file. Passing zero or a negative value as the nFrame parameter disables automatic checkpoints entirely.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint（D、N）は&lt;/a&gt;ラッパーです&lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;上の任意のデータベースの原因となる&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;を自動的にD &lt;a href=&quot;wal#ckpt&quot;&gt;のチェックポイント&lt;/a&gt; N以上のフレームがである場合、トランザクションをコミットした後&lt;a href=&quot;wal&quot;&gt;、先行書き込みログ&lt;/a&gt;ファイル。nFrameパラメータとしてゼロまたは負の値を渡すと、自動チェックポイントが完全に無効になります。</target>
        </trans-unit>
        <trans-unit id="9142f5b65b53643523fc33889c4ba6acff8188e5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; function is used to register a callback that is invoked each time data is committed to a database in wal mode.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;関数は、WALモードでデータベースにコミットされるたびにデータが呼び出されるコールバックを登録するために使用されます。</target>
        </trans-unit>
        <trans-unit id="fdbc2004b6063417b2874cd07563f5073fb2461b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connection's busy-handler callback. The argument is of type (void**) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connection's busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLERの&lt;/a&gt;ファイル制御は、それが、接続のビジーハンドラのコールバックへのアクセス権を持つカスタムVFSを提供するために開かれた直後に、データベースのファイルハンドル上のSQLiteによって呼び出すことができます。引数はタイプ（void **）-2つの（void *）値の配列です。最初の（void *）は、実際には型（int（*）（void *））の関数を指しています。接続のビジーハンドラーを呼び出すには、この関数を配列の2番目（void *）を唯一の引数として呼び出す必要があります。ゼロ以外を返す場合は、操作を再試行する必要があります。ゼロが返された場合、カスタムVFSは現在の操作を中止する必要があります。</target>
        </trans-unit>
        <trans-unit id="0804c63302651c02a306eb7ec9ff35797d83276d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connections busy-handler callback. The argument is of type (void **) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connections busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLERの&lt;/a&gt;ファイル制御は、それが接続ビジーハンドラのコールバックへのアクセス権を持つカスタムVFSを提供するために開かれた直後に、データベースのファイルハンドル上のSQLiteによって呼び出すことができます。引数のタイプは（void **）-2つの（void *）値の配列です。最初の（void *）は、実際には（int（*）（void *））型の関数を指します。 connections busy-handlerを呼び出すには、この関数は、配列の2番目（void *）を唯一の引数として呼び出す必要があります。ゼロ以外の値が返された場合、操作を再試行する必要があります。ゼロを返す場合、カスタムVFSは現在の操作を中止する必要があります。</target>
        </trans-unit>
        <trans-unit id="e16ec9bd7cc655e1fcca3234a2d80781961dcf25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE&lt;/a&gt; opcode is used to request that the VFS extends and truncates the database file in chunks of a size specified by the user. The fourth argument to &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; should point to an integer (type int) containing the new chunk-size to use for the nominated database. Allocating database file space in large chunks (say 1MB at a time), may reduce file-system fragmentation and improve performance on some systems.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZEの&lt;/a&gt;オペコードは、VFSが延びており、ユーザによって指定されたサイズのチャンクのデータベースファイルを切り捨てることを要求するために使用されます。&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;の4番目の引数は、指定されたデータベースに使用する新しいチャンクサイズを含む整数（int型）を指す必要があります。データベースファイルスペースを大きなチャンク（一度に1 MBなど）に割り当てると、ファイルシステムの断片化が減少し、一部のシステムのパフォーマンスが向上する場合があります。</target>
        </trans-unit>
        <trans-unit id="55799a140d15462e73ef05abf1db855a8aa627ae" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlckptdone&quot; id=&quot;sqlitefcntlckptdone&quot;&gt;SQLITE_FCNTL_CKPT_DONE&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode after the client has finished copying pages from the wal file to the database file, but before the *-shm file is updated to record the fact that the pages have been checkpointed.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlckptdone&quot; id=&quot;sqlitefcntlckptdone&quot;&gt;SQLITE_FCNTL_CKPT_DONEの&lt;/a&gt;クライアントがデータベースファイルにWALファイルからページのコピーが完了した後に、しかし* -shmファイルはページがチェックポイントされているという事実を記録するために更新される前に、オペコードはWALモードのチェックポイント内から呼び出されます。</target>
        </trans-unit>
        <trans-unit id="23adb4e434c478e58b40c24db57f497a0e6e59c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlckptstart&quot; id=&quot;sqlitefcntlckptstart&quot;&gt;SQLITE_FCNTL_CKPT_START&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode before the client starts to copy pages from the wal file to the database file.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlckptstart&quot; id=&quot;sqlitefcntlckptstart&quot;&gt;SQLITE_FCNTL_CKPT_STARTの&lt;/a&gt;クライアントがデータベースファイルにWALファイルからページをコピーする前オペコードはWALモードのチェックポイント内から呼び出されます。</target>
        </trans-unit>
        <trans-unit id="196a41f980c38337225c4ba413e0b1dc0b2b471a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be performed atomically. This file control returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if and only if the writes were all performed successfully and have been committed to persistent storage. Regardless of whether or not it is successful, this file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITEの&lt;/a&gt;オペコードは、前の呼び出しが成功するため、すべての書き込み操作が発生し&lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;アトミックに実行されます。このファイルコントロールは、書き込みがすべて正常に実行され、永続ストレージにコミットされている場合にのみ、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OKを&lt;/a&gt;返します。成功したかどうかに関係なく、このファイルコントロールはファイル記述子をバッチ書き込みモードから解除するため、後続のすべての書き込み操作は独立しています。 SQLiteは、&lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITEの&lt;/a&gt;呼び出しが成功していない限り、SQLITE_FCNTL_COMMIT_ATOMIC_WRITEを呼び出すことはありません。</target>
        </trans-unit>
        <trans-unit id="ed7c39458516ed31456486d668f266799517f0b4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS after a transaction has been committed immediately but before the database is unlocked. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWOの&lt;/a&gt;オペコードは、SQLiteのが内部で生成され、トランザクションが即座にコミットされた後でも、データベースのロックが解除される前に、VFSに送信されます。この信号を必要としないVFSは、このオペコードを黙って無視する必要があります。アプリケーションは、このオペコードで&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;を呼び出さないでください。呼び出すと、それを必要とする特殊なVFSの操作が中断される可能性があります。</target>
        </trans-unit>
        <trans-unit id="a6067fb898268faa568cf0d8b727509a1e63a822" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provide a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSIONの&lt;/a&gt;オペコードは、データベースファイルへの変更を検出するために使用されます。引数は、32ビットの符号なし整数へのポインターです。ページャの「データバージョン」がポインタに書き込まれます。 「データバージョン」は、対応するデータベースファイルに変更が発生するたびに、同じデータベース接続のSQLステートメントまたは別のデータベース接続によってコミットされたトランザクション（おそらく他のプロセス）によって変更されます。&lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;インターフェースは、接続上の任意のデータベースが変更された場合に検索するために使用することができるが、そのインターフェースTEMPに変化ならびにMAINに応答してのみMAINへの変更を検出するためのメカニズムを提供しません。また、&lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;インターフェイスは内部の変更にのみ応答し、他のデータベース接続によって行われた変更を省略します。&lt;a href=&quot;pragma#pragma_data_version&quot;&gt;プラグマdata_versionの&lt;/a&gt;コマンドは、他のデータベース接続のために起こる単一取り付けデータベースへの変更を検出するためのメカニズムを提供するが、省いは、それが呼び出されたデータベース接続によって実現変化します。このファイルコントロールは、内部または外部で発生し、特定の接続データベースに関連付けられている変更を検出する唯一のメカニズムです。</target>
        </trans-unit>
        <trans-unit id="e9a73ef11b02c7c1ef7f3e1f806173140bf3d029" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provides a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSIONの&lt;/a&gt;オペコードは、データベースファイルへの変更を検出するために使用されます。引数は、32ビットの符号なし整数へのポインタです。ポケットベルの「データバージョン」がポインタに書き込まれます。 「データバージョン」は、同じデータベース接続でのSQLステートメントを通じて、または他のプロセスで別のデータベース接続によってコミットされたトランザクションを通じて、対応するデータベースファイルに変更が発生するたびに変更されます。&lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;インターフェースは、接続上の任意のデータベースが変更された場合に検索するために使用することができるが、そのインターフェースTEMPに変化ならびにMAINに応答してのみMAINへの変更を検出するためのメカニズムを提供しません。また、&lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;インターフェイスは内部の変更にのみ応答し、他のデータベース接続によって行われた変更を省略します。&lt;a href=&quot;pragma#pragma_data_version&quot;&gt;プラグマdata_versionの&lt;/a&gt;コマンドは、他のデータベース接続のために起こる単一取り付けデータベースへの変更を検出するためのメカニズムを提供するが、省いた変化は、それが呼び出されたデータベースに接続することにより実現します。このファイル制御は、内部または外部で発生し、特定の接続されたデータベースに関連付けられている変更を検出する唯一のメカニズムです。</target>
        </trans-unit>
        <trans-unit id="c45a2fa29af05eafc8a58031e6a08762e72b9ebb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with a particular database connection. See also &lt;a href=&quot;#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTERの&lt;/a&gt;オペコードへのポインタ取得するために使用される&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;特定のデータベース接続に関連付けられたオブジェクトを。&lt;a href=&quot;#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="32fc3ec6f9212eb93de60bbea8de22f4f5c0720b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt; file control interprets its argument as a pointer to an integer and it writes a boolean into that integer depending on whether or not the file has been renamed, moved, or deleted since it was first opened.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt;ファイル制御は、整数へのポインタとして引数を解釈し、それがファイルは、名前が変更移動、またはそれが最初に開かれてから削除されたか否かに応じて、その整数にブール値を書き込みます。</target>
        </trans-unit>
        <trans-unit id="961fafabf95f8005cd6aacb0ba427c7a66f5ca95" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with the journal file (either the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; or the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;) for a particular database connection. See also &lt;a href=&quot;#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTERの&lt;/a&gt;オペコードへのポインタ取得するために使用される&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;ジャーナルファイル（のいずれかに関連付けられているオブジェクト&lt;a href=&quot;lockingv3#rollback&quot;&gt;ロールバックジャーナル&lt;/a&gt;または&lt;a href=&quot;wal&quot;&gt;先行書き込みログ&lt;/a&gt;特定のデータベース接続のために）。&lt;a href=&quot;#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="3359a645510d53c409e1e871158229645d3789b4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to write the current state of the lock (one of &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;, &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;, &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt;) into an integer that the pArg argument points to. This capability is used during testing and is only available when the SQLITE_TEST compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATEの&lt;/a&gt;オペコードは、デバッグに使用されます。このオペコードにより、xFileControlメソッドはロックの現在の状態（&lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;、&lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;、&lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;、&lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt;、または&lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_EXCLUSIVEの&lt;/a&gt;いずれか）をpArg引数が指す整数に書き込みます。この機能はテスト中に使用され、SQLITE_TESTコンパイル時オプションが使用されている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="413d8e1b0a9fd900669cb69e73b3dca110ff8c2c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode causes attempts to obtain a file lock using the xLock or xShmLock methods of the VFS to wait for up to M milliseconds before failing, where M is the single unsigned integer parameter.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUTの&lt;/a&gt;オペコードは、Mは、単一の符号なし整数パラメータである、障害の前にMミリ秒まで待つするVFSのXLOCK又はxShmLock方法を使用してファイルのロックを取得しようとする試みを引き起こします。</target>
        </trans-unit>
        <trans-unit id="15909a890c9f03d44aa2dc2921d58c760b545e1a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode is used to configure a VFS to block for up to M milliseconds before failing when attempting to obtain a file lock using the xLock or xShmLock methods of the VFS. The parameter is a pointer to a 32-bit signed integer that contains the value that M is to be set to. Before returning, the 32-bit signed integer is overwritten with the previous value of M.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUTの&lt;/a&gt;オペコードは、VFSのXLOCKまたはxShmLockメソッドを使用してファイルのロックを取得しようとすると失敗する前にMミリ秒までのためにブロックするようにVFSを設定するために使用されます。このパラメーターは、Mが設定される値を含む32ビットの符号付き整数へのポインターです。戻る前に、32ビットの符号付き整数は以前の値のMで上書きされます。</target>
        </trans-unit>
        <trans-unit id="98a69e4da16c0af72de938b51b675221a8706b54" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt; file control is used to query or set the maximum number of bytes that will be used for memory-mapped I/O. The argument is a pointer to a value of type sqlite3_int64 that is an advisory maximum number of bytes in the file to memory map. The pointer is overwritten with the old value. The limit is not changed if the value originally pointed to is negative, and so the current limit can be queried by passing in a pointer to a negative number. This file-control is used internally to implement &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZEの&lt;/a&gt;ファイル制御は、クエリに使用されるか、またはメモリマップドI / Oのために使用されるバイトの最大数を設定されています。引数は、ファイルからメモリマップへの推奨最大バイト数であるsqlite3_int64型の値へのポインターです。ポインタは古い値で上書きされます。最初にポイントされた値が負の場合、制限は変更されないため、負の数へのポインターを渡すことにより、現在の制限を照会できます。このファイル制御は、&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;を実装するために内部的に使用されます。</target>
        </trans-unit>
        <trans-unit id="d526543f15c2ce77f0461ecf7fe44c9004bea17a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE&lt;/a&gt; opcode is invoked by SQLite after opening a write transaction to indicate that, unless it is rolled back for some reason, the entire database file will be overwritten by the current transaction. This is used by VACUUM operations.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITEの&lt;/a&gt;オペコードは、それが何らかの理由でロールバックされていない限り、それを示すために、書き込みトランザクションを開いた後のSQLiteによって呼び出され、データベース全体のファイルは、現在のトランザクションによって上書きされます。これは、VACUUM操作で使用されます。</target>
        </trans-unit>
        <trans-unit id="5ebd2a70a799339bb0872257764cf8c08eda9ecd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; opcode is used to set or query the persistent &lt;a href=&quot;wal&quot;&gt;Write Ahead Log&lt;/a&gt; setting. By default, the auxiliary write ahead log (&lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt;) and shared memory files used for transaction control are automatically deleted when the latest connection to the database closes. Setting persistent WAL mode causes those files to persist after close. Persisting the files is useful when other processes that do not have write permission on the directory containing the database file want to read the database file, as the WAL and shared memory files must exist in order for the database to be readable. The fourth parameter to &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable persistent WAL mode or 1 to enable persistent WAL mode. If the integer is -1, then it is overwritten with the current WAL persistence setting.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;オペコードは、セットまたはクエリ永続的に使用されている&lt;a href=&quot;wal&quot;&gt;先読み書き込みログの&lt;/a&gt;設定。デフォルトでは、データベースへの最新の接続が閉じると、トランザクション制御に使用される補助先読みログ（&lt;a href=&quot;wal#walfile&quot;&gt;WALファイル&lt;/a&gt;）と共有メモリファイルが自動的に削除されます。永続的なWALモードを設定すると、これらのファイルは閉じた後も永続します。データベースを読み取り可能にするにはWALファイルと共有メモリファイルが存在している必要があるため、データベースファイルを含むディレクトリに対する書き込み権限のない他のプロセスがデータベースファイルを読みたい場合、ファイルの永続化が役立ちます。&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;の4番目のパラメーターこのオペコードは整数へのポインタでなければなりません。その整数は、永続的なWALモードを無効にする場合は0、永続的なWALモードを有効にする場合は1です。整数が-1の場合、現在のWAL永続性設定で上書きされます。</target>
        </trans-unit>
        <trans-unit id="fdccf2fe8da7ee0d8c5941a2ea211306829a9588" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode is used to set or query the persistent &quot;powersafe-overwrite&quot; or &quot;PSOW&quot; setting. The PSOW setting determines the &lt;a href=&quot;#SQLITE_IOCAP_ATOMIC&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; bit of the xDeviceCharacteristics methods. The fourth parameter to &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable zero-damage mode or 1 to enable zero-damage mode. If the integer is -1, then it is overwritten with the current zero-damage mode setting.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITEの&lt;/a&gt;オペコードは、セットまたはクエリ永続的な「powersafe-上書き」または「PSOW」の設定に使用されています。PSOW設定は、xDeviceCharacteristicsメソッドの&lt;a href=&quot;#SQLITE_IOCAP_ATOMIC&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt;ビットを決定します。このオペコードの&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;への4番目のパラメーターは、整数へのポインターでなければなりません。その整数は、ゼロダメージモードを無効にする場合は0、ゼロダメージモードを有効にする場合は1です。整数が-1の場合、現在のゼロダメージモード設定で上書きされます。</target>
        </trans-unit>
        <trans-unit id="7f192c2e63c8633453fa1eae93e0c07df64cf07f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU&lt;/a&gt; opcode is implemented by the special VFS used by the RBU extension only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBUの&lt;/a&gt;オペコードだけRBUの拡張子が使用する特殊なVFSによって実装されます。他のすべてのVFSは、このオペコードに対してSQLITE_NOTFOUNDを返す必要があります。</target>
        </trans-unit>
        <trans-unit id="dbf9a50cfd48cde386829709800477dc50bcc565" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be rolled back. This file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITEの&lt;/a&gt;オペコードは、前の呼び出しが成功するため、すべての書き込み操作が発生し&lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;ロールバックします。このファイル制御は、ファイル記述子をバッチ書き込みモードから外し、後続のすべての書き込み操作が独立するようにします。SQLiteは、&lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITEの&lt;/a&gt;呼び出しが成功していない限り、SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITEを呼び出すことはありません。</target>
        </trans-unit>
        <trans-unit id="a3dd434f5b5d6086654ad44e0af5b3fa3e940b9d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt; opcode is used by SQLite to give the VFS layer a hint of how large the database file will grow to be during the current transaction. This hint is not guaranteed to be accurate but it is often close. The underlying VFS might choose to preallocate database file space based on this hint in order to help writes to the database file run faster.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINTの&lt;/a&gt;オペコードは、VFS層にデータベースファイルが現在のトランザクション中に成長する方法を大のヒントを与えるためにSQLiteのに使用されます。このヒントは正確であることが保証されていませんが、近いことがよくあります。基礎となるVFSは、データベースファイルへの書き込みをより高速に実行するために、このヒントに基づいてデータベースファイル領域を事前に割り当てることを選択する場合があります。</target>
        </trans-unit>
        <trans-unit id="97cd9ce5f443d3219025ca93221b345486932d73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt; opcode is used by in-memory VFS that implements &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; to set an upper bound on the size of the in-memory database. The argument is a pointer to a &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt;. If the integer pointed to is negative, then it is filled in with the current limit. Otherwise the limit is set to the larger of the value of the integer pointed to and the current database size. The integer pointed to is set to the new limit.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMITの&lt;/a&gt;オペコードは、実装は、そのメモリ内VFSで使用されている&lt;a href=&quot;#sqlite3_deserialize&quot;&gt;）（sqlite3_deserialize&lt;/a&gt;アッパーインメモリデータベースのサイズに結合さを設定します。引数は&lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt;へのポインターです。指し示す整数が負の場合、現在の制限値が入ります。それ以外の場合、制限は、ポイントされた整数の値と現在のデータベースサイズの大きい方に設定されます。指す整数は新しい制限に設定されます。</target>
        </trans-unit>
        <trans-unit id="3a6ee4f80c9cf2b24ebb8343bd1162955c7d2500" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions master-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNCの&lt;/a&gt;オペコードは、SQLiteのが内部で生成され、XSYNC方法は、データベースのファイル記述子に呼び出される直前VFSに送信されます。または、ユーザーがSQLiteを&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期= OFF&lt;/a&gt;で構成したためにxSyncメソッドが呼び出されない場合は、xSyncメソッドの代わりに呼び出されます。ほとんどの場合、このファイルコントロールで渡されるポインタ引数はNULLです。ただし、データベースファイルがマルチデータベースコミットの一部として同期されている場合、引数は、トランザクションのマスタージャーナルファイル名を含むNULで終了する文字列を指します。この信号を必要としないVFSは、このオペコードを黙って無視する必要があります。アプリケーションは&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）を&lt;/a&gt;呼び出すべきではありません このオペコードを使用すると、それを必要とする特殊なVFSの操作が中断される可能性があるためです。</target>
        </trans-unit>
        <trans-unit id="5178975b67a8618a8b0176ac061e8db0d71f5de9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions super-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNCの&lt;/a&gt;オペコードは、SQLiteのが内部で生成され、XSYNC方法は、データベースのファイル記述子に呼び出される直前VFSに送信されます。または、ユーザーが&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA Synchronous = OFF&lt;/a&gt;でSQLiteを構成したためにxSyncメソッドが呼び出されない場合は、xSyncメソッドの代わりに呼び出されます。ほとんどの場合、このファイル制御で渡されるポインタ引数はNULLです。ただし、データベースファイルがマルチデータベースコミットの一部として同期されている場合、引数はトランザクションのスーパージャーナルファイル名を含むヌル終了文字列を指します。この信号を必要としないVFSは、このオペコードを黙って無視する必要があります。アプリケーションは&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）を&lt;/a&gt;呼び出さないでください このオペコードを使用すると、それを必要とする特殊なVFSの動作が中断される可能性があります。</target>
        </trans-unit>
        <trans-unit id="105a39338a53cf76076319343b91a58b713c591f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt; file control provides advisory information to the VFS about what the higher layers of the SQLite stack are doing. This file control is used by some VFS activity tracing &lt;a href=&quot;vfs#shim&quot;&gt;shims&lt;/a&gt;. The argument is a zero-terminated string. Higher layers in the SQLite stack may generate instances of this file control if the &lt;a href=&quot;compile#use_fcntl_trace&quot;&gt;SQLITE_USE_FCNTL_TRACE&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACEの&lt;/a&gt;ファイル制御は、SQLiteのスタックの上位層がやっていることについて、VFSへの助言情報を提供します。このファイルコントロールは、一部のVFSアクティビティトレース&lt;a href=&quot;vfs#shim&quot;&gt;シムで&lt;/a&gt;使用されます。引数はゼロで終了する文字列です。&lt;a href=&quot;compile#use_fcntl_trace&quot;&gt;SQLite_USE_FCNTL_TRACE&lt;/a&gt;コンパイル時オプションが有効になっている場合、SQLiteスタックの上位層でこのファイルコントロールのインスタンスが生成される可能性があります。</target>
        </trans-unit>
        <trans-unit id="10a39c75085aed62eed16a6bd93eb299fac8af13" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME&lt;/a&gt; opcode can be used to obtain the names of all &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; in the VFS stack. The names are of all VFS shims and the final bottom-level VFS are written into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and the result is stored in the char* variable that the fourth parameter of &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; points to. The caller is responsible for freeing the memory when done. As with all file-control actions, there is no guarantee that this will actually do anything. Callers should initialize the char* variable to a NULL pointer in case this file-control is not implemented. This file-control is intended for diagnostic use only.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAMEの&lt;/a&gt;オペコードは、すべての名前を取得するために使用することができ&lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; VFSスタック内を。名前はすべてのVFSシムの名前であり、最終的な最下位VFSは&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;から取得したメモリに書き込まれ、結果は&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）の&lt;/a&gt; 4番目のパラメーターが指す char *変数に格納されます。呼び出し元は、完了時にメモリを解放する責任があります。すべてのファイル制御アクションと同様に、これが実際に何かを実行するという保証はありません。このファイルコントロールが実装されていない場合、呼び出し元はchar *変数をNULLポインターに初期化する必要があります。このファイル制御は、診断での使用のみを目的としています。</target>
        </trans-unit>
        <trans-unit id="a0de6e2585567c94a4d2150e4d89a4457d85ed27" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; opcode finds a pointer to the top-level &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; currently in use. The argument X in sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be of type &quot;&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&quot;. This opcodes will set *X to a pointer to the top-level VFS. When there are multiple VFS shims in the stack, this opcode finds the upper-most shim only.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTERの&lt;/a&gt;オペコードは、トップレベルへのポインタ見つけ&lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;現在使用されています。sqlite3_file_control（db、SQLITE_FCNTL_VFS_POINTER、X）の引数Xは、タイプ &quot; &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&quot; でなければなりません。このオペコードは、* XをトップレベルのVFSへのポインターに設定します。スタックに複数のVFSシムがある場合、このオペコードは最上位のシムのみを検出します。</target>
        </trans-unit>
        <trans-unit id="6fb5c486ab423108118235eb419e942dcdffc3fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK&lt;/a&gt; is a signal to the VFS layer that it might be advantageous to block on the next WAL lock if the lock is not immediately available. The WAL subsystem issues this signal during rare circumstances in order to fix a problem with priority inversion. Applications should &lt;em&gt;not&lt;/em&gt; use this file-control.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCKは&lt;/a&gt;ロックが利用可能でない場合、次のWALロックをブロックすることが有利であるかもしれないことをVFS層に信号です。WALサブシステムは、優先順位の逆転の問題を修正するために、まれな状況でこの信号を発行します。アプリケーションはこのファイルコントロールを使用し&lt;em&gt;ないで&lt;/em&gt;ください。</target>
        </trans-unit>
        <trans-unit id="2324c4dab632501938725b9d6af72b57f5294994" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY&lt;/a&gt; opcode is used to configure automatic retry counts and intervals for certain disk I/O operations for the windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; in order to provide robustness in the presence of anti-virus programs. By default, the windows VFS will retry file read, file write, and file delete operations up to 10 times, with a delay of 25 milliseconds before the first retry and with the delay increasing by an additional 25 milliseconds with each subsequent retry. This opcode allows these two values (10 retries and 25 milliseconds of delay) to be adjusted. The values are changed for all database connections within the same process. The argument is a pointer to an array of two integers where the first integer is the new retry count and the second integer is the delay. If either integer is negative, then the setting is not changed but instead the prior value of that setting is written into the array entry, allowing the current retry settings to be interrogated. The zDbName parameter is ignored.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRYの&lt;/a&gt;オペコードは、特定のディスクの自動再試行回数と間隔を設定するために使用されているWindows用のI / O操作&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;ウイルス対策プログラムの存在下で堅牢性を提供するため。デフォルトでは、Windows VFSはファイルの読み取り、ファイルの書き込み、およびファイルの削除操作を最大10回再試行します。最初の再試行までに25ミリ秒の遅延があり、その後の再試行ごとに遅延がさらに25ミリ秒増加します。このオペコードにより、これらの2つの値（10回の再試行と25ミリ秒の遅延）を調整できます。同じプロセス内のすべてのデータベース接続の値が変更されます。引数は2つの整数の配列へのポインターです。最初の整数は新しい再試行回数で、2番目の整数は遅延です。いずれかの整数が負の場合、設定は変更されませんが、代わりにその設定の以前の値が配列エントリに書き込まれ、現在の再試行設定を問い合わせることができます。zDbNameパラメータは無視されます。</target>
        </trans-unit>
        <trans-unit id="257792bb90d40cbd5be070de917b57c36a5f9cd9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt; opcode can be used to obtain the underlying native file handle associated with a file handle. This file control interprets its argument as a pointer to a native file handle and writes the resulting value there.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLEの&lt;/a&gt;オペコードは、ファイルハンドルに関連付けられている基礎となるネイティブファイルハンドルを取得するために使用することができます。このファイルコントロールは、引数をネイティブファイルハンドルへのポインターとして解釈し、結果の値をそこに書き込みます。</target>
        </trans-unit>
        <trans-unit id="774ea185734630483687c4bdf35dc5a0169545c2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to swap the file handle with the one pointed to by the pArg argument. This capability is used during testing and only needs to be supported when SQLITE_TEST is defined.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLEの&lt;/a&gt;オペコードは、デバッグに使用されます。このオペコードにより、xFileControlメソッドは、ファイルハンドルを、pArg引数によってポイントされたものと交換します。この機能はテスト中に使用され、SQLITE_TESTが定義されている場合にのみサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="6d8e8025bf5df9df0de6e9fce45f3dc3f3a1832f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS&lt;/a&gt; opcode is implemented by zipvfs only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFSの&lt;/a&gt;オペコードだけzipvfsによって実装されます。他のすべてのVFSは、このオペコードに対してSQLITE_NOTFOUNDを返す必要があります。</target>
        </trans-unit>
        <trans-unit id="2a84f41bb71a501decc458aa53d2eb6f639dc064" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option can be used to limit the length of &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt; expansion in the output of sqlite3_trace().</source>
          <target state="translated">&lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt;コンパイル時オプションは、の長さを制限するために使用することができる&lt;a href=&quot;../lang_expr#varparam&quot;&gt;上限パラメータ&lt;/a&gt; sqlite3_traceの出力で膨張を（）。</target>
        </trans-unit>
        <trans-unit id="a6d12472a003010a0b08bc4775382d299187ba70" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option limits the size of bound parameter expansions. The &lt;a href=&quot;../compile#omit_trace&quot;&gt;SQLITE_OMIT_TRACE&lt;/a&gt; compile-time option causes sqlite3_expanded_sql() to always return NULL.</source>
          <target state="translated">&lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt;コンパイル時のオプションは、バインドされたパラメータ展開のサイズを制限します。&lt;a href=&quot;../compile#omit_trace&quot;&gt;SQLITE_OMIT_TRACE&lt;/a&gt;コンパイル時のオプションは常にNULLを返すために）（sqlite3_expanded_sqlの原因となります。</target>
        </trans-unit>
        <trans-unit id="7fbc9bba97b7220d8d7ecc905032c6bd233e87c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; should be avoided.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directoryプラグマは&lt;/a&gt;、この変数を変更してから取得したメモリを指すように、それを引き起こす可能性があり&lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;。さらに、&lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directoryプラグマは&lt;/a&gt;常に、この変数が指すすべての文字列が&lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;から取得したメモリに保持されていると想定し、プラグマは&lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;を使用してそのメモリを解放しようとする可能性があります。したがって、この変数を直接変更する場合は、NULLにするか、&lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;から取得したメモリを指すようにするか、&lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directoryプラグマの&lt;/a&gt;使用を避けます。</target>
        </trans-unit>
        <trans-unit id="f9eb53bad0c35cc3dcade82b9f30796bebe98ba9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_journal_mode&quot;&gt;プラグマjournal_mode = OFFの&lt;/a&gt;声明。</target>
        </trans-unit>
        <trans-unit id="4683a2e9a942c25fe816aae1882f9a79405f5686" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; should be avoided. Except when requested by the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, SQLite does not free the memory that sqlite3_temp_directory points to. If the application wants that memory to be freed, it must do so itself, taking care to only do so after all &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; objects have been destroyed.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directoryプラグマは&lt;/a&gt;、この変数を変更してから取得したメモリを指すように、それを引き起こす可能性があり&lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;。さらに、&lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directoryプラグマは&lt;/a&gt;常に、この変数が指すすべての文字列が&lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;から取得したメモリに保持されていると想定し、プラグマは&lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;を使用してそのメモリを解放しようとする可能性があります。したがって、この変数を直接変更する場合は、NULLにするか、&lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;から取得したメモリを指すようにするか、&lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directoryプラグマの&lt;/a&gt;使用を避けます。&lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directoryプラグマ&lt;/a&gt;によって要求された場合を除く、SQLiteはsqlite3_temp_directoryが指すメモリを解放しません。アプリケーションがそのメモリを解放したい場合は、それ自体で解放する必要があります。すべての&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;オブジェクトが破棄された後にのみ解放するように注意してください。</target>
        </trans-unit>
        <trans-unit id="d082fe94995359849591e8be7fa905999e11458e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; can be used to invoke this interface from SQL.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpointプラグマは、&lt;/a&gt; SQLからこのインターフェースを呼び出すために使用することができます。</target>
        </trans-unit>
        <trans-unit id="2688b20853de688f9667ff56467cd11f77df2163" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_wal_checkpoint&quot;&gt;PRAGMA wal_checkpoint&lt;/a&gt; command can be used to invoke this interface from SQL.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_wal_checkpoint&quot;&gt;プラグマwal_checkpointの&lt;/a&gt;コマンドは、SQLからこのインターフェースを呼び出すために使用することができます。</target>
        </trans-unit>
        <trans-unit id="3d14328a2609f4c2f2e647906b7ed9c9b0a6470e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;プラグマwritable_schemaはON =&lt;/a&gt;声明。</target>
        </trans-unit>
        <trans-unit id="3c456ed19efa854514b7975cbb780401189b8da5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and is not checked again by SQLite.</source>
          <target state="translated">&lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndexの&lt;/a&gt;方法はxFilterに渡すどのようなパラメータに関する情報をaConstraintUsage []を入力する必要があります。argvIndex&amp;gt; 0の場合、対応するaConstraint []の右側が評価され、argvのargvIndex番目のエントリになります。aConstraintUsage []。omitがtrueの場合、制約は仮想テーブルによって完全に処理されたと見なされ、SQLiteによって再度チェックされません。</target>
        </trans-unit>
        <trans-unit id="589ad4da98fc55a8cd1077ee9df3a71f69ad38f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and might not be checked again by the byte code. The aConstraintUsage[].omit flag is an optimization hint. When the omit flag is left in its default setting of false, the constraint will always be checked separately in byte code. If the omit flag is change to true, then the constraint may or may not be checked in byte code. In other words, when the omit flag is true there is no guarantee that the constraint will not be checked again using byte code.</source>
          <target state="translated">&lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndexの&lt;/a&gt;方法はxFilterに渡すどのようなパラメータに関する情報をaConstraintUsage []を入力する必要があります。 argvIndex&amp;gt; 0の場合、対応するaConstraint []の右側が評価され、argvのargvIndex番目のエントリになります。 aConstraintUsage []。omitがtrueの場合、制約は仮想テーブルによって完全に処理されていると見なされ、バイトコードによって再度チェックされない可能性があります。 aConstraintUsage []。omitフラグは最適化のヒントです。省略フラグがデフォルト設定のfalseのままになっている場合、制約は常にバイトコードで個別にチェックされます。省略フラグがtrueに変更された場合、制約はバイトコードでチェックされる場合とされない場合があります。つまり、省略フラグがtrueの場合、バイトコードを使用して制約が再度チェックされないという保証はありません。</target>
        </trans-unit>
        <trans-unit id="52eaec5cfbc452ed9aad230504ada3c60f5e208b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of a &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt; call this interface to declare the format (the names and datatypes of the columns) of the virtual tables they implement.</source>
          <target state="translated">&lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;と&lt;a href=&quot;../vtab#xconnect&quot;&gt;のxconnect&lt;/a&gt;の方法&lt;a href=&quot;module&quot;&gt;仮想テーブルは、モジュール&lt;/a&gt;、それらが実装仮想テーブルの形式（列の名前とデータ型）を宣言するために、このインターフェイスを呼び出します。</target>
        </trans-unit>
        <trans-unit id="eabaf2d0ed146df6465d7c01128019f3ef60888d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;atomiccommit&quot;&gt;atomic update capabilities&lt;/a&gt; of SQLite allow small incremental changes to be safely written into the document. This reduces total disk I/O and improves File/Save performance, enhancing the user experience.</source>
          <target state="translated">SQLite の&lt;a href=&quot;atomiccommit&quot;&gt;アトミック更新機能&lt;/a&gt;により、小さな増分変更をドキュメントに安全に書き込むことができます。これにより、ディスクI / Oの合計が減り、ファイル/保存のパフォーマンスが向上し、ユーザーエクスペリエンスが向上します。</target>
        </trans-unit>
        <trans-unit id="08525d9bc082ee31e91cdcebab98cc6662084121" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; feature in SQLite works differently than it does in MySQL. This often causes confusion for people who initially learned SQL on MySQL and then start using SQLite, and expect the two systems to work identically.</source>
          <target state="translated">SQLite の&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;機能は、MySQLとは異なる動作をします。これは、最初にMySQLでSQLを学び、次にSQLiteの使用を開始し、2つのシステムが同じように動作することを期待する人々を混乱させることがよくあります。</target>
        </trans-unit>
        <trans-unit id="bc38744c25dba895f9fced962c1bfedae8b7cde9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object itself is partially threadsafe. Multiple threads may safely make multiple concurrent calls to sqlite3_backup_step(). However, the sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs are not strictly speaking threadsafe. If they are invoked at the same time as another thread is invoking sqlite3_backup_step() it is possible that they return invalid values.</source>
          <target state="translated">&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;オブジェクト自体は、部分的にスレッドセーフです。複数のスレッドがsqlite3_backup_step（）への複数の同時呼び出しを安全に行うことができます。ただし、sqlite3_backup_remaining（）およびsqlite3_backup_pagecount（）APIは厳密にはスレッドセーフではありません。別のスレッドがsqlite3_backup_step（）を呼び出しているときに同時に呼び出された場合、無効な値を返す可能性があります。</target>
        </trans-unit>
        <trans-unit id="218098ad11bde6e156b4a9f8e57ca75e25354cce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_zeroblob()&lt;/a&gt; and &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; interfaces and the built-in &lt;a href=&quot;../lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; SQL function may be used to create a zero-filled blob to read or write using the incremental-blob interface.</source>
          <target state="translated">&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_zeroblob（）&lt;/a&gt;と&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_zeroblob（）&lt;/a&gt;インターフェースと内蔵&lt;a href=&quot;../lang_corefunc#zeroblob&quot;&gt;zeroblobの&lt;/a&gt; SQL関数は、読み取りまたはインクリメンタルブロブインタフェースを使用して書き込むためのゼロ充填BLOBを作成するために使用されてもよいです。</target>
        </trans-unit>
        <trans-unit id="54f66c39b1fdccfb02fbdb0dd7e08e6474fe1802" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; interface, which has been deprecated and undocumented for 8 years, is changed into a no-op.</source>
          <target state="translated">&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm（）&lt;/a&gt;非推奨と8年間の文書化されたインタフェースは、ノーオペレーションに変更されます。</target>
        </trans-unit>
        <trans-unit id="3cbc1814be35648af44f26835e6f82841778c411" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm&lt;/a&gt; routine is used to register a callback on memory allocation events. This routine registers or clears a callback that fires when the amount of memory allocated exceeds iThreshold. Only a single callback can be registered at a time. Each call to &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; overwrites the previous callback. The callback is disabled by setting xCallback to a NULL pointer.</source>
          <target state="translated">&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarmの&lt;/a&gt;ルーチンは、メモリの割り当てイベントにコールバックを登録するために使用されます。このルーチンは、割り当てられたメモリの量がiThresholdを超えたときに起動するコールバックを登録またはクリアします。一度に登録できるコールバックは1つだけです。&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm（）を&lt;/a&gt;呼び出すたびに、前のコールバックが上書きされます。xCallbackをNULLポインターに設定すると、コールバックが無効になります。</target>
        </trans-unit>
        <trans-unit id="fc7e34038a904f7366dde6ee090a8282d84ade6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_thread_cleanup()&lt;/a&gt; interface has become a no-op.</source>
          <target state="translated">&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_thread_cleanup（）&lt;/a&gt;インターフェースには、OPとなっていません。</target>
        </trans-unit>
        <trans-unit id="ac435cb36a069024ddc4f4287c8ff0d76c80af5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;Online Backup API&lt;/a&gt; was created to address these concerns. The online backup API allows the contents of one database to be copied into another database, overwriting the original contents of the target database. The copy operation may be done incrementally, in which case the source database does not need to be locked for the duration of the copy, only for the brief periods of time when it is actually being read from. This allows other database users to continue uninterrupted while a backup of an online database is made.</source>
          <target state="translated">&lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;オンラインバックアップAPIは、&lt;/a&gt;これらの懸念に対処するために作成されました。オンラインバックアップAPIを使用すると、あるデータベースのコンテンツを別のデータベースにコピーして、ターゲットデータベースの元のコンテンツを上書きできます。コピー操作は段階的に行うことができます。この場合、ソースデータベースは、実際に読み取られている短い期間だけ、コピーの期間中ロックする必要はありません。これにより、オンラインデータベースのバックアップが作成されている間、他のデータベースユーザーは中断することなく続行できます。</target>
        </trans-unit>
        <trans-unit id="563d98f5bc61682f67da5d25a1062884fd2fdf5d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; interface does &lt;u&gt;not&lt;/u&gt; work for a union-vtab. BLOB content must be read from the union-vtab using ordinary SQL statements.</source>
          <target state="translated">&lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;インタフェースがない&lt;u&gt;ではない&lt;/u&gt;組合vtabのために働きます。BLOBコンテンツは、通常のSQLステートメントを使用してunion-vtabから読み取る必要があります。</target>
        </trans-unit>
        <trans-unit id="b9d5c3998902d7d51338a9f7531152bceea38f9d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt;&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; is invoked once with a column name that is an empty string for every table referenced in a query from which no columns are extracted.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_READの&lt;/a&gt;&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;承認者のコールバックが&lt;/a&gt;何列が抽出されていない、そこからクエリで参照されているすべてのテーブルに空の文字列である列名で一度呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a68ee8ce42ad40a73650dbfe088fcf3e1c842ed0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt; run-time option and the &lt;a href=&quot;compile#enable_qpsg&quot;&gt;SQLITE_ENABLE_QPSG&lt;/a&gt; compile-time option enable the &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt;. See also ticket &lt;a href=&quot;https://www.sqlite.org/src/info/892fc34f173e99d8&quot;&gt;892fc34f173e99d8&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt;実行時オプションと&lt;a href=&quot;compile#enable_qpsg&quot;&gt;SQLITE_ENABLE_QPSG&lt;/a&gt;コンパイル時のオプションが有効&lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;問い合わせプランナの安定性を保証します&lt;/a&gt;。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/892fc34f173e99d8&quot;&gt;892fc34f173e99d8&lt;/a&gt;も参照</target>
        </trans-unit>
        <trans-unit id="ba2430856bd9775a861cef9dfde7c36d65a2cc4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; bit means that all writes to this device are atomic in the sense that either the entire write occurs or none of it occurs. The other &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;i&gt;nnn&lt;/i&gt;&lt;/a&gt; values indicate that writes of aligned blocks of the indicated size are atomic. &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SAFE_APPEND&lt;/a&gt; means that when extending a file with new data, the new data is written first and then the file size is updated. So if a power failure occurs, there is no chance that the file might have been extended with randomness. The &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SEQUENTIAL&lt;/a&gt; bit means that all writes occur in the order that they are issued and are not reordered by the underlying file system.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt;ビット手段は、このデバイスへのすべての書き込みは、いずれかの全体の書き込みが発生した意味でアトミックであるとか、それのどれも発生しません。他の&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC &lt;i&gt;nnn&lt;/i&gt;&lt;/a&gt;値は、示されたサイズの整列されたブロックの書き込みがアトミックであることを示します。&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SAFE_APPEND&lt;/a&gt;は、新しいデータでファイルを拡張するときに、新しいデータが最初に書き込まれ、次にファイルサイズが更新されることを意味します。したがって、停電が発生した場合、ファイルがランダムに拡張された可能性はありません。&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SEQUENTIAL&lt;/a&gt;ビット手段すべての書き込みは、彼らが発行され、基本的なファイルシステムによって並べ替えされていないことを順に発生していること。</target>
        </trans-unit>
        <trans-unit id="9a653d67bd1da50ffe32f058a08a81d4f6edcd9e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; flag means the file should be deleted when it is closed. This will always be set for TEMP databases and journals and for subjournals. The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; flag means the file should be opened for exclusive access. This flag is set for all files except for the main database file. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure passed as the third argument to xOpen is allocated by the caller. xOpen just fills it in. The caller allocates a minimum of szOsFile bytes for the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSEの&lt;/a&gt;フラグは、それが閉じているときに、ファイルが削除されるべきであることを意味します。これは、TEMPデータベースとジャーナル、およびサブジャーナルに対して常に設定されます。&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt;フラグは、ファイルが排他的アクセス用に開かれるべきであることを意味します。このフラグは、メインデータベースファイルを除くすべてのファイルに設定されます。&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_fileの&lt;/a&gt; XOPENの3番目の引数として渡される構造は、呼び出し元によって割り当てられます。 xOpenは、それを埋めるだけです。呼び出し側は、最小szOsFileバイトを&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;構造体に割り当てます。</target>
        </trans-unit>
        <trans-unit id="229110ee7251c5cf9b125b0ef0813a6c6ba215fe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; and &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flags to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; can also be used to adjust the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; of individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; at run-time.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;と&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX用&lt;/a&gt;にフラグ&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2は（）&lt;/a&gt;も調整するために使用することができる&lt;a href=&quot;threadsafe&quot;&gt;スレッドモード&lt;/a&gt;個々の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続を&lt;/a&gt;実行時に。</target>
        </trans-unit>
        <trans-unit id="966cc2ea77fca46efeb8c4289b4a653605ed43e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; option was added to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEXの&lt;/a&gt;オプションが追加された&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="abc999536061a5d7a156494c35b1ed191a9effbf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_type()&lt;/a&gt; function returns the datatype for the value in the Nth column. The return value is one of these:</source>
          <target state="translated">&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_type（）&lt;/a&gt;関数は、N番目の列の値のデータ型を返します。戻り値は次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="cffa274dabb801c01eb4f4986ad5f8726b7dca26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; function returns the number of columns in the results set. sqlite3_column_count() can be called at any time after &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count()&lt;/a&gt; works similarly to &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; except that it only works following &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. If the previous call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; returned SQLITE_DONE or an error code, then &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count()&lt;/a&gt; will return 0 whereas &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; will continue to return the number of columns in the result set.</source>
          <target state="translated">&lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count（）&lt;/a&gt;関数は、結果セット内の列の数を返します。 sqlite3_column_count（）は、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）の&lt;/a&gt;後でいつでも呼び出すことができます。&lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_countは（）&lt;/a&gt;と同じように動作し&lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count（）&lt;/a&gt;それが唯一の次という点を除いて&lt;a href=&quot;c3ref/step&quot;&gt;（）sqlite3_step&lt;/a&gt;。&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;への以前の呼び出しがSQLITE_DONEまたはエラーコードを返した場合、&lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count（）&lt;/a&gt;は0を返しますが、&lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count（）&lt;/a&gt;は結果セットの列数を返し続けます。</target>
        </trans-unit>
        <trans-unit id="df909dfd5bdc309e3368846cb0f8c21a5731a3d2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface is used to make global, process-wide configuration changes for SQLite. The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface must be called before any &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; are created. The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface allows the programmer to do things like:</source>
          <target state="translated">&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;インターフェースは、SQLiteのためのグローバル、プロセス全体の設定変更を行うために使用されます。&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;いずれかの前に、インタフェースが呼び出される必要があり&lt;a href=&quot;c3ref/sqlite3&quot;&gt;、データベースの接続が&lt;/a&gt;作成されます。&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;インターフェースは、プログラマがのようなものを行うことができます：</target>
        </trans-unit>
        <trans-unit id="7eb7ccb56d39b4e4c7e512ab71314c715b6ea1d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;,1) interfaces was invoked at start-time.</source>
          <target state="translated">&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;、1）インターフェースは、開始時に呼び出されました。</target>
        </trans-unit>
        <trans-unit id="00c837fffcba80492d406ed18ba293449ca9513c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt; interface is used to create new &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt; for sorting text. The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; interface is used to register new &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations. The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface creates new &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collat​​ion（）&lt;/a&gt;インタフェースは、新規作成するために使用される&lt;a href=&quot;datatype3#collation&quot;&gt;照合シーケンスを&lt;/a&gt;テキストをソートします。&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;インターフェースが新たに登録するために使用される&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;の実装を。&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;インタフェースは、新しい作成&lt;a href=&quot;vfs&quot;&gt;VFSesを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4c521e07609cbfdb8d566dab7163fc87d422895" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; family of interfaces now return &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; instead of &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; when passed invalid parameter combinations.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;インタフェースの家族は今返す&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;代わりの&lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;無効なパラメータの組み合わせを通過しました。</target>
        </trans-unit>
        <trans-unit id="caf6561662b932f66438111d53034fa55d79a49d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface can be used to override the like() function and thereby change the operation of the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator. When overriding the like() function, it may be important to override both the two and three argument versions of the like() function. Otherwise, different code may be called to implement the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator depending on whether or not an ESCAPE clause was specified.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;インターフェースのような（）関数をオーバーライドすることにより、操作変更するために使用することができる&lt;a href=&quot;lang_expr#like&quot;&gt;のLIKE&lt;/a&gt;演算子を。like（）関数をオーバーライドする場合、like（）関数の2つの引数バージョンと3つの引数バージョンの両方をオーバーライドすることが重要な場合があります。そうでない場合、ESCAPE句が指定されているかどうかに応じて、&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;演算子を実装するために別のコードが呼び出されることがあります。</target>
        </trans-unit>
        <trans-unit id="a6b630ee12d42fc4528bfc71d36f585a36895111" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface creates new SQL functions - either scalar or aggregate. The new function implementation typically makes use of the following additional interfaces:</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;スカラーまたは集計のいずれか-インターフェイスは、新しいSQL関数を作成します。新しい関数の実装では、通常、次の追加のインターフェイスを使用します。</target>
        </trans-unit>
        <trans-unit id="99635893a7742a2b0a9430ca501d241e5f7023c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; and &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; interfaces return SQLITE_MISUSE on any attempt to overload or replace a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; module. The destructor is always called in this case, in accordance with historical and current documentation.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;と&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2（）&lt;/a&gt;インターフェースは、過負荷または交換する試みでSQLITE_MISUSEを返す&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;モジュール。この場合、デストラクタは常に、過去および現在のドキュメントに従って呼び出されます。</target>
        </trans-unit>
        <trans-unit id="0e7c498dc9b696b8a3e4e1f8ce0b76687320b809" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; and &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; routines associates a module name with an &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure and a separate client data that is specific to each module. The only difference between the two create_module methods is that the _v2 method includes an extra parameter that specifies a destructor for client data pointer. The module structure is what defines the behavior of a virtual table. The module structure looks like this:</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;と&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2（）&lt;/a&gt;ルーチン仲間とモジュール名&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt;構造と、各モジュールに固有の別のクライアントデータ。2つのcreate_moduleメソッドの唯一の違いは、_v2メソッドには、クライアントデータポインターのデストラクタを指定する追加のパラメーターが含まれていることです。モジュール構造は、仮想テーブルの動作を定義するものです。モジュール構造は次のようになります。</target>
        </trans-unit>
        <trans-unit id="ea2068b9a7520d6dd4dead5bbb83fc7b95e63987" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusdeferredfks&quot;&gt;SQLITE_DBSTATUS_DEFERRED_FKS&lt;/a&gt;,...) C-language interface can be used during a transaction to determine if there are deferred and unresolved foreign key constraints.</source>
          <target state="translated">&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;（デシベル、&lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusdeferredfks&quot;&gt;SQLITE_DBSTATUS_DEFERRED_FKS&lt;/a&gt;、...）C言語インタフェースは繰延べられ、未解決の外部キー制約があるかどうかを決定するためにトランザクション中に使用することができます。</target>
        </trans-unit>
        <trans-unit id="5d823f649e66e357a40f8457ae11a89f890b8312" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; interface now applies to all threads within a process, not to just the one thread in which it was run.</source>
          <target state="translated">&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt;インタフェースは、今ではない、それが実行されたただ一つのスレッドに、プロセス内のすべてのスレッドに適用されます。</target>
        </trans-unit>
        <trans-unit id="dc8c7487a7241b1b53f75118a25cdfbd803a1bd5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; function works much as it did in SQLite version 2. Zero or more SQL statements specified in the second parameter are compiled and executed. Query results are returned to a callback routine.</source>
          <target state="translated">&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;がゼロ以上のSQL文は2番目のパラメータで指定されたSQLiteバージョン2で行ったように関数があまり機能してコンパイルされて実行されます。クエリ結果はコールバックルーチンに返されます。</target>
        </trans-unit>
        <trans-unit id="060e03cab55fa6e258498e740c2441a904ee6a9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; interface is a convenience wrapper that carries out all four of the above steps with a single function call. A callback function passed into &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; is used to process each row of the result set. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; is another convenience wrapper that does all four of the above steps. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; interface differs from &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; in that it stores the results of queries in heap memory rather than invoking a callback.</source>
          <target state="translated">&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;インターフェースは、単一の関数呼び出しで、上記の手順のすべての4つを行う便利なラッパーです。&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）に&lt;/a&gt;渡されるコールバック関数は、結果セットの各行を処理するために使用されます。&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）は、&lt;/a&gt;上記の手順のすべての4つを行い、他の便利なラッパーです。&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;からインタフェースが異なる&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;は、ヒープメモリ内のクエリの結果を格納するのではなく、コールバックを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="c55eb24f412d567a8152cd959c8adf08902c2ff0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface works on any prepared statement created using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;. It is no longer necessary to use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; with &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparenormalize&quot;&gt;SQLITE_PREPARE_NORMALIZE&lt;/a&gt; in order to use &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql（）&lt;/a&gt;任意のプリペアドステートメントのインターフェイス作品が使用して作成した&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;または&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3を（） &lt;/a&gt;。それは使用することがもはや必要である&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;で&lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparenormalize&quot;&gt;SQLITE_PREPARE_NORMALIZEを&lt;/a&gt;利用するために&lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b367904a5b319d97004324430003a01cf6b1ae72" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object represents an open file. The xOpen method of &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; constructs an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object when the file is opened. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; keeps track of the state of the file while it is opened.</source>
          <target state="translated">&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;オブジェクトは、開いているファイルを表します。XOPEN方法&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfsが&lt;/a&gt;構築&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;ファイルが開かれたときにオブジェクトを。&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_fileは、&lt;/a&gt;それが開いている間、ファイルの状態を追跡します。</target>
        </trans-unit>
        <trans-unit id="64a6d4c58c9877ecd1b62378eb5e65c884bd0f45" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface can be used to set an upper bound on the total amount of outstanding memory that the general-purpose memory allocator for SQLite will allow to be outstanding at one time. If attempts are made to allocate more memory than specified by the soft heap limit, then SQLite will first attempt to free cache memory before continuing with the allocation request. The soft heap limit mechanism only works if &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; are enabled and it works best if the SQLite library is compiled with the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;インターフェースは、SQLiteのための汎用のメモリアロケータが一度に未処理であることを可能にすること未処理のメモリの合計量の上限を設定するために使用することができます。ソフトヒープ制限で指定されているよりも多くのメモリを割り当てようとすると、SQLiteは割り当て要求を続行する前に、まずキャッシュメモリを解放しようとします。ソフトヒープ制限メカニズムは、&lt;a href=&quot;malloc#memstatus&quot;&gt;メモリ統計&lt;/a&gt;が有効になっている場合にのみ機能し、SQLiteライブラリが&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;コンパイル時オプションを使用してコンパイルされている場合に最適に機能します。</target>
        </trans-unit>
        <trans-unit id="b30882c8710d7d3a10831e6a935d755bd7e25652" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure is used to pass information into and out of the xBestIndex method of the module that implements a virtual table.</source>
          <target state="translated">&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_infoの&lt;/a&gt;構造はに、モジュール実装する仮想テーブルのxBestIndex方法のうち、情報を渡すために使用されます。</target>
        </trans-unit>
        <trans-unit id="c68c89f6fed7e1292abcc19abd161e51c2b5b49a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface can be called to explicitly initialize the SQLite subsystem. The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface is called automatically when invoking certain interfaces so the use of &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; is not required, but it is recommended.</source>
          <target state="translated">&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;インタフェースは、明示的にSQLiteのサブシステムを初期化するために呼び出すことができます。&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;を使用するように、特定のインターフェイスを呼び出す際のインタフェースが自動的に呼び出され&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）は&lt;/a&gt;不要であるが、これは推奨されます。</target>
        </trans-unit>
        <trans-unit id="086866a1ce9981846c47e35c1af526651c7809af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; interface causes SQLite to release any system resources (memory allocations, mutexes, open file handles) that might have been allocated by &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;インタフェースは、SQLiteのは、によって割り当てられた可能性のあるすべてのシステムリソース（メモリ割り当て、ミューテックス、開いているファイルハンドル）解放する原因となる&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initializeを（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18eeb48351b373543379c24e8aba67998ec2d5d9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; interface frees all mutexes under windows.</source>
          <target state="translated">&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;インタフェースは、窓の下にあるすべてのミューテックスを解放します。</target>
        </trans-unit>
        <trans-unit id="f14f29a4830a0488c9f404caad392cc8f7efd81d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; routine can be called for a different thread</source>
          <target state="translated">&lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt（）&lt;/a&gt;ルーチンは、別のスレッドのために呼び出すことができます</target>
        </trans-unit>
        <trans-unit id="78920df495dd4dfe901c1e207965f56317d12fca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object holds the methods used to interact with an open file. Each &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; contains a pointer to an &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object that is appropriate for the file it represents. The &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object contains methods to do things such as read and write from the file, to truncate the file, to flush any changes to persistent storage, to find the size of the file, to lock and unlock the file, and to close file and destroy the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methodsの&lt;/a&gt;オブジェクトは、開いているファイルと対話するために使用されるメソッドを保持しています。各&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_fileに&lt;/a&gt;は、それが表すファイルに適した&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;オブジェクトへのポインターが含まれています。&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methodsの&lt;/a&gt;オブジェクトは、そのようなファイルからの読み取りや書き込みなど、物事を行うには、ファイルを切り捨てるために、永続ストレージへの変更をフラッシュする、ファイルのサイズを見つけるために、ファイルをロックし、ロックを解除するために、そして近いファイルにメソッドが含まれており、&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;オブジェクトを破棄します。</target>
        </trans-unit>
        <trans-unit id="899386dff25e21c6b737c3d54a2f1045b6441f0a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object is a structure that contains pointers to methods for reading, writing, and otherwise dealing with files. This object is defined as follows:</source>
          <target state="translated">&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methodsの&lt;/a&gt;オブジェクトは、読み取り、書き込み、およびそれ以外のファイルを扱うためのメソッドへのポインタを含む構造体です。このオブジェクトは次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="1277e9425f23dd50c872910508a38720a4c40a0c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt; function tries to detect if the source code has been modified from what is checked into version control and if there are modifications, the last four characters of the version hash are shown as &quot;alt1&quot; or &quot;alt2&quot;. The objective is to detect accidental and/or careless edits. A forger can subvert this feature.</source>
          <target state="translated">&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid（）&lt;/a&gt;関数は、ソースコードをバージョン管理にチェックインされているものから変更されており、変更がある場合、バージョンのハッシュの最後の4つの文字が「ALT1」または「ALT2」として示されているかどうかを検出しようとします。目的は、偶発的または不注意な編集を検出することです。偽造者はこの機能を破壊することができます。</target>
        </trans-unit>
        <trans-unit id="e51a6d9f987aab5062f7ef525db57b1e02273eb7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface loads an &lt;a href=&quot;loadext&quot;&gt;extension&lt;/a&gt; into a single database connection. The default behavior is for that extension to be automatically unloaded when the database connection closes. However, if the extension entry point returns SQLITE_OK_LOAD_PERMANENTLY instead of SQLITE_OK, then the extension remains loaded into the process address space after the database connection closes. In other words, the xDlClose methods of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is not called for the extension when the database connection closes.</source>
          <target state="translated">&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;インターフェース負荷&lt;a href=&quot;loadext&quot;&gt;拡張&lt;/a&gt;単一のデータベース接続に。デフォルトの動作では、データベース接続が閉じたときに、その拡張機能が自動的にアンロードされます。ただし、拡張エントリポイントがSQLITE_OKではなくSQLITE_OK_LOAD_PERMANENTLYを返す場合、データベース接続が閉じた後、拡張はプロセスアドレススペースにロードされたままになります。つまり、データベース接続が閉じたときに、&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトのxDlCloseメソッドは拡張機能に対して呼び出されません。</target>
        </trans-unit>
        <trans-unit id="e180768903c106d7d176b62ab434360e88ec87ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interfaces are deprecated. The equivalent functionality is now available through &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;（sqlite3_memory_used）&lt;/a&gt;及び&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;インタフェースは廃止されています。同等の機能が&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status（）&lt;/a&gt;を通じて利用可能になりました。</target>
        </trans-unit>
        <trans-unit id="46ea088bdd6bab93bd39ac4df39be5b9d52d9d73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interfaces, the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64&lt;/a&gt;(&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;) interface, and the &lt;a href=&quot;compile#max_memory&quot;&gt;SQLITE_MAX_MEMORY&lt;/a&gt; compile-time option are all non-functional when memory usage tracking is disabled.</source>
          <target state="translated">&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;と&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;インターフェース、&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64&lt;/a&gt;（&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;）インターフェース、および&lt;a href=&quot;compile#max_memory&quot;&gt;SQLITE_MAX_MEMORY&lt;/a&gt;メモリ使用量の追跡が無効になっている場合、コンパイル時のオプションは、すべての非機能的です。</target>
        </trans-unit>
        <trans-unit id="8f1193a5998521b29a68d3af0690b60d457381cf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure defines a module object used to implement a virtual table. Think of a module as a class from which one can construct multiple virtual tables having similar properties. For example, one might have a module that provides read-only access to comma-separated-value (CSV) files on disk. That one module can then be used to create several virtual tables where each virtual table refers to a different CSV file.</source>
          <target state="translated">&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt;構造は、仮想テーブルを実装するために使用されるモジュールオブジェクトを定義します。モジュールを、類似のプロパティを持つ複数の仮想テーブルを構築できるクラスと考えてください。たとえば、ディスク上のコンマ区切り値（CSV）ファイルへの読み取り専用アクセスを提供するモジュールがあるとします。その1つのモジュールを使用して、各仮想テーブルが異なるCSVファイルを参照する複数の仮想テーブルを作成できます。</target>
        </trans-unit>
        <trans-unit id="26e5c834aec9a24795809e8d9018891e41492180" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_enter()&lt;/a&gt; attempts to enter the mutex and blocks if another threads is already there. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_try()&lt;/a&gt; attempts to enter and returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if another thread is already there. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave()&lt;/a&gt; exits a mutex. The mutex is held until the number of exits matches the number of entrances. If &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave()&lt;/a&gt; is called on a mutex that the thread is not currently holding, then the behavior is undefined. If any routine is called for a deallocated mutex, then the behavior is undefined.</source>
          <target state="translated">&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_enter（）は&lt;/a&gt;、別のスレッドが既に存在する場合、ミューテックスとブロックを入力しようとします。&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_try（）&lt;/a&gt;は、成功すると&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;に入り、別のスレッドがすでにそこにある場合は&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;を入力して返します。&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave（）&lt;/a&gt;はミューテックスを終了します。ミューテックスは、出口の数が入口の数と一致するまで保持されます。場合&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave（）は、&lt;/a&gt;スレッドが現在保持されていないことをミューテックスで呼び出され、その後、動作は未定義です。割り当て解除されたミューテックスに対してルーチンが呼び出された場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="6f27ad8fcfe5b9da304436aec019b4cf39a32876" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_free()&lt;/a&gt; routine should be used to deallocate a non-static mutex. If a static mutex is passed to this routine then the behavior is undefined.</source>
          <target state="translated">&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_free（）&lt;/a&gt;ルーチンは、非静的ミューテックスを解放するために使用します。静的ミューテックスがこのルーチンに渡された場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="bee285158d4476d2f4cfb28e9d58a1b17557c72d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/next_stmt&quot;&gt;sqlite3_next_stmt()&lt;/a&gt; interface allows an application to discover all &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/next_stmt&quot;&gt;sqlite3_next_stmt（）&lt;/a&gt;インターフェースは、すべて発見するアプリケーションでき&lt;a href=&quot;c3ref/stmt&quot;&gt;準備文&lt;/a&gt;に関連付けられた&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab075f99c29f68391431d9855c2d09e8ff55b4eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and related interfaces act as a compiler for converting SQL text into bytecode. The &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object is a container for a single bytecode program using to implement a single SQL statement. The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface passes a bytecode program into the virtual machine, and runs the program until it either completes, or forms a row of result to be returned, or hits a fatal error, or is &lt;a href=&quot;c3ref/interrupt&quot;&gt;interrupted&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;および関連するインターフェースは、バイトコードにSQL文を変換するためのコンパイラとして作用します。&lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;オブジェクトは、単一のSQL文を実行するために使用して、単一のバイトコードプログラムのコンテナです。&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;インターフェースは、仮想マシン内にバイトコード・プログラムを渡し、そのいずれかが完了するまでプログラムを実行し、または返される結果の行を形成し、または致命的なエラーがヒットであるか、または&lt;a href=&quot;c3ref/interrupt&quot;&gt;中断&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f760f8c540dcc654012aa0be1cef03e69842a01e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; interface creates a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; that will automatically recompile itself if the schema changes. The easiest way to deal with &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; errors is to always use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; instead of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;インタフェースが作成されます&lt;a href=&quot;c3ref/stmt&quot;&gt;プリペアドステートメント&lt;/a&gt;のスキーマが変更された場合、自動的に自分自身を再コンパイルします。対処する最も簡単な方法&lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMAの&lt;/a&gt;エラーは常に使用することです&lt;a href=&quot;c3ref/prepare&quot;&gt;（sqlite3_prepare_v2）の&lt;/a&gt;代わりに&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3cb166cb387770ce5ad92997ed9078bd0c5b5827" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_profile()&lt;/a&gt; callback is invoked (by &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;) for statements that did not run to completion.</source>
          <target state="translated">&lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_profile（）&lt;/a&gt;コールバックが（によって呼び出される&lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;または&lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;完了まで実行されなかった文のため）。</target>
        </trans-unit>
        <trans-unit id="c86c0301bb7f9f1fb47baffd646cd224ccc8e2ac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface will now attempt to reduce the memory usages across all database connections in all threads, not just connections in the thread where the interface is called.</source>
          <target state="translated">&lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory（）&lt;/a&gt;インタフェースは現在のインタフェースが呼び出されたスレッドではないだけで接続、すべてのスレッドですべてのデータベース接続間のメモリ使用状況を削減しようとします。</target>
        </trans-unit>
        <trans-unit id="049881541bf38acf3045d3cb673c48aa92e47dd3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt;, &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt;, and &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; interfaces now work cross all threads in the process, not just the single thread in which they are invoked. *** Potentially incompatible change ***</source>
          <target state="translated">&lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory（） &lt;/a&gt;、&lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit（） &lt;/a&gt;、及び&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt;インターフェースは、現在のプロセスのすべてのスレッドは、それらが起動されているだけではなく、単一のスレッドを横切る動作します。***互換性がない可能性のある変更***</target>
        </trans-unit>
        <trans-unit id="af837a86c1e38824ef1d301d32834ef9f9b670f7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; is invoked regardless of the presence of EXPLAIN or EXPLAIN QUERY PLAN.</source>
          <target state="translated">&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;承認者のコールバックは&lt;/a&gt;関係なく、EXPLAINやEXPLAINクエリ・プランの存在に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="af9451c90d2dee9cf3e529bb13a675b0008b0a17" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; interface now applies to all threads within a process, not to just the one thread in which it was run.</source>
          <target state="translated">&lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit（）&lt;/a&gt;インタフェースは、今ではない、それが実行されたただ一つのスレッドに、プロセス内のすべてのスレッドに適用されます。</target>
        </trans-unit>
        <trans-unit id="527b7feeedc271730252349576ab47baa1d727e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; interface works by registering a memory alarm at the soft heap limit and invoking &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; in the alarm callback. Application programs should not attempt to use the &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; interface because doing so will interfere with the &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; module. This interface is exposed only so that applications can provide their own alternative implementation when the SQLite core is compiled with &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit（）&lt;/a&gt;インターフェースは、ソフトヒープ限界でメモリアラームを登録し、呼び出すことによって動作&lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory（）&lt;/a&gt;アラームコールバックです。アプリケーションプログラムは、&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm（）&lt;/a&gt;インターフェースを使用しないでください。使用すると、&lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit（）&lt;/a&gt;モジュールに干渉します。このインターフェイスは、SQLiteコアが&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt;でコンパイルされたときにアプリケーションが独自の代替実装を提供できるようにするためにのみ公開されます。</target>
        </trans-unit>
        <trans-unit id="b1ed21e10553df3077d02ccee7e2ab02fc21afc9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface can be used to set an upper bound on the total amount of outstanding memory that the general-purpose memory allocator for SQLite will allow to be outstanding at one time. If attempts are made to allocate more memory than specified by the soft heap limit, then SQLite will first attempt to free cache memory before continuing with the allocation request. The soft heap limit mechanism only works if &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; are enabled and it works best if the SQLite library is compiled with the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;インターフェースは、SQLiteのための汎用のメモリアロケータが一度に未処理であることを可能にすること未処理のメモリの合計量の上限を設定するために使用することができます。ソフトヒープ制限で指定されたよりも多くのメモリを割り当てようとすると、SQLiteは割り当てリクエストを続行する前に、まずキャッシュメモリを解放しようとします。ソフトヒープ制限メカニズムは、&lt;a href=&quot;malloc#memstatus&quot;&gt;メモリ統計&lt;/a&gt;が有効な場合にのみ機能し、SQLiteライブラリが&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;コンパイル時オプションでコンパイルされている場合に最適に機能します。</target>
        </trans-unit>
        <trans-unit id="1eb6a622a1771cf9ae256233e2fb0c463ea616f9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects are controlled by a small set of C/C++ interface routine listed below.</source>
          <target state="translated">&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;と&lt;a href=&quot;c3ref/stmt&quot;&gt;準備文&lt;/a&gt;オブジェクトは下に記載されているC / C ++インタフェースルーチンの小さなセットによって制御されます。</target>
        </trans-unit>
        <trans-unit id="5466713b299a5e73e4a0863d52f92664bc3844c8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; object: sqlite3</source>
          <target state="translated">&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;オブジェクト：sqlite3の</target>
        </trans-unit>
        <trans-unit id="1c3b251682ed613e33db0de124845adce3edbb1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that is running the VACUUM INTO statement was originally opened using the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag.</source>
          <target state="translated">&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt; INTOステートメントVACUUMを実行している元々使用して開かれた&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URIの&lt;/a&gt;フラグを。</target>
        </trans-unit>
        <trans-unit id="79e9d37ccb6719391098f5d43ea1dcd316705462" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object: sqlite3_stmt</source>
          <target state="translated">&lt;a href=&quot;c3ref/stmt&quot;&gt;プリペアドステートメントの&lt;/a&gt;オブジェクト：sqlite3_stmt</target>
        </trans-unit>
        <trans-unit id="cbcb829701917628eb2fd7b1899f66a93be104f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; C/C++ interface together with the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusfullscanstep&quot;&gt;SQLITE_STMTSTATUS_FULLSCAN_STEP&lt;/a&gt; and &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatussort&quot;&gt;SQLITE_STMTSTATUS_SORT&lt;/a&gt; verbs can be used to detect at run-time when an SQL statement is not making effective use of indices. Many applications may prefer to use the &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface to detect index misuse rather than the INDEXED BY phrase described here.</source>
          <target state="translated">&lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_statusは（）&lt;/a&gt;と一緒にC / C ++インタフェース&lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusfullscanstep&quot;&gt;SQLITE_STMTSTATUS_FULLSCAN_STEP&lt;/a&gt;と&lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatussort&quot;&gt;SQLITE_STMTSTATUS_SORT&lt;/a&gt;動詞は、SQL文がインデックスを有効に活用していない場合、実行時に検出するために使用することができます。多くのアプリケーションは、ここで説明するINDEXED BY句ではなく、&lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status（）&lt;/a&gt;インターフェースを使用してインデックスの誤用を検出することを好む場合があります。</target>
        </trans-unit>
        <trans-unit id="d3e46371f36d9155345020a6a81ffaba033339b8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/table_column_metadata&quot;&gt;sqlite3_table_column_metadata()&lt;/a&gt; is enhanced to work correctly on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables and to check for the existence of a a table if the column name parameter is NULL. The interface is now also included in the build by default, without requiring the &lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;c3ref/table_column_metadata&quot;&gt;sqlite3_table_column_metadataは、（）&lt;/a&gt;で正しく動作するように拡張された&lt;a href=&quot;withoutrowid&quot;&gt;ROWIDのWITHOUT&lt;/a&gt;テーブルやカラム名パラメータがNULLである場合、AAテーブルの存在を確認します。&lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt;コンパイル時オプションを必要とせずに、インターフェイスもデフォルトでビルドに含まれるようになりました。</target>
        </trans-unit>
        <trans-unit id="edc8c97e4cc1a5aa05b289505090d5b34bad9902" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_OPTIMIZATIONS&lt;/a&gt;, ...) interface allows selected SQL statement optimizations to be disabled at run-time. SQLite should always generate exactly the same answer with optimizations enabled and with optimizations disabled; the answer simply arrives quicker with the optimizations turned on. So in a production environment, one always leaves the optimizations turned on (the default setting).</source>
          <target state="translated">&lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt;（&lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_OPTIMIZATIONS&lt;/a&gt;、...）インターフェース選択したSQL文の最適化は、実行時に無効にできます。SQLiteは、最適化を有効にして最適化を無効にしても、常にまったく同じ答えを生成するはずです。最適化をオンにすると、答えはより早く到達します。したがって、実稼働環境では、常に最適化をオンのままにしておきます（デフォルト設定）。</target>
        </trans-unit>
        <trans-unit id="43fd3a5c9f7460ba2ff5df434fcffaa34616785e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; output for nested SQL statements should always begin with a &quot;--&quot; comment marker.</source>
          <target state="translated">ネストされたSQLステートメントの&lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;出力は、常に「-」コメントマーカーで始まる必要があります。</target>
        </trans-unit>
        <trans-unit id="19462b9c93da59d00cf4ac09d7e75c3130b9c27d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; API, which is only available if the library is compiled with the pre-processor symbol &lt;a href=&quot;compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; defined, is &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;documented here&lt;/a&gt;. This article is not a substitute for reading the full API documentation!</source>
          <target state="translated">&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;ライブラリは、プリプロセッサのシンボルでコンパイルされている場合にのみ使用可能ですAPI、&lt;a href=&quot;compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFYが&lt;/a&gt;定義されたが、されて&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;ここに文書化&lt;/a&gt;。この記事は、完全なAPIドキュメントを読むことに代わるものではありません。</target>
        </trans-unit>
        <trans-unit id="3e8d6caa4b5453ea5545263fa9616b15bb0d4f1e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface is designed for use in systems that have a separate thread assigned to each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. There is nothing in the implementation that prevents a single thread from running multiple database connections. However, the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface only works on a single connection at a time, so the lock resolution logic presented here will only work for a single database connection per thread.</source>
          <target state="translated">&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;インターフェースは、それぞれに割り当てられた別のスレッドているシステムで使用するために設計された&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続を&lt;/a&gt;。実装には、単一のスレッドが複数のデータベース接続を実行することを妨げるものはありません。ただし、&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;インターフェースは一度に1つの接続でのみ機能するため、ここで説明するロック解決ロジックは、スレッドごとに1つのデータベース接続でのみ機能します。</target>
        </trans-unit>
        <trans-unit id="1d6fc659db0d56afaed258d4fdfa842c7a2494e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/update_hook&quot;&gt;update hook&lt;/a&gt; is not invoked for rows that are deleted by the REPLACE conflict resolution strategy. Nor does REPLACE increment the &lt;a href=&quot;c3ref/changes&quot;&gt;change counter&lt;/a&gt;. The exceptional behaviors defined in this paragraph might change in a future release.</source>
          <target state="translated">&lt;a href=&quot;c3ref/update_hook&quot;&gt;updateフックは、&lt;/a&gt; REPLACE競合解決戦略によって削除された行のために呼び出されません。また、REPLACEは&lt;a href=&quot;c3ref/changes&quot;&gt;変更カウンターを&lt;/a&gt;インクリメントしません。この段落で定義されている例外的な動作は、将来のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="50634212838ce725193912da3e909e9a53b3f585" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; API is used to locate a particular VFS by name. Its prototype is as follows:</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find（）&lt;/a&gt; APIは名前で特定のVFSの位置を特定するために使用されます。そのプロトタイプは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="cd79207584e9ef224be15cf9411b2100d6ae0c32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister()&lt;/a&gt; API is used to remove an existing VFS from the system.</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister（）&lt;/a&gt; APIは、システムから既存のVFSを削除するために使用されます。</target>
        </trans-unit>
        <trans-unit id="ca7466f7f648f5cd0c7b32027691a4626bfd37a6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; structure represents a pointer to a specific row of a virtual table. This is what an sqlite3_vtab_cursor looks like:</source>
          <target state="translated">&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursorの&lt;/a&gt;構造は、仮想テーブルの特定の行へのポインタを表します。これはsqlite3_vtab_cursorのようになります：</target>
        </trans-unit>
        <trans-unit id="7da2c1fa98bb7a679ac7ffc72d14de8a7e2722aa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connection's busy-handler callback. The argument is of type (void**) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connection's busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLERの&lt;/a&gt;ファイル制御は、それが、接続のビジーハンドラのコールバックへのアクセス権を持つカスタムVFSを提供するために開かれた直後に、データベースのファイルハンドル上のSQLiteによって呼び出すことができます。引数はタイプ（void **）-2つの（void *）値の配列です。最初の（void *）は、実際には型（int（*）（void *））の関数を指しています。接続のビジーハンドラーを呼び出すには、この関数を配列の2番目（void *）を唯一の引数として呼び出す必要があります。ゼロ以外を返す場合は、操作を再試行する必要があります。ゼロが返された場合、カスタムVFSは現在の操作を中止する必要があります。</target>
        </trans-unit>
        <trans-unit id="405e780a5eda0077cf02e3ce6060be9576266571" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connections busy-handler callback. The argument is of type (void **) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connections busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLERの&lt;/a&gt;ファイル制御は、それが接続ビジーハンドラのコールバックへのアクセス権を持つカスタムVFSを提供するために開かれた直後に、データベースのファイルハンドル上のSQLiteによって呼び出すことができます。引数のタイプは（void **）-2つの（void *）値の配列です。最初の（void *）は、実際には（int（*）（void *））型の関数を指します。 connections busy-handlerを呼び出すには、この関数は、配列の2番目（void *）を唯一の引数として呼び出す必要があります。ゼロ以外の値が返された場合、操作を再試行する必要があります。ゼロを返す場合、カスタムVFSは現在の操作を中止する必要があります。</target>
        </trans-unit>
        <trans-unit id="c09f9898013c2f2b9084c257d373e6d8fb8e1f1d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE&lt;/a&gt; opcode is used to request that the VFS extends and truncates the database file in chunks of a size specified by the user. The fourth argument to &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; should point to an integer (type int) containing the new chunk-size to use for the nominated database. Allocating database file space in large chunks (say 1MB at a time), may reduce file-system fragmentation and improve performance on some systems.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZEの&lt;/a&gt;オペコードは、VFSが延びており、ユーザによって指定されたサイズのチャンクのデータベースファイルを切り捨てることを要求するために使用されます。&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;の4番目の引数は、指定されたデータベースに使用する新しいチャンクサイズを含む整数（int型）を指す必要があります。データベースファイルスペースを大きなチャンク（一度に1 MBなど）に割り当てると、ファイルシステムの断片化が減少し、一部のシステムのパフォーマンスが向上する場合があります。</target>
        </trans-unit>
        <trans-unit id="2724ba1a9151f430bfc44ff351307f4c931e3d2e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlckptdone&quot; id=&quot;sqlitefcntlckptdone&quot;&gt;SQLITE_FCNTL_CKPT_DONE&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode after the client has finished copying pages from the wal file to the database file, but before the *-shm file is updated to record the fact that the pages have been checkpointed.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlckptdone&quot; id=&quot;sqlitefcntlckptdone&quot;&gt;SQLITE_FCNTL_CKPT_DONEの&lt;/a&gt;クライアントがデータベースファイルにWALファイルからページのコピーが完了した後に、しかし* -shmファイルはページがチェックポイントされているという事実を記録するために更新される前に、オペコードはWALモードのチェックポイント内から呼び出されます。</target>
        </trans-unit>
        <trans-unit id="e6b7ae020cfbad6284212ff443474df4c8cbc164" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlckptstart&quot; id=&quot;sqlitefcntlckptstart&quot;&gt;SQLITE_FCNTL_CKPT_START&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode before the client starts to copy pages from the wal file to the database file.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlckptstart&quot; id=&quot;sqlitefcntlckptstart&quot;&gt;SQLITE_FCNTL_CKPT_STARTの&lt;/a&gt;クライアントがデータベースファイルにWALファイルからページをコピーする前オペコードはWALモードのチェックポイント内から呼び出されます。</target>
        </trans-unit>
        <trans-unit id="563228c7f58e18a697dff44f98d2797b60b51628" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be performed atomically. This file control returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if and only if the writes were all performed successfully and have been committed to persistent storage. Regardless of whether or not it is successful, this file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITEの&lt;/a&gt;オペコードは、前の呼び出しが成功するため、すべての書き込み操作が発生し&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;アトミックに実行されます。このファイルコントロールは、書き込みがすべて正常に実行され、永続ストレージにコミットされている場合にのみ、&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OKを&lt;/a&gt;返します。成功したかどうかに関係なく、このファイルコントロールはファイル記述子をバッチ書き込みモードから解除するため、後続のすべての書き込み操作は独立しています。 SQLiteは、&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITEの&lt;/a&gt;呼び出しが成功していない限り、SQLITE_FCNTL_COMMIT_ATOMIC_WRITEを呼び出すことはありません。</target>
        </trans-unit>
        <trans-unit id="78b45f1d52cb17aec209a2fdf03a83375e0b951e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS after a transaction has been committed immediately but before the database is unlocked. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWOの&lt;/a&gt;オペコードは、SQLiteのが内部で生成され、トランザクションが即座にコミットされた後でも、データベースのロックが解除される前に、VFSに送信されます。この信号を必要としないVFSは、このオペコードを黙って無視する必要があります。アプリケーションは、このオペコードで&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;を呼び出さないでください。呼び出すと、それを必要とする特殊なVFSの操作が中断される可能性があります。</target>
        </trans-unit>
        <trans-unit id="fe01cd54971699e5fe35af1a0adc94faad95fbe1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provide a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSIONの&lt;/a&gt;オペコードは、データベースファイルへの変更を検出するために使用されます。引数は、32ビットの符号なし整数へのポインターです。ページャの「データバージョン」がポインタに書き込まれます。 「データバージョン」は、対応するデータベースファイルに変更が発生するたびに、同じデータベース接続のSQLステートメントまたは別のデータベース接続によってコミットされたトランザクション（おそらく他のプロセス）によって変更されます。&lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;インターフェースは、接続上の任意のデータベースが変更された場合に検索するために使用することができるが、そのインターフェースTEMPに変化ならびにMAINに応答してのみMAINへの変更を検出するためのメカニズムを提供しません。また、&lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;インターフェイスは内部の変更にのみ応答し、他のデータベース接続によって行われた変更を省略します。&lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;プラグマdata_versionの&lt;/a&gt;コマンドは、他のデータベース接続のために起こる単一取り付けデータベースへの変更を検出するためのメカニズムを提供するが、省いは、それが呼び出されたデータベース接続によって実現変化します。このファイルコントロールは、内部または外部で発生し、特定の接続データベースに関連付けられている変更を検出する唯一のメカニズムです。</target>
        </trans-unit>
        <trans-unit id="429853e91982da517f099946a428569f5a10010d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provides a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSIONの&lt;/a&gt;オペコードは、データベースファイルへの変更を検出するために使用されます。引数は、32ビットの符号なし整数へのポインタです。ポケットベルの「データバージョン」がポインタに書き込まれます。 「データバージョン」は、同じデータベース接続でのSQLステートメントを通じて、または他のプロセスで別のデータベース接続によってコミットされたトランザクションを通じて、対応するデータベースファイルに変更が発生するたびに変更されます。&lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;インターフェースは、接続上の任意のデータベースが変更された場合に検索するために使用することができるが、そのインターフェースTEMPに変化ならびにMAINに応答してのみMAINへの変更を検出するためのメカニズムを提供しません。また、&lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;インターフェイスは内部の変更にのみ応答し、他のデータベース接続によって行われた変更を省略します。&lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;プラグマdata_versionの&lt;/a&gt;コマンドは、他のデータベース接続のために起こる単一取り付けデータベースへの変更を検出するためのメカニズムを提供するが、省いた変化は、それが呼び出されたデータベースに接続することにより実現します。このファイル制御は、内部または外部で発生し、特定の接続されたデータベースに関連付けられている変更を検出する唯一のメカニズムです。</target>
        </trans-unit>
        <trans-unit id="0e0a05c22977d8b1dc9945aac16fc4626f1dd660" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with a particular database connection. See also &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTERの&lt;/a&gt;オペコードへのポインタ取得するために使用される&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;特定のデータベース接続に関連付けられたオブジェクトを。&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="ddddd8caea4f2699898b48925bf95b8d69764816" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt; file control interprets its argument as a pointer to an integer and it writes a boolean into that integer depending on whether or not the file has been renamed, moved, or deleted since it was first opened.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt;ファイル制御は、整数へのポインタとして引数を解釈し、それがファイルは、名前が変更移動、またはそれが最初に開かれてから削除されたか否かに応じて、その整数にブール値を書き込みます。</target>
        </trans-unit>
        <trans-unit id="bc589731780274c54e5cd365284382cd5887eded" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with the journal file (either the &lt;a href=&quot;../lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; or the &lt;a href=&quot;../wal&quot;&gt;write-ahead log&lt;/a&gt;) for a particular database connection. See also &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTERの&lt;/a&gt;オペコードへのポインタ取得するために使用される&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;ジャーナルファイル（のいずれかに関連付けられているオブジェクト&lt;a href=&quot;../lockingv3#rollback&quot;&gt;ロールバックジャーナル&lt;/a&gt;または&lt;a href=&quot;../wal&quot;&gt;先行書き込みログ&lt;/a&gt;特定のデータベース接続のために）。&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="c5d8ff8dd3d322caf95cdc56c272ff4998cee7a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to write the current state of the lock (one of &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;, &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;, &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;, &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt;, or &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt;) into an integer that the pArg argument points to. This capability is used during testing and is only available when the SQLITE_TEST compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATEの&lt;/a&gt;オペコードは、デバッグに使用されます。このオペコードにより、xFileControlメソッドはロックの現在の状態（&lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;、&lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;、&lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;、&lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt;、または&lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVEの&lt;/a&gt;いずれか）をpArg引数が指す整数に書き込みます。この機能はテスト中に使用され、SQLITE_TESTコンパイル時オプションが使用されている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="835bd4a6a4daee4b5c892d531fad550f3b7944bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode causes attempts to obtain a file lock using the xLock or xShmLock methods of the VFS to wait for up to M milliseconds before failing, where M is the single unsigned integer parameter.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUTの&lt;/a&gt;オペコードは、Mは、単一の符号なし整数パラメータである、障害の前にMミリ秒まで待つするVFSのXLOCK又はxShmLock方法を使用してファイルのロックを取得しようとする試みを引き起こします。</target>
        </trans-unit>
        <trans-unit id="f76db0b59ac49aa27a2ffafc1d9d0b7df64c41cd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode is used to configure a VFS to block for up to M milliseconds before failing when attempting to obtain a file lock using the xLock or xShmLock methods of the VFS. The parameter is a pointer to a 32-bit signed integer that contains the value that M is to be set to. Before returning, the 32-bit signed integer is overwritten with the previous value of M.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUTの&lt;/a&gt;オペコードは、VFSのXLOCKまたはxShmLockメソッドを使用してファイルのロックを取得しようとすると失敗する前にMミリ秒までのためにブロックするようにVFSを設定するために使用されます。このパラメーターは、Mが設定される値を含む32ビットの符号付き整数へのポインターです。戻る前に、32ビットの符号付き整数は以前の値のMで上書きされます。</target>
        </trans-unit>
        <trans-unit id="9534ed4df1d95266c96610467198479542d6649c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt; file control is used to query or set the maximum number of bytes that will be used for memory-mapped I/O. The argument is a pointer to a value of type sqlite3_int64 that is an advisory maximum number of bytes in the file to memory map. The pointer is overwritten with the old value. The limit is not changed if the value originally pointed to is negative, and so the current limit can be queried by passing in a pointer to a negative number. This file-control is used internally to implement &lt;a href=&quot;../pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZEの&lt;/a&gt;ファイル制御は、クエリに使用されるか、またはメモリマップドI / Oのために使用されるバイトの最大数を設定されています。引数は、ファイルからメモリマップへの推奨最大バイト数であるsqlite3_int64型の値へのポインターです。ポインタは古い値で上書きされます。最初にポイントされた値が負の場合、制限は変更されないため、負の数へのポインターを渡すことにより、現在の制限を照会できます。このファイル制御は、&lt;a href=&quot;../pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;を実装するために内部的に使用されます。</target>
        </trans-unit>
        <trans-unit id="85959ccb42981e5ee3527aa791391f6482ac784e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE&lt;/a&gt; opcode is invoked by SQLite after opening a write transaction to indicate that, unless it is rolled back for some reason, the entire database file will be overwritten by the current transaction. This is used by VACUUM operations.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITEの&lt;/a&gt;オペコードは、それが何らかの理由でロールバックされていない限り、それを示すために、書き込みトランザクションを開いた後のSQLiteによって呼び出され、データベース全体のファイルは、現在のトランザクションによって上書きされます。これは、VACUUM操作で使用されます。</target>
        </trans-unit>
        <trans-unit id="d2750128ef1083c346294ef6e3be361e6eba77af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; opcode is used to set or query the persistent &lt;a href=&quot;../wal&quot;&gt;Write Ahead Log&lt;/a&gt; setting. By default, the auxiliary write ahead log (&lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt;) and shared memory files used for transaction control are automatically deleted when the latest connection to the database closes. Setting persistent WAL mode causes those files to persist after close. Persisting the files is useful when other processes that do not have write permission on the directory containing the database file want to read the database file, as the WAL and shared memory files must exist in order for the database to be readable. The fourth parameter to &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable persistent WAL mode or 1 to enable persistent WAL mode. If the integer is -1, then it is overwritten with the current WAL persistence setting.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;オペコードは、セットまたはクエリ永続的に使用されている&lt;a href=&quot;../wal&quot;&gt;先読み書き込みログの&lt;/a&gt;設定。デフォルトでは、データベースへの最新の接続が閉じると、トランザクション制御に使用される補助先読みログ（&lt;a href=&quot;../wal#walfile&quot;&gt;WALファイル&lt;/a&gt;）と共有メモリファイルが自動的に削除されます。永続的なWALモードを設定すると、これらのファイルは閉じた後も永続します。データベースを読み取り可能にするにはWALファイルと共有メモリファイルが存在している必要があるため、データベースファイルを含むディレクトリに対する書き込み権限のない他のプロセスがデータベースファイルを読みたい場合、ファイルの永続化が役立ちます。&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;の4番目のパラメーターこのオペコードは整数へのポインタでなければなりません。その整数は、永続的なWALモードを無効にする場合は0、永続的なWALモードを有効にする場合は1です。整数が-1の場合、現在のWAL永続性設定で上書きされます。</target>
        </trans-unit>
        <trans-unit id="e3329771b09c8d9c17e5ba63393baaa851477f87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode is used to set or query the persistent &quot;powersafe-overwrite&quot; or &quot;PSOW&quot; setting. The PSOW setting determines the &lt;a href=&quot;c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; bit of the xDeviceCharacteristics methods. The fourth parameter to &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable zero-damage mode or 1 to enable zero-damage mode. If the integer is -1, then it is overwritten with the current zero-damage mode setting.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITEの&lt;/a&gt;オペコードは、セットまたはクエリ永続的な「powersafe-上書き」または「PSOW」の設定に使用されています。PSOW設定は、xDeviceCharacteristicsメソッドの&lt;a href=&quot;c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt;ビットを決定します。このオペコードの&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;への4番目のパラメーターは、整数へのポインターでなければなりません。その整数は、ゼロダメージモードを無効にする場合は0、ゼロダメージモードを有効にする場合は1です。整数が-1の場合、現在のゼロダメージモード設定で上書きされます。</target>
        </trans-unit>
        <trans-unit id="b7ebc915c79af1c389d3c702e8a0e217f15cd6b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU&lt;/a&gt; opcode is implemented by the special VFS used by the RBU extension only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBUの&lt;/a&gt;オペコードだけRBUの拡張子が使用する特殊なVFSによって実装されます。他のすべてのVFSは、このオペコードに対してSQLITE_NOTFOUNDを返す必要があります。</target>
        </trans-unit>
        <trans-unit id="d7a6279d094b2efb4418d75c6d39f8cf80f5db9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be rolled back. This file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITEの&lt;/a&gt;オペコードは、前の呼び出しが成功するため、すべての書き込み操作が発生し&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;ロールバックします。このファイル制御は、ファイル記述子をバッチ書き込みモードから外し、後続のすべての書き込み操作が独立するようにします。SQLiteは、&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITEの&lt;/a&gt;呼び出しが成功していない限り、SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITEを呼び出すことはありません。</target>
        </trans-unit>
        <trans-unit id="37dec85b72b827823523f2dbeaab4ae1365e897b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt; opcode is used by SQLite to give the VFS layer a hint of how large the database file will grow to be during the current transaction. This hint is not guaranteed to be accurate but it is often close. The underlying VFS might choose to preallocate database file space based on this hint in order to help writes to the database file run faster.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINTの&lt;/a&gt;オペコードは、VFS層にデータベースファイルが現在のトランザクション中に成長する方法を大のヒントを与えるためにSQLiteのに使用されます。このヒントは正確であることが保証されていませんが、近いことがよくあります。基礎となるVFSは、データベースファイルへの書き込みをより高速に実行するために、このヒントに基づいてデータベースファイル領域を事前に割り当てることを選択する場合があります。</target>
        </trans-unit>
        <trans-unit id="53dec04041f2a1cd0f5d61ecfdd7363482736f2d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt; opcode is used by in-memory VFS that implements &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; to set an upper bound on the size of the in-memory database. The argument is a pointer to a &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt;. If the integer pointed to is negative, then it is filled in with the current limit. Otherwise the limit is set to the larger of the value of the integer pointed to and the current database size. The integer pointed to is set to the new limit.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMITの&lt;/a&gt;オペコードは、実装は、そのメモリ内VFSで使用されている&lt;a href=&quot;deserialize&quot;&gt;）（sqlite3_deserialize&lt;/a&gt;アッパーインメモリデータベースのサイズに結合さを設定します。引数は&lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt;へのポインターです。指し示す整数が負の場合、現在の制限値が入ります。それ以外の場合、制限は、ポイントされた整数の値と現在のデータベースサイズの大きい方に設定されます。指す整数は新しい制限に設定されます。</target>
        </trans-unit>
        <trans-unit id="5eb8033743ca0212b9de7ee6d6d452df418e67e7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions master-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNCの&lt;/a&gt;オペコードは、SQLiteのが内部で生成され、XSYNC方法は、データベースのファイル記述子に呼び出される直前VFSに送信されます。または、ユーザーがSQLiteを&lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA同期= OFF&lt;/a&gt;で構成したためにxSyncメソッドが呼び出されない場合は、xSyncメソッドの代わりに呼び出されます。ほとんどの場合、このファイルコントロールで渡されるポインタ引数はNULLです。ただし、データベースファイルがマルチデータベースコミットの一部として同期されている場合、引数は、トランザクションのマスタージャーナルファイル名を含むNULで終了する文字列を指します。この信号を必要としないVFSは、このオペコードを黙って無視する必要があります。アプリケーションは&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）を&lt;/a&gt;呼び出すべきではありません このオペコードを使用すると、それを必要とする特殊なVFSの操作が中断される可能性があるためです。</target>
        </trans-unit>
        <trans-unit id="ca40036ed80ac456626498e6b097f64ffd5f3c6f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions super-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNCの&lt;/a&gt;オペコードは、SQLiteのが内部で生成され、XSYNC方法は、データベースのファイル記述子に呼び出される直前VFSに送信されます。または、ユーザーが&lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA Synchronous = OFF&lt;/a&gt;でSQLiteを構成したためにxSyncメソッドが呼び出されない場合は、xSyncメソッドの代わりに呼び出されます。ほとんどの場合、このファイル制御で渡されるポインタ引数はNULLです。ただし、データベースファイルがマルチデータベースコミットの一部として同期されている場合、引数はトランザクションのスーパージャーナルファイル名を含むヌル終了文字列を指します。この信号を必要としないVFSは、このオペコードを黙って無視する必要があります。アプリケーションは&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）を&lt;/a&gt;呼び出さないでください このオペコードを使用すると、それを必要とする特殊なVFSの動作が中断される可能性があります。</target>
        </trans-unit>
        <trans-unit id="df5b82162695e993bb266a9bcb74822b0cb0729d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt; file control provides advisory information to the VFS about what the higher layers of the SQLite stack are doing. This file control is used by some VFS activity tracing &lt;a href=&quot;../vfs#shim&quot;&gt;shims&lt;/a&gt;. The argument is a zero-terminated string. Higher layers in the SQLite stack may generate instances of this file control if the &lt;a href=&quot;../compile#use_fcntl_trace&quot;&gt;SQLITE_USE_FCNTL_TRACE&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACEの&lt;/a&gt;ファイル制御は、SQLiteのスタックの上位層がやっていることについて、VFSへの助言情報を提供します。このファイルコントロールは、一部のVFSアクティビティトレース&lt;a href=&quot;../vfs#shim&quot;&gt;シムで&lt;/a&gt;使用されます。引数はゼロで終了する文字列です。&lt;a href=&quot;../compile#use_fcntl_trace&quot;&gt;SQLite_USE_FCNTL_TRACE&lt;/a&gt;コンパイル時オプションが有効になっている場合、SQLiteスタックの上位層でこのファイルコントロールのインスタンスが生成される可能性があります。</target>
        </trans-unit>
        <trans-unit id="dc747f657ceac57a6b93ab7190def0e8a928303d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME&lt;/a&gt; opcode can be used to obtain the names of all &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; in the VFS stack. The names are of all VFS shims and the final bottom-level VFS are written into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and the result is stored in the char* variable that the fourth parameter of &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; points to. The caller is responsible for freeing the memory when done. As with all file-control actions, there is no guarantee that this will actually do anything. Callers should initialize the char* variable to a NULL pointer in case this file-control is not implemented. This file-control is intended for diagnostic use only.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAMEの&lt;/a&gt;オペコードは、すべての名前を取得するために使用することができ&lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; VFSスタック内を。名前はすべてのVFSシムの名前であり、最終的な最下位VFSは&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;から取得したメモリに書き込まれ、結果は&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）の&lt;/a&gt; 4番目のパラメーターが指す char *変数に格納されます。呼び出し元は、完了時にメモリを解放する責任があります。すべてのファイル制御アクションと同様に、これが実際に何かを実行するという保証はありません。このファイルコントロールが実装されていない場合、呼び出し元はchar *変数をNULLポインターに初期化する必要があります。このファイル制御は、診断での使用のみを目的としています。</target>
        </trans-unit>
        <trans-unit id="8a271c98ba50f856db7d26935d70d5164c6f00e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; opcode finds a pointer to the top-level &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; currently in use. The argument X in sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be of type &quot;&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&quot;. This opcodes will set *X to a pointer to the top-level VFS. When there are multiple VFS shims in the stack, this opcode finds the upper-most shim only.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTERの&lt;/a&gt;オペコードは、トップレベルへのポインタ見つけ&lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt;現在使用されています。sqlite3_file_control（db、SQLITE_FCNTL_VFS_POINTER、X）の引数Xは、タイプ &quot; &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&quot; でなければなりません。このオペコードは、* XをトップレベルのVFSへのポインターに設定します。スタックに複数のVFSシムがある場合、このオペコードは最上位のシムのみを検出します。</target>
        </trans-unit>
        <trans-unit id="5113389d53b260a388ff9b96ca66847bbd222b0d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK&lt;/a&gt; is a signal to the VFS layer that it might be advantageous to block on the next WAL lock if the lock is not immediately available. The WAL subsystem issues this signal during rare circumstances in order to fix a problem with priority inversion. Applications should &lt;em&gt;not&lt;/em&gt; use this file-control.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCKは&lt;/a&gt;ロックが利用可能でない場合、次のWALロックをブロックすることが有利であるかもしれないことをVFS層に信号です。WALサブシステムは、優先順位の逆転の問題を修正するために、まれな状況でこの信号を発行します。アプリケーションはこのファイルコントロールを使用し&lt;em&gt;ないで&lt;/em&gt;ください。</target>
        </trans-unit>
        <trans-unit id="6f1b780daaf82dc713d986bde97a154815b1318d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY&lt;/a&gt; opcode is used to configure automatic retry counts and intervals for certain disk I/O operations for the windows &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt; in order to provide robustness in the presence of anti-virus programs. By default, the windows VFS will retry file read, file write, and file delete operations up to 10 times, with a delay of 25 milliseconds before the first retry and with the delay increasing by an additional 25 milliseconds with each subsequent retry. This opcode allows these two values (10 retries and 25 milliseconds of delay) to be adjusted. The values are changed for all database connections within the same process. The argument is a pointer to an array of two integers where the first integer is the new retry count and the second integer is the delay. If either integer is negative, then the setting is not changed but instead the prior value of that setting is written into the array entry, allowing the current retry settings to be interrogated. The zDbName parameter is ignored.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRYの&lt;/a&gt;オペコードは、特定のディスクの自動再試行回数と間隔を設定するために使用されているWindows用のI / O操作&lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt;ウイルス対策プログラムの存在下で堅牢性を提供するため。デフォルトでは、Windows VFSはファイルの読み取り、ファイルの書き込み、およびファイルの削除操作を最大10回再試行します。最初の再試行までに25ミリ秒の遅延があり、その後の再試行ごとに遅延がさらに25ミリ秒増加します。このオペコードにより、これらの2つの値（10回の再試行と25ミリ秒の遅延）を調整できます。同じプロセス内のすべてのデータベース接続の値が変更されます。引数は2つの整数の配列へのポインターです。最初の整数は新しい再試行回数で、2番目の整数は遅延です。いずれかの整数が負の場合、設定は変更されませんが、代わりにその設定の以前の値が配列エントリに書き込まれ、現在の再試行設定を問い合わせることができます。zDbNameパラメータは無視されます。</target>
        </trans-unit>
        <trans-unit id="937fe17d531247dde2a8c434e7c019ad55d302c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt; opcode can be used to obtain the underlying native file handle associated with a file handle. This file control interprets its argument as a pointer to a native file handle and writes the resulting value there.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLEの&lt;/a&gt;オペコードは、ファイルハンドルに関連付けられている基礎となるネイティブファイルハンドルを取得するために使用することができます。このファイルコントロールは、引数をネイティブファイルハンドルへのポインターとして解釈し、結果の値をそこに書き込みます。</target>
        </trans-unit>
        <trans-unit id="e6e591e785c2547026326ba62eddb1a8e3a00235" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to swap the file handle with the one pointed to by the pArg argument. This capability is used during testing and only needs to be supported when SQLITE_TEST is defined.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLEの&lt;/a&gt;オペコードは、デバッグに使用されます。このオペコードにより、xFileControlメソッドは、ファイルハンドルを、pArg引数によってポイントされたものと交換します。この機能はテスト中に使用され、SQLITE_TESTが定義されている場合にのみサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="5d3e0696fb81e2cd89dc43dbc9ef7b0440a8b5e7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS&lt;/a&gt; opcode is implemented by zipvfs only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFSの&lt;/a&gt;オペコードだけzipvfsによって実装されます。他のすべてのVFSは、このオペコードに対してSQLITE_NOTFOUNDを返す必要があります。</target>
        </trans-unit>
        <trans-unit id="15edb51b39cd83bfa83c4b8e2f7138c93f46e748" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; flag means the file should be deleted when it is closed. The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; will be set for TEMP databases and their journals, transient databases, and subjournals.</source>
          <target state="translated">&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSEの&lt;/a&gt;フラグは、それが閉じているときに、ファイルが削除されるべきであることを意味します。&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSEは、&lt;/a&gt; TEMPデータベースとそのジャーナル、過渡データベース、およびsubjournalsのために設定されます。</target>
        </trans-unit>
        <trans-unit id="fc3c6baa196558e15836748dd318cdd30a688ef6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; flag is always used in conjunction with the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; flag, which are both directly analogous to the O_EXCL and O_CREAT flags of the POSIX open() API. The SQLITE_OPEN_EXCLUSIVE flag, when paired with the SQLITE_OPEN_CREATE, is used to indicate that file should always be created, and that it is an error if it already exists. It is</source>
          <target state="translated">&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt;フラグは常にと一緒に使用される&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATEの&lt;/a&gt;両方POSIXオープン（）APIのO_EXCLとO_CREATフラグに直接類似しているフラグ。SQLITE_OPEN_EXCLUSIVEフラグは、SQLITE_OPEN_CREATEと組み合わせて使用​​すると、ファイルを常に作成する必要があること、およびファイルがすでに存在する場合はエラーであることを示します。です</target>
        </trans-unit>
        <trans-unit id="c2061592c87f5f999944ce29cf7569df9e8b3f69" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; C preprocessor macro in the sqlite3.h header evaluates to a string literal that is the SQLite version in the format &quot;X.Y.Z&quot; where X is the major version number (always 3 for SQLite3) and Y is the minor version number and Z is the release number. The &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; C preprocessor macro resolves to an integer with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the same numbers used in &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;. The SQLITE_VERSION_NUMBER for any given release of SQLite will also be larger than the release from which it is derived. Either Y will be held constant and Z will be incremented or else Y will be incremented and Z will be reset to zero.</source>
          <target state="translated">sqlite3.hヘッダーの&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; Cプリプロセッサマクロは、「XYZ」形式のSQLiteバージョンである文字列リテラルに評価されます。Xはメジャーバージョン番号（SQLite3の場合は常に3）、Yはマイナーバージョン番号、Zはリリース番号。&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; Cプリプロセッサ値を有する整数マクロ解決さ（X * 1000000 + Y&amp;times;1000 + Z）X、Y、及びZは、で使用したのと同じ数である&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;。 SQLiteの特定のリリースのSQLITE_VERSION_NUMBERは、それが派生したリリースよりも大きくなります。 Yが一定に保持され、Zがインクリメントされるか、Yがインクリメントされ、Zがゼロにリセットされます。</target>
        </trans-unit>
        <trans-unit id="ffc6747416294fa8545c14bddccb7cfdc4ee3b78" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; interface unregisters the initialization routine X that was registered using a prior call to &lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension(X)&lt;/a&gt;. The &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; routine returns 1 if initialization routine X was successfully unregistered and it returns 0 if X was not on the list of initialization routines.</source>
          <target state="translated">&lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension（X）&lt;/a&gt;インターフェースが前の呼び出し使用して登録された初期化ルーチンX登録解除&lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension（X）を&lt;/a&gt;。&lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension（X）&lt;/a&gt;初期化ルーチンXであれば、リターン1が正常に登録解除されたとXは、初期化ルーチンのリストに載っていなかった場合には0を返します。</target>
        </trans-unit>
        <trans-unit id="5d6d6c3ad7f7d02755c43722a7a4b2dabb76ea67" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;carray&quot;&gt;carray table-valued function&lt;/a&gt; needs to accept a pointer to an array of C-language values from the application.</source>
          <target state="translated">&lt;a href=&quot;carray&quot;&gt;CARRAYテーブル値関数は、&lt;/a&gt;アプリケーションからC言語の値の配列へのポインタを受け入れる必要があります。</target>
        </trans-unit>
        <trans-unit id="99b9d11b0a4071822aa18a343a895720b0d0af06" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cli#dump&quot;&gt;.dump&lt;/a&gt; command now accepts multiple LIKE-pattern arguments and outputs the union of all matching tables.</source>
          <target state="translated">&lt;a href=&quot;cli#dump&quot;&gt;.dumpの&lt;/a&gt;コマンドは、複数のLIKEパターンの引数を受け入れ、一致するすべてのテーブルの和を出力します。</target>
        </trans-unit>
        <trans-unit id="c282faf1973e4f89130abe26a61f3f513af735e2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#default_page_size&quot;&gt;SQLITE_DEFAULT_PAGE_SIZE&lt;/a&gt; compile-time option can be used to change the default page size assigned to new databases.</source>
          <target state="translated">&lt;a href=&quot;compile#default_page_size&quot;&gt;SQLITE_DEFAULT_PAGE_SIZE&lt;/a&gt;コンパイル時のオプションは、新しいデータベースに割り当てられたデフォルトのページサイズを変更するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="5f025c2cb604da7be21c2713e7ae110d6fc22479" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#default_page_size&quot;&gt;SQLITE_DEFAULT_PAGE_SIZE&lt;/a&gt; is increased from 1024 to 4096. The &lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZE&lt;/a&gt; is changed from 2000 to -2000 so the same amount of cache memory is used by default. See the application note on the &lt;a href=&quot;pgszchng2016&quot;&gt;version 3.12.0 page size change&lt;/a&gt; for further information.</source>
          <target state="translated">&lt;a href=&quot;compile#default_page_size&quot;&gt;SQLITE_DEFAULT_PAGE_SIZEは、&lt;/a&gt; 1024年から4096に増加している&lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZEが&lt;/a&gt;同じ量のキャッシュ・メモリーがデフォルトで使用されているので、2000年から-2000に変更されます。詳細については、&lt;a href=&quot;pgszchng2016&quot;&gt;バージョン3.12.0のページサイズの変更&lt;/a&gt;に関するアプリケーションノートを参照してください。</target>
        </trans-unit>
        <trans-unit id="623f46dd8d1f8aedc876d36b9e6b7c6843fb38ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#direct_overflow_read&quot;&gt;-DSQLITE_DIRECT_OVERFLOW_READ&lt;/a&gt; compile-time option causes SQLite to bypass its page cache when reading content from overflow pages. This helps database reads of 10K blobs run a little faster, but not all that much faster. SQLite still holds a speed advantage over direct filesystem reads without the SQLITE_DIRECT_OVERFLOW_READ compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#direct_overflow_read&quot;&gt;-DSQLITE_DIRECT_OVERFLOW_READ&lt;/a&gt;オーバーフローページからコンテンツを読み込むときにコンパイル時のオプションでは、そのページのキャッシュバイパスにSQLiteの原因となります。これにより、10K blobのデータベース読み取りが少し速くなりますが、それほど高速ではありません。SQLiteは、SQLITE_DIRECT_OVERFLOW_READコンパイル時オプションのないファイルシステムの直接読み取りよりも速度の面で有利です。</target>
        </trans-unit>
        <trans-unit id="e8d73bde2dc7785ffa127c202c3991e5af269a19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; compile-time option is now turned on by default in the standard builds.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt;コンパイル時のオプションは、現在、標準のビルドではデフォルトでオンになっています。</target>
        </trans-unit>
        <trans-unit id="ec9ba2ea4ea2e87921df34017de3d69d7b4137bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; compile-time option causes the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command to collect a small histogram of each index, to help SQLite better select among competing range query indices.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;コンパイル時のオプションが原因&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; SQLiteのがより良い競合範囲クエリの指標の中から選択できるように、各指標の小さなヒストグラムを収集するためのコマンドを。</target>
        </trans-unit>
        <trans-unit id="e0180c578d01206ca2260b932e5fe2d4e6cc6568" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_...&lt;/a&gt; compile-time options only work when building from canonical source files. They do &lt;u&gt;not&lt;/u&gt; work when you build from the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; or from the pre-processed source files.</source>
          <target state="translated">&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _...&lt;/a&gt;正規のソースファイルからビルドするときにコンパイル時のオプションはのみ動作します。SQLite &lt;a href=&quot;amalgamation&quot;&gt;アマルガム&lt;/a&gt;から、または前処理されたソースファイルからビルドする場合は機能し&lt;u&gt;ません&lt;/u&gt;。</target>
        </trans-unit>
        <trans-unit id="f951ab56418025da71fd3229ec924e7681f98557" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT&lt;/a&gt; option sets an initial baseline value for the maximum number of index-and-constraint combinations that the query planner consider. The baseline query planner limit is increased by SQLITE_QUERY_PLANNER_LIMIT_INCR prior to processing each table of a join so that each table is guaranteed to be able to propose at least some index-and-constraint combinations to the optimizer even if prior tables of the join have exhausted the baseline limit. The default value for both this compile-time option and the &lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT&lt;/a&gt; option are set high enough so that they should never be reached for real-world queries.</source>
          <target state="translated">&lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMITの&lt;/a&gt;オプションは、クエリプランナが検討することをインデックスと制約の組み合わせの最大数の初期ベースライン値を設定します。ベースラインクエリプランナーの制限は、結合の各テーブルを処理する前にSQLITE_QUERY_PLANNER_LIMIT_INCRによって増加します。これにより、結合の前のテーブルが少なくともいくつかのインデックスと制約の組み合わせをオプティマイザに提案できることが保証されます。ベースライン制限。このコンパイル時オプションと&lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT&lt;/a&gt;オプションの両方のデフォルト値は、実際のクエリでは決して到達しないように十分に高く設定されています。</target>
        </trans-unit>
        <trans-unit id="4cd49b137fd67eca14bbcc5b6c746f08a2997711" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; compile-time option fixed to make sure that content is deleted even when the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; applies.</source>
          <target state="translated">&lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt;コンパイル時のオプションは、必ず際に、コンテンツも削除されたことを確認するために、固定&lt;a href=&quot;lang_delete#truncateopt&quot;&gt;切り捨て最適化が&lt;/a&gt;適用されます。</target>
        </trans-unit>
        <trans-unit id="656d7af3931cb41fc80d6fdefc85a4cfb80b7c01" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter is a #define whose value is an integer between 0 and 3, inclusive. The meaning of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter is as follows:</source>
          <target state="translated">&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;コンパイル時のパラメータは、その値が0と3までの整数であるの#defineです。&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;コンパイル時パラメーターの意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="4c11588171d30d65004665748aee39867b770ec3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option can be used to limit the length of &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt; expansion in the output of sqlite3_trace().</source>
          <target state="translated">&lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt;コンパイル時オプションは、の長さを制限するために使用することができる&lt;a href=&quot;lang_expr#varparam&quot;&gt;上限パラメータ&lt;/a&gt; sqlite3_traceの出力で膨張を（）。</target>
        </trans-unit>
        <trans-unit id="355c715bbc78271373ada3410d668232a6d1cc69" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option limits the size of bound parameter expansions. The &lt;a href=&quot;compile#omit_trace&quot;&gt;SQLITE_OMIT_TRACE&lt;/a&gt; compile-time option causes sqlite3_expanded_sql() to always return NULL.</source>
          <target state="translated">&lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt;コンパイル時のオプションは、バインドされたパラメータ展開のサイズを制限します。&lt;a href=&quot;compile#omit_trace&quot;&gt;SQLITE_OMIT_TRACE&lt;/a&gt;コンパイル時のオプションは常にNULLを返すために）（sqlite3_expanded_sqlの原因となります。</target>
        </trans-unit>
        <trans-unit id="d80a700ed456a052f14722da1654635b16877833" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA=0&lt;/a&gt; compile-time option will cause this setting to default to OFF.</source>
          <target state="translated">&lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA = 0&lt;/a&gt;コンパイル時のオプションは、この設定はOFFにデフォルト設定になります。</target>
        </trans-unit>
        <trans-unit id="4f82d70cfe7739c80fc41874304dfb1e1ffafd3f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;, ...) interface can register an alternative page cache implementation by passing in an instance of the sqlite3_pcache_methods2 structure. In many applications, most of the heap memory allocated by SQLite is used for the page cache. By implementing a custom page cache using this API, an application can better control the amount of memory consumed by SQLite, the way in which that memory is allocated and released, and the policies used to determine exactly which parts of a database file are cached and for how long.</source>
          <target state="translated">&lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;、...）インタフェースはsqlite3_pcache_methods2構造体のインスタンスを渡すことによって、代替ページキャッシュの実装を登録することができます。多くのアプリケーションでは、SQLiteによって割り当てられたヒープメモリのほとんどがページキャッシュに使用されます。このAPIを使用してカスタムページキャッシュを実装することにより、アプリケーションは、SQLiteによって消費されるメモリの量、そのメモリの割り当てと解放の方法、およびデータベースファイルのどの部分をキャッシュするかを正確に決定するために使用されるポリシーをより適切に制御できます。どれだけの時間。</target>
        </trans-unit>
        <trans-unit id="28bbb907be12b8d8d6cb3f58bde73db3db4a2a3e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output no longer shows an estimate of the number of rows generated by each loop in a join.</source>
          <target state="translated">&lt;a href=&quot;eqp&quot;&gt;クエリプランEXPLAIN&lt;/a&gt;の各ループによって生成される行の数の推定値が参加出力もはやショー。</target>
        </trans-unit>
        <trans-unit id="0403e12475b1041021c7db25c8bbeab40ee20902" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface makes a direct call to the xFileControl method for the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object associated with a particular database identified by the second argument. The name of the database is &quot;main&quot; for the main database or &quot;temp&quot; for the TEMP database, or the name that appears after the AS keyword for databases that are added using the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL command. A NULL pointer can be used in place of &quot;main&quot; to refer to the main database file. The third and fourth parameters to this routine are passed directly through to the second and third parameters of the xFileControl method. The return value of the xFileControl method becomes the return value of this routine.</source>
          <target state="translated">&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;インターフェースがためxFileControlメソッドを直接呼び出すことができる&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methodsが&lt;/a&gt;二番目の引数によって識別される特定のデータベースに関連付けられたオブジェクトを。データベースの名前は、メインデータベースの場合は「main」、TEMPデータベースの場合は「temp」、または&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQLコマンドを使用して追加されたデータベースのASキーワードの後に​​表示される名前です。 「main」の代わりにNULLポインタを使用して、メインデータベースファイルを参照できます。このルーチンの3番目と4番目のパラメーターは、xFileControlメソッドの2番目と3番目のパラメーターに直接渡されます。 xFileControlメソッドの戻り値は、このルーチンの戻り値になります。</target>
        </trans-unit>
        <trans-unit id="c477329521e0c202c4f6312a9b20720b0061408f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fileformat2&quot;&gt;underlying file format&lt;/a&gt; for SQLite databases does not change in incompatible ways. There are literally hundreds of billions, perhaps trillions, of SQLite database files in circulation and the SQLite developers are committing to supporting those files for decades into the future.</source>
          <target state="translated">SQLiteデータベースの&lt;a href=&quot;fileformat2&quot;&gt;基本的なファイル形式&lt;/a&gt;は、互換性のない方法で変更されません。文字通り数千億、おそらく数兆のSQLiteデータベースファイルが流通しており、SQLite開発者はそれらのファイルを何十年もの間サポートすることを約束しています。</target>
        </trans-unit>
        <trans-unit id="019a9b5a0c4bab7b2872e5382ef484fc4c667e1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fileformat2#validfor&quot;&gt;version-valid-for number&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fileformat2#validfor&quot;&gt;バージョン-有効-の番号&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="47ad55bfdbffd81a341414cce2caff94549fb57d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL file format&lt;/a&gt; is precisely defined and is cross-platform.</source>
          <target state="translated">&lt;a href=&quot;fileformat2#walformat&quot;&gt;WALファイル形式は&lt;/a&gt;、正確に定義されており、クロスプラットフォームです。</target>
        </trans-unit>
        <trans-unit id="d24509e4b9939bc43b94f948e05ab88b6b7e58c7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;floatingpoint#decext&quot;&gt;decimal extension&lt;/a&gt; and the &lt;a href=&quot;floatingpoint#ieee754ext&quot;&gt;ieee754 extension&lt;/a&gt; are built-in to the CLI</source>
          <target state="translated">&lt;a href=&quot;floatingpoint#decext&quot;&gt;小数の拡張&lt;/a&gt;と&lt;a href=&quot;floatingpoint#ieee754ext&quot;&gt;IEEE754拡張子は&lt;/a&gt;、内蔵されているCLIへ</target>
        </trans-unit>
        <trans-unit id="3e921edb70343a6bdb367da8f2286bed023bed5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;foreignkeys#parentchild&quot;&gt;parent key&lt;/a&gt; of a &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; is not allowed to use the rowid. The parent key must used named columns only.</source>
          <target state="translated">&lt;a href=&quot;foreignkeys&quot;&gt;外部キー制約&lt;/a&gt;の&lt;a href=&quot;foreignkeys#parentchild&quot;&gt;親キー&lt;/a&gt;は、ROWIDを使用できません。親キーは名前付きの列のみを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="94136fe2e1cb36bfe5b8895ca9db2e90ee44f1f5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; MATCH operator passes pointers into &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt;, &lt;a href=&quot;fts3#offsets&quot;&gt;offsets()&lt;/a&gt;, and &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; MATCHオペレータはへのポインタを通過&lt;a href=&quot;fts3#snippet&quot;&gt;スニペットを（） &lt;/a&gt;、&lt;a href=&quot;fts3#offsets&quot;&gt;オフセット（） &lt;/a&gt;、と&lt;a href=&quot;fts3#matchinfo&quot;&gt;のMatchInfo（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="43eb5ae7856e6e2985afc5b90e134ad6efe6a669" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#*fts4rebuidcmd&quot;&gt;FTS4 &quot;rebuild&quot; command&lt;/a&gt; deletes the entire full-text index and rebuilds it based on the current set of documents in the content table. Assuming again that &quot;t3&quot; is the name of the external content FTS4 table, the rebuild command looks like this:</source>
          <target state="translated">&lt;a href=&quot;fts3#*fts4rebuidcmd&quot;&gt;FTS4コマンドは、「再構築」&lt;/a&gt;全体のフルテキストインデックスを削除し、コンテンツテーブル内のドキュメントの現在のセットに基づいて、それを再構築します。再度、「t3」が外部コンテンツFTS4テーブルの名前であると仮定すると、rebuildコマンドは次のようになります。</target>
        </trans-unit>
        <trans-unit id="a98c7bde5e55ca0fc0875001b5230f001bb8d1a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; function always returns NULL unless either the legacy application-defined FTS3 tokenizers interface are enabled using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;) setting, or unless the first argument to fts3_tokenizer() is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer（）&lt;/a&gt;関数は常にNULLを返していない限りいずれかを使用して有効になっているインターフェース、レガシーアプリケーション定義FTS3トークナイザ&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;）設定、またはfts3_tokenizerの最初の引数は（）である場合を除き&lt;a href=&quot;lang_expr#varparam&quot;&gt;、結合したパラメーター&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1574210b17663fb17af96bfd5572d4febc918bf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;FTS MATCH&lt;/a&gt; operator is supported for queries based on the built-in full-text index.</source>
          <target state="translated">&lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;FTS MATCHの&lt;/a&gt;オペレータは、内蔵のフルテキストインデックスに基づくクエリでサポートされています。</target>
        </trans-unit>
        <trans-unit id="afda903a3f03dcbd2f01644e1f0a3ea9a0e62818" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#matchinfo-x&quot;&gt;matchinfo 'x' flag&lt;/a&gt; would report a single hit for the phrases &quot;a&quot; and &quot;c&quot;. However, the 'y' directive reports the number of hits for &quot;c&quot; as zero, as it is part of a sub-expression that does not match the document - (b AND c). For queries that do not contain AND operators descended from OR operators, the result values returned by 'y' are always the same as those returned by 'x'.</source>
          <target state="translated">&lt;a href=&quot;fts3#matchinfo-x&quot;&gt;MatchInfo「X」フラグは、&lt;/a&gt;フレーズ「」と「C」のためのシングルヒットを報告します。ただし、「y」ディレクティブは「c」のヒット数をゼロとして報告します。これは、ドキュメントに一致しない部分式の一部であるためです-（b AND c）。OR演算子から派生したAND演算子を含まないクエリの場合、「y」から返される結果値は「x」から返される結果値と常に同じです。</target>
        </trans-unit>
        <trans-unit id="5a3b429b14a3a0c21190f0bbe4a4fec620e8c35a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;, &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt;, &lt;a href=&quot;fts3#offsets&quot;&gt;offsets()&lt;/a&gt;, and &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; are available to support full-text queries.</source>
          <target state="translated">&lt;a href=&quot;fts3#snippet&quot;&gt;FTSの補助機能&lt;/a&gt;、&lt;a href=&quot;fts3#snippet&quot;&gt;スニペット（） &lt;/a&gt;、&lt;a href=&quot;fts3#offsets&quot;&gt;オフセット（） &lt;/a&gt;、および&lt;a href=&quot;fts3#matchinfo&quot;&gt;のMatchInfo（）は&lt;/a&gt;、フルテキストクエリをサポートするのに利用可能です。</target>
        </trans-unit>
        <trans-unit id="986cc21a6b9f4c0f213b24757430a9834e1ed2e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#snippet&quot;&gt;snippet&lt;/a&gt; function cannot be used with the above query. Because the outer query does not include a &quot;WHERE ... MATCH&quot; clause, the snippet function may not be used with it. One solution is to duplicate the WHERE clause used by the sub-query in the outer query. The overhead associated with this is usually negligible.</source>
          <target state="translated">&lt;a href=&quot;fts3#snippet&quot;&gt;スニペット&lt;/a&gt;機能は、上記のクエリで使用することはできません。外側のクエリには &quot;WHERE ... MATCH&quot;句が含まれていないため、スニペット関数は使用できません。1つの解決策は、外部クエリのサブクエリで使用されるWHERE句を複製することです。これに関連するオーバーヘッドは通常、無視できます。</target>
        </trans-unit>
        <trans-unit id="6bce43282ea827774137f471cf2a2f9eafebbd71" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; tokenizer is now included in &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; by default.</source>
          <target state="translated">&lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt;トークナイザは今に含まれている&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;デフォルトで。</target>
        </trans-unit>
        <trans-unit id="d0b9e4179a7690f373db2c622ddd029271ea2c29" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25() auxiliary function&lt;/a&gt; returns a real value reflecting the accuracy of the current match. Better matches are assigned numerically lower values.</source>
          <target state="translated">&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;BM25（）補助機能は、&lt;/a&gt;現在のマッチの正確さを反映する真の値を返します。一致度が高いほど、数値的に低い値が割り当てられます。</target>
        </trans-unit>
        <trans-unit id="86d537287fe3b1d151168bae58fabce38b16555d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;columnsize&quot; option&lt;/a&gt;, used to configure whether or not the size in tokens of each value in the FTS5 table is stored separately within the database.</source>
          <target state="translated">&lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;「ColumnSizeが」オプション&lt;/a&gt; FTS5テーブル内の各値のトークンにサイズがデータベース内に別々に格納されているか否かを設定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="4542957e1a08fcc6a2bdcd49b04a58f559cf1ff8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_detail_option&quot;&gt;&quot;detail&quot; option&lt;/a&gt;. This option may be used to reduce the size of the FTS index on disk by omitting some information from it.</source>
          <target state="translated">&lt;a href=&quot;fts5#the_detail_option&quot;&gt;「詳細」オプション&lt;/a&gt;。このオプションを使用すると、一部の情報を省略して、ディスク上のFTSインデックスのサイズを縮小できます。</target>
        </trans-unit>
        <trans-unit id="e41a2e84baae07818885bfa4f91b936da5a1f958" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_highlight_function&quot;&gt;highlight() auxiliary function&lt;/a&gt; returns a copy of the text from one of the columns of the current match with each instance of a queried term within the result surrounded by specified markup (for example &quot;&amp;lt;b&amp;gt;&quot; and &quot;&amp;lt;/b&amp;gt;&quot;).</source>
          <target state="translated">&lt;a href=&quot;fts5#the_highlight_function&quot;&gt;ハイライト（）補助機能は、&lt;/a&gt;結果内の照会用語の各インスタンスに現在一致の列のいずれかからのテキストのコピーを返す（例えば、「&amp;lt;B&amp;gt;」と「&amp;lt;/ B&amp;gt;」指定したマークアップに囲まれ）。</target>
        </trans-unit>
        <trans-unit id="b98a3fb75c4347301e0a46ec5f5ca45961387193" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_snippet_function&quot;&gt;snippet() auxiliary function&lt;/a&gt; selects a short fragment of text from one of the columns of the matched row and returns it with each instance of a queried term surrounded by markup in the same manner as the highlight() function. The fragment of text is selected so as to maximize the number of queried terms it contains.</source>
          <target state="translated">&lt;a href=&quot;fts5#the_snippet_function&quot;&gt;スニペット（）補助機能は、&lt;/a&gt;一致行の列とハイライト（）関数と同様に、マークアップで囲まれた照会用語の各インスタンスに戻ることのうちの1つからのテキストの短い断片を選択します。テキストのフラグメントは、それが含む照会された用語の数を最大化するように選択されます。</target>
        </trans-unit>
        <trans-unit id="3a9eabcd215930eb738f36712bb83d6c0b14ec4f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;American Fuzzy Lop&lt;/a&gt; or &quot;AFL&quot; fuzzer is a recent (circa 2014) innovation from Michal Zalewski. Unlike most other fuzzers that blindly generate random inputs, the AFL fuzzer instruments the program being tested (by modifying the assembly-language output from the C compiler) and uses that instrumentation to detect when an input causes the program to do something different - to follow a new control path or loop a different number of times. Inputs that provoke new behavior are retained and further mutated. In this way, AFL is able to &quot;discover&quot; new behaviors of the program under test, including behaviors that were never envisioned by the designers.</source>
          <target state="translated">&lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;アメリカンファジーロプ&lt;/a&gt;または「AFL」fuzzerはミハルZalewski氏から最近（2014年頃）の技術革新です。ランダム入力を盲目的に生成する他のほとんどのファザーとは異なり、AFLファザーは（Cコンパイラーからのアセンブリ言語出力を変更することによって）テスト対象のプログラムをインストルメント化し、そのインストルメンテーションを使用して、入力がプログラムに何か別のことをさせるタイミングを検出します。新しい制御パスまたは異なる回数のループ。新しい動作を引き起こす入力は保持され、さらに変化します。このようにして、AFLは、テスト対象のプログラムの新しい動作（設計者が想定していなかった動作を含む）を「発見」できます。</target>
        </trans-unit>
        <trans-unit id="8ddbb2bd7ba87408b594939a6917d04da89a5349" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt; is the version control system used to track all of the SQLite source code. A Fossil repository is an SQLite database file. (Readers are invited to ponder this recursion as an independent exercise.) Fossil is both the version-control system for SQLite and a test platform for SQLite. Whenever enhancements are made to SQLite, Fossil is one of the first applications to test and evaluate those enhancements. So Fossil was an early adopter of the NGQP.</source>
          <target state="translated">&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;化石DVCS&lt;/a&gt; SQLiteのソースコードのすべてを追跡するために使用されるバージョン管理システムです。 FossilリポジトリはSQLiteデータベースファイルです。 （読者は、この再帰を独立した演習として熟考するよう招待されています。）Fossilは、SQLiteのバージョン管理システムであり、SQLiteのテストプラットフォームでもあります。 SQLiteが拡張された場合、Fossilはそれらの拡張をテストおよび評価する最初のアプリケーションの1つです。したがって、FossilはNGQPの初期の採用者でした。</target>
        </trans-unit>
        <trans-unit id="cca3e4effc9207d5a63c711cbfd8ac97defe5fba" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.sqlite.org/sqllogictest&quot; id=&quot;slt&quot;&gt;&lt;b&gt;SQL Logic Test&lt;/b&gt;&lt;/a&gt; or SLT test harness is used to run huge numbers of SQL statements against both SQLite and several other SQL database engines and verify that they all get the same answers. SLT currently compares SQLite against PostgreSQL, MySQL, Microsoft SQL Server, and Oracle 10g. SLT runs 7.2 million queries comprising 1.12GB of test data.</source>
          <target state="translated">&lt;a href=&quot;http://www.sqlite.org/sqllogictest&quot; id=&quot;slt&quot;&gt;&lt;b&gt;SQLロジックのテスト&lt;/b&gt;&lt;/a&gt;やSLTテストハーネスは、SQLiteの、いくつかの他のSQLデータベースエンジンの両方に対してSQL文の膨大な数を実行し、それらはすべて同じ答えを得ることを確認するために使用されます。 SLTは現在、SQLiteをPostgreSQL、MySQL、Microsoft SQL Server、およびOracle 10gと比較しています。 SLTは、1.12GBのテストデータで構成される720万のクエリを実行します。</target>
        </trans-unit>
        <trans-unit id="154e70bf20f83a327304d76749961d8773743242" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://en.wikipedia.org/wiki/Web_SQL_Database&quot;&gt;WebSQL&lt;/a&gt; interface to webkit allowed any webpage to run arbitrary SQL in the browser for Chrome and Safari. That arbitrary SQL was supposed to be run inside a sandbox where it could do no harm even if exploited, but that sandbox turned out to be less secure than people supposed. In the spring of 2017, one team of hackers was able to root an iMac using a long sequence of exploits, one of which involved corrupting the pointers passed as BLOB values to the snippet() FTS3 function of an SQLite database running via the WebSQL interface inside of Safari.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Web_SQL_Database&quot;&gt;Webkit&lt;/a&gt;へのWebSQLインターフェースにより、任意のWebページがChromeおよびSafariのブラウザーで任意のSQLを実行できるようになりました。その任意のSQLは、悪用されても害を及ぼさないサンドボックス内で実行されるはずでしたが、そのサンドボックスは、人々が想定するよりも安全性が低いことが判明しました。2017年の春に、ハッカーの1つのチームが長いシーケンスのエクスプロイトを使用してiMacをルート化することができました。その1つは、WebSQLインターフェースを介して実行されるSQLiteデータベースのsnippet（）FTS3関数にBLOB値として渡されたポインターを破損することでした。サファリの中。</target>
        </trans-unit>
        <trans-unit id="6101be379589e2c8cd0e728015188ca8e192b3db" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil Distributed Version Control&lt;/a&gt; system provides users with the option to download check-ins as either Tarballs, ZIP Archives, or SQLite Archives.</source>
          <target state="translated">&lt;a href=&quot;https://fossil-scm.org/&quot;&gt;化石分散型バージョン管理&lt;/a&gt;システムでは、tarで固め、ZIPアーカイブ、またはSQLiteのアーカイブのいずれかとして、ダウンロードのチェックインのオプションをユーザーに提供します。</target>
        </trans-unit>
        <trans-unit id="6106b2007efa210c8ee70fed3636c5f43bb5c12d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;Append VFS&lt;/a&gt; is a &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; that allows an SQLite database to be appended to some other file. This allows (for example) a database to be appended to an executable that then opens and reads the database.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;追加VFSは&lt;/a&gt;ある&lt;a href=&quot;vfs#shim&quot;&gt;VFSシム&lt;/a&gt;のSQLiteデータベースは、いくつかの他のファイルに追加することができます。これにより、（たとえば）データベースを実行可能ファイルに追加して、データベースを開いて読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="80173a6349ab4ffb46f02ada86de670d66a57b26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/btreeinfo.c&quot;&gt;sqlite_btreeinfo&lt;/a&gt; eponymous virtual table for introspecting and estimating the sizes of the btrees in a database.</source>
          <target state="translated">データベース内のbtreeのサイズをイントロ&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/btreeinfo.c&quot;&gt;スペクト&lt;/a&gt;および推定するためのsqlite_btreeinfoの代名詞の仮想テーブル。</target>
        </trans-unit>
        <trans-unit id="ab07c049c01997dbb19b575504dcb74af616cde0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/remember.c&quot;&gt;remember() extension&lt;/a&gt; needs a pointer to a C-language integer variable in which to remember the value it passes.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/remember.c&quot;&gt;）（覚えている拡張は&lt;/a&gt;、それが通過する値を記憶するにC言語整数変数へのポインタを必要とします。</target>
        </trans-unit>
        <trans-unit id="56d93d46695516053b394cd5886b780db3048dfe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/vfsstat.c&quot;&gt;vfsstat.c&lt;/a&gt; extension show an example of a loadable extension that persistently registers both a new VFS and a new virtual table. The &lt;a href=&quot;https://sqlite.org/src/info/77b5b4235c9f7f11?ln=801-819&quot;&gt;sqlite3_vfsstat_init()&lt;/a&gt; initialization routine in that extension is called only once, when the extension is first loaded. It registers the new &quot;vfslog&quot; VFS just that one time, and it returns SQLITE_OK_LOAD_PERMANENTLY so that the code used to implement the &quot;vfslog&quot; VFS will remain in memory. The initialization routine also invokes &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; on a pointer to the &quot;vstatRegister()&quot; function so that all subsequent database connections will invoke the &quot;vstatRegister()&quot; function as they start up, and hence register the &quot;vfsstat&quot; virtual table.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/vfsstat.c&quot;&gt;vfsstat.cの&lt;/a&gt;拡張は持続新しいVFSと新しい仮想テーブルの両方を登録することがロード可能な拡張の例を示します。その拡張機能の&lt;a href=&quot;https://sqlite.org/src/info/77b5b4235c9f7f11?ln=801-819&quot;&gt;sqlite3_vfsstat_init（）&lt;/a&gt;初期化ルーチンは、拡張機能が最初にロードされたときに1回だけ呼び出されます。新しい「vfslog」VFSを一度に登録し、SQLITE_OK_LOAD_PERMANENTLYを返すので、「vfslog」VFSの実装に使用されるコードがメモリに残ります。また呼び出す初期化ルーチン&lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;「vstatRegister（）」関数へのポインタにそれらが起動するので「vfsstat」仮想テーブルを登録するように後続のすべてのデータベース接続は、「vstatRegister（）」関数を呼び出すことになります。</target>
        </trans-unit>
        <trans-unit id="037dcdadc7444a9f8e13871793682a198eab41e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;speed-check.sh&lt;/a&gt; shell script, also in the canonical source tree, is used to run the speedtest1.c program. To replicate the performance measurements, collect the following files into a single directory:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;speed-check.sh&lt;/a&gt;シェルスクリプトは、また、標準的なソースツリーで、speedtest1.cプログラムを実行するために使用されます。パフォーマンス測定を複製するには、次のファイルを1つのディレクトリに収集します。</target>
        </trans-unit>
        <trans-unit id="3427f1e6f488cf0eccc944462552651c0021ca21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/finfo?name=src/shell.c&quot;&gt;src/shell.c&lt;/a&gt; source code to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; is no longer under version control. That file is now generated as part of the build process.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;への&lt;a href=&quot;https://sqlite.org/src/finfo?name=src/shell.c&quot;&gt;src / shell.c&lt;/a&gt;ソースコードはバージョン管理下にありません。このファイルは、ビルドプロセスの一部として生成されます。</target>
        </trans-unit>
        <trans-unit id="c808a45cb504200c3f1dbb6bdafa2749899db0fe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;SQLite Fossil Repository&lt;/a&gt; contains links for downloading a Tarball, ZIP Archive, or &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; for any historical version of SQLite. The URLs for these downloads are simple and can be incorporated easily into automated tools. The format is:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;SQLiteの化石リポジトリは&lt;/a&gt; tarアーカイブ、ZIPアーカイブ、またはダウンロードするためのリンクが含まれている&lt;a href=&quot;sqlar&quot;&gt;SQLiteのアーカイブを&lt;/a&gt; SQLiteの任意の歴史的なバージョンのを。これらのダウンロードのURLはシンプルで、自動化ツールに簡単に組み込むことができます。形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d3fbdd1d270cc576e74540d52236d70c3135bcb8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;GeoJSON standard&lt;/a&gt; is syntax for exchanging geospatial information using JSON. GeoJSON is a rich standard that can describe nearly any kind of geospatial content.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;GeoJSON標準では、&lt;/a&gt; JSONを使用して、地理空間情報を交換するための構文です。GeoJSONは、ほぼすべての種類の地理空間コンテンツを記述できる豊富な標準です。</target>
        </trans-unit>
        <trans-unit id="103a9865440a893fd3c0abf774146aac35769fd1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil Version Control System&lt;/a&gt; uses its own printf() implementation that is derived from an early version of the SQLite printf() implementation, but those two implementations have since diverged.</source>
          <target state="translated">&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;化石バージョン管理システムは、&lt;/a&gt; SQLiteのprintfの（）の実装の初期バージョンから派生し、独自のprintf（）の実装を使用していますが、これらの2つの実装は、以来、分岐しています。</target>
        </trans-unit>
        <trans-unit id="6c9ad5b94e94e6f0742495238eb4e3e441c282ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; version control system (designed and written for the purpose of supporting SQLite development) allows mildly trusted users to enter arbitrary SQL for generating trouble-ticket reports. That SQL is sanitized using the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface, and no exploits have ever been found. But this is an example of potentially hostile agents being able to inject arbitrary SQL into the system.</source>
          <target state="translated">&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;化石&lt;/a&gt;（SQLiteの開発を支援する目的で設計されたと書かれた）バージョン管理システムは、穏やかな、信頼できるユーザーはトラブルチケットのレポートを生成するための任意のSQLを入力することができます。そのSQLは&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;インターフェースを使用してサニタイズされており、エクスプロイトは発見されていません。しかし、これは、システムに任意のSQLを挿入できる潜在的に敵対的なエージェントの例です。</target>
        </trans-unit>
        <trans-unit id="d3062c93a43df260caeb23ab2e3ad2153f90cd2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="translated">&lt;a href=&quot;int64&quot;&gt;sqlite3_int64の&lt;/a&gt;変数は、Tパラメータは、行の合計数に設定することによって指さX番目のループのすべての反復によって調べ。</target>
        </trans-unit>
        <trans-unit id="db1220ff947aa3310307b8d1e97a7892f5326b35" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="translated">&lt;a href=&quot;int64&quot;&gt;sqlite3_int64の&lt;/a&gt;変数は、TパラメータがX番目のループが実行された回数の合計数に設定することによって指さ。</target>
        </trans-unit>
        <trans-unit id="ffcdafee896254e841c8ceef0c82d886514030ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="translated">&lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt;変数はVパラメータによって指される行の合計数に設定されるX番目のループのすべての反復によって調べ。</target>
        </trans-unit>
        <trans-unit id="c0533f74a6fe1362e5ed7a748ce1c72de0f80c71" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="translated">&lt;a href=&quot;int64&quot;&gt;sqlite3_int64の&lt;/a&gt;Vパラメータによって指される変数がX番目のループが実行された回数の合計数に設定されます。</target>
        </trans-unit>
        <trans-unit id="d635355782e5d01fca2019b73467bea006012ad0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt; article on this website is an earlier investigation (circa 2011) that uses the same approach as the Jim Gray paper &amp;mdash; storing the blob filenames as entries in the database &amp;mdash; but for SQLite instead of SQL Server.</source>
          <target state="translated">このWebサイトの&lt;a href=&quot;intern-v-extern-blob&quot;&gt;内部と外部のBLOB&lt;/a&gt;に関する記事は、ジムグレイの論文と同じアプローチを使用した初期の調査（2011年頃）です。ブロブのファイル名をデータベースのエントリとして保存しますが、SQL ServerではなくSQLiteを対象としています。</target>
        </trans-unit>
        <trans-unit id="cf7fb4a466758f27d2e851f548bb98e33d7f26c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang&quot;&gt;SQL language documentation&lt;/a&gt; is converted to use &lt;a href=&quot;syntaxdiagrams&quot;&gt;syntax diagrams&lt;/a&gt; instead of BNF.</source>
          <target state="translated">&lt;a href=&quot;lang&quot;&gt;SQL言語のドキュメントを&lt;/a&gt;使用するように変換され、&lt;a href=&quot;syntaxdiagrams&quot;&gt;構文図&lt;/a&gt;の代わりBNFのを。</target>
        </trans-unit>
        <trans-unit id="e0edaa5ff21911b0f3da41c0480fbb1aa18847d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command works differently in two respects when foreign key constraints are enabled:</source>
          <target state="translated">&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLEの&lt;/a&gt;外部キー制約が有効になっているときのコマンドは、2つの点で異なって動作します。</target>
        </trans-unit>
        <trans-unit id="7f9caf431fddd0486fb12661e16a4ade73718c32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command now gathers statistics on tables even if they have no indices.</source>
          <target state="translated">&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドは、今、彼らは何のインデックスを持っていない場合でも、表の統計を収集します。</target>
        </trans-unit>
        <trans-unit id="2e90c478519d8e9b1bd82d0dd1c5b19da711cd5f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement is an SQLite extension that allows two or more databases to be associated to the same database connection and to operate as if they were a single database. The number of simultaneously attached databases is limited to SQLITE_MAX_ATTACHED which is set to 10 by default. The maximum number of attached databases cannot be increased above 125.</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;文が二つ以上のデータベースが同じデータベース接続に関連付けることができますし、それらが単一のデータベースであるかのように動作するSQLiteの拡張機能です。同時に接続されるデータベースの数は、デフォルトで10に設定されているSQLITE_MAX_ATTACHEDに制限されています。アタッチされるデータベースの最大数は125を超えることはできません。</target>
        </trans-unit>
        <trans-unit id="e65f9f430c67e4418373e91a58e15ed50bb5c875" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clause</source>
          <target state="translated">&lt;a href=&quot;lang_conflict&quot;&gt;CONFLICTのON&lt;/a&gt;句</target>
        </trans-unit>
        <trans-unit id="3e1a4fb3e81abe601d6a76ca6511292629d722a1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#ifnull&quot;&gt;ifnull()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt; SQL functions are now implemented using in-line VDBE code rather than calling external functions, so that unused arguments need never be evaluated.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#ifnull&quot;&gt;IFNULL（）&lt;/a&gt;および&lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;COALESCE（）&lt;/a&gt; SQL関数は、現在未使用の引数が評価されることはありません必要はそうすることを、インラインVDBEコードを使用するのではなく、外部関数の呼び出しを実装しています。</target>
        </trans-unit>
        <trans-unit id="c97e1aa1d73b591cf5ec83039aad0924cf633432" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; is subject to the &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt; limit of &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt;. Hence any printf() result with a width or precision more than the SQLITE_LIMIT_LENGTH will cause an &lt;a href=&quot;rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; error. However, the low-level formatting for the printf() function is done by a subroutine that does not have access to SQLITE_LIMIT_LENGTH. So the low-level formatting is done into a memory allocation that might be considerably larger than SQLITE_LIMIT_LENGTH and the SQLITE_LIMIT_LENGTH check is only performed after all formatting is complete. Thus there might be a transient buffer that exceeds SQLITE_LIMIT_LENGTH. The SQLITE_PRINTF_PRECISION_LIMIT option is an additional check that prevents excess sizes for the transient buffer used inside the low-level formatting subroutine, prior to the SQLITE_LIMIT_LENGTH check.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf（）SQL関数は、&lt;/a&gt;対象となる&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTHの&lt;/a&gt;限界&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（） &lt;/a&gt;。したがって、SQLITE_LIMIT_LENGTHを超える幅または精度のprintf（）結果は、SQLITE_TOOBIGを引き起こします&lt;a href=&quot;rescode#toobig&quot;&gt;。&lt;/a&gt;エラー。ただし、printf（）関数の低レベルのフォーマットは、SQLITE_LIMIT_LENGTHにアクセスできないサブルーチンによって行われます。したがって、低レベルのフォーマットは、SQLITE_LIMIT_LENGTHよりもかなり大きい可能性のあるメモリ割り当てに対して行われ、SQLITE_LIMIT_LENGTHチェックは、すべてのフォーマットが完了した後にのみ実行されます。したがって、SQLITE_LIMIT_LENGTHを超える一時バッファーが存在する可能性があります。SQLITE_PRINTF_PRECISION_LIMITオプションは、SQLITE_LIMIT_LENGTHチェックの前に、低レベルのフォーマットサブルーチン内で使用される一時バッファーのサイズが超過するのを防ぐ追加のチェックです。</target>
        </trans-unit>
        <trans-unit id="b38d1ab83adc6d5e3ecac3108de3718b731fffb5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; function is obviously non-deterministic because it gives a different answer every time it is invoked. The answers from &lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid()&lt;/a&gt; depend on prior SQL statements, and so they are also non-deterministic. The &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_version()&lt;/a&gt; function is mostly constant, but it can change when SQLite is upgraded, and so even though it always returns the same answer for any particular session, because it can change answers across sessions it is still considered non-deterministic.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#random&quot;&gt;ランダム（） &lt;/a&gt;、それは別の答えにそれが呼び出されるたびに与えるので、機能は明らかに非決定的です。&lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes（）&lt;/a&gt;と&lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid（）&lt;/a&gt;からの回答は以前のSQLステートメントに依存しているため、これらも非決定的です。&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_version（）&lt;/a&gt;関数は、ほとんど一定であるが、それは常に、特定のセッションのために同じ答えを返しても、それはそれはまだ非決定論的と考えられているセッション間で答えを変更することができますので、それは、そうでもSQLiteのがアップグレードされたときに変更する、とすることができます。</target>
        </trans-unit>
        <trans-unit id="201a260c8bdbe59035cb4cd8dc3341936a60ec2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset(X)&lt;/a&gt; SQL function requires a new interface on the B-tree storage engine, a new opcode in the &lt;a href=&quot;opcode&quot;&gt;virtual machine&lt;/a&gt; that runs SQL statements, and a new conditional in a critical path of the code generator. To avoid that overhead in applications that do not need the utility of sqlite_offset(X), the function is disabled by default.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset（X）&lt;/a&gt; SQL関数は、Bツリーストレージエンジンに新しいオペコードに新しいインターフェースが必要&lt;a href=&quot;opcode&quot;&gt;仮想マシン&lt;/a&gt; SQL文を実行し、コードジェネレータのクリティカルパスに新しい条件を。sqlite_offset（X）のユーティリティを必要としないアプリケーションでそのオーバーヘッドを回避するために、関数はデフォルトで無効になっています。</target>
        </trans-unit>
        <trans-unit id="5130992bbae98a73266f7f76541f0aac8e1ee306" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr()&lt;/a&gt; SQL function does not bother to measure the length its entire input string if it is only computing a prefix</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#substr&quot;&gt;SUBSTR（） &lt;/a&gt;、それが唯一の接頭辞を計算した場合のSQL関数は、長さにその入力文字列全体を測定するために、気にしません。</target>
        </trans-unit>
        <trans-unit id="051b877cf20f31f8d1edc5b8d94b799ecd70ba91" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; of a rowid table (if there is one) is usually not the true primary key for the table, in the sense that it is not the unique key used by the underlying &lt;a href=&quot;fileformat2#btree&quot;&gt;B-tree&lt;/a&gt; storage engine. The exception to this rule is when the rowid table declares an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;. In the exception, the INTEGER PRIMARY KEY becomes an alias for the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">ROWIDテーブルの&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;（存在する場合）は、基本的な&lt;a href=&quot;fileformat2#btree&quot;&gt;Bツリー&lt;/a&gt;ストレージエンジンで使用される一意のキーではないという意味で、通常、テーブルの実際のプライマリキーではありません。このルールの例外は、ROWIDテーブルが&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEYを&lt;/a&gt;宣言する場合です。例外では、INTEGER PRIMARY KEYが&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWIDの&lt;/a&gt;エイリアスになります。</target>
        </trans-unit>
        <trans-unit id="d236ba188ef88897dc53c50ffce983697148b3b9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of a rowid table can be accessed (or changed) by reading or writing to any of the &quot;rowid&quot; or &quot;oid&quot; or &quot;_rowid_&quot; columns. Except, if there is a declared columns in the table that use those special names, then those names refer to the declared columns, not to the underlying &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; ROWIDテーブルのは、読み取り又は「ROWID」または「OID」または「_ROWID_」列のいずれかに書き込むことによってアクセスする（または変更）することができます。ただし、これらの特別な名前を使用する宣言された列がテーブルにある場合、それらの名前は、基になる行&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ID&lt;/a&gt;ではなく、宣言された列を参照します。</target>
        </trans-unit>
        <trans-unit id="57ebcd163f26bc17678c31c9203482eaa22d5842" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of a table must be an integer. Attempt to set the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; to anything other than an integer (or a NULL which will be automatically converted into the next available integer rowid) results in an SQLITE_MISMATCH error.</source>
          <target state="translated">表の&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;は整数である必要があります。&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;を整数（または次に使用可能な整数ROWIDに自動的に変換されるNULL）以外に設定しようとすると、SQLITE_MISMATCHエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="feca6ba206a41f2092893b9e83da76d7c569ae87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; statement now accepts an optional list of column names following the view name.</source>
          <target state="translated">&lt;a href=&quot;lang_createview&quot;&gt;VIEWのCREATE&lt;/a&gt;文では、現在のビュー名以下のオプションのカラム名のリストを受け付けます。</target>
        </trans-unit>
        <trans-unit id="140e631b88f462024e846431476301a80f59bb76" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_datefunc&quot;&gt;Date And Time Functions&lt;/a&gt; are enhanced so that the current time (ex: julianday('now')) is always the same for multiple function invocations within the same &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call.</source>
          <target state="translated">&lt;a href=&quot;lang_datefunc&quot;&gt;日付と時刻の関数は&lt;/a&gt;（「今」）ユリウス通日（EX）常に同じ内の複数の関数呼び出しのために同じである現在時刻がなるように強化され&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;の呼び出し。</target>
        </trans-unit>
        <trans-unit id="50e6d59e6b5b950615232d8af21bbe3ba88f948d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; SQL command is used to obtain a high-level description of the strategy or plan that SQLite uses to implement a specific SQL query. Most significantly, EXPLAIN QUERY PLAN reports on the way in which the query uses database indices. This document is a guide to understanding and interpreting the EXPLAIN QUERY PLAN output. Background information is available separately:</source>
          <target state="translated">&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN PLAN QUERY&lt;/a&gt; SQLコマンドは、SQLiteのは、特定のSQLクエリを実装するために使用する戦略や計画のハイレベルの記述を取得するために使用されます。最も重要な点として、EXPLAIN QUERY PLANは、クエリがデータベースインデックスを使用する方法についてレポートします。このドキュメントは、EXPLAIN QUERY PLANの出力を理解して解釈するためのガイドです。背景情報は個別に入手できます。</target>
        </trans-unit>
        <trans-unit id="20275284a3bb298e3ed89b5acd684907f3305751" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; and &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; prefixes to SQL statements only affect the behavior of the statement during &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. That means that PRAGMA statements that take effect during &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; will behave the same way regardless of whether or not they are prefaced by &quot;EXPLAIN&quot;.</source>
          <target state="translated">SQLステートメントへの&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;および&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;プレフィックスは、&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;中のステートメントの動作にのみ影響します。つまり、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）の&lt;/a&gt;間に有効になるPRAGMAステートメントは、 &quot;EXPLAIN&quot;が前に付いているかどうかに関係なく、同じように動作します。</target>
        </trans-unit>
        <trans-unit id="65133dc98116af2c7f0912fa88b4b43954bbc4b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator</source>
          <target state="translated">&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOBの&lt;/a&gt;オペレータ</target>
        </trans-unit>
        <trans-unit id="0fa44fcf9bdf1d542216cc05466871344f55fb9a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS operator&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS演算子&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b92948d462015f78d114a35cb7f278e70f987a87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS operator&lt;/a&gt; is now able to drive indexes.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS演算子は、&lt;/a&gt;今のインデックスを駆動することができます。</target>
        </trans-unit>
        <trans-unit id="b253f85844781796ef1ae81936dfc99cf231cc5a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#like&quot;&gt;ESCAPE&lt;/a&gt; clause of a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator now overrides wildcard characters, so that the behavior matches what PostgreSQL does.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;演算子の&lt;a href=&quot;lang_expr#like&quot;&gt;ESCAPE&lt;/a&gt;句がワイルドカード文字をオーバーライドするようになり、動作がPostgreSQLの動作と一致するようになりました。</target>
        </trans-unit>
        <trans-unit id="41d7aaefd27d25ac767f490e47e6b7c9452f7e20" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt; clause</source>
          <target state="translated">&lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BYの&lt;/a&gt;句</target>
        </trans-unit>
        <trans-unit id="2b3b6b4eb30c653aa6f7ff986fc3927d49da19df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; command only works if the transaction stack is empty, or in other words if there are no pending transactions. If the transaction stack is not empty when the &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; command is invoked, then the command fails with an error.</source>
          <target state="translated">&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;保留中のトランザクションが存在しない場合は、トランザクション・スタックが空、または他の言葉である場合、コマンドのみ動作します。&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;コマンドが呼び出されたときにトランザクションスタックが空でない場合、コマンドはエラーで失敗します。</target>
        </trans-unit>
        <trans-unit id="68024f72adbd8a0a422c4b54cc30c9ba1ec76d4a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command commits all outstanding transactions and leaves the transaction stack empty.</source>
          <target state="translated">&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;コマンドはトランザクションがスタック空にするすべての未処理のトランザクションや葉をコミットします。</target>
        </trans-unit>
        <trans-unit id="6b3d11e09f03993abe204e129a5f26dcc598fb68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command now succeeds even if there are pending queries. It returns &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if there are pending incremental BLOB I/O requests.</source>
          <target state="translated">&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;コマンドは現在保留中のクエリがある場合でも成功します。保留中の増分BLOB I / O要求がある場合、&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSYを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="502339818ec9310f1093ba4d9556feff42c6ac87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command without a TO clause rolls backs all transactions and leaves the transaction stack empty.</source>
          <target state="translated">&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACKの&lt;/a&gt;すべてのトランザクションと葉がトランザクションがスタック空TO句ロールバックせずにコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="22ed8eeff156b9ac5c3272aebc736d20e9be8ea0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, and &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements within triggers do not support the full syntax for &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, and &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements. The following restrictions apply:</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;、&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;、および&lt;a href=&quot;lang_insert&quot;&gt;INSERTの&lt;/a&gt;トリガ内の文はのための完全な構文をサポートしていません&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;、&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;、および&lt;a href=&quot;lang_insert&quot;&gt;INSERTの&lt;/a&gt;ステートメントを。以下の制限が適用されます。</target>
        </trans-unit>
        <trans-unit id="25fa7af4817ff50638a1d09b6077bfa20413eee0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command packs the database about 1% tighter.</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUMの&lt;/a&gt;コマンドは、1％タイトに関するデータベースをパックします。</target>
        </trans-unit>
        <trans-unit id="6f6f65ccce3c60bd3538bde45dbba0bdabdce834" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command preserves the setting of the &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt;. (Ticket #2804.)</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUMの&lt;/a&gt;コマンドは、設定の保存し&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_formatプラグマを&lt;/a&gt;。（チケット＃2804）。</target>
        </trans-unit>
        <trans-unit id="47212a8707d0f0bd1679c6ba64f918cc5f5c6039" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command works by creating a temporary file and then rebuilding the entire database into that temporary file. Then the content of the temporary file is copied back into the original database file and the temporary file is deleted.</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUMの&lt;/a&gt;コマンドは、一時ファイルを作成し、その一時ファイルにデータベース全体を再構築することで動作します。次に、一時ファイルの内容が元のデータベースファイルにコピーされ、一時ファイルが削除されます。</target>
        </trans-unit>
        <trans-unit id="bdf2bbad9bfa5eb4a9865a13c14cd208bf3e40df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt; clause must occur on the first SELECT of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt;. It cannot follow a &lt;a href=&quot;syntax/compound-operator&quot;&gt;compound-operator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt;句は、最初のSELECTで発生しなければならない&lt;a href=&quot;lang_select#compound&quot;&gt;化合物SELECT&lt;/a&gt;。&lt;a href=&quot;syntax/compound-operator&quot;&gt;複合演算子を&lt;/a&gt;追跡することはできません。</target>
        </trans-unit>
        <trans-unit id="db6f4f9f7ee46543ffd0410e2806fc648ca23245" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; creates a faster parser.</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;レモンのパーサジェネレータは、&lt;/a&gt;より高速なパーサを作成します。</target>
        </trans-unit>
        <trans-unit id="a0ba7e4dcf6a75ed4b1ebb47695358df4a104180" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt; documentation describes how to &lt;a href=&quot;loadext#build&quot;&gt;compile loadable extensions&lt;/a&gt; as shared libraries. The techniques described there work fine for the json1 module.</source>
          <target state="translated">&lt;a href=&quot;loadext&quot;&gt;ロード可能な拡張機能&lt;/a&gt;のドキュメントはする方法について説明し&lt;a href=&quot;loadext#build&quot;&gt;ロード可能な拡張モジュールのコンパイル&lt;/a&gt;共有ライブラリとしてを。そこで説明されている手法は、json1モジュールに対してうまく機能します。</target>
        </trans-unit>
        <trans-unit id="01edd329b33f240dcc5cfa34ddb1e15eb22f3ff1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; interface writes a message into the &lt;a href=&quot;../errlog&quot;&gt;error log&lt;/a&gt; established by the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; option to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt;. If logging is enabled, the zFormat string and subsequent arguments are used with &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to generate the final output string.</source>
          <target state="translated">&lt;a href=&quot;log&quot;&gt;sqlite3_log（）&lt;/a&gt;インタフェースは、にメッセージを書き込み&lt;a href=&quot;../errlog&quot;&gt;、エラー・ログ&lt;/a&gt;によって確立された&lt;a href=&quot;c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt;にオプション&lt;a href=&quot;config&quot;&gt;sqlite3_config（） &lt;/a&gt;。ログが有効になっている場合、zFormat文字列と後続の引数が&lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf（）で&lt;/a&gt;使用され、最終的な出力文字列が生成されます。</target>
        </trans-unit>
        <trans-unit id="4883693c0c81d8dd1cc3d7c0223f243712aeaf0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; is enhanced to support two separate memory pools with different sized allocations in each pool. This allows more memory allocations to be covered by lookaside while at the same time reducing the heap memory usage to 48KB per connection, down from 120KB.</source>
          <target state="translated">&lt;a href=&quot;malloc#lookaside&quot;&gt;ルックアサイドメモリアロケータは、&lt;/a&gt;各プールにおける異なるサイズの割り当てを持つ2つの別個のメモリ・プールをサポートするように拡張されます。これにより、より多くのメモリ割り当てをルックアサイドでカバーできるようになると同時に、ヒープメモリ使用量を接続あたり120KBから48KBに削減できます。</target>
        </trans-unit>
        <trans-unit id="81d8579383d45cb472d3a4833d1ee2e13e4c3902" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;malloc#lookaside&quot;&gt;ルックアサイドメモリアロケータ&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6272b90c1e46ccb51f6a211fb05dce0a9b88e6f6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;malloc#pagecache&quot;&gt;ページキャッシュメモリアロケータ&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2033aab7c928977e8c566f6458591e6094a394bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; routine returns the number of bytes of memory currently outstanding (malloced but not freed). The &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; routine returns the maximum value of &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; since the high-water mark was last reset. The values returned by &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; include any overhead added by SQLite in its implementation of &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, but not overhead added by the any underlying system library routines that &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; may call.</source>
          <target state="translated">&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;リターンするメモリのバイト数は、現在未解決（mallocさが、解放されません）。&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;リターンの最大値&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;ハイウォーターマークが最後にリセットされたからです。返される値&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;と&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater（）は&lt;/a&gt;、任意のオーバーヘッドの実装でのSQLiteによって追加挙げ&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;が、オーバーヘッドこと任意の基礎となるシステム・ライブラリ・ルーチンによって追加されない&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="54555d04b0b2355ea81551452a102d3dd5b8966e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; interface takes a single argument which is one of these integer constants.</source>
          <target state="translated">&lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;インターフェースは、これらの整数の定数のいずれかである単一の引数を取ります。</target>
        </trans-unit>
        <trans-unit id="69f893d6e4ed45be57e659539245cae9d67b977d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; program created by the code generator is run by a virtual machine.</source>
          <target state="translated">&lt;a href=&quot;opcode&quot;&gt;バイトコード&lt;/a&gt;コードジェネレータによって作成されたプログラムは、仮想マシンで実行されます。</target>
        </trans-unit>
        <trans-unit id="6f82427ae6db3af3b60ee7889919a09e27176099" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Delete&quot;&gt;Delete&lt;/a&gt; does the work of this loop; it pops an integer key off the stack (placed there by the preceding ListRead) and deletes the record of cursor P1 that has that key. Because P2 is true, the row change counter is incremented.</source>
          <target state="translated">&lt;a href=&quot;opcode#Delete&quot;&gt;削除は、&lt;/a&gt;このループの作業を行います。スタックから整数キーをポップし（前のListReadによってそこに配置されました）、そのキーを持つカーソルP1のレコードを削除します。P2がtrueであるため、行変更カウンターが増分されます。</target>
        </trans-unit>
        <trans-unit id="49cbb2109ea61f54a2e0e215073c0e8f4e901d2e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Ge&quot;&gt;Ge&lt;/a&gt; operator compares the top two elements on the stack, pops them, and then branches based on the result of the comparison. If the second element is &amp;gt;= the top element, then jump to address P2 (the Next instruction at the end of the loop). Because P1 is true, if either operand is NULL (and thus the result is NULL) then take the jump. If we don't jump, just advance to the next instruction.</source>
          <target state="translated">&lt;a href=&quot;opcode#Ge&quot;&gt;Ge&lt;/a&gt;オペレータは、スタックの一番上の2つの要素を比較し、それらをポップして、比較の結果に基づいて分岐します。2番目の要素が最上位の要素である場合は、アドレスP2（ループの最後にある次の命令）にジャンプします。P1がtrueであるため、いずれかのオペランドがNULLである（したがって結果がNULLである）場合、ジャンプします。ジャンプしない場合は、次の指示に進んでください。</target>
        </trans-unit>
        <trans-unit id="04783e2a879da777c9928b0ae80c86689e955e7d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Gosub&quot;&gt;Gosub&lt;/a&gt; opcode stores the current program counter into register P1 then jumps to address P2. The &lt;a href=&quot;opcode#Return&quot;&gt;Return&lt;/a&gt; opcode jumps to address P1+1. Hence, every subroutine is associated with two integers: the address of the entry point in the subroutine and the register number that is used to hold the return address.</source>
          <target state="translated">&lt;a href=&quot;opcode#Gosub&quot;&gt;GOSUBの&lt;/a&gt;オペコードを格納するレジスタP1に現在のプログラムカウンタは、次にアドレスP2にジャンプ。&lt;a href=&quot;opcode#Return&quot;&gt;戻り&lt;/a&gt;オペコードは、アドレスP1 + 1にジャンプします。したがって、すべてのサブルーチンは2つの整数に関連付けられています。それは、サブルーチン内のエントリー・ポイントのアドレスと、戻りアドレスを保持するために使用されるレジスター番号です。</target>
        </trans-unit>
        <trans-unit id="cc4a6e0d461e428b5be9265ddcc51214a7a17162" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Goto&quot;&gt;Goto&lt;/a&gt; jumps back to the beginning of the loop. This is the end of the loop.</source>
          <target state="translated">&lt;a href=&quot;opcode#Goto&quot;&gt;後藤は、&lt;/a&gt;ループバックの先頭にジャンプします。これでループの終わりです。</target>
        </trans-unit>
        <trans-unit id="36b42b8529eed45ca4088e7606ce454bf579c098" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ListRead&quot;&gt;ListRead&lt;/a&gt; instruction reads an element from the temporary storage list and pushes it onto the stack. If this was successful, it continues to the next instruction. If this fails because the list is empty, it branches to P2, which is the instruction just after the loop. Afterwards the stack looks like:</source>
          <target state="translated">&lt;a href=&quot;opcode#ListRead&quot;&gt;ListReadの&lt;/a&gt;命令は、一時保存リストから要素を読み込み、スタックにプッシュします。これが成功した場合、次の命令に進みます。リストが空であるためにこれが失敗した場合は、ループの直後の命令であるP2に分岐します。その後、スタックは次のようになります。</target>
        </trans-unit>
        <trans-unit id="4879ed312fe574048c51b739d2a2e0c47c1cf28a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ListReset&quot;&gt;ListReset&lt;/a&gt; instruction empties the temporary storage list. This list is emptied automatically when the VDBE program terminates, so it isn't necessary in this case. The Close instruction closes the cursor P1. Again, this is done by the VDBE engine when it is finished running this program. The Commit ends the current transaction successfully, and causes all changes that occurred in this transaction to be saved to the database. The final Halt is also unnecessary, since it is added to every VDBE program when it is prepared to run.</source>
          <target state="translated">&lt;a href=&quot;opcode#ListReset&quot;&gt;ListResetの&lt;/a&gt;命令は、一時保存リストを空にします。このリストはVDBEプログラムの終了時に自動的に空になるため、この場合は不要です。Close命令は、カーソルP1を閉じます。繰り返しますが、これは、このプログラムの実行が終了したときにVDBEエンジンによって実行されます。コミットにより現在のトランザクションが正常に終了し、このトランザクションで発生したすべての変更がデータベースに保存されます。最後の停止は、実行の準備ができたときにすべてのVDBEプログラムに追加されるため、不要です。</target>
        </trans-unit>
        <trans-unit id="50c0b593163bf5647baef877e0e92b5b46f19553" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ListRewind&quot;&gt;ListRewind&lt;/a&gt; instruction rewinds the temporary storage list to the beginning. This prepares it for use in the second loop.</source>
          <target state="translated">&lt;a href=&quot;opcode#ListRewind&quot;&gt;ListRewindの&lt;/a&gt;命令が先頭に一時保存リストを巻き戻し。これにより、2番目のループで使用できるように準備されます。</target>
        </trans-unit>
        <trans-unit id="d684585d2e3d5fa36d7d1264c013ad5c814a5d30" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; opcode is only valid following an &lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;, or &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; opcode used to position the cursor. &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; is not allowed to follow &lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt;, or &lt;a href=&quot;opcode#Last&quot;&gt;Last&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;opcode#Next&quot;&gt;次&lt;/a&gt;のオペコードは、次のみ有効である&lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt;、&lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;、又は&lt;a href=&quot;opcode#Rewind&quot;&gt;巻き戻し&lt;/a&gt;カーソルを位置決めするために使用オペコード。&lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;は&lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt;、&lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt;、&lt;a href=&quot;opcode#Last&quot;&gt;Lastの&lt;/a&gt;後に続くことはできません。</target>
        </trans-unit>
        <trans-unit id="4bec0991ede69ff0f5b657d6da948ae6ccecdc12" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; instruction pops the top stack element and uses it as an integer key. If a record with that key does not exist in table P1, then jump to P2. If a record does exist, then fall through to the next instruction. In this case P2 takes us to the Goto at the end of the loop, which jumps back to the ListRead at the beginning. This could have been coded to have P2 be 16, the ListRead at the start of the loop, but the SQLite parser which generated this code didn't make that optimization.</source>
          <target state="translated">&lt;a href=&quot;opcode#NotExists&quot;&gt;NotExistsの&lt;/a&gt;命令は、トップスタック要素をポップし、整数キーとしてそれを使用します。そのキーを持つレコードがテーブルP1に存在しない場合は、P2にジャンプします。レコードが存在する場合は、次の命令に進みます。この場合、P2はループの最後でGotoに移動し、ループの最初でListReadにジャンプします。これは、ループの開始時にP2が16、ListReadになるようにコード化できますが、このコードを生成したSQLiteパーサーはその最適化を行いませんでした。</target>
        </trans-unit>
        <trans-unit id="1d15a242c00ad338da3936112e42488d3db597cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; opcode performs the same operation, but with &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; the P3 register must be guaranteed to contain an integer value. With this opcode, register P3 might not contain an integer.</source>
          <target state="translated">&lt;a href=&quot;opcode#NotExists&quot;&gt;NotExistsは&lt;/a&gt;同様の動作を行うのオペコードが、で&lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; P3レジスタは、整数値を含むことが保証されなければなりません。このオペコードでは、レジスタP3に整数が含まれていない場合があります。</target>
        </trans-unit>
        <trans-unit id="2ea51892f8acadad179e6f2fd2f42516a5edf44d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; opcode performs the same operation on index btrees (with arbitrary multi-value keys).</source>
          <target state="translated">&lt;a href=&quot;opcode#NotFound&quot;&gt;NOTFOUNDの&lt;/a&gt;オペコードを行う（任意多値キーで）インデックスのbtreeに同じ動作を行います。</target>
        </trans-unit>
        <trans-unit id="066073395b0144e2fa69bed2cb062af29a031388" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; opcode is only valid following an &lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt;, or &lt;a href=&quot;opcode#Last&quot;&gt;Last&lt;/a&gt; opcode used to position the cursor. &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; is not allowed to follow &lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;, or &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;opcode#Prev&quot;&gt;前の&lt;/a&gt;オペコードは、以下のみ有効です&lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt;、&lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt;、または&lt;a href=&quot;opcode#Last&quot;&gt;最後&lt;/a&gt;にカーソルを配置するために使用されるオペコード。&lt;a href=&quot;opcode#Prev&quot;&gt;前のページには&lt;/a&gt;従うことが許可されていない&lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt;、&lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;、または&lt;a href=&quot;opcode#Rewind&quot;&gt;巻き戻しを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e7073f193fc700364fff65aec536137cac5241f6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Recno&quot;&gt;Recno&lt;/a&gt; instruction pushes onto the stack an integer which is the first 4 bytes of the key to the current entry in a sequential scan of the table pointed to by cursor P1. The &lt;a href=&quot;opcode#ListWrite&quot;&gt;ListWrite&lt;/a&gt; instruction writes the integer on the top of the stack into a temporary storage list and pops the top element. This is the important work of this loop, to store the keys of the records to be deleted so we can delete them in the second loop. After this ListWrite instruction the stack is empty again.</source>
          <target state="translated">&lt;a href=&quot;opcode#Recno&quot;&gt;使うrecno&lt;/a&gt;スタックカーソルP1によって指さテーブルの順次スキャンの現在のエントリへのキーの最初の4バイト整数への命令押します。&lt;a href=&quot;opcode#ListWrite&quot;&gt;ListWriteの&lt;/a&gt;命令は、一時保存リストにスタックの最上位に整数を書き込み、トップ要素をポップ。これは、削除するレコードのキーを格納して2番目のループで削除できるようにする、このループの重要な作業です。このListWrite命令の後、スタックは再び空になります。</target>
        </trans-unit>
        <trans-unit id="ee3dc9b6c04eaf92dc7b817ad9cb3a0c30096f49" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; opcode may only be used with P5==0 or P5==OPFLAG_SEEKEQ and with P4 being a P4_KEYINFO object. Furthermore, the P3 value must be the same as every other &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; or &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; for the same cursor number.</source>
          <target state="translated">&lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdxの&lt;/a&gt;オペコードは、P5 == 0又はP5 == OPFLAG_SEEKEQとし、P4がP4_KEYINFOオブジェクトであると共に使用することができます。さらに、P3値は、同じカーソル番号に対する他のすべての&lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt;または&lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt;と同じでなければなりません。</target>
        </trans-unit>
        <trans-unit id="f1b24140a6cba2cd01303fe562cef908cbaa8ca3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; opcode works like &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; except that it first checks to see if the cursor on P1 is already open on the same b-tree and if it is this opcode becomes a no-op. In other words, if the cursor is already open, do not reopen it.</source>
          <target state="translated">&lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdxの&lt;/a&gt;オペコードは、同じように動作し&lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; P1上のカーソルが同じBツリーにすでに開いている場合、それは、このオペコードはノーオペレーションとなっていないかどうかを確認するには、それを最初にチェックことを除いて。つまり、カーソルがすでに開いている場合は、再度開かないでください。</target>
        </trans-unit>
        <trans-unit id="02cd685549e7ced789f6d67a2427e140b8a8620d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt; opcode causes the bytecode engine to pause and the corresponding &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call to return &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;. Before invoking &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt;, the bytecoded program will have loaded the results for a single row of a query into a series of registers. C-language APIs such as &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_int()&lt;/a&gt; or &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt; extract the query results from those registers. The bytecode engine resumes with the next instruction after the &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt; on the next call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRowの&lt;/a&gt;オペコードは、休止と対応するバイトコードエンジンを引き起こす&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;戻りの呼び出し&lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;。&lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt;を呼び出す前に、バイトコードプログラムは、クエリの単一行の結果を一連のレジスタにロードします。&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_int（）&lt;/a&gt;や&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_text（）&lt;/a&gt;などのC言語APIは、これらのレジスタからクエリ結果を抽出します。バイトコードエンジンは、&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;への次の呼び出しで&lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRowの&lt;/a&gt;後に次の命令で再開します。</target>
        </trans-unit>
        <trans-unit id="f2441406e5ac75bb5fd7cf1919c714faf20d6ab5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; instruction initializes a loop that iterates over the &quot;examp&quot; table. It rewinds the cursor P1 to the first entry in its table. This is required by the Column and Next instructions, which use the cursor to iterate through the table. If the table is empty, then jump to P2 (10), which is the instruction just past the loop. If the table is not empty, fall through to the following instruction at 6, which is the beginning of the loop body.</source>
          <target state="translated">&lt;a href=&quot;opcode#Rewind&quot;&gt;巻き戻しの&lt;/a&gt;指示は「examp」テーブルを反復そのループを初期化します。カーソルP1をそのテーブルの最初のエントリに巻き戻します。これは、カーソルを使用してテーブルを反復処理するColumnおよびNext命令で必要です。テーブルが空の場合は、ループの直後の命令であるP2（10）にジャンプします。テーブルが空でない場合は、ループ本体の開始である6の次の命令に進んでください。</target>
        </trans-unit>
        <trans-unit id="2de14c27a6545978f9bf6b60627e8141b94b7884" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#SeekRowid&quot;&gt;SeekRowid&lt;/a&gt; opcode performs the same operation but also allows the P3 register to contain a non-integer value, in which case the jump is always taken. This opcode requires that P3 always contain an integer.</source>
          <target state="translated">&lt;a href=&quot;opcode#SeekRowid&quot;&gt;SeekRowid&lt;/a&gt;オペコード実行同じ動作がなく、P3レジスタはジャンプが常に取られている場合には非整数値を含むことができます。このオペコードでは、P3に常に整数が含まれている必要があります。</target>
        </trans-unit>
        <trans-unit id="4b451f841c2d23194bca9774c72889abafce37d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; opcode swaps the value of the program counter with the integer value in register P1. This opcode is used to implement coroutines. Coroutines are often used to implement subqueries from which content is pulled on an as-needed basis.</source>
          <target state="translated">&lt;a href=&quot;opcode#Yield&quot;&gt;収量&lt;/a&gt;オペコードレジスタP1の整数値とプログラムカウンタの値をスワップ。このオペコードは、コルーチンを実装するために使用されます。コルーチンは、コンテンツが必要に応じてプルされるサブクエリを実装するためによく使用されます。</target>
        </trans-unit>
        <trans-unit id="2bf8499185976fd90927b75af83cad8ae29ef209" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; optimization is now capable of generating a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; if that is appropriate.</source>
          <target state="translated">&lt;a href=&quot;optoverview#autoindex&quot;&gt;自動インデックス&lt;/a&gt;最適化が今発生させることが可能である&lt;a href=&quot;partialindex&quot;&gt;部分インデックスを&lt;/a&gt;それが適切ですか。</target>
        </trans-unit>
        <trans-unit id="430bd4f8cb87deb1b045d791ee37f7bd1ef6a250" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; is allowed to proceed even if the OR expression has also been converted into an IN expression. Uses of the OR optimization are now also &lt;a href=&quot;eqp#or-opt&quot;&gt;more clearly shown&lt;/a&gt; in the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output.</source>
          <target state="translated">&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR最適化は、&lt;/a&gt; OR式中の他の表現に変換された場合でも、進行させます。OR最適化の使用も、&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;出力で&lt;a href=&quot;eqp#or-opt&quot;&gt;より明確に示さ&lt;/a&gt;れます。</target>
        </trans-unit>
        <trans-unit id="d9e2344b1a8686faee26008aaf6a744a538483c1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt; PRAGMA auto_vacuum=incremental&lt;/a&gt; setting is now persistent.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;プラグマauto_vacuumは=増分&lt;/a&gt;設定は今、永続的です。</target>
        </trans-unit>
        <trans-unit id="80d34339badbc8db002db2288680cbe2b4fee1a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;PRAGMA compile_options&lt;/a&gt; command now attempts to show the version number of the compiler that generated the library.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;プラグマcompile_optionsは&lt;/a&gt;今のライブラリを生成し、コンパイラのバージョン番号を表示しようとする試みを命じます。</target>
        </trans-unit>
        <trans-unit id="e347c28fc2dc6a091d91c4397055e68e6edfd76f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; should be avoided.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directoryプラグマは&lt;/a&gt;、この変数を変更してから取得したメモリを指すように、それを引き起こす可能性があり&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;。さらに、&lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directoryプラグマは&lt;/a&gt;常に、この変数が指すすべての文字列が&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;から取得したメモリに保持されていると想定し、プラグマは&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;を使用してそのメモリを解放しようとする可能性があります。したがって、この変数を直接変更する場合は、NULLにするか、&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;から取得したメモリを指すようにするか、&lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directoryプラグマの&lt;/a&gt;使用を避けます。</target>
        </trans-unit>
        <trans-unit id="dace9501e55329de3c436aaaf6d76500923f6803" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;PRAGMA defer_foreign_keys=ON&lt;/a&gt; statement now also disables &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;RESTRICT actions&lt;/a&gt; on foreign key.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;ONプラグマdefer_foreign_keys =&lt;/a&gt;文では、今も無効は&lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;アクションRESTRICT&lt;/a&gt;外部キー上を。</target>
        </trans-unit>
        <trans-unit id="182946c7ddef87f825c408a1e9bcb94b2aebed4e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;defer_foreign_keys pragma&lt;/a&gt; can be used to temporarily change all foreign key constraints to deferred regardless of how they are declared.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;defer_foreign_keysプラグマは、&lt;/a&gt;一時的に延期にかかわらず、それらが宣言されているかのにすべての外部キー制約を変更するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="be06db32b407171ea5432f85af4fdd64982ffbf0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;database encoding&lt;/a&gt; is UTF-8.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_encoding&quot;&gt;データベースのエンコーディングは&lt;/a&gt;UTF-8です。</target>
        </trans-unit>
        <trans-unit id="c8f76b3a27760e9d216beb8e378b627c5a5752f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_function_list&quot;&gt;PRAGMA function_list&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_module_list&quot;&gt;PRAGMA module_list&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;PRAGMA pragma_list&lt;/a&gt; commands are now enabled in all builds by default. Disable them using &lt;a href=&quot;compile#omit_introspection_pragmas&quot;&gt;-DSQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_function_list&quot;&gt;プラグマfunction_list&lt;/a&gt;、&lt;a href=&quot;pragma#pragma_module_list&quot;&gt;プラグマmodule_list&lt;/a&gt;、および&lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;プラグマpragma_listの&lt;/a&gt;すべてがデフォルトでビルドでコマンドが有効になります。&lt;a href=&quot;compile#omit_introspection_pragmas&quot;&gt;-DSQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/a&gt;を使用してそれらを無効にします。</target>
        </trans-unit>
        <trans-unit id="530eb5492fa66c41d47c216aab5658b932f1fde0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;index_xinfo&lt;/a&gt; pragmas are enhanced to provide information about the on-disk representation of &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info&lt;/a&gt;と&lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;index_xinfo&lt;/a&gt;プラグマは、のディスク上の表現についての情報を提供するように拡張されている&lt;a href=&quot;withoutrowid&quot;&gt;ROWIDのWITHOUT&lt;/a&gt;テーブルを。</target>
        </trans-unit>
        <trans-unit id="e422cf4cf15df880c393dd24dbfb049b1fcebe08" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check pragma&lt;/a&gt; is enhanced to detect out-of-order rowids.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_checkプラグマは、&lt;/a&gt;アウト・オブ・オーダーのROWIDを検出するように強化されます。</target>
        </trans-unit>
        <trans-unit id="2e10d900e5bf7e69cd4dd309e31da996954ece3c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt; is not OFF, MEMORY, or WAL</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;プラグマjournal_modeは&lt;/a&gt; OFF、MEMORY、またはWALではありません</target>
        </trans-unit>
        <trans-unit id="c602efe807a207ac9abab9847aa84a66f50dd768" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;プラグマjournal_mode = OFFの&lt;/a&gt;声明。</target>
        </trans-unit>
        <trans-unit id="49dd3e21f049f6bfedb0b7b5b1043722f3e1e37c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; setting is enabled prior to invoking this method, and the value for legacy_alter_table is restored after this method finishes. This is necessary for the correct operation of virtual tables that make use of &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt; where the shadow tables must be renamed to match the new virtual table name. If the legacy_alter_format is off, then the xConnect method will be invoked for the virtual table every time the xRename method tries to change the name of the shadow table.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt;設定は、このメソッドを呼び出す前にイネーブルされ、そしてlegacy_alter_tableの値は、この方法が終了した後に復元されます。これは、使用作る仮想テーブルが正しく動作するために必要である&lt;a href=&quot;vtab#xshadowname&quot;&gt;シャドウテーブル&lt;/a&gt;シャドウテーブルは、新しい仮想テーブル名と一致する名前を変更する必要があります。legacy_alter_formatがオフの場合、xRenameメソッドがシャドウテーブルの名前を変更しようとするたびに、仮想テーブルに対してxConnectメソッドが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="cd4d57758d0157882a76f0628926b46c59a64bbe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt; is deactivated. It is now a no-op. In its place, the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyfileformat&quot;&gt;SQLITE_DBCONFIG_LEGACY_FILE_FORMAT&lt;/a&gt; option to &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; is provided. The legacy_file_format pragma is deactivated because (1) it is rarely useful and (2) it is incompatible with &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; in schemas that have tables with both generated columns and descending indexes. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6484e6ce678fffab&quot;&gt;6484e6ce678fffab&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_formatプラグマは&lt;/a&gt;無効になります。今ではノーオペレーションです。その代わりに、&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config（）の&lt;/a&gt;&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyfileformat&quot;&gt;SQLITE_DBCONFIG_LEGACY_FILE_FORMAT&lt;/a&gt;オプションが提供されます。 Legacy_file_formatプラグマは、（1）ほとんど役に立たず、（2）生成された列と降順インデックスの両方を持つテーブルを持つスキーマの&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;と互換性がないため、非アクティブ化されます。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/6484e6ce678fffab&quot;&gt;6484e6ce678fffab&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb34969d518c763e5a52bf4853965875f5d7c504" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_max_page_count&quot;&gt; max_page_count PRAGMA&lt;/a&gt; can be used to raise or lower this limit at run-time.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_max_page_count&quot;&gt;max_page_countプラグマは&lt;/a&gt;上げたり、実行時にこの制限を下げるために使用することができます。</target>
        </trans-unit>
        <trans-unit id="ed5ae39d1285e1f44b4d8e91bc72231ec08350d0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; statement will never increase the amount of address space used for memory-mapped I/O above the hard limit set by the &lt;a href=&quot;compile#max_mmap_size&quot;&gt;SQLITE_MAX_MMAP_SIZE&lt;/a&gt; compile-time option, nor the hard limit set start-time by the second argument to sqlite3_config(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;プラグマmmap_sizeの&lt;/a&gt;文は、ハードリミットセットの上にメモリマップドI / Oのために使用されるアドレス空間の量増やすことは決してありません&lt;a href=&quot;compile#max_mmap_size&quot;&gt;SQLITE_MAX_MMAP_SIZE&lt;/a&gt; sqlite3_configの二番目の引数（でコンパイル時のオプション、またハードリミットセット開始時&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="3bccc6c555afb6a2715bad46795ba129af0dfe49" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; command was first introduced with SQLite 3.18.0 (2017-03-28) and is a no-op for all prior releases of SQLite.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;プラグマ最適化&lt;/a&gt;コマンドは、最初のSQLite 3.18.0（2017年3月28日）で導入し、SQLiteのすべての以前のリリースのために何もしませんました。</target>
        </trans-unit>
        <trans-unit id="ce8494947b4ce168119d270366337d52ae940b6c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; command will automatically run ANALYZE on individual tables on an as-needed basis. The recommended practice is for applications to invoke the &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; statement just before closing each database connection.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMAの最適化&lt;/a&gt;コマンドは、自動的に、必要に応じて個々のテーブルに対してANALYZEを実行します。推奨される方法は、アプリケーションが各データベース接続を閉じる直前に&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA最適化&lt;/a&gt;ステートメントを呼び出すことです。</target>
        </trans-unit>
        <trans-unit id="433dda316207c42123f3ff5f78471afdde0a76ae" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;optimize pragma&lt;/a&gt; is usually a no-op but it will occasionally run ANALYZE if it seems like doing so will be useful to the query planner. The &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;analysis_limit pragma&lt;/a&gt; limits the scope of any ANALYZE command that the &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;optimize pragma&lt;/a&gt; runs so that it does not consume too many CPU cycles. The constant &quot;400&quot; can be adjusted as needed. Values between 100 and 1000 work well for most applications.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;最適化プラグマは&lt;/a&gt;、通常は何もしませんが、それは時折、それは問い合わせプランナに有用であろうそうすることのように思える場合はANALYZEを実行します。&lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;analysis_limitプラグマが&lt;/a&gt;あることどんなANALYZEコマンドの範囲に制限&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;最適化プラグマは&lt;/a&gt;、それはあまりにも多くのCPUサイクルを消費しないように動作しますが。定数「400」は必要に応じて調整できます。100〜1000の値は、ほとんどのアプリケーションで適切に機能します。</target>
        </trans-unit>
        <trans-unit id="5fb4e7b95d0d162ecc58614e1af3f3f6380ba85b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting is not OFF</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt;設定がOFFでありません</target>
        </trans-unit>
        <trans-unit id="7b30b153f5bd150efb6f72a306c286fdddb45c5b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; has an integer value which also influences the decision of where to store temporary files. The values of the temp_store pragma have the following meanings:</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_storeプラグマは&lt;/a&gt;また、一時ファイルを格納する場所の決定に影響を与える整数値を持っています。temp_storeプラグマの値には、次の意味があります。</target>
        </trans-unit>
        <trans-unit id="f4fb45c2bb944888554bf90c8cb9a47bf3f2a979" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; should be avoided. Except when requested by the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, SQLite does not free the memory that sqlite3_temp_directory points to. If the application wants that memory to be freed, it must do so itself, taking care to only do so after all &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; objects have been destroyed.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directoryプラグマは&lt;/a&gt;、この変数を変更してから取得したメモリを指すように、それを引き起こす可能性があり&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;。さらに、&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directoryプラグマは&lt;/a&gt;常に、この変数が指すすべての文字列が&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;から取得したメモリに保持されていると想定し、プラグマは&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;を使用してそのメモリを解放しようとする可能性があります。したがって、この変数を直接変更する場合は、NULLにするか、&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;から取得したメモリを指すようにするか、&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directoryプラグマの&lt;/a&gt;使用を避けます。&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directoryプラグマ&lt;/a&gt;によって要求された場合を除く、SQLiteはsqlite3_temp_directoryが指すメモリを解放しません。アプリケーションがそのメモリを解放したい場合は、それ自体で解放する必要があります。すべての&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;オブジェクトが破棄された後にのみ解放するように注意してください。</target>
        </trans-unit>
        <trans-unit id="b7aff6f6a70787230cfdaa84381a4df9ff6088c1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version&lt;/a&gt; pragmas correctly set their column names in the result set</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version&lt;/a&gt;と&lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version&lt;/a&gt;プラグマは正しく結果セットでその列名を設定します</target>
        </trans-unit>
        <trans-unit id="e69bec34ec00cc126a20d5db14b73449e907cdd5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; can be used to invoke this interface from SQL.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpointプラグマは、&lt;/a&gt; SQLからこのインターフェースを呼び出すために使用することができます。</target>
        </trans-unit>
        <trans-unit id="dae72cb78cf83086aebe14bf09934eef63425e9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;PRAGMA wal_checkpoint&lt;/a&gt; command can be used to invoke this interface from SQL.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;プラグマwal_checkpointの&lt;/a&gt;コマンドは、SQLからこのインターフェースを呼び出すために使用することができます。</target>
        </trans-unit>
        <trans-unit id="65a223c3d19041fa0b396d7e3f3b2e302f5459e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;プラグマwritable_schemaはON =&lt;/a&gt;声明。</target>
        </trans-unit>
        <trans-unit id="684edbb611cbfa5623d7b600fa16d86090b5ff1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count(D)&lt;/a&gt; interface returns the number of columns in the row that is being inserted, updated, or deleted.</source>
          <target state="translated">&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count（D）&lt;/a&gt;インターフェースは、挿入、更新、または削除されている列の列数を返します。</target>
        </trans-unit>
        <trans-unit id="ba2d35feb7b268110f32aac36c1f5d65016e60f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth(D)&lt;/a&gt; interface returns 0 if the preupdate callback was invoked as a result of a direct insert, update, or delete operation; or 1 for inserts, updates, or deletes invoked by top-level triggers; or 2 for changes resulting from triggers called by top-level triggers; and so forth.</source>
          <target state="translated">&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth（D）&lt;/a&gt;戻り0インターフェイス更新前コールバックは、直接挿入、更新、または削除操作の結果として呼び出された場合。または、トップレベルのトリガーによって呼び出される挿入、更新、または削除の場合は1。または2は、トップレベルのトリガーによって呼び出されたトリガーから生じる変更です。など。</target>
        </trans-unit>
        <trans-unit id="61dec61cb0cf17103a6811f56ba836ebb2ef7198" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; interface registers a callback function that is invoked prior to each &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; operation on a database table. At most one preupdate hook may be registered at a time on a single &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;; each call to &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; overrides the previous setting. The preupdate hook is disabled by invoking &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; with a NULL pointer as the second parameter. The third parameter to &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; is passed through as the first parameter to callbacks.</source>
          <target state="translated">&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook（）&lt;/a&gt;インターフェース前各々に呼び出されるコールバック関数を登録する&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;、&lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt;、および&lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt;データベーステーブルの動作を制御します。単一の&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;で一度に登録できるpreupdateフックは1つだけです。&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook（）を&lt;/a&gt;呼び出すたびに、以前の設定が上書きされます。 preupdateフックは、2番目のパラメーターとしてNULLポインターを指定して&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook（）&lt;/a&gt;を呼び出すことにより無効になります。&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook（）&lt;/a&gt;の3番目のパラメーターは、最初のパラメーターとしてコールバックに渡されます。</target>
        </trans-unit>
        <trans-unit id="8df93bf8497a2d78f6914976e1609ba432170056" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row after it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_INSERT and SQLITE_UPDATE preupdate callbacks; if it is used by an SQLITE_DELETE callback then the behavior is undefined. The &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new（D、N、P）&lt;/a&gt;インタフェースPへのポインタ書き込み&lt;a href=&quot;value&quot;&gt;保護sqlite3_value&lt;/a&gt;それが更新された後、テーブルの行のN番目の列の値を含みます。 Nパラメータは0から列数よりも1少ない値でなければなりません。そうしないと、動作は定義されません。これは、SQLITE_INSERTおよびSQLITE_UPDATE事前更新コールバック内でのみ使用する必要があります。 SQLITE_DELETEコールバックによって使用される場合、動作は未定義です。&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;更新前コールバックリターンPポイントが破壊されるすること。</target>
        </trans-unit>
        <trans-unit id="aeb8933cda6d990d1669eb3665d8053606aee0ba" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old()&lt;/a&gt;, &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new()&lt;/a&gt;, &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count()&lt;/a&gt;, and &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth()&lt;/a&gt; interfaces provide additional information about a preupdate event. These routines may only be called from within a preupdate callback. Invoking any of these routines from outside of a preupdate callback or with a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; pointer that is different from the one supplied to the preupdate callback results in undefined and probably undesirable behavior.</source>
          <target state="translated">&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old（） &lt;/a&gt;、&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new（） &lt;/a&gt;、&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count（） &lt;/a&gt;、及び&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth（）&lt;/a&gt;インターフェースは、更新前のイベントに関する追加情報を提供します。これらのルーチンは、更新前のコールバック内からのみ呼び出すことができます。 preupdateコールバックの外部から、またはpreupdateコールバックに提供されたものとは異なる&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;ポインターを使用してこれらのルーチンを呼び出すと、未定義でおそらく望ましくない動作が発生します。</target>
        </trans-unit>
        <trans-unit id="dd30234761e0c7ea9f1053536a7bfab89c37bb25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row before it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_UPDATE and SQLITE_DELETE preupdate callbacks; if it is used by an SQLITE_INSERT callback then the behavior is undefined. The &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old（D、N、P）&lt;/a&gt;インターフェースはPへのポインタ書き込み&lt;a href=&quot;value&quot;&gt;保護sqlite3_value&lt;/a&gt;それが更新される前に、テーブルの行のN番目の列の値を含みます。Nパラメータは0から列数よりも1少ない値でなければなりません。そうしないと、動作は定義されません。これは、SQLITE_UPDATEおよびSQLITE_DELETE事前更新コールバック内でのみ使用する必要があります。SQLITE_INSERTコールバックによって使用される場合、動作は未定義です。&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;更新前コールバックリターンPポイントが破壊されるすること。</target>
        </trans-unit>
        <trans-unit id="6f6dd20be85a6ee9376cfe67d011732f51298a56" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;queryplanner-ng&quot;&gt;next generation query planner&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;queryplanner-ng&quot;&gt;次世代の問い合わせプランナ&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0815af1640f3451efe07a076fe65835b297a94b7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;query planner checklist&lt;/a&gt; describes steps that application developers should following to help resolve query planner problems. Notice the that the use of INDEXED BY is a last resort, to be used only when all other measures fail.</source>
          <target state="translated">&lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;問い合わせプランナのチェックリストは、&lt;/a&gt;アプリケーション開発者は、ヘルプ解決問い合わせプランナの問題に、次の必要がある手順を説明します。INDEXED BYの使用は最後の手段であり、他のすべての測定が失敗した場合にのみ使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0c1b5fdf8ac1234008ffa858abbdb051486a832c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt; extended error code is returned in WAL mode when a read transaction cannot be upgraded to a write transaction because the read is on an older snapshot.</source>
          <target state="translated">&lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt;読み取りが古いスナップショットであるため、読み取りトランザクションが書き込みトランザクションにアップグレードできない場合、拡張エラーコードは、WALモードに戻ります。</target>
        </trans-unit>
        <trans-unit id="a55e40d30155becf01edc33f7916ec42f8c15006" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface does not change the values of any &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; on the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S.</source>
          <target state="translated">&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（S）&lt;/a&gt;インタフェースは、任意の値が変化しない&lt;a href=&quot;bind_blob&quot;&gt;バインディング&lt;/a&gt;に&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt; S.</target>
        </trans-unit>
        <trans-unit id="3841b0084bc10aa5540a5c6c5c96fb98131e7bf0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface resets the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S back to the beginning of its program.</source>
          <target state="translated">&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（S）&lt;/a&gt;インタフェースがリセットされ&lt;a href=&quot;stmt&quot;&gt;、準備されたステートメントは、&lt;/a&gt;そのプログラムの先頭に戻るS。</target>
        </trans-unit>
        <trans-unit id="540e7b1566721b5eeac705b77c4d701d37c07cab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; returns this result code when an attempt is made to update the R-Tree while another prepared statement is actively reading the R-Tree. The update cannot proceed because any change to an R-Tree might involve reshuffling and rebalancing of nodes, which would disrupt read cursors, causing some rows to be repeated and other rows to be omitted.</source>
          <target state="translated">&lt;a href=&quot;rtree&quot;&gt;Rツリーの拡張子は&lt;/a&gt;、他のプリペアドステートメントを積極的にR-ツリーを読んでいる間、試みはR-ツリーを更新するために行われ、この結果コードを返します。Rツリーへの変更にはノードの再シャッフルと再バランスが含まれる可能性があるため、更新を続行できません。これにより、読み取りカーソルが中断され、一部の行が繰り返され、他の行が省略されます。</target>
        </trans-unit>
        <trans-unit id="b4b6d7c356a19c81f66c0c808b762014df51dab6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt; supports shared-cache read and write locks in the same way as all other database tables (see description above). The following special rules also apply:</source>
          <target state="translated">&lt;a href=&quot;schematab&quot;&gt;sqlite_schemaテーブルの&lt;/a&gt;サポート、共有キャッシュ（上記の説明を参照してください）他のすべてのデータベーステーブルと同じようにロックを読み取りおよび書き込み。次の特別なルールも適用されます。</target>
        </trans-unit>
        <trans-unit id="7707f3c0dce0c68c0fd1c390c4bccf3ca9ffcb57" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;session/sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; API is called to create and initialize an iterator to iterate through the contents of a changeset. Initially, the iterator points to no element at all.</source>
          <target state="translated">&lt;a href=&quot;session/sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt; APIは、チェンジセットの内容を反復処理するイテレータを作成し、初期化するために呼ばれています。最初、イテレータは要素をまったく指さない。</target>
        </trans-unit>
        <trans-unit id="e2c05e642dac6053ce210738d48ce79ebc45ba34" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;set_authorizer&quot;&gt;authorizer callback function&lt;/a&gt; must return either &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; or one of these two constants in order to signal SQLite whether or not the action is permitted. See the &lt;a href=&quot;set_authorizer&quot;&gt;authorizer documentation&lt;/a&gt; for additional information.</source>
          <target state="translated">&lt;a href=&quot;set_authorizer&quot;&gt;承認者のコールバック関数は、&lt;/a&gt;いずれかを返す必要があり&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;アクションが許可されているか否かのSQLiteを通知するために、またはこれら2つの定数のいずれか。追加情報については、&lt;a href=&quot;set_authorizer&quot;&gt;承認者のドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4b9f192cd368c894585cf856c53081dab4346439" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface registers a callback function that is invoked to authorize certain SQL statement actions. The second parameter to the callback is an integer code that specifies what action is being authorized. These are the integer action codes that the authorizer callback may be passed.</source>
          <target state="translated">&lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;インタフェースは、特定のSQLステートメントアクションを認可するために呼び出されるコールバック関数を登録します。コールバックの2番目のパラメーターは、どのアクションが許可されているかを指定する整数コードです。これらは、オーソライザーコールバックが渡される整数のアクションコードです。</target>
        </trans-unit>
        <trans-unit id="c88888932989847ef34ae0441a4a296cbf9342ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object returned from a successful call to &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; must be freed using &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; to avoid a memory leak.</source>
          <target state="translated">&lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshotの&lt;/a&gt;に成功した呼び出しから返されたオブジェクト&lt;a href=&quot;snapshot_get&quot;&gt;（）sqlite3_snapshot_getを&lt;/a&gt;使用して解放しなければならない&lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_freeを（）&lt;/a&gt;メモリリークを避けるために。</target>
        </trans-unit>
        <trans-unit id="334527e56ba0a296ee1d1034ee6898a348187ebd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; interface is only available when the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free（）&lt;/a&gt;ときインタフェースにのみ利用可能である&lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt;コンパイル時のオプションが使用されます。</target>
        </trans-unit>
        <trans-unit id="41f028c2f95ad413ccf78f4f0e636bf684908330" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free(P)&lt;/a&gt; interface destroys &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P. The application must eventually free every &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object using this routine to avoid a memory leak.</source>
          <target state="translated">&lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free（P）&lt;/a&gt;インターフェース破棄&lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P.アプリケーションは、最終的にすべての解放する必要があります&lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshotの&lt;/a&gt;メモリリークを避けるために、このルーチンを使用してオブジェクトを。</target>
        </trans-unit>
        <trans-unit id="b60983fe9853f804b509f3ca97ea438091fe792b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; interface is only available when the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get（）&lt;/a&gt;ときインタフェースにのみ利用可能である&lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt;コンパイル時のオプションが使用されます。</target>
        </trans-unit>
        <trans-unit id="f3e22e1c7c111b00a70790db9ce08d967e255fcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface attempts to make a new &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object that records the current state of schema S in database connection D. On success, the &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface writes a pointer to the newly created &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object into *P and returns SQLITE_OK. If there is not already a read-transaction open on schema S when this function is called, one is opened automatically.</source>
          <target state="translated">&lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get（D、S、P）&lt;/a&gt;新しいするためのインタフェース試み&lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshotの&lt;/a&gt;データベース接続D.オン成功のスキーマSの現在の状態を記録するオブジェクトを、&lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get（D、S、P）&lt;/a&gt;インターフェースは、新しく作成されたポインタを書き込みます。&lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt;オブジェクトを* Pに入れ、SQLITE_OKを返します。この関数が呼び出されたときにスキーマSで開いている読み取りトランザクションがまだない場合は、自動的に開きます。</target>
        </trans-unit>
        <trans-unit id="086ca737ecffa34122715fb37e08e08253d88ee7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface is only available when the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;ときインタフェースにのみ利用可能である&lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt;コンパイル時のオプションが使用されます。</target>
        </trans-unit>
        <trans-unit id="511890649947f63b55f8621e1cda37e48d68f4cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; interface either starts a new read transaction or upgrades an existing one for schema S of &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D such that the read transaction refers to historical &lt;a href=&quot;snapshot&quot;&gt;snapshot&lt;/a&gt; P, rather than the most recent change to the database. The &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface returns SQLITE_OK on success or an appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if it fails.</source>
          <target state="translated">&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open（D、S、P）&lt;/a&gt;インタフェースのいずれかが新しいリードトランザクションを開始またはスキーマSのための既存のものをアップグレード&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;リードトランザクション履歴を意味するように、D &lt;a href=&quot;snapshot&quot;&gt;スナップショット&lt;/a&gt;ではなく、データベースへの最新の変化より、P。&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;インターフェースは、成功または適切にSQLITE_OKを返し&lt;a href=&quot;../rescode&quot;&gt;、エラーコード&lt;/a&gt;が失敗した場合。</target>
        </trans-unit>
        <trans-unit id="4cef92cfdf633fc0c634b624e8f2e6727a6b4196" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; extension allows the application to optionally specify the rowid for each INSERT.</source>
          <target state="translated">&lt;a href=&quot;spellfix1&quot;&gt;spellfix1の&lt;/a&gt;拡張は、アプリケーションは、必要に応じて各インサート用の行IDを指定することを可能にします。</target>
        </trans-unit>
        <trans-unit id="d837c3195216596d022a1ac6dfae8f94ace29826" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;spellfix1#editdist3&quot;&gt;editdist3()&lt;/a&gt; edit-distance function can also be selected or deselected at run-time by inserting an appropriate string into the &quot;command&quot; column of the virtual table:</source>
          <target state="translated">&lt;a href=&quot;spellfix1#editdist3&quot;&gt;editdist3（）&lt;/a&gt;編集距離関数は、仮想テーブルの「コマンド」カラムに適切な文字列を挿入することによって、実行時に選択または選択解除することができます。</target>
        </trans-unit>
        <trans-unit id="832a2975224a148de7d49b3ae21cbf638061bcda" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; idea shows how SQLite can be used as a substitute for ZIP archives or Tarballs. An archive of files stored in SQLite is only very slightly larger, and in some cases actually smaller, than the equivalent ZIP archive. And an SQLite archive features incremental and atomic updating and the ability to store much richer metadata.</source>
          <target state="translated">&lt;a href=&quot;sqlar&quot;&gt;SQLiteのアーカイブ&lt;/a&gt; SQLiteのは、ZIPアーカイブまたはtarで固めの代用として使用することができる方法のアイデアを示しています。SQLiteに保存されたファイルのアーカイブは、同等のZIPアーカイブよりもわずかに大きく、場合によっては実際には小さくなります。また、SQLiteアーカイブは、インクリメンタルおよびアトミックな更新と、はるかに豊富なメタデータを保存する機能を備えています。</target>
        </trans-unit>
        <trans-unit id="e695129653037caa8407461dbbd9ea2a46762ce1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; pointer D in a call to &lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt(D,S)&lt;/a&gt; must refer to an open database connection and in particular must not be a NULL pointer.</source>
          <target state="translated">&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;の呼び出しでポインタD &lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt（D、S）は&lt;/a&gt;、オープンデータベース接続を参照し、特定する必要があり、NULLポインタであってはなりません。</target>
        </trans-unit>
        <trans-unit id="48a912a810b3a28ec149be0106a75289dbfa6333" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_append(X,S,N)&lt;/a&gt; method appends exactly N bytes from string S onto the end of the &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X. N must be non-negative. S must contain at least N non-zero bytes of content. To append a zero-terminated string in its entirety, use the &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall()&lt;/a&gt; method instead.</source>
          <target state="translated">&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_append（X、S、N）&lt;/a&gt;方法Nはの端部に弦Sからのバイト正確付加&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;オブジェクトX. Nは非負でなければなりません。Sには、少なくともNバイトの非ゼロバイトのコンテンツが含まれている必要があります。ゼロで終了する文字列全体を追加するには、代わりに&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall（）&lt;/a&gt;メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="1fad1c80b91150cb25ef6b94b5eb5de73c5d25b7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall(X,S)&lt;/a&gt; method appends the complete content of zero-terminated string S onto the end of &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall（X、S）&lt;/a&gt;メソッドは、の最後にゼロで終わる文字列Sの完全な内容を付加&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;オブジェクトX.</target>
        </trans-unit>
        <trans-unit id="b0fd412f541ab2a0f3d35988066ed4e8e4128c77" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendchar(X,N,C)&lt;/a&gt; method appends N copies of the single-byte character C onto the end of &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X. This method can be used, for example, to add whitespace indentation.</source>
          <target state="translated">&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendchar（X、N、C）&lt;/a&gt;の方法は、端部に単一バイト文字CのN個のコピーを付加&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;この方法は、空白インデントを追加するために、例えば、使用することができるオブジェクトX.。</target>
        </trans-unit>
        <trans-unit id="8a49ade027432cc3ca56bc0bb1633c34a874ad30" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendf(X,F,...)&lt;/a&gt; and &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_vappendf(X,F,V)&lt;/a&gt; interfaces uses the &lt;a href=&quot;../printf&quot;&gt;built-in printf&lt;/a&gt; functionality of SQLite to append formatted text onto the end of &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendf（X、F、...）&lt;/a&gt;と&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_vappendf（X、F、V）&lt;/a&gt;インターフェイスが使用&lt;a href=&quot;../printf&quot;&gt;内蔵のprintf&lt;/a&gt;のSQLiteの機能の最後にフォーマットされたテキストを追加する&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;オブジェクトX.</target>
        </trans-unit>
        <trans-unit id="8207628b57fa2acb2222184f79be191c7783d2ec" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_reset(X)&lt;/a&gt; method resets the string under construction inside &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X back to zero bytes in length.</source>
          <target state="translated">&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_reset（X）&lt;/a&gt;メソッドは、内部構造の下列リセット&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;長さはゼロバイトにオブジェクトXのバック。</target>
        </trans-unit>
        <trans-unit id="3979188fa64e50e829929b1acf8c993dc30e5490" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; method returns the current length, in bytes, of the dynamic string under construction in &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X. The length returned by &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; does not include the zero-termination byte.</source>
          <target state="translated">&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length（X）&lt;/a&gt;メソッドは、建設中の動的な列のバイト単位の現在の長さを返し&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;によって返される長さオブジェクトX. &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length（X）が&lt;/a&gt;ゼロ終端バイトを含みません。</target>
        </trans-unit>
        <trans-unit id="94c6db74a667c1ebd14fbec47092019e01e83407" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; method returns a pointer to the current content of the dynamic string under construction in X. The value returned by &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; is managed by the sqlite3_str object X and might be freed or altered by any subsequent method on the same &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object. Applications must not used the pointer returned &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; after any subsequent method call on the same object. Applications may change the content of the string returned by &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; as long as they do not write into any bytes outside the range of 0 to &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; and do not read or write any byte after any subsequent sqlite3_str method call.</source>
          <target state="translated">&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value（X）&lt;/a&gt;メソッドは、によって返される値Xに建設動的文字列の現在の内容へのポインタを返す&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value（X）は&lt;/a&gt; sqlite3_strオブジェクトXによって管理され、同じ上の任意の後続の方法によって解放または変更されるかもしれません&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;オブジェクト。アプリケーションは、同じオブジェクトに対する後続のメソッド呼び出しの後に返されるポインター&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value（X）を&lt;/a&gt;使用してはなりません。アプリケーションは、0から&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length（X）&lt;/a&gt;の範囲外のバイトに書き込みを行わず、後続のsqlite3_strメソッド呼び出しの後にバイトを読み書きしない限り、&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value（X）&lt;/a&gt;によって返される文字列の内容を変更できます。</target>
        </trans-unit>
        <trans-unit id="7e06028d8d9a37c76976481d45631c9360b94773" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; that contains the constructed string. The calling application should pass the returned value to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; to avoid a memory leak. The &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface may return a NULL pointer if any errors were encountered during construction of the string. The &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface will also return a NULL pointer if the string in &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X is zero bytes long.</source>
          <target state="translated">&lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish（X）&lt;/a&gt;インタフェースはsqlite3_strオブジェクトXとリターンから得られたバッファメモリへのポインタ破壊&lt;a href=&quot;free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;構築文字列を含みます。呼び出し側アプリケーションは、メモリリークを回避するために、戻り値を&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;に渡す必要があります。&lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish（X）&lt;/a&gt;エラーがストリングの構築中に遭遇した場合のインタフェースは、NULLポインタを返すことができます。&lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish（X）&lt;/a&gt;の文字列場合インターフェイスもNULLポインタを戻します&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;オブジェクトXがゼロバイト長です。</target>
        </trans-unit>
        <trans-unit id="893b46b38f797cff31c49b4ea957f7271c4d11b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface allocates and initializes a new &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object. To avoid memory leaks, the object returned by &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt; must be freed by a subsequent call to &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（D）&lt;/a&gt;界面割り当て及び新しい初期化&lt;a href=&quot;str&quot;&gt;sqlite3_strの&lt;/a&gt;オブジェクト。メモリリークを回避するには、&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;によって返されたオブジェクトを&lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish（X）&lt;/a&gt;への後続の呼び出しで解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="c8f2751d83d7d253a00544efb010e3f4e128798b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface always returns a pointer to a valid &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object, though in the event of an out-of-memory error the returned object might be a special singleton that will silently reject new text, always return SQLITE_NOMEM from &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode()&lt;/a&gt;, always return 0 for &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length()&lt;/a&gt;, and always return NULL from &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;. It is always safe to use the value returned by &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; as the sqlite3_str parameter to any of the other &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; methods.</source>
          <target state="translated">&lt;a href=&quot;str_new&quot;&gt;（D）sqlite3_str_new&lt;/a&gt;インターフェイスは常に有効にポインタを返す&lt;a href=&quot;str&quot;&gt;sqlite3_strの&lt;/a&gt;メモリ不足エラーが発生した場合に返されるオブジェクトは黙って新しいテキストを拒否します、常にからSQLITE_NOMEMを返す特殊なシングルトンかもしれませんが、オブジェクトを&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode（）&lt;/a&gt;、常に&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length（）&lt;/a&gt;に対して0を返し、常に&lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish（X）&lt;/a&gt;からNULLを返します。&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（D）&lt;/a&gt;によって返された値を、他の&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;メソッドのsqlite3_strパラメータとして使用することは常に安全です。</target>
        </trans-unit>
        <trans-unit id="4893933da22367d13b4236043c7aa3ee536ea00a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern P. The definition of &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern matching used in &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; is the same as for the &quot;X GLOB P&quot; operator in the SQL dialect understood by SQLite. The &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; function is case sensitive.</source>
          <target state="translated">&lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob（P、X）&lt;/a&gt;インタフェース戻る場合にのみ文字列Xが一致する場合ゼロ&lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOBの&lt;/a&gt;パターンPの定義&lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOBの&lt;/a&gt;に使用されるパターンマッチング&lt;a href=&quot;strglob&quot;&gt;（P、X）sqlite3_strglobの&lt;/a&gt;中の「X GLOB P」演算子の場合と同じですSQLiteが理解できるSQL方言。&lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob（P、X）&lt;/a&gt;関数は、大文字と小文字が区別されます。</target>
        </trans-unit>
        <trans-unit id="e174ba8e6223c998f458135f997fdab25603db49" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; APIs allow applications and extensions to compare the contents of two buffers containing UTF-8 strings in a case-independent fashion, using the same definition of &quot;case independence&quot; that SQLite uses internally when comparing identifiers.</source>
          <target state="translated">&lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp（）&lt;/a&gt;と&lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt; APIは、識別子を比較するときのSQLiteが内部で使用する「ケース・自立」の同じ定義を使用して、アプリケーションや拡張機能は、ケースに依存しない形式でUTF-8文字列を含む二つのバッファの内容を比較することができます。</target>
        </trans-unit>
        <trans-unit id="f2f61b252192f444bf8f6f8d93e248db03a4d372" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function matches Unicode characters, though only ASCII characters are case folded.</source>
          <target state="translated">&lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike（P、X、E）&lt;/a&gt; ASCII文字のみがケースに折り畳まれているものの関数は、Unicode文字に一致します。</target>
        </trans-unit>
        <trans-unit id="8540813014d56ead7baf2b2daf047a27f8df8c32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern P with escape character E. The definition of &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern matching used in &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; is the same as for the &quot;X LIKE P ESCAPE E&quot; operator in the SQL dialect understood by SQLite. For &quot;X LIKE P&quot; without the ESCAPE clause, set the E parameter of &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; to 0. As with the LIKE operator, the &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function is case insensitive - equivalent upper and lower case ASCII characters match one another.</source>
          <target state="translated">&lt;a href=&quot;strlike&quot;&gt;（P、X、E）sqlite3_strlike&lt;/a&gt;インターフェースリターン文字列Xが一致する場合と場合にのみ、ゼロ&lt;a href=&quot;../lang_expr#like&quot;&gt;LIKEの&lt;/a&gt;エスケープ文字Eでの定義パターンPを&lt;a href=&quot;../lang_expr#like&quot;&gt;LIKEの&lt;/a&gt;に使用されるパターンマッチング&lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike（P、X、Eは）&lt;/a&gt;と同じですSQLiteが理解するSQL方言の「X LIKE P ESCAPE E」演算子。ESCAPE句のない「X LIKE P」の場合、&lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike（P、X、E）&lt;/a&gt;のEパラメータを0 に設定します。LIKE演算子と同様に、&lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike（P、X、E）&lt;/a&gt;関数は大文字と小文字を区別しません-同等の大文字と小文字小文字のASCII文字は互いに一致します。</target>
        </trans-unit>
        <trans-unit id="4c4bc6f080bcb0613b19c8e24f2c8215e3263de6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; has been enhanced to use the &lt;a href=&quot;http://www.tcl-lang.org/cgi-bin/tct/tip/322.html&quot;&gt;Non-Recursive Engine (NRE)&lt;/a&gt; interface to the TCL interpreter when linked against TCL 8.6 or later.</source>
          <target state="translated">&lt;a href=&quot;tclsqlite&quot;&gt;TCLインターフェイス&lt;/a&gt;を使用するように拡張された&lt;a href=&quot;http://www.tcl-lang.org/cgi-bin/tct/tip/322.html&quot;&gt;非再帰的エンジン（NRE）&lt;/a&gt; TCL 8.6以降にリンクされたときにTCLインタープリタへのインターフェイスを。</target>
        </trans-unit>
        <trans-unit id="23310616ad13ff4bf64157f6f266be2fa9a80e64" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz&lt;/a&gt; fuzzer also does an excellent job of verifying that SQLite responds sanely to malformed database files.</source>
          <target state="translated">&lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzzの&lt;/a&gt;fuzzerもSQLiteのは、不正な形式のデータベースファイルにsanely応答することを確認する優れた仕事をしていません。</target>
        </trans-unit>
        <trans-unit id="de4e73f7d156e22fa7106d9f30fd3d58ff51bfbf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;testing#slt&quot;&gt;SQL Logic Tests&lt;/a&gt; are a set of test cases designed to show that SQLite behaves the same as other SQL database engines. These tests are hosted in a separate code public repository.</source>
          <target state="translated">&lt;a href=&quot;testing#slt&quot;&gt;SQLロジックテストは、&lt;/a&gt; SQLiteのは、他のSQLデータベースエンジンと同じように動作することを示すために設計されたテスト・ケースのセットです。これらのテストは、別のコードのパブリックリポジトリでホストされます。</target>
        </trans-unit>
        <trans-unit id="5f65ab47a0f86c2f22ae6f2632075f4320a179c7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;th3&quot;&gt;Test Harness #3&lt;/a&gt; or &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; test suite is a private set of test cases used to test SQLite to 100% MC/DC in an as-delivered configuration. TH3 sources are served on the same servers as the other SQLite repositories, but differ from the others in being proprietary. The TH3 code is only accessible to SQLite developers.</source>
          <target state="translated">&lt;a href=&quot;th3&quot;&gt;テストハーネス＃3&lt;/a&gt;又は&lt;a href=&quot;th3&quot;&gt;TH3の&lt;/a&gt;テストスイートは、として送達構成100％MC / DCへの試験SQLiteのに使用されるテストケースの秘密セットです。TH3ソースは、他のSQLiteリポジトリと同じサーバーで提供されますが、独自のものであるという点で他のソースとは異なります。TH3コードはSQLite開発者のみがアクセスできます。</target>
        </trans-unit>
        <trans-unit id="e8a696ccc2b635cda261283e62314013cf8db5a9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes(D)&lt;/a&gt; interface only reports the number of rows that changed due to SQL statement run against database connection D. Any changes by other database connections are ignored. To detect changes against a database file from other database connections use the &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command or the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;file control&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes（D）&lt;/a&gt;インターフェイスは、唯一の他のデータベース接続により、任意の変更は無視され、データベース接続D.に対してSQL文の実行のために変更された行の数を報告します。他のデータベース接続からのデータベースファイルに対する変更を検出するには、&lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt;コマンドまたは&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION &lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;ファイルコントロール&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="f49c08b6ed161fe2560890c885dd50855619ba24" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;uintcseq&quot;&gt;UINT collating sequence&lt;/a&gt; extension is automatically loaded</source>
          <target state="translated">&lt;a href=&quot;uintcseq&quot;&gt;UINTの照合順序の&lt;/a&gt;拡張子が自動的にロードされます</target>
        </trans-unit>
        <trans-unit id="5a2803f974353bfc4cbf30a15e234d493460a39f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;versionnumbers&quot;&gt;version numbering conventions&lt;/a&gt; for SQLite are revised to use the emerging standard of &lt;a href=&quot;http://semver.org/&quot;&gt;semantic versioning&lt;/a&gt;.</source>
          <target state="translated">SQLite の&lt;a href=&quot;versionnumbers&quot;&gt;バージョン番号付け規則&lt;/a&gt;は、&lt;a href=&quot;http://semver.org/&quot;&gt;セマンティックバージョニングの&lt;/a&gt;新しい標準を使用するように改訂されています。</target>
        </trans-unit>
        <trans-unit id="6ca284a5c0b69f330d98de127457542bdad0ece1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16) adds a new device characteristic named &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt;. Database files that report this characteristic are assumed to reside on storage systems that have the powersafe overwrite property. The default unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; now report &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; if SQLite is compiled with &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE=1&lt;/a&gt; or they make the legacy assumption that storage does not have the powersafe overwrite property if compiled with &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE=0&lt;/a&gt;. For now, the default is for powersafe overwrite to be turned on, though we may revisit this in the future and default it off.</source>
          <target state="translated">&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;のSQLiteのための&lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;バージョン3.7.10&lt;/a&gt;（2012-01-16）は、という名前の新しいデバイスの特性追加&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITEを&lt;/a&gt;。この特性を報告するデータベースファイルは、powersafe overwriteプロパティを持つストレージシステムにあると想定されています。デフォルトUNIXとWindows &lt;a href=&quot;vfs&quot;&gt;VFSesは&lt;/a&gt;今報告&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITEを&lt;/a&gt; SQLiteのがしてコンパイルされている場合&lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE = 1&lt;/a&gt;または彼らがしてコンパイルした場合、ストレージはpowersafeオーバーライト特性を持っていないという従来の仮定作る&lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE = 0を&lt;/a&gt;。現時点では、デフォルトでpowersafe overwriteがオンになっていますが、将来これを再確認してデフォルトでオフにする可能性があります。</target>
        </trans-unit>
        <trans-unit id="28df118ed088f75e95fa60751c2ccab88df9bbf6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xbestindex&quot;&gt;sqlite3_module.xBestIndex&lt;/a&gt; method in the implementation of this table checks for equality constraints against the HIDDEN columns, and uses those as input parameters to determine the range of integer &quot;value&quot; outputs to generate. Reasonable defaults are used for any unconstrained columns. For example, to list all integers between 5 and 50:</source>
          <target state="translated">このテーブルの実装の&lt;a href=&quot;vtab#xbestindex&quot;&gt;sqlite3_module.xBestIndex&lt;/a&gt;メソッドはHIDDEN列に対する等価制約をチェックし、それらを入力パラメーターとして使用して、生成する整数「値」出力の範囲を決定します。制約のない列には、妥当なデフォルトが使用されます。たとえば、5〜50のすべての整数を一覧表示するには、次のように入力します。</target>
        </trans-unit>
        <trans-unit id="e9cea685ebbde84bdb5186b0eb1062c8517be452" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and is not checked again by SQLite.</source>
          <target state="translated">&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndexの&lt;/a&gt;方法はxFilterに渡すどのようなパラメータに関する情報をaConstraintUsage []を入力する必要があります。argvIndex&amp;gt; 0の場合、対応するaConstraint []の右側が評価され、argvのargvIndex番目のエントリになります。aConstraintUsage []。omitがtrueの場合、制約は仮想テーブルによって完全に処理されたと見なされ、SQLiteによって再度チェックされません。</target>
        </trans-unit>
        <trans-unit id="f8ae1ca39afc04ccf6f18ad86632ba85cedd64de" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and might not be checked again by the byte code. The aConstraintUsage[].omit flag is an optimization hint. When the omit flag is left in its default setting of false, the constraint will always be checked separately in byte code. If the omit flag is change to true, then the constraint may or may not be checked in byte code. In other words, when the omit flag is true there is no guarantee that the constraint will not be checked again using byte code.</source>
          <target state="translated">&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndexの&lt;/a&gt;方法はxFilterに渡すどのようなパラメータに関する情報をaConstraintUsage []を入力する必要があります。 argvIndex&amp;gt; 0の場合、対応するaConstraint []の右側が評価され、argvのargvIndex番目のエントリになります。 aConstraintUsage []。omitがtrueの場合、制約は仮想テーブルによって完全に処理されていると見なされ、バイトコードによって再度チェックされない可能性があります。 aConstraintUsage []。omitフラグは最適化のヒントです。省略フラグがデフォルト設定のfalseのままになっている場合、制約は常にバイトコードで個別にチェックされます。省略フラグがtrueに変更された場合、制約はバイトコードでチェックされる場合とされない場合があります。つまり、省略フラグがtrueの場合、バイトコードを使用して制約が再度チェックされないという保証はありません。</target>
        </trans-unit>
        <trans-unit id="60b191bb31eb6d4e8bdeb7b48904acffd3c2dfc6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of a &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt; call this interface to declare the format (the names and datatypes of the columns) of the virtual tables they implement.</source>
          <target state="translated">&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;と&lt;a href=&quot;vtab#xconnect&quot;&gt;のxconnect&lt;/a&gt;の方法&lt;a href=&quot;#sqlite3_module&quot;&gt;仮想テーブルは、モジュール&lt;/a&gt;、それらが実装仮想テーブルの形式（列の名前とデータ型）を宣言するために、このインターフェイスを呼び出します。</target>
        </trans-unit>
        <trans-unit id="d6feb2481a619b82b0e2f46a25f49c2e66551dca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; method is called whenever a database connection that uses a virtual table is closed. The xDestroy method is only called when a &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; statement is executed against the virtual table.</source>
          <target state="translated">&lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnectの&lt;/a&gt;仮想テーブルを使用してデータベース接続が閉じられるたびにメソッドが呼び出されます。xDestroyメソッドは、&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;ステートメントが仮想テーブルに対して実行されたときにのみ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="8c0ce4af06185c37b128ad21eebbd21f3f9ac244" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method was originally designed around having a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; as a single value. The &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method has been expanded to accommodate an arbitrary PRIMARY KEY in place of the ROWID, but the PRIMARY KEY must still be only one column. For this reason, SQLite will reject any WITHOUT ROWID virtual table that has more than one PRIMARY KEY column and a non-NULL xUpdate method.</source>
          <target state="translated">&lt;a href=&quot;vtab#xupdate&quot;&gt;XUpdate&lt;/a&gt;方法は、もともと持って設計された&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWIDを&lt;/a&gt;単一の値として。&lt;a href=&quot;vtab#xupdate&quot;&gt;XUpdate&lt;/a&gt;方法は、ROWIDの代わりに任意のPRIMARY KEYに対応するために拡張されていますが、PRIMARY KEYはまだ1列のみでなければなりません。このため、SQLiteは、複数のPRIMARY KEY列とNULL以外のxUpdateメソッドを持つWITHOUT ROWID仮想テーブルを拒否します。</target>
        </trans-unit>
        <trans-unit id="e8e22d8d27e272cb6edbc57854c2655aac986253" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;wal#advantages&quot;&gt;second advantage of WAL-mode&lt;/a&gt; is that writers do not block readers and readers to do not block writers. This is &lt;u&gt;mostly&lt;/u&gt; true. But there are some obscure cases where a query against a WAL-mode database can return &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, so applications should be prepared for that happenstance.</source>
          <target state="translated">&lt;a href=&quot;wal#advantages&quot;&gt;WALモード&lt;/a&gt;の2番目の利点は、ライターがリーダーをブロックせず、リーダーがライターをブロックしないことです。これは&lt;u&gt;ほとんど&lt;/u&gt;本当です。ただし、WALモードのデータベースに対するクエリが&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;を返す場合があるため、アプリケーションはそのような事態に備える必要があります。</target>
        </trans-unit>
        <trans-unit id="73dd67efef2f2aca70b69d53d116d51359c36e68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint(D,N)&lt;/a&gt; is a wrapper around &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; that causes any database on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D to automatically &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; after committing a transaction if there are N or more frames in the &lt;a href=&quot;../wal&quot;&gt;write-ahead log&lt;/a&gt; file. Passing zero or a negative value as the nFrame parameter disables automatic checkpoints entirely.</source>
          <target state="translated">&lt;a href=&quot;wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint（D、N）は&lt;/a&gt;ラッパーです&lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;上の任意のデータベースの原因となる&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;を自動的にD &lt;a href=&quot;../wal#ckpt&quot;&gt;のチェックポイント&lt;/a&gt; N以上のフレームがである場合、トランザクションをコミットした後&lt;a href=&quot;../wal&quot;&gt;、先行書き込みログ&lt;/a&gt;ファイル。nFrameパラメータとしてゼロまたは負の値を渡すと、自動チェックポイントが完全に無効になります。</target>
        </trans-unit>
        <trans-unit id="70220a93d132293d087792692e0745eaa50f6944" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; function is used to register a callback that is invoked each time data is committed to a database in wal mode.</source>
          <target state="translated">&lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;関数は、WALモードでデータベースにコミットされるたびにデータが呼び出されるコールバックを登録するために使用されます。</target>
        </trans-unit>
        <trans-unit id="82c4cc754894816f7c5238173cc6918a40c6ae4d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;walformat#locks&quot;&gt;WAL-mode locks&lt;/a&gt; are described above.</source>
          <target state="translated">&lt;a href=&quot;walformat#locks&quot;&gt;WALモード・ロックは、&lt;/a&gt;上記に記載されています。</target>
        </trans-unit>
        <trans-unit id="2815c286729fb6fca3fa728a7812f5c530ea71ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; is implemented using an ordinary file that is mmapped for robustness. Early (pre-release) implementations of WAL mode stored the wal-index in volatile shared-memory, such as files created in /dev/shm on Linux or /tmp on other unix systems. The problem with that approach is that processes with a different root directory (changed via &lt;a href=&quot;http://en.wikipedia.org/wiki/Chroot&quot;&gt;chroot&lt;/a&gt;) will see different files and hence use different shared memory areas, leading to database corruption. Other methods for creating nameless shared memory blocks are not portable across the various flavors of unix. And we could not find any method to create nameless shared memory blocks on windows. The only way we have found to guarantee that all processes accessing the same database file use the same shared memory is to create the shared memory by mmapping a file in the same directory as the database itself.</source>
          <target state="translated">&lt;a href=&quot;walformat#shm&quot;&gt;WAL-インデックスは、&lt;/a&gt;堅牢性のためたmmapされた通常のファイルを使用して実装されています。 WALモードの初期（リリース前）の実装では、Linuxの/ dev / shmまたは他のUNIXシステムの/ tmpで作成されたファイルなど、揮発性の共有メモリにwal-indexが保存されていました。そのアプローチの問題は、異なるルートディレクトリ（&lt;a href=&quot;http://en.wikipedia.org/wiki/Chroot&quot;&gt;chroot&lt;/a&gt;経由で変更）でプロセスが）は異なるファイルを参照するため、異なる共有メモリ領域を使用し、データベースの破損につながります。名前のない共有メモリブロックを作成する他の方法は、さまざまな種類のUNIX間では移植できません。また、Windowsで名前のない共有メモリブロックを作成する方法は見つかりませんでした。同じデータベースファイルにアクセスするすべてのプロセスが同じ共有メモリを使用することを保証する唯一の方法は、データベース自体と同じディレクトリにあるファイルをmmmapして共有メモリを作成することです。</target>
        </trans-unit>
        <trans-unit id="e0f2b794ee3e27ce7edc3429510c9bf44ed6503d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;whentouse#website&quot;&gt;Appropriate Uses For SQLite&lt;/a&gt; page says that dynamic pages on the SQLite website typically do about 200 SQL statements each. This has provoked criticism from readers. Examples:</source>
          <target state="translated">&lt;a href=&quot;whentouse#website&quot;&gt;SQLite&lt;/a&gt;ページの適切な使用法によると、SQLite Webサイトの動的ページは通常、それぞれ約200のSQLステートメントを実行します。これは読者からの批判を引き起こした。例：</target>
        </trans-unit>
        <trans-unit id="edb12d8d86687eb25304ab545c4bdc2adb558bbf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; can read and write a &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP Archive&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;zipfile&quot;&gt;ZIPファイル仮想テーブルは&lt;/a&gt;読み書きできる&lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIPアーカイブを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d23698ad6db1bcbbe81ce38782af791870223128" translate="yes" xml:space="preserve">
          <source>The &lt;b id=&quot;tcl&quot;&gt;TCL Tests&lt;/b&gt; are the oldest set of tests for SQLite. They are contained in the same source tree as the SQLite core and like the SQLite core are in the public domain. The TCL tests are the primary tests used during development. The TCL tests are written using the &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;TCL scripting language&lt;/a&gt;. The TCL test harness itself consists of 26.9 KSLOC of C code used to create the TCL interface. The test scripts are contained in 1264 files totaling 20.5MB in size. There are 44792 distinct test cases, but many of the test cases are parameterized and run multiple times (with different parameters) so that on a full test run millions of separate tests are performed.</source>
          <target state="translated">&lt;b id=&quot;tcl&quot;&gt;TCLテストは、&lt;/b&gt; SQLiteのためのテストの最古のセットです。それらはSQLiteコアと同じソースツリーに含まれ、SQLiteコアと同様にパブリックドメインにあります。 TCLテストは、開発中に使用される主要なテストです。 TCLテストは、&lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;TCLスクリプト言語&lt;/a&gt;を使用して記述されています。 TCLテストハーネス自体は、TCLインターフェイスの作成に使用される26.9 KSLOCのCコードで構成されています。テストスクリプトは、合計20.5MBのサイズの1264ファイルに含まれています。 44792の異なるテストケースがありますが、テストケースの多くはパラメーター化され、（異なるパラメーターで）複数回実行されるため、完全なテストの実行では数百万の個別のテストが実行されます。</target>
        </trans-unit>
        <trans-unit id="1ec2f6c6133a8488b1cdbdaeca80a7abf2b8d280" translate="yes" xml:space="preserve">
          <source>The &lt;b id=&quot;tcl&quot;&gt;TCL Tests&lt;/b&gt; are the oldest set of tests for SQLite. They are contained in the same source tree as the SQLite core and like the SQLite core are in the public domain. The TCL tests are the primary tests used during development. The TCL tests are written using the &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;TCL scripting language&lt;/a&gt;. The TCL test harness itself consists of 27.0 KSLOC of C code used to create the TCL interface. The test scripts are contained in 1272 files totaling 21.1MB in size. There are 46363 distinct test cases, but many of the test cases are parameterized and run multiple times (with different parameters) so that on a full test run millions of separate tests are performed.</source>
          <target state="translated">&lt;b id=&quot;tcl&quot;&gt;TCLテストは、&lt;/b&gt; SQLiteのためのテストの最古のセットです。それらはSQLiteコアと同じソースツリーに含まれており、SQLiteコアと同様にパブリックドメインにあります。 TCLテストは、開発中に使用される主要なテストです。 TCLテストは、&lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;TCLスクリプト言語&lt;/a&gt;を使用して記述されています。 TCLテストハーネス自体は、TCLインターフェイスの作成に使用される27.0KSLOCのCコードで構成されています。テストスクリプトは、合計21.1MBのサイズの1272ファイルに含まれています。 46363の異なるテストケースがありますが、テストケースの多くはパラメーター化され、複数回（異なるパラメーターで）実行されるため、完全なテスト実行では数百万の個別のテストが実行されます。</target>
        </trans-unit>
        <trans-unit id="6a6c5521cf56a12cd7c97f53a6e81f778a626555" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;&lt;/b&gt; test harness is a set of proprietary tests, written in C that provide 100% branch test coverage (and &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC test coverage&lt;/a&gt;) to the core SQLite library. The TH3 tests are designed to run on embedded and specialized platforms that would not easily support TCL or other workstation services. TH3 tests use only the published SQLite interfaces. TH3 consists of about 69.4 MB or 948.1 KSLOC of C code implementing 44753 distinct test cases. TH3 tests are heavily parameterized, though, so a full-coverage test runs about 1.7 million different test instances. The cases that provide 100% branch test coverage constitute a subset of the total TH3 test suite. A soak test prior to release does hundreds of millions of tests. Additional information on TH3 is &lt;a href=&quot;th3&quot;&gt;available separately&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;th3&quot;&gt;TH3の&lt;/a&gt;&lt;/b&gt;テストハーネスは100％分岐テストカバレッジ（及び提供Cで書かれた独自のテストのセットである&lt;a href=&quot;testing#mcdc&quot;&gt;100％MC / DCテストカバレッジを&lt;/a&gt;コアのSQLiteライブラリに）。TH3テストは、TCLやその他のワークステーションサービスを簡単にサポートできない組み込みおよび専用プラットフォームで実行するように設計されています。TH3テストは、公開されているSQLiteインターフェイスのみを使用します。TH3は、約69.4 MBまたは948.1 KSLOCのCコードで構成され、44753の異なるテストケースを実装します。ただし、TH3テストは厳密にパラメーター化されているため、フルカバレッジテストでは約170万の異なるテストインスタンスが実行されます。100％ブランチテストカバレッジを提供するケースは、TH3テストスイート全体のサブセットを構成します。リリース前のソークテストでは、何億ものテストが行​​われます。TH3の追加情報は&lt;a href=&quot;th3&quot;&gt;別途入手可能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6d35eb6cfeae174de2bae520fa16645d47318a8" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;&lt;/b&gt; test harness is a set of proprietary tests, written in C that provide 100% branch test coverage (and &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC test coverage&lt;/a&gt;) to the core SQLite library. The TH3 tests are designed to run on embedded and specialized platforms that would not easily support TCL or other workstation services. TH3 tests use only the published SQLite interfaces. TH3 consists of about 71.5 MB or 978.3 KSLOC of C code implementing 46622 distinct test cases. TH3 tests are heavily parameterized, though, so a full-coverage test runs about 1.9 million different test instances. The cases that provide 100% branch test coverage constitute a subset of the total TH3 test suite. A soak test prior to release does hundreds of millions of tests. Additional information on TH3 is &lt;a href=&quot;th3&quot;&gt;available separately&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;th3&quot;&gt;TH3の&lt;/a&gt;&lt;/b&gt;テストハーネスは100％分岐テストカバレッジ（及び提供Cで書かれた独自のテストのセットである&lt;a href=&quot;testing#mcdc&quot;&gt;100％MC / DCテストカバレッジを&lt;/a&gt;コアのSQLiteライブラリに）。TH3テストは、TCLやその他のワークステーションサービスを簡単にサポートできない組み込みおよび特殊なプラットフォームで実行するように設計されています。TH3テストは、公開されているSQLiteインターフェイスのみを使用します。TH3は、46622の異なるテストケースを実装する約71.5MBまたは978.3KSLOCのCコードで構成されています。ただし、TH3テストは高度にパラメータ化されているため、フルカバレッジテストでは約190万の異なるテストインスタンスが実行されます。100％のブランチテストカバレッジを提供するケースは、TH3テストスイート全体のサブセットを構成します。リリース前のソークテストでは、何億ものテストが行​​われます。TH3の追加情報は&lt;a href=&quot;th3&quot;&gt;別途入手可能です&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4cd8f15572230ed1f58d51c1d5372e68bc7d3339" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;&lt;i&gt;page number&lt;/i&gt;&lt;/b&gt; of the cached page. Pages are sequentially numbered within a database file starting from page 1 (page 1 begins at byte offset 0). Refer to</source>
          <target state="translated">キャッシュされたページの&lt;b&gt;&lt;i&gt;ページ番号&lt;/i&gt;&lt;/b&gt;。ページは、データベースファイル内でページ1から順番に番号が付けられます（ページ1はバイトオフセット0から始まります）。参照する</target>
        </trans-unit>
        <trans-unit id="81a39adda694af530886e4e9df6d7182a049eea0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SQLITE_ENABLE_REDEF_IO&lt;/b&gt; compile-time flag no longer functions. I/O procedures are now always redefinable.</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_REDEF_IO&lt;/b&gt;コンパイル時のフラグ機能しなくなります。I / Oプロシージャは常に再定義可能になりました。</target>
        </trans-unit>
        <trans-unit id="66961c7dbacae09d459d2962003215ef6b06eee5" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;ascii&lt;/b&gt; tokenizer, which assumes all characters outside of the ASCII codepoint range (0-127) are to be treated as token characters.</source>
          <target state="translated">&lt;b&gt;アスキー&lt;/b&gt;外部ASCIIコードポイント範囲（0〜127）の全ての文字を想定トークナイザは、トークン文字として扱われるべきです。</target>
        </trans-unit>
        <trans-unit id="da7024788e6b267f1ba270622b866f7355ceaff9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;atomic-write&lt;/b&gt; property. A system that supports this property also specifies the size or sizes of the blocks that it is capable of writing. Valid sizes are powers of two greater than 512. If a write operation modifies a block of</source>
          <target state="translated">&lt;b&gt;アトミック書き込み&lt;/b&gt;プロパティ。このプロパティをサポートするシステムは、書き込み可能なブロックのサイズも指定します。有効なサイズは、512より大きい2のべき乗です。書き込み操作で、</target>
        </trans-unit>
        <trans-unit id="d4ac7f6fa28d8af8532959a7c557a99ffb086e4a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;cached data&lt;/b&gt;; a blob of data</source>
          <target state="translated">&lt;b&gt;キャッシュされたデータ&lt;/b&gt; ; データのブロブ</target>
        </trans-unit>
        <trans-unit id="4bdaa687775a7cc6ed8f468435ceaab97dc48b3c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;checksum initializer&lt;/b&gt; field is set to a pseudo-random value. It is used as part of the algorithm to calculate the checksum for all</source>
          <target state="translated">&lt;b&gt;初期チェックサム&lt;/b&gt;フィールドは、擬似ランダムな値に設定されています。すべてのチェックサムを計算するアルゴリズムの一部として使用されます</target>
        </trans-unit>
        <trans-unit id="9732c0255b0b0de3b180d5a5b9e6e0e0de10ed21" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;checksum&lt;/b&gt; field contains a checksum value stored as a 4-byte big-endian signed integer. The checksum value is calculated as the sum of the bytes that make up the</source>
          <target state="translated">&lt;b&gt;チェックサム&lt;/b&gt;フィールドは、4バイトのビッグエンディアンの符号付き整数として格納されたチェックサム値を含みます。チェックサム値は、構成するバイトの合計として計算されます。</target>
        </trans-unit>
        <trans-unit id="808b646bb572829a50a12856cab578c0ba1273b4" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;child key&lt;/b&gt; is the column or set of columns in the child table that are constrained by the foreign key constraint and which hold the REFERENCES clause.</source>
          <target state="translated">&lt;b&gt;子キーは、&lt;/b&gt; REFERENCES句を保持する列または外部キー制約によって制約されており、子テーブルの列のセットです。</target>
        </trans-unit>
        <trans-unit id="4eb5a92cd04b8762d6cafb14dc40e6502ca97d4b" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;child table&lt;/b&gt; is the table that a foreign key constraint is applied to and the table that contains the REFERENCES clause. The example in this section uses the</source>
          <target state="translated">&lt;b&gt;子テーブルは、&lt;/b&gt;外部キー制約が適用されていることを表し、REFERENCES句を含むテーブルです。このセクションの例では、</target>
        </trans-unit>
        <trans-unit id="d2c172ce98989ce0e6fad8d66979d45e11202395" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;columns=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;カラム=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4bbf98eb754afaa644e3f69b92d0dc2195f52253" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;data=&lt;/b&gt; argument specifies that</source>
          <target state="translated">&lt;b&gt;データ=&lt;/b&gt;引数が指定するもの</target>
        </trans-unit>
        <trans-unit id="6baedccfb53deaad3fb37afa8fc4d96019b82c5a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;dbhash&lt;/b&gt; (or &lt;b&gt;dbhash.exe&lt;/b&gt; on Windows) utility is a command-line program that computes the SHA1 hash of the schema and content for an SQLite database.</source>
          <target state="translated">&lt;b&gt;dbhash&lt;/b&gt;（又は&lt;b&gt;dbhash.exe&lt;/b&gt; Windowsの場合）ユーティリティは、SQLiteデータベースのスキーマとコンテンツのSHA1ハッシュを計算するコマンドラインプログラムです。</target>
        </trans-unit>
        <trans-unit id="d6a3ef16a0b39b8edb4795fe8274619e6786a20a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;dbstat&lt;/b&gt; virtual table is available on all &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; when SQLite is built using the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option. The dbstat virtual table provides low-level information about btree and overflow pages in a database file.</source>
          <target state="translated">&lt;b&gt;dbstat&lt;/b&gt;仮想テーブルがすべてで利用可能である&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;のSQLiteを使用して構築されたときに&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt;コンパイル時のオプションを選択します。dbstat仮想テーブルは、データベースファイルのbtreeおよびオーバーフローページに関する低レベルの情報を提供します。</target>
        </trans-unit>
        <trans-unit id="76a580c33e2e93bdaf2b8468f5fe69cbcb6b77c7" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;filename=&lt;/b&gt; argument specifies an external file from which CSV content is read. Every CSV virtual table must have either a &lt;b&gt;filename=&lt;/b&gt; argument or a &lt;b&gt;data=&lt;/b&gt; argument and not both.</source>
          <target state="translated">&lt;b&gt;ファイル名は=&lt;/b&gt;引数には、CSVの内容が読み取られる外部ファイルを指定します。すべてのCSV仮想テーブルには、&lt;b&gt;filename =&lt;/b&gt;引数または&lt;b&gt;data =&lt;/b&gt;引数のいずれかが必要です。両方は必要ありません。</target>
        </trans-unit>
        <trans-unit id="b993a193dd09d944f6699b7d9c40cd91aa1faf7c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;journal magic&lt;/b&gt; field always contains a well-known 8-byte string value used to identify SQLite journal files. The well-known sequence of byte values is:</source>
          <target state="translated">&lt;b&gt;ジャーナル魔法の&lt;/b&gt;フィールドは常にSQLiteのジャーナル・ファイルを識別するために使用される、よく知られた8バイトの文字列値が含まれています。よく知られているバイト値のシーケンスは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a2e5b0d62ca7f429d717982cbc08462058d705f1" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;json1&lt;/b&gt; extension is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; that implements fifteen &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and two &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that are useful for managing &lt;a href=&quot;http://json.org/&quot;&gt;JSON&lt;/a&gt; content stored in an SQLite database. There are thirteen scalar functions:</source>
          <target state="translated">&lt;b&gt;json1&lt;/b&gt;拡張は、&lt;a href=&quot;loadext&quot;&gt;ロード可能な拡張&lt;/a&gt;用具15その&lt;a href=&quot;appfunc&quot;&gt;アプリケーション定義SQL関数&lt;/a&gt;二つ&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数&lt;/a&gt;の管理に有用である&lt;a href=&quot;http://json.org/&quot;&gt;JSONの&lt;/a&gt;SQLiteデータベースに格納されたコンテンツを。13個のスカラー関数があります。</target>
        </trans-unit>
        <trans-unit id="0fb60bd76a6daf3fc22f58ff7ed03bdcd9faa9a0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;json1&lt;/b&gt; extension is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; that implements fifteen &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; and two &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that are useful for managing &lt;a href=&quot;http://json.org/&quot;&gt;JSON&lt;/a&gt; content stored in an SQLite database. There are thirteen scalar functions:</source>
          <target state="translated">&lt;b&gt;json1&lt;/b&gt;拡張は、&lt;a href=&quot;loadext&quot;&gt;ロード可能な拡張&lt;/a&gt;用具15その&lt;a href=&quot;c3ref/create_function&quot;&gt;アプリケーション定義SQL関数&lt;/a&gt;二つ&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数&lt;/a&gt;の管理に有用である&lt;a href=&quot;http://json.org/&quot;&gt;JSONの&lt;/a&gt; SQLiteデータベースに格納されたコンテンツを。13個のスカラー関数があります。</target>
        </trans-unit>
        <trans-unit id="74a8fe72057fb6a9d52ebf2366e8ca3d47b3ef51" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;master journal name&lt;/b&gt; field contains the name of the master journal file, encoded as a utf-8 string. There is no nul-terminator appended to the string.</source>
          <target state="translated">&lt;b&gt;マスタージャーナル名の&lt;/b&gt;欄には、UTF-8文字列としてエンコードされたマスター・ジャーナル・ファイルの名前が含まれています。文字列に付加されたNULターミネータはありません。</target>
        </trans-unit>
        <trans-unit id="32cd399bbb4e1a23152d71a26f07f3eec308179e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;name-length&lt;/b&gt; field contains the length of the previous field in bytes, formatted as a 4-byte big-endian unsigned integer.</source>
          <target state="translated">&lt;b&gt;名前の長さの&lt;/b&gt;フィールドは、4バイトのビッグエンディアンの符号なし整数としてフォーマット、バイト単位で前のフィールドの長さが含まれています。</target>
        </trans-unit>
        <trans-unit id="fae22eeca9bdb678bd49709e0047fc71684a2c64" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;page size&lt;/b&gt; field contains the database page size used by the corresponding</source>
          <target state="translated">&lt;b&gt;ページサイズの&lt;/b&gt;フィールドは、対応することにより、使用するデータベースのページサイズが含まれています</target>
        </trans-unit>
        <trans-unit id="b47567cd5b3319ed0502d81821002b32b190c8e7" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;parent key&lt;/b&gt; is the column or set of columns in the parent table that the foreign key constraint refers to. This is normally, but not always, the primary key of the parent table. The parent key must be a named column or columns in the parent table, not the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;親キーは、&lt;/b&gt;外部キー制約が参照する親テーブルの列または列のセットです。これは、常にではありませんが、通常は親テーブルの主キーです。親キーは、&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;ではなく、親テーブルの名前付き列である必要があります。</target>
        </trans-unit>
        <trans-unit id="ec4c139f470f21c5fe4e5b5cefa7700a1825e05d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;parent table&lt;/b&gt; is the table that a foreign key constraint refers to. The parent table in the example in this section is the</source>
          <target state="translated">&lt;b&gt;親テーブルは、&lt;/b&gt;外部キー制約が参照するテーブルです。このセクションの例の親テーブルは、</target>
        </trans-unit>
        <trans-unit id="36aa5afa4e61953d1ec495c1b005644b052981bb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;porter&lt;/b&gt; tokenizer, which implements the &lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;porter stemming algorithm&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;ポーター&lt;/b&gt;実装トークナイザ、&lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;ポーター語幹アルゴリズムを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a37111e2fe594df629017fae4b6e16c1ee66e480" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;safe-append&lt;/b&gt; property. If a system supports the</source>
          <target state="translated">&lt;b&gt;安全・アペンド&lt;/b&gt;プロパティ。システムが</target>
        </trans-unit>
        <trans-unit id="d6885cc42a1a11dedbc2ecde02a62efeb92c5994" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;schema=&lt;/b&gt; argument specifies a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement that the CSV virtual table passes to the &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; interface in order to define the names of the columns in the virtual table.</source>
          <target state="translated">&lt;b&gt;スキーマ=&lt;/b&gt;引数を指定し&lt;a href=&quot;lang_createtable&quot;&gt;、CREATE TABLEの&lt;/a&gt; CSV仮想テーブルは、に渡すステートメント&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;仮想テーブルの列の名前を定義するためのインターフェイスを。</target>
        </trans-unit>
        <trans-unit id="062e562546606b031a29c9b1538d01a4933fdf4d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sequential-write&lt;/b&gt; property. A system that supports the</source>
          <target state="translated">&lt;b&gt;シーケンシャル書き込み&lt;/b&gt;プロパティ。をサポートするシステム</target>
        </trans-unit>
        <trans-unit id="9a93bd9a21f342ac487fc44f9c521120beed1f0d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite3&lt;/b&gt; command is used as follows:</source>
          <target state="translated">&lt;b&gt;sqlite3の&lt;/b&gt;コマンドは次のように使用されます。</target>
        </trans-unit>
        <trans-unit id="6bd9a1c77e9aedcf3a7d203f467b8767663fc753" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite3&lt;/b&gt; command opens the database named in the second argument. If the database does not already exist, the default behavior is for it to be created automatically (though this can be changed by using the &quot;&lt;b&gt;-create false&lt;/b&gt;&quot; option). The &lt;b&gt;sqlite3&lt;/b&gt; command always creates a new Tcl command to control the database. The name of the new Tcl command is given by the first argument. This approach is similar to the way widgets are created in Tk.</source>
          <target state="translated">&lt;b&gt;sqlite3の&lt;/b&gt;コマンドは、第二引数で指定されたデータベースを開きます。データベースがまだ存在しない場合、デフォルトの動作では自動的に作成されます（ただし、「- &lt;b&gt;create false&lt;/b&gt;」オプションを使用して変更できます）。&lt;b&gt;sqlite3のの&lt;/b&gt;コマンドでは、常にデータベースを制御するための新しいTclコマンドを生成します。新しいTclコマンドの名前は、最初の引数で指定されます。このアプローチは、Tkでウィジェットが作成される方法に似ています。</target>
        </trans-unit>
        <trans-unit id="b032b475b9199ee134a35698c55445c506e1d56e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite&lt;/b&gt; command-line utility uses the &lt;b&gt;sqlite_complete&lt;/b&gt; function to know when it needs to call &lt;b&gt;sqlite_exec&lt;/b&gt;. After each line of input is received, &lt;b&gt;sqlite&lt;/b&gt; calls &lt;b&gt;sqlite_complete&lt;/b&gt; on all input in its buffer. If &lt;b&gt;sqlite_complete&lt;/b&gt; returns true, then &lt;b&gt;sqlite_exec&lt;/b&gt; is called and the input buffer is reset. If &lt;b&gt;sqlite_complete&lt;/b&gt; returns false, then the prompt is changed to the continuation prompt and another line of text is read and added to the input buffer.</source>
          <target state="translated">&lt;b&gt;sqliteの&lt;/b&gt;コマンドラインユーティリティを使用しています&lt;b&gt;sqlite_complete&lt;/b&gt;それが呼び出す必要があるときに知っておく機能を&lt;b&gt;sqlite_exec&lt;/b&gt;。入力の各行が受信されると、&lt;b&gt;sqlite&lt;/b&gt;はそのバッファー内のすべての入力で&lt;b&gt;sqlite_complete&lt;/b&gt;を呼び出します。場合&lt;b&gt;sqlite_complete&lt;/b&gt; trueを返し、その後、&lt;b&gt;sqlite_exec&lt;/b&gt;と呼ばれ、入力バッファがリセットされます。&lt;b&gt;sqlite_complete&lt;/b&gt;がfalseを返す場合、プロンプトは継続プロンプトに変更され、別のテキスト行が読み取られて入力バッファーに追加されます。</target>
        </trans-unit>
        <trans-unit id="332726262d6ef917130298a44650660fb1ebc042" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_busy_handler&lt;/b&gt; procedure can be used to register a busy callback with an open SQLite database. The busy callback will be invoked whenever SQLite tries to access a database that is locked. The callback will typically do some other useful work, or perhaps sleep, in order to give the lock a chance to clear. If the callback returns non-zero, then SQLite tries again to access the database and the cycle repeats. If the callback returns zero, then SQLite aborts the current operation and returns SQLITE_BUSY.</source>
          <target state="translated">&lt;b&gt;sqlite_busy_handlerの&lt;/b&gt;手順は、オープンSQLiteデータベースで忙しいコールバックを登録するために使用することができます。 SQLiteがロックされているデータベースにアクセスしようとするたびに、ビジーコールバックが呼び出されます。コールバックは通常、ロックにクリアする機会を与えるために、他のいくつかの有用な作業、またはおそらくスリープを行います。コールバックがゼロ以外を返す場合、SQLiteはデータベースへのアクセスを再試行し、サイクルが繰り返されます。コールバックがゼロを返す場合、SQLiteは現在の操作を中止し、SQLITE_BUSYを返します。</target>
        </trans-unit>
        <trans-unit id="21449bf7fdcd477c05c71384163b9f8717a257f0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_changes&lt;/b&gt; API function returns the number of rows that have been inserted, deleted, or modified since the database was last quiescent. A &quot;quiescent&quot; database is one in which there are no outstanding calls to &lt;b&gt;sqlite_exec&lt;/b&gt; and no VMs created by &lt;b&gt;sqlite_compile&lt;/b&gt; that have not been finalized by &lt;b&gt;sqlite_finalize&lt;/b&gt;. In common usage, &lt;b&gt;sqlite_changes&lt;/b&gt; returns the number of rows inserted, deleted, or modified by the most recent &lt;b&gt;sqlite_exec&lt;/b&gt; call or since the most recent &lt;b&gt;sqlite_compile&lt;/b&gt;. But if you have nested calls to &lt;b&gt;sqlite_exec&lt;/b&gt; (that is, if the callback routine of one &lt;b&gt;sqlite_exec&lt;/b&gt; invokes another &lt;b&gt;sqlite_exec&lt;/b&gt;) or if you invoke &lt;b&gt;sqlite_compile&lt;/b&gt; to create a new VM while there is still another VM in existence, then the meaning of the number returned by &lt;b&gt;sqlite_changes&lt;/b&gt; is more complex. The number reported includes any changes that were later undone by a ROLLBACK or ABORT. But rows that are deleted because of a DROP TABLE are &lt;em&gt;not&lt;/em&gt; counted.</source>
          <target state="translated">&lt;b&gt;sqlite_changesの&lt;/b&gt; API関数は、データベースが最後に休止だったので、挿入、削除、または変更された行の数を返します。 「静止」データベースとは、&lt;b&gt;sqlite_exec&lt;/b&gt;への未解決の呼び出しがなく、&lt;b&gt;sqlite_finalize&lt;/b&gt;によってファイナライズされていない&lt;b&gt;sqlite_compile&lt;/b&gt;によって作成されたVM がないデータベースです。一般的な用法では、&lt;b&gt;sqlite_changesが&lt;/b&gt;挿入された行の数を返し、削除、または直近で変更&lt;b&gt;sqlite_exec&lt;/b&gt;のコールまたは最新以降&lt;b&gt;sqlite_compile&lt;/b&gt;。しかし、&lt;b&gt;sqlite_exec&lt;/b&gt;へのネストされた呼び出しがある&lt;b&gt;場合&lt;/b&gt;（つまり、1つの&lt;b&gt;sqlite_execの&lt;/b&gt;コールバックルーチンが別の&lt;b&gt;sqlite_execを&lt;/b&gt;呼び出す場合&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;sqlite_exec&lt;/b&gt;）、または&lt;b&gt;sqlite_compile&lt;/b&gt;を呼び出して別のVMがまだ存在しているときに新しいVMを作成する場合、&lt;b&gt;sqlite_changes&lt;/b&gt;によって返される数値の意味はより複雑になります。報告される数には、後でROLLBACKまたはABORTによって取り消された変更が含まれます。ただし、DROP TABLEが原因で削除された行&lt;em&gt;は&lt;/em&gt;カウントされ&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="78ea929e712b658454a0d7a7507e5e6040d334f9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_compile&lt;/b&gt; &quot;compiles&quot; a single SQL statement (specified by the second parameter) and generates a virtual machine that is able to execute that statement. As with must interface routines, the first parameter must be a pointer to an sqlite structure that was obtained from a prior call to &lt;b&gt;sqlite_open&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;sqlite_compile&lt;/b&gt;「コンパイル」（第2パラメータで指定された）単一のSQL文と、そのステートメントを実行することができる仮想マシンを生成します。mustインターフェースルーチンと同様に、最初のパラメーターは、&lt;b&gt;sqlite_open&lt;/b&gt;への以前の呼び出しから取得されたsqlite構造体へのポインターでなければなりません。</target>
        </trans-unit>
        <trans-unit id="11aed5342f0d3f43d8e5e9d1781269c400901176" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_create_function()&lt;/b&gt; interface is used to create regular functions and &lt;b&gt;sqlite_create_aggregate()&lt;/b&gt; is used to create new aggregate functions. In both cases, the &lt;b&gt;db&lt;/b&gt; parameter is an open SQLite database on which the functions should be registered, &lt;b&gt;zName&lt;/b&gt; is the name of the new function, &lt;b&gt;nArg&lt;/b&gt; is the number of arguments, and &lt;b&gt;pUserData&lt;/b&gt; is a pointer which is passed through unchanged to the C implementation of the function. Both routines return 0 on success and non-zero if there are any errors.</source>
          <target state="translated">&lt;b&gt;sqlite_create_function（）&lt;/b&gt;インターフェースは、通常の機能および作成するために使用される&lt;b&gt;（）sqlite_create_aggregateを&lt;/b&gt;新しい集約関数を作成するために使用されます。両方の場合において、&lt;b&gt;DBの&lt;/b&gt;パラメータは、機能が登録されるべきでオープンSQLiteデータベースであり、&lt;b&gt;ZNAMEは&lt;/b&gt;新しい関数の名前であり、&lt;b&gt;第nargは、&lt;/b&gt;引数の数であり、そして&lt;b&gt;pUserDataは&lt;/b&gt; C実装に不変に通されるポインタであります関数の。どちらのルーチンも、成功した場合は0を返し、エラーが発生した場合はゼロ以外を返します。</target>
        </trans-unit>
        <trans-unit id="5689a09fe87990c5eb5859050a66b6bf0ba7128a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_exec&lt;/b&gt; function is used to process SQL statements and queries. This function requires 5 parameters as follows:</source>
          <target state="translated">&lt;b&gt;sqlite_exec&lt;/b&gt;関数はSQLステートメントとクエリを処理するために使用されます。この関数には、次の5つのパラメーターが必要です。</target>
        </trans-unit>
        <trans-unit id="121679113b5d1c7ddf7783cb3755cec086d10308" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_exec&lt;/b&gt; function normally returns SQLITE_OK. But if something goes wrong it can return a different value to indicate the type of error. Here is a complete list of the return codes:</source>
          <target state="translated">&lt;b&gt;sqlite_exec&lt;/b&gt;関数は、通常SQLITE_OKを返します。しかし、何かがうまくいかなかった場合、エラーのタイプを示す別の値を返す可能性があります。戻りコードの完全なリストを以下に示します。</target>
        </trans-unit>
        <trans-unit id="655f344d54e7a8508c37039b0267420f9c98a884" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_exec&lt;/b&gt; routine described above used to be the only way to retrieve data from an SQLite database. But many programmers found it inconvenient to use a callback function to obtain results. So beginning with SQLite version 2.7.7, a second access interface is available that does not use callbacks.</source>
          <target state="translated">上記の&lt;b&gt;sqlite_exec&lt;/b&gt;ルーチンは、SQLiteデータベースからデータを取得する唯一の方法でした。しかし、多くのプログラマーは、結果を取得するためにコールバック関数を使用するのは不便だと感じました。そのため、SQLiteバージョン2.7.7から、コールバックを使用しない2番目のアクセスインターフェイスが利用可能になりました。</target>
        </trans-unit>
        <trans-unit id="0f4f5ac57e80af00b368fb64cb711d6dc8b648f6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_finalize&lt;/b&gt; routine also returns the result code that indicates success or failure of the SQL operation that the virtual machine carried out. The value returned by sqlite_finalize() will be the same as would have been returned had the same SQL been executed by &lt;b&gt;sqlite_exec&lt;/b&gt;. The error message returned will also be the same.</source>
          <target state="translated">&lt;b&gt;sqlite_finalizeの&lt;/b&gt;ルーチンは、仮想マシンが実行されるSQL操作の成功または失敗を示す結果コードを返します。sqlite_finalize（）によって返される値は、&lt;b&gt;sqlite_exec&lt;/b&gt;によって同じSQLが実行された場合に返される値と同じになります。返されるエラーメッセージも同じです。</target>
        </trans-unit>
        <trans-unit id="e5fe3b872ae55549d978788ef7dd0751c76061d1" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_get_table()&lt;/b&gt; function now returns an error if you give it two or more SELECTs that return different numbers of columns.</source>
          <target state="translated">&lt;b&gt;sqlite_get_table（）&lt;/b&gt;関数は、今、あなたはそれを列の異なる数を返す二つ以上のSELECT文を与える場合はエラーを返します。</target>
        </trans-unit>
        <trans-unit id="6c359ecc30c529f766becf568f4c268c432080f6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_get_table&lt;/b&gt; function is a wrapper around &lt;b&gt;sqlite_exec&lt;/b&gt; that collects all the information from successive callbacks and writes it into memory obtained from malloc(). This is a convenience function that allows the application to get the entire result of a database query with a single function call.</source>
          <target state="translated">&lt;b&gt;sqlite_get_table&lt;/b&gt;機能はラッパです&lt;b&gt;sqlite_exec&lt;/b&gt;）連続したコールバックからすべての情報を収集してはmalloc（から得られたメモリに書き込みます。これは、アプリケーションが1回の関数呼び出しでデータベースクエリの結果全体を取得できるようにする便利な関数です。</target>
        </trans-unit>
        <trans-unit id="dc054248626971621053a5f41a56a6eacfcebb24" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_get_table&lt;/b&gt; routine returns the same integer result code as &lt;b&gt;sqlite_exec&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;sqlite_get_table&lt;/b&gt;リターン同じ整数結果コード&lt;b&gt;sqlite_exec&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="bd292002416cc2983b3342d6c1953e82de8e1607" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_interrupt&lt;/b&gt; function can be called from a different thread or from a signal handler to cause the current database operation to exit at its first opportunity. When this happens, the &lt;b&gt;sqlite_exec&lt;/b&gt; routine (or the equivalent) that started the database operation will return SQLITE_INTERRUPT.</source>
          <target state="translated">&lt;b&gt;sqlite_interrupt&lt;/b&gt;機能は、その最初の機会で終了し、現在のデータベースの動作を引き起こすために、異なるスレッドからか、シグナルハンドラから呼び出すことができます。これが発生すると、データベース操作を開始した&lt;b&gt;sqlite_exec&lt;/b&gt;ルーチン（または同等のルーチン）がSQLITE_INTERRUPTを返します。</target>
        </trans-unit>
        <trans-unit id="110634f7ff21aac9a3d6ba9124f053cdf818f538" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_mprintf()&lt;/b&gt; routine works like the standard library &lt;b&gt;sprintf()&lt;/b&gt; except that it writes its results into memory obtained from malloc() and returns a pointer to the malloced buffer. &lt;b&gt;sqlite_mprintf()&lt;/b&gt; also understands the %q and %Q extensions described above. The &lt;b&gt;sqlite_vmprintf()&lt;/b&gt; is a varargs version of the same routine. The string pointer that these routines return should be freed by passing it to &lt;b&gt;sqlite_freemem()&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;sqlite_mprintf（）&lt;/b&gt;標準ライブラリのような日常的な作品&lt;b&gt;のsprintf（） &lt;/b&gt;、それはmalloc関数から取得したメモリにその結果を書き込む（）とmallocで割り当てられ、バッファへのポインタを返すことを除いて。&lt;b&gt;sqlite_mprintf（）&lt;/b&gt;は、上記の％qおよび％Q拡張も理解します。&lt;b&gt;sqlite_vmprintf（）は&lt;/b&gt;同じルーチンの可変引数バージョンです。これらのルーチンが返す文字列ポインタは、それを&lt;b&gt;sqlite_freemem（）に&lt;/b&gt;渡すことによって解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="1c001281fc04cb0f8f55a953f44815f9bb2acd94" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_progress_handler()&lt;/b&gt; routine can be used to register a callback routine with an SQLite database to be invoked periodically during long running calls to &lt;b&gt;sqlite_exec()&lt;/b&gt;, &lt;b&gt;sqlite_step()&lt;/b&gt; and the various wrapper functions.</source>
          <target state="translated">&lt;b&gt;sqlite_progress_handler（）&lt;/b&gt;ルーチンは、長いへの呼び出し実行中に定期的に呼び出されるためのSQLiteデータベースとコールバック・ルーチンを登録するために使用することができる&lt;b&gt;sqlite_exec（） &lt;/b&gt;、&lt;b&gt;sqlite_step（）&lt;/b&gt;および様々なラッパー関数を。</target>
        </trans-unit>
        <trans-unit id="2365ff095ada5e9e18ca628c551aa06ded148313" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;unicode61&lt;/b&gt; tokenizer, based on the Unicode 6.1 standard. This is the default.</source>
          <target state="translated">&lt;b&gt;unicode61&lt;/b&gt;のUnicode 6.1規格に基づいてトークナイザ、。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="c89f587843e082fe105c35ca8b1efaa6d37ded8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-shm&lt;/code&gt; and &lt;code&gt;-wal&lt;/code&gt; files already exists and are readable</source>
          <target state="translated">&lt;code&gt;-shm&lt;/code&gt; と &lt;code&gt;-wal&lt;/code&gt; ファイルが既に存在し、読み取り可能です</target>
        </trans-unit>
        <trans-unit id="ae74358eb64792c48dfddc93166fad33cb929d0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sqldiff.exe&lt;/code&gt; binary is a command-line utility program that displays the differences between SQLite databases. Example usage:</source>
          <target state="translated">&lt;code&gt;sqldiff.exe&lt;/code&gt; バイナリはSQLiteのデータベース間の差異を表示するコマンドラインユーティリティプログラムです。使用例：</target>
        </trans-unit>
        <trans-unit id="d7c66765c0cb2c27b3a6401331165fc804dadc56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; binary is a command-line utility program that measures and displays how much and how efficiently space is used by individual tables and indexes with an SQLite database file. Example usage:</source>
          <target state="translated">&lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; バイナリはどのくらいの対策やディスプレイすることを、どのように効率的にスペースがSQLiteのデータベースファイルを個々のテーブルとインデックスで使用されるコマンドラインユーティリティプログラムです。使用例：</target>
        </trans-unit>
        <trans-unit id="6a1974b0f327d4817e6c9b37b72d6c96039edec4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; program is a &lt;a href=&quot;http://www.tcl.tk/&quot;&gt;TCL&lt;/a&gt; program that uses the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt; to gather information about the database file and then format that information neatly.</source>
          <target state="translated">&lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; プログラムは、&lt;a href=&quot;http://www.tcl.tk/&quot;&gt;TCLの&lt;/a&gt;使用するプログラム&lt;a href=&quot;dbstat&quot;&gt;dbstat仮想テーブルを&lt;/a&gt;データベースファイルに関する情報を収集して、きちんとその情報をフォーマットします。</target>
        </trans-unit>
        <trans-unit id="ef70743aa444e28fbab143ed138c4d54acc4ad9c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&amp;lt;name&amp;gt;&lt;/em&gt; is the name your application chooses for the R*Tree index and &lt;em&gt;&amp;lt;column-names&amp;gt;&lt;/em&gt; is a comma separated list of between 3 and 11 columns. The virtual &amp;lt;name&amp;gt; table creates three &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt; to actually store its content. The names of these shadow tables are:</source>
          <target state="translated">&lt;em&gt;&amp;lt;名前&amp;gt;は&lt;/em&gt; R * Treeインデックスとのためのアプリケーションを選択した名前である&lt;em&gt;&amp;lt;列名&amp;gt;は&lt;/em&gt;コンマ3〜11列のリストを分離されています。仮想&amp;lt;name&amp;gt;テーブルは、その内容を実際に格納するための3つの&lt;a href=&quot;vtab#xshadowname&quot;&gt;シャドウテーブル&lt;/a&gt;を作成します。これらのシャドウテーブルの名前は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="cfd2051780cda360472504e6c22be9c660375526" translate="yes" xml:space="preserve">
          <source>The ADD COLUMN syntax is used to add a new column to an existing table. The new column is always appended to the end of the list of existing columns. The &lt;a href=&quot;syntax/column-def&quot;&gt;column-def&lt;/a&gt; rule defines the characteristics of the new column. The new column may take any of the forms permissible in a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement, with the following restrictions:</source>
          <target state="translated">ADD COLUMN構文は、既存のテーブルに新しい列を追加するために使用されます。新しい列は常に、既存の列のリストの最後に追加されます。&lt;a href=&quot;syntax/column-def&quot;&gt;カラム-DEF&lt;/a&gt;ルールは、新しい列の特性を定義します。新しい列は、&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ステートメントで許可されている任意の形式をとることができますが、次の制限があります。</target>
        </trans-unit>
        <trans-unit id="dd4a8c42527cc6ad0b74da94ea18e9ecc2a5a9ab" translate="yes" xml:space="preserve">
          <source>The ALTER TABLE command works by modifying the SQL text of the schema stored in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt;. No changes are made to table content. Because of this, the execution time of the ALTER TABLE command is independent of the amount of data in the table. The ALTER TABLE command runs as quickly on a table with 10 million rows as it does on a table with 1 row.</source>
          <target state="translated">ALTER TABLEコマンドは、&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_masterテーブルに&lt;/a&gt;格納されているスキーマのSQLテキストを変更することで機能します。テーブルの内容は変更されません。このため、ALTER TABLEコマンドの実行時間は、テーブル内のデータ量とは無関係です。ALTER TABLEコマンドは、1,000万行のテーブルでも、1行のテーブルと同じくらい速く実行されます。</target>
        </trans-unit>
        <trans-unit id="b0731871ca262efc59fc6d44f9562ddd3fdb4667" translate="yes" xml:space="preserve">
          <source>The ALTER TABLE command works by modifying the SQL text of the schema stored in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt;. No changes are made to table content. Because of this, the execution time of the ALTER TABLE command is independent of the amount of data in the table. The ALTER TABLE command runs as quickly on a table with 10 million rows as it does on a table with 1 row.</source>
          <target state="translated">ALTER TABLEコマンドは、&lt;a href=&quot;schematab&quot;&gt;sqlite_schemaテーブルに&lt;/a&gt;格納されているスキーマのSQLテキストを変更することによって機能します。テーブルの内容は変更されません。このため、ALTER TABLEコマンドの実行時間は、テーブル内のデータ量に依存しません。ALTER TABLEコマンドは、1行のテーブルで実行するのと同じように、1,000万行のテーブルで実行されます。</target>
        </trans-unit>
        <trans-unit id="3548d68842f13a30875b616a72010deb210b5992" translate="yes" xml:space="preserve">
          <source>The ALWAYS(X) and NEVER(X) macros are a weaker statement about the truth of X. The presence of ALWAYS(X) or NEVER(X) means that the developers believe X is always or never true, but there is no proof, or the proof is complex and error-prone, or the proof depends on other aspects of the system that seem likely to change.</source>
          <target state="translated">ALWAYS(X)や NEVER(X)マクロは、X の真偽についてのより弱いステートメントです。 ALWAYS(X)や NEVER(X)が存在するということは、開発者が X が常に、あるいは決して真ではないと信じているが、証明がない、証明が複雑でエラーが発生しやすい、あるいは証明がシステムの他の側面に依存している、ということを意味します。</target>
        </trans-unit>
        <trans-unit id="6ae8b97d0df4ab8cc5246397daf337e302574c90" translate="yes" xml:space="preserve">
          <source>The ALWAYS(X) and NEVER(X) macros behave like assert(X) during functionality testing, because the developers want to be immediately alerted to the issue if the value of X is different from what is expected. But for delivery, ALWAYS(X) and NEVER(X) are simple pass-through macros, which provide defense-in-depth. For coverage testing ALWAYS(X) and NEVER(X) are hard-coded boolean values so that they do not cause unreachable machine code to be generated.</source>
          <target state="translated">ALWAYS(X)と NEVER(X)マクロは、機能テスト中に assert(X)のように振る舞います。しかし、デリバリでは、ALWAYS(X)と NEVER(X)はシンプルなパススルーマクロであり、防御の詳細を提供します。カバレッジテストでは、ALWAYS(X)とNEVER(X)はハードコードされたブール値なので、到達不可能なマシンコードが生成されることはありません。</target>
        </trans-unit>
        <trans-unit id="e07bd491ac7cf8d45ca2e35ee71bfa7a388a2b49" translate="yes" xml:space="preserve">
          <source>The ANALYZE command gathers statistics about tables and indices and stores the collected information in &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal tables&lt;/a&gt; of the database where the query optimizer can access the information and use it to help make better query planning choices. If no arguments are given, all attached databases are analyzed. If a schema name is given as the argument, then all tables and indices in that one database are analyzed. If the argument is a table name, then only that table and the indices associated with that table are analyzed. If the argument is an index name, then only that one index is analyzed.</source>
          <target state="translated">ANALYZEコマンドは、テーブルとインデックスに関する統計を収集し、収集された情報をデータベースの&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部テーブル&lt;/a&gt;に格納します。データベースの内部テーブルでは、クエリオプティマイザーが情報にアクセスし、それを使用してクエリの計画をより適切に選択できます。引数を指定しない場合、接続されているすべてのデータベースが分析されます。スキーマ名が引数として指定されている場合、その1つのデータベース内のすべてのテーブルとインデックスが分析されます。引数がテーブル名の場合、そのテーブルとそのテーブルに関連付けられているインデックスのみが分析されます。引数がインデックス名の場合、その1つのインデックスのみが分析されます。</target>
        </trans-unit>
        <trans-unit id="eab24cd68f511dec396088e10ba12e5df9e965d6" translate="yes" xml:space="preserve">
          <source>The AND operator determines the &lt;b&gt;intersection&lt;/b&gt; of two sets of documents.</source>
          <target state="translated">AND演算子は、2つのドキュメントセットの&lt;b&gt;共通&lt;/b&gt;部分を決定します。</target>
        </trans-unit>
        <trans-unit id="a3b6d448d425bac9ff08d9f7709bfd23114eaa1f" translate="yes" xml:space="preserve">
          <source>The AND operator may be implicitly specified. If two basic queries appear with no operator separating them in an FTS query string, the results are the same as if the two basic queries were separated by an AND operator. For example, the query expression &quot;implicit operator&quot; is a more succinct version of &quot;implicit AND operator&quot;.</source>
          <target state="translated">AND演算子は暗黙のうちに指定することができます。2つの基本的な問い合わせが、FTS問い合わせ文字列の中で演算子で区切られていない状態で現れた場合、結果は、2つの基本的な問い合わせがAND演算子で区切られていた場合と同じになります。例えば、クエリ式「暗黙の演算子」は、「暗黙のAND演算子」のより簡潔なバージョンです。</target>
        </trans-unit>
        <trans-unit id="15fd0430aabb02304def7c36146cf671599d3942" translate="yes" xml:space="preserve">
          <source>The API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="938085178daf2eb44e4c20ce7562d652c273a4d4" translate="yes" xml:space="preserve">
          <source>The API for SQLite 3.0 includes 83 separate functions in addition to several data structures and #defines. (A complete &lt;a href=&quot;c3ref/intro&quot;&gt;API reference&lt;/a&gt; is provided as a separate document.) Fortunately, the interface is not nearly as complex as its size implies. Simple programs can still make do with only 3 functions: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, and &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;. More control over the execution of the database engine is provided using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; to compile an SQLite statement into byte code and &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; to execute that bytecode. A family of routines with names beginning with &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_&lt;/a&gt; is used to extract information about the result set of a query. Many interface functions come in pairs, with both a UTF-8 and UTF-16 version. And there is a collection of routines used to implement user-defined SQL functions and user-defined text collating sequences.</source>
          <target state="translated">SQLite 3.0のAPIには、いくつかのデータ構造と#definesに加えて、83の個別の関数が含まれています。 （完全な&lt;a href=&quot;c3ref/intro&quot;&gt;APIリファレンス&lt;/a&gt;は別のドキュメントとして提供されています。）幸い、インターフェースはそのサイズが意味するほど複雑ではありません。単純なプログラムはまだ唯一の3つの機能で間に合わせることができます。&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（） &lt;/a&gt;、&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（） &lt;/a&gt;、および&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（） &lt;/a&gt;。&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;を使用してSQLiteステートメントをバイトコードにコンパイルし、&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;を使用してそのバイトコードを実行することにより、データベースエンジンの実行をより詳細に制御できます。名前が&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_で&lt;/a&gt;始まるルーチンのファミリークエリの結果セットに関する情報を抽出するために使用されます。多くのインターフェース関数は、UTF-8バージョンとUTF-16バージョンの両方でペアで提供されます。また、ユーザー定義のSQL関数とユーザー定義のテキスト照合シーケンスを実装するために使用されるルーチンのコレクションもあります。</target>
        </trans-unit>
        <trans-unit id="c44a4b3ab13cd66c53e9432e0d3af7281c445940" translate="yes" xml:space="preserve">
          <source>The API for version 3.0 is similar to the version 2.X API, but with some important changes. Most noticeably, the &quot;&lt;code&gt;sqlite_&lt;/code&gt;&quot; prefix that occurs on the beginning of all API functions and data structures are changed to &quot;&lt;code&gt;sqlite3_&lt;/code&gt;&quot;. This avoids confusion between the two APIs and allows linking against both SQLite 2.X and SQLite 3.0 at the same time.</source>
          <target state="translated">バージョン3.0のAPIはバージョン2.X APIに似ていますが、いくつかの重要な変更があります。最も顕著なのは、すべてのAPI関数とデータ構造の先頭にある「 &lt;code&gt;sqlite_&lt;/code&gt; 」接頭辞が「 &lt;code&gt;sqlite3_&lt;/code&gt; 」に変更されていることです。これにより、2つのAPI間の混乱が回避され、SQLite 2.XとSQLite 3.0の両方に対して同時にリンクできます。</target>
        </trans-unit>
        <trans-unit id="36d190e36c6e5fa5963aab7e95daad2e70b8ee67" translate="yes" xml:space="preserve">
          <source>The ATTACH DATABASE statement adds another database file to the current &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. Database files that were previously attached can be removed using the &lt;a href=&quot;lang_detach&quot;&gt;DETACH DATABASE&lt;/a&gt; command.</source>
          <target state="translated">ATTACH DATABASEステートメントは、現在の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続に&lt;/a&gt;別のデータベースファイルを追加します。以前にアタッチされたデータベースファイルは、&lt;a href=&quot;lang_detach&quot;&gt;DETACH DATABASE&lt;/a&gt;コマンドを使用して削除できます。</target>
        </trans-unit>
        <trans-unit id="1e719935b3c48aaab57f1043bcfdf280a49c9b8d" translate="yes" xml:space="preserve">
          <source>The AUTOINCREMENT keyword imposes extra CPU, memory, disk space, and disk I/O overhead and should be avoided if not strictly needed. It is usually not needed.</source>
          <target state="translated">AUTOINCREMENT キーワードは、余分な CPU、メモリ、ディスクスペース、およびディスク I/O のオーバーヘッドを発生させるので、厳密に必要でない場合は避けるべきです。通常は必要ありません。</target>
        </trans-unit>
        <trans-unit id="48851d12ae740edbaa05f50e23f70eaa76ffb64c" translate="yes" xml:space="preserve">
          <source>The Ascii tokenizer is similar to the Unicode61 tokenizer, except that:</source>
          <target state="translated">Asciiトークナイザーは、それ以外はUnicode61トークナイザーに似ています。</target>
        </trans-unit>
        <trans-unit id="12502ac36995aeed690062079cb8e1d738f368d7" translate="yes" xml:space="preserve">
          <source>The B-tree module requests information from the disk in fixed-size pages. The default &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; is 4096 bytes but can be any power of two between 512 and 65536 bytes. The page cache is responsible for reading, writing, and caching these pages. The page cache also provides the rollback and atomic commit abstraction and takes care of locking of the database file. The B-tree driver requests particular pages from the page cache and notifies the page cache when it wants to modify pages or commit or rollback changes. The page cache handles all the messy details of making sure the requests are handled quickly, safely, and efficiently.</source>
          <target state="translated">Bツリーモジュールは、固定サイズのページでディスクに情報を要求します。デフォルトの&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt;は4096バイトですが、512から65536バイトの間の2のべき乗にすることができます。ページキャッシュは、これらのページの読み取り、書き込み、およびキャッシュを行います。ページキャッシュは、ロールバックとアトミックコミットの抽象化も提供し、データベースファイルのロックを処理します。 Bツリードライバーは、ページキャッシュから特定のページを要求し、ページを変更したり、変更をコミットまたはロールバックしたりするときにページキャッシュに通知します。ページキャッシュは、要求が迅速、安全、かつ効率的に処理されるようにするための厄介な詳細をすべて処理します。</target>
        </trans-unit>
        <trans-unit id="a9c46870576aba5a82ba72dd5f506b8ec80b72f2" translate="yes" xml:space="preserve">
          <source>The BEFORE or AFTER keyword determines when the trigger actions will be executed relative to the insertion, modification or removal of the associated row.</source>
          <target state="translated">BEFORE または AFTER キーワードは、関連する行の挿入、変更、または削除に関連して、トリガ・アクションがいつ実行されるかを決定します。</target>
        </trans-unit>
        <trans-unit id="21f8310c8a4f643230a41569cc835883561b2976" translate="yes" xml:space="preserve">
          <source>The BEFORE or AFTER keyword determines when the trigger actions will be executed relative to the insertion, modification or removal of the associated row. BEFORE is the default when neither keyword is present.</source>
          <target state="translated">BEFORE または AFTER キーワードは、関連する行の挿入、変更、または削除に関連して、トリガ・アクションがいつ実行されるかを決定します。どちらのキーワードも存在しない場合は、BEFORE がデフォルトです。</target>
        </trans-unit>
        <trans-unit id="b63dc07d0b34107d9ff47bbfc25d958a7f1dde76" translate="yes" xml:space="preserve">
          <source>The BETWEEN operator</source>
          <target state="translated">BETWEEN演算子</target>
        </trans-unit>
        <trans-unit id="bf7d42c3d7c926828f621e364e6fa7e162b22076" translate="yes" xml:space="preserve">
          <source>The BETWEEN operator is logically equivalent to a pair of comparisons. &quot;</source>
          <target state="translated">BETWEEN演算子は論理的には一対の比較と等価です。&quot;</target>
        </trans-unit>
        <trans-unit id="b2bdb770820ef0c5e362d9c32237f45d4cd0627c" translate="yes" xml:space="preserve">
          <source>The BLOB argument to snippet() does not have the correct subtype, so the snippet function ignores it, makes no changes to any data structures, and harmlessly returns NULL.</source>
          <target state="translated">snippet()の BLOB 引数は正しいサブタイプを持っていないので、 snippet 関数はそれを無視してデータ構造を変更せず、無害に NULL を返します。</target>
        </trans-unit>
        <trans-unit id="3210a7f9aaf2f66bd9905568531663be357a3b69" translate="yes" xml:space="preserve">
          <source>The BTree module allocates large buffers using malloc() instead of off of the stack, in order to play better on machines with limited stack space.</source>
          <target state="translated">BTree モジュールは、スタックスペースが限られているマシンでより良いプレイをするために、スタックからではなく malloc()を使用して大きなバッファを割り当てます。</target>
        </trans-unit>
        <trans-unit id="21f5d882ac3e8071ceb7ad0fcec2c3ef4f2e3e7c" translate="yes" xml:space="preserve">
          <source>The C code below implements a simple window aggregate function named sumint(). This works in the same way as the built-in sum() function, except that it throws an exception if passed an argument that is not an integer value.</source>
          <target state="translated">以下の C コードは sumint()という名前の単純なウィンドウ集約関数を実装しています。これは組み込みの sum()関数と同じように動作しますが、整数値でない引数を渡された場合に例外が発生します。</target>
        </trans-unit>
        <trans-unit id="d5cf82df30f7e154d46c9db25174e218f7ef9aef" translate="yes" xml:space="preserve">
          <source>The C function to the right demonstrates one of the simplest, and most common, uses of the backup API: loading and saving the contents of an in-memory database to a file on disk. The backup API is used as follows in this example:</source>
          <target state="translated">右側のC関数は、バックアップAPIの最もシンプルで一般的な使用法の1つである、インメモリデータベースのコンテンツをロードしてディスク上のファイルに保存することを示しています。この例では、バックアップAPIは次のように使用されます。</target>
        </trans-unit>
        <trans-unit id="d54a9c2fa57a9ea05dba3dee97529bc735dc5276" translate="yes" xml:space="preserve">
          <source>The C language interface to SQLite Version 2</source>
          <target state="translated">SQLite バージョン 2 の C 言語インターフェース</target>
        </trans-unit>
        <trans-unit id="fe37317d6916dca66fe00426df36e00a240b1501" translate="yes" xml:space="preserve">
          <source>The C language is old and boring. It is a well-known and well-understood language. This is exactly what one wants when developing a module like SQLite. Writing a small, fast, and reliable database engine is hard enough as it is without the implementation language changing out from under you with each update to the implementation language specification.</source>
          <target state="translated">C言語は古くてつまらない。C言語はよく知られていて、よく理解されている言語です。これは、SQLiteのようなモジュールを開発するときに必要なものです。小さくて高速で信頼性の高いデータベースエンジンを書くのは、実装言語の仕様が更新されるたびに、実装言語があなたの下から変わっていくのではなく、十分に難しいことです。</target>
        </trans-unit>
        <trans-unit id="7245ee6098ebc8d6b59383d4e63478298246efb9" translate="yes" xml:space="preserve">
          <source>The C parameter to &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close(C)&lt;/a&gt; and &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2(C)&lt;/a&gt; must be either a NULL pointer or an &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object pointer obtained from &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and not previously closed. Calling sqlite3_close() or sqlite3_close_v2() with a NULL pointer argument is a harmless no-op.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close（C）&lt;/a&gt;および&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2（C）&lt;/a&gt;へのCパラメーターは、NULLポインター、または&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（）&lt;/a&gt;、または&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;から取得された&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt;オブジェクトポインターである必要があり、以前は閉じられていません。NULLポインター引数を指定してsqlite3_close（）またはsqlite3_close_v2（）を呼び出すことは、無害な何もしません。</target>
        </trans-unit>
        <trans-unit id="7c0540d8d33318130da25d1e55f755e6a1ecc3bb" translate="yes" xml:space="preserve">
          <source>The C parameter to &lt;a href=&quot;close&quot;&gt;sqlite3_close(C)&lt;/a&gt; and &lt;a href=&quot;close&quot;&gt;sqlite3_close_v2(C)&lt;/a&gt; must be either a NULL pointer or an &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object pointer obtained from &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and not previously closed. Calling sqlite3_close() or sqlite3_close_v2() with a NULL pointer argument is a harmless no-op.</source>
          <target state="translated">&lt;a href=&quot;close&quot;&gt;sqlite3_close（C）&lt;/a&gt;および&lt;a href=&quot;close&quot;&gt;sqlite3_close_v2（C）&lt;/a&gt;へのCパラメーターは、NULLポインター、または&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;open&quot;&gt;sqlite3_open16（）&lt;/a&gt;、または&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;から取得された&lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt;オブジェクトポインターである必要があり、以前は閉じられていません。NULLポインター引数を指定してsqlite3_close（）またはsqlite3_close_v2（）を呼び出すことは、無害な何もしません。</target>
        </trans-unit>
        <trans-unit id="c6b84eb128b8b4492347bcdafbeda21b63c03f1b" translate="yes" xml:space="preserve">
          <source>The C-language API for SQLite provides the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file control&lt;/a&gt; which gives &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations the opportunity to add new PRAGMA statements or to override the meaning of built-in PRAGMA statements.</source>
          <target state="translated">SQLiteのC言語APIは、&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA &lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;ファイルコントロール&lt;/a&gt;を提供します。これにより、&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;実装は、新しいPRAGMAステートメントを追加したり、組み込みのPRAGMAステートメントの意味を上書きしたりできます。</target>
        </trans-unit>
        <trans-unit id="3cdde2acd27b2b36bcb4e6d376af3a07b88f1a00" translate="yes" xml:space="preserve">
          <source>The CASE expression</source>
          <target state="translated">CASE式</target>
        </trans-unit>
        <trans-unit id="b66ba15f2fad294f2684c4bed978c753222465dc" translate="yes" xml:space="preserve">
          <source>The CAST operator understands decimal integers only &amp;mdash; conversion of &lt;a href=&quot;lang_expr#hexint&quot;&gt;hexadecimal integers&lt;/a&gt; stops at the &quot;x&quot; in the &quot;0x&quot; prefix of the hexadecimal integer string and thus result of the CAST is always zero.</source>
          <target state="translated">CAST演算子は10進整数のみを理解します&amp;mdash; &lt;a href=&quot;lang_expr#hexint&quot;&gt;16進整数の&lt;/a&gt;変換は、16進整数文字列の「0x」接頭辞の「x」で停止するため、CASTの結果は常にゼロです。</target>
        </trans-unit>
        <trans-unit id="a234c8e77cd8f0401958366a773fd160b49e7507" translate="yes" xml:space="preserve">
          <source>The CLI has another build-in SQL function named edit(). Edit() takes one or two arguments. The first argument is a value - usually a large multi-line string to be edited. The second argument is the name of a text editor. If the second argument is omitted, the VISUAL environment variable is used. The edit() function writes its first argument into a temporary file, invokes the editor on the temporary file, rereads the file back into memory after the editor is done, then returns the edited text.</source>
          <target state="translated">CLIには、edit()という名前の別のビルトインSQL関数があります。edit()は1つまたは2つの引数を取ります。最初の引数は値で、通常は編集される大きな複数行の文字列です。第二引数はテキスト・エディタの名前です。第二引数が省略された場合は、環境変数 VISUAL が使用されます。edit()関数は、第一引数を一時ファイルに書き込み、一時ファイル上でエディタを起動し、エディタが終了した後にファイルをメモリに戻し、編集されたテキストを返します。</target>
        </trans-unit>
        <trans-unit id="19b42365ba0a7a06fdcdf543ad6806dc3520342c" translate="yes" xml:space="preserve">
          <source>The CLI ignores whitespace (including comments) at the end of lines</source>
          <target state="translated">CLIは行末の空白(コメントを含む)を無視します。</target>
        </trans-unit>
        <trans-unit id="dd9e96d76e423f66ac741c4a46deda1233291328" translate="yes" xml:space="preserve">
          <source>The COLLATE clause optionally following each column name or expression defines a collating sequence used for text entries in that column. The default collating sequence is the collating sequence defined for that column in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. Or if no collating sequence is otherwise defined, the built-in BINARY collating sequence is used.</source>
          <target state="translated">オプションで各列名または式に続くCOLLATE句は、その列のテキストエントリに使用される照合シーケンスを定義します。デフォルトの照合シーケンスは、&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ステートメントでその列に対して定義された照合シーケンスです。または、他に照合シーケンスが定義されていない場合は、組み込みのBINARY照合シーケンスが使用されます。</target>
        </trans-unit>
        <trans-unit id="cce4b68250de466854c34f5909554bfe291d7ca1" translate="yes" xml:space="preserve">
          <source>The COLLATE clause specifies the name of a &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; to use as the default collation sequence for the column. If no COLLATE clause is specified, the default collation sequence is &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt;.</source>
          <target state="translated">COLLATE句は、列のデフォルトの照合シーケンスとして使用する&lt;a href=&quot;datatype3#collation&quot;&gt;照合シーケンスの&lt;/a&gt;名前を指定します。 COLLATE句が指定されていない場合、デフォルトの照合順序は&lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="4b44ceebb8207f8e640174bbe459b285c5b2aace" translate="yes" xml:space="preserve">
          <source>The COLLATE operator is a unary postfix operator that assigns a &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; to an expression. The COLLATE operator has a higher precedence (binds more tightly) than any binary operator and any unary prefix operator except &quot;~&quot;. (COLLATE and &quot;~&quot; are associative so their binding order does not matter.) The collating sequence set by the COLLATE operator overrides the collating sequence determined by the COLLATE clause in a table &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definition&lt;/a&gt;. See the &lt;a href=&quot;datatype3#collation&quot;&gt;detailed discussion on collating sequences&lt;/a&gt; in the &lt;a href=&quot;datatype3&quot;&gt;Datatype In SQLite3&lt;/a&gt; document for additional information.</source>
          <target state="translated">COLLATE演算子は、&lt;a href=&quot;datatype3#collation&quot;&gt;照合シーケンス&lt;/a&gt;を式に割り当てる単項後置演算子です。 COLLATE演算子は、 &quot;〜&quot;を除くすべての2項演算子および単項前置演算子よりも優先度が高くなります（より緊密にバインドされます）。 （COLLATEと &quot;〜&quot;は関連付けられているため、バインドの順序は重要ではありません。）COLLATE演算子によって設定された照合シーケンスは、テーブル&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;列定義の&lt;/a&gt; COLLATE句によって決定された照合シーケンスを上書きします。&lt;a href=&quot;datatype3#collation&quot;&gt;詳細について&lt;/a&gt;は、&lt;a href=&quot;datatype3&quot;&gt;Datatype In SQLite3&lt;/a&gt;ドキュメントの照合シーケンスに関する詳細な説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="a680bd512c99945ec1f5ce6f701753b4eac29105" translate="yes" xml:space="preserve">
          <source>The COMPLETION extension implements a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; named &quot;completion&quot; that can be used to suggest completions of partially entered words during interactive SQL input. The completion table can be used to help implement tab-completion, for example.</source>
          <target state="translated">COMPLETION拡張は、対話型SQL入力中に部分的に入力された単語の補完を提案するために使用できる「completion」という名前の&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数を&lt;/a&gt;実装します。補完テーブルは、たとえばタブ補完の実装に使用できます。</target>
        </trans-unit>
        <trans-unit id="f18272789e8a6f151079fbc600b2b7e84d838750" translate="yes" xml:space="preserve">
          <source>The COMPLETION() Table-Valued Function</source>
          <target state="translated">COMPLETION()テーブル値関数</target>
        </trans-unit>
        <trans-unit id="6a7ddb1a93117b2b3bde0c54048509560ea3634c" translate="yes" xml:space="preserve">
          <source>The COPY command puts NULLs in columns whose data is '\N'.</source>
          <target state="translated">COPYコマンドは、データが'\N'である列にNULLを入れます。</target>
        </trans-unit>
        <trans-unit id="13eb987eb47f3316a50f4573a4bd655a2e5a8454" translate="yes" xml:space="preserve">
          <source>The CORRUPT_DB macro is used in many assert() statements. In functional testing builds, CORRUPT_DB references a global variable that is true if the database file might contain corruption. This variable is true by default, since we do not normally know whether or not a database is corrupt, but during testing while working on databases that are known to be well-formed, that global variable can be set to false. Then the CORRUPT_DB macro can be used in assert() statements such as seen at &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680&lt;/a&gt;. Those assert()s specify pre-conditions to the routine that are true for consistent database files, but which might be false if the database file is corrupt. Knowledge of these kinds of conditions is very helpful to readers who are trying to understand a block of code in isolation.</source>
          <target state="translated">CORRUPT_DBマクロは、多くのassert（）ステートメントで使用されます。機能テストビルドでは、CORRUPT_DBは、データベースファイルに破損が含まれている可能性がある場合にtrueになるグローバル変数を参照します。通常、データベースが破損しているかどうかはわからないため、この変数はデフォルトでtrueですが、整形式であることがわかっているデータベースで作業しているときのテスト中に、グローバル変数をfalseに設定できます。次に、CORRUPT_DBマクロは、https：//sqlite.org/src/artifact/18a53540aa3？ln = 1679-1680にあるようなassert（）ステートメントで使用できます&lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680&quot;&gt;。&lt;/a&gt;。これらのassert（）は、一貫性のあるデータベースファイルに対してはtrueですが、データベースファイルが破損している場合はfalseになる可能性があるルーチンの事前条件を指定します。これらの種類の条件の知識は、コードのブロックを分離して理解しようとしている読者に非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="87b68f64512a185516fdf233a80a1c3ea3aa60fd" translate="yes" xml:space="preserve">
          <source>The CREATE INDEX command consists of the keywords &quot;CREATE INDEX&quot; followed by the name of the new index, the keyword &quot;ON&quot;, the name of a previously created table that is to be indexed, and a parenthesized list of table column names and/or expressions that are used for the index key. If the optional WHERE clause is included, then the index is a &quot;&lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;&quot;.</source>
          <target state="translated">CREATE INDEXコマンドは、キーワード &quot;CREATE INDEX&quot;の後に新しいインデックスの名前、キーワード &quot;ON&quot;、インデックスが作成される以前に作成されたテーブルの名前、括弧で囲まれたテーブルの列名のリスト、および/または、インデックスキーに使用される式。オプションのWHERE句が含まれている場合、インデックスは「&lt;a href=&quot;partialindex&quot;&gt;部分インデックス&lt;/a&gt;」です。</target>
        </trans-unit>
        <trans-unit id="abdfd2b1dd5fd6ecf72fce71bade948329a001e4" translate="yes" xml:space="preserve">
          <source>The CREATE TRIGGER statement is used to add triggers to the database schema. Triggers are database operations that are automatically performed when a specified database event occurs.</source>
          <target state="translated">CREATE TRIGGER ステートメントは、データベース スキーマにトリガーを追加するために使用されます。トリガーは、指定されたデータベースイベントが発生したときに自動的に実行されるデータベース操作です。</target>
        </trans-unit>
        <trans-unit id="598d64a270f59326bd978afae12168eba5f52ca0" translate="yes" xml:space="preserve">
          <source>The CREATE VIEW command assigns a name to a pre-packaged &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. Once the view is created, it can be used in the FROM clause of another &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; in place of a table name.</source>
          <target state="translated">CREATE VIEWコマンドは、事前にパッケージ化された&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントに名前を割り当てます。ビューが作成されると、テーブル名の代わりに別の&lt;a href=&quot;lang_select&quot;&gt;SELECTの&lt;/a&gt; FROM句で使用できます。</target>
        </trans-unit>
        <trans-unit id="174705dc4a8b591705076f7ea08e69231535552a" translate="yes" xml:space="preserve">
          <source>The CREATE VIRTUAL TABLE &quot;tokenize&quot; option is used to configure the specific tokenizer used by the FTS5 table. The option argument must be either an FTS5 bareword, or an SQL text literal. The text of the argument is itself treated as a white-space series of one or more FTS5 barewords or SQL text literals. The first of these is the name of the tokenizer to use. The second and subsequent list elements, if they exist, are arguments passed to the tokenizer implementation.</source>
          <target state="translated">CREATE VIRTUAL TABLE &quot;tokenize &quot;オプションは、FTS5テーブルで使用される特定のトークンライザを設定するために使用されます。オプションの引数は、FTS5のベアワードかSQLテキストリテラルのいずれかでなければなりません。引数のテキストは、それ自体が1つ以上のFTS5ベアワードまたはSQLテキストリテラルの空白文字列として扱われます。これらの最初の要素は、使用するトークナイザーの名前です。2 番目以降のリスト要素が存在する場合は、トークンizer の実装に渡される引数です。</target>
        </trans-unit>
        <trans-unit id="5585953bde77b974603ba3ea6e6ff59c9cc91b38" translate="yes" xml:space="preserve">
          <source>The CREATE VIRTUAL TABLE statement creates a new table called table-name derived from the class class module-name. The module-name is the name that is registered for the virtual table by the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; interface.</source>
          <target state="translated">CREATE VIRTUAL TABLEステートメントは、クラスクラスmodule-nameから派生したtable-nameと呼ばれる新しいテーブルを作成します。module-nameは、&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;インターフェースによって仮想テーブルに登録される名前です。</target>
        </trans-unit>
        <trans-unit id="1062968fd409aff74d10cea95e91438b9101e01c" translate="yes" xml:space="preserve">
          <source>The CREATE, TABLE, VIEW, TRIGGER, and INDEX keywords at the beginning of the statement are converted to all upper case letters.</source>
          <target state="translated">文頭のCREATE、TABLE、VIEW、TRIGGER、INDEXキーワードはすべて大文字に変換されます。</target>
        </trans-unit>
        <trans-unit id="640a12b822aa85aa459e9a1bb86ef50f7f04eecb" translate="yes" xml:space="preserve">
          <source>The CSV Virtual Table</source>
          <target state="translated">CSV仮想テーブル</target>
        </trans-unit>
        <trans-unit id="7457dbcb832f7358700e049001b26f6040f77dbe" translate="yes" xml:space="preserve">
          <source>The CSV virtual table is not built into the SQLite amalgamation. It is available as a &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/csv.c&quot;&gt;separate source file&lt;/a&gt; that can be compiled into a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;. Typical usage of the CSV virtual table from the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; would be something like this:</source>
          <target state="translated">CSV仮想テーブルはSQLiteの統合に組み込まれていません。&lt;a href=&quot;loadext&quot;&gt;ロード可能な拡張機能に&lt;/a&gt;コンパイルできる&lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/csv.c&quot;&gt;個別のソースファイル&lt;/a&gt;として使用できます。&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;からのCSV仮想テーブルの一般的な使用法は次のようになります。</target>
        </trans-unit>
        <trans-unit id="15b49f55e220937bbbf59d823ad49d5a9aa75e6b" translate="yes" xml:space="preserve">
          <source>The CSV virtual table is useful to applications that need to bulk-load large amounts of comma-separated value content. The CSV virtual table is also useful as a template source file for implementing other virtual tables.</source>
          <target state="translated">CSV 仮想テーブルは、カンマで区切られた値の内容を大量に一括して読み込む必要があるアプリケーションに便利です。また、CSV仮想テーブルは、他の仮想テーブルを実装するためのテンプレートソースファイルとしても有用です。</target>
        </trans-unit>
        <trans-unit id="ea497adefbfc963344834dc953220548ab21ec73" translate="yes" xml:space="preserve">
          <source>The CSV virtual table reads &lt;a href=&quot;https://www.ietf.org/rfc/rfc4180.txt&quot;&gt;RFC 4180&lt;/a&gt; formatted comma-separated values, and returns that content as if it were rows and columns of an SQL table.</source>
          <target state="translated">CSV仮想テーブルは、&lt;a href=&quot;https://www.ietf.org/rfc/rfc4180.txt&quot;&gt;RFC 4180&lt;/a&gt;形式のコンマ区切り値を読み取り、その内容をSQLテーブルの行と列のように返します。</target>
        </trans-unit>
        <trans-unit id="701ea259a9685ea4d0bc43814eed54520d975a72" translate="yes" xml:space="preserve">
          <source>The Callback instruction in this example has to generate data for three result columns instead of two, but is otherwise the same as in the first query. When the Callback instruction is invoked, the left-most column of the result should be the lowest in the stack and the right-most result column should be the top of the stack. We can see the stack being set up this way at addresses 11 through 15. The Column instructions at 11 and 12 push the values for the first two columns in the result. The two Column instructions at 13 and 14 pull in the values needed to compute the third result column and the Concat instruction at 15 joins them together into a single entry on the stack.</source>
          <target state="translated">この例のコールバック命令は、2つの結果カラムではなく3つの結果カラムのデータを生成しなければなりませんが、それ以外は最初のクエリと同じです。コールバック命令が呼び出されたとき、結果の左端のカラムがスタックの最下位になり、右端のカラムがスタックの最上位になります。アドレス11から15までのスタックがこのように設定されているのがわかります。11と12のColumn命令は、結果の最初の2列の値をプッシュします。13と14の2つのColumn命令は、3番目の結果列を計算するのに必要な値を取り込み、15のConcat命令はそれらの値をスタック上の1つのエントリに結合します。</target>
        </trans-unit>
        <trans-unit id="421f0a20824677ed3aab71d6f46b98a38cc2b1ed" translate="yes" xml:space="preserve">
          <source>The Carray() Table-Valued Function</source>
          <target state="translated">Carray()のテーブル値関数</target>
        </trans-unit>
        <trans-unit id="b6379901f8c254a706f0c6dbee9e66ad0809b055" translate="yes" xml:space="preserve">
          <source>The Checklist Manifesto</source>
          <target state="translated">チェックリスト・マニフェスト</target>
        </trans-unit>
        <trans-unit id="b16740a57ff0b848b3dcfa1e89789fe4179b42d5" translate="yes" xml:space="preserve">
          <source>The Clang/LLVM compiler is not competitive with GCC. Clang-generated binaries are consistently larger and slower than GCC-generated binaries.</source>
          <target state="translated">Clang/LLVMコンパイラはGCCと競合しません。Clangが生成したバイナリは、GCCが生成したバイナリよりも一貫して大きく、遅いです。</target>
        </trans-unit>
        <trans-unit id="78bc8f511390974d6caf83474dc6a28ef2586f49" translate="yes" xml:space="preserve">
          <source>The Close instruction at the end of the program closes the cursor that points into the table &quot;examp&quot;. It is not really necessary to call Close here since all cursors will be automatically closed by the VDBE when the program halts. But we needed an instruction for the Rewind to jump to so we might as well go ahead and have that instruction do something useful. The Halt instruction ends the VDBE program.</source>
          <target state="translated">プログラムの最後にあるClose命令は、テーブル &quot;examp &quot;を指すカーソルを閉じる。プログラムが停止したとき、すべてのカーソルはVDBEによって自動的に閉じられるので、ここでCloseを呼び出す必要はありません。しかし、巻き戻しにジャンプするための命令が必要だったので、先に行ってその命令に何か役に立つことをさせた方がいいかもしれない。Halt命令はVDBEプログラムを終了する。</target>
        </trans-unit>
        <trans-unit id="b524e42667c1ac047d027b2497617d613c12fde4" translate="yes" xml:space="preserve">
          <source>The D and N arguments to sqlite3_backup_init(D,N,S,M) are the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; associated with the destination database and the database name, respectively. The database name is &quot;main&quot; for the main database, &quot;temp&quot; for the temporary database, or the name specified after the AS keyword in an &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for an attached database. The S and M arguments passed to sqlite3_backup_init(D,N,S,M) identify the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and database name of the source database, respectively. The source and destination &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; (parameters S and D) must be different or else sqlite3_backup_init(D,N,S,M) will fail with an error.</source>
          <target state="translated">sqlite3_backup_init（D、N、S、M）のD引数とN引数は、それぞれ宛先データベースとデータベース名に関連付けられた&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;です。データベース名は、メインデータベースの場合は「main」、一時データベースの場合は「temp」、または接続されているデータベースの&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;ステートメントのASキーワードの後に​​指定された名前です。 sqlite3_backup_init（D、N、S、M）に渡されるS引数とM引数は、それぞれソースデータベースの&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;とデータベース名を識別します。ソースと宛先の&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;（パラメーターSとD）は異なる必要があります。そうでない場合、sqlite3_backup_init（D、N、S、M）はエラーで失敗します。</target>
        </trans-unit>
        <trans-unit id="f80ea416ab3893dba34d3603b147323625f4c5ae" translate="yes" xml:space="preserve">
          <source>The D and N arguments to sqlite3_backup_init(D,N,S,M) are the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; associated with the destination database and the database name, respectively. The database name is &quot;main&quot; for the main database, &quot;temp&quot; for the temporary database, or the name specified after the AS keyword in an &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for an attached database. The S and M arguments passed to sqlite3_backup_init(D,N,S,M) identify the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and database name of the source database, respectively. The source and destination &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; (parameters S and D) must be different or else sqlite3_backup_init(D,N,S,M) will fail with an error.</source>
          <target state="translated">sqlite3_backup_init（D、N、S、M）のD引数とN引数は、それぞれ宛先データベースとデータベース名に関連付けられた&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;です。データベース名は、メインデータベースの場合は「main」、一時データベースの場合は「temp」、または接続されているデータベースの&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;ステートメントのASキーワードの後に​​指定された名前です。 sqlite3_backup_init（D、N、S、M）に渡されるS引数とM引数は、それぞれソースデータベースの&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;とデータベース名を識別します。ソースと宛先の&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;（パラメーターSとD）は異なる必要があります。そうでない場合、sqlite3_backup_init（D、N、S、M）はエラーで失敗します。</target>
        </trans-unit>
        <trans-unit id="8f1eeb8e873e48b54ccf8adc2382597a61daec29" translate="yes" xml:space="preserve">
          <source>The D parameter to &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; may be NULL. If the D parameter in &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; is not NULL, then the maximum length of the string contained in the &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object will be the value set for &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(D,&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) instead of &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（D）&lt;/a&gt;のDパラメータがNULLである可能性があります。&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（D）&lt;/a&gt;のDパラメータがNULLでない場合、&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;オブジェクトに含まれる文字列の最大長は、&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;ではなく&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;（D、SQLITE_LIMIT_LENGTH）に設定された値に&lt;a href=&quot;limits#max_length&quot;&gt;なり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="f7435a55126fe3b0801a03e561888366bace9433" translate="yes" xml:space="preserve">
          <source>The D parameter to &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; may be NULL. If the D parameter in &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; is not NULL, then the maximum length of the string contained in the &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object will be the value set for &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(D,&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) instead of &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（D）&lt;/a&gt;のDパラメータがNULLである可能性があります。&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（D）&lt;/a&gt;のDパラメータがNULLでない場合、&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;オブジェクトに含まれる文字列の最大長は、&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;ではなく&lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;（D、SQLITE_LIMIT_LENGTH）に設定された値に&lt;a href=&quot;../limits#max_length&quot;&gt;なり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="091a2ba2d55b0a7d15b54d374b18e4d57aa3a683" translate="yes" xml:space="preserve">
          <source>The DBSTAT Virtual Table</source>
          <target state="translated">DBSTAT 仮想テーブル</target>
        </trans-unit>
        <trans-unit id="97ceb7c4621bdd8f62a9cfbb2a879b8e9e999bd7" translate="yes" xml:space="preserve">
          <source>The DBSTAT table only reports on the content of btrees within the database file. Freelist pages, pointer-map pages, and the lock page are omitted from the analysis.</source>
          <target state="translated">DBSTATテーブルは、データベースファイル内のbtreeの内容のみを報告する。フリーリストページ、ポインタマップページ、ロックページは分析から省略されます。</target>
        </trans-unit>
        <trans-unit id="76cd10f2092ca8f1b285dee48937f8c50e332d42" translate="yes" xml:space="preserve">
          <source>The DBSTAT virtual table is a read-only &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; that returns information about the amount of disk space used to store the content of an SQLite database. Example use cases for the DBSTAT virtual table include the &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt; utility program and the &lt;a href=&quot;https://www.sqlite.org/src/repo-tabsize&quot;&gt;table size pie-chart&lt;/a&gt; in the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil-implemented&lt;/a&gt; version control system for SQLite.</source>
          <target state="translated">DBSTAT仮想テーブルは、SQLiteデータベースのコンテンツを格納するために使用されるディスク領域の量に関する情報を返す読み取り専用の&lt;a href=&quot;vtab#epovtab&quot;&gt;同名の仮想テーブル&lt;/a&gt;です。 DBSTAT仮想テーブルの使用例には、&lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt;ユーティリティプログラムと、SQLite用に&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossilで実装された&lt;/a&gt;バージョン管理システムの&lt;a href=&quot;https://www.sqlite.org/src/repo-tabsize&quot;&gt;テーブルサイズの円グラフが含ま&lt;/a&gt;れます。</target>
        </trans-unit>
        <trans-unit id="53bde0cca31e9e282f188b556d84747d1c6f1e06" translate="yes" xml:space="preserve">
          <source>The DBSTAT virtual table is a read-only &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; that returns information about which pages of the database files are used by which tables and indexes in the schema. The DBSTAT virtual table is used to implement &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt; utility program, and to help compute the &lt;a href=&quot;https://www.sqlite.org/src/repo-tabsize&quot;&gt;table size pie-chart&lt;/a&gt; in the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil-implemented&lt;/a&gt; version control system for SQLite.</source>
          <target state="translated">DBSTAT仮想テーブルは、読み取り専用である&lt;a href=&quot;vtab#epovtab&quot;&gt;同名の仮想テーブル&lt;/a&gt;を返す情報は、データベースファイルのページは、スキーマ内のどのテーブルとインデックスで使用されているかについてのこと。 DBSTAT仮想テーブルは、&lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt;ユーティリティプログラムを実装し、&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossilで実装さ&lt;/a&gt;れたSQLiteのバージョン管理システムで&lt;a href=&quot;https://www.sqlite.org/src/repo-tabsize&quot;&gt;テーブルサイズの円グラフ&lt;/a&gt;を計算するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="a9ce5a525fa3a87844d5ab55ef30cdd54b0cc3c2" translate="yes" xml:space="preserve">
          <source>The DBSTAT virtual table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;, meaning that is not necessary to run &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; to create an instance of the dbstat virtual table before using it. The &quot;dbstat&quot; module name can be used as if it were a table name to query the dbstat virtual table directly. For example:</source>
          <target state="translated">DBSTAT仮想テーブルは&lt;a href=&quot;vtab#epovtab&quot;&gt;同名の仮想テーブルです&lt;/a&gt;。つまり、&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE&lt;/a&gt; VIRTUALTABLEを実行してdbstat仮想テーブルのインスタンスを作成してから使用する必要はありません。「dbstat」モジュール名は、dbstat仮想テーブルを直接照会するためのテーブル名であるかのように使用できます。例えば：</target>
        </trans-unit>
        <trans-unit id="f357b6765d9672540c415d35375e9c82ab3dde27" translate="yes" xml:space="preserve">
          <source>The DBSTAT virtual table is available on all &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; when SQLite is built using the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLiteが&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt;コンパイル時オプションを使用して構築されている場合、DBSTAT仮想テーブルはすべての&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続で&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="8e77f3a2af88468cea075512b7c593d618135668" translate="yes" xml:space="preserve">
          <source>The DEFAULT clause specifies a default value to use for the column if no value is explicitly provided by the user when doing an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;. If there is no explicit DEFAULT clause attached to a column definition, then the default value of the column is NULL. An explicit DEFAULT clause may specify that the default value is NULL, a string constant, a blob constant, a signed-number, or any constant expression enclosed in parentheses. A default value may also be one of the special case-independent keywords CURRENT_TIME, CURRENT_DATE or CURRENT_TIMESTAMP. For the purposes of the DEFAULT clause, an expression is considered constant if it contains no sub-queries, column or table references, &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;, or string literals enclosed in double-quotes instead of single-quotes.</source>
          <target state="translated">DEFAULT句は、&lt;a href=&quot;lang_insert&quot;&gt;INSERTの&lt;/a&gt;実行時にユーザーが値を明示的に提供しない場合に列に使用するデフォルト値を指定します。列定義に明示的なDEFAULT句がアタッチされていない場合、列のデフォルト値はNULLです。明示的なDEFAULT句は、デフォルト値がNULL、文字列定数、BLOB定数、符号付き数値、または括弧で囲まれた定数式であることを指定できます。デフォルト値は、特殊な大文字と小文字を区別しないキーワードCURRENT_TIME、CURRENT_DATE、またはCURRENT_TIMESTAMPのいずれかである場合もあります。 DEFAULT句では、サブクエリ、列またはテーブル参照、&lt;a href=&quot;lang_expr#varparam&quot;&gt;バインドされたパラメータ&lt;/a&gt;、または単一引用符ではなく二重引用符で囲まれた文字列リテラルが含まれていない場合、式は定数と見なされます。</target>
        </trans-unit>
        <trans-unit id="f30a44f7fde1290a9d66490fe4c7fc9d343db0a2" translate="yes" xml:space="preserve">
          <source>The DELETE command removes records from the table identified by the &lt;a href=&quot;syntax/qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;.</source>
          <target state="translated">DELETEコマンドは、&lt;a href=&quot;syntax/qualified-table-name&quot;&gt;qualified-table-nameで&lt;/a&gt;識別されるテーブルからレコードを削除します。</target>
        </trans-unit>
        <trans-unit id="549ed1cfefc84f8dde1745ba5b3bb051dd3b5008" translate="yes" xml:space="preserve">
          <source>The DELETE command without a WHILE clause just removes the database files from the disk, rather than going through and deleting record by record.</source>
          <target state="translated">WHILE句のないDELETEコマンドは、レコードごとにレコードを削除するのではなく、ディスクからデータベースファイルを削除するだけです。</target>
        </trans-unit>
        <trans-unit id="0c69d162dd597ca7eb6e965c55e71ba6c6554cc2" translate="yes" xml:space="preserve">
          <source>The DELETE journaling mode is the normal behavior. In the DELETE mode, the rollback journal is deleted at the conclusion of each transaction. Indeed, the delete operation is the action that causes the transaction to commit. (See the document titled &lt;a href=&quot;atomiccommit&quot;&gt; Atomic Commit In SQLite&lt;/a&gt; for additional detail.)</source>
          <target state="translated">DELETEジャーナリングモードは通常の動作です。DELETEモードでは、各トランザクションの終了時にロールバックジャーナルが削除されます。実際、削除操作はトランザクションをコミットさせるアクションです。（詳細については、&lt;a href=&quot;atomiccommit&quot;&gt;SQLiteのAtomic Commit&lt;/a&gt;というタイトルのドキュメントを参照してください。）</target>
        </trans-unit>
        <trans-unit id="1da9a7936dc2b558a9310f00abb6a148be159cba" translate="yes" xml:space="preserve">
          <source>The DELETE trigger must be fired before the actual delete takes place on the content table. This is so that FTS4 can still retrieve the original values in order to update the full-text index. And the INSERT trigger must be fired after the new row is inserted, so as to handle the case where the rowid is assigned automatically within the system. The UPDATE trigger must be split into two parts, one fired before and one after the update of the content table, for the same reasons.</source>
          <target state="translated">DELETE トリガは、実際の削除がコンテンツテーブル上で行われる前に実行されなければなりません。これは、FTS4がフルテキスト・インデックスを更新するために元の値を取得することができるようにするためです。また、行IDがシステム内で自動的に割り当てられている場合に対応するため、INSERTトリガは、新しい行が挿入された後に発行されなければなりません。同じ理由で、UPDATEトリガは2つの部分に分けなければなりません。</target>
        </trans-unit>
        <trans-unit id="3ab4459caaad95b429957125366d895b4021e494" translate="yes" xml:space="preserve">
          <source>The DELETE-mode locks are stored on the &lt;a href=&quot;fileformat2#lockbyte&quot;&gt;lock-byte page&lt;/a&gt; of the main database file. Only SQLITE_LOCK_SHARED and SQLITE_LOCK_EXCLUSIVE are factors for WAL-mode databases. The other locking states are used in rollback-mode, but not in WAL-mode.</source>
          <target state="translated">DELETEモードのロックは、メインデータベースファイルの&lt;a href=&quot;fileformat2#lockbyte&quot;&gt;ロックバイトページ&lt;/a&gt;に格納されます。SQLITE_LOCK_SHAREDとSQLITE_LOCK_EXCLUSIVEだけがWALモードデータベースの要素です。他のロック状態はロールバックモードで使用されますが、WALモードでは使用されません。</target>
        </trans-unit>
        <trans-unit id="577fca03e1d22d54957a27f6f46f602e956a7f46" translate="yes" xml:space="preserve">
          <source>The DISTINCT keyword in an aggregate query</source>
          <target state="translated">集計クエリの DISTINCT キーワード。</target>
        </trans-unit>
        <trans-unit id="5960207cc3ff80c8b76aafd25f9f8b94d8c8f42b" translate="yes" xml:space="preserve">
          <source>The DISTINCT keyword now will sometimes use an INDEX if an appropriate index is available and the optimizer thinks its use might be advantageous.</source>
          <target state="translated">現在のDISTINCTキーワードは、適切なインデックスが利用可能で、オプティマイザがその使用が有利であると考えている場合には、INDEXを使用することがあります。</target>
        </trans-unit>
        <trans-unit id="fc7140e369fedc4714b9ea0083c995ff08e24d5b" translate="yes" xml:space="preserve">
          <source>The DISTINCT keyword on an aggregate query is implemented by creating a transient index in a temporary file and storing each result row in that index. As new result rows are computed a check is made to see if they already exist in the transient index and if they do the new result row is discarded.</source>
          <target state="translated">集約クエリの DISTINCT キーワードは、一時ファイルに一時インデックスを作成し、そのインデックスに各結果行を格納することで実装されます。新しい結果行が計算されると、その結果行が既にトランジェントインデックスに存在するかどうかがチェックされ、存在する場合は新しい結果行が破棄されます。</target>
        </trans-unit>
        <trans-unit id="3c8c0a43ed7404e0a2eaed887060f73b06109a61" translate="yes" xml:space="preserve">
          <source>The DROP INDEX statement removes an index added with the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement. The index is completely removed from the disk. The only way to recover the index is to reenter the appropriate &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; command.</source>
          <target state="translated">DROP INDEXステートメントは、&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;ステートメントで追加されたインデックスを削除します。インデックスがディスクから完全に削除されます。インデックスを回復する唯一の方法は、適切な&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;コマンドを再入力することです。</target>
        </trans-unit>
        <trans-unit id="bf79716c365aa3a9096fb80997c218efa52bf726" translate="yes" xml:space="preserve">
          <source>The DROP TABLE statement removes a table added with the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. The name specified is the table name. The dropped table is completely removed from the database schema and the disk file. The table can not be recovered. All indices and triggers associated with the table are also deleted.</source>
          <target state="translated">DROP TABLEステートメントは、&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ステートメントで追加されたテーブルを削除します。指定された名前はテーブル名です。ドロップされたテーブルは、データベーススキーマとディスクファイルから完全に削除されます。テーブルは回復できません。テーブルに関連付けられているすべてのインデックスとトリガーも削除されます。</target>
        </trans-unit>
        <trans-unit id="8134f9df85fa3c68e953f09b317e3c27f145a52e" translate="yes" xml:space="preserve">
          <source>The DROP TRIGGER statement removes a trigger created by the &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement. Once removed, the trigger definition is no longer present in the sqlite_master (or sqlite_temp_master) table and is not fired by any subsequent INSERT, UPDATE or DELETE statements.</source>
          <target state="translated">DROP TRIGGERステートメントは、&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;ステートメントによって作成されたトリガーを削除します。削除されると、トリガー定義はsqlite_master（またはsqlite_temp_master）テーブルに存在しなくなり、後続のINSERT、UPDATE、またはDELETEステートメントによって起動されません。</target>
        </trans-unit>
        <trans-unit id="5c4386299e0353e3df19809c98731f022556c566" translate="yes" xml:space="preserve">
          <source>The DROP VIEW statement removes a view created by the &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; statement. The view definition is removed from the database schema, but no actual data in the underlying base tables is modified.</source>
          <target state="translated">DROP VIEWステートメントは、&lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;ステートメントによって作成されたビューを削除します。ビュー定義はデータベーススキーマから削除されますが、基になるベーステーブルの実際のデータは変更されません。</target>
        </trans-unit>
        <trans-unit id="81bf67a5e4628332f9b58ee8c6d173a4c4f911e2" translate="yes" xml:space="preserve">
          <source>The Dbbe abstraction and the GDBM and memory drivers were removed.</source>
          <target state="translated">Dbbeの抽象化とGDBMとメモリドライバを削除しました。</target>
        </trans-unit>
        <trans-unit id="b8ac6ee150153e29d6eb02ac712357b33cd11445" translate="yes" xml:space="preserve">
          <source>The Default Page Size Change of SQLite 3.12.0</source>
          <target state="translated">SQLite 3.12.0のデフォルトページサイズの変更について</target>
        </trans-unit>
        <trans-unit id="9fa7fe014de7884ad65be67fee11ca70cb61f51e" translate="yes" xml:space="preserve">
          <source>The EXCEPT operator for compound queries is implemented by creating a transient index in a temporary file, storing the results of the left subquery in this transient index, then removing the result from right subquery from the transient index, and finally walking the index from beginning to end to obtain the final output.</source>
          <target state="translated">複合クエリのEXCEPT演算子は、一時ファイルに一時インデックスを作成し、左の副問い合わせの結果をこの一時インデックスに格納し、右の副問い合わせの結果を一時インデックスから削除し、最後にインデックスを最初から最後まで歩いて最終出力を得ることで実装されています。</target>
        </trans-unit>
        <trans-unit id="5ae9f97f03202a131a787390ace280bc0296d78b" translate="yes" xml:space="preserve">
          <source>The EXISTS operator</source>
          <target state="translated">EXISTS演算子</target>
        </trans-unit>
        <trans-unit id="84773fe1424e26217a7a2df622779c7708ba171b" translate="yes" xml:space="preserve">
          <source>The EXISTS operator always evaluates to one of the integer values 0 and 1. If executing the SELECT statement specified as the right-hand operand of the EXISTS operator would return one or more rows, then the EXISTS operator evaluates to 1. If executing the SELECT would return no rows at all, then the EXISTS operator evaluates to 0.</source>
          <target state="translated">EXISTS演算子は常に0と1の整数値のいずれかに評価されます。 EXISTS演算子の右辺のオペランドとして指定されたSELECT文を実行すると1行以上の行が返される場合、EXISTS演算子は1と評価されます。 SELECTを実行すると全く行が返されない場合、EXISTS演算子は0と評価されます。</target>
        </trans-unit>
        <trans-unit id="93ef1c61206801602304d02bd0314e2e805ed955" translate="yes" xml:space="preserve">
          <source>The EXPLAIN QUERY PLAN command is described in &lt;a href=&quot;eqp&quot;&gt;more detail here&lt;/a&gt;.</source>
          <target state="translated">EXPLAIN QUERY PLANコマンドについては、&lt;a href=&quot;eqp&quot;&gt;ここで詳しく説明します&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c62b11f7e5c5d50c87cb37698a2dd96b4ced3ac8" translate="yes" xml:space="preserve">
          <source>The EXPLAIN and EXPLAIN QUERY PLAN prefixes affect the behavior of running a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; using &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. The process of generating a new prepared statement using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or similar is (mostly) unaffected by EXPLAIN. (The exception to the previous sentence is that some special opcodes used by EXPLAIN QUERY PLAN are omitted when building an EXPLAIN QUERY PLAN prepared statement, as a performance optimization.)</source>
          <target state="translated">EXPLAINおよびEXPLAIN QUERY PLANプレフィックスは、&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;を使用して&lt;a href=&quot;c3ref/stmt&quot;&gt;準備済みステートメント&lt;/a&gt;を実行する動作に影響します。&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;などを使用して新しい準備済みステートメントを生成するプロセスは、（ほとんど）EXPLAINの影響を受けません。（前の文の例外は、EXPLAIN QUERY PLAN準備済みステートメントを構築するときに、パフォーマンスの最適化として、EXPLAIN QUERY PLANで使用されるいくつかの特別なオペコードが省略されることです。）</target>
        </trans-unit>
        <trans-unit id="c3ee00b5769ef7f7d7fa11249f75b6c728fff5d2" translate="yes" xml:space="preserve">
          <source>The Error And Warning Log</source>
          <target state="translated">エラーと警告ログ</target>
        </trans-unit>
        <trans-unit id="d0e00804aea114acdf8c7482e29e4b6fc1dd022a" translate="yes" xml:space="preserve">
          <source>The FAIL behavior only works for uniqueness, NOT NULL, and CHECK constraints. A &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; violation causes an ABORT.</source>
          <target state="translated">FAIL動作は、一意性、NOT NULL、およびCHECK制約に対してのみ機能します。&lt;a href=&quot;foreignkeys&quot;&gt;外部キー制約&lt;/a&gt;違反がABORTが発生します。</target>
        </trans-unit>
        <trans-unit id="adadb0f9269151516b0ccaba4b14756b3c80bd9b" translate="yes" xml:space="preserve">
          <source>The FOR EACH STATEMENT clause on a trigger now causes a syntax error. It used to be silently ignored.</source>
          <target state="translated">トリガ上の FOR EACH STATEMENT 句は、構文エラーを引き起こすようになりました。以前は無視されていました。</target>
        </trans-unit>
        <trans-unit id="9cd48fd724eca1ec736eda16ef97971212fd20e2" translate="yes" xml:space="preserve">
          <source>The FTS modules may be compiled to use one of two slightly different versions of the full-text query syntax, the &quot;standard&quot; query syntax and the &quot;enhanced&quot; query syntax. The basic term, term-prefix, phrase and NEAR queries described above are the same in both versions of the syntax. The way in which set operations are specified is slightly different. The following two sub-sections describe the part of the two query syntaxes that pertains to set operations. Refer to the description of how to &lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;compile fts&lt;/a&gt; for compilation notes.</source>
          <target state="translated">FTSモジュールは、フルテキストクエリ構文の「標準」クエリ構文と「拡張」クエリ構文の2つのわずかに異なるバージョンの1つを使用するようにコンパイルできます。上記の基本的な用語、用語の接頭辞、フレーズ、およびNEARクエリは、両方のバージョンの構文で同じです。集合演算の指定方法は少し異なります。次の2つのサブセクションでは、2つのクエリ構文のうち、集合演算に関連する部分について説明します。コンパイルの注意事項については&lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;、ftsのコンパイル&lt;/a&gt;方法の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="b82e31fa29aba07c9204f92b3f977e0bafebbf9f" translate="yes" xml:space="preserve">
          <source>The FTS query syntax (right hand side of the MATCH operator) has changed in some ways. The FTS5 syntax is quite close to the FTS4 &quot;enhanced syntax&quot;. The main difference is that FTS5 is fussier about unrecognized punctuation characters and similar within query strings. Most queries that work with FTS3/4 should also work with FTS5, and those that do not should return parse errors.</source>
          <target state="translated">FTSクエリの構文(MATCH演算子の右側)がいくつか変更されています。FTS5の構文は、FTS4の「拡張構文」にかなり近いです。主な違いは、FTS5は、認識されていない句読点文字やクエリ文字列内の類似文字についてより慎重になっていることです。FTS3/4で動作するほとんどのクエリはFTS5でも動作し、そうでないクエリはパースエラーを返すはずです。</target>
        </trans-unit>
        <trans-unit id="452e2c3759f6eb486841492aa116e202a1ab1f44" translate="yes" xml:space="preserve">
          <source>The FTS table column number to extract the returned fragments of text from. Columns are numbered from left to right starting with zero. A negative value indicates that the text may be extracted from any column.</source>
          <target state="translated">返されたテキストの断片を抽出するFTSテーブルのカラム番号。カラムは、ゼロから始まる左から右に番号が付けられています。負の値は、どの列からでもテキストを抽出できることを示します。</target>
        </trans-unit>
        <trans-unit id="e03bf1e933cfbb832357f37ab56f4975c4a387f7" translate="yes" xml:space="preserve">
          <source>The FTS3 and FTS4 extension modules allows users to create special tables with a built-in full-text index (hereafter &quot;FTS tables&quot;). The full-text index allows the user to efficiently query the database for all rows that contain one or more words (hereafter &quot;tokens&quot;), even if the table contains many large documents.</source>
          <target state="translated">FTS3およびFTS4の拡張モジュールでは、ユーザは、フルテキストインデックスを内蔵した特殊なテーブル(以下、「FTSテーブル」という)を作成することができます。フルテキストインデックスを使用することで、テーブルに大きな文書が多く含まれている場合でも、1つ以上の単語(以下、「トークン」という)を含むすべての行を効率的にデータベースに問い合わせることができます。</target>
        </trans-unit>
        <trans-unit id="7d4bac9786b108503576084f19784d9481dfe5de" translate="yes" xml:space="preserve">
          <source>The FTS3 and FTS4 modules provide three special SQL scalar functions that may be useful to the developers of full-text query systems: &quot;snippet&quot;, &quot;offsets&quot; and &quot;matchinfo&quot;. The purpose of the &quot;snippet&quot; and &quot;offsets&quot; functions is to allow the user to identify the location of queried terms in the returned documents. The &quot;matchinfo&quot; function provides the user with metrics that may be useful for filtering or sorting query results according to relevance.</source>
          <target state="translated">FTS3 および FTS4 モジュールは、フルテキストクエリシステムの開発者にとって有用な 3 つの特別な SQL スカラー関数を提供します。&quot;snippet&quot;、&quot;offsets&quot;、&quot;matchinfo &quot;です。snippet&quot; と &quot;offsets&quot; 関数の目的は、返されたドキュメントの中のクエリされた用語の位置をユーザが特定できるようにすることです。matchinfo &quot;関数は、関連性に応じてクエリ結果をフィルタリングしたり、ソートしたりするのに便利なメトリクスをユーザに提供します。</target>
        </trans-unit>
        <trans-unit id="cd165aec23f192a3f9f07347a0254f2d27b32b66" translate="yes" xml:space="preserve">
          <source>The FTS3 extension has undergone a major rework and cleanup. New &lt;a href=&quot;fts3&quot;&gt;FTS3 documentation&lt;/a&gt; is now available.</source>
          <target state="translated">FTS3拡張機能は、大幅な手直しとクリーンアップが行われました。新しい&lt;a href=&quot;fts3&quot;&gt;FTS3ドキュメント&lt;/a&gt;が利用可能になりました。</target>
        </trans-unit>
        <trans-unit id="9cae97c9c8daf8017ea793bf4be64df945be883c" translate="yes" xml:space="preserve">
          <source>The FTS3/4 &quot;automerge=X&quot; command has been replaced by the &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 automerge option&lt;/a&gt;.</source>
          <target state="translated">FTS3 / 4 &quot;automerge = X&quot;コマンドは、&lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5自動マージオプションに&lt;/a&gt;置き換えられました。</target>
        </trans-unit>
        <trans-unit id="e8ba1806c7cd7bdfbbc2b404c832b1beab23a209" translate="yes" xml:space="preserve">
          <source>The FTS3/4 &quot;merge=X,Y&quot; command has been replaced by the &lt;a href=&quot;fts5#the_merge_command&quot;&gt;FTS5 merge command&lt;/a&gt;.</source>
          <target state="translated">FTS3 / 4の「merge = X、Y」コマンドは、&lt;a href=&quot;fts5#the_merge_command&quot;&gt;FTS5マージコマンドに&lt;/a&gt;置き換えられました。</target>
        </trans-unit>
        <trans-unit id="b2c4e64578a5475fd4fbd32b9347a70fbc56baad" translate="yes" xml:space="preserve">
          <source>The FTS4 prefix option causes FTS to index term prefixes of specified lengths in the same way that it always indexes complete terms. The prefix option must be set to a comma separated list of positive non-zero integers. For each value N in the list, prefixes of length N bytes (when encoded using UTF-8) are indexed. FTS4 uses term prefix indexes to speed up &lt;a href=&quot;fts3#termprefix&quot;&gt;prefix queries&lt;/a&gt;. The cost, of course, is that indexing term prefixes as well as complete terms increases the database size and slows down write operations on the FTS4 table.</source>
          <target state="translated">FTS4接頭辞オプションを使用すると、FTSは常に完全な用語にインデックスを付けるのと同じ方法で、指定された長さの用語プレフィックスにインデックスを付けます。 prefixオプションは、ゼロ以外の正の整数のコンマ区切りリストに設定する必要があります。リストの各値Nについて、長さNバイトのプレフィックス（UTF-8を使用してエンコードされた場合）にインデックスが付けられます。 FTS4は、プレフィックスインデックスを使用して、&lt;a href=&quot;fts3#termprefix&quot;&gt;プレフィックスクエリ&lt;/a&gt;を高速化します。もちろん、コストは、用語のプレフィックスと完全な用語のインデックス付けにより、データベースサイズが増加し、FTS4テーブルへの書き込み操作が遅くなることです。</target>
        </trans-unit>
        <trans-unit id="f3623dd8b5a2a6147fa4bef6afa8dea8c88c6337" translate="yes" xml:space="preserve">
          <source>The F_FULLSYNC ioctl (currently only supported on Mac OS X) is disabled if the synchronous pragma is set to something other than &quot;full&quot;.</source>
          <target state="translated">F_FULLSYNC ioctl (現在は Mac OS X でのみサポートされています)は、同期プラグマが &quot;full&quot; 以外のものに設定されている場合には無効になります。</target>
        </trans-unit>
        <trans-unit id="4a8e5028bc3ed89b6a1dc3d8dc7eba9bd090d027" translate="yes" xml:space="preserve">
          <source>The Fossil NGQP Upgrade Case Study</source>
          <target state="translated">フォッシルNGQPのアップグレード事例</target>
        </trans-unit>
        <trans-unit id="6dc92de118e5e87426474c7d89d8139659caa059" translate="yes" xml:space="preserve">
          <source>The Fossil performance problem described in the previous section of this document arose because there were over ten-thousand entries in the TAGXREF table with the same value for the left-most column (the TAGID column) of the TAGXREF_I1 index.</source>
          <target state="translated">このドキュメントの前のセクションで説明したFossilパフォーマンスの問題は、TAGXREF_I1インデックスの左端の列(TAGID列)に同じ値を持つTAGXREFテーブルのエントリが1万件以上あったために発生しました。</target>
        </trans-unit>
        <trans-unit id="d2cc3db361bc3155e6c06330a65fa4635f5425d3" translate="yes" xml:space="preserve">
          <source>The Fossil view clearly shows that the branch was eventually merged back into trunk. It shows where the branch started, and it shows two occasions where changes on trunk were merged into the branch. GitHub shows none of this. In fact, the GitHub display is mostly useless in trying to figure out what happened.</source>
          <target state="translated">Fossil ビューでは、ブランチが最終的にトランクにマージされたことがはっきりと示されています。ブランチがどこから始まったのか、そして trunk 上の変更がブランチにマージされたことが二度ほど示されています。しかし、GitHub にはこのようなことは何も表示されません。実際、GitHub の表示は、何が起こったのかを知る上でほとんど役に立たないのです。</target>
        </trans-unit>
        <trans-unit id="6b63744d939cc984f1b96440853e8df6692826ba" translate="yes" xml:space="preserve">
          <source>The Fts5PhraseIter structure is defined above. Applications should not modify this structure directly - it should only be used as shown above with the xPhraseFirst() and xPhraseNext() API methods (and by xPhraseFirstColumn() and xPhraseNextColumn() as illustrated below).</source>
          <target state="translated">Fts5PhraseIter 構造体は上記で定義されています。アプリケーションはこの構造体を直接変更してはいけません-上で示したように xPhraseFirst()および xPhraseNext()API メソッドを使用してのみ使用してください (以下に示すように xPhraseFirstColumn()および xPhraseNextColumn()によっても使用できます)。</target>
        </trans-unit>
        <trans-unit id="a5efd19f10743bd231ab41e35fd5ac44fc6fbe77" translate="yes" xml:space="preserve">
          <source>The GLOB operator is always case sensitive. The column on the left side of the GLOB operator must always use the built-in BINARY collating sequence or no attempt will be made to optimize that operator with indices.</source>
          <target state="translated">GLOB演算子は常に大文字と小文字を区別します。GLOB演算子の左側の列は、常に組み込みのBINARY照合シーケンスを使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="ebb21a9ebdf2dcd06a6d1e05cc13a1948a1a0378" translate="yes" xml:space="preserve">
          <source>The GLOB operator is similar to LIKE but uses the Unix file globbing syntax for its wildcards. Also, GLOB is case sensitive, unlike LIKE. Both GLOB and LIKE may be preceded by the NOT keyword to invert the sense of the test. The infix GLOB operator is implemented by calling the function &lt;a href=&quot;lang_corefunc#glob&quot;&gt;glob(&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;X&lt;/i&gt;)&lt;/a&gt; and can be modified by overriding that function.</source>
          <target state="translated">GLOB演算子はLIKEに似ていますが、ワイルドカードにUnixファイルグロビング構文を使用します。また、GLOBはLIKEとは異なり、大文字と小文字が区別されます。テストの意味を逆にするために、GLOBとLIKEの前にNOTキーワードを付けることができます。内接GLOB演算子は、関数&lt;a href=&quot;lang_corefunc#glob&quot;&gt;glob（&lt;i&gt;Y&lt;/i&gt;、&lt;i&gt;X&lt;/i&gt;）&lt;/a&gt;を呼び出すことで実装され、その関数をオーバーライドすることで変更できます。</target>
        </trans-unit>
        <trans-unit id="6bf488312da9736e109b0de15500f2677c1ccca1" translate="yes" xml:space="preserve">
          <source>The Geopoly Interface To The SQLite R*Tree Module</source>
          <target state="translated">SQLite R*Treeモジュールへのジオポリインターフェース</target>
        </trans-unit>
        <trans-unit id="768b26bb16f751e006af08115829d3719bded2a3" translate="yes" xml:space="preserve">
          <source>The Geopoly module is an alternative interface to the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; that uses the &lt;a href=&quot;http://geojson.org&quot;&gt;GeoJSON&lt;/a&gt; notation (&lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;RFC-7946&lt;/a&gt;) to describe two-dimensional polygons. Geopoly includes functions for detecting when one polygon is contained within or overlaps with another, for computing the area enclosed by a polygon, for doing linear transformations of polygons, for rendering polygons as &lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;SVG&lt;/a&gt;, and other similar operations.</source>
          <target state="translated">Geopolyモジュールは、&lt;a href=&quot;http://geojson.org&quot;&gt;GeoJSON&lt;/a&gt;表記（&lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;RFC-7946&lt;/a&gt;）を使用して2次元ポリゴンを記述する&lt;a href=&quot;rtree&quot;&gt;Rツリー拡張の&lt;/a&gt;代替インターフェースです。 Geopolyには、1つのポリゴンが別のポリゴンに含まれるか、または別のポリゴンと重複することを検出する関数、ポリゴンで囲まれた領域を計算する関数、ポリゴンの線形変換を実行する関数、ポリゴンを&lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;SVG&lt;/a&gt;としてレンダリングする関数、およびその他の同様の操作が含まれます。</target>
        </trans-unit>
        <trans-unit id="a237ed77d23b0a3e93b7e807216496727ce2d486" translate="yes" xml:space="preserve">
          <source>The Geopoly module only understands a small subset of GeoJSON, but a critical subset. In particular, GeoJSON understands the JSON array of vertexes that describes a simple polygon.</source>
          <target state="translated">GeopolyモジュールはGeoJSONの小さなサブセットしか理解していませんが、重要なサブセットです。特に、GeoJSONは単純な多角形を記述する頂点のJSON配列を理解します。</target>
        </trans-unit>
        <trans-unit id="be3160b95c10c837d23b555d2d76ced7f5c9c397" translate="yes" xml:space="preserve">
          <source>The ICU tokenizer implementation is very simple. It splits the input text according to the ICU rules for finding word boundaries and discards any tokens that consist entirely of white-space. This may be suitable for some applications in some locales, but not all. If more complex processing is required, for example to implement stemming or discard punctuation, this can be done by creating a tokenizer implementation that uses the ICU tokenizer as part of its implementation.</source>
          <target state="translated">ICU トークナイザーの実装は非常にシンプルです。それは、単語の境界を見つけるためのICUのルールに従って入力テキストを分割し、完全に空白で構成されているトークンはすべて破棄します。これは、いくつかのロケールでのアプリケーションには適しているかもしれませんが、すべてのアプリケーションに適しているわけではありません。より複雑な処理が必要な場合は、例えばステミングを実装したり、句読点を破棄したりするために、ICU のトークナイザーを実装の一部として使用するトークナイザーの実装を作成することで、これを行うことができます。</target>
        </trans-unit>
        <trans-unit id="a6ddce9bb57f20218d7a75f29be10f1ad340213b" translate="yes" xml:space="preserve">
          <source>The ICU tokenizer is not available.</source>
          <target state="translated">ICUのトークンライザーは利用できません。</target>
        </trans-unit>
        <trans-unit id="975a07114fdeda8b12153b2d0d474cd1f76f40a8" translate="yes" xml:space="preserve">
          <source>The IN and NOT IN operators</source>
          <target state="translated">INとNOT INの演算子</target>
        </trans-unit>
        <trans-unit id="ae86038950b2d471648c3c6d1b5cdb4844f71708" translate="yes" xml:space="preserve">
          <source>The IN and NOT IN operators take an expression on the left and a list of values or a subquery on the right. When the right operand of an IN or NOT IN operator is a subquery, the subquery must have the same number of columns as there are columns in the &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; of the left operand. The subquery on the right of an IN or NOT IN operator must be a scalar subquery if the left expression is not a &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; expression. If the right operand of an IN or NOT IN operator is a list of values, each of those values must be scalars and the left expression must also be a scalar. The right-hand side of an IN or NOT IN operator can be a table</source>
          <target state="translated">INおよびNOT IN演算子は、左側に式、右側に値のリストまたはサブクエリを受け取ります。INまたはNOT IN演算子の右側のオペランドがサブクエリである場合、サブクエリの列の数は、左側のオペランドの&lt;a href=&quot;rowvalue&quot;&gt;行の値&lt;/a&gt;の列と同じでなければなりません。INまたはNOT IN演算子の右側のサブクエリは、左側の式が&lt;a href=&quot;rowvalue&quot;&gt;行値&lt;/a&gt;式でない場合、スカラーサブクエリでなければなりません。INまたはNOT IN演算子の右側のオペランドが値のリストである場合、それらの値はそれぞれスカラーでなければならず、左側の式もスカラーでなければなりません。INまたはNOT IN演算子の右側はテーブルにすることができます</target>
        </trans-unit>
        <trans-unit id="a79accc7fc2bc30ac0fead525b227ad7d9b1df52" translate="yes" xml:space="preserve">
          <source>The IN operator is now a candidate for optimization even if the left-hand side is not the left-most term of the index. Multiple IN operators can be used with the same index.</source>
          <target state="translated">IN演算子は、左辺がインデックスの左端項でなくても最適化の候補になるようになりました。同じインデックスで複数のIN演算子を使用することができます。</target>
        </trans-unit>
        <trans-unit id="84955ffcf9bdb1365dbcf57de003852e491d0f74" translate="yes" xml:space="preserve">
          <source>The IN-early-out optimization: When doing a look-up on a multi-column index and an IN operator is used on a column other than the left-most column, then if no rows match against the first IN value, check to make sure there exist rows that match the columns to the right before continuing with the next IN value.</source>
          <target state="translated">IN-early-out最適化。複数列インデックスの検索を行い、左端の列以外の列にIN演算子を使用した場合、最初のIN値に一致する行がない場合、次のIN値に進む前に右端の列に一致する行が存在するかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="c69ea675978574ca724f9055d892093e6e8c8e6f" translate="yes" xml:space="preserve">
          <source>The INDEXED BY Clause</source>
          <target state="translated">INDEXED BY条項</target>
        </trans-unit>
        <trans-unit id="c7f2969be40943bb47a40ea44d17f6c5eac58206" translate="yes" xml:space="preserve">
          <source>The INDEXED BY and NOT INDEXED clauses are not allowed on DELETE statements within triggers.</source>
          <target state="translated">トリガー内のDELETE文では、INDEXED BY句とNOT INDEXED句は使用できません。</target>
        </trans-unit>
        <trans-unit id="f74b8a2cb9b68ac44cbe1110518350bde980f1d2" translate="yes" xml:space="preserve">
          <source>The INDEXED BY and NOT INDEXED clauses are not allowed on UPDATE statements within triggers.</source>
          <target state="translated">トリガー内のUPDATE文では、INDEXED BY句とNOT INDEXED句は使用できません。</target>
        </trans-unit>
        <trans-unit id="b6f68ce27c8cff5cc2a071306e82e684ac57bb2a" translate="yes" xml:space="preserve">
          <source>The INDEXED BY and NOT INDEXED clauses are not supported for &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements.</source>
          <target state="translated">INDEXED BYおよびNOT INDEXED句は、&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;および&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;ステートメントではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="c219f61fe4cd1e708d4fe79c89efa6776605815d" translate="yes" xml:space="preserve">
          <source>The INDEXED BY clause is &lt;em&gt;not&lt;/em&gt; intended for use in tuning the performance of a query. The intent of the INDEXED BY clause is to raise a run-time error if a schema change, such as dropping or creating an index, causes the query plan for a time-sensitive query to change. The INDEXED BY clause is designed to help detect undesirable query plan changes during regression testing. Application developers are admonished to omit all use of INDEXED BY during application design, implementation, testing, and tuning. If INDEXED BY is to be used at all, it should be inserted at the very end of the development process when &quot;locking down&quot; a design.</source>
          <target state="translated">INDEXED BY句は、クエリのパフォーマンスの調整に使用するためのものではあり&lt;em&gt;ません&lt;/em&gt;。 INDEXED BY句の目的は、インデックスの削除や作成などのスキーマ変更により、時間に依存するクエリのクエリプランが変更された場合に、実行時エラーを発生させることです。 INDEXED BY句は、回帰テスト中に望ましくないクエリプランの変更を検出できるように設計されています。アプリケーション開発者は、アプリケーションの設計、実装、テスト、およびチューニングの際にINDEXED BYをすべて使用しないようにしてください。 INDEXED BYを使用する場合は、デザインを「ロックダウン」するときに、開発プロセスの最後に挿入する必要があります。</target>
        </trans-unit>
        <trans-unit id="2f4cc404750644d945353fc113cb9dba262e1c3b" translate="yes" xml:space="preserve">
          <source>The INDEXED BY phrase forces the &lt;a href=&quot;optoverview&quot;&gt;SQLite query planner&lt;/a&gt; to use a particular named index on a &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, or &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement. The INDEXED BY phrase is an SQLite extension and is not portable to other SQL database engines.</source>
          <target state="translated">INDEXED BY句は、&lt;a href=&quot;optoverview&quot;&gt;SQLiteクエリプランナー&lt;/a&gt;が&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;、&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;、または&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;ステートメントで特定の名前付きインデックスを使用するように強制します。INDEXED BY句はSQLiteの拡張機能であり、他のSQLデータベースエンジンには移植できません。</target>
        </trans-unit>
        <trans-unit id="272773ebe8d5f9cc82e317b171f77d7379a1e581" translate="yes" xml:space="preserve">
          <source>The INSERT change remains in the changegroup. The values in the INSERT change are modified as if the row was inserted by the existing change and then updated according to the new change.</source>
          <target state="translated">INSERT 変更は changegroup に残っています。INSERT変更の値は、既存の変更によって行が挿入されたかのように変更され、新しい変更に従って更新されます。</target>
        </trans-unit>
        <trans-unit id="110ff0538d0b835d343c6aa7fc9be56d02650901" translate="yes" xml:space="preserve">
          <source>The INSERT statement above adds a new row to the sqlite_master table that defines a table &quot;t2&quot; having the same on-disk format as index &quot;t1bc&quot; and pointing to the same b-tree. After adding this sqlite_master table entry, it is necessary to close and reopen the database in order to get SQLite to reread the schema. Then the &quot;t2&quot; table can be queried to see the content of the &quot;t1bc&quot; index.</source>
          <target state="translated">上のINSERT文は、インデックス &quot;t1bc &quot;と同じディスク上のフォーマットを持ち、同じb-treeを指すテーブル &quot;t2 &quot;を定義するsqlite_masterテーブルに新しい行を追加しています。このsqlite_masterテーブルエントリを追加した後、SQLiteにスキーマを再読ませるために、データベースを閉じて再オープンする必要があります。その後、&quot;t2 &quot;テーブルをクエリして、&quot;t1bc &quot;インデックスの内容を確認することができます。</target>
        </trans-unit>
        <trans-unit id="cfe3ae8d2c81f2e60d52f407b340e91b2e1ca71c" translate="yes" xml:space="preserve">
          <source>The INSERT statement above adds a new row to the sqlite_schema table that defines a table &quot;t2&quot; having the same on-disk format as index &quot;t1bc&quot; and pointing to the same b-tree. After adding this sqlite_schema table entry, it is necessary to close and reopen the database in order to get SQLite to reread the schema. Then the &quot;t2&quot; table can be queried to see the content of the &quot;t1bc&quot; index.</source>
          <target state="translated">上のINSERT文は、インデックス &quot;t1bc &quot;と同じディスク上のフォーマットを持ち、同じb-treeを指すテーブル &quot;t2 &quot;を定義するsqlite_schemaテーブルに新しい行を追加しています。このsqlite_schemaテーブルエントリを追加した後、SQLiteにスキーマを再読ませるために、データベースを閉じて再オープンする必要があります。その後、&quot;t2 &quot;テーブルをクエリして、&quot;t1bc &quot;インデックスの内容を見ることができます。</target>
        </trans-unit>
        <trans-unit id="08d21ad99ed5f4abc02a63a43ee6d040107fe785" translate="yes" xml:space="preserve">
          <source>The INSERT statement comes in three basic forms.</source>
          <target state="translated">INSERT文には3つの基本的な形があります。</target>
        </trans-unit>
        <trans-unit id="47c4a334a3fe174333881ca555ae014ebc13040d" translate="yes" xml:space="preserve">
          <source>The INTERSECT operator for compound queries is implemented by creating two separate transient indices, each in a separate temporary file. The left and right subqueries are evaluated each into a separate transient index. Then the two indices are walked together and entries that appear in both indices are output.</source>
          <target state="translated">複合クエリの INTERSECT 演算子は、別々のテンポラリファイルに 2 つの別々のトランジェントインデックスを作成することで実装されます。左と右のサブクエリは、それぞれ別個のトランジェントインデックスに評価されます。その後、2つのインデックスが一緒にウォークされ、両方のインデックスに現れるエントリが出力されます。</target>
        </trans-unit>
        <trans-unit id="24b1f06632bef12995013965847655934cbf7975" translate="yes" xml:space="preserve">
          <source>The Idx1 index is scanned from top to bottom (or from bottom to top if &quot;ORDER BY fruit DESC&quot; is used) in order to find the rowids for each item in order by fruit. Then for each rowid, a binary search is done to lookup and output that row. In this way, the output appears in the requested order without the need to gather the entire output and sort it using a separate step.</source>
          <target state="translated">Idx1 インデックスを上から下(「ORDER BY fruit DESC」を使用している場合は下から上)にスキャンして、各項目の行 ID を果実順に探す。そして、各行 ID に対してバイナリ検索を行い、その行を探し出して出力します。この方法では、出力全体を集めて別のステップでソートする必要がなく、出力は要求された順番で表示されます。</target>
        </trans-unit>
        <trans-unit id="2840ff0c49d75f050e9ec79f4cca0962bc4cd995" translate="yes" xml:space="preserve">
          <source>The JSON1 Extension</source>
          <target state="translated">JSON1 拡張機能</target>
        </trans-unit>
        <trans-unit id="9880ae6264f9c31927d61592bb6cec20147ead44" translate="yes" xml:space="preserve">
          <source>The LIKE operator can be made case sensitive using the &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like pragma&lt;/a&gt;.</source>
          <target state="translated">LIKE演算子は、&lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_likeプラグマ&lt;/a&gt;を使用して大文字と小文字を区別することができます。</target>
        </trans-unit>
        <trans-unit id="d553aca858e8d5460148027e2f586810cb9b2c44" translate="yes" xml:space="preserve">
          <source>The LIKE operator does a pattern matching comparison. The operand to the right of the LIKE operator contains the pattern and the left hand operand contains the string to match against the pattern. A percent symbol (&quot;%&quot;) in the LIKE pattern matches any sequence of zero or more characters in the string. An underscore (&quot;_&quot;) in the LIKE pattern matches any single character in the string. Any other character matches itself or its lower/upper case equivalent (i.e. case-insensitive matching). &lt;u&gt;Important Note:&lt;/u&gt; SQLite only understands upper/lower case for ASCII characters by default. The LIKE operator is case sensitive by default for unicode characters that are beyond the ASCII range. For example, the expression &lt;b&gt;'a' LIKE 'A'&lt;/b&gt; is TRUE but &lt;b&gt;'&amp;aelig;' LIKE '&amp;AElig;'&lt;/b&gt; is FALSE. The ICU extension to SQLite includes an enhanced version of the LIKE operator that does case folding across all unicode characters.</source>
          <target state="translated">LIKE演算子は、パターンマッチング比較を行います。 LIKE演算子の右側のオペランドにはパターンが含まれ、左側のオペランドにはパターンと照合する文字列が含まれます。 LIKEパターンのパーセント記号（ &quot;％&quot;）は、文字列内の0個以上の文字のシーケンスと一致します。 LIKEパターンのアンダースコア（ &quot;_&quot;）は、文字列の任意の1文字と一致します。その他の文字は、それ自体またはそれに対応する小文字/大文字に一致します（つまり、大文字と小文字を区別しない一致）。&lt;u&gt;重要な注意：&lt;/u&gt; SQLiteは、デフォルトではASCII文字の大文字と小文字のみを認識します。 LIKE演算子は、ASCIIの範囲を超えるUnicode文字の場合、デフォルトで大文字と小文字が区別されます。たとえば、式&lt;b&gt;'a' LIKE 'A'&lt;/b&gt;はTRUEですが、&lt;b&gt;'&amp;aelig;' LIKE '&amp;AElig; '&lt;/b&gt;はFALSEです。SQLiteのICU拡張機能には、すべてのUnicode文字で大文字と小文字を区別しないLIKE演算子の拡張バージョンが含まれています。</target>
        </trans-unit>
        <trans-unit id="1dc39afda5c7dfd4c06c9ca219ccdec668d80d92" translate="yes" xml:space="preserve">
          <source>The LIKE operator has two modes that can be set by a &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;pragma&lt;/a&gt;. The default mode is for LIKE comparisons to be insensitive to differences of case for latin1 characters. Thus, by default, the following expression is true:</source>
          <target state="translated">LIKE演算子には、&lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;プラグマ&lt;/a&gt;で設定できる2つのモードがあります。デフォルトのモードでは、LIKE比較で、latin1文字の大文字と小文字の違いが区別されません。したがって、デフォルトでは、次の式は真です。</target>
        </trans-unit>
        <trans-unit id="1212c823074bac84702844422e3c272b2bd97163" translate="yes" xml:space="preserve">
          <source>The LIKE operator is case insensitive by default because this is what the SQL standard requires. You can change the default behavior at compile time by using the &lt;a href=&quot;compile#case_sensitive_like&quot;&gt;SQLITE_CASE_SENSITIVE_LIKE&lt;/a&gt; command-line option to the compiler.</source>
          <target state="translated">LIKE演算子は、SQL標準で必要なため、デフォルトでは大文字と小文字を区別しません。コンパイラに対して&lt;a href=&quot;compile#case_sensitive_like&quot;&gt;SQLITE_CASE_SENSITIVE_LIKE&lt;/a&gt;コマンドラインオプションを使用すると、コンパイル時にデフォルトの動作を変更できます。</target>
        </trans-unit>
        <trans-unit id="974b1e3eeffaa9ed2ed23dfb8ae4c0123aeb3aed" translate="yes" xml:space="preserve">
          <source>The LIKE optimization might occur if the column named on the left of the operator is indexed using the built-in BINARY collating sequence and case_sensitive_like is turned on. Or the optimization might occur if the column is indexed using the built-in NOCASE collating sequence and the case_sensitive_like mode is off. These are the only two combinations under which LIKE operators will be optimized.</source>
          <target state="translated">演算子の左側に指定された列が、組み込みの BINARY 照合シーケンスを使用してインデックス化され、かつ case_sensitive_like がオンになっている場合、LIKE の最適化が発生する可能性があります。あるいは、組み込みの NOCASE 照合シーケンスを使用してインデックスを作成し、case_sensitive_like モードがオフになっている場合に最適化が行われるかもしれません。これらは、LIKE演算子が最適化される唯一の組み合わせです。</target>
        </trans-unit>
        <trans-unit id="93b8dceb670473d258369826a0e1bcdc46904ecc" translate="yes" xml:space="preserve">
          <source>The LIKE optimization was generating incorrect byte-code and hence getting the wrong answer if the left-hand operand has numeric affinity and the right-hand-side pattern is '/%' or if the pattern begins with the ESCAPE character. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/c94369cae9b561b1f996d0054b&quot;&gt;c94369cae9b561b1f996d0054b&lt;/a&gt;</source>
          <target state="translated">LIKE最適化が不正なバイトコードを生成していたため、左側のオペランドに数値の類似性があり、右側のパターンが「/％」の場合、またはパターンがESCAPE文字で始まっている場合は、誤った回答が返されていました。チケットの修正&lt;a href=&quot;https://www.sqlite.org/src/info/c94369cae9b561b1f996d0054b&quot;&gt;c94369cae9b561b1f996d0054b&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="50c934a9b19a46fe0d3c49a41fee7d1fdd7083c0" translate="yes" xml:space="preserve">
          <source>The LIKE optimization will only be attempted if the right-hand side of the GLOB or LIKE operator is either literal string or a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that has been &lt;a href=&quot;c3ref/bind_blob&quot;&gt;bound&lt;/a&gt; to a string literal. The string literal must not begin with a wildcard; if the right-hand side begins with a wildcard character then this optimization is attempted. If the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that is bound to a string, then this optimization is only attempted if the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; containing the expression was compiled with &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;. The LIKE optimization is not attempted if the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement was prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;.</source>
          <target state="translated">LIKE最適化は、GLOBまたはLIKE演算子の右側がリテラル文字列または文字列リテラルに&lt;a href=&quot;c3ref/bind_blob&quot;&gt;バインドさ&lt;/a&gt;れている&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーターで&lt;/a&gt;ある場合にのみ試行されます。文字列リテラルはワイルドカードで始めることはできません。右側がワイルドカード文字で始まる場合、この最適化が試行されます。右側が文字列にバインドされている&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーター&lt;/a&gt;である場合、この最適化は、式を含む&lt;a href=&quot;c3ref/stmt&quot;&gt;準備されたステートメント&lt;/a&gt;が&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;または&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2（）で&lt;/a&gt;コンパイルされた場合にのみ試行されます。右側が&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーターで&lt;/a&gt;あり、ステートメントが以下を使用して準備された場合、LIKE最適化は試行されません。&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;または&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="75a37b85ec9af203958779031808e1e864da0987" translate="yes" xml:space="preserve">
          <source>The LIKE optimization will only be attempted if the right-hand side of the GLOB or LIKE operator is either literal string or a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that has been &lt;a href=&quot;c3ref/bind_blob&quot;&gt;bound&lt;/a&gt; to a string literal. The string literal must not begin with a wildcard; if the right-hand side begins with a wildcard character then this optimization is not attempted. If the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that is bound to a string, then this optimization is only attempted if the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; containing the expression was compiled with &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;. The LIKE optimization is not attempted if the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement was prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;.</source>
          <target state="translated">LIKE最適化は、GLOBまたはLIKE演算子の右側がリテラル文字列、または文字列リテラルに&lt;a href=&quot;c3ref/bind_blob&quot;&gt;バインドさ&lt;/a&gt;れている&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメータの&lt;/a&gt;場合にのみ試行されます。文字列リテラルはワイルドカードで始めてはなりません。右側がワイルドカード文字で始まる場合、この最適化は試行されません。右側が文字列にバインドされた&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメータ&lt;/a&gt;である場合、この最適化は、式を含む&lt;a href=&quot;c3ref/stmt&quot;&gt;準備されたステートメント&lt;/a&gt;が&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;または&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2（）で&lt;/a&gt;コンパイルされた場合にのみ試行されます。右側が&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーターで&lt;/a&gt;あり、ステートメントが以下を使用して作成された場合、LIKE最適化は試行されません。&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;または&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bfdfb505c18eab193b8701d8963abc89096358bd" translate="yes" xml:space="preserve">
          <source>The LIKE, GLOB, REGEXP, and MATCH operators</source>
          <target state="translated">LIKE、GLOB、REGEXP、MATCH演算子</target>
        </trans-unit>
        <trans-unit id="bd6f903f94d0893c11340df485d7ab2df47a60ff" translate="yes" xml:space="preserve">
          <source>The LIMIT and ORDER BY clauses (described below) are unsupported for DELETE statements within triggers.</source>
          <target state="translated">LIMIT句およびORDER BY句(後述)は、トリガ内のDELETE文ではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="ac40736f7c111bc231ce85d71233af9ca860229d" translate="yes" xml:space="preserve">
          <source>The LIMIT and ORDER BY clauses for UPDATE are unsupported within triggers, regardless of the compilation options used to build SQLite.</source>
          <target state="translated">UPDATE の LIMIT 句と ORDER BY 句は、SQLite のビルドに使用されたコンパイルオプションに関わらず、トリガー内ではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="8e074183b71823eb43ac076c4294086172e78dd9" translate="yes" xml:space="preserve">
          <source>The LIMIT clause</source>
          <target state="translated">リミット条項</target>
        </trans-unit>
        <trans-unit id="0504a702a97dc6330d2a4e4c66843d71b8b8976c" translate="yes" xml:space="preserve">
          <source>The LIMIT clause is used to place an upper bound on the number of rows returned by the entire SELECT statement.</source>
          <target state="translated">LIMIT句は、SELECT文全体で返される行数の上限を設定するために使用します。</target>
        </trans-unit>
        <trans-unit id="077d300ed4cc15ee3f95aa8d7373e80b1b912e57" translate="yes" xml:space="preserve">
          <source>The LIMIT clause now works on subselects</source>
          <target state="translated">LIMIT 句がサブセレクトで動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="243d546893ed2d7dba744bb55553e651413994ea" translate="yes" xml:space="preserve">
          <source>The LIMIT clause, if present, determines the maximum number of rows that will ever be added to the recursive table in step 2b. Once the limit is reached, the recursion stops. A limit of zero means that no rows are ever added to the recursive table, and a negative limit means an unlimited number of rows may be added to the recursive table.</source>
          <target state="translated">LIMIT句が存在する場合、ステップ2bで再帰テーブルに追加される行の最大数を決定します。制限に達すると、再帰は停止します。制限値がゼロの場合、再帰テーブルに行が追加されないことを意味し、負の制限値は、再帰テーブルに無制限に行が追加されることを意味します。</target>
        </trans-unit>
        <trans-unit id="9ff51df664023512f948df1ac796d229e7d0e9d2" translate="yes" xml:space="preserve">
          <source>The LOCKING_STYLE extension is now enabled by default on Mac OS X</source>
          <target state="translated">Mac OS X で LOCKING_STYLE 拡張機能がデフォルトで有効になりました。</target>
        </trans-unit>
        <trans-unit id="0d323fe988c47fdc7cf51035f151e1d7348afa80" translate="yes" xml:space="preserve">
          <source>The Lemon LALR(1) Parser Generator</source>
          <target state="translated">レモン LALR(1)パーサジェネレータ</target>
        </trans-unit>
        <trans-unit id="cac145bc2534e8394ef262506cd070ba23b13005" translate="yes" xml:space="preserve">
          <source>The Lemon source code was originally written as separate source files, and only later merged into a single &quot;lemon.c&quot; source file.</source>
          <target state="translated">Lemonのソースコードは元々別々のソースファイルとして書かれていましたが、後になって一つの &quot;lemon.c &quot;ソースファイルにマージされました。</target>
        </trans-unit>
        <trans-unit id="f3666de7d407bd838db280e08d40dcf3369cd962" translate="yes" xml:space="preserve">
          <source>The MATCH operator is a special syntax for the match() application-defined function. The default match() function implementation raises an exception and is not really useful for anything. But extensions can override the match() function with more helpful logic.</source>
          <target state="translated">MATCH 演算子は、アプリケーション定義関数 match()のための特別な構文です。デフォルトの match()関数の実装は例外を発生させ、実際には何の役にも立ちません。しかし、拡張モジュールは、より有用なロジックで match()関数をオーバーライドすることができます。</target>
        </trans-unit>
        <trans-unit id="42afa4f5f59a4dbd2c306334064e90d9b1a32220" translate="yes" xml:space="preserve">
          <source>The MATCH operator of a custom R*Tree query function must be a top-level AND-connected term of the WHERE clause, or else it will not be usable by the R*Tree query optimizer and the query will not be runnable. If the MATCH operator is connected to other terms of the WHERE clause via an OR operator, for example, the query will fail with an error.</source>
          <target state="translated">カスタムR*Treeクエリ関数のMATCH演算子は、WHERE句のトップレベルのANDに接続された項でなければなりません。例えば、MATCH演算子がOR演算子を介してWHERE句の他の項に接続されている場合、クエリはエラーで失敗します。</target>
        </trans-unit>
        <trans-unit id="a59083e3614cc05a48a3bbb667742c5ff714f7ae" translate="yes" xml:space="preserve">
          <source>The MEMORY journaling mode stores the rollback journal in volatile RAM. This saves disk I/O but at the expense of database safety and integrity. If the application using SQLite crashes in the middle of a transaction when the MEMORY journaling mode is set, then the database file will very likely &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;go corrupt&lt;/a&gt;.</source>
          <target state="translated">MEMORYジャーナリングモードでは、ロールバックジャーナルが揮発性RAMに保存されます。これにより、ディスクI / Oが節約されますが、データベースの安全性と整合性が犠牲になります。MEMORYジャーナリングモードが設定されている場合、SQLiteを使用するアプリケーションがトランザクションの途中でクラッシュすると、データベースファイルが&lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;破損する&lt;/a&gt;可能性が高くなります。</target>
        </trans-unit>
        <trans-unit id="f83732bb3e32c92cf54961a7828a9a9bf48899eb" translate="yes" xml:space="preserve">
          <source>The MySQL UPDATE statement does not have just one target table like other systems. Any of the tables that participate in the join can be modified in the SET clause. The MySQL UPDATE syntax allows you to update multiple tables at once!</source>
          <target state="translated">MySQL UPDATE文は、他のシステムのようにターゲットテーブルを1つだけ持つわけではありません。結合に参加しているテーブルのいずれかをSET句で変更することができます。MySQL UPDATE構文を使用すると、複数のテーブルを一度に更新することができます!</target>
        </trans-unit>
        <trans-unit id="02f3e583df88fe87cd750b4e8f9145cc25dd009e" translate="yes" xml:space="preserve">
          <source>The Mythical Man-Month</source>
          <target state="translated">神話の人月</target>
        </trans-unit>
        <trans-unit id="47382a1ade54ee985c5d1e4d884a10d978c3d9d5" translate="yes" xml:space="preserve">
          <source>The NGQP has no way of knowing that TAGXREF_I1 is almost useless in this query, unless &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been run on the database. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command gathers statistics on the quality of the various indexes and stores those statistics in &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1&lt;/a&gt; table. Having access to this statistical information, the NGQP easily chooses algorithm-1 as the best algorithm, by a wide margin.</source>
          <target state="translated">NGQPは、&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;がデータベースで実行されていない限り、TAGXREF_I1がこのクエリでほとんど役に立たないことを知る方法がありません。&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;のもの統計様々な指標や店舗の品質上のコマンド集まる統計を&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1の&lt;/a&gt;テーブル。この統計情報にアクセスできるNGQPは、アルゴリズム1を最適なアルゴリズムとして簡単に選択できます。</target>
        </trans-unit>
        <trans-unit id="143a4238d4916cb63313c4577ca26b997b836c83" translate="yes" xml:space="preserve">
          <source>The NGQP is almost always better than the legacy query planner. However, there may exist legacy applications that unknowingly depend on undefined and/or suboptimal behavior in the legacy query planner, and upgrading to the NGQP on those legacy applications could cause performance regressions. This risk is considered and a checklist is provided for reducing the risk and for fixing any issues that do arise.</source>
          <target state="translated">NGQPは、ほとんどの場合、レガシークエリプランナよりも優れています。しかし、レガシーアプリケーションの中には、知らず知らずのうちにレガシークエリプランナーの未定義の動作や最適化されていない動作に依存しているものが存在し、それらのレガシーアプリケーションをNGQPにアップグレードすると、パフォーマンスが低下する可能性があります。このリスクを考慮し、リスクを軽減し、発生した問題を修正するためのチェックリストを提供します。</target>
        </trans-unit>
        <trans-unit id="2965ed7439648bc6c724543a8009a196c9039cf3" translate="yes" xml:space="preserve">
          <source>The NGQP uses a new heuristic for seeking the best path through the graph: &quot;N Nearest Neighbors&quot; (hereafter &quot;N3&quot;). With N3, instead of choosing just one nearest neighbor for each step, the algorithm keeps track of the N bests paths at each step for some small integer N.</source>
          <target state="translated">NGQPは、グラフを通る最良のパスを求めるために新しいヒューリスティックを使用しています。&quot;それは、「N ニアレストネイバー」(以下、「N3」)です。N3では、各ステップで1つの最近傍を選択するのではなく、アルゴリズムは、いくつかの小さな整数Nについて、各ステップでのN個のベスト・パスを追跡し続けます。</target>
        </trans-unit>
        <trans-unit id="0cc9ac5c6c19fb4a0c339daee645a66512bd3730" translate="yes" xml:space="preserve">
          <source>The NGQP will always find a good query plan as long as the schema does not contain indexes that have more than about 10 or 20 rows with the same value in the left-most column of the index.</source>
          <target state="translated">NGQPは、スキーマがインデックスの左端の列に同じ値を持つ約10行または20行以上のインデックスを含まない限り、常に良いクエリプランを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="64782e52a0662885b1e4e8b616fd2a06e03a36a9" translate="yes" xml:space="preserve">
          <source>The NGQP will always find an equal or better query plan, compared to prior query planners, as long as it has access to accurate &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; data in the &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1&lt;/a&gt; file.</source>
          <target state="translated">NGQPは、&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1&lt;/a&gt;ファイルの正確な&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;データにアクセスできる限り、以前のクエリプランナーと比較して、常に同等かそれ以上のクエリプランを見つけます。</target>
        </trans-unit>
        <trans-unit id="19150b2c84a3f9ff0a3cf33ed2fd4c984408dbd2" translate="yes" xml:space="preserve">
          <source>The NOCASE collation is like BINARY except that uppercase ASCII characters ('A' through 'Z') are folded into their lowercase equivalents prior to running the comparison. Only ASCII characters are case-folded. NOCASE does not implement a general purpose unicode caseless comparison.</source>
          <target state="translated">NOCASE照合は、大文字のASCII文字('A'から'Z'まで)が比較を実行する前に小文字の同等の文字に折りたたまれることを除いて、BINARYと同様です。大文字で折りたたまれるのはASCII文字のみです。NOCASEは、汎用的なユニコードのケースレス比較を実装していません。</target>
        </trans-unit>
        <trans-unit id="e84b5eaf17b803151297f975dc355cb961ea61cd" translate="yes" xml:space="preserve">
          <source>The NOT operator (or, if using the standard syntax, a unary &quot;-&quot; operator) may be used to compute the &lt;b&gt;relative complement&lt;/b&gt; of one set of documents with respect to another.</source>
          <target state="translated">NOT演算子（または、標準構文を使用する場合は、単項「-」演算子）を使用して、ドキュメントのセットの別のセット&lt;b&gt;に対する相対的な補集合&lt;/b&gt;を計算できます。</target>
        </trans-unit>
        <trans-unit id="0622850d3c0896e3d4a2cdc1368b8e7708693108" translate="yes" xml:space="preserve">
          <source>The NOT operator is not supported. Instead of the NOT operator, the standard query syntax supports a unary &quot;-&quot; operator that may be applied to basic term and term-prefix queries (but not to phrase or NEAR queries). A term or term-prefix that has a unary &quot;-&quot; operator attached to it may not appear as an operand to an OR operator. An FTS query may not consist entirely of terms or term-prefix queries with unary &quot;-&quot; operators attached to them.</source>
          <target state="translated">NOT演算子はサポートされていません。NOT演算子の代わりに、標準クエリ構文では、基本的な用語および用語プレフィックスクエリに適用できる単項演算子(-)がサポートされています (ただし、フレーズクエリやNEARクエリには適用されません)。単項演算子である「-」演算子が付加されている用語や用語プレフィックスは、OR演算子のオペランドとしては使用できません。FTSクエリは、単項演算子である&quot;-&quot;演算子を持つタームまたはタームプレフィックスクエリだけでは構成されない場合があります。</target>
        </trans-unit>
        <trans-unit id="92f10f8b9e2a034cee1135ad17b2a216a2126edd" translate="yes" xml:space="preserve">
          <source>The NULLS FIRST and NULLS LAST predicates are not supported for indexes. For &lt;a href=&quot;datatype3#sortorder&quot;&gt;sorting purposes&lt;/a&gt;, SQLite considers NULL values to be smaller than all other values. Hence NULL values always appear at the beginning of an ASC index and at the end of a DESC index.</source>
          <target state="translated">NULLSFIRSTおよびNULLSLAST述部は、索引ではサポートされていません。以下のために&lt;a href=&quot;datatype3#sortorder&quot;&gt;目的を仕分け&lt;/a&gt;、SQLiteは他のすべての値よりも小さくなるようにNULL値を考慮します。したがって、NULL値は常にASCインデックスの先頭とDESCインデックスの末尾に表示されます。</target>
        </trans-unit>
        <trans-unit id="7a314ee0d4a8c6c880fc2de97d4d977bd035a9e6" translate="yes" xml:space="preserve">
          <source>The NULLS FIRST and NULLS LAST predicates are not supported for indexes. For &lt;a href=&quot;datatype3#sortorder&quot;&gt;sorting purposes&lt;/a&gt;, SQLite considers NULL values to be smaller than all other values. Hences NULL values always appear at the beginning of an ASC index and at the end of a DESC index.</source>
          <target state="translated">NULLS FIRSTおよびNULLS LAST述部は、索引ではサポートされていません。以下のために&lt;a href=&quot;datatype3#sortorder&quot;&gt;目的を仕分け&lt;/a&gt;、SQLiteは他のすべての値よりも小さくなるようにNULL値を考慮します。したがって、NULL値は常にASCインデックスの先頭とDESCインデックスの末尾に表示されます。</target>
        </trans-unit>
        <trans-unit id="df615076dd2b352c1767b46fb626e9bea1df01d8" translate="yes" xml:space="preserve">
          <source>The Next instruction increments the cursor to point to the next element in the table pointed to by cursor P0, and if it was successful branches to P2 (6, the beginning of the loop body). The Close instruction closes cursor P1. It doesn't affect the temporary storage list because it isn't associated with cursor P1; it is instead a global working list (which can be saved with ListPush).</source>
          <target state="translated">Next命令は、カーソルP0が指し示すテーブルの次の要素を指すようにカーソルをインクリメントし、成功した場合はP2(ループ本体の先頭6)に分岐します。Close命令はカーソルP1を閉じます。カーソルP1に関連付けられていないので、一時的な保存リストには影響しません;代わりにグローバルな作業リスト(ListPushで保存可能)です。</target>
        </trans-unit>
        <trans-unit id="ead51814a41f1aee68f72130d432c2d7adca2550" translate="yes" xml:space="preserve">
          <source>The Next-Generation Query Planner</source>
          <target state="translated">次世代クエリプランナー</target>
        </trans-unit>
        <trans-unit id="72bb3fb56f491dbfd70c567055e36bba4fdf8c24" translate="yes" xml:space="preserve">
          <source>The ODP ZIP archive contains four different XML files: content.xml, styles.xml, meta.xml, and settings.xml. Those four files define the slide layout, text content, and styling. This particular presentation contains 62 images, ranging from full-screen pictures to tiny icons, each stored as a separate file in the Pictures folder. The &quot;mimetype&quot; file contains a single line of text that says:</source>
          <target state="translated">ODP ZIPアーカイブには、content.xml、styles.xml、meta.xml、およびsettings.xmlという4つのXMLファイルが含まれています。これら4つのファイルは、スライド レイアウト、テキスト コンテンツ、およびスタイリングを定義します。このプレゼンテーションには、フルスクリーン画像から小さなアイコンまで、62枚の画像が含まれており、それぞれが[Pictures]フォルダ内の個別ファイルとして保存されています。mimetype」ファイルには、次のような1行のテキストが含まれています。</target>
        </trans-unit>
        <trans-unit id="bd2fb71eee9ad290a0e9bebe4f7b07ef57d97050" translate="yes" xml:space="preserve">
          <source>The OFF journaling mode disables the rollback journal completely. No rollback journal is ever created and hence there is never a rollback journal to delete. The OFF journaling mode disables the atomic commit and rollback capabilities of SQLite. The &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command no longer works; it behaves in an undefined way. Applications must avoid using the &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command when the journal mode is OFF. If the application crashes in the middle of a transaction when the OFF journaling mode is set, then the database file will very likely &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;go corrupt&lt;/a&gt;. Without a journal, there is no way for a statement to unwind partially completed operations following a constraint error. This might also leave the database in a corrupted state. For example, if a duplicate entry causes a &lt;a href=&quot;lang_createindex&quot;&gt;CREATE UNIQUE INDEX&lt;/a&gt; statement to fail half-way through, it will leave behind a partially created, and hence corrupt, index. Because OFF journaling mode allows the database file to be corrupted using ordinary SQL, it is disabled when &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; is enabled.</source>
          <target state="translated">OFFジャーナリングモードでは、ロールバックジャーナルが完全に無効になります。ロールバックジャーナルは作成されないため、削除するロールバックジャーナルはありません。 OFFジャーナリングモードは、SQLiteのアトミックコミットおよびロールバック機能を無効にします。&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACKの&lt;/a&gt;コマンドは、もはや機能していません。未定義の方法で動作します。ジャーナルモードがオフの場合、アプリケーションは&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;コマンドの使用を回避する必要があります。 OFFジャーナリングモードが設定されている場合、トランザクションの途中でアプリケーションがクラッシュすると、データベースファイルが&lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;破損する&lt;/a&gt;可能性が高くなります。ジャーナルがないと、文が制約エラーの後に部分的に完了した操作を巻き戻す方法がありません。これにより、データベースが破損した状態になることもあります。たとえば、重複するエントリが原因で&lt;a href=&quot;lang_createindex&quot;&gt;CREATE UNIQUE INDEX&lt;/a&gt;ステートメントが途中で失敗すると、部分的に作成された、したがって破損したインデックスが残ります。OFFジャーナリングモードでは、通常のSQLを使用してデータベースファイルが破損する可能性があるため、&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt;が有効になっている場合は無効になります。</target>
        </trans-unit>
        <trans-unit id="374ba8e6eebafb57002a1dcdb7b0375a9e1ef0e6" translate="yes" xml:space="preserve">
          <source>The OFFSET clause, if it is present and has a positive value N, prevents the first N rows from being added to the recursive table. The first N rows are still processed by the recursive-select &amp;mdash; they just are not added to the recursive table. Rows are not counted toward fulfilling the LIMIT until all OFFSET rows have been skipped.</source>
          <target state="translated">OFFSET句が存在し、正の値Nがある場合、最初のN行が再帰テーブルに追加されません。最初のN行は、再帰的選択によって引き続き処理されます&amp;mdash;それらは再帰的テーブルに追加されないだけです。すべてのOFFSET行がスキップされるまで、行はLIMITを満たすためにカウントされません。</target>
        </trans-unit>
        <trans-unit id="0b277e3e2e965c40320745de00278d14c1b4c238" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT Clause</source>
          <target state="translated">オンコンフリクト条項</target>
        </trans-unit>
        <trans-unit id="549fba753f3ce9487855ba9f0e10547cd8338f25" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT clause applies to &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;, &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;, &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt;, and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints. The ON CONFLICT algorithm does not apply to &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY constraints&lt;/a&gt;. There are five conflict resolution algorithm choices: ROLLBACK, ABORT, FAIL, IGNORE, and REPLACE. The default conflict resolution algorithm is ABORT. This is what they mean:</source>
          <target state="translated">ON CONFLICT句は、&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;、&lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;、&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt;、および&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;制約に適用されます。ON CONFLICTアルゴリズムは、&lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY制約に&lt;/a&gt;は適用されません。競合解決アルゴリズムには、ROLLBACK、ABORT、FAIL、IGNORE、REPLACEの5つの選択肢があります。デフォルトの競合解消アルゴリズムはABORTです。これは彼らが意味するところです：</target>
        </trans-unit>
        <trans-unit id="1bdda41615452e17b3f0971a7f023b71ba464bbb" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT clause described here has been a part of SQLite since before version 3.0.0 (2004-06-18). The phrase &quot;ON CONFLICT&quot; is also part of &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt;, which is an extension to &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; added in version 3.24.0 (2018-06-04). Do not confuse these two separate uses of the &quot;ON CONFLICT&quot; phrase.</source>
          <target state="translated">ここで説明するON CONFLICT句は、バージョン3.0.0（2004-06-18）より前のSQLiteの一部です。「ON CONFLICT」という句も&lt;a href=&quot;lang_upsert&quot;&gt;UPSERTの&lt;/a&gt;一部です。これは、バージョン3.24.0（2018-06-04）で追加された&lt;a href=&quot;lang_insert&quot;&gt;INSERTの&lt;/a&gt;拡張機能です。「ON CONFLICT」句のこれら2つの別々の使用を混同しないでください。</target>
        </trans-unit>
        <trans-unit id="cdcbfd707214ce0a425024950f0078c8093a672f" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT clause is a non-standard extension specific to SQLite that can appear in many other SQL commands. It is given its own section in this document because it is not part of standard SQL and therefore might not be familiar.</source>
          <target state="translated">ON CONFLICT句はSQLiteに特有の非標準の拡張であり、他の多くのSQLコマンドにも登場します。このドキュメントでは、標準SQLの一部ではないため、あまり馴染みがないかもしれないため、独自のセクションを設けています。</target>
        </trans-unit>
        <trans-unit id="0b1442e3d6081cb327542a1dfef2a119f6cc8762" translate="yes" xml:space="preserve">
          <source>The ON DELETE and ON UPDATE action associated with each foreign key in an SQLite database is one of &quot;NO ACTION&quot;, &quot;RESTRICT&quot;, &quot;SET NULL&quot;, &quot;SET DEFAULT&quot; or &quot;CASCADE&quot;. If an action is not explicitly specified, it defaults to &quot;NO ACTION&quot;.</source>
          <target state="translated">SQLite データベース内の各外部キーに関連付けられた DELETE および UPDATE の ON アクションは、&quot;NO ACTION&quot;、&quot;RESTRICT&quot;、&quot;SET NULL&quot;、&quot;SET DEFAULT&quot;、&quot;CASCADE&quot; のいずれかです。アクションが明示的に指定されていない場合、デフォルトは &quot;NO ACTION &quot;となります。</target>
        </trans-unit>
        <trans-unit id="6bf1202b648eb0b4a5f050a8c6d05340c107e859" translate="yes" xml:space="preserve">
          <source>The ON and USING clauses of an inner join are converted into additional terms of the WHERE clause prior to WHERE clause analysis described above in paragraph 1.0. Thus with SQLite, there is no computational advantage to use the newer SQL92 join syntax over the older SQL89 comma-join syntax. They both end up accomplishing exactly the same thing on inner joins.</source>
          <target state="translated">内部結合の ON 節と USING 節は、上記のパラグラフ 1.0 で説明した WHERE 節分析の前に、WHERE 節の追加項に変換されます。このように、SQLiteでは、古いSQL89カンマ結合構文よりも新しいSQL92結合構文を使用しても計算上の利点はありません。どちらも内部結合では全く同じことを行うことになります。</target>
        </trans-unit>
        <trans-unit id="bb4c3f3b3997cb8490367acdbc7718d009c8a562" translate="yes" xml:space="preserve">
          <source>The OR operator calculates the &lt;b&gt;union&lt;/b&gt; of two sets of documents.</source>
          <target state="translated">OR演算子は、2つのドキュメントセットの&lt;b&gt;和集合&lt;/b&gt;を計算します。</target>
        </trans-unit>
        <trans-unit id="4ba92a05446009b56fe03f1afc3e8240d551a35c" translate="yes" xml:space="preserve">
          <source>The ORDER BY LIMIT optimization is not valid unless the inner-most IN operator loop is actually used by the query plan. Fix for ticket &lt;a href=&quot;https://sqlite.org/src/info/0c4df46116e90f92&quot;&gt;0c4df46116e90f92&lt;/a&gt;.</source>
          <target state="translated">ORDER BY LIMIT最適化は、最も内側のIN演算子ループがクエリプランで実際に使用されていない限り無効です。チケット&lt;a href=&quot;https://sqlite.org/src/info/0c4df46116e90f92&quot;&gt;0c4df46116e90f92の&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="7b8e2023ca7e681416d915e1d1b8f5b26d152e1f" translate="yes" xml:space="preserve">
          <source>The ORDER BY LIMIT optimization might have caused an infinite loop in the byte code of the prepared statement under very obscure circumstances, due to a confluence of minor defects in the query optimizer. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/9936b2fa443fec03ff25&quot;&gt;9936b2fa443fec03ff25&lt;/a&gt;</source>
          <target state="translated">ORDER BY LIMIT最適化により、クエリオプティマイザの小さな欠陥の合流により、非常にあいまいな状況下で準備さ​​れたステートメントのバイトコードに無限ループが発生した可能性があります。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/9936b2fa443fec03ff25&quot;&gt;9936b2fa443fec03ff25の&lt;/a&gt;修正</target>
        </trans-unit>
        <trans-unit id="b25ea5983496f08c601930c1bfec228ee9f65c25" translate="yes" xml:space="preserve">
          <source>The ORDER BY and LIMIT clauses on &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements are not supported. ORDER BY and LIMIT are not normally supported for &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; in any context but can be enabled for top-level statements using the &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; compile-time option. However, that compile-time option only applies to top-level &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements, not &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements within triggers.</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;および&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;ステートメントのORDER BYおよびLIMIT句はサポートされていません。 ORDER BYとLIMITは通常、どのコンテキストでも&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;または&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;でサポートされませんが、&lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt;コンパイル時オプションを使用してトップレベルのステートメントで有効にできます。ただし、そのコンパイル時オプションはトップレベルの&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;および&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;ステートメントにのみ適用され、トリガー内の&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;および&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;ステートメントには適用されません。</target>
        </trans-unit>
        <trans-unit id="3cfee8a3cdd0f5ece05fc4719284d9ca35cb1ece" translate="yes" xml:space="preserve">
          <source>The ORDER BY clause</source>
          <target state="translated">ORDER BY句</target>
        </trans-unit>
        <trans-unit id="30dc9fe3a4d009f8e23f54fc9886804eb6fd68d9" translate="yes" xml:space="preserve">
          <source>The ORDER BY clause on a DELETE statement is used only to determine which rows fall within the LIMIT. The order in which rows are deleted is arbitrary and is not influenced by the ORDER BY clause.</source>
          <target state="translated">DELETE文のORDER BY句は、どの行がLIMITに含まれるかを決定するためにのみ使用されます。削除される行の順序は任意であり、ORDER BY句の影響を受けることはありません。</target>
        </trans-unit>
        <trans-unit id="838347206eac0478c704f6fe626059a265388ac1" translate="yes" xml:space="preserve">
          <source>The ORDER BY clause on an UPDATE statement is used only to determine which rows fall within the LIMIT. The order in which rows are modified is arbitrary and is not influenced by the ORDER BY clause.</source>
          <target state="translated">UPDATE文のORDER BY句は、どの行がLIMITに含まれるかを決定するためにのみ使用されます。行が修正される順序は任意であり、ORDER BY句の影響を受けません。</target>
        </trans-unit>
        <trans-unit id="db6946cde6c76ae16df632182494e97889b98107" translate="yes" xml:space="preserve">
          <source>The OS Interface - also called the &quot;VFS&quot; - is what makes SQLite portable across operating systems. Whenever any of the other modules in SQLite needs to communicate with the operating system, they invoke methods in the VFS. The VFS then invokes the operating-specific code needed to satisfy the request. Hence, porting SQLite to a new operating system is simply a matter of writing a new OS interface layer or &quot;VFS&quot;.</source>
          <target state="translated">OS インターフェイス-&quot;VFS&quot; とも呼ばれる-は、SQLite をオペレーティング・システム間での移植性を高めています。SQLite の他のモジュールがオペレーティングシステムと通信する必要があるときはいつでも、VFS のメソッドを呼び出します。そして、VFS は要求を満たすために必要なオペレーティング・システム固有のコードを呼び出します。したがって、SQLite を新しいオペレーティングシステムに移植するには、単に新しい OS インターフェイス層または &quot;VFS&quot; を書けばよいのです。</target>
        </trans-unit>
        <trans-unit id="61b9ed4bbd7c64412bf999ddb3735b90a9006325" translate="yes" xml:space="preserve">
          <source>The OS interface layer has been completely reworked:</source>
          <target state="translated">OSのインターフェース層が完全に作り直されています。</target>
        </trans-unit>
        <trans-unit id="7db34215d6389d29f797bd445ad557bb97d4d35b" translate="yes" xml:space="preserve">
          <source>The OVER clause is required for &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt; and is prohibited otherwise. The DISTINCT keyword is only allowed in &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt;. The FILTER clause may not appear on a &lt;a href=&quot;lang_corefunc&quot;&gt;simple function&lt;/a&gt;.</source>
          <target state="translated">OVER句は&lt;a href=&quot;windowfunctions&quot;&gt;ウィンドウ関数に&lt;/a&gt;必要であり、それ以外の場合は禁止されています。DISTINCTキーワードは、&lt;a href=&quot;lang_aggfunc&quot;&gt;集約関数で&lt;/a&gt;のみ使用できます。FILTER句は、&lt;a href=&quot;lang_corefunc&quot;&gt;単純な関数&lt;/a&gt;では使用できません。</target>
        </trans-unit>
        <trans-unit id="97086bd49779ce0aff6b3d28109cebe94640094e" translate="yes" xml:space="preserve">
          <source>The OpenDocument file format is used for office applications: word processors, spreadsheets, and presentations. It was originally designed for the OpenOffice suite but has since been incorporated into other desktop application suites. The OpenOffice application has been forked and renamed a few times. This author's primary use for OpenDocument is building slide presentations with either &lt;a href=&quot;https://www.neooffice.org/neojava/en/index.php&quot;&gt;NeoOffice&lt;/a&gt; on Mac, or &lt;a href=&quot;http://www.libreoffice.org/&quot;&gt;LibreOffice&lt;/a&gt; on Linux and Windows.</source>
          <target state="translated">OpenDocumentファイル形式は、ワープロ、スプレッドシート、プレゼンテーションなどのオフィスアプリケーションで使用されます。もともとはOpenOfficeスイート用に設計されましたが、その後、他のデスクトップアプリケーションスイートに組み込まれました。OpenOfficeアプリケーションはフォークされ、何度か名前が変更されました。この著者のOpenDocumentの主な用途は、Mac上の&lt;a href=&quot;https://www.neooffice.org/neojava/en/index.php&quot;&gt;NeoOffice&lt;/a&gt;、またはLinuxとWindows上の&lt;a href=&quot;http://www.libreoffice.org/&quot;&gt;LibreOfficeの&lt;/a&gt;いずれかを使用してスライドプレゼンテーションを作成することです。</target>
        </trans-unit>
        <trans-unit id="a12f97809890d0843d3b379960cdb5a48586d66d" translate="yes" xml:space="preserve">
          <source>The P parameter in sqlite3_create_filename(D,J,W,N,P) should be an array of 2*N pointers to strings. Each pair of pointers in this array corresponds to a key and value for a query parameter. The P parameter may be a NULL pointer if N is zero. None of the 2*N pointers in the P array may be NULL pointers and key pointers should not be empty strings. None of the D, J, or W parameters to sqlite3_create_filename(D,J,W,N,P) may be NULL pointers, though they can be empty strings.</source>
          <target state="translated">sqlite3_create_filename(D,J,W,N,P)のPパラメータは文字列への2*Nのポインタの配列でなければなりません。この配列の各ポインタのペアは、クエリパラメータのキーと値に対応します。Pパラメータは,Nが0の場合はNULLポインタになります.P配列内の2*N個のポインタはいずれもNULLポインタであってはならず,キーポインタは空の文字列であってはなりません.sqlite3_create_filename(D,J,W,N,P)のD,J,WパラメータはどれもNULLポインタではありません。</target>
        </trans-unit>
        <trans-unit id="7e13d51d1ef218d337ca9fb917ffdb16cbc244df" translate="yes" xml:space="preserve">
          <source>The P1 cursor must be for a real table, not a pseudo-table. If P1 is not open then the behavior is undefined.</source>
          <target state="translated">P1カーソルは擬似テーブルではなく、実際のテーブル用でなければなりません。P1がオープンされていない場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="5b81ca2502b2715c59c443936643d2e3be1132fa" translate="yes" xml:space="preserve">
          <source>The P1 cursor must be for a real table, not a pseudo-table. P1 must have been opened prior to this opcode or the program will segfault.</source>
          <target state="translated">P1 カーソルは擬似テーブルではなく、実際のテーブルでなければなりません。P1はこのオペコードの前にオープンされていなければなりません。</target>
        </trans-unit>
        <trans-unit id="607ac7f84bdc4d441c6cb285c55a825dad256470" translate="yes" xml:space="preserve">
          <source>The P1 parameter is not actually used by this opcode. However, it is sometimes set to 1 instead of 0 as a hint to the command-line shell that this &lt;a href=&quot;opcode#Goto&quot;&gt;Goto&lt;/a&gt; is the bottom of a loop and that the lines from P2 down to the current line should be indented for EXPLAIN output.</source>
          <target state="translated">P1パラメータは、このオペコードでは実際には使用されません。ただし、コマンドラインシェルへのヒントとして、この&lt;a href=&quot;opcode#Goto&quot;&gt;Goto&lt;/a&gt;がループの最後であり、P2から現在の行までの行がEXPLAIN出力でインデントされる必要があることを、0ではなく1に設定する場合があります。</target>
        </trans-unit>
        <trans-unit id="28dbb0803ca5b349efaf91bc329608b765d512d1" translate="yes" xml:space="preserve">
          <source>The P3 argument of instruction 11 is of particular interest. The sort key is formed by prepending one character from P3 to each string and concatenating all the strings. The sort comparison function will look at this character to determine whether the sort order is ascending or descending, and whether to sort as a string or number. In this example, the first column should be sorted as a string in descending order so its prefix is &quot;D&quot; and the second column should sorted numerically in ascending order so its prefix is &quot;+&quot;. Ascending string sorting uses &quot;A&quot;, and descending numeric sorting uses &quot;-&quot;.</source>
          <target state="translated">特に注目すべきは命令11の引数P3である。ソートキーは、P3から1つの文字を各文字列に前置し、すべての文字列を連結することで形成されます。ソート比較関数はこの文字を見て、ソート順が昇順なのか降順なのか、文字列としてソートするのか数字としてソートするのかを判断します。この例では、最初の列は文字列として降順にソートされ、その接頭辞は &quot;D &quot;となり、2番目の列は数値として昇順にソートされ、その接頭辞は &quot;+&quot;となります。昇順の文字列ソートでは &quot;A &quot;を使用し、降順の数値ソートでは&quot;-&quot;を使用します。</target>
        </trans-unit>
        <trans-unit id="55ff312bc89d3e83256edc55b23ecd77e64741ac" translate="yes" xml:space="preserve">
          <source>The P3 value is a hint to the btree implementation. If P3==1, that means P1 is an SQL index and that this instruction could have been omitted if that index had been unique. P3 is usually 0. P3 is always either 0 or 1.</source>
          <target state="translated">P3の値はbtreeの実装へのヒントです。P3==1の場合、それはP1がSQLインデックスであり、そのインデックスが一意であれば、この命令は省略された可能性があることを意味します。P3は通常0ですが、P3は常に0か1です。</target>
        </trans-unit>
        <trans-unit id="f0f52e542da01be92f32d06abf2506b4a2d4f31b" translate="yes" xml:space="preserve">
          <source>The P4 register values beginning with P3 form an unpacked index key that omits the PRIMARY KEY or ROWID. &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; this key value against the index that P1 is currently pointing to, ignoring the PRIMARY KEY or ROWID on the P1 index.</source>
          <target state="translated">P3で始まるP4レジスタ値は、PRIMARY KEYまたはROWIDを省略したアンパックされたインデックスキーを形成します。このキー値をP1が現在指しているインデックスと&lt;a href=&quot;opcode#Compare&quot;&gt;比較&lt;/a&gt;し、P1インデックスのPRIMARY KEYまたはROWIDを無視します。</target>
        </trans-unit>
        <trans-unit id="4c2c023857d26616de9f3d4b0976bd5072c920ee" translate="yes" xml:space="preserve">
          <source>The P4 register values beginning with P3 form an unpacked index key that omits the PRIMARY KEY. &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; this key value against the index that P1 is currently pointing to, ignoring the PRIMARY KEY or ROWID fields at the end.</source>
          <target state="translated">P3で始まるP4レジスタ値は、PRIMARY KEYを省略したアンパックされたインデックスキーを形成します。このキー値を、P1が現在指しているインデックスと&lt;a href=&quot;opcode#Compare&quot;&gt;比較&lt;/a&gt;します。最後のPRIMARY KEYまたはROWIDフィールドは無視されます。</target>
        </trans-unit>
        <trans-unit id="19d27257909a32ae5401b59e606c768db9ed4065" translate="yes" xml:space="preserve">
          <source>The P4 value may be either an integer (P4_INT32) or a pointer to a KeyInfo structure (P4_KEYINFO). If it is a pointer to a KeyInfo object, then table being opened must be an &lt;a href=&quot;fileformat2#btypes&quot;&gt;index b-tree&lt;/a&gt; where the KeyInfo object defines the content and collating sequence of that index b-tree. Otherwise, if P4 is an integer value, then the table being opened must be a &lt;a href=&quot;fileformat2#btypes&quot;&gt;table b-tree&lt;/a&gt; with a number of columns no less than the value of P4.</source>
          <target state="translated">P4値は、整数（P4_INT32）またはKeyInfo構造体へのポインター（P4_KEYINFO）のいずれかです。それがKeyInfoオブジェクトへのポインタである場合、開かれるテーブルは、&lt;a href=&quot;fileformat2#btypes&quot;&gt;インデックスbツリー&lt;/a&gt;である必要があります。KeyInfoオブジェクトは、そのインデックスbツリーの内容と照合シーケンスを定義します。それ以外の場合、P4が整数値の場合、開かれる&lt;a href=&quot;fileformat2#btypes&quot;&gt;テーブル&lt;/a&gt;は、P4の値以上の列数を持つテーブルBツリーである必要があります。</target>
        </trans-unit>
        <trans-unit id="21923e08794e63280a41a6b5f859992f400d98cc" translate="yes" xml:space="preserve">
          <source>The P5 arguments are taken from register P2 and its successors.</source>
          <target state="translated">P5の引数は、レジスタP2とその後継者から取り出されます。</target>
        </trans-unit>
        <trans-unit id="6017964a6129b7a7e8f6a3da3f0784c73d2078ba" translate="yes" xml:space="preserve">
          <source>The P5 parameter can be a mask of the BTREE_* flags defined in btree.h. These flags control aspects of the operation of the btree. The BTREE_OMIT_JOURNAL and BTREE_SINGLE flags are added automatically.</source>
          <target state="translated">P5 パラメータには btree.h で定義されている BTREE_*フラグのマスクを指定することができます。BTREE_OMIT_JOURNAL および BTREE_SINGLE フラグは自動的に追加されます。</target>
        </trans-unit>
        <trans-unit id="3f1c0ff5695ef10ade1f6c3734423a4eb3077d3e" translate="yes" xml:space="preserve">
          <source>The PERSIST journaling mode prevents the rollback journal from being deleted at the end of each transaction. Instead, the header of the journal is overwritten with zeros. This will prevent other database connections from rolling the journal back. The PERSIST journaling mode is useful as an optimization on platforms where deleting or truncating a file is much more expensive than overwriting the first block of a file with zeros. See also: &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;PRAGMA journal_size_limit&lt;/a&gt; and &lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt;.</source>
          <target state="translated">PERSISTジャーナリングモードでは、各トランザクションの終了時にロールバックジャーナルが削除されないようにします。代わりに、ジャーナルのヘッダーはゼロで上書きされます。これにより、他のデータベース接続がジャーナルをロールバックするのを防ぎます。 PERSISTジャーナリングモードは、ファイルの削除または切り捨てがファイルの最初のブロックをゼロで上書きするよりもはるかにコストがかかるプラットフォームでの最適化として役立ちます。参照：&lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;PRAGMA journal_size_limit&lt;/a&gt;および&lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="161bece08ac2f5702ce5212ddbeeb1a41f2dbaee" translate="yes" xml:space="preserve">
          <source>The PLINK table holds parent-child relationships between check-ins. The TAGXREF table maps tags into check-ins. For reference, the relevant portions of the schemas for these two tables is shown here:</source>
          <target state="translated">PLINK テーブルは、チェックイン間の親子関係を保持します。TAGXREFテーブルは、タグをチェックインにマッピングします。参考までに、これら2つのテーブルのスキーマの関連部分をここに示します。</target>
        </trans-unit>
        <trans-unit id="e4bd8ba431ab4e0d31722f8db284b8bb979b0c36" translate="yes" xml:space="preserve">
          <source>The PRAGMA statement is an SQL extension specific to SQLite and used to modify the operation of the SQLite library or to query the SQLite library for internal (non-table) data. The PRAGMA statement is issued using the same interface as other SQLite commands (e.g. &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;) but is different in the following important respects:</source>
          <target state="translated">PRAGMAステートメントはSQLiteに固有のSQL拡張であり、SQLiteライブラリの操作を変更したり、SQLiteライブラリに内部（非テーブル）データを照会したりするために使用されます。PRAGMAステートメントは、他のSQLiteコマンド（例：&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;、&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;）と同じインターフェイスを使用して発行されますが、次の重要な点が異なります。</target>
        </trans-unit>
        <trans-unit id="c66b0cfca97f029db26ea6f18637a49f7fab6a97" translate="yes" xml:space="preserve">
          <source>The PRAGMA synchronous=off statement now disables syncing of the master journal file in addition to the normal rollback journals</source>
          <target state="translated">PRAGMA synchronous=offステートメントは、通常のロールバック・ジャーナルに加えて、マスター・ジャーナル・ファイルの同期を無効にするようになりました。</target>
        </trans-unit>
        <trans-unit id="b37fa685a4763fe504598bdda8b4b2f3d3eef491" translate="yes" xml:space="preserve">
          <source>The PRIMARY KEY constraint for a rowid table (as long as it is not the true primary key or INTEGER PRIMARY KEY) is really the same thing as a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE constraint&lt;/a&gt;. Because it is not a true primary key, columns of the PRIMARY KEY are allowed to be NULL, in violation of all SQL standards.</source>
          <target state="translated">ROWIDテーブルのPRIMARY KEY制約は（それが真の主キーまたはINTEGER PRIMARY KEYでない限り）、&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE制約&lt;/a&gt;と同じです。これは本当の主キーではないため、すべてのSQL標準に違反して、PRIMARY KEYの列をNULLにすることができます。</target>
        </trans-unit>
        <trans-unit id="ebe8c7b0a4b69dc3800a6f41776c565d6842c281" translate="yes" xml:space="preserve">
          <source>The PRIMARY KEY values identifying the modified row,</source>
          <target state="translated">変更された行を識別する PRIMARY KEY 値。</target>
        </trans-unit>
        <trans-unit id="90caad2286223b2e029c8d716238518e674a76d1" translate="yes" xml:space="preserve">
          <source>The Page Cache</source>
          <target state="translated">ページキャッシュ</target>
        </trans-unit>
        <trans-unit id="1f5eb567adef7decaf2acc8e4aa86ec1481f2a20" translate="yes" xml:space="preserve">
          <source>The PostgreSQL and MySQL servers used were as delivered by default on RedHat 7.2. (PostgreSQL version 7.1.3 and MySQL version 3.23.41.) No effort was made to tune these engines. Note in particular the default MySQL configuration on RedHat 7.2 does not support transactions. Not having to support transactions gives MySQL a big speed advantage, but SQLite is still able to hold its own on most tests.</source>
          <target state="translated">使用したPostgreSQLとMySQLサーバは、RedHat 7.2上でデフォルトで提供されているものを使用しました。(PostgreSQL バージョン 7.1.3 と MySQL バージョン 3.23.41)これらのエンジンをチューニングする努力はしていません。特に、RedHat 7.2 のデフォルトの MySQL 構成はトランザクションをサポートしていないことに注意してください。トランザクションをサポートしないことで、MySQLは大きな速度の優位性を得ていますが、SQLiteはほとんどのテストではまだ自分自身を維持することができます。</target>
        </trans-unit>
        <trans-unit id="3d04a38a1d2743c1862a6cfdba60ded14ba2896a" translate="yes" xml:space="preserve">
          <source>The PutIntKey instruction (also described during the discussion about INSERT) writes an entry into the database file whose data is the top of the stack and whose key is the next on the stack, and then pops the stack twice. The PutIntKey instruction will overwrite the data of an existing record with the same key, which is what we want here. Overwriting was not an issue with INSERT because with INSERT the key was generated by the NewRecno instruction which is guaranteed to provide a key that has not been used before.</source>
          <target state="translated">PutIntKey命令(INSERTについての説明でも説明しました)は、データがスタックの先頭にあり、そのキーがスタックの次のキーであるエントリをデータベースファイルに書き込み、スタックを2回ポップします。PutIntKey命令は、同じキーを持つ既存のレコードのデータを上書きします。上書きは、INSERTではキーがNewRecno命令によって生成されたため、INSERTでは問題になりませんでしたが、これは以前に使用されたことのないキーを提供することが保証されているからです。</target>
        </trans-unit>
        <trans-unit id="7408173a3218822a3bb6af7f7e3d86be256cefca" translate="yes" xml:space="preserve">
          <source>The QPSG is disabled by default. It can be enabled at compile-time using the &lt;a href=&quot;compile#enable_qpsg&quot;&gt;SQLITE_ENABLE_QPSG&lt;/a&gt; compile-time option, or at run-time by invoking &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt;,1,0).</source>
          <target state="translated">QPSGはデフォルトで無効になっています。これは、コンパイル時に&lt;a href=&quot;compile#enable_qpsg&quot;&gt;SQLITE_ENABLE_QPSG&lt;/a&gt;コンパイル時オプションを使用して有効にするか、実行時に&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt;、1,0）を呼び出して有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="7ff5d03d1a40249005abd9682f890ac5af94c96e" translate="yes" xml:space="preserve">
          <source>The QPSG means that if all of your queries run efficiently during testing, and if your application does not change the schema, then SQLite will not suddenly decide to start using a different query plan, possibly causing a performance problem, after your application is released to users. If your application works in the lab, it will continue working the same way after deployment.</source>
          <target state="translated">QPSG は、テスト中にすべてのクエリが効率的に実行され、アプリケーションがスキーマを変更していなければ、アプリケーションがユーザにリリースされた後に、SQLite が突然別のクエリプランを使用し始め、パフォーマンスの問題を引き起こすことはないということを意味します。アプリケーションがラボで動作している場合、デプロイ後も同じように動作します。</target>
        </trans-unit>
        <trans-unit id="e7c6137b874e291f7e936bf89d2438f289c1e9a2" translate="yes" xml:space="preserve">
          <source>The R-Tree concept originated with &lt;a href=&quot;http://www.baymoon.com/~tg2/&quot;&gt;Toni Guttman&lt;/a&gt;: &lt;em&gt;R-Trees: A Dynamic Index Structure for Spatial Searching&lt;/em&gt;, Proc. 1984 ACM SIGMOD International Conference on Management of Data, pp. 47-57. The implementation found in SQLite is a refinement of Guttman's original idea, commonly called &quot;R*Trees&quot;, that was described by Norbert Beckmann, Hans-Peter Kriegel, Ralf Schneider, Bernhard Seeger: &lt;em&gt;The R*-Tree: An Efficient and Robust Access Method for Points and Rectangles.&lt;/em&gt; SIGMOD Conference 1990: 322-331.</source>
          <target state="translated">Rツリーの概念がで始まっ&lt;a href=&quot;http://www.baymoon.com/~tg2/&quot;&gt;トニガットマン&lt;/a&gt;：&lt;em&gt;R-木：空間検索のためのAの動的インデックス構造&lt;/em&gt;、PROC。1984 ACM SIGMOD国際データ管理会議、47-57ページ。SQLiteにある実装は、一般に「R * Trees」と呼ばれるガットマンのオリジナルのアイデアを改良したもので、Norbert Beckmann、Hans-Peter Kriegel、Ralf Schneider、Bernhard Seeger：&lt;em&gt;R * -Tree：An Efficient and Robust Access&lt;/em&gt;によって記述され&lt;em&gt;ました。ポイントと長方形の方法。&lt;/em&gt;SIGMOD会議1990：322-331。</target>
        </trans-unit>
        <trans-unit id="5d3074807f0a652cf6707800a925f23953d72a9a" translate="yes" xml:space="preserve">
          <source>The RAISE() function</source>
          <target state="translated">RAISE()関数</target>
        </trans-unit>
        <trans-unit id="c69d2de0461d9e5577928a8a0c182e55c377b7ea" translate="yes" xml:space="preserve">
          <source>The RBU Extension</source>
          <target state="translated">RBU拡張</target>
        </trans-unit>
        <trans-unit id="f271a1dcb4b99763d2ff19003d2b360191882c40" translate="yes" xml:space="preserve">
          <source>The RBU database table contains a single row for each target database row inserted, updated or deleted by the update. Populating the RBU database tables is described in &lt;a href=&quot;rbu#database_contents&quot;&gt;the following section&lt;/a&gt;.</source>
          <target state="translated">RBUデータベーステーブルには、更新によって挿入、更新、または削除されたターゲットデータベースの行ごとに1つの行が含まれます。RBUデータベーステーブルへの入力については&lt;a href=&quot;rbu#database_contents&quot;&gt;、次のセクションで&lt;/a&gt;説明します。</target>
        </trans-unit>
        <trans-unit id="5b9dd90a4d99e081d94181c982214ebaab88f1ab" translate="yes" xml:space="preserve">
          <source>The RBU extension interface allows an application to apply an RBU update stored in an RBU database to an existing target database. The procedure is as follows:</source>
          <target state="translated">RBU拡張インターフェースは、アプリケーションがRBUデータベースに格納されたRBU更新を既存のターゲットデータベースに適用することを可能にします。その手順は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="fb0cbd808e0878559e4326851133fccc2e2e33dd" translate="yes" xml:space="preserve">
          <source>The RBU extension is an add-on for SQLite designed for use with large SQLite database files on low-power devices at the edge of a network. RBU may be used for two separate tasks:</source>
          <target state="translated">RBU 拡張機能は、ネットワークのエッジにある低消費電力デバイス上の大規模な SQLite データベースファイルで使用するために設計された SQLite 用のアドオンです。RBU は、2 つの異なるタスクに使用することができます。</target>
        </trans-unit>
        <trans-unit id="dc51cf7dfcbe19fae28d177efed486cafebfaa37" translate="yes" xml:space="preserve">
          <source>The RBU extension is not enabled by default. To enable it, compile the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; with the &lt;a href=&quot;compile#enable_rbu&quot;&gt;SQLITE_ENABLE_RBU&lt;/a&gt; compile-time option.</source>
          <target state="translated">RBU拡張機能はデフォルトでは有効になっていません。これを有効にするには、&lt;a href=&quot;compile#enable_rbu&quot;&gt;SQLITE_ENABLE_RBU&lt;/a&gt;コンパイル時オプションを使用して&lt;a href=&quot;amalgamation&quot;&gt;融合&lt;/a&gt;をコンパイルします。</target>
        </trans-unit>
        <trans-unit id="0d487cd05415f0ab5a85f8a6d6877a414f0dad6c" translate="yes" xml:space="preserve">
          <source>The RBU update will not detect or prevent foreign key or CHECK constraint violations.</source>
          <target state="translated">RBUの更新は、外部キーまたはCHECK制約違反を検出または防止しません。</target>
        </trans-unit>
        <trans-unit id="593961271c55fed248c83e9d463fa6fd9e121437" translate="yes" xml:space="preserve">
          <source>The RBU update will not fire any triggers.</source>
          <target state="translated">RBUアップデートではトリガーは発動しません。</target>
        </trans-unit>
        <trans-unit id="c6564cc776de2c808e8f2b66fc117a6728b91dc4" translate="yes" xml:space="preserve">
          <source>The REGEXP operator is a special syntax for the regexp() user function. No regexp() user function is defined by default and so use of the REGEXP operator will normally result in an error message. If an &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; named &quot;regexp&quot; is added at run-time, then the &quot;</source>
          <target state="translated">REGEXP演算子は、regexp（）ユーザー関数の特別な構文です。デフォルトではregexp（）ユーザー関数は定義されていないため、REGEXP演算子を使用すると、通常はエラーメッセージが表示されます。場合は&lt;a href=&quot;appfunc&quot;&gt;、アプリケーション定義のSQL関数&lt;/a&gt;「正規表現」という名前は、実行時に追加され、その後&quot;</target>
        </trans-unit>
        <trans-unit id="d8e251943a38b26d445d7abf3f883e482037ceab" translate="yes" xml:space="preserve">
          <source>The REGEXP operator is a special syntax for the regexp() user function. No regexp() user function is defined by default and so use of the REGEXP operator will normally result in an error message. If an &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL function&lt;/a&gt; named &quot;regexp&quot; is added at run-time, then the &quot;</source>
          <target state="translated">REGEXP演算子は、regexp（）ユーザー関数の特別な構文です。regexp（）ユーザー関数はデフォルトでは定義されていないため、REGEXP演算子を使用すると、通常、エラーメッセージが表示されます。場合は&lt;a href=&quot;c3ref/create_function&quot;&gt;、アプリケーション定義のSQL関数&lt;/a&gt;「正規表現」という名前は、実行時に追加され、その後&quot;</target>
        </trans-unit>
        <trans-unit id="f6504d5094ffa58be5ab1ac79df65f0b1aba5e47" translate="yes" xml:space="preserve">
          <source>The REINDEX command is used to delete and recreate indices from scratch. This is useful when the definition of a collation sequence has changed, or when there are &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt; involving a function whose definition has changed.</source>
          <target state="translated">REINDEXコマンドは、インデックスを最初から削除および再作成するために使用されます。これは、照合順序の定義が変更された場合、または定義が変更された関数を含む&lt;a href=&quot;expridx&quot;&gt;式にインデックス&lt;/a&gt;がある場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="5a60389a484988aa39c6d8ad03d71480c4d40ec6" translate="yes" xml:space="preserve">
          <source>The REINDEX command is used to delete and recreate indices from scratch. This is useful when the definition of a collation sequence has changed.</source>
          <target state="translated">REINDEXコマンドは、ゼロからインデックスを削除して再作成するために使用します。これは、照合順序の定義が変更された場合に便利です。</target>
        </trans-unit>
        <trans-unit id="26337c24aa4b0f0ab8be7c9f3c788f1a63917d77" translate="yes" xml:space="preserve">
          <source>The REINDEX command was added.</source>
          <target state="translated">REINDEXコマンドを追加しました。</target>
        </trans-unit>
        <trans-unit id="25bdb1a8b2079e760c4eabb862683c2777d36a53" translate="yes" xml:space="preserve">
          <source>The RELEASE command is like a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; for a SAVEPOINT. The RELEASE command causes all savepoints back to and including the most recent savepoint with a matching name to be removed from the transaction stack. The RELEASE of an inner transaction does not cause any changes to be written to the database file; it merely removes savepoints from the transaction stack such that it is no longer possible to ROLLBACK TO those savepoints. If a RELEASE command releases the outermost savepoint, so that the transaction stack becomes empty, then RELEASE is the same as &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;. The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command may be used to release all savepoints and commit the transaction even if the transaction was originally started by a SAVEPOINT command instead of a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; command.</source>
          <target state="translated">RELEASEコマンドは、SAVEPOINTの&lt;a href=&quot;lang_transaction&quot;&gt;COMMITの&lt;/a&gt;ようなものです。RELEASEコマンドを使用すると、名前が一致する最新のセーブポイントまでのすべてのセーブポイントがトランザクションスタックから削除されます。内部トランザクションのRELEASEによって、データベースファイルに変更が書き込まれることはありません。トランザクションスタックからセーブポイントを削除するだけで、それらのセーブポイントにROLLBACKできなくなります。RELEASEコマンドが最も外側のセーブポイントを解放してトランザクションスタックが空になる場合、RELEASEは&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;と同じです。&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;コマンドは、すべてのセーブポイントを解放し、トランザクションは、もともとの代わりに、SAVEPOINTコマンドによって開始された場合でも、トランザクションをコミットするために使用することができる&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; コマンド。</target>
        </trans-unit>
        <trans-unit id="2ca08634243012d2e2bc4d0598e7fea902f6787a" translate="yes" xml:space="preserve">
          <source>The RELEASE command starts with the most recent addition to the transaction stack and releases savepoints backwards in time until it releases a savepoint with a matching savepoint-name. Prior savepoints, even savepoints with matching savepoint-names, are unchanged. If the RELEASE command causes the transaction stack to become empty (if the RELEASE command releases the outermost transaction from the stack) then the transaction commits.</source>
          <target state="translated">RELEASEコマンドは、トランザクション・スタックに追加された最新のものから開始し、一致するセーブポイント名を持つセーブポイントをリリースするまで、セーブポイントを時間的に遡ってリリースします。それ以前のセーブポイントは、一致するセーブポイント名を持つセーブポイントであっても変更されません。RELEASE コマンドによってトランザクションスタックが空になった場合(RELEASE コマンドがスタックから最外 部のトランザクションを解放した場合)、そのトランザクションはコミットします。</target>
        </trans-unit>
        <trans-unit id="00402a1bc7f00a30656be0c0b84db4535fdee37b" translate="yes" xml:space="preserve">
          <source>The RENAME COLUMN TO syntax changes the column-name of table table-name into new-column-name. The column name is changed both within the table definition itself and also within all indexes, triggers, and views that reference the column. If the column name change would result in a semantic ambiguity in a trigger or view, then the RENAME COLUMN fails with an error and no changes are applied.</source>
          <target state="translated">RENAME COLUMN TO 構文は、テーブル名のカラム名を新しいカラム名に変更します。カラム名は、テーブル定義自体の中だけでなく、そのカラムを参照するすべてのインデックス、トリガ、およびビューの中でも変更されます。カラム名の変更がトリガまたはビューの意味的な曖昧さにつながる場合、RENAME COLUMNはエラーで失敗し、変更は適用されません。</target>
        </trans-unit>
        <trans-unit id="4fd18ba9ff83bdc2461dca0a5dcb6bdcec775c80" translate="yes" xml:space="preserve">
          <source>The RENAME TO syntax changes the name of table-name to new-table-name. This command cannot be used to move a table between attached databases, only to rename a table within the same database. If the table being renamed has triggers or indices, then these remain attached to the table after it has been renamed.</source>
          <target state="translated">RENAME TO 構文は、テーブル名の名前を new-table-name に変更します。このコマンドは、接続されたデータベース間でテーブルを移動するためには使用できず、同じデータベース内のテーブルの名前を変更するためだけに使用します。名前を変更するテーブルにトリガまたはインデックスがある場合、これらは名前を変更した後もテーブルにアタッチされたままになります。</target>
        </trans-unit>
        <trans-unit id="802816683a1617052efa11363c7e7856de219468" translate="yes" xml:space="preserve">
          <source>The REPLACE command is an alias for the &quot;&lt;a href=&quot;lang_conflict&quot;&gt;INSERT OR REPLACE&lt;/a&gt;&quot; variant of the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; command. This alias is provided for compatibility other SQL database engines. See the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; command documentation for additional information.</source>
          <target state="translated">REPLACEコマンドは、&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;コマンドの &quot; &lt;a href=&quot;lang_conflict&quot;&gt;INSERT OR REPLACE&lt;/a&gt; &quot;バリアントのエイリアスです。このエイリアスは、他のSQLデータベースエンジンとの互換性のために提供されています。詳細については、&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;コマンドのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="f900ded58f3c3fd3840ddc24eb90dbbf605e279b" translate="yes" xml:space="preserve">
          <source>The ROLLBACK TO command reverts the state of the database back to what it was just after the corresponding SAVEPOINT. Note that unlike that plain &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command (without the TO keyword) the ROLLBACK TO command does not cancel the transaction. Instead of cancelling the transaction, the ROLLBACK TO command restarts the transaction again at the beginning. All intervening SAVEPOINTs are canceled, however.</source>
          <target state="translated">ROLLBACK TOコマンドは、データベースの状態を、対応するSAVEPOINTの直後の状態に戻します。その単純な&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;コマンド（TOキーワードなし）とは異なり、ROLLBACK TOコマンドはトランザクションをキャンセルしないことに注意してください。トランザクションをキャンセルする代わりに、ROLLBACK TOコマンドはトランザクションを最初から再開します。ただし、間にあるSAVEPOINTはすべて取り消されます。</target>
        </trans-unit>
        <trans-unit id="cd447cb0f90571617cf670fb9ebcb0a187d10c25" translate="yes" xml:space="preserve">
          <source>The ROLLBACK command with a TO clause rolls back transactions going backwards in time back to the most recent SAVEPOINT with a matching name. The SAVEPOINT with the matching name remains on the transaction stack, but all database changes that occurred after that SAVEPOINT was created are rolled back. If the savepoint-name in a ROLLBACK TO command does not match any SAVEPOINT on the stack, then the ROLLBACK command fails with an error and leaves the state of the database unchanged.</source>
          <target state="translated">TO句を持つROLLBACKコマンドは、名前が一致する最新のSAVEPOINTまで時間を遡ってトランザクションをロールバックします。一致する名前のSAVEPOINTはトランザクション・スタック上に残りますが、そのSAVEPOINTが作成された後に発生したすべてのデータベース変更はロールバックされます。ROLLBACK TOコマンドのSAVEPOINT-NAMEがスタック上のどのSAVEPOINTにも一致しない場合、ROLLBACKコマンドはエラーで失敗し、データベースの状態は変更されません。</target>
        </trans-unit>
        <trans-unit id="62a43e8d492ce5e858bd1d1f31b22f0ef1c5e90c" translate="yes" xml:space="preserve">
          <source>The ROWS and GROUPS frame types are similar in that they both determine the extent of a frame by counting relative to the current row. The difference is that ROWS counts individual rows and GROUPS counts peer groups. The RANGE frame type is different. The RANGE frame type determines the extent of a frame by looking for expression values that are within some band of values relative to the current row.</source>
          <target state="translated">ROWSとGROUPSのフレームタイプは、どちらも現在の行を相対的にカウントすることでフレームの範囲を決定するという点で似ています。違いは、ROWS は個々の行をカウントし、GROUPS はピアグループをカウントすることです。RANGEフレームタイプは異なります。RANGEフレームタイプは、現在の行からの相対的な値のいくつかのバンド内にある式の値を探すことによって、フレームの範囲を決定します。</target>
        </trans-unit>
        <trans-unit id="6cd583a191932218eb3314e3e838d31fd080381b" translate="yes" xml:space="preserve">
          <source>The Robson proof applies separately to each of the memory allocators used by SQLite:</source>
          <target state="translated">ロブソンの証明は、SQLite が使用するメモリアロケータのそれぞれに個別に適用されます。</target>
        </trans-unit>
        <trans-unit id="ebd8832f03de287c31f207b9169a825dcdfbcb2a" translate="yes" xml:space="preserve">
          <source>The RowSet object is optimized for the case where sets of integers are inserted in distinct phases, which each set contains no duplicates. Each set is identified by a unique P4 value. The first set must have P4==0, the final set must have P4==-1, and for all other sets must have P4&amp;gt;0.</source>
          <target state="translated">RowSetオブジェクトは、整数のセットが異なるフェーズに挿入され、各セットに重複がない場合に最適化されています。各セットは、一意のP4値によって識別されます。最初のセットはP4 == 0でなければならず、最後のセットはP4 ==-1でなければならず、他のすべてのセットはP4&amp;gt; 0でなければなりません。</target>
        </trans-unit>
        <trans-unit id="69b35696d5bc7e8c253762e4c23df59d339d7859" translate="yes" xml:space="preserve">
          <source>The SAVEPOINT command starts a new transaction with a name. The transaction names need not be unique. A SAVEPOINT can be started either within or outside of a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;...&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;. When a SAVEPOINT is the outer-most savepoint and it is not within a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;...&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; then the behavior is the same as BEGIN DEFERRED TRANSACTION.</source>
          <target state="translated">SAVEPOINTコマンドは、名前を指定して新しいトランザクションを開始します。トランザクション名は一意である必要はありません。SAVEPOINTは、&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; ... &lt;a href=&quot;lang_transaction&quot;&gt;COMMITの&lt;/a&gt;内部または外部で開始できます。SAVEPOINTが最も外側のセーブポイントであり、&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; ... &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;内にない場合、動作はBEGIN DEFERRED TRANSACTIONと同じです。</target>
        </trans-unit>
        <trans-unit id="ce13fbd458ee477db75220e11cabd929def8f2a4" translate="yes" xml:space="preserve">
          <source>The SCHEMA column is NULL, except for cases when the &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface is used to interrogate the ZIPVFS backend. As this only happens when the memstat.c module is compiled with -DSQLITE_ENABLE_ZIPVFS and when &lt;a href=&quot;https://www.hwaci.com/sw/sqlite/zipvfs.html&quot;&gt;ZIPVFS&lt;/a&gt; is in use, SCHEMA is usually NULL.</source>
          <target state="translated">&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;インターフェースを使用してZIPVFSバックエンドに問い合わせる場合を除いて、SCHEMA列はNULL です。これはのみ発生したようmemstat.cモジュールは-DSQLITE_ENABLE_ZIPVFSでコンパイルされたときに、いつ&lt;a href=&quot;https://www.hwaci.com/sw/sqlite/zipvfs.html&quot;&gt;ZIPVFSが&lt;/a&gt;使用されている、SCHEMAは、通常はNULLです。</target>
        </trans-unit>
        <trans-unit id="c6115bd106a2add942203424bfde4ef5e373053a" translate="yes" xml:space="preserve">
          <source>The SELECT begins in a familiar fashion. First the column names are initialized and the table being queried is opened. Things become different beginning with instructions 5 and 6 where the index file is also opened. Instructions 7 and 8 make a key with the value of 50. The &lt;a href=&quot;opcode#MemStore&quot;&gt;MemStore&lt;/a&gt; instruction at 9 stores the index key in VDBE memory location 0. The VDBE memory is used to avoid having to fetch a value from deep in the stack, which can be done, but makes the program harder to generate. The following instruction &lt;a href=&quot;opcode#MoveTo&quot;&gt;MoveTo&lt;/a&gt; at address 10 pops the key off the stack and moves the index cursor to the first row of the index with that key. This initializes the cursor for use in the following loop.</source>
          <target state="translated">SELECTはおなじみの方法で始まります。最初に列名が初期化され、クエリ対象のテーブルが開かれます。インデックスファイルも開く手順5と6から、状況は異なります。命令7と8は、値が50のキーを作成します&lt;a href=&quot;opcode#MemStore&quot;&gt;。9のMemStore&lt;/a&gt;命令は、インデックスキーをVDBEメモリロケーション0に格納します。VDBEメモリは、スタックの深いところから値をフェッチする必要がないようにするために使用されます。ただし、プログラムの生成が難しくなります。次の命令&lt;a href=&quot;opcode#MoveTo&quot;&gt;MoveToは&lt;/a&gt;、アドレス10でスタックからキーをポップし、インデックスカーソルをそのキーを持つインデックスの最初の行に移動します。これにより、次のループで使用するためにカーソルが初期化されます。</target>
        </trans-unit>
        <trans-unit id="7a0eced3e1981106cb4ea9f622f50ad79cd9e5a4" translate="yes" xml:space="preserve">
          <source>The SELECT statement is the most complicated command in the SQL language. To make the description easier to follow, some of the passages below describe the way the data returned by a SELECT statement is determined as a series of steps. It is important to keep in mind that this is purely illustrative - in practice neither SQLite nor any other SQL engine is required to follow this or any other specific process.</source>
          <target state="translated">SELECT文はSQL言語の中で最も複雑なコマンドです。説明をわかりやすくするために、以下のいくつかの文章では、SELECT文によって返されるデータが一連のステップとして決定される方法を説明しています。これは純粋に例示的なものであり、実際にはSQLiteも他のSQLエンジンもこのような特定のプロセスに従う必要はないことを覚えておくことが重要です。</target>
        </trans-unit>
        <trans-unit id="ecb8c3356a31e99d0c2a4414b1c0627a922137ba" translate="yes" xml:space="preserve">
          <source>The SELECT statement is used to query the database. The result of a SELECT is zero or more rows of data where each row has a fixed number of columns. A SELECT statement does not make any changes to the database.</source>
          <target state="translated">SELECT文はデータベースへの問い合わせに使用されます。SELECTの結果は0行以上のデータで、各行は固定の列数を持ちます。SELECT文はデータベースに変更を加えません。</target>
        </trans-unit>
        <trans-unit id="06f43e1f8274aa8dc54f915ee9dedc6e51d7565a" translate="yes" xml:space="preserve">
          <source>The SELECT statement on the left returns a single row since '0' and '0.0' are treated as numbers and are therefore indistinct. But the SELECT statement on the right returns two rows since 0 and 0.0 are treated a strings which are different.</source>
          <target state="translated">左側のSELECT文は、'0'と'0.0'が数値として扱われているため、1行を返します。しかし、右のSELECT文は、0と0.0が異なる文字列として扱われるため、2行を返します。</target>
        </trans-unit>
        <trans-unit id="e902534831ef4c318239e243a80c6ae4bb31b6d1" translate="yes" xml:space="preserve">
          <source>The SQL command &quot;BEGIN TRANSACTION&quot; (the TRANSACTION keyword is optional) is used to take SQLite out of autocommit mode. Note that the BEGIN command does not acquire any locks on the database. After a BEGIN command, a SHARED lock will be acquired when the first SELECT statement is executed. A RESERVED lock will be acquired when the first INSERT, UPDATE, or DELETE statement is executed. No EXCLUSIVE lock is acquired until either the memory cache fills up and must be spilled to disk or until the transaction commits. In this way, the system delays blocking read access to the file file until the last possible moment.</source>
          <target state="translated">SQL コマンド &quot;BEGIN TRANSACTION&quot; (TRANSACTION キーワードはオプションです)を使用して、SQLite を自動コミット・モードから解除します。BEGIN コマンドはデータベースのロックを取得しないことに注意してください。BEGIN コマンドの後、最初の SELECT 文の実行時に SHARED ロックが取得されます。RESERVEDロックは、最初のINSERT、UPDATE、またはDELETE文が実行されたときに取得されます。メモリ・キャッシュが一杯になってディスクに流出しなければならないか、トランザクションがコミットされるまでは、EXCLUSIVEロックは取得されません。このようにして、システムは可能な限り最後の瞬間までファイルファイルへの読み取りアクセスをブロックするのを遅らせます。</target>
        </trans-unit>
        <trans-unit id="af8ff773b8faa66109f99e9e85b3a719b5cf7712" translate="yes" xml:space="preserve">
          <source>The SQL command &quot;COMMIT&quot; does not actually commit the changes to disk. It just turns autocommit back on. Then, at the conclusion of the command, the regular autocommit logic takes over and causes the actual commit to disk to occur. The SQL command &quot;ROLLBACK&quot; also operates by turning autocommit back on, but it also sets a flag that tells the autocommit logic to rollback rather than commit.</source>
          <target state="translated">SQLコマンド &quot;commit &quot;は、実際には変更をディスクにコミットしません。単に自動コミットをオンに戻すだけです。そして、コマンドが終了すると、通常のオートコミットロジックが引き継がれ、ディスクへの実際のコミットが行われます。SQL コマンド &quot;ROLLBACK&quot; もまた、オートコミットをオンに戻すことで動作しますが、コミットではなくロールバックするようにオートコミットロジックに指示するフラグを設定します。</target>
        </trans-unit>
        <trans-unit id="82504fd949554ebcdca052a7976082cbbc273023" translate="yes" xml:space="preserve">
          <source>The SQL fuzz generator tests are part of the TCL test suite. During a full test run, about 111.3 thousand fuzz SQL statements are generated and tested.</source>
          <target state="translated">SQLファズジェネレータのテストは、TCLテストスイートの一部です。完全なテスト実行中に、約111.3千のfuzz SQL文が生成され、テストされます。</target>
        </trans-unit>
        <trans-unit id="3044d65e21f066cf67f7a5007e05a25a7bcd19f9" translate="yes" xml:space="preserve">
          <source>The SQL language features several contexts where an expression is evaluated and the result converted to a boolean (true or false) value. These contexts are:</source>
          <target state="translated">SQL言語は、式が評価され、その結果がブール値(真または偽)に変換されるいくつかのコンテキストを特徴としています。これらのコンテキストは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="8b4f854d9a377d64ee6ebf1ef026f57adf3093a6" translate="yes" xml:space="preserve">
          <source>The SQL language is a &quot;standard&quot;. Even so, no two SQL database engines work exactly alike. Every SQL implementation has it own peculiarities and oddities, and SQLite is no exception to this rule.</source>
          <target state="translated">SQL言語は「標準」です。それでも、2つのSQLデータベースエンジンが全く同じように動作することはありません。すべてのSQLの実装には独自の特殊性や奇抜さがあり、SQLiteも例外ではありません。</target>
        </trans-unit>
        <trans-unit id="10de2fe05ef5e79065921e1cfe79576a9514e5b1" translate="yes" xml:space="preserve">
          <source>The SQL language is rich in keywords. Most SQL implementations do not allow keywords to be used as identifiers (the names of table or columns) unless they are enclosed in double-quotes. But SQLite is more flexible. Many keywords can be used as identifiers without needing to be quoted, as long as those keywords are used in a context where it is clear that they are intended to be an identifier.</source>
          <target state="translated">SQL言語にはキーワードが豊富にあります。ほとんどのSQLの実装では、ダブルクォートで囲まれていない限り、キーワードを識別子(テーブルやカラムの名前)として使用することはできません。しかし、SQLiteはより柔軟です。多くのキーワードは、それらのキーワードが識別子であることが明らかな文脈で使用されている限り、引用符で囲まなくても識別子として使用することができます。</target>
        </trans-unit>
        <trans-unit id="a6afa95ef6a6482806d3030ee240e85ae2e39791" translate="yes" xml:space="preserve">
          <source>The SQL language is very powerful, and so it is always possible for malicious SQL inputs (or erroneous SQL inputs caused by an application bug) to submit SQL that runs for a very long time. To prevent this from becoming a denial-of-service attack, consider using the &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; interface to invoke a callback periodically as each SQL statement runs, and have that callback return non-zero to abort the statement if the statement runs for too long. Alternatively, set a timer in a separate thread and invoke &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; when the timer goes off to prevent the SQL statement from running forever.</source>
          <target state="translated">SQL言語は非常に強力であるため、悪意のあるSQL入力（またはアプリケーションのバグが原因で発生した誤ったSQL入力）が、長時間実行されるSQLを送信する可能性があります。これがサービス拒否攻撃になるのを防ぐには、&lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler（）&lt;/a&gt;インターフェースを使用して、各SQLステートメントの実行時に定期的にコールバックを呼び出し、ステートメントの実行時間が長すぎる場合、コールバックがゼロ以外の値を返すようにしてください。 。または、別のスレッドにタイマーを設定し、タイマーがオフになったときに&lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt（）&lt;/a&gt;を呼び出して、SQLステートメントが永久に実行されないようにします。</target>
        </trans-unit>
        <trans-unit id="48efb4a27989fcb1221b7de6665fb9fdbe5be779" translate="yes" xml:space="preserve">
          <source>The SQL language parser for SQLite is generated using a code-generator program called &quot;Lemon&quot;. The Lemon program reads a grammar of the input language and emits C-code to implement a parser for that language.</source>
          <target state="translated">SQLite用のSQL言語パーサは、&quot;Lemon &quot;と呼ばれるコード生成プログラムを使用して生成されます。Lemon プログラムは入力言語の文法を読み込んで、その言語用のパーサを実装するための C コードを出力します。</target>
        </trans-unit>
        <trans-unit id="3001af76a5af3b3d6822f17dc4d8570b011ad5be" translate="yes" xml:space="preserve">
          <source>The SQL output resulting from &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; is now modified to include the values of &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;からのSQL出力は、&lt;a href=&quot;lang_expr#varparam&quot;&gt;バインドされたパラメータの&lt;/a&gt;値を含むように変更されました。</target>
        </trans-unit>
        <trans-unit id="677e1e6ba30ceb96b1361fef9b1a12b6f65a8d13" translate="yes" xml:space="preserve">
          <source>The SQL query in the example above uses less CPU than the first example in this section, but still has a non-obvious performance problem. SQLite satisfies this query by retrieving the value of the &quot;title&quot; column and matchinfo data from the FTS module for every row matched by the users query before it sorts and limits the results. Because of the way SQLite's virtual table interface works, retrieving the value of the &quot;title&quot; column requires loading the entire row from disk (including the &quot;content&quot; field, which may be quite large). This means that if the users query matches several thousand documents, many megabytes of &quot;title&quot; and &quot;content&quot; data may be loaded from disk into memory even though they will never be used for any purpose.</source>
          <target state="translated">上の例の SQL クエリは、このセクションの最初の例よりも CPU の使用量は少ないですが、明らかなパフォーマンスの問題はありません。SQLite は、ユーザー クエリでマッチしたすべての行について、FTS モジュールから &quot;title&quot; カラムの値と matchinfo データを取得してから、結果をソートして制限することで、このクエリを満たしています。SQLite の仮想テーブルインターフェイスの動作方法のため、&quot;title&quot; カラムの値を取得するには、ディスクから行全体をロードする必要があります(&quot;content&quot; フィールドを含む)。これは、ユーザーのクエリが数千のドキュメントにマッチした場合、何メガバイトもの &quot;title &quot;と &quot;content &quot;データがディスクからメモリにロードされる可能性があることを意味しています。</target>
        </trans-unit>
        <trans-unit id="44349eaec4c0440f46685e284dc3b9bdf9db6763" translate="yes" xml:space="preserve">
          <source>The SQL query in the following example block is one solution to this problem. In SQLite, when a &lt;a href=&quot;optoverview#flattening&quot;&gt;sub-query used in a join contains a LIMIT clause&lt;/a&gt;, the results of the sub-query are calculated and stored in temporary table before the main query is executed. This means that SQLite will load only the docid and matchinfo data for each row matching the users query into memory, determine the docid values corresponding to the ten most relevant documents, then load only the title and content information for those 10 documents only. Because both the matchinfo and docid values are gleaned entirely from the full-text index, this results in dramatically less data being loaded from the database into memory.</source>
          <target state="translated">次のサンプルブロックのSQLクエリは、この問題の1つの解決策です。 SQLiteでは&lt;a href=&quot;optoverview#flattening&quot;&gt;、結合で使用されるサブクエリにLIMIT句が含まれて&lt;/a&gt;いる場合、メインクエリが実行される前に、サブクエリの結果が計算され、一時テーブルに保存されます。つまり、SQLiteは、ユーザークエリに一致する各行のdocidデータとmatchinfoデータのみをメモリに読み込み、最も関連性の高い10個のドキュメントに対応するdocid値を決定し、それら10個のドキュメントのみのタイトルとコンテンツ情報のみを読み込みます。 matchinfoとdocidの両方の値がフルテキストインデックスから完全に収集されるため、データベースからメモリに読み込まれるデータが劇的に少なくなります。</target>
        </trans-unit>
        <trans-unit id="a5256c5c7d2eb97fecf26da60392ff96d1a9f664" translate="yes" xml:space="preserve">
          <source>The SQL standard requires double-quotes around identifiers and single-quotes around string literals. For example:</source>
          <target state="translated">SQL標準では、識別子をダブルクォートで囲み、文字列リテラルをシングルクォートで囲う必要があります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="7e7a261f0a3880c45baf726e85dad9e7315752c4" translate="yes" xml:space="preserve">
          <source>The SQL standard requires that a UNIQUE constraint be enforced even if one or more of the columns in the constraint are NULL, but SQLite does not do this. Isn't that a bug?</source>
          <target state="translated">SQL標準では、制約の中の1つ以上の列がNULLであってもUNIQUE制約を適用することが求められていますが、SQLiteではこれが行われていません。これはバグではないのでしょうか?</target>
        </trans-unit>
        <trans-unit id="7a04eb23eef56ed5f467e10f54232c8a27c42d7f" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies a large number of keywords which may not be used as the names of tables, indices, columns, databases, user-defined functions, collations, virtual table modules, or any other named object. The list of keywords is so long that few people can remember them all. For most SQL code, your safest bet is to never use any English language word as the name of a user-defined object.</source>
          <target state="translated">SQL標準では、テーブル、インデックス、カラム、データベース、ユーザー定義関数、照合順序、仮想テーブルモジュール、その他の名前付きオブジェクトの名前として使用できないキーワードが多数規定されています。キーワードのリストは非常に長く、それらをすべて覚えている人はほとんどいません。ほとんどのSQLコードでは、ユーザー定義オブジェクトの名前に英語の単語を使用しないことが最も安全です。</target>
        </trans-unit>
        <trans-unit id="f8004c4c668fddca439c94d74dc1d6f7c7684dbe" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that single-quotes in strings are escaped by putting two single quotes in a row. SQL works like the Pascal programming language in this regard. Example:</source>
          <target state="translated">SQL標準では、文字列中のシングルクォートは、行の中に2つのシングルクォートを入れることでエスケープされるように規定されています。SQLはこの点ではPascalプログラミング言語のように動作します。例を示します。</target>
        </trans-unit>
        <trans-unit id="59242cd06ef98d5456a2038bc8b7aff22753485f" translate="yes" xml:space="preserve">
          <source>The SQL statement is a UTF-8 string for sqlite3_prepare(). The sqlite3_prepare16() works the same way except that it expects a UTF-16 string as SQL input. Only the first SQL statement in the input string is compiled. The fifth parameter is filled in with a pointer to the next (uncompiled) SQLite statement in the input string, if any. The sqlite3_finalize() routine deallocates a prepared SQL statement. All prepared statements must be finalized before the database can be closed. The sqlite3_reset() routine resets a prepared SQL statement so that it can be executed again.</source>
          <target state="translated">SQL文はsqlite3_prepare()のUTF-8文字列です。sqlite3_prepare16()は、SQL入力としてUTF-16文字列を期待していることを除いては、同じように動作します。入力文字列の最初のSQL文だけがコンパイルされます。5番目のパラメータは、入力文字列の中に次の(コンパイルされていない)SQLite文があれば、そのポインタで埋められます。sqlite3_finalize()ルーチンは準備されたSQL文を解放します。準備されたすべての文は、データベースを閉じる前に最終化されなければなりません。sqlite3_reset()ルーチンは準備されたSQL文をリセットし、再度実行できるようにします。</target>
        </trans-unit>
        <trans-unit id="05506ce34afb730ccba4a9b42a033056b9bc26b4" translate="yes" xml:space="preserve">
          <source>The SQL statement may contain tokens of the form &quot;?&quot; or &quot;?nnn&quot; or &quot;:aaa&quot; where &quot;nnn&quot; is an integer and &quot;aaa&quot; is an identifier. Such tokens represent unspecified literal values (or &quot;wildcards&quot;) to be filled in later by the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind&lt;/a&gt; interface. Each wildcard has an associated number which is its sequence in the statement or the &quot;nnn&quot; in the case of a &quot;?nnn&quot; form. It is allowed for the same wildcard to occur more than once in the same SQL statement, in which case all instance of that wildcard will be filled in with the same value. Unbound wildcards have a value of NULL.</source>
          <target state="translated">SQLステートメントには、「？」形式のトークンを含めることができます。または「？nnn」または「：aaa」。「nnn」は整数、「aaa」は識別子です。このようなトークンは、&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind&lt;/a&gt;インターフェースによって後で入力される未指定のリテラル値（または「ワイルドカード」）を表します。各ワイルドカードには、ステートメント内のシーケンス、または「？nnn」形式の場合は「nnn」の番号が関連付けられています。同じSQLステートメントで同じワイルドカードを複数回使用できます。その場合、そのワイルドカードのすべてのインスタンスに同じ値が入力されます。バインドされていないワイルドカードの値はNULLです。</target>
        </trans-unit>
        <trans-unit id="449ffcbd2d390b1586ef94ae6aaf64cdfbb6cfbd" translate="yes" xml:space="preserve">
          <source>The SQL statement supplied as the argument to the CREATE VIRTUAL TABLE statement is executed when the table is created. It must return either four or five columns. Each row returned describes one of the component tables. The first four columns are interpreted, from first to last, as:</source>
          <target state="translated">CREATE VIRTUAL TABLE文の引数として与えられたSQL文は、テーブルが作成されたときに実行されます。これは4つまたは5つの列を返さなければなりません。返される各行は、コンポーネントテーブルの1つを記述します。最初の4つの列は、最初から最後まで、次のように解釈されます。</target>
        </trans-unit>
        <trans-unit id="dd374f0003c79e47aa8712ac4ea58e570b4758d5" translate="yes" xml:space="preserve">
          <source>The SQL statements used to implement SQLite Archive operations make use of various &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt;. These extensions are all available in the &lt;a href=&quot;https://sqlite.org/src&quot;&gt;SQLite source tree&lt;/a&gt; in the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc&quot;&gt;ext/misc/ subfolder&lt;/a&gt;. The extensions needed for full SQLite Archive support include:</source>
          <target state="translated">SQLiteアーカイブ操作の実装に使用されるSQLステートメントは、さまざまな&lt;a href=&quot;loadext&quot;&gt;ロード可能な拡張機能&lt;/a&gt;を利用します。これらの拡張機能はすべて、&lt;a href=&quot;https://sqlite.org/src/file/ext/misc&quot;&gt;ext / misc /サブフォルダー&lt;/a&gt;の&lt;a href=&quot;https://sqlite.org/src&quot;&gt;SQLiteソースツリー&lt;/a&gt;で使用できます。SQLite Archiveを完全にサポートするために必要な拡張機能は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="cc6ae8d6fb78d715b5f8b26d43534dafb12ea942" translate="yes" xml:space="preserve">
          <source>The SQL syntax for custom queries is the same regardless of which interface, sqlite3_rtree_geometry_callback() or sqlite3_rtree_query_callback(), is used to register the SQL function. However, the newer query-style callbacks give the application greater control over how the query proceeds.</source>
          <target state="translated">カスタムクエリのSQL構文は、SQL関数の登録にsqlite3_rtree_geometry_callback()とsqlite3_rtree_query_callback()のどちらのインターフェイスを使用しても同じです。しかし、新しいクエリスタイルのコールバックは、アプリケーションがクエリをどのように進めるかをより大きく制御することができます。</target>
        </trans-unit>
        <trans-unit id="f9308701d68c8225498cd757f7331dde6f73adc8" translate="yes" xml:space="preserve">
          <source>The SQL:1999 spec requires that the RECURSIVE keyword follow WITH in any WITH clause that includes a recursive common table expression. However, for compatibility with SqlServer and Oracle, SQLite does not enforce this rule.</source>
          <target state="translated">SQL:1999仕様では、再帰的な共通テーブル式を含むWITH句では、RECURSIVEキーワードがWITHに続くことが要求されています。しかし、SqlServerやOracleとの互換性のために、SQLiteではこのルールを適用していません。</target>
        </trans-unit>
        <trans-unit id="b5ddf5e6785ea3822394b6d6a54fb42d4acd1778" translate="yes" xml:space="preserve">
          <source>The SQLITE_ABORT result code indicates that an operation was aborted prior to completion, usually be application request. See also: &lt;a href=&quot;rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;.</source>
          <target state="translated">SQLITE_ABORT結果コードは、操作が完了する前に打ち切られたことを示します。通常はアプリケーションの要求です。&lt;a href=&quot;rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="1613fab985744b29bc64a3b7d315d71db7102a20" translate="yes" xml:space="preserve">
          <source>The SQLITE_ABORT_ROLLBACK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; indicating that an SQL statement aborted because the transaction that was active when the SQL statement first started was rolled back. Pending write operations always fail with this error when a rollback occurs. A &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; will cause a pending read operation to fail only if the schema was changed within the transaction being rolled back.</source>
          <target state="translated">SQLITE_ABORT_ROLLBACKエラーコードは、SQLステートメントが最初に開始されたときにアクティブだったトランザクションがロールバックされたためにSQLステートメントが&lt;a href=&quot;rescode#pve&quot;&gt;異常終了した&lt;/a&gt;ことを示す&lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORTの&lt;/a&gt;拡張エラーコードです。ロールバックが発生すると、保留中の書き込み操作は常にこのエラーで失敗します。A &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACKは、&lt;/a&gt;スキーマは、トランザクションがロールバックさで変化させた場合、保留中の読み取り操作のみ失敗します。</target>
        </trans-unit>
        <trans-unit id="9776b801900694be8692d527b6b6a5014611c72c" translate="yes" xml:space="preserve">
          <source>The SQLITE_AFF_MASK portion of P5 must be an affinity character - SQLITE_AFF_TEXT, SQLITE_AFF_INTEGER, and so forth. An attempt is made to coerce both inputs according to this affinity before the comparison is made. If the SQLITE_AFF_MASK is 0x00, then numeric affinity is used. Note that the affinity conversions are stored back into the input registers P1 and P3. So this opcode can cause persistent changes to registers P1 and P3.</source>
          <target state="translated">P5 の SQLITE_AFF_MASK 部分は、SQLITE_AFF_TEXT、SQLITE_AFF_INTEGER などの親和性文字でなければなりません。比較が行われる前に、この親和性に従って両方の入力を強制するように試みます。SQLITE_AFF_MASKが0x00の場合、数値の親和性が使用されます。アフィニティ変換は入力レジスタP1とP3に格納されることに注意してください。そのため、このオペコードはレジスタP1とP3に永続的な変更を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="dfa8cf2714776524ecdde2f427b30f632065e986" translate="yes" xml:space="preserve">
          <source>The SQLITE_AUTH error is returned when the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; indicates that an SQL statement being prepared is not authorized.</source>
          <target state="translated">SQLITE_AUTHエラーは、準備中のSQLステートメントが承認されていないことを&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;承認者コールバックが&lt;/a&gt;示したときに返されます。</target>
        </trans-unit>
        <trans-unit id="a716819bd21e33b0b83c8f1def818df42717b54a" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY result code differs from &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; in that SQLITE_BUSY indicates a conflict with a separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;, probably in a separate process, whereas &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; indicates a conflict within the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; (or sometimes a database connection with a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;).</source>
          <target state="translated">SQLITE_BUSY結果コードは&lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;とは異なります。SQLITE_BUSYは別の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;との競合（おそらく別のプロセス内）を示し、&lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;は同じ&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;（または場合によっては&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュ&lt;/a&gt;とのデータベース接続）内の競合を示します。</target>
        </trans-unit>
        <trans-unit id="6847ec78063b3fe6af5cc42bad60bb51ac404849" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY result code indicates that the database file could not be written (or in some cases read) because of concurrent activity by some other &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;, usually a database connection in a separate process.</source>
          <target state="translated">SQLITE_BUSY結果コードは、他の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;（通常は別のプロセスのデータベース接続）による同時アクティビティが原因で、データベースファイルの書き込み（または場合によっては読み取り）ができなかったことを示しています。</target>
        </trans-unit>
        <trans-unit id="3cfe6b580ae13113f460c28fc71a7b4dbcf6c75a" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY_RECOVERY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; that indicates that an operation could not continue because another process is busy recovering a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database file following a crash. The SQLITE_BUSY_RECOVERY error code only occurs on &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; databases.</source>
          <target state="translated">SQLITE_BUSY_RECOVERYエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;別のプロセスが回復ビジー状態であるため、操作を継続できなかったことを示します&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;クラッシュ後のデータベースファイルを。SQLITE_BUSY_RECOVERYエラーコードは、&lt;a href=&quot;wal&quot;&gt;WALモードの&lt;/a&gt;データベースでのみ発生します。</target>
        </trans-unit>
        <trans-unit id="fc5599d49b00bbca3062bad1e4d863f9643aada6" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY_SNAPSHOT error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; that occurs on &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; databases when a database connection tries to promote a read transaction into a write transaction but finds that another &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has already written to the database and thus invalidated prior reads.</source>
          <target state="translated">SQLITE_BUSY_SNAPSHOTエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;で発生&lt;a href=&quot;wal&quot;&gt;WALモードの&lt;/a&gt;データベース接続が別のことを書き込みトランザクションが、発見に読み取りトランザクションを促進しようとすると、データベース&lt;a href=&quot;c3ref/sqlite3&quot;&gt;、データベース接続が&lt;/a&gt;既にデータベースに書き込まれ、前の読み取りので無効化しています。</target>
        </trans-unit>
        <trans-unit id="9ff4a95f8927914c1763adf9045af4ab62d2f754" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN result code indicates that SQLite was unable to open a file. The file in question might be a primary database file or one of several &lt;a href=&quot;tempfiles&quot;&gt;temporary disk files&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CANTOPEN結果コードは、SQLiteがファイルを開くことができなかったことを示します。問題のファイルは、プライマリデータベースファイルまたはいくつかの&lt;a href=&quot;tempfiles&quot;&gt;一時ディスクファイルの&lt;/a&gt; 1つである可能性があります。</target>
        </trans-unit>
        <trans-unit id="500408920c5afff76382c31e4489f9ce53192205" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_CONVPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; used only by Cygwin &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; and indicating that the cygwin_conv_path() system call failed while trying to open a file. See also: &lt;a href=&quot;rescode#ioerr_convpath&quot;&gt;SQLITE_IOERR_CONVPATH&lt;/a&gt;</source>
          <target state="translated">SQLITE_CANTOPEN_CONVPATHエラーコードは、Cygwin &lt;a href=&quot;vfs&quot;&gt;VFSで&lt;/a&gt;のみ使用される&lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPENの&lt;/a&gt;&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;であり、ファイルを開こうとしたときにcygwin_conv_path（）システムコールが失敗したことを示します。参照：&lt;a href=&quot;rescode#ioerr_convpath&quot;&gt;SQLITE_IOERR_CONVPATH&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="55203070958c2991ba87f3b32bd40d536d90189a" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_DIRTYWAL result code is not used at this time.</source>
          <target state="translated">SQLITE_CANTOPEN_DIRTYWALの結果コードは、現時点では使用していません。</target>
        </trans-unit>
        <trans-unit id="13b8dd7bacea04f63a2cb5fbae43d894d6332998" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_FULLPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; indicating that a file open operation failed because the operating system was unable to convert the filename into a full pathname.</source>
          <target state="translated">SQLITE_CANTOPEN_FULLPATHエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;オペレーティングシステムが完全パス名にファイル名を変換することができなかったため、ファイルオープン動作が失敗したことを示します。</target>
        </trans-unit>
        <trans-unit id="c1b7e5d009e56aefb1e5fa74fb773f95be397ef4" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_ISDIR error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; indicating that a file open operation failed because the file is really a directory.</source>
          <target state="translated">SQLITE_CANTOPEN_ISDIRエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;ファイルが実際にディレクトリであるため、ファイルのオープン操作が失敗したことを示します。</target>
        </trans-unit>
        <trans-unit id="3ff11cefb3f88aae4a84bf8291076f3bac03ede6" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_NOTEMPDIR error code is no longer used.</source>
          <target state="translated">SQLITE_CANTOPEN_NOTEMPDIRのエラーコードが使用されなくなりました。</target>
        </trans-unit>
        <trans-unit id="06f769e27f147dfdd680f8a17a2bfe539caf9796" translate="yes" xml:space="preserve">
          <source>The SQLITE_CHECKPOINT_FULL, RESTART and TRUNCATE modes also obtain the exclusive &quot;writer&quot; lock on the database file. If the writer lock cannot be obtained immediately, and a busy-handler is configured, it is invoked and the writer lock retried until either the busy-handler returns 0 or the lock is successfully obtained. The busy-handler is also invoked while waiting for database readers as described above. If the busy-handler returns 0 before the writer lock is obtained or while waiting for database readers, the checkpoint operation proceeds from that point in the same way as SQLITE_CHECKPOINT_PASSIVE - checkpointing as many frames as possible without blocking any further. SQLITE_BUSY is returned in this case.</source>
          <target state="translated">SQLITE_CHECKPOINT_FULL、RESTART、およびTRUNCATEモードは、データベースファイル上の排他的な &quot;ライタ &quot;ロックも取得します。ライタロックをすぐに取得できず、ビジーハンドラが設定されている場合、ビジーハンドラが0を返すか、ロックが正常に取得されるまで、ビジーハンドラが呼び出され、ライタロックが再試行されます。また、ビジーハンドラは、上述のようにデータベース・リーダを待っている間にも呼び出されます。ライターロックが取得される前、またはデータベースリーダを待っている間にビジーハンドラが0を返した場合、チェックポイント操作はその時点からSQLITE_CHECKPOINT_PASSIVEと同じ方法で進行します-それ以上ブロックすることなく可能な限り多くのフレームをチェックポイントします。この場合、SQLITE_BUSYが返されます。</target>
        </trans-unit>
        <trans-unit id="5f7466fb166d62399d9f0072e0370315299af5b1" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_COVERING_INDEX_SCAN option takes a single integer argument which is interpreted as a boolean in order to enable or disable the use of covering indices for full table scans in the query optimizer. The default setting is determined by the &lt;a href=&quot;../compile#allow_covering_index_scan&quot;&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN&lt;/a&gt; compile-time option, or is &quot;on&quot; if that compile-time option is omitted. The ability to disable the use of covering indices for full table scans is because some incorrectly coded legacy applications might malfunction when the optimization is enabled. Providing the ability to disable the optimization allows the older, buggy application code to work without change even with newer versions of SQLite.</source>
          <target state="translated">SQLITE_CONFIG_COVERING_INDEX_SCANオプションは、クエリオプティマイザで全テーブルスキャンのカバーするインデックスの使用を有効または無効にするためにブール値として解釈される単一の整数引数を取ります。デフォルト設定は、&lt;a href=&quot;../compile#allow_covering_index_scan&quot;&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN&lt;/a&gt;コンパイル時オプションによって決定されるか、そのコンパイル時オプションが省略されている場合は「オン」です。フルテーブルスキャンのカバリングインデックスの使用を無効にする機能は、最適化を有効にすると、一部の誤ってコーディングされたレガシーアプリケーションが誤動作する可能性があるためです。最適化を無効にする機能を提供することで、SQLiteの新しいバージョンでも、古いバグのあるアプリケーションコードを変更せずに機能させることができます。</target>
        </trans-unit>
        <trans-unit id="7d7ecdbc601a4823c2b08a2a5337606f8d30aa46" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_COVERING_INDEX_SCAN option takes a single integer argument which is interpreted as a boolean in order to enable or disable the use of covering indices for full table scans in the query optimizer. The default setting is determined by the &lt;a href=&quot;compile#allow_covering_index_scan&quot;&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN&lt;/a&gt; compile-time option, or is &quot;on&quot; if that compile-time option is omitted. The ability to disable the use of covering indices for full table scans is because some incorrectly coded legacy applications might malfunction when the optimization is enabled. Providing the ability to disable the optimization allows the older, buggy application code to work without change even with newer versions of SQLite.</source>
          <target state="translated">SQLITE_CONFIG_COVERING_INDEX_SCANオプションは、クエリオプティマイザで全テーブルスキャンのカバーするインデックスの使用を有効または無効にするためにブール値として解釈される単一の整数引数を取ります。デフォルト設定は、&lt;a href=&quot;compile#allow_covering_index_scan&quot;&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN&lt;/a&gt;コンパイル時オプションによって決定されるか、そのコンパイル時オプションが省略されている場合は「オン」です。フルテーブルスキャンのカバリングインデックスの使用を無効にする機能は、最適化を有効にすると、一部の誤ってコーディングされたレガシーアプリケーションが誤動作する可能性があるためです。最適化を無効にする機能を提供することで、SQLiteの新しいバージョンでも、古いバグのあるアプリケーションコードを変更せずに機能させることができます。</target>
        </trans-unit>
        <trans-unit id="ff83d1ba90843c7f9c3dc720386b86f9f35e0379" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure is filled with the currently defined memory allocation routines. This option can be used to overload the default memory allocation routines with a wrapper that simulations memory allocation failure or tracks memory usage, for example.</source>
          <target state="translated">SQLITE_CONFIG_GETMALLOCオプションは、&lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;構造体のインスタンスへのポインターである単一の引数を取ります。&lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methodsの&lt;/a&gt;構造は、現在定義されているメモリ割り当てルーチンで満たされています。このオプションを使用すると、デフォルトのメモリ割り当てルーチンを、メモリ割り当ての失敗をシミュレーションしたり、メモリ使用量を追跡したりするラッパーでオーバーロードできます。</target>
        </trans-unit>
        <trans-unit id="27c7cd5a1eddca0fbdae5b53b4edcfcd1711ca82" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure is filled with the currently defined memory allocation routines. This option can be used to overload the default memory allocation routines with a wrapper that simulations memory allocation failure or tracks memory usage, for example.</source>
          <target state="translated">SQLITE_CONFIG_GETMALLOCオプションは、&lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;構造体のインスタンスへのポインターである単一の引数を取ります。&lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methodsの&lt;/a&gt;構造は、現在定義されているメモリ割り当てルーチンで満たされています。このオプションを使用すると、デフォルトのメモリ割り当てルーチンを、メモリ割り当ての失敗をシミュレーションしたり、メモリ使用量を追跡したりするラッパーでオーバーロードできます。</target>
        </trans-unit>
        <trans-unit id="be1078933a2f48f4ba63fb92d6b093d628661727" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure is filled with the currently defined mutex routines. This option can be used to overload the default mutex allocation routines with a wrapper used to track mutex usage for performance profiling or testing, for example. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_GETMUTEX configuration option will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONFIG_GETMUTEXオプションは、&lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt;構造体のインスタンスへのポインターである単一の引数を取ります。&lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methodsの&lt;/a&gt;構造は、現在定義されているミューテックス・ルーチンで満たされています。このオプションを使用すると、パフォーマンスのプロファイリングやテストなどのミューテックスの使用状況を追跡するために使用されるラッパーで、デフォルトのミューテックス割り当てルーチンをオーバーロードできます。 SQLiteが&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;コンパイル時オプションでコンパイルされている場合、ミューテックスサブシステム全体がビルドから省略されるため、SQLITE_CONFIG_GETMUTEX構成オプションを指定して&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;を呼び出すと、SQLITE_ERRORが返され&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4910d5633ae70fa15de2ae4b340873caa0f78feb" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure is filled with the currently defined mutex routines. This option can be used to overload the default mutex allocation routines with a wrapper used to track mutex usage for performance profiling or testing, for example. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_GETMUTEX configuration option will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONFIG_GETMUTEXオプションは、&lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt;構造体のインスタンスへのポインターである単一の引数を取ります。&lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methodsの&lt;/a&gt;構造は、現在定義されているミューテックス・ルーチンで満たされています。このオプションを使用すると、パフォーマンスのプロファイリングやテストなどのミューテックスの使用状況を追跡するために使用されるラッパーで、デフォルトのミューテックス割り当てルーチンをオーバーロードできます。 SQLiteが&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;コンパイル時オプションでコンパイルされている場合、ミューテックスサブシステム全体がビルドから省略されるため、SQLITE_CONFIG_GETMUTEX構成オプションを指定して&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;を呼び出すと、SQLITE_ERRORが返され&lt;a href=&quot;../rescode#error&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="480ac6642108db12dacb128d029ff61248587e74" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETPCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. SQLite copies of the current page cache implementation into that object.</source>
          <target state="translated">SQLITE_CONFIG_GETPCACHE2オプションは、&lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt;オブジェクトへのポインターである単一の引数を取ります。現在のページキャッシュ実装のSQLiteコピーをそのオブジェクトにコピーします。</target>
        </trans-unit>
        <trans-unit id="d15656e2a537c4d062ffc1a4a28c224d21946fb5" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETPCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. SQLite copies of the current page cache implementation into that object.</source>
          <target state="translated">SQLITE_CONFIG_GETPCACHE2オプションは、&lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt;オブジェクトへのポインターである単一の引数を取ります。現在のページキャッシュ実装のSQLiteコピーをそのオブジェクトにコピーします。</target>
        </trans-unit>
        <trans-unit id="41bf906d256dc3dcf8d1b8d18fc31630de1f686b" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_HEAP option specifies a static memory buffer that SQLite will use for all of its dynamic memory allocation needs beyond those provided for by &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The SQLITE_CONFIG_HEAP option is only available if SQLite is compiled with either &lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; or &lt;a href=&quot;compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; and returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if invoked otherwise. There are three arguments to SQLITE_CONFIG_HEAP: An 8-byte aligned pointer to the memory, the number of bytes in the memory buffer, and the minimum allocation size. If the first pointer (the memory pointer) is NULL, then SQLite reverts to using its default memory allocator (the system malloc() implementation), undoing any prior invocation of &lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;. If the memory pointer is not NULL then the alternative memory allocator is engaged to handle all of SQLites memory allocation needs. The first pointer (the memory pointer) must be aligned to an 8-byte boundary or subsequent behavior of SQLite will be undefined. The minimum allocation size is capped at 2**12. Reasonable values for the minimum allocation size are 2**5 through 2**8.</source>
          <target state="translated">SQLITE_CONFIG_HEAPオプションは、&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITEがSQLITE_CONFIG_PAGECACHE&lt;/a&gt;によって提供されるものを超える動的メモリ割り当てのすべてのニーズに使用する静的メモリバッファを指定します。 SQLiteのは、どちらかでコンパイルされている場合SQLITE_CONFIG_HEAPオプションにのみ使用可能です&lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt;または&lt;a href=&quot;compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt;戻り&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;そう呼び出された場合。 SQLITE_CONFIG_HEAPには3つの引数があります。メモリへの8バイト境界で整列されたポインタ、メモリバッファのバイト数、および最小割り当てサイズです。最初のポインタ（メモリポインタ）がNULLの場合、SQLiteはデフォルトのメモリアロケータ（システムのmalloc（）実装）の使用に戻り、&lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOCの&lt;/a&gt;以前の呼び出しをすべて取り消します。。メモリポインタがNULLでない場合、代替メモリアロケータがSQLitesのメモリ割り当てニーズのすべてを処理するために使用されています。最初のポインター（メモリポインター）は8バイト境界に揃える必要があります。そうしないと、SQLiteのその後の動作は定義されません。最小割り当てサイズの上限は2 ** 12です。最小割り当てサイズの妥当な値は2 ** 5から2 ** 8です。</target>
        </trans-unit>
        <trans-unit id="3fe54eb9feb326e6993f5e80b5d7f631fea68373" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_HEAP option specifies a static memory buffer that SQLite will use for all of its dynamic memory allocation needs beyond those provided for by &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The SQLITE_CONFIG_HEAP option is only available if SQLite is compiled with either &lt;a href=&quot;../compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; or &lt;a href=&quot;../compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; and returns &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if invoked otherwise. There are three arguments to SQLITE_CONFIG_HEAP: An 8-byte aligned pointer to the memory, the number of bytes in the memory buffer, and the minimum allocation size. If the first pointer (the memory pointer) is NULL, then SQLite reverts to using its default memory allocator (the system malloc() implementation), undoing any prior invocation of &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;. If the memory pointer is not NULL then the alternative memory allocator is engaged to handle all of SQLites memory allocation needs. The first pointer (the memory pointer) must be aligned to an 8-byte boundary or subsequent behavior of SQLite will be undefined. The minimum allocation size is capped at 2**12. Reasonable values for the minimum allocation size are 2**5 through 2**8.</source>
          <target state="translated">SQLITE_CONFIG_HEAPオプションは、&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITEがSQLITE_CONFIG_PAGECACHE&lt;/a&gt;によって提供されるものを超える動的メモリ割り当てのすべてのニーズに使用する静的メモリバッファを指定します。 SQLiteのは、どちらかでコンパイルされている場合SQLITE_CONFIG_HEAPオプションにのみ使用可能です&lt;a href=&quot;../compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt;または&lt;a href=&quot;../compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt;戻り&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;そう呼び出された場合。 SQLITE_CONFIG_HEAPには3つの引数があります。メモリへの8バイト境界で整列されたポインタ、メモリバッファのバイト数、および最小割り当てサイズです。最初のポインタ（メモリポインタ）がNULLの場合、SQLiteはデフォルトのメモリアロケータ（システムのmalloc（）実装）の使用に戻り、&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOCの&lt;/a&gt;以前の呼び出しをすべて取り消します。。メモリポインタがNULLでない場合、代替メモリアロケータがSQLitesのメモリ割り当てニーズのすべてを処理するために使用されています。最初のポインター（メモリポインター）は8バイト境界に揃える必要があります。そうしないと、SQLiteのその後の動作は定義されません。最小割り当てサイズの上限は2 ** 12です。最小割り当てサイズの妥当な値は2 ** 5から2 ** 8です。</target>
        </trans-unit>
        <trans-unit id="01d248a0a82b03a7f001692e75d24ae19d015766" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOG option is used to configure the SQLite global &lt;a href=&quot;../errlog&quot;&gt;error log&lt;/a&gt;. (The SQLITE_CONFIG_LOG option takes two arguments: a pointer to a function with a call signature of void(*)(void*,int,const char*), and a pointer to void. If the function pointer is not NULL, it is invoked by &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; to process each logging event. If the function pointer is NULL, the &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; interface becomes a no-op. The void pointer that is the second argument to SQLITE_CONFIG_LOG is passed through as the first parameter to the application-defined logger function whenever that function is invoked. The second parameter to the logger function is a copy of the first parameter to the corresponding &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; call and is intended to be a &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result code&lt;/a&gt;. The third parameter passed to the logger is log message after formatting via &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt;. The SQLite logging interface is not reentrant; the logger function supplied by the application must not invoke any SQLite interface. In a multi-threaded application, the application-defined logger function must be threadsafe.</source>
          <target state="translated">SQLITE_CONFIG_LOGオプションは、SQLiteグローバル&lt;a href=&quot;../errlog&quot;&gt;エラーログ&lt;/a&gt;を構成するために使用されます。 （SQLITE_CONFIG_LOGオプションは2つの引数を取ります：void（*）（void *、int、const char *）の呼び出しシグネチャを持つ関数へのポインターとvoidへのポインター。関数ポインターがNULLでない場合、呼び出されます&lt;a href=&quot;log&quot;&gt;sqlite3_log（）&lt;/a&gt;によって各ロギングイベントを処理します。関数ポインタがNULLの場合、&lt;a href=&quot;log&quot;&gt;sqlite3_log（）&lt;/a&gt;インターフェースは何もしません。SQLITE_CONFIG_LOGの2番目の引数であるvoidポインタは、最初のパラメータとしてアプリケーション定義に渡されますロガー関数が呼び出されたときは常に、ロガー関数。ロガー関数の2番目のパラメーターは、対応する&lt;a href=&quot;log&quot;&gt;sqlite3_log（）&lt;/a&gt;呼び出しへの最初のパラメーターのコピーであり、&lt;a href=&quot;../rescode&quot;&gt;結果コード&lt;/a&gt;または&lt;a href=&quot;../rescode#extrc&quot;&gt;拡張結果コード&lt;/a&gt;。ロガーに渡される3番目のパラメーターは、&lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf（）で&lt;/a&gt;フォーマットした後のログメッセージです。 SQLiteロギングインターフェイスは再入可能ではありません。アプリケーションによって提供されるロガー関数は、SQLiteインターフェースを呼び出してはなりません。マルチスレッドアプリケーションでは、アプリケーション定義のロガー関数はスレッドセーフでなければなりません。</target>
        </trans-unit>
        <trans-unit id="59e287bb60474979eb8cefde91438388d0375975" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOG option is used to configure the SQLite global &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt;. (The SQLITE_CONFIG_LOG option takes two arguments: a pointer to a function with a call signature of void(*)(void*,int,const char*), and a pointer to void. If the function pointer is not NULL, it is invoked by &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; to process each logging event. If the function pointer is NULL, the &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; interface becomes a no-op. The void pointer that is the second argument to SQLITE_CONFIG_LOG is passed through as the first parameter to the application-defined logger function whenever that function is invoked. The second parameter to the logger function is a copy of the first parameter to the corresponding &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; call and is intended to be a &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended result code&lt;/a&gt;. The third parameter passed to the logger is log message after formatting via &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt;. The SQLite logging interface is not reentrant; the logger function supplied by the application must not invoke any SQLite interface. In a multi-threaded application, the application-defined logger function must be threadsafe.</source>
          <target state="translated">SQLITE_CONFIG_LOGオプションは、SQLiteグローバル&lt;a href=&quot;errlog&quot;&gt;エラーログ&lt;/a&gt;を構成するために使用されます。 （SQLITE_CONFIG_LOGオプションは2つの引数を取ります：void（*）（void *、int、const char *）の呼び出しシグネチャを持つ関数へのポインターとvoidへのポインター。関数ポインターがNULLでない場合、呼び出されます&lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log（）&lt;/a&gt;によって各ロギングイベントを処理します。関数ポインタがNULLの場合、&lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log（）&lt;/a&gt;インターフェースは何もしません。SQLITE_CONFIG_LOGの2番目の引数であるvoidポインタは、最初のパラメータとしてアプリケーション定義に渡されますロガー関数が呼び出されたときは常に、ロガー関数。ロガー関数の2番目のパラメーターは、対応する&lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log（）&lt;/a&gt;呼び出しへの最初のパラメーターのコピーであり、&lt;a href=&quot;rescode&quot;&gt;結果コード&lt;/a&gt;または&lt;a href=&quot;rescode#extrc&quot;&gt;拡張結果コード&lt;/a&gt;。ロガーに渡される3番目のパラメーターは、&lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf（）で&lt;/a&gt;フォーマットした後のログメッセージです。 SQLiteロギングインターフェイスは再入可能ではありません。アプリケーションによって提供されるロガー関数は、SQLiteインターフェースを呼び出してはなりません。マルチスレッドアプリケーションでは、アプリケーション定義のロガー関数はスレッドセーフでなければなりません。</target>
        </trans-unit>
        <trans-unit id="ab0156b86adc81defa456094d6dda8a22884243b" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOOKASIDE option takes two arguments that determine the default size of lookaside memory on each &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument is the size of each lookaside buffer slot and the second is the number of slots allocated to each database connection. SQLITE_CONFIG_LOOKASIDE sets the</source>
          <target state="translated">SQLITE_CONFIG_LOOKASIDEオプションは、各&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続の&lt;/a&gt;ルックアサイドメモリのデフォルトサイズを決定する2つの引数を取ります。最初の引数は各lookasideバッファースロットのサイズで、2番目の引数は各データベース接続に割り当てられたスロットの数です。SQLITE_CONFIG_LOOKASIDEは、</target>
        </trans-unit>
        <trans-unit id="517e0ab9da5cb1067d00b2d40dff6d21a15492c5" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOOKASIDE option takes two arguments that determine the default size of lookaside memory on each &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument is the size of each lookaside buffer slot and the second is the number of slots allocated to each database connection. SQLITE_CONFIG_LOOKASIDE sets the</source>
          <target state="translated">SQLITE_CONFIG_LOOKASIDEオプションは、各&lt;a href=&quot;sqlite3&quot;&gt;データベース接続の&lt;/a&gt;ルックアサイドメモリのデフォルトサイズを決定する2つの引数を取ります。最初の引数は各lookasideバッファースロットのサイズで、2番目の引数は各データベース接続に割り当てられたスロットの数です。SQLITE_CONFIG_LOOKASIDEは、</target>
        </trans-unit>
        <trans-unit id="5f5ea304960d2945164c69cf799e956ea26314e7" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The argument specifies alternative low-level memory allocation routines to be used in place of the memory allocation routines built into SQLite. SQLite makes its own private copy of the content of the &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure before the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; call returns.</source>
          <target state="translated">SQLITE_CONFIG_MALLOCオプションは、&lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;構造体のインスタンスへのポインターである単一の引数を取ります。引数は、SQLiteに組み込まれたメモリ割り当てルーチンの代わりに使用される代替の低レベルメモリ割り当てルーチンを指定します。 SQLiteは、&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;呼び出しが戻る前に、&lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;構造体のコンテンツの独自のプライベートコピーを作成します。</target>
        </trans-unit>
        <trans-unit id="212fa0cc6b6461ceacd5f53dcf7fed283b480c6d" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The argument specifies alternative low-level memory allocation routines to be used in place of the memory allocation routines built into SQLite. SQLite makes its own private copy of the content of the &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure before the &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; call returns.</source>
          <target state="translated">SQLITE_CONFIG_MALLOCオプションは、&lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;構造体のインスタンスへのポインターである単一の引数を取ります。引数は、SQLiteに組み込まれたメモリ割り当てルーチンの代わりに使用される代替の低レベルメモリ割り当てルーチンを指定します。 SQLiteは、&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;呼び出しが戻る前に、&lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;構造体のコンテンツの独自のプライベートコピーを作成します。</target>
        </trans-unit>
        <trans-unit id="a0f6142b40b1216838367535e150c109342d48bb" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MEMDB_MAXSIZE option accepts a single parameter &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; parameter which is the default maximum size for an in-memory database created using &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt;. This default maximum size can be adjusted up or down for individual databases using the &lt;a href=&quot;#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file-control&lt;/a&gt;. If this configuration setting is never used, then the default maximum is determined by the &lt;a href=&quot;compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt; compile-time option. If that compile-time option is not set, then the default maximum is 1073741824.</source>
          <target state="translated">SQLITE_CONFIG_MEMDB_MAXSIZEオプションは、&lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize（）&lt;/a&gt;を使用して作成されたメモリ内データベースのデフォルトの最大サイズである単一のパラメーター&lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt;パラメーターを受け入れます。このデフォルトの最大サイズは、&lt;a href=&quot;#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT &lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file-control&lt;/a&gt;を使用して、個々のデータベースに対して上下に調整できます。この構成設定が使用されない場合、デフォルトの最大値は&lt;a href=&quot;compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt;コンパイル時オプションによって決定されます。そのコンパイル時オプションが設定されていない場合、デフォルトの最大値は1073741824です。</target>
        </trans-unit>
        <trans-unit id="81e7b78f6947d183a3f90000da914d03e1bc727e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MEMDB_MAXSIZE option accepts a single parameter &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; parameter which is the default maximum size for an in-memory database created using &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt;. This default maximum size can be adjusted up or down for individual databases using the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;file-control&lt;/a&gt;. If this configuration setting is never used, then the default maximum is determined by the &lt;a href=&quot;../compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt; compile-time option. If that compile-time option is not set, then the default maximum is 1073741824.</source>
          <target state="translated">SQLITE_CONFIG_MEMDB_MAXSIZEオプションは、&lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize（）&lt;/a&gt;を使用して作成されたメモリ内データベースのデフォルトの最大サイズである単一のパラメーター&lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt;パラメーターを受け入れます。このデフォルトの最大サイズは、&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT &lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;file-control&lt;/a&gt;を使用して、個々のデータベースに対して上下に調整できます。この構成設定が使用されない場合、デフォルトの最大値は&lt;a href=&quot;../compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt;コンパイル時オプションによって決定されます。そのコンパイル時オプションが設定されていない場合、デフォルトの最大値は1073741824です。</target>
        </trans-unit>
        <trans-unit id="0f876ee04fb467dec2e88424ad542eb53469ec0b" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MEMSTATUS option takes single argument of type int, interpreted as a boolean, which enables or disables the collection of memory allocation statistics. When memory allocation statistics are disabled, the following SQLite interfaces become non-operational:</source>
          <target state="translated">SQLITE_CONFIG_MEMSTATUS オプションは int 型の単一の引数を取り、ブーリアンとして解釈されます。メモリ割り当て統計情報が無効になっている場合、以下の SQLite インターフェースは動作しなくなります。</target>
        </trans-unit>
        <trans-unit id="c9d36e0270700e44060555bf77969beca0ef1bb6" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The argument specifies alternative low-level mutex routines to be used in place the mutex routines built into SQLite. SQLite makes a copy of the content of the &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure before the call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; returns. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_MUTEX configuration option will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONFIG_MUTEXオプションは、&lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt;構造体のインスタンスへのポインターである単一の引数を取ります。引数は、SQLiteに組み込まれたmutexルーチンの代わりに使用される代替の低レベルmutexルーチンを指定します。 SQLiteは、&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;への呼び出しが戻る前に、&lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt;構造の内容のコピーを作成します。 SQLiteが&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;コンパイル時オプションでコンパイルされている場合、ミューテックスサブシステム全体がビルドから省略されるため、SQLITE_CONFIG_MUTEX構成オプションで&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;を呼び出すと、SQLITE_ERRORが返され&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b773ada2ea4912cbbe3a1e1cebfe063f6d8a1c0" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The argument specifies alternative low-level mutex routines to be used in place the mutex routines built into SQLite. SQLite makes a copy of the content of the &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure before the call to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; returns. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_MUTEX configuration option will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONFIG_MUTEXオプションは、&lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt;構造体のインスタンスへのポインターである単一の引数を取ります。引数は、SQLiteに組み込まれたmutexルーチンの代わりに使用される代替の低レベルmutexルーチンを指定します。 SQLiteは、&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;への呼び出しが戻る前に、&lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt;構造の内容のコピーを作成します。 SQLiteが&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;コンパイル時オプションでコンパイルされている場合、ミューテックスサブシステム全体がビルドから省略されるため、SQLITE_CONFIG_MUTEX構成オプションで&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;を呼び出すと、SQLITE_ERRORが返され&lt;a href=&quot;../rescode#error&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="09e3ca8fa4415d94f70fc44a6276555caf14748e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-define page cache implementation is loaded using the &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="translated">SQLITE_CONFIG_PAGECACHEオプションは、SQLiteがデフォルトのページキャッシュ実装でデータベースページキャッシュに使用できるメモリプールを指定します。アプリケーション定義のページキャッシュ実装が&lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;を使用してロードされている場合、この構成オプションは何もしません。 SQLITE_CONFIG_PAGECACHEには3つの引数があります。8バイト境界整列メモリ（pMem）へのポインター、各ページキャッシュラインのサイズ（sz）、およびキャッシュラインの数（N）。 sz引数は、最大のデータベースページのサイズ（512から65536の間の2の累乗）に各ページヘッダーの追加バイトを加えたものでなければなりません。ページヘッダーに必要な追加のバイト数は、&lt;a href=&quot;#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;を使用して決定できます。。メモリの浪費は別として、szパラメータが必要以上に大きくなることは無害です。 pMem引数は、NULLポインタまたは少なくともsz * Nバイトのメモリの8バイト境界で整列されたブロックへのポインタである必要があります。それ以外の場合の動作は未定義です。 pMemがNULLでない場合、SQLiteは提供されたメモリを使用してページキャッシュのニーズを満たすように努め、ページキャッシュラインがszバイトより大きい場合、またはすべてのpMemバッファーが使い果たされた場合、&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）に&lt;/a&gt;フォールバックします。 pMemがNULLでNがゼロ以外の場合、各データベース接続は&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;からページキャッシュメモリの初期一括割り当てを行いますNが正の場合はNキャッシュラインに十分、Nが負の場合は-1024 * Nバイト。最初の割り当てで提供されるもの以外に追加のページキャッシュメモリが必要な場合、SQLiteは追加のキャッシュラインごとに個別に&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;に移動します。</target>
        </trans-unit>
        <trans-unit id="cc50296996fcaf95f25672cd009256aa14c36a0e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-define page cache implementation is loaded using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="translated">SQLITE_CONFIG_PAGECACHEオプションは、SQLiteがデフォルトのページキャッシュ実装でデータベースページキャッシュに使用できるメモリプールを指定します。アプリケーション定義のページキャッシュ実装が&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;を使用してロードされている場合、この構成オプションは何もしません。 SQLITE_CONFIG_PAGECACHEには3つの引数があります。8バイト境界整列メモリ（pMem）へのポインター、各ページキャッシュラインのサイズ（sz）、およびキャッシュラインの数（N）。 sz引数は、最大のデータベースページのサイズ（512から65536の間の2の累乗）に各ページヘッダーの追加バイトを加えたものでなければなりません。ページヘッダーに必要な追加のバイト数は、&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;を使用して決定できます。。メモリの浪費は別として、szパラメータが必要以上に大きくなることは無害です。 pMem引数は、NULLポインタまたは少なくともsz * Nバイトのメモリの8バイト境界で整列されたブロックへのポインタである必要があります。それ以外の場合の動作は未定義です。 pMemがNULLでない場合、SQLiteは提供されたメモリを使用してページキャッシュのニーズを満たすように努め、ページキャッシュラインがszバイトより大きい場合、またはすべてのpMemバッファーが使い果たされた場合、&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）に&lt;/a&gt;フォールバックします。 pMemがNULLでNがゼロ以外の場合、各データベース接続は&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;からページキャッシュメモリの初期一括割り当てを行いますNが正の場合はNキャッシュラインに十分、Nが負の場合は-1024 * Nバイト。最初の割り当てで提供されるもの以外に追加のページキャッシュメモリが必要な場合、SQLiteは追加のキャッシュラインごとに個別に&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;に移動します。</target>
        </trans-unit>
        <trans-unit id="373c6de3bbf7db29ed258a5d09d9109fe9568cc5" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-defined page cache implementation is loaded using the &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="translated">SQLITE_CONFIG_PAGECACHEオプションは、SQLiteがデフォルトのページキャッシュ実装でデータベースページキャッシュに使用できるメモリプールを指定します。&lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;を使用してアプリケーション定義のページキャッシュ実装がロードされる場合、この構成オプションは何もしません。 SQLITE_CONFIG_PAGECACHEには、8バイトの整列メモリ（pMem）へのポインタ、各ページキャッシュラインのサイズ（sz）、およびキャッシュラインの数（N）の3つの引数があります。 sz引数は、最大のデータベースページのサイズ（512〜65536の2の累乗）に各ページヘッダーの追加バイトを加えたものである必要があります。ページヘッダーに必要な追加バイト数は、&lt;a href=&quot;#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;を使用して決定できます。。 szパラメータが必要以上に大きくなることは、メモリの浪費を除けば無害です。 pMem引数は、NULLポインター、または少なくともsz * Nバイトの8バイトに整列されたメモリーブロックへのポインターである必要があります。そうでない場合、その後の動作は定義されません。 pMemがNULLでない場合、SQLiteは、ページキャッシュのニーズを満たすために提供されたメモリを使用するように努め、ページキャッシュラインがszバイトより大きい場合、またはすべてのpMemバッファーが使い果たされた場合、&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）に&lt;/a&gt;フォールバックします。 pMemがNULLで、Nがゼロ以外の場合、各データベース接続は&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;からページキャッシュメモリの初期バルク割り当てを行います。Nが正の場合はN個のキャッシュラインに、Nが負の場合は-1024 * Nバイトで十分です。初期割り当てによって提供されるものを超えて追加のページキャッシュメモリが必要な場合、SQLiteは追加のキャッシュラインごとに個別に&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;に移動します。</target>
        </trans-unit>
        <trans-unit id="fe2e2404fd6d076f4a9442bd42821a9709933fc2" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-defined page cache implementation is loaded using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="translated">SQLITE_CONFIG_PAGECACHEオプションは、SQLiteがデフォルトのページキャッシュ実装でデータベースページキャッシュに使用できるメモリプールを指定します。&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;を使用してアプリケーション定義のページキャッシュ実装がロードされる場合、この構成オプションは何もしません。 SQLITE_CONFIG_PAGECACHEには、8バイトの整列メモリ（pMem）へのポインタ、各ページキャッシュラインのサイズ（sz）、およびキャッシュラインの数（N）の3つの引数があります。 sz引数は、最大のデータベースページのサイズ（512〜65536の2の累乗）に各ページヘッダーの追加バイトを加えたものである必要があります。ページヘッダーに必要な追加バイト数は、&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;を使用して決定できます。。 szパラメータが必要以上に大きくなることは、メモリの浪費を除けば無害です。 pMem引数は、NULLポインター、または少なくともsz * Nバイトの8バイトに整列されたメモリーブロックへのポインターである必要があります。そうでない場合、その後の動作は定義されません。 pMemがNULLでない場合、SQLiteは、ページキャッシュのニーズを満たすために提供されたメモリを使用するように努め、ページキャッシュラインがszバイトより大きい場合、またはすべてのpMemバッファーが使い果たされた場合、&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）に&lt;/a&gt;フォールバックします。 pMemがNULLで、Nがゼロ以外の場合、各データベース接続は&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;からページキャッシュメモリの初期バルク割り当てを行います。Nが正の場合はN個のキャッシュラインに、Nが負の場合は-1024 * Nバイトで十分です。初期割り当てによって提供されるものを超えて追加のページキャッシュメモリが必要な場合、SQLiteは追加のキャッシュラインごとに個別に&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;に移動します。</target>
        </trans-unit>
        <trans-unit id="1911f8a733a42d2b6026789f4ef363d83afb65d1" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. This object specifies the interface to a custom page cache implementation. SQLite makes a copy of the &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_CONFIG_PCACHE2オプションは、&lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt;オブジェクトへのポインターである単一の引数を取ります。このオブジェクトは、カスタムページキャッシュ実装へのインターフェイスを指定します。SQLiteは&lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt;オブジェクトのコピーを作成します。</target>
        </trans-unit>
        <trans-unit id="fe0c16b7c9692df379eddfaf23502a1d2deb56c4" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. This object specifies the interface to a custom page cache implementation. SQLite makes a copy of the &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_CONFIG_PCACHE2オプションは、&lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt;オブジェクトへのポインターである単一の引数を取ります。このオブジェクトは、カスタムページキャッシュ実装へのインターフェイスを指定します。SQLiteは&lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt;オブジェクトのコピーを作成します。</target>
        </trans-unit>
        <trans-unit id="8ecb0f208e89787f9a7f11980392d2014f2ef02a" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE_HDRSZ option takes a single parameter which is a pointer to an integer and writes into that integer the number of extra bytes per page required for each page in &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The amount of extra space required can change depending on the compiler, target platform, and SQLite version.</source>
          <target state="translated">SQLITE_CONFIG_PCACHE_HDRSZオプションは、整数へのポインタであり、各ページに必要なページあたりの余分なバイトの数整数それに書き込む単一のパラメータ取り&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHEを&lt;/a&gt;。必要な追加スペースの量は、コンパイラ、ターゲットプラットフォーム、およびSQLiteのバージョンによって異なります。</target>
        </trans-unit>
        <trans-unit id="efc57facbbb1ece8f5d6410e99a1c9a1fcbbbc32" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE_HDRSZ option takes a single parameter which is a pointer to an integer and writes into that integer the number of extra bytes per page required for each page in &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The amount of extra space required can change depending on the compiler, target platform, and SQLite version.</source>
          <target state="translated">SQLITE_CONFIG_PCACHE_HDRSZオプションは、整数へのポインタであり、各ページに必要なページあたりの余分なバイトの数整数それに書き込む単一のパラメータ取り&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHEを&lt;/a&gt;。必要な追加スペースの量は、コンパイラ、ターゲットプラットフォーム、およびSQLiteのバージョンによって異なります。</target>
        </trans-unit>
        <trans-unit id="c693040f9e2e760d6e4cb06df98665a33285d6df" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PMASZ option takes a single parameter which is an unsigned integer and sets the &quot;Minimum PMA Size&quot; for the multithreaded sorter to that integer. The default minimum PMA Size is set by the &lt;a href=&quot;../compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt; compile-time option. New threads are launched to help with sort operations when multithreaded sorting is enabled (using the &lt;a href=&quot;../pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command) and the amount of content to be sorted exceeds the page size times the minimum of the &lt;a href=&quot;../pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; setting and this value.</source>
          <target state="translated">SQLITE_CONFIG_PMASZオプションは、符号なし整数である単一のパラメーターを取り、マルチスレッドソーターの「最小PMAサイズ」をその整数に設定します。デフォルトの最小PMAサイズは、&lt;a href=&quot;../compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt;コンパイル時オプションによって設定されます。マルチスレッドの並べ替えが有効になっていて（&lt;a href=&quot;../pragma#pragma_threads&quot;&gt;PRAGMAスレッド&lt;/a&gt;コマンドを使用）、並べ替え操作を支援する新しいスレッドが起動され、並べ替えるコンテンツの量がページサイズに&lt;a href=&quot;../pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt;設定の最小値とこの値を掛けた値を超えている。</target>
        </trans-unit>
        <trans-unit id="667ddbb0eaa86ffc653459dd23bacb289f6854a7" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PMASZ option takes a single parameter which is an unsigned integer and sets the &quot;Minimum PMA Size&quot; for the multithreaded sorter to that integer. The default minimum PMA Size is set by the &lt;a href=&quot;compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt; compile-time option. New threads are launched to help with sort operations when multithreaded sorting is enabled (using the &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command) and the amount of content to be sorted exceeds the page size times the minimum of the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; setting and this value.</source>
          <target state="translated">SQLITE_CONFIG_PMASZオプションは、符号なし整数である単一のパラメーターを取り、マルチスレッドソーターの「最小PMAサイズ」をその整数に設定します。デフォルトの最小PMAサイズは、&lt;a href=&quot;compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt;コンパイル時オプションによって設定されます。マルチスレッドの並べ替えが有効になっていて（&lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMAスレッド&lt;/a&gt;コマンドを使用）、並べ替え操作を支援する新しいスレッドが起動され、並べ替えるコンテンツの量がページサイズに&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt;設定の最小値とこの値を掛けた値を超えている。</target>
        </trans-unit>
        <trans-unit id="109fdd8da62f03c0d4a96a618a19a71e802f905e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SCRATCH option is no longer used.</source>
          <target state="translated">SQLITE_CONFIG_SCRATCH オプションは使用されなくなりました。</target>
        </trans-unit>
        <trans-unit id="29ca3b2106e1eec121b349f9609e0d465c220d3d" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SMALL_MALLOC option takes single argument of type int, interpreted as a boolean, which if true provides a hint to SQLite that it should avoid large memory allocations if possible. SQLite will run faster if it is free to make large memory allocations, but some application might prefer to run slower in exchange for guarantees about memory fragmentation that are possible if large allocations are avoided. This hint is normally off.</source>
          <target state="translated">SQLITE_CONFIG_SMALL_MALLOC オプションは int 型の単一の引数を取り、 boolean として解釈されます。しかし、アプリケーションによっては、大規模なメモリ割り当てが回避された場合に可能なメモリの断片化を保証する代わりに、より遅く実行したいと思うかもしれません。このヒントは通常オフになっています。</target>
        </trans-unit>
        <trans-unit id="05ddcc0bca5d82f48fed51db87e518d3912d859e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SORTERREF_SIZE option accepts a single parameter of type (int) - the new value of the sorter-reference size threshold. Usually, when SQLite uses an external sort to order records according to an ORDER BY clause, all fields required by the caller are present in the sorted records. However, if SQLite determines based on the declared type of a table column that its values are likely to be very large - larger than the configured sorter-reference size threshold - then a reference is stored in each sorted record and the required column values loaded from the database as records are returned in sorted order. The default value for this option is to never use this optimization. Specifying a negative value for this option restores the default behaviour. This option is only available if SQLite is compiled with the &lt;a href=&quot;../compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_CONFIG_SORTERREF_SIZEオプションは、タイプ（int）の単一パラメーター（ソーター参照サイズしきい値の新しい値）を受け入れます。通常、SQLiteが外部ソートを使用してORDER BY句に従ってレコードを並べ替えると、呼び出し元が必要とするすべてのフィールドがソートされたレコードに存在します。ただし、SQLiteが、テーブルカラムの宣言されたタイプに基づいて、その値が非常に大きい（設定されたソーター参照サイズのしきい値より大きい）と判断した場合、参照は各ソート済みレコードに格納され、必要な列の値はレコードとしてのデータベースはソートされた順序で返されます。このオプションのデフォルト値は、この最適化を決して使用しないことです。このオプションに負の値を指定すると、デフォルトの動作に戻ります。このオプションは、SQLiteが&lt;a href=&quot;../compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt;コンパイル時オプション。</target>
        </trans-unit>
        <trans-unit id="8e4676f31515701431b60d8c3fec0783441a3fad" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SORTERREF_SIZE option accepts a single parameter of type (int) - the new value of the sorter-reference size threshold. Usually, when SQLite uses an external sort to order records according to an ORDER BY clause, all fields required by the caller are present in the sorted records. However, if SQLite determines based on the declared type of a table column that its values are likely to be very large - larger than the configured sorter-reference size threshold - then a reference is stored in each sorted record and the required column values loaded from the database as records are returned in sorted order. The default value for this option is to never use this optimization. Specifying a negative value for this option restores the default behaviour. This option is only available if SQLite is compiled with the &lt;a href=&quot;compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_CONFIG_SORTERREF_SIZEオプションは、タイプ（int）の単一パラメーター（ソーター参照サイズしきい値の新しい値）を受け入れます。通常、SQLiteが外部ソートを使用してORDER BY句に従ってレコードを並べ替えると、呼び出し元が必要とするすべてのフィールドがソートされたレコードに存在します。ただし、SQLiteが、テーブルカラムの宣言されたタイプに基づいて、その値が非常に大きい（設定されたソーター参照サイズのしきい値より大きい）と判断した場合、参照は各ソート済みレコードに格納され、必要な列の値はレコードとしてのデータベースはソートされた順序で返されます。このオプションのデフォルト値は、この最適化を決して使用しないことです。このオプションに負の値を指定すると、デフォルトの動作に戻ります。このオプションは、SQLiteが&lt;a href=&quot;compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt;コンパイル時オプション。</target>
        </trans-unit>
        <trans-unit id="605f0b5884691b12b17ca06f9366cc2ade4cfd24" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_STMTJRNL_SPILL option takes a single parameter which becomes the &lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; spill-to-disk threshold. &lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;Statement journals&lt;/a&gt; are held in memory until their size (in bytes) exceeds this threshold, at which point they are written to disk. Or if the threshold is -1, statement journals are always held exclusively in memory. Since many statement journals never become large, setting the spill threshold to a value such as 64KiB can greatly reduce the amount of I/O required to support statement rollback. The default value for this setting is controlled by the &lt;a href=&quot;../compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_CONFIG_STMTJRNL_SPILLオプションは、&lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;ステートメントジャーナルの&lt;/a&gt;ディスクへのスピルへのしきい値になる単一のパラメーターを取ります。&lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;ステートメントジャーナル&lt;/a&gt;は、サイズ（バイト単位）がこのしきい値を超えるまでメモリに保持されます。このしきい値を超えると、ディスクに書き込まれます。または、しきい値が-1の場合、ステートメントジャーナルは常にメモリ内に排他的に保持されます。多くのステートメントジャーナルが大きくなることはないため、スピルしきい値を64KiBなどの値に設定すると、ステートメントのロールバックをサポートするために必要なI / Oの量を大幅に削減できます。この設定のデフォルト値は、&lt;a href=&quot;../compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt;コンパイル時オプションによって制御されます。</target>
        </trans-unit>
        <trans-unit id="c96a7bbc95d6882993f7d0afda36dce9d7d4b5c0" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_STMTJRNL_SPILL option takes a single parameter which becomes the &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; spill-to-disk threshold. &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;Statement journals&lt;/a&gt; are held in memory until their size (in bytes) exceeds this threshold, at which point they are written to disk. Or if the threshold is -1, statement journals are always held exclusively in memory. Since many statement journals never become large, setting the spill threshold to a value such as 64KiB can greatly reduce the amount of I/O required to support statement rollback. The default value for this setting is controlled by the &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_CONFIG_STMTJRNL_SPILLオプションは、&lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;ステートメントジャーナルの&lt;/a&gt;ディスクへのスピルへのしきい値になる単一のパラメーターを取ります。&lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;ステートメントジャーナル&lt;/a&gt;は、サイズ（バイト単位）がこのしきい値を超えるまでメモリに保持されます。このしきい値を超えると、ディスクに書き込まれます。または、しきい値が-1の場合、ステートメントジャーナルは常にメモリ内に排他的に保持されます。多くのステートメントジャーナルが大きくなることはないため、スピルしきい値を64KiBなどの値に設定すると、ステートメントのロールバックをサポートするために必要なI / Oの量を大幅に削減できます。この設定のデフォルト値は、&lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt;コンパイル時オプションによって制御されます。</target>
        </trans-unit>
        <trans-unit id="e7c94d69eb75e63340f2383ddf68d20c1d31a18d" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_URI option takes a single argument of type int. If non-zero, then URI handling is globally enabled. If the parameter is zero, then URI handling is globally disabled. If URI handling is globally enabled, all filenames passed to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt; or specified as part of &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; commands are interpreted as URIs, regardless of whether or not the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set when the database connection is opened. If it is globally disabled, filenames are only interpreted as URIs if the SQLITE_OPEN_URI flag is set when the database connection is opened. By default, URI handling is globally disabled. The default value may be changed by compiling with the &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; symbol defined.</source>
          <target state="translated">SQLITE_CONFIG_URIオプションは、int型の単一の引数を取ります。ゼロ以外の場合、URI処理はグローバルに有効になります。パラメータがゼロの場合、URI処理はグローバルに無効になります。 URI処理がグローバルに有効になっている場合、データベース接続が開かれたときに&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;フラグが設定されているかどうかに関係なく、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;、sqlite3_open16（）に&lt;a href=&quot;#sqlite3_open&quot;&gt;渡される&lt;/a&gt;、または&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;コマンドの一部として指定されるすべてのファイル名はURIとして解釈されます。グローバルに無効になっている場合、データベース接続が開かれたときにSQLITE_OPEN_URIフラグが設定されている場合、ファイル名はURIとしてのみ解釈されます。デフォルトでは、URI処理はグローバルに無効になっています。デフォルト値は、&lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt;シンボルが定義されました。</target>
        </trans-unit>
        <trans-unit id="4ab4ffd66152d39e37a9eeebeb02a7852ae9ede8" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_URI option takes a single argument of type int. If non-zero, then URI handling is globally enabled. If the parameter is zero, then URI handling is globally disabled. If URI handling is globally enabled, all filenames passed to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt; or specified as part of &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; commands are interpreted as URIs, regardless of whether or not the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set when the database connection is opened. If it is globally disabled, filenames are only interpreted as URIs if the SQLITE_OPEN_URI flag is set when the database connection is opened. By default, URI handling is globally disabled. The default value may be changed by compiling with the &lt;a href=&quot;../compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; symbol defined.</source>
          <target state="translated">SQLITE_CONFIG_URIオプションは、int型の単一の引数を取ります。ゼロ以外の場合、URI処理はグローバルに有効になります。パラメータがゼロの場合、URI処理はグローバルに無効になります。 URI処理がグローバルに有効になっている場合、データベース接続が開かれたときに&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;フラグが設定されているかどうかに関係なく、&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;、sqlite3_open16（）に&lt;a href=&quot;open&quot;&gt;渡される&lt;/a&gt;、または&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;コマンドの一部として指定されるすべてのファイル名はURIとして解釈されます。グローバルに無効になっている場合、データベース接続が開かれたときにSQLITE_OPEN_URIフラグが設定されている場合、ファイル名はURIとしてのみ解釈されます。デフォルトでは、URI処理はグローバルに無効になっています。デフォルト値は、&lt;a href=&quot;../compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt;シンボルが定義されました。</target>
        </trans-unit>
        <trans-unit id="b4ea1f91dd128d45077ef6aab24be62cde2c08e4" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_WIN32_HEAPSIZE option is only available if SQLite is compiled for Windows with the &lt;a href=&quot;../compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; pre-processor macro defined. SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit unsigned integer value that specifies the maximum size of the created heap.</source>
          <target state="translated">SQLITE_CONFIG_WIN32_HEAPSIZEオプションは、&lt;a href=&quot;../compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt;プリプロセッサマクロが定義されているWindows用にSQLiteがコンパイルされている場合にのみ使用できます。SQLITE_CONFIG_WIN32_HEAPSIZEは、作成されるヒープの最大サイズを指定する32ビットの符号なし整数値を取ります。</target>
        </trans-unit>
        <trans-unit id="55987e1e9f78159dc547356995af9fe3ce5c9817" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_WIN32_HEAPSIZE option is only available if SQLite is compiled for Windows with the &lt;a href=&quot;compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; pre-processor macro defined. SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit unsigned integer value that specifies the maximum size of the created heap.</source>
          <target state="translated">SQLITE_CONFIG_WIN32_HEAPSIZEオプションは、&lt;a href=&quot;compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt;プリプロセッサマクロが定義されているWindows用にSQLiteがコンパイルされている場合にのみ使用できます。SQLITE_CONFIG_WIN32_HEAPSIZEは、作成されるヒープの最大サイズを指定する32ビットの符号なし整数値を取ります。</target>
        </trans-unit>
        <trans-unit id="90354942dff120bb22a653ae9fa0d244342b89da" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT code can also be used as the return value from the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex()&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation. When xBestIndex() returns SQLITE_CONSTRAINT, that indicates that the particular combination of inputs submitted to xBestIndex() cannot result in a usable query plan and should not be given further consideration.</source>
          <target state="translated">SQLITE_CONSTRAINTコードは、&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;実装の&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex（）&lt;/a&gt;メソッドからの戻り値としても使用できます。xBestIndex（）がSQLITE_CONSTRAINTを返す場合、これは、xBestIndex（）に送信された入力の特定の組み合わせでは使用可能なクエリプランが得られないため、これ以上の考慮は不要であることを示します。</target>
        </trans-unit>
        <trans-unit id="cd3afc5f9dc7b86d4db8138dda7591ba7ea2f042" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT error code means that an SQL constraint violation occurred while trying to process an SQL statement. Additional information about the failed constraint can be found by consulting the accompanying error message (returned via &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; or &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt;) or by looking at the &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONSTRAINTエラーコードは、SQLステートメントの処理中にSQL制約違反が発生したことを意味します。失敗した制約に関する追加情報は、付随するエラーメッセージ（&lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;または&lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg16（）&lt;/a&gt;を介して返される）を調べるか、&lt;a href=&quot;rescode#extrc&quot;&gt;拡張エラーコードを&lt;/a&gt;確認することで確認できます。</target>
        </trans-unit>
        <trans-unit id="1402b83ad789cf26361c62d000ccad7aa66cb251" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_CHECK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt; failed.</source>
          <target state="translated">SQLITE_CONSTRAINT_CHECKエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;ことを示す&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;チェック制約が&lt;/a&gt;失敗しました。</target>
        </trans-unit>
        <trans-unit id="59f7b5e1d1fc684ffe767053e5ae405c247a79ff" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_COMMITHOOK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;c3ref/commit_hook&quot;&gt;commit hook callback&lt;/a&gt; returned non-zero that thus caused the SQL statement to be rolled back.</source>
          <target state="translated">SQLITE_CONSTRAINT_COMMITHOOKエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;ことを示す&lt;a href=&quot;c3ref/commit_hook&quot;&gt;フックコールバックがコミット&lt;/a&gt;こうしてロールバックされるSQL文を引き起こした非ゼロを返さ。</target>
        </trans-unit>
        <trans-unit id="c857f1295fd44fc161f41f3c36b1faa547511cbf" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_FOREIGNKEY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; failed.</source>
          <target state="translated">SQLITE_CONSTRAINT_FOREIGNKEYエラーコードである&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;ことを示す&lt;a href=&quot;foreignkeys&quot;&gt;外部キー制約が&lt;/a&gt;失敗しました。</target>
        </trans-unit>
        <trans-unit id="fa48ddcf19118820df2cdaa1b78eb70d4071dd14" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_FUNCTION error code is not currently used by the SQLite core. However, this error code is available for use by extension functions.</source>
          <target state="translated">SQLITE_CONSTRAINT_FUNCTION エラーコードは、現在のところ SQLite コアでは使用されていません。しかし、このエラーコードは拡張関数で使用することができます。</target>
        </trans-unit>
        <trans-unit id="3c4481d9380cb514a86e596c21d0da6c70c2337c" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_NOTNULL error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL constraint&lt;/a&gt; failed.</source>
          <target state="translated">SQLITE_CONSTRAINT_NOTNULLエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;ことを示す&lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL制約が&lt;/a&gt;失敗しました。</target>
        </trans-unit>
        <trans-unit id="b921914ef5b1ae6eddb9ee04650c5c235d49ed11" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_PRIMARYKEY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY constraint&lt;/a&gt; failed.</source>
          <target state="translated">SQLITE_CONSTRAINT_PRIMARYKEYエラーコードである&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;ことを示す&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY制約が&lt;/a&gt;失敗しました。</target>
        </trans-unit>
        <trans-unit id="3d2416f0eb5c1e4932d96de2c633168fe0745690" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_ROWID error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; is not unique.</source>
          <target state="translated">SQLITE_CONSTRAINT_ROWIDエラーコードである&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;ことを示す&lt;a href=&quot;lang_createtable#rowid&quot;&gt;行IDが&lt;/a&gt;一意ではありません。</target>
        </trans-unit>
        <trans-unit id="d42ea811023ed01aef8eff1b26fe2bb9abe7bb95" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_TRIGGER error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtrigger#raise&quot;&gt;RAISE function&lt;/a&gt; within a &lt;a href=&quot;lang_createtrigger&quot;&gt;trigger&lt;/a&gt; fired, causing the SQL statement to abort.</source>
          <target state="translated">SQLITE_CONSTRAINT_TRIGGERエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;ことを示す&lt;a href=&quot;lang_createtrigger#raise&quot;&gt;raise関数&lt;/a&gt;内の&lt;a href=&quot;lang_createtrigger&quot;&gt;トリガは&lt;/a&gt; SQL文を中断させ、焼成します。</target>
        </trans-unit>
        <trans-unit id="360095776d45f4673d25e1354d178fe2a9b1bd8f" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_UNIQUE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE constraint&lt;/a&gt; failed.</source>
          <target state="translated">SQLITE_CONSTRAINT_UNIQUEエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;ことを示す&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE制約が&lt;/a&gt;失敗しました。</target>
        </trans-unit>
        <trans-unit id="a2591670580b26a952a816bde9a68b915c405d78" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_VTAB error code is not currently used by the SQLite core. However, this error code is available for use by application-defined &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONSTRAINT_VTABエラーコードは、現在SQLiteコアでは使用されていません。ただし、このエラーコードは、アプリケーション定義の&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;で使用できます。</target>
        </trans-unit>
        <trans-unit id="ca22607c1bc11adbc4850780682a00fc2af063db" translate="yes" xml:space="preserve">
          <source>The SQLITE_CORRUPT result code indicates that the database file has been corrupted. See the &lt;a href=&quot;lockingv3#how_to_corrupt&quot;&gt;How To Corrupt Your Database Files&lt;/a&gt; for further discussion on how corruption can occur.</source>
          <target state="translated">SQLITE_CORRUPT結果コードは、データベースファイルが破損していることを示します。破損が発生する&lt;a href=&quot;lockingv3#how_to_corrupt&quot;&gt;方法の&lt;/a&gt;詳細については、データベースファイルの破損方法を参照してください。</target>
        </trans-unit>
        <trans-unit id="83192f645bf11cddd8fa598bcc30dab724111331" translate="yes" xml:space="preserve">
          <source>The SQLITE_CORRUPT_SEQUENCE result code means that the schema of the sqlite_sequence table is corrupt. The sqlite_sequence table is used to help implement the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; feature. The sqlite_sequence table should have the following format:</source>
          <target state="translated">SQLITE_CORRUPT_SEQUENCE結果コードは、sqlite_sequenceテーブルのスキーマが破損していることを意味します。sqlite_sequenceテーブルは、&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;機能の実装を支援するために使用されます。sqlite_sequenceテーブルの形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e605977504524c24f74112f64c7f554569d710cb" translate="yes" xml:space="preserve">
          <source>The SQLITE_CORRUPT_VTAB error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; used by &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. A &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; might return SQLITE_CORRUPT_VTAB to indicate that content in the virtual table is corrupt.</source>
          <target state="translated">SQLITE_CORRUPT_VTABエラーコードは、&lt;a href=&quot;vtab&quot;&gt;仮想テーブルで&lt;/a&gt;使用される&lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPTの&lt;/a&gt;&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;です。&lt;a href=&quot;vtab&quot;&gt;仮想テーブルは、&lt;/a&gt;仮想テーブルの内容が壊れていることを示すためにSQLITE_CORRUPT_VTABを返すことがあります。</target>
        </trans-unit>
        <trans-unit id="6f5aeac16ee13da96d49c9c69d5a1efa4f1ec4c7" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DEFENSIVE option activates or deactivates the &quot;defensive&quot; flag for a database connection. When the defensive flag is enabled, language features that allow ordinary SQL to deliberately corrupt the database file are disabled. The disabled features include but are not limited to the following:</source>
          <target state="translated">SQLITE_DBCONFIG_DEFENSIVE オプションは、データベース接続の &quot;防御&quot; フラグを有効または無効にします。defensive フラグが有効な場合、通常の SQL がデータベースファイルを故意に破損させるような言語機能は無効になります。無効化される機能には、以下のものがありますが、これらに限定されるものではありません。</target>
        </trans-unit>
        <trans-unit id="b1c89dddb1e567654969cbefc3cb66f653fb53df" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS option activates or deactivates the legacy &lt;a href=&quot;../quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DDL statements, such as CREATE TABLE and CREATE INDEX. The default value of this setting is determined by the &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQSオプションは、CREATE TABLEやCREATE INDEXなどのDDLステートメントの従来の&lt;a href=&quot;../quirks#dblquote&quot;&gt;二重引用符で囲まれた文字列リテラルの&lt;/a&gt;誤機能をアクティブまたは非アクティブにします。この設定のデフォルト値は、&lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt;コンパイル時オプションによって決定されます。</target>
        </trans-unit>
        <trans-unit id="5fa9af190de834f94817db4398afc2b28f903d62" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS option activates or deactivates the legacy &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DDL statements, such as CREATE TABLE and CREATE INDEX. The default value of this setting is determined by the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQSオプションは、CREATE TABLEやCREATE INDEXなどのDDLステートメントの従来の&lt;a href=&quot;quirks#dblquote&quot;&gt;二重引用符で囲まれた文字列リテラルの&lt;/a&gt;誤機能をアクティブまたは非アクティブにします。この設定のデフォルト値は、&lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt;コンパイル時オプションによって決定されます。</target>
        </trans-unit>
        <trans-unit id="7a4f8ed114b3f33c0656fd3fe462891e36a86bca" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates the legacy &lt;a href=&quot;../quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DML statement only, that is DELETE, INSERT, SELECT, and UPDATE statements. The default value of this setting is determined by the &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQS_DMLオプションは、DMLステートメント（DELETE、INSERT、SELECT、およびUPDATEステートメント）に対してのみ、従来の&lt;a href=&quot;../quirks#dblquote&quot;&gt;二重引用符で囲まれた文字列リテラルの&lt;/a&gt;誤機能をアクティブ化または非アクティブ化します。この設定のデフォルト値は、&lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt;コンパイル時オプションによって決定されます。</target>
        </trans-unit>
        <trans-unit id="5ef07fd34a275a246ee518a98e66084fe0a55fad" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates the legacy &lt;a href=&quot;../quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DML statements only, that is DELETE, INSERT, SELECT, and UPDATE statements. The default value of this setting is determined by the &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQS_DMLオプションは、DMLステートメント、つまりDELETE、INSERT、SELECT、およびUPDATEステートメントに対してのみ、従来の&lt;a href=&quot;../quirks#dblquote&quot;&gt;二重引用符で囲まれた文字列リテラルの&lt;/a&gt;誤動作をアクティブ化または非アクティブ化します。この設定のデフォルト値は、&lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt;コンパイル時オプションによって決定されます。</target>
        </trans-unit>
        <trans-unit id="b23b83b3528f7ad3365bcce16b9fcdca7b11634b" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates the legacy &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DML statement only, that is DELETE, INSERT, SELECT, and UPDATE statements. The default value of this setting is determined by the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQS_DMLオプションは、DMLステートメント（DELETE、INSERT、SELECT、およびUPDATEステートメント）に対してのみ、従来の&lt;a href=&quot;quirks#dblquote&quot;&gt;二重引用符で囲まれた文字列リテラルの&lt;/a&gt;誤機能をアクティブ化または非アクティブ化します。この設定のデフォルト値は、&lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt;コンパイル時オプションによって決定されます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
