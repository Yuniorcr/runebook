<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="fa9dd62d3bfcaf75e4033204e51b41d31455c6e9" translate="yes" xml:space="preserve">
          <source>It is important to verify that the gcov test run and the second real test run both give the same output. Any differences in output indicate either the use of undefined or indeterminate behavior in the SQLite code (and hence a bug), or a bug in the compiler. Note that SQLite has, over the previous decade, encountered bugs in each of GCC, Clang, and MSVC. Compiler bugs, while rare, do happen, which is why it is so important to test the code in an as-delivered configuration.</source>
          <target state="translated">gcovテスト実行と2回目の実際のテスト実行の両方で同じ出力が得られることを確認することが重要です。出力に違いがある場合は、SQLite コードに未定義の動作や不確定な動作が使用されている(つまりバグ)か、コンパイラにバグがあることを示しています。SQLite は過去 10 年間で GCC,Clang,MSVC のそれぞれでバグに遭遇してきたことに注意してください。コンパイラのバグは、まれではありますが発生します。</target>
        </trans-unit>
        <trans-unit id="d1cea258b6006ec069fad2e48bb8e0ae1aa954d2" translate="yes" xml:space="preserve">
          <source>It is impossible to test every possible combination of compile-time options for SQLite. But the following set of compile-time options is one configuration that is always fully tested.</source>
          <target state="translated">SQLite のコンパイル時オプションのすべての可能な組み合わせをテストすることは不可能です。しかし、以下のコンパイル時オプションのセットは、常に完全にテストされている設定の一つです。</target>
        </trans-unit>
        <trans-unit id="15edf0a6c6c69dc4fe559f59d8b017e98f300472" translate="yes" xml:space="preserve">
          <source>It is impractical to do crash testing using real power failures, of course, and so crash testing is done in simulation. An alternative &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System&lt;/a&gt; is inserted that allows the test harness to simulate the state of the database file following a crash.</source>
          <target state="translated">もちろん、実際の電源障害を使用してクラッシュテストを行うことは現実的ではないため、クラッシュテストはシミュレーションで行われます。テストハーネスがクラッシュ後のデータベースファイルの状態をシミュレートできるようにする代替の&lt;a href=&quot;c3ref/vfs&quot;&gt;仮想ファイルシステム&lt;/a&gt;が挿入されます。</target>
        </trans-unit>
        <trans-unit id="e1d5ef237a2a6e6403153de4b153927de75448b8" translate="yes" xml:space="preserve">
          <source>It is not an error if the named table does not exist in the database. Nor is it an error if the named table does not have a PRIMARY KEY. However, no changes will be recorded in either of these scenarios.</source>
          <target state="translated">指定されたテーブルがデータベースに存在しない場合はエラーではありません。また、指定されたテーブルが PRIMARY KEY を持っていない場合もエラーではありません。しかし、これらのシナリオのいずれにおいても変更は記録されません。</target>
        </trans-unit>
        <trans-unit id="d49fdf0ef1b4c639114a4ac63de04efc40c67c48" translate="yes" xml:space="preserve">
          <source>It is not an error to create a table that has the same name as an existing &lt;a href=&quot;lang_createtrigger&quot;&gt;trigger&lt;/a&gt;.</source>
          <target state="translated">既存の&lt;a href=&quot;lang_createtrigger&quot;&gt;トリガー&lt;/a&gt;と同じ名前のテーブルを作成してもエラーにはなりません。</target>
        </trans-unit>
        <trans-unit id="8aaf6c77de556f14a491171c58f28d211cfbc9d4" translate="yes" xml:space="preserve">
          <source>It is not commonly useful to evaluate the &lt;em&gt;exact&lt;/em&gt; same SQL statement more than once. More often, one wants to evaluate similar statements. For example, you might want to evaluate an INSERT statement multiple times with different values. Or you might want to evaluate the same query multiple times using a different key in the WHERE clause. To accommodate this, SQLite allows SQL statements to contain &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; which are &quot;bound&quot; to values prior to being evaluated. These values can later be changed and the same &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; can be evaluated a second time using the new values.</source>
          <target state="translated">&lt;em&gt;まったく&lt;/em&gt;同じSQLステートメントを複数回評価することは、一般的には役に立ちません。多くの場合、同様のステートメントを評価する必要があります。たとえば、INSERTステートメントを異なる値で複数回評価したい場合があります。または、WHERE句の異なるキーを使用して、同じクエリを複数回評価することもできます。これに対応するため、SQLiteでは、SQLステートメントに、評価前に値に「バインド」された&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーター&lt;/a&gt;を含めることができます。これらの値は後で変更でき、同じ&lt;a href=&quot;c3ref/stmt&quot;&gt;準備済みステートメント&lt;/a&gt;を新しい値を使用してもう一度評価できます。</target>
        </trans-unit>
        <trans-unit id="8de5c77745aab508a14fca7f3c047cc5a41b83c4" translate="yes" xml:space="preserve">
          <source>It is not impossible to find the descendents of a check-in in Git. It is merely difficult. For example, there is a &lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;stackoverflow page&lt;/a&gt; showing the command sequence for finding the descendents of a check-in in unix:</source>
          <target state="translated">Gitでチェックインの子孫を見つけることは不可能ではありません。ただ難しいだけです。たとえば、Unixでチェックインの子孫を見つけるためのコマンドシーケンスを示す&lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;stackoverflowページ&lt;/a&gt;があります。</target>
        </trans-unit>
        <trans-unit id="968af02ea707c660eea2edbc719717453c1c09b4" translate="yes" xml:space="preserve">
          <source>It is not necessary for every column of an index to appear in a WHERE clause term in order for that index to be used. But there cannot be gaps in the columns of the index that are used. Thus for the example index above, if there is no WHERE clause term that constraints column c, then terms that constrain columns a and b can be used with the index but not terms that constraint columns d through z. Similarly, index columns will not normally be used (for indexing purposes) if they are to the right of a column that is constrained only by inequalities. (See the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; below for the exception.)</source>
          <target state="translated">インデックスを使用するために、インデックスのすべての列がWHERE句の用語に含まれている必要はありません。ただし、使用されるインデックスの列にギャップがあってはなりません。したがって、上記の例のインデックスでは、列cを制約するWHERE句の用語がない場合、列aとbを制約する用語はインデックスで使用できますが、列dからzを制約する用語は使用できません。同様に、インデックス列は、不等式のみによって制約されている列の右側にある場合、通常は（インデックス作成の目的で）使用されません。 （例外については、以下の&lt;a href=&quot;optoverview#skipscan&quot;&gt;スキップスキャン最適化を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="91c4a366eb8b7036569a617f444657bfe2829b75" translate="yes" xml:space="preserve">
          <source>It is not necessary to delete a session object after extracting a changeset or patchset from it. It can be left attached to the database handle and will continue monitoring for changes on the configured tables as before. However, if &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; or &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset()&lt;/a&gt; is called a second time on a session object, the changeset or patchset will contain &lt;em&gt;all&lt;/em&gt; changes that have taken place on the connection since the session was created. In other words, a session object is not reset or zeroed by a call to sqlite3session_changeset() or sqlite3session_patchset().</source>
          <target state="translated">チェンジセットまたはパッチセットをセッションオブジェクトから抽出した後で、セッションオブジェクトを削除する必要はありません。これはデータベースハンドルに接続したままにすることができ、以前と同様に構成されたテーブルの変更を監視し続けます。ただし、&lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）&lt;/a&gt;または&lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset（）&lt;/a&gt;がセッションオブジェクトで2回目に呼び出された場合、変更セットまたはパッチセットには、セッションの作成以降に接続で行われた&lt;em&gt;すべての&lt;/em&gt;変更が含まれます。つまり、sqlite3session_changeset（）またはsqlite3session_patchset（）の呼び出しによってセッションオブジェクトがリセットまたはゼロにされることはありません。</target>
        </trans-unit>
        <trans-unit id="670d42dfe457729d9823abd17b04a227c0f7995a" translate="yes" xml:space="preserve">
          <source>It is not necessary to increment the change counter in the database header for transactions after the first transaction. This will often save a write of page one to both the rollback journal and the main database file.</source>
          <target state="translated">最初のトランザクションの後のトランザクションについては、データベースヘッダの変更カウンタをインクリメントする必要はありません。これにより、ロールバックジャーナルとメインデータベースファイルの両方に1ページ目の書き込みが保存されることが多いです。</target>
        </trans-unit>
        <trans-unit id="2403c6f4220d7ab7621d951d5ca316ce8bb167ec" translate="yes" xml:space="preserve">
          <source>It is not necessary to retrieve data in the format specify by sqlite3_column_type(). If a different format is requested, the data is converted automatically.</source>
          <target state="translated">sqlite3_column_type()で指定した形式でデータを取得する必要はありません。別のフォーマットが要求された場合、データは自動的に変換されます。</target>
        </trans-unit>
        <trans-unit id="900bad887efaa153c1a2b75294545475e3b1d504" translate="yes" xml:space="preserve">
          <source>It is not possible for a single FTS query to return rows with different languageid values. The results of adding WHERE clauses that use other operators (e.g. lid!=5, or lid&amp;lt;=5) are undefined.</source>
          <target state="translated">1つのFTSクエリが異なるlanguageid値を持つ行を返すことはできません。他の演算子を使用するWHERE句（例：lid！= 5、lid &amp;lt;= 5）を追加した結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="7d7041428ac37cb2fe5a20d78347fe7eb6acfbe1" translate="yes" xml:space="preserve">
          <source>It is not possible to UPDATE or DELETE a row stored in a contentless FTS4 table. Attempting to do so is an error.</source>
          <target state="translated">内容のないFTS4テーブルに格納されている行をUPDATEまたはDELETEすることはできません。これを試みるとエラーになります。</target>
        </trans-unit>
        <trans-unit id="9e4665d3e6caf2e43eb0161671eab0b61b62c13a" translate="yes" xml:space="preserve">
          <source>It is not possible to change the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; after entering WAL mode, either on an empty database or by using &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; or by restoring from a backup using the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt;. You must be in a rollback journal mode to change the page size.</source>
          <target state="translated">空のデータベースで、または&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;を使用して、または&lt;a href=&quot;backup&quot;&gt;バックアップAPI&lt;/a&gt;を使用してバックアップから復元することによって、WALモードに入った後で&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt;を変更することはできません。ページサイズを変更するには、ロールバックジャーナルモードになっている必要があります。</target>
        </trans-unit>
        <trans-unit id="deaab8f44371f477a4e7e55d31601e0d0d6a03fb" translate="yes" xml:space="preserve">
          <source>It is not possible to enable or disable foreign key constraints in the middle of a &lt;a href=&quot;lang_transaction&quot;&gt;multi-statement transaction&lt;/a&gt; (when SQLite is not in &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;). Attempting to do so does not return an error; it simply has no effect.</source>
          <target state="translated">&lt;a href=&quot;lang_transaction&quot;&gt;マルチステートメントトランザクションの&lt;/a&gt;途中で外部キー制約を有効または無効にすることはできません（SQLiteが&lt;a href=&quot;c3ref/get_autocommit&quot;&gt;自動コミットモードで&lt;/a&gt;ない場合）。これを実行しようとしてもエラーは返されません。効果はありません。</target>
        </trans-unit>
        <trans-unit id="59d7023d400b2c4a42c25e47c1d1dae5bdb83625" translate="yes" xml:space="preserve">
          <source>It is not possible to use the &quot;ALTER TABLE ... ADD COLUMN&quot; syntax to add a column that includes a REFERENCES clause, unless the default value of the new column is NULL. Attempting to do so returns an error.</source>
          <target state="translated">ALTER TABLE ...新しい列のデフォルト値がNULLでない限り、REFERENCES句を含む列を追加するために &quot;ALTER TABLE ...ADD COLUMN &quot;構文を使用することはできません。これを試みようとするとエラーを返します。</target>
        </trans-unit>
        <trans-unit id="912f58b54e2d4f955145072d5727d208f46d87cf" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">この変数を一度に複数のスレッドで読み取ったり変更したりすることは安全ではありません。&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;が別のスレッドで同時に使用されている場合、この変数を読み取ったり変更したりするのは安全ではありません。この変数は、プロセスの初期化の一部として、SQLiteインターフェースルーチンが呼び出される前に一度設定され、その後もこの変数は変更されないままであることが意図されています。</target>
        </trans-unit>
        <trans-unit id="903cea61d0db784ec27805bae69d5dea09532edb" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">この変数を一度に複数のスレッドで読み取ったり変更したりすることは安全ではありません。&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;が別のスレッドで同時に使用されている場合、この変数を読み取ったり変更したりするのは安全ではありません。この変数は、プロセスの初期化の一部として、SQLiteインターフェースルーチンが呼び出される前に一度設定され、その後もこの変数は変更されないままであることが意図されています。</target>
        </trans-unit>
        <trans-unit id="159cf71be6e4a6830ae2567917f78113abca0955" translate="yes" xml:space="preserve">
          <source>It is ok to make multiple entries for the same word as long as each entry has a different soundslike value. Note that if no soundslike value is specified, the soundslike defaults to the word itself.</source>
          <target state="translated">各エントリが異なるサウンドスライク値を持つ限り、同じ単語に対して複数のエントリを作成しても構いません。サウンドスライク値が指定されていない場合、サウンドスライクのデフォルトは単語そのものであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="42b6da3d325a27b4a54e5028535caa1fb0d83d7a" translate="yes" xml:space="preserve">
          <source>It is particularly important to use an entry point name that is based on the extension filename, rather than the generic &quot;sqlite3_extension_init&quot; entry point name, if you will be statically linking two or more extensions. If you use the generic name, there will be multiple definitions of the same symbol and the link will fail.</source>
          <target state="translated">2つ以上の拡張機能を静的にリンクする場合、一般的な &quot;sqlite3_extension_init &quot;というエントリーポイント名ではなく、拡張機能のファイル名に基づいたエントリーポイント名を使用することが特に重要です。一般名を使用した場合、同じシンボルの定義が複数存在し、リンクは失敗します。</target>
        </trans-unit>
        <trans-unit id="1f5372992ab68655b726354d1de85f6b9510df2c" translate="yes" xml:space="preserve">
          <source>It is permitted to register multiple implementations of the same functions with the same name but with either differing numbers of arguments or differing preferred text encodings. SQLite will use the implementation that most closely matches the way in which the SQL function is used. A function implementation with a non-negative nArg parameter is a better match than a function implementation with a negative nArg. A function where the preferred text encoding matches the database encoding is a better match than a function where the encoding is different. A function where the encoding difference is between UTF16le and UTF16be is a closer match than a function where the encoding difference is between UTF8 and UTF16.</source>
          <target state="translated">同じ関数の複数の実装を同じ名前で登録することができますが、引数の数や優先するテキストエンコーディングが異なる場合もあります。SQLite は、その SQL 関数の使用方法に最も近い実装を使用します。負ではない nArg パラメータを持つ関数の実装は、負の nArg パラメータを持つ関数の実装よりもマッチします。優先されるテキストエンコーディングがデータベースのエンコーディングと一致する関数は、エンコーディングが異なる関数よりも一致します。エンコーディングの違いがUTF16leとUTF16beの間にある関数は、エンコーディングの違いがUTF8とUTF16の間にある関数よりも近い一致となります。</target>
        </trans-unit>
        <trans-unit id="d335c80330cdb9262d358bd293d73594c1829762" translate="yes" xml:space="preserve">
          <source>It is possible for the library compile-time C preprocessor symbol &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; to override this pragma setting. The following table summarizes the interaction of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; preprocessor macro and the temp_store pragma:</source>
          <target state="translated">ライブラリコンパイル時のCプリプロセッサシンボル&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;がこのプラグマ設定を上書きする可能性があります。次の表は、&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;プリプロセッサマクロとtemp_storeプラグマの相互作用をまとめたものです。</target>
        </trans-unit>
        <trans-unit id="882d45108ae3506a475e868a2ed67d0f5c2e5629" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. But not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="translated">証明者の将来の拡張により、特定の組み込み関数へのNULL入力が常にNULL回答になることを証明者が認識できるようになる可能性があります。ただし、すべての組み込み関数にそのプロパティがあるわけではありません（たとえば、&lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce（）&lt;/a&gt;）。もちろん、証明者は&lt;a href=&quot;appfunc&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;について推論することはできません。</target>
        </trans-unit>
        <trans-unit id="105eb1a524704db6ebed7c523dd9971899853505" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. But not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="translated">証明者に対する将来の拡張により、特定の組み込み関数へのNULL入力が常にNULL回答になることを認識できるようになる可能性があります。しかし、すべての組み込み関数がそのプロパティを持っているわけではありません（たとえば、&lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce（）&lt;/a&gt;）。もちろん、証明者が&lt;a href=&quot;c3ref/create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;について推論することはできません。</target>
        </trans-unit>
        <trans-unit id="2be5eee10a74ce784db26ece955361d8533b48cb" translate="yes" xml:space="preserve">
          <source>It is possible to build a special &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; that will work with a predetermined set of SQLITE_OMIT_... options. Instructions for doing so can be found with the &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_... documentation&lt;/a&gt;.</source>
          <target state="translated">事前に定義されたSQLITE_OMIT _...オプションのセットで機能する特別な&lt;a href=&quot;amalgamation&quot;&gt;融合&lt;/a&gt;を構築することが可能です。これを行うための手順は、&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _...のドキュメントに記載&lt;/a&gt;されています。</target>
        </trans-unit>
        <trans-unit id="321373a36254200d34f2e6be79e9dd835a4c4ba3" translate="yes" xml:space="preserve">
          <source>It is possible to create multiple session objects attached to a single database handle.</source>
          <target state="translated">1つのデータベースハンドルに接続された複数のセッションオブジェクトを作成することができます。</target>
        </trans-unit>
        <trans-unit id="bed5d040f0bed9644c8d2600cb5ecf6e91531170" translate="yes" xml:space="preserve">
          <source>It is possible to extend custom or pile-of-files formats too, of course, but doing is often much harder. If indices are added, then all application code that changes the corresponding tables must be located and modified to keep those indices up-to-date. If columns are added, then all application code that accesses the corresponding table must be located and modified to take into account the new columns.</source>
          <target state="translated">もちろん、カスタムフォーマットや pile-of-files フォーマットを拡張することも可能ですが、それを行うのははるかに難しいことが多いです。インデックスが追加された場合、対応するテーブルを変更するすべてのアプリケーションコードは、それらのインデックスを最新の状態に保つように配置され、修正されなければなりません。カラムが追加された場合は、対応するテーブルにアクセスするすべてのアプリケーションコードを配置し、新しいカラムを考慮に入れるように修正しなければなりません。</target>
        </trans-unit>
        <trans-unit id="e6a04c27b0773734dfa33829ac44458f0f513a43" translate="yes" xml:space="preserve">
          <source>It is possible to have an aggregate function with the same name as a simple function, as long as the number of arguments for the two forms of the function are different. For example, the &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max()&lt;/a&gt; function with a single argument is an aggregate and the &lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max()&lt;/a&gt; function with two or more arguments is a simple function. Aggregate functions can usually also be used as window functions.</source>
          <target state="translated">関数の2つの形式の引数の数が異なる限り、単純な関数と同じ名前の集約関数を持つことができます。たとえば、単一の引数を持つ&lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max（）&lt;/a&gt;関数は集約であり、2つ以上の引数を持つ&lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max（）&lt;/a&gt;関数は単純な関数です。通常、集計関数はウィンドウ関数としても使用できます。</target>
        </trans-unit>
        <trans-unit id="79fc85e42448050747bff9c78bdebc62767b73c0" translate="yes" xml:space="preserve">
          <source>It is possible to make SQLite treat NULLs as distinct for the purposes of the SELECT DISTINCT and UNION. To do so, one should change the value of the NULL_ALWAYS_DISTINCT #define in the &lt;code&gt;sqliteInt.h&lt;/code&gt; source file and recompile.</source>
          <target state="translated">SQLiteがSELECT DISTINCTとUNIONの目的のためにNULLを別個のものとして扱うようにすることが可能です。これを行うには、 &lt;code&gt;sqliteInt.h&lt;/code&gt; ソースファイルのNULL_ALWAYS_DISTINCT #defineの値を変更して再コンパイルする必要があります。</target>
        </trans-unit>
        <trans-unit id="ef8babc1f36de58a996ade599caa2a6556653b1a" translate="yes" xml:space="preserve">
          <source>It is possible to tell whether or not the 'merge' command found any b-trees to merge together by checking the value returned by the &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; API before and after the command is executed. If the difference between the two values is 2 or greater, then work was performed. If the difference is less than 2, then the 'merge' command was a no-op. In this case there is no reason to execute the same 'merge' command again, at least until after the FTS table is next updated.</source>
          <target state="translated">コマンドの実行前後に&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt; APIから返された値を確認することで、 'merge'コマンドがマージするbツリーを見つけたかどうかを判断できます。2つの値の差が2以上の場合、作業は実行されています。差が2未満の場合、 'merge'コマンドは何もしませんでした。この場合、少なくともFTSテーブルが次に更新されるまでは、同じ「マージ」コマンドを再度実行する必要はありません。</target>
        </trans-unit>
        <trans-unit id="e63e80c9bba9974f9e6774ae97788b65cf7107ad" translate="yes" xml:space="preserve">
          <source>It is possible to write into the &quot;t2&quot; table, thus changing the content of the index. But doing so will get the &quot;t1bc&quot; index out of synchronization with its parent table &quot;t1&quot;. An out-of-sync index can result in incorrect query results.</source>
          <target state="translated">t2 &quot;テーブルに書き込むことが可能で、インデックスの内容を変更することができます。しかし、そうすると、&quot;t1bc &quot;インデックスは親テーブル &quot;t1 &quot;と同期しなくなってしまいます。同期が取れていないインデックスは、正しくないクエリ結果をもたらす可能性がある。</target>
        </trans-unit>
        <trans-unit id="0822da1b538a191177f07ef1dc3b36f0cff1be87" translate="yes" xml:space="preserve">
          <source>It is recommended that applications respond to the errors listed above by explicitly issuing a ROLLBACK command. If the transaction has already been rolled back automatically by the error response, then the ROLLBACK command will fail with an error, but no harm is caused by this.</source>
          <target state="translated">アプリケーションは、明示的にROLLBACKコマンドを発行することによって、上記のエラーに応答することが推奨される。エラー応答によってトランザクションが既に自動的にロールバックされている場合、ROLLBACKコマンドはエラーで失敗しますが、これによって害はありません。</target>
        </trans-unit>
        <trans-unit id="7b7eb3618faa363b4bb6cb76587e213a07280f4c" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">現在データベース操作を実行しているスレッドとは別のスレッドからこのルーチンを呼び出しても安全です。しかし、sqlite3_interrupt（）が戻る前に閉じられているか、閉じられる可能性のある&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;でこのルーチンを呼び出すのは安全ではありません。</target>
        </trans-unit>
        <trans-unit id="0d70d917087b8b111a765ae7a55cfbd2640b316e" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">現在データベース操作を実行しているスレッドとは別のスレッドからこのルーチンを呼び出しても安全です。しかし、sqlite3_interrupt（）が戻る前に閉じられているか、閉じられる可能性のある&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;でこのルーチンを呼び出すのは安全ではありません。</target>
        </trans-unit>
        <trans-unit id="d9e98c95444e8fd3d643f309806f8f5b2d312406" translate="yes" xml:space="preserve">
          <source>It is safe to execute SQL statements, including those that write to the table that the callback related to, from within the xConflict callback. This can be used to further customize the application's conflict resolution strategy.</source>
          <target state="translated">xConflict コールバック内から、コールバックが関連するテーブルへの書き込みを含む SQL 文を実行しても安全です。これを使用して、アプリケーションの競合解決戦略をさらにカスタマイズすることができます。</target>
        </trans-unit>
        <trans-unit id="7155cc55f906067b466a3957abc2b2fa5ca703ab" translate="yes" xml:space="preserve">
          <source>It is safe to execute SQL statements, including those that write to the table that the callback related to, from within the xConflict callback. This can be used to further customize the applications conflict resolution strategy.</source>
          <target state="translated">コールバックが関連するテーブルへの書き込みを含む SQL 文を xConflict コールバック内から実行しても安全です。これを使用して、アプリケーションの競合解決戦略をさらにカスタマイズすることができます。</target>
        </trans-unit>
        <trans-unit id="33153f14bd397b5e62d91fe18b2589aae1781966" translate="yes" xml:space="preserve">
          <source>It is sometimes convenient for SQLite extensions to communicate non-SQL values between subcomponents or between the extension and the application. Some examples:</source>
          <target state="translated">SQLite の拡張機能では、サブコンポーネント間や拡張機能とアプリケーション間で非 SQL 値を通信するのが便利な場合があります。いくつかの例があります。</target>
        </trans-unit>
        <trans-unit id="4e37312abd7d96cc7759f842b46f93a1a662f8a0" translate="yes" xml:space="preserve">
          <source>It is still the responsibility of the user to ensure that the contents of an external content FTS5 table are kept up to date with the content table. One way to do this is with triggers. For example:</source>
          <target state="translated">外部コンテンツFTS5テーブルのコンテンツがコンテンツテーブルと最新の状態に保たれていることを確認することは、依然としてユーザーの責任である。これを行う1つの方法は、トリガーを使用することです。例えば、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="9c7272134156136dee6648bc42ced66fabf0b75c" translate="yes" xml:space="preserve">
          <source>It is the nature of the Guttman R-Tree algorithm that any write might radically restructure the tree, and in the process change the scan order of the nodes. For this reason, it is not generally possible to modify the R-Tree in the middle of a query of the R-Tree. Attempts to do so will fail with a &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; &quot;database table is locked&quot; error.</source>
          <target state="translated">書き込みによってツリーが根本的に再構築され、その過程でノードのスキャン順序が変更されるのは、GuttmanR-Treeアルゴリズムの性質です。このため、通常、Rツリーのクエリの途中でRツリーを変更することはできません。そうしようとすると、&lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;「データベーステーブルがロックされています」エラーで失敗します。</target>
        </trans-unit>
        <trans-unit id="5653d5d90f75b604cccae96a448a1866fdfa38fe" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually call sqlite3_free() on the *ppOut pointer to free the buffer allocation following a successful call to this function.</source>
          <target state="translated">この関数の呼び出しに成功した後、バッファアロケーションを解放するために、最終的に*ppOutポインタでsqlite3_free()を呼び出すのは呼び出し元の責任です。</target>
        </trans-unit>
        <trans-unit id="ea70438336584a95d4e17716f1df0d6b713aeb3b" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize（）に&lt;/a&gt;渡してイテレータを最終的に破棄するのは、呼び出し元の責任です。変更セット（pChangeset）を含むバッファは、イテレータが破棄されるまで有効のままである必要があります。</target>
        </trans-unit>
        <trans-unit id="f0493c91af19ce8153b8e56f3f8a534dd5019c91" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">&lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize（）に&lt;/a&gt;渡してイテレータを最終的に破棄するのは、呼び出し元の責任です。変更セット（pChangeset）を含むバッファは、イテレータが破棄されるまで有効のままである必要があります。</target>
        </trans-unit>
        <trans-unit id="6d23d845a723659b2b2994a8ad4c9862067cda40" translate="yes" xml:space="preserve">
          <source>It is true that applications sometimes import complete binary SQLite database files from untrusted sources, and such imports could present a possible attack vector. However, those code paths in SQLite are limited and are extremely well tested. And pre-validation routines are available to applications that want to read untrusted databases that can help detect possible attacks prior to use.</source>
          <target state="translated">確かに、アプリケーションが信頼できないソースから完全なバイナリSQLiteデータベースファイルをインポートすることがあり、そのようなインポートが攻撃のベクトルとなる可能性があります。しかし、SQLite のコードパスは限られており、非常によくテストされています。また、信頼されていないデータベースを読みたいアプリケーションには、使用前に攻撃の可能性を検出するための事前検証ルーチンが用意されています。</target>
        </trans-unit>
        <trans-unit id="c6122ba39afe0e09e2d2af761ca27152501399d2" translate="yes" xml:space="preserve">
          <source>It is usually an error to attempt to create a new table in a database that already contains a table, index or view of the same name. However, if the &quot;IF NOT EXISTS&quot; clause is specified as part of the CREATE TABLE statement and a table or view of the same name already exists, the CREATE TABLE command simply has no effect (and no error message is returned). An error is still returned if the table cannot be created because of an existing index, even if the &quot;IF NOT EXISTS&quot; clause is specified.</source>
          <target state="translated">通常、同じ名前のテーブル、インデックス、ビューが既に存在するデータベースに新しいテーブルを作成しようとするとエラーになります。しかし、&quot;IF NOT EXISTS &quot;句がCREATE TABLE文の一部として指定され、同名のテーブルやビューが既に存在する場合、CREATE TABLEコマンドは何の効果もありません(エラーメッセージも返されません)。IF NOT EXISTS &quot;句が指定されていても、既存のインデックスのためにテーブルを作成できない場合、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="6955fa966a557f5231f3a39e108f89afbdbb1b83" translate="yes" xml:space="preserve">
          <source>It may not be used on a database that contains &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expridx&quot;&gt;式のインデックス&lt;/a&gt;を含むデータベースでは使用できません。</target>
        </trans-unit>
        <trans-unit id="16a2200cb76f9664274f3ef9da8045211e14cc43" translate="yes" xml:space="preserve">
          <source>It might be that there are conflicts in the merge. Conflicts occur when the same line of code was changed in different ways between circles (1) and (4) versus circles (2) and (3). The merge command will announce any conflicts and will include both versions of the conflicting lines in the output. You will need to bring up the files that contain conflicts and manually resolve the conflicts.</source>
          <target state="translated">マージにコンフリクトが発生している可能性があります。コンフリクトは、同じ行のコードが丸(1)と(4)と丸(2)と(3)の間で異なる方法で変更された場合に発生します。merge コマンドは、競合があった場合にその旨を通知し、競合している行の両方のバージョンを出力に含めます。競合を含むファイルを表示し、手動で競合を解決する必要があります。</target>
        </trans-unit>
        <trans-unit id="129a00b2ad750693913d2844d8acb7e806afdd09" translate="yes" xml:space="preserve">
          <source>It must not be possible to make the LIKE or GLOB operator true by having a numeric value (instead of a string or blob) on the left-hand side. This means that either:</source>
          <target state="translated">左側に(文字列やブロブではなく)数値を持つことで、LIKEやGLOB演算子を真にすることはできないはずです。つまり、どちらかが</target>
        </trans-unit>
        <trans-unit id="e56780a95b18eed6f05e0be25053224b3c52ac99" translate="yes" xml:space="preserve">
          <source>It was necessary to move to version 3.0 to implement these features because each requires incompatible changes to the database file format. Other incompatible changes, such as a cleanup of the API, were introduced at the same time under the theory that it is best to get your incompatible changes out of the way all at once.</source>
          <target state="translated">これらの機能を実装するためには、それぞれがデータベースファイル形式に互換性のない変更を必要とするため、バージョン3.0に移行する必要がありました。APIのクリーンアップのような他の互換性のない変更は、互換性のない変更を一度に済ませるのが最善であるという理論のもとに、同時に導入されました。</target>
        </trans-unit>
        <trans-unit id="8d41777ca525f229dab6b56dd5c34598aff8efa5" translate="yes" xml:space="preserve">
          <source>It works with unicode (UTF8) text.</source>
          <target state="translated">unicode (UTF8)テキストで動作します。</target>
        </trans-unit>
        <trans-unit id="829d920a492c6126eef1531c8e8c0e1ab7033bd1" translate="yes" xml:space="preserve">
          <source>Its master journal exists or the master journal name is an empty string, and</source>
          <target state="translated">そのマスター・ジャーナルが存在するか、マスター・ジャーナル名が空文字列であり</target>
        </trans-unit>
        <trans-unit id="a9d92a1b4a228c7e648d8125ef5d3c71b3cd4ff7" translate="yes" xml:space="preserve">
          <source>Its size is greater than 512 bytes, and</source>
          <target state="translated">そのサイズは512バイトよりも大きく</target>
        </trans-unit>
        <trans-unit id="0239a4728421bae8f8eeba1f3844a6c5e5e3d81b" translate="yes" xml:space="preserve">
          <source>Its super-journal exists or the super-journal name is an empty string, and</source>
          <target state="translated">そのスーパージャーナルが存在するか、スーパージャーナル名が空文字列であり</target>
        </trans-unit>
        <trans-unit id="73bd910d330560ea1012376a486871434fb0c82d" translate="yes" xml:space="preserve">
          <source>J. M. Robson. &quot;Bounds for Some Functions Concerning Dynamic Storage Allocation&quot;.</source>
          <target state="translated">J.J.M.ロブソン &quot;動的ストレージ割り当てに関するいくつかの関数の境界&quot;</target>
        </trans-unit>
        <trans-unit id="9a3f6528f2606d1ed81f1e9f85b624a26b98cbbe" translate="yes" xml:space="preserve">
          <source>JOIN</source>
          <target state="translated">JOIN</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="935b885e280c10afb46d2bf45f85bbea09bc94ce" translate="yes" xml:space="preserve">
          <source>JSON support</source>
          <target state="translated">JSON サポート</target>
        </trans-unit>
        <trans-unit id="69a65023a22e8f6d2ee1c6c6ee36c64ccb6d5c6d" translate="yes" xml:space="preserve">
          <source>Join order</source>
          <target state="translated">順番に参加する</target>
        </trans-unit>
        <trans-unit id="63acacbd536ebc7829ae48a83492249201168016" translate="yes" xml:space="preserve">
          <source>Join reordering is automatic and usually works well enough that programmers do not have to think about it, especially if &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been used to gather statistics about the available indices. But occasionally some hints from the programmer are needed. Consider, for example, the following schema:</source>
          <target state="translated">結合の並べ替えは自動的に行われ、通常は十分に機能します。特に、利用可能なインデックスに関する統計を収集するために&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;が使用されている場合は、プログラマが考える必要はありません。ただし、プログラマーからのヒントが必要になる場合があります。たとえば、次のスキーマについて考えてみます。</target>
        </trans-unit>
        <trans-unit id="36cb6826dbbbacc9f0915d9e44ccb82925b04c72" translate="yes" xml:space="preserve">
          <source>Joins</source>
          <target state="translated">Joins</target>
        </trans-unit>
        <trans-unit id="742ad08bca9c2e1be08d58aae42e6201c809dcf9" translate="yes" xml:space="preserve">
          <source>Journal File Format</source>
          <target state="translated">ジャーナルファイル形式</target>
        </trans-unit>
        <trans-unit id="debc03f25ef5600d2ed4edf18b01b3412bb71c87" translate="yes" xml:space="preserve">
          <source>Journal Header Format</source>
          <target state="translated">ジャーナルヘッダー形式</target>
        </trans-unit>
        <trans-unit id="ccdedfc7a4a23f259c6823eed7a5e93d7a6e430f" translate="yes" xml:space="preserve">
          <source>Journal Record Format</source>
          <target state="translated">ジャーナルレコード形式</target>
        </trans-unit>
        <trans-unit id="683ff0cc3706704c295b1d1835a7e2e4c3a2a6b7" translate="yes" xml:space="preserve">
          <source>Journal of the Association for Computing Machinery</source>
          <target state="translated">計算機学会誌</target>
        </trans-unit>
        <trans-unit id="769726f4101068333430cd9eee0a56b7dfd75235" translate="yes" xml:space="preserve">
          <source>JournalMode</source>
          <target state="translated">JournalMode</target>
        </trans-unit>
        <trans-unit id="c0e70f1bd285ac28ec38cf9261dd9cf6df3840dd" translate="yes" xml:space="preserve">
          <source>Journalling a Database Page</source>
          <target state="translated">データベースのページを追記する</target>
        </trans-unit>
        <trans-unit id="b576bd921c8bd5cb6e5720fc3c6797d3e02e8d08" translate="yes" xml:space="preserve">
          <source>Journalling a page</source>
          <target state="translated">ページを追悼する</target>
        </trans-unit>
        <trans-unit id="84e304128c1076094ba7ee02aeb09745e71eaf53" translate="yes" xml:space="preserve">
          <source>Julian day number</source>
          <target state="translated">ユリウスの日番号</target>
        </trans-unit>
        <trans-unit id="1eba140fdd9c6860a1730c408e3064aa417ca2a3" translate="yes" xml:space="preserve">
          <source>Jump</source>
          <target state="translated">Jump</target>
        </trans-unit>
        <trans-unit id="5d84018241481efa31572e7a64ddf20102d5a735" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is False. The value is considered false if it has a numeric value of zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">レジスタP1の値がFalseの場合はP2にジャンプします。値が0の数値の場合はFalseとみなされます。P1の値がNULLの場合は、P3が0でない場合にのみジャンプします。</target>
        </trans-unit>
        <trans-unit id="c02affea77793c1c3281caf3fff7c025052fcd28" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is NULL.</source>
          <target state="translated">レジスタP1の値がNULLの場合はP2にジャンプします。</target>
        </trans-unit>
        <trans-unit id="9d04284895be3aad627f0d99db148ecf0772d61d" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is not NULL.</source>
          <target state="translated">レジスタP1の値がNULLでなければP2にジャンプします。</target>
        </trans-unit>
        <trans-unit id="38d677f93cf11ed33026afa36fe1f252297e13d5" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is true. The value is considered true if it is numeric and non-zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">レジスタP1の値が真であればP2にジャンプします。数値で0以外の値であれば真とみなされます。P1の値がNULLの場合は、P3が0でない場合にのみジャンプします。</target>
        </trans-unit>
        <trans-unit id="04a8d1cd1316034cf886277bf2c8dd963c76b71c" translate="yes" xml:space="preserve">
          <source>Jump to the instruction at address P1, P2, or P3 depending on whether in the most recent &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; instruction the P1 vector was less than equal to, or greater than the P2 vector, respectively.</source>
          <target state="translated">最新の&lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt;命令で、P1ベクトルがP2ベクトルと同じかそれよりも小さいかによって、アドレスP1、P2、またはP3にある命令にジャンプします。</target>
        </trans-unit>
        <trans-unit id="029dc808e2fcf8db0d9a3400f04a64bf760921ba" translate="yes" xml:space="preserve">
          <source>Jump to the next instruction after the address in register P1. After the jump, register P1 becomes undefined.</source>
          <target state="translated">レジスタP1のアドレスの次の命令にジャンプします。ジャンプ後、レジスタP1は未定義となります。</target>
        </trans-unit>
        <trans-unit id="be91c2cd21e07ee8ceb31ed436dfe5c08c9a83b6" translate="yes" xml:space="preserve">
          <source>Just as there is the &quot;zip&quot; program to manage ZIP Archives, and the &quot;tar&quot; program to manage Tarballs, the &lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;&quot;sqlar&quot; program&lt;/a&gt; exists to manage SQL Archives. The &quot;sqlar&quot; program is able to create a new SQLite Archive, list the content of an existing archive, add or remove files from the archive, and/or extract files from the archive. A separate &quot;sqlarfs&quot; program is able to mount the SQLite Archive as a &lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;Fuse Filesystem&lt;/a&gt;.</source>
          <target state="translated">ZIPアーカイブを管理するための「zip」プログラムと、Tarballを管理するための&lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;「tar」プログラム&lt;/a&gt;があるように、SQLアーカイブを管理するための「sqlar」プログラムが存在します。「sqlar」プログラムは、新しいSQLiteアーカイブの作成、既存のアーカイブの内容の一覧表示、アーカイブからのファイルの追加または削除、および/またはアーカイブからのファイルの抽出を行うことができます。別の「sqlarfs」プログラムは、SQLiteアーカイブを&lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;Fuseファイルシステム&lt;/a&gt;としてマウントできます。</target>
        </trans-unit>
        <trans-unit id="dd65c1b4b3e66e765523873bd29cf5d6d6838189" translate="yes" xml:space="preserve">
          <source>KEY</source>
          <target state="translated">KEY</target>
        </trans-unit>
        <trans-unit id="d27c8f02c4abf5f11c1eced4acd8b35520a9fe80" translate="yes" xml:space="preserve">
          <source>Keep constant guard over the actions of your life.</source>
          <target state="translated">あなたの人生の行動を常に見守ってください。</target>
        </trans-unit>
        <trans-unit id="194e669a908d39900cf589c5a981d721d7c9618b" translate="yes" xml:space="preserve">
          <source>Keep death daily before your eyes.</source>
          <target state="translated">目の前の死を毎日維持してください。</target>
        </trans-unit>
        <trans-unit id="c25db8dd7484e7f7bee803cd3895b18495da35bc" translate="yes" xml:space="preserve">
          <source>Keep the full precision of integers (if possible) when casting to NUMERIC. Ticket #2364</source>
          <target state="translated">NUMERICにキャストする際には、整数の完全な精度を保つようにしてください(可能であれば)。チケット #2364</target>
        </trans-unit>
        <trans-unit id="4989895ac52269498fe4414b7697f7a4c22ad5aa" translate="yes" xml:space="preserve">
          <source>Key points:</source>
          <target state="translated">キーポイント。</target>
        </trans-unit>
        <trans-unit id="08fa4eb3aedd30338134d345421fea84986b3d4a" translate="yes" xml:space="preserve">
          <source>Key take-aways from this essay:</source>
          <target state="translated">このエッセイからの主なポイント。</target>
        </trans-unit>
        <trans-unit id="8b3a8bbf2ec2d401e862eec6bf418d40320b88cb" translate="yes" xml:space="preserve">
          <source>Key/value store for the raw database file content. The key is the page number and the value is binary page content.</source>
          <target state="translated">生のデータベースファイルの内容を格納するキー/値のストア。キーはページ番号、値はバイナリページの内容です。</target>
        </trans-unit>
        <trans-unit id="7b687d48e96f480574af88076704d469738ac8fd" translate="yes" xml:space="preserve">
          <source>Keyword arguments can optionally appear in quotes. (Example: &lt;code&gt;'yes' [FALSE]&lt;/code&gt;.) Some pragmas takes a string literal as their argument. When pragma takes a keyword argument, it will usually also take a numeric equivalent as well. For example, &quot;0&quot; and &quot;no&quot; mean the same thing, as does &quot;1&quot; and &quot;yes&quot;. When querying the value of a setting, many pragmas return the number rather than the keyword.</source>
          <target state="translated">キーワード引数は、オプションで引用符で囲むことができます。（例： &lt;code&gt;'yes' [FALSE]&lt;/code&gt; 。）一部のプラグマは、引数として文字列リテラルを取ります。プラグマがキーワード引数を取る場合、通常は同等の数値も受け取ります。たとえば、「0」と「いいえ」は「1」と「はい」と同じ意味です。設定の値を照会すると、多くのプラグマはキーワードではなく数値を返します。</target>
        </trans-unit>
        <trans-unit id="71d7d3fe2fa70220d2397ae5ef29dbf8ffba7a8b" translate="yes" xml:space="preserve">
          <source>Know for certain that God sees you everywhere.</source>
          <target state="translated">神はどこでもあなたを見ていると確信しています。</target>
        </trans-unit>
        <trans-unit id="7e70d2e585c390da7abcf2a3249245e0e36e0092" translate="yes" xml:space="preserve">
          <source>LAST</source>
          <target state="translated">LAST</target>
        </trans-unit>
        <trans-unit id="969e2cc476ff76be41815b17d8fb9c685f97e243" translate="yes" xml:space="preserve">
          <source>LEFT</source>
          <target state="translated">LEFT</target>
        </trans-unit>
        <trans-unit id="fa443d7d6200af63823dccc305e61eed839b45c2" translate="yes" xml:space="preserve">
          <source>LEFT JOIN</source>
          <target state="translated">左結合</target>
        </trans-unit>
        <trans-unit id="06214bf7efebdbadf0fc2e8285b451472a810158" translate="yes" xml:space="preserve">
          <source>LEFT JOIN elimination often comes up when LEFT JOINs are used inside of views, and then the view is used in such as way that none of the columns of the right-hand table of the LEFT JOIN are referenced.</source>
          <target state="translated">LEFT JOINの排除は、LEFT JOINがビューの内部で使用され、LEFT JOINの右側のテーブルの列がどれも参照されないような方法でビューが使用されている場合によく発生します。</target>
        </trans-unit>
        <trans-unit id="228baedd626cec5fb29f832c085ce530c565f626" translate="yes" xml:space="preserve">
          <source>LEFT JOIN strength reduction optimization</source>
          <target state="translated">LEFT JOIN強度低下最適化</target>
        </trans-unit>
        <trans-unit id="e43376033cc5d4106eb2e868e3b049e3915b255f" translate="yes" xml:space="preserve">
          <source>LEFT OUTER JOIN is implemented, but not RIGHT OUTER JOIN or FULL OUTER JOIN.</source>
          <target state="translated">LEFT OUTER JOINは実装されていますが、RIGHT OUTER JOINやFULL OUTER JOINは実装されていません。</target>
        </trans-unit>
        <trans-unit id="5ddf6f04739d8bc3a11b487863b27a7bcaa6fc24" translate="yes" xml:space="preserve">
          <source>LIKE</source>
          <target state="translated">LIKE</target>
        </trans-unit>
        <trans-unit id="92323e665381f4f6e8310e0e8d0ab85b11facf9e" translate="yes" xml:space="preserve">
          <source>LIKE optimization</source>
          <target state="translated">LIKE最適化</target>
        </trans-unit>
        <trans-unit id="c385d79f275c108bd6a32af099948cfc74a92c05" translate="yes" xml:space="preserve">
          <source>LIKE optimization now works for columns with COLLATE NOCASE</source>
          <target state="translated">COLLATE NOCASE を持つカラムで LIKE 最適化が動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="9c590af5665cfc2916823206547377e482547e1d" translate="yes" xml:space="preserve">
          <source>LIMIT</source>
          <target state="translated">LIMIT</target>
        </trans-unit>
        <trans-unit id="40c4547fe7d52f08474372a32d5cd65ef3e61db8" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now shows no rows. Use LIMIT -1 to see all rows.</source>
          <target state="translated">LIMIT 0では行が表示されません。すべての行を表示するにはLIMIT -1を使用してください。</target>
        </trans-unit>
        <trans-unit id="e120f1515582fd60e3aa87caeded6a95706ff6a5" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now works on subqueries</source>
          <target state="translated">LIMIT 0がサブクエリで動作するようになりました</target>
        </trans-unit>
        <trans-unit id="2726a4b3c5be6bc17db3c5aa67da0f6e30ea159f" translate="yes" xml:space="preserve">
          <source>LIMIT_ATTACH</source>
          <target state="translated">LIMIT_ATTACH</target>
        </trans-unit>
        <trans-unit id="e8bf21b0d0f3b850c955bb94b5141253b1ae7e2a" translate="yes" xml:space="preserve">
          <source>LIMIT_COLUMN</source>
          <target state="translated">LIMIT_COLUMN</target>
        </trans-unit>
        <trans-unit id="7b09e7eae5f068cca9e40a4e561d97d66518a255" translate="yes" xml:space="preserve">
          <source>LIMIT_COMPOUND_SELECT</source>
          <target state="translated">LIMIT_COMPOUND_SELECT</target>
        </trans-unit>
        <trans-unit id="b1c8f4255d541a1d18f761d25857086f40b1bf20" translate="yes" xml:space="preserve">
          <source>LIMIT_EXPR_DEPTH</source>
          <target state="translated">LIMIT_EXPR_DEPTH</target>
        </trans-unit>
        <trans-unit id="2a0de541f4fa62311ff3575519dfacbb5ae6b11e" translate="yes" xml:space="preserve">
          <source>LIMIT_FUNCTION_ARG</source>
          <target state="translated">LIMIT_FUNCTION_ARG</target>
        </trans-unit>
        <trans-unit id="1a3a784fe44fc702cae042a37cb3ba3e0f6fa7ac" translate="yes" xml:space="preserve">
          <source>LIMIT_LENGTH</source>
          <target state="translated">LIMIT_LENGTH</target>
        </trans-unit>
        <trans-unit id="72fc2492f41deaa54c2dac4538490fafaa14d0d6" translate="yes" xml:space="preserve">
          <source>LIMIT_LIKE_PATTERN_LENGTH</source>
          <target state="translated">LIMIT_LIKE_PATTERN_LENGTH</target>
        </trans-unit>
        <trans-unit id="5e8999dc05d8b9aa066f6d09239a0ae740e36f64" translate="yes" xml:space="preserve">
          <source>LIMIT_SQL_LENGTH</source>
          <target state="translated">LIMIT_SQL_LENGTH</target>
        </trans-unit>
        <trans-unit id="db5d695bfcc2c3ebffa6c7ffcd096c20b8eed97c" translate="yes" xml:space="preserve">
          <source>LIMIT_TRIGGER_DEPTH</source>
          <target state="translated">LIMIT_TRIGGER_DEPTH</target>
        </trans-unit>
        <trans-unit id="16d75adbe3aa654b347523eb12544c39563f5b43" translate="yes" xml:space="preserve">
          <source>LIMIT_VARIABLE_NUMBER</source>
          <target state="translated">LIMIT_VARIABLE_NUMBER</target>
        </trans-unit>
        <trans-unit id="a604921b15950316535a24537e634352270c370e" translate="yes" xml:space="preserve">
          <source>LIMIT_VDBE_OP</source>
          <target state="translated">LIMIT_VDBE_OP</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="7428d00a0b1c6a4c3041c21ce5ceb9dbaa4b015a" translate="yes" xml:space="preserve">
          <source>Large WAL files</source>
          <target state="translated">大容量のWALファイル</target>
        </trans-unit>
        <trans-unit id="d1c69a859a9638b242f2dabf8acf1c0b1450ce6b" translate="yes" xml:space="preserve">
          <source>Last</source>
          <target state="translated">Last</target>
        </trans-unit>
        <trans-unit id="07235ffa8a70d2e51e9570c942d05e5b5851a313" translate="yes" xml:space="preserve">
          <source>Last Insert Rowid</source>
          <target state="translated">最終インサート ロイド</target>
        </trans-unit>
        <trans-unit id="7f81d5c9ec25b5fa1a2640b99a8421ac6c71b017" translate="yes" xml:space="preserve">
          <source>Later, SQLite version 3.6.16 is released, as shown by circle (4) in the diagram. At the point, the private branch maintainer does a merge which takes all of the changes going from (1) to (4) and applies those changes to (3). The result is version (5), which is SQLite 3.6.16 plus edits.</source>
          <target state="translated">その後、図中の丸(4)で示すように、SQLite バージョン 3.6.16 がリリースされます。この時点で、プライベートブランチのメンテナは、(1)から(4)への変更をすべてマージし、それらの変更を(3)に適用します。その結果、バージョン(5)はSQLite 3.6.16に編集を加えたものになります。</target>
        </trans-unit>
        <trans-unit id="e07edacb2555a09c495279c3384f36a675435d8d" translate="yes" xml:space="preserve">
          <source>Le</source>
          <target state="translated">Le</target>
        </trans-unit>
        <trans-unit id="fa3757f35a67a972328ec50d59fdef6fec4d197a" translate="yes" xml:space="preserve">
          <source>Leading spaces are removed.</source>
          <target state="translated">リーディングスペースは削除されています。</target>
        </trans-unit>
        <trans-unit id="1dae495d04abf17bb3895a89b30ae8efcca9f3f1" translate="yes" xml:space="preserve">
          <source>Leaf payload fraction. Must be 32.</source>
          <target state="translated">リーフペイロード分数。32である必要があります。</target>
        </trans-unit>
        <trans-unit id="e2626d2b1592bacc07397cf31582efd1c5b2420a" translate="yes" xml:space="preserve">
          <source>Left operand</source>
          <target state="translated">左オペランド</target>
        </trans-unit>
        <trans-unit id="203223a5600f328f50c6338dfe2e4c11e8803475" translate="yes" xml:space="preserve">
          <source>Left operand found</source>
          <target state="translated">左のオペランドが見つかりました。</target>
        </trans-unit>
        <trans-unit id="865d1c5dcc029d18d1621430419ee2f04f5f424f" translate="yes" xml:space="preserve">
          <source>Left-justify the value in the output. The default is to right-justify. If the width is zero or is otherwise less than the length of the value being substituted, then there is no padding and the &quot;-&quot; flag is a no-op.</source>
          <target state="translated">出力の値を左寄せにします。デフォルトは右寄せである。幅が0であるか、置換される値の長さよりも小さい場合は、パディングはなく、&quot;-&quot;フラグは無効です。</target>
        </trans-unit>
        <trans-unit id="1877e2f919fe86f5371e6a3e7d9d6b6080bf4d57" translate="yes" xml:space="preserve">
          <source>Legacy (older than 3.22.0) versions of the sessions module cannot capture changes made to the sqlite_stat1 table. Legacy versions of the sqlite3changeset_apply() function silently ignore any modifications to the sqlite_stat1 table that are part of a changeset or patchset.</source>
          <target state="translated">レガシーバージョン(3.22.0より古い)のセッションモジュールでは、sqlite_stat1テーブルに加えられた変更を捕捉できません。sqlite3changeset_apply()関数のレガシーバージョンは、チェンジセットやパッチセットの一部であるsqlite_stat1テーブルへの変更を黙って無視します。</target>
        </trans-unit>
        <trans-unit id="48078fcdb6dc318fa741d70a2ecdb6ae1437e609" translate="yes" xml:space="preserve">
          <source>Lemon does not have its own source repository. Rather, Lemon consists of a few files in the SQLite source tree:</source>
          <target state="translated">Lemonは独自のソースリポジトリを持っていません。むしろ、Lemon は SQLite ソースツリーの中のいくつかのファイルから構成されています。</target>
        </trans-unit>
        <trans-unit id="bf0578b2a25d2e804bfd4deee5634450a8293393" translate="yes" xml:space="preserve">
          <source>Lemon generates an LALR(1) parser. It's operation is similar to the more familiar tools &lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt;, but Lemon adds important improvements, including:</source>
          <target state="translated">レモンはLALR（1）パーサーを生成します。その操作は、より身近なツールである&lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt;や&lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt;に似ていますが、Lemonには次のような重要な改善が加えられています。</target>
        </trans-unit>
        <trans-unit id="ae32ad1b62e795e4b0f91393920f4a7aff7c555a" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a &quot;fallback&quot; tokens. The SQL language contains a large number of keywords and these keywords have the potential to collide with identifier names. Lemon has the ability to designate some keywords has being able to &quot;fallback&quot; to an identifier. If the keyword appears in the input token stream in a context that would otherwise be a syntax error, the token is automatically transformed into its fallback before the syntax error is raised. This feature allows the parser to be very forgiving of reserved words used as identifiers, which is a problem that comes up frequently in the SQL language.</source>
          <target state="translated">レモンには「フォールバック」トークンという概念があります。SQL言語には多数のキーワードが含まれており、これらのキーワードは識別子名と衝突する可能性があります。Lemonは、いくつかのキーワードを識別子に &quot;フォールバック &quot;することができるように指定する機能を持っています。キーワードが構文エラーとなるコンテキストで入力トークンストリームに現れた場合、構文エラーが発生する前に、トークンは自動的にそのフォールバックに変換されます。この機能により、パーサは識別子として使用される予約語に対して非常に寛容になることができます。</target>
        </trans-unit>
        <trans-unit id="2f9dc02cb8bf5b03f6591dbb44f0a7a4b90f82f4" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a non-terminal destructor that can be used to reclaim memory or other resources following a syntax error or other aborted parse.</source>
          <target state="translated">レモンは、構文エラーや他のアボートされたパースに続くメモリや他のリソースを取り戻すために使用できる非終端デストラクタの概念を持っています。</target>
        </trans-unit>
        <trans-unit id="cee927c3e2d6e42d43d5738f627f3200d5121eac" translate="yes" xml:space="preserve">
          <source>Lemon is also used to generate parse for the query pattern expressions in the &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; extension. In this case, the input grammar file is &lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt;.</source>
          <target state="translated">レモンは、&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;拡張機能でクエリパターン式の解析を生成するためにも使用されます。この場合、入力文法ファイルは&lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="611d0deb28e86cca8303457d918752428288861c" translate="yes" xml:space="preserve">
          <source>Lemon is used in two places in SQLite.</source>
          <target state="translated">レモンはSQLiteでは2箇所で使われています。</target>
        </trans-unit>
        <trans-unit id="0045a01f71c39a54c68dbc362b5b7275372032f5" translate="yes" xml:space="preserve">
          <source>Lemon supports conditional compilation of grammar file rules, so that a different parser can be generated depending on compile-time options.</source>
          <target state="translated">Lemonは文法ファイルルールの条件付きコンパイルをサポートしているので、コンパイル時のオプションに応じて異なるパーサーを生成することができます。</target>
        </trans-unit>
        <trans-unit id="c5c89f378ce33982d309c573eb1ff14dd3f01e8a" translate="yes" xml:space="preserve">
          <source>Lemon was original written by D. Richard Hipp (also the creator of SQLite) while he was in graduate school at Duke University between 1987 and 1992. The original creation date of Lemon has been lost, but was probably sometime around 1990. Lemon generates an LALR(1) parser. There was companion LL(1) parser generator tool named &quot;Lime&quot;, but the source code for Lime has been lost.</source>
          <target state="translated">Lemonは、D.Richard Hipp(SQLiteの生みの親でもある)が1987年から1992年の間にデューク大学の大学院に在籍していた時に書いたものです。Lemonのオリジナルの作成日は失われていますが、おそらく1990年頃のことでしょう。LemonはLALR(1)パーサを生成します。Limeという名前のLL(1)パーサ生成ツールがありましたが、Limeのソースコードは失われています。</target>
        </trans-unit>
        <trans-unit id="aa1fa89453ad95c8f115feb4d323d1e9b329630d" translate="yes" xml:space="preserve">
          <source>Length Specifier</source>
          <target state="translated">長さ指定</target>
        </trans-unit>
        <trans-unit id="c999fb0a278ca9591b2cd0c03ceaa3328da57984" translate="yes" xml:space="preserve">
          <source>Less administration means that programmers spend more time working on the software (SQLite in this case) and less time fussing with the version control system.</source>
          <target state="translated">管理が少ないということは、プログラマーがソフトウェア(この場合はSQLite)の作業に時間を割いて、バージョン管理システムと格闘する時間が少ないということです。</target>
        </trans-unit>
        <trans-unit id="cbcb5b1fa488787750d49ab79f8ec375ce5124b9" translate="yes" xml:space="preserve">
          <source>Less memory used</source>
          <target state="translated">使用メモリの削減</target>
        </trans-unit>
        <trans-unit id="bc720094b72d521a9bad35bfe37f02c776160039" translate="yes" xml:space="preserve">
          <source>Let K be M+((P-M)%(U-4)).</source>
          <target state="translated">KをM+((P-M)%(U-4)とする。)</target>
        </trans-unit>
        <trans-unit id="ec5fd8c108643b71cf1bdd72351ff3e987fc1a5d" translate="yes" xml:space="preserve">
          <source>Let X be ((U-12)*64/255)-23. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the index b-tree page is K if K is less than or equal to X or M otherwise. The number of bytes stored on the index page is never less than M.</source>
          <target state="translated">X を ((U-12)*64/255)-23 とする。ペイロードサイズPがX以下の場合、ペイロード全体がb-treeページに格納されます。M を ((U-12)*32/255)-23 とし、K を M+((P-M)%(U-4))とします。PがXより大きい場合、インデックスのb-treeページに格納されているバイト数は、KがX以下であればKであり、そうでなければMである。インデックスページに格納されているバイト数は、M以下になることはありません。</target>
        </trans-unit>
        <trans-unit id="3814595cf4d53307c33619bbcfd8505bff49fec5" translate="yes" xml:space="preserve">
          <source>Let X be U-35. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree leaf page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the table b-tree leaf page is K if K is less or equal to X or M otherwise. The number of bytes stored on the leaf page is never less than M.</source>
          <target state="translated">X を U-35 とする。ペイロードサイズPがX以下の場合、ペイロード全体がb-treeリーフページに格納されます。M を ((U-12)*32/255)-23 とし、K を M+((P-M)%(U-4))とする。PがXより大きい場合、テーブルのb-treeリーフページに格納されているバイト数は、KがX以下であればKであり、そうでなければMである。リーフページに格納されているバイト数はMより決して小さくない。</target>
        </trans-unit>
        <trans-unit id="04ab6da7aca9e95067f1ce62f19a937e96ff6418" translate="yes" xml:space="preserve">
          <source>Let X be the expression in the WHERE clause of a partial index, and let W be the WHERE clause of a query that uses the table that is indexed. Then, the query is permitted to use the partial index if W&amp;rArr;X, where the &amp;rArr; operator (usually pronounced &quot;implies&quot;) is the logic operator equivalent to &quot;X or not W&quot;. Hence, determining whether or not a partial index is usable in a particular query reduces to proving a theorem in first-order logic.</source>
          <target state="translated">Xを部分インデックスのWHERE句の式とし、Wをインデックス付きのテーブルを使用するクエリのWHERE句とします。次に、クエリはW&amp;rArr;Xの場合、部分インデックスの使用を許可されます。ここで、&amp;rArr;演算子（通常は「暗黙的」と発音）は、「XまたはWではない」と同等の論理演算子です。したがって、特定のクエリで部分インデックスが使用可能かどうかを判断すると、1次論理で定理が証明されます。</target>
        </trans-unit>
        <trans-unit id="8e79f3f73bca370e5a0d09f6e67e4908583572b1" translate="yes" xml:space="preserve">
          <source>Let X be the largest set of consecutive integers {h, h+1, h+2, ..., h+N} such that for every j in X, aPgno[j%8192]!=0. The X set will be empty if aPgno[h%8192]==0. The X set is easily computed by starting with the value h%8192, and adding h%8192 to X and incrementing h until encountering the first aPgno[h%8192] entry that is zero.</source>
          <target state="translated">Xを連続した整数{h,h+1,h+2,...,h+N}の最大の集合とします.Xの各jに対して,aPgno[j%8192]!=0となるような連続した整数{h,h+1,h+2,...,h+N}の集合は,aPgno[h%8192]==0の場合は空になります.Xの集合は,値h%8192から始まり,Xにh%8192を加え,最初のaPgno[h%8192]が0になるまでhを増加させることで簡単に計算できます.</target>
        </trans-unit>
        <trans-unit id="37bafb8ebd6ac523c9fab977240fbaca2d2a4205" translate="yes" xml:space="preserve">
          <source>Let the database page size (the value of the integer at offset 24 in the journal header) be N. Then the format of a page record is as follows:</source>
          <target state="translated">データベースのページサイズ(ジャーナルヘッダのオフセット24の整数値)をNとすると、ページレコードの形式は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="5da01c6ea976760415bf0eb965f5e685ea3c15ec" translate="yes" xml:space="preserve">
          <source>Let the datatypes &quot;u8&quot;, &quot;u16&quot;, and &quot;u32&quot; mean unsigned integers of length 8, 16, and 32 bits, respectively. Then, the first 32768-byte unit of the shm file is organized as follows:</source>
          <target state="translated">データ型 &quot;u8&quot;,&quot;u16&quot;,&quot;u32 &quot;はそれぞれ長さ8,16,32ビットの符号なし整数を意味する。すると、shmファイルの最初の32768バイト単位は以下のように構成される。</target>
        </trans-unit>
        <trans-unit id="bd114f90a251306f5f9680610cc3593a57d82e5b" translate="yes" xml:space="preserve">
          <source>Let the number of alice nodes be M and the number of bob nodes be N. Consider two scenarios. In the first scenario, M and N are both 2 but there are thousands of edges on each node. In this case, option 1 is preferred. With option 1, the inner loop checks for the existence of an edge between a pair of nodes and outputs the result if found. But because there are only 2 alice and bob nodes each, the inner loop only has to run 4 times and the query is very quick. Option 2 would take much longer here. The outer loop of option 2 only executes twice, but because there are a large number of edges leaving each alice node, the middle loop has to iterate many thousands of times. It will be much slower. So in the first scenario, we prefer to use option 1.</source>
          <target state="translated">アライスノードの数をM、ボブノードの数をNとすると、2つのシナリオが考えられる。最初のシナリオでは、MとNは両方とも2であるが、各ノードには数千のエッジがある。この場合,オプション1が好ましい.オプション1では,内部ループはノードのペア間にエッジが存在するかどうかをチェックし,見つかった場合にはその結果を出力します.しかし、aliceとbobのノードはそれぞれ2つしかないので、内部ループは4回しか実行されず、クエリは非常に速くなります。オプション2は、ここではもっと時間がかかります。オプション2の外側のループは2回しか実行されませんが、各aliceノードから出るエッジの数が多いので、真ん中のループは何千回も繰り返し実行しなければなりません。これはもっと遅くなります。そこで、最初のシナリオでは、オプション1を使用することを好みます。</target>
        </trans-unit>
        <trans-unit id="74b220b56c9d6c3f209f91061a8b3234a645c429" translate="yes" xml:space="preserve">
          <source>Let the page count value at offset 8 in the journal header be M. If M is greater than zero then after M page records the journal file may be zero padded out to the next multiple of the sector size and another journal header may be inserted. All journal headers within the same journal must contain the same database page size and sector size.</source>
          <target state="translated">Mがゼロよりも大きい場合、Mページレコードの後、ジャーナルファイルはセクタサイズの次の倍数までゼロパディングされ、別のジャーナルヘッダーが挿入されます。同じジャーナル内のすべてのジャーナルヘッダは、同じデータベースのページサイズとセクタサイズを含まなければなりません。</target>
        </trans-unit>
        <trans-unit id="f44e417ae6158672e12bddd6f44e6cd28bdb55bb" translate="yes" xml:space="preserve">
          <source>Let us assume that you are using the amalgamation source code. Add the baseline to your project as follows:</source>
          <target state="translated">アマルガムのソースコードを使用していると仮定してみましょう。以下のようにプロジェクトにベースラインを追加します。</target>
        </trans-unit>
        <trans-unit id="ae7bd817eacac0a262f119102109a97036180841" translate="yes" xml:space="preserve">
          <source>Let us suppose that instead of using a ZIP archive to store its files, OpenDocument used a very simple SQLite database with the following single-table schema:</source>
          <target state="translated">ファイルを保存するために ZIP アーカイブを使用する代わりに、OpenDocument が以下のような単一テーブルスキーマを持つ非常にシンプルな SQLite データベースを使用していたとします。</target>
        </trans-unit>
        <trans-unit id="ecc5e1e5e0ad7c0dd2b547a397bdb11d90ca6d36" translate="yes" xml:space="preserve">
          <source>Let us use the following notation (similar but not identical to Robson's notation):</source>
          <target state="translated">以下のような表記法(ロブソンの表記法と似ていますが、同じではありません)を使ってみましょう。</target>
        </trans-unit>
        <trans-unit id="2d2261f9e0cbec9edf95c4d47c5f5eb0cbcca2f7" translate="yes" xml:space="preserve">
          <source>Let's be real. Few people seriously dispute that Git provides a suboptimal user experience. A lot of the underlying implementation shows through into the user interface. The interface is so bad that there is even a parody site that generates &lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;fake git man pages&lt;/a&gt;.</source>
          <target state="translated">現実になりましょう。Gitが次善のユーザーエクスペリエンスを提供することに真剣に異議を唱える人はほとんどいません。基礎となる実装の多くは、ユーザーインターフェイスに表示されます。インターフェースが非常に悪いので、&lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;偽のgit manページ&lt;/a&gt;を生成するパロディサイトさえあります。</target>
        </trans-unit>
        <trans-unit id="0f0987eb98b35f60885158c865b4e995d0d04bc9" translate="yes" xml:space="preserve">
          <source>Let's look more closely at what is happening here. The first SELECT is implemented by the loop at instructions 5 through 10. Instruction 5 initializes the loop by rewinding its cursor. Instruction 6 extracts the value of the &quot;two&quot; column from &quot;examp&quot; and instruction 7 converts this into a row. Instruction 8 pushes an empty string onto the stack. Finally, instruction 9 writes the row into the temporary table. But remember, the PutStrKey opcode uses the top of the stack as the record data and the next on stack as the key. For an INSERT statement, the row generated by the MakeRecord opcode is the record data and the record key is an integer created by the NewRecno opcode. But here the roles are reversed and the row created by MakeRecord is the record key and the record data is just an empty string.</source>
          <target state="translated">ここで何が起こっているのか、もう少し詳しく見てみましょう。最初のSELECTは、命令5から10までのループによって実装されています。命令5はカーソルを巻き戻すことでループを初期化します。命令6は「examp」から「2」列の値を抽出し、命令7はこれを行に変換します。命令8は空の文字列をスタックに押し込む。最後に、命令9はその行を一時テーブルに書き込みます。しかし、PutStrKeyオペコードは、スタックの先頭をレコードデータとして使用し、スタックの次の行をキーとして使用することを覚えておいてください。INSERT文では、MakeRecordオペコードによって生成された行がレコード・データであり、レコード・キーはNewRecnoオペコードによって生成された整数です。しかし、ここでは役割が逆になっており、MakeRecordによって生成された行がレコードキーで、レコードデータは単なる空の文字列です。</target>
        </trans-unit>
        <trans-unit id="8ce47b13d09374c0748516f88f9567e0ba880c6e" translate="yes" xml:space="preserve">
          <source>Libraries written in C do not have a huge run-time dependency. In its minimum configuration, SQLite requires only the following routines from the standard C library:</source>
          <target state="translated">C で書かれたライブラリは、ランタイムに大きな依存性を持ちません。最小限の設定では、SQLite が必要とするのは標準 C ライブラリの以下のルーチンだけです。</target>
        </trans-unit>
        <trans-unit id="16b9101f24846717dcb86cc74d99a08aad5ead61" translate="yes" xml:space="preserve">
          <source>Libraries written in C++ or Java can generally only be used by applications written in the same language. It is difficult to get an application written in Haskell or Java to invoke a library written in C++. On the other hand, libraries written in C are callable from any programming language.</source>
          <target state="translated">C++やJavaで書かれたライブラリは、一般的に同じ言語で書かれたアプリケーションでしか使用できません。HaskellやJavaで書かれたアプリケーションからC++で書かれたライブラリを呼び出すことは困難です。一方、Cで書かれたライブラリは、どのプログラミング言語からでも呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="8f218c8346bfddbca30ecf6b104e83b9f15b5e98" translate="yes" xml:space="preserve">
          <source>Library size optimizations.</source>
          <target state="translated">ライブラリサイズの最適化。</target>
        </trans-unit>
        <trans-unit id="3769a60d2f565f40c7f7836558211471f7d8a029" translate="yes" xml:space="preserve">
          <source>Like --file, use file FILE as the archive, but open the file using the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS&lt;/a&gt; so that the archive will be appended to the end of FILE if FILE already exists.</source>
          <target state="translated">--fileと同様に、ファイルFILEをアーカイブとして使用しますが、&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS&lt;/a&gt;を使用してファイルを開き、FILEがすでに存在する場合にアーカイブがFILEの最後に追加されるようにします。</target>
        </trans-unit>
        <trans-unit id="0b095c3da7d05183eec1d9c68eafa22989981539" translate="yes" xml:space="preserve">
          <source>Like contentless tables, external content tables do not support REPLACE conflict handling. Any operations that specify REPLACE conflict handling are handled using ABORT.</source>
          <target state="translated">コンテンツレステーブルと同様に、外部コンテンツテーブルは REPLACE 競合処理をサポートしていません。REPLACE 競合処理を指定した操作は、ABORT を使用して処理されます。</target>
        </trans-unit>
        <trans-unit id="231d089dd7b27b9cd1c3006b16a6dc21b83bfb7e" translate="yes" xml:space="preserve">
          <source>Like other virtual table types, new FTS tables are created using a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. The module name, which follows the USING keyword, is either &quot;fts3&quot; or &quot;fts4&quot;. The virtual table module arguments may be left empty, in which case an FTS table with a single user-defined column named &quot;content&quot; is created. Alternatively, the module arguments may be passed a list of comma separated column names.</source>
          <target state="translated">他の仮想テーブルタイプと同様に、新しいFTSテーブルは&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;ステートメントを使用して作成されます。USINGキーワードに続くモジュール名は、「fts3」または「fts4」のいずれかです。仮想テーブルモジュールの引数は空のままにできます。その場合、「content」という名前の単一のユーザー定義列を持つFTSテーブルが作成されます。または、モジュール引数にカンマ区切りの列名のリストを渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="fd7d7c85c83f29484f2e117602dc4bec07bd365d" translate="yes" xml:space="preserve">
          <source>Like sqlite3rbu_step(), if the vacuum operation has finished, sqlite3rbu_close() returns SQLITE_DONE. If the vacuum has not finished but no error has occurred, SQLITE_OK is returned. Or, if an error has occurred, an SQLite error code is returned. If an error occurred as part of a prior call to sqlite3rbu_step(), sqlite3rbu_close() returns the same error code.</source>
          <target state="translated">sqlite3rbu_step()と同様に、バキューム操作が終了した場合、sqlite3rbu_close()はSQLITE_DONEを返します。バキュームが終了していないがエラーが発生していない場合は、SQLITE_OKが返されます。または、エラーが発生した場合は、SQLiteエラーコードが返されます。sqlite3rbu_step()の前の呼び出しの一部としてエラーが発生した場合、sqlite3rbu_close()は同じエラーコードを返します。</target>
        </trans-unit>
        <trans-unit id="7e8a69dbe9cf8dfea5767671aa0118b3491fc369" translate="yes" xml:space="preserve">
          <source>Like the &quot;.dump&quot; command, &quot;.recover&quot; attempts to convert the entire contents of a database file to text. The difference is that instead of reading data using the normal SQL database interface, &quot;.recover&quot; attempts to reassemble the database based on data extracted directly from as many database pages as possible. If the database is corrupt, &quot;.recover&quot; is usually able to recover data from all uncorrupted parts of the database, whereas &quot;.dump&quot; stops when the first sign of corruption is encountered.</source>
          <target state="translated">dump」コマンドと同様に、「.recover」は、データベースファイルの内容全体をテキストに変換しようとする。違いは、通常のSQLデータベースインターフェイスを使用してデータを読み込むのではなく、&quot;.recover &quot;は可能な限り多くのデータベースページから直接抽出されたデータに基づいてデータベースを再構築しようとする点である。データベースが破損している場合、&quot;.recover &quot;は通常、データベースの破損していないすべての部分からデータを復元することができますが、&quot;.dump &quot;は破損の最初の兆候に遭遇したときに停止します。</target>
        </trans-unit>
        <trans-unit id="86f2b5c75e6099a6cf032f5fc9564b20f9285845" translate="yes" xml:space="preserve">
          <source>Limit Setting</source>
          <target state="translated">リミット設定</target>
        </trans-unit>
        <trans-unit id="dc00d8255b192a092dc29a4b67bc17a891ccaa1d" translate="yes" xml:space="preserve">
          <source>Limit the amount of output that &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; generates.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integer_checkが&lt;/a&gt;生成する出力の量を制限します。</target>
        </trans-unit>
        <trans-unit id="3bc4a74f4bc8f6fbe5d7600c2ffc0ce32f2df522" translate="yes" xml:space="preserve">
          <source>Limit the depth of recursion for JSON objects and arrays in order to avoid excess stack usage in the recursive descent parser. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052&lt;/a&gt;.</source>
          <target state="translated">再帰降下パーサーでスタックが過剰に使用されないように、JSONオブジェクトと配列の再帰の深さを制限します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052の&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="5c73db06777439f7e7a4e0b4ef090767959f015d" translate="yes" xml:space="preserve">
          <source>Limit the maximum amount of memory that SQLite will allocate using the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64()&lt;/a&gt; interface. This helps prevent denial-of-service attacks. To find out how much heap space an application actually needs, run the it against typical inputs and then measure the maximum instantaneous memory usage with the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interface. Set the hard heap limit to the maximum observed instantaneous memory usage plus some margin.</source>
          <target state="translated">&lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64（）&lt;/a&gt;インターフェイスを使用してSQLiteが割り当てるメモリの最大量を制限します。これは、サービス拒否攻撃を防ぐのに役立ちます。アプリケーションが実際に必要とするヒープスペースの量を確認するには、一般的な入力に対してアプリケーションを実行してから、&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;インターフェイスを使用して瞬間的な最大メモリ使用量を測定します。ハードヒープ制限を、観測された最大瞬間メモリ使用量にマージンを加えたものに設定します。</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="cd047048aa9c975f33600c7ec5b79b0145824c1c" translate="yes" xml:space="preserve">
          <source>Limitations And Caveats</source>
          <target state="translated">制限と警告</target>
        </trans-unit>
        <trans-unit id="140fa43a5b0009e4451c320039ee7a35af9ef59d" translate="yes" xml:space="preserve">
          <source>Limitations Of The OpenDocument Presentation Format</source>
          <target state="translated">OpenDocument プレゼンテーションフォーマットの限界</target>
        </trans-unit>
        <trans-unit id="61a0ae3b849d95fb8185df69b96d0ec676fb0688" translate="yes" xml:space="preserve">
          <source>Limits</source>
          <target state="translated">Limits</target>
        </trans-unit>
        <trans-unit id="da74bbdf0c5ba1732a1bcf36654960401f556496" translate="yes" xml:space="preserve">
          <source>Limits In SQLite</source>
          <target state="translated">SQLite での制限</target>
        </trans-unit>
        <trans-unit id="2b535e43758af2a0faba7d7491e8ccc0937261f7" translate="yes" xml:space="preserve">
          <source>Lines that begin with &quot;#&quot; and that are not in the middle of an SQL statement are interpreted as comments.</source>
          <target state="translated">で始まり、SQL文の途中ではない行はコメントとして解釈されます。</target>
        </trans-unit>
        <trans-unit id="56c40b8da457fccee36d2dd25cabffcd286e7be5" translate="yes" xml:space="preserve">
          <source>Link SQLite against a test program that runs approximately 30,000 SQL statements representing a typical workload.</source>
          <target state="translated">典型的なワークロードを代表する約30,000のSQL文を実行するテストプログラムに対してSQLiteをリンクします。</target>
        </trans-unit>
        <trans-unit id="aa106ea45c187562ead66ff45b2537ad9d39d113" translate="yes" xml:space="preserve">
          <source>Linus Torvalds used different words to say much the same thing on the Git mailing list on 2006-06-27:</source>
          <target state="translated">Linus Torvalds さんが 2006-06-27 の Git メーリングリストで違う言葉を使って同じことを言っていました。</target>
        </trans-unit>
        <trans-unit id="518aa8e09ec633a2ee7ca4061837886754889a59" translate="yes" xml:space="preserve">
          <source>List Of Constants:</source>
          <target state="translated">定数のリスト。</target>
        </trans-unit>
        <trans-unit id="c88854d7fb661e5a305fcbc6e6989b1500fbf8a5" translate="yes" xml:space="preserve">
          <source>List Of Functions:</source>
          <target state="translated">機能のリスト。</target>
        </trans-unit>
        <trans-unit id="02564776632cdeb522e81ac2cc1d466134257360" translate="yes" xml:space="preserve">
          <source>List Of Objects:</source>
          <target state="translated">オブジェクトのリスト。</target>
        </trans-unit>
        <trans-unit id="5976b759c2bbe27a2c436cf0d06c399c38f9db0a" translate="yes" xml:space="preserve">
          <source>List Of PRAGMAs</source>
          <target state="translated">PRAGMA一覧</target>
        </trans-unit>
        <trans-unit id="198f4f9677551df3e26744118c9e2c5bcd812876" translate="yes" xml:space="preserve">
          <source>List Of SQLite Constants</source>
          <target state="translated">SQLite 定数のリスト</target>
        </trans-unit>
        <trans-unit id="b6b508ee374f53a81be169f4d47397a7a1f331e0" translate="yes" xml:space="preserve">
          <source>List Of SQLite Functions</source>
          <target state="translated">SQLite 関数のリスト</target>
        </trans-unit>
        <trans-unit id="52d4b531b52e9862c4189d27482ae4e958f97760" translate="yes" xml:space="preserve">
          <source>List Of SQLite Objects</source>
          <target state="translated">SQLite オブジェクトのリスト</target>
        </trans-unit>
        <trans-unit id="68749615daec6b7db7287fc101bfd1803474c677" translate="yes" xml:space="preserve">
          <source>List Of Virtual Tables</source>
          <target state="translated">仮想テーブルの一覧</target>
        </trans-unit>
        <trans-unit id="9d1c029d1a64007ca37f5bf394575d02eef0574f" translate="yes" xml:space="preserve">
          <source>List each file as it is processed.</source>
          <target state="translated">処理中の各ファイルを一覧表示します。</target>
        </trans-unit>
        <trans-unit id="a5d1705cc809076e6266257a5ff3fa27b21bc1d4" translate="yes" xml:space="preserve">
          <source>List the contents of the archive. If no arguments are specified, then all files are listed. Otherwise, only those specified as arguments are. Currently, the --verbose option does not change the behaviour of this command. That may change in the future.</source>
          <target state="translated">アーカイブの内容をリストアップします。引数が指定されていない場合は、すべてのファイルをリストアップします。それ以外の場合は、引数として指定されたファイルのみがリストアップされます。現在のところ、--verbose オプションはこのコマンドの動作を変更しません。将来的には変更されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="27424535e9c380832791dbc03c67071412b07455" translate="yes" xml:space="preserve">
          <source>List the files in the archive.</source>
          <target state="translated">アーカイブ内のファイルを一覧表示します。</target>
        </trans-unit>
        <trans-unit id="615e9625e4457bad91a4957735c233d58d384ed8" translate="yes" xml:space="preserve">
          <source>List values on the right-hand side of IN are treated as a subquery that must be materialized. In other words, the previous statement acts as if it were:</source>
          <target state="translated">INの右辺のリスト値は、マテリアライズされなければならない副問い合わせとして扱われます。つまり、前の文があたかもそうであるかのように振る舞います。</target>
        </trans-unit>
        <trans-unit id="f653dec85c31b3ff9b77fe72b2384cf749288d85" translate="yes" xml:space="preserve">
          <source>Listed below are some cases where it might make sense to add additional soundslike entries. The specific entries will depend on the application and the target language.</source>
          <target state="translated">以下にリストアップされているのは、サウンドライクなエントリを追加することが意味を持つかもしれないいくつかのケースです。具体的なエントリはアプリケーションとターゲット言語に依存します。</target>
        </trans-unit>
        <trans-unit id="9a2828a10d993798b426c35ab47fdbeb8b46927a" translate="yes" xml:space="preserve">
          <source>Listen willingly to holy reading.</source>
          <target state="translated">進んで聖なる朗読に耳を傾ける。</target>
        </trans-unit>
        <trans-unit id="3805c697baba47d8b6fac8ff193aac1d5aae53c5" translate="yes" xml:space="preserve">
          <source>Literal Values (Constants)</source>
          <target state="translated">リテラル値(定数</target>
        </trans-unit>
        <trans-unit id="3c11cc0f06e28252855afe306ffae2efa4d23a55" translate="yes" xml:space="preserve">
          <source>Literal strings contain no byte-order-marks.</source>
          <target state="translated">リテラル文字列にはバイトオーダマークは含まれていません。</target>
        </trans-unit>
        <trans-unit id="a95fd3f55e521532b15bff8dba2b3aa3f6401a1a" translate="yes" xml:space="preserve">
          <source>Literal value</source>
          <target state="translated">リテラル値</target>
        </trans-unit>
        <trans-unit id="fc57b0cbf2f7891171194ad1bf1b86f68a201597" translate="yes" xml:space="preserve">
          <source>LoC Recommended Storage Format</source>
          <target state="translated">LoC推奨ストレージフォーマット</target>
        </trans-unit>
        <trans-unit id="c1fd24450afa2a8ca3ccb54f712f70e15f33b7ed" translate="yes" xml:space="preserve">
          <source>Load An Extension</source>
          <target state="translated">拡張機能をロードする</target>
        </trans-unit>
        <trans-unit id="f9c032c8f6af23d9ff803554a14cbcd6e3037cb8" translate="yes" xml:space="preserve">
          <source>Load The Difference Between Tables Into A Session</source>
          <target state="translated">テーブル間の違いをセッションに読み込む</target>
        </trans-unit>
        <trans-unit id="9c794e6d2b53e1c944bf6d4f24a6f0f6be485378" translate="yes" xml:space="preserve">
          <source>Load the shared library or DLL file LIBRARY into SQLite prior to computing the differences. This can be used to add application-defined &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt; that are required by the schema.</source>
          <target state="translated">違いを計算する前に、共有ライブラリまたはDLLファイルLIBRARYをSQLiteにロードします。これは、スキーマで必要とされるアプリケーション定義の&lt;a href=&quot;datatype3#collation&quot;&gt;照合シーケンス&lt;/a&gt;を追加するために使用できます。</target>
        </trans-unit>
        <trans-unit id="1f26dca858775a9ffdc6b130413dfda84cf7cc4a" translate="yes" xml:space="preserve">
          <source>LoadAnalysis</source>
          <target state="translated">LoadAnalysis</target>
        </trans-unit>
        <trans-unit id="494260ec047bea19460fac6ca8324736557ff1c6" translate="yes" xml:space="preserve">
          <source>Loadable Extension Thunk</source>
          <target state="translated">ロード可能な拡張サンク</target>
        </trans-unit>
        <trans-unit id="a8855a7ba639af1775ee3c99ff39ec45827a09ba" translate="yes" xml:space="preserve">
          <source>Loadable extensions are C-code. To compile them on most unix-like operating systems, the usual command is something like this:</source>
          <target state="translated">ロード可能な拡張機能は C コードです。ほとんどの Unix ライクなオペレーティングシステム上でコンパイルするには、通常は次のようなコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="16baeb9dc5c7b831d9570f59926debb8cb175348" translate="yes" xml:space="preserve">
          <source>Local DELETE</source>
          <target state="translated">ローカルDELETE</target>
        </trans-unit>
        <trans-unit id="ad4c5e9ed0fc895a0d42b932b2926861699fe92c" translate="yes" xml:space="preserve">
          <source>Local INSERT</source>
          <target state="translated">ローカルINSERT</target>
        </trans-unit>
        <trans-unit id="3e12d4ac47a72a1f8aa6fb2cd56dc176cf45a02b" translate="yes" xml:space="preserve">
          <source>Local UPDATE</source>
          <target state="translated">ローカルUPDATE</target>
        </trans-unit>
        <trans-unit id="e88556ba53a549a6a9fbf15298a71732177e868b" translate="yes" xml:space="preserve">
          <source>Localtime modifier</source>
          <target state="translated">ローカルタイム修飾子</target>
        </trans-unit>
        <trans-unit id="249beb765376acea4283a10da9faa975024e8fe9" translate="yes" xml:space="preserve">
          <source>Lock Name</source>
          <target state="translated">ロック名</target>
        </trans-unit>
        <trans-unit id="d4795eaa0bbabf21615f9f3e359ab0c2e3631ccd" translate="yes" xml:space="preserve">
          <source>Lock offset</source>
          <target state="translated">ロックオフセット</target>
        </trans-unit>
        <trans-unit id="eb6bc036bb67cd66abad9bfabc9e6cb6a5eaef00" translate="yes" xml:space="preserve">
          <source>Lock the btree to which cursor P1 is pointing so that the btree cannot be written by an other cursor.</source>
          <target state="translated">カーソルP1が指しているbtreeをロックし、他のカーソルからbtreeが書き込めないようにします。</target>
        </trans-unit>
        <trans-unit id="de20f3d1eb2301b2722958c2ff4a7d6bd4e9d117" translate="yes" xml:space="preserve">
          <source>Locking and Concurrency</source>
          <target state="translated">ロックと並行性</target>
        </trans-unit>
        <trans-unit id="668186cf26fd89e59f391d180f6666c5c03f0bfa" translate="yes" xml:space="preserve">
          <source>Locking and concurrency control are handled by the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt; pager module&lt;/a&gt;. The pager module is responsible for making SQLite &quot;ACID&quot; (Atomic, Consistent, Isolated, and Durable). The pager module makes sure changes happen all at once, that either all changes occur or none of them do, that two or more processes do not try to access the database in incompatible ways at the same time, and that once changes have been written they persist until explicitly deleted. The pager also provides a memory cache of some of the contents of the disk file.</source>
          <target state="translated">ロックと同時実行制御は&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt;ページャーモジュール&lt;/a&gt;によって処理されます。ページャーモジュールは、SQLiteを &quot;ACID&quot;（Atomic、Consistent、Isolated、Durable）にする責任があります。ページャーモジュールは、すべての変更が一度に行われるか、まったく行われないか、2つ以上のプロセスが同時に互換性のない方法でデータベースにアクセスしようとしないこと、および変更が書き込まれると変更が一度に行われるようにします。明示的に削除されるまで存続します。ページャは、ディスクファイルの内容の一部のメモリキャッシュも提供します。</target>
        </trans-unit>
        <trans-unit id="57d0597b0f360ba173ecb2d2a1f767cb5748ea2e" translate="yes" xml:space="preserve">
          <source>Long Option</source>
          <target state="translated">ロングオプション</target>
        </trans-unit>
        <trans-unit id="76889c4037fcda94eba3afe630f0b45c824942de" translate="yes" xml:space="preserve">
          <source>Long Term Support</source>
          <target state="translated">長期サポート</target>
        </trans-unit>
        <trans-unit id="fce206f4d564c7fbca45ff9aebf22500127c7c61" translate="yes" xml:space="preserve">
          <source>Long and short style options may be mixed. For example, the following are equivalent:</source>
          <target state="translated">ロングスタイルとショートスタイルの選択肢が混在していてもよい。例えば、以下のようなものが該当します。</target>
        </trans-unit>
        <trans-unit id="1a01077cb8c85bad9873673a9051f4ee19688494" translate="yes" xml:space="preserve">
          <source>Longer answer: If you declare a column of a table to be &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, then whenever you insert a NULL into that column of the table, the NULL is automatically converted into an integer which is one greater than the largest value of that column over all other rows in the table, or 1 if the table is empty. Or, if the largest existing integer key 9223372036854775807 is in use then an unused key value is chosen at random. For example, suppose you have a table like this:</source>
          <target state="translated">より長い答え：テーブルの列を&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;として宣言すると、テーブルのその列にNULLを挿入するたびに、NULLはその列の最大値より1大きい整数に自動的に変換されますテーブル内の他のすべての行、またはテーブルが空の場合は1。または、最大の既存の整数キー9223372036854775807が使用中の場合、未使用のキー値がランダムに選択されます。たとえば、次のようなテーブルがあるとします。</target>
        </trans-unit>
        <trans-unit id="6e9f2602cf3d1fd809e1312f33acfde2f150141f" translate="yes" xml:space="preserve">
          <source>Lookaside buffer allocations for new &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;.</source>
          <target state="translated">新しい&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;用のルックアサイドバッファ割り当て。</target>
        </trans-unit>
        <trans-unit id="04bd7a984d3646ac5eb9c18de550a3f1e203e5b1" translate="yes" xml:space="preserve">
          <source>Lookaside memory allocator</source>
          <target state="translated">ルックサイドメモリアロケータ</target>
        </trans-unit>
        <trans-unit id="fde137681e3baa6ad1143b905327accc0fb28e76" translate="yes" xml:space="preserve">
          <source>Lots of bug fixes.</source>
          <target state="translated">たくさんのバグ修正。</target>
        </trans-unit>
        <trans-unit id="990ee2bc3df995ba8afb44c45e674fd9a503ec05" translate="yes" xml:space="preserve">
          <source>Lots of little bug fixes.</source>
          <target state="translated">小さなバグ修正がたくさん。</target>
        </trans-unit>
        <trans-unit id="43de40a3e36d80f18de0a9c09a14efee88ae8d7f" translate="yes" xml:space="preserve">
          <source>Love chastity.</source>
          <target state="translated">貞操観念を愛する。</target>
        </trans-unit>
        <trans-unit id="0bbc37af1e456bff56591e973337f95cdf967a70" translate="yes" xml:space="preserve">
          <source>Love fasting.</source>
          <target state="translated">断食を愛する。</target>
        </trans-unit>
        <trans-unit id="b7fcabbc1c2979a6343998251fb3b60ca2fcf13c" translate="yes" xml:space="preserve">
          <source>Love your enemies.</source>
          <target state="translated">敵を愛せ</target>
        </trans-unit>
        <trans-unit id="868ab24a96d3a2771240294f216c1eb308fe2112" translate="yes" xml:space="preserve">
          <source>Love your juniors.</source>
          <target state="translated">後輩が大好きです。</target>
        </trans-unit>
        <trans-unit id="dcbca8259d75e252eae0048dd86f40340f8d0cd8" translate="yes" xml:space="preserve">
          <source>Low-Level Control Of Database Files</source>
          <target state="translated">データベースファイルの低レベル制御</target>
        </trans-unit>
        <trans-unit id="c47d12b1a2b47bc6fe16c9cb80aba1cd8b334072" translate="yes" xml:space="preserve">
          <source>Low-dependency</source>
          <target state="translated">Low-dependency</target>
        </trans-unit>
        <trans-unit id="9b49cf9a88d0eb7571f152a707297d6594a2f0d2" translate="yes" xml:space="preserve">
          <source>Low-level system error code</source>
          <target state="translated">低レベルシステムエラーコード</target>
        </trans-unit>
        <trans-unit id="0be209fef2b5ea9e4e344d9742cbe9598db19564" translate="yes" xml:space="preserve">
          <source>Lowest precedence (loosest grouping).</source>
          <target state="translated">優先順位が最も低い(ゆるいグループ化)。</target>
        </trans-unit>
        <trans-unit id="f41a055096fba2f5ebbddc8916d81727739dbdb3" translate="yes" xml:space="preserve">
          <source>Lt</source>
          <target state="translated">Lt</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="a4b52e49796d63ce942c6b8bfaa86fb7c20383ea" translate="yes" xml:space="preserve">
          <source>M is always ((U-12)*32/255)-23.</source>
          <target state="translated">Mは常に((U-12)*32/255)-23です。</target>
        </trans-unit>
        <trans-unit id="1758fbe17031a1050ba647fef2f5a93784bd0bf5" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="5fbd2551d496e24af3eb24927ec50373a744a672" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="835c3f9feac04a1fedeecdc386e908df7274d7ab" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="7e3ce80c0f5019f27debc96398dd7ba53b449b32" translate="yes" xml:space="preserve">
          <source>MASK</source>
          <target state="translated">MASK</target>
        </trans-unit>
        <trans-unit id="4110e0d1b0232ec2802f84b8b4f2d0c2fb3fbbb7" translate="yes" xml:space="preserve">
          <source>MASK bit 0x02 is set.</source>
          <target state="translated">MASK ビット 0x02 が設定されます。</target>
        </trans-unit>
        <trans-unit id="ce71241b2af9817fe6f961964423ded83b2b2446" translate="yes" xml:space="preserve">
          <source>MATCH</source>
          <target state="translated">MATCH</target>
        </trans-unit>
        <trans-unit id="fb533649ca2f9e73b11b6bb948adb363f958ac9f" translate="yes" xml:space="preserve">
          <source>MEDIUMINT</source>
          <target state="translated">MEDIUMINT</target>
        </trans-unit>
        <trans-unit id="7c2c1a9b5cbb8b738dc37806d8007da0a4dabc51" translate="yes" xml:space="preserve">
          <source>MS-SQL</source>
          <target state="translated">MS-SQL</target>
        </trans-unit>
        <trans-unit id="e6557f13d224519bee5609849fa3b7fe2b045817" translate="yes" xml:space="preserve">
          <source>Macs are unix-like, but they do not follow the usual shared library conventions. To compile a shared library on a Mac, use a command like this:</source>
          <target state="translated">Mac は unix に似ていますが、通常の共有ライブラリの規約には従いません。Mac で共有ライブラリをコンパイルするには、次のようなコマンドを使います。</target>
        </trans-unit>
        <trans-unit id="a1e5337bd6f525fef1a4495aefda7354ea999138" translate="yes" xml:space="preserve">
          <source>Made selected parameters in API functions &lt;b&gt;const&lt;/b&gt;. This should be fully backwards compatible.</source>
          <target state="translated">API関数&lt;b&gt;const&lt;/b&gt;で選択したパラメーターを作成しました。これは完全に下位互換性があるはずです。</target>
        </trans-unit>
        <trans-unit id="debb142b11cd7000f7ccf5be052a02bcc1c7f9ef" translate="yes" xml:space="preserve">
          <source>Made the &lt;a href=&quot;testing#aflfuzz&quot;&gt;American Fuzzy Lop fuzzer&lt;/a&gt; a standard part of SQLite's &lt;a href=&quot;testing&quot;&gt;testing strategy&lt;/a&gt;.</source>
          <target state="translated">メイド&lt;a href=&quot;testing#aflfuzz&quot;&gt;アメリカンファジーロプはfuzzer&lt;/a&gt;のSQLiteのの標準部品&lt;a href=&quot;testing&quot;&gt;テスト戦略&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aadd04e928883126f21deaf37b5282558e747d50" translate="yes" xml:space="preserve">
          <source>Made the CACHE_SIZE pragma persistent</source>
          <target state="translated">CACHE_SIZE プラグマを永続化しました。</target>
        </trans-unit>
        <trans-unit id="2d544f28a897acf54e3872442614c2de63e16acf" translate="yes" xml:space="preserve">
          <source>Magic number. 0x377f0682 or 0x377f0683</source>
          <target state="translated">マジックナンバー。0x377f0682または0x377f0683</target>
        </trans-unit>
        <trans-unit id="a249757e280e4c1ed4596ef256151f0633cc5c86" translate="yes" xml:space="preserve">
          <source>Maintaining 100% MC/DC is laborious and time-consuming. The level of effort needed to maintain full-coverage testing is probably not cost effective for a typical application. However, we think that full-coverage testing is justified for a &lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;very widely deployed&lt;/a&gt; infrastructure library like SQLite, and especially for a database library which by its very nature &quot;remembers&quot; past mistakes.</source>
          <target state="translated">MC / DCを100％に維持することは、面倒で時間がかかります。フルカバレッジテストを維持するために必要な労力のレベルは、通常のアプリケーションではおそらく費用対効果が高くありません。ただし、SQLiteのような&lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;非常に広く展開&lt;/a&gt;されているインフラストラクチャライブラリ、特にその性質上過去の間違いを「記憶」しているデータベースライブラリに対しては、フルカバレッジテストが正当化されると考えています。</target>
        </trans-unit>
        <trans-unit id="0690809fdfc162c136b84c90c7f6551b5a7d6bb1" translate="yes" xml:space="preserve">
          <source>Maintaining Private Branches Of SQLite</source>
          <target state="translated">SQLiteのプライベートブランチの管理</target>
        </trans-unit>
        <trans-unit id="74db8285437f292d07f23511a8853dab08df8f69" translate="yes" xml:space="preserve">
          <source>Make &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; responsive to the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="translated">メイクは&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;）（sqlite3_compileoption_used&lt;/a&gt;に応答&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt;コンパイル時のオプション。</target>
        </trans-unit>
        <trans-unit id="f178a74cc1dcf57fcc7b73994685f97569f4844f" translate="yes" xml:space="preserve">
          <source>Make AreFileApisANSI() a no-op macro in WinCE since WinCE does not support this function.</source>
          <target state="translated">WinCE はこの関数をサポートしていないため、AreFileApisANSI()を WinCE で動作しないマクロにするようにしました。</target>
        </trans-unit>
        <trans-unit id="07dc88b6cef4d75e2f7c3880e8647593525aa07e" translate="yes" xml:space="preserve">
          <source>Make CSV (comma separate value) output from the command-line shell more closely aligned to accepted practice</source>
          <target state="translated">コマンドラインシェルからのCSV(カンマ区切りの値)出力を、より一般的な慣習に近いものにする</target>
        </trans-unit>
        <trans-unit id="7ebdddec87e9007589d5ada3e116c78e26d2e69a" translate="yes" xml:space="preserve">
          <source>Make LIMIT work on a compound SELECT statement.</source>
          <target state="translated">複合SELECT文でLIMITが機能するようにします。</target>
        </trans-unit>
        <trans-unit id="67a20c818425dd125a3dee8478ee3f7563c8b234" translate="yes" xml:space="preserve">
          <source>Make a copy of registers P1..P1+P3 into registers P2..P2+P3.</source>
          <target state="translated">レジスタP1...P1+P3をレジスタP2...P2+P3にコピーします。</target>
        </trans-unit>
        <trans-unit id="8d0b0f116d9ed8fdf1c047e6cff51269d6d08bd0" translate="yes" xml:space="preserve">
          <source>Make a distinction between numeric and text values when sorting. Text values sort according to memcmp(). Numeric values sort in numeric order.</source>
          <target state="translated">ソートする際には、数値とテキスト値を区別するようにしてください。テキスト値は memcmp()に従ってソートします。数値は数値順にソートします。</target>
        </trans-unit>
        <trans-unit id="9f53feddfd33da18e3bb3466ea22bc837873fc9d" translate="yes" xml:space="preserve">
          <source>Make a shallow copy of register P1 into register P2.</source>
          <target state="translated">レジスタP1をレジスタP2に浅くコピーする。</target>
        </trans-unit>
        <trans-unit id="c4914cad6e6db40e49d46939d936ae678cbe7888" translate="yes" xml:space="preserve">
          <source>Make every effort to allocate a new page. Only return NULL if allocating a new page is effectively impossible.</source>
          <target state="translated">新しいページを確保するためにあらゆる努力をしてください。新しいページの割り当てが事実上不可能な場合のみ NULL を返します。</target>
        </trans-unit>
        <trans-unit id="94089eca234684dc20cbdb2f8434b3d3fb23b40c" translate="yes" xml:space="preserve">
          <source>Make peace with your adversary before the sun sets.</source>
          <target state="translated">太陽が沈む前に敵と仲直りしましょう。</target>
        </trans-unit>
        <trans-unit id="b31d5954ede96c4a01bf917d9892337c3c9f6de7" translate="yes" xml:space="preserve">
          <source>Make sure ORDER BY puts rows in ascending order even if the DISTINCT operator is implemented using a descending index. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9e&lt;/a&gt;.</source>
          <target state="translated">DISTINCT演算子が降順のインデックスを使用して実装されている場合でも、ORDER BYが行を昇順で配置することを確認してください。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9eの&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="fd7437d47e0ca64701851f46718248492d235445" translate="yes" xml:space="preserve">
          <source>Make sure VIEWs are created after their corresponding TABLEs in the output of the &lt;b&gt;.dump&lt;/b&gt; command in the shell.</source>
          <target state="translated">シェルの&lt;b&gt;.dump&lt;/b&gt;コマンドの出力で、対応するTABLEの後にVIEWが作成されていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="b8fc01ec14bc51db67a6c7f295254a0473ee78c4" translate="yes" xml:space="preserve">
          <source>Make sure all individual database files have an EXCLUSIVE lock and a valid journal.</source>
          <target state="translated">すべての個々のデータベースファイルにEXCLUSIVEロックと有効なジャーナルがあることを確認してください。</target>
        </trans-unit>
        <trans-unit id="39ceab29d21e2433cf3cad2d290185c2cdda1b07" translate="yes" xml:space="preserve">
          <source>Make sure all rollback journal data has actually been written to the surface of the disk (and is not just being held in the operating system's or disk controllers cache) so that if a power failure occurs the data will still be there after power is restored.</source>
          <target state="translated">停電が発生しても、電源が復旧した後もデータが残っているように、すべてのロールバックジャーナルデータが実際にディスクの表面に書き込まれていることを確認してください(オペレーティングシステムやディスクコントローラのキャッシュに保持されているだけではありません)。</target>
        </trans-unit>
        <trans-unit id="faaff6cbdbf4873f3d095a4a0e2d87974475615a" translate="yes" xml:space="preserve">
          <source>Make sure functions expressions in the VALUES clause of an INSERT are correct.</source>
          <target state="translated">INSERTのVALUES句の関数式が正しいことを確認してください。</target>
        </trans-unit>
        <trans-unit id="b3c87542457fbfa0848fd99500f7827664d328fc" translate="yes" xml:space="preserve">
          <source>Make sure that database filenames follow the 8+3 filename format and that they do not have an empty name or extension. In other words, the database filename must contain between 1 and 8 characters in the base name and between 1 and 3 characters in the extension. Blank extensions are not allowed.</source>
          <target state="translated">データベースファイル名は8+3ファイル名の形式に従い、空の名前や拡張子を持たないようにしてください。言い換えれば、データベースファイル名には、ベース名に1文字から8文字、拡張子に1文字から3文字の間の文字を含める必要があります。空の拡張子は許されません。</target>
        </trans-unit>
        <trans-unit id="559ee78af19e40cf8fa346787df1709761be2f3c" translate="yes" xml:space="preserve">
          <source>Make sure that when a connection blocks on a RESERVED lock that it is able to continue after the lock is released. (Ticket #3093)</source>
          <target state="translated">RESERVEDロックで接続がブロックされた場合、ロックが解除された後も接続を継続できるようにしてください。(チケット#3093)</target>
        </trans-unit>
        <trans-unit id="6c2032f0b0a487670b92ae7b1f7c2a4d3713ca71" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt; values from multiple triggers within a single statement do not interfere with one another. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt;.</source>
          <target state="translated">単一ステートメント内の複数のトリガーからの&lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata（）&lt;/a&gt;値が互いに干渉しないことを確認してください。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6638940c401bf7e1c92493be7672af3af206b2b" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; interface does not zero-terminate the buffer if the buffer size is less than 1. Ticket #2341</source>
          <target state="translated">バッファーサイズが1未満の場合、&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;インターフェイスがバッファーをゼロで終了しないことを確認してください。チケット＃2341</target>
        </trans-unit>
        <trans-unit id="3bc85b9279a5981ff83181cec093f69c7042f9c4" translate="yes" xml:space="preserve">
          <source>Make sure the MIN() and MAX() optimizations work within subqueries.</source>
          <target state="translated">MIN()および MAX()の最適化がサブクエリ内で動作することを確認してください。</target>
        </trans-unit>
        <trans-unit id="58ff8f836097af00b92625ae2c5e983cf4412032" translate="yes" xml:space="preserve">
          <source>Make sure the ORDER BY LIMIT optimization (from check-in &lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09e&lt;/a&gt;) works with IN operators on INTEGER PRIMARY KEYs. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96c1454c&lt;/a&gt;</source>
          <target state="translated">（チェックイン&lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09eからの&lt;/a&gt;）ORDER BY LIMIT最適化がINTEGER PRIMARY KEYのIN演算子で機能することを確認します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96c1454cの&lt;/a&gt;修正</target>
        </trans-unit>
        <trans-unit id="3ea00b4a5adf172672ba7e54a20e155f2d4f11b3" translate="yes" xml:space="preserve">
          <source>Make sure the TCL language interface works correctly with 64-bit integers on 64-bit machines.</source>
          <target state="translated">TCL言語インタフェースが64ビットマシン上で64ビット整数で正しく動作することを確認してください。</target>
        </trans-unit>
        <trans-unit id="2c7d7b5412a65ed5d6ce615755d9929fa6d57cca" translate="yes" xml:space="preserve">
          <source>Make sure the in-memory backend response sanely if malloc() fails.</source>
          <target state="translated">malloc()が失敗した場合に、インメモリバックエンドのレスポンスが正気であることを確認するようにしてください。</target>
        </trans-unit>
        <trans-unit id="eae9ed5b156bcdd54a8967008569fef435a53021" translate="yes" xml:space="preserve">
          <source>Make sure the query optimizer checks dependencies on all terms of a compound SELECT statement. Ticket #2640.</source>
          <target state="translated">クエリオプティマイザが複合SELECT文のすべての項の依存関係をチェックするようにしてください。チケット番号#2640。</target>
        </trans-unit>
        <trans-unit id="30c0cf0484d7a5f504b6b728788d263a9e41fc0c" translate="yes" xml:space="preserve">
          <source>Make sure you type a semicolon at the end of each SQL command! The sqlite3 program looks for a semicolon to know when your SQL command is complete. If you omit the semicolon, sqlite3 will give you a continuation prompt and wait for you to enter more text to be added to the current SQL command. This feature allows you to enter SQL commands that span multiple lines. For example:</source>
          <target state="translated">各SQLコマンドの最後にセミコロンを入力してください! sqlite3プログラムは、SQLコマンドが完了したときにセミコロンを探します。もしセミコロンを省略した場合、sqlite3は継続プロンプトを表示し、現在のSQLコマンドに追加されるテキストを入力するのを待ちます。この機能により、複数行にまたがるSQLコマンドを入力することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0f78a73d59843cf77efe52a3fb9a1c8bc577fb63" translate="yes" xml:space="preserve">
          <source>Make that script executable and put it on your $PATH. Then compile the kvtest program as follows:</source>
          <target state="translated">そのスクリプトを実行可能にして $PATH に置いてください。そして、以下のようにkvtestプログラムをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="55a8e3fef2599367be1f179f0eeae6e3f90c5562" translate="yes" xml:space="preserve">
          <source>Make the &quot;AS&quot; keyword optional again.</source>
          <target state="translated">再び「as」キーワードを任意にします。</target>
        </trans-unit>
        <trans-unit id="e8d3c7849aaf72378ce97fad0ef58bb50dfa844b" translate="yes" xml:space="preserve">
          <source>Make the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt; part of standard builds when compiled with the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; option.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt;オプションを使用してコンパイルする場合、&lt;a href=&quot;dbstat&quot;&gt;dbstat仮想テーブル&lt;/a&gt;を標準ビルドの一部にします。</target>
        </trans-unit>
        <trans-unit id="3cf1a1fb81ef7a54777705fadfc53565c39e040a" translate="yes" xml:space="preserve">
          <source>Make the GLOB and LIKE operators functions that can be overridden by a programmer. This allows, for example, the LIKE operator to be changed to be case sensitive.</source>
          <target state="translated">GLOBとLIKE演算子をプログラマがオーバーライドできる関数にする。これにより、例えばLIKE演算子を大文字小文字を区別するように変更することができます。</target>
        </trans-unit>
        <trans-unit id="06d1ed76522acc5f77d35b87ff9bcb7713142c7d" translate="yes" xml:space="preserve">
          <source>Make the LIMIT clause work on subqueries. (ORDER BY still does not work, though.)</source>
          <target state="translated">LIMIT句が副問い合わせで動作するようにしました。(ただし、ORDER BYはまだ動作しません)。</target>
        </trans-unit>
        <trans-unit id="e949e24407b3c3e74908e043648105301add53c5" translate="yes" xml:space="preserve">
          <source>Make the library thread-safe. (The code is there and appears to work but has not been stressed.)</source>
          <target state="translated">ライブラリをスレッドセーフにする。(コードはあり、動作しているように見えますが、ストレスをかけていません)。</target>
        </trans-unit>
        <trans-unit id="aa1b502d7a3d8467cdd71e12de59017bd7bf7832" translate="yes" xml:space="preserve">
          <source>Make the os.h header file more robust in detecting when the compile is for Windows and when it is for Unix.</source>
          <target state="translated">Windows 用のコンパイルと Unix 用のコンパイルを検出するために、 os.h ヘッダファイルをより強固なものにしました。</target>
        </trans-unit>
        <trans-unit id="5b70367d16489f70b60357dd49e971c66ecb7a25" translate="yes" xml:space="preserve">
          <source>Make use of OVERLAPPED in the windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to avoid some system calls and thereby obtain a performance improvement.</source>
          <target state="translated">Windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;でOVERLAPPEDを使用して、一部のシステムコールを回避し、パフォーマンスを向上させます。</target>
        </trans-unit>
        <trans-unit id="bb3c80011eafc56757b5115bd6da6df2d3cc0bcf" translate="yes" xml:space="preserve">
          <source>Make use of the one-pass UPDATE and DELETE query plans in the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; where appropriate.</source>
          <target state="translated">必要に応じて、&lt;a href=&quot;rtree&quot;&gt;Rツリー拡張の&lt;/a&gt;ワンパスUPDATEおよびDELETEクエリプランを利用します。</target>
        </trans-unit>
        <trans-unit id="9c7ffc0af1b5a78c06ebbd279554c53e269060be" translate="yes" xml:space="preserve">
          <source>MakeRecord</source>
          <target state="translated">MakeRecord</target>
        </trans-unit>
        <trans-unit id="decb5fb2e05d5246774c7c119193e5dd3eeab585" translate="yes" xml:space="preserve">
          <source>Makefile updates</source>
          <target state="translated">Makefile の更新</target>
        </trans-unit>
        <trans-unit id="3e75c9edc23a32990a13f91bc222c1cd2fb310c7" translate="yes" xml:space="preserve">
          <source>Makefile updates and miscellaneous bug fixes.</source>
          <target state="translated">Makefileの更新と雑なバグ修正。</target>
        </trans-unit>
        <trans-unit id="bdecdca82af325fcab74535c838b3bad719fc7de" translate="yes" xml:space="preserve">
          <source>Makefile updates from A. Rottmann</source>
          <target state="translated">A.RottmannからのMakefileの更新</target>
        </trans-unit>
        <trans-unit id="1a74e86adcd0000bd7de1be192d074c821dd68c1" translate="yes" xml:space="preserve">
          <source>Making Other Kinds Of Table Schema Changes</source>
          <target state="translated">他の種類のテーブルスキーマの変更を行う</target>
        </trans-unit>
        <trans-unit id="e6fe063cab95ff9f5d6ec0129688c23c296059b5" translate="yes" xml:space="preserve">
          <source>Malformed UTF-8 that SQLite converts to a UTF-16 byte-order-mark is embedded at the beginning of an SQL string literal value inserted into an FTS3 table.</source>
          <target state="translated">FTS3 テーブルに挿入された SQL 文字列リテラル値の先頭に、SQLite が UTF-16 バイトオーダマークに変換する不正な UTF-8 が埋め込まれています。</target>
        </trans-unit>
        <trans-unit id="e30f6661f23230d01a3d07773b601db8982cabdd" translate="yes" xml:space="preserve">
          <source>Malformed database tests</source>
          <target state="translated">不正なデータベーステスト</target>
        </trans-unit>
        <trans-unit id="d6314779095d53af544ef97df23a24554ee88bdd" translate="yes" xml:space="preserve">
          <source>Managing SQLite Archives from the command-line</source>
          <target state="translated">コマンドラインからの SQLite アーカイブの管理</target>
        </trans-unit>
        <trans-unit id="3fbc66cdb2efde39d2ec8d74f242ca151b4515bd" translate="yes" xml:space="preserve">
          <source>Manifest Typing and BLOB Support</source>
          <target state="translated">マニフェストタイプとBLOBのサポート</target>
        </trans-unit>
        <trans-unit id="bb55c1a865472533208270e05409a59df50af4d8" translate="yes" xml:space="preserve">
          <source>Manifest typing and BLOB support.</source>
          <target state="translated">マニフェストタイピングとBLOBのサポート。</target>
        </trans-unit>
        <trans-unit id="1cc470a30ade4f894dfdc6d3819af02869f9a0ff" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using CROSS JOIN</source>
          <target state="translated">CROSS JOINを用いたクエリプランの手動制御</target>
        </trans-unit>
        <trans-unit id="cd08ce62fe23d2df3bf17c27439fcc586ae7eb2c" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using SQLITE_STAT Tables</source>
          <target state="translated">SQLITE_STAT テーブルを使用したクエリプランの手動制御</target>
        </trans-unit>
        <trans-unit id="6ce25f14125bd349207477d6be9b5bb56a241bb2" translate="yes" xml:space="preserve">
          <source>Many SQLITE_OMIT_ macros inserts to omit features at compile-time and reduce the library footprint.</source>
          <target state="translated">多くの SQLITE_OMIT_マクロは、コンパイル時に機能を省略し、ライブラリのフットプリントを減らすために挿入します。</target>
        </trans-unit>
        <trans-unit id="58bc21cac299bf4ec03f599485fd07e14baffb8d" translate="yes" xml:space="preserve">
          <source>Many SQLite functions return an integer result code from the set shown here in order to indicate success or failure.</source>
          <target state="translated">多くの SQLite 関数は、成功か失敗かを示すために、ここで示したセットから整数の結果コードを返します。</target>
        </trans-unit>
        <trans-unit id="29bbffe8721f3a2848d887e1fb7a366159ccdc97" translate="yes" xml:space="preserve">
          <source>Many Small Queries Are Efficient In SQLite</source>
          <target state="translated">SQLiteでは多くの小さなクエリが効率的</target>
        </trans-unit>
        <trans-unit id="b88b7072aba4a1d9cfba91839cebc05836eb0907" translate="yes" xml:space="preserve">
          <source>Many applications destroy their &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using calls to &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; at shutdown. Or, for example, an application that uses SQLite as its &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt; might open &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; in response to a File/Open menu action and then destroy the corresponding &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; in response to the File/Close menu.</source>
          <target state="translated">多くのアプリケーションは、シャットダウン時に&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;への呼び出しを使用して&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;を破棄します。または、例えば、そのようSQLiteのを使用するアプリケーション&lt;a href=&quot;appfileformat&quot;&gt;アプリケーションファイルフォーマットは、&lt;/a&gt;開くことがあります&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続を&lt;/a&gt;ファイル/開く]メニューのアクションに応じて、その後、対応する破壊する&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;ファイル/閉じるメニューに対応しています。</target>
        </trans-unit>
        <trans-unit id="e4e81b55d5c98ead21919f5ad70f41ad3433a3b2" translate="yes" xml:space="preserve">
          <source>Many applications use SQLite as a cache of relevant content from an enterprise RDBMS. This reduces latency, since most queries now occur against the local cache and avoid a network round-trip. It also reduces the load on the network and on the central database server. And in many cases, it means that the client-side application can continue operating during network outages.</source>
          <target state="translated">多くのアプリケーションでは、SQLite をエンタープライズ RDBMS の関連コンテンツのキャッシュとして使用しています。これにより、ほとんどのクエリがローカルキャッシュに対して実行され、ネットワークの往復を避けることができるため、待ち時間が短縮されます。また、ネットワークと中央データベースサーバの負荷も軽減されます。また、多くの場合、ネットワークが停止してもクライアント側のアプリケーションが動作を継続できることを意味します。</target>
        </trans-unit>
        <trans-unit id="0a456e7268dde3087ce48e51e3014a05bf0f0916" translate="yes" xml:space="preserve">
          <source>Many code simplifications and obscure bug fixes in support of providing &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;testing#coverage&quot;&gt;100％ブランチテストカバレッジの&lt;/a&gt;提供をサポートする多くのコードの簡素化と不明瞭なバグ修正。</target>
        </trans-unit>
        <trans-unit id="a1bfd103f34c0767adc1c7bc9d7d6d545e23cabf" translate="yes" xml:space="preserve">
          <source>Many documentation updates</source>
          <target state="translated">多くのドキュメントの更新</target>
        </trans-unit>
        <trans-unit id="3c83fd215f6013569c8872261f46c5842b6f52ba" translate="yes" xml:space="preserve">
          <source>Many examples of complete and working loadable extensions can be seen in the SQLite source tree in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory. Each file in that directory is a separate extension. Documentation is provided by a header comment on the file. Here are brief notes on a few of the extensions in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory:</source>
          <target state="translated">完全で機能するロード可能な拡張機能の多くの例は、&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt;サブディレクトリのSQLiteソースツリーにあります。そのディレクトリ内の各ファイルは個別の拡張子です。ドキュメントは、ファイルのヘッダーコメントによって提供されます。&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt;サブディレクトリにあるいくつかの拡張機能について簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="c27368aaf7a63c4c54dd85e130e6a371a0b652db" translate="yes" xml:space="preserve">
          <source>Many improvements and cleanups to the configure script</source>
          <target state="translated">configure スクリプトの多くの改善とクリーンアップ</target>
        </trans-unit>
        <trans-unit id="478a301b607ffcc6373478ce0ad5e01e286e6440" translate="yes" xml:space="preserve">
          <source>Many improvements and enhancements to the shell.</source>
          <target state="translated">シェルの多くの改良と強化。</target>
        </trans-unit>
        <trans-unit id="86f119ce378fd6fb5c391277ea97047cef855bbe" translate="yes" xml:space="preserve">
          <source>Many improvements to the test suite. Test coverage now exceeded 98%</source>
          <target state="translated">テストスイートの多くの改善。テストカバレッジが98%を超えるようになりました</target>
        </trans-unit>
        <trans-unit id="ec9cc9f8a731e2c88a6a0e04dca8da72cc53d489" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations result in 20.3% more work for the same number of CPU cycles relative to the previous release. The cumulative performance increase since &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; is 61%. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 13.10 x64 with gcc 4.8.1 and -Os. Your performance may vary.)</source>
          <target state="translated">多くのマイクロ最適化により、以前のリリースと比較して、同じ数のCPUサイクルで20.3％多い作業が発生します。&lt;a href=&quot;#version_3_8_0&quot;&gt;バージョン3.8.0&lt;/a&gt;以降の累積パフォーマンスの向上は61％です。（使用して測定&lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrindを&lt;/a&gt;上&lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.cの&lt;/a&gt; GCC 4.8.1と-OsとUbuntuの13.10のx64上のワークロード。あなたのパフォーマンスは変更になる場合があります。）</target>
        </trans-unit>
        <trans-unit id="1070ccc184f5ee6e5132e8f78957c23f5d18aeb1" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations, resulting in a library that is faster than the previous release.</source>
          <target state="translated">多くのマイクロ最適化が行われ、その結果、以前のリリースよりも高速なライブラリが得られました。</target>
        </trans-unit>
        <trans-unit id="ef73d713f7e1172e113f066199b34719f6daec88" translate="yes" xml:space="preserve">
          <source>Many minor bug fixes</source>
          <target state="translated">多くのマイナーなバグ修正</target>
        </trans-unit>
        <trans-unit id="d82e20d7c9c34c867cdbaaabca856ec1debc82ea" translate="yes" xml:space="preserve">
          <source>Many nuisance bugs fixed.</source>
          <target state="translated">多くの迷惑なバグが修正されました。</target>
        </trans-unit>
        <trans-unit id="58cc54792f79ad7e4a6c20e286dbf7226ea88ce5" translate="yes" xml:space="preserve">
          <source>Many of the routines in the SQLite &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; return numeric result codes indicating either success or failure, and in the event of a failure, providing some idea of the cause of the failure. This document strives to explain what each of those numeric result codes means.</source>
          <target state="translated">SQLite &lt;a href=&quot;c3ref/intro&quot;&gt;C言語インターフェイス&lt;/a&gt;のルーチンの多くは、成功または失敗のいずれかを示す数値の結果コードを返し、失敗の場合は、失敗の原因についての何らかの考えを提供します。このドキュメントでは、これらの数値結果コードのそれぞれの意味を説明するよう努めています。</target>
        </trans-unit>
        <trans-unit id="684a0cdf6fba65d365077c8562625db95e85aea3" translate="yes" xml:space="preserve">
          <source>Many operations, especially I/O intensive operations, can be faster since content does need to be copied between kernel space and user space.</source>
          <target state="translated">多くの操作、特に I/O を多用する操作は、コンテンツをカーネル空間とユーザ空間の間でコピーする必要があるため、高速化することができます。</target>
        </trans-unit>
        <trans-unit id="e75f87ad413b2b989beb9904a93bbc6902b68acd" translate="yes" xml:space="preserve">
          <source>Many programs use &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen()&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread()&lt;/a&gt;, and &lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite()&lt;/a&gt; to create and manage files of data in home-grown formats. SQLite works particularly well as a replacement for these</source>
          <target state="translated">多くのプログラムは、&lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen（）&lt;/a&gt;、&lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread（）&lt;/a&gt;、および&lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite（）&lt;/a&gt;を使用して、自社開発の形式でデータのファイルを作成および管理します。SQLiteはこれらの代替として特にうまく機能します</target>
        </trans-unit>
        <trans-unit id="58c8d3506d92b491bec9b8982cb696fb925723f6" translate="yes" xml:space="preserve">
          <source>Many readers have recommended various third-party GUIs for Git that might do a better job of showing historical development activity. Maybe some of them do work better than native Git and/or GitHub, though they will all be hampered by the fact that Git does not preserve historical branch names across syncs. And even if those other tools are better, the fact that it is necessary to go to a third-party tool to get the information desired does not speak well of the core system.</source>
          <target state="translated">多くの読者が、過去の開発活動の履歴を表示するのに適したサードパーティ製の Git 用 GUI を推奨しています。その中には、ネイティブの Git や GitHub よりもうまく機能するものもあるかもしれませんが、いずれも Git が同期した際に歴史的なブランチ名を保存しないという事実に阻まれます。また、他のツールの方が優れているとしても、必要な情報を得るためにサードパーティのツールを使わなければならないという事実は、コアシステムの良さをよく表していません。</target>
        </trans-unit>
        <trans-unit id="57a3139bc8f04dd188f9b7807c96ec2f953e86dc" translate="yes" xml:space="preserve">
          <source>Many small performance optimizations.</source>
          <target state="translated">多くの小さなパフォーマンスの最適化。</target>
        </trans-unit>
        <trans-unit id="575ebc9be57deafee12eee1cb275aca14943f68c" translate="yes" xml:space="preserve">
          <source>Many, many bug fixes and compatibility enhancements.</source>
          <target state="translated">多くのバグ修正と互換性の強化。</target>
        </trans-unit>
        <trans-unit id="305801fe337dfa5f8bad0f9f9e15662ddae791a8" translate="yes" xml:space="preserve">
          <source>Many, many minor bug fixes and documentation updates.</source>
          <target state="translated">多くの、多くのマイナーなバグ修正とドキュメントの更新。</target>
        </trans-unit>
        <trans-unit id="35ddb236d4c17515cfe7146a42b5a461cee3e50c" translate="yes" xml:space="preserve">
          <source>Master Journal Pointer</source>
          <target state="translated">マスタージャーナルポインター</target>
        </trans-unit>
        <trans-unit id="9abc1c7f8fc32d4d49746263693941601091cb5d" translate="yes" xml:space="preserve">
          <source>Master journal</source>
          <target state="translated">マスタージャーナル</target>
        </trans-unit>
        <trans-unit id="cb9cc1ceef6f81a9f36806b03b083dc9a2408c5e" translate="yes" xml:space="preserve">
          <source>Master journals</source>
          <target state="translated">マスタージャーナル</target>
        </trans-unit>
        <trans-unit id="7b5111bfd1045a8ecdd3554c1e9631c35ec01ef6" translate="yes" xml:space="preserve">
          <source>Matches if both query1 and query2 match.</source>
          <target state="translated">クエリ1とクエリ2の両方が一致した場合にマッチします。</target>
        </trans-unit>
        <trans-unit id="1abd40ea027c30a30c262947ec1298a0d519b4e6" translate="yes" xml:space="preserve">
          <source>Matches if either query1 or query2 match.</source>
          <target state="translated">クエリ1またはクエリ2のいずれかが一致した場合にマッチします。</target>
        </trans-unit>
        <trans-unit id="51cd172796c27ae8bf6aa95066f1e3c65189a939" translate="yes" xml:space="preserve">
          <source>Matches if query1 matches and query2 does not match.</source>
          <target state="translated">クエリ1がマッチし、クエリ2がマッチしない場合にマッチします。</target>
        </trans-unit>
        <trans-unit id="bd5c38104019f7a3a298ccf7253423afa28167b4" translate="yes" xml:space="preserve">
          <source>Matchinfo b flag</source>
          <target state="translated">マッチ情報b旗</target>
        </trans-unit>
        <trans-unit id="c836afd188ddb1668f2e9e6d198ffaad1a60d7a2" translate="yes" xml:space="preserve">
          <source>Matchinfo x flag</source>
          <target state="translated">マッチインフォ×フラグ</target>
        </trans-unit>
        <trans-unit id="1cd52c33bad6e28fab493f91164add2569119727" translate="yes" xml:space="preserve">
          <source>Matchinfo y flag</source>
          <target state="translated">マッチ情報と旗</target>
        </trans-unit>
        <trans-unit id="eba78e6ccaca884931e9772ee282f8ff7b915236" translate="yes" xml:space="preserve">
          <source>Materializations of views and subqueries</source>
          <target state="translated">ビューとサブクエリのマテリアライゼーション</target>
        </trans-unit>
        <trans-unit id="b44a1f3f0332ddaecfe37d45239aca1621b1d815" translate="yes" xml:space="preserve">
          <source>Mathematical operators (+, -, *, /, %, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) interpret both operands as if they were numbers. STRING or BLOB operands automatically convert into REAL or INTEGER values. If the STRING or BLOB looks like a real number (if it has a decimal point or an exponent) or if the value is outside the range that can be represented as a 64-bit signed integer, then it converts to REAL. Otherwise the operand converts to INTEGER. The implied type conversion of mathematical operands is slightly different from &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt; in that string and BLOB values that look like real numbers but have no fractional part are kept as REAL instead of being converted into INTEGER as they would be for &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt;. The conversion from STRING or BLOB into REAL or INTEGER is performed even if it is lossy and irreversible. Some mathematical operators (%, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) expect INTEGER operands. For those operators, REAL operands are converted into INTEGER in the same way as a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to INTEGER&lt;/a&gt;. The &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and | operators always return an INTEGER (or NULL) result, but the % operator returns either INTEGER or REAL (or NULL) depending on the type of its operands. A NULL operand on a mathematical operator yields a NULL result. An operand on a mathematical operator that does not look in any way numeric and is not NULL is converted to 0 or 0.0. Division by zero gives a result of NULL.</source>
          <target state="translated">数学演算子（+、-、*、/、％、&amp;lt;&amp;lt;、&amp;gt;&amp;gt;、＆、|）は、両方のオペランドを数値のように解釈します。 STRINGまたはBLOBオペランドは、自動的にREALまたはINTEGER値に変換されます。 STRINGまたはBLOBが実数のように見える場合（小数点または指数がある場合）、または値が64ビットの符号付き整数として表すことができる範囲外の場合、REALに変換されます。それ以外の場合、オペランドはINTEGERに変換されます。数学的なオペランドの暗黙の型変換は、&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CASTからNUMERIC&lt;/a&gt;にわずかに異なり、その文字列と、実数のように見えるが小数部分がないBLOB値は、CASTからNUMERICの場合のようにINTEGERに変換されるのではなくREALとして保持され&lt;a href=&quot;lang_expr#castexpr&quot;&gt;ます&lt;/a&gt;。 STRINGまたはBLOBからREALまたはINTEGERへの変換は、不可逆的で不可逆的であっても実行されます。一部の数学演算子（％、&amp;lt;&amp;lt;、&amp;gt;&amp;gt;、＆、および|）は、INTEGERオペランドを必要とします。これらの演算子の場合、REALオペランドは&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CASTからINTEGERへの&lt;/a&gt;変換と同じ方法でINTEGERに変換されます。 &amp;lt;&amp;lt;、&amp;gt;&amp;gt;、＆、および|演算子は常にINTEGER（またはNULL）の結果を返しますが、％演算子は、オペランドのタイプに応じてINTEGERまたはREAL（またはNULL）を返します。算術演算子のNULLオペランドは、NULLの結果になります。数値ではなく、NULLでない数学演算子のオペランドは、0または0.0に変換されます。ゼロによる除算はNULLの結果を与えます。</target>
        </trans-unit>
        <trans-unit id="1d9b8da2be0b14b678f29575b8bd5d6d1b4664b6" translate="yes" xml:space="preserve">
          <source>MaxPgcnt</source>
          <target state="translated">MaxPgcnt</target>
        </trans-unit>
        <trans-unit id="6cf7147e1932d9bf8b6d38604abfcfd205a85da8" translate="yes" xml:space="preserve">
          <source>Maximum embedded payload fraction. Must be 64.</source>
          <target state="translated">最大組み込みペイロード率。64でなければなりません。</target>
        </trans-unit>
        <trans-unit id="24d9373f317266755bd6dbb0fc6450a4905171c2" translate="yes" xml:space="preserve">
          <source>Maximum rowid</source>
          <target state="translated">最大行数</target>
        </trans-unit>
        <trans-unit id="5bc432c657fe4144bd45d936698c166acecd18fa" translate="yes" xml:space="preserve">
          <source>Maximum xShmLock index</source>
          <target state="translated">最大 xShmLock インデックス</target>
        </trans-unit>
        <trans-unit id="77e5adb0194b8d8026832696c1f2c7818741ee2e" translate="yes" xml:space="preserve">
          <source>Maxopen parameter</source>
          <target state="translated">マックスオープンパラメータ</target>
        </trans-unit>
        <trans-unit id="0cccb688a9f1ffa766c4517a7aa3af7c04fd578c" translate="yes" xml:space="preserve">
          <source>May you do good and not evil</source>
          <target state="translated">悪を行わず善を行うことができますように</target>
        </trans-unit>
        <trans-unit id="8b1b4d5262b0d017f35623d6ebe39d0b87517497" translate="yes" xml:space="preserve">
          <source>May you find forgiveness for yourself and forgive others</source>
          <target state="translated">自分を許し、人を許すことができますように</target>
        </trans-unit>
        <trans-unit id="580b0f5d2afa3fc028fd1cbe9832972ae188e8d2" translate="yes" xml:space="preserve">
          <source>May you share freely, never taking more than you give.</source>
          <target state="translated">あなたが自由に分かち合い、与える以上のものを取ることがありませんように。</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="4916cdca74bd290a34e18174e1358515f2ca12e0" translate="yes" xml:space="preserve">
          <source>Measure the performance for reading blobs from the database and from individual files using these commands:</source>
          <target state="translated">これらのコマンドを使用して、データベースからのブロブの読み込みと個々のファイルからの読み込みのパフォーマンスを測定します。</target>
        </trans-unit>
        <trans-unit id="32d3f574c379f02e466ab9d634b2afa7cedf3a39" translate="yes" xml:space="preserve">
          <source>Measure write performance by adding the --update option. This causes the blobs are overwritten in place with another random blob of exactly the same size.</source>
          <target state="translated">updateオプションを追加して、書き込みパフォーマンスを測定します。これにより、ブロブは全く同じサイズの別のランダムなブロブで上書きされます。</target>
        </trans-unit>
        <trans-unit id="f8f8ae177706bfa8cf72569452745c1f4cb10ab6" translate="yes" xml:space="preserve">
          <source>Measured using cachegrind on Ubuntu 16.04 on x64 with gcc 5.4.0 and -Os.</source>
          <target state="translated">Ubuntu 16.04,x64,gcc 5.4.0,-Osでcachegrindを使用して測定しました。</target>
        </trans-unit>
        <trans-unit id="b32c8e35e5b4b276295d8f91c2b0f1620f45e186" translate="yes" xml:space="preserve">
          <source>Measurements above were conducted using SQLite version &lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;5594a121bf132a98&lt;/a&gt; from 2017-10-08.</source>
          <target state="translated">上記の測定は、2017-10-08のSQLiteバージョン&lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;5594a121bf132a98&lt;/a&gt;を使用して行われました。</target>
        </trans-unit>
        <trans-unit id="201062f4cfcc7a2c58dc61b839eac4c989004f31" translate="yes" xml:space="preserve">
          <source>Measuring and Reducing CPU Usage in SQLite</source>
          <target state="translated">SQLiteでのCPU使用量の測定と削減</target>
        </trans-unit>
        <trans-unit id="d815eeb251818f42b639c19483653cb9e9676a23" translate="yes" xml:space="preserve">
          <source>MemMax</source>
          <target state="translated">MemMax</target>
        </trans-unit>
        <trans-unit id="57b0394c856fac60e784f92bcfff68951cf81266" translate="yes" xml:space="preserve">
          <source>Memory Allocation Routines</source>
          <target state="translated">メモリ割り当てルーチン</target>
        </trans-unit>
        <trans-unit id="3a30329db6460c4ed15bebe4d427af9052e6678f" translate="yes" xml:space="preserve">
          <source>Memory Allocation Subsystem</source>
          <target state="translated">メモリわりあてサブシステム</target>
        </trans-unit>
        <trans-unit id="f5bd12480983914d8406751d31133ba86381302d" translate="yes" xml:space="preserve">
          <source>Memory Allocator Statistics</source>
          <target state="translated">メモリアロケータの統計</target>
        </trans-unit>
        <trans-unit id="8ee60155b22e766b4de73dc4f683f3ac25fa009b" translate="yes" xml:space="preserve">
          <source>Memory Slot</source>
          <target state="translated">メモリースロット</target>
        </trans-unit>
        <trans-unit id="ea9be83a8f265809341121ab4ff9c58d527a1bdd" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;、...）開始時間オプションと&lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;コンパイル時間オプションの組み合わせを使用すると、メモリアカウンティングが無効になります。</target>
        </trans-unit>
        <trans-unit id="83484b2c23e2c43deda0dd88234486f9158814f3" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;、...）開始時間オプションと&lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;コンパイル時間オプションの組み合わせを使用すると、メモリアカウンティングが無効になります。</target>
        </trans-unit>
        <trans-unit id="c90d2f9e1fbdf5d88900e51c0817d79397425f44" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">SQLiteが&lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0でコンパイルされていない限り、メモリ割り当て統計はデフォルトで有効になっています。この場合、メモリ割り当て統計はデフォルトで無効になっています。</target>
        </trans-unit>
        <trans-unit id="36fecd267945c46262e4527e9008734a419499a2" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">SQLiteが&lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0でコンパイルされていない限り、メモリ割り当て統計はデフォルトで有効になっています。この場合、メモリ割り当て統計はデフォルトで無効になっています。</target>
        </trans-unit>
        <trans-unit id="30cf1b800d03b60f9a295eac5e3ee911eb40a567" translate="yes" xml:space="preserve">
          <source>Memory allocation, caseless string comparison routines, portable text-to-number conversion routines, and other utilities are located in &lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.c&lt;/a&gt;. Symbol tables used by the parser are maintained by hash tables found in &lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;utf.c&lt;/a&gt; source file contains Unicode conversion subroutines. SQLite has its own private implementation of &lt;a href=&quot;printf&quot;&gt;printf()&lt;/a&gt; (with some extensions) in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; and its own pseudo-random number generator (PRNG) in &lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;random.c&lt;/a&gt;.</source>
          <target state="translated">メモリ割り当て、大文字と小文字を区別しない文字列比較ルーチン、移植可能なテキストから数値への変換ルーチン、およびその他のユーティリティは&lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.cにあり&lt;/a&gt;ます。パーサーが使用するシンボルテーブルは、&lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.cにある&lt;/a&gt;ハッシュテーブルによって維持されます。&lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;utf.cの&lt;/a&gt;ソースファイルは、Unicode変換サブルーチンが含まれています。 SQLiteは、&lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.cに&lt;/a&gt;独自の実装の&lt;a href=&quot;printf&quot;&gt;printf（）&lt;/a&gt;（一部拡張あり）を、random.cに独自の疑似乱数ジェネレータ（PRNG）を&lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;実装してい&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="8351f935d7e0b92d4dbd88ff6014fc3cfebc6b06" translate="yes" xml:space="preserve">
          <source>Memory statistics</source>
          <target state="translated">メモリ統計</target>
        </trans-unit>
        <trans-unit id="0b3951c84915f2636f64c4da056f2bbaa63121ac" translate="yes" xml:space="preserve">
          <source>Memory to hold the information returned by &lt;b&gt;sqlite_get_table&lt;/b&gt; is obtained from malloc(). But the calling function should not try to free this information directly. Instead, pass the complete table to &lt;b&gt;sqlite_free_table&lt;/b&gt; when the table is no longer needed. It is safe to call &lt;b&gt;sqlite_free_table&lt;/b&gt; with a NULL pointer such as would be returned if the result set is empty.</source>
          <target state="translated">&lt;b&gt;sqlite_get_table&lt;/b&gt;によって返される情報を保持するメモリは、malloc（）から取得されます。しかし、呼び出し側の関数は、この情報を直接解放しようとするべきではありません。代わりに、テーブルが不要になったときに、テーブル&lt;b&gt;全体&lt;/b&gt;を&lt;b&gt;sqlite_free_table&lt;/b&gt;に渡します。結果セットが空の場合に返されるようなNULLポインタで&lt;b&gt;sqlite_free_table&lt;/b&gt;を呼び出すのは安全です。</target>
        </trans-unit>
        <trans-unit id="0ebf6aa26b7b4fd9c6127be506bafbc4c2292df8" translate="yes" xml:space="preserve">
          <source>Memory-Mapped I/O</source>
          <target state="translated">メモリマップI/O</target>
        </trans-unit>
        <trans-unit id="7640161f9a59fd693f768ecd9272e3177311b46c" translate="yes" xml:space="preserve">
          <source>Memsys4 and memsys6 were experimental memory allocators introduced in around 2007 and subsequently removed from the source tree in around 2008, after it became clear that they added no new value.</source>
          <target state="translated">Memsys4 と memsys6 は 2007 年頃に導入された実験的なメモリアロケータで、その後、新しい価値を与えないことが明らかになったため、2008 年頃にソースツリーから削除されました。</target>
        </trans-unit>
        <trans-unit id="53e5e9eaf00f6f480e84b07b830bf50ed69b3504" translate="yes" xml:space="preserve">
          <source>Merge development changes into the main trunk. Future work toward using a BTree file structure will use a separate CVS source tree. This CVS tree will continue to support the GDBM version of SQLite only.</source>
          <target state="translated">開発の変更点をメインのトランクにマージしました。BTree ファイル構造を使用するための将来の作業では、別の CVS ソースツリーを使用することになります。この CVS ツリーは、SQLite の GDBM バージョンのみをサポートし続けます。</target>
        </trans-unit>
        <trans-unit id="1c69f87311ee49961b7db4c6959bf9e564173753" translate="yes" xml:space="preserve">
          <source>MergePatch can add, modify, or delete elements of a JSON Object, and so for JSON Objects, the json_patch() routine is a generalized replacement for &lt;a href=&quot;json1#jset&quot;&gt;json_set()&lt;/a&gt; and &lt;a href=&quot;json1#jrm&quot;&gt;json_remove()&lt;/a&gt;. However, MergePatch treats JSON Array objects as atomic. MergePatch cannot append to an Array nor modify individual elements of an Array. It can only insert, replace, or delete the whole Array as a single unit. Hence, json_patch() is not as useful when dealing with JSON that includes Arrays, especially Arrays with lots of substructure.</source>
          <target state="translated">MergePatchは、JSONオブジェクトの要素を追加、変更、または削除できるため、JSONオブジェクトの場合、json_patch（）ルーチンは、&lt;a href=&quot;json1#jset&quot;&gt;json_set（）&lt;/a&gt;および&lt;a href=&quot;json1#jrm&quot;&gt;json_remove（）の&lt;/a&gt;汎用的な置き換えです。ただし、MergePatchはJSON配列オブジェクトをアトミックとして扱います。MergePatchは、配列に追加したり、配列の個々の要素を変更したりすることはできません。アレイ全体を1つのユニットとして挿入、置換、または削除することしかできません。したがって、json_patch（）は、配列、特に多くの部分構造を持つ配列を含むJSONを処理する場合にはあまり役に立ちません。</target>
        </trans-unit>
        <trans-unit id="b34856a8252222662370c82e139676a40460db4d" translate="yes" xml:space="preserve">
          <source>Merged the &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; extension into trunk.</source>
          <target state="translated">&lt;a href=&quot;sessionintro&quot;&gt;セッション&lt;/a&gt;拡張をトランクにマージしました。</target>
        </trans-unit>
        <trans-unit id="dbaecd82c952801d0bb82c4bd7a41de66b9fda44" translate="yes" xml:space="preserve">
          <source>Metadata is returned by writing to the memory locations passed as the 5th and subsequent parameters to this function. Any of these arguments may be NULL, in which case the corresponding element of metadata is omitted.</source>
          <target state="translated">メタデータは、この関数の5番目以降の引数として渡されたメモリの位置に書き込むことで返されます。これらの引数のいずれかがNULLであっても構いませんが、その場合はメタデータの対応する要素は省略されます。</target>
        </trans-unit>
        <trans-unit id="4d3732872bb2a9906cc1153aeb2590dd048c19aa" translate="yes" xml:space="preserve">
          <source>Method (2) offers a midpoint between (1) and (3). Using this method, a query such as '1s*' will match documents that contain the literal token &quot;1st&quot;, but not &quot;first&quot; (assuming the tokenizer is not able to provide synonyms for prefixes). However, a non-prefix query like '1st' will match against &quot;1st&quot; and &quot;first&quot;. This method does not require extra disk space, as no extra entries are added to the FTS index. On the other hand, it may require more CPU cycles to run MATCH queries, as separate queries of the FTS index are required for each synonym.</source>
          <target state="translated">メソッド(2)は、(1)と(3)の中間点を提供します。このメソッドを使用すると、'1s*'のようなクエリは、リテラルトークン &quot;1st &quot;を含むドキュメントにはマッチしますが、&quot;first &quot;にはマッチしません(トークナイザーが接頭辞の同義語を提供できないことを前提としています)。しかし、'1st'のようなプレフィックスではないクエリは、&quot;1st &quot;と &quot;first &quot;に対してマッチします。この方法では、FTSインデックスに余分なエントリが追加されないので、余分なディスクスペースを必要としません。一方で、FTSインデックスの個別のクエリが各同義語に対して必要となるため、MATCHクエリの実行にはより多くのCPUサイクルが必要となるかもしれません。</target>
        </trans-unit>
        <trans-unit id="1df213a45649b1f66258f5768182bafcd559f0b9" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">メソッド：&lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b9983b06e527d46d817373bc15d13089f4d3e12" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">メソッド：&lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="547fb3fd92f4ba766d2b81080903dd2fa70ddd7a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">メソッド：&lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ba8e151eaa184a6fb4bcf2ae01f52e3682b9b04" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">メソッド：&lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;、&lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;、&lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;、&lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05bb53e8fd80fd00914dd4034f12bb335994738a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">メソッド：&lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp（）&lt;/a&gt;、&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;、&lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80b86f6f0bb9183c80c83fe634331b034c5a3b6c" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">メソッド：&lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add（）&lt;/a&gt;、&lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91126b8550d89c2cabd56ad5c8ea6415436ef4e7" translate="yes" xml:space="preserve">
          <source>Millions and millions of test cases</source>
          <target state="translated">数百万、数百万のテストケース</target>
        </trans-unit>
        <trans-unit id="8cb901663cd153748076b7a4eed655ac9c9ceb63" translate="yes" xml:space="preserve">
          <source>Minimum embedded payload fraction. Must be 32.</source>
          <target state="translated">埋込ペイロードの最小割合。32でなければなりません。</target>
        </trans-unit>
        <trans-unit id="9f5a0ef3646738848b65efb74e98db2b2c5a359b" translate="yes" xml:space="preserve">
          <source>Minimum rowid</source>
          <target state="translated">最小行数</target>
        </trans-unit>
        <trans-unit id="62a01943e842ea4e97ec6b470d86e59a45ec37a1" translate="yes" xml:space="preserve">
          <source>Minor revisions to the website.</source>
          <target state="translated">ホームページの軽微な修正。</target>
        </trans-unit>
        <trans-unit id="e2f772b3f3e4226648620e3b2d22fc9e06b7af3b" translate="yes" xml:space="preserve">
          <source>Minor syntactic changes to support a wider variety of compilers.</source>
          <target state="translated">より多くのコンパイラをサポートするためのマイナーな構文の変更。</target>
        </trans-unit>
        <trans-unit id="a207d914072a9004f7af9edb9092f93397750bdb" translate="yes" xml:space="preserve">
          <source>Minor tweaks to other code to make it run a little faster.</source>
          <target state="translated">他のコードを少し速く実行するために、他のコードを微調整しました。</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="b80fca6a605a77935ff5f5e3122df5de2dfd1555" translate="yes" xml:space="preserve">
          <source>Miscellaneous &lt;a href=&quot;cpu#microopt&quot;&gt;microoptimizations&lt;/a&gt; reduce CPU usage by about 2.1%.</source>
          <target state="translated">その他の&lt;a href=&quot;cpu#microopt&quot;&gt;マイクロ最適化&lt;/a&gt;により、CPU使用率が約2.1％削減されます。</target>
        </trans-unit>
        <trans-unit id="28c8a44394b5bc456bad4c873373e406d652fe87" translate="yes" xml:space="preserve">
          <source>Miscellaneous code size optimizations and bug fixes</source>
          <target state="translated">その他のコードサイズの最適化とバグ修正</target>
        </trans-unit>
        <trans-unit id="bbb81db24ef06a2153135306601290fda608c2da" translate="yes" xml:space="preserve">
          <source>Miscellaneous documentation enhancements.</source>
          <target state="translated">その他のドキュメントの強化。</target>
        </trans-unit>
        <trans-unit id="98990a8e0a243a1fdf56c721a0da9558936ac95e" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations reduce CPU usage by more than 7% on common workloads. Most optimization in this release has been on the front-end (&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;).</source>
          <target state="translated">その他のマイクロ最適化により、一般的なワークロードでのCPU使用率が7％以上削減されます。このリリースのほとんどの最適化はフロントエンドで行われました（&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fbdfeb6f538d5f7f87b9990239ba0793588dd6eb" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations result in 22.3% more work for the same number of CPU cycles relative to the previous release. SQLite now runs twice as fast as &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; and three times as fast as &lt;a href=&quot;#version_3_3_9&quot;&gt;version 3.3.9&lt;/a&gt;. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 14.04 x64 with gcc 4.8.2 and -Os. Your performance may vary.)</source>
          <target state="translated">その他のマイクロ最適化により、以前のリリースと比較して、同じ数のCPUサイクルで22.3％多い作業が発生します。SQLiteは、&lt;a href=&quot;#version_3_8_0&quot;&gt;バージョン3.8.0の&lt;/a&gt; 2倍、&lt;a href=&quot;#version_3_3_9&quot;&gt;バージョン3.3.9の&lt;/a&gt; 3倍の速度で実行されます。（使用して測定&lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrindを&lt;/a&gt;上&lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.cの&lt;/a&gt; GCC 4.8.2と-OsとUbuntuの14.04のx64上のワークロード。あなたのパフォーマンスは変更になる場合があります。）</target>
        </trans-unit>
        <trans-unit id="fc459de1c05b709bda425ad3c5816738720eebc5" translate="yes" xml:space="preserve">
          <source>Miscellaneous minor bug fixes</source>
          <target state="translated">その他のマイナーなバグ修正</target>
        </trans-unit>
        <trans-unit id="44d1c5c9aa54a9db91e7e7fe347ac18190d724ed" translate="yes" xml:space="preserve">
          <source>Miscellaneous optimizations result in a 2% reduction in &lt;a href=&quot;cpu&quot;&gt;CPU cycles used&lt;/a&gt;.</source>
          <target state="translated">その他の最適化により、&lt;a href=&quot;cpu&quot;&gt;使用されるCPUサイクルが&lt;/a&gt; 2％削減されます。</target>
        </trans-unit>
        <trans-unit id="f1774acabb62d5801f41470f6cd189b2c0aaaf3c" translate="yes" xml:space="preserve">
          <source>Miscellaneous performance enhancements</source>
          <target state="translated">その他の性能強化</target>
        </trans-unit>
        <trans-unit id="276e26893215e7c8d37e726040961fa631182ebb" translate="yes" xml:space="preserve">
          <source>Miscellaneous problem words such as &quot;debt&quot;, &quot;tsetse&quot;, &quot;Nguyen&quot;, &quot;Van Nuyes&quot;.</source>
          <target state="translated">借金」「ツェツェ」「グエン」「ヴァンヌイ」などの雑多な問題語</target>
        </trans-unit>
        <trans-unit id="4f0711bb69728ffde416a549e0f91f702e273516" translate="yes" xml:space="preserve">
          <source>Misformatted records</source>
          <target state="translated">誤ったフォーマットのレコード</target>
        </trans-unit>
        <trans-unit id="0c46987b5699d45998eb4a1f03a81d222b78e342" translate="yes" xml:space="preserve">
          <source>Missing callback</source>
          <target state="translated">コールバックの欠落</target>
        </trans-unit>
        <trans-unit id="55fd1e5df760c82f67c5509ea619f439d18e5b37" translate="yes" xml:space="preserve">
          <source>Missing or surplus index entries</source>
          <target state="translated">欠落または余剰インデックス項目</target>
        </trans-unit>
        <trans-unit id="96732b61a8d377ada7b914c38aba1cf0d28297dd" translate="yes" xml:space="preserve">
          <source>Missing pages</source>
          <target state="translated">欠落しているページ</target>
        </trans-unit>
        <trans-unit id="a1570b7a7267e412717981829df93815ef1f5214" translate="yes" xml:space="preserve">
          <source>Modern filesystems operate faster when disk accesses are sequential. Hence, SQLite will run faster if the content of the database file is on sequential pages. To find out what fraction of the pages in a database are sequential (and thus obtain a measurement that might be useful in determining when to &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;), run a query like the following:</source>
          <target state="translated">最新のファイルシステムは、ディスクアクセスがシーケンシャルである場合、より高速に動作します。したがって、データベースファイルのコンテンツが順次ページ上にある場合、SQLiteはより高速に実行されます。データベース内のページのどの部分がシーケンシャルであるかを見つける（したがって、&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;を行うタイミングを決定するのに役立つ測定値を取得する）には、次のようなクエリを実行します。</target>
        </trans-unit>
        <trans-unit id="213d5e141cc4f1fbdb215e4e1d09c9f135e23841" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;c3ref/vfs&quot;&gt;virtual file system&lt;/a&gt; interface to support a wider range of embedded systems. See &lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt; for additional information. *** Potentially incompatible change ***</source>
          <target state="translated">幅広い組み込みシステムをサポートするための&lt;a href=&quot;c3ref/vfs&quot;&gt;仮想ファイルシステム&lt;/a&gt;インターフェイスの変更。詳細については、&lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt;を参照してください。***互換性がない可能性のある変更***</target>
        </trans-unit>
        <trans-unit id="846a3f594ccb25f4d8b90bf39076621c7a3da386" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; so that the parser tables are 4 times smaller.</source>
          <target state="translated">パーサーテーブルが4倍小さくなるように、&lt;a href=&quot;lemon&quot;&gt;レモンパーサージェネレーターを&lt;/a&gt;変更しました。</target>
        </trans-unit>
        <trans-unit id="a373b9c05e3506597302158ddcc81e7b79ce6310" translate="yes" xml:space="preserve">
          <source>Modified &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH&lt;/a&gt; to remove the &quot;+4&quot; magic number in the buffer size computation.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;および&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH&lt;/a&gt;を変更して、バッファサイズの計算で「+4」のマジックナンバーを削除しました。</target>
        </trans-unit>
        <trans-unit id="7ae047108ffb132cb41d3775cac528b7c36bd9c6" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to print the schema for the built-in SQLITE_MASTER table, if explicitly requested.</source>
          <target state="translated">明示的に要求された場合、組み込みSQLITE_MASTERテーブルのスキーマを出力するように&lt;b&gt;sqlite&lt;/b&gt;シェルプログラムを変更しました。</target>
        </trans-unit>
        <trans-unit id="64b762eca0515a688c77ad3f10cd0b574a4463f3" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to use the new interface routines.</source>
          <target state="translated">新しいインターフェイスルーチンを使用するように&lt;b&gt;sqlite&lt;/b&gt;シェルプログラムを変更しました。</target>
        </trans-unit>
        <trans-unit id="9bea3abf3349ced7a2bd684045cab38caa6bf680" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to make use of the new sqlite_get_table() API in order to print a list of tables in multiple columns, similar to the way &quot;ls&quot; prints filenames.</source>
          <target state="translated">&quot;ls&quot;がファイル名を印刷する方法と同様に、複数の列でテーブルのリストを印刷するために、新しいsqlite_get_table（）APIを使用するように&lt;b&gt;sqlite&lt;/b&gt;シェルを変更しました。</target>
        </trans-unit>
        <trans-unit id="d9d09adf1be852d2030f454ddcb0fb1bbde85e4b" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to print a semicolon at the end of each CREATE statement in the output of the &quot;.schema&quot; command.</source>
          <target state="translated">&quot;.schema&quot;コマンドの出力で各CREATEステートメントの最後にセミコロンを出力するように&lt;b&gt;sqlite&lt;/b&gt;シェルを変更しました。</target>
        </trans-unit>
        <trans-unit id="cecf75f0a6c4e051f8158a879b4378a1d3e737c4" translate="yes" xml:space="preserve">
          <source>Modified the B-Tree and Pager modules so that disk pages that do not contain real data (free pages) are not journaled and are not written from memory back to the disk when they change. This does not impact database integrity, since the pages contain no real data, but it does make large INSERT operations about 2.5 times faster and large DELETEs about 5 times faster.</source>
          <target state="translated">B-Tree モジュールと Pager モジュールを変更し、実データを含まないディスクページ(フリーページ)はジャーナル化されず、変更されてもメモリからディスクに書き戻されないようにしました。これは、ページには実データが含まれていないので、データベースの整合性には影響しませんが、大規模な INSERT 操作が約 2.5 倍、大規模な DELETE が約 5 倍速くなります。</target>
        </trans-unit>
        <trans-unit id="2c4d4de8cb2205ec2b07c88e0fe421ab99dc0aaa" translate="yes" xml:space="preserve">
          <source>Modified the journal file format to make it more resistant to corruption that can occur after an OS crash or power failure.</source>
          <target state="translated">ジャーナルファイル形式を変更し、OSのクラッシュや停電後に発生する破損に強くなるようにしました。</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="2d258a9a354e69d26a5737aed0d98ba4a12d4ab3" translate="yes" xml:space="preserve">
          <source>Modify the TCL interface to use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;.</source>
          <target state="translated">TCLインターフェイスを変更して、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="9c186ff83bfc4ba49c92b1876d399ba40e64a0cc" translate="yes" xml:space="preserve">
          <source>Modify the test scripts to identify tests that depend on system load and processor speed and to warn the user that a failure of one of those (rare) tests does not necessarily mean the library is malfunctioning. No changes to code.</source>
          <target state="translated">システムの負荷とプロセッサ速度に依存するテストを識別し、それらの (まれな)テストの 1 つが失敗したからといって、ライブラリが誤動作しているとは限らないことをユーザーに警告するために、テストスクリプトを変更します。コードに変更はありません。</target>
        </trans-unit>
        <trans-unit id="ef40b73dad75552add2180adc162c800be16bf41" translate="yes" xml:space="preserve">
          <source>Modifying the contents of a database page.</source>
          <target state="translated">データベースページの内容を変更する</target>
        </trans-unit>
        <trans-unit id="56d9419099fd345280bf9a9122ad284109000f7d" translate="yes" xml:space="preserve">
          <source>Modifying, Adding or Truncating a Database Page</source>
          <target state="translated">データベースページの変更、追加、または切り捨て</target>
        </trans-unit>
        <trans-unit id="d9ae0b87be39aed320fa35b9e4b820b36d71a71f" translate="yes" xml:space="preserve">
          <source>More aggressive &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</source>
          <target state="translated">より積極的な&lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="150e84142afe50eae5e55924e9aafb441ae8328b" translate="yes" xml:space="preserve">
          <source>More aggressive optimization of the AND operator when one side or the other is always false.</source>
          <target state="translated">片方またはもう片方が常に偽である場合のAND演算子のより積極的な最適化。</target>
        </trans-unit>
        <trans-unit id="4dccd541fa7b33732e530432dc181f83dcc6ba6e" translate="yes" xml:space="preserve">
          <source>More complex queries may or may not be able to employ query flattening to avoid the temporary table. Whether or not the query can be flattened depends on such factors as whether or not the subquery or outer query contain aggregate functions, ORDER BY or GROUP BY clauses, LIMIT clauses, and so forth. The rules for when a query can and cannot be flattened are very complex and are beyond the scope of this document.</source>
          <target state="translated">より複雑なクエリでは、一時テーブルを避けるためにクエリの平坦化を採用できる場合とできない場合があります。クエリを平坦化できるかどうかは、副問い合わせや外部問い合わせに集約関数、ORDER BY句やGROUP BY句、LIMIT句などが含まれているかどうかに依存します。問い合わせが平坦化できる場合とできない場合のルールは非常に複雑であり、このドキュメントの範囲を超えています。</target>
        </trans-unit>
        <trans-unit id="0e965ef66116c7e835a08b23bc0aea20069b16ec" translate="yes" xml:space="preserve">
          <source>More efficient encoding of boolean values resulting in smaller database files</source>
          <target state="translated">より効率的なブーリアン値のエンコーディングにより、データベースファイルが小さくなります。</target>
        </trans-unit>
        <trans-unit id="bc15bc11932b9e3bb7aa3bd3cd6dd3273dc66921" translate="yes" xml:space="preserve">
          <source>More efficient handling of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, especially in cases where the application defines hundreds or thousands of custom functions.</source>
          <target state="translated">特にアプリケーションが数百または数千のカスタム関数を定義する場合に、アプリケーション&lt;a href=&quot;appfunc&quot;&gt;定義のSQL関数&lt;/a&gt;をより効率的に処理します。</target>
        </trans-unit>
        <trans-unit id="8a3c60573ba6ac75355060c30752d85d7e4a4ea7" translate="yes" xml:space="preserve">
          <source>More efficient handling of &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;, especially in cases where the application defines hundreds or thousands of custom functions.</source>
          <target state="translated">特にアプリケーションが数百または数千のカスタム関数を定義する場合、アプリケーション&lt;a href=&quot;c3ref/create_function&quot;&gt;定義のSQL関数の&lt;/a&gt;より効率的な処理。</target>
        </trans-unit>
        <trans-unit id="bbf641e990dbd768fc579b21dbc73f3e38164565" translate="yes" xml:space="preserve">
          <source>More efficient implementation of sqliteFileExists() under Windows. (by Joel Luscy)</source>
          <target state="translated">WindowsでのsqliteFileExists()のより効率的な実装。(Joel Luscyによる)</target>
        </trans-unit>
        <trans-unit id="da802536bedcdb71b26438d22c88c54625f47a34" translate="yes" xml:space="preserve">
          <source>More robust handling of out-of-memory errors.</source>
          <target state="translated">メモリ切れエラーの処理がより強固になりました。</target>
        </trans-unit>
        <trans-unit id="f0bbe298877a69ce96299f0684d775b43d33f438" translate="yes" xml:space="preserve">
          <source>More suggestions...</source>
          <target state="translated">他にも提案が...</target>
        </trans-unit>
        <trans-unit id="40a15bddc2f46eb54c50912ec8296652a2a161bf" translate="yes" xml:space="preserve">
          <source>More than one NEAR operator may appear in a single query. In this case each pair of terms or phrases separated by a NEAR operator must appear within the specified proximity of each other in the document. Using the same table and data as in the block of examples above:</source>
          <target state="translated">1 つのクエリに複数の NEAR 演算子が出現することがあります。この場合、near演算子で区切られた用語または語句の各ペアは、文書内で互いに指定された近接度内に出現しなければなりません。上記の例のブロックと同じテーブルとデータを使用します。</target>
        </trans-unit>
        <trans-unit id="e8eaec9acde05ea65cc7e78b52370752d8ff824b" translate="yes" xml:space="preserve">
          <source>Most R*Tree queries use a depth-first search. This is accomplished by setting the rScore equal to iLevel. A depth-first search is usually preferred since it minimizes the number of elements in the priority queue, which reduces memory requirements and speeds processing. However, some application may prefer a breadth-first search, which can be accomplished by setting rScore to mxLevel-iLevel. By creating more complex formulas for rScore, applications can exercise detailed control over the order in which subtree are searched and leaf R*Tree entries are returned. For example, in an application with many millions of R*Tree entries, the rScore might be arranged so that the largest or most significant entries are returned first, allowing the application to display the most important information quickly, and filling in smaller and less important details as they become available.</source>
          <target state="translated">ほとんどのR*Treeクエリは深度優先検索を使用します。これは、rScoreをiLevelと等しく設定することで実現されます。深さ優先検索は、優先度キュー内の要素数を最小限に抑えることができるため、通常は優先度優先検索が好まれます。しかし、アプリケーションによっては、rScore を mxLevel-iLevel に設定することで実現できる、幅優先検索を好む場合もあります。rScore のためにより複雑な式を作成することで、アプリケーションは、サブツリーが検索され、リーフ R*Tree エントリが返される順序を詳細に制御することができます。例えば、何百万もの R*Tree エントリを持つアプリケーションでは、最大または最も重要なエントリが最初に返されるように rScore を配置することで、アプリケーションは最も重要な情報を素早く表示し、利用可能になるにつれて小さくて重要ではない詳細を埋めることができます。</target>
        </trans-unit>
        <trans-unit id="0b7d92086a8e46f293a7dca57cb6a5c138416054" translate="yes" xml:space="preserve">
          <source>Most SQL database engines (every SQL database engine other than SQLite, as far as we know) uses static, rigid typing. With static typing, the datatype of a value is determined by its container - the particular column in which the value is stored.</source>
          <target state="translated">ほとんどのSQLデータベースエンジン(私たちが知る限り、SQLite以外のすべてのSQLデータベースエンジン)は、静的な型付けを使用しています。静的型付けでは、値のデータ型はコンテナ、つまり値が格納されている特定のカラムによって決定されます。</target>
        </trans-unit>
        <trans-unit id="0b21de15eb7e27a08d9b4ec057ceb748bbaa22cd" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one known to this author that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">ほとんどの SQL データベースエンジンはクライアント/サーバベースです。サーバーレスの中でも、複数のアプリケーションが同時に同じデータベースにアクセスできるのはSQLiteだけです。</target>
        </trans-unit>
        <trans-unit id="27297778565294594247653539b897aca8f2a9fb" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one that this author knows of that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">ほとんどの SQL データベースエンジンはクライアント/サーバーベースです。サーバーレスの中でも、複数のアプリケーションが同時に同じデータベースにアクセスできるのは、この著者が知っている中ではSQLiteだけです。</target>
        </trans-unit>
        <trans-unit id="260ad8dfcdd6cee164826174f5ff18a6d6796783" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are implemented as a separate server process. Programs that want to access the database communicate with the server using some kind of interprocess communication (typically TCP/IP) to send requests to the server and to receive back results. SQLite does not work this way. With SQLite, the process that wants to access the database reads and writes directly from the database files on disk. There is no intermediary server process.</source>
          <target state="translated">ほとんどのSQLデータベースエンジンは、独立したサーバープロセスとして実装されています。データベースにアクセスしたいプログラムは、ある種のプロセス間通信(一般的にはTCP/IP)を使用してサーバーと通信し、サーバーにリクエストを送信して結果を受信します。SQLiteでは、このようには動作しません。SQLiteでは、データベースにアクセスしようとするプロセスは、ディスク上のデータベースファイルから直接読み書きを行います。中間のサーバープロセスはありません。</target>
        </trans-unit>
        <trans-unit id="e11debe28c45aae3eb5d59593787d087cef00a39" translate="yes" xml:space="preserve">
          <source>Most SQL database engines store the schema already parsed into various system tables. On those database engines, ALTER TABLE merely has to make modifications to the corresponding system tables.</source>
          <target state="translated">ほとんどのSQLデータベースエンジンは、すでに解析されたスキーマを様々なシステムテーブルに保存しています。これらのデータベースエンジンでは、ALTER TABLEは対応するシステムテーブルに変更を加えるだけです。</target>
        </trans-unit>
        <trans-unit id="c8146f85b00a04238b33c2841ef39833177b149b" translate="yes" xml:space="preserve">
          <source>Most SQL database engines use static typing. A datatype is associated with each column in a table and only values of that particular datatype are allowed to be stored in that column. SQLite relaxes this restriction by using manifest typing. In manifest typing, the datatype is a property of the value itself, not of the column in which the value is stored. SQLite thus allows the user to store any value of any datatype into any column regardless of the declared type of that column. (There are some exceptions to this rule: An INTEGER PRIMARY KEY column may only store integers. And SQLite attempts to coerce values into the declared datatype of the column when it can.)</source>
          <target state="translated">ほとんどのSQLデータベースエンジンは静的型付けを使用しています。データ型はテーブルの各列に関連付けられており、その列にはその特定のデータ型の値しか格納できません。SQLite では、マニフェスト型付けを使用することでこの制限を緩和しています。マニフェスト型付けでは、データ型は値自体のプロパティであり、値が格納されている列のプロパティではありません。このため、SQLite では、任意のデータ型の値を、そのカラムの宣言された型に関係なく、任意のカラムに格納することができます。(この規則にはいくつかの例外があります。INTEGER PRIMARY KEY カラムは整数のみを格納することができます。また、SQLiteは可能な場合には、そのカラムの宣言されたデータ型に値を強制的に格納しようとします)。</target>
        </trans-unit>
        <trans-unit id="725952f518d7037ff04756bd99d602eae557b1ce" translate="yes" xml:space="preserve">
          <source>Most application formats fit into one of these three categories:</source>
          <target state="translated">ほとんどのアプリケーションフォーマットは、これらの3つのカテゴリのいずれかに当てはまります。</target>
        </trans-unit>
        <trans-unit id="ce502bced488a9855f9633bf314ed3f557c5599e" translate="yes" xml:space="preserve">
          <source>Most applications will only use the session module functionality described in the previous section. However, the following additional functionality is available for the use and manipulation of changeset and patchset blobs:</source>
          <target state="translated">ほとんどのアプリケーションでは、前のセクションで説明したセッションモジュールの機能のみを使用します。しかし、チェンジセットとパッチセットのブロブの使用と操作には、以下の追加機能が利用できます。</target>
        </trans-unit>
        <trans-unit id="cd513c058fc14329a86bc7561ce2383e9150f5ca" translate="yes" xml:space="preserve">
          <source>Most applications work great with SQLite in its default configuration and with no special compile-time configuration. Most developers should be able to completely ignore this document and simply build SQLite from &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt; without any special knowledge and without taking any special actions.</source>
          <target state="translated">ほとんどのアプリケーションは、デフォルトの構成でSQLiteを使用してうまく機能し、特別なコンパイル時の構成は必要ありません。ほとんどの開発者は、このドキュメントを完全に無視し、特別な知識や特別なアクションを実行することなく&lt;a href=&quot;amalgamation&quot;&gt;、統合&lt;/a&gt;からSQLiteを簡単に構築できます。</target>
        </trans-unit>
        <trans-unit id="635fff5a9d997771ed833778dcd946f9fa076040" translate="yes" xml:space="preserve">
          <source>Most builds also use the system memory allocation routines:</source>
          <target state="translated">ほとんどのビルドでは、システムメモリ割り当てルーチンも使用しています。</target>
        </trans-unit>
        <trans-unit id="c757f57c7c0fc6a3a16a4ba481be29df77f7ba0d" translate="yes" xml:space="preserve">
          <source>Most built-in window functions ignore the frame-spec, the exceptions being first_value(), last_value() and nth_value(). It is a syntax error to specify a FILTER clause as part of a built-in window function invocation.</source>
          <target state="translated">ほとんどの組み込みウィンドウ関数はフレーム仕様を無視しますが、例外は first_value()、last_value()、nth_value()です。ビルトインウィンドウ関数の呼び出しの一部としてFILTER句を指定するのは構文エラーです。</target>
        </trans-unit>
        <trans-unit id="91aff38100948ec7606e7b9be6940203c42b637c" translate="yes" xml:space="preserve">
          <source>Most memory statistics are global, and therefore the tracking of statistics must be serialized with a mutex. Statistics are turned on by default, but an option exists to disable them. By disabling memory statistics, SQLite avoids entering and leaving a mutex on each memory allocation and deallocation. That savings can be noticeable on systems where mutex operations are expensive. To disable memory statistics, the following interface is used at start-time:</source>
          <target state="translated">ほとんどのメモリ統計情報はグローバルであるため、統計情報の追跡はミューテックスでシリアル化されなければなりません。統計情報はデフォルトでオンになっていますが、無効にするオプションもあります。メモリ統計情報を無効にすることで、SQLiteはメモリの割り当てや解放のたびにミューテックスを入力したり残したりする必要がなくなります。この節約は、ミューテックス処理が高価なシステムでは顕著です。メモリ統計情報を無効にするには、以下のインターフェイスを起動時に使用します。</target>
        </trans-unit>
        <trans-unit id="3ddc29325f5f8b33e852a6ad2b01d9c1a5b27979" translate="yes" xml:space="preserve">
          <source>Most object references may only resolve to a specific type of object (for example a reference that is part of a DROP TABLE statement may only resolve to a table object, not an index, trigger or view). However in some contexts (e.g. &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;) an object reference may be resolve to more than one type of object. When searching database schemas for a named object, objects of types that cannot be used in the context of the reference are always ignored.</source>
          <target state="translated">ほとんどのオブジェクト参照は、特定のタイプのオブジェクトにのみ解決できます（たとえば、DROP TABLEステートメントの一部である参照は、インデックス、トリガー、またはビューではなく、テーブルオブジェクトにのみ解決できます）。ただし、コンテキストによっては（&lt;a href=&quot;lang_reindex&quot;&gt;REINDEXなど&lt;/a&gt;）、オブジェクト参照が複数のタイプのオブジェクトに解決される場合があります。名前付きオブジェクトのデータベーススキーマを検索する場合、参照のコンテキストで使用できないタイプのオブジェクトは常に無視されます。</target>
        </trans-unit>
        <trans-unit id="1f85923bce6297c36b3c44bb82e688cbd09f35ee" translate="yes" xml:space="preserve">
          <source>Most of the code in the SQLite source tree is devoted purely to &lt;a href=&quot;testing&quot;&gt;testing and verification&lt;/a&gt;. Reliability is important to SQLite. Among the tasks of the test infrastructure is to ensure that SQLite does not misuse dynamically allocated memory, that SQLite does not leak memory, and that SQLite responds correctly to a dynamic memory allocation failure.</source>
          <target state="translated">SQLiteソースツリーのコードのほとんどは、純粋に&lt;a href=&quot;testing&quot;&gt;テストと検証に&lt;/a&gt;充てられています。信頼性はSQLiteにとって重要です。テストインフラストラクチャのタスクの1つは、SQLiteが動的に割り当てられたメモリを誤用しないこと、SQLiteがメモリをリークしないこと、SQLiteが動的メモリ割り当ての失敗に正しく応答することを確認することです。</target>
        </trans-unit>
        <trans-unit id="4ea1351b2e34fd10311e1e13ffcc8b793141d24f" translate="yes" xml:space="preserve">
          <source>Most of the time, sqlite3 just reads lines of input and passes them on to the SQLite library for execution. But input lines that begin with a dot (&quot;.&quot;) are intercepted and interpreted by the sqlite3 program itself. These &quot;dot commands&quot; are typically used to change the output format of queries, or to execute certain prepackaged query statements. There were originally just a few dot commands, but over the years many new features have accumulated so that today there over 60.</source>
          <target state="translated">ほとんどの場合、sqlite3は入力行を読み込んでSQLiteライブラリに渡して実行します。しかし、ドット(&quot;.&quot;)で始まる入力行は、sqlite3プログラム自身によって傍受され、解釈されます。これらの &quot;ドットコマンド &quot;は通常、クエリの出力形式を変更したり、パッケージ化されたクエリ文を実行したりするために使用されます。元々ドットコマンドは数個しかありませんでしたが、長年にわたって多くの新機能が蓄積され、今日では60個以上になりました。</target>
        </trans-unit>
        <trans-unit id="8140e633bb506b56ea3ecec29c87f47b39a7e315" translate="yes" xml:space="preserve">
          <source>Most of the time, the query planner in SQLite does a good job. However, the query planner needs indices to work with. These indices must normally be added by programmers. Rarely, the query planner AI will make a suboptimal algorithm choice. In those cases, programmers may want to provide additional hints to help the query planner do a better job.</source>
          <target state="translated">ほとんどの場合、SQLite のクエリプランナは良い仕事をしてくれます。しかし、クエリプランナが動作するためにはインデックスが必要です。これらのインデックスは通常、プログラマが追加しなければなりません。まれに、クエリプランナのAIが最適でないアルゴリズムを選択することがあります。そのような場合には、プログラマはクエリプランナがより良い仕事をするのを助けるために、追加のヒントを提供したいと思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="4d637cb6d91465469dba952401dcd3c4590d5c67" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines allocated a fixed amount of disk space for each row in most tables. They play special tricks for handling BLOBs and CLOBs which can be of wildly varying length. But for most tables, if you declare a column to be a VARCHAR(100) then the database engine will allocate 100 bytes of disk space regardless of how much information you actually store in that column.</source>
          <target state="translated">他のほとんどの SQL データベースエンジンは、ほとんどのテーブルの各行に一定量のディスク容量を割り当てています。これらのエンジンは、長さの異なる BLOB や CLOB を扱うために特別な仕掛けをしています。しかし、ほとんどのテーブルでは、ある列をVARCHAR(100)と宣言すると、その列に実際にどれだけの情報が格納されているかに関わらず、データベースエンジンは100バイトのディスク領域を割り当てます。</target>
        </trans-unit>
        <trans-unit id="b52c62ddb6e76f10df4280114ef18bdd833e392c" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines are much larger than this. IBM boasts that its recently released CloudScape database engine is &quot;only&quot; a 2MiB jar file - an order of magnitude larger than SQLite even after it is compressed! Firebird boasts that its client-side library is only 350KiB. That's as big as SQLite and does not even contain the database engine. The Berkeley DB library from Oracle is 450KiB and it omits SQL support, providing the programmer with only simple key/value pairs.</source>
          <target state="translated">他のほとんどの SQL データベースエンジンはこれよりもはるかに大きいです。IBMは最近リリースされたCloudScapeデータベースエンジンは &quot;たった &quot;2MiBのjarファイルだと自慢しています。Firebirdは、そのクライアント側のライブラリがたったの350KiBだと自慢しています。これはSQLiteと同じくらいの大きさで、データベースエンジンさえ含まれていません。OracleのBerkeley DBライブラリは450KiBで、SQLのサポートを省略しており、プログラマには単純なキー/値のペアだけを提供しています。</target>
        </trans-unit>
        <trans-unit id="5dfe3bda7177abf58f732623f4daabfa91229422" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines require you to dump and restore the database when moving from one platform to another and often when upgrading to a newer version of the software.</source>
          <target state="translated">他のほとんどのSQLデータベースエンジンでは、あるプラットフォームから別のプラットフォームに移動するときや、ソフトウェアの新しいバージョンにアップグレードするときに、データベースをダンプしてリストアする必要があります。</target>
        </trans-unit>
        <trans-unit id="879c0198beea8a0459677487adc544c847a7576f" translate="yes" xml:space="preserve">
          <source>Most programmers compile SQLite into their applications using the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is C-code but it is not &quot;source code&quot;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is generated from source code by scripts.</source>
          <target state="translated">ほとんどのプログラマーは、&lt;a href=&quot;amalgamation&quot;&gt;融合&lt;/a&gt;を使用してSQLiteをアプリケーションにコンパイルします。&lt;a href=&quot;amalgamation&quot;&gt;合併は、&lt;/a&gt; C-コードですが、それは「ソースコード」ではありません。&lt;a href=&quot;amalgamation&quot;&gt;合併は、&lt;/a&gt;スクリプトによって、ソースコードから生成されます。</target>
        </trans-unit>
        <trans-unit id="e8416192176e318d00a7b55e02e8a608d8bdbda6" translate="yes" xml:space="preserve">
          <source>Most tables in SQLite consist of zero or more rows with a unique integer key (the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; or &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;) followed by content. (The exception is &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.) The rows are logically stored in order of increasing rowid. As an example, this article uses a table named &quot;FruitsForSale&quot; which relates various fruits to the state where they are grown and their unit price at market. The schema is this:</source>
          <target state="translated">SQLiteのほとんどのテーブルは、一意の整数キー（&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;または&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;）とその後にコンテンツが続く0個以上の行で構成されます。（例外は、&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルです。）行は、ROWIDの増加順に論理的に格納されます。例として、この記事では「FruitsForSale」という名前のテーブルを使用します。このテーブルは、さまざまな果物を栽培されている州と市場での単価に関連付けています。スキーマはこれです：</target>
        </trans-unit>
        <trans-unit id="22d0e010589dcfa569bc8ab54799e70d1b27d453" translate="yes" xml:space="preserve">
          <source>Most tables in a typical SQLite database schema are rowid tables.</source>
          <target state="translated">典型的なSQLiteデータベーススキーマのほとんどのテーブルはrowidテーブルです。</target>
        </trans-unit>
        <trans-unit id="ab23b25ac3bb6f94df4203c5e40926f8de962adb" translate="yes" xml:space="preserve">
          <source>Most users of swarmvtab will only use the features described above. This section describes features designed for more esoteric use cases. These features all involve specifying extra optional parameters following the SQL statement as part of the CREATE VIRTUAL TABLE command. An optional parameter is specified using its name, followed by an &quot;=&quot; character, followed by an optionally quoted value. Whitespace may separate the name, &quot;=&quot; character and value. For example:</source>
          <target state="translated">swarmvtab のほとんどのユーザーは、上記の機能のみを使用します。このセクションでは、より難解な使用例のために設計された機能について説明します。これらの機能はすべて、CREATE VIRTUAL TABLEコマンドの一部としてSQL文の後にオプションのパラメータを指定します。オプションのパラメータは、名前の後に&quot;=&quot;文字を続けて指定し、その後に任意で引用符で囲まれた値を指定します。空白文字で名前、&quot;=&quot;文字、値を区切ることができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="76cdb950721642b6b8596d36d5a39f7705028b99" translate="yes" xml:space="preserve">
          <source>Move</source>
          <target state="translated">Move</target>
        </trans-unit>
        <trans-unit id="7e894652e8d984064189391f996d60397e2a48ec" translate="yes" xml:space="preserve">
          <source>Move a BLOB Handle to a New Row</source>
          <target state="translated">BLOBハンドルを新しい行に移動する</target>
        </trans-unit>
        <trans-unit id="b0ff33b105569af9f2119de68af4d3ef24773b02" translate="yes" xml:space="preserve">
          <source>Move the P3 values in register P1..P1+P3-1 over into registers P2..P2+P3-1. Registers P1..P1+P3-1 are left holding a NULL. It is an error for register ranges P1..P1+P3-1 and P2..P2+P3-1 to overlap. It is an error for P3 to be less than 1.</source>
          <target state="translated">レジスタP1...P1+P3-1のP3値をレジスタP2...P2+P3-1に移動します。レジスタP1..P1+P3-1はNULLを保持したままになります。レジスタ範囲P1..P1+P3-1とP2..P2+P3-1が重なるのはエラーです。P3が1より小さいのはエラーです。</target>
        </trans-unit>
        <trans-unit id="43e629ad230f33beeec0dc2dfe68b2611f083ba6" translate="yes" xml:space="preserve">
          <source>Move the cursor P1 to a null row. Any &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; operations that occur while the cursor is on the null row will always write a NULL.</source>
          <target state="translated">カーソルP1をnull行に移動します。任意の&lt;a href=&quot;opcode#Column&quot;&gt;列&lt;/a&gt;カーソルがヌル行にあるときに発生する操作は常にNULLを記述します。</target>
        </trans-unit>
        <trans-unit id="ff17aceff7878d14b853ed0faf40490493d4491b" translate="yes" xml:space="preserve">
          <source>Move website and documentation files out of the source tree into a &lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;separate CM system&lt;/a&gt;.</source>
          <target state="translated">Webサイトとドキュメントファイルをソースツリーから&lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;別のCMシステムに移動し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="42fda9211198a462ad90d286a7b4b2828423cc34" translate="yes" xml:space="preserve">
          <source>Moved the CVS repository to www.sqlite.org</source>
          <target state="translated">CVS リポジトリを www.sqlite.org に移動しました。</target>
        </trans-unit>
        <trans-unit id="dc586a90c5c94a44d1d972ced97472cbaf4b949e" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.4.2 to 3.5.0</source>
          <target state="translated">SQLite 3.4.2から3.5.0への移行</target>
        </trans-unit>
        <trans-unit id="d4fefbd0278cf9b39cd3f466ee48861cfc5e39db" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.5.9 to 3.6.0</source>
          <target state="translated">SQLite 3.5.9から3.6.0への移行</target>
        </trans-unit>
        <trans-unit id="f76bc373feee6b1842d340bd7d664f80273b9cc9" translate="yes" xml:space="preserve">
          <source>Moving a journal file from one database to another.</source>
          <target state="translated">ジャーナルファイルをあるデータベースから別のデータベースに移動します。</target>
        </trans-unit>
        <trans-unit id="f0efafe4edefbbfdb22e09fc7f8e1939d65fc935" translate="yes" xml:space="preserve">
          <source>Much of the &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; is found in source files &lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt;, and &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c&lt;/a&gt; though some routines are scattered about in other files where they can have access to data structures with file scope. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; routine is implemented in &lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; routine is found in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete()&lt;/a&gt; interface is in &lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt;. The &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; is implemented by &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/intro&quot;&gt;C言語インターフェイスの&lt;/a&gt;多くは、ソースファイル&lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt;、&lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt;、および&lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.cに&lt;/a&gt;ありますが、一部のルーチンは、ファイルスコープを持つデータ構造にアクセスできる他のファイルに散在しています。&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;ルーチンが実装されて&lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt;。&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;ルーチンがで発見され&lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;。&lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete（）&lt;/a&gt;インターフェースはである&lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt;。&lt;a href=&quot;tclsqlite&quot;&gt;TCLインタフェース&lt;/a&gt;によって実装され&lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0aeaa0f6e5bc7f27528f2732350cce3993158ba7" translate="yes" xml:space="preserve">
          <source>Multi-File Transactions</source>
          <target state="translated">複数ファイル取引</target>
        </trans-unit>
        <trans-unit id="7bd215d0dc08a639766c0fd92af7ca6bd919b359" translate="yes" xml:space="preserve">
          <source>Multi-character insertions, deletions, and substitutions can be enumerated in the cost table.</source>
          <target state="translated">複数の文字の挿入、削除、置換は、コストテーブルに列挙することができます。</target>
        </trans-unit>
        <trans-unit id="658e2e2d073be17c3d24649adb63bc8071c4e34c" translate="yes" xml:space="preserve">
          <source>Multi-column indexes</source>
          <target state="translated">複数列インデックス</target>
        </trans-unit>
        <trans-unit id="b37d6f5d76bdf33c501015c981f38efa402cfb25" translate="yes" xml:space="preserve">
          <source>Multi-column indices only work if the constraint terms in the WHERE clause of the query are connected by AND. So Idx3 and Idx4 are helpful when the search is for items that are both Oranges and grown in California, but neither index would be that useful if we wanted all items that were either oranges</source>
          <target state="translated">マルチカラムインデックスは、クエリのWHERE句の制約条件がANDで接続されている場合にのみ機能します。つまり、Idx3とIdx4は、オレンジとカリフォルニア産の両方のアイテムを検索する場合に便利ですが、オレンジとカリフォルニア産の両方のアイテムを検索する場合には、どちらのインデックスもそれほど便利ではありません。</target>
        </trans-unit>
        <trans-unit id="a6a2f3477040c5c780afe34563348a368c865f18" translate="yes" xml:space="preserve">
          <source>Multiple Programming Languages</source>
          <target state="translated">複数のプログラミング言語</target>
        </trans-unit>
        <trans-unit id="8127845d9b0c204fa8283356e673cf21f966c9a0" translate="yes" xml:space="preserve">
          <source>Multiple VFSes can be registered at the same time. Each VFS has a unique names. Separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; within the same process can be using different VFSes at the same time. For that matter, if a single database connection has multiple database files open using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command, then each attached database might be using a different VFS.</source>
          <target state="translated">複数のVFSを同時に登録できます。各VFSには一意の名前があります。同じプロセス内の個別の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;は、異なるVFSを同時に使用できます。さらに言えば、単一のデータベース接続で&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;コマンドを使用して複数のデータベースファイルが開かれている場合、接続されている各データベースが異なるVFSを使用している可能性があります。</target>
        </trans-unit>
        <trans-unit id="dcdea0a58cadff7c782d97a6048e7da5d88f4991" translate="yes" xml:space="preserve">
          <source>Multiple b-tree structures are used instead of a single b-tree to reduce the cost of inserting records into FTS tables. When a new record is inserted into an FTS table that already contains a lot of data, it is likely that many of the terms in the new record are already present in a large number of existing records. If a single b-tree were used, then large doclist structures would have to be loaded from the database, amended to include the new docid and term-offset list, then written back to the database. Using multiple b-tree tables allows this to be avoided by creating a new b-tree which can be merged with the existing b-tree (or b-trees) later on. Merging of b-tree structures can be performed as a background task, or once a certain number of separate b-tree structures have been accumulated. Of course, this scheme makes queries more expensive (as the FTS code may have to look up individual terms in more than one b-tree and merge the results), but it has been found that in practice this overhead is often negligible.</source>
          <target state="translated">FTSテーブルへのレコード挿入のコストを削減するために、単一のbツリーの代わりに複数のbツリー構造が使用されます。すでに多くのデータを含むFTSテーブルに新しいレコードが挿入される場合、新しいレコードに含まれる用語の多くは、既存の多数のレコードにすでに存在している可能性が高い。単一のb-treeを使用した場合、大規模なdoclist構造をデータベースからロードし、新しいdocidと用語オフセットリストを含むように修正し、データベースに書き戻す必要があります。複数のb-treeテーブルを使用すると、後で既存のb-tree(またはb-tree)とマージできる新しいb-treeを作成することで、このような事態を避けることができます。b-tree構造のマージは、バックグラウンドタスクとして実行することもできますし、一定数の個別のb-tree構造が蓄積された後に実行することもできます。もちろん、この方式はクエリをより高価なものにします(FTSコードは複数のb-treeの中の個々の用語を検索し、その結果をマージしなければならないので)が、実際にはこのオーバーヘッドは無視できることが多いことがわかっています。</target>
        </trans-unit>
        <trans-unit id="46b7208fbb4e603607fdd8e005b8c2b44c4f2832" translate="yes" xml:space="preserve">
          <source>Multiple bug fixes to the &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; logic that was introduced in version 3.15.0.</source>
          <target state="translated">バージョン3.15.0で導入された&lt;a href=&quot;rowvalue&quot;&gt;行値&lt;/a&gt;ロジックに対する複数のバグ修正。</target>
        </trans-unit>
        <trans-unit id="5bf9dc54bb3a9335bc64c25972bec9a940f13e21" translate="yes" xml:space="preserve">
          <source>Multiple commentators have expressed a desire to use dynamic strings for the pointer type, and to have SQLite take ownership of the type strings and to automatically free the type string when it has finished using it. That design is rejected for the following reasons:</source>
          <target state="translated">複数のコメンテーターが、ポインタ型に動的な文字列を使用し、SQLiteが型文字列の所有権を持ち、それを使用し終わったときに自動的に型文字列を解放するようにしたいという願望を表明しています。この設計は以下の理由で却下されました。</target>
        </trans-unit>
        <trans-unit id="5989cfc9447928ba4d05b443c6d4b672ed4ef531" translate="yes" xml:space="preserve">
          <source>Multiple connections from within a single process that use this implementation of asynchronous IO may access a single database file concurrently. From the point of view of the user, if all connections are from within a single process, there is no difference between the concurrency offered by &quot;normal&quot; SQLite and SQLite using the asynchronous backend.</source>
          <target state="translated">非同期IOのこの実装を使用した単一プロセス内の複数の接続は、単一のデータベースファイルに同時にアクセスすることができます。ユーザーの視点から見ると、すべての接続が単一のプロセス内からのものであれば、&quot;通常の &quot;SQLiteと非同期バックエンドを使用したSQLiteで提供される同時実行性に違いはありません。</target>
        </trans-unit>
        <trans-unit id="de5017f80cc138eb92a9fee1631567420f1d53b1" translate="yes" xml:space="preserve">
          <source>Multiple connections may hold a read-lock simultaneously. If many threads are acquiring overlapping read-locks, it might be the case that at least one thread is always holding a read lock. Then a table waiting for a write-lock will wait forever. This scenario is called &quot;writer starvation.&quot;</source>
          <target state="translated">複数の接続が同時にリードロックを保持する場合があります。多くのスレッドが重複するリードロックを取得している場合、少なくとも1つのスレッドが常にリードロックを保持している場合があります。そうすると、書き込みロックを待っているテーブルは永遠に待つことになります。このシナリオは &quot;ライター飢餓 &quot;と呼ばれています。</target>
        </trans-unit>
        <trans-unit id="809241f3730c6379db2c7c73b89d2efee62ec7f1" translate="yes" xml:space="preserve">
          <source>Multiple databases on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using &lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE &lt;/a&gt;&lt;a href=&quot;c3ref/sqlite3&quot;&gt;を&lt;/a&gt;使用した同じデータベース接続上の複数のデータベース</target>
        </trans-unit>
        <trans-unit id="45a728f83fed6326d4c43841ba1813e1ce7eb6dd" translate="yes" xml:space="preserve">
          <source>Multiple processes can attach to the same application file and can read and write without interfering with each another.</source>
          <target state="translated">複数のプロセスが同じアプリケーションファイルにアタッチすることができ、お互いに干渉することなく読み書きすることができます。</target>
        </trans-unit>
        <trans-unit id="2aa7ba24512eed1d018b442b661d99d24d2bbe28" translate="yes" xml:space="preserve">
          <source>Multiple processes can have the same database open at the same time. Multiple processes can be doing a SELECT at the same time. But only one process can be making changes to the database at any moment in time, however.</source>
          <target state="translated">複数のプロセスが同時に同じデータベースを開くことができます。複数のプロセスが同時にSELECTを実行することができます。しかし、データベースに変更を加えることができるのは1つのプロセスだけです。</target>
        </trans-unit>
        <trans-unit id="933ed3deea04e9e9fbd7189bd88652e303cb225d" translate="yes" xml:space="preserve">
          <source>Multiple small sorts collectively use fewer CPU cycles than a single large sort.</source>
          <target state="translated">複数の小規模なソートをまとめて使用すると、単一の大規模なソートよりも少ないCPUサイクルを使用します。</target>
        </trans-unit>
        <trans-unit id="b20a305f06f0be2e3dd77e203ae365353776cf59" translate="yes" xml:space="preserve">
          <source>Multiply</source>
          <target state="translated">Multiply</target>
        </trans-unit>
        <trans-unit id="8e0df4037503e2d7d2784fedb62cdd6ec1bcce1f" translate="yes" xml:space="preserve">
          <source>Multiply the value in register P1 by the value in register P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">レジスタP1の値とレジスタP2の値を掛け合わせ、その結果をレジスタP3に格納します。どちらかの入力がNULLの場合、結果はNULLになります。</target>
        </trans-unit>
        <trans-unit id="96a8063d277e69bad9338f2cd2299ce555b10c74" translate="yes" xml:space="preserve">
          <source>Multiplying null by zero gives null</source>
          <target state="translated">nullに0を乗算すると、nullは次のようになります。</target>
        </trans-unit>
        <trans-unit id="0882d3aaa23d5575a8f63bfdd8452012d19a092f" translate="yes" xml:space="preserve">
          <source>MustBeInt</source>
          <target state="translated">MustBeInt</target>
        </trans-unit>
        <trans-unit id="ad84a5c1e8958f4a9c3429e8188a4603875d0079" translate="yes" xml:space="preserve">
          <source>Mutation test script</source>
          <target state="translated">変異検査スクリプト</target>
        </trans-unit>
        <trans-unit id="20e073cd00cadf7d267e8b82f5b78e0e3f9214a2" translate="yes" xml:space="preserve">
          <source>Mutation testing can be slow, since each test can take up to 5 minutes on a fast workstation, and there are two tests for each branch instructions, and over 20,000 branch instructions. Efforts are made to expedite operation. For example, TH3 is compiled in such a way that it exits as soon as it finds the first error, and as many of the mutations are easily detected, many cycles happen in only a few seconds. Nevertheless, the mutation-test.tcl script includes command-line options to limit the range of code lines tested so that mutation testing only needs to be performed on blocks of code that have recently changed.</source>
          <target state="translated">突然変異検査は、高速なワークステーションでは1回の検査に5分程度かかることがあり、分岐命令ごとに2回の検査があり、20,000以上の分岐命令があるため、時間がかかることがあります。動作を高速化するための努力がなされています。例えば、TH3 は最初のエラーを見つけるとすぐに終了するようにコンパイルされており、多くの突然変異が簡単に検出されるため、多くのサイクルが数秒で発生します。それにもかかわらず、mutation-test.tclスクリプトには、テストするコード行の範囲を制限するコマンドラインオプションが含まれているので、突然変異テストは最近変更されたコードブロックに対してのみ実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="ee9066f4d731d8a141c6e684743ee9a9527de8b6" translate="yes" xml:space="preserve">
          <source>Mutex Handle</source>
          <target state="translated">ミューテックスハンドル</target>
        </trans-unit>
        <trans-unit id="9f117864c1709baa2c76d7b2cfa8d17c9f1bfe11" translate="yes" xml:space="preserve">
          <source>Mutex Methods Object</source>
          <target state="translated">Mutex メソッド オブジェクト</target>
        </trans-unit>
        <trans-unit id="83fb9a7fd1246d148749d832e1630432bf7c41eb" translate="yes" xml:space="preserve">
          <source>Mutex Types</source>
          <target state="translated">ミューテックスの種類</target>
        </trans-unit>
        <trans-unit id="9ca067080a430d66f997055e5f2d644e22736a96" translate="yes" xml:space="preserve">
          <source>Mutex Verification Routines</source>
          <target state="translated">ミューテックス検証ルーチン</target>
        </trans-unit>
        <trans-unit id="82f2c9599c5c14be2ce92b9de958cb57db81b38f" translate="yes" xml:space="preserve">
          <source>Mutexes</source>
          <target state="translated">Mutexes</target>
        </trans-unit>
        <trans-unit id="5b84f7a78e5961ea2a526de843a9daab8f41a20c" translate="yes" xml:space="preserve">
          <source>Mutexes are cheap but they are not free, so performance will be better when mutexes are completely disabled. The resulting library footprint will also be a little smaller. Disabling the mutexes at compile-time is a recommended optimization for applications where it makes sense.</source>
          <target state="translated">ミューテックスは安いですが、無料ではないので、ミューテックスを完全に無効にした方がパフォーマンスは良くなります。その結果、ライブラリのフットプリントも少し小さくなります。コンパイル時にミューテックスを無効にすることは、意味のあるアプリケーションには最適化することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="b22446695cc6c25d3041d52dab780b6caac7cd1e" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">ミューテックスは&lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;を使用して作成されます。</target>
        </trans-unit>
        <trans-unit id="a8bd3143e806972c1aad1cdeede17125b4f66fc3" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">ミューテックスは&lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;を使用して作成されます。</target>
        </trans-unit>
        <trans-unit id="90dba5f17bdba09d7b97e3f464ca3b8fa2e57394" translate="yes" xml:space="preserve">
          <source>My WHERE clause expression &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; does not work. It causes every row of the table to be returned, not just the rows where column1 has the value &quot;column1&quot;.</source>
          <target state="translated">WHERE句の式 &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; が機能しません。column1の値が &quot;column1&quot;である行だけでなく、テーブルのすべての行が返されます。</target>
        </trans-unit>
        <trans-unit id="53dbb81c605812b9954b771e4d176a4b96f646d2" translate="yes" xml:space="preserve">
          <source>My query does not return the column name that I expect. Is this a bug?</source>
          <target state="translated">私のクエリは、私が期待するカラム名を返しません。これはバグでしょうか?</target>
        </trans-unit>
        <trans-unit id="deaa0c393a6613972aaccbf1fecfdad67aa21e88" translate="yes" xml:space="preserve">
          <source>MySQL</source>
          <target state="translated">MySQL</target>
        </trans-unit>
        <trans-unit id="424aa797f42c3aefebeedcebb618509b36642239" translate="yes" xml:space="preserve">
          <source>MySQL supports the UPDATE FROM idea, but it does so without using a FROM clause. Instead, the complete join specification is given in between the UPDATE and SET keywords. The equivalent MySQL statement would be like this:</source>
          <target state="translated">MySQLはUPDATE FROMのアイデアをサポートしていますが、これはFROM句を使わずに行います。代わりに、完全な結合指定はUPDATEキーワードとSETキーワードの間に与えられます。これと同等のMySQL文は次のようになります。</target>
        </trans-unit>
        <trans-unit id="e5d56b96c147bc00244a87ca5dec3dbb343c2acd" translate="yes" xml:space="preserve">
          <source>MySQL version 3.23.41 does not support UNION.</source>
          <target state="translated">MySQL バージョン 3.23.41 は UNION をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="e303d2711b51452d1cb5f1e99368e6acecd1238f" translate="yes" xml:space="preserve">
          <source>MySQL:</source>
          <target state="translated">MySQL:</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="8942124b2b322d5ed5aaedb0379f2b4629d337ae" translate="yes" xml:space="preserve">
          <source>N&amp;ge;12 and even</source>
          <target state="translated">N&amp;ge;12でさえ</target>
        </trans-unit>
        <trans-unit id="65234a7e6be9327b0d7bbc7e6bf2ce41cdf5a33b" translate="yes" xml:space="preserve">
          <source>N&amp;ge;13 and odd</source>
          <target state="translated">N&amp;ge;13と奇数</target>
        </trans-unit>
        <trans-unit id="4bbff46d5e4a2066e44932399c1db699e807cf39" translate="yes" xml:space="preserve">
          <source>N+1</source>
          <target state="translated">N+1</target>
        </trans-unit>
        <trans-unit id="bd2f53c8c05f137a14d10bbea3ef6da285114906" translate="yes" xml:space="preserve">
          <source>N+4</source>
          <target state="translated">N+4</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="8dd6dc5b4967e63a1a79c5eb2a6c948692613a58" translate="yes" xml:space="preserve">
          <source>N1 (cost: 5.52)</source>
          <target state="translated">N1(コスト:5.52</target>
        </trans-unit>
        <trans-unit id="798d9ffe324145d7424e3df912c7130f87d2bc5a" translate="yes" xml:space="preserve">
          <source>N2 (cost: 5.52)</source>
          <target state="translated">N2(コスト:5.52</target>
        </trans-unit>
        <trans-unit id="15fbf39b576cc8bd369719e2a3d26f97ec889560" translate="yes" xml:space="preserve">
          <source>N2-N1 (cost: 11.04)</source>
          <target state="translated">N2-N1(コスト:11.04</target>
        </trans-unit>
        <trans-unit id="5b4ea6d782abcd0ed1483d887c331af67374531e" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="e5c2df06ba96ff92a5b489615f6b10abd3bf147f" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2c0a1bee57f9f58fc50d516a0bf15f88caa7689c" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="a9d371451b6909ac85117130b9153a96499a362c" translate="yes" xml:space="preserve">
          <source>NAME</source>
          <target state="translated">NAME</target>
        </trans-unit>
        <trans-unit id="5b0ac1bba3d09af88af51314ab9e3274563ae94b" translate="yes" xml:space="preserve">
          <source>NATIVE CHARACTER(70)</source>
          <target state="translated">ネイティブキャラクター(70)</target>
        </trans-unit>
        <trans-unit id="7b0c42d6ea58612c19c7961351b229254674e033" translate="yes" xml:space="preserve">
          <source>NATURAL</source>
          <target state="translated">NATURAL</target>
        </trans-unit>
        <trans-unit id="ea1a1d896196c614eb971163bd79e6b0f3ccbe73" translate="yes" xml:space="preserve">
          <source>NB: This extension is deprecated. [WAL mode] is recommended as a replacement.</source>
          <target state="translated">注意:この拡張機能は非推奨です。代わりに [WAL mode]をお勧めします。</target>
        </trans-unit>
        <trans-unit id="9829174ea4702c19a86b2f2d0ae072ffd5bcdee0" translate="yes" xml:space="preserve">
          <source>NCHAR(55)</source>
          <target state="translated">NCHAR(55)</target>
        </trans-unit>
        <trans-unit id="b7fe5d20802ca2aca87db42d4b7dae9f148c0ed7" translate="yes" xml:space="preserve">
          <source>NEAR queries</source>
          <target state="translated">NEAR クエリ</target>
        </trans-unit>
        <trans-unit id="ad140e1560939f826df416c1e0d8f81eaa5dd26a" translate="yes" xml:space="preserve">
          <source>NEAR queries are not available.</source>
          <target state="translated">NEAR クエリは利用できません。</target>
        </trans-unit>
        <trans-unit id="9bbceb6fd3a09583f532267c802c583270b6ed37" translate="yes" xml:space="preserve">
          <source>NEVER(X)</source>
          <target state="translated">NEVER(X)</target>
        </trans-unit>
        <trans-unit id="97b77dd54bade796fe382680ffda0d54d204b7ea" translate="yes" xml:space="preserve">
          <source>NEW and OLD references are valid</source>
          <target state="translated">新しい参照と古い参照が有効です。</target>
        </trans-unit>
        <trans-unit id="a82d81a38474e7a2f1b05be86c3d0ec157924da9" translate="yes" xml:space="preserve">
          <source>NEW references are valid</source>
          <target state="translated">NEW リファレンスは有効です。</target>
        </trans-unit>
        <trans-unit id="aa7b193ecb5f5e8127c45d86d672c669b4ad311a" translate="yes" xml:space="preserve">
          <source>NNN</source>
          <target state="translated">NNN</target>
        </trans-unit>
        <trans-unit id="cf99bc0053e83f8041fe548005de7972be838e08" translate="yes" xml:space="preserve">
          <source>NNN days</source>
          <target state="translated">NNN日</target>
        </trans-unit>
        <trans-unit id="33c4ffa6e43390375c0bf9b4e04eedef73776044" translate="yes" xml:space="preserve">
          <source>NNN hours</source>
          <target state="translated">NNN時間</target>
        </trans-unit>
        <trans-unit id="4dc2b6e588bcda89bc862d480bc0a6894df9769a" translate="yes" xml:space="preserve">
          <source>NNN minutes</source>
          <target state="translated">エヌエヌエヌエヌ議事録</target>
        </trans-unit>
        <trans-unit id="bf0082b4c02bd0d30ff30874661f393df82750f4" translate="yes" xml:space="preserve">
          <source>NNN months</source>
          <target state="translated">エヌエヌエヌ月</target>
        </trans-unit>
        <trans-unit id="afb2dbb2fb0e9adb5cd092d7e7b6d3ffb78523de" translate="yes" xml:space="preserve">
          <source>NNN years</source>
          <target state="translated">NNN年</target>
        </trans-unit>
        <trans-unit id="b58c197b751c5ed1962a3c0390de8c10bb4951b3" translate="yes" xml:space="preserve">
          <source>NNN.NNNN seconds</source>
          <target state="translated">エヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌ秒</target>
        </trans-unit>
        <trans-unit id="a0509b7780628bd9d9abc7eb8a2163477341053a" translate="yes" xml:space="preserve">
          <source>NO</source>
          <target state="translated">NO</target>
        </trans-unit>
        <trans-unit id="05fdd36e7692e52033451b07ec66dff9eb7e55c8" translate="yes" xml:space="preserve">
          <source>NOCASE</source>
          <target state="translated">NOCASE</target>
        </trans-unit>
        <trans-unit id="0654a028e5aea48c8fbb09871b8f397a186c883b" translate="yes" xml:space="preserve">
          <source>NONE</source>
          <target state="translated">NONE</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="13e8b0dd0b366e8464e50db4ffa83a38db17f5c0" translate="yes" xml:space="preserve">
          <source>NOT EXISTS operator</source>
          <target state="translated">不存在演算子</target>
        </trans-unit>
        <trans-unit id="c251201ede2fa823c20c38c57254fd75c17ce421" translate="yes" xml:space="preserve">
          <source>NOT IN operator</source>
          <target state="translated">ふていにゅうえんざんし</target>
        </trans-unit>
        <trans-unit id="f4a4efddb03a7d76572898f7eabe1ea34a780b2f" translate="yes" xml:space="preserve">
          <source>NOT NULL constraint</source>
          <target state="translated">NOT NULLL制約</target>
        </trans-unit>
        <trans-unit id="6ff7e3eeee65666114a7a3854176937e0d8c1522" translate="yes" xml:space="preserve">
          <source>NOT NULL constraints are honored.</source>
          <target state="translated">NOT NULL 制約は優先されます。</target>
        </trans-unit>
        <trans-unit id="c462e8fc3e502ae6d5489c34ffa0054b7073578f" translate="yes" xml:space="preserve">
          <source>NOTHING</source>
          <target state="translated">NOTHING</target>
        </trans-unit>
        <trans-unit id="d6a7f5abac5bd9faa0bac9e8bb7907ab9f614941" translate="yes" xml:space="preserve">
          <source>NOTNULL</source>
          <target state="translated">NOTNULL</target>
        </trans-unit>
        <trans-unit id="4771b572fc1de8c483abeb1a95a1bc516fa56a87" translate="yes" xml:space="preserve">
          <source>NUL characters (ASCII code 0x00 and Unicode \u0000) may appear in the middle of strings in SQLite. This can lead to unexpected behavior. See the &quot;&lt;a href=&quot;nulinstr&quot;&gt;NUL characters in strings&lt;/a&gt;&quot; document for further information.</source>
          <target state="translated">SQLiteの文字列の途中にNUL文字（ASCIIコード0x00およびUnicode \ u0000）が表示される場合があります。これにより、予期しない動作が発生する可能性があります。詳細については、「&lt;a href=&quot;nulinstr&quot;&gt;文字列内のNUL文字&lt;/a&gt;」ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="0d475d854a2a7eeffd82e1a01f92ca65e566328f" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite</source>
          <target state="translated">SQLiteでのNULL処理</target>
        </trans-unit>
        <trans-unit id="7fac7bb3c1a767adbbac557d34135fb142c688ca" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite Versus Other Database Engines</source>
          <target state="translated">SQLiteと他のデータベースエンジンとの比較でのNULL処理</target>
        </trans-unit>
        <trans-unit id="248ab3abcb099e69f2fef53b64e651576012c852" translate="yes" xml:space="preserve">
          <source>NULL values (serial type 0) sort first.</source>
          <target state="translated">NULL 値 (シリアルタイプ 0)を最初にソートします。</target>
        </trans-unit>
        <trans-unit id="a1efa1e3b6119cae6664d71bdefea57f479d6ebf" translate="yes" xml:space="preserve">
          <source>NULL values are now reported to the callback as a NULL pointer rather than an empty string.</source>
          <target state="translated">NULL 値は、空の文字列ではなく NULL ポインタとしてコールバックに報告されるようになりました。</target>
        </trans-unit>
        <trans-unit id="743ef19013396d7d94a24cacbb830235275be9c8" translate="yes" xml:space="preserve">
          <source>NULLS</source>
          <target state="translated">NULLS</target>
        </trans-unit>
        <trans-unit id="fc81819cf87d3384597c4ae67d1976d82323a9b0" translate="yes" xml:space="preserve">
          <source>NULLS LAST</source>
          <target state="translated">NULLS LAST</target>
        </trans-unit>
        <trans-unit id="8280c934b3178b2afed2c01f955aab5fe7295999" translate="yes" xml:space="preserve">
          <source>NULLs sort first</source>
          <target state="translated">NULLは最初にソートします。</target>
        </trans-unit>
        <trans-unit id="58ad270de77802cc63222e273fa800c4b248cdd7" translate="yes" xml:space="preserve">
          <source>NUMERIC</source>
          <target state="translated">NUMERIC</target>
        </trans-unit>
        <trans-unit id="024959fd2d5e8c9c205a2098591019699ae29143" translate="yes" xml:space="preserve">
          <source>NVARCHAR(100)</source>
          <target state="translated">NVARCHAR(100)</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="daa5b774be0bfcbd2e2835e6bd0980fb6e06778a" translate="yes" xml:space="preserve">
          <source>Name Of A Host Parameter</source>
          <target state="translated">ホストパラメータ名</target>
        </trans-unit>
        <trans-unit id="cb9e33f6b09bb7fe5d38a783b74c6905b2f43077" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Database Files</source>
          <target state="translated">データベースファイルを格納するフォルダ名</target>
        </trans-unit>
        <trans-unit id="7749c218b18b42cbe27f3f870da40b8d3d708ba1" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Temporary Files</source>
          <target state="translated">一時ファイルを保存しているフォルダ名</target>
        </trans-unit>
        <trans-unit id="fbb9c33e0412f25c0e798fd22a36fd452bd92012" translate="yes" xml:space="preserve">
          <source>Name of default collation sequence</source>
          <target state="translated">デフォルトの照合順序の名前</target>
        </trans-unit>
        <trans-unit id="4e3a9de996d9196b59f293d51cf53aa5b2a8a36e" translate="yes" xml:space="preserve">
          <source>Named window-defn clauses may also be added to a SELECT statement using a WINDOW clause and then referred to by name within window function invocations. For example, the following SELECT statement contains two named window-defs clauses, &quot;win1&quot; and &quot;win2&quot;:</source>
          <target state="translated">名前付きwindow-defn句は、WINDOW句を使用してSELECT文に追加され、window関数の呼び出しの中で名前で参照されることもあります。例えば、以下のSELECT文は、2つの名前付きwindow-defn句、&quot;win1 &quot;と &quot;win2 &quot;を含んでいます。</target>
        </trans-unit>
        <trans-unit id="02aead4c6c683a05b1c0ebf7ea825cf0f6d1b06c" translate="yes" xml:space="preserve">
          <source>Naming Changes</source>
          <target state="translated">ネーミングの変更</target>
        </trans-unit>
        <trans-unit id="f736bf35e196e5f8a2152cf612783a7b401c2cad" translate="yes" xml:space="preserve">
          <source>Ne</source>
          <target state="translated">Ne</target>
        </trans-unit>
        <trans-unit id="28477357de69f5526193889fda40ed45cd101a03" translate="yes" xml:space="preserve">
          <source>Nearly all systems have the ability to call libraries written in C. This is not true of other implementation languages.</source>
          <target state="translated">ほぼすべてのシステムは C で書かれたライブラリを呼び出す機能を持っていますが、これは他の実装言語には当てはまりません。</target>
        </trans-unit>
        <trans-unit id="a37e5d1459b64bbf0f387b130668f0c8c4924e69" translate="yes" xml:space="preserve">
          <source>Negative numbers in the &quot;.width&quot; command cause right-alignment</source>
          <target state="translated">.width&quot; コマンドの負の数値は、右寄せの原因となります。</target>
        </trans-unit>
        <trans-unit id="fec37acea6ebcef8454c4fc958c0b8f34d2b8c80" translate="yes" xml:space="preserve">
          <source>Nested transactions using &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;, &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;, and &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;、&lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;、および&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO&lt;/a&gt;を使用したネストされたトランザクション</target>
        </trans-unit>
        <trans-unit id="9c791dcaae3666d9984fccf3b99d9aec11d78e88" translate="yes" xml:space="preserve">
          <source>Never despair of God's mercy.</source>
          <target state="translated">神の憐れみを絶望してはならない。</target>
        </trans-unit>
        <trans-unit id="cb1f0a8ca1cbcde19e25e6a553a1aa4154cf9c78" translate="yes" xml:space="preserve">
          <source>Nevertheless, application developers are admonished to monitor the state of the memory allocation subsystems and raise alarms when memory usage approaches or exceeds Robson limits. In this way, the application will provide operators with abundant warning well in advance of failure. The &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; interfaces of SQLite provide the application with all the mechanism necessary to complete the monitoring portion of this task.</source>
          <target state="translated">それにもかかわらず、アプリケーション開発者は、メモリ割り当てサブシステムの状態を監視し、メモリ使用量がロブソン制限に近づいたり超えたりしたときにアラームを発生させるように警告されています。このようにして、アプリケーションは、障害が発生する前に十分な警告をオペレーターに提供します。SQLite の&lt;a href=&quot;malloc#memstatus&quot;&gt;メモリ統計&lt;/a&gt;インターフェイスは、このタスクの監視部分を完了するために必要なすべてのメカニズムをアプリケーションに提供します。</target>
        </trans-unit>
        <trans-unit id="b14d2dd89e46e860f7449a61cc79bde67323500f" translate="yes" xml:space="preserve">
          <source>Nevertheless, bugs happen. If you are writing an application that sends untrusted SQL inputs or database files to SQLite, there are additional steps you can take to help reduce the attack surface and prevent zero-day exploits caused by undetected bugs.</source>
          <target state="translated">とはいえ、バグは発生します。信頼されていない SQL 入力やデータベースファイルを SQLite に送信するアプリケーションを書いている場合、攻撃対象を減らし、検出されなかったバグによるゼロデイエクスプロイトを防ぐための追加のステップがあります。</target>
        </trans-unit>
        <trans-unit id="fe8f48a38c1ee2d5e1ec0b569c50eb0f4be22e0d" translate="yes" xml:space="preserve">
          <source>Nevertheless, integer overflow in the computation of memory allocation sizes is a concern that SQLite would like to deal with. To prevent problems, all SQLite internal memory allocations occur using thin wrapper functions that take a signed 64-bit integer size parameter. The SQLite source code is audited to ensure that all size computations are carried out using 64-bit signed integers as well. SQLite will refuse to allocate more than about 2GB of memory at one go. (In common use, SQLite seldom ever allocates more than about 8KB of memory at a time so a 2GB allocation limit is not a burden.) So the 64-bit size parameter provides lots of headroom for detecting overflows. The same audit that verifies that all size computations are done as 64-bit signed integers also verifies that it is impossible to overflow a 64-bit integer during the computation.</source>
          <target state="translated">それにもかかわらず、メモリ割り当てサイズの計算における整数オーバーフローは、SQLiteが対処したい懸念事項です。問題を防ぐために、すべての SQLite 内部メモリ割り当ては、64 ビット符号付き整数のサイズパラメータを取るシンラッパー関数を使用して行われます。SQLite のソースコードは監査され、すべてのサイズ計算が 64 ビット符号付き整数を使用して行われていることを確認しています。SQLite は、一度に約 2GB を超えるメモリの割り当てを拒否します。(一般的な使用方法では、SQLite は一度に約 8KB 以上のメモリを割り当てることはめったにありませんので、2GB の割り当て制限は負担になりません)。そのため、64ビットのサイズパラメータはオーバーフローを検出するために多くの余裕を提供しています。すべてのサイズ計算が 64 ビット符号付き整数で行われていることを確認するのと同じ監査では、計算中に 64 ビット整数をオーバーフローさせることが不可能であることも確認されます。</target>
        </trans-unit>
        <trans-unit id="e49fc674e296beca34786edd4c2b299863546a78" translate="yes" xml:space="preserve">
          <source>Nevertheless, no software is 100% perfect. There have been a few historical bugs in SQLite (now fixed) that could cause database corruption. And there may be yet a few more that remain undiscovered. Because of the extensive testing and widespread use of SQLite, bugs that result in database corruption tend to be very obscure. The likelihood of an application encountering an SQLite bug is small. To illustrate this, an account is given below of all database-corruption bugs found in SQLite during the four-year period from 2009-04-01 to 2013-04-15. This account should give the reader an intuitive sense of the kinds of bugs in SQLite that manage to slip through testing procedures and make it into a release.</source>
          <target state="translated">とはいえ、どんなソフトウェアも100%完璧ではありません。SQLiteには、データベースの破損を引き起こす可能性のある歴史的なバグがいくつかありました(現在は修正されています)。また、まだ発見されていないバグがいくつかあるかもしれません。大規模なテストが行われ、SQLiteが広く使われているため、データベースの破損の原因となるバグは非常に目立たない傾向にあります。アプリケーションがSQLiteのバグに遭遇する可能性は低いのです。これを説明するために、2009-04-01 から 2013-04-15 までの 4 年間に SQLite で発見されたすべてのデータベース破損バグの説明を以下に示します。この説明は、SQLite のバグがテスト手順をすり抜けてリリースに至るまでにどのような種類のバグがあるのか、読者に直感的な感覚を与えてくれるはずです。</target>
        </trans-unit>
        <trans-unit id="0116882452ef2d4b8e1293a906b669874cb29ba7" translate="yes" xml:space="preserve">
          <source>New &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_...&lt;/a&gt; compile-time options added</source>
          <target state="translated">新しい&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _...&lt;/a&gt;コンパイル時オプションが追加されました</target>
        </trans-unit>
        <trans-unit id="75836f6f6b6f280ffed2e7c97c8de38d49f8b36b" translate="yes" xml:space="preserve">
          <source>New Change</source>
          <target state="translated">新しい変更点</target>
        </trans-unit>
        <trans-unit id="519eb3711af9fb8ce8d81cf7983b569f9b988fc0" translate="yes" xml:space="preserve">
          <source>New File Format</source>
          <target state="translated">新しいファイル形式</target>
        </trans-unit>
        <trans-unit id="05a025f4bcdcce620e0b66e603b7b96a2aa62567" translate="yes" xml:space="preserve">
          <source>New HH:MM:SS modifier to the built-in date/time functions.</source>
          <target state="translated">組み込みの日付/時刻関数に新しいHH:MM:SS修飾子を追加しました。</target>
        </trans-unit>
        <trans-unit id="35afb195f0b01edb4e7140e0f143cfa5913617eb" translate="yes" xml:space="preserve">
          <source>New VFSes are registered with sqlite3_vfs_register(). Each new VFS becomes the default VFS if the makeDflt flag is set. The same VFS can be registered multiple times without injury. To make an existing VFS into the default VFS, register it again with the makeDflt flag set. If two different VFSes with the same name are registered, the behavior is undefined. If a VFS is registered with a name that is NULL or an empty string, then the behavior is undefined.</source>
          <target state="translated">新しいVFSはsqlite3_vfs_register()で登録されます。各新規VFSは、makeDfltフラグが設定されていればデフォルトのVFSになります。同じVFSを複数回登録しても問題ありません。既存のVFSをデフォルトVFSにするには、makeDfltフラグをセットして再度登録します。同じ名前の異なるVFSが2つ登録されている場合の動作は未定義です。名前が NULL または空文字列の VFS が登録されている場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="9e6d8977d2335274bf96388fe98628d1d0b7e083" translate="yes" xml:space="preserve">
          <source>New applications should always invoke &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; instead of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;. The older &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; is retained for backwards compatibility. But &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; provides a much better interface.</source>
          <target state="translated">新しいアプリケーションでは、常に呼び出す必要があります&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;の代わりに、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepareは）（ &lt;/a&gt;。古い&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;は、下位互換性のために保持されています。しかし、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;ははるかに優れたインターフェースを提供します。</target>
        </trans-unit>
        <trans-unit id="741f30a581517ffe6e7dcd8b6f50643914279724" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">SQLiteの将来のリリースでは、新しい構成オプションが追加される可能性があります。既存の構成オプションは廃止される可能性があります。アプリケーションは、&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;からの戻りコードをチェックして、呼び出しが機能したことを確認する必要があります。&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;インターフェースは、非ゼロ返され&lt;a href=&quot;rescode&quot;&gt;たエラーコードを&lt;/a&gt;廃止またはサポートされていない構成オプションが呼び出された場合。</target>
        </trans-unit>
        <trans-unit id="dfd7ca29d835fc9c4dbb0540c0bcc6f89fdaa393" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">SQLiteの将来のリリースでは、新しい構成オプションが追加される可能性があります。既存の構成オプションは廃止される可能性があります。アプリケーションは&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;からの戻りコードをチェックして、呼び出しが機能したことを確認する必要があります。&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;インターフェースは、非ゼロ返され&lt;a href=&quot;rescode&quot;&gt;たエラーコードを&lt;/a&gt;廃止またはサポートされていない構成オプションが呼び出された場合。</target>
        </trans-unit>
        <trans-unit id="290c5a063c07711b910fa8250f0c45e5e6c8d5a9" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">SQLiteの将来のリリースでは、新しい構成オプションが追加される可能性があります。既存の構成オプションは廃止される可能性があります。アプリケーションは、&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;からの戻りコードをチェックして、呼び出しが機能したことを確認する必要があります。&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;インターフェースは、非ゼロ返され&lt;a href=&quot;../rescode&quot;&gt;たエラーコードを&lt;/a&gt;廃止またはサポートされていない構成オプションが呼び出された場合。</target>
        </trans-unit>
        <trans-unit id="bef0fe1db7b5b12623a7cb6dd11860448e032b3e" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">SQLiteの将来のリリースでは、新しい構成オプションが追加される可能性があります。既存の構成オプションは廃止される可能性があります。アプリケーションは&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;からの戻りコードをチェックして、呼び出しが機能したことを確認する必要があります。&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;インターフェースは、非ゼロ返され&lt;a href=&quot;../rescode&quot;&gt;たエラーコードを&lt;/a&gt;廃止またはサポートされていない構成オプションが呼び出された場合。</target>
        </trans-unit>
        <trans-unit id="b448decebb78010dbfebbde65087fb4a352a7ae8" translate="yes" xml:space="preserve">
          <source>New database files created by SQLite use format 4 by default. The &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt; can be used to cause SQLite to create new database files using format 1. The format version number can be made to default to 1 instead of 4 by setting &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt;=1 at compile-time.</source>
          <target state="translated">SQLiteによって作成された新しいデータベースファイルは、デフォルトでフォーマット4を使用します。&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_formatプラグマは、&lt;/a&gt;設定することで、フォーマットのバージョン番号は1ではなく4にデフォルトにすることができる形式1を使用して、新しいデータベースファイルを作成するためのSQLiteを引き起こすために使用することができます&lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt;コンパイル時に= 1を。</target>
        </trans-unit>
        <trans-unit id="7fae2a2a8fa480fb532533df6e47c596e4029933" translate="yes" xml:space="preserve">
          <source>New error codes may be added in future versions of SQLite.</source>
          <target state="translated">SQLite の将来のバージョンでは、新しいエラーコードが追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="02a2eef012a8248fed2ec4a5f4418e441dee6267" translate="yes" xml:space="preserve">
          <source>New extensions:</source>
          <target state="translated">新しいエクステンションです。</target>
        </trans-unit>
        <trans-unit id="c375e60e4ec3e7a7421f6f6fc9277a408ea2286e" translate="yes" xml:space="preserve">
          <source>New file format that is 25% to 35% smaller for typical use.</source>
          <target state="translated">一般的な使用のために25%から35%縮小された新しいファイル形式。</target>
        </trans-unit>
        <trans-unit id="fd04fa0f053215d42b7f8b539b38e361266bd4c9" translate="yes" xml:space="preserve">
          <source>New flags may be added in future releases of SQLite.</source>
          <target state="translated">SQLite の将来のリリースでは、新しいフラグが追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="609f25b82bb11b34abf866257917b5188d15ee70" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt; that returns the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; handle that has invoked an application-defined SQL function.</source>
          <target state="translated">アプリケーション定義のSQL関数を呼び出した&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;ハンドルを返す新しいインターフェース&lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="97e454a0ee0ddbdb1207081ac8f340c9145f813d" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; allows size and length limits to be set on a per-connection basis and at run-time.</source>
          <target state="translated">新しいインターフェース&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）を&lt;/a&gt;使用すると、サイズと長さの制限を接続ごとおよび実行時に設定できます。</target>
        </trans-unit>
        <trans-unit id="351a6ce815b5dd18ffcf850d512cce2a33e3cd28" translate="yes" xml:space="preserve">
          <source>New interface: sqlite3_bind_parameter_index()</source>
          <target state="translated">新しいインタフェース:sqlite3_bind_parameter_index()</target>
        </trans-unit>
        <trans-unit id="ff421fae0557a39a0bd809f33195e163ee4bb7ae" translate="yes" xml:space="preserve">
          <source>New interfaces added to the test_quota.c add-on module.</source>
          <target state="translated">test_quota.c アドオンモジュールに新しいインターフェースが追加されました。</target>
        </trans-unit>
        <trans-unit id="ae3613412d28080958e2d37e217b087b523b9aae" translate="yes" xml:space="preserve">
          <source>New internal schema objects names, always beginning with &quot;sqlite_&quot;, may be added to the SQLite file format in future releases.</source>
          <target state="translated">常に &quot;sqlite_&quot;で始まる新しい内部スキーマオブジェクト名は、将来のリリースでSQLiteファイルフォーマットに追加されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="26bcef71ccfa90b2e0cbb123ce577eb05e69bad7" translate="yes" xml:space="preserve">
          <source>New memory allocators do not have to be part of the SQLite source tree nor included in the sqlite3.c &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. Individual applications can supply their own memory allocators to SQLite at start-time.</source>
          <target state="translated">新しいメモリアロケータは、SQLiteのソースツリーの一部である必要はありもsqlite3.cには含まれません&lt;a href=&quot;amalgamation&quot;&gt;合併&lt;/a&gt;。個々のアプリケーションは、起動時にSQLiteに独自のメモリアロケータを提供できます。</target>
        </trans-unit>
        <trans-unit id="5e4800161f51168ad45c54c49952a916eb4c7f5a" translate="yes" xml:space="preserve">
          <source>New options to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; for configuring auxiliary memory usage: --pagecache, --lookaside, and --scratch.</source>
          <target state="translated">補助メモリの使用を構成するための&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルの&lt;/a&gt;新しいオプション：--pagecache、-lookaside、および--scratch。</target>
        </trans-unit>
        <trans-unit id="33b435c4ed8f9927e4700fe7e7aeadeae900e749" translate="yes" xml:space="preserve">
          <source>New query optimizations:</source>
          <target state="translated">新しいクエリの最適化。</target>
        </trans-unit>
        <trans-unit id="27a96e272ba4064e97b901622de6fb30f7bc2a07" translate="yes" xml:space="preserve">
          <source>New run-time limit categories may be added in future releases.</source>
          <target state="translated">今後のリリースでは、新しいランタイムリミットカテゴリが追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="aa7ba8a90d79e3949a9a92f1f6dd6361b3924b13" translate="yes" xml:space="preserve">
          <source>New status parameters may be added from time to time.</source>
          <target state="translated">新しいステータスパラメータは随時追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="8001d5465bcc215e617045ec61b342b4c0fbe511" translate="yes" xml:space="preserve">
          <source>New tests added to the test suite.</source>
          <target state="translated">テストスイートに新しいテストが追加されました。</target>
        </trans-unit>
        <trans-unit id="19df796618ecb880621a1ff2386886f64457fe9e" translate="yes" xml:space="preserve">
          <source>New text tokens may be added to the end of the stat column in future enhancements to SQLite. For compatibility, unrecognized tokens at the end of the stat column are silently ignored.</source>
          <target state="translated">SQLite の将来の拡張機能では、stat 列の末尾に新しいテキストトークンが追加される可能性があります。互換性のために、 stat カラムの最後にある認識されていないトークンは静かに無視されます。</target>
        </trans-unit>
        <trans-unit id="d23050a62d4b2ebb32c827e3e8678911cb996090" translate="yes" xml:space="preserve">
          <source>New tracing constants may be added in future releases.</source>
          <target state="translated">今後のリリースでは、新しいトレース定数が追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="8ec81cf9bf3ff78a39346bf7439447032b8bc32c" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">SQLiteの将来のリリースでは、新しい動詞が追加される可能性があります。既存の動詞は廃止される可能性があります。アプリケーションは&lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;からの戻りコードをチェックして、呼び出しが機能したことを確認する必要があります。&lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;廃止またはサポートされていない動詞が呼び出された場合のインターフェースは、非ゼロのエラーコードを返します。</target>
        </trans-unit>
        <trans-unit id="6997236519e17b29acb8e0c21015208012814bff" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">SQLiteの将来のリリースでは、新しい動詞が追加される可能性があります。既存の動詞は廃止される可能性があります。アプリケーションは&lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;からの戻りコードをチェックして、呼び出しが機能したことを確認する必要があります。&lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;廃止またはサポートされていない動詞が呼び出された場合のインターフェースは、非ゼロのエラーコードを返します。</target>
        </trans-unit>
        <trans-unit id="b162b6ee72989cc021180a9aa2d3a7a0e2b57826" translate="yes" xml:space="preserve">
          <source>New zip archives may be constructed entirely within memory using the zipfile() aggregate function. Each row visited by the aggregate function adds an entry to the zip archive. The value returned is a blob containing the entire archive image.</source>
          <target state="translated">新しい zip アーカイブは、zipfile()集約関数を使用してメモリ内で完全に構築することができます。集計関数が訪れる各行は、ZIP アーカイブへのエントリを追加します。返される値は、アーカイブ画像全体を含む blob となります。</target>
        </trans-unit>
        <trans-unit id="e327377c14f6ddd81b93544df605d7203e2995e8" translate="yes" xml:space="preserve">
          <source>NewRowid</source>
          <target state="translated">NewRowid</target>
        </trans-unit>
        <trans-unit id="6975bed1eebd03a852e5aa6a11d0f144cd34ff6e" translate="yes" xml:space="preserve">
          <source>Newer disk drives have begun using 4096 byte sectors however. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16), the SQLite development team experimented with changes xSectorSize to report 4096 bytes as the blast radius. This had the effect of increasing write overhead on many databases. For a database with a &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; of 1024 (a very common choice) making a change to a single page in the database now requires SQLite to backup three other adjacent pages to the rollback journal, whereas formerly it only had to backup the one page that was changing. In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, each transaction had to be padded out to the next 4096-byte boundary in the WAL file, rather than the next 512-byte boundary, resulting in thousands of extra bytes being written per transaction.</source>
          <target state="translated">新しいディスクドライブは、4096バイトのセクターを使用し始めました。 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;バージョン3.7.10&lt;/a&gt;（2012-01-16）以降、SQLite開発チームはxSectorSizeを変更して実験を行い、爆風半径として4096バイトを報告しました。これにより、多くのデータベースで書き込みオーバーヘッドが増加するという影響がありました。データベースのための&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;プラグマPAGE_SIZE&lt;/a&gt;以前はそれが唯一のバックアップに1つのページを持っていたのに対し、データベース内の1つのページへの変更を行う1024（非常に一般的な選択肢は）今、ロールバック・ジャーナルへのバックアップ3つの、隣接する他のページへのSQLiteが必要です変わりました。では&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;、各トランザクションは、トランザクションごとに書き込まれている余分なバイト数千の結果として、WALファイルではなく、次の512バイト境界で次の4096バイト境界にパディングされなければなりませんでした。</target>
        </trans-unit>
        <trans-unit id="bc981983e7f547dc62e19a1e383acfe00782a6d5" translate="yes" xml:space="preserve">
          <source>Next</source>
          <target state="translated">Next</target>
        </trans-unit>
        <trans-unit id="bc1189b8a3e7e2b908b403ea79a8eb14b14bcd47" translate="yes" xml:space="preserve">
          <source>Next, make copies of all the blobs into individual files in a directory using a command like this:</source>
          <target state="translated">次に、以下のようなコマンドを使って、すべての blob のコピーをディレクトリ内の個々のファイルに作成します。</target>
        </trans-unit>
        <trans-unit id="73f7cfb7746314674a12b8d200b36135947e050b" translate="yes" xml:space="preserve">
          <source>Next, move the resulting kvtest-android executable to the Android device:</source>
          <target state="translated">次に、出来上がったkvtest-android実行ファイルをAndroidデバイスに移動します。</target>
        </trans-unit>
        <trans-unit id="21d2b394790e7b47b83f7c9d1daa6c55ee3c0c16" translate="yes" xml:space="preserve">
          <source>Next, suppose that you want to look up the price of not just any orange, but specifically California-grown oranges. The appropriate query would be as follows:</source>
          <target state="translated">次に、どんなオレンジでも良いのではなく、カリフォルニア産のオレンジの価格を調べたいとします。適切なクエリは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="dad2991d263e4aa51578f91e92e9777428d9762b" translate="yes" xml:space="preserve">
          <source>No (Note 1)</source>
          <target state="translated">いいえ(注1)</target>
        </trans-unit>
        <trans-unit id="b4f66722cbcf69861e819a02ca8d6803b779fcd3" translate="yes" xml:space="preserve">
          <source>No Isolation Between Operations On The Same Database Connection</source>
          <target state="translated">同じデータベース接続上での操作間の分離ができない</target>
        </trans-unit>
        <trans-unit id="8dae863821cb04b5484c9a0e7717d726d350b9bd" translate="yes" xml:space="preserve">
          <source>No application file I/O code to write and debug.</source>
          <target state="translated">アプリケーションファイルのI/Oコードを書き込んでデバッグすることはできません。</target>
        </trans-unit>
        <trans-unit id="95ec05297c8cafc96feb998f4af109f4728d5530" translate="yes" xml:space="preserve">
          <source>No change</source>
          <target state="translated">変更なし</target>
        </trans-unit>
        <trans-unit id="7f2ff41fbbf4963dea6c3e81c6aa743e95c596b5" translate="yes" xml:space="preserve">
          <source>No current or conflicting row information is provided. The only function it is possible to call on the supplied sqlite3_changeset_iter handle is sqlite3changeset_fk_conflicts().</source>
          <target state="translated">現在の行情報や競合する行情報は提供されません。与えられたsqlite3_changeset_iterハンドルで呼び出すことができる唯一の関数はsqlite3changeset_fk_conflicts()です。</target>
        </trans-unit>
        <trans-unit id="7c5c383086cc31c41ab2122a84d0a48706ccfc11" translate="yes" xml:space="preserve">
          <source>No error is raised if a width or precision exceeds SQLITE_PRINTF_PRECISION_LIMIT. Instead, the large width or precision is silently truncated.</source>
          <target state="translated">幅または精度が SQLITE_PRINTF_PRECISION_LIMIT を超えてもエラーは発生しません。その代わり、大きな幅または精度は静かに切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="662adfcee595804e0d0a40f3427892366f101024" translate="yes" xml:space="preserve">
          <source>No error messages are generated if an unknown pragma is issued. Unknown pragmas are simply ignored. This means if there is a typo in a pragma statement the library does not inform the user of the fact.</source>
          <target state="translated">不明なプラグマが発行されてもエラーメッセージは生成されません。未知のプラグマは単に無視されます。これは、プラグマ文の中にタイプミスがあっても、ライブラリがその事実をユーザに知らせないことを意味します。</target>
        </trans-unit>
        <trans-unit id="36386488a9bfa58ff6f23801ec174053b73ed777" translate="yes" xml:space="preserve">
          <source>No locking style. If none of the above can be supported, this locking style is used. No database locking mechanism is used. When this system is used it is not safe for a single database to be accessed by multiple clients.</source>
          <target state="translated">ロックスタイルはありません。上記のいずれにも対応できない場合は、このロックスタイルが使用されます。データベースのロック機構を使用しない。このシステムを使用する場合、単一のデータベースが複数のクライアントからアクセスされることは安全ではありません。</target>
        </trans-unit>
        <trans-unit id="7b15426333f8adb77f306aae95c84b204b379d14" translate="yes" xml:space="preserve">
          <source>No locks are held on the database. The database may be neither read nor written. Any internally cached data is considered suspect and subject to verification against the database file before being used. Other processes can read or write the database as their own locking states permit. This is the default state.</source>
          <target state="translated">データベースにはロックはありません。データベースは読み書きできません。内部的にキャッシュされたデータはすべて疑わしいものとみなされ、使用する前にデータベースファイルとの照合が必要です。他のプロセスは、それぞれのロック状態が許す限り、データベースを読み書きすることができます。これがデフォルトの状態です。</target>
        </trans-unit>
        <trans-unit id="589cdf57b87436c5bbc074aa5e48b70f3f3363e1" translate="yes" xml:space="preserve">
          <source>No longer in use.</source>
          <target state="translated">使わなくなった。</target>
        </trans-unit>
        <trans-unit id="7375825a734eee4acde64dd3de9ae4b6f89db26c" translate="yes" xml:space="preserve">
          <source>No longer used.</source>
          <target state="translated">使わなくなりました。</target>
        </trans-unit>
        <trans-unit id="1cff8c4990053d03c141cc08cc6f740585898fb6" translate="yes" xml:space="preserve">
          <source>No one is required to follow The Rule, to know The Rule, or even to think that The Rule is a good idea. The Founder of SQLite believes that anyone who follows The Rule will live a happier and more productive life, but individuals are free to dispute or ignore that advice if they wish.</source>
          <target state="translated">誰もThe Ruleに従う必要はありませんし、The Ruleを知っている必要もありませんし、The Ruleが良い考えであると考える必要もありません。SQLiteの創設者は、The Ruleに従う人は誰でもより幸せで生産的な人生を送ることができると信じていますが、そのアドバイスに異議を唱えたり、無視したりするのは個人の自由です。</target>
        </trans-unit>
        <trans-unit id="a4226fa0e8cf6311cf2613fee3e52c99bd81b607" translate="yes" xml:space="preserve">
          <source>No other processes can change the database so there is never a need to check the change counter and clear the user-space cache at the beginning of a transaction.</source>
          <target state="translated">他のプロセスがデータベースを変更することはないので、トランザクションの最初に変更カウンタをチェックしてユーザースペースのキャッシュをクリアする必要はありません。</target>
        </trans-unit>
        <trans-unit id="6b5b494aee4d1b7c43eaf07044f46f3778af61cd" translate="yes" xml:space="preserve">
          <source>No other writes may occur on the target database while the RBU update is being applied. A read-lock is held on the target database to prevent this.</source>
          <target state="translated">RBU更新が適用されている間は、ターゲット・データベースに他の書き込みが発生することはありません。これを防ぐために、ターゲット・データベースではリード・ロックが保持されています。</target>
        </trans-unit>
        <trans-unit id="3943b575617ba52cb8729616c676b13dc34b8e79" translate="yes" xml:space="preserve">
          <source>No reads or writes occur except within a transaction. Any command that accesses the database (basically, any SQL command, except a few &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements) will automatically start a transaction if one is not already in effect. Automatically started transactions are committed when the last SQL statement finishes.</source>
          <target state="translated">トランザクション内を除き、読み取りまたは書き込みは発生しません。データベースにアクセスするコマンド（基本的には、いくつかの&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;ステートメントを除くすべてのSQLコマンド）は、トランザクションがまだ有効になっていない場合、自動的にトランザクションを開始します。自動的に開始されたトランザクションは、最後のSQLステートメントが完了するとコミットされます。</target>
        </trans-unit>
        <trans-unit id="2a9bc5ebe3cc4eba5a484c518ae347f8a47ccd50" translate="yes" xml:space="preserve">
          <source>No table in a union-vtab may contain entries that are outside of the rowid bounds established by the</source>
          <target state="translated">union-vtab内のどのテーブルにも</target>
        </trans-unit>
        <trans-unit id="7d5b25b567984a7a4091e940273bfff96cd2fed3" translate="yes" xml:space="preserve">
          <source>No. When you delete information from an SQLite database, the unused disk space is added to an internal &quot;free-list&quot; and is reused the next time you insert data. The disk space is not lost. But neither is it returned to the operating system.</source>
          <target state="translated">SQLite データベースから情報を削除すると、未使用のディスク領域は内部の「フリーリスト」に追加され、次にデータを挿入するときに再利用されます。ディスク領域が失われることはありません。しかし、それがオペレーティングシステムに戻されることはありません。</target>
        </trans-unit>
        <trans-unit id="d4e9f5ef9057ec35a6f3d638ab0a7b961dadfa79" translate="yes" xml:space="preserve">
          <source>NoConflict</source>
          <target state="translated">NoConflict</target>
        </trans-unit>
        <trans-unit id="66290ce3e3466df1560e431a1eebe9e205ef9f1e" translate="yes" xml:space="preserve">
          <source>Non-ASCII range characters (i.e. unicode codepoints greater than 127), or</source>
          <target state="translated">非ASCII範囲文字(すなわち127より大きいユニコードコードコードポイント)、または</target>
        </trans-unit>
        <trans-unit id="1bc1387523b6d25784112f80a2990511e6a57420" translate="yes" xml:space="preserve">
          <source>Non-Vista Windows platforms only support one set of DST rules. Vista only supports two. Therefore, on these platforms, historical DST calculations will be incorrect. For example, in the US, in 2007 the DST rules changed. Non-Vista Windows platforms apply the new 2007 DST rules to all previous years as well. Vista does somewhat better getting results correct back to 1986, when the rules were also changed.</source>
          <target state="translated">Vista 以外の Windows プラットフォームでは、DST ルールは 1 つのセットしかサポートしていません。Vistaでは2つのルールしかサポートしていません。そのため、これらのプラットフォームでは、過去のDSTの計算は正しくありません。たとえば、米国では2007年にDSTルールが変更されました。Vista以外のWindowsプラットフォームでは、2007年の新しいDSTルールがそれ以前のすべての年にも適用されます。Vistaでは、規則が変更された1986年まで遡って正しい結果が得られるようになります。</target>
        </trans-unit>
        <trans-unit id="b1b833538f0549b7c8aca0acf47c1aa5ac7f2fac" translate="yes" xml:space="preserve">
          <source>Non-deterministic functions might give different answers on each invocation, even if the arguments are always the same. The following are examples of non-deterministic functions:</source>
          <target state="translated">非決定論的関数は、引数が常に同じであっても、呼び出しごとに異なる答えを与える可能性があります。以下に非決定論的関数の例を示します。</target>
        </trans-unit>
        <trans-unit id="cf3ad9f318d5d17809c32f85aa54a78cb4cda991" translate="yes" xml:space="preserve">
          <source>Non-streaming equivalent</source>
          <target state="translated">ノンストリーミング相当</target>
        </trans-unit>
        <trans-unit id="1d0d5248c3c8dbbb61313817bba98f17697e01b6" translate="yes" xml:space="preserve">
          <source>Non-streaming functions that accept changesets (or patchsets) as input require that the entire changeset be stored in a single buffer in memory. Similarly, those that return a changeset or patchset do so by returning a pointer to a single large buffer allocated using sqlite3_malloc(). Normally this is convenient. However, if an application running in a low-memory environment is required to handle very large changesets, the large contiguous memory allocations required can become onerous.</source>
          <target state="translated">チェンジセット(またはパッチセット)を入力として受け取る非ストリーミング関数は、チェンジセット全体をメモリ内の単一のバッファに格納する必要があります。同様に、チェンジセットやパッチセットを返す関数は、sqlite3_malloc()を使って確保された単一の大きなバッファへのポインタを返します。通常はこれが便利です。しかし、低メモリ環境で動作するアプリケーションが非常に大きなチェンジセットを扱う必要がある場合、必要とされる大きな連続したメモリの割り当ては負担になります。</target>
        </trans-unit>
        <trans-unit id="09f7070838a5d668002d389cd9b3fec752e6c30d" translate="yes" xml:space="preserve">
          <source>None of the safe programming languages existed for the first 10 years of SQLite's existence. SQLite could be recoded in Go or Rust, but doing so would probably introduce far more bugs than would be fixed, and it seems also likely to result in slower code.</source>
          <target state="translated">SQLite が存在していた最初の 10 年間は、安全なプログラミング言語は存在しませんでした。SQLiteはGoやRustで再コード化することができますが、そうすることで修正されるよりもはるかに多くのバグが発生し、コードが遅くなる可能性が高いようです。</target>
        </trans-unit>
        <trans-unit id="9b9f34e057f76ac2b419477d464548015d8ef844" translate="yes" xml:space="preserve">
          <source>None of the xSavepoint(), xRelease(), or xRollbackTo() methods will ever be called except in between calls to xBegin() and either xCommit() or xRollback().</source>
          <target state="translated">xSavepoint()、xRelease()、または xRollbackTo()メソッドは、xBegin()と xCommit()または xRollback()のいずれかを呼び出す間を除いて、いずれも呼び出されることはありません。</target>
        </trans-unit>
        <trans-unit id="a1fe0caa1d6e9f3e9dd7087ae4f2a9ea810cd170" translate="yes" xml:space="preserve">
          <source>Noop</source>
          <target state="translated">Noop</target>
        </trans-unit>
        <trans-unit id="2bbfb9d52741dbc3a4ff03abc70ca82cb8e2f1bc" translate="yes" xml:space="preserve">
          <source>Normal functions specify only xFunc and leave xStep and xFinal set to NULL. Aggregate functions specify xStep and xFinal and leave xFunc set to NULL. There is no separate sqlite3_create_aggregate() API.</source>
          <target state="translated">通常の関数はxFuncのみを指定し、xStepとxFinalをNULLにします。集約関数はxStepとxFinalを指定し、xFuncをNULLにします。sqlite3_create_aggregate()APIは別途ありません。</target>
        </trans-unit>
        <trans-unit id="8feff5d8988d2d3b3f82fe7920cdb81d5ba04e3a" translate="yes" xml:space="preserve">
          <source>Normal meaning</source>
          <target state="translated">通常の意味</target>
        </trans-unit>
        <trans-unit id="e304219719d389c0ea46b9c98590f2134fb67330" translate="yes" xml:space="preserve">
          <source>Normally, FTS5 maintains a special backing table within the database that stores the size of each column value in tokens inserted into the main FTS5 table in a separate table. This backing table is used by the &lt;a href=&quot;#xColumnSize&quot;&gt;xColumnSize&lt;/a&gt;&lt;a&gt; API function, which is in turn used by the built-in &lt;/a&gt;&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25 ranking function&lt;/a&gt; (and is likely to be useful to other ranking functions as well).</source>
          <target state="translated">通常、FTS5は、メインのFTS5テーブルに挿入されたトークンの各列の値のサイズを別のテーブルに格納する特別なバッキングテーブルをデータベース内に保持します。このバッキングテーブルは、&lt;a href=&quot;#xColumnSize&quot;&gt;xColumnSize &lt;/a&gt;&lt;a&gt;API関数&lt;/a&gt;によって使用されます。これは、組み込みの&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25ランキング関数&lt;/a&gt;によって使用されます（他のランキング関数にも役立つ可能性があります）。</target>
        </trans-unit>
        <trans-unit id="866b49d7e3deb743a545b4433375afa6debe3327" translate="yes" xml:space="preserve">
          <source>Normally, NULL SQL results are stored in the array using the &lt;a href=&quot;#nullvalue&quot;&gt;nullvalue&lt;/a&gt; setting. However, if the &lt;b&gt;-withoutnulls&lt;/b&gt; option is used, then NULL SQL values cause the corresponding array element to be unset instead.</source>
          <target state="translated">通常、NULL SQL結果は&lt;a href=&quot;#nullvalue&quot;&gt;nullvalue&lt;/a&gt;設定を使用して配列に格納されます。ただし、&lt;b&gt;-withoutnulls&lt;/b&gt;オプションを使用すると、NULL SQL値により、対応する配列要素が設定解除されます。</target>
        </trans-unit>
        <trans-unit id="d1f5712d735a4022fc9c1482cc2c46055815935d" translate="yes" xml:space="preserve">
          <source>Normally, SQLite assumes that if a power failure occurs while updating any portion of a sector then the contents of the entire device sector is suspect following recovery. After writing to any part of a sector within a file, it is assumed that the modified sector contents are held in a volatile buffer somewhere within the system (main memory, disk cache etc.). SQLite does not assume that the updated data has reached the persistent storage media, until after it has successfully</source>
          <target state="translated">通常、SQLite は、セクタの一部を更新している間に停電が発生した場合、復旧後のデバイスセクタ全体の内容が疑われると想定しています。ファイル内のセクタの任意の部分に書き込みを行った後、変更されたセクタの内容はシステム内のどこか(メインメモリ、ディスクキャッシュなど)の揮発性バッファに保持されていると想定されます。SQLite は、更新されたデータが永続的なストレージメディアに到達したとは考えていません。</target>
        </trans-unit>
        <trans-unit id="e5b528fefcff05064efc30021e7a7579eaaad4d2" translate="yes" xml:space="preserve">
          <source>Normally, a token or token prefix query is matched against the FTS table column specified as the left-hand side of the MATCH operator. Or, if the special column with the same name as the FTS table itself is specified, against all columns. This may be overridden by specifying a column-name followed by a &quot;:&quot; character before a basic term query. There may be space between the &quot;:&quot; and the term to query for, but not between the column-name and the &quot;:&quot; character. For example:</source>
          <target state="translated">通常、トークンまたはトークンプレフィックスクエリは、MATCH演算子の左側に指定されたFTSテーブルのカラムに対してマッチされます。あるいは、FTS テーブル自体と同じ名前の特別なカラムが指定されている場合は、すべてのカラムに対してマッチされます。これは、基本的な用語クエリの前にカラム名の後に&quot;:&quot;文字を指定することで上書きすることができます。カラム名と&quot;:&quot;文字の間にはスペースがあってもよいが、カラム名と&quot;:&quot;文字の間にはスペースはない。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="bf4491e66772ed8b491e6908438d7924fa774545" translate="yes" xml:space="preserve">
          <source>Normally, an SQL index references columns of a table. But an index can also be formed on expressions involving table columns.</source>
          <target state="translated">通常、SQLインデックスはテーブルのカラムを参照します。しかし、インデックスはテーブルのカラムを含む式にも形成することができます。</target>
        </trans-unit>
        <trans-unit id="39e8cea13d3d48550994e6ce4ac623d3130ee592" translate="yes" xml:space="preserve">
          <source>Normally, fossil will modify all the files in your checkout when switching between the private and the public branches. But at this point, the files are identical in both branches so not modifications need to be made.</source>
          <target state="translated">通常、プライベートブランチとパブリックブランチを切り替えると、fossilはチェックアウト内のすべてのファイルを修正します。しかし、この時点ではどちらのブランチでもファイルは同じなので、修正の必要はありません。</target>
        </trans-unit>
        <trans-unit id="d3d92a3c721eaacd534b06f545203c90c257b9b9" translate="yes" xml:space="preserve">
          <source>Normally, full-text queries are case-insensitive. However, this is dependent on the specific &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt; used by the FTS table being queried. Refer to the section on &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizers&lt;/a&gt; for details.</source>
          <target state="translated">通常、フルテキストクエリでは大文字と小文字が区別されません。ただし、これは、照会されるFTSテーブルが使用する特定の&lt;a href=&quot;fts3#tokenizer&quot;&gt;トークナイザーに&lt;/a&gt;依存します。詳細については、&lt;a href=&quot;fts3#tokenizer&quot;&gt;トークナイザー&lt;/a&gt;のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="63e53b72fdcc0af9b1c300c26469b45178a485e4" translate="yes" xml:space="preserve">
          <source>Normally, the FTS module maintains an inverted index of all terms in all columns of the table. This option is used to specify the name of a column for which entries should not be added to the index. Multiple &quot;notindexed&quot; options may be used to specify that multiple columns should be omitted from the index. For example:</source>
          <target state="translated">通常、FTSモジュールは、テーブルのすべての列のすべての用語の転置インデックスを保持する。このオプションは、インデックスにエントリを追加してはならない列の名前を指定するために使用される。複数の &quot;notindexed &quot;オプションを使用して、複数の列をインデックスから除外することを指定することができる。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="ebe2262110ee72155bb934332e4fc5587e66a440" translate="yes" xml:space="preserve">
          <source>Normally, the database &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and whether or not the database supports &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; must be configured before the database file is actually created. However, when not in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; properties of an existing database may be changed by using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;pragma auto_vacuum&lt;/a&gt; pragmas and then immediately VACUUMing the database. When in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, only the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; support property can be changed using VACUUM.</source>
          <target state="translated">通常、データベース&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PAGE_SIZE&lt;/a&gt;とデータベースがサポートするかどうか&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuumは、&lt;/a&gt;データベースファイルが実際に作成される前に設定する必要があります。しかし、ないときに&lt;a href=&quot;wal&quot;&gt;先行書き込みログ&lt;/a&gt;モード、&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PAGE_SIZE&lt;/a&gt;及び/又は&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuumの&lt;/a&gt;既存のデータベースの特性は、使用して変更することができる&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PAGE_SIZE&lt;/a&gt;および/または&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;プラグマauto_vacuum&lt;/a&gt;プラグマと直ちにデータベースを掃除します。すると&lt;a href=&quot;wal&quot;&gt;、先行書き込みログ&lt;/a&gt;モードのみ&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuumの&lt;/a&gt;サポートプロパティは、VACUUMを使用して変更することができます。</target>
        </trans-unit>
        <trans-unit id="5df62864e283fb4361bad80921bbac8b7ec57013" translate="yes" xml:space="preserve">
          <source>Normally, when SQLite writes to a database file, it waits until the write operation is finished before returning control to the calling application. Since writing to the file-system is usually very slow compared with CPU bound operations, this can be a performance bottleneck. The asynchronous I/O backend is an extension that causes SQLite to perform all write requests using a separate thread running in the background. Although this does not reduce the overall system resources (CPU, disk bandwidth etc.), it does allow SQLite to return control to the caller quickly even when writing to the database.</source>
          <target state="translated">通常、SQLite がデータベースファイルに書き込む際には、書き込み操作が終了するまで待ってから呼び出し元のアプリケーションに制御を返します。ファイルシステムへの書き込みは通常、CPUに依存した操作に比べて非常に遅いため、これがパフォーマンスのボトルネックになることがあります。非同期I/Oバックエンドは、SQLiteがバックグラウンドで実行している別のスレッドを使ってすべての書き込み要求を実行するようにする拡張機能です。これはシステム全体のリソース(CPUやディスクの帯域幅など)を削減するものではありませんが、データベースへの書き込み中でもSQLiteが呼び出し元に制御を迅速に返すことができるようになります。</target>
        </trans-unit>
        <trans-unit id="b810f7b8c9c4b12cca67db5205f27d6d0477e848" translate="yes" xml:space="preserve">
          <source>Normally, when a row is inserted into an FTS5 table, as well as the various full-text index entries and other data a copy of the row is stored in a private table managed by the FTS5 module. When column values are requested from the FTS5 table by the user or by an auxiliary function implementation, they are read from this private table. The &quot;content&quot; option may be used to create an FTS5 table that stores only FTS full-text index entries. Because the column values themselves are usually much larger than the associated full-text index entries, this can save significant database space.</source>
          <target state="translated">通常、行がFTS5テーブルに挿入されると、様々なフルテキストインデックスエントリやその他のデータと同様に、その行のコピーがFTS5モジュールによって管理されるプライベートテーブルに格納されます。ユーザ又は補助関数の実装によってFTS5テーブルから列の値が要求されると、このプライベートテーブルから読み出される。content」オプションは、FTSフルテキストインデックスエントリのみを格納するFTS5テーブルを作成するために使用することができる。列の値自体は、通常、関連するフルテキストインデックス項目よりもはるかに大きいので、これはデータベースのスペースを大幅に節約することができる。</target>
        </trans-unit>
        <trans-unit id="ca1dd39379254ab3f3c73dbffb0d03d628b27d20" translate="yes" xml:space="preserve">
          <source>Not</source>
          <target state="translated">Not</target>
        </trans-unit>
        <trans-unit id="5927a7e485b2adcf5a36cf65c4801a2eed120fcc" translate="yes" xml:space="preserve">
          <source>Not all applications meet these conditions. Fortunately, the NGQP will still usually find good query plans, even without these conditions. However, cases do arise (rarely) where performance regressions can occur.</source>
          <target state="translated">すべてのアプリケーションがこれらの条件を満たすわけではありません。幸いなことに、これらの条件を満たしていなくても、NGQPは通常、良い問い合わせプランを見つけます。しかし、パフォーマンスの低下が発生する場合もあります(まれにですが)。</target>
        </trans-unit>
        <trans-unit id="6938024f626f02a7276620a318f6367169f62576" translate="yes" xml:space="preserve">
          <source>Not all test cases can be handled this way. Some test cases check to verify that the optimizations really are reducing the amount of computation by counting the number of disk accesses, sort operations, full-scan steps, or other processing steps that occur during queries. Those test cases will appear to fail when optimizations are disabled. But the majority of test cases simply check that the correct answer was obtained, and all of those cases can be run successfully with and without the optimizations, in order to show that the optimizations do not cause malfunctions.</source>
          <target state="translated">すべてのテストケースがこの方法で処理できるわけではありません。一部のテストケースでは、ディスクアクセス数、ソート操作、フルスキャンステップ、またはクエリ中に発生するその他の処理ステップをカウントすることで、最適化によって本当に計算量が削減されているかどうかを確認します。これらのテストケースは、最適化が無効になっている場合には失敗するように見えます。しかし、テストケースの大部分は単に正しい答えが得られたかどうかをチェックするだけで、最適化の有無にかかわらずすべてのケースを正常に実行して、最適化が誤動作を引き起こさないことを示します。</target>
        </trans-unit>
        <trans-unit id="593dbd15d49368a738585302a9107baf925136df" translate="yes" xml:space="preserve">
          <source>Not shown in the example above is that there are also &lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;various options&lt;/a&gt; that may be provided to FTS5 as part of the CREATE VIRTUAL TABLE statement to configure various aspects of the new table. These may be used to modify the way in which the FTS5 table extracts terms from documents and queries, to create extra indexes on disk to speed up prefix queries, or to create an FTS5 table that acts as an index on content stored elsewhere.</source>
          <target state="translated">上記の例には示されていませんが、新しいテーブルのさまざまな側面を構成するために、CREATE VIRTUAL TABLEステートメントの一部としてFTS5に提供できる&lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;さまざまなオプション&lt;/a&gt;もあります。これらを使用して、FTS5テーブルがドキュメントとクエリから用語を抽出する方法を変更したり、ディスクに追加のインデックスを作成してプレフィックスクエリを高速化したり、他の場所に格納されているコンテンツのインデックスとして機能するFTS5テーブルを作成したりできます。</target>
        </trans-unit>
        <trans-unit id="edbfab21e07e4e0dbe02fb875980c40bdd52ad0f" translate="yes" xml:space="preserve">
          <source>NotExists</source>
          <target state="translated">NotExists</target>
        </trans-unit>
        <trans-unit id="6f05e7cc9203f83829c08dcc46fafe9db426763f" translate="yes" xml:space="preserve">
          <source>NotFound</source>
          <target state="translated">NotFound</target>
        </trans-unit>
        <trans-unit id="85c73c74f4b29a9fb7ba8d0a5bc532eb27f0866a" translate="yes" xml:space="preserve">
          <source>NotNull</source>
          <target state="translated">NotNull</target>
        </trans-unit>
        <trans-unit id="7884a1030f088443b3e65dc8c7d9c833c3f14209" translate="yes" xml:space="preserve">
          <source>Nota bene:</source>
          <target state="translated">Nota bene.</target>
        </trans-unit>
        <trans-unit id="59ab81d7ff99620547d7c60a07878ec16f88cba0" translate="yes" xml:space="preserve">
          <source>Note also that when adding a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt;, the CHECK constraint is not tested against preexisting rows of the table. This can result in a table that contains data that is in violation of the CHECK constraint. Future versions of SQLite might change to validate CHECK constraints as they are added.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK制約を&lt;/a&gt;追加する場合、CHECK制約はテーブルの既存の行に対してテストされないことにも注意してください。これにより、CHECK制約に違反するデータを含むテーブルが作成される可能性があります。SQLiteの将来のバージョンでは、追加されたCHECK制約を検証するように変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="63cff68b4cc8b6d1593b377ca2761e4a780c9aef" translate="yes" xml:space="preserve">
          <source>Note that &quot;monotonically increasing&quot; does not imply that the ROWID always increases by exactly one. One is the usual increment. However, if an insert fails due to (for example) a uniqueness constraint, the ROWID of the failed insertion attempt might not be reused on subsequent inserts, resulting in gaps in the ROWID sequence. AUTOINCREMENT guarantees that automatically chosen ROWIDs will be increasing but not that they will be sequential.</source>
          <target state="translated">単調に増加する」というのは、ROWIDが常に正確に1だけ増加することを意味するわけではないことに注意してください。1は通常の増分です。しかし、(例えば)一意性制約のために挿入が失敗した場合、失敗した挿入試行の ROWID はその後の挿入で再利用されず、結果として ROWID シーケンスにギャップが生じる可能性があります。AUTOINCREMENT は、自動的に選択された ROWID が増加することを保証しますが、それらが順次になることは保証しません。</target>
        </trans-unit>
        <trans-unit id="4308667a324be6565f7e88fc7a4b19a7777f66dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;または&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;は、副作用としてデータベースを間接的に変更する可能性があることに注意してください。たとえば、アプリケーションが&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;を呼び出す関数 &quot;eval（）&quot;を定義している場合、次のSQLステートメントは副作用によってデータベースファイルを変更します。</target>
        </trans-unit>
        <trans-unit id="2de1256b9fbe19c405bb475cc7365f640da5726d" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">&lt;a href=&quot;../appfunc&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;または&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;は、副作用としてデータベースを間接的に変更する可能性があることに注意してください。たとえば、アプリケーションが&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;を呼び出す関数 &quot;eval（）&quot;を定義している場合、次のSQLステートメントは副作用によってデータベースファイルを変更します。</target>
        </trans-unit>
        <trans-unit id="2a8f4592d0e17a85103883247d0a4447a3744957" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="translated">&lt;a href=&quot;appfunc&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;は、デフォルトでは非決定論的と&lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;見なされ&lt;/a&gt;、関数の登録時にSQLITE_DETERMINISTICフラグが使用されない限り、CREATEINDEXステートメントで使用できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="1de4b11ed42096116749429497dc130939876ea1" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">&lt;a href=&quot;appfunc&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;または&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;は、副作用としてデータベースを間接的に変更する可能性があることに注意してください。たとえば、アプリケーションが&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;を呼び出す関数 &quot;eval（）&quot;を定義している場合、次のSQLステートメントは副作用によってデータベースファイルを変更します。</target>
        </trans-unit>
        <trans-unit id="aa33906842475ccf0659a59159f766bfacc10e93" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;は、デフォルトでは非決定的と&lt;a href=&quot;c3ref/c_deterministic&quot;&gt;見なされ&lt;/a&gt;、関数の登録時にSQLITE_DETERMINISTICフラグを使用しない限り、CREATE INDEXステートメントで使用できない場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5f9e6d6d8a3bf2c6d2a7e519940c1c6c58742f80" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">&lt;a href=&quot;create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;または&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;は、副作用としてデータベースを間接的に変更する可能性があることに注意してください。たとえば、アプリケーションが&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;を呼び出す関数 &quot;eval（）&quot;を定義している場合、次のSQLステートメントは副作用によってデータベースファイルを変更します。</target>
        </trans-unit>
        <trans-unit id="f679875d06130633120a14b47faa759dd16975f1" translate="yes" xml:space="preserve">
          <source>Note that Idx3 contains all the same information as the original &lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt;. And so if we have Idx3, we do not really need Idx1 any more. The &quot;price of peaches&quot; query can be satisfied using Idx3 by simply ignoring the &quot;state&quot; column of Idx3:</source>
          <target state="translated">Idx3には、元の&lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt;と同じ情報がすべて含まれていることに注意してください。Idx3があれば、Idx1はもう必要ありません。「桃の価格」クエリは、Idx3の「state」列を単に無視することで、Idx3を使用して満たすことができます。</target>
        </trans-unit>
        <trans-unit id="8e97b2bc14d77a13e225d171f50b67e2004fff89" translate="yes" xml:space="preserve">
          <source>Note that MinGW generates 32-bit DLLs only. There is a separate MinGW64 project that can be used to generate 64-bit DLLs. Presumably the command-line syntax is similar. Also note that recent versions of MSVC generate DLLs that will not work on WinXP and earlier versions of Windows. So for maximum compatibility of your generated DLL, MinGW is recommended. A good rule-of-thumb is to generate 32-bit DLLs using MinGW and 64-bit DLLs using MSVC.</source>
          <target state="translated">MinGWは32ビットのDLLのみを生成することに注意してください。別のMinGW64プロジェクトがあり、これを使って64ビットDLLを生成することができます。おそらくコマンドラインの構文は似ていると思われます。また、MSVCの最近のバージョンでは、WinXPやそれ以前のバージョンのWindowsでは動作しないDLLを生成することにも注意してください。そのため、生成されたDLLの互換性を最大限に高めるためには、MinGWをお勧めします。目安としては、MinGWを使って32ビットのDLLを生成し、MSVCを使って64ビットのDLLを生成するのが良いでしょう。</target>
        </trans-unit>
        <trans-unit id="103d786acd07e894276011f9fe0ff0e5d6f3f4da" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">SQLITE_IGNOREは、&lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;インターフェースから返される&lt;a href=&quot;#SQLITE_FAIL&quot;&gt;競合解決モード&lt;/a&gt;としても使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="82cf9ab6c420a3c604d44b14992c4f512d1f4c35" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;c_fail&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">SQLITE_IGNOREは、&lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;インターフェースから返される&lt;a href=&quot;c_fail&quot;&gt;競合解決モード&lt;/a&gt;としても使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="bd4aaf9aa187deca337c2af0406d2d0e3c9d07f4" translate="yes" xml:space="preserve">
          <source>Note that SQLite allows the parenthesized list of scalar values on the right-hand side of an IN or NOT IN operator to be an empty list but most other SQL database database engines and the SQL92 standard require the list to contain at least one element.</source>
          <target state="translated">SQLite では IN または NOT IN 演算子の右側にあるスカラ値の括弧付きリストを空リストにすることができますが、他のほとんどの SQL データベースエンジンや SQL92 標準では、リストに少なくとも 1 つの要素を含める必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="069a48733ca46d6fc20e074068d69739ed664b2b" translate="yes" xml:space="preserve">
          <source>Note that SQLite automatically adds the appropriate extension suffix (&quot;.dll&quot; on windows, &quot;.dylib&quot; on Mac, &quot;.so&quot; on most other unixes) to the extension filename. It is generally a good idea to specify the full pathname of the extension.</source>
          <target state="translated">SQLite は自動的に適切な拡張子のサフィックス (&quot;windows では&quot;.dll&quot;、Mac では &quot;.dylib&quot;、他のほとんどの Unix では &quot;.so&quot;)を拡張子ファイル名に追加することに注意してください。一般的には、拡張子のフルパス名を指定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="878abfb73c8f4fd7637bff37205a9854afa6975b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;../malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">SQLiteには、圧倒的多数のアプリケーションに完全に適した&lt;a href=&quot;../malloc#altalloc&quot;&gt;組み込みメモリアロケータ&lt;/a&gt;がいくつか付属しており、このオブジェクトは、特殊なメモリ割り当て要件を持つごく少数のアプリケーションにのみ役立つことに注意してください。このオブジェクトは、SQLiteのテスト中に、メモリ不足状態をシミュレートする代替メモリアロケータを指定して、SQLiteがそのような状態から正常に回復することを確認するためにも使用されます。</target>
        </trans-unit>
        <trans-unit id="8a9932e44739c8fef89cbf2d998599f354bb604b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">SQLiteには、圧倒的多数のアプリケーションに完全に適した&lt;a href=&quot;malloc#altalloc&quot;&gt;組み込みメモリアロケータ&lt;/a&gt;がいくつか付属しており、このオブジェクトは、特殊なメモリ割り当て要件を持つごく少数のアプリケーションにのみ役立つことに注意してください。このオブジェクトは、SQLiteのテスト中に、メモリ不足状態をシミュレートする代替メモリアロケータを指定して、SQLiteがそのような状態から正常に回復することを確認するためにも使用されます。</target>
        </trans-unit>
        <trans-unit id="f1f541cbfa03c47b900f800f3f8afdec05b49044" translate="yes" xml:space="preserve">
          <source>Note that SQLite does not enforce the PRIMARY KEY for a WITHOUT ROWID virtual table. Enforcement is the responsibility of the underlying virtual table implementation. But SQLite does assume that the PRIMARY KEY constraint is valid - that the identified columns really are UNIQUE and NOT NULL - and it uses that assumption to optimize queries against the virtual table.</source>
          <target state="translated">SQLite は WITHOUT ROWID 仮想テーブルの PRIMARY KEY を強制しないことに注意してください。強制するかどうかは、基礎となる仮想テーブルの実装の責任となります。しかし、SQLite は PRIMARY KEY 制約が有効であること、つまり識別された列が本当に UNIQUE で NOT NULL であることを前提としており、その前提を用いて仮想テーブルに対するクエリを最適化します。</target>
        </trans-unit>
        <trans-unit id="d3bdb4d9a8050dadd7145a64b6065f6da75ef0eb" translate="yes" xml:space="preserve">
          <source>Note that SQLite must believe whatever the operating system and hardware tell it about the status of sync requests. There is no way for SQLite to detect that either is lying and that writes might be occurring out-of-order. However, SQLite in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is far more forgiving of out-of-order writes than in the default rollback journal modes. In WAL mode, the only time that a failed sync operation can cause database corruption is during a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operation. A sync failure during a COMMIT might result in loss of durability but not in a corrupt database file. Hence, one line of defense against database corruption due to failed sync operations is to use SQLite in WAL mode and to checkpoint as infrequently as possible.</source>
          <target state="translated">SQLiteは、オペレーティングシステムとハードウェアが同期要求のステータスについて教えているものをすべて信じなければならないことに注意してください。 SQLiteがどちらかが嘘であり、書き込みが順不同で発生している可能性があることを検出する方法はありません。ただし、&lt;a href=&quot;wal&quot;&gt;WALモードの&lt;/a&gt; SQLiteは、デフォルトのロールバックジャーナルモードよりも、順序の乱れた書き込みをはるかに許容します。 WALモードでは、失敗した同期操作がデータベースの破損を引き起こす可能性があるのは、&lt;a href=&quot;wal#ckpt&quot;&gt;チェックポイント&lt;/a&gt;操作中のみです。 COMMIT中に同期が失敗すると、耐久性が失われる可能性がありますが、データベースファイルが破損することはありません。したがって、同期操作の失敗によるデータベースの破損に対する防御策の1つは、SQLiteをWALモードで使用し、チェックポイントをできるだけ少なくすることです。</target>
        </trans-unit>
        <trans-unit id="a2fee544cde41af143fe81786b7190276086b344" translate="yes" xml:space="preserve">
          <source>Note that SQLite uses b-trees, which are a sorted data structure, so indices can be used when the WHERE clause of the SELECT statement contains tests for equality or inequality. Queries like the following can use an index if it is available:</source>
          <target state="translated">SQLite はソートされたデータ構造である b-tree を使用しているため、SELECT 文の WHERE 句に等しさや不等しさのテストが含まれている場合にインデックスを使用することができることに注意してください。以下のようなクエリでは、インデックスが利用可能であればインデックスを使用することができます。</target>
        </trans-unit>
        <trans-unit id="5081483bfc5c0173b67743dd4507d0595797d951" translate="yes" xml:space="preserve">
          <source>Note that a declared type of &quot;FLOATING POINT&quot; would give INTEGER affinity, not REAL affinity, due to the &quot;INT&quot; at the end of &quot;POINT&quot;. And the declared type of &quot;STRING&quot; has an affinity of NUMERIC, not TEXT.</source>
          <target state="translated">FLOATING POINT&quot; の宣言型は、&quot;POINT&quot; の最後に &quot;INT&quot; があるため、REAL ではなく INTEGER との親和性を持つことに注意してください。また、宣言された &quot;STRING&quot; の型は、NUMERIC の親和性を持ち、TEXT の親和性を持ちません。</target>
        </trans-unit>
        <trans-unit id="6008db09d7c79dcc3b84a140fc5e215929e6ce79" translate="yes" xml:space="preserve">
          <source>Note that a transformation that flips the polygon might cause the order of vertexes to be reversed. In other words, the transformation might cause the vertexes to circulate in clockwise order instead of counter-clockwise. This can be corrected by sending the result through the &lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw()&lt;/a&gt; function after transformation.</source>
          <target state="translated">ポリゴンを反転する変換では、頂点の順序が逆になる可能性があることに注意してください。つまり、変換により、頂点が反時計回りではなく時計回りに循環する場合があります。これは、変換後に&lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw（）&lt;/a&gt;関数を使用して結果を送信することで修正できます。</target>
        </trans-unit>
        <trans-unit id="3eb1501d271603c6953bfb8ef829d45c83d17e8d" translate="yes" xml:space="preserve">
          <source>Note that an inner transaction might commit (using the RELEASE command) but then later have its work undone by a ROLLBACK in an outer transaction. A power failure or program crash or OS crash will cause the outer-most transaction to rollback, undoing all changes that have occurred within that outer transaction, even changes that have supposedly been &quot;committed&quot; by the RELEASE command. Content is not actually committed on the disk until the outermost transaction commits.</source>
          <target state="translated">内部のトランザクションが(RELEASEコマンドを使用して)コミットした後、外部のトランザクションのROLLBACKによってその作業が取り消されるかもしれないことに注意すること。停電、プログラムのクラッシュ、OS のクラッシュは、一番外側のトランザクションをロールバックさせ、その外側のトランザクショ ン内で発生したすべての変更を元に戻し、RELEASE コマンドによって「コミット」されたと思われる変更でさえも元に戻す。コンテンツは、最も外側のトランザクションがコミットするまで、実際にはディスク上にコミットされません。</target>
        </trans-unit>
        <trans-unit id="7c93fd99fb4687ad2997daf3b6769cc616b7c58e" translate="yes" xml:space="preserve">
          <source>Note that conflict resolutions from multiple remote changesets are combined on a per-field basis, not per-row. This means that in the case of multiple remote UPDATE operations, some fields of a single local change may be rebased for REPLACE while others are rebased for OMIT.</source>
          <target state="translated">複数のリモートチェンジセットからの競合解決は、行単位ではなく、フィールド単位で結合されることに注意してください。これは、複数のリモートUPDATE操作の場合、単一のローカル変更の一部のフィールドはREPLACEでリベースされ、他のフィールドはOMITでリベースされる可能性があることを意味します。</target>
        </trans-unit>
        <trans-unit id="e3af7101a58299023cb05d90e0fc88f9fa63608b" translate="yes" xml:space="preserve">
          <source>Note that conversions between UTF-16be and UTF-16le are always done in place and do not invalidate a prior pointer, though of course the content of the buffer that the prior pointer points to will have been modified. Other kinds of conversion are done in place when it is possible, but sometime it is not possible and in those cases prior pointers are invalidated.</source>
          <target state="translated">UTF-16be と UTF-16le 間の変換は常にその場で行われ、先行ポ イ ン タ ーは無効にはなりません。その他の種類の変換は可能な場合にはその場で行われますが、それが不可能な場合もあり、その場合には先行ポインタは無効になります。</target>
        </trans-unit>
        <trans-unit id="f0c5f85c046ed0d0d783a57a522950f881e39de3" translate="yes" xml:space="preserve">
          <source>Note that deleting records from a zip archive does not reclaim the space used within the archive - it merely removes an entry from the archives &quot;Central Directory Structure&quot;, making the entry inaccessible. One way to work around this inefficiency is to create a new zip archive based on the contents of the edited archive. For example, after editing the archive accessed via virtual table temp.zzz:</source>
          <target state="translated">ZIP アーカイブからレコードを削除しても、アーカイブ内で使われているスペースを取り戻すわけではないことに注意してください。この非効率性を回避する一つの方法は、編集したアーカイブの内容に基づいて新しい zip アーカイブを作成することです。例えば、仮想テーブル temp.zzz を介してアクセスされたアーカイブを編集した後、次のようにします。</target>
        </trans-unit>
        <trans-unit id="710cdb120286dd832bd6798397cffbb5dfeed9ef" translate="yes" xml:space="preserve">
          <source>Note that different operating systems use different filename suffixes for their shared libraries. Windows use &quot;.dll&quot;, Mac uses &quot;.dylib&quot;, and most unixes other than mac use &quot;.so&quot;. If you want to make your code portable, you can omit the suffix from the shared library filename and the appropriate suffix will be added automatically by the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface.</source>
          <target state="translated">オペレーティングシステムによって、共有ライブラリのファイル名のサフィックスが異なることに注意してください。Windowsは「.dll」を使用し、Macは「.dylib」を使用し、mac以外のほとんどのunixは「.so」を使用します。コードを移植可能にする場合は、共有ライブラリのファイル名から接尾辞を省略できます。適切な接尾辞は、&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;インターフェースによって自動的に追加されます。</target>
        </trans-unit>
        <trans-unit id="c12e1242a0c93cb2f83528b0161fb89fb73eac90" translate="yes" xml:space="preserve">
          <source>Note that each 32768-byte unit of the shm file has its own aHash and aPgno arrays. The aHash array for a single unit is only helpful in finding aPgno entries in that same unit. The overall FindFrame(P,M) function needs to do hash lookups beginning with the latest unit and working backwards to the oldest unit until it finds an answer.</source>
          <target state="translated">shmファイルの各32768バイトのユニットには、それぞれ独自のaHashとaPgno配列があることに注意してください。一つのユニットの aHash 配列は、同じユニット内の aPgno エントリを見つけるのにのみ役立ちます。全体的な FindFrame(P,M)関数は、答えが見つかるまで、最新のユニットから始まり、最も古いユニットに遡ってハッシュ検索を行う必要があります。</target>
        </trans-unit>
        <trans-unit id="30f49c0b1079064845cadc4000f3f0cbc4ba7f9a" translate="yes" xml:space="preserve">
          <source>Note that enabling FTS3 also makes FTS4 available. There is not a separate SQLITE_ENABLE_FTS4 compile-time option. A build of SQLite either supports both FTS3 and FTS4 or it supports neither.</source>
          <target state="translated">FTS3 を有効にすると FTS4 も使用可能になることに注意してください。SQLITE_ENABLE_FTS4 コンパイル時オプションは別途用意されていません。SQLite のビルドは FTS3 と FTS4 の両方をサポートしているか、どちらもサポートしていません。</target>
        </trans-unit>
        <trans-unit id="665e7a6fdd40011f21f13b4109b67442ccc2792c" translate="yes" xml:space="preserve">
          <source>Note that except for a few corner-case differences detailed above, WITHOUT ROWID tables and rowid tables work the same. They both generate the same answers given the same SQL statements. So it is a simple matter to run experiments on an application, late in the development cycle, to test whether or not the use of WITHOUT ROWID tables will be helpful. A good strategy is to simply not worry about WITHOUT ROWID until near the end of product development, then go back and run tests to see if adding WITHOUT ROWID to tables with non-integer PRIMARY KEYs helps or hurts performance, and retaining the WITHOUT ROWID only in those cases where it helps.</source>
          <target state="translated">上記で詳述したいくつかのコーナーケースの違いを除いて、WITHOUT ROWIDテーブルとROWIDテーブルは同じように動作することに注意してください。どちらも同じSQL文が与えられたときに同じ答えを生成します。ですから、開発サイクルの後半にアプリケーションで実験を実行して、WITHOUT ROWIDテーブルの使用が役に立つかどうかをテストするのは簡単なことです。良い戦略は、製品開発の終わり近くまでWITHOUT ROWIDを気にしないことです。その後、戻ってテストを実行し、非整数のPRIMARY KEYを持つテーブルにWITHOUT ROWIDを追加することがパフォーマンスに役立つかどうかを確認し、WITHOUT ROWIDは役立つ場合にのみ保持することです。</target>
        </trans-unit>
        <trans-unit id="bde5b3e09fe9bd78baf5c5b8cf655c1d83bf9828" translate="yes" xml:space="preserve">
          <source>Note that geopoly uses a traditional right-handed cartesian coordinate system with the origin at the lower left, whereas SVG uses a left-handed coordinate system with the origin at the upper left. The geopoly_svg() routine makes no attempt to transform the coordinate system, so the displayed images are shown in mirror image and rotated. If that is undesirable, the geopoly_xform() routine can be used to transform the output from cartesian to SVG coordinates prior to passing the polygons into geopoly_svg().</source>
          <target state="translated">geopoly は左下を原点とする伝統的な右手の直交座標系を使用しているのに対し、SVG は左上を原点とする左手の座標系を使用していることに注意してください。geopoly_svg()ルーチンは座標系を変換しようとしないので、表示される画像は鏡像で表示され、回転されます。それが望ましくない場合は、 geopoly_svg()にポリゴンを渡す前に、 geopoly_xform()ルーチンを使用して、出力を直交座標系から SVG 座標系に変換することができます。</target>
        </trans-unit>
        <trans-unit id="98a440c913714baad6d711ca1c482bbb8e3fece7" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">非決定的関数が&lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;でタグ付けされている場合、その関数が&lt;a href=&quot;partialindex&quot;&gt;部分インデックスの&lt;/a&gt; WHERE句または&lt;a href=&quot;expridx&quot;&gt;式インデックス&lt;/a&gt;で使用されると、関数が異なる回答を返し始めると、関連付けられたインデックスが破損する可能性があることに注意してください。。 SQL関数がほぼ確定的であり（つまり、&lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version（）の&lt;/a&gt;ようにほとんど変更されない場合）、破損したインデックスで使用される場合、&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;を実行することで破損を修正できます。</target>
        </trans-unit>
        <trans-unit id="c13f9095e78ebed2a9c8d270bb63e3a9b47c70fe" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">非決定論的関数が&lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;でタグ付けされ、その関数が&lt;a href=&quot;partialindex&quot;&gt;部分インデックスの&lt;/a&gt;WHERE句または&lt;a href=&quot;expridx&quot;&gt;式インデックス&lt;/a&gt;で使用されることになった場合、関数が異なる回答を返し始めると、関連するインデックスが破損する可能性があることに注意してください。。 SQL関数がほぼ決定論的であり（つまり、&lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version（）の&lt;/a&gt;ようにほとんど変更されない場合）、破損したインデックスで使用されている場合は、&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;を実行することで破損を修正できます。</target>
        </trans-unit>
        <trans-unit id="3e7ef1f945a3c3a6083df7d03b59a24fcefb7fd0" translate="yes" xml:space="preserve">
          <source>Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc() returns a different mutex on every call. For the static mutex types, the same mutex is returned on every call that has the same type number.</source>
          <target state="translated">動的ミューテックスパラメータ(SQLITE_MUTEX_FASTまたはSQLITE_MUTEX_RECURSIVE)が使用されている場合、sqlite3_mutex_alloc()はコールごとに異なるミューテックスを返すことに注意してください。静的なミューテックス型の場合は、同じ型番号を持つ全ての呼び出しで同じミューテックスが返されます。</target>
        </trans-unit>
        <trans-unit id="1c50891c113debf231642ee8d937768c49d352cf" translate="yes" xml:space="preserve">
          <source>Note that if you do not include the &quot;langid=N&quot; term in the WHERE clause, the search will be against language 0 (English in the example above.) All spellfix1 searches are against a single language id. There is no way to search all languages at once.</source>
          <target state="translated">WHERE 句に &quot;langid=N&quot; を含まない場合は、言語 0 (上の例では英語)を対象とした検索になることに注意しましょう。すべての言語を一度に検索する方法はありません。</target>
        </trans-unit>
        <trans-unit id="67f33837baeec763fa57cef78587afa10292c83d" translate="yes" xml:space="preserve">
          <source>Note that in most cases, SQLite will only use a single index for each table in the FROM clause of a query. The second OR-clause optimization described here is the exception to that rule. With an OR-clause, a different index might be used for each subterm in the OR-clause.</source>
          <target state="translated">ほとんどの場合、SQLiteはクエリのFROM句の各テーブルに対して単一のインデックスしか使用しないことに注意してください。ここで説明する二番目のOR句の最適化は、このルールの例外です。OR句では、OR句の各サブタームに対して異なるインデックスが使用されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="63fa9dab5a3c38f244560b4ee3d5231308f8ad59" translate="yes" xml:space="preserve">
          <source>Note that in order for the special &quot;:memory:&quot; name to apply and to create a pure in-memory database, there must be no additional text in the filename. Thus, a disk-based database can be created in a file by prepending a pathname, like this: &quot;./:memory:&quot;.</source>
          <target state="translated">特別な &quot;:memory:&quot; という名前が適用され、純粋なインメモリデータベースを作成するためには、 ファイル名の中に追加のテキストがあってはならないことに注意してください。したがって、ディスクベースのデータベースは、以下のようにパス名を前置してファイル内に作成することができます。&quot;./:memory:&quot; のようにパス名を前置することで、ファイル内にディスクベースのデータベースを作成することができます。</target>
        </trans-unit>
        <trans-unit id="1b52e107709738a3260fec8ebd98ff46511f5c58" translate="yes" xml:space="preserve">
          <source>Note that in the diagram above, we showed the private edits as a single commit. This was for clarity of presentation only. There is nothing to stop you from doing dozens or hundreds of separate tiny changes and committing each separately. In fact, making many small changes is the preferred way to work. The only reason for doing all the changes in a single commit is that it makes the diagram easier to draw.</source>
          <target state="translated">上の図では、プライベートな編集を単一のコミットとして表示したことに注意してください。これは表示をわかりやすくするためだけのものです。何十個も何百個もの小さな変更を個別に行い、それぞれを個別にコミットすることを止めるものは何もありません。実際には、多くの小さな変更を行うことが望ましい作業方法です。すべての変更を単一のコミットで行う唯一の理由は、図を描きやすくするためです。</target>
        </trans-unit>
        <trans-unit id="705b7526443ed2af20dbc38ecc0ad5be9f1ce9d9" translate="yes" xml:space="preserve">
          <source>Note that in this design, the tokenizer calls the parser. People who are familiar with YACC and BISON may be accustomed to doing things the other way around &amp;mdash; having the parser call the tokenizer. Having the tokenizer call the parser is better, though, because it can be made threadsafe and it runs faster.</source>
          <target state="translated">この設計では、トークナイザーがパーサーを呼び出すことに注意してください。YACCとBISONに精通している人々は、逆の方法でパーサーにトークナイザーを呼び出させるのに慣れているかもしれません。ただし、トークナイザがパーサーを呼び出すようにすると、スレッドセーフにすることができ、実行速度が向上するため、より優れています。</target>
        </trans-unit>
        <trans-unit id="819e65339172e5dc379cf7c2c3439c1fadf7ced3" translate="yes" xml:space="preserve">
          <source>Note that infix functions (&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;, and &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;) reverse the order of their arguments. So &quot;like(A,B)&quot; is equivalent to &quot;B like A&quot;. For the form &quot;B like A&quot; the B term is considered the first argument to the function. But for &quot;like(A,B)&quot; the A term is considered the first argument.</source>
          <target state="translated">イン&lt;a href=&quot;lang_expr#glob&quot;&gt;フィックス&lt;/a&gt;関数（&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;、GLOB、&lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;、および&lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;）は、引数の順序を逆にすることに注意してください。したがって、「like（A、B）」は「B like A」と同等です。「B like A」の形式の場合、B項は関数の最初の引数と見なされます。ただし、「like（A、B）」の場合、A項が最初の引数と見なされます。</target>
        </trans-unit>
        <trans-unit id="35589dde916482f10a4613056291243d802b1cc4" translate="yes" xml:space="preserve">
          <source>Note that it is important to set the &quot;mode&quot; to &quot;csv&quot; before running the &quot;.import&quot; command. This is necessary to prevent the command-line shell from trying to interpret the input file text as some other format.</source>
          <target state="translated">.import &quot;コマンドを実行する前に &quot;mode &quot;を &quot;csv &quot;に設定することが重要であることに注意してください。これは、コマンドラインシェルが入力ファイルのテキストを他の形式として解釈しようとするのを防ぐために必要です。</target>
        </trans-unit>
        <trans-unit id="aab0f603b95c5838db66d31fe53b5c5afd66afd1" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary for all coordinates in an R*Tree index to be constrained in order for the index search to be efficient. One might, for example, want to query all objects that overlap with the 35th parallel:</source>
          <target state="translated">インデックス検索を効率的に行うためには、R*Treeインデックス内のすべての座標に制約がある必要はないことに注意してください。例えば、35番目の平行線と重なるすべてのオブジェクトを検索したいとします。</target>
        </trans-unit>
        <trans-unit id="750004cbbcdb4b09f134058116396d2802e69e0a" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to quote the $bigstring value. That happens automatically. If $bigstring is a large string or binary object, this technique is not only easier to write, it is also much more efficient since it avoids making a copy of the content of $bigstring.</source>
          <target state="translated">BIGSTRING の値を引用する必要はないことに注意してください。これは自動的に行われます。BIGSTRING が大きな文字列やバイナリオブジェクトの場合は、この方法の方が書きやすいだけでなく、 $BIGSTRING の内容のコピーを作成しなくて済むので、はるかに効率的です。</target>
        </trans-unit>
        <trans-unit id="aedf129a94b2c6ea4cf41bd3da4352659cc6bb37" translate="yes" xml:space="preserve">
          <source>Note that it is perfectly safe for two or more threads to access the same SQLite database file using the SQLite library. The unix drivers for SQLite know about the POSIX advisory locking quirks and work around them. This problem only arises when a thread tries to bypass the SQLite library and read the database file directly.</source>
          <target state="translated">2つ以上のスレッドがSQLiteライブラリを使用して同じSQLiteデータベースファイルにアクセスすることは完全に安全であることに注意してください。SQLite 用の unix ドライバは POSIX 勧告のロックの癖を知っており、それを回避しています。この問題は、スレッドが SQLite ライブラリをバイパスしてデータベースファイルを直接読み込もうとした場合にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="af76f7d3a1b3eb149d8a26a0e9299bf38c7c0401" translate="yes" xml:space="preserve">
          <source>Note that it is very important that the database filename have some kind of extension. If there is no extension, then SQLite creates auxiliary filenames by appending to the base name of the file. Thus, a database named &quot;&lt;code&gt;db01&lt;/code&gt;&quot; would have a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; file named &quot;&lt;code&gt;db01-journal&lt;/code&gt;&quot;. And as this filename has no extension to shorten to 3 characters, it will be used as-is, and will violate 8+3 naming rules.</source>
          <target state="translated">データベースのファイル名になんらかの拡張子を付けることが非常に重要であることに注意してください。拡張子がない場合、SQLiteはファイルのベース名に追加して補助ファイル名を作成します。したがって、「 &lt;code&gt;db01&lt;/code&gt; 」という名前のデータベースには、「 &lt;code&gt;db01-journal&lt;/code&gt; 」という名前の&lt;a href=&quot;lockingv3#rollback&quot;&gt;ロールバックジャーナル&lt;/a&gt;ファイルがあります。また、このファイル名には3文字に短縮する拡張子がないため、そのまま使用され、8 + 3の命名規則に違反します。</target>
        </trans-unit>
        <trans-unit id="19eeeefb37e5b82a70fbf6a86a847157f005c210" translate="yes" xml:space="preserve">
          <source>Note that prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), SQLite did not check the xCreate method for NULL before invoking it. So if an eponymous-only virtual table is registered with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;version 3.8.11.1&lt;/a&gt; (2015-07-29) or earlier and a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; command is attempted against that virtual table module, a jump to a NULL pointer will occur, resulting in a crash.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;バージョン3.9.0&lt;/a&gt;（2015-10-14）より前では、SQLiteは呼び出す前にNULLのxCreateメソッドをチェックしていませんでした。したがって、名前のみの仮想テーブルがSQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;バージョン3.8.11.1&lt;/a&gt;（2015-07-29）以前に登録され、その仮想テーブルモジュールに対して&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;コマンドが試行されると、NULLポインターへのジャンプが発生し、クラッシュ。</target>
        </trans-unit>
        <trans-unit id="7cb63274cd75ba4167c68c8885d57c07e7241aab" translate="yes" xml:space="preserve">
          <source>Note that running SQLite with gcov is not a test of SQLite &amp;mdash; it is a test of the test suite. The gcov run does not test SQLite because the -fprofile-args and -ftest-coverage options cause the compiler to generate different code. The gcov run merely verifies that the test suite provides 100% branch test coverage. The gcov run is a test of the test - a meta-test.</source>
          <target state="translated">gcovでSQLiteを実行することはSQLiteのテストではないことに注意してください&amp;mdash;これはテストスイートのテストです。-fprofile-argsおよび-ftest-coverageオプションによりコンパイラーが異なるコードを生成するため、gcovの実行ではSQLiteをテストしません。gcovの実行は、テストスイートが100％ブランチテストカバレッジを提供することを確認するだけです。gcovの実行は、テストのテスト-メタテストです。</target>
        </trans-unit>
        <trans-unit id="5a5f0aee350ad05534eee4c24d91d936725afa91" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;定数は&lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;コールバックからの潜在的な戻り値としても使用され、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;も&lt;a href=&quot;rescode&quot;&gt;結果コードで&lt;/a&gt;あることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f4daa0a4c8ffbaa8c905b7b2b472738ae1e277cf" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces do not count INSTEAD OF trigger firings, but the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; does count INSTEAD OF trigger firing.</source>
          <target state="translated">&lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes（）&lt;/a&gt;および&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;インターフェースはINSTEAD OFトリガーの起動をカウントしませんが、&lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changesプラグマ&lt;/a&gt;はINSTEAD OFトリガーの起動をカウントすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f4f048e66a09e44bfda0411919740620eea7756a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;定数は&lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;コールバックからの潜在的な戻り値としても使用され、&lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;も&lt;a href=&quot;../rescode&quot;&gt;結果コードで&lt;/a&gt;あることに注意してください。</target>
        </trans-unit>
        <trans-unit id="732e678676cbad83be2195f0c9cbdf90bfcdfbeb" translate="yes" xml:space="preserve">
          <source>Note that the DO UPDATE clause acts only on the single row that experienced the constraint error during INSERT. It is not necessary to include a WHERE clause that restrictions the action to that one row. The only use for the WHERE clause at the end of the DO UPDATE is to optionally change the DO UPDATE into a no-op depending on the original and/or new values. For example:</source>
          <target state="translated">DO UPDATE句は、INSERT時に制約エラーが発生した1つの行に対してのみ動作することに注意してください。アクションをその1行に制限するWHERE句を含める必要はありません。DO UPDATEの最後にあるWHERE句の唯一の使用法は、DO UPDATEを元の値および/または新しい値に応じて、オプションでDO UPDATEをno-opに変更することです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="9e431af898d8e365308f86b50efb344365dfb157" translate="yes" xml:space="preserve">
          <source>Note that the SQLITE_TEXT constant was also used in SQLite version 2 for a completely different meaning. Software that links against both SQLite version 2 and SQLite version 3 should use SQLITE3_TEXT, not SQLITE_TEXT.</source>
          <target state="translated">SQLITE_TEXT 定数は SQLite バージョン 2 でも全く異なる意味で使われていたことに注意してください。SQLite バージョン 2 と SQLite バージョン 3 の両方にリンクするソフトウェアは、SQLITE_TEXT ではなく SQLITE3_TEXT を使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="db7397560741b34c84d7c7b13b86a2bbf792ba5b" translate="yes" xml:space="preserve">
          <source>Note that the SQLite parser will not always generate code to use an index, even if it is possible to do so. The following queries will not currently use the index:</source>
          <target state="translated">SQLite パーサーは、インデックスを使用することが可能であっても、必ずしもインデックスを使用するコードを生成するとは限らないことに注意してください。以下のクエリは現在のところインデックスを使用しません。</target>
        </trans-unit>
        <trans-unit id="021cca6e0a1bc313b828c0c99864715910f5cf3d" translate="yes" xml:space="preserve">
          <source>Note that the UNION ALL operator for compound queries does not use transient indices by itself (though of course the right and left subqueries of the UNION ALL might use transient indices depending on how they are composed.)</source>
          <target state="translated">複合クエリ用のUNION ALL演算子は、それ自体では過渡インデックスを使用しないことに注意してください(もちろん、UNION ALLの右と左の副問い合わせがどのように構成されているかによっては過渡インデックスを使用するかもしれませんが)。</target>
        </trans-unit>
        <trans-unit id="0676f5b60fd19b027ecab9b9999e5b7f746d671c" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_prepare&quot;&gt;オーソライザー&lt;/a&gt;コールバックは、sqlite3_prepare（）またはそのバリアントの間にのみ呼び出されることに注意してください。前の段落で述べたように、sqlite3_step（）がsqlite3_prepare_v2（）を呼び出してスキーマの変更後にステートメントを再準備しない限り、&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;でのステートメント評価中は認可は実行されません。</target>
        </trans-unit>
        <trans-unit id="f1e28776761e0bfe4431c21ae77ea6373668b8fc" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">&lt;a href=&quot;prepare&quot;&gt;オーソライザー&lt;/a&gt;コールバックは、sqlite3_prepare（）またはそのバリアントの間にのみ呼び出されることに注意してください。前の段落で述べたように、sqlite3_step（）がsqlite3_prepare_v2（）を呼び出してスキーマの変更後にステートメントを再準備しない限り、&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;でのステートメント評価中は認可は実行されません。</target>
        </trans-unit>
        <trans-unit id="ac6d36a8492877c1ea3743d0c173020c27937cf2" translate="yes" xml:space="preserve">
          <source>Note that the character encoding mechanism used by SQLite cannot be changed at run-time. This is a compile-time option only. The &lt;b&gt;sqlite_encoding&lt;/b&gt; character string just tells you how the library was compiled.</source>
          <target state="translated">SQLiteが使用する文字エンコーディングメカニズムは、実行時に変更できないことに注意してください。これはコンパイル時のオプションのみです。&lt;b&gt;sqlite_encoding&lt;/b&gt;文字列だけでライブラリがコンパイルされた方法を説明します。</target>
        </trans-unit>
        <trans-unit id="7febee2154ade1b2d3219ad0df6d8ce2b6d91690" translate="yes" xml:space="preserve">
          <source>Note that the checksums in the rollback journal are not necessary if the synchronous setting is FULL. We only depend on the checksums when synchronous is lowered to NORMAL. Nevertheless, the checksums never hurt and so they are included in the rollback journal regardless of the synchronous setting.</source>
          <target state="translated">同期設定がFULLの場合、ロールバックジャーナルのチェックサムは必要ないことに注意してください。チェックサムに依存するのは、 synchronous が NORMAL に下げられたときだけです。とはいえ、チェックサムは決して問題にならないので、同期の設定に関係なくロールバックジャーナルに含まれます。</target>
        </trans-unit>
        <trans-unit id="808239b91162b2ff74019b785a2c4443032a884a" translate="yes" xml:space="preserve">
          <source>Note that the command-line shell program has already enabled extension loading for you (by calling the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface as part of its setup) so the command above works without any special switches, setup, or other complications.</source>
          <target state="translated">コマンドラインシェルプログラムでは、拡張機能のロードが既に有効になっている（&lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt;インターフェイスをセットアップの一部として呼び出すことにより）ため、上記のコマンドは特別なスイッチ、セットアップ、またはその他の複雑な作業なしで機能します。</target>
        </trans-unit>
        <trans-unit id="6e9cc72c28987333ade7d6e3571128f51c3b46dd" translate="yes" xml:space="preserve">
          <source>Note that the destructor function D is for the pointer value P, not for the type string T. The type string T should be a static string with an infinite lifetime.</source>
          <target state="translated">デストラクタ関数Dはポインタ値Pに対するものであり、型文字列Tに対するものではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="4cfa4e46e35f2a19630aea45991cffe3dd621ecd" translate="yes" xml:space="preserve">
          <source>Note that the integer key is one greater than the largest key that was in the table just prior to the insert. The new key will be unique over all keys currently in the table, but it might overlap with keys that have been previously deleted from the table. To create keys that are unique over the lifetime of the table, add the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; keyword to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; declaration. Then the key chosen will be one more than the largest key that has ever existed in that table. If the largest possible key has previously existed in that table, then the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error code.</source>
          <target state="translated">整数キーは、挿入直前のテーブルにあった最大のキーよりも1つ大きいことに注意してください。新しいキーは現在テーブルにあるすべてのキーに対して一意ですが、以前にテーブルから削除されたキーと重複する場合があります。テーブルの存続期間を通じて一意のキーを作成するには、&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;キーワードを&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;宣言に追加します。次に、選択されたキーは、そのテーブルに存在する最大のキーより1つ多くなります。可能な最大のキーが以前にそのテーブルに存在していた場合、&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;は&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;エラーコードで失敗します。</target>
        </trans-unit>
        <trans-unit id="228b63ead1b7d1b62a8c83539d4e8ab64da2dc4c" translate="yes" xml:space="preserve">
          <source>Note that the journal_mode for an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; is either MEMORY or OFF and can not be changed to a different value. An attempt to change the journal_mode of an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; to any setting other than MEMORY or OFF is ignored. Note also that the journal_mode cannot be changed while a transaction is active.</source>
          <target state="translated">&lt;a href=&quot;inmemorydb&quot;&gt;インメモリデータベース&lt;/a&gt;のjournal_mode はMEMORYまたはOFFであり、別の値に変更できないことに注意してください。&lt;a href=&quot;inmemorydb&quot;&gt;インメモリデータベース&lt;/a&gt;のjournal_modeをMEMORYまたはOFF以外の設定に変更しようとしても無視されます。また、トランザクションがアクティブな間は、journal_modeを変更できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="1150442b82dfad6909e59c690e94911009ab738b" translate="yes" xml:space="preserve">
          <source>Note that the list of routines above is conceptual rather than actual. Many of these routines come in multiple versions. For example, the list above shows a single routine named &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; when in fact there are three separate routines that accomplish the same thing in slightly different ways: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The list mentions &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; when in fact no such routine exists. The &quot;sqlite3_column()&quot; shown in the list is a placeholder for an entire family of routines that extra column data in various datatypes.</source>
          <target state="translated">上記のルーチンのリストは実際のものではなく概念的なものであることに注意してください。これらのルーチンの多くには、複数のバージョンがあります。例えば、番組上のリスト、単一の名前付きルーチン&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;実際には、わずかに異なる方法で同じことを達成する3つの別々のルーチンがある場合：&lt;a href=&quot;c3ref/open&quot;&gt;（sqlite3_open）は&lt;/a&gt;、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;と&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（） &lt;/a&gt;。リストには実際にはそのようなルーチンが存在しない場合の&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column（）&lt;/a&gt;が記載されています。リストに示されている「sqlite3_column（）」は、さまざまなデータ型の列データを追加するルーチン全体のプレースホルダーです。</target>
        </trans-unit>
        <trans-unit id="4fdc00a153b8f8752a20bfd3564af15ee4f88900" translate="yes" xml:space="preserve">
          <source>Note that the memory leak detection logic continues to work even when the OOM overlay is being used. This verifies that SQLite does not leak memory even when it encounters memory allocation errors. Note also that the OOM overlay can work with any underlying memory allocator, including the instrumented memory allocator that checks for memory allocation misuse. In this way it is verified that OOM errors do not induce other kinds of memory usage errors.</source>
          <target state="translated">OOM オーバーレイが使用されている場合でも、メモリリーク検出ロジックは動作し続けることに注意してください。これにより、SQLite がメモリ割り当てエラーに遭遇してもメモリリークが発生しないことが確認されます。また、OOM オーバーレイは、メモリ割り当ての不正使用をチェックするインスツルメンテッド・メモリ・アロケータを含む、あらゆる基礎となるメモリ・アロケータで動作することにも注意してください。このようにして、OOM エラーが他の種類のメモリ使用エラーを誘発しないことが検証されています。</target>
        </trans-unit>
        <trans-unit id="a2673a9d4ca364b864416763c5f28c9b8fac9ff0" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">SQLiteが理解できるキーワードの数は、コンパイル時のオプションに依存する可能性があることに注意してください。たとえば、SQLiteが&lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt;オプションを使用してコンパイルされている場合、「VACUUM」はキーワードではありません。また、新しいキーワードがSQLiteの将来のリリースに追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="2d91b980ac2f1529b090c5eabcb20ce64f838c85" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">SQLiteが理解できるキーワードの数は、コンパイル時のオプションに依存する可能性があることに注意してください。たとえば、SQLiteが&lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt;オプションを使用してコンパイルされている場合、「VACUUM」はキーワードではありません。また、新しいキーワードがSQLiteの将来のリリースに追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="4aca65a78510b061ab1efe777d7b5b2943653a08" translate="yes" xml:space="preserve">
          <source>Note that the order of the rules for determining column affinity is important. A column whose declared type is &quot;CHARINT&quot; will match both rules 1 and 2 but the first rule takes precedence and so the column affinity will be INTEGER.</source>
          <target state="translated">カラムの親和性を決定するルールの順序が重要であることに注意してください。宣言された型が &quot;CHARINT &quot;であるカラムは、ルール1と2の両方にマッチしますが、最初のルールが優先されるため、カラムの親和性はINTEGERになります。</target>
        </trans-unit>
        <trans-unit id="1d73e69c69eafce89c99fd09f5dcbc2e6299190a" translate="yes" xml:space="preserve">
          <source>Note that the primary result code is always a part of the extended result code. Given a full 32-bit extended result code, the application can always find the corresponding primary result code merely by extracting the least significant 8 bits of the extended result code.</source>
          <target state="translated">一次結果コードは常に拡張結果コードの一部であることに注意してください。完全な32ビットの拡張結果コードが与えられると、アプリケーションは、拡張結果コードの最下位8ビットを抽出するだけで、対応する主結果コードを常に見つけることができます。</target>
        </trans-unit>
        <trans-unit id="299082c757bfbc2b1a98c9af13620cc48c49d3d4" translate="yes" xml:space="preserve">
          <source>Note that the program for this SELECT query didn't contain the Transaction and Commit instructions used in the INSERT example. Because the SELECT is a read operation that doesn't alter the database, it doesn't require a transaction.</source>
          <target state="translated">このSELECTクエリのプログラムには、INSERTの例で使用したトランザクション命令とコミット命令が含まれていないことに注意してください。SELECTはデータベースを変更しない読み取り操作なので、トランザクションは必要ありません。</target>
        </trans-unit>
        <trans-unit id="f586476195ef53b793699f052ad1af05d3a6c8e4" translate="yes" xml:space="preserve">
          <source>Note that the readfile(X) and writefile(X,Y) functions are extension functions and are not built into the core SQLite library. These routines are available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext/misc/fileio.c&lt;/a&gt; source file in the &lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLite source code repositories&lt;/a&gt;.</source>
          <target state="translated">readfile（X）およびwritefile（X、Y）関数は拡張関数であり、コアSQLiteライブラリに組み込まれていないことに注意してください。これらのルーチンは、&lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLiteソースコードリポジトリ&lt;/a&gt;の&lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext / misc / fileio.c&lt;/a&gt;ソースファイルで&lt;a href=&quot;loadext&quot;&gt;ロード可能な拡張機能&lt;/a&gt;として使用できます。</target>
        </trans-unit>
        <trans-unit id="64553501493418021ca0b221dddc1b5aa622fbc2" translate="yes" xml:space="preserve">
          <source>Note that the result from casting any non-BLOB value into a BLOB and the result from casting any BLOB value into a non-BLOB value may be different depending on whether the database &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; is UTF-8, UTF-16be, or UTF-16le.</source>
          <target state="translated">非BLOB値をBLOBにキャストした結果とBLOB値を非BLOB値にキャストした結果は、データベースの&lt;a href=&quot;pragma#pragma_encoding&quot;&gt;エンコーディング&lt;/a&gt;がUTF-8、UTF-16be、またはUTF-16leのいずれであるかによって異なる場合があることに注意してください。 。</target>
        </trans-unit>
        <trans-unit id="e984670ffac060fe0c3430de1a1c23ffe29028d1" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_apply_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">sqlite3changeset_apply_v2（）APIはまだ&lt;b&gt;実験&lt;/b&gt;段階であり、変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a04165c5ad09a6b0ad2414206038c2e65d87aa51" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_start_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">sqlite3changeset_start_v2（）APIはまだ&lt;b&gt;実験&lt;/b&gt;段階であり、変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6c55c88c2dea7079ec802efa3e99479f764ecf7e" translate="yes" xml:space="preserve">
          <source>Note that the unary *+* operator also removes &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; from an expression, and in some cases this can cause subtle changes in the meaning of an expression. In the example above, if column *x* has &lt;a href=&quot;datatype3#affinity&quot;&gt;TEXT affinity&lt;/a&gt; then the comparison &quot;x=5&quot; will be done as text. But the *+* operator removes the affinity. So the comparison &quot;+x=5&quot; will compare the text in column *x* with the numeric value 5 and will always be false.</source>
          <target state="translated">単項* + *演算子は&lt;a href=&quot;datatype3#affinity&quot;&gt;式&lt;/a&gt;から型の類似性も削除することに注意してください。場合によっては、式の意味に微妙な変化が生じることがあります。上記の例では、列* x *に&lt;a href=&quot;datatype3#affinity&quot;&gt;TEXTアフィニティがある&lt;/a&gt;場合、比較 &quot;x = 5&quot;はテキストとして行われます。ただし、* + *演算子はアフィニティを削除します。したがって、「+ x = 5」の比較では、列* x *のテキストが数値5と比較され、常にfalseになります。</target>
        </trans-unit>
        <trans-unit id="c990d58c5d0bc49b39ec476dafbb19955404bbcd" translate="yes" xml:space="preserve">
          <source>Note that there are paths through the syntax diagrams that are not allowed in practice. Some examples:</source>
          <target state="translated">実際には許可されていない構文図を通るパスがあることに注意してください。いくつかの例があります。</target>
        </trans-unit>
        <trans-unit id="96acc3ff45ab0c01a0b94c0892486dbb72afce32" translate="yes" xml:space="preserve">
          <source>Note that there are two variations of the equals and not equals operators. Equals can be either</source>
          <target state="translated">等号演算子には、等号演算子と等号演算子ではない演算子があります。等号は次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="a67d64fb18ca2294fb42994c6d74eeb61ff03be8" translate="yes" xml:space="preserve">
          <source>Note that this is only a thought experiment. We are not suggesting that OpenDocument be changed. Nor is this article a criticism of the current OpenDocument design. The point of this essay is to suggest ways to improve future file format designs.</source>
          <target state="translated">これはあくまでも思考実験であることに注意してください。私たちは OpenDocument を変更することを提案しているわけではありません。また、この記事は現在の OpenDocument のデザインを批判するものでもありません。このエッセイのポイントは、将来のファイルフォーマットのデザインを改善する方法を提案することです。</target>
        </trans-unit>
        <trans-unit id="99c1505807d577ab62bcd4edbb24d5f3cd06e9f6" translate="yes" xml:space="preserve">
          <source>Note that this problem only occurs if the attempt to acquire the lock resulted in an I/O error. If the lock is simply not granted (because some other thread or process is already holding a conflicting lock) then no corruption will ever occur. We are not aware of any operating systems that will fail with an I/O error while attempting to get a file lock on shared memory. So this is a theoretical problem rather than a real problem. Needless to say, this problem has never been observed in the wild. The problem was discovered while doing stress testing of SQLite in a test harness that simulates I/O errors.</source>
          <target state="translated">この問題は、ロックを取得しようとした結果、I/O エラーが発生した場合にのみ発生することに注意してください。ロックが単に付与されなかった場合(他のスレッドやプロセスが既に競合するロックを保持しているため)、破損は発生しません。共有メモリ上のファイルロックを取得しようとしたときに I/O エラーで失敗するようなオペレーティングシステムはありません。したがって、これは実際の問題ではなく理論上の問題です。言うまでもなく、この問題は実際に観測されたことがありません。この問題は、I/O エラーをシミュレートするテストハーネスで SQLite のストレステストを行っているときに発見されました。</target>
        </trans-unit>
        <trans-unit id="ebff595e74a177f5fa63d87902cc62cb3ce02f96" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp（）&lt;/a&gt;および&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt;と同様に、このルーチンは文字列が一致しない場合、一致時にゼロを返し、ゼロ以外を返すことに注意してください。</target>
        </trans-unit>
        <trans-unit id="0d629b76283bd20b6edf31050b7b9b764c009820" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp（）&lt;/a&gt;および&lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt;と同様に、このルーチンは文字列が一致しない場合、一致時にゼロを返し、ゼロ以外を返すことに注意してください。</target>
        </trans-unit>
        <trans-unit id="c810fa4c8943f66ac3d34092b7e767d31528340e" translate="yes" xml:space="preserve">
          <source>Note that triggers are automatically dropped when the associated table is dropped.</source>
          <target state="translated">関連するテーブルが削除されると、トリガーが自動的に削除されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d606f23ac3535efbf11c3a7516392c25071ecf15" translate="yes" xml:space="preserve">
          <source>Note that when SQLite is compiled with SQLITE_THREADSAFE=0, the code to make SQLite threadsafe is omitted from the build. When this occurs, it is impossible to change the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; at start-time or run-time.</source>
          <target state="translated">SQLiteがSQLITE_THREADSAFE = 0でコンパイルされている場合、SQLiteをスレッドセーフにするコードはビルドから省略されます。これが発生すると、開始時または実行時に&lt;a href=&quot;threadsafe&quot;&gt;スレッドモード&lt;/a&gt;を変更することができません。</target>
        </trans-unit>
        <trans-unit id="32708b7e6e76296f6dad18be6a6d369658183e8b" translate="yes" xml:space="preserve">
          <source>Note that when the SQLITE_DBCONFIG_LEGACY_FILE_FORMAT setting is on, the &lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will fail with an obscure error when attempting to process a table with generated columns and a descending index. This is not considered a bug since SQLite versions 3.3.0 and earlier do not support either generated columns or decending indexes.</source>
          <target state="translated">SQLITE_DBCONFIG_LEGACY_FILE_FORMAT設定がオンの場合、生成された列と降順のインデックスを持つテーブルを処理しようとすると、&lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;コマンドがあいまいなエラーで失敗することに注意してください。SQLiteバージョン3.3.0以前は、生成された列または降順インデックスのいずれもサポートしていないため、これはバグとは見なされません。</target>
        </trans-unit>
        <trans-unit id="3822538f7b251248e21c02ba82556fd2e3a92957" translate="yes" xml:space="preserve">
          <source>Note that when the SQLITE_DBCONFIG_LEGACY_FILE_FORMAT setting is on, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will fail with an obscure error when attempting to process a table with generated columns and a descending index. This is not considered a bug since SQLite versions 3.3.0 and earlier do not support either generated columns or decending indexes.</source>
          <target state="translated">SQLITE_DBCONFIG_LEGACY_FILE_FORMAT設定がオンの場合、生成された列と降順のインデックスを持つテーブルを処理しようとすると、&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;コマンドがあいまいなエラーで失敗することに注意してください。SQLiteバージョン3.3.0以前は、生成された列または降順インデックスのいずれもサポートしていないため、これはバグとは見なされません。</target>
        </trans-unit>
        <trans-unit id="789391b5c680547fd2d7df978b13d5bea4b6c611" translate="yes" xml:space="preserve">
          <source>Note that when the right-hand side of a LIKE or GLOB operator is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement is prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; then the statement is automatically reparsed and recompiled on the first &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call of each run if the binding to the right-hand side parameter has changed since the previous run. This reparse and recompile is essentially the same action that occurs following a schema change. The recompile is necessary so that the query planner can examine the new value bound to the right-hand side of the LIKE or GLOB operator and determine whether or not to employ the optimization described above.</source>
          <target state="translated">LIKEまたはGLOB演算子の右側が&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーターで&lt;/a&gt;あり、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;または&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;を使用してステートメントが準備される場合、ステートメントが自動的に再解析され、各実行の最初の&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;呼び出しで再コンパイルされることに注意してください。右側のパラメーターへのバインドは、前回の実行以降変更されています。この再解析と再コンパイルは、スキーマの変更後に発生するアクションと基本的に同じです。クエリプランナーがLIKEまたはGLOB演算子の右側にバインドされた新しい値を調べて、上記の最適化を採用するかどうかを決定できるように、再コンパイルが必要です。</target>
        </trans-unit>
        <trans-unit id="7aca89c620a18b6fdc63e568bea908a626dcadff" translate="yes" xml:space="preserve">
          <source>Note that when type conversions occur, pointers returned by prior calls to sqlite3_column_blob(), sqlite3_column_text(), and/or sqlite3_column_text16() may be invalidated. Type conversions and pointer invalidations might occur in the following cases:</source>
          <target state="translated">型変換が発生した場合、sqlite3_column_blob(),sqlite3_column_text(),および/または sqlite3_column_text16()の前の呼び出しによって返されたポインタが無効になることがあることに注意してください。以下の場合、型変換やポインタが無効になることがあります。</target>
        </trans-unit>
        <trans-unit id="1368e4859dec1f8b656ae1f17b0c284cfecc238a" translate="yes" xml:space="preserve">
          <source>Note that with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to NORMAL, the checkpoint is the only operation to issue an I/O barrier or sync operation (fsync() on unix or FlushFileBuffers() on windows). If an application therefore runs checkpoint in a separate thread or process, the main thread or process that is doing database queries and updates will never block on a sync operation. This helps to prevent &quot;latch-up&quot; in applications running on a busy disk drive. The downside to this configuration is that transactions are no longer durable and might rollback following a power failure or hard reset.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt;をNORMALに設定すると、チェックポイントがI / Oバリアまたは同期操作（UNIXではfsync（）、WindowsではFlushFileBuffers（））を発行する唯一の操作になることに注意してください。したがって、アプリケーションが別のスレッドまたはプロセスでチェックポイントを実行する場合、データベースクエリと更新を実行しているメインスレッドまたはプロセスが同期操作をブロックすることはありません。これは、ビジーなディスクドライブで実行されているアプリケーションの「ラッチアップ」を防ぐのに役立ちます。この構成の欠点は、トランザクションが永続的でなくなり、電源障害またはハードリセットの後にロールバックされる可能性があることです。</target>
        </trans-unit>
        <trans-unit id="8da0c032621fbb18df4dc03aaa124440bc316a57" translate="yes" xml:space="preserve">
          <source>Note that with ANALYZE the cost estimates are better aligned with reality and algorithm-1 is selected by both NN and N3.</source>
          <target state="translated">ANALYZEでは、コスト推定値がより現実と一致しており、NNとN3の両方でアルゴリズム-1が選択されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="695e607ef01e6db075031ffa227e23ca60904541" translate="yes" xml:space="preserve">
          <source>Note that xBestIndex will always be called before &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;, since the idxNum and idxStr outputs from xBestIndex are required inputs to xFilter. However, there is no guarantee that xFilter will be called following a successful xBestIndex.</source>
          <target state="translated">&lt;a href=&quot;vtab#xfilter&quot;&gt;xBestIndex&lt;/a&gt;からのidxNumおよびidxStr出力はxFilterへの必須入力であるため、xBestIndexは常にxFilterの前に呼び出されることに注意してください。ただし、xBestIndexが成功した後でxFilterが呼び出されるという保証はありません。</target>
        </trans-unit>
        <trans-unit id="d227a38478007bafe1c5681fa0c0259f1628a846" translate="yes" xml:space="preserve">
          <source>Note the &quot;temp.&quot; qualifier before the virtual table name (&quot;stat&quot;). This qualifier causes the virtual table to be temporary - to only exist for the duration of the current database connection. This is the recommended approach.</source>
          <target state="translated">仮想テーブル名 (&quot;stat&quot;)の前に &quot;temp.&quot; という修飾子があることに注意してください。この修飾子により、仮想テーブルは一時的なものとなり、現在のデータベース接続の間だけ存在します。これが推奨されるアプローチです。</target>
        </trans-unit>
        <trans-unit id="984a9d35869a9cec59e40e09a2d60d76afb99304" translate="yes" xml:space="preserve">
          <source>Note the last bullet in particular. The destructor X in sqlite3_set_auxdata(C,N,P,X) might be called immediately, before the sqlite3_set_auxdata() interface even returns. Hence sqlite3_set_auxdata() should be called near the end of the function implementation and the function implementation should not make any use of P after sqlite3_set_auxdata() has been called.</source>
          <target state="translated">特に最後の箇条書きに注意してください。sqlite3_set_auxdata(C,N,P,X)のデストラクタXはsqlite3_set_auxdata()インタフェースが戻る前に呼ばれるかもしれません。したがって、sqlite3_set_auxdata()は関数の実装の終わり近くで呼ばれるべきであり、sqlite3_set_auxdata()が呼ばれた後はPを使ってはいけません。</target>
        </trans-unit>
        <trans-unit id="be13ad345e0dba5ca596ce6f7266fdf09fc32236" translate="yes" xml:space="preserve">
          <source>Note the use of the &lt;a href=&quot;lang_corefunc#quote&quot;&gt;quote() SQL function&lt;/a&gt; in these triggers. The quote() function converts its argument into a form that is appropriate for inclusion in an SQL statement. Numeric values come through unchanged. Single quotes are added before and after strings and any internal single quotes are escaped. BLOB values are rendered using SQL-standard hexadecimal BLOB notation. The use of the quote() function ensures that the SQL statements used to undo and redo are always safe from SQL injection.</source>
          <target state="translated">これらのトリガーでの&lt;a href=&quot;lang_corefunc#quote&quot;&gt;quote（）SQL関数&lt;/a&gt;の使用に注意してください。quote（）関数は、引数をSQLステートメントに含めるのに適した形式に変換します。数値は変更されずに通過します。文字列の前後に単一引用符が追加され、内部の単一引用符はエスケープされます。BLOB値は、SQL標準の16進BLOB表記を使用してレンダリングされます。quote（）関数を使用すると、取り消しとやり直しに使用されるSQLステートメントがSQLインジェクションから常に安全になります。</target>
        </trans-unit>
        <trans-unit id="044b3a09040052b2232feb80c6848441318257d4" translate="yes" xml:space="preserve">
          <source>Note the warnings on the &quot;estimatedRows&quot;, &quot;idxFlags&quot;, and colUsed fields. These fields were added with SQLite versions 3.8.2, 3.9.0, and 3.10.0, respectively. Any extension that reads or writes these fields must first check that the version of the SQLite library in use is greater than or equal to appropriate version - perhaps comparing the value returned from &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; against constants 3008002, 3009000, and/or 3010000. The result of attempting to access these fields in an sqlite3_index_info structure created by an older version of SQLite are undefined.</source>
          <target state="translated">「estimatedRows」、「idxFlags」、およびcolUsedフィールドの警告に注意してください。これらのフィールドは、SQLiteバージョン3.8.2、3.9.0、および3.10.0でそれぞれ追加されました。これらのフィールドを読み書きする拡張機能では、まず、使用中のSQLiteライブラリのバージョンが適切なバージョン以上であることを確認する必要があります。おそらく、&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number（）&lt;/a&gt;から返された値を定数3008002、3009000、3010000 と比較します。古いバージョンのSQLiteによって作成されたsqlite3_index_info構造体のこれらのフィールドにアクセスしようとした結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="49bc1f28a1c9c886ae8bd63cbcbb27c797246229" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;capi3ref&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;capi3ref&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">注：「&lt;small&gt;&lt;i&gt;（exp）&lt;/i&gt;&lt;/small&gt;」でマークされた関数は&lt;a href=&quot;capi3ref&quot;&gt;実験的なもので&lt;/a&gt;あり、名前に&lt;s&gt;取り消し線&lt;/s&gt;が&lt;a href=&quot;capi3ref&quot;&gt;引かれた&lt;/a&gt;関数は非推奨です。</target>
        </trans-unit>
        <trans-unit id="66ee76f5066068620f09c7e62f4bb8c158c87cf7" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;experimental&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;experimental&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">注：「&lt;small&gt;&lt;i&gt;（exp）&lt;/i&gt;&lt;/small&gt;」でマークされた関数は&lt;a href=&quot;experimental&quot;&gt;実験的なもので&lt;/a&gt;あり、名前に&lt;s&gt;取り消し線&lt;/s&gt;が&lt;a href=&quot;experimental&quot;&gt;引かれた&lt;/a&gt;関数は非推奨です。</target>
        </trans-unit>
        <trans-unit id="03b148e28fde4df0887542e9d88b598d5e8f42db" translate="yes" xml:space="preserve">
          <source>Note: Sections 2.0 and 3.0 of this article were added in response to comments on &lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt; and &lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit&lt;/a&gt;.</source>
          <target state="translated">注：この記事のセクション2.0と3.0は、&lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt;と&lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit&lt;/a&gt;へのコメントに応じて追加されました。</target>
        </trans-unit>
        <trans-unit id="85e051b1f236f895d99d48916ab5fd667388aec3" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">注：このメソッドはMacOS X 10.7およびiOSバージョン5.0では無効であり、常にSQLITE_MISUSEを返します。これらのシステムでは、共有キャッシュモードは、ビアごとのデータベース接続を有効にする必要がある&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;と&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHEを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ddf57deb38e4651cb3981116d2b9ec03a6feb885" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">注：このメソッドはMacOS X 10.7およびiOSバージョン5.0では無効であり、常にSQLITE_MISUSEを返します。これらのシステムでは、共有キャッシュモードは、ビアごとのデータベース接続を有効にする必要がある&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;と&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHEを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="b7c62ae6be1885d1c5a81f6a7886c67b36419ed4" translate="yes" xml:space="preserve">
          <source>Notes on the &lt;a href=&quot;optoverview&quot;&gt;query optimizer&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;optoverview&quot;&gt;クエリオプティマイザ&lt;/a&gt;に関する注意事項。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="bb5c89c5cb4409cab6ee44d716c6d95feaaddc62" translate="yes" xml:space="preserve">
          <source>Notice how the LIKE operator is implemented. It is a user-defined function in SQLite, so the address of its function definition is specified in P3. The operand P1 is the number of function arguments for it to take from the stack. In this case the LIKE() function takes 2 arguments. The arguments are taken off the stack in reverse order (right-to-left), so the pattern to match is the top stack element, and the next element is the data to compare. The return value is pushed onto the stack.</source>
          <target state="translated">LIKE 演算子がどのように実装されているかに注目してください。これはSQLiteのユーザー定義関数なので、関数定義のアドレスはP3で指定されています。オペランドP1は、スタックから取得する関数引数の数です。この場合、LIKE()関数は2つの引数を取ります。引数はスタックから逆順(右から左)に取り出されますので、マッチするパターンはスタックの一番上の要素で、次の要素は比較するデータです。戻り値はスタックに押し出されます。</target>
        </trans-unit>
        <trans-unit id="5255c6a9b36d606aac6af8d3dbbceadb0d1f9b02" translate="yes" xml:space="preserve">
          <source>Notice how the query above works: The R*Tree index runs in the outer loop to find entries that are contained within the bounding box of longitude -81..-79.6 and latitude 35.0..36.2. For each object identifier found, SQLite looks up the corresponding entry in the demo_data table. It then uses the boundary field from the demo_data table as a parameter to the contained_in() function and if that function returns true, the objname field from the demo_data table is returned as the next row of query result.</source>
          <target state="translated">上のクエリがどのように動作するかに注目してください。R*Tree インデックスは、経度 -81...-79.6 と緯度 35.0...36.2 のバウンディングボックス内に含まれるエントリを見つけるために外側のループ内で実行されます。見つかった各オブジェクト識別子について、SQLite は demo_data テーブルの対応するエントリを検索します。次に、demo_data テーブルの境界フィールドをパラメータとして contained_in()関数を使用し、その関数が true を返すと、demo_data テーブルの objname フィールドがクエリ結果の次の行として返されます。</target>
        </trans-unit>
        <trans-unit id="3b7384e004cca4a56bb485375c44be1a10c5774f" translate="yes" xml:space="preserve">
          <source>Notice that all other date and time functions can be expressed in terms of strftime():</source>
          <target state="translated">他のすべての日付と時刻の関数は strftime()で表現できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a0897fe8cedb04900939c7986a4c19ddb9b29972" translate="yes" xml:space="preserve">
          <source>Notice that dividing up the content into smaller pieces using an SQLite table gives flexibility to the implementation. The application can choose to read all content into memory at startup. Or it can read just a few pages into memory and keep the rest on disk. Or it can read just single page into memory at a time. And different versions of the application can make different choices without having to make any changes to the file format. Such options are not available when all content is in a single big XML file in a ZIP archive.</source>
          <target state="translated">SQLite テーブルを使用してコンテンツを小さな断片に分割することで、実装に柔軟性を与えることに注意してください。アプリケーションは、起動時にすべてのコンテンツをメモリに読み込むことができます。あるいは、数ページだけをメモリに読み込んで残りをディスクに保存することもできます。あるいは、一度に単一のページだけをメモリに読み込むこともできます。また、アプリケーションの異なるバージョンでは、ファイル形式を変更することなく、異なる選択をすることができます。このようなオプションは、すべてのコンテンツがZIPアーカイブ内の単一の大きなXMLファイルにある場合には利用できません。</target>
        </trans-unit>
        <trans-unit id="8b6637336242d861c3d1aedafa06202a9a576add" translate="yes" xml:space="preserve">
          <source>Notice that the &quot;host&quot; value for the &quot;dummy&quot; record is NULL so the result[] array contains a NULL pointer at that slot.</source>
          <target state="translated">ダミーレコードの &quot;ホスト &quot;の値はNULLなので、result[]配列にはそのスロットにNULLポインタが含まれていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="81da02d10ebbcf526492f91d32dd8afa2884d608" translate="yes" xml:space="preserve">
          <source>Notice that the parameters to functions are now pointers to sqlite3_value structures instead of pointers to strings as in SQLite version 2.X. The following routines are used to extract useful information from these &quot;values&quot;:</source>
          <target state="translated">関数のパラメータがSQLiteバージョン2.Xのように文字列へのポインタではなく、sqlite3_value構造体へのポインタになったことに注目してください。</target>
        </trans-unit>
        <trans-unit id="45ef496d245754f1f4daa860e31545d9feaf1aea" translate="yes" xml:space="preserve">
          <source>Notice that the shared lock is on the operating system disk cache, not on the disk itself. File locks really are just flags within the operating system kernel, usually. (The details depend on the specific OS layer interface.) Hence, the lock will instantly vanish if the operating system crashes or if there is a power loss. It is usually also the case that the lock will vanish if the process that created the lock exits.</source>
          <target state="translated">共有ロックはオペレーティングシステムのディスクキャッシュ上にあり、ディスク自体にはないことに注意してください。ファイルロックは、通常、オペレーティングシステムのカーネル内のフラグに過ぎません (詳細は特定の OS レイヤーインターフェースに依存します)。(詳細は特定の OS レイヤーインターフェースに依存します。)したがって、オペレーティングシステムがクラッシュしたり、電源が切れたりすると、ロックは即座に消えてしまいます。また、ロックを作成したプロセスが終了した場合も、通常はロックは消えます。</target>
        </trans-unit>
        <trans-unit id="f8f4b80268c40011630e5371241e6ab982124215" translate="yes" xml:space="preserve">
          <source>Notice that the tokens in the result set from the fts3tokenize virtual table have been transformed according to the rules of the tokenizer. Since this example used the &quot;porter&quot; tokenizer, the &quot;This&quot; token was converted into &quot;thi&quot;. If the original text of the token is desired, it can be retrieved using the &quot;start&quot; and &quot;end&quot; columns with the &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr()&lt;/a&gt; function. For example:</source>
          <target state="translated">fts3tokenize仮想テーブルからの結果セット内のトークンは、トークナイザーのルールに従って変換されていることに注意してください。この例では「porter」トークナイザーを使用したため、「This」トークンは「thi」に変換されました。トークンの元のテキストが必要な場合は、&lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr（）&lt;/a&gt;関数で「start」列と「end」列を使用して取得できます。例えば：</target>
        </trans-unit>
        <trans-unit id="af54971d34d4b499061179fcac4a7f0e1fee4c0f" translate="yes" xml:space="preserve">
          <source>Notice the similarity between the ListRead and Next instructions. Both operations work according to this rule:</source>
          <target state="translated">ListRead 命令と Next 命令の類似性に注目してください。どちらの操作もこのルールに従って動作します。</target>
        </trans-unit>
        <trans-unit id="7cec2e96076ffe89a48a9bb0d641ff84dbe2e0a2" translate="yes" xml:space="preserve">
          <source>Notice too that there is a tradeoff between average read performance and average write performance. To maximize the read performance, one wants to keep the WAL as small as possible and hence run checkpoints frequently, perhaps as often as every COMMIT. To maximize write performance, one wants to amortize the cost of each checkpoint over as many writes as possible, meaning that one wants to run checkpoints infrequently and let the WAL grow as large as possible before each checkpoint. The decision of how often to run checkpoints may therefore vary from one application to another depending on the relative read and write performance requirements of the application. The default strategy is to run a checkpoint once the WAL reaches 1000 pages and this strategy seems to work well in test applications on workstations, but other strategies might work better on different platforms or for different workloads.</source>
          <target state="translated">平均的な読み込み性能と平均的な書き込み性能の間にはトレードオフがあることにも注意してください。読み込み性能を最大化するためには、WALを可能な限り小さくしたいので、チェックポイントを頻繁に、おそらくCOMMITごとに実行するのと同じくらいの頻度で実行したいと考えます。書き込み性能を最大化するには、各チェックポイントのコストを可能な限り多くの書き込みに渡って償却したいと考えます。したがって、チェックポイントをどのくらいの頻度で実行するかの決定は、アプリケーションの相対的な読み取りと書き込みのパフォーマンス要件に応じて、アプリケーションごとに異なる場合があります。デフォルトの戦略は、WAL が 1000 ページに達したらチェックポイントを実行するというもので、この戦略はワークステーション上のテストアプリケーションではうまく機能しているようですが、他の戦略は異なるプラットフォームや異なるワークロードではよりうまく機能するかもしれません。</target>
        </trans-unit>
        <trans-unit id="d969bb722b85b5d0915700d40ff32bef3f77944d" translate="yes" xml:space="preserve">
          <source>Now compiles on MSVC++6 again</source>
          <target state="translated">MSVC++6で再びコンパイルできるようになりました。</target>
        </trans-unit>
        <trans-unit id="6c31ef81ebda278449acfecbdc59bc58b62b9f81" translate="yes" xml:space="preserve">
          <source>Now compiles on Solaris and OpenBSD and other Unix variants that lack the fdatasync() function</source>
          <target state="translated">Solaris、OpenBSD、および fdatasync()関数を欠いた他の Unix バリアントでのコンパイルが可能になりました。</target>
        </trans-unit>
        <trans-unit id="d8eeae1a57da5c7c1fc46f998bfb914d868defe3" translate="yes" xml:space="preserve">
          <source>Now consider a query to find the names of everyone in the organization that is 180cm tall or taller:</source>
          <target state="translated">では、身長180cm以上の組織内の全員の名前を検索するクエリを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="cace99b617f1285adb8e73b73b38a21bf398149e" translate="yes" xml:space="preserve">
          <source>Now consider the case where M and N are both 3500. Alice nodes are abundant. But suppose each of these nodes is connected by only one or two edges. In this case, option 2 is preferred. With option 2, the outer loop still has to run 3500 times, but the middle loop only runs once or twice for each outer loop and the inner loop will only run once for each middle loop, if at all. So the total number of iterations of the inner loop is around 7000. Option 1, on the other hand, has to run both its outer loop and its middle loop 3500 times each, resulting in 12 million iterations of the middle loop. Thus in the second scenario, option 2 is nearly 2000 times faster than option 1.</source>
          <target state="translated">では、MとNがともに3500の場合を考えてみましょう。アリスノードは豊富にあります。しかし、これらのノードのそれぞれが1つか2つの辺だけでつながっているとします。この場合、オプション2が好ましい。オプション2では、外側のループはまだ3500回実行しなければなりませんが、中間のループは外側のループごとに1回か2回しか実行しませんし、内側のループは中間のループごとに1回しか実行しません(全く実行しない場合)。つまり、内側ループの総反復回数は7000回程度になります。一方、オプション1の場合は、外側ループと中間ループをそれぞれ3500回ずつ実行しなければならず、結果として中間ループの反復回数は1200万回になります。このように、2番目のシナリオでは、オプション2はオプション1の2000倍近く速くなります。</target>
        </trans-unit>
        <trans-unit id="ddfe6464a41b67622d5429681d09c2e30ec73502" translate="yes" xml:space="preserve">
          <source>Now it is time to make the private, custom modifications to SQLite which are the whole point of this exercise. Switch to the private branch (if you are not already there) using the &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; command, then bring up the source files in your text editor and make whatever changes you want to make. Once you have finished making changes, commit those changes using this command:</source>
          <target state="translated">これで、この演習の要点であるSQLiteにプライベートなカスタム変更を加える時がきました。&quot; &lt;code&gt;fossil update private&lt;/code&gt; &quot;コマンドを使用して（まだそこにいない場合）プライベートブランチに切り替え、テキストエディターでソースファイルを表示して、必要な変更を行います。変更が完了したら、次のコマンドを使用してそれらの変更をコミットします。</target>
        </trans-unit>
        <trans-unit id="421feb72f2bd97fb759d08871988b6f039784dca" translate="yes" xml:space="preserve">
          <source>Now let's look at how this index will be used. Consider the following query:</source>
          <target state="translated">では、このインデックスがどのように使われるのか見てみましょう。次のクエリを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="470c0db4772f894a123be1434e95e5d5a6304ade" translate="yes" xml:space="preserve">
          <source>Now suppose the user.phone field contains plain text if the user has only a single phone number and a JSON array if the user has multiple phone numbers. The same question is posed: &quot;Which users have a phone number in the 704 area code?&quot; But now the json_each() function can only be called for those users that have two or more phone numbers since json_each() requires well-formed JSON as its first argument:</source>
          <target state="translated">さて、user.phoneフィールドには、ユーザーが電話番号を1つだけ持っている場合はプレーンテキストが含まれ、ユーザーが複数の電話番号を持っている場合はJSON配列が含まれているとします。同じ質問をします。&quot;どのユーザーが704市外局番に電話番号を持っていますか?&quot; しかし、json_each()は第一引数として整形された JSON を必要とするため、json_each()関数は 2 つ以上の電話番号を持つユーザーに対してのみ呼び出すことができるようになりました。</target>
        </trans-unit>
        <trans-unit id="f22ea5fd82bf1b044f7951c4c771bd645f73f8d1" translate="yes" xml:space="preserve">
          <source>Now that the public and private branches are different, you can run the &quot;&lt;code&gt;fossil update trunk&lt;/code&gt;&quot; and &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; commands and see that fossil really does change the files in the checkout as you switch back and forth between branches.</source>
          <target state="translated">パブリックブランチとプライベートブランチが異なるため、「 &lt;code&gt;fossil update trunk&lt;/code&gt; 」コマンドと「 &lt;code&gt;fossil update private&lt;/code&gt; 」コマンドを実行して、ブランチ間を切り替えると、チェックアウト内のファイルがfossilによって実際に変更されることがわかります。</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="5b7d454836a77f93829b713b5a5d0e3045934959" translate="yes" xml:space="preserve">
          <source>Null-indicator is an optional string that indicates a column value is null. The default is an empty string. Note that column-separator and null-indicator are optional positional arguments; if null-indicator is specified, a column-separator argument must be specified and precede the null-indicator argument.</source>
          <target state="translated">Null-indicatorは、列の値がNULLであることを示すオプションの文字列です。デフォルトは空の文字列です。column-separatorとnull-indicatorはオプションの位置引数であることに注意してください。null-indicatorが指定されている場合は、column-separator引数を指定し、null-indicator引数の前に指定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="a37aacd80c708abde1a03c3d5afe5b13fd00cfc3" translate="yes" xml:space="preserve">
          <source>NullRow</source>
          <target state="translated">NullRow</target>
        </trans-unit>
        <trans-unit id="eb0f5a21c19313cdefd12cf556538964ec1b60c1" translate="yes" xml:space="preserve">
          <source>Number Of Columns In A Result Set</source>
          <target state="translated">結果セットのカラム数</target>
        </trans-unit>
        <trans-unit id="29a85c89c3b665d61a62026778cb1a84d89e00ac" translate="yes" xml:space="preserve">
          <source>Number Of SQL Parameters</source>
          <target state="translated">SQLパラメータの数</target>
        </trans-unit>
        <trans-unit id="a780fc260fcaca2d5e967db2577edefc7720d5d2" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have already been backfilled into the database by prior checkpoints</source>
          <target state="translated">事前のチェックポイントで既にデータベースにバックフィルされているWALフレームの数</target>
        </trans-unit>
        <trans-unit id="2a37475de2d92c9f14f2ea5c38819cea5766eaa7" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have attempted to be backfilled but which might not have been backfilled successfully.</source>
          <target state="translated">バックフィルが試みられたが、バックフィルが成功しなかった可能性のあるWALフレームの数。</target>
        </trans-unit>
        <trans-unit id="3b125f191573ae8fecea26a8fd5c1f85866a1737" translate="yes" xml:space="preserve">
          <source>Number of bytes of payload</source>
          <target state="translated">ペイロードのバイト数</target>
        </trans-unit>
        <trans-unit id="3bacc7e3374d56ead644519a8de907aa11ddb984" translate="yes" xml:space="preserve">
          <source>Number of cells on the current page or btree</source>
          <target state="translated">現在のページまたはbtreeのセル数</target>
        </trans-unit>
        <trans-unit id="93e4ee2802912bc9542ff03c865140e0975aff48" translate="yes" xml:space="preserve">
          <source>Number of columns in a result set</source>
          <target state="translated">結果セットの列数</target>
        </trans-unit>
        <trans-unit id="2b00ff36e6009d3918fa275ec909bb841ed966c0" translate="yes" xml:space="preserve">
          <source>Number of valid and committed frames in the WAL file.</source>
          <target state="translated">WALファイル内の有効なフレーム数とコミットされたフレーム数。</target>
        </trans-unit>
        <trans-unit id="ff84d5af979f34eb1211b7993c06c6a08d3a99e3" translate="yes" xml:space="preserve">
          <source>Number-of-pages</source>
          <target state="translated">Number-of-pages</target>
        </trans-unit>
        <trans-unit id="2f32b7f17e88cd173c751d8cdc7e8c19cbcaed9f" translate="yes" xml:space="preserve">
          <source>Numeric and text types make a difference for the DISTINCT keyword too:</source>
          <target state="translated">DISTINCTキーワードでも、数値型とテキスト型の違いがあります。</target>
        </trans-unit>
        <trans-unit id="c37c2e33a0fa0b90c0fc1ac3254fa39cce3fa242" translate="yes" xml:space="preserve">
          <source>Numeric values (serial types 1 through 9) sort after NULLs and in numeric order.</source>
          <target state="translated">数値(シリアルタイプ1~9)は、NULLの後に数値順にソートします。</target>
        </trans-unit>
        <trans-unit id="16bebfa71033ff1ade58c6f0e6b14f281dfaba25" translate="yes" xml:space="preserve">
          <source>Numeric values sort next in numerical order</source>
          <target state="translated">数値は数値順に次のようにソートされます。</target>
        </trans-unit>
        <trans-unit id="0f5fd79254e55ff1fbee2cde5598536b3ec7dea6" translate="yes" xml:space="preserve">
          <source>Numerous bug fixes and documentation updates.</source>
          <target state="translated">多数のバグ修正とドキュメントの更新。</target>
        </trans-unit>
        <trans-unit id="dc11c061204c46d3ddd7e450955d3893423efff5" translate="yes" xml:space="preserve">
          <source>Numerous code optimizations, specially optimizations designed to make the code footprint smaller.</source>
          <target state="translated">多数のコード最適化、コードフットプリントを小さくするために設計された特別な最適化。</target>
        </trans-unit>
        <trans-unit id="1608a6f49ab43b4c01022e79721183478aa81607" translate="yes" xml:space="preserve">
          <source>Numerous minor bug fixes</source>
          <target state="translated">数々のマイナーなバグ修正</target>
        </trans-unit>
        <trans-unit id="59f5ab25bf1e5a211679172dc18a637343443a9e" translate="yes" xml:space="preserve">
          <source>Numerous other performance enhancements</source>
          <target state="translated">その他多数の性能強化</target>
        </trans-unit>
        <trans-unit id="957b6bbcded8f49f8684b4d5e7a64d7f3a67b7a1" translate="yes" xml:space="preserve">
          <source>OCELOT</source>
          <target state="translated">OCELOT</target>
        </trans-unit>
        <trans-unit id="7481b4b2758d96d6c2ef2af6709c88460dc01560" translate="yes" xml:space="preserve">
          <source>ODP - The Open Document presentation format used by OpenOffice and others</source>
          <target state="translated">ODP-OpenOffice などで使用されているオープンドキュメントのプレゼンテーションフォーマット</target>
        </trans-unit>
        <trans-unit id="2a2888f26efa625ef4871988ca874037d8ea156c" translate="yes" xml:space="preserve">
          <source>ODT - The Open Document format used by OpenOffice and others</source>
          <target state="translated">ODT-OpenOffice などで使用されているオープンドキュメント形式です。</target>
        </trans-unit>
        <trans-unit id="0cf81c47abad8b8dc52569f7edcc1b5b2d3511f9" translate="yes" xml:space="preserve">
          <source>OF</source>
          <target state="translated">OF</target>
        </trans-unit>
        <trans-unit id="acd2081fe0965992b6934d49ae30eed38ac749e0" translate="yes" xml:space="preserve">
          <source>OFFSET</source>
          <target state="translated">OFFSET</target>
        </trans-unit>
        <trans-unit id="4f963961751f0891a23f93bba4882f74f0ade805" translate="yes" xml:space="preserve">
          <source>OFFSET clause ignored on queries without a FROM clause. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</source>
          <target state="translated">FROM句のないクエリでは、OFFSET句は無視されます。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80f83fb7443c61c317b946841f59c0be3182f095" translate="yes" xml:space="preserve">
          <source>OFFSET gives the correct answer. However, OFFSET requires time proportional to the offset value. What really happens with &quot;LIMIT x OFFSET y&quot; is that SQLite computes the query as &quot;LIMIT x+y&quot; and discards the first y values without returning them to the application. So as the window scrolls down toward the bottom of a long list, and the y value becomes larger and larger, successive offset computations take more and more time.</source>
          <target state="translated">OFFSETは正しい答えを与えます。しかし、OFFSETはオフセット値に比例した時間を必要とします。LIMIT x OFFSET y &quot;で実際に何が起こるかというと、SQLiteはクエリを &quot;LIMIT x+y &quot;として計算し、最初のy値をアプリケーションに返さずに破棄します。そのため、ウィンドウが長いリストの一番下に向かって下にスクロールし、y の値がどんどん大きくなっていくと、連続したオフセットの計算に時間がかかります。</target>
        </trans-unit>
        <trans-unit id="9c108e42d4ae43fd2c4c857619aacef018184aee" translate="yes" xml:space="preserve">
          <source>OLD references are valid</source>
          <target state="translated">古い参照は有効です。</target>
        </trans-unit>
        <trans-unit id="387d7a59dbaaef002e0f9ac69ecd4443b9c5cef2" translate="yes" xml:space="preserve">
          <source>ON</source>
          <target state="translated">ON</target>
        </trans-unit>
        <trans-unit id="32bb503cc80e713ad933b48ce9053610aae7664e" translate="yes" xml:space="preserve">
          <source>ON CONFLICT clause</source>
          <target state="translated">オンコンフリクト句</target>
        </trans-unit>
        <trans-unit id="c13d037157d8eb7ac7ee7af0a3380941dabf2fa2" translate="yes" xml:space="preserve">
          <source>OOM testing is accomplished by simulating OOM errors. SQLite allows an application to substitute an alternative malloc() implementation using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;,...) interface. The TCL and TH3 test harnesses are both capable of inserting a modified version of malloc() that can be rigged to fail after a certain number of allocations. These instrumented mallocs can be set to fail only once and then start working again, or to continue failing after the first failure. OOM tests are done in a loop. On the first iteration of the loop, the instrumented malloc is rigged to fail on the first allocation. Then some SQLite operation is carried out and checks are done to make sure SQLite handled the OOM error correctly. Then the time-to-failure counter on the instrumented malloc is increased by one and the test is repeated. The loop continues until the entire operation runs to completion without ever encountering a simulated OOM failure. Tests like this are run twice, once with the instrumented malloc set to fail only once, and again with the instrumented malloc set to fail continuously after the first failure.</source>
          <target state="translated">OOMテストは、OOMエラーをシミュレートすることによって行われます。 SQLiteは、アプリケーションが&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;を使用して代替のmalloc（）実装を置き換えることを可能にします、...） インターフェース。 TCLとTH3のテストハーネスはどちらも、特定の数の割り当て後に失敗するようにリギングできるmalloc（）の変更バージョンを挿入できます。これらのインストルメント化されたmallocは、1回だけ失敗してから再び作業を開始するか、最初の失敗後に失敗し続けるように設定できます。 OOMテストはループで実行されます。ループの最初の反復で、インストルメント化されたmallocは、最初の割り当てで失敗するようにリギングされます。次に、いくつかのSQLite操作が実行され、SQLiteがOOMエラーを正しく処理したことを確認するためのチェックが行われます。次に、インストルメント化されたmallocの障害までの時間カウンターを1つ増やし、テストを繰り返します。ループは、シミュレーション全体のOOM障害に遭遇することなく、操作全体が完了するまで実行されます。このようなテストは2回実行され、一度、インストルメント化されたmallocが1回だけ失敗するように設定し、インストルメント化mallocを設定して、最初の失敗の後に継続的に失敗するように設定します。</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="683e61c81d390d130002106c2c28e827414b7056" translate="yes" xml:space="preserve">
          <source>ORDER</source>
          <target state="translated">ORDER</target>
        </trans-unit>
        <trans-unit id="2164bde64d5e67a9aad0e7c0543250365dc40e72" translate="yes" xml:space="preserve">
          <source>ORDER BY</source>
          <target state="translated">並び順</target>
        </trans-unit>
        <trans-unit id="e4ec6dd8b3c32fb2c490ae23010139de3ea19166" translate="yes" xml:space="preserve">
          <source>ORDER BY and GROUP BY now use bounded memory</source>
          <target state="translated">ORDER BYとGROUP BYでは、制限付きメモリを使用するようになりました。</target>
        </trans-unit>
        <trans-unit id="f9252c387c5a364e0aa75e161fd6ca4b31550d60" translate="yes" xml:space="preserve">
          <source>ORDER BY ignored if the query has an identical GROUP BY. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</source>
          <target state="translated">クエリに同じGROUP BYがある場合、ORDER BYは無視されます。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d00407a3fb0d8ad7b8bcf4535e5d986d53520d0" translate="yes" xml:space="preserve">
          <source>ORDER BY works on subselects</source>
          <target state="translated">ORDER BY はサブセレクトで動作します。</target>
        </trans-unit>
        <trans-unit id="fb1eb08d2d3f0a79b8449be8ce9ee77050e088a5" translate="yes" xml:space="preserve">
          <source>OS Interface</source>
          <target state="translated">OSインタフェース</target>
        </trans-unit>
        <trans-unit id="7ea1a5ba1dffba576fe0a188bb466f1a65ef5c2d" translate="yes" xml:space="preserve">
          <source>OS Interface File Virtual Methods Object</source>
          <target state="translated">OSインタフェースファイル仮想メソッドオブジェクト</target>
        </trans-unit>
        <trans-unit id="2fdd9f0dd04e20b2da0185c9864ac62e0fd49b33" translate="yes" xml:space="preserve">
          <source>OS Interface Object</source>
          <target state="translated">OSインタフェースオブジェクト</target>
        </trans-unit>
        <trans-unit id="e502b880ac4721322e02bb29b5215f15ab6c97e9" translate="yes" xml:space="preserve">
          <source>OS Interface Open File Handle</source>
          <target state="translated">OSインタフェースオープンファイルハンドル</target>
        </trans-unit>
        <trans-unit id="1bea0dbc1c9e6f1262f42405074e1a4e5f89e1c4" translate="yes" xml:space="preserve">
          <source>OSS Fuzz no longer finds historical bugs in SQLite. But it is still running and does occasionally find issues in new development check-ins. Examples: &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=c422afb507dc8757&quot;&gt;[1]&lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=0a2eb949f8a759e5&quot;&gt;[2]&lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=62f2235adf796c72&quot;&gt;[3]&lt;/a&gt;.</source>
          <target state="translated">OSS Fuzzは、SQLiteの過去のバグを検出しなくなりました。ただし、まだ実行中であり、新しい開発チェックインで問題が発生することがあります。例：&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=c422afb507dc8757&quot;&gt;[1] &lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=0a2eb949f8a759e5&quot;&gt;[2] &lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=62f2235adf796c72&quot;&gt;[3]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dee9889ad644e6e58468f0ff85f3a57aa76cfbd9" translate="yes" xml:space="preserve">
          <source>OTHERS</source>
          <target state="translated">OTHERS</target>
        </trans-unit>
        <trans-unit id="a032f6607e24aa99492871d19a553d714048e163" translate="yes" xml:space="preserve">
          <source>OUTER</source>
          <target state="translated">OUTER</target>
        </trans-unit>
        <trans-unit id="cc11826689203b888f22525a7551a5472c324526" translate="yes" xml:space="preserve">
          <source>OVER</source>
          <target state="translated">OVER</target>
        </trans-unit>
        <trans-unit id="829a2c0005fc7d37eb660c0d5cde206b5192f790" translate="yes" xml:space="preserve">
          <source>Obey in all things the commands of those whom God has placed in authority over you even though they (which God forbid) should act otherwise, mindful of the Lord's precept, &quot;Do what they say, but not what they do.&quot;</source>
          <target state="translated">たとえ彼らが(神が禁じている)他の行動をとることがあっても、「彼らが言うことをして、彼らがすることをしてはならない」という主の戒めに注意して、神があなたの上に権威を置かれた人の命令にすべてのことで従いなさい。</target>
        </trans-unit>
        <trans-unit id="a21a5206c75e38db5a2f38df79e6283758ee658a" translate="yes" xml:space="preserve">
          <source>Object-Oriented Design</source>
          <target state="translated">オブジェクト指向設計</target>
        </trans-unit>
        <trans-unit id="898a9f4f224c827df0fb00ecec65822c23a3936e" translate="yes" xml:space="preserve">
          <source>Object-Oriented is a design pattern, not a programming language. You can do object-oriented programming in any language you want, including assembly language. Some languages (ex: C++ or Java) make object-oriented easier. But you can still do object-oriented programming in languages like C.</source>
          <target state="translated">オブジェクト指向はデザインパターンであって、プログラミング言語ではありません。アセンブリ言語を含め、どんな言語でもオブジェクト指向プログラミングを行うことができます。いくつかの言語(例:C++やJava)はオブジェクト指向をより簡単にしています。しかし、C言語のような言語でもオブジェクト指向プログラミングはできます。</target>
        </trans-unit>
        <trans-unit id="1e6159d8c90870c6430155592639731dac8033a3" translate="yes" xml:space="preserve">
          <source>Object-oriented is not the only valid design pattern. Many programmers have been taught to think purely in terms of objects. And, to be fair, objects are often a good way to decompose a problem. But objects are not the only way, and are not always the best way to decompose a problem. Sometimes good old procedural code is easier to write, easier to maintain and understand, and faster than object-oriented code.</source>
          <target state="translated">オブジェクト指向だけが有効な設計パターンではありません。多くのプログラマは、純粋にオブジェクトの観点から考えるように教えられてきました。そして、確かに、オブジェクトは問題を分解するのに良い方法であることが多い。しかし、オブジェクトは唯一の方法ではありませんし、問題を分解する最良の方法とは限りません。古き良き手続き的なコードの方が、オブジェクト指向のコードよりも書きやすく、メンテナンスや理解が容易で、高速であることもあります。</target>
        </trans-unit>
        <trans-unit id="ea838bb1557d80ce2bdbf51816fc7a1525503976" translate="yes" xml:space="preserve">
          <source>Objects:</source>
          <target state="translated">Objects:</target>
        </trans-unit>
        <trans-unit id="3a36347e6c9b66b32ae45cd886e8708db38d062b" translate="yes" xml:space="preserve">
          <source>Obscure bug fix on triggers (&lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt;).</source>
          <target state="translated">トリガーの不明瞭なバグ修正（&lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="06705e47733fa2d26527ca5b13fe92c1b7ca1944" translate="yes" xml:space="preserve">
          <source>Obsolete Documents</source>
          <target state="translated">廃止された文書</target>
        </trans-unit>
        <trans-unit id="adcd55329b6153adb94eaf8a12d01ba2bc7cea95" translate="yes" xml:space="preserve">
          <source>Obtain A Composite Changeset From A Changegroup</source>
          <target state="translated">チェンジグループからのコンポジット チェンジセットの取得</target>
        </trans-unit>
        <trans-unit id="f036e380a093cadb7b7384e4b591b8c75c1ba145" translate="yes" xml:space="preserve">
          <source>Obtain Aggregate Function Context</source>
          <target state="translated">集計関数コンテキストの取得</target>
        </trans-unit>
        <trans-unit id="e79fb280b93973e6bfe3f8e79ba72b5b038ba1fa" translate="yes" xml:space="preserve">
          <source>Obtain Conflicting Row Values From A Changeset Iterator</source>
          <target state="translated">チェンジセット イテレータからの矛盾する行値の取得</target>
        </trans-unit>
        <trans-unit id="d4c8c29e25fb3ccc649578fec3be2c67a658b123" translate="yes" xml:space="preserve">
          <source>Obtain The Current Operation From A Changeset Iterator</source>
          <target state="translated">チェンジセット イテレータからの現在の操作の取得</target>
        </trans-unit>
        <trans-unit id="7ada95f817f8fc624dbadc0c0f495b244a8d38b3" translate="yes" xml:space="preserve">
          <source>Obtain The Primary Key Definition Of A Table</source>
          <target state="translated">表の主キー定義の取得</target>
        </trans-unit>
        <trans-unit id="2f0f8596ef7c82c2d68f88fe0c2c42b22b20b24e" translate="yes" xml:space="preserve">
          <source>Obtain Values For URI Parameters</source>
          <target state="translated">URIパラメータの値の取得</target>
        </trans-unit>
        <trans-unit id="e719cf57b48331ec73c3d09816f240ac71d990d4" translate="yes" xml:space="preserve">
          <source>Obtain a PENDING lock and then an EXCLUSIVE lock on the database file. If other processes still have SHARED locks, the writer might have to wait until those SHARED locks clear before it is able to obtain an EXCLUSIVE lock.</source>
          <target state="translated">データベースファイルのPENDINGロックとEXCLUSIVEロックを取得します。他のプロセスがまだSHAREDロックを持っている場合、ライタはEXCLUSIVEロックを取得できるようになる前に、SHAREDロックがクリアされるまで待たなければならないかもしれません。</target>
        </trans-unit>
        <trans-unit id="c4c184719398e2fd529d288f83e902aa72fdd7b4" translate="yes" xml:space="preserve">
          <source>Obtain a buffer containing a changeset (or patchset) representing the current contents of the changegroup. If the inputs to the changegroup were themselves changesets, the output is a changeset. Or, if the inputs were patchsets, the output is also a patchset.</source>
          <target state="translated">チェンジグループの現在の内容を表すチェンジセット(またはパッチセット)を含むバッファを取得します。changegroupへの入力がそれ自体がチェンジセットであった場合、出力はチェンジセットになります。あるいは、入力がパッチセットであった場合、出力はパッチセットでもあります。</target>
        </trans-unit>
        <trans-unit id="0ad736b5bee2570f5cbf619854f8b97d9b6134d1" translate="yes" xml:space="preserve">
          <source>Obtain a changeset containing changes to the tables attached to the session object passed as the first argument. If successful, set *ppChangeset to point to a buffer containing the changeset and *pnChangeset to the size of the changeset in bytes before returning SQLITE_OK. If an error occurs, set both *ppChangeset and *pnChangeset to zero and return an SQLite error code.</source>
          <target state="translated">第一引数として渡されたセッション・オブジェクトにアタッチされたテーブルの変更を含むチェンジセットを取得します。成功した場合、*ppChangesetをチェンジセットを含むバッファを指すように設定し、*pnChangesetをチェンジセットのサイズをバイト単位で設定してからSQLITE_OKを返します。エラーが発生した場合、*ppChangeset と *pnChangeset の両方をゼロに設定し、SQLite エラー・コードを返します。</target>
        </trans-unit>
        <trans-unit id="4304c4d08f4f900e2ab1ec29540131e8bf87ae39" translate="yes" xml:space="preserve">
          <source>Obtain a lock on a particular table. This instruction is only used when the shared-cache feature is enabled.</source>
          <target state="translated">特定のテーブルのロックを取得します。この命令は、共有キャッシュ機能が有効な場合にのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="35cc8c81bb0ab78babd3f65cb1b473a29bd69034" translate="yes" xml:space="preserve">
          <source>Obtain an EXCLUSIVE lock on the database file and make sure all memory changes have been written to the database file using the algorithm of steps 1-3 above.</source>
          <target state="translated">データベースファイルのEXCLUSIVEロックを取得し、上記の手順1-3のアルゴリズムを使用して、すべてのメモリ変更がデータベースファイルに書き込まれていることを確認します。</target>
        </trans-unit>
        <trans-unit id="edc981514ab58076de28ce864d46ccc2641ec1d0" translate="yes" xml:space="preserve">
          <source>Obtain new.* Values From A Changeset Iterator</source>
          <target state="translated">変更セット・イテレータからの new.*値の取得</target>
        </trans-unit>
        <trans-unit id="c31b9f4e355939157fe39f17fcb0e54282736c63" translate="yes" xml:space="preserve">
          <source>Obtain old.* Values From A Changeset Iterator</source>
          <target state="translated">変更セット・イテレータからの old.*値の取得</target>
        </trans-unit>
        <trans-unit id="d399842fa2ae120f608cae0543637da5b44e2b8c" translate="yes" xml:space="preserve">
          <source>Obtain the latest SQLite code from fossil.</source>
          <target state="translated">fossilから最新のSQLiteコードを取得します。</target>
        </trans-unit>
        <trans-unit id="9ed23644c9e9a46df1cd037be0519be726230e11" translate="yes" xml:space="preserve">
          <source>Obtaining SQL Values</source>
          <target state="translated">SQL値の取得</target>
        </trans-unit>
        <trans-unit id="ffe740a4611067b4b4dd0b5b7a28183003203956" translate="yes" xml:space="preserve">
          <source>Obtaining the</source>
          <target state="translated">の取得</target>
        </trans-unit>
        <trans-unit id="a8fbf19c89308087d70d289986f946de344868c9" translate="yes" xml:space="preserve">
          <source>Obtains the mutex.</source>
          <target state="translated">ミューテックスを取得します。</target>
        </trans-unit>
        <trans-unit id="974debb0f023f79fb3eec2db47da68008b639181" translate="yes" xml:space="preserve">
          <source>Occasionally, a serious problem is found and a small &quot;patch&quot; release must be made against a regular maintenance release. Patch are distinct from maintenance releases in that the number of lines of code changed from the previous release is very small. Every effort is made to avoid patch releases by making sure that maintenance releases are bug free.</source>
          <target state="translated">時折、深刻な問題が発見され、通常のメンテナンスリリースに対して小さな「パッチ」リリースを行わなければならないことがあります。パッチはメンテナンスリリースとは異なり、以前のリリースから変更されたコードの行数が非常に少ないという点で区別されます。メンテナンスリリースがバグフリーであることを確認することで、パッチリリースを避けるためのあらゆる努力がなされています。</target>
        </trans-unit>
        <trans-unit id="10b7fae72f94602297b15a7cf850a8e1ee7b4b31" translate="yes" xml:space="preserve">
          <source>Of course, ANALYZE only works effectively if you have a significant amount of content in your database in the first place. When creating a new database that you expect to accumulate a lot of data, you can run the command &quot;ANALYZE sqlite_master&quot; to create the SQLITE_STAT1 table, then prepopulate the SQLITE_STAT1 table (using ordinary INSERT statements) with content that describes a typical database for your application - perhaps content that you extracted after running ANALYZE on a well-populated template database in the lab.</source>
          <target state="translated">もちろん、ANALYZEが有効に機能するのは、そもそもデータベースにかなりの量のコンテンツが蓄積されている場合に限られます。多くのデータを蓄積することが予想される新しいデータベースを作成する場合、&quot;ANALYZE sqlite_master &quot;コマンドを実行してSQLITE_STAT1テーブルを作成し、アプリケーションの典型的なデータベースを記述したコンテンツでSQLITE_STAT1テーブルを事前に埋め込んで(通常のINSERT文を使用して)おくことができます。</target>
        </trans-unit>
        <trans-unit id="3d4796f0a34c568634b9634297a83ac77168e0e1" translate="yes" xml:space="preserve">
          <source>Of course, ANALYZE only works effectively if you have a significant amount of content in your database in the first place. When creating a new database that you expect to accumulate a lot of data, you can run the command &quot;ANALYZE sqlite_schema&quot; to create the SQLITE_STAT1 table, then prepopulate the SQLITE_STAT1 table (using ordinary INSERT statements) with content that describes a typical database for your application - perhaps content that you extracted after running ANALYZE on a well-populated template database in the lab.</source>
          <target state="translated">もちろん、analyzeが有効に機能するのは、そもそもデータベースにかなりの量のコンテンツが蓄積されている場合に限られます。多くのデータを蓄積することが予想される新しいデータベースを作成する場合、&quot;ANALYZE sqlite_schema &quot;コマンドを実行してSQLITE_STAT1テーブルを作成し、(通常のINSERT文を使用して)SQLITE_STAT1テーブルにアプリケーションの典型的なデータベースを記述したコンテンツを事前に登録しておくことができます-おそらくラボでよく登録されたテンプレートデータベースでANALYZEを実行した後に抽出したコンテンツです。</target>
        </trans-unit>
        <trans-unit id="79c23fc170f4a6f6a03298037f6a0ed97740fe0f" translate="yes" xml:space="preserve">
          <source>Of course, an error may occur while attempting any of the 4 steps enumerated above. If this happens, then the</source>
          <target state="translated">もちろん、上記の4つのステップのいずれかを実行中にエラーが発生する可能性があります。このような場合は</target>
        </trans-unit>
        <trans-unit id="4144a21a0e5e7b5ef89db325c2463b409501b64d" translate="yes" xml:space="preserve">
          <source>Of course, an ordinary SQLite table will also do a query against its integer primary key efficiently, so the previous is no big deal. The real reason for using an R*Tree is so that you can efficiently do inequality queries against the coordinate ranges. To find all elements of the index that are contained within the vicinity of Charlotte, North Carolina, one might do:</source>
          <target state="translated">もちろん、通常のSQLiteテーブルであれば、整数の主キーに対するクエリも効率的に実行されますので、前者は大した問題ではありません。R*Treeを使う本当の理由は、座標範囲に対する不等式クエリを効率的に行うためです。ノースカロライナ州シャーロット付近に含まれるインデックスのすべての要素を見つけるには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="ad9000f84241cbe168fcf9edea5a309a2f41cf64" translate="yes" xml:space="preserve">
          <source>Of course, it is also possible that it does exist following system recovery.</source>
          <target state="translated">もちろん、システムリカバリー後に存在する可能性もあります。</target>
        </trans-unit>
        <trans-unit id="7a79fe7e88cf76ed8c1ab2e6617de9596ed474d8" translate="yes" xml:space="preserve">
          <source>Of course, it is usually not possible to atomically apply all the changes required by a</source>
          <target state="translated">もちろん、通常は、すべての変更をアトミックに適用することはできません。</target>
        </trans-unit>
        <trans-unit id="b8a4fe5b2fe5db1f855a348ab89c3de5aa545089" translate="yes" xml:space="preserve">
          <source>Of course, one wants to eventually transfer all the transactions that are appended in the WAL file back into the original database. Moving the WAL file transactions back into the database is called a &quot;</source>
          <target state="translated">もちろん、最終的にはWALファイルに追加されたすべてのトランザクションを元のデータベースに戻したいと考えています。WALファイルのトランザクションをデータベースに戻すことを&quot;</target>
        </trans-unit>
        <trans-unit id="a8d7cb464eb0b5300b1a2a71635654f684270965" translate="yes" xml:space="preserve">
          <source>Of course, ordering the output of a query by rowid is seldom useful. Usually one wants to order the output by some other column.</source>
          <target state="translated">もちろん、クエリの出力をrowidで順番に並べることは滅多にありません。通常は、他のカラムで出力を順番に並べたいものです。</target>
        </trans-unit>
        <trans-unit id="178df5e8851c3ac34f7dcea098e85da7dbfe235b" translate="yes" xml:space="preserve">
          <source>Of course, substitute the desired index and imposter table names in place of the &quot;t1bc&quot; and &quot;t2&quot; shown in the example. The &quot;.imposter&quot; command reads the schema of the &quot;t1bc&quot; index, uses that information to construct a compatible CREATE TABLE statement for the imposter table, then makes all the necessary calls to create the transient imposter table automatically.</source>
          <target state="translated">もちろん、例に示した &quot;t1bc &quot;と &quot;t2 &quot;の代わりに、希望するインデックスとインポスターテーブル名を代入してください。.imposter &quot;コマンドは、&quot;t1bc &quot;インデックスのスキーマを読み込み、その情報を使用してインポスターテーブル用の互換性のあるCREATE TABLE文を構築し、その後、過渡的なインポスターテーブルを自動的に作成するために必要なすべての呼び出しを行います。</target>
        </trans-unit>
        <trans-unit id="116444cf2f220a0caf732f16ffb5a2f69fd9321c" translate="yes" xml:space="preserve">
          <source>Of course, the two queries above are not entirely equivalent. For example the LIKE query matches rows that contain terms such as &quot;linuxophobe&quot; or &quot;EnterpriseLinux&quot; (as it happens, the Enron E-Mail Dataset does not actually contain any such terms), whereas the MATCH query on the FTS3 table selects only those rows that contain &quot;linux&quot; as a discrete token. Both searches are case-insensitive. The FTS3 table consumes around 2006 MB on disk compared to just 1453 MB for the ordinary table. Using the same hardware configuration used to perform the SELECT queries above, the FTS3 table took just under 31 minutes to populate, versus 25 for the ordinary table.</source>
          <target state="translated">もちろん、上記の2つのクエリは完全に等価というわけではありません。例えば、LIKEクエリは &quot;linuxophobe &quot;や &quot;EnterpriseLinux &quot;のような用語を含む行にマッチします(実際にはEnron E-Mail Datasetにはそのような用語は含まれていません)。どちらの検索も大文字小文字を区別しません。FTS3テーブルのディスク消費量は、通常のテーブルが1453 MBであるのに対し、FTS3テーブルは約2006 MBです。上記の SELECT クエリの実行に使用したのと同じハードウェア構成を使用した場合、FTS3 テーブルの入力に要した時間は、通常のテーブルが 25 分であったのに対し、31 分弱でした。</target>
        </trans-unit>
        <trans-unit id="68b0ebb94fca52bc2076d132ead5c0f0cef17ce0" translate="yes" xml:space="preserve">
          <source>Of course, users would prefer code that is both robust in normal use and resistant to malicious attack. The SQLite developers are dedicated to providing that. The purpose of this section is merely to point out that doing both at the same time is hard.</source>
          <target state="translated">もちろん、ユーザーは通常の使用では堅牢で、悪意のある攻撃にも強いコードを好むでしょう。SQLite の開発者はそれを提供することに専念しています。このセクションの目的は、両方を同時に行うことが難しいことを指摘することにあります。</target>
        </trans-unit>
        <trans-unit id="e6778acfecc08483f487870a27c4e0b19bb8701d" translate="yes" xml:space="preserve">
          <source>Of course, your mileage may vary depending on hardware, filesystem, and operating system. Double-check these figures on target hardware before committing to a particular design.</source>
          <target state="translated">もちろん、ハードウェア、ファイルシステム、オペレーティング・システムによって異なる場合があります。特定のデザインにコミットする前に、ターゲットハードウェアでこれらの数字をダブルチェックしてください。</target>
        </trans-unit>
        <trans-unit id="315230e941921effe51cc9ebfa05403b855f0476" translate="yes" xml:space="preserve">
          <source>Of these changes, only 1a and 2a through 2c are incompatibilities in any formal sense. But users who have previously made custom modifications to the SQLite source (for example to add a custom OS layer for embedded hardware) might find that these changes have a larger impact. On the other hand, an important goal of these changes is to make it much easier to customize SQLite for use on different operating systems.</source>
          <target state="translated">これらの変更のうち、形式的な意味での非互換性があるのは 1a と 2a から 2c だけです。しかし、以前に SQLite ソースにカスタムの変更を加えたことのあるユーザ(例えば、組み込みハードウェア用のカスタム OS レイヤを追加するなど)は、これらの変更がより大きな影響を与えることに気づくかもしれません。一方で、これらの変更の重要な目的は、異なるオペレーティングシステムで使用するためのSQLiteのカスタマイズをより簡単にすることです。</target>
        </trans-unit>
        <trans-unit id="e3de5ab0ca4c69dbf00e86d2558843e8d806bb49" translate="yes" xml:space="preserve">
          <source>Off</source>
          <target state="translated">Off</target>
        </trans-unit>
        <trans-unit id="ce667716547fa82bc8795ad7ef205e9410193ed0" translate="yes" xml:space="preserve">
          <source>Offset</source>
          <target state="translated">Offset</target>
        </trans-unit>
        <trans-unit id="58190317f4f075103c701ab1719a5146c7d71c8f" translate="yes" xml:space="preserve">
          <source>OffsetLimit</source>
          <target state="translated">OffsetLimit</target>
        </trans-unit>
        <trans-unit id="1ab3ac50fee719ce4797840a2df9f8c5ee707c03" translate="yes" xml:space="preserve">
          <source>Older versions of SQLite could not read a WAL-mode database that was read-only. In other words, write access was required in order to read a WAL-mode database. This constraint was relaxed beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;version 3.22.0&lt;/a&gt; (2018-01-22).</source>
          <target state="translated">SQLiteの古いバージョンは、読み取り専用のWALモードデータベースを読み取ることができませんでした。つまり、WALモードのデータベースを読み取るには、書き込みアクセス権が必要でした。この制約は、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;バージョン3.22.0&lt;/a&gt;（2018-01-22）から緩和されました。</target>
        </trans-unit>
        <trans-unit id="28b3eeca1402aeadaf4db2bf8f6d2403ee957bf0" translate="yes" xml:space="preserve">
          <source>Older versions of firebird omits all NULLs from SELECT DISTINCT and from UNION.</source>
          <target state="translated">古いバージョンのfirebirdでは、SELECT DISTINCTやUNIONからはすべてのNULLを省略しています。</target>
        </trans-unit>
        <trans-unit id="8bfe5e60a5daf11fac21979e5a4fa9643a76bc3b" translate="yes" xml:space="preserve">
          <source>Omit all use of &quot;awk&quot; in the makefiles, to make building easier for MSVC users.</source>
          <target state="translated">MSVC ユーザーがビルドしやすくするために、makefile での &quot;awk&quot; の使用をすべて省略しました。</target>
        </trans-unit>
        <trans-unit id="bf4d0857bd27f59258be5d9b1e12776a9ff94992" translate="yes" xml:space="preserve">
          <source>Omitted parameters take on default values. STEP defaults to 1. END defaults to 9223372036854775807. START defaults to 0.</source>
          <target state="translated">省略されたパラメータは、デフォルト値を使用します。STEPのデフォルト値は1です。END のデフォルトは 9223372036854775807 です。START のデフォルト値は 0 です。</target>
        </trans-unit>
        <trans-unit id="e0049a66519cae71159800bb77a35007bc2d76d3" translate="yes" xml:space="preserve">
          <source>On</source>
          <target state="translated">On</target>
        </trans-unit>
        <trans-unit id="0e46092ad025ac57fb1677f1d311680029cda2c1" translate="yes" xml:space="preserve">
          <source>On Android, we are told, there are many services that will blindly run arbitrary SQL that is passed to them by untrustworthy apps that have been downloaded from dodgy corners of the internet. Android services are suppose to be more guarded about running SQL from unvetted sources. This author does not have any specific examples to the contrary, but he has heard rumors that they exist. Even if all Android services are more careful and properly vet all the SQL they run, it would be difficult to audit them all in order to verify that they are safe. Hence, security-minded people are keen to ensure that no exploits are possible by passing arbitrary SQL text.</source>
          <target state="translated">Androidでは、インターネットの怪しげなコーナーからダウンロードした信頼できないアプリから渡された任意のSQLを盲目的に実行するサービスがたくさんあると言われています。Androidのサービスは、信頼されていないソースからのSQLを実行することについては、より警戒されているはずだ。筆者はそれに反して具体的な例を持っていないが、存在するという噂を聞いたことがある。仮にすべての Android サービスがより慎重になり、実行するすべての SQL を適切に検証したとしても、それらが安全であることを確認するためにすべての SQL を監査することは難しいだろう。それゆえ、セキュリティに関心のある人たちは、任意のSQLテキストを渡すことで悪用されることがないようにしたいと考えている。</target>
        </trans-unit>
        <trans-unit id="26c3af907230190631617dbb8e5acb92e9854301" translate="yes" xml:space="preserve">
          <source>On Linux and other unix systems you will need to enter something like:</source>
          <target state="translated">Linux やその他の Unix システムでは、次のように入力する必要があります。</target>
        </trans-unit>
        <trans-unit id="1273deeaf4de08300113723f337bae0ec716c243" translate="yes" xml:space="preserve">
          <source>On Win32, do not return an error when attempting to delete a file that does not exist.</source>
          <target state="translated">Win32では、存在しないファイルを削除しようとしてもエラーを返さないようにしました。</target>
        </trans-unit>
        <trans-unit id="b2b2f36a4fafa25d031c2e6870c72d35c487959e" translate="yes" xml:space="preserve">
          <source>On Windows systems, folders are searched in the following order:</source>
          <target state="translated">Windows システムでは、フォルダは次の順序で検索されます。</target>
        </trans-unit>
        <trans-unit id="9d83a99bbbc3869a446954149b390c5195af03a3" translate="yes" xml:space="preserve">
          <source>On Windows with MSVC, use nmake with the Makefile.msc:</source>
          <target state="translated">MSVCを搭載したWindowsでは、Makefile.mscでnmakeを使用します。</target>
        </trans-unit>
        <trans-unit id="e51bd18dd2b65a7e346c37ac44c1031b3f3942d7" translate="yes" xml:space="preserve">
          <source>On Windows, enter:</source>
          <target state="translated">Windowsでは、入力します。</target>
        </trans-unit>
        <trans-unit id="aacb79e6ea038d7e3cda09880e0781239b1e3933" translate="yes" xml:space="preserve">
          <source>On a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;, the WAL is first flushed to persistent storage using the xSync method of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;VFS&lt;/a&gt;. Then valid content of the WAL is transferred into the database file. Finally, the database is flushed to persistent storage using another xSync method call. The xSync operations serve as write barriers - all writes launched before the xSync must complete before any write that launches after the xSync begins.</source>
          <target state="translated">上の&lt;a href=&quot;wal#ckpt&quot;&gt;チェックポイント&lt;/a&gt;、WALは、第一のXSYNC方法使用永続ストレージにフラッシュされる&lt;a href=&quot;c3ref/io_methods&quot;&gt;VFSを&lt;/a&gt;。次に、WALの有効なコンテンツがデータベースファイルに転送されます。最後に、データベースは別のxSyncメソッド呼び出しを使用して永続ストレージにフラッシュされます。xSync操作は書き込みバリアとして機能します。xSyncの前に起動されたすべての書き込みは、xSyncの開始後に起動される書き込みの前に完了する必要があります。</target>
        </trans-unit>
        <trans-unit id="ea7fd316bd0a1ed7abbfd63a2c9be9dcb14966c5" translate="yes" xml:space="preserve">
          <source>On a DISTINCT query that uses an index, try to skip ahead to the next distinct entry using the index rather than stepping through rows, when an appropriate index is available.</source>
          <target state="translated">インデックスを使用するDISTINCTクエリでは、適切なインデックスが利用可能な場合には、行をステップスルーするのではなく、インデックスを使用して次の明確なエントリにスキップしてみてください。</target>
        </trans-unit>
        <trans-unit id="439b4340c2826997b9311dbcdfa182caed0bc968" translate="yes" xml:space="preserve">
          <source>On a traditional spinning disk, a sector is the minimum unit of transfer in both directions, both reading and writing. On flash memory, however, the minimum size of a read is typically much smaller than a minimum write. SQLite is only concerned with the minimum write amount and so for the purposes of this article, when we say &quot;sector&quot; we mean the minimum amount of data that can be written to mass storage in a single go.</source>
          <target state="translated">従来のスピニングディスクでは、セクタとは、読み取りと書き込みの両方の方向の転送の最小単位である。しかし、フラッシュメモリでは、通常、読み込みの最小サイズは書き込みの最小サイズよりもはるかに小さくなります。SQLiteは最小書き込み量にしか関心がないので、この記事では「セクタ」というと、大容量ストレージに一度に書き込める最小データ量のことを指します。</target>
        </trans-unit>
        <trans-unit id="4d25766d7605da89f0dc45ce4758796da7aaedb1" translate="yes" xml:space="preserve">
          <source>On an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, if the ROWID or INTEGER PRIMARY KEY column is not explicitly given a value, then it will be filled automatically with an unused integer, usually one more than the largest ROWID currently in use. This is true regardless of whether or not the AUTOINCREMENT keyword is used.</source>
          <target state="translated">上&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; ROWIDまたはINTEGER PRIMARY KEY列が明示的に値が与えられていない場合、それは通常、1つ以上の現在使用されている最大ROWIDより、未使用整数で自動的に満たされます。これは、AUTOINCREMENTキーワードが使用されているかどうかに関係なく当てはまります。</target>
        </trans-unit>
        <trans-unit id="ebef8439735d14eb6033471fd2e7d318b20febc6" translate="yes" xml:space="preserve">
          <source>On an UPSERT when the order of constraint checks is rearranged, ensure that the affinity transformations on the inserted content occur before any of the constraint checks. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9e&lt;/a&gt;.</source>
          <target state="translated">UPSERTでは、制約チェックの順序が再配置される場合、挿入されたコンテンツのアフィニティ変換が制約チェックの前に行われることを確認してください。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9eの&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="0a7e67fba14e6027ea80edde2148e2473e22f15f" translate="yes" xml:space="preserve">
          <source>On each call to undo::undo or undo::redo, the undo/redo module automatically invokes methods status_refresh and reload_all in all toplevel namespaces. These methods should be defined to reconstruct the display or otherwise update the state of the program based on the undone/redone changes to the database.</source>
          <target state="translated">undo::undo または undo::redo を呼び出すたびに、undo/redo モジュールは、すべてのトップレベルの名前空間で status_refresh および reload_all メソッドを自動的に呼び出します。これらのメソッドは、表示を再構築したり、データベースに対する undo/redone の変更に基づいてプログラムの状態を更新したりするために定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="51efe73d5459fecda0ebf237f9f8f384ca5daf31" translate="yes" xml:space="preserve">
          <source>On embedded systems with synchronous filesystems, TRUNCATE results in slower behavior than PERSIST. The commit operation is the same speed. But subsequent transactions are slower following a TRUNCATE because it is faster to overwrite existing content than to append to the end of a file. New journal file entries will always be appended following a TRUNCATE but will usually overwrite with PERSIST.</source>
          <target state="translated">同期ファイルシステムを持つ組み込みシステムでは、TRUNCATEはPERSISTよりも動作が遅くなります。コミット操作は同じ速度です。しかし、ファイルの最後に追加するよりも既存のコンテンツを上書きする方が速いため、TRUNCATEの後に続くトランザクションは遅くなります。新しいジャーナルファイルエントリはTRUNCATEの後に常に追加されますが、通常はPERSISTで上書きされます。</target>
        </trans-unit>
        <trans-unit id="cff1aa0bee9c89492d085449129eae77e72bb5fa" translate="yes" xml:space="preserve">
          <source>On most systems, the malloc() system call returns a buffer that is aligned to an 8-byte boundary. But on some systems (ex: windows) malloc() returns 4-byte aligned pointer. This compile-time option must be used on systems that return 4-byte aligned pointers from malloc().</source>
          <target state="translated">ほとんどのシステムでは、malloc()システムコールは 8 バイトの境界に整列したバッファを返します。しかし、一部のシステム (例:windows)では malloc()は 4 バイトアライメントされたポインタを返します。このコンパイル時オプションは、malloc()から 4 バイトアライメントされたポインタを返すシステムで使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="87f5be0e7a33503458f9f1fc5e662122708d06fc" translate="yes" xml:space="preserve">
          <source>On newer versions of SQLite, a WAL-mode database on read-only media, or a WAL-mode database that lacks write permission, can still be read as long as one or more of the following conditions are met:</source>
          <target state="translated">新しいバージョンのSQLiteでは、読み取り専用メディア上のWALモードデータベースや、書き込み権限を持たないWALモードデータベースでも、以下の条件の1つ以上が満たされていれば読み込むことができます。</target>
        </trans-unit>
        <trans-unit id="0a3b32dd2c0c0446522505f738b73e43600ba9ad" translate="yes" xml:space="preserve">
          <source>On startup, the &lt;b&gt;sqlite3&lt;/b&gt; program will show a brief banner message then prompt you to enter SQL. Type in SQL statements (terminated by a semicolon), press &quot;Enter&quot; and the SQL will be executed.</source>
          <target state="translated">起動時に、&lt;b&gt;sqlite3&lt;/b&gt;プログラムは短いバナーメッセージを表示し、SQLの入力を要求します。SQLステートメントを入力し（セミコロンで終了）、[Enter]を押すとSQLが実行されます。</target>
        </trans-unit>
        <trans-unit id="a6133c9cbc7fd01002e1fd8f131c7ef4a48f7b82" translate="yes" xml:space="preserve">
          <source>On startup, the application first decides which version it wants to display. Since the versionId will naturally increase in time and one would normally want to see the latest version, an appropriate query might be:</source>
          <target state="translated">起動時に、アプリケーションは最初に表示したいバージョンを決定します。versionIdは当然ながら時間の経過とともに増加し、通常は最新のバージョンを表示したいので、適切なクエリは次のようになります。</target>
        </trans-unit>
        <trans-unit id="d2a06dc722811f829dbda8827b08f5f0b5f36ae8" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">成功すると、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;が返され、新しい&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOBハンドル&lt;/a&gt;が* ppBlobに格納されます。それ以外の場合、&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;が返され、エラーコードがSQLITE_MISUSEでない限り、* ppBlobはNULLに設定されます。つまり、APIが誤用されていない限り、この関数が返した後、* ppBlobで&lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close（）&lt;/a&gt;を呼び出しても常に安全です。</target>
        </trans-unit>
        <trans-unit id="749e0ca8bebcf0ea981a3b5d51013a9a74a29d29" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">成功すると、&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;が返され、新しい&lt;a href=&quot;blob&quot;&gt;BLOBハンドル&lt;/a&gt;が* ppBlobに格納されます。それ以外の場合、&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;が返され、エラーコードがSQLITE_MISUSEでない限り、* ppBlobはNULLに設定されます。つまり、APIが誤用されていない限り、この関数が返した後、* ppBlobで&lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close（）&lt;/a&gt;を呼び出しても常に安全です。</target>
        </trans-unit>
        <trans-unit id="65eaebdd334ea618570d91e4458e0eb1b208375f" translate="yes" xml:space="preserve">
          <source>On success, &lt;b&gt;sqlite_compile&lt;/b&gt; returns SQLITE_OK. Otherwise and error code is returned.</source>
          <target state="translated">成功すると、&lt;b&gt;sqlite_compile&lt;/b&gt;は&lt;b&gt;SQLITE_OKを&lt;/b&gt;返します。それ以外の場合は、エラーコードが返されます。</target>
        </trans-unit>
        <trans-unit id="3e9b1d8e369d082b964c508c283e64eea1e0560c" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">成功すると、sqlite3_blob_read（）はSQLITE_OKを返します。それ以外の場合は、&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;または&lt;a href=&quot;../rescode#extrc&quot;&gt;拡張エラーコード&lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="e81bdc76837634caa6cec9a7812e38a822384af4" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">成功すると、sqlite3_blob_read（）はSQLITE_OKを返します。それ以外の場合は、&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;または&lt;a href=&quot;rescode#extrc&quot;&gt;拡張エラーコード&lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="00223380eeb8684c87e10d42630c25143e83fb7d" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">成功すると、sqlite3_blob_write（）はSQLITE_OKを返します。それ以外の場合は、&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;または&lt;a href=&quot;../rescode#extrc&quot;&gt;拡張エラーコード&lt;/a&gt;が返されます。SQLITE_MISUSEが返されない限り、この関数は、&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;と&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;および関連する関数を介してアクセス可能な&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;エラーコードとメッセージを設定します。</target>
        </trans-unit>
        <trans-unit id="e1d8319a0f054e12945ffdcd496271dbacaf81a2" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">成功すると、sqlite3_blob_write（）はSQLITE_OKを返します。それ以外の場合は、&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;または&lt;a href=&quot;rescode#extrc&quot;&gt;拡張エラーコード&lt;/a&gt;が返されます。SQLITE_MISUSEが返されない限り、この関数は、&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;および関連する関数を介してアクセス可能な&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;エラーコードとメッセージを設定します。</target>
        </trans-unit>
        <trans-unit id="8609e89a9e3f181cc9bf01d1a6238ab2d0959ed4" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">成功すると、sqlite3_prepare（）ファミリーのルーチンは&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OKを返し&lt;/a&gt;ます。それ以外の場合は、&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="3e16251e40927c67fe655d2518e028082c6fa9b3" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">成功すると、sqlite3_prepare（）ファミリーのルーチンは&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OKを返し&lt;/a&gt;ます。それ以外の場合は、&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="79e4255a03a365ba20cd0884b8ee349e3d935179" translate="yes" xml:space="preserve">
          <source>On the Mac, you can set this pragma:</source>
          <target state="translated">Macでは、このプラグマを設定することができます。</target>
        </trans-unit>
        <trans-unit id="69a450284be9205b76c2e066c35f545c5c025beb" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able control database access with more precision, allowing for finer grain locking and better concurrency.</source>
          <target state="translated">一方、サーバーを使用するデータベースエンジンは、クライアントアプリケーションのバグからより良い保護を提供することができます。また、サーバは単一の永続的なプロセスであるため、データベースへのアクセスをより正確に制御することができ、より細かい粒度のロックとより良い同時実行が可能になります。</target>
        </trans-unit>
        <trans-unit id="84736c128a35123ea022380e6a3900484bf1a802" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able to control database access with more precision, allowing for finer-grained locking and better concurrency.</source>
          <target state="translated">一方、サーバーを使用するデータベースエンジンは、クライアントアプリケーションのバグからより良い保護を提供することができます。また、サーバは単一の永続的なプロセスであるため、データベースへのアクセスをより正確に制御することができ、より細かなロックとより良い同時実行が可能になります。</target>
        </trans-unit>
        <trans-unit id="71cbc82c664fd1caf1a677d0c65b18293805a90f" translate="yes" xml:space="preserve">
          <source>On the other hand, an RBU Vacuum uses more CPU than a regular SQLite VACUUM - in one test as much as five times as much. For this reason, an RBU Vacuum is often significantly slower than an SQLite VACUUM under the same conditions.</source>
          <target state="translated">一方、RBUバキュームは通常のSQLite VACUUMよりも多くのCPUを使用します。このため、RBU VACUUMは、同じ条件下ではSQLite VACUUMよりも大幅に遅くなることがよくあります。</target>
        </trans-unit>
        <trans-unit id="2ec9b50cf6f067a94359ec578926c021dba81fa8" translate="yes" xml:space="preserve">
          <source>On the other hand, dropping tables is not a very common operation so if SQLite takes a little longer, that is not seen as a big problem.</source>
          <target state="translated">一方で、テーブルのドロップはあまり一般的な操作ではないので、SQLiteがもう少し時間がかかっても、それは大きな問題とは思われません。</target>
        </trans-unit>
        <trans-unit id="b75edbc4ccb51b3a0effc26ec943821968d21e88" translate="yes" xml:space="preserve">
          <source>On the other hand, if the result of the subquery must be scanned multiple times (because, for example, it is just one table in a join) then it is better to use a transient table to remember the entire result of the subquery, in order to avoid computing the subquery more than once.</source>
          <target state="translated">一方、副問い合わせの結果を複数回スキャンしなければならない場合(例えば、ジョインの中の1つのテーブルだけであるため)、副問い合わせを複数回計算しないようにするために、副問い合わせの結果全体を記憶するために過渡的なテーブルを使用する方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="4cb26bb6bd2845585001f514df8ac5e23d3a9784" translate="yes" xml:space="preserve">
          <source>On the other hand, read performance deteriorates as the WAL file grows in size since each reader must check the WAL file for the content and the time needed to check the WAL file is proportional to the size of the WAL file. The wal-index helps find content in the WAL file much faster, but performance still falls off with increasing WAL file size. Hence, to maintain good read performance it is important to keep the WAL file size down by running checkpoints at regular intervals.</source>
          <target state="translated">一方、WALファイルのサイズが大きくなると、各リーダーがWALファイルの内容をチェックしなければならず、チェックに要する時間はWALファイルのサイズに比例するため、読み取り性能が低下します。wal-indexはWALファイル内のコンテンツをより速く見つけるのに役立ちますが、WALファイルのサイズが大きくなるとパフォーマンスは低下します。したがって、良好な読み取り性能を維持するためには、一定の間隔でチェックポイントを実行してWALファイルのサイズを抑えることが重要です。</target>
        </trans-unit>
        <trans-unit id="9a0c49cb1cedb27f90f5b843b5321b6c2675c041" translate="yes" xml:space="preserve">
          <source>On the stack display, most entries are shown with a prefix that tells the datatype of that stack entry. Integers begin with &quot;&lt;code&gt;i:&lt;/code&gt;&quot;. Floating point values begin with &quot;&lt;code&gt;r:&lt;/code&gt;&quot;. (The &quot;r&quot; stands for &quot;real-number&quot;.) Strings begin with either &quot;&lt;code&gt;s:&lt;/code&gt;&quot;, &quot;&lt;code&gt;t:&lt;/code&gt;&quot;, &quot;&lt;code&gt;e:&lt;/code&gt;&quot; or &quot;&lt;code&gt;z:&lt;/code&gt;&quot;. The difference among the string prefixes is caused by how their memory is allocated. The z: strings are stored in memory obtained from &lt;b&gt;malloc()&lt;/b&gt;. The t: strings are statically allocated. The e: strings are ephemeral. All other strings have the s: prefix. This doesn't make any difference to you, the observer, but it is vitally important to the VDBE since the z: strings need to be passed to &lt;b&gt;free()&lt;/b&gt; when they are popped to avoid a memory leak. Note that only the first 10 characters of string values are displayed and that binary values (such as the result of the MakeRecord instruction) are treated as strings. The only other datatype that can be stored on the VDBE stack is a NULL, which is display without prefix as simply &quot;&lt;code&gt;NULL&lt;/code&gt;&quot;. If an integer has been placed on the stack as both an integer and a string, its prefix is &quot;&lt;code&gt;si:&lt;/code&gt;&quot;.</source>
          <target state="translated">スタック表示では、ほとんどのエントリは、そのスタックエントリのデータ型を示すプレフィックスで表示されます。整数は「 &lt;code&gt;i:&lt;/code&gt; 」で始まります。浮動小数点値は「 &lt;code&gt;r:&lt;/code&gt; 」で始まります。 （「r」は「実数」を表します。）文字列は「 &lt;code&gt;s:&lt;/code&gt; 」、「 &lt;code&gt;t:&lt;/code&gt; 」、「 &lt;code&gt;e:&lt;/code&gt; 」または「 &lt;code&gt;z:&lt;/code&gt; 」で始まります。文字列プレフィックスの違いは、メモリの割り当て方法が原因です。 z：文字列は、&lt;b&gt;malloc（）&lt;/b&gt;から取得したメモリに格納されます。 t：文字列は静的に割り当てられます。 e：文字列は短命です。他のすべての文字列にはs：プレフィックスがあります。これは観察者であるあなたに何の違いもありません、ただし、z：文字列を渡す必要があるため、VDBEにとって非常に重要です。&lt;b&gt;&lt;/b&gt;メモリリークを回避するためにポップされたときの&lt;b&gt;free（）&lt;/b&gt;。文字列値の最初の10文字だけが表示され、バイナリ値（MakeRecord命令の結果など）は文字列として扱われることに注意してください。VDBEスタックに格納できる他の唯一のデータ型はNULLで、接頭辞なしで単に「 &lt;code&gt;NULL&lt;/code&gt; 」として表示されます。整数が整数と文字列の両方としてスタックに配置されている場合、その接頭辞は &quot; &lt;code&gt;si:&lt;/code&gt; &quot;です。</target>
        </trans-unit>
        <trans-unit id="e3336bd71adcf37ccf53527f3a1cc4855eac8894" translate="yes" xml:space="preserve">
          <source>On unix systems (or on Windows using cygwin or mingw+msys) the command typically looks something like this:</source>
          <target state="translated">unix システム (または cygwin や mingw+msys を使用している Windows)では、このコマンドは通常次のようになります。</target>
        </trans-unit>
        <trans-unit id="287d1cbba1056569ceaf042e45ed9558181651a7" translate="yes" xml:space="preserve">
          <source>On unix, if a symlink to a database file is opened, then the corresponding journal files are based on the actual filename, not the symlink name.</source>
          <target state="translated">unixでは、データベースファイルへのシンボリックリンクが開かれた場合、対応するジャーナルファイルはシンボリックリンク名ではなく実際のファイル名に基づいています。</target>
        </trans-unit>
        <trans-unit id="6c70d0e29a89e83eef274cc81c5528ba689d997c" translate="yes" xml:space="preserve">
          <source>On unix-like systems, directories are searched in the following order:</source>
          <target state="translated">unix ライクなシステムでは、ディレクトリは以下の順序で検索されます。</target>
        </trans-unit>
        <trans-unit id="db7db60b91e81d2d39614db0d3144dc3caa85aa5" translate="yes" xml:space="preserve">
          <source>On windows only, convert all &quot;&lt;code&gt;\&lt;/code&gt;&quot; characters into &quot;&lt;code&gt;/&lt;/code&gt;&quot;.</source>
          <target state="translated">Windowsのみで、すべての「 &lt;code&gt;\&lt;/code&gt; 」文字を「 &lt;code&gt;/&lt;/code&gt; 」に変換します。</target>
        </trans-unit>
        <trans-unit id="aa996bed689bb081c327fe76624367885c13654f" translate="yes" xml:space="preserve">
          <source>On windows only, if the filename begins with a drive letter, prepend a single &quot;&lt;code&gt;/&lt;/code&gt;&quot; character.</source>
          <target state="translated">Windowsのみで、ファイル名がドライブ文字で始まる場合は、単一の「 &lt;code&gt;/&lt;/code&gt; 」文字を先頭に追加します。</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="87f26aaf5f6994f877b899775d955216fa5722f5" translate="yes" xml:space="preserve">
          <source>Once a</source>
          <target state="translated">一度は</target>
        </trans-unit>
        <trans-unit id="8464198c181050b3c7b7af3b57436c91d71a13de" translate="yes" xml:space="preserve">
          <source>Once a VFS has been registered, it should never be modified. If a change in behavior is required, a new VFS should be registered. The application could, perhaps, use &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; to locate the old VFS, make a copy of the old VFS into a new &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object, make the desired modifications to the new VFS, unregister the old VFS, then register the new VFS in its place. Existing database connections would continue to use the old VFS even after it is unregistered, but new database connections would use the new VFS.</source>
          <target state="translated">VFSが登録されたら、決して変更しないでください。動作の変更が必要な場合は、新しいVFSを登録する必要があります。アプリケーションは、おそらく、&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find（）&lt;/a&gt;を使用して古いVFSを特定し、古いVFSのコピーを新しい&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトに作成し、新しいVFSに必要な変更を加え、古いVFSの登録を解除し、新しいVFSを場所。登録を解除した後でも、既存のデータベース接続は古いVFSを使用し続けますが、新しいデータベース接続は新しいVFSを使用します。</target>
        </trans-unit>
        <trans-unit id="55b2eace4f6d572184649196769be324d9ec08aa" translate="yes" xml:space="preserve">
          <source>Once a connection obtains a table lock, it is not released until the current transaction (read or write) is concluded.</source>
          <target state="translated">接続がテーブルロックを取得すると、現在のトランザクション(読み取りまたは書き込み)が終了するまで解放されません。</target>
        </trans-unit>
        <trans-unit id="5e4e9f1432dcf3c9b2a4412dec01ffd3ea3a631b" translate="yes" xml:space="preserve">
          <source>Once a process obtains an exclusive lock, it is permitted to write to the database file. It then proceeds to read the original content of pages out of the rollback journal and write that content back to where it came from in the database file. Recall that the header of the rollback journal records the original size of the database file prior to the start of the aborted transaction. SQLite uses this information to truncate the database file back to its original size in cases where the incomplete transaction caused the database to grow. At the end of this step, the database should be the same size and contain the same information as it did before the start of the aborted transaction.</source>
          <target state="translated">プロセスが排他的ロックを取得すると、データベースファイルへの書き込みが許可されます。その後、ロールバック・ジャーナルからページの元の内容を読み取り、その内容をデータベース・ファイルの元の場所に書き戻します。ロールバックジャーナルのヘッダには、中断されたトランザクションが開始される前のデータベースファイルの元のサイズが記録されていることを思い出してください。SQLiteはこの情報を使用して、不完全なトランザクションが原因でデータベースが大きくなった場合に、データベースファイルを元のサイズに戻すために切り詰めます。このステップの終了時には、データベースは同じサイズになり、中断されたトランザクションの開始前と同じ情報が含まれているはずです。</target>
        </trans-unit>
        <trans-unit id="b42ea281b3fc7c07c016d5e3f2cf18291c599ca4" translate="yes" xml:space="preserve">
          <source>Once a table has been attached to a session object, the session object records the primary key values of all new rows inserted into the table. It also records the original primary key and other column values of any deleted or updated rows. For each unique primary key value, data is only recorded once - the first time a row with said primary key is inserted, updated or deleted in the lifetime of the session.</source>
          <target state="translated">テーブルがセッションオブジェクトにアタッチされると、セッションオブジェクトは、テーブルに挿入されたすべての新しい行の主キーの値を記録します。また、削除された行や更新された行の元の主キーやその他の列の値も記録されます。それぞれのユニークな主キー値に対して、データが記録されるのは1回だけです。</target>
        </trans-unit>
        <trans-unit id="9c0b7ad6ff995bbd9fed309a9d73615d47bfa0e5" translate="yes" xml:space="preserve">
          <source>Once a transaction has been opened, reading data from a database connection is a simple operation. Using the xRead() method of the file-handle open on the database file, the required database file pages are read one at a time. SQLite never reads partial pages and always uses a single call to xRead() for each required page.</source>
          <target state="translated">トランザクションがオープンされると、データベース接続からデータを読み込むのは簡単な操作です。データベースファイル上で開いているファイルハンドルの xRead()メソッドを使用して、必要なデータベースファイルのページを一度に一つずつ読み込みます。SQLite は部分的なページを読み込むことはなく、常に必要なページごとに xRead()を 1 回だけ呼び出します。</target>
        </trans-unit>
        <trans-unit id="511dc23c3f8ad619f86fc49e5ac60cacc5f4cbfc" translate="yes" xml:space="preserve">
          <source>Once a virtual table has been created, it can be used like any other table with the exceptions noted above and imposed by specific virtual table implementations. A virtual table is destroyed using the ordinary &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; syntax.</source>
          <target state="translated">仮想テーブルが作成されると、上記の例外を除き、特定の仮想テーブルの実装によって強制される他のテーブルと同じように使用できます。仮想テーブルは、通常の&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;構文を使用して破棄されます。</target>
        </trans-unit>
        <trans-unit id="c3f695a7b377f8d655c6f7bd1deb78c481aa015e" translate="yes" xml:space="preserve">
          <source>Once again, practical implementations will likely subclass this structure to add additional private fields.</source>
          <target state="translated">繰り返しになりますが、実用的な実装ではこの構造体をサブクラス化してプライベートフィールドを追加することになるでしょう。</target>
        </trans-unit>
        <trans-unit id="44317a76e0c4f1b6b3d16db84fa92562885dc8a9" translate="yes" xml:space="preserve">
          <source>Once again, the SQL statements generate identical bytecode and thus do exactly the same job in exactly the same way. But the second form is made easier for humans to read by grouping the query parameters together into a single row value rather than scattering them across the WHERE clause.</source>
          <target state="translated">繰り返しになりますが、SQL文は同じバイトコードを生成するので、全く同じ方法で全く同じ仕事をします。しかし、2つ目の形式では、クエリパラメータをWHERE句に分散させるのではなく、1つの行の値にまとめることで、人間が読みやすくなっています。</target>
        </trans-unit>
        <trans-unit id="d645ca4d6b0e5bfa41d1d0e06bb9cd91ff636156" translate="yes" xml:space="preserve">
          <source>Once all rollback journal files have been flushed to disk, it is safe to begin updating database files. We have to obtain an exclusive lock on all database files before writing the changes. After all the changes are written, it is important to flush the changes to disk so that they will be preserved in the event of a power failure or operating system crash.</source>
          <target state="translated">すべてのロールバックジャーナルファイルがディスクにフラッシュされると、データベースファイルの更新を開始しても安全です。変更を書き込む前に、すべてのデータベースファイルの排他的ロックを取得しなければなりません。すべての変更が書き込まれた後は、電源障害やオペレーティングシステムのクラッシュが発生した場合でも変更を保存できるように、変更をディスクにフラッシュすることが重要です。</target>
        </trans-unit>
        <trans-unit id="73fcb528effe6301ec78591adf7629a8ed98b913" translate="yes" xml:space="preserve">
          <source>Once an SQLite database is open, it can be controlled using methods of the</source>
          <target state="translated">SQLite データベースがオープンされると、そのデータベースは</target>
        </trans-unit>
        <trans-unit id="1676ac6920d27f0701cc052fe7ff5982a44cea9d" translate="yes" xml:space="preserve">
          <source>Once an encoding has been set for a database, it cannot be changed.</source>
          <target state="translated">一度データベースに設定したエンコーディングは変更できません。</target>
        </trans-unit>
        <trans-unit id="1f61d0c0dc743205cfd592b973902a4df3bd2139" translate="yes" xml:space="preserve">
          <source>Once an exclusive lock is held, we know that no other processes are reading from the database file and it is safe to write changes into the database file. Usually those changes only go as far as the operating systems disk cache and do not make it all the way to mass storage.</source>
          <target state="translated">排他的なロックがかかっていれば、他のプロセスがデータベースファイルから読み込んでいないことがわかり、データベースファイルに変更を書き込むことは安全です。通常、これらの変更はオペレーティングシステムのディスクキャッシュの範囲内でしか行われず、大容量ストレージには到達しません。</target>
        </trans-unit>
        <trans-unit id="8d6da848ac7743477288c842a221e398489c8a06" translate="yes" xml:space="preserve">
          <source>Once any conversions have taken place, and neither value is NULL, the values are compared. If both values are blobs then memcmp() is used to determine the results of the comparison. If both values are text, then the appropriate collating function specified in P4 is used to do the comparison. If P4 is not specified then memcmp() is used to compare text string. If both values are numeric, then a numeric comparison is used. If the two values are of different types, then numbers are considered less than strings and strings are considered less than blobs.</source>
          <target state="translated">変換が行われ、どちらの値もNULLでなければ、値が比較されます。両方の値がblobの場合は,比較の結果を決定するためにmemcmp()が使用されます。両方の値がテキストの場合は,P4で指定された適切な照合関数が比較のために使用されます.P4 が指定されていない場合は、memcmp()がテキスト文字列の比較に使用されます。両方の値が数値の場合、数値比較が使用されます。2つの値が異なるタイプのものであれば、数値は文字列よりも小さく、文字列はブロブよりも小さいとみなされます。</target>
        </trans-unit>
        <trans-unit id="4b170c45b3f098d917697616ac86ca3f213bd255" translate="yes" xml:space="preserve">
          <source>Once everything is ready, run the &quot;&lt;code&gt;fossil commit&lt;/code&gt;&quot; command to check in the changes. This creates circle (4) in the diagram above.</source>
          <target state="translated">すべての準備が整ったら、「 &lt;code&gt;fossil commit&lt;/code&gt; 」コマンドを実行して変更をチェックインします。これにより、上図の円（4）が作成されます。</target>
        </trans-unit>
        <trans-unit id="89efbd20c0a9cf3f9851965660941121b8a57cbc" translate="yes" xml:space="preserve">
          <source>Once one is comfortable with the concept of storing each slide separately, it is a small step to support versioning of the presentation. Consider the following schema:</source>
          <target state="translated">1つは、それぞれのスライドを別々に格納するという概念に快適になったら、それはプレゼンテーションのバージョン管理をサポートするための小さなステップです。次のスキーマを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="05be8dd08c1c90f1df285706af044dc836d0d98a" translate="yes" xml:space="preserve">
          <source>Once populated, there are three ways to execute a full-text query against the contents of an FTS5 table:</source>
          <target state="translated">一度埋め込んだ後、FTS5テーブルの内容に対してフルテキストクエリを実行するには、3つの方法があります。</target>
        </trans-unit>
        <trans-unit id="e7dc51406db9bf51bbe6620c6512b34c3f0e8f5e" translate="yes" xml:space="preserve">
          <source>Once the dirty page being purged is writable, it is simply written into the database file.</source>
          <target state="translated">パージされるダーティなページが書き込み可能になると、それは単にデータベースファイルに書き込まれます。</target>
        </trans-unit>
        <trans-unit id="821430ef05c1ab204de759a3df24102ae4261d90" translate="yes" xml:space="preserve">
          <source>Once the input data from the FROM clause has been filtered by the WHERE clause expression (if any), the set of result rows for the simple SELECT are calculated. Exactly how this is done depends on whether the simple SELECT is an aggregate or non-aggregate query, and whether or not a GROUP BY clause was specified.</source>
          <target state="translated">FROM句からの入力データがWHERE句式(あれば)でフィルタリングされると、単純なSELECTの結果行のセットが計算されます。これがどのように行われるかは、単純なSELECTが集約クエリか非集約クエリか、GROUP BY句が指定されているかどうかによって異なります。</target>
        </trans-unit>
        <trans-unit id="79336569e93b2e9d0a83cc5e0a929d5ce48d2824" translate="yes" xml:space="preserve">
          <source>Once the project repository is created, create an open checkout of the project by moving to the directory where you want to keep all of the project source code and typing:</source>
          <target state="translated">プロジェクトリポジトリを作成したら、プロジェクトのソースコードをすべて保管しておきたいディレクトリに移動して、プロジェクトのオープンチェックアウトを作成し、タイピングを行います。</target>
        </trans-unit>
        <trans-unit id="c4e9c9ce3f592c90096798d4d198a8b0474086e9" translate="yes" xml:space="preserve">
          <source>Once the spellfix1 extension is loaded, an instance of the spellfix1 virtual table is created like this:</source>
          <target state="translated">spellfix1 拡張モジュールを読み込むと、spellfix1 仮想テーブルのインスタンスがこのように作成されます。</target>
        </trans-unit>
        <trans-unit id="8513b43854c13df7657753be614db748baf13f7a" translate="yes" xml:space="preserve">
          <source>Once the test program is generated, it is run with no arguments to perform the tests. Progress information as well as error diagnostics appear on standard output. (Alternative output arrangements can be made using a compile-time option for embedded devices that lack a standard output channel.) The program returns zero if there are no errors and non-zero if any problems were detected.</source>
          <target state="translated">テストプログラムが生成されると、テストを実行するために引数なしで実行されます。進捗情報とエラー診断は、標準出力に表示されます。(標準出力チャネルを持たない組み込み機器の場合は、コンパイル時のオプションを使用して、代替の出力を設定することができます)。プログラムは、エラーがない場合はゼロを返し、問題が検出された場合はゼロ以外を返します。</target>
        </trans-unit>
        <trans-unit id="bd0d76b14cf548de7ba347b074f1a4d3fbd73686" translate="yes" xml:space="preserve">
          <source>Once the virtual table is created, it can be queried as follows:</source>
          <target state="translated">仮想テーブルが作成されると、以下のように問い合わせができます。</target>
        </trans-unit>
        <trans-unit id="1f76d0dc14ccffaabe0506021b655e9b2d8e3d76" translate="yes" xml:space="preserve">
          <source>Once you locate a specific version, click on the hyperlink for that version to see the &quot;Check-in Information Page&quot;. Then click on either the &quot;Tarball&quot; link or the &quot;ZIP archive&quot; link to download the complete source tree.</source>
          <target state="translated">特定のバージョンを見つけたら、そのバージョンのハイパーリンクをクリックして、「チェックイン情報ページ」を見てください。その後、「Tarball」リンクまたは「ZIPアーカイブ」リンクをクリックして、完全なソースツリーをダウンロードしてください。</target>
        </trans-unit>
        <trans-unit id="5d89aa77c530c282e22378ce0f5d708e01a8b4fb" translate="yes" xml:space="preserve">
          <source>One approach to this query is to use the fruit='Orange' term of the WHERE clause to find all rows dealing with oranges, then filter those rows by rejecting any that are from states other than California. This process is shown by &lt;a href=&quot;#fig7&quot;&gt;figure 7&lt;/a&gt; above. This is a perfectly reasonable approach in most cases. Yes, the database engine did have to do an extra binary search for the Florida orange row that was later rejected, so it was not as efficient as we might hope, though for many applications it is efficient enough.</source>
          <target state="translated">このクエリへのアプローチの1つは、WHERE句のfruit = 'Orange'用語を使用してオレンジを扱うすべての行を検索し、カリフォルニア以外の州からの行をすべて拒否することによってそれらの行をフィルター処理することです。このプロセスは、上の&lt;a href=&quot;#fig7&quot;&gt;図7に&lt;/a&gt;示されています。これは、ほとんどの場合、完全に妥当なアプローチです。はい、データベースエンジンはフロリダのオレンジ色の行に対して追加のバイナリ検索を実行する必要があったため、後で拒否されたため、期待したほど効率的ではありませんでしたが、多くのアプリケーションでは十分に効率的です。</target>
        </trans-unit>
        <trans-unit id="83e48e323326e14265bd89807dc478da45112a98" translate="yes" xml:space="preserve">
          <source>One can also provide comma-separated arguments to the module following the module name:</source>
          <target state="translated">モジュール名の後にカンマ区切りの引数を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="c99a07ebdfa971a90b20da9b4561b5f49cd6023c" translate="yes" xml:space="preserve">
          <source>One can also set the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; into automatic EXPLAIN QUERY PLAN mode using the &quot;.eqp on&quot; command:</source>
          <target state="translated">「.eqp on」コマンドを使用して、&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;を自動EXPLAIN QUERY PLANモードに設定することもできます。</target>
        </trans-unit>
        <trans-unit id="efbb187108974c009f143234a98d6989ff9c9ac6" translate="yes" xml:space="preserve">
          <source>One can also think of savepoints as &quot;marks&quot; in the transaction timeline. In this view, the SAVEPOINT command creates a new mark, the ROLLBACK TO command rewinds the timeline back to a point just after the named mark, and the RELEASE command erases marks from the timeline without actually making any changes to the database.</source>
          <target state="translated">また、セーブポイントをトランザクションのタイムラインにおける「マーク」と考えることもできます。このビューでは、SAVEPOINTコマンドは新しいマークを作成し、ROLLBACK TOコマンドはタイムラインを指定されたマークの直後のポイントに巻き戻し、RELEASEコマンドは実際にデータベースに変更を加えることなくタイムラインからマークを消去します。</target>
        </trans-unit>
        <trans-unit id="3d55d95e5af6d3d744fa5a934dc2cc27683084a3" translate="yes" xml:space="preserve">
          <source>One can explicitly change out of WAL mode using a pragma such as this:</source>
          <target state="translated">このようなプラグマを使って、WALモードから明示的に切り替えることができます。</target>
        </trans-unit>
        <trans-unit id="5812082b2084545c8ed5d26ce266777d4a58efe5" translate="yes" xml:space="preserve">
          <source>One can see how the OR-by-UNION technique could also be leveraged to use multiple indices on queries where the WHERE clause has terms connected by AND, by using an intersect operator in place of union. Many SQL database engines will do just that. But the performance gain over using just a single index is slight and so SQLite does not implement that technique at this time. However, a future version SQLite might be enhanced to support AND-by-INTERSECT.</source>
          <target state="translated">OR-by-UNIONテクニックを利用して、WHERE句がANDで結ばれた用語を持つクエリで、ユニオンの代わりにインターセクト演算子を使用することで、複数のインデックスを使用することができることがわかります。多くのSQLデータベースエンジンはこれを実行します。しかし、単一のインデックスを使用した場合のパフォーマンスの向上はわずかであるため、現在のところSQLiteではこのテクニックは実装されていません。しかし、将来のバージョンの SQLite は AND-by-INTERSECT をサポートするように拡張されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="18266c8f1da4ccb3784663f1422488207a89b45d" translate="yes" xml:space="preserve">
          <source>One cannot create a trigger on a virtual table.</source>
          <target state="translated">仮想テーブルにトリガーを作成することはできません。</target>
        </trans-unit>
        <trans-unit id="08c14fea12c1a91b86b4eb3020bc8d201daa13d9" translate="yes" xml:space="preserve">
          <source>One cannot create additional indices on a virtual table. (Virtual tables can have indices but that must be built into the virtual table implementation. Indices cannot be added separately using &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statements.)</source>
          <target state="translated">仮想テーブルに追加のインデックスを作成することはできません。（仮想テーブルはインデックスを持つことができますが、仮想テーブルの実装に組み込む必要があります。インデックスは、&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;ステートメントを使用して個別に追加することはできません。）</target>
        </trans-unit>
        <trans-unit id="d3b50c178c087fb42ad06f0aba999c85b1ef895b" translate="yes" xml:space="preserve">
          <source>One cannot easily view, change, or extract the content of an OpenDocument presentation using generic tools. The only reasonable way to view or edit an OpenDocument document is to open it up using an application that is specifically designed to read or write OpenDocument (read: LibreOffice or one of its cousins). The situation could be worse. One can extract and view individual images (say) from a presentation using just the &quot;zip&quot; archiver tool. But it is not reasonable try to extract the text from a slide. Remember that all content is stored in a single &quot;context.xml&quot; file. That file is XML, so it is a text file. But it is not a text file that can be managed with an ordinary text editor. For the example presentation above, the content.xml file consist of exactly two lines. The first line of the file is just:</source>
          <target state="translated">一般的なツールを使って OpenDocument プレゼンテーションの内容を閲覧、変更、抽出することは簡単にはできません。OpenDocument ドキュメントを閲覧・編集する唯一の合理的な方法は、OpenDocument を読み書きするために特別に設計されたアプリケーショ ンを使って開くことです(読み方:LibreOffice やその従兄弟の一つ)。状況はもっと悪いかもしれません。プレゼンテーションから個々の画像を抽出して表示するには、単に「zip」アーカイバツールを使用します。しかし、それはスライドからテキストを抽出しようとすると合理的ではありません。すべてのコンテンツは、単一の ³&quot;context.xml³&quot;ファイルに格納されていることを覚えておいてください。そのファイルはXMLなので、テキストファイルです。しかし、それは通常のテキストエディタで管理できるテキストファイルではありません。上のプレゼンテーションの例では、content.xmlファイルはちょうど2行で構成されています。ファイルの1行目は、ただの</target>
        </trans-unit>
        <trans-unit id="8b60832325e280604faf68cf7c5149fd06825525" translate="yes" xml:space="preserve">
          <source>One cannot run &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; commands against a virtual table.</source>
          <target state="translated">仮想テーブルに対して&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt;コマンドを実行することはできません。</target>
        </trans-unit>
        <trans-unit id="8229271a498b58a8b73749061ba175879d5bffff" translate="yes" xml:space="preserve">
          <source>One difference between Next and ListRead is their idea of a &quot;thing&quot;. The &quot;things&quot; for the Next instruction are records in a database file. &quot;Things&quot; for ListRead are integer keys in a list. Another difference is whether to jump or fall through if there is no next &quot;thing&quot;. In this case, Next falls through, and ListRead jumps. Later on, we will see other looping instructions (NextIdx and SortNext) that operate using the same principle.</source>
          <target state="translated">Next命令とListRead命令の違いの一つは、「モノ」の考え方です。Next命令の「モノ」はデータベースファイル内のレコードです。&quot;ListReadの「もの」は、リスト内の整数キーです。もう一つの違いは、次の &quot;もの &quot;がない場合に、ジャンプするかフォールスルーするかということです。この場合、Nextはスルーし、ListReadはジャンプします。後に、同じ原理で動作する他のループ命令(NextIdxとSortNext)を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="0e2add845dd3757fedbc712aca0fdd2b6ebca768" translate="yes" xml:space="preserve">
          <source>One example of this occurred circa 2013-08-30 on the canonical repository for the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt;. In that event, file descriptor 2 (standard error) was being erroneously closed (by &lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt;, we suspect) prior to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; so that the file descriptor used for the repository database file was 2. Later, an application bug caused an assert() statement to emit an error message by invoking write(2,...). But since file descriptor 2 was now connected to a database file, the error message overwrote part of the database. To guard against this kind of problem, SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;version 3.8.1&lt;/a&gt; (2013-10-17) and later refuse to use low-numbered file descriptors for database files. (See &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; for additional information.)</source>
          <target state="translated">この一例は、2013-08-30年に&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCSの&lt;/a&gt;正規リポジトリで発生しました。そのイベントでは、ファイル記述子2（標準エラー）が&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）の&lt;/a&gt;前に誤って閉じられていたため（おそらく&lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt;によって）、リポジトリデータベースファイルに使用されるファイル記述子は2でした。その後、アプリケーションのバグによりassert（ ）ステートメントでwrite（2、...）を呼び出してエラーメッセージを出力します。しかし、ファイル記述子2がデータベースファイルに接続されたため、エラーメッセージがデータベースの一部を上書きしました。この種の問題を防ぐために、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;バージョン3.8.1&lt;/a&gt;（2013-10-17）以降では、データベースファイルに小さい番号のファイル記述子を使用することを拒否しています。（&lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTORを&lt;/a&gt;参照してください 詳細については）。</target>
        </trans-unit>
        <trans-unit id="f155185b09ba1b186403646b80d41d02e18f29b2" translate="yes" xml:space="preserve">
          <source>One exception to the typelessness of SQLite is a column whose type is INTEGER PRIMARY KEY. (And you must use &quot;INTEGER&quot; not &quot;INT&quot;. A column of type INT PRIMARY KEY is typeless just like any other.) INTEGER PRIMARY KEY columns must contain a 32-bit signed integer. Any attempt to insert non-integer data will result in an error.</source>
          <target state="translated">SQLiteの型なしの例外として、型がINTEGER PRIMARY KEYであるカラムがあります。(そして、&quot;INT &quot;ではなく &quot;INTEGER &quot;を使用しなければなりません。INT PRIMARY KEY型のカラムは、他のカラムと同様に型無しです)。INTEGER PRIMARY KEY カラムは 32 ビット符号付き整数を含まなければなりません。整数以外のデータを挿入しようとするとエラーになります。</target>
        </trans-unit>
        <trans-unit id="c476dc0c19b1ad151c922c972d11950866ac1040" translate="yes" xml:space="preserve">
          <source>One fuzzing researcher of particular note is &lt;a href=&quot;https://www.manuelrigger.at/&quot;&gt;Manuel Rigger&lt;/a&gt;, currently (as this paragraph is written on 2019-12-21) at &lt;a href=&quot;https://ethz.ch/en.html&quot;&gt;ETH Zurich&lt;/a&gt;. Most fuzzers only look for assertion faults, crashes, undefined behavior (UB), or other easily detected anomalies. Dr. Rigger's fuzzers, on the other hand, are able to find cases where SQLite computes an incorrect answer. Rigger has found &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=t&amp;amp;u=mrigger&amp;amp;n=all&quot;&gt;many such cases&lt;/a&gt;. Most of these finds are fairly obscure corner cases involving type conversions and affinity transformations, and a good number of the finds are against unreleased features. Nevertheless, his finds are still important as they are real bugs, and the SQLite developers are grateful to be able to identify and fix the underlying problems. Rigger's work is currently unpublished. When it is released, it could be as influential as Zalewski's invention of AFL and profile-guided fuzzing.</source>
          <target state="translated">特に注目の一つファジング研究者である&lt;a href=&quot;https://www.manuelrigger.at/&quot;&gt;マヌエル・リガー&lt;/a&gt;で（この段落は、2019年12月21日に書かれているもの）は現在、&lt;a href=&quot;https://ethz.ch/en.html&quot;&gt;スイス連邦工科大学チューリッヒ校&lt;/a&gt;。ほとんどのファザーは、アサーションフォールト、クラッシュ、未定義の動作（UB）、またはその他の簡単に検出される異常のみを探します。一方、リガー博士のファザーは、SQLiteが誤った答えを計算するケースを見つけることができます。リガーは&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=t&amp;amp;u=mrigger&amp;amp;n=all&quot;&gt;そのようなケースをたくさん&lt;/a&gt;見つけました。これらの発見のほとんどは、型変換とアフィニティ変換を含むかなりあいまいなコーナーケースであり、かなりの数の発見が未リリースの機能に反対しています。それにもかかわらず、彼の発見は実際のバグであるため依然として重要であり、SQLite開発者は根本的な問題を特定して修正できることに感謝しています。リガーの作品は現在未発表です。それがリリースされるとき、それはAFLとプロファイルガイドファジングのZalewskiの発明と同じくらい影響力があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="a6bf8910e6414d0165fef0d30b0886bc0f8d4329" translate="yes" xml:space="preserve">
          <source>One implication of the above is that if a change is made and then unmade within a single session (for example if a row is inserted and then deleted again), the sessions module does not report any change at all. Or if a row is updated multiple times within the same session, all updates are coalesced into a single update within any changeset or patchset blob.</source>
          <target state="translated">上記の意味するところは、1つのセッション内で変更が行われた後に変更が解除された場合(例えば、行が挿入された後に再び削除された場合など)、セッションモジュールは変更を全く報告しないということです。あるいは、同じセッション内で行が複数回更新された場合、すべての更新はチェンジセットやパッチセットブロブ内の1つの更新にまとめられます。</target>
        </trans-unit>
        <trans-unit id="fc9f38831587103a404686b12cd389ecfbf1fe12" translate="yes" xml:space="preserve">
          <source>One might argue that it is ok, in this era of multi-gigabyte desktops, to read the entire document into memory. But it is not ok. For one, the amount of memory used far exceeds the (compressed) file size on disk. So a 50MB presentation might take 200MB or more RAM. That still is not a problem if one only edits a single document at a time. But when working on a talk, this author will typically have 10 or 15 different presentations up all at the same time (to facilitate copy/paste of slides from past presentation) and so gigabytes of memory are required. Add in an open web browser or two and a few other desktop apps, and suddenly the disk is whirling and the machine is swapping. And even having just a single document is a problem when working on an inexpensive Chromebook retrofitted with Ubuntu. Using less memory is always better.</source>
          <target state="translated">マルチ・ギガバイトのデスクトップの時代には、文書全体をメモリに読み込んでもいいのではないかという議論があるかもしれません。しかし、それは大丈夫ではありません。まず、使用されるメモリの量は、ディスク上の(圧縮された)ファイルサイズをはるかに超えています。そのため、50MBのプレゼンテーションには200MB以上のRAMが必要になるかもしれません。一度に一つの文書を編集するだけならまだ問題ありません。しかし、トークに取り組んでいるとき、この著者は通常、10または15の異なるプレゼンテーションをすべて同時にアップしているでしょう(過去のプレゼンテーションからのスライドのコピー/貼り付けを容易にするために)ので、メモリのギガバイトが必要です。それに加えて、開いているWebブラウザやデスクトップアプリケーションをいくつか追加すると、突然ディスクが回転し、マシンが入れ替わるようになります。そして、ちょうど単一のドキュメントを持っていても、Ubuntuで改装された安価なChromebookで作業するときに問題となっています.少ないメモリを使うのは常に良いことです。</target>
        </trans-unit>
        <trans-unit id="f44cc341ba0d29ec39fe1d9113cc5db69afebdc7" translate="yes" xml:space="preserve">
          <source>One might want to provide other &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; such as &lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt; or &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt; for full-text search, &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; for the R*Tree search engine extension, &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; to include &lt;a href=&quot;json1&quot;&gt;JSON SQL functions&lt;/a&gt;, or &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; for the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;. In order to see extra commentary in &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; listings, add the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; option. On unix systems, add -DHAVE_USLEEP=1 if the host machine supports the usleep() system call. Add -DHAVE_READLINE and the -lreadline and -lncurses libraries to get command-line editing support. One might also want to specify some compiler optimization switches. (The precompiled CLI available for download from the SQLite website uses &quot;-Os&quot;.) There are countless possible variations here. A command to compile a full-featured shell might look something like this:</source>
          <target state="translated">一つは、他の提供する場合があります&lt;a href=&quot;compile&quot;&gt;コンパイル時のオプション&lt;/a&gt;など&lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt;や&lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt;全文検索のため、&lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; R *ツリー検索エンジンの拡張のために、&lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1を&lt;/a&gt;含めるように&lt;a href=&quot;json1&quot;&gt;JSON SQL関数&lt;/a&gt;、または&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTABを&lt;/a&gt;するために&lt;a href=&quot;dbstat&quot;&gt;仮想テーブルdbstat&lt;/a&gt;。で余分な解説を見るために&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;リスト、追加&lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTSを&lt;/a&gt;オプション。 UNIXシステムで、ホストマシンがusleep（）システムコールをサポートしている場合は、-DHAVE_USLEEP = 1を追加します。 -DHAVE_READLINEおよび-lreadlineおよび-lncursesライブラリを追加して、コマンドライン編集サポートを取得します。一部のコンパイラ最適化スイッチを指定することもできます。 （SQLite Webサイトからダウンロードできるプリコンパイル済みCLIは「-Os」を使用します。）ここには無数の可能なバリエーションがあります。フル機能のシェルをコンパイルするコマンドは、次のようになります。</target>
        </trans-unit>
        <trans-unit id="6a02d032d7380123e8a5e72e863e1054c5bd48cb" translate="yes" xml:space="preserve">
          <source>One minor downside of splitting content into smaller pieces is that compression does not work as well on shorter texts and so the size of the document might increase. But as the bulk of the document space is used to store images, a small reduction in the compression efficiency of the text content will hardly be noticeable, and is a small price to pay for an improved user experience.</source>
          <target state="translated">コンテンツをより小さな断片に分割することの小さな欠点は、短いテキストでは圧縮がうまく機能しないため、ドキュメントのサイズが大きくなる可能性があるということです。しかし、文書スペースの大部分は画像の保存に使用されているため、テキストコンテンツの圧縮効率が少し低下してもほとんど気にならないでしょう。</target>
        </trans-unit>
        <trans-unit id="b297ff44d76535e06e20e05a05458aba9a18af0a" translate="yes" xml:space="preserve">
          <source>One of the 10 decimal digit ASCII characters, or</source>
          <target state="translated">10進数10桁のASCII文字のうちの1つ、または</target>
        </trans-unit>
        <trans-unit id="67403b0cb5390fcf0c705699aeb495a2edb6d96b" translate="yes" xml:space="preserve">
          <source>One of the 52 upper and lower case ASCII characters, or</source>
          <target state="translated">52文字の大文字と小文字のASCII文字のうちの1つ、または</target>
        </trans-unit>
        <trans-unit id="cff101187bdbe5720613db95b3564ea1057f17a1" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;different&quot;&gt;distinctive features&lt;/a&gt; of SQLite is that a database consists of a single disk file. This simplifies the use of SQLite since moving or backing up a database is a simple as copying a single file. It also makes SQLite appropriate for use as an &lt;a href=&quot;whentouse#appfileformat&quot;&gt;application file format&lt;/a&gt;. But while a complete database is held in a single disk file, SQLite does make use of many temporary files during the course of processing a database.</source>
          <target state="translated">SQLiteの&lt;a href=&quot;different&quot;&gt;特徴の&lt;/a&gt; 1つは、データベースが単一のディスクファイルで構成されることです。データベースの移動やバックアップは、単一のファイルをコピーするのと同じくらい簡単なので、SQLiteの使用が簡単になります。また、SQLiteを&lt;a href=&quot;whentouse#appfileformat&quot;&gt;アプリケーションファイル形式&lt;/a&gt;として使用するのにも適しています。しかし、完全なデータベースは単一のディスクファイルに保持されますが、SQLiteはデータベースの処理中に多くの一時ファイルを利用します。</target>
        </trans-unit>
        <trans-unit id="e5c91de459561e96de8f3e9e77eaa61509cd18a7" translate="yes" xml:space="preserve">
          <source>One of the ALL or DISTINCT keywords may follow the SELECT keyword in a simple SELECT statement. If the simple SELECT is a SELECT ALL, then the entire set of result rows are returned by the SELECT. If neither ALL or DISTINCT are present, then the behavior is as if ALL were specified. If the simple SELECT is a SELECT DISTINCT, then duplicate rows are removed from the set of result rows before it is returned. For the purposes of detecting duplicate rows, two NULL values are considered to be equal. The &lt;a href=&quot;datatype3#colrules&quot;&gt;usual rules&lt;/a&gt; apply for selecting a collation sequence to compare text values.</source>
          <target state="translated">ALLまたはDISTINCTキーワードのいずれかが、単純なSELECTステートメントのSELECTキーワードの後に​​続く場合があります。単純なSELECTがSELECT ALLの場合、結果行のセット全体がSELECTによって返されます。 ALLもDISTINCTも存在しない場合、動作はALLが指定されたかのようになります。単純なSELECTがSELECT DISTINCTの場合、結果の行のセットから重複する行が削除されてから返されます。重複行を検出するために、2つのNULL値は等しいと見なされます。&lt;a href=&quot;datatype3#colrules&quot;&gt;通常の規則は、&lt;/a&gt;テキスト値を比較するための照合順序を選択するために適用されます。</target>
        </trans-unit>
        <trans-unit id="148ba6e1c7e039de60e4599c768cf9921948e4c8" translate="yes" xml:space="preserve">
          <source>One of the advantages of hosting code generator tools as part of the project is that the tools can be optimized to serve specific needs of the overall project. Lemon has benefited from this effect. Over the years, the Lemon parser generator has been extended and enhanced to provide new capabilities and improved performance to SQLite. A few of the specific enhancements to Lemon that are specifically designed for use by SQLite include:</source>
          <target state="translated">プロジェクトの一部としてコードジェネレーターツールをホスティングする利点の1つは、プロジェクト全体の特定のニーズに対応するためにツールを最適化できることです。Lemonはこの効果の恩恵を受けています。長年にわたり、Lemon パーサージェネレータは拡張され、SQLiteに新しい機能とパフォーマンスの向上を提供するために強化されてきました。SQLiteで使用するために特別に設計されたLemonの具体的な機能強化には、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="66a50c77336f3c9a6df53cb2e7363aee5a52fbbd" translate="yes" xml:space="preserve">
          <source>One of the interesting features of the VFS interface is that SQLite can support multiple VFSes at the same time. Each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has to choose a single VFS for its use when the connection is first opened using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. But if a process contains multiple &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; each can choose a different VFS. VFSes can be added at run-time using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface.</source>
          <target state="translated">VFSインターフェースの興味深い機能の1つは、SQLiteが複数のVFSを同時にサポートできることです。各&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;は、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;を使用して接続が最初に開かれるときに、その使用のために単一のVFSを選択する必要があります。ただし、プロセスに複数の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;が含まれている場合、それぞれが異なるVFSを選択できます。 VFSは、&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;インターフェイスを使用して実行時に追加できます。</target>
        </trans-unit>
        <trans-unit id="f1c2a440e7d12be65f7ff95454bfa77307c4b02e" translate="yes" xml:space="preserve">
          <source>One of the many reports that Fossil makes available is a timeline of changes to a single branch showing all merges in and out of that branch. See &lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt; for a typical example of such a report. Generating such a report normally takes just a few milliseconds. But after upgrading to the NGQP we noticed that this one report was taking closer to 10 seconds for the trunk of the repository.</source>
          <target state="translated">Fossilが提供する多くのレポートの1つは、単一のブランチへの変更のタイムラインで、そのブランチに出入りするすべてのマージを示しています。このようなレポートの典型的な例については、&lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http：//www.sqlite.org/src/timeline？nd＆n = 200＆r = trunk&lt;/a&gt;を参照してください。このようなレポートの生成には、通常数ミリ秒しかかかりません。しかし、NGQPにアップグレードした後、この1つのレポートがリポジトリのトランクに10秒近くかかっていることに気付きました。</target>
        </trans-unit>
        <trans-unit id="16f929fd09cef7d1acb11b165614f8e6f651a35f" translate="yes" xml:space="preserve">
          <source>One of the things that SQLite does to ensure that transactions are atomic across system crashes and power failures is to write all changes into the rollback journal file prior to changing the database. The TCL test harness contains an alternative &lt;a href=&quot;vfs&quot;&gt;OS backend&lt;/a&gt; implementation that helps to verify this is occurring correctly. The &quot;journal-test VFS&quot; monitors all disk I/O traffic between the database file and rollback journal, checking to make sure that nothing is written into the database file which has not first been written and synced to the rollback journal. If any discrepancies are found, an assertion fault is raised.</source>
          <target state="translated">SQLiteがシステムクラッシュや停電全体でトランザクションをアトミックにするために行うことの1つは、データベースを変更する前に、すべての変更をロールバックジャーナルファイルに書き込むことです。 TCLテストハーネスには、これが正しく行われていることを確認するのに役立つ代替の&lt;a href=&quot;vfs&quot;&gt;OSバックエンド&lt;/a&gt;実装が含まれています。 「ジャーナルテストVFS」は、データベースファイルとロールバックジャーナルの間のすべてのディスクI / Oトラフィックを監視し、最初に書き込まれてロールバックジャーナルに同期されていないものがデータベースファイルに書き込まれていないことを確認します。不一致が見つかった場合、アサーションエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="8702bf42f5b52e2937e5261eb8fe5e53cb025817" translate="yes" xml:space="preserve">
          <source>One or more indexes of the table are currently unanalyzed &lt;em&gt;or&lt;/em&gt; the number of rows in the table has increased by 25 times or more since the last time ANALYZE was run.</source>
          <target state="translated">テーブルの1つ以上のインデックスが現在分析されてい&lt;em&gt;ないか&lt;/em&gt;、前回のANALYZEの実行以降、テーブルの行数が25倍以上増加しています。</target>
        </trans-unit>
        <trans-unit id="c07477cd0e5dcf04189629377d839b6d5b58ba89" translate="yes" xml:space="preserve">
          <source>One or more transactions must have been written to the current wal file since it was created on disk (by any connection). This means that a snapshot cannot be taken on a wal mode database with no wal file immediately after it is first opened. At least one transaction must be written to it first.</source>
          <target state="translated">ディスク上に作成されてから(どのような接続でも)、現在のwalファイルに1つ以上のトランザクションが書き込まれていなければなりません。これは、最初に開いた直後に wal ファイルがない wal モードのデータベースでスナップショットを撮影することはできないことを意味します。少なくとも1つのトランザクションが最初に書き込まれていなければなりません。</target>
        </trans-unit>
        <trans-unit id="b839504f0d97f30339eb42940d7178a50aed3e9b" translate="yes" xml:space="preserve">
          <source>One solution is to add an SQL foreign key constraint to the database schema to enforce the relationship between the</source>
          <target state="translated">1つの解決策は、データベーススキーマにSQL外部キー制約を追加して</target>
        </trans-unit>
        <trans-unit id="9e9e9e6d05419e1f1b802f612d5f17adfe32fb1a" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to change SQLite to do an exhaustive search for the best path. But an exhaustive search requires time proportional to K! (where K is the number of tables in the join) and so when you get beyond a 10-way join, the time to run &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; becomes very large.</source>
          <target state="translated">この問題の1つの解決策は、SQLiteを変更して、最適なパスを徹底的に検索することです。しかし、徹底的な検索にはKに比例した時間が必要です。（Kは結合内のテーブルの数です）したがって、10方向結合を超えると、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;を実行する時間が非常に長くなります。</target>
        </trans-unit>
        <trans-unit id="3ea27e906845c470414940dc542a3a724c62dba9" translate="yes" xml:space="preserve">
          <source>One technique for avoiding a full table scan is to do lookups by rowid (or by the equivalent &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;). To lookup the price of peaches, one would query for the entry with a rowid of 4:</source>
          <target state="translated">全表スキャンを回避するための1つの方法は、ROWID（または同等の&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;）によるルックアップを行うことです。桃の価格を調べるには、ROWIDが4のエントリをクエリします。</target>
        </trans-unit>
        <trans-unit id="9d59b48161b2263d40d4491d1bb939a7b7f92e6e" translate="yes" xml:space="preserve">
          <source>One user of both Git and Fossil &lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;writes in HN&lt;/a&gt;:</source>
          <target state="translated">GitとFossilの両方の1人のユーザーが&lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;HNで書き込みます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="75f64ba853c8246c4f074dd74725d9448e0221f8" translate="yes" xml:space="preserve">
          <source>One verification technique used on SQLite is to run an entire test suite twice, once with optimizations left on and a second time with optimizations turned off, and verify that the same output is obtained both times. This shows that the optimizations do not introduce errors.</source>
          <target state="translated">SQLiteで使用されている検証手法の1つは、テストスイート全体を2回実行し、1回目は最適化をオンにしたまま、2回目は最適化をオフにして、2回とも同じ出力が得られることを検証するというものです。これは、最適化がエラーを発生させないことを示しています。</target>
        </trans-unit>
        <trans-unit id="1193850e31c2f1f6fdd8ba5f6d6a21ba1025f991" translate="yes" xml:space="preserve">
          <source>One very simple scheme might be to count the number of instances of the users search terms in each result document. Those documents that contain many instances of the terms are considered more relevant than those with a small number of instances of each term. In an FTS application, the number of term instances in each result could be determined by counting the number of integers in the return value of the &lt;a href=&quot;fts3#offsets&quot;&gt;offsets&lt;/a&gt; function. The following example shows a query that could be used to obtain the ten most relevant results for a query entered by the user:</source>
          <target state="translated">1つの非常に単純なスキームは、各結果ドキュメント内のユーザー検索語のインスタンスの数をカウントすることです。用語のインスタンスが多数含まれているドキュメントは、各用語のインスタンスが少ないドキュメントよりも関連性が高いと見なされます。 FTSアプリケーションでは、各結果の項インスタンスの数は、&lt;a href=&quot;fts3#offsets&quot;&gt;オフセット&lt;/a&gt;関数の戻り値の整数の数を数えることで決定できます。次の例は、ユーザーが入力したクエリに対して最も関連性の高い10個の結果を取得するために使用できるクエリを示しています。</target>
        </trans-unit>
        <trans-unit id="ef8241368a545dcfd4804f314c3279bd316a6040" translate="yes" xml:space="preserve">
          <source>One way around this problem is to check the extended error code returned by an sqlite3_step() call. If there is a blocking connection, then the extended error code is set to SQLITE_LOCKED_SHAREDCACHE. Otherwise, in the special &quot;DROP TABLE/INDEX&quot; case, the extended error code is just SQLITE_LOCKED.</source>
          <target state="translated">この問題を回避する一つの方法は、sqlite3_step()呼び出しで返される拡張エラーコードをチェックすることです。ブロッキング接続がある場合、拡張エラーコードはSQLITE_LOCKED_SHAREDCACHEに設定されます。そうでなければ、特別な &quot;DROP TABLE/INDEX &quot;の場合、拡張エラーコードはSQLITE_LOCKEDだけになります。</target>
        </trans-unit>
        <trans-unit id="acee115381c0c09c4f7ee9640610c7e8117858b5" translate="yes" xml:space="preserve">
          <source>One way to compute FindFrame(P,M) would be to scan the aPgno array starting with the M-th entry and working backwards towards the beginning and return J where aPgno[J]==P. Such an algorithm would work, and it would be faster than searching the whole WAL file for the latest frame with page number P. But the search can be made much faster still by using the aHash structure.</source>
          <target state="translated">FindFrame(P,M)を計算する一つの方法は、M番目のエントリから始まり、最初のエントリに向かって遡っていくaPgno配列をスキャンし、aPgno[J]==PでJを返すというものです。このようなアルゴリズムは機能し、ページ番号Pの最新のフレームをWALファイル全体から探すよりも高速です。</target>
        </trans-unit>
        <trans-unit id="43ce70174605b98e2611ee3fa62c55d5c3b3d847" translate="yes" xml:space="preserve">
          <source>One way to create an imposter table is to directly edit the sqlite_master table to insert a new row that describes the table. For example, suppose the schema is like this:</source>
          <target state="translated">インポスターテーブルを作成する1つの方法は、sqlite_masterテーブルを直接編集して、テーブルを記述する新しい行を挿入することです。例えば、スキーマが次のようなものだとします。</target>
        </trans-unit>
        <trans-unit id="84cd9c4bdeae83b60aa9ede1d4ab69d156255724" translate="yes" xml:space="preserve">
          <source>One way to create an imposter table is to directly edit the sqlite_schema table to insert a new row that describes the table. For example, suppose the schema is like this:</source>
          <target state="translated">偽装テーブルを作成する1つの方法は、sqlite_schemaテーブルを直接編集して、テーブルを記述する新しい行を挿入することです。例えば、スキーマが次のようなものだとします。</target>
        </trans-unit>
        <trans-unit id="5371a62fb713016b88bf9cbe1ee3e53f088627a9" translate="yes" xml:space="preserve">
          <source>One way to use sqlite3 in a shell script is to use &quot;echo&quot; or &quot;cat&quot; to generate a sequence of commands in a file, then invoke sqlite3 while redirecting input from the generated command file. This works fine and is appropriate in many circumstances. But as an added convenience, sqlite3 allows a single SQL command to be entered on the command line as a second argument after the database name. When the sqlite3 program is launched with two arguments, the second argument is passed to the SQLite library for processing, the query results are printed on standard output in list mode, and the program exits. This mechanism is designed to make sqlite3 easy to use in conjunction with programs like &quot;awk&quot;. For example:</source>
          <target state="translated">シェルスクリプトでsqlite3を使う一つの方法は、&quot;echo &quot;や &quot;cat &quot;を使ってファイルに一連のコマンドを生成し、生成されたコマンドファイルから入力をリダイレクトしながらsqlite3を起動することです。これはうまく動作し、多くの状況で適切です。しかし、追加の利便性として、sqlite3は単一のSQLコマンドをデータベース名の後の第二引数としてコマンドラインに入力することができます。sqlite3プログラムが2つの引数で起動されると、2番目の引数は処理のためにSQLiteライブラリに渡され、クエリ結果はリストモードで標準出力に印刷され、プログラムは終了します。この仕組みは、&quot;awk &quot;のようなプログラムと組み合わせてsqlite3を使いやすくするためのものです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="c9f164cc934fc44dc3087a408a43d581d45a004f" translate="yes" xml:space="preserve">
          <source>One would get the same answer without the use of the R*Tree index using the following simpler query:</source>
          <target state="translated">R*Treeインデックスを使用しなくても、以下のより単純なクエリを使用して同じ答えを得ることができます。</target>
        </trans-unit>
        <trans-unit id="17f5a4fe2f5c62ecd81776d246b8c0c725190c25" translate="yes" xml:space="preserve">
          <source>One-Step Query Execution Interface</source>
          <target state="translated">ワンステップクエリ実行インタフェース</target>
        </trans-unit>
        <trans-unit id="aa3d3adac784c0d74a31276058a965e9e8ca9895" translate="yes" xml:space="preserve">
          <source>Online Backup API</source>
          <target state="translated">オンラインバックアップAPI</target>
        </trans-unit>
        <trans-unit id="84ecd14ddbadabe468f63832d803f2392f405f33" translate="yes" xml:space="preserve">
          <source>Online Backup API.</source>
          <target state="translated">オンラインバックアップAPI。</target>
        </trans-unit>
        <trans-unit id="df4435ab96f572a5ddc0d0575dab3a2326c426c1" translate="yes" xml:space="preserve">
          <source>Online Backup Object</source>
          <target state="translated">オンラインバックアップオブジェクト</target>
        </trans-unit>
        <trans-unit id="cf333df0d0137378797eeac3fd91be937936f09b" translate="yes" xml:space="preserve">
          <source>Only CPU cycle counts are being measured here. CPU cycle counts are a good proxy for energy consumption, but do not necessary correlate well with real-world timings. Time spent doing I/O is not reflected in the CPU cycle counts, and I/O time predominates in many SQLite usage scenarios.</source>
          <target state="translated">ここではCPUサイクルカウントのみを測定しています。CPUサイクルカウントはエネルギー消費量の良いプロキシですが、実際のタイミングとの相関性はあまり必要ありません。I/Oを行っていた時間はCPUサイクルカウントには反映されておらず、多くのSQLite使用シナリオではI/O時間が主に使用されています。</target>
        </trans-unit>
        <trans-unit id="d5604491374c9f17a80675ca75c6861a336b77e6" translate="yes" xml:space="preserve">
          <source>Only a single authorizer can be in place on a database connection at a time. Each call to sqlite3_set_authorizer overrides the previous call. Disable the authorizer by installing a NULL callback. The authorizer is disabled by default.</source>
          <target state="translated">一度に1つのデータベース接続に1つのオーソライザーだけを配置することができます。sqlite3_set_authorizerの各呼び出しは前の呼び出しを上書きします。NULLコールバックをインストールすることでオーサライザを無効にします。オーサライザはデフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="478d5d49691bd8c6240a1fe276d18045c9e67957" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;ごとに一度に定義できる進行ハンドラは1つだけです。新しい進捗ハンドラを設定すると、古いハンドラがキャンセルされます。パラメータXをNULLに設定すると、進捗ハンドラが無効になります。Nを1未満の値に設定すると、進行状況ハンドラーも無効になります。</target>
        </trans-unit>
        <trans-unit id="94e56a9c57047e711c69e819b360a3dd7e101263" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;ごとに一度に定義できる進行ハンドラは1つだけです。新しい進捗ハンドラを設定すると、古いハンドラがキャンセルされます。パラメータXをNULLに設定すると、進捗ハンドラが無効になります。Nを1未満の値に設定すると、進行状況ハンドラーも無効になります。</target>
        </trans-unit>
        <trans-unit id="7036e4ebe3282d4cd750dee2b265f33019cf27cb" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;../lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">INSERT、UPDATE、またはDELETEステートメントによって直接行われた変更のみが考慮され&lt;a href=&quot;../lang_createtrigger&quot;&gt;ます。トリガー&lt;/a&gt;、&lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;外部キーアクション、&lt;/a&gt;または&lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt;制約の解決によって引き起こされた補助的な変更はカウントされません。</target>
        </trans-unit>
        <trans-unit id="c27ab9dbf00600e9d93b4dae249b72bd85740109" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">INSERT、UPDATE、またはDELETEステートメントによって直接行われた変更のみが考慮され&lt;a href=&quot;lang_createtrigger&quot;&gt;ます。トリガー&lt;/a&gt;、&lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;外部キーアクション、&lt;/a&gt;または&lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;制約の解決によって引き起こされた補助的な変更はカウントされません。</target>
        </trans-unit>
        <trans-unit id="9ca2d95ecc0496343a0233bd681510ca318c6946" translate="yes" xml:space="preserve">
          <source>Only columns a and b of the index would be usable. The d column would not be usable because column c is not constrained and there can be no gaps in the set of columns that usable by the index.</source>
          <target state="translated">インデックスのa列とb列だけが使用可能です。c列は制約を受けておらず、インデックスが使用可能な列の集合に隙間がないため、d列は使用できません。</target>
        </trans-unit>
        <trans-unit id="05736f4fee6c4c67dfd5428743f05e710b55053c" translate="yes" xml:space="preserve">
          <source>Only columns a, b, and c of the index would be usable. The d column would not be usable because it occurs to the right of c and c is constrained only by inequalities.</source>
          <target state="translated">インデックスの a,b,c 列だけが使用可能です。d列はcの右側にあり、cは不等式によってのみ制約されるため、使用できません。</target>
        </trans-unit>
        <trans-unit id="6822d83fba844c52182b6e2b1305124432ab29b8" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;master journal&lt;/a&gt; files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="translated">2つ以上の接続されたデータベースがすべて変更され、&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt;がOFFに設定されておらず、&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt;がOFF、MEMORY、またはWALに設定されていない場合にのみ、&lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;マスタージャーナル&lt;/a&gt;ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="9d1635246b5aeaad6de58e92e5095276c845c10a" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; files when their size exceeds a threshold. Otherwise the journal is held in memory and no I/O occurs. The threshold can be configured at compile-time using &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; or at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt;).</source>
          <target state="translated">サイズがしきい値を超えた場合にのみ、&lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;ステートメントジャーナル&lt;/a&gt;ファイルを作成します。それ以外の場合、ジャーナルはメモリに保持され、I / Oは発生しません。しきい値は、コンパイル時に&lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt;を使用して、または開始時に&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt;）を使用して構成できます。</target>
        </trans-unit>
        <trans-unit id="04951ae9e91c50e633618b0424f4870112bf6e2c" translate="yes" xml:space="preserve">
          <source>Only create master journal files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="translated">2つ以上の接続されたデータベースがすべて変更され、&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt;がOFFに設定されておらず、&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt;がOFF、MEMORY、またはWALに設定されていない場合にのみ、マスタージャーナルファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="610003d6616c61d3e569880b1cf6337a8bfaac43" translate="yes" xml:space="preserve">
          <source>Only rows of the table for which the WHERE clause evaluates to true are included in the index. If the WHERE clause expression evaluates to NULL or to false for some rows of the table, then those rows are omitted from the index.</source>
          <target state="translated">WHERE句が真と評価されるテーブルの行のみがインデックスに含まれます。WHERE句式の評価値がNULLまたはFalseの場合、それらの行はインデックスから除外されます。</target>
        </trans-unit>
        <trans-unit id="255e530c466468dcdf3e2dbc7217cf60c632c517" translate="yes" xml:space="preserve">
          <source>Only terms of the vocabulary with a matching langid are searched. Hence, the same table can contain entries from multiple languages and only the requested language will be used. The default langid is 0.</source>
          <target state="translated">一致する言語の語彙の用語のみが検索されます。したがって、同じテーブルに複数の言語からのエントリを含めることができ、要求された言語のみが使用されます。デフォルトのlangidは0です。</target>
        </trans-unit>
        <trans-unit id="2ece13f71abf0bca8da38ece8f95957b023f2f28" translate="yes" xml:space="preserve">
          <source>Only the &quot;ll&quot; length modifier ever makes a difference for SQLite. And it only makes a difference when using the C-language interfaces.</source>
          <target state="translated">SQLite の場合、&quot;ll &quot;長の修飾子だけが違いを生むことがあります。そして、C 言語のインターフェイスを使用しているときだけ違いがあります。</target>
        </trans-unit>
        <trans-unit id="85148a6237828ed28c44695045ab73ff06e6fcad" translate="yes" xml:space="preserve">
          <source>Only the RENAME TABLE, ADD COLUMN, and RENAME COLUMN variants of the ALTER TABLE command are supported. Other kinds of ALTER TABLE operations such as DROP COLUMN, ALTER COLUMN, ADD CONSTRAINT, and so forth are omitted.</source>
          <target state="translated">ALTER TABLEコマンドのRENAME TABLE、ADD COLUMN、RENAME COLUMNのみサポートしています。DROP COLUMN、ALTER COLUMN、ADD CONSTRAINTなどの他の種類のALTER TABLE操作は省略されています。</target>
        </trans-unit>
        <trans-unit id="718ea1282b5847e8c3e9e8f8d5345c6ee50c38cc" translate="yes" xml:space="preserve">
          <source>Only the implicit version of the AND operator is supported. Specifying the string &quot;AND&quot; as part of a standard query syntax query is interpreted as a term query for the set of documents containing the term &quot;and&quot;.</source>
          <target state="translated">AND演算子の暗黙のバージョンだけがサポートされています。標準的なクエリ構文クエリの一部として文字列 &quot;AND &quot;を指定すると、用語 &quot;and &quot;を含む文書の集合に対する用語クエリとして解釈されます。</target>
        </trans-unit>
        <trans-unit id="1eda18e73564838ddd329dd3f15abb7d2f114fbe" translate="yes" xml:space="preserve">
          <source>Only the three core routines described in section 1.0 are required to use SQLite. But there are many other functions that provide useful interfaces. These extended routines are as follows:</source>
          <target state="translated">SQLiteを使用するために必要なのは、1.0節で説明した3つのコアルーチンのみです。しかし、有用なインターフェースを提供する他の多くの関数があります。これらの拡張ルーチンは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="9ddd9d23f19b01af8d3915a7bfd11c89aef2d1d4" translate="yes" xml:space="preserve">
          <source>Only use indexes-on-expressions to optimize ORDER BY or GROUP BY if the COLLATE is correct. Ticket &lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</source>
          <target state="translated">COLLATEが正しい場合にのみ、ORDERS-ON-EXPRESSIONSを使用してORDER BYまたはGROUP BYを最適化します。チケット&lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c74dd7ced7cd4ea8002b3c96a9b1ecdff66b1e59" translate="yes" xml:space="preserve">
          <source>Opcode Name</source>
          <target state="translated">オペコード名</target>
        </trans-unit>
        <trans-unit id="1682c59856887894432baf4bb39e98c21d42d731" translate="yes" xml:space="preserve">
          <source>Opcode definitions</source>
          <target state="translated">オプコード定義</target>
        </trans-unit>
        <trans-unit id="313411b9bd1b97b8fcd666d91d350cb8e6bed0d1" translate="yes" xml:space="preserve">
          <source>Open A BLOB For Incremental I/O</source>
          <target state="translated">インクリメンタルI/O用のBLOBを開く</target>
        </trans-unit>
        <trans-unit id="beb2e15e058a69d62502daa1bdfb1095abeb86de" translate="yes" xml:space="preserve">
          <source>Open a cursor into the table to be queried.</source>
          <target state="translated">クエリ対象のテーブルにカーソルを開きます。</target>
        </trans-unit>
        <trans-unit id="7e8e851c144078264ee423ec854e116a3d7fdff4" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 that points to the same ephemeral table as cursor P2. The P2 cursor must have been opened by a prior &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; opcode. Only ephemeral cursors may be duplicated.</source>
          <target state="translated">カーソルP2と同じ一時テーブルを指す新しいカーソルP1を開きます。P2カーソルは、前の&lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt;オペコードによって開かれている必要があります。一時カーソルのみを複製できます。</target>
        </trans-unit>
        <trans-unit id="57454cf77dc40f8ad1e1086dd9c199e6c88ed771" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 to a transient table. The cursor is always opened read/write even if the main database is read-only. The ephemeral table is deleted automatically when the cursor is closed.</source>
          <target state="translated">トランジェントテーブルに新規カーソルP1をオープンします。メインデータベースが読み取り専用であっても、カーソルは常に読み書きで開かれます。エフェメラルテーブルはカーソルを閉じると自動的に削除されます。</target>
        </trans-unit>
        <trans-unit id="545bc19bf66be6511144aed187f1840c5a4278d1" translate="yes" xml:space="preserve">
          <source>Open a new cursor that points to a fake table that contains a single row of data. The content of that one row is the content of memory register P2. In other words, cursor P1 becomes an alias for the MEM_Blob content contained in register P2.</source>
          <target state="translated">1行のデータを含む偽のテーブルを指す新しいカーソルを開きます。その1行の内容は、メモリレジスタP2の内容です。つまり、カーソルP1は、レジスタP2に含まれるMEM_Blobの内容のエイリアスになります。</target>
        </trans-unit>
        <trans-unit id="135ddb8c48350a0a78c4aa223b6b8ae16522c7fd" translate="yes" xml:space="preserve">
          <source>Open a read-only cursor for the database table whose root page is P2 in a database file. The database file is determined by P3. P3==0 means the main database, P3==1 means the database used for temporary tables, and P3&amp;gt;1 means used the corresponding attached database. Give the new cursor an identifier of P1. The P1 values need not be contiguous but all P1 values should be small integers. It is an error for P1 to be negative.</source>
          <target state="translated">データベースファイルで、ルートページがP2であるデータベーステーブルの読み取り専用カーソルを開きます。データベースファイルはP3によって決定されます。P3 == 0はメインデータベースを意味し、P3 == 1は一時テーブルに使用されるデータベースを意味し、P3&amp;gt; 1は対応する接続​​データベースを使用することを意味します。新しいカーソルにP1の識別子を与えます。P1値は連続している必要はありませんが、すべてのP1値は小さい整数である必要があります。P1が負になるのはエラーです。</target>
        </trans-unit>
        <trans-unit id="84089bd01646e44fd57253086466eec04ccae47a" translate="yes" xml:space="preserve">
          <source>Open a read/write cursor named P1 on the table or index whose root page is P2 (or whose root page is held in register P2 if the OPFLAG_P2ISREG bit is set in P5 - see below).</source>
          <target state="translated">ルートページがP2であるテーブルまたはインデックス上にP1という名前の読み書きカーソルをオープンします(OPFLAG_P2ISREGビットがP5にセットされている場合は、そのルートページがレジスタP2に保持されています-以下を参照)。</target>
        </trans-unit>
        <trans-unit id="4063448157b3ab2686e1495793b9571ba748ea89" translate="yes" xml:space="preserve">
          <source>Open an RBU handle using the sqlite3rbu_open(T,A,S) function.</source>
          <target state="translated">sqlite3rbu_open(T,A,S)関数を使用してRBUハンドルを開きます。</target>
        </trans-unit>
        <trans-unit id="6423cf77a906b294f7ccb82649c19b9b21d337a4" translate="yes" xml:space="preserve">
          <source>Open file &quot;/home/fred/data.db&quot;. Use the special VFS &quot;unix-dotfile&quot; that uses dot-files in place of posix advisory locking.</source>
          <target state="translated">ファイル「/home/fred/data.db」を開きます。posixのアドバイザリロックの代わりにドットファイルを使用する特殊なVFS「unix-dotfile」を使用します。</target>
        </trans-unit>
        <trans-unit id="d23dfc68fcbe2b64c96946a59f2391f88d879ada" translate="yes" xml:space="preserve">
          <source>Open file &quot;data.db&quot; in the current directory for read-only access. Regardless of whether or not shared-cache mode is enabled by default, use a private cache.</source>
          <target state="translated">読み取り専用のアクセスのために、カレントディレクトリにあるファイル &quot;data.db &quot;を開きます。デフォルトで共有キャッシュモードが有効になっているかどうかに関わらず、プライベートキャッシュを使用します。</target>
        </trans-unit>
        <trans-unit id="32023375b26a0776fe1660f78af585c47d78b01e" translate="yes" xml:space="preserve">
          <source>Open the database file &quot;/home/fred/data.db&quot;.</source>
          <target state="translated">データベースファイル「/home/fred/data.db」を開きます。</target>
        </trans-unit>
        <trans-unit id="b140126e4bb0c579baba79fa4b78910264cad628" translate="yes" xml:space="preserve">
          <source>Open the database file and obtain a SHARED lock. If the SHARED lock cannot be obtained, fail immediately and return SQLITE_BUSY.</source>
          <target state="translated">データベースファイルを開き、SHAREDロックを取得します。SHARED ロックが取得できない場合は、直ちに失敗して SQLITE_BUSY を返します。</target>
        </trans-unit>
        <trans-unit id="1fdbee3b0460b37f393d93c476774730b651cdaf" translate="yes" xml:space="preserve">
          <source>Open the file &quot;data.db&quot; in the current directory.</source>
          <target state="translated">カレントディレクトリにある「data.db」というファイルを開きます。</target>
        </trans-unit>
        <trans-unit id="e305cdc0a6e58d2992d00df36114935a966f06eb" translate="yes" xml:space="preserve">
          <source>Open two cursors, one to each of the two tables being queried.</source>
          <target state="translated">2つのカーソルを開き、1つは問い合わせ先の2つのテーブルにそれぞれ1つずつ。</target>
        </trans-unit>
        <trans-unit id="db8828ea77768020acda7b34e1bdcfb01f4a650b" translate="yes" xml:space="preserve">
          <source>Open, release or rollback the savepoint named by parameter P4, depending on the value of P1. To open a new savepoint set P1==0 (SAVEPOINT_BEGIN). To release (commit) an existing savepoint set P1==1 (SAVEPOINT_RELEASE). To rollback an existing savepoint set P1==2 (SAVEPOINT_ROLLBACK).</source>
          <target state="translated">パラメータP4で指定されたセーブポイントをオープン、リリース、またはロールバックします。新規セーブポイントを開くには、P1==0 (SAVEPOINT_BEGIN)を設定します。既存のセーブポイントを解放(コミット)するには、P1==1 (SAVEPOINT_RELEASE)を設定します。既存のセーブポイントをロールバックするには、P1==2 (SAVEPOINT_ROLLBACK)を設定します。</target>
        </trans-unit>
        <trans-unit id="e54c6e14fb4a075fa699ffdaaaf395ff313982e8" translate="yes" xml:space="preserve">
          <source>OpenAutoindex</source>
          <target state="translated">OpenAutoindex</target>
        </trans-unit>
        <trans-unit id="4102c59c0ab3f6e830e46718de359a59f628ee07" translate="yes" xml:space="preserve">
          <source>OpenDup</source>
          <target state="translated">OpenDup</target>
        </trans-unit>
        <trans-unit id="ad5bdfbe38582d74f4e2d987d0014c4a061fc0bc" translate="yes" xml:space="preserve">
          <source>OpenEphemeral</source>
          <target state="translated">OpenEphemeral</target>
        </trans-unit>
        <trans-unit id="4a5d4d0e6cf7c26b571b8ed8b7d9e91f5a55707c" translate="yes" xml:space="preserve">
          <source>OpenPseudo</source>
          <target state="translated">OpenPseudo</target>
        </trans-unit>
        <trans-unit id="321f145cb1e3470cc293ca452256220e4b476cbf" translate="yes" xml:space="preserve">
          <source>OpenRead</source>
          <target state="translated">OpenRead</target>
        </trans-unit>
        <trans-unit id="3894e594709a936290c9439b10b580db3b56e3b5" translate="yes" xml:space="preserve">
          <source>OpenWrite</source>
          <target state="translated">OpenWrite</target>
        </trans-unit>
        <trans-unit id="10f17177db5db183ce11fbbf98483043f8f93d13" translate="yes" xml:space="preserve">
          <source>Openclose callback</source>
          <target state="translated">オープンクローズコールバック</target>
        </trans-unit>
        <trans-unit id="f1ba5b2c8dba45952ee1dd4e3e5587becf1e4832" translate="yes" xml:space="preserve">
          <source>Opening A New Database Connection</source>
          <target state="translated">新しいデータベース接続を開く</target>
        </trans-unit>
        <trans-unit id="8bea067fa84f98eb8cb08b76d377cd2759d84a48" translate="yes" xml:space="preserve">
          <source>Opening a New Connection</source>
          <target state="translated">新しい接続を開く</target>
        </trans-unit>
        <trans-unit id="0fcdc2f790b5b05c0b11e1b00c614a1147af7a65" translate="yes" xml:space="preserve">
          <source>Opening a Read-Only Transaction</source>
          <target state="translated">読み取り専用のトランザクションを開く</target>
        </trans-unit>
        <trans-unit id="8c328ea219e123938753dd011cc218695e36770e" translate="yes" xml:space="preserve">
          <source>Opening a connection.</source>
          <target state="translated">接続を開く。</target>
        </trans-unit>
        <trans-unit id="0a848c1fa6f5b691a8b43871dbf9920b32a63f8f" translate="yes" xml:space="preserve">
          <source>Opening a new database connection is a two-step process:</source>
          <target state="translated">新しいデータベース接続を開くには、2つのステップがあります。</target>
        </trans-unit>
        <trans-unit id="60a2e026abe5554a6164ccf369d3bdb712d462a6" translate="yes" xml:space="preserve">
          <source>Opening a read-only transaction.</source>
          <target state="translated">読み取り専用のトランザクションを開く。</target>
        </trans-unit>
        <trans-unit id="d0a97ec8f1b3b761b48ba3f0b5793b7b063cf28e" translate="yes" xml:space="preserve">
          <source>Opening a read-write transaction.</source>
          <target state="translated">読み書き可能なトランザクションをオープンします。</target>
        </trans-unit>
        <trans-unit id="5bef4a855a587c7ae88d0d6e7fbc4f0cf1d92d9c" translate="yes" xml:space="preserve">
          <source>Opening a statement transaction.</source>
          <target state="translated">ステートメント取引を開く。</target>
        </trans-unit>
        <trans-unit id="5f6fc2590106eab5d853e4838b574315ff3651ac" translate="yes" xml:space="preserve">
          <source>Operand P1 must be 0x7fffffff and P2 must positive.</source>
          <target state="translated">オペランドP1は0x7fffffff、P2は正でなければなりません。</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="653e79b2411d60c991c837c40648dc99da326979" translate="yes" xml:space="preserve">
          <source>Optimization: When doing an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; on a table with &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, do not update the expression indexes if they do not refer to any of the columns of the table being updated.</source>
          <target state="translated">最適化：&lt;a href=&quot;expridx&quot;&gt;式&lt;/a&gt;にインデックスがあるテーブルで&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;を実行するとき、更新されるテーブルの列を参照していない場合は、式のインデックスを更新しないでください。</target>
        </trans-unit>
        <trans-unit id="a794f9704b3031ad0771d79793775c086e03f157" translate="yes" xml:space="preserve">
          <source>Optimizations to the sqlite_mprintf() routine.</source>
          <target state="translated">sqlite_mprintf()ルーチンの最適化。</target>
        </trans-unit>
        <trans-unit id="088089a3961fc329e20285999528f0da0604b13a" translate="yes" xml:space="preserve">
          <source>Optimize the &lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#length&quot;&gt;length()&lt;/a&gt; SQL functions so that they avoid unnecessary reading of database content from disk.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof（）&lt;/a&gt;および&lt;a href=&quot;lang_corefunc#length&quot;&gt;length（）&lt;/a&gt; SQL関数を最適化して、ディスクからのデータベースコンテンツの不要な読み取りを回避します。</target>
        </trans-unit>
        <trans-unit id="89ea4f0e94546aba0e6576de32f5af050f08375b" translate="yes" xml:space="preserve">
          <source>Optimizer does a better job of using indices to satisfy ORDER BY clauses that sort on the integer primary key</source>
          <target state="translated">オプティマイザーは、整数の主キーでソートするORDER BY句を満たすためにインデックスを使用することができるようになりました。</target>
        </trans-unit>
        <trans-unit id="d859dd72c637fafc6319ca0f4f6cb8c1fd01736f" translate="yes" xml:space="preserve">
          <source>Optimizer enhancement: &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; are automatically re-compiled when a binding on the RHS of a LIKE operator changes or when any range constraint changes under &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;.</source>
          <target state="translated">オプティマイザの強化：LIKE演算子のRHSでのバインディングが変更されたとき、または&lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2で&lt;/a&gt;範囲制約が変更されたときに、&lt;a href=&quot;c3ref/stmt&quot;&gt;準備されたステートメント&lt;/a&gt;が自動的に再コンパイルされます。</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="6120d3ea8f989e319fa4157b88a6894abd99ea8b" translate="yes" xml:space="preserve">
          <source>Option 1:</source>
          <target state="translated">オプション1。</target>
        </trans-unit>
        <trans-unit id="787636b9cef675727f97423a49f2d6e8aeb5b354" translate="yes" xml:space="preserve">
          <source>Option 2:</source>
          <target state="translated">オプション2</target>
        </trans-unit>
        <trans-unit id="620a38bc45cce1e89bad8abed95cee233ec74ca8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY Clauses</source>
          <target state="translated">オプションの制限と ORDER BY 条項</target>
        </trans-unit>
        <trans-unit id="4a8101f15dc88fa6899984a679049286645dada8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY clauses</source>
          <target state="translated">オプションのLIMITとORDER BY句</target>
        </trans-unit>
        <trans-unit id="147fccad2acf5d54cf4c9bd90959d2b685bb12a8" translate="yes" xml:space="preserve">
          <source>Optional READ UNCOMMITTED isolation (instead of the default isolation level of SERIALIZABLE) and table level locking when database connections share a common cache.</source>
          <target state="translated">データベース接続が共通のキャッシュを共有している場合のREAD UNCOMMITTED隔離(デフォルトのSERIALIZABLE隔離レベルの代わりに)とテーブルレベルのロックをオプションで指定できます。</target>
        </trans-unit>
        <trans-unit id="99e39e3c25d749e303cfb0392ac6108be81a9ed0" translate="yes" xml:space="preserve">
          <source>Optionally, a &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt; constraint.</source>
          <target state="translated">オプションで、&lt;a href=&quot;gencol&quot;&gt;生成された列&lt;/a&gt;制約。</target>
        </trans-unit>
        <trans-unit id="f3c4d258c19e0b0e32f1a0047f810a58bf67a8d7" translate="yes" xml:space="preserve">
          <source>Optionally, a PRIMARY KEY for the table. Both single column and composite (multiple column) primary keys are supported.</source>
          <target state="translated">オプションで、テーブルのPRIMARY KEY。シングルカラムとコンポジット(複数カラム)の両方の主キーがサポートされています。</target>
        </trans-unit>
        <trans-unit id="afb65b09ecb1abf655b3870806d0d663e9055759" translate="yes" xml:space="preserve">
          <source>Options understood by the &lt;b&gt;sqlite3&lt;/b&gt; command include:</source>
          <target state="translated">&lt;b&gt;sqlite3&lt;/b&gt;コマンドが理解できるオプションは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="1a5a89789f35d1adc160640f07b04eccb062e675" translate="yes" xml:space="preserve">
          <source>Or consider these identical queries:</source>
          <target state="translated">または、これらの同一のクエリを考えてみてください。</target>
        </trans-unit>
        <trans-unit id="aa8e4bd6460fbb4edd20d4ab7cc84cb756c25fa7" translate="yes" xml:space="preserve">
          <source>Or on Windows with MSVC:</source>
          <target state="translated">またはMSVCを搭載したWindows上で。</target>
        </trans-unit>
        <trans-unit id="65cc0e4d32009c846d3d67b851864fc0e2100eac" translate="yes" xml:space="preserve">
          <source>Or optimization</source>
          <target state="translated">または最適化</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
