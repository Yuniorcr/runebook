<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="33c558ed5ce36b119e16ee3e9d824eb5021f92cb" translate="yes" xml:space="preserve">
          <source>In the previous sections, we have seen how moving from a key/value store implemented as a ZIP archive to a simple SQLite database with just three tables can add significant capabilities to an application file format. We could continue to enhance the schema with new tables, with indexes added for performance, with triggers and views for programming convenience, and constraints to enforce consistency of content even in the face of programming errors. Further enhancement ideas include:</source>
          <target state="translated">前のセクションでは、ZIP アーカイブとして実装されたキー/値ストアから、わずか 3 つのテーブルを持つシンプルな SQLite データベースに移行することで、アプリケーションのファイル形式に重要な機能を追加できることを見てきました。新しいテーブル、パフォーマンスのために追加されたインデックス、プログラミングの利便性のためのトリガーとビュー、プログラミングエラーに直面してもコンテンツの一貫性を強制するための制約など、スキーマの強化を続けていくことができます。さらなる強化案としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="6567a872214501806e02589f934b8c11a8b0e4f5" translate="yes" xml:space="preserve">
          <source>In the previous, the &quot;type NOT IN ('object','array')&quot; term of the WHERE clause suppresses containers and only lets through leaf elements. The same effect could be achieved this way:</source>
          <target state="translated">先ほどの例では、WHERE句の &quot;type NOT IN ('object','array')&quot;の項はコンテナを抑制し、リーフ要素のみを通しています。この方法でも同じ効果が得られます。</target>
        </trans-unit>
        <trans-unit id="1dd63ff23c59a1e0a739d0a06a35ed29c44ad2c6" translate="yes" xml:space="preserve">
          <source>In the query above, if both t1 and t2 have approximately N rows, then without any indices the query will require O(N*N) time. On the other hand, creating an index on table t2 requires O(NlogN) time and then use that index to evaluate the query requires an additional O(NlogN) time. In the absence of &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; information, SQLite guesses that N is one million and hence it believes that constructing the automatic index will be the cheaper approach.</source>
          <target state="translated">上記のクエリで、t1とt2の両方に約N行がある場合、インデックスがないと、クエリはO（N * N）時間を必要とします。一方、テーブルt2にインデックスを作成するにはO（NlogN）時間を要し、そのインデックスを使用してクエリを評価するには、追加のO（NlogN）時間が必要です。&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;情報がない場合、SQLiteはNが100万であると推測しているため、自動インデックスを構築する方が安価なアプローチであると考えています。</target>
        </trans-unit>
        <trans-unit id="d42fa24dde8794f21d6a489ff49ead792c8bc812" translate="yes" xml:space="preserve">
          <source>In the query above, one would presumably bind the binary BLOB description of the precise boundary of the 12th district to the &quot;:boundary&quot; parameter.</source>
          <target state="translated">上記のクエリでは、12区の正確な境界を表すバイナリBLOBの記述を&quot;:boundary &quot;パラメータにバインドします。</target>
        </trans-unit>
        <trans-unit id="5dbfd2d21d7bf5385c8b5fed28f3d0558f663390" translate="yes" xml:space="preserve">
          <source>In the query above, the &quot;PARTITION BY c&quot; clause breaks the result set up into three partitions. The first partition has three rows with c=='one'. The second partition has two rows with c=='three' and the third partition has two rows with c=='two'.</source>
          <target state="translated">上のクエリでは、&quot;PARTITION BY c &quot;句は、結果セットを3つのパーティションに分割します。最初のパーティションはc=='1'で3行です。2番目のパーティションはc=='3'で2行、3番目のパーティションはc=='2'で2行です。</target>
        </trans-unit>
        <trans-unit id="ff23670a4dd151a2afe2511d238ffe5c9f59a6d2" translate="yes" xml:space="preserve">
          <source>In the query above, the &quot;a&quot; column is part of the GROUP BY clause and so each row of the output contains one of the distinct values for &quot;a&quot;. The &quot;c&quot; column is contained within the &lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum()&lt;/a&gt; aggregate function and so that output column is the sum of all &quot;c&quot; values in rows that have the same value for &quot;a&quot;. But what is the result of the bare column &quot;b&quot;? The answer is that the &quot;b&quot; result will be the value for &quot;b&quot; in one of the input rows that form the aggregate. The problem is that you usually do not know which input row is used to compute &quot;b&quot;, and so in many cases the value for &quot;b&quot; is undefined.</source>
          <target state="translated">上記のクエリでは、 &quot;a&quot;列はGROUP BY句の一部であるため、出力の各行には &quot;a&quot;の個別の値の1つが含まれています。「c」列は&lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum（）&lt;/a&gt;集約関数内に含まれているため、出力列は「a」に対して同じ値を持つ行のすべての「c」値の合計になります。しかし、裸の列「b」の結果は何ですか？答えは、「b」の結果は、集計を形成する入力行の1つにおける「b」の値になるということです。問題は、通常、「b」の計算に使用される入力行がわからないため、多くの場合、「b」の値が定義されていないことです。</target>
        </trans-unit>
        <trans-unit id="cd7c1539a48900d085cdab5fe3ab086624874b10" translate="yes" xml:space="preserve">
          <source>In the query above, the subquery &quot;SELECT b FROM ex2&quot; is evaluated and its results are stored in a temporary table (actually a temporary index) that allows one to determine whether or not a value ex2.b exists using a simple binary search. Once this table is constructed, the outer query is run and for each prospective result row a check is made to see if ex1.a is contained within the temporary table. The row is output only if the check is true.</source>
          <target state="translated">上記のクエリでは、サブクエリ &quot;SELECT b FROM ex2 &quot;が評価され、その結果が一時テーブル(実際には一時インデックス)に格納され、単純なバイナリ検索を使用してex2.bの値が存在するかどうかを判断することができます。このテーブルが構築されると、外部クエリが実行され、各結果の候補行に対して、ex1.aが一時テーブルに含まれているかどうかのチェックが行われます。チェックが真の場合にのみ、行が出力されます。</target>
        </trans-unit>
        <trans-unit id="e4290c818e5599eff7616300b06206a049026a55" translate="yes" xml:space="preserve">
          <source>In the query above, the values for the first_name and last_name columns will correspond to the row that satisfied the max(salary) condition.</source>
          <target state="translated">上記のクエリでは、first_name列とlast_name列の値は、max(salary)条件を満たした行に対応します。</target>
        </trans-unit>
        <trans-unit id="812c0304c15e5adbac36486ee814e9ec1db44d78" translate="yes" xml:space="preserve">
          <source>In the revised query, the subquery implemented by a co-routine computes the five most recent values for &quot;a&quot;. Those five values are passed from the co-routine up into the outer query where the &quot;expensive_function()&quot; is invoked on only the specific rows that the application cares about.</source>
          <target state="translated">修正されたクエリでは、サブルーチンによって実装された副問い合わせが &quot;a &quot;の最新の5つの値を計算します。これら5つの値はサブルーチンから外部クエリに渡され、アプリケーションが気にする特定の行のみに&quot; expensive_function()&quot;が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="5464a60c31d2aba9c62ea2f61ec84b78e0768c87" translate="yes" xml:space="preserve">
          <source>In the second example, the expression in the DO UPDATE clause is of the form &quot;excluded.phonenumber&quot;. The &quot;excluded.&quot; prefix causes the &quot;phonenumber&quot; to refer to the value for phonenumber that would have been inserted had there been no conflict. Hence, the effect of the upsert is to insert a phonenumber of Alice if none exists, or to overwrite any prior phonenumber for Alice with the new one.</source>
          <target state="translated">2番目の例では、DO UPDATE句の式は &quot;excluded.phonenumber &quot;という形式である。接頭辞 &quot;excluded.&quot;は、&quot;phonenumber &quot;が、競合がなければ挿入されていたであろうphonenumberの値を参照していることを意味する。したがって、アップサートの効果は、アリスの電話番号が存在しない場合にアリスの電話番号を挿入するか、 アリスの以前の電話番号を新しい電話番号で上書きすることである。</target>
        </trans-unit>
        <trans-unit id="0d5709c51541d0085c2cbbc496ec178e66f3f72e" translate="yes" xml:space="preserve">
          <source>In the sequence on the left, the second insert will fail. In this case, the strings '0' and '0.0' are treated as numbers since they are being inserted into a numeric column but 0==0.0 which violates the uniqueness constraint. However, the second insert in the right-hand sequence works. In this case, the constants 0 and 0.0 are treated a strings which means that they are distinct.</source>
          <target state="translated">左のシーケンスでは、2回目の挿入に失敗します。この場合、文字列 '0' と '0.0' は数値列に挿入されているので数値として扱われますが、0==0.0 は一意性制約に違反しています。しかし、右手の列の2番目の挿入は動作します。この場合、定数0と0.0は文字列として扱われます。</target>
        </trans-unit>
        <trans-unit id="a547afdf67cd8d948e7c4160e0e5b6f6d4b49400" translate="yes" xml:space="preserve">
          <source>In the shell, &lt;b&gt;sqlite_interrupt()&lt;/b&gt; is invoked when the user presses Control-C</source>
          <target state="translated">シェルでは、ユーザーがControl-Cを押すと&lt;b&gt;sqlite_interrupt（）&lt;/b&gt;が呼び出されます</target>
        </trans-unit>
        <trans-unit id="8d983faa26111b1d1fcd83dfccc76792d6f87417" translate="yes" xml:space="preserve">
          <source>In the spellfix1 algorithm, cFrom is the text as the user entered it and cTo is the correctly spelled text as it exists in the database. The goal of the editdist3 algorithm is to determine how close the user-entered text is to the dictionary text.</source>
          <target state="translated">spellfix1アルゴリズムでは、cFromはユーザーが入力したテキストであり、cToはデータベースに存在する正しくスペルされたテキストです。editdist3アルゴリズムの目的は、ユーザが入力したテキストが辞書のテキストにどれだけ近いかを判断することです。</target>
        </trans-unit>
        <trans-unit id="f33fd6db9521ba57d781c7a6cc1cb461b4a1e385" translate="yes" xml:space="preserve">
          <source>In the sqlite shell, now print the version number on initial startup.</source>
          <target state="translated">sqliteシェルで、初期起動時にバージョン番号を表示するようにしました。</target>
        </trans-unit>
        <trans-unit id="567ed9c7de12cfc6ba8542459479acb37712e779" translate="yes" xml:space="preserve">
          <source>In the sqlite shell, print the &quot;Database opened READ ONLY&quot; message to stderr instead of stdout.</source>
          <target state="translated">sqliteシェルでは、&quot;Database opened READ ONLY &quot;メッセージをstdoutの代わりにstderrに出力します。</target>
        </trans-unit>
        <trans-unit id="04b0bd3687019af0690c1810844c9c6e7505bacb" translate="yes" xml:space="preserve">
          <source>In the statement above, the FTS3 cursor pointer generated by the MATCH operator is send into the carray() table-valued function instead of its intended recipient snippet(). The carray() function treats the pointer as a pointer to an array of integers and returns each integer one by one, thus leaking the content of the FTS3 cursor object. Since the FTS3 cursor object contains pointers to other objects, the statement above would be a pointer leak.</source>
          <target state="translated">上の文では、MATCH演算子によって生成されたFTS3カーソルポインタは、意図された受信者であるsnippet()の代わりにcarray()テーブル値関数に送られています。carray()関数はポインタを整数の配列へのポインタとして扱い、各整数を1つずつ返すので、FTS3カーソルオブジェクトの内容が漏れます。FTS3 カーソルオブジェクトには他のオブジェクトへのポインタが含まれているので、上の文はポインタの漏洩となる。</target>
        </trans-unit>
        <trans-unit id="e5c24d1846d01f843a98c707910ed22a0e9486cc" translate="yes" xml:space="preserve">
          <source>In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier. The values of these parameters (also called &quot;host parameter names&quot; or &quot;SQL parameters&quot;) can be set using the sqlite3_bind_*() routines defined here.</source>
          <target state="translated">上記のテンプレートでは、NNNは整数リテラルを表し、VVVVは英数字の識別子を表します。これらのパラメータ(&quot;ホストパラメータ名 &quot;または &quot;SQLパラメータ &quot;とも呼ばれます)の値は、ここで定義されているsqlite3_bind_*()ルーチンを使って設定することができます。</target>
        </trans-unit>
        <trans-unit id="dee8f982211055f9a9e8d1a438d7f794e0810555" translate="yes" xml:space="preserve">
          <source>In the underlying &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt;, each rowid is stored as a &lt;a href=&quot;fileformat2#varint&quot;&gt;variable-length integer&lt;/a&gt;. That means that small non-negative rowid values take up less disk space than large or negative rowid values.</source>
          <target state="translated">基礎となる&lt;a href=&quot;fileformat2&quot;&gt;ファイル形式では&lt;/a&gt;、各ROWIDは&lt;a href=&quot;fileformat2#varint&quot;&gt;可変長整数&lt;/a&gt;として格納されます。つまり、負でない小さなROWID値は、大きなまたは負のROWID値よりもディスク容量を消費しません。</target>
        </trans-unit>
        <trans-unit id="147d02b1e1e949a788ff444f3cb5e754276ba6d2" translate="yes" xml:space="preserve">
          <source>In this case the aConstraint[].op value is the same as the value returned by &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction()&lt;/a&gt; for FUNCTION.</source>
          <target state="translated">この場合、aConstraint []。op値は、FUNCTIONの&lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction（）&lt;/a&gt;によって返される値と同じです。</target>
        </trans-unit>
        <trans-unit id="b6bf8cbfac9c457904e9c2859da73ee4a95d3f0d" translate="yes" xml:space="preserve">
          <source>In this case using the temporary b-tree can be avoided by creating an index on t2(c), as follows:</source>
          <target state="translated">この場合、以下のようにt2(c)上にインデックスを作成することで、一時的なb-treeの使用を避けることができます。</target>
        </trans-unit>
        <trans-unit id="a530fdc0efceb4d3e07dfc220358b90fa2145a02" translate="yes" xml:space="preserve">
          <source>In this case, SQLite still does a single binary search to find the first entry of the index where fruit='Orange'. Then it extracts the rowid from the index and uses that rowid to lookup the original table entry via binary search and output the price from the original table. But instead of quitting, the database engine then advances to the next row of index to repeat the process for next fruit='Orange' entry. Advancing to the next row of an index (or table) is much less costly than doing a binary search since the next row is often located on the same database page as the current row. In fact, the cost of advancing to the next row is so cheap in comparison to a binary search that we usually ignore it. So our estimate for the total cost of this query is 3 binary searches. If the number of rows of output is K and the number of rows in the table is N, then in general the cost of doing the query is proportional to (K+1)*logN.</source>
          <target state="translated">この場合でも、SQLite は単一のバイナリ検索を行い、fruit='Orange' のインデックスの最初のエントリを見つけます。そして、インデックスから rowid を抽出し、その rowid を使用してバイナリ検索で元のテーブルエントリを検索し、元のテーブルから価格を出力します。しかし、データベースエンジンは、終了する代わりに、次の fruit='Orange' エントリのために処理を繰り返すために、インデックスの次の行に進みます。インデックス(またはテーブル)の次の行に進むことは、バイナリ検索を行うよりもはるかにコストがかかりません。実際、次の行に進むコストはバイナリ検索に比べて非常に安いので、通常は無視しています。したがって、このクエリの総コストの見積もりは3回のバイナリ検索です。出力の行数をK、テーブルの行数をNとすると、一般的にこのクエリを行うコストは(K+1)*logNに比例します。</target>
        </trans-unit>
        <trans-unit id="419a046b4e9791c3dfbe6ecdc597fd0e975a6969" translate="yes" xml:space="preserve">
          <source>In this chart, an SQL statement (&quot;SELECT v FROM kv WHERE k=?1&quot;) is prepared once. Then for each blob, the blob key value is bound to the ?1 parameter and the statement is evaluated to extract the blob content.</source>
          <target state="translated">この図では、SQL文(&quot;SELECT v FROM kv WHERE k=?1&quot;)を一度用意します。そして、各ブロブについて、ブロブ・キーの値を?1パラメータにバインドし、文を評価してブロブの内容を抽出します。</target>
        </trans-unit>
        <trans-unit id="67f262080695617f0fd577e77df041ccaf828f11" translate="yes" xml:space="preserve">
          <source>In this example, the content of the docs.body field for the entry where docs.name is &quot;report-15&quot; will be sent to the editor. After the editor returns, the result will be written back into the docs.body field.</source>
          <target state="translated">この例では、docs.nameが &quot;report-15 &quot;のエントリのdocs.bodyフィールドの内容がエディタに送られます。エディタが戻ってきた後、結果はdocs.bodyフィールドに書き戻されます。</target>
        </trans-unit>
        <trans-unit id="3455933a8fde6f3fc95c8e0f500aee581e4e0da2" translate="yes" xml:space="preserve">
          <source>In this example, the demo_data.boundary field is intended to hold some kind of binary representation of the precise boundaries of the object. The R*Tree index only holds an axis-aligned rectangular boundary for the object. The R*Tree boundary is just an approximation of the true object boundary. So what typically happens is that the R*Tree index is used to narrow a search down to a list of candidate objects and then more detailed and expensive computations are done on each candidate to find if the candidate truly meets the search criteria.</source>
          <target state="translated">この例では、demo_data.boundary フィールドは、オブジェクトの正確な境界のバイナリ表現を保持することを目的としています。R*Tree インデックスは、オブジェクトの軸に沿った長方形の境界のみを保持します。R*Tree の境界は、真のオブジェクトの境界の近似値にすぎません。そのため、一般的には、R*Tree インデックスを使用して、候補となるオブジェクトのリストに絞って検索を行い、その候補が本当に検索条件を満たしているかどうかを見つけるために、各候補に対してより詳細で高価な計算を行います。</target>
        </trans-unit>
        <trans-unit id="0eba84e3861d469d7f133f2d07dd6079cc3e76b6" translate="yes" xml:space="preserve">
          <source>In this example, the rowids are not consecutive but they are ordered. SQLite usually creates rowids beginning with one and increasing by one with each added row. But if rows are deleted, gaps can appear in the sequence. And the application can control the rowid assigned if desired, so that rows are not necessarily inserted at the bottom. But regardless of what happens, the rowids are always unique and in strictly ascending order.</source>
          <target state="translated">この例では、行番号は連続していませんが、順番に並んでいます。SQLiteでは通常、行番号は1から始まり、行が追加されるごとに1ずつ増えていきます。しかし、行が削除された場合には、行の並びに空白が生じる可能性があります。また、アプリケーションは必要に応じて割り当てられた行IDを制御することができるので、行が必ずしも一番下に挿入されるわけではありません。しかし、何が起こったかに関係なく、行IDは常に一意で、厳密に昇順になります。</target>
        </trans-unit>
        <trans-unit id="5350836f804099dba5657839c67d9e6572dea27d" translate="yes" xml:space="preserve">
          <source>In this example, the t2 table is used in a subquery to translate values of the t1.b column. If each table contains N rows, SQLite expects that the subquery will run N times, and hence it will believe it is faster to construct an automatic, transient index on t2 first and then use that index to satisfy the N instances of the subquery.</source>
          <target state="translated">この例では、t1.b列の値を変換する副問い合わせでt2テーブルが使用されています。各テーブルがN行を含む場合、SQLiteは副問い合わせがN回実行されることを想定しているため、最初にt2に自動で過渡的なインデックスを構築してから、そのインデックスを使用して副問い合わせのN個のインスタンスを満たす方が速いと考えています。</target>
        </trans-unit>
        <trans-unit id="c42a9794244d33827402d87bbb30dbcaf8693beb" translate="yes" xml:space="preserve">
          <source>In this last example, the phonebook2 entry is only updated if the validDate for the newly inserted value is newer than the entry already in the table. If the table already contains an entry with the same name and a current validDate, then the WHERE clause causes the DO UPDATE to become a no-op.</source>
          <target state="translated">この最後の例では、新しく挿入された値のvalidDateが既にテーブルにあるエントリよりも新しい場合にのみ、電話帳2のエントリが更新されます。テーブルに同じ名前で現在のvalidDateを持つエントリが既に含まれている場合、WHERE句によってDO UPDATEが実行されなくなります。</target>
        </trans-unit>
        <trans-unit id="25dff0fca0922d5e6626c7a322eba86698c2596d" translate="yes" xml:space="preserve">
          <source>In this latter table, there is only a single B-Tree which uses the &quot;word&quot; column as its key and the &quot;cnt&quot; column as its data. (Technicality: the low-level implementation actually stores both &quot;word&quot; and &quot;cnt&quot; in the &quot;key&quot; area of the B-Tree. But unless you are looking at the low-level byte encoding of the database file, that fact is unimportant.) Because there is only a single B-Tree, the text of the &quot;word&quot; column is only stored once in the database. Furthermore, querying the &quot;cnt&quot; value for a specific &quot;word&quot; only involves a single binary search into the main B-Tree, since the &quot;cnt&quot; value can be retrieved directly from the record found by that first search and without the need to do a second binary search on the rowid.</source>
          <target state="translated">この後者のテーブルでは、&quot;word &quot;列をキーとし、&quot;cnt &quot;列をデータとする単一のB-Treeだけが存在します(技術的な問題:低レベルの実装では、実際には &quot;word &quot;と &quot;cnt &quot;の両方を &quot;キー &quot;領域に格納します)。(技術的な問題:低レベルの実装では、実際には &quot;word &quot;と &quot;cnt &quot;の両方をB-Treeの &quot;key &quot;エリアに格納しています。しかし、データベースファイルの低レベルのバイトエンコーディングを見ていない限り、この事実は重要ではありません)。B-Treeは1つしかないので、&quot;word &quot;カラムのテキストはデータベースに1回しか格納されません。さらに、特定の &quot;word &quot;に対する &quot;cnt &quot;値の問い合わせは、メインのB-Treeへの1回のバイナリ検索だけで済む。</target>
        </trans-unit>
        <trans-unit id="27f1607d8d73cecfa7aadf0af1217d0ee5b1b3de" translate="yes" xml:space="preserve">
          <source>In this query, the &quot;xaxis&quot; and &quot;yaxis&quot; CTEs define the grid of points for which the Mandelbrot Set will be approximated. Each row in the &quot;m(iter,cx,cy,x,y)&quot; CTE means that after &quot;iter&quot; iterations, the Mandelbrot iteration starting at cx,cy has reached point x,y. The number of iterations in this example is limited to 28 (which severely limits the resolution of the computation, but is sufficient for low-resolution ASCII-art output). The &quot;m2(iter,cx,cy)&quot; CTE holds the maximum number of iterations reached when starting at point cx,cy. Finally, each row in the &quot;a(t)&quot; CTE holds a string which is a single line of the output ASCII-art. The SELECT statement at the end just queries the &quot;a&quot; CTE to retrieve all lines of ASCII-art, one by one.</source>
          <target state="translated">このクエリでは、&quot;xaxis &quot;および &quot;yaxis&quot; CTEは、マンデルブロー集合を近似する点のグリッドを定義します。m(iter,cx,cy,x,y)&quot; CTEの各行は、&quot;iter &quot;反復の後、cx,cyから始まるマンデルブロ反復が点x,yに到達したことを意味します。この例の反復回数は 28 回に制限されています (これは計算の解像度を著しく制限していますが,低解像度の ASCII アート出力には十分です)。m2(iter,cx,cy)&quot; CTE は、点 cx,cy から開始したときに到達した最大反復回数を保持します。最後に、&quot;a(t)&quot; CTEの各行は、出力されたASCIIアートの1行の文字列を保持する。最後のSELECT文は、ASCIIアートの全行を1行ずつ取得するために &quot;a&quot; CTEに問い合わせを行うだけです。</target>
        </trans-unit>
        <trans-unit id="e3c6ef43db25cfa53ed4da6f4cdaac9eb93f9ff7" translate="yes" xml:space="preserve">
          <source>In this schema, instead of each slide having a page number that determines its order within the presentation, each slide has a unique integer identifier that is unrelated to where it occurs in sequence. The order of slides in the presentation is determined by a list of slideIds, stored as a text string in the MANIFEST column of the VERSION table. Since multiple entries are allowed in the VERSION table, that means that multiple presentations can be stored in the same document.</source>
          <target state="translated">このスキーマでは、各スライドがプレゼンテーション内での順序を決定するページ番号を持つ代わりに、各スライドは、順序のどこで発生するかとは関係のない一意の整数の識別子を持ちます。プレゼンテーション内のスライドの順序は、VERSION テーブルの MANIFEST 列にテキスト文字列として格納された slideIds のリストによって決定されます。VERSION テーブルでは複数のエントリが許可されているので、同じドキュメントに複数のプレゼンテーションを格納することができます。</target>
        </trans-unit>
        <trans-unit id="0941893928b48e6ed8f71fafe5691ea7ff76077a" translate="yes" xml:space="preserve">
          <source>In this system, each entry in the song table is required to map to an entry in the album table with the same combination of artist and album.</source>
          <target state="translated">このシステムでは、曲表の各エントリは、アーティストとアルバムの組み合わせが同じであるアルバム表のエントリにマッピングする必要があります。</target>
        </trans-unit>
        <trans-unit id="e2304a60e4555367ae83803d8a81dcbbc6bac3fc" translate="yes" xml:space="preserve">
          <source>In this way the new pointer-passing interface seems to solve all of the security problems associated with passing pointer values from one extension to another in SQLite.</source>
          <target state="translated">このようにして、新しいポインタ渡しインターフェースは、SQLite のある拡張子から別の拡張子へのポインタ値の渡しに関連するセキュリティ上の問題をすべて解決しているように見えます。</target>
        </trans-unit>
        <trans-unit id="5b4cc2bd1f16fd79626e9a2d355ec8140a8334dd" translate="yes" xml:space="preserve">
          <source>In those routines that have a fourth argument, its value is the number of bytes in the parameter. To be clear: the value is the number of &lt;u&gt;bytes&lt;/u&gt; in the value, not the number of characters. If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16() is negative, then the length of the string is the number of bytes up to the first zero terminator. If the fourth parameter to sqlite3_bind_blob() is negative, then the behavior is undefined. If a non-negative fourth parameter is provided to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_text64() then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated. If any NUL characters occur at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs. The result of expressions involving strings with embedded NULs is undefined.</source>
          <target state="translated">4番目の引数を持つこれらのルーチンでは、その値はパラメーターのバイト数です。明確にするために：値は&lt;u&gt;バイト&lt;/u&gt;数です&lt;u&gt;&lt;/u&gt;値ではなく、文字数。 sqlite3_bind_text（）またはsqlite3_bind_text16（）の4番目のパラメーターが負の場合、文字列の長さは最初のゼロターミネーターまでのバイト数になります。 sqlite3_bind_blob（）の4番目のパラメーターが負の場合、動作は未定義です。負でない4番目のパラメーターがsqlite3_bind_text（）またはsqlite3_bind_text16（）またはsqlite3_bind_text64（）に提供される場合、そのパラメーターは、文字列がNULで終了していると想定してNULターミネーターが発生するバイトオフセットでなければなりません。 4番目のパラメーターの値よりも小さいバイトオフセットでNUL文字が発生した場合、結果の文字列値には埋め込みNULが含まれます。 NULが埋め込まれた文字列を含む式の結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="f5c0b6c1ce652bbe2a9ce301182f0e17dcf5f222" translate="yes" xml:space="preserve">
          <source>In those routines that have a fourth argument, its value is the number of bytes in the parameter. To be clear: the value is the number of &lt;u&gt;bytes&lt;/u&gt; in the value, not the number of characters. If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16() is negative, then the length of the string is the number of bytes up to the first zero terminator. If the fourth parameter to sqlite3_bind_blob() is negative, then the behavior is undefined. If a non-negative fourth parameter is provided to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_text64() then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated. If any NUL characters occurs at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs. The result of expressions involving strings with embedded NULs is undefined.</source>
          <target state="translated">4番目の引数を持つルーチンでは、その値はパラメーターのバイト数です。明確にするために：値は&lt;u&gt;バイト&lt;/u&gt;数です&lt;u&gt;&lt;/u&gt;文字数ではなく、値で。 sqlite3_bind_text（）またはsqlite3_bind_text16（）の4番目のパラメーターが負の場合、ストリングの長さは最初のゼロターミネーターまでのバイト数です。 sqlite3_bind_blob（）の4番目のパラメーターが負の場合、動作は未定義です。負でない4番目のパラメーターがsqlite3_bind_text（）またはsqlite3_bind_text16（）またはsqlite3_bind_text64（）に提供される場合、そのパラメーターは、ストリングがNULで終了したと仮定してNULターミネーターが発生するバイトオフセットでなければなりません。 4番目のパラメーターの値よりも小さいバイトオフセットでNUL文字が発生した場合、結果の文字列値には埋め込みNULが含まれます。 NULが埋め込まれた文字列を含む式の結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="e5828032be03f722c81b6852fba96bca0f86ff7f" translate="yes" xml:space="preserve">
          <source>In truncate journal mode, the transaction is committed by truncating the journal file to zero length rather than deleting the journal file (as in DELETE mode) or by zeroing the header (as in PERSIST mode). TRUNCATE mode shares the advantage of PERSIST mode that the directory that contains the journal file and database does not need to be updated. Hence truncating a file is often faster than deleting it. TRUNCATE has the additional advantage that it is not followed by a system call (ex: fsync()) to synchronize the change to disk. It might be safer if it did. But on many modern filesystems, a truncate is an atomic and synchronous operation and so we think that TRUNCATE will usually be safe in the face of power failures. If you are uncertain about whether or not TRUNCATE will be synchronous and atomic on your filesystem and it is important to you that your database survive a power loss or operating system crash that occurs during the truncation operation, then you might consider using a different journaling mode.</source>
          <target state="translated">TRUNCATEジャーナルモードでは、トランザクションは、ジャーナルファイルを削除するのではなく(DELETEモードのように)、ヘッダーをゼロにする(PERSISTモードのように)、ジャーナルファイルをゼロ長に切り詰めることによってコミットされます。TRUNCATEモードは、ジャーナルファイルとデータベースを含むディレクトリを更新する必要がないというPERSISTモードの利点を共有しています。そのため、ファイルを削除するよりも、ファイルを切り詰める方が高速であることが多いです。TRUNCATEには、変更をディスクに同期させるためのシステムコール(例:fsync()のような)が後に続かないという追加の利点があります。その方が安全かもしれません。しかし、多くの最新のファイルシステムでは、TRUNCATE はアトミックで同期的な操作なので、 TRUNCATE は通常、停電に直面しても安全だと考えています。ファイルシステム上でTRUNCATEが同期的でアトミックな操作であるかどうかが不明で、TRUNCATE操作中に発生した停電やオペレーティングシステムのクラッシュにデータベースが耐えられるかどうかが重要な場合は、別のジャーナリングモードを使用することを検討するかもしれません。</target>
        </trans-unit>
        <trans-unit id="0ad1bfd687f56543c8ea5ff79723971d89b554aa" translate="yes" xml:space="preserve">
          <source>In version 3.5.9 the query above would return a single column named &quot;t1.a&quot;. In version 3.6.0 the column name is just &quot;a&quot;.</source>
          <target state="translated">バージョン3.5.9では、上記のクエリは &quot;t1.a &quot;という名前の単一のカラムを返します。バージョン 3.6.0 では、カラム名は単に &quot;a&quot; です。</target>
        </trans-unit>
        <trans-unit id="b38dc06ca0b3ec94d37d385f6a25506410f69b7f" translate="yes" xml:space="preserve">
          <source>In very old versions of SQLite (before version 3.7.11 - 2012-03-20) the ROLLBACK will fail with an error code &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if there are any pending queries. In more recent versions of SQLite, the ROLLBACK will proceed and pending statements will often be aborted, causing them to return an &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; or &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; error. In SQLite version 3.8.8 (2015-01-16) and later, a pending read will continue functioning after the ROLLBACK as long as the ROLLBACK does not modify the database schema.</source>
          <target state="translated">SQLiteの非常に古いバージョン（バージョン3.7.11-2012-03-20より前）では、保留中のクエリがある場合、ROLLBACKはエラーコード&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSYで&lt;/a&gt;失敗します。 SQLiteの最新バージョンでは、ROLLBACKが続行され、保留中のステートメントが中止されることが多く、&lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;または&lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt;エラーが返されます。 SQLiteバージョン3.8.8（2015-01-16）以降では、ROLLBACKがデータベーススキーマを変更しない限り、保留中の読み取りはROLLBACKの後も機能し続けます。</target>
        </trans-unit>
        <trans-unit id="b499aec31026161ef5b7e71ea3cf99793674a2a9" translate="yes" xml:space="preserve">
          <source>In words, we have a database table named &quot;examp&quot; that has two columns of data named &quot;one&quot; and &quot;two&quot;. Now suppose we want to insert a single record into this table. Like this:</source>
          <target state="translated">言い換えれば、&quot;examp &quot;という名前のデータベーステーブルがあり、そこには &quot;1 &quot;と &quot;2 &quot;という2つの列のデータがあります。ここで、このテーブルに1つのレコードを挿入したいとします。このようにします。</target>
        </trans-unit>
        <trans-unit id="538f80f611dd84d930a92b9f7317e8773bd20fa3" translate="yes" xml:space="preserve">
          <source>In-Memory Databases</source>
          <target state="translated">インメモリデータベース</target>
        </trans-unit>
        <trans-unit id="d29dcc989f8aeac43865c646816b27c0bf5d86c1" translate="yes" xml:space="preserve">
          <source>In-memory Databases And Shared Cache</source>
          <target state="translated">インメモリデータベースと共有キャッシュ</target>
        </trans-unit>
        <trans-unit id="f87e1ebcfb907fda4b66420b21bcba1a298d5d80" translate="yes" xml:space="preserve">
          <source>In-memory databases are allowed to use &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; if they are opened using a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. If the unadorned &quot;:memory:&quot; name is used to specify the in-memory database, then that database always has a private cache and is this only visible to the database connection that originally opened it. However, the same in-memory database can be opened by two or more database connections as follows:</source>
          <target state="translated">インメモリデータベースは、&lt;a href=&quot;uri&quot;&gt;URIファイル名&lt;/a&gt;を使用して開かれている場合、&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュ&lt;/a&gt;を使用できます。装飾されていない &quot;：memory：&quot;名を使用してインメモリデータベースを指定する場合、そのデータベースには常にプライベートキャッシュがあり、これは最初にそれを開いたデータベース接続にのみ表示されます。ただし、次のように、同じインメモリデータベースを2つ以上のデータベース接続で開くことができます。</target>
        </trans-unit>
        <trans-unit id="4e5ba204b0641a7420c326e6c9ccf4a171f01a91" translate="yes" xml:space="preserve">
          <source>Include a digit somewhere in every identifier name.</source>
          <target state="translated">すべての識別子名のどこかに桁を含めてください。</target>
        </trans-unit>
        <trans-unit id="609cf98670fbb073608f2b25b70dd7c1c13a30bc" translate="yes" xml:space="preserve">
          <source>Include a static string in the library that responds to the RCS &quot;ident&quot; command and which contains the library version number.</source>
          <target state="translated">RCS &quot;ident &quot;コマンドに応答し、ライブラリのバージョン番号を含む静的文字列をライブラリに含めます。</target>
        </trans-unit>
        <trans-unit id="c0417d1d2b8071cc5718dd6c321dee3ddd0e2b30" translate="yes" xml:space="preserve">
          <source>Incompatible changes are covered first since they are the most important to maintainers and programmers.</source>
          <target state="translated">互換性のない変更は、メンテナやプログラマーにとって最も重要な変更なので、最初に取り上げます。</target>
        </trans-unit>
        <trans-unit id="bc118ee16ef865aed415e5f3a8d6022aa76b72dd" translate="yes" xml:space="preserve">
          <source>Inconsistent result set column names between CREATE TABLE AS and a simple SELECT. Ticket &lt;a href=&quot;https://sqlite.org/src/info/3b4450072511e621&quot;&gt;3b4450072511e621&lt;/a&gt;</source>
          <target state="translated">CREATE TABLE ASと単純なSELECTの間の結果セットの列名に一貫性がありません。チケット&lt;a href=&quot;https://sqlite.org/src/info/3b4450072511e621&quot;&gt;3b4450072511e621&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7579773ac4d764f11e434b97ff14dade4554c12" translate="yes" xml:space="preserve">
          <source>Incorporate makefile patches form A. Rottmann to use LIBTOOL</source>
          <target state="translated">A.Rottmannからのmakefileパッチを組み込み、LIBTOOLを使用するようにしました。</target>
        </trans-unit>
        <trans-unit id="78318ed3e6ca4f2006eecd671fb4e1b78bbf85cb" translate="yes" xml:space="preserve">
          <source>Incorrect</source>
          <target state="translated">Incorrect</target>
        </trans-unit>
        <trans-unit id="f074a009d21038c67513df8d49c6353ecce4802a" translate="yes" xml:space="preserve">
          <source>Incorrect assert() statement removed. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/823779d31eb09cda&quot;&gt;823779d31eb09cda&lt;/a&gt;.</source>
          <target state="translated">誤ったassert（）ステートメントが削除されました。チェックイン&lt;a href=&quot;https://www.sqlite.org/src/info/823779d31eb09cda&quot;&gt;823779d31eb09cda&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86f64d7d599af33f2e2d357b68bfbc2590e32e39" translate="yes" xml:space="preserve">
          <source>Incorrect column datatype reported. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/a8a0d2996a&quot;&gt;a8a0d2996a&lt;/a&gt;</source>
          <target state="translated">不正な列データ型が報告されました。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/a8a0d2996a&quot;&gt;a8a0d2996a&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5010ff6ebfa98793b55410eccec7fb293111ca61" translate="yes" xml:space="preserve">
          <source>Incorrect query results on a join with a ORDER BY DESC. Ticket &lt;a href=&quot;https://sqlite.org/src/info/123c9ba32130a6c9&quot;&gt;123c9ba32130a6c9&lt;/a&gt;.</source>
          <target state="translated">ORDER BY DESCを使用した結合で不正なクエリが発生します。チケット&lt;a href=&quot;https://sqlite.org/src/info/123c9ba32130a6c9&quot;&gt;123c9ba32130a6c9&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d72bf52d94d169fcce6582014fa4914c962c4cbe" translate="yes" xml:space="preserve">
          <source>Incorrect query results when the skip-ahead-distinct optimization is used. Ticket &lt;a href=&quot;https://sqlite.org/src/info/ef9318757b152e3a&quot;&gt;ef9318757b152e3a&lt;/a&gt;.</source>
          <target state="translated">先読みスキップ最適化を使用すると、クエリ結果が不正になります。チケット&lt;a href=&quot;https://sqlite.org/src/info/ef9318757b152e3a&quot;&gt;ef9318757b152e3a&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b88b306633c693ef74330d871a60d1a4c0698aa" translate="yes" xml:space="preserve">
          <source>Incorrect result on the less-than operator in &lt;a href=&quot;rowvalue&quot;&gt;row values&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f484b65f3d62305&quot;&gt;f484b65f3d62305&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;rowvalue&quot;&gt;行の値の小&lt;/a&gt;なり演算子の結果が正しくありません。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/f484b65f3d62305&quot;&gt;f484b65f3d62305&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="353e2ea7a72adf3f039c8f1d29d7d6a2765ce415" translate="yes" xml:space="preserve">
          <source>IncrVacuum</source>
          <target state="translated">IncrVacuum</target>
        </trans-unit>
        <trans-unit id="bfb28e75251bc4d83a52b5697560b9c1115b80bf" translate="yes" xml:space="preserve">
          <source>Increase the &lt;a href=&quot;limits#max_variable_number&quot;&gt;default upper bound&lt;/a&gt; on the number of &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; from 999 to 32766.</source>
          <target state="translated">増加&lt;a href=&quot;limits#max_variable_number&quot;&gt;上限デフォルト&lt;/a&gt;の数に&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメータを&lt;/a&gt;999から32766までを。</target>
        </trans-unit>
        <trans-unit id="21ef0be270a54a1cdd6fa173d6d67cc79394e640" translate="yes" xml:space="preserve">
          <source>Increase the default &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; allocation size from 100 to 128 bytes.</source>
          <target state="translated">デフォルトの&lt;a href=&quot;malloc#lookaside&quot;&gt;lookasideメモリアロケータの&lt;/a&gt;割り当てサイズを100から128バイトに増やします。</target>
        </trans-unit>
        <trans-unit id="40e4fa7cf5d195215158819dc861b48ed9ae1b97" translate="yes" xml:space="preserve">
          <source>Increase the default &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside&lt;/a&gt; size from 512,125 to 1200,100 as this provides better performance while only adding 56KB of extra memory per connection. Memory-sensitive applications can restore the old default at compile-time, start-time, or run-time.</source>
          <target state="translated">接続ごとに56KBのメモリを追加するだけでパフォーマンスが向上するため、デフォルトの&lt;a href=&quot;malloc#lookaside&quot;&gt;ルックアサイド&lt;/a&gt;サイズを512,125から1200,100に増やします。メモリに依存するアプリケーションは、コンパイル時、開始時、または実行時に古いデフォルトを復元できます。</target>
        </trans-unit>
        <trans-unit id="0e1c35718b4f025f2f5dcc35d709e6b06c180f12" translate="yes" xml:space="preserve">
          <source>Increase the default size of a lookahead cache line from 100 to 128 bytes.</source>
          <target state="translated">ルックヘッドキャッシュ行のデフォルトサイズを100バイトから128バイトに増やす。</target>
        </trans-unit>
        <trans-unit id="7da2a83b3ac0a9788385c812ce2d8ccd3f55fd86" translate="yes" xml:space="preserve">
          <source>Increase the default value of &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; to 50 and make sure that it is honored in every place that a schema change might force a statement retry.</source>
          <target state="translated">&lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt;のデフォルト値を50に増やし、スキーマの変更によってステートメントの再試行が強制される可能性があるすべての場所でそれが受け入れられることを確認します。</target>
        </trans-unit>
        <trans-unit id="8609e4a99103452adeaaadda83f7438f10dd550a" translate="yes" xml:space="preserve">
          <source>Increase the maximum &quot;scope&quot; value for the &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; extension from 6 to 30.</source>
          <target state="translated">&lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt;拡張機能の「スコープ」の最大値を6から30に増やします。</target>
        </trans-unit>
        <trans-unit id="c2f2fd643cba996348fe945409caf6a8045d3c9f" translate="yes" xml:space="preserve">
          <source>Increase the maximum size of a database pages from 32KiB to 64KiB.</source>
          <target state="translated">データベースページの最大サイズを32KiBから64KiBに拡大。</target>
        </trans-unit>
        <trans-unit id="c023946d393ce520944a7e8848356e945bf33b16" translate="yes" xml:space="preserve">
          <source>Increase the maximum size of database files to 281 TB.</source>
          <target state="translated">データベースファイルの最大サイズを281TBに拡大。</target>
        </trans-unit>
        <trans-unit id="45c470cb2d5edd4a76a24043774f958df34166de" translate="yes" xml:space="preserve">
          <source>Increase the maximum value of &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; from 30 to 62 (though the default value remains at 10).</source>
          <target state="translated">&lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt;の最大値を30から62に増やします（ただし、デフォルト値は10のままです）。</target>
        </trans-unit>
        <trans-unit id="bb8cf068d7b2280526a2d202959cea91dd49770d" translate="yes" xml:space="preserve">
          <source>Increase the maximum value of &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; from 62 to 125.</source>
          <target state="translated">&lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt;の最大値を62から125に増やします。</target>
        </trans-unit>
        <trans-unit id="69df92b5969bbc35734aa6107d3290339d53b888" translate="yes" xml:space="preserve">
          <source>Increase the timeout in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; before issuing an &lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt; error from 1 second to 10 seconds.</source>
          <target state="translated">&lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt;エラーを発行する前に、&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;のタイムアウトを1秒から10秒に増やします。</target>
        </trans-unit>
        <trans-unit id="9f009e1e744f83083af0b2cc7e6b2078c78f112f" translate="yes" xml:space="preserve">
          <source>Increased robustness against malicious SQL that is run against a maliciously corrupted database.</source>
          <target state="translated">悪意を持って破損したデータベースに対して実行される悪意のあるSQLに対する堅牢性が向上しました。</target>
        </trans-unit>
        <trans-unit id="6b178246a9f68a2d5235ede0c3d198671a18c66b" translate="yes" xml:space="preserve">
          <source>Increased the version number on the &lt;a href=&quot;c3ref/vfs&quot;&gt;VFS object&lt;/a&gt; to 3 and added new methods xSetSysCall, xGetSysCall, and xNextSysCall used for doing full-coverage testing.</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;VFSオブジェクト&lt;/a&gt;のバージョン番号を3に増やし、フルカバレッジテストを実行するために使用される新しいメソッドxSetSysCall、xGetSysCall、xNextSysCallを追加しました。</target>
        </trans-unit>
        <trans-unit id="5b01748d80c9a44e0b5e68cd44f76d6fdcd5fbdb" translate="yes" xml:space="preserve">
          <source>Increment a &quot;constraint counter&quot; by P2 (P2 may be negative or positive). If P1 is non-zero, the database constraint counter is incremented (deferred foreign key constraints). Otherwise, if P1 is zero, the statement counter is incremented (immediate foreign key constraints).</source>
          <target state="translated">制約カウンタ」をP2でインクリメントする(P2は負でも正でもよい)。P1が0以外の場合、データベースの制約カウンタがインクリメントされます(外部キー制約の遅延)。そうでなければ、P1がゼロの場合、文カウンタをインクリメントする(即時外部キー制約)。</target>
        </trans-unit>
        <trans-unit id="9728ef186d1aa3193e57c71ddbd9cc22dfa95396" translate="yes" xml:space="preserve">
          <source>Increment the schema version number using &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version=X&lt;/a&gt; where X is one more than the old schema version number found in step 2 above.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version = X&lt;/a&gt;を使用してスキーマバージョン番号をインクリメントします。Xは、上記の手順2で見つかった古いスキーマバージョン番号より1つ大きくなります。</target>
        </trans-unit>
        <trans-unit id="8144fd658d7904e59a32604de5f5f1ca74f2f2ee" translate="yes" xml:space="preserve">
          <source>Increment the value of P1 so that &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; opcodes will jump the first time they are evaluated for this run.</source>
          <target state="translated">なるようにP1の値をインクリメント&lt;a href=&quot;opcode#Once&quot;&gt;すると&lt;/a&gt;オペコードは、彼らがこの実行のために評価されている最初の時間をジャンプします。</target>
        </trans-unit>
        <trans-unit id="99958674e5ab051f627364f0e7aec7700da2c443" translate="yes" xml:space="preserve">
          <source>Incremental And Continuous Updates</source>
          <target state="translated">増分的および継続的な更新</target>
        </trans-unit>
        <trans-unit id="c978bfe7fe02498da062fb7e2f5271fe832940ed" translate="yes" xml:space="preserve">
          <source>Index B-Tree Interior Cell (header 0x02):</source>
          <target state="translated">インデックスB-ツリー内部セル(ヘッダ0x02)。</target>
        </trans-unit>
        <trans-unit id="4e71969581a513a52c19a67df3b923e84e3cb4d7" translate="yes" xml:space="preserve">
          <source>Index B-Tree Leaf Cell (header 0x0a):</source>
          <target state="translated">インデックス B-Tree リーフセル(ヘッダ 0x0a)。</target>
        </trans-unit>
        <trans-unit id="6834f50285e5eaa6aab20cfc4003ad141369bccf" translate="yes" xml:space="preserve">
          <source>Index B-Tree Leaf Or Interior Cell:</source>
          <target state="translated">Index B-Tree Leaf or Interior Cell.</target>
        </trans-unit>
        <trans-unit id="d05474cb52cfb6c27f6a9c375d177e07d462e5e6" translate="yes" xml:space="preserve">
          <source>Index Interior (0x02)</source>
          <target state="translated">インデックス内部 (0x02)</target>
        </trans-unit>
        <trans-unit id="f35ac0d24fd01ec25554f05ecc89c727c71a1e04" translate="yes" xml:space="preserve">
          <source>Index Leaf (0x0a)</source>
          <target state="translated">インデックスリーフ(0x0a</target>
        </trans-unit>
        <trans-unit id="96c319248a56deb59ef179cae4ae3f7a3c92eca2" translate="yes" xml:space="preserve">
          <source>Index Of A Parameter With A Given Name</source>
          <target state="translated">指定された名前のパラメータのインデックス</target>
        </trans-unit>
        <trans-unit id="239b13bdf631a9f83fa9a8a3d5c3895198fcc15a" translate="yes" xml:space="preserve">
          <source>Indexes On Expressions</source>
          <target state="translated">式のインデックス</target>
        </trans-unit>
        <trans-unit id="f48dd71980245b4a0803daa066444bcb1b77f26c" translate="yes" xml:space="preserve">
          <source>Indexes are removed with the &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; command.</source>
          <target state="translated">インデックスは&lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt;コマンドで削除されます。</target>
        </trans-unit>
        <trans-unit id="535c9c6ad77a4b24ea3df3e8a1b9f2c196027e6c" translate="yes" xml:space="preserve">
          <source>Indexes can use &lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC&lt;/a&gt; and &lt;a href=&quot;lang_createindex#collidx&quot;&gt;COLLATE&lt;/a&gt;</source>
          <target state="translated">インデックスは&lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC&lt;/a&gt;と&lt;a href=&quot;lang_createindex#collidx&quot;&gt;COLLATE&lt;/a&gt;を使用できます</target>
        </trans-unit>
        <trans-unit id="5826c397297007e146b25d7bb80a3a9d200a4f00" translate="yes" xml:space="preserve">
          <source>Indices are not required for child key columns but they are almost always beneficial. Returning to the example in &lt;a href=&quot;#fk_basics&quot;&gt;section 1&lt;/a&gt;, each time an application deletes a row from the</source>
          <target state="translated">インデックスは子キー列には必要ありませんが、ほとんどの場合有益です。&lt;a href=&quot;#fk_basics&quot;&gt;セクション1&lt;/a&gt;の例に戻ると、アプリケーションが行を削除するたびに、</target>
        </trans-unit>
        <trans-unit id="952faf72c9a83e116cef336ce73f046eb32c95b9" translate="yes" xml:space="preserve">
          <source>Indices with names of the form &quot;sqlite_autoindex_TABLE_N&quot; that are used to implement &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on ordinary tables.</source>
          <target state="translated">通常のテーブルに&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;および&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;制約を実装するために使用される「sqlite_autoindex_TABLE_N」の形式の名前を持つインデックス。</target>
        </trans-unit>
        <trans-unit id="853f712d884520adb0232cc6445c159a48a0d960" translate="yes" xml:space="preserve">
          <source>Individual database connections created using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; can choose to participate or not participate in shared cache mode by using the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flags the third parameter. The use of either of these flags overrides the global shared cache mode setting established by &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. No more than one of the flags should be used; if both SQLITE_OPEN_SHAREDCACHE and SQLITE_OPEN_PRIVATECACHE flags are used in the third argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;を使用して作成された個々のデータベース接続は、&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;または&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;フラグの3番目のパラメーターを使用して、共有キャッシュモードに参加するか、参加しないかを選択できます。これらのフラグのいずれかを使用すると、&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt;によって確立されたグローバル共有キャッシュモード設定が上書きされます。フラグは1つだけ使用してください。 SQLITE_OPEN_SHAREDCACHEフラグとSQLITE_OPEN_PRIVATECACHEフラグの両方が&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）の&lt;/a&gt; 3番目の引数で使用されている場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="e34e9639a7829e3d1eeead355b99441da28ac59a" translate="yes" xml:space="preserve">
          <source>Individual fields of the shm header, except for the salt values copied from the WAL header, are unsigned integers in the native byte-order of the host machine. The salt values are exact copies from the WAL header and are in whatever byte order is used by the WAL file. The size of integers may be 8, 16, 32, or 64 bits. A detailed breakout of the individual fields of the shm header follows:</source>
          <target state="translated">WAL ヘッダーからコピーされた salt 値を除いた shm ヘッダーの個々のフィールドは、ホストマシンのネイティブバイトオーダーの符号なし整数です。ソルト値は WAL ヘッダーからの正確なコピーであり、WAL ファイルで使用されるバイトオーダーである。整数のサイズは8、16、32、64ビットです。shmヘッダの個々のフィールドの詳細なブレークアウトは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="afaa9b90ffb384cf537b3db99f57a1ca2ab340a0" translate="yes" xml:space="preserve">
          <source>Individual subterms might be a single comparison expression like *a=5* or *x&amp;gt;y* or they can be LIKE or BETWEEN expressions, or a subterm can be a parenthesized list of AND-connected sub-subterms. Each subterm is analyzed as if it were itself the entire WHERE clause in order to see if the subterm is indexable by itself. If &lt;u&gt;every&lt;/u&gt; subterm of an OR clause is separately indexable then the OR clause might be coded such that a separate index is used to evaluate each term of the OR clause. One way to think about how SQLite uses separate indices for each OR clause term is to imagine that the WHERE clause where rewritten as follows:</source>
          <target state="translated">個々のサブタームは、* a = 5 *または* x&amp;gt; y *のような単一の比較式であるか、LIKEまたはBETWEEN式であるか、またはANDで接続されたサブサブタームの括弧で囲まれたリストです。各サブタームは、それ自体がWHERE句全体であるかのように分析され、サブターム自体がインデックス付け可能かどうかを確認します。場合&lt;u&gt;毎&lt;/u&gt;または句の部分項が別々に割出し可能である次にOR句は、別のインデックスがOR句の各用語を評価するために使用されるように符号化されるかもしれません。 SQLiteがOR句の用語ごとに別々のインデックスを使用する方法について考える1つの方法は、WHERE句が次のように書き直されることを想像することです。</target>
        </trans-unit>
        <trans-unit id="7a9fd17dd36196733342a48e4a93f680869a4f7c" translate="yes" xml:space="preserve">
          <source>Individual virtual table implementations might impose additional constraints. For example, some virtual implementations might provide read-only tables. Or some virtual table implementations might allow &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; but not &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;. Or some virtual table implementations might limit the kinds of UPDATEs that can be made.</source>
          <target state="translated">個々の仮想テーブルの実装により、追加の制約が課される場合があります。たとえば、一部の仮想実装は読み取り専用テーブルを提供する場合があります。または、仮想テーブルの実装によっては、&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;または&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;は許可されても、&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;は許可されない場合があります。または、仮想テーブルの実装によっては、実行できるUPDATEの種類が制限される場合があります。</target>
        </trans-unit>
        <trans-unit id="b7ab8cb519f7ae8e1280427c18f93285db556ab6" translate="yes" xml:space="preserve">
          <source>Infinite loop on an UPDATE that uses an OR operator in the WHERE clause. Problem introduced with 3.17.0 and reported on the mailing list about one year later. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/47b2581aa9bfecec&quot;&gt;47b2581aa9bfecec&lt;/a&gt;.</source>
          <target state="translated">WHERE句でOR演算子を使用するUPDATEの無限ループ。問題は3.17.0で導入され、約1年後にメーリングリストで報告されました。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/47b2581aa9bfecec&quot;&gt;47b2581aa9bfecec&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9779307227ff608723d6f1acc622b0fbd0d99060" translate="yes" xml:space="preserve">
          <source>Information about the ORDER BY clause is stored in aOrderBy[]. Each term of aOrderBy records a column of the ORDER BY clause.</source>
          <target state="translated">ORDER BY節に関する情報は、aOrderBy[]に格納されます。aOrderByの各項は、ORDER BY句の列を記録します。</target>
        </trans-unit>
        <trans-unit id="8900519c8c00e46885e8acc9f5e07ba3fa96d336" translate="yes" xml:space="preserve">
          <source>Informix</source>
          <target state="translated">Informix</target>
        </trans-unit>
        <trans-unit id="19682bdb9185a5fa9d763d414d0443d3a0bc2456" translate="yes" xml:space="preserve">
          <source>Init</source>
          <target state="translated">Init</target>
        </trans-unit>
        <trans-unit id="c807a586d6078a7e14adef4ebb7912d0c6f4aa53" translate="yes" xml:space="preserve">
          <source>InitCoroutine</source>
          <target state="translated">InitCoroutine</target>
        </trans-unit>
        <trans-unit id="9ceecfe65e61c428178f61207aad8930969e6176" translate="yes" xml:space="preserve">
          <source>Initial Public Release of Alpha code</source>
          <target state="translated">アルファコードの初回公開</target>
        </trans-unit>
        <trans-unit id="22e34d8b442d40192baed65a8aa102e6e94f33a1" translate="yes" xml:space="preserve">
          <source>Initial release of version 2.0. The idea of renaming the library to &quot;SQLus&quot; was abandoned in favor of keeping the &quot;SQLite&quot; name and bumping the major version number.</source>
          <target state="translated">バージョン2.0の初期リリース。ライブラリの名前を &quot;SQLus&quot; に変更するというアイデアは、&quot;SQLite&quot; の名前を維持し、メジャーバージョン番号を変更することで放棄されました。</target>
        </trans-unit>
        <trans-unit id="8f5bfa371a731c186afb7ca1237eb5d4d7f1e077" translate="yes" xml:space="preserve">
          <source>Initial size of the database in pages</source>
          <target state="translated">データベースの初期サイズ(ページ数</target>
        </trans-unit>
        <trans-unit id="7bf3e06594405eb1afbafdd083622d687011597a" translate="yes" xml:space="preserve">
          <source>Initialize The SQLite Library</source>
          <target state="translated">SQLite ライブラリの初期化</target>
        </trans-unit>
        <trans-unit id="d191407d44cf9ade286348bd4b44b9f7f3e25feb" translate="yes" xml:space="preserve">
          <source>Initialize index X to be N-200 (where N is the size of a database page in bytes.</source>
          <target state="translated">インデックスXをN-200(ここでNはデータベースページのサイズをバイト単位で表します)に初期化します。</target>
        </trans-unit>
        <trans-unit id="8e6cd4e5b42b5a543357e6d81e6f378b25c829f6" translate="yes" xml:space="preserve">
          <source>Initialize the &lt;b&gt;azColumnName[]&lt;/b&gt; array for the callback.</source>
          <target state="translated">コールバックの&lt;b&gt;azColumnName []&lt;/b&gt;配列を初期化します。</target>
        </trans-unit>
        <trans-unit id="5f7aab6a3275a65fb3b4985527f188c8b61dc3b5" translate="yes" xml:space="preserve">
          <source>Initialize the checksum to the checksum nonce value found in the journal header at offset 12.</source>
          <target state="translated">チェックサムを、オフセット12のジャーナル・ヘッダにあるチェックサム・ノンス値に初期化します。</target>
        </trans-unit>
        <trans-unit id="404f059fc8a52705cd25b69b3e9ff09c1be18ec9" translate="yes" xml:space="preserve">
          <source>Inner joins can be freely reordered. However a left outer join is neither commutative nor associative and hence will not be reordered. Inner joins to the left and right of the outer join might be reordered if the optimizer thinks that is advantageous but the outer joins are always evaluated in the order in which they occur.</source>
          <target state="translated">内側結合は自由に並び替えることができます。しかし、左の外側結合は可換的でも連想的でもないので、並び替えられません。オプティマイザが有利だと考えた場合、外側結合の左と右の内側結合は並べ替えられるかもしれませんが、外側結合は常に発生した順番で評価されます。</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="6173fc45fc7b2219f9b313a58dd34b30a31fc6dc" translate="yes" xml:space="preserve">
          <source>Insert that single row into the recursive table</source>
          <target state="translated">その一行を再帰表に挿入します。</target>
        </trans-unit>
        <trans-unit id="e9c69a8b8aca121e6ec4067a03fd7e5c40db2b72" translate="yes" xml:space="preserve">
          <source>Insert the integer value held by register P2 into a RowSet object held in register P1.</source>
          <target state="translated">レジスタP2で保持している整数値を、レジスタP1で保持しているRowSetオブジェクトに挿入します。</target>
        </trans-unit>
        <trans-unit id="85a8fe292b0b6ab92cb375e9d651b4f869ca615a" translate="yes" xml:space="preserve">
          <source>Inserting Records Into The Database</source>
          <target state="translated">データベースにレコードを挿入する</target>
        </trans-unit>
        <trans-unit id="d9102185aa139480514433588d7c7980df39e939" translate="yes" xml:space="preserve">
          <source>Instead of a separate OFFSET clause, the LIMIT clause may specify two scalar expressions separated by a comma. In this case, the first expression is used as the OFFSET expression and the second as the LIMIT expression. This is counter-intuitive, as when using the OFFSET clause the second of the two expressions is the OFFSET and the first the LIMIT. This reversal of the offset and limit is intentional - it maximizes compatibility with other SQL database systems. However, to avoid confusion, programmers are strongly encouraged to use the form of the LIMIT clause that uses the &quot;OFFSET&quot; keyword and avoid using a LIMIT clause with a comma-separated offset.</source>
          <target state="translated">独立したOFFSET句の代わりに、LIMIT句はカンマで区切られた2つのスカラ式を指定することができます。この場合、最初の式がOFFSET式として使用され、2番目の式がLIMIT式として使用されます。これは直観的ではありませんが、OFFSET句を使用すると、2つの式のうち2番目の式がOFFSETで、1番目の式がLIMITになります。オフセットとリミットのこの反転は意図的なもので、他のSQLデータベースシステムとの互換性を最大化します。しかし、混乱を避けるために、プログラマーは、&quot;OFFSET &quot;キーワードを使用する形式のLIMIT句を使用し、カンマで区切られたオフセットを持つLIMIT句の使用を避けることを強く推奨します。</target>
        </trans-unit>
        <trans-unit id="d84a58129471e483da1b069622f8ee436752fbf7" translate="yes" xml:space="preserve">
          <source>Instead of deleting records where the &quot;two&quot; column is less than 50, this statement just puts the &quot;one&quot; column in parentheses The VDBE program to implement this statement follows:</source>
          <target state="translated">この文では、&quot;2 &quot;列が50未満のレコードを削除する代わりに、&quot;1 &quot;列を括弧で囲んでいるだけである。 この文を実装するVDBEプログラムは以下の通りである。</target>
        </trans-unit>
        <trans-unit id="123ee948ecafb3b169cf486ec20a13fbb0b9103f" translate="yes" xml:space="preserve">
          <source>Instead of providing full Unicode case support by default, SQLite provides the ability to link against external Unicode comparison and conversion routines. The application can overload the built-in &lt;a href=&quot;datatype3#collation&quot;&gt;NOCASE&lt;/a&gt; collating sequence (using &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt;) and the built-in &lt;a href=&quot;lang_corefunc#like&quot;&gt;like()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#upper&quot;&gt;upper()&lt;/a&gt;, and &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower()&lt;/a&gt; functions (using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;). The SQLite source code includes an &quot;ICU&quot; extension that does these overloads. Or, developers can write their own overloads based on their own Unicode-aware comparison routines already contained within their project.</source>
          <target state="translated">SQLiteは、デフォルトで完全なUnicodeケースサポートを提供する代わりに、外部Unicode比較および変換ルーチンに対してリンクする機能を提供します。アプリケーションは、組み込みの&lt;a href=&quot;datatype3#collation&quot;&gt;NOCASE&lt;/a&gt;照合シーケンス（&lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collat​​ion（）&lt;/a&gt;を使用）および組み込みの&lt;a href=&quot;lang_corefunc#like&quot;&gt;like（）&lt;/a&gt;、&lt;a href=&quot;lang_corefunc#upper&quot;&gt;upper（）&lt;/a&gt;、&lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower（）&lt;/a&gt;関数（&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;を使用）をオーバーロードできます。 SQLiteソースコードには、これらのオーバーロードを実行する「ICU」拡張機能が含まれています。または、開発者は、プロジェクト内に既に含まれている独自のUnicode対応の比較ルーチンに基づいて、独自のオーバーロードを作成できます。</target>
        </trans-unit>
        <trans-unit id="e02d371a11cece5f4e01254e6fedf80303033a58" translate="yes" xml:space="preserve">
          <source>Instead of using a single data structure on disk to store the full-text index, FTS5 uses a series of b-trees. Each time a new transaction is committed, a new b-tree containing the contents of the committed transaction is written into the database file. When the full-text index is queried, each b-tree must be queried individually and the results merged before being returned to the user.</source>
          <target state="translated">フルテキストインデックスを格納するためにディスク上の単一のデータ構造を使用する代わりに、FTS5は一連のb-木を使用する。新しいトランザクションがコミットされるたびに、コミットされたトランザクションの内容を含む新しいb-木がデータベースファイルに書き込まれる。フルテキストインデックスがクエリされるとき、各bツリーは個別にクエリされ、結果がマージされてからユーザに返されなければならない。</target>
        </trans-unit>
        <trans-unit id="17249ad26f29e1aabdd8d073e961780b07d76064" translate="yes" xml:space="preserve">
          <source>Instead of using bm25() with no trailing arguments, the specific auxiliary function mapped to the rank column may be configured either on a per-query basis, or by setting a different persistent default for the FTS table.</source>
          <target state="translated">bm25()を最後の引数なしで使用する代わりに、ランク列にマップされた特定の補助関数は、クエリごとに、またはFTSテーブルに別の永続的なデフォルトを設定することによって設定することができます。</target>
        </trans-unit>
        <trans-unit id="f96fd53b0d03f5a031e6bd07854c303b890ed6f3" translate="yes" xml:space="preserve">
          <source>Instead of writing separately to the full-text index and the content table, some users may wish to use database triggers to keep the full-text index up to date with respect to the set of documents stored in the content table. For example, using the tables from earlier examples:</source>
          <target state="translated">全文インデックスとコンテンツテーブルに別々に書き込む代わりに、データベースのトリガーを使用して、コンテンツテーブルに格納されている文書のセットに関して、全文インデックスを最新の状態に保つことを望むユーザーもいるかもしれません。例えば、以前の例のテーブルを使用して、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="2dfaa927aed3a85d724ea909cde490986f208ecf" translate="yes" xml:space="preserve">
          <source>Instruction 1 is of particular importance in this example. Normally, the Column instruction extracts the value of a column from a larger record in the data of an SQLite file entry. Instruction 1 sets a flag on the transient table so that Column will instead treat the key of the SQLite file entry as if it were data and extract column information from the key.</source>
          <target state="translated">この例では、命令1が特に重要です。通常、Column 命令は SQLite ファイル エントリのデータ内のより大きなレコードからカラムの値を抽出します。命令 1 は過渡的なテーブルにフラグを設定して、Column が代わりに SQLite ファイル エントリのキーをあたかもデータであるかのように扱い、キーからカラム情報を抽出するようにします。</target>
        </trans-unit>
        <trans-unit id="5a41b63030179eee6fe726824158f303ff0039a4" translate="yes" xml:space="preserve">
          <source>Instructions 0 though 4 are as in the INSERT example. They start transactions for the main and temporary databases, verify the database schema for the main database, and open a read cursor on the table &quot;examp&quot;. Notice that the cursor is opened for reading, not writing. At this stage of the program we are only going to be scanning the table, not changing it. We will reopen the same table for writing later, at instruction 15.</source>
          <target state="translated">命令0から4は、INSERTの例と同じです。それらは、メイン・データベースと一時データベースのトランザクションを開始し、メイン・データベースのデータベース・スキーマを検証し、テーブル &quot;examp &quot;上に読み取りカーソルを開きます。カーソルは書き込みではなく読み込みのために開かれていることに注意してください。このプログラムのこの段階では、テーブルをスキャンするだけで、変更はしません。同じテーブルを後で、命令15で書き込み用に開き直します。</target>
        </trans-unit>
        <trans-unit id="b00a667a760d339b93dad1b03b5b7f4819103702" translate="yes" xml:space="preserve">
          <source>Instructions 11 through 18 implement a loop over all index records with the key that was fetched by instruction 8. All of the index records with this key will be contiguous in the index table, so we walk through them and fetch the corresponding table key from the index. This table key is then used to move the cursor to that row in the table. The rest of the loop is the same as the loop for the non-indexed SELECT query.</source>
          <target state="translated">命令11から18までは、命令8によってフェッチされたキーを持つすべてのインデックスレコード上のループを実装します。このキーを持つすべてのインデックスレコードはインデックステーブル内で連続しているので、それらをウォークスルーし、インデックスから対応するテーブルキーをフェッチします。そして、このテーブルキーは、テーブル内のその行にカーソルを移動させるために使用されます。残りのループは、インデックスを持たないSELECTクエリのループと同じです。</target>
        </trans-unit>
        <trans-unit id="93ad75caff49702ce2412b358044c514b17d458d" translate="yes" xml:space="preserve">
          <source>Instructions 18 through 23 implement a loop over every row of the table being indexed. For each table row, we first extract the integer key for that row using Recno in instruction 19, then get the value of the &quot;two&quot; column using Column in instruction 20. The &lt;a href=&quot;opcode#MakeIdxKey&quot;&gt;MakeIdxKey&lt;/a&gt; instruction at 21 converts data from the &quot;two&quot; column (which is on the top of the stack) into a valid index key. For an index on a single column, this is basically a no-op. But if the P1 operand to MakeIdxKey had been greater than one multiple entries would have been popped from the stack and converted into a single index key. The &lt;a href=&quot;opcode#IdxPut&quot;&gt;IdxPut&lt;/a&gt; instruction at 22 is what actually creates the index entry. IdxPut pops two elements from the stack. The top of the stack is used as a key to fetch an entry from the index table. Then the integer which was second on stack is added to the set of integers for that index and the new record is written back to the database file. Note that the same index entry can store multiple integers if there are two or more table entries with the same value for the two column.</source>
          <target state="translated">命令18から23は、インデックス付けされるテーブルのすべての行にループを実装します。テーブルの各行について、最初に命令19のRecnoを使用してその行の整数キーを抽出し、次に命令20の列を使用して「2」列の値を取得します&lt;a href=&quot;opcode#MakeIdxKey&quot;&gt;。21のMakeIdxKey&lt;/a&gt;命令は「2」列からデータを変換します（スタックの一番上にあります）有効なインデックスキーに。単一列のインデックスの場合、これは基本的に何もしません。ただし、MakeIdxKeyのP1オペランドが1より大きい場合、複数のエントリがスタックからポップされ、単一のインデックスキーに変換されます。&lt;a href=&quot;opcode#IdxPut&quot;&gt;IdxPut&lt;/a&gt;22の命令は、実際にインデックスエントリを作成するものです。IdxPutは2つの要素をスタックからポップします。スタックの最上部は、インデックステーブルからエントリをフェッチするためのキーとして使用されます。次に、スタックで2番目の整数がそのインデックスの整数のセットに追加され、新しいレコードがデータベースファイルに書き戻されます。2つの列に同じ値を持つ2つ以上のテーブルエントリがある場合、同じインデックスエントリが複数の整数を格納できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d073fd93c649c9cf841978f9cb4f52abf67079a9" translate="yes" xml:space="preserve">
          <source>Instructions 19 through 25 construct a new database record that will be used to replace the existing record. This is the same kind of code that we saw in the description of INSERT and will not be described further. After instruction 25 executes, the stack looks like this:</source>
          <target state="translated">命令19から25は、既存のレコードを置き換えるために使用される新しいデータベースレコードを構築します。これはINSERTの説明で見たのと同じ種類のコードなので、これ以上は説明しません。命令25が実行された後、スタックは次のようになります。</target>
        </trans-unit>
        <trans-unit id="560e44647be24d5aca941bd1314e718abb8f4a57" translate="yes" xml:space="preserve">
          <source>Instructions 2 and 3 open a read cursor on the database table that is to be queried. This works the same as the OpenWrite instruction in the INSERT example except that the cursor is opened for reading this time instead of for writing. Instruction 4 verifies the database schema as in the INSERT example.</source>
          <target state="translated">命令2と3は、問い合わせ先のデータベース・テーブル上に読み取りカーソルを開きます。これはINSERTの例のOpenWrite命令と同じように動作しますが、今回はカーソルが書き込み用ではなく読み取り用に開かれています。命令4はINSERTの例と同様にデータベーススキーマを検証します。</target>
        </trans-unit>
        <trans-unit id="fca2a6be701ffa87d686ce081ffdb761ec90891d" translate="yes" xml:space="preserve">
          <source>Instructions for compiling for Android are &lt;a href=&quot;#compile-android&quot;&gt;shown below&lt;/a&gt;.</source>
          <target state="translated">Android向けのコンパイル手順を&lt;a href=&quot;#compile-android&quot;&gt;以下に示します&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="180fcbe698d0f2c44101a06215c472930bbd0a01" translate="yes" xml:space="preserve">
          <source>Int64</source>
          <target state="translated">Int64</target>
        </trans-unit>
        <trans-unit id="8245fcad9e0056a0d272c8564c605d1f5607526e" translate="yes" xml:space="preserve">
          <source>IntCopy</source>
          <target state="translated">IntCopy</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="d591fd91d02ea91f2fb6bfc98baa68985aa1c55d" translate="yes" xml:space="preserve">
          <source>Integer arithmetic operations that would have resulted in overflow are now performed using floating-point instead.</source>
          <target state="translated">オーバーフローの原因となっていた整数演算が、代わりに浮動小数点を使用して実行されるようになりました。</target>
        </trans-unit>
        <trans-unit id="a45ac87a27eab6aa76ce2b5c611f2a64d3669419" translate="yes" xml:space="preserve">
          <source>Integer values stored as part of segment b-tree nodes are encoded using the FTS varint format. This encoding is similar, but &lt;b&gt;not identical&lt;/b&gt;, to the &lt;a href=&quot;fileformat#varint_format&quot;&gt;SQLite varint format&lt;/a&gt;.</source>
          <target state="translated">セグメントbツリーノードの一部として格納された整数値は、FTS varint形式を使用してエンコードされます。このエンコーディングは&lt;a href=&quot;fileformat#varint_format&quot;&gt;SQLite varint形式&lt;/a&gt;と似ていますが&lt;b&gt;、同じ&lt;/b&gt;ではあり&lt;b&gt;ません&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="60896296e2cc4f360fd103b1acf3b75080d48243" translate="yes" xml:space="preserve">
          <source>Integrity of the freelist</source>
          <target state="translated">フリーリストの誠実さ</target>
        </trans-unit>
        <trans-unit id="e5d27de0bdb200a7cf8d08a229aa8daa78f0e8ef" translate="yes" xml:space="preserve">
          <source>IntegrityCk</source>
          <target state="translated">IntegrityCk</target>
        </trans-unit>
        <trans-unit id="825d7872ab454dde0951d75f4e8c3836556b73f2" translate="yes" xml:space="preserve">
          <source>Intended Use Of This Memory Slot</source>
          <target state="translated">このメモリスロットの使用目的</target>
        </trans-unit>
        <trans-unit id="bad6e55f508278bbd1f2de2f51b2cfa41d861db7" translate="yes" xml:space="preserve">
          <source>Interbase</source>
          <target state="translated">Interbase</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="5fe5b201b27c997051ff6e5d94d0bbfdf6211714" translate="yes" xml:space="preserve">
          <source>Interior pages of table b-trees have no payload and so there is never any payload to spill.</source>
          <target state="translated">テーブルbツリーの内部ページにはペイロードがないので、こぼれ落ちるペイロードがあることはありません。</target>
        </trans-unit>
        <trans-unit id="fc9225a1693f44637be7aea70d7fcc2c5840704d" translate="yes" xml:space="preserve">
          <source>Internal</source>
          <target state="translated">Internal</target>
        </trans-unit>
        <trans-unit id="2e2e38ed2987465eebf4fce7929c514aa147e99c" translate="yes" xml:space="preserve">
          <source>Internal Versus External BLOBs</source>
          <target state="translated">内部BLOBと外部BLOB</target>
        </trans-unit>
        <trans-unit id="8f5ed2d53487fd119b9560f28f441dc6f596f2d9" translate="yes" xml:space="preserve">
          <source>Internal Versus External BLOBs in SQLite</source>
          <target state="translated">SQLiteにおける内部BLOBと外部BLOBの比較</target>
        </trans-unit>
        <trans-unit id="e76edc7c42bb9553424aeb43d13659b70db42f10" translate="yes" xml:space="preserve">
          <source>Internal schema objects used by SQLite may include the following:</source>
          <target state="translated">SQLite が使用する内部スキーマオブジェクトには、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="f7a3c018025e7b8852ebedd2735d4dc85161ed87" translate="yes" xml:space="preserve">
          <source>Internal table</source>
          <target state="translated">内部テーブル</target>
        </trans-unit>
        <trans-unit id="43a9dae252aed092af4315626ccea64ecf3ea367" translate="yes" xml:space="preserve">
          <source>Internally, Geopoly stores polygons in a binary format - an SQL BLOB. Details of the binary format are given below. All of the Geopoly interfaces are able to accept polygons in either the GeoJSON format or in the binary format.</source>
          <target state="translated">内部的には、GeopolyはポリゴンをSQL BLOBというバイナリ形式で保存します。バイナリフォーマットの詳細は以下に記載されています。すべてのGeopolyインターフェースは、GeoJSONフォーマットまたはバイナリフォーマットのポリゴンを受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="f1e37c3aeef00d8b7d2ca4c1560bedb3798f4927" translate="yes" xml:space="preserve">
          <source>Internationalization of the TRIM() function. Ticket #2323</source>
          <target state="translated">TRIM()関数の国際化。チケット #2323</target>
        </trans-unit>
        <trans-unit id="888710a95af8568e1d72613950e6141b6fd4f17f" translate="yes" xml:space="preserve">
          <source>Interpret the byte at offset X into the page as an 8-bit unsigned integer and add the value of that integer to the checksum.</source>
          <target state="translated">ページ内のオフセットXのバイトを8ビットの符号なし整数として解釈し、その整数の値をチェックサムに加算します。</target>
        </trans-unit>
        <trans-unit id="0a6e9fc795cd5f992a07708fafc38d37296f0f2e" translate="yes" xml:space="preserve">
          <source>Interpret the content of register P1 as an integer. Store the ones-complement of the P1 value into register P2. If P1 holds a NULL then store a NULL in P2.</source>
          <target state="translated">レジスタP1の内容を整数として解釈します。P1 の値の ones-complement をレジスタ P2 に格納します。P1がNULLを保持している場合は、P2にNULLを格納します。</target>
        </trans-unit>
        <trans-unit id="5e8db10d44914bca3da452a09d9353f35541c4d5" translate="yes" xml:space="preserve">
          <source>Interpret the data that cursor P1 points to as a structure built using the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; instruction. (See the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; opcode for additional information about the format of the data.) Extract the P2-th column from this record. If there are less that (P2+1) values in the record, extract a NULL.</source>
          <target state="translated">カーソルP1が指すデータを、&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;命令を使用して作成された構造体として解釈します。（データの形式の詳細については、&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;オペコードを参照してください。）このレコードからP2番目の列を抽出します。レコードの値が（P2 + 1）より少ない場合は、NULLを抽出します。</target>
        </trans-unit>
        <trans-unit id="2f79feeee233aec484084c713d84bf8b19e18fec" translate="yes" xml:space="preserve">
          <source>Interpret the value in register P1 as a boolean value. Store that boolean (a 0 or 1) in register P2. Or if the value in register P1 is NULL, then the P3 is stored in register P2. Invert the answer if P4 is 1.</source>
          <target state="translated">レジスタP1の値をブール値として解釈します。そのブール値(0または1)をレジスタP2に格納する。または、レジスタP1の値がNULLであれば、そのP3をレジスタP2に格納する。P4が1であれば答えを反転させます。</target>
        </trans-unit>
        <trans-unit id="11ded0e7491f472be93758e1becf6a72788c6084" translate="yes" xml:space="preserve">
          <source>Interpret the value in register P1 as a boolean value. Store the boolean complement in register P2. If the value in register P1 is NULL, then a NULL is stored in P2.</source>
          <target state="translated">レジスタP1の値をブール値として解釈します。そのブール値の補数をレジスタP2に格納します。レジスタP1の値がNULLの場合は、P2にNULLを格納します。</target>
        </trans-unit>
        <trans-unit id="15470fd033e12b800743519c6e594f7da0f4f0f0" translate="yes" xml:space="preserve">
          <source>Interpretation</source>
          <target state="translated">Interpretation</target>
        </trans-unit>
        <trans-unit id="1215cbe2c98ef14d7aa50ec46f17432a95774205" translate="yes" xml:space="preserve">
          <source>Interrupt A Long-Running Query</source>
          <target state="translated">長時間実行中のクエリの割り込み</target>
        </trans-unit>
        <trans-unit id="5c1dd154209c449e02a41fa43190c4baa16c350d" translate="yes" xml:space="preserve">
          <source>Introduce extended error codes and add error codes for various kinds of I/O errors.</source>
          <target state="translated">拡張エラーコードを導入し、各種I/Oエラーのエラーコードを追加します。</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="99fc2e9eb55cb6b8a4a8e79d3fb3b2c33516ae12" translate="yes" xml:space="preserve">
          <source>Introspect the disk content of an SQLite database file (the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;)</source>
          <target state="translated">SQLiteデータベースファイル（&lt;a href=&quot;dbstat&quot;&gt;dbstat仮想テーブル&lt;/a&gt;）のディスクコンテンツをイントロスペクトする</target>
        </trans-unit>
        <trans-unit id="eca078956e48bad9ba22213be258664ddfba5fe3" translate="yes" xml:space="preserve">
          <source>Intuitively, we humans understand that algorithm-1 is best. Each check-in is likely to have few children (one child is the most common case) and each child can be tested for the $trunk tag in logarithmic time. Indeed, algorithm-1 is the faster choice in practice. But the NGQP has no intuition. The NGQP must use hard math, and algorithm-2 is slightly better mathematically. This is because, in the absence of other information, the NGQP must assume that the indexes PLINK_I1 and TAGXREF_I1 are of equal quality and are equally selective. Algorithm-2 uses one field of the TAGXREF_I1 index and both fields of the PLINK_I1 index whereas algorithm-1 only uses the first field of each index. Since algorithm-2 uses more index material, the NGQP is correct to judge it to be the better algorithm. The scores are close and algorithm-2 just barely squeaks ahead of algorithm-1. But algorithm-2 really is the correct choice here.</source>
          <target state="translated">直感的に、私たち人間はアルゴリズム-1が最良であることを理解しています。各チェックインは、子供が少ない(1人の子供が最も一般的なケースです)可能性が高く、各子供は対数時間で$trunkタグをテストすることができます。実際、実際にはアルゴリズム-1の方が速い選択です。しかし、NGQPには直感がありません。NGQPは難しい数学を使わなければならず、アルゴリズム-2の方が数学的にはわずかに優れています。これは、他の情報がない場合、NGQPはインデックスPLINK_I1とTAGXREF_I1が同等の品質であり、等しく選択的であると仮定しなければならないからです。アルゴリズム-2は、アルゴリズム-1が各インデックスの最初のフィールドのみを使用するのに対し、TAGXREF_I1インデックスの1つのフィールドとPLINK_I1インデックスの両方のフィールドを使用する。アルゴリズム-2はより多くのインデックスを使用するので、NGQPはそれがより優れたアルゴリズムであると判断するのが正しいです。スコアは近くにあり、アルゴリズム-2 はアルゴリズム-1 の前をかろうじてこけています。しかし、ここではアルゴリズム-2 が本当に正しい選択です。</target>
        </trans-unit>
        <trans-unit id="b761791d82a982a68e59a508cac1ee842272cd79" translate="yes" xml:space="preserve">
          <source>Invert A Changeset</source>
          <target state="translated">チェンジセットの反転</target>
        </trans-unit>
        <trans-unit id="e32caad6eec08f7fecc6a1b58616c917f68be530" translate="yes" xml:space="preserve">
          <source>Invert the changeset before applying it. This is equivalent to inverting a changeset using sqlite3changeset_invert() before applying it. It is an error to specify this flag with a patchset.</source>
          <target state="translated">チェンジセットを適用する前に反転させます。これは、適用する前にsqlite3changeset_invert()を使用してチェンジセットを反転させることと同等です。このフラグをパッチセットで指定するのはエラーです。</target>
        </trans-unit>
        <trans-unit id="78ac8e24cc6e1af906f6d84df224cae4a5dbdc9c" translate="yes" xml:space="preserve">
          <source>Invert the changeset while iterating through it. This is equivalent to inverting a changeset using sqlite3changeset_invert() before applying it. It is an error to specify this flag with a patchset.</source>
          <target state="translated">チェンジセットを反復処理している間、チェンジセットを反転します。これは、適用する前にsqlite3changeset_invert()を使用してチェンジセットを反転させることと同等です。このフラグをパッチセットで指定するのはエラーです。</target>
        </trans-unit>
        <trans-unit id="7bcd843ccbf3ca2b0a46090c9286f7cf70d294d4" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;,0,0) on each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as soon as it is opened.</source>
          <target state="translated">&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;が開かれるとすぐに、各データベース接続で&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;、0,0）を呼び出します。</target>
        </trans-unit>
        <trans-unit id="ebc598ee05cff833de713e00e614680a147ad7e5" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;,0,0) on each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as soon as it is opened. This prevents application-defined functions from being used in places where an attacker might be able to surreptiously invoke them by modifying a database schema:</source>
          <target state="translated">&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;が開かれるとすぐに、各データベース接続で&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;、0,0）を呼び出します。これにより、攻撃者がデータベーススキーマを変更することにより、アプリケーション定義関数を密かに呼び出すことができる可能性のある場所で、アプリケーション定義関数が使用されるのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="1f705eccb3bd6ee22f3941d7379adda7f2017d82" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; on the database connection handle associated with the supplied statement handle to register for an unlock-notify callback. If the call to unlock_notify() returns SQLITE_LOCKED, then return this value to the caller.</source>
          <target state="translated">提供されたステートメントハンドルに関連付けられているデータベース接続ハンドルで&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;を呼び出して、ロック解除通知コールバックに登録します。unlock_notify（）の呼び出しがSQLITE_LOCKEDを返す場合、この値を呼び出し元に返します。</target>
        </trans-unit>
        <trans-unit id="7c709a0509002cbc5917883c970a9481452275c1" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to a FuncDef object that defines the function) with P5 arguments taken from register P2 and successors. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">レジスタP2から取り出されたP5の引数とその後継者でユーザ関数(P4は関数を定義するFuncDefオブジェクトへのポインタ)を呼び出します。関数の結果はレジスタP3に格納されます。レジスタP3は関数の入力の一つであってはなりません。</target>
        </trans-unit>
        <trans-unit id="d5afe87b60965605a9297c781c01328e7ab18fc9" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to an sqlite3_context object that contains a pointer to the function to be run) with P5 arguments taken from register P2 and successors. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">レジスタP2とその後継から取り出されたP5の引数でユーザ関数(P4は実行される関数へのポインタを含むsqlite3_contextオブジェクトへのポインタ)を呼び出します。関数の結果はレジスタP3に格納されます。レジスタP3は関数の入力の一つであってはなりません。</target>
        </trans-unit>
        <trans-unit id="bf8b8c1d4d822ee5f5035e452152155ef6c1caa7" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to an sqlite3_context object that contains a pointer to the function to be run) with arguments taken from register P2 and successors. The number of arguments is in the sqlite3_context object that P4 points to. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">レジスタP2とその後継から取り出した引数でユーザ関数(P4は実行する関数へのポインタを含むsqlite3_contextオブジェクトへのポインタ)を呼び出します。引数の数はP4が指すsqlite3_contextオブジェクトにあります。関数の結果はレジスタP3に格納されます。レジスタP3は関数の入力の一つであってはなりません。</target>
        </trans-unit>
        <trans-unit id="ec3125db909dbad56a3a25ad8b3535b576369321" translate="yes" xml:space="preserve">
          <source>Invoke the 'merge' command once with the parameter set to -N, then</source>
          <target state="translated">パラメータを -N に設定した状態で 'merge' コマンドを一度だけ呼び出してから</target>
        </trans-unit>
        <trans-unit id="7dd177608c23145959faf29e93b347c2a9c95d8f" translate="yes" xml:space="preserve">
          <source>Invoke the 'merge' command zero or more times with the parameter set to N.</source>
          <target state="translated">パラメータを N に設定して、'merge' コマンドを 0 回以上実行します。</target>
        </trans-unit>
        <trans-unit id="66ccce8dbed894fb937993244705085ff4d8803a" translate="yes" xml:space="preserve">
          <source>Invoke the callback function for the current row of the result.</source>
          <target state="translated">結果の現在の行のコールバック関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="125398c8d0ddcbf991b86f4ee6d99da4c12cf932" translate="yes" xml:space="preserve">
          <source>Invoke the sqlite3rbu_step(X) function one or more times on the sqlite3rbu object pointer X. Each call to sqlite3rbu_step() performs a single b-tree operation, so thousands of calls may be required to apply a complete update. The sqlite3rbu_step() interface will return SQLITE_DONE when the update has been completely applied.</source>
          <target state="translated">sqlite3rbuオブジェクトポインタXに対してsqlite3rbu_step(X)関数を1回以上呼び出します。 sqlite3rbu_step()の各呼び出しは1つのb-tree操作を実行するので、完全な更新を適用するためには何千回も呼び出す必要があるかもしれません。sqlite3rbu_step()インタフェースは、更新が完全に適用されたときにSQLITE_DONEを返します。</target>
        </trans-unit>
        <trans-unit id="09ac0f478fa9c31ebe084063003a8993cc83456c" translate="yes" xml:space="preserve">
          <source>Invoke the xValue() function and store the result in register P3.</source>
          <target state="translated">xValue()関数を呼び出し、その結果をレジスタP3に格納します。</target>
        </trans-unit>
        <trans-unit id="ec2b47e7de90dfad0a6211ad1cb07982eafe0cde" translate="yes" xml:space="preserve">
          <source>Invoking sqlite3_finalize() on a NULL pointer is a harmless no-op.</source>
          <target state="translated">NULLポインタ上でsqlite3_finalize()を呼び出すことは無害なノーオペです。</target>
        </trans-unit>
        <trans-unit id="bd8202d31b1a7640473e2e12fd946892b1ec4008" translate="yes" xml:space="preserve">
          <source>Invoking this pragma with an argument is equivalent to calling the &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; C interface with a &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;3rd parameter&lt;/a&gt; corresponding to the argument:</source>
          <target state="translated">引数を指定してこのプラグマを呼び出すことは、引数に対応する&lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;3番目のパラメーターを指定&lt;/a&gt;して&lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt; Cインターフェイスを呼び出すことと同じです。</target>
        </trans-unit>
        <trans-unit id="5f0e3d2a93c21482714b0b7a93ae0ad2d3dfb1f3" translate="yes" xml:space="preserve">
          <source>Invoking this pragma without an argument is equivalent to calling the &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; C interface.</source>
          <target state="translated">引数なしでこのプラグマを呼び出すことは、&lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint（）&lt;/a&gt; Cインターフェースを呼び出すことと同じです。</target>
        </trans-unit>
        <trans-unit id="8cedb7aa520fd9ec8eb114043f05f6f9d17e93dd" translate="yes" xml:space="preserve">
          <source>Is SQLite threadsafe?</source>
          <target state="translated">SQLiteはスレッドセーフですか?</target>
        </trans-unit>
        <trans-unit id="d993744fe6f739c6aa4d5f6de34d342868d7e529" translate="yes" xml:space="preserve">
          <source>Is replaced by:</source>
          <target state="translated">置き換えられています。</target>
        </trans-unit>
        <trans-unit id="accaed01010f56d422eef5c33bfb4384f7eeeed3" translate="yes" xml:space="preserve">
          <source>IsNull</source>
          <target state="translated">IsNull</target>
        </trans-unit>
        <trans-unit id="a0830278e8f462114ebf33a9e4e362b34c86b01d" translate="yes" xml:space="preserve">
          <source>IsTrue</source>
          <target state="translated">IsTrue</target>
        </trans-unit>
        <trans-unit id="3dea5e42ca2754f9e6823ecfc4f51c71cf05676a" translate="yes" xml:space="preserve">
          <source>Isolation And Concurrency</source>
          <target state="translated">分離と並行性</target>
        </trans-unit>
        <trans-unit id="6a3e64b57124b4061c4f707d69ad242f0d0e0ef1" translate="yes" xml:space="preserve">
          <source>Isolation Between Database Connections</source>
          <target state="translated">データベース接続間の分離</target>
        </trans-unit>
        <trans-unit id="e3488e8cb34f4c736ddb072c649ba2a6c79489e5" translate="yes" xml:space="preserve">
          <source>Isolation In SQLite</source>
          <target state="translated">SQLiteでの分離</target>
        </trans-unit>
        <trans-unit id="2dfabf57c5175b858eac45130bf0b51df7502b3e" translate="yes" xml:space="preserve">
          <source>Issue an &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt; warning on the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; whenever the query planner uses an automatic index.</source>
          <target state="translated">クエリプランナーが自動インデックスを使用する&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;場合は&lt;/a&gt;常に、&lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_CONFIG_LOGでSQLITE_WARNING_AUTOINDEX&lt;/a&gt;警告を発行します。</target>
        </trans-unit>
        <trans-unit id="ffb450eea3632a82507d6bc65c2b7d60604799db" translate="yes" xml:space="preserve">
          <source>Issue an SQLITE_WARNING message on the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; if a &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; is used.</source>
          <target state="translated">&lt;a href=&quot;quirks#dblquote&quot;&gt;二重引用符で囲まれた文字列リテラル&lt;/a&gt;が使用されている場合は、&lt;a href=&quot;errlog&quot;&gt;エラーログで&lt;/a&gt; SQLITE_WARNINGメッセージを発行します。</target>
        </trans-unit>
        <trans-unit id="887bf7a7997457d1a84b4ef3887a47fd35509c6e" translate="yes" xml:space="preserve">
          <source>Issue an error rather instead of an assertion-fault or null-pointer dereference when the sqlite_master table is corrupted so that the sqlite_sequence table root page is really a btree-index page. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/525deb7a67fbd647&quot;&gt;525deb7a67fbd647&lt;/a&gt;</source>
          <target state="translated">sqlite_masterテーブルが破損し、sqlite_sequenceテーブルのルートページが実際にはbtreeインデックスページになるように、アサーションフォールトまたはnullポインター逆参照の代わりにエラーを発行します。チェックイン&lt;a href=&quot;https://www.sqlite.org/src/info/525deb7a67fbd647&quot;&gt;525deb7a67fbd647&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="265877cc565c8d7a6873f0a63d90a0fdd348de2c" translate="yes" xml:space="preserve">
          <source>It an error if database zFrom does not exist or does not contain the required compatible table.</source>
          <target state="translated">データベース zFrom が存在しないか、必要な互換性のあるテーブルが含まれていない場合のエラーです。</target>
        </trans-unit>
        <trans-unit id="0e154e176231a0aafc6a2d79aba315f0be81a2c2" translate="yes" xml:space="preserve">
          <source>It cannot be used to copy data to or from in-memory databases.</source>
          <target state="translated">インメモリデータベースへの、またはインメモリデータベースからのデータのコピーには使用できません。</target>
        </trans-unit>
        <trans-unit id="6fd3c51616175d12c8323af133471dff22943ef2" translate="yes" xml:space="preserve">
          <source>It could handle a special case of SQLITE_LOCKED that can occur when dropping a table or index.</source>
          <target state="translated">テーブルやインデックスを削除したときに発生する SQLITE_LOCKED の特殊なケースを扱うことができました。</target>
        </trans-unit>
        <trans-unit id="186b030c86f45f0c84d4dba2b997ab209083ef94" translate="yes" xml:space="preserve">
          <source>It could manage thread priorities.</source>
          <target state="translated">スレッドの優先順位を管理することができました。</target>
        </trans-unit>
        <trans-unit id="46b90c15208f2a0e159c21cdb03813412db842c6" translate="yes" xml:space="preserve">
          <source>It exists, and</source>
          <target state="translated">それは存在し</target>
        </trans-unit>
        <trans-unit id="40ecc5a776918cb0ff3984e5d8619d213f6f930d" translate="yes" xml:space="preserve">
          <source>It is a good idea to establish a convention for determining the RBU vacuum state database name based on the target database name. The example code below uses &quot;&amp;lt;target&amp;gt;-vacuum&quot;, where &amp;lt;target&amp;gt; is the name of the database being vacuumed.</source>
          <target state="translated">ターゲットデータベース名に基づいてRBUバキューム状態データベース名を決定するための規則を確立することをお勧めします。以下のコード例では、「&amp;lt;target&amp;gt; -vacuum」を使用しています。ここで、&amp;lt;target&amp;gt;は、バキュームされるデータベースの名前です。</target>
        </trans-unit>
        <trans-unit id="bc2605e225f0c06786d4d6602b4aa9c521bcd8db" translate="yes" xml:space="preserve">
          <source>It is acceptable to call &lt;b&gt;sqlite_finalize&lt;/b&gt; on a virtual machine before &lt;b&gt;sqlite_step&lt;/b&gt; has returned SQLITE_DONE. Doing so has the effect of interrupting the operation in progress. Partially completed changes will be rolled back and the database will be restored to its original state (unless an alternative recovery algorithm is selected using an ON CONFLICT clause in the SQL being executed.) The effect is the same as if a callback function of &lt;b&gt;sqlite_exec&lt;/b&gt; had returned non-zero.</source>
          <target state="translated">&lt;b&gt;sqlite_step&lt;/b&gt;が&lt;b&gt;SQLITE_DONE&lt;/b&gt;を返す前に、仮想マシンで&lt;b&gt;sqlite_finalize&lt;/b&gt;を呼び出すことは許容されます。これを行うと、進行中の操作が中断されます。部分的に完了した変更はロールバックされ、データベースは元の状態に復元されます（実行中のSQLでON CONFLICT句を使用して代替の復旧アルゴリズムが選択されている場合を除く）。効果は、&lt;b&gt;sqlite_execの&lt;/b&gt;コールバック関数が&lt;b&gt;持っ&lt;/b&gt;ていた場合と同じです。ゼロ以外を返しました。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9b1cdd52a287f4e7becc07615494854f9dea1062" translate="yes" xml:space="preserve">
          <source>It is also acceptable to call &lt;b&gt;sqlite_finalize&lt;/b&gt; on a virtual machine that has never been passed to &lt;b&gt;sqlite_step&lt;/b&gt; even once.</source>
          <target state="translated">また、一度も&lt;b&gt;sqlite_stepに&lt;/b&gt;渡されたことがない仮想マシンで&lt;b&gt;sqlite_finalize&lt;/b&gt;を呼び出すこともできます。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8524404ce2a2650e2fd11b49dcd571c2f2744c61" translate="yes" xml:space="preserve">
          <source>It is also possible to create custom tokenizers for FTS5. The API for doing so is &lt;a href=&quot;fts5#custom_tokenizers&quot;&gt;described here&lt;/a&gt;.</source>
          <target state="translated">FTS5のカスタムトークナイザーを作成することもできます。そのためのAPIについては&lt;a href=&quot;fts5#custom_tokenizers&quot;&gt;、ここ&lt;/a&gt;で説明します。</target>
        </trans-unit>
        <trans-unit id="af4ea7504b8858e61227bf5cbac3c869a2ebb0cf" translate="yes" xml:space="preserve">
          <source>It is also possible to customize the set of codepoints that unicode61 treats as separator characters. The &quot;separators=&quot; option may be used to specify one or more extra characters that should be treated as separator characters, and the &quot;tokenchars=&quot; option may be used to specify one or more extra characters that should be treated as part of tokens instead of as separator characters. For example:</source>
          <target state="translated">unicode61 がセパレータキ ャ ラ ク タ と し て扱う コ ー ド 点の集合を カ ス タ マ イ ズす る こ と も で き ます。separators=&quot;オプションを使って、セパレータ文字として扱うべき1つ以上の余分な文字を指定したり、&quot;tokenchars=&quot;オプションを使って、セパレータ文字としてではなくトークンの一部として扱うべき1つ以上の余分な文字を指定したりすることができます。例えば、&quot;tokenchars=&quot;オプションを使用して、セパレータ文字としてではなくトークンの一部として扱うべき1つ以上の余分な文字を指定することができます。</target>
        </trans-unit>
        <trans-unit id="c5f2716f625be713954d4be305f323e2da4e7532" translate="yes" xml:space="preserve">
          <source>It is also possible to express this kind of simultaneous read and write on an R-Tree within a single query, for example if an UPDATE statement tries to change the value of one row of the R-Tree based on a complicated query from another row of the same R-Tree, perhaps something like this:</source>
          <target state="translated">例えば、UPDATE文が、同じR-Treeの別の行からの複雑なクエリに基づいて、R-Treeのある行の値を変更しようとした場合、おそらく次のように表現することができます。</target>
        </trans-unit>
        <trans-unit id="756b3fcc2f7b6b94c8632586f6c6ecc720cec025" translate="yes" xml:space="preserve">
          <source>It is an error to add types, constraints or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; declarations to a CREATE VIRTUAL TABLE statement used to create an FTS5 table. Once created, an FTS5 table may be populated using &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements like any other table. Like any other table with no PRIMARY KEY declaration, an FTS5 table has an implicit INTEGER PRIMARY KEY field named rowid.</source>
          <target state="translated">FTS5テーブルの作成に使用されるCREATE VIRTUAL TABLEステートメントにタイプ、制約、または&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;宣言を追加すると、エラーになります。作成されたFTS5テーブルは、他のテーブルと同様に、&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;、&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;または&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;ステートメントを使用して入力できます。PRIMARY KEY宣言のない他のテーブルと同様に、FTS5テーブルには、rowidという名前の暗黙のINTEGER PRIMARY KEYフィールドがあります。</target>
        </trans-unit>
        <trans-unit id="444eee32669789fe15a56475160491d70e6d7f57" translate="yes" xml:space="preserve">
          <source>It is an error to attempt to set the sz or rawdata field to any value other than NULL.</source>
          <target state="translated">sz または rawdata フィールドに NULL 以外の値を設定しようとするとエラーになります。</target>
        </trans-unit>
        <trans-unit id="24bfd3e9a865c193cff416ba8b58e38e3815e72c" translate="yes" xml:space="preserve">
          <source>It is an error to set the columnsize option to any value other than 0 or 1.</source>
          <target state="translated">columnsize オプションを 0 または 1 以外の値に設定するとエラーになります。</target>
        </trans-unit>
        <trans-unit id="66b8e09fbd7b220da38b0f56a632afa06ded1cc2" translate="yes" xml:space="preserve">
          <source>It is an error to specify the FTS5_TOKEN_COLOCATED flag the first time xToken() is called. Multiple synonyms may be specified for a single token by making multiple calls to xToken(FTS5_TOKEN_COLOCATED) in sequence. There is no limit to the number of synonyms that may be provided for a single token.</source>
          <target state="translated">最初に xToken()が呼び出されたときに FTS5_TOKEN_COLOCATED フラグを指定するのはエラーです。xToken(FTS5_TOKEN_COLOCATED)を連続して複数回呼び出すことで、1つのトークンに対して複数の同義語を指定することができます。1 つのトークンに対して提供される同義語の数に制限はありません。</target>
        </trans-unit>
        <trans-unit id="f8a103b729e696566ddb48fa0100f23ca6a9cb4a" translate="yes" xml:space="preserve">
          <source>It is assumed that the cursor is used only for appending and so if the cursor is valid, then the cursor must already be pointing at the end of the btree and so no changes are made to the cursor.</source>
          <target state="translated">カーソルは追記にのみ使用されると仮定されているので、カーソルが有効な場合、カーソルは既にbtreeの最後を指しているはずなので、カーソルに変更は加えられません。</target>
        </trans-unit>
        <trans-unit id="28727e9350bc13e9dd557e61676acaf81b800e9f" translate="yes" xml:space="preserve">
          <source>It is assumed that writing a series of sequential blocks of data to a file in order is faster than writing the same blocks in an arbitrary order.</source>
          <target state="translated">ファイルに連続したブロックのデータを順番に書き込むことは、同じブロックを任意の順番で書き込むよりも高速であることが前提となっています。</target>
        </trans-unit>
        <trans-unit id="b7995ee897a4d7d38d5bc734c7b7a1490089b50f" translate="yes" xml:space="preserve">
          <source>It is common for an application to invoke sqlite3_create_function() multiple times for the same SQL function. For example, if an SQL function can take either 2 or 3 arguments, then sqlite3_create_function() would be invoked once for the 2-argument version and a second time for the 3-argument version. The underlying implementation (the callbacks) can be different for both variants.</source>
          <target state="translated">アプリケーションが同じSQL関数に対して複数回sqlite3_create_function()を呼び出すのは一般的です。例えば、SQL関数が2つまたは3つの引数を取ることができる場合、sqlite3_create_function()は2つの引数バージョンでは1回、3つの引数バージョンでは2回目に呼び出されます。基本的な実装(コールバック)は両方のバージョンで異なることがあります。</target>
        </trans-unit>
        <trans-unit id="90995e42fb1f9b39bc19b92ec7c0b1c1c734e41d" translate="yes" xml:space="preserve">
          <source>It is created using a call to sqlite3changegroup_new().</source>
          <target state="translated">sqlite3changegroup_new()の呼び出しを使用して作成されます。</target>
        </trans-unit>
        <trans-unit id="4e7aaf577a2ee286bdd21a85c82980a7edeb975b" translate="yes" xml:space="preserve">
          <source>It is difficult to update individual entries in a ZIP archive. It is especially difficult to update individual entries in a ZIP archive in a way that does not destroy the entire document if the computer loses power and/or crashes in the middle of the update. It is not impossible to do this, but it is sufficiently difficult that nobody actually does it. Instead, whenever the user selects &quot;File/Save&quot;, the entire ZIP archive is rewritten. Hence, &quot;File/Save&quot; takes longer than it ought, especially on older hardware. Newer machines are faster, but it is still bothersome that changing a single character in a 50 megabyte presentation causes one to burn through 50 megabytes of the finite write life on the SSD.</source>
          <target state="translated">ZIP アーカイブ内の個々のエントリを更新することは困難です。特に、更新の途中でコンピュータの電源が落ちたり、クラッシュしたりした場合に、ドキュメント全体を破壊しない方法で、ZIPアーカイブ内の個々のエントリを更新することは困難です。これを行うことは不可能ではありませんが、実際には誰もやっていないほど困難です。その代わり、ユーザが「ファイル/保存」を選択するたびに、ZIP アーカイブ全体が書き換えられます。そのため、特に古いハードウェアでは、&quot;ファイル/保存 &quot;に時間がかかります。新しいマシンはより高速ですが、50メガバイトのプレゼンテーションで一文字を変更すると、SSDの有限の書き込み寿命である50メガバイトを焼き尽くすことになるのは、まだ気になるところです。</target>
        </trans-unit>
        <trans-unit id="5567ffe2a8c6dd00685158eaaf03eb7345f63a44" translate="yes" xml:space="preserve">
          <source>It is illegal for P1 and P3 to be the same register. Sometimes, if P3 is the same register as P2, the implementation is able to avoid a memcpy().</source>
          <target state="translated">P1とP3が同じレジスタであることは違法です。時々、P3がP2と同じレジスタであれば、実装はmemcpy()を避けることができます。</target>
        </trans-unit>
        <trans-unit id="e08adbd91885a13f3de038527a6e47107fedd5af" translate="yes" xml:space="preserve">
          <source>It is important that all connections to the same database file use the same locking protocol. If one application is using POSIX advisory locks and another application is using dot-file locking, then the two applications will not see each other's locks and will not be able to coordinate database access, possibly leading to database corruption.</source>
          <target state="translated">同じデータベースファイルへのすべての接続が同じロックプロトコルを使用することが重要です。あるアプリケーションがPOSIXアドバイザリロックを使用し、別のアプリケーションがドットファイルロックを使用している場合、2つのアプリケーションはお互いのロックを見ることができず、データベースへのアクセスを調整することができず、データベースの破損につながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="8c1111b9c3326c8dd11b23932594b685a7b1d3f7" translate="yes" xml:space="preserve">
          <source>It is important to note that changing versions of SQLite might cause changes in query plans. The same version of SQLite will always pick the same query plan, but if you relink your application to use a different version of SQLite, then query plans might change. In rare cases, an SQLite version change might lead to a performance regression. This is one reason you should consider statically linking your applications against SQLite rather than use a system-wide SQLite shared library which might change without your knowledge or control.</source>
          <target state="translated">SQLite のバージョンを変更すると、クエリプランが変更される可能性があることに注意することが重要です。同じバージョンの SQLite は常に同じクエリプランを選択しますが、異なるバージョンの SQLite を使用するようにアプリケーションを再リンクした場合、クエリプランが変更される可能性があります。まれに、SQLite のバージョンの変更がパフォーマンスの低下につながることがあります。これが、システム全体のSQLite共有ライブラリを使用するよりも、SQLiteに対してアプリケーションを静的にリンクすることを検討すべき理由の一つです。</target>
        </trans-unit>
        <trans-unit id="2fb1bf740043ac6cffabf7ccc0393c49b8d377d2" translate="yes" xml:space="preserve">
          <source>It is important to realize that neither &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; nor &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; do anything that cannot be accomplished using the core routines. In fact, these wrappers are implemented purely in terms of the core routines.</source>
          <target state="translated">&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;も&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;も、コアルーチンを使用して達成できないことは何もしないことを理解することが重要です。実際、これらのラッパーは、コアルーチンの観点から純粋に実装されています。</target>
        </trans-unit>
        <trans-unit id="e6f1d24d369dd36a94bbbfa574744f4d470ce689" translate="yes" xml:space="preserve">
          <source>It is important to store all pages of a sector in the rollback journal in order to prevent database corruption following a power loss while writing the sector. Suppose that pages 1, 2, 3, and 4 are all stored in sector 1 and that page 2 is modified. In order to write the changes to page 2, the underlying hardware must also rewrite the content of pages 1, 3, and 4 since the hardware must write the complete sector. If this write operation is interrupted by a power outage, one or more of the pages 1, 3, or 4 might be left with incorrect data. Hence, to avoid lasting corruption to the database, the original content of all of those pages must be contained in the rollback journal.</source>
          <target state="translated">セクタの書き込み中に停電が発生してデータベースが破損するのを防ぐために、セクタの全ページをロールバックジャーナルに格納することが重要です。ページ 1、2、3、4 がすべてセクタ 1 に格納されており、ページ 2 が変更されているとします。ページ 2 への変更を書き込むためには、ハードウェアが完全なセクタを書き込まなければならないため、基礎となるハードウェアはページ 1、3、および 4 の内容も書き換えなければなりません。この書き込み動作が停電によって中断された場合、ページ1、3、または4のうちの1つまたは複数のページが正しくないデータで残される可能性があります。したがって、データベースへの永続的な破損を避けるために、これらのページのすべての元の内容をロールバックジャーナルに含める必要があります。</target>
        </trans-unit>
        <trans-unit id="128a48935084af31c9e8080ab5a8fbf025139866" translate="yes" xml:space="preserve">
          <source>It is important to understand these two different definitions for &quot;serverless&quot;. When a database claims to be &quot;serverless&quot;, be sure to discern whether they mean &quot;classic serverless&quot; or &quot;neo-serverless&quot;.</source>
          <target state="translated">サーバーレス」の2つの異なる定義を理解することが重要です。データベースが「サーバーレス」であると主張している場合、それが「クラシックサーバーレス」を意味しているのか「ネオサーバーレス」を意味しているのかを見分けるようにしてください。</target>
        </trans-unit>
        <trans-unit id="fa9dd62d3bfcaf75e4033204e51b41d31455c6e9" translate="yes" xml:space="preserve">
          <source>It is important to verify that the gcov test run and the second real test run both give the same output. Any differences in output indicate either the use of undefined or indeterminate behavior in the SQLite code (and hence a bug), or a bug in the compiler. Note that SQLite has, over the previous decade, encountered bugs in each of GCC, Clang, and MSVC. Compiler bugs, while rare, do happen, which is why it is so important to test the code in an as-delivered configuration.</source>
          <target state="translated">gcovテスト実行と2回目の実際のテスト実行の両方で同じ出力が得られることを確認することが重要です。出力に違いがある場合は、SQLite コードに未定義の動作や不確定な動作が使用されている(つまりバグ)か、コンパイラにバグがあることを示しています。SQLite は過去 10 年間で GCC,Clang,MSVC のそれぞれでバグに遭遇してきたことに注意してください。コンパイラのバグは、まれではありますが発生します。</target>
        </trans-unit>
        <trans-unit id="d1cea258b6006ec069fad2e48bb8e0ae1aa954d2" translate="yes" xml:space="preserve">
          <source>It is impossible to test every possible combination of compile-time options for SQLite. But the following set of compile-time options is one configuration that is always fully tested.</source>
          <target state="translated">SQLite のコンパイル時オプションのすべての可能な組み合わせをテストすることは不可能です。しかし、以下のコンパイル時オプションのセットは、常に完全にテストされている設定の一つです。</target>
        </trans-unit>
        <trans-unit id="15edf0a6c6c69dc4fe559f59d8b017e98f300472" translate="yes" xml:space="preserve">
          <source>It is impractical to do crash testing using real power failures, of course, and so crash testing is done in simulation. An alternative &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System&lt;/a&gt; is inserted that allows the test harness to simulate the state of the database file following a crash.</source>
          <target state="translated">もちろん、実際の電源障害を使用してクラッシュテストを行うことは現実的ではないため、クラッシュテストはシミュレーションで行われます。テストハーネスがクラッシュ後のデータベースファイルの状態をシミュレートできるようにする代替の&lt;a href=&quot;c3ref/vfs&quot;&gt;仮想ファイルシステム&lt;/a&gt;が挿入されます。</target>
        </trans-unit>
        <trans-unit id="e1d5ef237a2a6e6403153de4b153927de75448b8" translate="yes" xml:space="preserve">
          <source>It is not an error if the named table does not exist in the database. Nor is it an error if the named table does not have a PRIMARY KEY. However, no changes will be recorded in either of these scenarios.</source>
          <target state="translated">指定されたテーブルがデータベースに存在しない場合はエラーではありません。また、指定されたテーブルが PRIMARY KEY を持っていない場合もエラーではありません。しかし、これらのシナリオのいずれにおいても変更は記録されません。</target>
        </trans-unit>
        <trans-unit id="d49fdf0ef1b4c639114a4ac63de04efc40c67c48" translate="yes" xml:space="preserve">
          <source>It is not an error to create a table that has the same name as an existing &lt;a href=&quot;lang_createtrigger&quot;&gt;trigger&lt;/a&gt;.</source>
          <target state="translated">既存の&lt;a href=&quot;lang_createtrigger&quot;&gt;トリガー&lt;/a&gt;と同じ名前のテーブルを作成してもエラーにはなりません。</target>
        </trans-unit>
        <trans-unit id="8aaf6c77de556f14a491171c58f28d211cfbc9d4" translate="yes" xml:space="preserve">
          <source>It is not commonly useful to evaluate the &lt;em&gt;exact&lt;/em&gt; same SQL statement more than once. More often, one wants to evaluate similar statements. For example, you might want to evaluate an INSERT statement multiple times with different values. Or you might want to evaluate the same query multiple times using a different key in the WHERE clause. To accommodate this, SQLite allows SQL statements to contain &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; which are &quot;bound&quot; to values prior to being evaluated. These values can later be changed and the same &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; can be evaluated a second time using the new values.</source>
          <target state="translated">&lt;em&gt;まったく&lt;/em&gt;同じSQLステートメントを複数回評価することは、一般的には役に立ちません。多くの場合、同様のステートメントを評価する必要があります。たとえば、INSERTステートメントを異なる値で複数回評価したい場合があります。または、WHERE句の異なるキーを使用して、同じクエリを複数回評価することもできます。これに対応するため、SQLiteでは、SQLステートメントに、評価前に値に「バインド」された&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーター&lt;/a&gt;を含めることができます。これらの値は後で変更でき、同じ&lt;a href=&quot;c3ref/stmt&quot;&gt;準備済みステートメント&lt;/a&gt;を新しい値を使用してもう一度評価できます。</target>
        </trans-unit>
        <trans-unit id="8de5c77745aab508a14fca7f3c047cc5a41b83c4" translate="yes" xml:space="preserve">
          <source>It is not impossible to find the descendents of a check-in in Git. It is merely difficult. For example, there is a &lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;stackoverflow page&lt;/a&gt; showing the command sequence for finding the descendents of a check-in in unix:</source>
          <target state="translated">Gitでチェックインの子孫を見つけることは不可能ではありません。ただ難しいだけです。たとえば、Unixでチェックインの子孫を見つけるためのコマンドシーケンスを示す&lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;stackoverflowページ&lt;/a&gt;があります。</target>
        </trans-unit>
        <trans-unit id="968af02ea707c660eea2edbc719717453c1c09b4" translate="yes" xml:space="preserve">
          <source>It is not necessary for every column of an index to appear in a WHERE clause term in order for that index to be used. But there cannot be gaps in the columns of the index that are used. Thus for the example index above, if there is no WHERE clause term that constraints column c, then terms that constrain columns a and b can be used with the index but not terms that constraint columns d through z. Similarly, index columns will not normally be used (for indexing purposes) if they are to the right of a column that is constrained only by inequalities. (See the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; below for the exception.)</source>
          <target state="translated">インデックスを使用するために、インデックスのすべての列がWHERE句の用語に含まれている必要はありません。ただし、使用されるインデックスの列にギャップがあってはなりません。したがって、上記の例のインデックスでは、列cを制約するWHERE句の用語がない場合、列aとbを制約する用語はインデックスで使用できますが、列dからzを制約する用語は使用できません。同様に、インデックス列は、不等式のみによって制約されている列の右側にある場合、通常は（インデックス作成の目的で）使用されません。 （例外については、以下の&lt;a href=&quot;optoverview#skipscan&quot;&gt;スキップスキャン最適化を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="91c4a366eb8b7036569a617f444657bfe2829b75" translate="yes" xml:space="preserve">
          <source>It is not necessary to delete a session object after extracting a changeset or patchset from it. It can be left attached to the database handle and will continue monitoring for changes on the configured tables as before. However, if &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; or &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset()&lt;/a&gt; is called a second time on a session object, the changeset or patchset will contain &lt;em&gt;all&lt;/em&gt; changes that have taken place on the connection since the session was created. In other words, a session object is not reset or zeroed by a call to sqlite3session_changeset() or sqlite3session_patchset().</source>
          <target state="translated">チェンジセットまたはパッチセットをセッションオブジェクトから抽出した後で、セッションオブジェクトを削除する必要はありません。これはデータベースハンドルに接続したままにすることができ、以前と同様に構成されたテーブルの変更を監視し続けます。ただし、&lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）&lt;/a&gt;または&lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset（）&lt;/a&gt;がセッションオブジェクトで2回目に呼び出された場合、変更セットまたはパッチセットには、セッションの作成以降に接続で行われた&lt;em&gt;すべての&lt;/em&gt;変更が含まれます。つまり、sqlite3session_changeset（）またはsqlite3session_patchset（）の呼び出しによってセッションオブジェクトがリセットまたはゼロにされることはありません。</target>
        </trans-unit>
        <trans-unit id="670d42dfe457729d9823abd17b04a227c0f7995a" translate="yes" xml:space="preserve">
          <source>It is not necessary to increment the change counter in the database header for transactions after the first transaction. This will often save a write of page one to both the rollback journal and the main database file.</source>
          <target state="translated">最初のトランザクションの後のトランザクションについては、データベースヘッダの変更カウンタをインクリメントする必要はありません。これにより、ロールバックジャーナルとメインデータベースファイルの両方に1ページ目の書き込みが保存されることが多いです。</target>
        </trans-unit>
        <trans-unit id="2403c6f4220d7ab7621d951d5ca316ce8bb167ec" translate="yes" xml:space="preserve">
          <source>It is not necessary to retrieve data in the format specify by sqlite3_column_type(). If a different format is requested, the data is converted automatically.</source>
          <target state="translated">sqlite3_column_type()で指定した形式でデータを取得する必要はありません。別のフォーマットが要求された場合、データは自動的に変換されます。</target>
        </trans-unit>
        <trans-unit id="900bad887efaa153c1a2b75294545475e3b1d504" translate="yes" xml:space="preserve">
          <source>It is not possible for a single FTS query to return rows with different languageid values. The results of adding WHERE clauses that use other operators (e.g. lid!=5, or lid&amp;lt;=5) are undefined.</source>
          <target state="translated">1つのFTSクエリが異なるlanguageid値を持つ行を返すことはできません。他の演算子を使用するWHERE句（例：lid！= 5、lid &amp;lt;= 5）を追加した結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="0859fe8615c2125c6e219976b0af5affb3b3243b" translate="yes" xml:space="preserve">
          <source>It is not possible to &lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;ALTER TABLE ADD COLUMN&lt;/a&gt; a STORED column. One can add a VIRTUAL column, however.</source>
          <target state="translated">&lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;ALTER TABLE ADD COLUMN&lt;/a&gt; aSTORED列を変更することはできません。ただし、VIRTUAL列を追加することはできます。</target>
        </trans-unit>
        <trans-unit id="7d7041428ac37cb2fe5a20d78347fe7eb6acfbe1" translate="yes" xml:space="preserve">
          <source>It is not possible to UPDATE or DELETE a row stored in a contentless FTS4 table. Attempting to do so is an error.</source>
          <target state="translated">内容のないFTS4テーブルに格納されている行をUPDATEまたはDELETEすることはできません。これを試みるとエラーになります。</target>
        </trans-unit>
        <trans-unit id="9e4665d3e6caf2e43eb0161671eab0b61b62c13a" translate="yes" xml:space="preserve">
          <source>It is not possible to change the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; after entering WAL mode, either on an empty database or by using &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; or by restoring from a backup using the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt;. You must be in a rollback journal mode to change the page size.</source>
          <target state="translated">空のデータベースで、または&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;を使用して、または&lt;a href=&quot;backup&quot;&gt;バックアップAPI&lt;/a&gt;を使用してバックアップから復元することによって、WALモードに入った後で&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt;を変更することはできません。ページサイズを変更するには、ロールバックジャーナルモードになっている必要があります。</target>
        </trans-unit>
        <trans-unit id="deaab8f44371f477a4e7e55d31601e0d0d6a03fb" translate="yes" xml:space="preserve">
          <source>It is not possible to enable or disable foreign key constraints in the middle of a &lt;a href=&quot;lang_transaction&quot;&gt;multi-statement transaction&lt;/a&gt; (when SQLite is not in &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;). Attempting to do so does not return an error; it simply has no effect.</source>
          <target state="translated">&lt;a href=&quot;lang_transaction&quot;&gt;マルチステートメントトランザクションの&lt;/a&gt;途中で外部キー制約を有効または無効にすることはできません（SQLiteが&lt;a href=&quot;c3ref/get_autocommit&quot;&gt;自動コミットモードで&lt;/a&gt;ない場合）。これを実行しようとしてもエラーは返されません。効果はありません。</target>
        </trans-unit>
        <trans-unit id="59d7023d400b2c4a42c25e47c1d1dae5bdb83625" translate="yes" xml:space="preserve">
          <source>It is not possible to use the &quot;ALTER TABLE ... ADD COLUMN&quot; syntax to add a column that includes a REFERENCES clause, unless the default value of the new column is NULL. Attempting to do so returns an error.</source>
          <target state="translated">ALTER TABLE ...新しい列のデフォルト値がNULLでない限り、REFERENCES句を含む列を追加するために &quot;ALTER TABLE ...ADD COLUMN &quot;構文を使用することはできません。これを試みようとするとエラーを返します。</target>
        </trans-unit>
        <trans-unit id="912f58b54e2d4f955145072d5727d208f46d87cf" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">この変数を一度に複数のスレッドで読み取ったり変更したりすることは安全ではありません。&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;が別のスレッドで同時に使用されている場合、この変数を読み取ったり変更したりするのは安全ではありません。この変数は、プロセスの初期化の一部として、SQLiteインターフェースルーチンが呼び出される前に一度設定され、その後もこの変数は変更されないままであることが意図されています。</target>
        </trans-unit>
        <trans-unit id="903cea61d0db784ec27805bae69d5dea09532edb" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">この変数を一度に複数のスレッドで読み取ったり変更したりすることは安全ではありません。&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;が別のスレッドで同時に使用されている場合、この変数を読み取ったり変更したりするのは安全ではありません。この変数は、プロセスの初期化の一部として、SQLiteインターフェースルーチンが呼び出される前に一度設定され、その後もこの変数は変更されないままであることが意図されています。</target>
        </trans-unit>
        <trans-unit id="159cf71be6e4a6830ae2567917f78113abca0955" translate="yes" xml:space="preserve">
          <source>It is ok to make multiple entries for the same word as long as each entry has a different soundslike value. Note that if no soundslike value is specified, the soundslike defaults to the word itself.</source>
          <target state="translated">各エントリが異なるサウンドスライク値を持つ限り、同じ単語に対して複数のエントリを作成しても構いません。サウンドスライク値が指定されていない場合、サウンドスライクのデフォルトは単語そのものであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="42b6da3d325a27b4a54e5028535caa1fb0d83d7a" translate="yes" xml:space="preserve">
          <source>It is particularly important to use an entry point name that is based on the extension filename, rather than the generic &quot;sqlite3_extension_init&quot; entry point name, if you will be statically linking two or more extensions. If you use the generic name, there will be multiple definitions of the same symbol and the link will fail.</source>
          <target state="translated">2つ以上の拡張機能を静的にリンクする場合、一般的な &quot;sqlite3_extension_init &quot;というエントリーポイント名ではなく、拡張機能のファイル名に基づいたエントリーポイント名を使用することが特に重要です。一般名を使用した場合、同じシンボルの定義が複数存在し、リンクは失敗します。</target>
        </trans-unit>
        <trans-unit id="1f5372992ab68655b726354d1de85f6b9510df2c" translate="yes" xml:space="preserve">
          <source>It is permitted to register multiple implementations of the same functions with the same name but with either differing numbers of arguments or differing preferred text encodings. SQLite will use the implementation that most closely matches the way in which the SQL function is used. A function implementation with a non-negative nArg parameter is a better match than a function implementation with a negative nArg. A function where the preferred text encoding matches the database encoding is a better match than a function where the encoding is different. A function where the encoding difference is between UTF16le and UTF16be is a closer match than a function where the encoding difference is between UTF8 and UTF16.</source>
          <target state="translated">同じ関数の複数の実装を同じ名前で登録することができますが、引数の数や優先するテキストエンコーディングが異なる場合もあります。SQLite は、その SQL 関数の使用方法に最も近い実装を使用します。負ではない nArg パラメータを持つ関数の実装は、負の nArg パラメータを持つ関数の実装よりもマッチします。優先されるテキストエンコーディングがデータベースのエンコーディングと一致する関数は、エンコーディングが異なる関数よりも一致します。エンコーディングの違いがUTF16leとUTF16beの間にある関数は、エンコーディングの違いがUTF8とUTF16の間にある関数よりも近い一致となります。</target>
        </trans-unit>
        <trans-unit id="d335c80330cdb9262d358bd293d73594c1829762" translate="yes" xml:space="preserve">
          <source>It is possible for the library compile-time C preprocessor symbol &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; to override this pragma setting. The following table summarizes the interaction of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; preprocessor macro and the temp_store pragma:</source>
          <target state="translated">ライブラリコンパイル時のCプリプロセッサシンボル&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;がこのプラグマ設定を上書きする可能性があります。次の表は、&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;プリプロセッサマクロとtemp_storeプラグマの相互作用をまとめたものです。</target>
        </trans-unit>
        <trans-unit id="882d45108ae3506a475e868a2ed67d0f5c2e5629" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. But not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="translated">証明者の将来の拡張により、特定の組み込み関数へのNULL入力が常にNULL回答になることを証明者が認識できるようになる可能性があります。ただし、すべての組み込み関数にそのプロパティがあるわけではありません（たとえば、&lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce（）&lt;/a&gt;）。もちろん、証明者は&lt;a href=&quot;appfunc&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;について推論することはできません。</target>
        </trans-unit>
        <trans-unit id="105eb1a524704db6ebed7c523dd9971899853505" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. But not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="translated">証明者に対する将来の拡張により、特定の組み込み関数へのNULL入力が常にNULL回答になることを認識できるようになる可能性があります。しかし、すべての組み込み関数がそのプロパティを持っているわけではありません（たとえば、&lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce（）&lt;/a&gt;）。もちろん、証明者が&lt;a href=&quot;c3ref/create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;について推論することはできません。</target>
        </trans-unit>
        <trans-unit id="2be5eee10a74ce784db26ece955361d8533b48cb" translate="yes" xml:space="preserve">
          <source>It is possible to build a special &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; that will work with a predetermined set of SQLITE_OMIT_... options. Instructions for doing so can be found with the &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_... documentation&lt;/a&gt;.</source>
          <target state="translated">事前に定義されたSQLITE_OMIT _...オプションのセットで機能する特別な&lt;a href=&quot;amalgamation&quot;&gt;融合&lt;/a&gt;を構築することが可能です。これを行うための手順は、&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _...のドキュメントに記載&lt;/a&gt;されています。</target>
        </trans-unit>
        <trans-unit id="321373a36254200d34f2e6be79e9dd835a4c4ba3" translate="yes" xml:space="preserve">
          <source>It is possible to create multiple session objects attached to a single database handle.</source>
          <target state="translated">1つのデータベースハンドルに接続された複数のセッションオブジェクトを作成することができます。</target>
        </trans-unit>
        <trans-unit id="bed5d040f0bed9644c8d2600cb5ecf6e91531170" translate="yes" xml:space="preserve">
          <source>It is possible to extend custom or pile-of-files formats too, of course, but doing is often much harder. If indices are added, then all application code that changes the corresponding tables must be located and modified to keep those indices up-to-date. If columns are added, then all application code that accesses the corresponding table must be located and modified to take into account the new columns.</source>
          <target state="translated">もちろん、カスタムフォーマットや pile-of-files フォーマットを拡張することも可能ですが、それを行うのははるかに難しいことが多いです。インデックスが追加された場合、対応するテーブルを変更するすべてのアプリケーションコードは、それらのインデックスを最新の状態に保つように配置され、修正されなければなりません。カラムが追加された場合は、対応するテーブルにアクセスするすべてのアプリケーションコードを配置し、新しいカラムを考慮に入れるように修正しなければなりません。</target>
        </trans-unit>
        <trans-unit id="e6a04c27b0773734dfa33829ac44458f0f513a43" translate="yes" xml:space="preserve">
          <source>It is possible to have an aggregate function with the same name as a simple function, as long as the number of arguments for the two forms of the function are different. For example, the &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max()&lt;/a&gt; function with a single argument is an aggregate and the &lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max()&lt;/a&gt; function with two or more arguments is a simple function. Aggregate functions can usually also be used as window functions.</source>
          <target state="translated">関数の2つの形式の引数の数が異なる限り、単純な関数と同じ名前の集約関数を持つことができます。たとえば、単一の引数を持つ&lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max（）&lt;/a&gt;関数は集約であり、2つ以上の引数を持つ&lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max（）&lt;/a&gt;関数は単純な関数です。通常、集計関数はウィンドウ関数としても使用できます。</target>
        </trans-unit>
        <trans-unit id="79fc85e42448050747bff9c78bdebc62767b73c0" translate="yes" xml:space="preserve">
          <source>It is possible to make SQLite treat NULLs as distinct for the purposes of the SELECT DISTINCT and UNION. To do so, one should change the value of the NULL_ALWAYS_DISTINCT #define in the &lt;code&gt;sqliteInt.h&lt;/code&gt; source file and recompile.</source>
          <target state="translated">SQLiteがSELECT DISTINCTとUNIONの目的のためにNULLを別個のものとして扱うようにすることが可能です。これを行うには、 &lt;code&gt;sqliteInt.h&lt;/code&gt; ソースファイルのNULL_ALWAYS_DISTINCT #defineの値を変更して再コンパイルする必要があります。</target>
        </trans-unit>
        <trans-unit id="ef8babc1f36de58a996ade599caa2a6556653b1a" translate="yes" xml:space="preserve">
          <source>It is possible to tell whether or not the 'merge' command found any b-trees to merge together by checking the value returned by the &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; API before and after the command is executed. If the difference between the two values is 2 or greater, then work was performed. If the difference is less than 2, then the 'merge' command was a no-op. In this case there is no reason to execute the same 'merge' command again, at least until after the FTS table is next updated.</source>
          <target state="translated">コマンドの実行前後に&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt; APIから返された値を確認することで、 'merge'コマンドがマージするbツリーを見つけたかどうかを判断できます。2つの値の差が2以上の場合、作業は実行されています。差が2未満の場合、 'merge'コマンドは何もしませんでした。この場合、少なくともFTSテーブルが次に更新されるまでは、同じ「マージ」コマンドを再度実行する必要はありません。</target>
        </trans-unit>
        <trans-unit id="e63e80c9bba9974f9e6774ae97788b65cf7107ad" translate="yes" xml:space="preserve">
          <source>It is possible to write into the &quot;t2&quot; table, thus changing the content of the index. But doing so will get the &quot;t1bc&quot; index out of synchronization with its parent table &quot;t1&quot;. An out-of-sync index can result in incorrect query results.</source>
          <target state="translated">t2 &quot;テーブルに書き込むことが可能で、インデックスの内容を変更することができます。しかし、そうすると、&quot;t1bc &quot;インデックスは親テーブル &quot;t1 &quot;と同期しなくなってしまいます。同期が取れていないインデックスは、正しくないクエリ結果をもたらす可能性がある。</target>
        </trans-unit>
        <trans-unit id="0822da1b538a191177f07ef1dc3b36f0cff1be87" translate="yes" xml:space="preserve">
          <source>It is recommended that applications respond to the errors listed above by explicitly issuing a ROLLBACK command. If the transaction has already been rolled back automatically by the error response, then the ROLLBACK command will fail with an error, but no harm is caused by this.</source>
          <target state="translated">アプリケーションは、明示的にROLLBACKコマンドを発行することによって、上記のエラーに応答することが推奨される。エラー応答によってトランザクションが既に自動的にロールバックされている場合、ROLLBACKコマンドはエラーで失敗しますが、これによって害はありません。</target>
        </trans-unit>
        <trans-unit id="7b7eb3618faa363b4bb6cb76587e213a07280f4c" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">現在データベース操作を実行しているスレッドとは別のスレッドからこのルーチンを呼び出しても安全です。しかし、sqlite3_interrupt（）が戻る前に閉じられているか、閉じられる可能性のある&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;でこのルーチンを呼び出すのは安全ではありません。</target>
        </trans-unit>
        <trans-unit id="0d70d917087b8b111a765ae7a55cfbd2640b316e" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">現在データベース操作を実行しているスレッドとは別のスレッドからこのルーチンを呼び出しても安全です。しかし、sqlite3_interrupt（）が戻る前に閉じられているか、閉じられる可能性のある&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;でこのルーチンを呼び出すのは安全ではありません。</target>
        </trans-unit>
        <trans-unit id="d9e98c95444e8fd3d643f309806f8f5b2d312406" translate="yes" xml:space="preserve">
          <source>It is safe to execute SQL statements, including those that write to the table that the callback related to, from within the xConflict callback. This can be used to further customize the application's conflict resolution strategy.</source>
          <target state="translated">xConflict コールバック内から、コールバックが関連するテーブルへの書き込みを含む SQL 文を実行しても安全です。これを使用して、アプリケーションの競合解決戦略をさらにカスタマイズすることができます。</target>
        </trans-unit>
        <trans-unit id="7155cc55f906067b466a3957abc2b2fa5ca703ab" translate="yes" xml:space="preserve">
          <source>It is safe to execute SQL statements, including those that write to the table that the callback related to, from within the xConflict callback. This can be used to further customize the applications conflict resolution strategy.</source>
          <target state="translated">コールバックが関連するテーブルへの書き込みを含む SQL 文を xConflict コールバック内から実行しても安全です。これを使用して、アプリケーションの競合解決戦略をさらにカスタマイズすることができます。</target>
        </trans-unit>
        <trans-unit id="33153f14bd397b5e62d91fe18b2589aae1781966" translate="yes" xml:space="preserve">
          <source>It is sometimes convenient for SQLite extensions to communicate non-SQL values between subcomponents or between the extension and the application. Some examples:</source>
          <target state="translated">SQLite の拡張機能では、サブコンポーネント間や拡張機能とアプリケーション間で非 SQL 値を通信するのが便利な場合があります。いくつかの例があります。</target>
        </trans-unit>
        <trans-unit id="4e37312abd7d96cc7759f842b46f93a1a662f8a0" translate="yes" xml:space="preserve">
          <source>It is still the responsibility of the user to ensure that the contents of an external content FTS5 table are kept up to date with the content table. One way to do this is with triggers. For example:</source>
          <target state="translated">外部コンテンツFTS5テーブルのコンテンツがコンテンツテーブルと最新の状態に保たれていることを確認することは、依然としてユーザーの責任である。これを行う1つの方法は、トリガーを使用することです。例えば、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="9c7272134156136dee6648bc42ced66fabf0b75c" translate="yes" xml:space="preserve">
          <source>It is the nature of the Guttman R-Tree algorithm that any write might radically restructure the tree, and in the process change the scan order of the nodes. For this reason, it is not generally possible to modify the R-Tree in the middle of a query of the R-Tree. Attempts to do so will fail with a &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; &quot;database table is locked&quot; error.</source>
          <target state="translated">書き込みによってツリーが根本的に再構築され、その過程でノードのスキャン順序が変更されるのは、GuttmanR-Treeアルゴリズムの性質です。このため、通常、Rツリーのクエリの途中でRツリーを変更することはできません。そうしようとすると、&lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;「データベーステーブルがロックされています」エラーで失敗します。</target>
        </trans-unit>
        <trans-unit id="5653d5d90f75b604cccae96a448a1866fdfa38fe" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually call sqlite3_free() on the *ppOut pointer to free the buffer allocation following a successful call to this function.</source>
          <target state="translated">この関数の呼び出しに成功した後、バッファアロケーションを解放するために、最終的に*ppOutポインタでsqlite3_free()を呼び出すのは呼び出し元の責任です。</target>
        </trans-unit>
        <trans-unit id="ea70438336584a95d4e17716f1df0d6b713aeb3b" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize（）に&lt;/a&gt;渡してイテレータを最終的に破棄するのは、呼び出し元の責任です。変更セット（pChangeset）を含むバッファは、イテレータが破棄されるまで有効のままである必要があります。</target>
        </trans-unit>
        <trans-unit id="f0493c91af19ce8153b8e56f3f8a534dd5019c91" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">&lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize（）に&lt;/a&gt;渡してイテレータを最終的に破棄するのは、呼び出し元の責任です。変更セット（pChangeset）を含むバッファは、イテレータが破棄されるまで有効のままである必要があります。</target>
        </trans-unit>
        <trans-unit id="6d23d845a723659b2b2994a8ad4c9862067cda40" translate="yes" xml:space="preserve">
          <source>It is true that applications sometimes import complete binary SQLite database files from untrusted sources, and such imports could present a possible attack vector. However, those code paths in SQLite are limited and are extremely well tested. And pre-validation routines are available to applications that want to read untrusted databases that can help detect possible attacks prior to use.</source>
          <target state="translated">確かに、アプリケーションが信頼できないソースから完全なバイナリSQLiteデータベースファイルをインポートすることがあり、そのようなインポートが攻撃のベクトルとなる可能性があります。しかし、SQLite のコードパスは限られており、非常によくテストされています。また、信頼されていないデータベースを読みたいアプリケーションには、使用前に攻撃の可能性を検出するための事前検証ルーチンが用意されています。</target>
        </trans-unit>
        <trans-unit id="c6122ba39afe0e09e2d2af761ca27152501399d2" translate="yes" xml:space="preserve">
          <source>It is usually an error to attempt to create a new table in a database that already contains a table, index or view of the same name. However, if the &quot;IF NOT EXISTS&quot; clause is specified as part of the CREATE TABLE statement and a table or view of the same name already exists, the CREATE TABLE command simply has no effect (and no error message is returned). An error is still returned if the table cannot be created because of an existing index, even if the &quot;IF NOT EXISTS&quot; clause is specified.</source>
          <target state="translated">通常、同じ名前のテーブル、インデックス、ビューが既に存在するデータベースに新しいテーブルを作成しようとするとエラーになります。しかし、&quot;IF NOT EXISTS &quot;句がCREATE TABLE文の一部として指定され、同名のテーブルやビューが既に存在する場合、CREATE TABLEコマンドは何の効果もありません(エラーメッセージも返されません)。IF NOT EXISTS &quot;句が指定されていても、既存のインデックスのためにテーブルを作成できない場合、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="6955fa966a557f5231f3a39e108f89afbdbb1b83" translate="yes" xml:space="preserve">
          <source>It may not be used on a database that contains &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expridx&quot;&gt;式のインデックス&lt;/a&gt;を含むデータベースでは使用できません。</target>
        </trans-unit>
        <trans-unit id="16a2200cb76f9664274f3ef9da8045211e14cc43" translate="yes" xml:space="preserve">
          <source>It might be that there are conflicts in the merge. Conflicts occur when the same line of code was changed in different ways between circles (1) and (4) versus circles (2) and (3). The merge command will announce any conflicts and will include both versions of the conflicting lines in the output. You will need to bring up the files that contain conflicts and manually resolve the conflicts.</source>
          <target state="translated">マージにコンフリクトが発生している可能性があります。コンフリクトは、同じ行のコードが丸(1)と(4)と丸(2)と(3)の間で異なる方法で変更された場合に発生します。merge コマンドは、競合があった場合にその旨を通知し、競合している行の両方のバージョンを出力に含めます。競合を含むファイルを表示し、手動で競合を解決する必要があります。</target>
        </trans-unit>
        <trans-unit id="129a00b2ad750693913d2844d8acb7e806afdd09" translate="yes" xml:space="preserve">
          <source>It must not be possible to make the LIKE or GLOB operator true by having a numeric value (instead of a string or blob) on the left-hand side. This means that either:</source>
          <target state="translated">左側に(文字列やブロブではなく)数値を持つことで、LIKEやGLOB演算子を真にすることはできないはずです。つまり、どちらかが</target>
        </trans-unit>
        <trans-unit id="48d86628c63409da486bd0d69fb891667a6d8475" translate="yes" xml:space="preserve">
          <source>It never hurts to run the VACUUM, even if you don't need it. If the database is in WAL mode, you should shutdown and reopen all database connections before continuing.</source>
          <target state="translated">VACUUMを実行することは、たとえ必要がなくても決して痛手ではありません。データベースがWALモードになっている場合は、続行する前にシャットダウンして、すべてのデータベース接続を再開する必要があります。</target>
        </trans-unit>
        <trans-unit id="e56780a95b18eed6f05e0be25053224b3c52ac99" translate="yes" xml:space="preserve">
          <source>It was necessary to move to version 3.0 to implement these features because each requires incompatible changes to the database file format. Other incompatible changes, such as a cleanup of the API, were introduced at the same time under the theory that it is best to get your incompatible changes out of the way all at once.</source>
          <target state="translated">これらの機能を実装するためには、それぞれがデータベースファイル形式に互換性のない変更を必要とするため、バージョン3.0に移行する必要がありました。APIのクリーンアップのような他の互換性のない変更は、互換性のない変更を一度に済ませるのが最善であるという理論のもとに、同時に導入されました。</target>
        </trans-unit>
        <trans-unit id="8d41777ca525f229dab6b56dd5c34598aff8efa5" translate="yes" xml:space="preserve">
          <source>It works with unicode (UTF8) text.</source>
          <target state="translated">unicode (UTF8)テキストで動作します。</target>
        </trans-unit>
        <trans-unit id="829d920a492c6126eef1531c8e8c0e1ab7033bd1" translate="yes" xml:space="preserve">
          <source>Its master journal exists or the master journal name is an empty string, and</source>
          <target state="translated">そのマスター・ジャーナルが存在するか、マスター・ジャーナル名が空文字列であり</target>
        </trans-unit>
        <trans-unit id="a9d92a1b4a228c7e648d8125ef5d3c71b3cd4ff7" translate="yes" xml:space="preserve">
          <source>Its size is greater than 512 bytes, and</source>
          <target state="translated">そのサイズは512バイトよりも大きく</target>
        </trans-unit>
        <trans-unit id="0239a4728421bae8f8eeba1f3844a6c5e5e3d81b" translate="yes" xml:space="preserve">
          <source>Its super-journal exists or the super-journal name is an empty string, and</source>
          <target state="translated">そのスーパージャーナルが存在するか、スーパージャーナル名が空文字列であり</target>
        </trans-unit>
        <trans-unit id="73bd910d330560ea1012376a486871434fb0c82d" translate="yes" xml:space="preserve">
          <source>J. M. Robson. &quot;Bounds for Some Functions Concerning Dynamic Storage Allocation&quot;.</source>
          <target state="translated">J.J.M.ロブソン &quot;動的ストレージ割り当てに関するいくつかの関数の境界&quot;</target>
        </trans-unit>
        <trans-unit id="9a3f6528f2606d1ed81f1e9f85b624a26b98cbbe" translate="yes" xml:space="preserve">
          <source>JOIN</source>
          <target state="translated">JOIN</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="935b885e280c10afb46d2bf45f85bbea09bc94ce" translate="yes" xml:space="preserve">
          <source>JSON support</source>
          <target state="translated">JSON サポート</target>
        </trans-unit>
        <trans-unit id="69a65023a22e8f6d2ee1c6c6ee36c64ccb6d5c6d" translate="yes" xml:space="preserve">
          <source>Join order</source>
          <target state="translated">順番に参加する</target>
        </trans-unit>
        <trans-unit id="63acacbd536ebc7829ae48a83492249201168016" translate="yes" xml:space="preserve">
          <source>Join reordering is automatic and usually works well enough that programmers do not have to think about it, especially if &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been used to gather statistics about the available indices. But occasionally some hints from the programmer are needed. Consider, for example, the following schema:</source>
          <target state="translated">結合の並べ替えは自動的に行われ、通常は十分に機能します。特に、利用可能なインデックスに関する統計を収集するために&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;が使用されている場合は、プログラマが考える必要はありません。ただし、プログラマーからのヒントが必要になる場合があります。たとえば、次のスキーマについて考えてみます。</target>
        </trans-unit>
        <trans-unit id="36cb6826dbbbacc9f0915d9e44ccb82925b04c72" translate="yes" xml:space="preserve">
          <source>Joins</source>
          <target state="translated">Joins</target>
        </trans-unit>
        <trans-unit id="742ad08bca9c2e1be08d58aae42e6201c809dcf9" translate="yes" xml:space="preserve">
          <source>Journal File Format</source>
          <target state="translated">ジャーナルファイル形式</target>
        </trans-unit>
        <trans-unit id="debc03f25ef5600d2ed4edf18b01b3412bb71c87" translate="yes" xml:space="preserve">
          <source>Journal Header Format</source>
          <target state="translated">ジャーナルヘッダー形式</target>
        </trans-unit>
        <trans-unit id="ccdedfc7a4a23f259c6823eed7a5e93d7a6e430f" translate="yes" xml:space="preserve">
          <source>Journal Record Format</source>
          <target state="translated">ジャーナルレコード形式</target>
        </trans-unit>
        <trans-unit id="683ff0cc3706704c295b1d1835a7e2e4c3a2a6b7" translate="yes" xml:space="preserve">
          <source>Journal of the Association for Computing Machinery</source>
          <target state="translated">計算機学会誌</target>
        </trans-unit>
        <trans-unit id="769726f4101068333430cd9eee0a56b7dfd75235" translate="yes" xml:space="preserve">
          <source>JournalMode</source>
          <target state="translated">JournalMode</target>
        </trans-unit>
        <trans-unit id="c0e70f1bd285ac28ec38cf9261dd9cf6df3840dd" translate="yes" xml:space="preserve">
          <source>Journalling a Database Page</source>
          <target state="translated">データベースのページを追記する</target>
        </trans-unit>
        <trans-unit id="b576bd921c8bd5cb6e5720fc3c6797d3e02e8d08" translate="yes" xml:space="preserve">
          <source>Journalling a page</source>
          <target state="translated">ページを追悼する</target>
        </trans-unit>
        <trans-unit id="84e304128c1076094ba7ee02aeb09745e71eaf53" translate="yes" xml:space="preserve">
          <source>Julian day number</source>
          <target state="translated">ユリウスの日番号</target>
        </trans-unit>
        <trans-unit id="1eba140fdd9c6860a1730c408e3064aa417ca2a3" translate="yes" xml:space="preserve">
          <source>Jump</source>
          <target state="translated">Jump</target>
        </trans-unit>
        <trans-unit id="5d84018241481efa31572e7a64ddf20102d5a735" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is False. The value is considered false if it has a numeric value of zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">レジスタP1の値がFalseの場合はP2にジャンプします。値が0の数値の場合はFalseとみなされます。P1の値がNULLの場合は、P3が0でない場合にのみジャンプします。</target>
        </trans-unit>
        <trans-unit id="c02affea77793c1c3281caf3fff7c025052fcd28" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is NULL.</source>
          <target state="translated">レジスタP1の値がNULLの場合はP2にジャンプします。</target>
        </trans-unit>
        <trans-unit id="9d04284895be3aad627f0d99db148ecf0772d61d" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is not NULL.</source>
          <target state="translated">レジスタP1の値がNULLでなければP2にジャンプします。</target>
        </trans-unit>
        <trans-unit id="38d677f93cf11ed33026afa36fe1f252297e13d5" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is true. The value is considered true if it is numeric and non-zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">レジスタP1の値が真であればP2にジャンプします。数値で0以外の値であれば真とみなされます。P1の値がNULLの場合は、P3が0でない場合にのみジャンプします。</target>
        </trans-unit>
        <trans-unit id="04a8d1cd1316034cf886277bf2c8dd963c76b71c" translate="yes" xml:space="preserve">
          <source>Jump to the instruction at address P1, P2, or P3 depending on whether in the most recent &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; instruction the P1 vector was less than equal to, or greater than the P2 vector, respectively.</source>
          <target state="translated">最新の&lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt;命令で、P1ベクトルがP2ベクトルと同じかそれよりも小さいかによって、アドレスP1、P2、またはP3にある命令にジャンプします。</target>
        </trans-unit>
        <trans-unit id="029dc808e2fcf8db0d9a3400f04a64bf760921ba" translate="yes" xml:space="preserve">
          <source>Jump to the next instruction after the address in register P1. After the jump, register P1 becomes undefined.</source>
          <target state="translated">レジスタP1のアドレスの次の命令にジャンプします。ジャンプ後、レジスタP1は未定義となります。</target>
        </trans-unit>
        <trans-unit id="be91c2cd21e07ee8ceb31ed436dfe5c08c9a83b6" translate="yes" xml:space="preserve">
          <source>Just as there is the &quot;zip&quot; program to manage ZIP Archives, and the &quot;tar&quot; program to manage Tarballs, the &lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;&quot;sqlar&quot; program&lt;/a&gt; exists to manage SQL Archives. The &quot;sqlar&quot; program is able to create a new SQLite Archive, list the content of an existing archive, add or remove files from the archive, and/or extract files from the archive. A separate &quot;sqlarfs&quot; program is able to mount the SQLite Archive as a &lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;Fuse Filesystem&lt;/a&gt;.</source>
          <target state="translated">ZIPアーカイブを管理するための「zip」プログラムと、Tarballを管理するための&lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;「tar」プログラム&lt;/a&gt;があるように、SQLアーカイブを管理するための「sqlar」プログラムが存在します。「sqlar」プログラムは、新しいSQLiteアーカイブの作成、既存のアーカイブの内容の一覧表示、アーカイブからのファイルの追加または削除、および/またはアーカイブからのファイルの抽出を行うことができます。別の「sqlarfs」プログラムは、SQLiteアーカイブを&lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;Fuseファイルシステム&lt;/a&gt;としてマウントできます。</target>
        </trans-unit>
        <trans-unit id="dd65c1b4b3e66e765523873bd29cf5d6d6838189" translate="yes" xml:space="preserve">
          <source>KEY</source>
          <target state="translated">KEY</target>
        </trans-unit>
        <trans-unit id="d27c8f02c4abf5f11c1eced4acd8b35520a9fe80" translate="yes" xml:space="preserve">
          <source>Keep constant guard over the actions of your life.</source>
          <target state="translated">あなたの人生の行動を常に見守ってください。</target>
        </trans-unit>
        <trans-unit id="194e669a908d39900cf589c5a981d721d7c9618b" translate="yes" xml:space="preserve">
          <source>Keep death daily before your eyes.</source>
          <target state="translated">目の前の死を毎日維持してください。</target>
        </trans-unit>
        <trans-unit id="c25db8dd7484e7f7bee803cd3895b18495da35bc" translate="yes" xml:space="preserve">
          <source>Keep the full precision of integers (if possible) when casting to NUMERIC. Ticket #2364</source>
          <target state="translated">NUMERICにキャストする際には、整数の完全な精度を保つようにしてください(可能であれば)。チケット #2364</target>
        </trans-unit>
        <trans-unit id="4989895ac52269498fe4414b7697f7a4c22ad5aa" translate="yes" xml:space="preserve">
          <source>Key points:</source>
          <target state="translated">キーポイント。</target>
        </trans-unit>
        <trans-unit id="08fa4eb3aedd30338134d345421fea84986b3d4a" translate="yes" xml:space="preserve">
          <source>Key take-aways from this essay:</source>
          <target state="translated">このエッセイからの主なポイント。</target>
        </trans-unit>
        <trans-unit id="8b3a8bbf2ec2d401e862eec6bf418d40320b88cb" translate="yes" xml:space="preserve">
          <source>Key/value store for the raw database file content. The key is the page number and the value is binary page content.</source>
          <target state="translated">生のデータベースファイルの内容を格納するキー/値のストア。キーはページ番号、値はバイナリページの内容です。</target>
        </trans-unit>
        <trans-unit id="7b687d48e96f480574af88076704d469738ac8fd" translate="yes" xml:space="preserve">
          <source>Keyword arguments can optionally appear in quotes. (Example: &lt;code&gt;'yes' [FALSE]&lt;/code&gt;.) Some pragmas takes a string literal as their argument. When pragma takes a keyword argument, it will usually also take a numeric equivalent as well. For example, &quot;0&quot; and &quot;no&quot; mean the same thing, as does &quot;1&quot; and &quot;yes&quot;. When querying the value of a setting, many pragmas return the number rather than the keyword.</source>
          <target state="translated">キーワード引数は、オプションで引用符で囲むことができます。（例： &lt;code&gt;'yes' [FALSE]&lt;/code&gt; 。）一部のプラグマは、引数として文字列リテラルを取ります。プラグマがキーワード引数を取る場合、通常は同等の数値も受け取ります。たとえば、「0」と「いいえ」は「1」と「はい」と同じ意味です。設定の値を照会すると、多くのプラグマはキーワードではなく数値を返します。</target>
        </trans-unit>
        <trans-unit id="71d7d3fe2fa70220d2397ae5ef29dbf8ffba7a8b" translate="yes" xml:space="preserve">
          <source>Know for certain that God sees you everywhere.</source>
          <target state="translated">神はどこでもあなたを見ていると確信しています。</target>
        </trans-unit>
        <trans-unit id="7e70d2e585c390da7abcf2a3249245e0e36e0092" translate="yes" xml:space="preserve">
          <source>LAST</source>
          <target state="translated">LAST</target>
        </trans-unit>
        <trans-unit id="969e2cc476ff76be41815b17d8fb9c685f97e243" translate="yes" xml:space="preserve">
          <source>LEFT</source>
          <target state="translated">LEFT</target>
        </trans-unit>
        <trans-unit id="fa443d7d6200af63823dccc305e61eed839b45c2" translate="yes" xml:space="preserve">
          <source>LEFT JOIN</source>
          <target state="translated">左結合</target>
        </trans-unit>
        <trans-unit id="06214bf7efebdbadf0fc2e8285b451472a810158" translate="yes" xml:space="preserve">
          <source>LEFT JOIN elimination often comes up when LEFT JOINs are used inside of views, and then the view is used in such as way that none of the columns of the right-hand table of the LEFT JOIN are referenced.</source>
          <target state="translated">LEFT JOINの排除は、LEFT JOINがビューの内部で使用され、LEFT JOINの右側のテーブルの列がどれも参照されないような方法でビューが使用されている場合によく発生します。</target>
        </trans-unit>
        <trans-unit id="228baedd626cec5fb29f832c085ce530c565f626" translate="yes" xml:space="preserve">
          <source>LEFT JOIN strength reduction optimization</source>
          <target state="translated">LEFT JOIN強度低下最適化</target>
        </trans-unit>
        <trans-unit id="e43376033cc5d4106eb2e868e3b049e3915b255f" translate="yes" xml:space="preserve">
          <source>LEFT OUTER JOIN is implemented, but not RIGHT OUTER JOIN or FULL OUTER JOIN.</source>
          <target state="translated">LEFT OUTER JOINは実装されていますが、RIGHT OUTER JOINやFULL OUTER JOINは実装されていません。</target>
        </trans-unit>
        <trans-unit id="5ddf6f04739d8bc3a11b487863b27a7bcaa6fc24" translate="yes" xml:space="preserve">
          <source>LIKE</source>
          <target state="translated">LIKE</target>
        </trans-unit>
        <trans-unit id="92323e665381f4f6e8310e0e8d0ab85b11facf9e" translate="yes" xml:space="preserve">
          <source>LIKE optimization</source>
          <target state="translated">LIKE最適化</target>
        </trans-unit>
        <trans-unit id="c385d79f275c108bd6a32af099948cfc74a92c05" translate="yes" xml:space="preserve">
          <source>LIKE optimization now works for columns with COLLATE NOCASE</source>
          <target state="translated">COLLATE NOCASE を持つカラムで LIKE 最適化が動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="9c590af5665cfc2916823206547377e482547e1d" translate="yes" xml:space="preserve">
          <source>LIMIT</source>
          <target state="translated">LIMIT</target>
        </trans-unit>
        <trans-unit id="40c4547fe7d52f08474372a32d5cd65ef3e61db8" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now shows no rows. Use LIMIT -1 to see all rows.</source>
          <target state="translated">LIMIT 0では行が表示されません。すべての行を表示するにはLIMIT -1を使用してください。</target>
        </trans-unit>
        <trans-unit id="e120f1515582fd60e3aa87caeded6a95706ff6a5" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now works on subqueries</source>
          <target state="translated">LIMIT 0がサブクエリで動作するようになりました</target>
        </trans-unit>
        <trans-unit id="2726a4b3c5be6bc17db3c5aa67da0f6e30ea159f" translate="yes" xml:space="preserve">
          <source>LIMIT_ATTACH</source>
          <target state="translated">LIMIT_ATTACH</target>
        </trans-unit>
        <trans-unit id="e8bf21b0d0f3b850c955bb94b5141253b1ae7e2a" translate="yes" xml:space="preserve">
          <source>LIMIT_COLUMN</source>
          <target state="translated">LIMIT_COLUMN</target>
        </trans-unit>
        <trans-unit id="7b09e7eae5f068cca9e40a4e561d97d66518a255" translate="yes" xml:space="preserve">
          <source>LIMIT_COMPOUND_SELECT</source>
          <target state="translated">LIMIT_COMPOUND_SELECT</target>
        </trans-unit>
        <trans-unit id="b1c8f4255d541a1d18f761d25857086f40b1bf20" translate="yes" xml:space="preserve">
          <source>LIMIT_EXPR_DEPTH</source>
          <target state="translated">LIMIT_EXPR_DEPTH</target>
        </trans-unit>
        <trans-unit id="2a0de541f4fa62311ff3575519dfacbb5ae6b11e" translate="yes" xml:space="preserve">
          <source>LIMIT_FUNCTION_ARG</source>
          <target state="translated">LIMIT_FUNCTION_ARG</target>
        </trans-unit>
        <trans-unit id="1a3a784fe44fc702cae042a37cb3ba3e0f6fa7ac" translate="yes" xml:space="preserve">
          <source>LIMIT_LENGTH</source>
          <target state="translated">LIMIT_LENGTH</target>
        </trans-unit>
        <trans-unit id="72fc2492f41deaa54c2dac4538490fafaa14d0d6" translate="yes" xml:space="preserve">
          <source>LIMIT_LIKE_PATTERN_LENGTH</source>
          <target state="translated">LIMIT_LIKE_PATTERN_LENGTH</target>
        </trans-unit>
        <trans-unit id="5e8999dc05d8b9aa066f6d09239a0ae740e36f64" translate="yes" xml:space="preserve">
          <source>LIMIT_SQL_LENGTH</source>
          <target state="translated">LIMIT_SQL_LENGTH</target>
        </trans-unit>
        <trans-unit id="db5d695bfcc2c3ebffa6c7ffcd096c20b8eed97c" translate="yes" xml:space="preserve">
          <source>LIMIT_TRIGGER_DEPTH</source>
          <target state="translated">LIMIT_TRIGGER_DEPTH</target>
        </trans-unit>
        <trans-unit id="16d75adbe3aa654b347523eb12544c39563f5b43" translate="yes" xml:space="preserve">
          <source>LIMIT_VARIABLE_NUMBER</source>
          <target state="translated">LIMIT_VARIABLE_NUMBER</target>
        </trans-unit>
        <trans-unit id="a604921b15950316535a24537e634352270c370e" translate="yes" xml:space="preserve">
          <source>LIMIT_VDBE_OP</source>
          <target state="translated">LIMIT_VDBE_OP</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="7428d00a0b1c6a4c3041c21ce5ceb9dbaa4b015a" translate="yes" xml:space="preserve">
          <source>Large WAL files</source>
          <target state="translated">大容量のWALファイル</target>
        </trans-unit>
        <trans-unit id="d1c69a859a9638b242f2dabf8acf1c0b1450ce6b" translate="yes" xml:space="preserve">
          <source>Last</source>
          <target state="translated">Last</target>
        </trans-unit>
        <trans-unit id="07235ffa8a70d2e51e9570c942d05e5b5851a313" translate="yes" xml:space="preserve">
          <source>Last Insert Rowid</source>
          <target state="translated">最終インサート ロイド</target>
        </trans-unit>
        <trans-unit id="7f81d5c9ec25b5fa1a2640b99a8421ac6c71b017" translate="yes" xml:space="preserve">
          <source>Later, SQLite version 3.6.16 is released, as shown by circle (4) in the diagram. At the point, the private branch maintainer does a merge which takes all of the changes going from (1) to (4) and applies those changes to (3). The result is version (5), which is SQLite 3.6.16 plus edits.</source>
          <target state="translated">その後、図中の丸(4)で示すように、SQLite バージョン 3.6.16 がリリースされます。この時点で、プライベートブランチのメンテナは、(1)から(4)への変更をすべてマージし、それらの変更を(3)に適用します。その結果、バージョン(5)はSQLite 3.6.16に編集を加えたものになります。</target>
        </trans-unit>
        <trans-unit id="e07edacb2555a09c495279c3384f36a675435d8d" translate="yes" xml:space="preserve">
          <source>Le</source>
          <target state="translated">Le</target>
        </trans-unit>
        <trans-unit id="fa3757f35a67a972328ec50d59fdef6fec4d197a" translate="yes" xml:space="preserve">
          <source>Leading spaces are removed.</source>
          <target state="translated">リーディングスペースは削除されています。</target>
        </trans-unit>
        <trans-unit id="e52b8a48a53a875ca174a915ae5c47d6e94c2665" translate="yes" xml:space="preserve">
          <source>Leading zeros are handled properly, in the sense that they do not mess of the maginitude comparison of embedded strings of digits. &quot;x00123y&quot; is equal to &quot;x123y&quot;.</source>
          <target state="translated">先頭のゼロは、埋め込まれた数字の文字列のマジニチュード比較を混乱させないという意味で、適切に処理されます。&quot;x00123y &quot;は &quot;x123y &quot;と同じです。</target>
        </trans-unit>
        <trans-unit id="1dae495d04abf17bb3895a89b30ae8efcca9f3f1" translate="yes" xml:space="preserve">
          <source>Leaf payload fraction. Must be 32.</source>
          <target state="translated">リーフペイロード分数。32である必要があります。</target>
        </trans-unit>
        <trans-unit id="e2626d2b1592bacc07397cf31582efd1c5b2420a" translate="yes" xml:space="preserve">
          <source>Left operand</source>
          <target state="translated">左オペランド</target>
        </trans-unit>
        <trans-unit id="203223a5600f328f50c6338dfe2e4c11e8803475" translate="yes" xml:space="preserve">
          <source>Left operand found</source>
          <target state="translated">左のオペランドが見つかりました。</target>
        </trans-unit>
        <trans-unit id="865d1c5dcc029d18d1621430419ee2f04f5f424f" translate="yes" xml:space="preserve">
          <source>Left-justify the value in the output. The default is to right-justify. If the width is zero or is otherwise less than the length of the value being substituted, then there is no padding and the &quot;-&quot; flag is a no-op.</source>
          <target state="translated">出力の値を左寄せにします。デフォルトは右寄せである。幅が0であるか、置換される値の長さよりも小さい場合は、パディングはなく、&quot;-&quot;フラグは無効です。</target>
        </trans-unit>
        <trans-unit id="1877e2f919fe86f5371e6a3e7d9d6b6080bf4d57" translate="yes" xml:space="preserve">
          <source>Legacy (older than 3.22.0) versions of the sessions module cannot capture changes made to the sqlite_stat1 table. Legacy versions of the sqlite3changeset_apply() function silently ignore any modifications to the sqlite_stat1 table that are part of a changeset or patchset.</source>
          <target state="translated">レガシーバージョン(3.22.0より古い)のセッションモジュールでは、sqlite_stat1テーブルに加えられた変更を捕捉できません。sqlite3changeset_apply()関数のレガシーバージョンは、チェンジセットやパッチセットの一部であるsqlite_stat1テーブルへの変更を黙って無視します。</target>
        </trans-unit>
        <trans-unit id="48078fcdb6dc318fa741d70a2ecdb6ae1437e609" translate="yes" xml:space="preserve">
          <source>Lemon does not have its own source repository. Rather, Lemon consists of a few files in the SQLite source tree:</source>
          <target state="translated">Lemonは独自のソースリポジトリを持っていません。むしろ、Lemon は SQLite ソースツリーの中のいくつかのファイルから構成されています。</target>
        </trans-unit>
        <trans-unit id="bf0578b2a25d2e804bfd4deee5634450a8293393" translate="yes" xml:space="preserve">
          <source>Lemon generates an LALR(1) parser. It's operation is similar to the more familiar tools &lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt;, but Lemon adds important improvements, including:</source>
          <target state="translated">レモンはLALR（1）パーサーを生成します。その操作は、より身近なツールである&lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt;や&lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt;に似ていますが、Lemonには次のような重要な改善が加えられています。</target>
        </trans-unit>
        <trans-unit id="ae32ad1b62e795e4b0f91393920f4a7aff7c555a" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a &quot;fallback&quot; tokens. The SQL language contains a large number of keywords and these keywords have the potential to collide with identifier names. Lemon has the ability to designate some keywords has being able to &quot;fallback&quot; to an identifier. If the keyword appears in the input token stream in a context that would otherwise be a syntax error, the token is automatically transformed into its fallback before the syntax error is raised. This feature allows the parser to be very forgiving of reserved words used as identifiers, which is a problem that comes up frequently in the SQL language.</source>
          <target state="translated">レモンには「フォールバック」トークンという概念があります。SQL言語には多数のキーワードが含まれており、これらのキーワードは識別子名と衝突する可能性があります。Lemonは、いくつかのキーワードを識別子に &quot;フォールバック &quot;することができるように指定する機能を持っています。キーワードが構文エラーとなるコンテキストで入力トークンストリームに現れた場合、構文エラーが発生する前に、トークンは自動的にそのフォールバックに変換されます。この機能により、パーサは識別子として使用される予約語に対して非常に寛容になることができます。</target>
        </trans-unit>
        <trans-unit id="2f9dc02cb8bf5b03f6591dbb44f0a7a4b90f82f4" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a non-terminal destructor that can be used to reclaim memory or other resources following a syntax error or other aborted parse.</source>
          <target state="translated">レモンは、構文エラーや他のアボートされたパースに続くメモリや他のリソースを取り戻すために使用できる非終端デストラクタの概念を持っています。</target>
        </trans-unit>
        <trans-unit id="cee927c3e2d6e42d43d5738f627f3200d5121eac" translate="yes" xml:space="preserve">
          <source>Lemon is also used to generate parse for the query pattern expressions in the &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; extension. In this case, the input grammar file is &lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt;.</source>
          <target state="translated">レモンは、&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;拡張機能でクエリパターン式の解析を生成するためにも使用されます。この場合、入力文法ファイルは&lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="611d0deb28e86cca8303457d918752428288861c" translate="yes" xml:space="preserve">
          <source>Lemon is used in two places in SQLite.</source>
          <target state="translated">レモンはSQLiteでは2箇所で使われています。</target>
        </trans-unit>
        <trans-unit id="0045a01f71c39a54c68dbc362b5b7275372032f5" translate="yes" xml:space="preserve">
          <source>Lemon supports conditional compilation of grammar file rules, so that a different parser can be generated depending on compile-time options.</source>
          <target state="translated">Lemonは文法ファイルルールの条件付きコンパイルをサポートしているので、コンパイル時のオプションに応じて異なるパーサーを生成することができます。</target>
        </trans-unit>
        <trans-unit id="c5c89f378ce33982d309c573eb1ff14dd3f01e8a" translate="yes" xml:space="preserve">
          <source>Lemon was original written by D. Richard Hipp (also the creator of SQLite) while he was in graduate school at Duke University between 1987 and 1992. The original creation date of Lemon has been lost, but was probably sometime around 1990. Lemon generates an LALR(1) parser. There was companion LL(1) parser generator tool named &quot;Lime&quot;, but the source code for Lime has been lost.</source>
          <target state="translated">Lemonは、D.Richard Hipp(SQLiteの生みの親でもある)が1987年から1992年の間にデューク大学の大学院に在籍していた時に書いたものです。Lemonのオリジナルの作成日は失われていますが、おそらく1990年頃のことでしょう。LemonはLALR(1)パーサを生成します。Limeという名前のLL(1)パーサ生成ツールがありましたが、Limeのソースコードは失われています。</target>
        </trans-unit>
        <trans-unit id="aa1fa89453ad95c8f115feb4d323d1e9b329630d" translate="yes" xml:space="preserve">
          <source>Length Specifier</source>
          <target state="translated">長さ指定</target>
        </trans-unit>
        <trans-unit id="c999fb0a278ca9591b2cd0c03ceaa3328da57984" translate="yes" xml:space="preserve">
          <source>Less administration means that programmers spend more time working on the software (SQLite in this case) and less time fussing with the version control system.</source>
          <target state="translated">管理が少ないということは、プログラマーがソフトウェア(この場合はSQLite)の作業に時間を割いて、バージョン管理システムと格闘する時間が少ないということです。</target>
        </trans-unit>
        <trans-unit id="cbcb5b1fa488787750d49ab79f8ec375ce5124b9" translate="yes" xml:space="preserve">
          <source>Less memory used</source>
          <target state="translated">使用メモリの削減</target>
        </trans-unit>
        <trans-unit id="bc720094b72d521a9bad35bfe37f02c776160039" translate="yes" xml:space="preserve">
          <source>Let K be M+((P-M)%(U-4)).</source>
          <target state="translated">KをM+((P-M)%(U-4)とする。)</target>
        </trans-unit>
        <trans-unit id="ec5fd8c108643b71cf1bdd72351ff3e987fc1a5d" translate="yes" xml:space="preserve">
          <source>Let X be ((U-12)*64/255)-23. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the index b-tree page is K if K is less than or equal to X or M otherwise. The number of bytes stored on the index page is never less than M.</source>
          <target state="translated">X を ((U-12)*64/255)-23 とする。ペイロードサイズPがX以下の場合、ペイロード全体がb-treeページに格納されます。M を ((U-12)*32/255)-23 とし、K を M+((P-M)%(U-4))とします。PがXより大きい場合、インデックスのb-treeページに格納されているバイト数は、KがX以下であればKであり、そうでなければMである。インデックスページに格納されているバイト数は、M以下になることはありません。</target>
        </trans-unit>
        <trans-unit id="3814595cf4d53307c33619bbcfd8505bff49fec5" translate="yes" xml:space="preserve">
          <source>Let X be U-35. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree leaf page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the table b-tree leaf page is K if K is less or equal to X or M otherwise. The number of bytes stored on the leaf page is never less than M.</source>
          <target state="translated">X を U-35 とする。ペイロードサイズPがX以下の場合、ペイロード全体がb-treeリーフページに格納されます。M を ((U-12)*32/255)-23 とし、K を M+((P-M)%(U-4))とする。PがXより大きい場合、テーブルのb-treeリーフページに格納されているバイト数は、KがX以下であればKであり、そうでなければMである。リーフページに格納されているバイト数はMより決して小さくない。</target>
        </trans-unit>
        <trans-unit id="04ab6da7aca9e95067f1ce62f19a937e96ff6418" translate="yes" xml:space="preserve">
          <source>Let X be the expression in the WHERE clause of a partial index, and let W be the WHERE clause of a query that uses the table that is indexed. Then, the query is permitted to use the partial index if W&amp;rArr;X, where the &amp;rArr; operator (usually pronounced &quot;implies&quot;) is the logic operator equivalent to &quot;X or not W&quot;. Hence, determining whether or not a partial index is usable in a particular query reduces to proving a theorem in first-order logic.</source>
          <target state="translated">Xを部分インデックスのWHERE句の式とし、Wをインデックス付きのテーブルを使用するクエリのWHERE句とします。次に、クエリはW&amp;rArr;Xの場合、部分インデックスの使用を許可されます。ここで、&amp;rArr;演算子（通常は「暗黙的」と発音）は、「XまたはWではない」と同等の論理演算子です。したがって、特定のクエリで部分インデックスが使用可能かどうかを判断すると、1次論理で定理が証明されます。</target>
        </trans-unit>
        <trans-unit id="8e79f3f73bca370e5a0d09f6e67e4908583572b1" translate="yes" xml:space="preserve">
          <source>Let X be the largest set of consecutive integers {h, h+1, h+2, ..., h+N} such that for every j in X, aPgno[j%8192]!=0. The X set will be empty if aPgno[h%8192]==0. The X set is easily computed by starting with the value h%8192, and adding h%8192 to X and incrementing h until encountering the first aPgno[h%8192] entry that is zero.</source>
          <target state="translated">Xを連続した整数{h,h+1,h+2,...,h+N}の最大の集合とします.Xの各jに対して,aPgno[j%8192]!=0となるような連続した整数{h,h+1,h+2,...,h+N}の集合は,aPgno[h%8192]==0の場合は空になります.Xの集合は,値h%8192から始まり,Xにh%8192を加え,最初のaPgno[h%8192]が0になるまでhを増加させることで簡単に計算できます.</target>
        </trans-unit>
        <trans-unit id="37bafb8ebd6ac523c9fab977240fbaca2d2a4205" translate="yes" xml:space="preserve">
          <source>Let the database page size (the value of the integer at offset 24 in the journal header) be N. Then the format of a page record is as follows:</source>
          <target state="translated">データベースのページサイズ(ジャーナルヘッダのオフセット24の整数値)をNとすると、ページレコードの形式は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="5da01c6ea976760415bf0eb965f5e685ea3c15ec" translate="yes" xml:space="preserve">
          <source>Let the datatypes &quot;u8&quot;, &quot;u16&quot;, and &quot;u32&quot; mean unsigned integers of length 8, 16, and 32 bits, respectively. Then, the first 32768-byte unit of the shm file is organized as follows:</source>
          <target state="translated">データ型 &quot;u8&quot;,&quot;u16&quot;,&quot;u32 &quot;はそれぞれ長さ8,16,32ビットの符号なし整数を意味する。すると、shmファイルの最初の32768バイト単位は以下のように構成される。</target>
        </trans-unit>
        <trans-unit id="bd114f90a251306f5f9680610cc3593a57d82e5b" translate="yes" xml:space="preserve">
          <source>Let the number of alice nodes be M and the number of bob nodes be N. Consider two scenarios. In the first scenario, M and N are both 2 but there are thousands of edges on each node. In this case, option 1 is preferred. With option 1, the inner loop checks for the existence of an edge between a pair of nodes and outputs the result if found. But because there are only 2 alice and bob nodes each, the inner loop only has to run 4 times and the query is very quick. Option 2 would take much longer here. The outer loop of option 2 only executes twice, but because there are a large number of edges leaving each alice node, the middle loop has to iterate many thousands of times. It will be much slower. So in the first scenario, we prefer to use option 1.</source>
          <target state="translated">アライスノードの数をM、ボブノードの数をNとすると、2つのシナリオが考えられる。最初のシナリオでは、MとNは両方とも2であるが、各ノードには数千のエッジがある。この場合,オプション1が好ましい.オプション1では,内部ループはノードのペア間にエッジが存在するかどうかをチェックし,見つかった場合にはその結果を出力します.しかし、aliceとbobのノードはそれぞれ2つしかないので、内部ループは4回しか実行されず、クエリは非常に速くなります。オプション2は、ここではもっと時間がかかります。オプション2の外側のループは2回しか実行されませんが、各aliceノードから出るエッジの数が多いので、真ん中のループは何千回も繰り返し実行しなければなりません。これはもっと遅くなります。そこで、最初のシナリオでは、オプション1を使用することを好みます。</target>
        </trans-unit>
        <trans-unit id="74b220b56c9d6c3f209f91061a8b3234a645c429" translate="yes" xml:space="preserve">
          <source>Let the page count value at offset 8 in the journal header be M. If M is greater than zero then after M page records the journal file may be zero padded out to the next multiple of the sector size and another journal header may be inserted. All journal headers within the same journal must contain the same database page size and sector size.</source>
          <target state="translated">Mがゼロよりも大きい場合、Mページレコードの後、ジャーナルファイルはセクタサイズの次の倍数までゼロパディングされ、別のジャーナルヘッダーが挿入されます。同じジャーナル内のすべてのジャーナルヘッダは、同じデータベースのページサイズとセクタサイズを含まなければなりません。</target>
        </trans-unit>
        <trans-unit id="f44e417ae6158672e12bddd6f44e6cd28bdb55bb" translate="yes" xml:space="preserve">
          <source>Let us assume that you are using the amalgamation source code. Add the baseline to your project as follows:</source>
          <target state="translated">アマルガムのソースコードを使用していると仮定してみましょう。以下のようにプロジェクトにベースラインを追加します。</target>
        </trans-unit>
        <trans-unit id="ae7bd817eacac0a262f119102109a97036180841" translate="yes" xml:space="preserve">
          <source>Let us suppose that instead of using a ZIP archive to store its files, OpenDocument used a very simple SQLite database with the following single-table schema:</source>
          <target state="translated">ファイルを保存するために ZIP アーカイブを使用する代わりに、OpenDocument が以下のような単一テーブルスキーマを持つ非常にシンプルな SQLite データベースを使用していたとします。</target>
        </trans-unit>
        <trans-unit id="ecc5e1e5e0ad7c0dd2b547a397bdb11d90ca6d36" translate="yes" xml:space="preserve">
          <source>Let us use the following notation (similar but not identical to Robson's notation):</source>
          <target state="translated">以下のような表記法(ロブソンの表記法と似ていますが、同じではありません)を使ってみましょう。</target>
        </trans-unit>
        <trans-unit id="2d2261f9e0cbec9edf95c4d47c5f5eb0cbcca2f7" translate="yes" xml:space="preserve">
          <source>Let's be real. Few people seriously dispute that Git provides a suboptimal user experience. A lot of the underlying implementation shows through into the user interface. The interface is so bad that there is even a parody site that generates &lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;fake git man pages&lt;/a&gt;.</source>
          <target state="translated">現実になりましょう。Gitが次善のユーザーエクスペリエンスを提供することに真剣に異議を唱える人はほとんどいません。基礎となる実装の多くは、ユーザーインターフェイスに表示されます。インターフェースが非常に悪いので、&lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;偽のgit manページ&lt;/a&gt;を生成するパロディサイトさえあります。</target>
        </trans-unit>
        <trans-unit id="0f0987eb98b35f60885158c865b4e995d0d04bc9" translate="yes" xml:space="preserve">
          <source>Let's look more closely at what is happening here. The first SELECT is implemented by the loop at instructions 5 through 10. Instruction 5 initializes the loop by rewinding its cursor. Instruction 6 extracts the value of the &quot;two&quot; column from &quot;examp&quot; and instruction 7 converts this into a row. Instruction 8 pushes an empty string onto the stack. Finally, instruction 9 writes the row into the temporary table. But remember, the PutStrKey opcode uses the top of the stack as the record data and the next on stack as the key. For an INSERT statement, the row generated by the MakeRecord opcode is the record data and the record key is an integer created by the NewRecno opcode. But here the roles are reversed and the row created by MakeRecord is the record key and the record data is just an empty string.</source>
          <target state="translated">ここで何が起こっているのか、もう少し詳しく見てみましょう。最初のSELECTは、命令5から10までのループによって実装されています。命令5はカーソルを巻き戻すことでループを初期化します。命令6は「examp」から「2」列の値を抽出し、命令7はこれを行に変換します。命令8は空の文字列をスタックに押し込む。最後に、命令9はその行を一時テーブルに書き込みます。しかし、PutStrKeyオペコードは、スタックの先頭をレコードデータとして使用し、スタックの次の行をキーとして使用することを覚えておいてください。INSERT文では、MakeRecordオペコードによって生成された行がレコード・データであり、レコード・キーはNewRecnoオペコードによって生成された整数です。しかし、ここでは役割が逆になっており、MakeRecordによって生成された行がレコードキーで、レコードデータは単なる空の文字列です。</target>
        </trans-unit>
        <trans-unit id="8ce47b13d09374c0748516f88f9567e0ba880c6e" translate="yes" xml:space="preserve">
          <source>Libraries written in C do not have a huge run-time dependency. In its minimum configuration, SQLite requires only the following routines from the standard C library:</source>
          <target state="translated">C で書かれたライブラリは、ランタイムに大きな依存性を持ちません。最小限の設定では、SQLite が必要とするのは標準 C ライブラリの以下のルーチンだけです。</target>
        </trans-unit>
        <trans-unit id="16b9101f24846717dcb86cc74d99a08aad5ead61" translate="yes" xml:space="preserve">
          <source>Libraries written in C++ or Java can generally only be used by applications written in the same language. It is difficult to get an application written in Haskell or Java to invoke a library written in C++. On the other hand, libraries written in C are callable from any programming language.</source>
          <target state="translated">C++やJavaで書かれたライブラリは、一般的に同じ言語で書かれたアプリケーションでしか使用できません。HaskellやJavaで書かれたアプリケーションからC++で書かれたライブラリを呼び出すことは困難です。一方、Cで書かれたライブラリは、どのプログラミング言語からでも呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="8f218c8346bfddbca30ecf6b104e83b9f15b5e98" translate="yes" xml:space="preserve">
          <source>Library size optimizations.</source>
          <target state="translated">ライブラリサイズの最適化。</target>
        </trans-unit>
        <trans-unit id="3769a60d2f565f40c7f7836558211471f7d8a029" translate="yes" xml:space="preserve">
          <source>Like --file, use file FILE as the archive, but open the file using the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS&lt;/a&gt; so that the archive will be appended to the end of FILE if FILE already exists.</source>
          <target state="translated">--fileと同様に、ファイルFILEをアーカイブとして使用しますが、&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS&lt;/a&gt;を使用してファイルを開き、FILEがすでに存在する場合にアーカイブがFILEの最後に追加されるようにします。</target>
        </trans-unit>
        <trans-unit id="0b095c3da7d05183eec1d9c68eafa22989981539" translate="yes" xml:space="preserve">
          <source>Like contentless tables, external content tables do not support REPLACE conflict handling. Any operations that specify REPLACE conflict handling are handled using ABORT.</source>
          <target state="translated">コンテンツレステーブルと同様に、外部コンテンツテーブルは REPLACE 競合処理をサポートしていません。REPLACE 競合処理を指定した操作は、ABORT を使用して処理されます。</target>
        </trans-unit>
        <trans-unit id="231d089dd7b27b9cd1c3006b16a6dc21b83bfb7e" translate="yes" xml:space="preserve">
          <source>Like other virtual table types, new FTS tables are created using a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. The module name, which follows the USING keyword, is either &quot;fts3&quot; or &quot;fts4&quot;. The virtual table module arguments may be left empty, in which case an FTS table with a single user-defined column named &quot;content&quot; is created. Alternatively, the module arguments may be passed a list of comma separated column names.</source>
          <target state="translated">他の仮想テーブルタイプと同様に、新しいFTSテーブルは&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;ステートメントを使用して作成されます。USINGキーワードに続くモジュール名は、「fts3」または「fts4」のいずれかです。仮想テーブルモジュールの引数は空のままにできます。その場合、「content」という名前の単一のユーザー定義列を持つFTSテーブルが作成されます。または、モジュール引数にカンマ区切りの列名のリストを渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="fd7d7c85c83f29484f2e117602dc4bec07bd365d" translate="yes" xml:space="preserve">
          <source>Like sqlite3rbu_step(), if the vacuum operation has finished, sqlite3rbu_close() returns SQLITE_DONE. If the vacuum has not finished but no error has occurred, SQLITE_OK is returned. Or, if an error has occurred, an SQLite error code is returned. If an error occurred as part of a prior call to sqlite3rbu_step(), sqlite3rbu_close() returns the same error code.</source>
          <target state="translated">sqlite3rbu_step()と同様に、バキューム操作が終了した場合、sqlite3rbu_close()はSQLITE_DONEを返します。バキュームが終了していないがエラーが発生していない場合は、SQLITE_OKが返されます。または、エラーが発生した場合は、SQLiteエラーコードが返されます。sqlite3rbu_step()の前の呼び出しの一部としてエラーが発生した場合、sqlite3rbu_close()は同じエラーコードを返します。</target>
        </trans-unit>
        <trans-unit id="7e8a69dbe9cf8dfea5767671aa0118b3491fc369" translate="yes" xml:space="preserve">
          <source>Like the &quot;.dump&quot; command, &quot;.recover&quot; attempts to convert the entire contents of a database file to text. The difference is that instead of reading data using the normal SQL database interface, &quot;.recover&quot; attempts to reassemble the database based on data extracted directly from as many database pages as possible. If the database is corrupt, &quot;.recover&quot; is usually able to recover data from all uncorrupted parts of the database, whereas &quot;.dump&quot; stops when the first sign of corruption is encountered.</source>
          <target state="translated">dump」コマンドと同様に、「.recover」は、データベースファイルの内容全体をテキストに変換しようとする。違いは、通常のSQLデータベースインターフェイスを使用してデータを読み込むのではなく、&quot;.recover &quot;は可能な限り多くのデータベースページから直接抽出されたデータに基づいてデータベースを再構築しようとする点である。データベースが破損している場合、&quot;.recover &quot;は通常、データベースの破損していないすべての部分からデータを復元することができますが、&quot;.dump &quot;は破損の最初の兆候に遭遇したときに停止します。</target>
        </trans-unit>
        <trans-unit id="86f2b5c75e6099a6cf032f5fc9564b20f9285845" translate="yes" xml:space="preserve">
          <source>Limit Setting</source>
          <target state="translated">リミット設定</target>
        </trans-unit>
        <trans-unit id="dc00d8255b192a092dc29a4b67bc17a891ccaa1d" translate="yes" xml:space="preserve">
          <source>Limit the amount of output that &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; generates.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integer_checkが&lt;/a&gt;生成する出力の量を制限します。</target>
        </trans-unit>
        <trans-unit id="3bc4a74f4bc8f6fbe5d7600c2ffc0ce32f2df522" translate="yes" xml:space="preserve">
          <source>Limit the depth of recursion for JSON objects and arrays in order to avoid excess stack usage in the recursive descent parser. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052&lt;/a&gt;.</source>
          <target state="translated">再帰降下パーサーでスタックが過剰に使用されないように、JSONオブジェクトと配列の再帰の深さを制限します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052の&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="5c73db06777439f7e7a4e0b4ef090767959f015d" translate="yes" xml:space="preserve">
          <source>Limit the maximum amount of memory that SQLite will allocate using the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64()&lt;/a&gt; interface. This helps prevent denial-of-service attacks. To find out how much heap space an application actually needs, run the it against typical inputs and then measure the maximum instantaneous memory usage with the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interface. Set the hard heap limit to the maximum observed instantaneous memory usage plus some margin.</source>
          <target state="translated">&lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64（）&lt;/a&gt;インターフェイスを使用してSQLiteが割り当てるメモリの最大量を制限します。これは、サービス拒否攻撃を防ぐのに役立ちます。アプリケーションが実際に必要とするヒープスペースの量を確認するには、一般的な入力に対してアプリケーションを実行してから、&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;インターフェイスを使用して瞬間的な最大メモリ使用量を測定します。ハードヒープ制限を、観測された最大瞬間メモリ使用量にマージンを加えたものに設定します。</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="cd047048aa9c975f33600c7ec5b79b0145824c1c" translate="yes" xml:space="preserve">
          <source>Limitations And Caveats</source>
          <target state="translated">制限と警告</target>
        </trans-unit>
        <trans-unit id="140fa43a5b0009e4451c320039ee7a35af9ef59d" translate="yes" xml:space="preserve">
          <source>Limitations Of The OpenDocument Presentation Format</source>
          <target state="translated">OpenDocument プレゼンテーションフォーマットの限界</target>
        </trans-unit>
        <trans-unit id="61a0ae3b849d95fb8185df69b96d0ec676fb0688" translate="yes" xml:space="preserve">
          <source>Limits</source>
          <target state="translated">Limits</target>
        </trans-unit>
        <trans-unit id="da74bbdf0c5ba1732a1bcf36654960401f556496" translate="yes" xml:space="preserve">
          <source>Limits In SQLite</source>
          <target state="translated">SQLite での制限</target>
        </trans-unit>
        <trans-unit id="2b535e43758af2a0faba7d7491e8ccc0937261f7" translate="yes" xml:space="preserve">
          <source>Lines that begin with &quot;#&quot; and that are not in the middle of an SQL statement are interpreted as comments.</source>
          <target state="translated">で始まり、SQL文の途中ではない行はコメントとして解釈されます。</target>
        </trans-unit>
        <trans-unit id="56c40b8da457fccee36d2dd25cabffcd286e7be5" translate="yes" xml:space="preserve">
          <source>Link SQLite against a test program that runs approximately 30,000 SQL statements representing a typical workload.</source>
          <target state="translated">典型的なワークロードを代表する約30,000のSQL文を実行するテストプログラムに対してSQLiteをリンクします。</target>
        </trans-unit>
        <trans-unit id="aa106ea45c187562ead66ff45b2537ad9d39d113" translate="yes" xml:space="preserve">
          <source>Linus Torvalds used different words to say much the same thing on the Git mailing list on 2006-06-27:</source>
          <target state="translated">Linus Torvalds さんが 2006-06-27 の Git メーリングリストで違う言葉を使って同じことを言っていました。</target>
        </trans-unit>
        <trans-unit id="518aa8e09ec633a2ee7ca4061837886754889a59" translate="yes" xml:space="preserve">
          <source>List Of Constants:</source>
          <target state="translated">定数のリスト。</target>
        </trans-unit>
        <trans-unit id="c88854d7fb661e5a305fcbc6e6989b1500fbf8a5" translate="yes" xml:space="preserve">
          <source>List Of Functions:</source>
          <target state="translated">機能のリスト。</target>
        </trans-unit>
        <trans-unit id="02564776632cdeb522e81ac2cc1d466134257360" translate="yes" xml:space="preserve">
          <source>List Of Objects:</source>
          <target state="translated">オブジェクトのリスト。</target>
        </trans-unit>
        <trans-unit id="5976b759c2bbe27a2c436cf0d06c399c38f9db0a" translate="yes" xml:space="preserve">
          <source>List Of PRAGMAs</source>
          <target state="translated">PRAGMA一覧</target>
        </trans-unit>
        <trans-unit id="198f4f9677551df3e26744118c9e2c5bcd812876" translate="yes" xml:space="preserve">
          <source>List Of SQLite Constants</source>
          <target state="translated">SQLite 定数のリスト</target>
        </trans-unit>
        <trans-unit id="b6b508ee374f53a81be169f4d47397a7a1f331e0" translate="yes" xml:space="preserve">
          <source>List Of SQLite Functions</source>
          <target state="translated">SQLite 関数のリスト</target>
        </trans-unit>
        <trans-unit id="52d4b531b52e9862c4189d27482ae4e958f97760" translate="yes" xml:space="preserve">
          <source>List Of SQLite Objects</source>
          <target state="translated">SQLite オブジェクトのリスト</target>
        </trans-unit>
        <trans-unit id="68749615daec6b7db7287fc101bfd1803474c677" translate="yes" xml:space="preserve">
          <source>List Of Virtual Tables</source>
          <target state="translated">仮想テーブルの一覧</target>
        </trans-unit>
        <trans-unit id="9d1c029d1a64007ca37f5bf394575d02eef0574f" translate="yes" xml:space="preserve">
          <source>List each file as it is processed.</source>
          <target state="translated">処理中の各ファイルを一覧表示します。</target>
        </trans-unit>
        <trans-unit id="a5d1705cc809076e6266257a5ff3fa27b21bc1d4" translate="yes" xml:space="preserve">
          <source>List the contents of the archive. If no arguments are specified, then all files are listed. Otherwise, only those specified as arguments are. Currently, the --verbose option does not change the behaviour of this command. That may change in the future.</source>
          <target state="translated">アーカイブの内容をリストアップします。引数が指定されていない場合は、すべてのファイルをリストアップします。それ以外の場合は、引数として指定されたファイルのみがリストアップされます。現在のところ、--verbose オプションはこのコマンドの動作を変更しません。将来的には変更されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="27424535e9c380832791dbc03c67071412b07455" translate="yes" xml:space="preserve">
          <source>List the files in the archive.</source>
          <target state="translated">アーカイブ内のファイルを一覧表示します。</target>
        </trans-unit>
        <trans-unit id="615e9625e4457bad91a4957735c233d58d384ed8" translate="yes" xml:space="preserve">
          <source>List values on the right-hand side of IN are treated as a subquery that must be materialized. In other words, the previous statement acts as if it were:</source>
          <target state="translated">INの右辺のリスト値は、マテリアライズされなければならない副問い合わせとして扱われます。つまり、前の文があたかもそうであるかのように振る舞います。</target>
        </trans-unit>
        <trans-unit id="f653dec85c31b3ff9b77fe72b2384cf749288d85" translate="yes" xml:space="preserve">
          <source>Listed below are some cases where it might make sense to add additional soundslike entries. The specific entries will depend on the application and the target language.</source>
          <target state="translated">以下にリストアップされているのは、サウンドライクなエントリを追加することが意味を持つかもしれないいくつかのケースです。具体的なエントリはアプリケーションとターゲット言語に依存します。</target>
        </trans-unit>
        <trans-unit id="9a2828a10d993798b426c35ab47fdbeb8b46927a" translate="yes" xml:space="preserve">
          <source>Listen willingly to holy reading.</source>
          <target state="translated">進んで聖なる朗読に耳を傾ける。</target>
        </trans-unit>
        <trans-unit id="3805c697baba47d8b6fac8ff193aac1d5aae53c5" translate="yes" xml:space="preserve">
          <source>Literal Values (Constants)</source>
          <target state="translated">リテラル値(定数</target>
        </trans-unit>
        <trans-unit id="3c11cc0f06e28252855afe306ffae2efa4d23a55" translate="yes" xml:space="preserve">
          <source>Literal strings contain no byte-order-marks.</source>
          <target state="translated">リテラル文字列にはバイトオーダマークは含まれていません。</target>
        </trans-unit>
        <trans-unit id="a95fd3f55e521532b15bff8dba2b3aa3f6401a1a" translate="yes" xml:space="preserve">
          <source>Literal value</source>
          <target state="translated">リテラル値</target>
        </trans-unit>
        <trans-unit id="402377f4fa54f586c7bcf70486179fb514f52098" translate="yes" xml:space="preserve">
          <source>Literal values: numeric or string constants.</source>
          <target state="translated">リテラル値:数値または文字列定数。</target>
        </trans-unit>
        <trans-unit id="fc57b0cbf2f7891171194ad1bf1b86f68a201597" translate="yes" xml:space="preserve">
          <source>LoC Recommended Storage Format</source>
          <target state="translated">LoC推奨ストレージフォーマット</target>
        </trans-unit>
        <trans-unit id="c1fd24450afa2a8ca3ccb54f712f70e15f33b7ed" translate="yes" xml:space="preserve">
          <source>Load An Extension</source>
          <target state="translated">拡張機能をロードする</target>
        </trans-unit>
        <trans-unit id="f9c032c8f6af23d9ff803554a14cbcd6e3037cb8" translate="yes" xml:space="preserve">
          <source>Load The Difference Between Tables Into A Session</source>
          <target state="translated">テーブル間の違いをセッションに読み込む</target>
        </trans-unit>
        <trans-unit id="9c794e6d2b53e1c944bf6d4f24a6f0f6be485378" translate="yes" xml:space="preserve">
          <source>Load the shared library or DLL file LIBRARY into SQLite prior to computing the differences. This can be used to add application-defined &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt; that are required by the schema.</source>
          <target state="translated">違いを計算する前に、共有ライブラリまたはDLLファイルLIBRARYをSQLiteにロードします。これは、スキーマで必要とされるアプリケーション定義の&lt;a href=&quot;datatype3#collation&quot;&gt;照合シーケンス&lt;/a&gt;を追加するために使用できます。</target>
        </trans-unit>
        <trans-unit id="1f26dca858775a9ffdc6b130413dfda84cf7cc4a" translate="yes" xml:space="preserve">
          <source>LoadAnalysis</source>
          <target state="translated">LoadAnalysis</target>
        </trans-unit>
        <trans-unit id="494260ec047bea19460fac6ca8324736557ff1c6" translate="yes" xml:space="preserve">
          <source>Loadable Extension Thunk</source>
          <target state="translated">ロード可能な拡張サンク</target>
        </trans-unit>
        <trans-unit id="a8855a7ba639af1775ee3c99ff39ec45827a09ba" translate="yes" xml:space="preserve">
          <source>Loadable extensions are C-code. To compile them on most unix-like operating systems, the usual command is something like this:</source>
          <target state="translated">ロード可能な拡張機能は C コードです。ほとんどの Unix ライクなオペレーティングシステム上でコンパイルするには、通常は次のようなコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="16baeb9dc5c7b831d9570f59926debb8cb175348" translate="yes" xml:space="preserve">
          <source>Local DELETE</source>
          <target state="translated">ローカルDELETE</target>
        </trans-unit>
        <trans-unit id="ad4c5e9ed0fc895a0d42b932b2926861699fe92c" translate="yes" xml:space="preserve">
          <source>Local INSERT</source>
          <target state="translated">ローカルINSERT</target>
        </trans-unit>
        <trans-unit id="3e12d4ac47a72a1f8aa6fb2cd56dc176cf45a02b" translate="yes" xml:space="preserve">
          <source>Local UPDATE</source>
          <target state="translated">ローカルUPDATE</target>
        </trans-unit>
        <trans-unit id="e88556ba53a549a6a9fbf15298a71732177e868b" translate="yes" xml:space="preserve">
          <source>Localtime modifier</source>
          <target state="translated">ローカルタイム修飾子</target>
        </trans-unit>
        <trans-unit id="249beb765376acea4283a10da9faa975024e8fe9" translate="yes" xml:space="preserve">
          <source>Lock Name</source>
          <target state="translated">ロック名</target>
        </trans-unit>
        <trans-unit id="d4795eaa0bbabf21615f9f3e359ab0c2e3631ccd" translate="yes" xml:space="preserve">
          <source>Lock offset</source>
          <target state="translated">ロックオフセット</target>
        </trans-unit>
        <trans-unit id="eb6bc036bb67cd66abad9bfabc9e6cb6a5eaef00" translate="yes" xml:space="preserve">
          <source>Lock the btree to which cursor P1 is pointing so that the btree cannot be written by an other cursor.</source>
          <target state="translated">カーソルP1が指しているbtreeをロックし、他のカーソルからbtreeが書き込めないようにします。</target>
        </trans-unit>
        <trans-unit id="de20f3d1eb2301b2722958c2ff4a7d6bd4e9d117" translate="yes" xml:space="preserve">
          <source>Locking and Concurrency</source>
          <target state="translated">ロックと並行性</target>
        </trans-unit>
        <trans-unit id="668186cf26fd89e59f391d180f6666c5c03f0bfa" translate="yes" xml:space="preserve">
          <source>Locking and concurrency control are handled by the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt; pager module&lt;/a&gt;. The pager module is responsible for making SQLite &quot;ACID&quot; (Atomic, Consistent, Isolated, and Durable). The pager module makes sure changes happen all at once, that either all changes occur or none of them do, that two or more processes do not try to access the database in incompatible ways at the same time, and that once changes have been written they persist until explicitly deleted. The pager also provides a memory cache of some of the contents of the disk file.</source>
          <target state="translated">ロックと同時実行制御は&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt;ページャーモジュール&lt;/a&gt;によって処理されます。ページャーモジュールは、SQLiteを &quot;ACID&quot;（Atomic、Consistent、Isolated、Durable）にする責任があります。ページャーモジュールは、すべての変更が一度に行われるか、まったく行われないか、2つ以上のプロセスが同時に互換性のない方法でデータベースにアクセスしようとしないこと、および変更が書き込まれると変更が一度に行われるようにします。明示的に削除されるまで存続します。ページャは、ディスクファイルの内容の一部のメモリキャッシュも提供します。</target>
        </trans-unit>
        <trans-unit id="57d0597b0f360ba173ecb2d2a1f767cb5748ea2e" translate="yes" xml:space="preserve">
          <source>Long Option</source>
          <target state="translated">ロングオプション</target>
        </trans-unit>
        <trans-unit id="76889c4037fcda94eba3afe630f0b45c824942de" translate="yes" xml:space="preserve">
          <source>Long Term Support</source>
          <target state="translated">長期サポート</target>
        </trans-unit>
        <trans-unit id="fce206f4d564c7fbca45ff9aebf22500127c7c61" translate="yes" xml:space="preserve">
          <source>Long and short style options may be mixed. For example, the following are equivalent:</source>
          <target state="translated">ロングスタイルとショートスタイルの選択肢が混在していてもよい。例えば、以下のようなものが該当します。</target>
        </trans-unit>
        <trans-unit id="1a01077cb8c85bad9873673a9051f4ee19688494" translate="yes" xml:space="preserve">
          <source>Longer answer: If you declare a column of a table to be &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, then whenever you insert a NULL into that column of the table, the NULL is automatically converted into an integer which is one greater than the largest value of that column over all other rows in the table, or 1 if the table is empty. Or, if the largest existing integer key 9223372036854775807 is in use then an unused key value is chosen at random. For example, suppose you have a table like this:</source>
          <target state="translated">より長い答え：テーブルの列を&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;として宣言すると、テーブルのその列にNULLを挿入するたびに、NULLはその列の最大値より1大きい整数に自動的に変換されますテーブル内の他のすべての行、またはテーブルが空の場合は1。または、最大の既存の整数キー9223372036854775807が使用中の場合、未使用のキー値がランダムに選択されます。たとえば、次のようなテーブルがあるとします。</target>
        </trans-unit>
        <trans-unit id="6e9f2602cf3d1fd809e1312f33acfde2f150141f" translate="yes" xml:space="preserve">
          <source>Lookaside buffer allocations for new &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;.</source>
          <target state="translated">新しい&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;用のルックアサイドバッファ割り当て。</target>
        </trans-unit>
        <trans-unit id="04bd7a984d3646ac5eb9c18de550a3f1e203e5b1" translate="yes" xml:space="preserve">
          <source>Lookaside memory allocator</source>
          <target state="translated">ルックサイドメモリアロケータ</target>
        </trans-unit>
        <trans-unit id="fde137681e3baa6ad1143b905327accc0fb28e76" translate="yes" xml:space="preserve">
          <source>Lots of bug fixes.</source>
          <target state="translated">たくさんのバグ修正。</target>
        </trans-unit>
        <trans-unit id="990ee2bc3df995ba8afb44c45e674fd9a503ec05" translate="yes" xml:space="preserve">
          <source>Lots of little bug fixes.</source>
          <target state="translated">小さなバグ修正がたくさん。</target>
        </trans-unit>
        <trans-unit id="43de40a3e36d80f18de0a9c09a14efee88ae8d7f" translate="yes" xml:space="preserve">
          <source>Love chastity.</source>
          <target state="translated">貞操観念を愛する。</target>
        </trans-unit>
        <trans-unit id="0bbc37af1e456bff56591e973337f95cdf967a70" translate="yes" xml:space="preserve">
          <source>Love fasting.</source>
          <target state="translated">断食を愛する。</target>
        </trans-unit>
        <trans-unit id="b7fcabbc1c2979a6343998251fb3b60ca2fcf13c" translate="yes" xml:space="preserve">
          <source>Love your enemies.</source>
          <target state="translated">敵を愛せ</target>
        </trans-unit>
        <trans-unit id="868ab24a96d3a2771240294f216c1eb308fe2112" translate="yes" xml:space="preserve">
          <source>Love your juniors.</source>
          <target state="translated">後輩が大好きです。</target>
        </trans-unit>
        <trans-unit id="dcbca8259d75e252eae0048dd86f40340f8d0cd8" translate="yes" xml:space="preserve">
          <source>Low-Level Control Of Database Files</source>
          <target state="translated">データベースファイルの低レベル制御</target>
        </trans-unit>
        <trans-unit id="c47d12b1a2b47bc6fe16c9cb80aba1cd8b334072" translate="yes" xml:space="preserve">
          <source>Low-dependency</source>
          <target state="translated">Low-dependency</target>
        </trans-unit>
        <trans-unit id="9b49cf9a88d0eb7571f152a707297d6594a2f0d2" translate="yes" xml:space="preserve">
          <source>Low-level system error code</source>
          <target state="translated">低レベルシステムエラーコード</target>
        </trans-unit>
        <trans-unit id="0be209fef2b5ea9e4e344d9742cbe9598db19564" translate="yes" xml:space="preserve">
          <source>Lowest precedence (loosest grouping).</source>
          <target state="translated">優先順位が最も低い(ゆるいグループ化)。</target>
        </trans-unit>
        <trans-unit id="f41a055096fba2f5ebbddc8916d81727739dbdb3" translate="yes" xml:space="preserve">
          <source>Lt</source>
          <target state="translated">Lt</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="1e549c8c539e5dd3fb33fffd4ca9bec2df1c3d6b" translate="yes" xml:space="preserve">
          <source>M &amp;amp;times 2&lt;sup&gt;&lt;small&gt;E&lt;/small&gt;&lt;/sup&gt;</source>
          <target state="translated">M＆times 2 &lt;sup&gt;&lt;small&gt;E&lt;/small&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a4b52e49796d63ce942c6b8bfaa86fb7c20383ea" translate="yes" xml:space="preserve">
          <source>M is always ((U-12)*32/255)-23.</source>
          <target state="translated">Mは常に((U-12)*32/255)-23です。</target>
        </trans-unit>
        <trans-unit id="1758fbe17031a1050ba647fef2f5a93784bd0bf5" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="5fbd2551d496e24af3eb24927ec50373a744a672" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="835c3f9feac04a1fedeecdc386e908df7274d7ab" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="7e3ce80c0f5019f27debc96398dd7ba53b449b32" translate="yes" xml:space="preserve">
          <source>MASK</source>
          <target state="translated">MASK</target>
        </trans-unit>
        <trans-unit id="4110e0d1b0232ec2802f84b8b4f2d0c2fb3fbbb7" translate="yes" xml:space="preserve">
          <source>MASK bit 0x02 is set.</source>
          <target state="translated">MASK ビット 0x02 が設定されます。</target>
        </trans-unit>
        <trans-unit id="ce71241b2af9817fe6f961964423ded83b2b2446" translate="yes" xml:space="preserve">
          <source>MATCH</source>
          <target state="translated">MATCH</target>
        </trans-unit>
        <trans-unit id="fb533649ca2f9e73b11b6bb948adb363f958ac9f" translate="yes" xml:space="preserve">
          <source>MEDIUMINT</source>
          <target state="translated">MEDIUMINT</target>
        </trans-unit>
        <trans-unit id="7c2c1a9b5cbb8b738dc37806d8007da0a4dabc51" translate="yes" xml:space="preserve">
          <source>MS-SQL</source>
          <target state="translated">MS-SQL</target>
        </trans-unit>
        <trans-unit id="e6557f13d224519bee5609849fa3b7fe2b045817" translate="yes" xml:space="preserve">
          <source>Macs are unix-like, but they do not follow the usual shared library conventions. To compile a shared library on a Mac, use a command like this:</source>
          <target state="translated">Mac は unix に似ていますが、通常の共有ライブラリの規約には従いません。Mac で共有ライブラリをコンパイルするには、次のようなコマンドを使います。</target>
        </trans-unit>
        <trans-unit id="a1e5337bd6f525fef1a4495aefda7354ea999138" translate="yes" xml:space="preserve">
          <source>Made selected parameters in API functions &lt;b&gt;const&lt;/b&gt;. This should be fully backwards compatible.</source>
          <target state="translated">API関数&lt;b&gt;const&lt;/b&gt;で選択したパラメーターを作成しました。これは完全に下位互換性があるはずです。</target>
        </trans-unit>
        <trans-unit id="debb142b11cd7000f7ccf5be052a02bcc1c7f9ef" translate="yes" xml:space="preserve">
          <source>Made the &lt;a href=&quot;testing#aflfuzz&quot;&gt;American Fuzzy Lop fuzzer&lt;/a&gt; a standard part of SQLite's &lt;a href=&quot;testing&quot;&gt;testing strategy&lt;/a&gt;.</source>
          <target state="translated">メイド&lt;a href=&quot;testing#aflfuzz&quot;&gt;アメリカンファジーロプはfuzzer&lt;/a&gt;のSQLiteのの標準部品&lt;a href=&quot;testing&quot;&gt;テスト戦略&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aadd04e928883126f21deaf37b5282558e747d50" translate="yes" xml:space="preserve">
          <source>Made the CACHE_SIZE pragma persistent</source>
          <target state="translated">CACHE_SIZE プラグマを永続化しました。</target>
        </trans-unit>
        <trans-unit id="2d544f28a897acf54e3872442614c2de63e16acf" translate="yes" xml:space="preserve">
          <source>Magic number. 0x377f0682 or 0x377f0683</source>
          <target state="translated">マジックナンバー。0x377f0682または0x377f0683</target>
        </trans-unit>
        <trans-unit id="a249757e280e4c1ed4596ef256151f0633cc5c86" translate="yes" xml:space="preserve">
          <source>Maintaining 100% MC/DC is laborious and time-consuming. The level of effort needed to maintain full-coverage testing is probably not cost effective for a typical application. However, we think that full-coverage testing is justified for a &lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;very widely deployed&lt;/a&gt; infrastructure library like SQLite, and especially for a database library which by its very nature &quot;remembers&quot; past mistakes.</source>
          <target state="translated">MC / DCを100％に維持することは、面倒で時間がかかります。フルカバレッジテストを維持するために必要な労力のレベルは、通常のアプリケーションではおそらく費用対効果が高くありません。ただし、SQLiteのような&lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;非常に広く展開&lt;/a&gt;されているインフラストラクチャライブラリ、特にその性質上過去の間違いを「記憶」しているデータベースライブラリに対しては、フルカバレッジテストが正当化されると考えています。</target>
        </trans-unit>
        <trans-unit id="0690809fdfc162c136b84c90c7f6551b5a7d6bb1" translate="yes" xml:space="preserve">
          <source>Maintaining Private Branches Of SQLite</source>
          <target state="translated">SQLiteのプライベートブランチの管理</target>
        </trans-unit>
        <trans-unit id="74db8285437f292d07f23511a8853dab08df8f69" translate="yes" xml:space="preserve">
          <source>Make &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; responsive to the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="translated">メイクは&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;）（sqlite3_compileoption_used&lt;/a&gt;に応答&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt;コンパイル時のオプション。</target>
        </trans-unit>
        <trans-unit id="f178a74cc1dcf57fcc7b73994685f97569f4844f" translate="yes" xml:space="preserve">
          <source>Make AreFileApisANSI() a no-op macro in WinCE since WinCE does not support this function.</source>
          <target state="translated">WinCE はこの関数をサポートしていないため、AreFileApisANSI()を WinCE で動作しないマクロにするようにしました。</target>
        </trans-unit>
        <trans-unit id="07dc88b6cef4d75e2f7c3880e8647593525aa07e" translate="yes" xml:space="preserve">
          <source>Make CSV (comma separate value) output from the command-line shell more closely aligned to accepted practice</source>
          <target state="translated">コマンドラインシェルからのCSV(カンマ区切りの値)出力を、より一般的な慣習に近いものにする</target>
        </trans-unit>
        <trans-unit id="7ebdddec87e9007589d5ada3e116c78e26d2e69a" translate="yes" xml:space="preserve">
          <source>Make LIMIT work on a compound SELECT statement.</source>
          <target state="translated">複合SELECT文でLIMITが機能するようにします。</target>
        </trans-unit>
        <trans-unit id="67a20c818425dd125a3dee8478ee3f7563c8b234" translate="yes" xml:space="preserve">
          <source>Make a copy of registers P1..P1+P3 into registers P2..P2+P3.</source>
          <target state="translated">レジスタP1...P1+P3をレジスタP2...P2+P3にコピーします。</target>
        </trans-unit>
        <trans-unit id="8d0b0f116d9ed8fdf1c047e6cff51269d6d08bd0" translate="yes" xml:space="preserve">
          <source>Make a distinction between numeric and text values when sorting. Text values sort according to memcmp(). Numeric values sort in numeric order.</source>
          <target state="translated">ソートする際には、数値とテキスト値を区別するようにしてください。テキスト値は memcmp()に従ってソートします。数値は数値順にソートします。</target>
        </trans-unit>
        <trans-unit id="9f53feddfd33da18e3bb3466ea22bc837873fc9d" translate="yes" xml:space="preserve">
          <source>Make a shallow copy of register P1 into register P2.</source>
          <target state="translated">レジスタP1をレジスタP2に浅くコピーする。</target>
        </trans-unit>
        <trans-unit id="c4914cad6e6db40e49d46939d936ae678cbe7888" translate="yes" xml:space="preserve">
          <source>Make every effort to allocate a new page. Only return NULL if allocating a new page is effectively impossible.</source>
          <target state="translated">新しいページを確保するためにあらゆる努力をしてください。新しいページの割り当てが事実上不可能な場合のみ NULL を返します。</target>
        </trans-unit>
        <trans-unit id="94089eca234684dc20cbdb2f8434b3d3fb23b40c" translate="yes" xml:space="preserve">
          <source>Make peace with your adversary before the sun sets.</source>
          <target state="translated">太陽が沈む前に敵と仲直りしましょう。</target>
        </trans-unit>
        <trans-unit id="b31d5954ede96c4a01bf917d9892337c3c9f6de7" translate="yes" xml:space="preserve">
          <source>Make sure ORDER BY puts rows in ascending order even if the DISTINCT operator is implemented using a descending index. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9e&lt;/a&gt;.</source>
          <target state="translated">DISTINCT演算子が降順のインデックスを使用して実装されている場合でも、ORDER BYが行を昇順で配置することを確認してください。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9eの&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="fd7437d47e0ca64701851f46718248492d235445" translate="yes" xml:space="preserve">
          <source>Make sure VIEWs are created after their corresponding TABLEs in the output of the &lt;b&gt;.dump&lt;/b&gt; command in the shell.</source>
          <target state="translated">シェルの&lt;b&gt;.dump&lt;/b&gt;コマンドの出力で、対応するTABLEの後にVIEWが作成されていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="b8fc01ec14bc51db67a6c7f295254a0473ee78c4" translate="yes" xml:space="preserve">
          <source>Make sure all individual database files have an EXCLUSIVE lock and a valid journal.</source>
          <target state="translated">すべての個々のデータベースファイルにEXCLUSIVEロックと有効なジャーナルがあることを確認してください。</target>
        </trans-unit>
        <trans-unit id="39ceab29d21e2433cf3cad2d290185c2cdda1b07" translate="yes" xml:space="preserve">
          <source>Make sure all rollback journal data has actually been written to the surface of the disk (and is not just being held in the operating system's or disk controllers cache) so that if a power failure occurs the data will still be there after power is restored.</source>
          <target state="translated">停電が発生しても、電源が復旧した後もデータが残っているように、すべてのロールバックジャーナルデータが実際にディスクの表面に書き込まれていることを確認してください(オペレーティングシステムやディスクコントローラのキャッシュに保持されているだけではありません)。</target>
        </trans-unit>
        <trans-unit id="faaff6cbdbf4873f3d095a4a0e2d87974475615a" translate="yes" xml:space="preserve">
          <source>Make sure functions expressions in the VALUES clause of an INSERT are correct.</source>
          <target state="translated">INSERTのVALUES句の関数式が正しいことを確認してください。</target>
        </trans-unit>
        <trans-unit id="b3c87542457fbfa0848fd99500f7827664d328fc" translate="yes" xml:space="preserve">
          <source>Make sure that database filenames follow the 8+3 filename format and that they do not have an empty name or extension. In other words, the database filename must contain between 1 and 8 characters in the base name and between 1 and 3 characters in the extension. Blank extensions are not allowed.</source>
          <target state="translated">データベースファイル名は8+3ファイル名の形式に従い、空の名前や拡張子を持たないようにしてください。言い換えれば、データベースファイル名には、ベース名に1文字から8文字、拡張子に1文字から3文字の間の文字を含める必要があります。空の拡張子は許されません。</target>
        </trans-unit>
        <trans-unit id="559ee78af19e40cf8fa346787df1709761be2f3c" translate="yes" xml:space="preserve">
          <source>Make sure that when a connection blocks on a RESERVED lock that it is able to continue after the lock is released. (Ticket #3093)</source>
          <target state="translated">RESERVEDロックで接続がブロックされた場合、ロックが解除された後も接続を継続できるようにしてください。(チケット#3093)</target>
        </trans-unit>
        <trans-unit id="6c2032f0b0a487670b92ae7b1f7c2a4d3713ca71" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt; values from multiple triggers within a single statement do not interfere with one another. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt;.</source>
          <target state="translated">単一ステートメント内の複数のトリガーからの&lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata（）&lt;/a&gt;値が互いに干渉しないことを確認してください。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6638940c401bf7e1c92493be7672af3af206b2b" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; interface does not zero-terminate the buffer if the buffer size is less than 1. Ticket #2341</source>
          <target state="translated">バッファーサイズが1未満の場合、&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;インターフェイスがバッファーをゼロで終了しないことを確認してください。チケット＃2341</target>
        </trans-unit>
        <trans-unit id="3bc85b9279a5981ff83181cec093f69c7042f9c4" translate="yes" xml:space="preserve">
          <source>Make sure the MIN() and MAX() optimizations work within subqueries.</source>
          <target state="translated">MIN()および MAX()の最適化がサブクエリ内で動作することを確認してください。</target>
        </trans-unit>
        <trans-unit id="58ff8f836097af00b92625ae2c5e983cf4412032" translate="yes" xml:space="preserve">
          <source>Make sure the ORDER BY LIMIT optimization (from check-in &lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09e&lt;/a&gt;) works with IN operators on INTEGER PRIMARY KEYs. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96c1454c&lt;/a&gt;</source>
          <target state="translated">（チェックイン&lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09eからの&lt;/a&gt;）ORDER BY LIMIT最適化がINTEGER PRIMARY KEYのIN演算子で機能することを確認します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96c1454cの&lt;/a&gt;修正</target>
        </trans-unit>
        <trans-unit id="3ea00b4a5adf172672ba7e54a20e155f2d4f11b3" translate="yes" xml:space="preserve">
          <source>Make sure the TCL language interface works correctly with 64-bit integers on 64-bit machines.</source>
          <target state="translated">TCL言語インタフェースが64ビットマシン上で64ビット整数で正しく動作することを確認してください。</target>
        </trans-unit>
        <trans-unit id="2c7d7b5412a65ed5d6ce615755d9929fa6d57cca" translate="yes" xml:space="preserve">
          <source>Make sure the in-memory backend response sanely if malloc() fails.</source>
          <target state="translated">malloc()が失敗した場合に、インメモリバックエンドのレスポンスが正気であることを確認するようにしてください。</target>
        </trans-unit>
        <trans-unit id="eae9ed5b156bcdd54a8967008569fef435a53021" translate="yes" xml:space="preserve">
          <source>Make sure the query optimizer checks dependencies on all terms of a compound SELECT statement. Ticket #2640.</source>
          <target state="translated">クエリオプティマイザが複合SELECT文のすべての項の依存関係をチェックするようにしてください。チケット番号#2640。</target>
        </trans-unit>
        <trans-unit id="30c0cf0484d7a5f504b6b728788d263a9e41fc0c" translate="yes" xml:space="preserve">
          <source>Make sure you type a semicolon at the end of each SQL command! The sqlite3 program looks for a semicolon to know when your SQL command is complete. If you omit the semicolon, sqlite3 will give you a continuation prompt and wait for you to enter more text to be added to the current SQL command. This feature allows you to enter SQL commands that span multiple lines. For example:</source>
          <target state="translated">各SQLコマンドの最後にセミコロンを入力してください! sqlite3プログラムは、SQLコマンドが完了したときにセミコロンを探します。もしセミコロンを省略した場合、sqlite3は継続プロンプトを表示し、現在のSQLコマンドに追加されるテキストを入力するのを待ちます。この機能により、複数行にまたがるSQLコマンドを入力することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0f78a73d59843cf77efe52a3fb9a1c8bc577fb63" translate="yes" xml:space="preserve">
          <source>Make that script executable and put it on your $PATH. Then compile the kvtest program as follows:</source>
          <target state="translated">そのスクリプトを実行可能にして $PATH に置いてください。そして、以下のようにkvtestプログラムをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="55a8e3fef2599367be1f179f0eeae6e3f90c5562" translate="yes" xml:space="preserve">
          <source>Make the &quot;AS&quot; keyword optional again.</source>
          <target state="translated">再び「as」キーワードを任意にします。</target>
        </trans-unit>
        <trans-unit id="e8d3c7849aaf72378ce97fad0ef58bb50dfa844b" translate="yes" xml:space="preserve">
          <source>Make the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt; part of standard builds when compiled with the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; option.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt;オプションを使用してコンパイルする場合、&lt;a href=&quot;dbstat&quot;&gt;dbstat仮想テーブル&lt;/a&gt;を標準ビルドの一部にします。</target>
        </trans-unit>
        <trans-unit id="3cf1a1fb81ef7a54777705fadfc53565c39e040a" translate="yes" xml:space="preserve">
          <source>Make the GLOB and LIKE operators functions that can be overridden by a programmer. This allows, for example, the LIKE operator to be changed to be case sensitive.</source>
          <target state="translated">GLOBとLIKE演算子をプログラマがオーバーライドできる関数にする。これにより、例えばLIKE演算子を大文字小文字を区別するように変更することができます。</target>
        </trans-unit>
        <trans-unit id="06d1ed76522acc5f77d35b87ff9bcb7713142c7d" translate="yes" xml:space="preserve">
          <source>Make the LIMIT clause work on subqueries. (ORDER BY still does not work, though.)</source>
          <target state="translated">LIMIT句が副問い合わせで動作するようにしました。(ただし、ORDER BYはまだ動作しません)。</target>
        </trans-unit>
        <trans-unit id="e949e24407b3c3e74908e043648105301add53c5" translate="yes" xml:space="preserve">
          <source>Make the library thread-safe. (The code is there and appears to work but has not been stressed.)</source>
          <target state="translated">ライブラリをスレッドセーフにする。(コードはあり、動作しているように見えますが、ストレスをかけていません)。</target>
        </trans-unit>
        <trans-unit id="aa1b502d7a3d8467cdd71e12de59017bd7bf7832" translate="yes" xml:space="preserve">
          <source>Make the os.h header file more robust in detecting when the compile is for Windows and when it is for Unix.</source>
          <target state="translated">Windows 用のコンパイルと Unix 用のコンパイルを検出するために、 os.h ヘッダファイルをより強固なものにしました。</target>
        </trans-unit>
        <trans-unit id="5b70367d16489f70b60357dd49e971c66ecb7a25" translate="yes" xml:space="preserve">
          <source>Make use of OVERLAPPED in the windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to avoid some system calls and thereby obtain a performance improvement.</source>
          <target state="translated">Windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;でOVERLAPPEDを使用して、一部のシステムコールを回避し、パフォーマンスを向上させます。</target>
        </trans-unit>
        <trans-unit id="bb3c80011eafc56757b5115bd6da6df2d3cc0bcf" translate="yes" xml:space="preserve">
          <source>Make use of the one-pass UPDATE and DELETE query plans in the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; where appropriate.</source>
          <target state="translated">必要に応じて、&lt;a href=&quot;rtree&quot;&gt;Rツリー拡張の&lt;/a&gt;ワンパスUPDATEおよびDELETEクエリプランを利用します。</target>
        </trans-unit>
        <trans-unit id="9c7ffc0af1b5a78c06ebbd279554c53e269060be" translate="yes" xml:space="preserve">
          <source>MakeRecord</source>
          <target state="translated">MakeRecord</target>
        </trans-unit>
        <trans-unit id="decb5fb2e05d5246774c7c119193e5dd3eeab585" translate="yes" xml:space="preserve">
          <source>Makefile updates</source>
          <target state="translated">Makefile の更新</target>
        </trans-unit>
        <trans-unit id="3e75c9edc23a32990a13f91bc222c1cd2fb310c7" translate="yes" xml:space="preserve">
          <source>Makefile updates and miscellaneous bug fixes.</source>
          <target state="translated">Makefileの更新と雑なバグ修正。</target>
        </trans-unit>
        <trans-unit id="bdecdca82af325fcab74535c838b3bad719fc7de" translate="yes" xml:space="preserve">
          <source>Makefile updates from A. Rottmann</source>
          <target state="translated">A.RottmannからのMakefileの更新</target>
        </trans-unit>
        <trans-unit id="1a74e86adcd0000bd7de1be192d074c821dd68c1" translate="yes" xml:space="preserve">
          <source>Making Other Kinds Of Table Schema Changes</source>
          <target state="translated">他の種類のテーブルスキーマの変更を行う</target>
        </trans-unit>
        <trans-unit id="e6fe063cab95ff9f5d6ec0129688c23c296059b5" translate="yes" xml:space="preserve">
          <source>Malformed UTF-8 that SQLite converts to a UTF-16 byte-order-mark is embedded at the beginning of an SQL string literal value inserted into an FTS3 table.</source>
          <target state="translated">FTS3 テーブルに挿入された SQL 文字列リテラル値の先頭に、SQLite が UTF-16 バイトオーダマークに変換する不正な UTF-8 が埋め込まれています。</target>
        </trans-unit>
        <trans-unit id="e30f6661f23230d01a3d07773b601db8982cabdd" translate="yes" xml:space="preserve">
          <source>Malformed database tests</source>
          <target state="translated">不正なデータベーステスト</target>
        </trans-unit>
        <trans-unit id="aa578a91aad5dc4dab2da9a4bac602790d836ae2" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement (an ALTER TABLE that tries to rename a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; into one of its own &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;) causes an infinite loop and denial of service. &lt;a href=&quot;https://sqlite.org/src/info/eca0ba2cf4c0fdf7&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">悪意のあるSQLステートメント（&lt;a href=&quot;vtab&quot;&gt;仮想テーブルの&lt;/a&gt;名前を独自の&lt;a href=&quot;vtab#xshadowname&quot;&gt;シャドウテーブルの&lt;/a&gt;1つに変更しようとするALTER TABLE ）は、無限ループとサービス拒否を引き起こします。&lt;a href=&quot;https://sqlite.org/src/info/eca0ba2cf4c0fdf7&quot;&gt;（詳細）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e3505da2486b779eca8455a74c0a2213782342dc" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference and denial-of-service &lt;a href=&quot;https://www.sqlite.org/src/info/1bc783da63d58b05&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">悪意のあるSQLステートメントにより、NULLポインターの逆参照とサービス拒否が発生します&lt;a href=&quot;https://www.sqlite.org/src/info/1bc783da63d58b05&quot;&gt;（詳細）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3b3de4ef5153133c67b1a8788b48babe0af12634" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/862974312edf00e9&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">悪意のあるSQLステートメントにより、NULLポインターの逆参照とサービス拒否が発生します。&lt;a href=&quot;https://www.sqlite.org/src/info/862974312edf00e9&quot;&gt;（詳細）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f05b51d00c5136f9765e2a5529ff25dd76521560" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference and in the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension and denial-of-service. This is only possible when the optional &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension is deployed, which is not the case in default builds. &lt;a href=&quot;https://www.sqlite.org/src/info/a80f84b511231204&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">悪意のあるSQLステートメントは、NULLポインターの逆参照を引き起こし、&lt;a href=&quot;zipfile&quot;&gt;Zipfile仮想テーブル&lt;/a&gt;拡張およびサービス拒否を引き起こします。これは、オプションの&lt;a href=&quot;zipfile&quot;&gt;Zipfile仮想テーブル&lt;/a&gt;拡張機能がデプロイされている場合にのみ可能です。これはデフォルトのビルドには当てはまりません。&lt;a href=&quot;https://www.sqlite.org/src/info/a80f84b511231204&quot;&gt;（詳細）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3223f276a85bbea2e40f22c66ab04105f353da0b" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference in the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension and denial-of-service. This is only possible when the optional &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension is deployed, which is not the case in default builds. &lt;a href=&quot;https://www.sqlite.org/src/info/cc0fb00a128fd077&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">悪意のあるSQLステートメントにより、&lt;a href=&quot;zipfile&quot;&gt;Zipfile仮想テーブル&lt;/a&gt;拡張およびサービス拒否でNULLポインターの逆参照が発生します。これは、オプションの&lt;a href=&quot;zipfile&quot;&gt;Zipfile仮想テーブル&lt;/a&gt;拡張機能がデプロイされている場合にのみ可能です。これはデフォルトのビルドには当てはまりません。&lt;a href=&quot;https://www.sqlite.org/src/info/cc0fb00a128fd077&quot;&gt;（詳細）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be787da663e373d3f7997d1441cd2ca035e3495f" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read access to a NULL pointer and denial of service. &lt;a href=&quot;https://www.sqlite.org/src/info/7a5279a25c57adf1&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">悪意のあるSQLステートメントにより、NULLポインターへの読み取りアクセスとサービス拒否が発生します。&lt;a href=&quot;https://www.sqlite.org/src/info/7a5279a25c57adf1&quot;&gt;（詳細）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b7808ef1d93533f98b34a6af3e305d6a4a79902" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read of a NULL pointer in the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; SQL function of the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; extension, resulting in denial of service. &lt;a href=&quot;https://sqlite.org/src/info/a4dd148928ea65bd&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">悪意のあるSQLステートメントにより、&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;拡張機能の&lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo（）&lt;/a&gt; SQL関数でNULLポインターが読み取られ、サービス拒否が発生します。&lt;a href=&quot;https://sqlite.org/src/info/a4dd148928ea65bd&quot;&gt;（詳細）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb5500a4c4534dd4662f8932a169f8e6f4053c24" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read using an uninitialized pointer and denial-of-service &lt;a href=&quot;https://www.sqlite.org/src/info/4374860b29383380&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">悪意のあるSQLステートメントにより、初期化されていないポインターとサービス拒否を使用して読み取りが発生します&lt;a href=&quot;https://www.sqlite.org/src/info/4374860b29383380&quot;&gt;（詳細）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="08a51de55d02f39c503f43bf8dbb67b4a981750f" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read using an uninitialized pointer and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/af4556bb5c285c08&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">悪意のあるSQLステートメントは、初期化されていないポインタとサービス拒否を使用して読み取りを引き起こします。&lt;a href=&quot;https://www.sqlite.org/src/info/af4556bb5c285c08&quot;&gt;（詳細）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0f420ed40458097230e18bc609dc3d6070a139e7" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read-only use-after-free memory error. &lt;a href=&quot;https://sqlite.org/src/info/c8d3b9f0a750a529&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">悪意のあるSQLステートメントにより、読み取り専用の解放後使用メモリエラーが発生します。&lt;a href=&quot;https://sqlite.org/src/info/c8d3b9f0a750a529&quot;&gt;（詳細）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c7315e30c332568a87d33624f52296d256dba71" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read-only use-after-free, possibly resulting in a incorrect output from the &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt; SQL function of the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; extension. There is no known way to exfiltrate data or crash the application using this bug. &lt;a href=&quot;https://sqlite.org/src/info/0d69f76f0865f962&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">悪意のあるSQLステートメントにより、読み取り専用の解放後使用が発生し、&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;拡張機能の&lt;a href=&quot;fts3#snippet&quot;&gt;snippet（）&lt;/a&gt; SQL関数からの出力が正しくなくなる可能性があります。このバグを使用してデータを盗み出したり、アプリケーションをクラッシュさせたりする既知の方法はありません。&lt;a href=&quot;https://sqlite.org/src/info/0d69f76f0865f962&quot;&gt;（詳細）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="605174f0d56c0319ea8c88e54fd141ec899039f3" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a uninitialized pointer reference and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/e2bddcd4c55ba3cb&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">悪意のあるSQLステートメントにより、初期化されていないポインタ参照とサービス拒否が発生します。&lt;a href=&quot;https://www.sqlite.org/src/info/e2bddcd4c55ba3cb&quot;&gt;（詳細）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5a3d15a3efb587f7e5d31ca19ff99f19bff90311" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes an read past the end of a heap buffer. &lt;a href=&quot;https://sqlite.org/src/info/8f157e8010b22af0&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">悪意のあるSQLステートメントにより、ヒープバッファーの終わりを超えて読み取りが発生します。&lt;a href=&quot;https://sqlite.org/src/info/8f157e8010b22af0&quot;&gt;（詳細）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3460af9ab9b12af9da67324f2da63f63e80a6848" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes an uninitialized pointer read and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/cba2a2a44cdf138a&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">悪意のあるSQLステートメントにより、初期化されていないポインタの読み取りとサービス拒否が発生します。&lt;a href=&quot;https://www.sqlite.org/src/info/cba2a2a44cdf138a&quot;&gt;（詳細）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b341edff7ed671940a8d972691c324a8c7d62137" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes an uninitialized pointer read and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/timeline?r=better-error-handling-1&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">悪意のあるSQLステートメントにより、初期化されていないポインタの読み取りとサービス拒否が発生します。&lt;a href=&quot;https://www.sqlite.org/src/timeline?r=better-error-handling-1&quot;&gt;（詳細）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be80211b17a199f937f0a9b644dfd18f1e2cecb3" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes read-only use-after-free of memory allocation if SQLite is compile with -DSQLITE_DEBUG. Does not affect release builds. &lt;a href=&quot;https://www.sqlite.org/src/info/4722bdab08cb1&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">SQLiteが-DSQLITE_DEBUGを使用してコンパイルされている場合、悪意のあるSQLステートメントにより、読み取り専用の解放後のメモリ割り当てが発生します。リリースビルドには影響しません。&lt;a href=&quot;https://www.sqlite.org/src/info/4722bdab08cb1&quot;&gt;（詳細）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="90aacfe82b6d869ef75232c639a3bc16d905426f" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement involving the printf() SQL function results in an integer overflow which can overwrite the stack with over 2 billion bytes of 0x30 or 0x20 (ASCII '0' or ' '). Even though this is a stack overwrite, there is no known way to redirect control or otherwise escalate the level of harm. This is a denial-of-service attack only. &lt;a href=&quot;https://www.sqlite.org/src/info/23439ea582241138&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">printf（）SQL関数を含む悪意のあるSQLステートメントは、整数オーバーフローを引き起こし、20億バイトを超える0x30または0x20（ASCII'0 'または' '）でスタックを上書きする可能性があります。これはスタックの上書きですが、制御をリダイレクトしたり、害のレベルをエスカレートしたりする既知の方法はありません。これはサービス拒否攻撃のみです。&lt;a href=&quot;https://www.sqlite.org/src/info/23439ea582241138&quot;&gt;（詳細）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6314779095d53af544ef97df23a24554ee88bdd" translate="yes" xml:space="preserve">
          <source>Managing SQLite Archives from the command-line</source>
          <target state="translated">コマンドラインからの SQLite アーカイブの管理</target>
        </trans-unit>
        <trans-unit id="3fbc66cdb2efde39d2ec8d74f242ca151b4515bd" translate="yes" xml:space="preserve">
          <source>Manifest Typing and BLOB Support</source>
          <target state="translated">マニフェストタイプとBLOBのサポート</target>
        </trans-unit>
        <trans-unit id="bb55c1a865472533208270e05409a59df50af4d8" translate="yes" xml:space="preserve">
          <source>Manifest typing and BLOB support.</source>
          <target state="translated">マニフェストタイピングとBLOBのサポート。</target>
        </trans-unit>
        <trans-unit id="1cc470a30ade4f894dfdc6d3819af02869f9a0ff" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using CROSS JOIN</source>
          <target state="translated">CROSS JOINを用いたクエリプランの手動制御</target>
        </trans-unit>
        <trans-unit id="cd08ce62fe23d2df3bf17c27439fcc586ae7eb2c" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using SQLITE_STAT Tables</source>
          <target state="translated">SQLITE_STAT テーブルを使用したクエリプランの手動制御</target>
        </trans-unit>
        <trans-unit id="6ce25f14125bd349207477d6be9b5bb56a241bb2" translate="yes" xml:space="preserve">
          <source>Many SQLITE_OMIT_ macros inserts to omit features at compile-time and reduce the library footprint.</source>
          <target state="translated">多くの SQLITE_OMIT_マクロは、コンパイル時に機能を省略し、ライブラリのフットプリントを減らすために挿入します。</target>
        </trans-unit>
        <trans-unit id="58bc21cac299bf4ec03f599485fd07e14baffb8d" translate="yes" xml:space="preserve">
          <source>Many SQLite functions return an integer result code from the set shown here in order to indicate success or failure.</source>
          <target state="translated">多くの SQLite 関数は、成功か失敗かを示すために、ここで示したセットから整数の結果コードを返します。</target>
        </trans-unit>
        <trans-unit id="29bbffe8721f3a2848d887e1fb7a366159ccdc97" translate="yes" xml:space="preserve">
          <source>Many Small Queries Are Efficient In SQLite</source>
          <target state="translated">SQLiteでは多くの小さなクエリが効率的</target>
        </trans-unit>
        <trans-unit id="b88b7072aba4a1d9cfba91839cebc05836eb0907" translate="yes" xml:space="preserve">
          <source>Many applications destroy their &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using calls to &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; at shutdown. Or, for example, an application that uses SQLite as its &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt; might open &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; in response to a File/Open menu action and then destroy the corresponding &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; in response to the File/Close menu.</source>
          <target state="translated">多くのアプリケーションは、シャットダウン時に&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;への呼び出しを使用して&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;を破棄します。または、例えば、そのようSQLiteのを使用するアプリケーション&lt;a href=&quot;appfileformat&quot;&gt;アプリケーションファイルフォーマットは、&lt;/a&gt;開くことがあります&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続を&lt;/a&gt;ファイル/開く]メニューのアクションに応じて、その後、対応する破壊する&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;ファイル/閉じるメニューに対応しています。</target>
        </trans-unit>
        <trans-unit id="e4e81b55d5c98ead21919f5ad70f41ad3433a3b2" translate="yes" xml:space="preserve">
          <source>Many applications use SQLite as a cache of relevant content from an enterprise RDBMS. This reduces latency, since most queries now occur against the local cache and avoid a network round-trip. It also reduces the load on the network and on the central database server. And in many cases, it means that the client-side application can continue operating during network outages.</source>
          <target state="translated">多くのアプリケーションでは、SQLite をエンタープライズ RDBMS の関連コンテンツのキャッシュとして使用しています。これにより、ほとんどのクエリがローカルキャッシュに対して実行され、ネットワークの往復を避けることができるため、待ち時間が短縮されます。また、ネットワークと中央データベースサーバの負荷も軽減されます。また、多くの場合、ネットワークが停止してもクライアント側のアプリケーションが動作を継続できることを意味します。</target>
        </trans-unit>
        <trans-unit id="0a456e7268dde3087ce48e51e3014a05bf0f0916" translate="yes" xml:space="preserve">
          <source>Many code simplifications and obscure bug fixes in support of providing &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;testing#coverage&quot;&gt;100％ブランチテストカバレッジの&lt;/a&gt;提供をサポートする多くのコードの簡素化と不明瞭なバグ修正。</target>
        </trans-unit>
        <trans-unit id="a1bfd103f34c0767adc1c7bc9d7d6d545e23cabf" translate="yes" xml:space="preserve">
          <source>Many documentation updates</source>
          <target state="translated">多くのドキュメントの更新</target>
        </trans-unit>
        <trans-unit id="3c83fd215f6013569c8872261f46c5842b6f52ba" translate="yes" xml:space="preserve">
          <source>Many examples of complete and working loadable extensions can be seen in the SQLite source tree in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory. Each file in that directory is a separate extension. Documentation is provided by a header comment on the file. Here are brief notes on a few of the extensions in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory:</source>
          <target state="translated">完全で機能するロード可能な拡張機能の多くの例は、&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt;サブディレクトリのSQLiteソースツリーにあります。そのディレクトリ内の各ファイルは個別の拡張子です。ドキュメントは、ファイルのヘッダーコメントによって提供されます。&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt;サブディレクトリにあるいくつかの拡張機能について簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="c27368aaf7a63c4c54dd85e130e6a371a0b652db" translate="yes" xml:space="preserve">
          <source>Many improvements and cleanups to the configure script</source>
          <target state="translated">configure スクリプトの多くの改善とクリーンアップ</target>
        </trans-unit>
        <trans-unit id="478a301b607ffcc6373478ce0ad5e01e286e6440" translate="yes" xml:space="preserve">
          <source>Many improvements and enhancements to the shell.</source>
          <target state="translated">シェルの多くの改良と強化。</target>
        </trans-unit>
        <trans-unit id="86f119ce378fd6fb5c391277ea97047cef855bbe" translate="yes" xml:space="preserve">
          <source>Many improvements to the test suite. Test coverage now exceeded 98%</source>
          <target state="translated">テストスイートの多くの改善。テストカバレッジが98%を超えるようになりました</target>
        </trans-unit>
        <trans-unit id="ec9cc9f8a731e2c88a6a0e04dca8da72cc53d489" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations result in 20.3% more work for the same number of CPU cycles relative to the previous release. The cumulative performance increase since &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; is 61%. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 13.10 x64 with gcc 4.8.1 and -Os. Your performance may vary.)</source>
          <target state="translated">多くのマイクロ最適化により、以前のリリースと比較して、同じ数のCPUサイクルで20.3％多い作業が発生します。&lt;a href=&quot;#version_3_8_0&quot;&gt;バージョン3.8.0&lt;/a&gt;以降の累積パフォーマンスの向上は61％です。（使用して測定&lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrindを&lt;/a&gt;上&lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.cの&lt;/a&gt; GCC 4.8.1と-OsとUbuntuの13.10のx64上のワークロード。あなたのパフォーマンスは変更になる場合があります。）</target>
        </trans-unit>
        <trans-unit id="1070ccc184f5ee6e5132e8f78957c23f5d18aeb1" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations, resulting in a library that is faster than the previous release.</source>
          <target state="translated">多くのマイクロ最適化が行われ、その結果、以前のリリースよりも高速なライブラリが得られました。</target>
        </trans-unit>
        <trans-unit id="ef73d713f7e1172e113f066199b34719f6daec88" translate="yes" xml:space="preserve">
          <source>Many minor bug fixes</source>
          <target state="translated">多くのマイナーなバグ修正</target>
        </trans-unit>
        <trans-unit id="d82e20d7c9c34c867cdbaaabca856ec1debc82ea" translate="yes" xml:space="preserve">
          <source>Many nuisance bugs fixed.</source>
          <target state="translated">多くの迷惑なバグが修正されました。</target>
        </trans-unit>
        <trans-unit id="a8c23cdfb8fba87694bb2dbb013754a5354d8db3" translate="yes" xml:space="preserve">
          <source>Many of the parameters passed to the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; family of interfaces are common across the entire family.</source>
          <target state="translated">インターフェイスの&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;ファミリに渡されるパラメータの多くは、ファミリ全体で共通です。</target>
        </trans-unit>
        <trans-unit id="58cc54792f79ad7e4a6c20e286dbf7226ea88ce5" translate="yes" xml:space="preserve">
          <source>Many of the routines in the SQLite &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; return numeric result codes indicating either success or failure, and in the event of a failure, providing some idea of the cause of the failure. This document strives to explain what each of those numeric result codes means.</source>
          <target state="translated">SQLite &lt;a href=&quot;c3ref/intro&quot;&gt;C言語インターフェイス&lt;/a&gt;のルーチンの多くは、成功または失敗のいずれかを示す数値の結果コードを返し、失敗の場合は、失敗の原因についての何らかの考えを提供します。このドキュメントでは、これらの数値結果コードのそれぞれの意味を説明するよう努めています。</target>
        </trans-unit>
        <trans-unit id="684a0cdf6fba65d365077c8562625db95e85aea3" translate="yes" xml:space="preserve">
          <source>Many operations, especially I/O intensive operations, can be faster since content does need to be copied between kernel space and user space.</source>
          <target state="translated">多くの操作、特に I/O を多用する操作は、コンテンツをカーネル空間とユーザ空間の間でコピーする必要があるため、高速化することができます。</target>
        </trans-unit>
        <trans-unit id="e75f87ad413b2b989beb9904a93bbc6902b68acd" translate="yes" xml:space="preserve">
          <source>Many programs use &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen()&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread()&lt;/a&gt;, and &lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite()&lt;/a&gt; to create and manage files of data in home-grown formats. SQLite works particularly well as a replacement for these</source>
          <target state="translated">多くのプログラムは、&lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen（）&lt;/a&gt;、&lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread（）&lt;/a&gt;、および&lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite（）&lt;/a&gt;を使用して、自社開発の形式でデータのファイルを作成および管理します。SQLiteはこれらの代替として特にうまく機能します</target>
        </trans-unit>
        <trans-unit id="58c8d3506d92b491bec9b8982cb696fb925723f6" translate="yes" xml:space="preserve">
          <source>Many readers have recommended various third-party GUIs for Git that might do a better job of showing historical development activity. Maybe some of them do work better than native Git and/or GitHub, though they will all be hampered by the fact that Git does not preserve historical branch names across syncs. And even if those other tools are better, the fact that it is necessary to go to a third-party tool to get the information desired does not speak well of the core system.</source>
          <target state="translated">多くの読者が、過去の開発活動の履歴を表示するのに適したサードパーティ製の Git 用 GUI を推奨しています。その中には、ネイティブの Git や GitHub よりもうまく機能するものもあるかもしれませんが、いずれも Git が同期した際に歴史的なブランチ名を保存しないという事実に阻まれます。また、他のツールの方が優れているとしても、必要な情報を得るためにサードパーティのツールを使わなければならないという事実は、コアシステムの良さをよく表していません。</target>
        </trans-unit>
        <trans-unit id="57a3139bc8f04dd188f9b7807c96ec2f953e86dc" translate="yes" xml:space="preserve">
          <source>Many small performance optimizations.</source>
          <target state="translated">多くの小さなパフォーマンスの最適化。</target>
        </trans-unit>
        <trans-unit id="575ebc9be57deafee12eee1cb275aca14943f68c" translate="yes" xml:space="preserve">
          <source>Many, many bug fixes and compatibility enhancements.</source>
          <target state="translated">多くのバグ修正と互換性の強化。</target>
        </trans-unit>
        <trans-unit id="305801fe337dfa5f8bad0f9f9e15662ddae791a8" translate="yes" xml:space="preserve">
          <source>Many, many minor bug fixes and documentation updates.</source>
          <target state="translated">多くの、多くのマイナーなバグ修正とドキュメントの更新。</target>
        </trans-unit>
        <trans-unit id="35ddb236d4c17515cfe7146a42b5a461cee3e50c" translate="yes" xml:space="preserve">
          <source>Master Journal Pointer</source>
          <target state="translated">マスタージャーナルポインター</target>
        </trans-unit>
        <trans-unit id="9abc1c7f8fc32d4d49746263693941601091cb5d" translate="yes" xml:space="preserve">
          <source>Master journal</source>
          <target state="translated">マスタージャーナル</target>
        </trans-unit>
        <trans-unit id="cb9cc1ceef6f81a9f36806b03b083dc9a2408c5e" translate="yes" xml:space="preserve">
          <source>Master journals</source>
          <target state="translated">マスタージャーナル</target>
        </trans-unit>
        <trans-unit id="7b5111bfd1045a8ecdd3554c1e9631c35ec01ef6" translate="yes" xml:space="preserve">
          <source>Matches if both query1 and query2 match.</source>
          <target state="translated">クエリ1とクエリ2の両方が一致した場合にマッチします。</target>
        </trans-unit>
        <trans-unit id="1abd40ea027c30a30c262947ec1298a0d519b4e6" translate="yes" xml:space="preserve">
          <source>Matches if either query1 or query2 match.</source>
          <target state="translated">クエリ1またはクエリ2のいずれかが一致した場合にマッチします。</target>
        </trans-unit>
        <trans-unit id="51cd172796c27ae8bf6aa95066f1e3c65189a939" translate="yes" xml:space="preserve">
          <source>Matches if query1 matches and query2 does not match.</source>
          <target state="translated">クエリ1がマッチし、クエリ2がマッチしない場合にマッチします。</target>
        </trans-unit>
        <trans-unit id="bd5c38104019f7a3a298ccf7253423afa28167b4" translate="yes" xml:space="preserve">
          <source>Matchinfo b flag</source>
          <target state="translated">マッチ情報b旗</target>
        </trans-unit>
        <trans-unit id="c836afd188ddb1668f2e9e6d198ffaad1a60d7a2" translate="yes" xml:space="preserve">
          <source>Matchinfo x flag</source>
          <target state="translated">マッチインフォ×フラグ</target>
        </trans-unit>
        <trans-unit id="1cd52c33bad6e28fab493f91164add2569119727" translate="yes" xml:space="preserve">
          <source>Matchinfo y flag</source>
          <target state="translated">マッチ情報と旗</target>
        </trans-unit>
        <trans-unit id="eba78e6ccaca884931e9772ee282f8ff7b915236" translate="yes" xml:space="preserve">
          <source>Materializations of views and subqueries</source>
          <target state="translated">ビューとサブクエリのマテリアライゼーション</target>
        </trans-unit>
        <trans-unit id="b44a1f3f0332ddaecfe37d45239aca1621b1d815" translate="yes" xml:space="preserve">
          <source>Mathematical operators (+, -, *, /, %, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) interpret both operands as if they were numbers. STRING or BLOB operands automatically convert into REAL or INTEGER values. If the STRING or BLOB looks like a real number (if it has a decimal point or an exponent) or if the value is outside the range that can be represented as a 64-bit signed integer, then it converts to REAL. Otherwise the operand converts to INTEGER. The implied type conversion of mathematical operands is slightly different from &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt; in that string and BLOB values that look like real numbers but have no fractional part are kept as REAL instead of being converted into INTEGER as they would be for &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt;. The conversion from STRING or BLOB into REAL or INTEGER is performed even if it is lossy and irreversible. Some mathematical operators (%, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) expect INTEGER operands. For those operators, REAL operands are converted into INTEGER in the same way as a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to INTEGER&lt;/a&gt;. The &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and | operators always return an INTEGER (or NULL) result, but the % operator returns either INTEGER or REAL (or NULL) depending on the type of its operands. A NULL operand on a mathematical operator yields a NULL result. An operand on a mathematical operator that does not look in any way numeric and is not NULL is converted to 0 or 0.0. Division by zero gives a result of NULL.</source>
          <target state="translated">数学演算子（+、-、*、/、％、&amp;lt;&amp;lt;、&amp;gt;&amp;gt;、＆、|）は、両方のオペランドを数値のように解釈します。 STRINGまたはBLOBオペランドは、自動的にREALまたはINTEGER値に変換されます。 STRINGまたはBLOBが実数のように見える場合（小数点または指数がある場合）、または値が64ビットの符号付き整数として表すことができる範囲外の場合、REALに変換されます。それ以外の場合、オペランドはINTEGERに変換されます。数学的なオペランドの暗黙の型変換は、&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CASTからNUMERIC&lt;/a&gt;にわずかに異なり、その文字列と、実数のように見えるが小数部分がないBLOB値は、CASTからNUMERICの場合のようにINTEGERに変換されるのではなくREALとして保持され&lt;a href=&quot;lang_expr#castexpr&quot;&gt;ます&lt;/a&gt;。 STRINGまたはBLOBからREALまたはINTEGERへの変換は、不可逆的で不可逆的であっても実行されます。一部の数学演算子（％、&amp;lt;&amp;lt;、&amp;gt;&amp;gt;、＆、および|）は、INTEGERオペランドを必要とします。これらの演算子の場合、REALオペランドは&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CASTからINTEGERへの&lt;/a&gt;変換と同じ方法でINTEGERに変換されます。 &amp;lt;&amp;lt;、&amp;gt;&amp;gt;、＆、および|演算子は常にINTEGER（またはNULL）の結果を返しますが、％演算子は、オペランドのタイプに応じてINTEGERまたはREAL（またはNULL）を返します。算術演算子のNULLオペランドは、NULLの結果になります。数値ではなく、NULLでない数学演算子のオペランドは、0または0.0に変換されます。ゼロによる除算はNULLの結果を与えます。</target>
        </trans-unit>
        <trans-unit id="1d9b8da2be0b14b678f29575b8bd5d6d1b4664b6" translate="yes" xml:space="preserve">
          <source>MaxPgcnt</source>
          <target state="translated">MaxPgcnt</target>
        </trans-unit>
        <trans-unit id="6cf7147e1932d9bf8b6d38604abfcfd205a85da8" translate="yes" xml:space="preserve">
          <source>Maximum embedded payload fraction. Must be 64.</source>
          <target state="translated">最大組み込みペイロード率。64でなければなりません。</target>
        </trans-unit>
        <trans-unit id="24d9373f317266755bd6dbb0fc6450a4905171c2" translate="yes" xml:space="preserve">
          <source>Maximum rowid</source>
          <target state="translated">最大行数</target>
        </trans-unit>
        <trans-unit id="5bc432c657fe4144bd45d936698c166acecd18fa" translate="yes" xml:space="preserve">
          <source>Maximum xShmLock index</source>
          <target state="translated">最大 xShmLock インデックス</target>
        </trans-unit>
        <trans-unit id="77e5adb0194b8d8026832696c1f2c7818741ee2e" translate="yes" xml:space="preserve">
          <source>Maxopen parameter</source>
          <target state="translated">マックスオープンパラメータ</target>
        </trans-unit>
        <trans-unit id="0cccb688a9f1ffa766c4517a7aa3af7c04fd578c" translate="yes" xml:space="preserve">
          <source>May you do good and not evil</source>
          <target state="translated">悪を行わず善を行うことができますように</target>
        </trans-unit>
        <trans-unit id="8b1b4d5262b0d017f35623d6ebe39d0b87517497" translate="yes" xml:space="preserve">
          <source>May you find forgiveness for yourself and forgive others</source>
          <target state="translated">自分を許し、人を許すことができますように</target>
        </trans-unit>
        <trans-unit id="580b0f5d2afa3fc028fd1cbe9832972ae188e8d2" translate="yes" xml:space="preserve">
          <source>May you share freely, never taking more than you give.</source>
          <target state="translated">あなたが自由に分かち合い、与える以上のものを取ることがありませんように。</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="4916cdca74bd290a34e18174e1358515f2ca12e0" translate="yes" xml:space="preserve">
          <source>Measure the performance for reading blobs from the database and from individual files using these commands:</source>
          <target state="translated">これらのコマンドを使用して、データベースからのブロブの読み込みと個々のファイルからの読み込みのパフォーマンスを測定します。</target>
        </trans-unit>
        <trans-unit id="32d3f574c379f02e466ab9d634b2afa7cedf3a39" translate="yes" xml:space="preserve">
          <source>Measure write performance by adding the --update option. This causes the blobs are overwritten in place with another random blob of exactly the same size.</source>
          <target state="translated">updateオプションを追加して、書き込みパフォーマンスを測定します。これにより、ブロブは全く同じサイズの別のランダムなブロブで上書きされます。</target>
        </trans-unit>
        <trans-unit id="f8f8ae177706bfa8cf72569452745c1f4cb10ab6" translate="yes" xml:space="preserve">
          <source>Measured using cachegrind on Ubuntu 16.04 on x64 with gcc 5.4.0 and -Os.</source>
          <target state="translated">Ubuntu 16.04,x64,gcc 5.4.0,-Osでcachegrindを使用して測定しました。</target>
        </trans-unit>
        <trans-unit id="b32c8e35e5b4b276295d8f91c2b0f1620f45e186" translate="yes" xml:space="preserve">
          <source>Measurements above were conducted using SQLite version &lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;5594a121bf132a98&lt;/a&gt; from 2017-10-08.</source>
          <target state="translated">上記の測定は、2017-10-08のSQLiteバージョン&lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;5594a121bf132a98&lt;/a&gt;を使用して行われました。</target>
        </trans-unit>
        <trans-unit id="201062f4cfcc7a2c58dc61b839eac4c989004f31" translate="yes" xml:space="preserve">
          <source>Measuring and Reducing CPU Usage in SQLite</source>
          <target state="translated">SQLiteでのCPU使用量の測定と削減</target>
        </trans-unit>
        <trans-unit id="d815eeb251818f42b639c19483653cb9e9676a23" translate="yes" xml:space="preserve">
          <source>MemMax</source>
          <target state="translated">MemMax</target>
        </trans-unit>
        <trans-unit id="57b0394c856fac60e784f92bcfff68951cf81266" translate="yes" xml:space="preserve">
          <source>Memory Allocation Routines</source>
          <target state="translated">メモリ割り当てルーチン</target>
        </trans-unit>
        <trans-unit id="3a30329db6460c4ed15bebe4d427af9052e6678f" translate="yes" xml:space="preserve">
          <source>Memory Allocation Subsystem</source>
          <target state="translated">メモリわりあてサブシステム</target>
        </trans-unit>
        <trans-unit id="f5bd12480983914d8406751d31133ba86381302d" translate="yes" xml:space="preserve">
          <source>Memory Allocator Statistics</source>
          <target state="translated">メモリアロケータの統計</target>
        </trans-unit>
        <trans-unit id="8ee60155b22e766b4de73dc4f683f3ac25fa009b" translate="yes" xml:space="preserve">
          <source>Memory Slot</source>
          <target state="translated">メモリースロット</target>
        </trans-unit>
        <trans-unit id="ea9be83a8f265809341121ab4ff9c58d527a1bdd" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;、...）開始時間オプションと&lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;コンパイル時間オプションの組み合わせを使用すると、メモリアカウンティングが無効になります。</target>
        </trans-unit>
        <trans-unit id="83484b2c23e2c43deda0dd88234486f9158814f3" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;、...）開始時間オプションと&lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;コンパイル時間オプションの組み合わせを使用すると、メモリアカウンティングが無効になります。</target>
        </trans-unit>
        <trans-unit id="c90d2f9e1fbdf5d88900e51c0817d79397425f44" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">SQLiteが&lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0でコンパイルされていない限り、メモリ割り当て統計はデフォルトで有効になっています。この場合、メモリ割り当て統計はデフォルトで無効になっています。</target>
        </trans-unit>
        <trans-unit id="36fecd267945c46262e4527e9008734a419499a2" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">SQLiteが&lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0でコンパイルされていない限り、メモリ割り当て統計はデフォルトで有効になっています。この場合、メモリ割り当て統計はデフォルトで無効になっています。</target>
        </trans-unit>
        <trans-unit id="30cf1b800d03b60f9a295eac5e3ee911eb40a567" translate="yes" xml:space="preserve">
          <source>Memory allocation, caseless string comparison routines, portable text-to-number conversion routines, and other utilities are located in &lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.c&lt;/a&gt;. Symbol tables used by the parser are maintained by hash tables found in &lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;utf.c&lt;/a&gt; source file contains Unicode conversion subroutines. SQLite has its own private implementation of &lt;a href=&quot;printf&quot;&gt;printf()&lt;/a&gt; (with some extensions) in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; and its own pseudo-random number generator (PRNG) in &lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;random.c&lt;/a&gt;.</source>
          <target state="translated">メモリ割り当て、大文字と小文字を区別しない文字列比較ルーチン、移植可能なテキストから数値への変換ルーチン、およびその他のユーティリティは&lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.cにあり&lt;/a&gt;ます。パーサーが使用するシンボルテーブルは、&lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.cにある&lt;/a&gt;ハッシュテーブルによって維持されます。&lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;utf.cの&lt;/a&gt;ソースファイルは、Unicode変換サブルーチンが含まれています。 SQLiteは、&lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.cに&lt;/a&gt;独自の実装の&lt;a href=&quot;printf&quot;&gt;printf（）&lt;/a&gt;（一部拡張あり）を、random.cに独自の疑似乱数ジェネレータ（PRNG）を&lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;実装してい&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="8351f935d7e0b92d4dbd88ff6014fc3cfebc6b06" translate="yes" xml:space="preserve">
          <source>Memory statistics</source>
          <target state="translated">メモリ統計</target>
        </trans-unit>
        <trans-unit id="0b3951c84915f2636f64c4da056f2bbaa63121ac" translate="yes" xml:space="preserve">
          <source>Memory to hold the information returned by &lt;b&gt;sqlite_get_table&lt;/b&gt; is obtained from malloc(). But the calling function should not try to free this information directly. Instead, pass the complete table to &lt;b&gt;sqlite_free_table&lt;/b&gt; when the table is no longer needed. It is safe to call &lt;b&gt;sqlite_free_table&lt;/b&gt; with a NULL pointer such as would be returned if the result set is empty.</source>
          <target state="translated">&lt;b&gt;sqlite_get_table&lt;/b&gt;によって返される情報を保持するメモリは、malloc（）から取得されます。しかし、呼び出し側の関数は、この情報を直接解放しようとするべきではありません。代わりに、テーブルが不要になったときに、テーブル&lt;b&gt;全体&lt;/b&gt;を&lt;b&gt;sqlite_free_table&lt;/b&gt;に渡します。結果セットが空の場合に返されるようなNULLポインタで&lt;b&gt;sqlite_free_table&lt;/b&gt;を呼び出すのは安全です。</target>
        </trans-unit>
        <trans-unit id="0ebf6aa26b7b4fd9c6127be506bafbc4c2292df8" translate="yes" xml:space="preserve">
          <source>Memory-Mapped I/O</source>
          <target state="translated">メモリマップI/O</target>
        </trans-unit>
        <trans-unit id="7640161f9a59fd693f768ecd9272e3177311b46c" translate="yes" xml:space="preserve">
          <source>Memsys4 and memsys6 were experimental memory allocators introduced in around 2007 and subsequently removed from the source tree in around 2008, after it became clear that they added no new value.</source>
          <target state="translated">Memsys4 と memsys6 は 2007 年頃に導入された実験的なメモリアロケータで、その後、新しい価値を与えないことが明らかになったため、2008 年頃にソースツリーから削除されました。</target>
        </trans-unit>
        <trans-unit id="53e5e9eaf00f6f480e84b07b830bf50ed69b3504" translate="yes" xml:space="preserve">
          <source>Merge development changes into the main trunk. Future work toward using a BTree file structure will use a separate CVS source tree. This CVS tree will continue to support the GDBM version of SQLite only.</source>
          <target state="translated">開発の変更点をメインのトランクにマージしました。BTree ファイル構造を使用するための将来の作業では、別の CVS ソースツリーを使用することになります。この CVS ツリーは、SQLite の GDBM バージョンのみをサポートし続けます。</target>
        </trans-unit>
        <trans-unit id="1c69f87311ee49961b7db4c6959bf9e564173753" translate="yes" xml:space="preserve">
          <source>MergePatch can add, modify, or delete elements of a JSON Object, and so for JSON Objects, the json_patch() routine is a generalized replacement for &lt;a href=&quot;json1#jset&quot;&gt;json_set()&lt;/a&gt; and &lt;a href=&quot;json1#jrm&quot;&gt;json_remove()&lt;/a&gt;. However, MergePatch treats JSON Array objects as atomic. MergePatch cannot append to an Array nor modify individual elements of an Array. It can only insert, replace, or delete the whole Array as a single unit. Hence, json_patch() is not as useful when dealing with JSON that includes Arrays, especially Arrays with lots of substructure.</source>
          <target state="translated">MergePatchは、JSONオブジェクトの要素を追加、変更、または削除できるため、JSONオブジェクトの場合、json_patch（）ルーチンは、&lt;a href=&quot;json1#jset&quot;&gt;json_set（）&lt;/a&gt;および&lt;a href=&quot;json1#jrm&quot;&gt;json_remove（）の&lt;/a&gt;汎用的な置き換えです。ただし、MergePatchはJSON配列オブジェクトをアトミックとして扱います。MergePatchは、配列に追加したり、配列の個々の要素を変更したりすることはできません。アレイ全体を1つのユニットとして挿入、置換、または削除することしかできません。したがって、json_patch（）は、配列、特に多くの部分構造を持つ配列を含むJSONを処理する場合にはあまり役に立ちません。</target>
        </trans-unit>
        <trans-unit id="b34856a8252222662370c82e139676a40460db4d" translate="yes" xml:space="preserve">
          <source>Merged the &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; extension into trunk.</source>
          <target state="translated">&lt;a href=&quot;sessionintro&quot;&gt;セッション&lt;/a&gt;拡張をトランクにマージしました。</target>
        </trans-unit>
        <trans-unit id="dbaecd82c952801d0bb82c4bd7a41de66b9fda44" translate="yes" xml:space="preserve">
          <source>Metadata is returned by writing to the memory locations passed as the 5th and subsequent parameters to this function. Any of these arguments may be NULL, in which case the corresponding element of metadata is omitted.</source>
          <target state="translated">メタデータは、この関数の5番目以降の引数として渡されたメモリの位置に書き込むことで返されます。これらの引数のいずれかがNULLであっても構いませんが、その場合はメタデータの対応する要素は省略されます。</target>
        </trans-unit>
        <trans-unit id="4d3732872bb2a9906cc1153aeb2590dd048c19aa" translate="yes" xml:space="preserve">
          <source>Method (2) offers a midpoint between (1) and (3). Using this method, a query such as '1s*' will match documents that contain the literal token &quot;1st&quot;, but not &quot;first&quot; (assuming the tokenizer is not able to provide synonyms for prefixes). However, a non-prefix query like '1st' will match against &quot;1st&quot; and &quot;first&quot;. This method does not require extra disk space, as no extra entries are added to the FTS index. On the other hand, it may require more CPU cycles to run MATCH queries, as separate queries of the FTS index are required for each synonym.</source>
          <target state="translated">メソッド(2)は、(1)と(3)の中間点を提供します。このメソッドを使用すると、'1s*'のようなクエリは、リテラルトークン &quot;1st &quot;を含むドキュメントにはマッチしますが、&quot;first &quot;にはマッチしません(トークナイザーが接頭辞の同義語を提供できないことを前提としています)。しかし、'1st'のようなプレフィックスではないクエリは、&quot;1st &quot;と &quot;first &quot;に対してマッチします。この方法では、FTSインデックスに余分なエントリが追加されないので、余分なディスクスペースを必要としません。一方で、FTSインデックスの個別のクエリが各同義語に対して必要となるため、MATCHクエリの実行にはより多くのCPUサイクルが必要となるかもしれません。</target>
        </trans-unit>
        <trans-unit id="1df213a45649b1f66258f5768182bafcd559f0b9" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">メソッド：&lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b9983b06e527d46d817373bc15d13089f4d3e12" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">メソッド：&lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="547fb3fd92f4ba766d2b81080903dd2fa70ddd7a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">メソッド：&lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ba8e151eaa184a6fb4bcf2ae01f52e3682b9b04" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">メソッド：&lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;、&lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;、&lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;、&lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05bb53e8fd80fd00914dd4034f12bb335994738a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">メソッド：&lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp（）&lt;/a&gt;、&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;、&lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80b86f6f0bb9183c80c83fe634331b034c5a3b6c" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">メソッド：&lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add（）&lt;/a&gt;、&lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91126b8550d89c2cabd56ad5c8ea6415436ef4e7" translate="yes" xml:space="preserve">
          <source>Millions and millions of test cases</source>
          <target state="translated">数百万、数百万のテストケース</target>
        </trans-unit>
        <trans-unit id="8cb901663cd153748076b7a4eed655ac9c9ceb63" translate="yes" xml:space="preserve">
          <source>Minimum embedded payload fraction. Must be 32.</source>
          <target state="translated">埋込ペイロードの最小割合。32でなければなりません。</target>
        </trans-unit>
        <trans-unit id="9f5a0ef3646738848b65efb74e98db2b2c5a359b" translate="yes" xml:space="preserve">
          <source>Minimum rowid</source>
          <target state="translated">最小行数</target>
        </trans-unit>
        <trans-unit id="62a01943e842ea4e97ec6b470d86e59a45ec37a1" translate="yes" xml:space="preserve">
          <source>Minor revisions to the website.</source>
          <target state="translated">ホームページの軽微な修正。</target>
        </trans-unit>
        <trans-unit id="e2f772b3f3e4226648620e3b2d22fc9e06b7af3b" translate="yes" xml:space="preserve">
          <source>Minor syntactic changes to support a wider variety of compilers.</source>
          <target state="translated">より多くのコンパイラをサポートするためのマイナーな構文の変更。</target>
        </trans-unit>
        <trans-unit id="a207d914072a9004f7af9edb9092f93397750bdb" translate="yes" xml:space="preserve">
          <source>Minor tweaks to other code to make it run a little faster.</source>
          <target state="translated">他のコードを少し速く実行するために、他のコードを微調整しました。</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="b80fca6a605a77935ff5f5e3122df5de2dfd1555" translate="yes" xml:space="preserve">
          <source>Miscellaneous &lt;a href=&quot;cpu#microopt&quot;&gt;microoptimizations&lt;/a&gt; reduce CPU usage by about 2.1%.</source>
          <target state="translated">その他の&lt;a href=&quot;cpu#microopt&quot;&gt;マイクロ最適化&lt;/a&gt;により、CPU使用率が約2.1％削減されます。</target>
        </trans-unit>
        <trans-unit id="28c8a44394b5bc456bad4c873373e406d652fe87" translate="yes" xml:space="preserve">
          <source>Miscellaneous code size optimizations and bug fixes</source>
          <target state="translated">その他のコードサイズの最適化とバグ修正</target>
        </trans-unit>
        <trans-unit id="bbb81db24ef06a2153135306601290fda608c2da" translate="yes" xml:space="preserve">
          <source>Miscellaneous documentation enhancements.</source>
          <target state="translated">その他のドキュメントの強化。</target>
        </trans-unit>
        <trans-unit id="98990a8e0a243a1fdf56c721a0da9558936ac95e" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations reduce CPU usage by more than 7% on common workloads. Most optimization in this release has been on the front-end (&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;).</source>
          <target state="translated">その他のマイクロ最適化により、一般的なワークロードでのCPU使用率が7％以上削減されます。このリリースのほとんどの最適化はフロントエンドで行われました（&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fbdfeb6f538d5f7f87b9990239ba0793588dd6eb" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations result in 22.3% more work for the same number of CPU cycles relative to the previous release. SQLite now runs twice as fast as &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; and three times as fast as &lt;a href=&quot;#version_3_3_9&quot;&gt;version 3.3.9&lt;/a&gt;. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 14.04 x64 with gcc 4.8.2 and -Os. Your performance may vary.)</source>
          <target state="translated">その他のマイクロ最適化により、以前のリリースと比較して、同じ数のCPUサイクルで22.3％多い作業が発生します。SQLiteは、&lt;a href=&quot;#version_3_8_0&quot;&gt;バージョン3.8.0の&lt;/a&gt; 2倍、&lt;a href=&quot;#version_3_3_9&quot;&gt;バージョン3.3.9の&lt;/a&gt; 3倍の速度で実行されます。（使用して測定&lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrindを&lt;/a&gt;上&lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.cの&lt;/a&gt; GCC 4.8.2と-OsとUbuntuの14.04のx64上のワークロード。あなたのパフォーマンスは変更になる場合があります。）</target>
        </trans-unit>
        <trans-unit id="fc459de1c05b709bda425ad3c5816738720eebc5" translate="yes" xml:space="preserve">
          <source>Miscellaneous minor bug fixes</source>
          <target state="translated">その他のマイナーなバグ修正</target>
        </trans-unit>
        <trans-unit id="44d1c5c9aa54a9db91e7e7fe347ac18190d724ed" translate="yes" xml:space="preserve">
          <source>Miscellaneous optimizations result in a 2% reduction in &lt;a href=&quot;cpu&quot;&gt;CPU cycles used&lt;/a&gt;.</source>
          <target state="translated">その他の最適化により、&lt;a href=&quot;cpu&quot;&gt;使用されるCPUサイクルが&lt;/a&gt; 2％削減されます。</target>
        </trans-unit>
        <trans-unit id="f1774acabb62d5801f41470f6cd189b2c0aaaf3c" translate="yes" xml:space="preserve">
          <source>Miscellaneous performance enhancements</source>
          <target state="translated">その他の性能強化</target>
        </trans-unit>
        <trans-unit id="276e26893215e7c8d37e726040961fa631182ebb" translate="yes" xml:space="preserve">
          <source>Miscellaneous problem words such as &quot;debt&quot;, &quot;tsetse&quot;, &quot;Nguyen&quot;, &quot;Van Nuyes&quot;.</source>
          <target state="translated">借金」「ツェツェ」「グエン」「ヴァンヌイ」などの雑多な問題語</target>
        </trans-unit>
        <trans-unit id="4f0711bb69728ffde416a549e0f91f702e273516" translate="yes" xml:space="preserve">
          <source>Misformatted records</source>
          <target state="translated">誤ったフォーマットのレコード</target>
        </trans-unit>
        <trans-unit id="0c46987b5699d45998eb4a1f03a81d222b78e342" translate="yes" xml:space="preserve">
          <source>Missing callback</source>
          <target state="translated">コールバックの欠落</target>
        </trans-unit>
        <trans-unit id="55fd1e5df760c82f67c5509ea619f439d18e5b37" translate="yes" xml:space="preserve">
          <source>Missing or surplus index entries</source>
          <target state="translated">欠落または余剰インデックス項目</target>
        </trans-unit>
        <trans-unit id="96732b61a8d377ada7b914c38aba1cf0d28297dd" translate="yes" xml:space="preserve">
          <source>Missing pages</source>
          <target state="translated">欠落しているページ</target>
        </trans-unit>
        <trans-unit id="a1570b7a7267e412717981829df93815ef1f5214" translate="yes" xml:space="preserve">
          <source>Modern filesystems operate faster when disk accesses are sequential. Hence, SQLite will run faster if the content of the database file is on sequential pages. To find out what fraction of the pages in a database are sequential (and thus obtain a measurement that might be useful in determining when to &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;), run a query like the following:</source>
          <target state="translated">最新のファイルシステムは、ディスクアクセスがシーケンシャルである場合、より高速に動作します。したがって、データベースファイルのコンテンツが順次ページ上にある場合、SQLiteはより高速に実行されます。データベース内のページのどの部分がシーケンシャルであるかを見つける（したがって、&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;を行うタイミングを決定するのに役立つ測定値を取得する）には、次のようなクエリを実行します。</target>
        </trans-unit>
        <trans-unit id="213d5e141cc4f1fbdb215e4e1d09c9f135e23841" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;c3ref/vfs&quot;&gt;virtual file system&lt;/a&gt; interface to support a wider range of embedded systems. See &lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt; for additional information. *** Potentially incompatible change ***</source>
          <target state="translated">幅広い組み込みシステムをサポートするための&lt;a href=&quot;c3ref/vfs&quot;&gt;仮想ファイルシステム&lt;/a&gt;インターフェイスの変更。詳細については、&lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt;を参照してください。***互換性がない可能性のある変更***</target>
        </trans-unit>
        <trans-unit id="846a3f594ccb25f4d8b90bf39076621c7a3da386" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; so that the parser tables are 4 times smaller.</source>
          <target state="translated">パーサーテーブルが4倍小さくなるように、&lt;a href=&quot;lemon&quot;&gt;レモンパーサージェネレーターを&lt;/a&gt;変更しました。</target>
        </trans-unit>
        <trans-unit id="a373b9c05e3506597302158ddcc81e7b79ce6310" translate="yes" xml:space="preserve">
          <source>Modified &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH&lt;/a&gt; to remove the &quot;+4&quot; magic number in the buffer size computation.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;および&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH&lt;/a&gt;を変更して、バッファサイズの計算で「+4」のマジックナンバーを削除しました。</target>
        </trans-unit>
        <trans-unit id="7ae047108ffb132cb41d3775cac528b7c36bd9c6" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to print the schema for the built-in SQLITE_MASTER table, if explicitly requested.</source>
          <target state="translated">明示的に要求された場合、組み込みSQLITE_MASTERテーブルのスキーマを出力するように&lt;b&gt;sqlite&lt;/b&gt;シェルプログラムを変更しました。</target>
        </trans-unit>
        <trans-unit id="64b762eca0515a688c77ad3f10cd0b574a4463f3" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to use the new interface routines.</source>
          <target state="translated">新しいインターフェイスルーチンを使用するように&lt;b&gt;sqlite&lt;/b&gt;シェルプログラムを変更しました。</target>
        </trans-unit>
        <trans-unit id="9bea3abf3349ced7a2bd684045cab38caa6bf680" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to make use of the new sqlite_get_table() API in order to print a list of tables in multiple columns, similar to the way &quot;ls&quot; prints filenames.</source>
          <target state="translated">&quot;ls&quot;がファイル名を印刷する方法と同様に、複数の列でテーブルのリストを印刷するために、新しいsqlite_get_table（）APIを使用するように&lt;b&gt;sqlite&lt;/b&gt;シェルを変更しました。</target>
        </trans-unit>
        <trans-unit id="d9d09adf1be852d2030f454ddcb0fb1bbde85e4b" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to print a semicolon at the end of each CREATE statement in the output of the &quot;.schema&quot; command.</source>
          <target state="translated">&quot;.schema&quot;コマンドの出力で各CREATEステートメントの最後にセミコロンを出力するように&lt;b&gt;sqlite&lt;/b&gt;シェルを変更しました。</target>
        </trans-unit>
        <trans-unit id="cecf75f0a6c4e051f8158a879b4378a1d3e737c4" translate="yes" xml:space="preserve">
          <source>Modified the B-Tree and Pager modules so that disk pages that do not contain real data (free pages) are not journaled and are not written from memory back to the disk when they change. This does not impact database integrity, since the pages contain no real data, but it does make large INSERT operations about 2.5 times faster and large DELETEs about 5 times faster.</source>
          <target state="translated">B-Tree モジュールと Pager モジュールを変更し、実データを含まないディスクページ(フリーページ)はジャーナル化されず、変更されてもメモリからディスクに書き戻されないようにしました。これは、ページには実データが含まれていないので、データベースの整合性には影響しませんが、大規模な INSERT 操作が約 2.5 倍、大規模な DELETE が約 5 倍速くなります。</target>
        </trans-unit>
        <trans-unit id="2c4d4de8cb2205ec2b07c88e0fe421ab99dc0aaa" translate="yes" xml:space="preserve">
          <source>Modified the journal file format to make it more resistant to corruption that can occur after an OS crash or power failure.</source>
          <target state="translated">ジャーナルファイル形式を変更し、OSのクラッシュや停電後に発生する破損に強くなるようにしました。</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="2d258a9a354e69d26a5737aed0d98ba4a12d4ab3" translate="yes" xml:space="preserve">
          <source>Modify the TCL interface to use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;.</source>
          <target state="translated">TCLインターフェイスを変更して、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="9c186ff83bfc4ba49c92b1876d399ba40e64a0cc" translate="yes" xml:space="preserve">
          <source>Modify the test scripts to identify tests that depend on system load and processor speed and to warn the user that a failure of one of those (rare) tests does not necessarily mean the library is malfunctioning. No changes to code.</source>
          <target state="translated">システムの負荷とプロセッサ速度に依存するテストを識別し、それらの (まれな)テストの 1 つが失敗したからといって、ライブラリが誤動作しているとは限らないことをユーザーに警告するために、テストスクリプトを変更します。コードに変更はありません。</target>
        </trans-unit>
        <trans-unit id="ef40b73dad75552add2180adc162c800be16bf41" translate="yes" xml:space="preserve">
          <source>Modifying the contents of a database page.</source>
          <target state="translated">データベースページの内容を変更する</target>
        </trans-unit>
        <trans-unit id="56d9419099fd345280bf9a9122ad284109000f7d" translate="yes" xml:space="preserve">
          <source>Modifying, Adding or Truncating a Database Page</source>
          <target state="translated">データベースページの変更、追加、または切り捨て</target>
        </trans-unit>
        <trans-unit id="d9ae0b87be39aed320fa35b9e4b820b36d71a71f" translate="yes" xml:space="preserve">
          <source>More aggressive &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</source>
          <target state="translated">より積極的な&lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="150e84142afe50eae5e55924e9aafb441ae8328b" translate="yes" xml:space="preserve">
          <source>More aggressive optimization of the AND operator when one side or the other is always false.</source>
          <target state="translated">片方またはもう片方が常に偽である場合のAND演算子のより積極的な最適化。</target>
        </trans-unit>
        <trans-unit id="4dccd541fa7b33732e530432dc181f83dcc6ba6e" translate="yes" xml:space="preserve">
          <source>More complex queries may or may not be able to employ query flattening to avoid the temporary table. Whether or not the query can be flattened depends on such factors as whether or not the subquery or outer query contain aggregate functions, ORDER BY or GROUP BY clauses, LIMIT clauses, and so forth. The rules for when a query can and cannot be flattened are very complex and are beyond the scope of this document.</source>
          <target state="translated">より複雑なクエリでは、一時テーブルを避けるためにクエリの平坦化を採用できる場合とできない場合があります。クエリを平坦化できるかどうかは、副問い合わせや外部問い合わせに集約関数、ORDER BY句やGROUP BY句、LIMIT句などが含まれているかどうかに依存します。問い合わせが平坦化できる場合とできない場合のルールは非常に複雑であり、このドキュメントの範囲を超えています。</target>
        </trans-unit>
        <trans-unit id="0e965ef66116c7e835a08b23bc0aea20069b16ec" translate="yes" xml:space="preserve">
          <source>More efficient encoding of boolean values resulting in smaller database files</source>
          <target state="translated">より効率的なブーリアン値のエンコーディングにより、データベースファイルが小さくなります。</target>
        </trans-unit>
        <trans-unit id="bc15bc11932b9e3bb7aa3bd3cd6dd3273dc66921" translate="yes" xml:space="preserve">
          <source>More efficient handling of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, especially in cases where the application defines hundreds or thousands of custom functions.</source>
          <target state="translated">特にアプリケーションが数百または数千のカスタム関数を定義する場合に、アプリケーション&lt;a href=&quot;appfunc&quot;&gt;定義のSQL関数&lt;/a&gt;をより効率的に処理します。</target>
        </trans-unit>
        <trans-unit id="8a3c60573ba6ac75355060c30752d85d7e4a4ea7" translate="yes" xml:space="preserve">
          <source>More efficient handling of &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;, especially in cases where the application defines hundreds or thousands of custom functions.</source>
          <target state="translated">特にアプリケーションが数百または数千のカスタム関数を定義する場合、アプリケーション&lt;a href=&quot;c3ref/create_function&quot;&gt;定義のSQL関数の&lt;/a&gt;より効率的な処理。</target>
        </trans-unit>
        <trans-unit id="bbf641e990dbd768fc579b21dbc73f3e38164565" translate="yes" xml:space="preserve">
          <source>More efficient implementation of sqliteFileExists() under Windows. (by Joel Luscy)</source>
          <target state="translated">WindowsでのsqliteFileExists()のより効率的な実装。(Joel Luscyによる)</target>
        </trans-unit>
        <trans-unit id="da802536bedcdb71b26438d22c88c54625f47a34" translate="yes" xml:space="preserve">
          <source>More robust handling of out-of-memory errors.</source>
          <target state="translated">メモリ切れエラーの処理がより強固になりました。</target>
        </trans-unit>
        <trans-unit id="f0bbe298877a69ce96299f0684d775b43d33f438" translate="yes" xml:space="preserve">
          <source>More suggestions...</source>
          <target state="translated">他にも提案が...</target>
        </trans-unit>
        <trans-unit id="40a15bddc2f46eb54c50912ec8296652a2a161bf" translate="yes" xml:space="preserve">
          <source>More than one NEAR operator may appear in a single query. In this case each pair of terms or phrases separated by a NEAR operator must appear within the specified proximity of each other in the document. Using the same table and data as in the block of examples above:</source>
          <target state="translated">1 つのクエリに複数の NEAR 演算子が出現することがあります。この場合、near演算子で区切られた用語または語句の各ペアは、文書内で互いに指定された近接度内に出現しなければなりません。上記の例のブロックと同じテーブルとデータを使用します。</target>
        </trans-unit>
        <trans-unit id="759136a5c089af122dabc1e0771753f48776ccec" translate="yes" xml:space="preserve">
          <source>Most CVEs written about SQLite assume that the attacker is able to run arbitrary SQL scripts in SQLite. In most applications, this means that there must first be an SQL Injection vulnerability that allows the attacker to inject the malicious SQL.</source>
          <target state="translated">SQLite について書かれたほとんどの CVE は、攻撃者が SQLite 内で任意の SQL スクリプトを実行できることを前提としています。ほとんどのアプリケーションでは、これは攻撃者が悪意のある SQL を注入できる SQL インジェクションの脆弱性がまず存在しなければならないことを意味します。</target>
        </trans-unit>
        <trans-unit id="e8eaec9acde05ea65cc7e78b52370752d8ff824b" translate="yes" xml:space="preserve">
          <source>Most R*Tree queries use a depth-first search. This is accomplished by setting the rScore equal to iLevel. A depth-first search is usually preferred since it minimizes the number of elements in the priority queue, which reduces memory requirements and speeds processing. However, some application may prefer a breadth-first search, which can be accomplished by setting rScore to mxLevel-iLevel. By creating more complex formulas for rScore, applications can exercise detailed control over the order in which subtree are searched and leaf R*Tree entries are returned. For example, in an application with many millions of R*Tree entries, the rScore might be arranged so that the largest or most significant entries are returned first, allowing the application to display the most important information quickly, and filling in smaller and less important details as they become available.</source>
          <target state="translated">ほとんどのR*Treeクエリは深度優先検索を使用します。これは、rScoreをiLevelと等しく設定することで実現されます。深さ優先検索は、優先度キュー内の要素数を最小限に抑えることができるため、通常は優先度優先検索が好まれます。しかし、アプリケーションによっては、rScore を mxLevel-iLevel に設定することで実現できる、幅優先検索を好む場合もあります。rScore のためにより複雑な式を作成することで、アプリケーションは、サブツリーが検索され、リーフ R*Tree エントリが返される順序を詳細に制御することができます。例えば、何百万もの R*Tree エントリを持つアプリケーションでは、最大または最も重要なエントリが最初に返されるように rScore を配置することで、アプリケーションは最も重要な情報を素早く表示し、利用可能になるにつれて小さくて重要ではない詳細を埋めることができます。</target>
        </trans-unit>
        <trans-unit id="0b7d92086a8e46f293a7dca57cb6a5c138416054" translate="yes" xml:space="preserve">
          <source>Most SQL database engines (every SQL database engine other than SQLite, as far as we know) uses static, rigid typing. With static typing, the datatype of a value is determined by its container - the particular column in which the value is stored.</source>
          <target state="translated">ほとんどのSQLデータベースエンジン(私たちが知る限り、SQLite以外のすべてのSQLデータベースエンジン)は、静的な型付けを使用しています。静的型付けでは、値のデータ型はコンテナ、つまり値が格納されている特定のカラムによって決定されます。</target>
        </trans-unit>
        <trans-unit id="0b21de15eb7e27a08d9b4ec057ceb748bbaa22cd" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one known to this author that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">ほとんどの SQL データベースエンジンはクライアント/サーバベースです。サーバーレスの中でも、複数のアプリケーションが同時に同じデータベースにアクセスできるのはSQLiteだけです。</target>
        </trans-unit>
        <trans-unit id="27297778565294594247653539b897aca8f2a9fb" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one that this author knows of that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">ほとんどの SQL データベースエンジンはクライアント/サーバーベースです。サーバーレスの中でも、複数のアプリケーションが同時に同じデータベースにアクセスできるのは、この著者が知っている中ではSQLiteだけです。</target>
        </trans-unit>
        <trans-unit id="260ad8dfcdd6cee164826174f5ff18a6d6796783" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are implemented as a separate server process. Programs that want to access the database communicate with the server using some kind of interprocess communication (typically TCP/IP) to send requests to the server and to receive back results. SQLite does not work this way. With SQLite, the process that wants to access the database reads and writes directly from the database files on disk. There is no intermediary server process.</source>
          <target state="translated">ほとんどのSQLデータベースエンジンは、独立したサーバープロセスとして実装されています。データベースにアクセスしたいプログラムは、ある種のプロセス間通信(一般的にはTCP/IP)を使用してサーバーと通信し、サーバーにリクエストを送信して結果を受信します。SQLiteでは、このようには動作しません。SQLiteでは、データベースにアクセスしようとするプロセスは、ディスク上のデータベースファイルから直接読み書きを行います。中間のサーバープロセスはありません。</target>
        </trans-unit>
        <trans-unit id="e11debe28c45aae3eb5d59593787d087cef00a39" translate="yes" xml:space="preserve">
          <source>Most SQL database engines store the schema already parsed into various system tables. On those database engines, ALTER TABLE merely has to make modifications to the corresponding system tables.</source>
          <target state="translated">ほとんどのSQLデータベースエンジンは、すでに解析されたスキーマを様々なシステムテーブルに保存しています。これらのデータベースエンジンでは、ALTER TABLEは対応するシステムテーブルに変更を加えるだけです。</target>
        </trans-unit>
        <trans-unit id="c8146f85b00a04238b33c2841ef39833177b149b" translate="yes" xml:space="preserve">
          <source>Most SQL database engines use static typing. A datatype is associated with each column in a table and only values of that particular datatype are allowed to be stored in that column. SQLite relaxes this restriction by using manifest typing. In manifest typing, the datatype is a property of the value itself, not of the column in which the value is stored. SQLite thus allows the user to store any value of any datatype into any column regardless of the declared type of that column. (There are some exceptions to this rule: An INTEGER PRIMARY KEY column may only store integers. And SQLite attempts to coerce values into the declared datatype of the column when it can.)</source>
          <target state="translated">ほとんどのSQLデータベースエンジンは静的型付けを使用しています。データ型はテーブルの各列に関連付けられており、その列にはその特定のデータ型の値しか格納できません。SQLite では、マニフェスト型付けを使用することでこの制限を緩和しています。マニフェスト型付けでは、データ型は値自体のプロパティであり、値が格納されている列のプロパティではありません。このため、SQLite では、任意のデータ型の値を、そのカラムの宣言された型に関係なく、任意のカラムに格納することができます。(この規則にはいくつかの例外があります。INTEGER PRIMARY KEY カラムは整数のみを格納することができます。また、SQLiteは可能な場合には、そのカラムの宣言されたデータ型に値を強制的に格納しようとします)。</target>
        </trans-unit>
        <trans-unit id="725952f518d7037ff04756bd99d602eae557b1ce" translate="yes" xml:space="preserve">
          <source>Most application formats fit into one of these three categories:</source>
          <target state="translated">ほとんどのアプリケーションフォーマットは、これらの3つのカテゴリのいずれかに当てはまります。</target>
        </trans-unit>
        <trans-unit id="d19cf0ebd0035eff768792dfdb24fc34ef35cd23" translate="yes" xml:space="preserve">
          <source>Most applications can use SQLite without having to worry about bugs in obscure SQL inputs. If the application controls the SQL, and the application is not deliberately trying to break SQLite, then everything should just work. It is not necessary to have the latest patched version of SQLite. Any older version should work just fine.</source>
          <target state="translated">ほとんどのアプリケーションは、不明瞭な SQL 入力のバグを心配することなく SQLite を使用することができます。アプリケーションがSQLを制御していて、アプリケーションが意図的にSQLiteを壊そうとしていなければ、すべてがうまくいくはずです。SQLite の最新のパッチが適用されたバージョンを持っている必要はありません。古いバージョンでも問題なく動作するはずです。</target>
        </trans-unit>
        <trans-unit id="ce502bced488a9855f9633bf314ed3f557c5599e" translate="yes" xml:space="preserve">
          <source>Most applications will only use the session module functionality described in the previous section. However, the following additional functionality is available for the use and manipulation of changeset and patchset blobs:</source>
          <target state="translated">ほとんどのアプリケーションでは、前のセクションで説明したセッションモジュールの機能のみを使用します。しかし、チェンジセットとパッチセットのブロブの使用と操作には、以下の追加機能が利用できます。</target>
        </trans-unit>
        <trans-unit id="cd513c058fc14329a86bc7561ce2383e9150f5ca" translate="yes" xml:space="preserve">
          <source>Most applications work great with SQLite in its default configuration and with no special compile-time configuration. Most developers should be able to completely ignore this document and simply build SQLite from &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt; without any special knowledge and without taking any special actions.</source>
          <target state="translated">ほとんどのアプリケーションは、デフォルトの構成でSQLiteを使用してうまく機能し、特別なコンパイル時の構成は必要ありません。ほとんどの開発者は、このドキュメントを完全に無視し、特別な知識や特別なアクションを実行することなく&lt;a href=&quot;amalgamation&quot;&gt;、統合&lt;/a&gt;からSQLiteを簡単に構築できます。</target>
        </trans-unit>
        <trans-unit id="635fff5a9d997771ed833778dcd946f9fa076040" translate="yes" xml:space="preserve">
          <source>Most builds also use the system memory allocation routines:</source>
          <target state="translated">ほとんどのビルドでは、システムメモリ割り当てルーチンも使用しています。</target>
        </trans-unit>
        <trans-unit id="c757f57c7c0fc6a3a16a4ba481be29df77f7ba0d" translate="yes" xml:space="preserve">
          <source>Most built-in window functions ignore the frame-spec, the exceptions being first_value(), last_value() and nth_value(). It is a syntax error to specify a FILTER clause as part of a built-in window function invocation.</source>
          <target state="translated">ほとんどの組み込みウィンドウ関数はフレーム仕様を無視しますが、例外は first_value()、last_value()、nth_value()です。ビルトインウィンドウ関数の呼び出しの一部としてFILTER句を指定するのは構文エラーです。</target>
        </trans-unit>
        <trans-unit id="91aff38100948ec7606e7b9be6940203c42b637c" translate="yes" xml:space="preserve">
          <source>Most memory statistics are global, and therefore the tracking of statistics must be serialized with a mutex. Statistics are turned on by default, but an option exists to disable them. By disabling memory statistics, SQLite avoids entering and leaving a mutex on each memory allocation and deallocation. That savings can be noticeable on systems where mutex operations are expensive. To disable memory statistics, the following interface is used at start-time:</source>
          <target state="translated">ほとんどのメモリ統計情報はグローバルであるため、統計情報の追跡はミューテックスでシリアル化されなければなりません。統計情報はデフォルトでオンになっていますが、無効にするオプションもあります。メモリ統計情報を無効にすることで、SQLiteはメモリの割り当てや解放のたびにミューテックスを入力したり残したりする必要がなくなります。この節約は、ミューテックス処理が高価なシステムでは顕著です。メモリ統計情報を無効にするには、以下のインターフェイスを起動時に使用します。</target>
        </trans-unit>
        <trans-unit id="3ddc29325f5f8b33e852a6ad2b01d9c1a5b27979" translate="yes" xml:space="preserve">
          <source>Most object references may only resolve to a specific type of object (for example a reference that is part of a DROP TABLE statement may only resolve to a table object, not an index, trigger or view). However in some contexts (e.g. &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;) an object reference may be resolve to more than one type of object. When searching database schemas for a named object, objects of types that cannot be used in the context of the reference are always ignored.</source>
          <target state="translated">ほとんどのオブジェクト参照は、特定のタイプのオブジェクトにのみ解決できます（たとえば、DROP TABLEステートメントの一部である参照は、インデックス、トリガー、またはビューではなく、テーブルオブジェクトにのみ解決できます）。ただし、コンテキストによっては（&lt;a href=&quot;lang_reindex&quot;&gt;REINDEXなど&lt;/a&gt;）、オブジェクト参照が複数のタイプのオブジェクトに解決される場合があります。名前付きオブジェクトのデータベーススキーマを検索する場合、参照のコンテキストで使用できないタイプのオブジェクトは常に無視されます。</target>
        </trans-unit>
        <trans-unit id="1f85923bce6297c36b3c44bb82e688cbd09f35ee" translate="yes" xml:space="preserve">
          <source>Most of the code in the SQLite source tree is devoted purely to &lt;a href=&quot;testing&quot;&gt;testing and verification&lt;/a&gt;. Reliability is important to SQLite. Among the tasks of the test infrastructure is to ensure that SQLite does not misuse dynamically allocated memory, that SQLite does not leak memory, and that SQLite responds correctly to a dynamic memory allocation failure.</source>
          <target state="translated">SQLiteソースツリーのコードのほとんどは、純粋に&lt;a href=&quot;testing&quot;&gt;テストと検証に&lt;/a&gt;充てられています。信頼性はSQLiteにとって重要です。テストインフラストラクチャのタスクの1つは、SQLiteが動的に割り当てられたメモリを誤用しないこと、SQLiteがメモリをリークしないこと、SQLiteが動的メモリ割り当ての失敗に正しく応答することを確認することです。</target>
        </trans-unit>
        <trans-unit id="4ea1351b2e34fd10311e1e13ffcc8b793141d24f" translate="yes" xml:space="preserve">
          <source>Most of the time, sqlite3 just reads lines of input and passes them on to the SQLite library for execution. But input lines that begin with a dot (&quot;.&quot;) are intercepted and interpreted by the sqlite3 program itself. These &quot;dot commands&quot; are typically used to change the output format of queries, or to execute certain prepackaged query statements. There were originally just a few dot commands, but over the years many new features have accumulated so that today there over 60.</source>
          <target state="translated">ほとんどの場合、sqlite3は入力行を読み込んでSQLiteライブラリに渡して実行します。しかし、ドット(&quot;.&quot;)で始まる入力行は、sqlite3プログラム自身によって傍受され、解釈されます。これらの &quot;ドットコマンド &quot;は通常、クエリの出力形式を変更したり、パッケージ化されたクエリ文を実行したりするために使用されます。元々ドットコマンドは数個しかありませんでしたが、長年にわたって多くの新機能が蓄積され、今日では60個以上になりました。</target>
        </trans-unit>
        <trans-unit id="8140e633bb506b56ea3ecec29c87f47b39a7e315" translate="yes" xml:space="preserve">
          <source>Most of the time, the query planner in SQLite does a good job. However, the query planner needs indices to work with. These indices must normally be added by programmers. Rarely, the query planner AI will make a suboptimal algorithm choice. In those cases, programmers may want to provide additional hints to help the query planner do a better job.</source>
          <target state="translated">ほとんどの場合、SQLite のクエリプランナは良い仕事をしてくれます。しかし、クエリプランナが動作するためにはインデックスが必要です。これらのインデックスは通常、プログラマが追加しなければなりません。まれに、クエリプランナのAIが最適でないアルゴリズムを選択することがあります。そのような場合には、プログラマはクエリプランナがより良い仕事をするのを助けるために、追加のヒントを提供したいと思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="4d637cb6d91465469dba952401dcd3c4590d5c67" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines allocated a fixed amount of disk space for each row in most tables. They play special tricks for handling BLOBs and CLOBs which can be of wildly varying length. But for most tables, if you declare a column to be a VARCHAR(100) then the database engine will allocate 100 bytes of disk space regardless of how much information you actually store in that column.</source>
          <target state="translated">他のほとんどの SQL データベースエンジンは、ほとんどのテーブルの各行に一定量のディスク容量を割り当てています。これらのエンジンは、長さの異なる BLOB や CLOB を扱うために特別な仕掛けをしています。しかし、ほとんどのテーブルでは、ある列をVARCHAR(100)と宣言すると、その列に実際にどれだけの情報が格納されているかに関わらず、データベースエンジンは100バイトのディスク領域を割り当てます。</target>
        </trans-unit>
        <trans-unit id="b52c62ddb6e76f10df4280114ef18bdd833e392c" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines are much larger than this. IBM boasts that its recently released CloudScape database engine is &quot;only&quot; a 2MiB jar file - an order of magnitude larger than SQLite even after it is compressed! Firebird boasts that its client-side library is only 350KiB. That's as big as SQLite and does not even contain the database engine. The Berkeley DB library from Oracle is 450KiB and it omits SQL support, providing the programmer with only simple key/value pairs.</source>
          <target state="translated">他のほとんどの SQL データベースエンジンはこれよりもはるかに大きいです。IBMは最近リリースされたCloudScapeデータベースエンジンは &quot;たった &quot;2MiBのjarファイルだと自慢しています。Firebirdは、そのクライアント側のライブラリがたったの350KiBだと自慢しています。これはSQLiteと同じくらいの大きさで、データベースエンジンさえ含まれていません。OracleのBerkeley DBライブラリは450KiBで、SQLのサポートを省略しており、プログラマには単純なキー/値のペアだけを提供しています。</target>
        </trans-unit>
        <trans-unit id="5dfe3bda7177abf58f732623f4daabfa91229422" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines require you to dump and restore the database when moving from one platform to another and often when upgrading to a newer version of the software.</source>
          <target state="translated">他のほとんどのSQLデータベースエンジンでは、あるプラットフォームから別のプラットフォームに移動するときや、ソフトウェアの新しいバージョンにアップグレードするときに、データベースをダンプしてリストアする必要があります。</target>
        </trans-unit>
        <trans-unit id="879c0198beea8a0459677487adc544c847a7576f" translate="yes" xml:space="preserve">
          <source>Most programmers compile SQLite into their applications using the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is C-code but it is not &quot;source code&quot;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is generated from source code by scripts.</source>
          <target state="translated">ほとんどのプログラマーは、&lt;a href=&quot;amalgamation&quot;&gt;融合&lt;/a&gt;を使用してSQLiteをアプリケーションにコンパイルします。&lt;a href=&quot;amalgamation&quot;&gt;合併は、&lt;/a&gt; C-コードですが、それは「ソースコード」ではありません。&lt;a href=&quot;amalgamation&quot;&gt;合併は、&lt;/a&gt;スクリプトによって、ソースコードから生成されます。</target>
        </trans-unit>
        <trans-unit id="e8416192176e318d00a7b55e02e8a608d8bdbda6" translate="yes" xml:space="preserve">
          <source>Most tables in SQLite consist of zero or more rows with a unique integer key (the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; or &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;) followed by content. (The exception is &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.) The rows are logically stored in order of increasing rowid. As an example, this article uses a table named &quot;FruitsForSale&quot; which relates various fruits to the state where they are grown and their unit price at market. The schema is this:</source>
          <target state="translated">SQLiteのほとんどのテーブルは、一意の整数キー（&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;または&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;）とその後にコンテンツが続く0個以上の行で構成されます。（例外は、&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルです。）行は、ROWIDの増加順に論理的に格納されます。例として、この記事では「FruitsForSale」という名前のテーブルを使用します。このテーブルは、さまざまな果物を栽培されている州と市場での単価に関連付けています。スキーマはこれです：</target>
        </trans-unit>
        <trans-unit id="22d0e010589dcfa569bc8ab54799e70d1b27d453" translate="yes" xml:space="preserve">
          <source>Most tables in a typical SQLite database schema are rowid tables.</source>
          <target state="translated">典型的なSQLiteデータベーススキーマのほとんどのテーブルはrowidテーブルです。</target>
        </trans-unit>
        <trans-unit id="ab23b25ac3bb6f94df4203c5e40926f8de962adb" translate="yes" xml:space="preserve">
          <source>Most users of swarmvtab will only use the features described above. This section describes features designed for more esoteric use cases. These features all involve specifying extra optional parameters following the SQL statement as part of the CREATE VIRTUAL TABLE command. An optional parameter is specified using its name, followed by an &quot;=&quot; character, followed by an optionally quoted value. Whitespace may separate the name, &quot;=&quot; character and value. For example:</source>
          <target state="translated">swarmvtab のほとんどのユーザーは、上記の機能のみを使用します。このセクションでは、より難解な使用例のために設計された機能について説明します。これらの機能はすべて、CREATE VIRTUAL TABLEコマンドの一部としてSQL文の後にオプションのパラメータを指定します。オプションのパラメータは、名前の後に&quot;=&quot;文字を続けて指定し、その後に任意で引用符で囲まれた値を指定します。空白文字で名前、&quot;=&quot;文字、値を区切ることができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="76cdb950721642b6b8596d36d5a39f7705028b99" translate="yes" xml:space="preserve">
          <source>Move</source>
          <target state="translated">Move</target>
        </trans-unit>
        <trans-unit id="7e894652e8d984064189391f996d60397e2a48ec" translate="yes" xml:space="preserve">
          <source>Move a BLOB Handle to a New Row</source>
          <target state="translated">BLOBハンドルを新しい行に移動する</target>
        </trans-unit>
        <trans-unit id="b0ff33b105569af9f2119de68af4d3ef24773b02" translate="yes" xml:space="preserve">
          <source>Move the P3 values in register P1..P1+P3-1 over into registers P2..P2+P3-1. Registers P1..P1+P3-1 are left holding a NULL. It is an error for register ranges P1..P1+P3-1 and P2..P2+P3-1 to overlap. It is an error for P3 to be less than 1.</source>
          <target state="translated">レジスタP1...P1+P3-1のP3値をレジスタP2...P2+P3-1に移動します。レジスタP1..P1+P3-1はNULLを保持したままになります。レジスタ範囲P1..P1+P3-1とP2..P2+P3-1が重なるのはエラーです。P3が1より小さいのはエラーです。</target>
        </trans-unit>
        <trans-unit id="43e629ad230f33beeec0dc2dfe68b2611f083ba6" translate="yes" xml:space="preserve">
          <source>Move the cursor P1 to a null row. Any &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; operations that occur while the cursor is on the null row will always write a NULL.</source>
          <target state="translated">カーソルP1をnull行に移動します。任意の&lt;a href=&quot;opcode#Column&quot;&gt;列&lt;/a&gt;カーソルがヌル行にあるときに発生する操作は常にNULLを記述します。</target>
        </trans-unit>
        <trans-unit id="ff17aceff7878d14b853ed0faf40490493d4491b" translate="yes" xml:space="preserve">
          <source>Move website and documentation files out of the source tree into a &lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;separate CM system&lt;/a&gt;.</source>
          <target state="translated">Webサイトとドキュメントファイルをソースツリーから&lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;別のCMシステムに移動し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="42fda9211198a462ad90d286a7b4b2828423cc34" translate="yes" xml:space="preserve">
          <source>Moved the CVS repository to www.sqlite.org</source>
          <target state="translated">CVS リポジトリを www.sqlite.org に移動しました。</target>
        </trans-unit>
        <trans-unit id="dc586a90c5c94a44d1d972ced97472cbaf4b949e" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.4.2 to 3.5.0</source>
          <target state="translated">SQLite 3.4.2から3.5.0への移行</target>
        </trans-unit>
        <trans-unit id="d4fefbd0278cf9b39cd3f466ee48861cfc5e39db" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.5.9 to 3.6.0</source>
          <target state="translated">SQLite 3.5.9から3.6.0への移行</target>
        </trans-unit>
        <trans-unit id="f76bc373feee6b1842d340bd7d664f80273b9cc9" translate="yes" xml:space="preserve">
          <source>Moving a journal file from one database to another.</source>
          <target state="translated">ジャーナルファイルをあるデータベースから別のデータベースに移動します。</target>
        </trans-unit>
        <trans-unit id="f0efafe4edefbbfdb22e09fc7f8e1939d65fc935" translate="yes" xml:space="preserve">
          <source>Much of the &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; is found in source files &lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt;, and &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c&lt;/a&gt; though some routines are scattered about in other files where they can have access to data structures with file scope. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; routine is implemented in &lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; routine is found in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete()&lt;/a&gt; interface is in &lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt;. The &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; is implemented by &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/intro&quot;&gt;C言語インターフェイスの&lt;/a&gt;多くは、ソースファイル&lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt;、&lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt;、および&lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.cに&lt;/a&gt;ありますが、一部のルーチンは、ファイルスコープを持つデータ構造にアクセスできる他のファイルに散在しています。&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;ルーチンが実装されて&lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt;。&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;ルーチンがで発見され&lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;。&lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete（）&lt;/a&gt;インターフェースはである&lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt;。&lt;a href=&quot;tclsqlite&quot;&gt;TCLインタフェース&lt;/a&gt;によって実装され&lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0aeaa0f6e5bc7f27528f2732350cce3993158ba7" translate="yes" xml:space="preserve">
          <source>Multi-File Transactions</source>
          <target state="translated">複数ファイル取引</target>
        </trans-unit>
        <trans-unit id="7bd215d0dc08a639766c0fd92af7ca6bd919b359" translate="yes" xml:space="preserve">
          <source>Multi-character insertions, deletions, and substitutions can be enumerated in the cost table.</source>
          <target state="translated">複数の文字の挿入、削除、置換は、コストテーブルに列挙することができます。</target>
        </trans-unit>
        <trans-unit id="658e2e2d073be17c3d24649adb63bc8071c4e34c" translate="yes" xml:space="preserve">
          <source>Multi-column indexes</source>
          <target state="translated">複数列インデックス</target>
        </trans-unit>
        <trans-unit id="b37d6f5d76bdf33c501015c981f38efa402cfb25" translate="yes" xml:space="preserve">
          <source>Multi-column indices only work if the constraint terms in the WHERE clause of the query are connected by AND. So Idx3 and Idx4 are helpful when the search is for items that are both Oranges and grown in California, but neither index would be that useful if we wanted all items that were either oranges</source>
          <target state="translated">マルチカラムインデックスは、クエリのWHERE句の制約条件がANDで接続されている場合にのみ機能します。つまり、Idx3とIdx4は、オレンジとカリフォルニア産の両方のアイテムを検索する場合に便利ですが、オレンジとカリフォルニア産の両方のアイテムを検索する場合には、どちらのインデックスもそれほど便利ではありません。</target>
        </trans-unit>
        <trans-unit id="a6a2f3477040c5c780afe34563348a368c865f18" translate="yes" xml:space="preserve">
          <source>Multiple Programming Languages</source>
          <target state="translated">複数のプログラミング言語</target>
        </trans-unit>
        <trans-unit id="8127845d9b0c204fa8283356e673cf21f966c9a0" translate="yes" xml:space="preserve">
          <source>Multiple VFSes can be registered at the same time. Each VFS has a unique names. Separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; within the same process can be using different VFSes at the same time. For that matter, if a single database connection has multiple database files open using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command, then each attached database might be using a different VFS.</source>
          <target state="translated">複数のVFSを同時に登録できます。各VFSには一意の名前があります。同じプロセス内の個別の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;は、異なるVFSを同時に使用できます。さらに言えば、単一のデータベース接続で&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;コマンドを使用して複数のデータベースファイルが開かれている場合、接続されている各データベースが異なるVFSを使用している可能性があります。</target>
        </trans-unit>
        <trans-unit id="dcdea0a58cadff7c782d97a6048e7da5d88f4991" translate="yes" xml:space="preserve">
          <source>Multiple b-tree structures are used instead of a single b-tree to reduce the cost of inserting records into FTS tables. When a new record is inserted into an FTS table that already contains a lot of data, it is likely that many of the terms in the new record are already present in a large number of existing records. If a single b-tree were used, then large doclist structures would have to be loaded from the database, amended to include the new docid and term-offset list, then written back to the database. Using multiple b-tree tables allows this to be avoided by creating a new b-tree which can be merged with the existing b-tree (or b-trees) later on. Merging of b-tree structures can be performed as a background task, or once a certain number of separate b-tree structures have been accumulated. Of course, this scheme makes queries more expensive (as the FTS code may have to look up individual terms in more than one b-tree and merge the results), but it has been found that in practice this overhead is often negligible.</source>
          <target state="translated">FTSテーブルへのレコード挿入のコストを削減するために、単一のbツリーの代わりに複数のbツリー構造が使用されます。すでに多くのデータを含むFTSテーブルに新しいレコードが挿入される場合、新しいレコードに含まれる用語の多くは、既存の多数のレコードにすでに存在している可能性が高い。単一のb-treeを使用した場合、大規模なdoclist構造をデータベースからロードし、新しいdocidと用語オフセットリストを含むように修正し、データベースに書き戻す必要があります。複数のb-treeテーブルを使用すると、後で既存のb-tree(またはb-tree)とマージできる新しいb-treeを作成することで、このような事態を避けることができます。b-tree構造のマージは、バックグラウンドタスクとして実行することもできますし、一定数の個別のb-tree構造が蓄積された後に実行することもできます。もちろん、この方式はクエリをより高価なものにします(FTSコードは複数のb-treeの中の個々の用語を検索し、その結果をマージしなければならないので)が、実際にはこのオーバーヘッドは無視できることが多いことがわかっています。</target>
        </trans-unit>
        <trans-unit id="46b7208fbb4e603607fdd8e005b8c2b44c4f2832" translate="yes" xml:space="preserve">
          <source>Multiple bug fixes to the &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; logic that was introduced in version 3.15.0.</source>
          <target state="translated">バージョン3.15.0で導入された&lt;a href=&quot;rowvalue&quot;&gt;行値&lt;/a&gt;ロジックに対する複数のバグ修正。</target>
        </trans-unit>
        <trans-unit id="5bf9dc54bb3a9335bc64c25972bec9a940f13e21" translate="yes" xml:space="preserve">
          <source>Multiple commentators have expressed a desire to use dynamic strings for the pointer type, and to have SQLite take ownership of the type strings and to automatically free the type string when it has finished using it. That design is rejected for the following reasons:</source>
          <target state="translated">複数のコメンテーターが、ポインタ型に動的な文字列を使用し、SQLiteが型文字列の所有権を持ち、それを使用し終わったときに自動的に型文字列を解放するようにしたいという願望を表明しています。この設計は以下の理由で却下されました。</target>
        </trans-unit>
        <trans-unit id="5989cfc9447928ba4d05b443c6d4b672ed4ef531" translate="yes" xml:space="preserve">
          <source>Multiple connections from within a single process that use this implementation of asynchronous IO may access a single database file concurrently. From the point of view of the user, if all connections are from within a single process, there is no difference between the concurrency offered by &quot;normal&quot; SQLite and SQLite using the asynchronous backend.</source>
          <target state="translated">非同期IOのこの実装を使用した単一プロセス内の複数の接続は、単一のデータベースファイルに同時にアクセスすることができます。ユーザーの視点から見ると、すべての接続が単一のプロセス内からのものであれば、&quot;通常の &quot;SQLiteと非同期バックエンドを使用したSQLiteで提供される同時実行性に違いはありません。</target>
        </trans-unit>
        <trans-unit id="de5017f80cc138eb92a9fee1631567420f1d53b1" translate="yes" xml:space="preserve">
          <source>Multiple connections may hold a read-lock simultaneously. If many threads are acquiring overlapping read-locks, it might be the case that at least one thread is always holding a read lock. Then a table waiting for a write-lock will wait forever. This scenario is called &quot;writer starvation.&quot;</source>
          <target state="translated">複数の接続が同時にリードロックを保持する場合があります。多くのスレッドが重複するリードロックを取得している場合、少なくとも1つのスレッドが常にリードロックを保持している場合があります。そうすると、書き込みロックを待っているテーブルは永遠に待つことになります。このシナリオは &quot;ライター飢餓 &quot;と呼ばれています。</target>
        </trans-unit>
        <trans-unit id="809241f3730c6379db2c7c73b89d2efee62ec7f1" translate="yes" xml:space="preserve">
          <source>Multiple databases on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using &lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE &lt;/a&gt;&lt;a href=&quot;c3ref/sqlite3&quot;&gt;を&lt;/a&gt;使用した同じデータベース接続上の複数のデータベース</target>
        </trans-unit>
        <trans-unit id="45a728f83fed6326d4c43841ba1813e1ce7eb6dd" translate="yes" xml:space="preserve">
          <source>Multiple processes can attach to the same application file and can read and write without interfering with each another.</source>
          <target state="translated">複数のプロセスが同じアプリケーションファイルにアタッチすることができ、お互いに干渉することなく読み書きすることができます。</target>
        </trans-unit>
        <trans-unit id="2aa7ba24512eed1d018b442b661d99d24d2bbe28" translate="yes" xml:space="preserve">
          <source>Multiple processes can have the same database open at the same time. Multiple processes can be doing a SELECT at the same time. But only one process can be making changes to the database at any moment in time, however.</source>
          <target state="translated">複数のプロセスが同時に同じデータベースを開くことができます。複数のプロセスが同時にSELECTを実行することができます。しかし、データベースに変更を加えることができるのは1つのプロセスだけです。</target>
        </trans-unit>
        <trans-unit id="933ed3deea04e9e9fbd7189bd88652e303cb225d" translate="yes" xml:space="preserve">
          <source>Multiple small sorts collectively use fewer CPU cycles than a single large sort.</source>
          <target state="translated">複数の小規模なソートをまとめて使用すると、単一の大規模なソートよりも少ないCPUサイクルを使用します。</target>
        </trans-unit>
        <trans-unit id="b20a305f06f0be2e3dd77e203ae365353776cf59" translate="yes" xml:space="preserve">
          <source>Multiply</source>
          <target state="translated">Multiply</target>
        </trans-unit>
        <trans-unit id="8e0df4037503e2d7d2784fedb62cdd6ec1bcce1f" translate="yes" xml:space="preserve">
          <source>Multiply the value in register P1 by the value in register P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">レジスタP1の値とレジスタP2の値を掛け合わせ、その結果をレジスタP3に格納します。どちらかの入力がNULLの場合、結果はNULLになります。</target>
        </trans-unit>
        <trans-unit id="96a8063d277e69bad9338f2cd2299ce555b10c74" translate="yes" xml:space="preserve">
          <source>Multiplying null by zero gives null</source>
          <target state="translated">nullに0を乗算すると、nullは次のようになります。</target>
        </trans-unit>
        <trans-unit id="0882d3aaa23d5575a8f63bfdd8452012d19a092f" translate="yes" xml:space="preserve">
          <source>MustBeInt</source>
          <target state="translated">MustBeInt</target>
        </trans-unit>
        <trans-unit id="ad84a5c1e8958f4a9c3429e8188a4603875d0079" translate="yes" xml:space="preserve">
          <source>Mutation test script</source>
          <target state="translated">変異検査スクリプト</target>
        </trans-unit>
        <trans-unit id="20e073cd00cadf7d267e8b82f5b78e0e3f9214a2" translate="yes" xml:space="preserve">
          <source>Mutation testing can be slow, since each test can take up to 5 minutes on a fast workstation, and there are two tests for each branch instructions, and over 20,000 branch instructions. Efforts are made to expedite operation. For example, TH3 is compiled in such a way that it exits as soon as it finds the first error, and as many of the mutations are easily detected, many cycles happen in only a few seconds. Nevertheless, the mutation-test.tcl script includes command-line options to limit the range of code lines tested so that mutation testing only needs to be performed on blocks of code that have recently changed.</source>
          <target state="translated">突然変異検査は、高速なワークステーションでは1回の検査に5分程度かかることがあり、分岐命令ごとに2回の検査があり、20,000以上の分岐命令があるため、時間がかかることがあります。動作を高速化するための努力がなされています。例えば、TH3 は最初のエラーを見つけるとすぐに終了するようにコンパイルされており、多くの突然変異が簡単に検出されるため、多くのサイクルが数秒で発生します。それにもかかわらず、mutation-test.tclスクリプトには、テストするコード行の範囲を制限するコマンドラインオプションが含まれているので、突然変異テストは最近変更されたコードブロックに対してのみ実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="ee9066f4d731d8a141c6e684743ee9a9527de8b6" translate="yes" xml:space="preserve">
          <source>Mutex Handle</source>
          <target state="translated">ミューテックスハンドル</target>
        </trans-unit>
        <trans-unit id="9f117864c1709baa2c76d7b2cfa8d17c9f1bfe11" translate="yes" xml:space="preserve">
          <source>Mutex Methods Object</source>
          <target state="translated">Mutex メソッド オブジェクト</target>
        </trans-unit>
        <trans-unit id="83fb9a7fd1246d148749d832e1630432bf7c41eb" translate="yes" xml:space="preserve">
          <source>Mutex Types</source>
          <target state="translated">ミューテックスの種類</target>
        </trans-unit>
        <trans-unit id="9ca067080a430d66f997055e5f2d644e22736a96" translate="yes" xml:space="preserve">
          <source>Mutex Verification Routines</source>
          <target state="translated">ミューテックス検証ルーチン</target>
        </trans-unit>
        <trans-unit id="82f2c9599c5c14be2ce92b9de958cb57db81b38f" translate="yes" xml:space="preserve">
          <source>Mutexes</source>
          <target state="translated">Mutexes</target>
        </trans-unit>
        <trans-unit id="5b84f7a78e5961ea2a526de843a9daab8f41a20c" translate="yes" xml:space="preserve">
          <source>Mutexes are cheap but they are not free, so performance will be better when mutexes are completely disabled. The resulting library footprint will also be a little smaller. Disabling the mutexes at compile-time is a recommended optimization for applications where it makes sense.</source>
          <target state="translated">ミューテックスは安いですが、無料ではないので、ミューテックスを完全に無効にした方がパフォーマンスは良くなります。その結果、ライブラリのフットプリントも少し小さくなります。コンパイル時にミューテックスを無効にすることは、意味のあるアプリケーションには最適化することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="b22446695cc6c25d3041d52dab780b6caac7cd1e" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">ミューテックスは&lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;を使用して作成されます。</target>
        </trans-unit>
        <trans-unit id="a8bd3143e806972c1aad1cdeede17125b4f66fc3" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">ミューテックスは&lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;を使用して作成されます。</target>
        </trans-unit>
        <trans-unit id="90dba5f17bdba09d7b97e3f464ca3b8fa2e57394" translate="yes" xml:space="preserve">
          <source>My WHERE clause expression &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; does not work. It causes every row of the table to be returned, not just the rows where column1 has the value &quot;column1&quot;.</source>
          <target state="translated">WHERE句の式 &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; が機能しません。column1の値が &quot;column1&quot;である行だけでなく、テーブルのすべての行が返されます。</target>
        </trans-unit>
        <trans-unit id="53dbb81c605812b9954b771e4d176a4b96f646d2" translate="yes" xml:space="preserve">
          <source>My query does not return the column name that I expect. Is this a bug?</source>
          <target state="translated">私のクエリは、私が期待するカラム名を返しません。これはバグでしょうか?</target>
        </trans-unit>
        <trans-unit id="deaa0c393a6613972aaccbf1fecfdad67aa21e88" translate="yes" xml:space="preserve">
          <source>MySQL</source>
          <target state="translated">MySQL</target>
        </trans-unit>
        <trans-unit id="424aa797f42c3aefebeedcebb618509b36642239" translate="yes" xml:space="preserve">
          <source>MySQL supports the UPDATE FROM idea, but it does so without using a FROM clause. Instead, the complete join specification is given in between the UPDATE and SET keywords. The equivalent MySQL statement would be like this:</source>
          <target state="translated">MySQLはUPDATE FROMのアイデアをサポートしていますが、これはFROM句を使わずに行います。代わりに、完全な結合指定はUPDATEキーワードとSETキーワードの間に与えられます。これと同等のMySQL文は次のようになります。</target>
        </trans-unit>
        <trans-unit id="e5d56b96c147bc00244a87ca5dec3dbb343c2acd" translate="yes" xml:space="preserve">
          <source>MySQL version 3.23.41 does not support UNION.</source>
          <target state="translated">MySQL バージョン 3.23.41 は UNION をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="e303d2711b51452d1cb5f1e99368e6acecd1238f" translate="yes" xml:space="preserve">
          <source>MySQL:</source>
          <target state="translated">MySQL:</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="8942124b2b322d5ed5aaedb0379f2b4629d337ae" translate="yes" xml:space="preserve">
          <source>N&amp;ge;12 and even</source>
          <target state="translated">N&amp;ge;12でさえ</target>
        </trans-unit>
        <trans-unit id="65234a7e6be9327b0d7bbc7e6bf2ce41cdf5a33b" translate="yes" xml:space="preserve">
          <source>N&amp;ge;13 and odd</source>
          <target state="translated">N&amp;ge;13と奇数</target>
        </trans-unit>
        <trans-unit id="4bbff46d5e4a2066e44932399c1db699e807cf39" translate="yes" xml:space="preserve">
          <source>N+1</source>
          <target state="translated">N+1</target>
        </trans-unit>
        <trans-unit id="bd2f53c8c05f137a14d10bbea3ef6da285114906" translate="yes" xml:space="preserve">
          <source>N+4</source>
          <target state="translated">N+4</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="8dd6dc5b4967e63a1a79c5eb2a6c948692613a58" translate="yes" xml:space="preserve">
          <source>N1 (cost: 5.52)</source>
          <target state="translated">N1(コスト:5.52</target>
        </trans-unit>
        <trans-unit id="798d9ffe324145d7424e3df912c7130f87d2bc5a" translate="yes" xml:space="preserve">
          <source>N2 (cost: 5.52)</source>
          <target state="translated">N2(コスト:5.52</target>
        </trans-unit>
        <trans-unit id="15fbf39b576cc8bd369719e2a3d26f97ec889560" translate="yes" xml:space="preserve">
          <source>N2-N1 (cost: 11.04)</source>
          <target state="translated">N2-N1(コスト:11.04</target>
        </trans-unit>
        <trans-unit id="5b4ea6d782abcd0ed1483d887c331af67374531e" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="e5c2df06ba96ff92a5b489615f6b10abd3bf147f" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2c0a1bee57f9f58fc50d516a0bf15f88caa7689c" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="a9d371451b6909ac85117130b9153a96499a362c" translate="yes" xml:space="preserve">
          <source>NAME</source>
          <target state="translated">NAME</target>
        </trans-unit>
        <trans-unit id="5b0ac1bba3d09af88af51314ab9e3274563ae94b" translate="yes" xml:space="preserve">
          <source>NATIVE CHARACTER(70)</source>
          <target state="translated">ネイティブキャラクター(70)</target>
        </trans-unit>
        <trans-unit id="7b0c42d6ea58612c19c7961351b229254674e033" translate="yes" xml:space="preserve">
          <source>NATURAL</source>
          <target state="translated">NATURAL</target>
        </trans-unit>
        <trans-unit id="ea1a1d896196c614eb971163bd79e6b0f3ccbe73" translate="yes" xml:space="preserve">
          <source>NB: This extension is deprecated. [WAL mode] is recommended as a replacement.</source>
          <target state="translated">注意:この拡張機能は非推奨です。代わりに [WAL mode]をお勧めします。</target>
        </trans-unit>
        <trans-unit id="9829174ea4702c19a86b2f2d0ae072ffd5bcdee0" translate="yes" xml:space="preserve">
          <source>NCHAR(55)</source>
          <target state="translated">NCHAR(55)</target>
        </trans-unit>
        <trans-unit id="b7fe5d20802ca2aca87db42d4b7dae9f148c0ed7" translate="yes" xml:space="preserve">
          <source>NEAR queries</source>
          <target state="translated">NEAR クエリ</target>
        </trans-unit>
        <trans-unit id="ad140e1560939f826df416c1e0d8f81eaa5dd26a" translate="yes" xml:space="preserve">
          <source>NEAR queries are not available.</source>
          <target state="translated">NEAR クエリは利用できません。</target>
        </trans-unit>
        <trans-unit id="9bbceb6fd3a09583f532267c802c583270b6ed37" translate="yes" xml:space="preserve">
          <source>NEVER(X)</source>
          <target state="translated">NEVER(X)</target>
        </trans-unit>
        <trans-unit id="97b77dd54bade796fe382680ffda0d54d204b7ea" translate="yes" xml:space="preserve">
          <source>NEW and OLD references are valid</source>
          <target state="translated">新しい参照と古い参照が有効です。</target>
        </trans-unit>
        <trans-unit id="a82d81a38474e7a2f1b05be86c3d0ec157924da9" translate="yes" xml:space="preserve">
          <source>NEW references are valid</source>
          <target state="translated">NEW リファレンスは有効です。</target>
        </trans-unit>
        <trans-unit id="aa7b193ecb5f5e8127c45d86d672c669b4ad311a" translate="yes" xml:space="preserve">
          <source>NNN</source>
          <target state="translated">NNN</target>
        </trans-unit>
        <trans-unit id="cf99bc0053e83f8041fe548005de7972be838e08" translate="yes" xml:space="preserve">
          <source>NNN days</source>
          <target state="translated">NNN日</target>
        </trans-unit>
        <trans-unit id="33c4ffa6e43390375c0bf9b4e04eedef73776044" translate="yes" xml:space="preserve">
          <source>NNN hours</source>
          <target state="translated">NNN時間</target>
        </trans-unit>
        <trans-unit id="4dc2b6e588bcda89bc862d480bc0a6894df9769a" translate="yes" xml:space="preserve">
          <source>NNN minutes</source>
          <target state="translated">エヌエヌエヌエヌ議事録</target>
        </trans-unit>
        <trans-unit id="bf0082b4c02bd0d30ff30874661f393df82750f4" translate="yes" xml:space="preserve">
          <source>NNN months</source>
          <target state="translated">エヌエヌエヌ月</target>
        </trans-unit>
        <trans-unit id="afb2dbb2fb0e9adb5cd092d7e7b6d3ffb78523de" translate="yes" xml:space="preserve">
          <source>NNN years</source>
          <target state="translated">NNN年</target>
        </trans-unit>
        <trans-unit id="b58c197b751c5ed1962a3c0390de8c10bb4951b3" translate="yes" xml:space="preserve">
          <source>NNN.NNNN seconds</source>
          <target state="translated">エヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌ秒</target>
        </trans-unit>
        <trans-unit id="a0509b7780628bd9d9abc7eb8a2163477341053a" translate="yes" xml:space="preserve">
          <source>NO</source>
          <target state="translated">NO</target>
        </trans-unit>
        <trans-unit id="05fdd36e7692e52033451b07ec66dff9eb7e55c8" translate="yes" xml:space="preserve">
          <source>NOCASE</source>
          <target state="translated">NOCASE</target>
        </trans-unit>
        <trans-unit id="0654a028e5aea48c8fbb09871b8f397a186c883b" translate="yes" xml:space="preserve">
          <source>NONE</source>
          <target state="translated">NONE</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="13e8b0dd0b366e8464e50db4ffa83a38db17f5c0" translate="yes" xml:space="preserve">
          <source>NOT EXISTS operator</source>
          <target state="translated">不存在演算子</target>
        </trans-unit>
        <trans-unit id="c251201ede2fa823c20c38c57254fd75c17ce421" translate="yes" xml:space="preserve">
          <source>NOT IN operator</source>
          <target state="translated">ふていにゅうえんざんし</target>
        </trans-unit>
        <trans-unit id="f4a4efddb03a7d76572898f7eabe1ea34a780b2f" translate="yes" xml:space="preserve">
          <source>NOT NULL constraint</source>
          <target state="translated">NOT NULLL制約</target>
        </trans-unit>
        <trans-unit id="6ff7e3eeee65666114a7a3854176937e0d8c1522" translate="yes" xml:space="preserve">
          <source>NOT NULL constraints are honored.</source>
          <target state="translated">NOT NULL 制約は優先されます。</target>
        </trans-unit>
        <trans-unit id="c462e8fc3e502ae6d5489c34ffa0054b7073578f" translate="yes" xml:space="preserve">
          <source>NOTHING</source>
          <target state="translated">NOTHING</target>
        </trans-unit>
        <trans-unit id="d6a7f5abac5bd9faa0bac9e8bb7907ab9f614941" translate="yes" xml:space="preserve">
          <source>NOTNULL</source>
          <target state="translated">NOTNULL</target>
        </trans-unit>
        <trans-unit id="545dacd66301f165f41f75a11471135695f4dede" translate="yes" xml:space="preserve">
          <source>NUL Characters In Strings</source>
          <target state="translated">文字列内のNUL文字</target>
        </trans-unit>
        <trans-unit id="4771b572fc1de8c483abeb1a95a1bc516fa56a87" translate="yes" xml:space="preserve">
          <source>NUL characters (ASCII code 0x00 and Unicode \u0000) may appear in the middle of strings in SQLite. This can lead to unexpected behavior. See the &quot;&lt;a href=&quot;nulinstr&quot;&gt;NUL characters in strings&lt;/a&gt;&quot; document for further information.</source>
          <target state="translated">SQLiteの文字列の途中にNUL文字（ASCIIコード0x00およびUnicode \ u0000）が表示される場合があります。これにより、予期しない動作が発生する可能性があります。詳細については、「&lt;a href=&quot;nulinstr&quot;&gt;文字列内のNUL文字&lt;/a&gt;」ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="0d475d854a2a7eeffd82e1a01f92ca65e566328f" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite</source>
          <target state="translated">SQLiteでのNULL処理</target>
        </trans-unit>
        <trans-unit id="7fac7bb3c1a767adbbac557d34135fb142c688ca" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite Versus Other Database Engines</source>
          <target state="translated">SQLiteと他のデータベースエンジンとの比較でのNULL処理</target>
        </trans-unit>
        <trans-unit id="248ab3abcb099e69f2fef53b64e651576012c852" translate="yes" xml:space="preserve">
          <source>NULL values (serial type 0) sort first.</source>
          <target state="translated">NULL 値 (シリアルタイプ 0)を最初にソートします。</target>
        </trans-unit>
        <trans-unit id="a1efa1e3b6119cae6664d71bdefea57f479d6ebf" translate="yes" xml:space="preserve">
          <source>NULL values are now reported to the callback as a NULL pointer rather than an empty string.</source>
          <target state="translated">NULL 値は、空の文字列ではなく NULL ポインタとしてコールバックに報告されるようになりました。</target>
        </trans-unit>
        <trans-unit id="743ef19013396d7d94a24cacbb830235275be9c8" translate="yes" xml:space="preserve">
          <source>NULLS</source>
          <target state="translated">NULLS</target>
        </trans-unit>
        <trans-unit id="fc81819cf87d3384597c4ae67d1976d82323a9b0" translate="yes" xml:space="preserve">
          <source>NULLS LAST</source>
          <target state="translated">NULLS LAST</target>
        </trans-unit>
        <trans-unit id="8280c934b3178b2afed2c01f955aab5fe7295999" translate="yes" xml:space="preserve">
          <source>NULLs sort first</source>
          <target state="translated">NULLは最初にソートします。</target>
        </trans-unit>
        <trans-unit id="58ad270de77802cc63222e273fa800c4b248cdd7" translate="yes" xml:space="preserve">
          <source>NUMERIC</source>
          <target state="translated">NUMERIC</target>
        </trans-unit>
        <trans-unit id="024959fd2d5e8c9c205a2098591019699ae29143" translate="yes" xml:space="preserve">
          <source>NVARCHAR(100)</source>
          <target state="translated">NVARCHAR(100)</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="daa5b774be0bfcbd2e2835e6bd0980fb6e06778a" translate="yes" xml:space="preserve">
          <source>Name Of A Host Parameter</source>
          <target state="translated">ホストパラメータ名</target>
        </trans-unit>
        <trans-unit id="cb9e33f6b09bb7fe5d38a783b74c6905b2f43077" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Database Files</source>
          <target state="translated">データベースファイルを格納するフォルダ名</target>
        </trans-unit>
        <trans-unit id="7749c218b18b42cbe27f3f870da40b8d3d708ba1" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Temporary Files</source>
          <target state="translated">一時ファイルを保存しているフォルダ名</target>
        </trans-unit>
        <trans-unit id="fbb9c33e0412f25c0e798fd22a36fd452bd92012" translate="yes" xml:space="preserve">
          <source>Name of default collation sequence</source>
          <target state="translated">デフォルトの照合順序の名前</target>
        </trans-unit>
        <trans-unit id="4e3a9de996d9196b59f293d51cf53aa5b2a8a36e" translate="yes" xml:space="preserve">
          <source>Named window-defn clauses may also be added to a SELECT statement using a WINDOW clause and then referred to by name within window function invocations. For example, the following SELECT statement contains two named window-defs clauses, &quot;win1&quot; and &quot;win2&quot;:</source>
          <target state="translated">名前付きwindow-defn句は、WINDOW句を使用してSELECT文に追加され、window関数の呼び出しの中で名前で参照されることもあります。例えば、以下のSELECT文は、2つの名前付きwindow-defn句、&quot;win1 &quot;と &quot;win2 &quot;を含んでいます。</target>
        </trans-unit>
        <trans-unit id="02aead4c6c683a05b1c0ebf7ea825cf0f6d1b06c" translate="yes" xml:space="preserve">
          <source>Naming Changes</source>
          <target state="translated">ネーミングの変更</target>
        </trans-unit>
        <trans-unit id="f736bf35e196e5f8a2152cf612783a7b401c2cad" translate="yes" xml:space="preserve">
          <source>Ne</source>
          <target state="translated">Ne</target>
        </trans-unit>
        <trans-unit id="28477357de69f5526193889fda40ed45cd101a03" translate="yes" xml:space="preserve">
          <source>Nearly all systems have the ability to call libraries written in C. This is not true of other implementation languages.</source>
          <target state="translated">ほぼすべてのシステムは C で書かれたライブラリを呼び出す機能を持っていますが、これは他の実装言語には当てはまりません。</target>
        </trans-unit>
        <trans-unit id="a37e5d1459b64bbf0f387b130668f0c8c4924e69" translate="yes" xml:space="preserve">
          <source>Negative numbers in the &quot;.width&quot; command cause right-alignment</source>
          <target state="translated">.width&quot; コマンドの負の数値は、右寄せの原因となります。</target>
        </trans-unit>
        <trans-unit id="fec37acea6ebcef8454c4fc958c0b8f34d2b8c80" translate="yes" xml:space="preserve">
          <source>Nested transactions using &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;, &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;, and &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;、&lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;、および&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO&lt;/a&gt;を使用したネストされたトランザクション</target>
        </trans-unit>
        <trans-unit id="9c791dcaae3666d9984fccf3b99d9aec11d78e88" translate="yes" xml:space="preserve">
          <source>Never despair of God's mercy.</source>
          <target state="translated">神の憐れみを絶望してはならない。</target>
        </trans-unit>
        <trans-unit id="56cdefb3df5828b1fdbe0c79de688ed68de09460" translate="yes" xml:space="preserve">
          <source>Never tag an application-defined SQL function with &lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt; unless you really need to and you have checked the implementation closely and are certain that it can do no harm even if it falls under the control of an attacker.</source>
          <target state="translated">本当に必要で、実装を綿密にチェックし、攻撃者の制御下にあったとしても害がないことが確実でない限り、アプリケーション定義のSQL関数に&lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUSの&lt;/a&gt;タグを付けないでください。</target>
        </trans-unit>
        <trans-unit id="cb1f0a8ca1cbcde19e25e6a553a1aa4154cf9c78" translate="yes" xml:space="preserve">
          <source>Nevertheless, application developers are admonished to monitor the state of the memory allocation subsystems and raise alarms when memory usage approaches or exceeds Robson limits. In this way, the application will provide operators with abundant warning well in advance of failure. The &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; interfaces of SQLite provide the application with all the mechanism necessary to complete the monitoring portion of this task.</source>
          <target state="translated">それにもかかわらず、アプリケーション開発者は、メモリ割り当てサブシステムの状態を監視し、メモリ使用量がロブソン制限に近づいたり超えたりしたときにアラームを発生させるように警告されています。このようにして、アプリケーションは、障害が発生する前に十分な警告をオペレーターに提供します。SQLite の&lt;a href=&quot;malloc#memstatus&quot;&gt;メモリ統計&lt;/a&gt;インターフェイスは、このタスクの監視部分を完了するために必要なすべてのメカニズムをアプリケーションに提供します。</target>
        </trans-unit>
        <trans-unit id="b14d2dd89e46e860f7449a61cc79bde67323500f" translate="yes" xml:space="preserve">
          <source>Nevertheless, bugs happen. If you are writing an application that sends untrusted SQL inputs or database files to SQLite, there are additional steps you can take to help reduce the attack surface and prevent zero-day exploits caused by undetected bugs.</source>
          <target state="translated">とはいえ、バグは発生します。信頼されていない SQL 入力やデータベースファイルを SQLite に送信するアプリケーションを書いている場合、攻撃対象を減らし、検出されなかったバグによるゼロデイエクスプロイトを防ぐための追加のステップがあります。</target>
        </trans-unit>
        <trans-unit id="fe8f48a38c1ee2d5e1ec0b569c50eb0f4be22e0d" translate="yes" xml:space="preserve">
          <source>Nevertheless, integer overflow in the computation of memory allocation sizes is a concern that SQLite would like to deal with. To prevent problems, all SQLite internal memory allocations occur using thin wrapper functions that take a signed 64-bit integer size parameter. The SQLite source code is audited to ensure that all size computations are carried out using 64-bit signed integers as well. SQLite will refuse to allocate more than about 2GB of memory at one go. (In common use, SQLite seldom ever allocates more than about 8KB of memory at a time so a 2GB allocation limit is not a burden.) So the 64-bit size parameter provides lots of headroom for detecting overflows. The same audit that verifies that all size computations are done as 64-bit signed integers also verifies that it is impossible to overflow a 64-bit integer during the computation.</source>
          <target state="translated">それにもかかわらず、メモリ割り当てサイズの計算における整数オーバーフローは、SQLiteが対処したい懸念事項です。問題を防ぐために、すべての SQLite 内部メモリ割り当ては、64 ビット符号付き整数のサイズパラメータを取るシンラッパー関数を使用して行われます。SQLite のソースコードは監査され、すべてのサイズ計算が 64 ビット符号付き整数を使用して行われていることを確認しています。SQLite は、一度に約 2GB を超えるメモリの割り当てを拒否します。(一般的な使用方法では、SQLite は一度に約 8KB 以上のメモリを割り当てることはめったにありませんので、2GB の割り当て制限は負担になりません)。そのため、64ビットのサイズパラメータはオーバーフローを検出するために多くの余裕を提供しています。すべてのサイズ計算が 64 ビット符号付き整数で行われていることを確認するのと同じ監査では、計算中に 64 ビット整数をオーバーフローさせることが不可能であることも確認されます。</target>
        </trans-unit>
        <trans-unit id="e49fc674e296beca34786edd4c2b299863546a78" translate="yes" xml:space="preserve">
          <source>Nevertheless, no software is 100% perfect. There have been a few historical bugs in SQLite (now fixed) that could cause database corruption. And there may be yet a few more that remain undiscovered. Because of the extensive testing and widespread use of SQLite, bugs that result in database corruption tend to be very obscure. The likelihood of an application encountering an SQLite bug is small. To illustrate this, an account is given below of all database-corruption bugs found in SQLite during the four-year period from 2009-04-01 to 2013-04-15. This account should give the reader an intuitive sense of the kinds of bugs in SQLite that manage to slip through testing procedures and make it into a release.</source>
          <target state="translated">とはいえ、どんなソフトウェアも100%完璧ではありません。SQLiteには、データベースの破損を引き起こす可能性のある歴史的なバグがいくつかありました(現在は修正されています)。また、まだ発見されていないバグがいくつかあるかもしれません。大規模なテストが行われ、SQLiteが広く使われているため、データベースの破損の原因となるバグは非常に目立たない傾向にあります。アプリケーションがSQLiteのバグに遭遇する可能性は低いのです。これを説明するために、2009-04-01 から 2013-04-15 までの 4 年間に SQLite で発見されたすべてのデータベース破損バグの説明を以下に示します。この説明は、SQLite のバグがテスト手順をすり抜けてリリースに至るまでにどのような種類のバグがあるのか、読者に直感的な感覚を与えてくれるはずです。</target>
        </trans-unit>
        <trans-unit id="0116882452ef2d4b8e1293a906b669874cb29ba7" translate="yes" xml:space="preserve">
          <source>New &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_...&lt;/a&gt; compile-time options added</source>
          <target state="translated">新しい&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _...&lt;/a&gt;コンパイル時オプションが追加されました</target>
        </trans-unit>
        <trans-unit id="75836f6f6b6f280ffed2e7c97c8de38d49f8b36b" translate="yes" xml:space="preserve">
          <source>New Change</source>
          <target state="translated">新しい変更点</target>
        </trans-unit>
        <trans-unit id="519eb3711af9fb8ce8d81cf7983b569f9b988fc0" translate="yes" xml:space="preserve">
          <source>New File Format</source>
          <target state="translated">新しいファイル形式</target>
        </trans-unit>
        <trans-unit id="05a025f4bcdcce620e0b66e603b7b96a2aa62567" translate="yes" xml:space="preserve">
          <source>New HH:MM:SS modifier to the built-in date/time functions.</source>
          <target state="translated">組み込みの日付/時刻関数に新しいHH:MM:SS修飾子を追加しました。</target>
        </trans-unit>
        <trans-unit id="35afb195f0b01edb4e7140e0f143cfa5913617eb" translate="yes" xml:space="preserve">
          <source>New VFSes are registered with sqlite3_vfs_register(). Each new VFS becomes the default VFS if the makeDflt flag is set. The same VFS can be registered multiple times without injury. To make an existing VFS into the default VFS, register it again with the makeDflt flag set. If two different VFSes with the same name are registered, the behavior is undefined. If a VFS is registered with a name that is NULL or an empty string, then the behavior is undefined.</source>
          <target state="translated">新しいVFSはsqlite3_vfs_register()で登録されます。各新規VFSは、makeDfltフラグが設定されていればデフォルトのVFSになります。同じVFSを複数回登録しても問題ありません。既存のVFSをデフォルトVFSにするには、makeDfltフラグをセットして再度登録します。同じ名前の異なるVFSが2つ登録されている場合の動作は未定義です。名前が NULL または空文字列の VFS が登録されている場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="9e6d8977d2335274bf96388fe98628d1d0b7e083" translate="yes" xml:space="preserve">
          <source>New applications should always invoke &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; instead of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;. The older &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; is retained for backwards compatibility. But &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; provides a much better interface.</source>
          <target state="translated">新しいアプリケーションでは、常に呼び出す必要があります&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;の代わりに、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepareは）（ &lt;/a&gt;。古い&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;は、下位互換性のために保持されています。しかし、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;ははるかに優れたインターフェースを提供します。</target>
        </trans-unit>
        <trans-unit id="741f30a581517ffe6e7dcd8b6f50643914279724" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">SQLiteの将来のリリースでは、新しい構成オプションが追加される可能性があります。既存の構成オプションは廃止される可能性があります。アプリケーションは、&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;からの戻りコードをチェックして、呼び出しが機能したことを確認する必要があります。&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;インターフェースは、非ゼロ返され&lt;a href=&quot;rescode&quot;&gt;たエラーコードを&lt;/a&gt;廃止またはサポートされていない構成オプションが呼び出された場合。</target>
        </trans-unit>
        <trans-unit id="dfd7ca29d835fc9c4dbb0540c0bcc6f89fdaa393" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">SQLiteの将来のリリースでは、新しい構成オプションが追加される可能性があります。既存の構成オプションは廃止される可能性があります。アプリケーションは&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;からの戻りコードをチェックして、呼び出しが機能したことを確認する必要があります。&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;インターフェースは、非ゼロ返され&lt;a href=&quot;rescode&quot;&gt;たエラーコードを&lt;/a&gt;廃止またはサポートされていない構成オプションが呼び出された場合。</target>
        </trans-unit>
        <trans-unit id="290c5a063c07711b910fa8250f0c45e5e6c8d5a9" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">SQLiteの将来のリリースでは、新しい構成オプションが追加される可能性があります。既存の構成オプションは廃止される可能性があります。アプリケーションは、&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;からの戻りコードをチェックして、呼び出しが機能したことを確認する必要があります。&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;インターフェースは、非ゼロ返され&lt;a href=&quot;../rescode&quot;&gt;たエラーコードを&lt;/a&gt;廃止またはサポートされていない構成オプションが呼び出された場合。</target>
        </trans-unit>
        <trans-unit id="bef0fe1db7b5b12623a7cb6dd11860448e032b3e" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">SQLiteの将来のリリースでは、新しい構成オプションが追加される可能性があります。既存の構成オプションは廃止される可能性があります。アプリケーションは&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;からの戻りコードをチェックして、呼び出しが機能したことを確認する必要があります。&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;インターフェースは、非ゼロ返され&lt;a href=&quot;../rescode&quot;&gt;たエラーコードを&lt;/a&gt;廃止またはサポートされていない構成オプションが呼び出された場合。</target>
        </trans-unit>
        <trans-unit id="b448decebb78010dbfebbde65087fb4a352a7ae8" translate="yes" xml:space="preserve">
          <source>New database files created by SQLite use format 4 by default. The &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt; can be used to cause SQLite to create new database files using format 1. The format version number can be made to default to 1 instead of 4 by setting &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt;=1 at compile-time.</source>
          <target state="translated">SQLiteによって作成された新しいデータベースファイルは、デフォルトでフォーマット4を使用します。&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_formatプラグマは、&lt;/a&gt;設定することで、フォーマットのバージョン番号は1ではなく4にデフォルトにすることができる形式1を使用して、新しいデータベースファイルを作成するためのSQLiteを引き起こすために使用することができます&lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt;コンパイル時に= 1を。</target>
        </trans-unit>
        <trans-unit id="7fae2a2a8fa480fb532533df6e47c596e4029933" translate="yes" xml:space="preserve">
          <source>New error codes may be added in future versions of SQLite.</source>
          <target state="translated">SQLite の将来のバージョンでは、新しいエラーコードが追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="02a2eef012a8248fed2ec4a5f4418e441dee6267" translate="yes" xml:space="preserve">
          <source>New extensions:</source>
          <target state="translated">新しいエクステンションです。</target>
        </trans-unit>
        <trans-unit id="c375e60e4ec3e7a7421f6f6fc9277a408ea2286e" translate="yes" xml:space="preserve">
          <source>New file format that is 25% to 35% smaller for typical use.</source>
          <target state="translated">一般的な使用のために25%から35%縮小された新しいファイル形式。</target>
        </trans-unit>
        <trans-unit id="fd04fa0f053215d42b7f8b539b38e361266bd4c9" translate="yes" xml:space="preserve">
          <source>New flags may be added in future releases of SQLite.</source>
          <target state="translated">SQLite の将来のリリースでは、新しいフラグが追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="609f25b82bb11b34abf866257917b5188d15ee70" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt; that returns the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; handle that has invoked an application-defined SQL function.</source>
          <target state="translated">アプリケーション定義のSQL関数を呼び出した&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;ハンドルを返す新しいインターフェース&lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="97e454a0ee0ddbdb1207081ac8f340c9145f813d" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; allows size and length limits to be set on a per-connection basis and at run-time.</source>
          <target state="translated">新しいインターフェース&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）を&lt;/a&gt;使用すると、サイズと長さの制限を接続ごとおよび実行時に設定できます。</target>
        </trans-unit>
        <trans-unit id="351a6ce815b5dd18ffcf850d512cce2a33e3cd28" translate="yes" xml:space="preserve">
          <source>New interface: sqlite3_bind_parameter_index()</source>
          <target state="translated">新しいインタフェース:sqlite3_bind_parameter_index()</target>
        </trans-unit>
        <trans-unit id="ff421fae0557a39a0bd809f33195e163ee4bb7ae" translate="yes" xml:space="preserve">
          <source>New interfaces added to the test_quota.c add-on module.</source>
          <target state="translated">test_quota.c アドオンモジュールに新しいインターフェースが追加されました。</target>
        </trans-unit>
        <trans-unit id="ae3613412d28080958e2d37e217b087b523b9aae" translate="yes" xml:space="preserve">
          <source>New internal schema objects names, always beginning with &quot;sqlite_&quot;, may be added to the SQLite file format in future releases.</source>
          <target state="translated">常に &quot;sqlite_&quot;で始まる新しい内部スキーマオブジェクト名は、将来のリリースでSQLiteファイルフォーマットに追加されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="26bcef71ccfa90b2e0cbb123ce577eb05e69bad7" translate="yes" xml:space="preserve">
          <source>New memory allocators do not have to be part of the SQLite source tree nor included in the sqlite3.c &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. Individual applications can supply their own memory allocators to SQLite at start-time.</source>
          <target state="translated">新しいメモリアロケータは、SQLiteのソースツリーの一部である必要はありもsqlite3.cには含まれません&lt;a href=&quot;amalgamation&quot;&gt;合併&lt;/a&gt;。個々のアプリケーションは、起動時にSQLiteに独自のメモリアロケータを提供できます。</target>
        </trans-unit>
        <trans-unit id="5e4800161f51168ad45c54c49952a916eb4c7f5a" translate="yes" xml:space="preserve">
          <source>New options to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; for configuring auxiliary memory usage: --pagecache, --lookaside, and --scratch.</source>
          <target state="translated">補助メモリの使用を構成するための&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルの&lt;/a&gt;新しいオプション：--pagecache、-lookaside、および--scratch。</target>
        </trans-unit>
        <trans-unit id="33b435c4ed8f9927e4700fe7e7aeadeae900e749" translate="yes" xml:space="preserve">
          <source>New query optimizations:</source>
          <target state="translated">新しいクエリの最適化。</target>
        </trans-unit>
        <trans-unit id="27a96e272ba4064e97b901622de6fb30f7bc2a07" translate="yes" xml:space="preserve">
          <source>New run-time limit categories may be added in future releases.</source>
          <target state="translated">今後のリリースでは、新しいランタイムリミットカテゴリが追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="aa7ba8a90d79e3949a9a92f1f6dd6361b3924b13" translate="yes" xml:space="preserve">
          <source>New status parameters may be added from time to time.</source>
          <target state="translated">新しいステータスパラメータは随時追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="8001d5465bcc215e617045ec61b342b4c0fbe511" translate="yes" xml:space="preserve">
          <source>New tests added to the test suite.</source>
          <target state="translated">テストスイートに新しいテストが追加されました。</target>
        </trans-unit>
        <trans-unit id="19df796618ecb880621a1ff2386886f64457fe9e" translate="yes" xml:space="preserve">
          <source>New text tokens may be added to the end of the stat column in future enhancements to SQLite. For compatibility, unrecognized tokens at the end of the stat column are silently ignored.</source>
          <target state="translated">SQLite の将来の拡張機能では、stat 列の末尾に新しいテキストトークンが追加される可能性があります。互換性のために、 stat カラムの最後にある認識されていないトークンは静かに無視されます。</target>
        </trans-unit>
        <trans-unit id="d23050a62d4b2ebb32c827e3e8678911cb996090" translate="yes" xml:space="preserve">
          <source>New tracing constants may be added in future releases.</source>
          <target state="translated">今後のリリースでは、新しいトレース定数が追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="8ec81cf9bf3ff78a39346bf7439447032b8bc32c" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">SQLiteの将来のリリースでは、新しい動詞が追加される可能性があります。既存の動詞は廃止される可能性があります。アプリケーションは&lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;からの戻りコードをチェックして、呼び出しが機能したことを確認する必要があります。&lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;廃止またはサポートされていない動詞が呼び出された場合のインターフェースは、非ゼロのエラーコードを返します。</target>
        </trans-unit>
        <trans-unit id="6997236519e17b29acb8e0c21015208012814bff" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">SQLiteの将来のリリースでは、新しい動詞が追加される可能性があります。既存の動詞は廃止される可能性があります。アプリケーションは&lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;からの戻りコードをチェックして、呼び出しが機能したことを確認する必要があります。&lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;廃止またはサポートされていない動詞が呼び出された場合のインターフェースは、非ゼロのエラーコードを返します。</target>
        </trans-unit>
        <trans-unit id="b162b6ee72989cc021180a9aa2d3a7a0e2b57826" translate="yes" xml:space="preserve">
          <source>New zip archives may be constructed entirely within memory using the zipfile() aggregate function. Each row visited by the aggregate function adds an entry to the zip archive. The value returned is a blob containing the entire archive image.</source>
          <target state="translated">新しい zip アーカイブは、zipfile()集約関数を使用してメモリ内で完全に構築することができます。集計関数が訪れる各行は、ZIP アーカイブへのエントリを追加します。返される値は、アーカイブ画像全体を含む blob となります。</target>
        </trans-unit>
        <trans-unit id="e327377c14f6ddd81b93544df605d7203e2995e8" translate="yes" xml:space="preserve">
          <source>NewRowid</source>
          <target state="translated">NewRowid</target>
        </trans-unit>
        <trans-unit id="6975bed1eebd03a852e5aa6a11d0f144cd34ff6e" translate="yes" xml:space="preserve">
          <source>Newer disk drives have begun using 4096 byte sectors however. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16), the SQLite development team experimented with changes xSectorSize to report 4096 bytes as the blast radius. This had the effect of increasing write overhead on many databases. For a database with a &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; of 1024 (a very common choice) making a change to a single page in the database now requires SQLite to backup three other adjacent pages to the rollback journal, whereas formerly it only had to backup the one page that was changing. In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, each transaction had to be padded out to the next 4096-byte boundary in the WAL file, rather than the next 512-byte boundary, resulting in thousands of extra bytes being written per transaction.</source>
          <target state="translated">新しいディスクドライブは、4096バイトのセクターを使用し始めました。 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;バージョン3.7.10&lt;/a&gt;（2012-01-16）以降、SQLite開発チームはxSectorSizeを変更して実験を行い、爆風半径として4096バイトを報告しました。これにより、多くのデータベースで書き込みオーバーヘッドが増加するという影響がありました。データベースのための&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;プラグマPAGE_SIZE&lt;/a&gt;以前はそれが唯一のバックアップに1つのページを持っていたのに対し、データベース内の1つのページへの変更を行う1024（非常に一般的な選択肢は）今、ロールバック・ジャーナルへのバックアップ3つの、隣接する他のページへのSQLiteが必要です変わりました。では&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;、各トランザクションは、トランザクションごとに書き込まれている余分なバイト数千の結果として、WALファイルではなく、次の512バイト境界で次の4096バイト境界にパディングされなければなりませんでした。</target>
        </trans-unit>
        <trans-unit id="bc981983e7f547dc62e19a1e383acfe00782a6d5" translate="yes" xml:space="preserve">
          <source>Next</source>
          <target state="translated">Next</target>
        </trans-unit>
        <trans-unit id="bc1189b8a3e7e2b908b403ea79a8eb14b14bcd47" translate="yes" xml:space="preserve">
          <source>Next, make copies of all the blobs into individual files in a directory using a command like this:</source>
          <target state="translated">次に、以下のようなコマンドを使って、すべての blob のコピーをディレクトリ内の個々のファイルに作成します。</target>
        </trans-unit>
        <trans-unit id="73f7cfb7746314674a12b8d200b36135947e050b" translate="yes" xml:space="preserve">
          <source>Next, move the resulting kvtest-android executable to the Android device:</source>
          <target state="translated">次に、出来上がったkvtest-android実行ファイルをAndroidデバイスに移動します。</target>
        </trans-unit>
        <trans-unit id="21d2b394790e7b47b83f7c9d1daa6c55ee3c0c16" translate="yes" xml:space="preserve">
          <source>Next, suppose that you want to look up the price of not just any orange, but specifically California-grown oranges. The appropriate query would be as follows:</source>
          <target state="translated">次に、どんなオレンジでも良いのではなく、カリフォルニア産のオレンジの価格を調べたいとします。適切なクエリは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="dad2991d263e4aa51578f91e92e9777428d9762b" translate="yes" xml:space="preserve">
          <source>No (Note 1)</source>
          <target state="translated">いいえ(注1)</target>
        </trans-unit>
        <trans-unit id="b4f66722cbcf69861e819a02ca8d6803b779fcd3" translate="yes" xml:space="preserve">
          <source>No Isolation Between Operations On The Same Database Connection</source>
          <target state="translated">同じデータベース接続上での操作間の分離ができない</target>
        </trans-unit>
        <trans-unit id="8dae863821cb04b5484c9a0e7717d726d350b9bd" translate="yes" xml:space="preserve">
          <source>No application file I/O code to write and debug.</source>
          <target state="translated">アプリケーションファイルのI/Oコードを書き込んでデバッグすることはできません。</target>
        </trans-unit>
        <trans-unit id="95ec05297c8cafc96feb998f4af109f4728d5530" translate="yes" xml:space="preserve">
          <source>No change</source>
          <target state="translated">変更なし</target>
        </trans-unit>
        <trans-unit id="7f2ff41fbbf4963dea6c3e81c6aa743e95c596b5" translate="yes" xml:space="preserve">
          <source>No current or conflicting row information is provided. The only function it is possible to call on the supplied sqlite3_changeset_iter handle is sqlite3changeset_fk_conflicts().</source>
          <target state="translated">現在の行情報や競合する行情報は提供されません。与えられたsqlite3_changeset_iterハンドルで呼び出すことができる唯一の関数はsqlite3changeset_fk_conflicts()です。</target>
        </trans-unit>
        <trans-unit id="7c5c383086cc31c41ab2122a84d0a48706ccfc11" translate="yes" xml:space="preserve">
          <source>No error is raised if a width or precision exceeds SQLITE_PRINTF_PRECISION_LIMIT. Instead, the large width or precision is silently truncated.</source>
          <target state="translated">幅または精度が SQLITE_PRINTF_PRECISION_LIMIT を超えてもエラーは発生しません。その代わり、大きな幅または精度は静かに切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="662adfcee595804e0d0a40f3427892366f101024" translate="yes" xml:space="preserve">
          <source>No error messages are generated if an unknown pragma is issued. Unknown pragmas are simply ignored. This means if there is a typo in a pragma statement the library does not inform the user of the fact.</source>
          <target state="translated">不明なプラグマが発行されてもエラーメッセージは生成されません。未知のプラグマは単に無視されます。これは、プラグマ文の中にタイプミスがあっても、ライブラリがその事実をユーザに知らせないことを意味します。</target>
        </trans-unit>
        <trans-unit id="36386488a9bfa58ff6f23801ec174053b73ed777" translate="yes" xml:space="preserve">
          <source>No locking style. If none of the above can be supported, this locking style is used. No database locking mechanism is used. When this system is used it is not safe for a single database to be accessed by multiple clients.</source>
          <target state="translated">ロックスタイルはありません。上記のいずれにも対応できない場合は、このロックスタイルが使用されます。データベースのロック機構を使用しない。このシステムを使用する場合、単一のデータベースが複数のクライアントからアクセスされることは安全ではありません。</target>
        </trans-unit>
        <trans-unit id="7b15426333f8adb77f306aae95c84b204b379d14" translate="yes" xml:space="preserve">
          <source>No locks are held on the database. The database may be neither read nor written. Any internally cached data is considered suspect and subject to verification against the database file before being used. Other processes can read or write the database as their own locking states permit. This is the default state.</source>
          <target state="translated">データベースにはロックはありません。データベースは読み書きできません。内部的にキャッシュされたデータはすべて疑わしいものとみなされ、使用する前にデータベースファイルとの照合が必要です。他のプロセスは、それぞれのロック状態が許す限り、データベースを読み書きすることができます。これがデフォルトの状態です。</target>
        </trans-unit>
        <trans-unit id="589cdf57b87436c5bbc074aa5e48b70f3f3363e1" translate="yes" xml:space="preserve">
          <source>No longer in use.</source>
          <target state="translated">使わなくなった。</target>
        </trans-unit>
        <trans-unit id="7375825a734eee4acde64dd3de9ae4b6f89db26c" translate="yes" xml:space="preserve">
          <source>No longer used.</source>
          <target state="translated">使わなくなりました。</target>
        </trans-unit>
        <trans-unit id="1cff8c4990053d03c141cc08cc6f740585898fb6" translate="yes" xml:space="preserve">
          <source>No one is required to follow The Rule, to know The Rule, or even to think that The Rule is a good idea. The Founder of SQLite believes that anyone who follows The Rule will live a happier and more productive life, but individuals are free to dispute or ignore that advice if they wish.</source>
          <target state="translated">誰もThe Ruleに従う必要はありませんし、The Ruleを知っている必要もありませんし、The Ruleが良い考えであると考える必要もありません。SQLiteの創設者は、The Ruleに従う人は誰でもより幸せで生産的な人生を送ることができると信じていますが、そのアドバイスに異議を唱えたり、無視したりするのは個人の自由です。</target>
        </trans-unit>
        <trans-unit id="a4226fa0e8cf6311cf2613fee3e52c99bd81b607" translate="yes" xml:space="preserve">
          <source>No other processes can change the database so there is never a need to check the change counter and clear the user-space cache at the beginning of a transaction.</source>
          <target state="translated">他のプロセスがデータベースを変更することはないので、トランザクションの最初に変更カウンタをチェックしてユーザースペースのキャッシュをクリアする必要はありません。</target>
        </trans-unit>
        <trans-unit id="6b5b494aee4d1b7c43eaf07044f46f3778af61cd" translate="yes" xml:space="preserve">
          <source>No other writes may occur on the target database while the RBU update is being applied. A read-lock is held on the target database to prevent this.</source>
          <target state="translated">RBU更新が適用されている間は、ターゲット・データベースに他の書き込みが発生することはありません。これを防ぐために、ターゲット・データベースではリード・ロックが保持されています。</target>
        </trans-unit>
        <trans-unit id="3943b575617ba52cb8729616c676b13dc34b8e79" translate="yes" xml:space="preserve">
          <source>No reads or writes occur except within a transaction. Any command that accesses the database (basically, any SQL command, except a few &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements) will automatically start a transaction if one is not already in effect. Automatically started transactions are committed when the last SQL statement finishes.</source>
          <target state="translated">トランザクション内を除き、読み取りまたは書き込みは発生しません。データベースにアクセスするコマンド（基本的には、いくつかの&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;ステートメントを除くすべてのSQLコマンド）は、トランザクションがまだ有効になっていない場合、自動的にトランザクションを開始します。自動的に開始されたトランザクションは、最後のSQLステートメントが完了するとコミットされます。</target>
        </trans-unit>
        <trans-unit id="2a9bc5ebe3cc4eba5a484c518ae347f8a47ccd50" translate="yes" xml:space="preserve">
          <source>No table in a union-vtab may contain entries that are outside of the rowid bounds established by the</source>
          <target state="translated">union-vtab内のどのテーブルにも</target>
        </trans-unit>
        <trans-unit id="7d5b25b567984a7a4091e940273bfff96cd2fed3" translate="yes" xml:space="preserve">
          <source>No. When you delete information from an SQLite database, the unused disk space is added to an internal &quot;free-list&quot; and is reused the next time you insert data. The disk space is not lost. But neither is it returned to the operating system.</source>
          <target state="translated">SQLite データベースから情報を削除すると、未使用のディスク領域は内部の「フリーリスト」に追加され、次にデータを挿入するときに再利用されます。ディスク領域が失われることはありません。しかし、それがオペレーティングシステムに戻されることはありません。</target>
        </trans-unit>
        <trans-unit id="d4e9f5ef9057ec35a6f3d638ab0a7b961dadfa79" translate="yes" xml:space="preserve">
          <source>NoConflict</source>
          <target state="translated">NoConflict</target>
        </trans-unit>
        <trans-unit id="66290ce3e3466df1560e431a1eebe9e205ef9f1e" translate="yes" xml:space="preserve">
          <source>Non-ASCII range characters (i.e. unicode codepoints greater than 127), or</source>
          <target state="translated">非ASCII範囲文字(すなわち127より大きいユニコードコードコードポイント)、または</target>
        </trans-unit>
        <trans-unit id="1bc1387523b6d25784112f80a2990511e6a57420" translate="yes" xml:space="preserve">
          <source>Non-Vista Windows platforms only support one set of DST rules. Vista only supports two. Therefore, on these platforms, historical DST calculations will be incorrect. For example, in the US, in 2007 the DST rules changed. Non-Vista Windows platforms apply the new 2007 DST rules to all previous years as well. Vista does somewhat better getting results correct back to 1986, when the rules were also changed.</source>
          <target state="translated">Vista 以外の Windows プラットフォームでは、DST ルールは 1 つのセットしかサポートしていません。Vistaでは2つのルールしかサポートしていません。そのため、これらのプラットフォームでは、過去のDSTの計算は正しくありません。たとえば、米国では2007年にDSTルールが変更されました。Vista以外のWindowsプラットフォームでは、2007年の新しいDSTルールがそれ以前のすべての年にも適用されます。Vistaでは、規則が変更された1986年まで遡って正しい結果が得られるようになります。</target>
        </trans-unit>
        <trans-unit id="b1b833538f0549b7c8aca0acf47c1aa5ac7f2fac" translate="yes" xml:space="preserve">
          <source>Non-deterministic functions might give different answers on each invocation, even if the arguments are always the same. The following are examples of non-deterministic functions:</source>
          <target state="translated">非決定論的関数は、引数が常に同じであっても、呼び出しごとに異なる答えを与える可能性があります。以下に非決定論的関数の例を示します。</target>
        </trans-unit>
        <trans-unit id="cf3ad9f318d5d17809c32f85aa54a78cb4cda991" translate="yes" xml:space="preserve">
          <source>Non-streaming equivalent</source>
          <target state="translated">ノンストリーミング相当</target>
        </trans-unit>
        <trans-unit id="1d0d5248c3c8dbbb61313817bba98f17697e01b6" translate="yes" xml:space="preserve">
          <source>Non-streaming functions that accept changesets (or patchsets) as input require that the entire changeset be stored in a single buffer in memory. Similarly, those that return a changeset or patchset do so by returning a pointer to a single large buffer allocated using sqlite3_malloc(). Normally this is convenient. However, if an application running in a low-memory environment is required to handle very large changesets, the large contiguous memory allocations required can become onerous.</source>
          <target state="translated">チェンジセット(またはパッチセット)を入力として受け取る非ストリーミング関数は、チェンジセット全体をメモリ内の単一のバッファに格納する必要があります。同様に、チェンジセットやパッチセットを返す関数は、sqlite3_malloc()を使って確保された単一の大きなバッファへのポインタを返します。通常はこれが便利です。しかし、低メモリ環境で動作するアプリケーションが非常に大きなチェンジセットを扱う必要がある場合、必要とされる大きな連続したメモリの割り当ては負担になります。</target>
        </trans-unit>
        <trans-unit id="09f7070838a5d668002d389cd9b3fec752e6c30d" translate="yes" xml:space="preserve">
          <source>None of the safe programming languages existed for the first 10 years of SQLite's existence. SQLite could be recoded in Go or Rust, but doing so would probably introduce far more bugs than would be fixed, and it seems also likely to result in slower code.</source>
          <target state="translated">SQLite が存在していた最初の 10 年間は、安全なプログラミング言語は存在しませんでした。SQLiteはGoやRustで再コード化することができますが、そうすることで修正されるよりもはるかに多くのバグが発生し、コードが遅くなる可能性が高いようです。</target>
        </trans-unit>
        <trans-unit id="9b9f34e057f76ac2b419477d464548015d8ef844" translate="yes" xml:space="preserve">
          <source>None of the xSavepoint(), xRelease(), or xRollbackTo() methods will ever be called except in between calls to xBegin() and either xCommit() or xRollback().</source>
          <target state="translated">xSavepoint()、xRelease()、または xRollbackTo()メソッドは、xBegin()と xCommit()または xRollback()のいずれかを呼び出す間を除いて、いずれも呼び出されることはありません。</target>
        </trans-unit>
        <trans-unit id="a1fe0caa1d6e9f3e9dd7087ae4f2a9ea810cd170" translate="yes" xml:space="preserve">
          <source>Noop</source>
          <target state="translated">Noop</target>
        </trans-unit>
        <trans-unit id="2bbfb9d52741dbc3a4ff03abc70ca82cb8e2f1bc" translate="yes" xml:space="preserve">
          <source>Normal functions specify only xFunc and leave xStep and xFinal set to NULL. Aggregate functions specify xStep and xFinal and leave xFunc set to NULL. There is no separate sqlite3_create_aggregate() API.</source>
          <target state="translated">通常の関数はxFuncのみを指定し、xStepとxFinalをNULLにします。集約関数はxStepとxFinalを指定し、xFuncをNULLにします。sqlite3_create_aggregate()APIは別途ありません。</target>
        </trans-unit>
        <trans-unit id="8feff5d8988d2d3b3f82fe7920cdb81d5ba04e3a" translate="yes" xml:space="preserve">
          <source>Normal meaning</source>
          <target state="translated">通常の意味</target>
        </trans-unit>
        <trans-unit id="e304219719d389c0ea46b9c98590f2134fb67330" translate="yes" xml:space="preserve">
          <source>Normally, FTS5 maintains a special backing table within the database that stores the size of each column value in tokens inserted into the main FTS5 table in a separate table. This backing table is used by the &lt;a href=&quot;#xColumnSize&quot;&gt;xColumnSize&lt;/a&gt;&lt;a&gt; API function, which is in turn used by the built-in &lt;/a&gt;&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25 ranking function&lt;/a&gt; (and is likely to be useful to other ranking functions as well).</source>
          <target state="translated">通常、FTS5は、メインのFTS5テーブルに挿入されたトークンの各列の値のサイズを別のテーブルに格納する特別なバッキングテーブルをデータベース内に保持します。このバッキングテーブルは、&lt;a href=&quot;#xColumnSize&quot;&gt;xColumnSize &lt;/a&gt;&lt;a&gt;API関数&lt;/a&gt;によって使用されます。これは、組み込みの&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25ランキング関数&lt;/a&gt;によって使用されます（他のランキング関数にも役立つ可能性があります）。</target>
        </trans-unit>
        <trans-unit id="866b49d7e3deb743a545b4433375afa6debe3327" translate="yes" xml:space="preserve">
          <source>Normally, NULL SQL results are stored in the array using the &lt;a href=&quot;#nullvalue&quot;&gt;nullvalue&lt;/a&gt; setting. However, if the &lt;b&gt;-withoutnulls&lt;/b&gt; option is used, then NULL SQL values cause the corresponding array element to be unset instead.</source>
          <target state="translated">通常、NULL SQL結果は&lt;a href=&quot;#nullvalue&quot;&gt;nullvalue&lt;/a&gt;設定を使用して配列に格納されます。ただし、&lt;b&gt;-withoutnulls&lt;/b&gt;オプションを使用すると、NULL SQL値により、対応する配列要素が設定解除されます。</target>
        </trans-unit>
        <trans-unit id="d1f5712d735a4022fc9c1482cc2c46055815935d" translate="yes" xml:space="preserve">
          <source>Normally, SQLite assumes that if a power failure occurs while updating any portion of a sector then the contents of the entire device sector is suspect following recovery. After writing to any part of a sector within a file, it is assumed that the modified sector contents are held in a volatile buffer somewhere within the system (main memory, disk cache etc.). SQLite does not assume that the updated data has reached the persistent storage media, until after it has successfully</source>
          <target state="translated">通常、SQLite は、セクタの一部を更新している間に停電が発生した場合、復旧後のデバイスセクタ全体の内容が疑われると想定しています。ファイル内のセクタの任意の部分に書き込みを行った後、変更されたセクタの内容はシステム内のどこか(メインメモリ、ディスクキャッシュなど)の揮発性バッファに保持されていると想定されます。SQLite は、更新されたデータが永続的なストレージメディアに到達したとは考えていません。</target>
        </trans-unit>
        <trans-unit id="e5b528fefcff05064efc30021e7a7579eaaad4d2" translate="yes" xml:space="preserve">
          <source>Normally, a token or token prefix query is matched against the FTS table column specified as the left-hand side of the MATCH operator. Or, if the special column with the same name as the FTS table itself is specified, against all columns. This may be overridden by specifying a column-name followed by a &quot;:&quot; character before a basic term query. There may be space between the &quot;:&quot; and the term to query for, but not between the column-name and the &quot;:&quot; character. For example:</source>
          <target state="translated">通常、トークンまたはトークンプレフィックスクエリは、MATCH演算子の左側に指定されたFTSテーブルのカラムに対してマッチされます。あるいは、FTS テーブル自体と同じ名前の特別なカラムが指定されている場合は、すべてのカラムに対してマッチされます。これは、基本的な用語クエリの前にカラム名の後に&quot;:&quot;文字を指定することで上書きすることができます。カラム名と&quot;:&quot;文字の間にはスペースがあってもよいが、カラム名と&quot;:&quot;文字の間にはスペースはない。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="bf4491e66772ed8b491e6908438d7924fa774545" translate="yes" xml:space="preserve">
          <source>Normally, an SQL index references columns of a table. But an index can also be formed on expressions involving table columns.</source>
          <target state="translated">通常、SQLインデックスはテーブルのカラムを参照します。しかし、インデックスはテーブルのカラムを含む式にも形成することができます。</target>
        </trans-unit>
        <trans-unit id="39e8cea13d3d48550994e6ce4ac623d3130ee592" translate="yes" xml:space="preserve">
          <source>Normally, fossil will modify all the files in your checkout when switching between the private and the public branches. But at this point, the files are identical in both branches so not modifications need to be made.</source>
          <target state="translated">通常、プライベートブランチとパブリックブランチを切り替えると、fossilはチェックアウト内のすべてのファイルを修正します。しかし、この時点ではどちらのブランチでもファイルは同じなので、修正の必要はありません。</target>
        </trans-unit>
        <trans-unit id="d3d92a3c721eaacd534b06f545203c90c257b9b9" translate="yes" xml:space="preserve">
          <source>Normally, full-text queries are case-insensitive. However, this is dependent on the specific &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt; used by the FTS table being queried. Refer to the section on &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizers&lt;/a&gt; for details.</source>
          <target state="translated">通常、フルテキストクエリでは大文字と小文字が区別されません。ただし、これは、照会されるFTSテーブルが使用する特定の&lt;a href=&quot;fts3#tokenizer&quot;&gt;トークナイザーに&lt;/a&gt;依存します。詳細については、&lt;a href=&quot;fts3#tokenizer&quot;&gt;トークナイザー&lt;/a&gt;のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="63e53b72fdcc0af9b1c300c26469b45178a485e4" translate="yes" xml:space="preserve">
          <source>Normally, the FTS module maintains an inverted index of all terms in all columns of the table. This option is used to specify the name of a column for which entries should not be added to the index. Multiple &quot;notindexed&quot; options may be used to specify that multiple columns should be omitted from the index. For example:</source>
          <target state="translated">通常、FTSモジュールは、テーブルのすべての列のすべての用語の転置インデックスを保持する。このオプションは、インデックスにエントリを追加してはならない列の名前を指定するために使用される。複数の &quot;notindexed &quot;オプションを使用して、複数の列をインデックスから除外することを指定することができる。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="ebe2262110ee72155bb934332e4fc5587e66a440" translate="yes" xml:space="preserve">
          <source>Normally, the database &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and whether or not the database supports &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; must be configured before the database file is actually created. However, when not in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; properties of an existing database may be changed by using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;pragma auto_vacuum&lt;/a&gt; pragmas and then immediately VACUUMing the database. When in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, only the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; support property can be changed using VACUUM.</source>
          <target state="translated">通常、データベース&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PAGE_SIZE&lt;/a&gt;とデータベースがサポートするかどうか&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuumは、&lt;/a&gt;データベースファイルが実際に作成される前に設定する必要があります。しかし、ないときに&lt;a href=&quot;wal&quot;&gt;先行書き込みログ&lt;/a&gt;モード、&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PAGE_SIZE&lt;/a&gt;及び/又は&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuumの&lt;/a&gt;既存のデータベースの特性は、使用して変更することができる&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PAGE_SIZE&lt;/a&gt;および/または&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;プラグマauto_vacuum&lt;/a&gt;プラグマと直ちにデータベースを掃除します。すると&lt;a href=&quot;wal&quot;&gt;、先行書き込みログ&lt;/a&gt;モードのみ&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuumの&lt;/a&gt;サポートプロパティは、VACUUMを使用して変更することができます。</target>
        </trans-unit>
        <trans-unit id="5df62864e283fb4361bad80921bbac8b7ec57013" translate="yes" xml:space="preserve">
          <source>Normally, when SQLite writes to a database file, it waits until the write operation is finished before returning control to the calling application. Since writing to the file-system is usually very slow compared with CPU bound operations, this can be a performance bottleneck. The asynchronous I/O backend is an extension that causes SQLite to perform all write requests using a separate thread running in the background. Although this does not reduce the overall system resources (CPU, disk bandwidth etc.), it does allow SQLite to return control to the caller quickly even when writing to the database.</source>
          <target state="translated">通常、SQLite がデータベースファイルに書き込む際には、書き込み操作が終了するまで待ってから呼び出し元のアプリケーションに制御を返します。ファイルシステムへの書き込みは通常、CPUに依存した操作に比べて非常に遅いため、これがパフォーマンスのボトルネックになることがあります。非同期I/Oバックエンドは、SQLiteがバックグラウンドで実行している別のスレッドを使ってすべての書き込み要求を実行するようにする拡張機能です。これはシステム全体のリソース(CPUやディスクの帯域幅など)を削減するものではありませんが、データベースへの書き込み中でもSQLiteが呼び出し元に制御を迅速に返すことができるようになります。</target>
        </trans-unit>
        <trans-unit id="b810f7b8c9c4b12cca67db5205f27d6d0477e848" translate="yes" xml:space="preserve">
          <source>Normally, when a row is inserted into an FTS5 table, as well as the various full-text index entries and other data a copy of the row is stored in a private table managed by the FTS5 module. When column values are requested from the FTS5 table by the user or by an auxiliary function implementation, they are read from this private table. The &quot;content&quot; option may be used to create an FTS5 table that stores only FTS full-text index entries. Because the column values themselves are usually much larger than the associated full-text index entries, this can save significant database space.</source>
          <target state="translated">通常、行がFTS5テーブルに挿入されると、様々なフルテキストインデックスエントリやその他のデータと同様に、その行のコピーがFTS5モジュールによって管理されるプライベートテーブルに格納されます。ユーザ又は補助関数の実装によってFTS5テーブルから列の値が要求されると、このプライベートテーブルから読み出される。content」オプションは、FTSフルテキストインデックスエントリのみを格納するFTS5テーブルを作成するために使用することができる。列の値自体は、通常、関連するフルテキストインデックス項目よりもはるかに大きいので、これはデータベースのスペースを大幅に節約することができる。</target>
        </trans-unit>
        <trans-unit id="ca1dd39379254ab3f3c73dbffb0d03d628b27d20" translate="yes" xml:space="preserve">
          <source>Not</source>
          <target state="translated">Not</target>
        </trans-unit>
        <trans-unit id="5927a7e485b2adcf5a36cf65c4801a2eed120fcc" translate="yes" xml:space="preserve">
          <source>Not all applications meet these conditions. Fortunately, the NGQP will still usually find good query plans, even without these conditions. However, cases do arise (rarely) where performance regressions can occur.</source>
          <target state="translated">すべてのアプリケーションがこれらの条件を満たすわけではありません。幸いなことに、これらの条件を満たしていなくても、NGQPは通常、良い問い合わせプランを見つけます。しかし、パフォーマンスの低下が発生する場合もあります(まれにですが)。</target>
        </trans-unit>
        <trans-unit id="6938024f626f02a7276620a318f6367169f62576" translate="yes" xml:space="preserve">
          <source>Not all test cases can be handled this way. Some test cases check to verify that the optimizations really are reducing the amount of computation by counting the number of disk accesses, sort operations, full-scan steps, or other processing steps that occur during queries. Those test cases will appear to fail when optimizations are disabled. But the majority of test cases simply check that the correct answer was obtained, and all of those cases can be run successfully with and without the optimizations, in order to show that the optimizations do not cause malfunctions.</source>
          <target state="translated">すべてのテストケースがこの方法で処理できるわけではありません。一部のテストケースでは、ディスクアクセス数、ソート操作、フルスキャンステップ、またはクエリ中に発生するその他の処理ステップをカウントすることで、最適化によって本当に計算量が削減されているかどうかを確認します。これらのテストケースは、最適化が無効になっている場合には失敗するように見えます。しかし、テストケースの大部分は単に正しい答えが得られたかどうかをチェックするだけで、最適化の有無にかかわらずすべてのケースを正常に実行して、最適化が誤動作を引き起こさないことを示します。</target>
        </trans-unit>
        <trans-unit id="d047995ecc6203bb86f7cef3de1f0a2b4fa5dba8" translate="yes" xml:space="preserve">
          <source>Not ever decimal number with fewer than 16 significant digits can be represented exactly as a binary64 number. In fact, most decimal numbers with digits to the right of the decimal point lack an exact binary64 equivalent. For example, if you have a database column that is intended to hold an item price in dollars and cents, the only cents value that can be exactly represented are 0.00, 0.25, 0.50, and 0.75. Any other numbers to the right of the decimal point result in an approximation. If you provide a &quot;price&quot; value of 47.49, that number will be represented in binary64 as:</source>
          <target state="translated">有効桁数が16桁未満の10進数が、正確にbinary64数として表現できるわけではありません。実際、小数点以下の桁数を持つほとんどの10進数には、正確なbinary64と同等のものがありません。例えば、商品価格をドルとセントで保持するデータベースのカラムがある場合、正確に表現できるセント値は0.00、0.25、0.50、および0.75のみです。小数点の右側にあるその他の数字は、近似値となります。47.49という「価格」の値を指定した場合、その数値は次のように2進数で表現されます。</target>
        </trans-unit>
        <trans-unit id="593dbd15d49368a738585302a9107baf925136df" translate="yes" xml:space="preserve">
          <source>Not shown in the example above is that there are also &lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;various options&lt;/a&gt; that may be provided to FTS5 as part of the CREATE VIRTUAL TABLE statement to configure various aspects of the new table. These may be used to modify the way in which the FTS5 table extracts terms from documents and queries, to create extra indexes on disk to speed up prefix queries, or to create an FTS5 table that acts as an index on content stored elsewhere.</source>
          <target state="translated">上記の例には示されていませんが、新しいテーブルのさまざまな側面を構成するために、CREATE VIRTUAL TABLEステートメントの一部としてFTS5に提供できる&lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;さまざまなオプション&lt;/a&gt;もあります。これらを使用して、FTS5テーブルがドキュメントとクエリから用語を抽出する方法を変更したり、ディスクに追加のインデックスを作成してプレフィックスクエリを高速化したり、他の場所に格納されているコンテンツのインデックスとして機能するFTS5テーブルを作成したりできます。</target>
        </trans-unit>
        <trans-unit id="edbfab21e07e4e0dbe02fb875980c40bdd52ad0f" translate="yes" xml:space="preserve">
          <source>NotExists</source>
          <target state="translated">NotExists</target>
        </trans-unit>
        <trans-unit id="6f05e7cc9203f83829c08dcc46fafe9db426763f" translate="yes" xml:space="preserve">
          <source>NotFound</source>
          <target state="translated">NotFound</target>
        </trans-unit>
        <trans-unit id="85c73c74f4b29a9fb7ba8d0a5bc532eb27f0866a" translate="yes" xml:space="preserve">
          <source>NotNull</source>
          <target state="translated">NotNull</target>
        </trans-unit>
        <trans-unit id="7884a1030f088443b3e65dc8c7d9c833c3f14209" translate="yes" xml:space="preserve">
          <source>Nota bene:</source>
          <target state="translated">Nota bene.</target>
        </trans-unit>
        <trans-unit id="59ab81d7ff99620547d7c60a07878ec16f88cba0" translate="yes" xml:space="preserve">
          <source>Note also that when adding a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt;, the CHECK constraint is not tested against preexisting rows of the table. This can result in a table that contains data that is in violation of the CHECK constraint. Future versions of SQLite might change to validate CHECK constraints as they are added.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK制約を&lt;/a&gt;追加する場合、CHECK制約はテーブルの既存の行に対してテストされないことにも注意してください。これにより、CHECK制約に違反するデータを含むテーブルが作成される可能性があります。SQLiteの将来のバージョンでは、追加されたCHECK制約を検証するように変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="63cff68b4cc8b6d1593b377ca2761e4a780c9aef" translate="yes" xml:space="preserve">
          <source>Note that &quot;monotonically increasing&quot; does not imply that the ROWID always increases by exactly one. One is the usual increment. However, if an insert fails due to (for example) a uniqueness constraint, the ROWID of the failed insertion attempt might not be reused on subsequent inserts, resulting in gaps in the ROWID sequence. AUTOINCREMENT guarantees that automatically chosen ROWIDs will be increasing but not that they will be sequential.</source>
          <target state="translated">単調に増加する」というのは、ROWIDが常に正確に1だけ増加することを意味するわけではないことに注意してください。1は通常の増分です。しかし、(例えば)一意性制約のために挿入が失敗した場合、失敗した挿入試行の ROWID はその後の挿入で再利用されず、結果として ROWID シーケンスにギャップが生じる可能性があります。AUTOINCREMENT は、自動的に選択された ROWID が増加することを保証しますが、それらが順次になることは保証しません。</target>
        </trans-unit>
        <trans-unit id="4308667a324be6565f7e88fc7a4b19a7777f66dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;または&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;は、副作用としてデータベースを間接的に変更する可能性があることに注意してください。たとえば、アプリケーションが&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;を呼び出す関数 &quot;eval（）&quot;を定義している場合、次のSQLステートメントは副作用によってデータベースファイルを変更します。</target>
        </trans-unit>
        <trans-unit id="2de1256b9fbe19c405bb475cc7365f640da5726d" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">&lt;a href=&quot;../appfunc&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;または&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;は、副作用としてデータベースを間接的に変更する可能性があることに注意してください。たとえば、アプリケーションが&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;を呼び出す関数 &quot;eval（）&quot;を定義している場合、次のSQLステートメントは副作用によってデータベースファイルを変更します。</target>
        </trans-unit>
        <trans-unit id="2a8f4592d0e17a85103883247d0a4447a3744957" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="translated">&lt;a href=&quot;appfunc&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;は、デフォルトでは非決定論的と&lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;見なされ&lt;/a&gt;、関数の登録時にSQLITE_DETERMINISTICフラグが使用されない限り、CREATEINDEXステートメントで使用できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="1de4b11ed42096116749429497dc130939876ea1" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">&lt;a href=&quot;appfunc&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;または&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;は、副作用としてデータベースを間接的に変更する可能性があることに注意してください。たとえば、アプリケーションが&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;を呼び出す関数 &quot;eval（）&quot;を定義している場合、次のSQLステートメントは副作用によってデータベースファイルを変更します。</target>
        </trans-unit>
        <trans-unit id="aa33906842475ccf0659a59159f766bfacc10e93" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;は、デフォルトでは非決定的と&lt;a href=&quot;c3ref/c_deterministic&quot;&gt;見なされ&lt;/a&gt;、関数の登録時にSQLITE_DETERMINISTICフラグを使用しない限り、CREATE INDEXステートメントで使用できない場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5f9e6d6d8a3bf2c6d2a7e519940c1c6c58742f80" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">&lt;a href=&quot;create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;または&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;は、副作用としてデータベースを間接的に変更する可能性があることに注意してください。たとえば、アプリケーションが&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;を呼び出す関数 &quot;eval（）&quot;を定義している場合、次のSQLステートメントは副作用によってデータベースファイルを変更します。</target>
        </trans-unit>
        <trans-unit id="f679875d06130633120a14b47faa759dd16975f1" translate="yes" xml:space="preserve">
          <source>Note that Idx3 contains all the same information as the original &lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt;. And so if we have Idx3, we do not really need Idx1 any more. The &quot;price of peaches&quot; query can be satisfied using Idx3 by simply ignoring the &quot;state&quot; column of Idx3:</source>
          <target state="translated">Idx3には、元の&lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt;と同じ情報がすべて含まれていることに注意してください。Idx3があれば、Idx1はもう必要ありません。「桃の価格」クエリは、Idx3の「state」列を単に無視することで、Idx3を使用して満たすことができます。</target>
        </trans-unit>
        <trans-unit id="8e97b2bc14d77a13e225d171f50b67e2004fff89" translate="yes" xml:space="preserve">
          <source>Note that MinGW generates 32-bit DLLs only. There is a separate MinGW64 project that can be used to generate 64-bit DLLs. Presumably the command-line syntax is similar. Also note that recent versions of MSVC generate DLLs that will not work on WinXP and earlier versions of Windows. So for maximum compatibility of your generated DLL, MinGW is recommended. A good rule-of-thumb is to generate 32-bit DLLs using MinGW and 64-bit DLLs using MSVC.</source>
          <target state="translated">MinGWは32ビットのDLLのみを生成することに注意してください。別のMinGW64プロジェクトがあり、これを使って64ビットDLLを生成することができます。おそらくコマンドラインの構文は似ていると思われます。また、MSVCの最近のバージョンでは、WinXPやそれ以前のバージョンのWindowsでは動作しないDLLを生成することにも注意してください。そのため、生成されたDLLの互換性を最大限に高めるためには、MinGWをお勧めします。目安としては、MinGWを使って32ビットのDLLを生成し、MSVCを使って64ビットのDLLを生成するのが良いでしょう。</target>
        </trans-unit>
        <trans-unit id="103d786acd07e894276011f9fe0ff0e5d6f3f4da" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">SQLITE_IGNOREは、&lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;インターフェースから返される&lt;a href=&quot;#SQLITE_FAIL&quot;&gt;競合解決モード&lt;/a&gt;としても使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="82cf9ab6c420a3c604d44b14992c4f512d1f4c35" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;c_fail&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">SQLITE_IGNOREは、&lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;インターフェースから返される&lt;a href=&quot;c_fail&quot;&gt;競合解決モード&lt;/a&gt;としても使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="63e763dca84d9237a89baecc3d0c141975e41415" translate="yes" xml:space="preserve">
          <source>Note that SQLite allows the number of reserve-bytes to be increased but not decreased. So if a database file already has a reserve-bytes value greater than 8, there is no way to activate checksumming on that database, other than to dump and restore the database file. Note also that other extensions might also make use of the reserve-bytes. Checksumming will be incompatible with those other extensions.</source>
          <target state="translated">SQLite ではリザーブバイト数を増やすことはできますが、減らすことはできないことに注意してください。そのため、もしデータベースファイルのリザーブバイトの値が既に8よりも大きい場合、そのデータベースファイルをダンプしてリストアする以外に、そのデータベースでチェックサムを有効にする方法はありません。また、他の拡張機能でもリザーブバイトを利用している可能性があることにも注意してください。チェックサムは他の拡張モジュールとは互換性がありません。</target>
        </trans-unit>
        <trans-unit id="bd4aaf9aa187deca337c2af0406d2d0e3c9d07f4" translate="yes" xml:space="preserve">
          <source>Note that SQLite allows the parenthesized list of scalar values on the right-hand side of an IN or NOT IN operator to be an empty list but most other SQL database database engines and the SQL92 standard require the list to contain at least one element.</source>
          <target state="translated">SQLite では IN または NOT IN 演算子の右側にあるスカラ値の括弧付きリストを空リストにすることができますが、他のほとんどの SQL データベースエンジンや SQL92 標準では、リストに少なくとも 1 つの要素を含める必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="069a48733ca46d6fc20e074068d69739ed664b2b" translate="yes" xml:space="preserve">
          <source>Note that SQLite automatically adds the appropriate extension suffix (&quot;.dll&quot; on windows, &quot;.dylib&quot; on Mac, &quot;.so&quot; on most other unixes) to the extension filename. It is generally a good idea to specify the full pathname of the extension.</source>
          <target state="translated">SQLite は自動的に適切な拡張子のサフィックス (&quot;windows では&quot;.dll&quot;、Mac では &quot;.dylib&quot;、他のほとんどの Unix では &quot;.so&quot;)を拡張子ファイル名に追加することに注意してください。一般的には、拡張子のフルパス名を指定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="878abfb73c8f4fd7637bff37205a9854afa6975b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;../malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">SQLiteには、圧倒的多数のアプリケーションに完全に適した&lt;a href=&quot;../malloc#altalloc&quot;&gt;組み込みメモリアロケータ&lt;/a&gt;がいくつか付属しており、このオブジェクトは、特殊なメモリ割り当て要件を持つごく少数のアプリケーションにのみ役立つことに注意してください。このオブジェクトは、SQLiteのテスト中に、メモリ不足状態をシミュレートする代替メモリアロケータを指定して、SQLiteがそのような状態から正常に回復することを確認するためにも使用されます。</target>
        </trans-unit>
        <trans-unit id="8a9932e44739c8fef89cbf2d998599f354bb604b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">SQLiteには、圧倒的多数のアプリケーションに完全に適した&lt;a href=&quot;malloc#altalloc&quot;&gt;組み込みメモリアロケータ&lt;/a&gt;がいくつか付属しており、このオブジェクトは、特殊なメモリ割り当て要件を持つごく少数のアプリケーションにのみ役立つことに注意してください。このオブジェクトは、SQLiteのテスト中に、メモリ不足状態をシミュレートする代替メモリアロケータを指定して、SQLiteがそのような状態から正常に回復することを確認するためにも使用されます。</target>
        </trans-unit>
        <trans-unit id="f1f541cbfa03c47b900f800f3f8afdec05b49044" translate="yes" xml:space="preserve">
          <source>Note that SQLite does not enforce the PRIMARY KEY for a WITHOUT ROWID virtual table. Enforcement is the responsibility of the underlying virtual table implementation. But SQLite does assume that the PRIMARY KEY constraint is valid - that the identified columns really are UNIQUE and NOT NULL - and it uses that assumption to optimize queries against the virtual table.</source>
          <target state="translated">SQLite は WITHOUT ROWID 仮想テーブルの PRIMARY KEY を強制しないことに注意してください。強制するかどうかは、基礎となる仮想テーブルの実装の責任となります。しかし、SQLite は PRIMARY KEY 制約が有効であること、つまり識別された列が本当に UNIQUE で NOT NULL であることを前提としており、その前提を用いて仮想テーブルに対するクエリを最適化します。</target>
        </trans-unit>
        <trans-unit id="d3bdb4d9a8050dadd7145a64b6065f6da75ef0eb" translate="yes" xml:space="preserve">
          <source>Note that SQLite must believe whatever the operating system and hardware tell it about the status of sync requests. There is no way for SQLite to detect that either is lying and that writes might be occurring out-of-order. However, SQLite in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is far more forgiving of out-of-order writes than in the default rollback journal modes. In WAL mode, the only time that a failed sync operation can cause database corruption is during a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operation. A sync failure during a COMMIT might result in loss of durability but not in a corrupt database file. Hence, one line of defense against database corruption due to failed sync operations is to use SQLite in WAL mode and to checkpoint as infrequently as possible.</source>
          <target state="translated">SQLiteは、オペレーティングシステムとハードウェアが同期要求のステータスについて教えているものをすべて信じなければならないことに注意してください。 SQLiteがどちらかが嘘であり、書き込みが順不同で発生している可能性があることを検出する方法はありません。ただし、&lt;a href=&quot;wal&quot;&gt;WALモードの&lt;/a&gt; SQLiteは、デフォルトのロールバックジャーナルモードよりも、順序の乱れた書き込みをはるかに許容します。 WALモードでは、失敗した同期操作がデータベースの破損を引き起こす可能性があるのは、&lt;a href=&quot;wal#ckpt&quot;&gt;チェックポイント&lt;/a&gt;操作中のみです。 COMMIT中に同期が失敗すると、耐久性が失われる可能性がありますが、データベースファイルが破損することはありません。したがって、同期操作の失敗によるデータベースの破損に対する防御策の1つは、SQLiteをWALモードで使用し、チェックポイントをできるだけ少なくすることです。</target>
        </trans-unit>
        <trans-unit id="a2fee544cde41af143fe81786b7190276086b344" translate="yes" xml:space="preserve">
          <source>Note that SQLite uses b-trees, which are a sorted data structure, so indices can be used when the WHERE clause of the SELECT statement contains tests for equality or inequality. Queries like the following can use an index if it is available:</source>
          <target state="translated">SQLite はソートされたデータ構造である b-tree を使用しているため、SELECT 文の WHERE 句に等しさや不等しさのテストが含まれている場合にインデックスを使用することができることに注意してください。以下のようなクエリでは、インデックスが利用可能であればインデックスを使用することができます。</target>
        </trans-unit>
        <trans-unit id="5081483bfc5c0173b67743dd4507d0595797d951" translate="yes" xml:space="preserve">
          <source>Note that a declared type of &quot;FLOATING POINT&quot; would give INTEGER affinity, not REAL affinity, due to the &quot;INT&quot; at the end of &quot;POINT&quot;. And the declared type of &quot;STRING&quot; has an affinity of NUMERIC, not TEXT.</source>
          <target state="translated">FLOATING POINT&quot; の宣言型は、&quot;POINT&quot; の最後に &quot;INT&quot; があるため、REAL ではなく INTEGER との親和性を持つことに注意してください。また、宣言された &quot;STRING&quot; の型は、NUMERIC の親和性を持ち、TEXT の親和性を持ちません。</target>
        </trans-unit>
        <trans-unit id="6008db09d7c79dcc3b84a140fc5e215929e6ce79" translate="yes" xml:space="preserve">
          <source>Note that a transformation that flips the polygon might cause the order of vertexes to be reversed. In other words, the transformation might cause the vertexes to circulate in clockwise order instead of counter-clockwise. This can be corrected by sending the result through the &lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw()&lt;/a&gt; function after transformation.</source>
          <target state="translated">ポリゴンを反転する変換では、頂点の順序が逆になる可能性があることに注意してください。つまり、変換により、頂点が反時計回りではなく時計回りに循環する場合があります。これは、変換後に&lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw（）&lt;/a&gt;関数を使用して結果を送信することで修正できます。</target>
        </trans-unit>
        <trans-unit id="3eb1501d271603c6953bfb8ef829d45c83d17e8d" translate="yes" xml:space="preserve">
          <source>Note that an inner transaction might commit (using the RELEASE command) but then later have its work undone by a ROLLBACK in an outer transaction. A power failure or program crash or OS crash will cause the outer-most transaction to rollback, undoing all changes that have occurred within that outer transaction, even changes that have supposedly been &quot;committed&quot; by the RELEASE command. Content is not actually committed on the disk until the outermost transaction commits.</source>
          <target state="translated">内部のトランザクションが(RELEASEコマンドを使用して)コミットした後、外部のトランザクションのROLLBACKによってその作業が取り消されるかもしれないことに注意すること。停電、プログラムのクラッシュ、OS のクラッシュは、一番外側のトランザクションをロールバックさせ、その外側のトランザクショ ン内で発生したすべての変更を元に戻し、RELEASE コマンドによって「コミット」されたと思われる変更でさえも元に戻す。コンテンツは、最も外側のトランザクションがコミットするまで、実際にはディスク上にコミットされません。</target>
        </trans-unit>
        <trans-unit id="7c93fd99fb4687ad2997daf3b6769cc616b7c58e" translate="yes" xml:space="preserve">
          <source>Note that conflict resolutions from multiple remote changesets are combined on a per-field basis, not per-row. This means that in the case of multiple remote UPDATE operations, some fields of a single local change may be rebased for REPLACE while others are rebased for OMIT.</source>
          <target state="translated">複数のリモートチェンジセットからの競合解決は、行単位ではなく、フィールド単位で結合されることに注意してください。これは、複数のリモートUPDATE操作の場合、単一のローカル変更の一部のフィールドはREPLACEでリベースされ、他のフィールドはOMITでリベースされる可能性があることを意味します。</target>
        </trans-unit>
        <trans-unit id="e3af7101a58299023cb05d90e0fc88f9fa63608b" translate="yes" xml:space="preserve">
          <source>Note that conversions between UTF-16be and UTF-16le are always done in place and do not invalidate a prior pointer, though of course the content of the buffer that the prior pointer points to will have been modified. Other kinds of conversion are done in place when it is possible, but sometime it is not possible and in those cases prior pointers are invalidated.</source>
          <target state="translated">UTF-16be と UTF-16le 間の変換は常にその場で行われ、先行ポ イ ン タ ーは無効にはなりません。その他の種類の変換は可能な場合にはその場で行われますが、それが不可能な場合もあり、その場合には先行ポインタは無効になります。</target>
        </trans-unit>
        <trans-unit id="f0c5f85c046ed0d0d783a57a522950f881e39de3" translate="yes" xml:space="preserve">
          <source>Note that deleting records from a zip archive does not reclaim the space used within the archive - it merely removes an entry from the archives &quot;Central Directory Structure&quot;, making the entry inaccessible. One way to work around this inefficiency is to create a new zip archive based on the contents of the edited archive. For example, after editing the archive accessed via virtual table temp.zzz:</source>
          <target state="translated">ZIP アーカイブからレコードを削除しても、アーカイブ内で使われているスペースを取り戻すわけではないことに注意してください。この非効率性を回避する一つの方法は、編集したアーカイブの内容に基づいて新しい zip アーカイブを作成することです。例えば、仮想テーブル temp.zzz を介してアクセスされたアーカイブを編集した後、次のようにします。</target>
        </trans-unit>
        <trans-unit id="710cdb120286dd832bd6798397cffbb5dfeed9ef" translate="yes" xml:space="preserve">
          <source>Note that different operating systems use different filename suffixes for their shared libraries. Windows use &quot;.dll&quot;, Mac uses &quot;.dylib&quot;, and most unixes other than mac use &quot;.so&quot;. If you want to make your code portable, you can omit the suffix from the shared library filename and the appropriate suffix will be added automatically by the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface.</source>
          <target state="translated">オペレーティングシステムによって、共有ライブラリのファイル名のサフィックスが異なることに注意してください。Windowsは「.dll」を使用し、Macは「.dylib」を使用し、mac以外のほとんどのunixは「.so」を使用します。コードを移植可能にする場合は、共有ライブラリのファイル名から接尾辞を省略できます。適切な接尾辞は、&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;インターフェースによって自動的に追加されます。</target>
        </trans-unit>
        <trans-unit id="c12e1242a0c93cb2f83528b0161fb89fb73eac90" translate="yes" xml:space="preserve">
          <source>Note that each 32768-byte unit of the shm file has its own aHash and aPgno arrays. The aHash array for a single unit is only helpful in finding aPgno entries in that same unit. The overall FindFrame(P,M) function needs to do hash lookups beginning with the latest unit and working backwards to the oldest unit until it finds an answer.</source>
          <target state="translated">shmファイルの各32768バイトのユニットには、それぞれ独自のaHashとaPgno配列があることに注意してください。一つのユニットの aHash 配列は、同じユニット内の aPgno エントリを見つけるのにのみ役立ちます。全体的な FindFrame(P,M)関数は、答えが見つかるまで、最新のユニットから始まり、最も古いユニットに遡ってハッシュ検索を行う必要があります。</target>
        </trans-unit>
        <trans-unit id="30f49c0b1079064845cadc4000f3f0cbc4ba7f9a" translate="yes" xml:space="preserve">
          <source>Note that enabling FTS3 also makes FTS4 available. There is not a separate SQLITE_ENABLE_FTS4 compile-time option. A build of SQLite either supports both FTS3 and FTS4 or it supports neither.</source>
          <target state="translated">FTS3 を有効にすると FTS4 も使用可能になることに注意してください。SQLITE_ENABLE_FTS4 コンパイル時オプションは別途用意されていません。SQLite のビルドは FTS3 と FTS4 の両方をサポートしているか、どちらもサポートしていません。</target>
        </trans-unit>
        <trans-unit id="665e7a6fdd40011f21f13b4109b67442ccc2792c" translate="yes" xml:space="preserve">
          <source>Note that except for a few corner-case differences detailed above, WITHOUT ROWID tables and rowid tables work the same. They both generate the same answers given the same SQL statements. So it is a simple matter to run experiments on an application, late in the development cycle, to test whether or not the use of WITHOUT ROWID tables will be helpful. A good strategy is to simply not worry about WITHOUT ROWID until near the end of product development, then go back and run tests to see if adding WITHOUT ROWID to tables with non-integer PRIMARY KEYs helps or hurts performance, and retaining the WITHOUT ROWID only in those cases where it helps.</source>
          <target state="translated">上記で詳述したいくつかのコーナーケースの違いを除いて、WITHOUT ROWIDテーブルとROWIDテーブルは同じように動作することに注意してください。どちらも同じSQL文が与えられたときに同じ答えを生成します。ですから、開発サイクルの後半にアプリケーションで実験を実行して、WITHOUT ROWIDテーブルの使用が役に立つかどうかをテストするのは簡単なことです。良い戦略は、製品開発の終わり近くまでWITHOUT ROWIDを気にしないことです。その後、戻ってテストを実行し、非整数のPRIMARY KEYを持つテーブルにWITHOUT ROWIDを追加することがパフォーマンスに役立つかどうかを確認し、WITHOUT ROWIDは役立つ場合にのみ保持することです。</target>
        </trans-unit>
        <trans-unit id="bde5b3e09fe9bd78baf5c5b8cf655c1d83bf9828" translate="yes" xml:space="preserve">
          <source>Note that geopoly uses a traditional right-handed cartesian coordinate system with the origin at the lower left, whereas SVG uses a left-handed coordinate system with the origin at the upper left. The geopoly_svg() routine makes no attempt to transform the coordinate system, so the displayed images are shown in mirror image and rotated. If that is undesirable, the geopoly_xform() routine can be used to transform the output from cartesian to SVG coordinates prior to passing the polygons into geopoly_svg().</source>
          <target state="translated">geopoly は左下を原点とする伝統的な右手の直交座標系を使用しているのに対し、SVG は左上を原点とする左手の座標系を使用していることに注意してください。geopoly_svg()ルーチンは座標系を変換しようとしないので、表示される画像は鏡像で表示され、回転されます。それが望ましくない場合は、 geopoly_svg()にポリゴンを渡す前に、 geopoly_xform()ルーチンを使用して、出力を直交座標系から SVG 座標系に変換することができます。</target>
        </trans-unit>
        <trans-unit id="98a440c913714baad6d711ca1c482bbb8e3fece7" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">非決定的関数が&lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;でタグ付けされている場合、その関数が&lt;a href=&quot;partialindex&quot;&gt;部分インデックスの&lt;/a&gt; WHERE句または&lt;a href=&quot;expridx&quot;&gt;式インデックス&lt;/a&gt;で使用されると、関数が異なる回答を返し始めると、関連付けられたインデックスが破損する可能性があることに注意してください。。 SQL関数がほぼ確定的であり（つまり、&lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version（）の&lt;/a&gt;ようにほとんど変更されない場合）、破損したインデックスで使用される場合、&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;を実行することで破損を修正できます。</target>
        </trans-unit>
        <trans-unit id="c13f9095e78ebed2a9c8d270bb63e3a9b47c70fe" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">非決定論的関数が&lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;でタグ付けされ、その関数が&lt;a href=&quot;partialindex&quot;&gt;部分インデックスの&lt;/a&gt;WHERE句または&lt;a href=&quot;expridx&quot;&gt;式インデックス&lt;/a&gt;で使用されることになった場合、関数が異なる回答を返し始めると、関連するインデックスが破損する可能性があることに注意してください。。 SQL関数がほぼ決定論的であり（つまり、&lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version（）の&lt;/a&gt;ようにほとんど変更されない場合）、破損したインデックスで使用されている場合は、&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;を実行することで破損を修正できます。</target>
        </trans-unit>
        <trans-unit id="3e7ef1f945a3c3a6083df7d03b59a24fcefb7fd0" translate="yes" xml:space="preserve">
          <source>Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc() returns a different mutex on every call. For the static mutex types, the same mutex is returned on every call that has the same type number.</source>
          <target state="translated">動的ミューテックスパラメータ(SQLITE_MUTEX_FASTまたはSQLITE_MUTEX_RECURSIVE)が使用されている場合、sqlite3_mutex_alloc()はコールごとに異なるミューテックスを返すことに注意してください。静的なミューテックス型の場合は、同じ型番号を持つ全ての呼び出しで同じミューテックスが返されます。</target>
        </trans-unit>
        <trans-unit id="1c50891c113debf231642ee8d937768c49d352cf" translate="yes" xml:space="preserve">
          <source>Note that if you do not include the &quot;langid=N&quot; term in the WHERE clause, the search will be against language 0 (English in the example above.) All spellfix1 searches are against a single language id. There is no way to search all languages at once.</source>
          <target state="translated">WHERE 句に &quot;langid=N&quot; を含まない場合は、言語 0 (上の例では英語)を対象とした検索になることに注意しましょう。すべての言語を一度に検索する方法はありません。</target>
        </trans-unit>
        <trans-unit id="67f33837baeec763fa57cef78587afa10292c83d" translate="yes" xml:space="preserve">
          <source>Note that in most cases, SQLite will only use a single index for each table in the FROM clause of a query. The second OR-clause optimization described here is the exception to that rule. With an OR-clause, a different index might be used for each subterm in the OR-clause.</source>
          <target state="translated">ほとんどの場合、SQLiteはクエリのFROM句の各テーブルに対して単一のインデックスしか使用しないことに注意してください。ここで説明する二番目のOR句の最適化は、このルールの例外です。OR句では、OR句の各サブタームに対して異なるインデックスが使用されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="63fa9dab5a3c38f244560b4ee3d5231308f8ad59" translate="yes" xml:space="preserve">
          <source>Note that in order for the special &quot;:memory:&quot; name to apply and to create a pure in-memory database, there must be no additional text in the filename. Thus, a disk-based database can be created in a file by prepending a pathname, like this: &quot;./:memory:&quot;.</source>
          <target state="translated">特別な &quot;:memory:&quot; という名前が適用され、純粋なインメモリデータベースを作成するためには、 ファイル名の中に追加のテキストがあってはならないことに注意してください。したがって、ディスクベースのデータベースは、以下のようにパス名を前置してファイル内に作成することができます。&quot;./:memory:&quot; のようにパス名を前置することで、ファイル内にディスクベースのデータベースを作成することができます。</target>
        </trans-unit>
        <trans-unit id="1b52e107709738a3260fec8ebd98ff46511f5c58" translate="yes" xml:space="preserve">
          <source>Note that in the diagram above, we showed the private edits as a single commit. This was for clarity of presentation only. There is nothing to stop you from doing dozens or hundreds of separate tiny changes and committing each separately. In fact, making many small changes is the preferred way to work. The only reason for doing all the changes in a single commit is that it makes the diagram easier to draw.</source>
          <target state="translated">上の図では、プライベートな編集を単一のコミットとして表示したことに注意してください。これは表示をわかりやすくするためだけのものです。何十個も何百個もの小さな変更を個別に行い、それぞれを個別にコミットすることを止めるものは何もありません。実際には、多くの小さな変更を行うことが望ましい作業方法です。すべての変更を単一のコミットで行う唯一の理由は、図を描きやすくするためです。</target>
        </trans-unit>
        <trans-unit id="705b7526443ed2af20dbc38ecc0ad5be9f1ce9d9" translate="yes" xml:space="preserve">
          <source>Note that in this design, the tokenizer calls the parser. People who are familiar with YACC and BISON may be accustomed to doing things the other way around &amp;mdash; having the parser call the tokenizer. Having the tokenizer call the parser is better, though, because it can be made threadsafe and it runs faster.</source>
          <target state="translated">この設計では、トークナイザーがパーサーを呼び出すことに注意してください。YACCとBISONに精通している人々は、逆の方法でパーサーにトークナイザーを呼び出させるのに慣れているかもしれません。ただし、トークナイザがパーサーを呼び出すようにすると、スレッドセーフにすることができ、実行速度が向上するため、より優れています。</target>
        </trans-unit>
        <trans-unit id="819e65339172e5dc379cf7c2c3439c1fadf7ced3" translate="yes" xml:space="preserve">
          <source>Note that infix functions (&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;, and &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;) reverse the order of their arguments. So &quot;like(A,B)&quot; is equivalent to &quot;B like A&quot;. For the form &quot;B like A&quot; the B term is considered the first argument to the function. But for &quot;like(A,B)&quot; the A term is considered the first argument.</source>
          <target state="translated">イン&lt;a href=&quot;lang_expr#glob&quot;&gt;フィックス&lt;/a&gt;関数（&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;、GLOB、&lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;、および&lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;）は、引数の順序を逆にすることに注意してください。したがって、「like（A、B）」は「B like A」と同等です。「B like A」の形式の場合、B項は関数の最初の引数と見なされます。ただし、「like（A、B）」の場合、A項が最初の引数と見なされます。</target>
        </trans-unit>
        <trans-unit id="35589dde916482f10a4613056291243d802b1cc4" translate="yes" xml:space="preserve">
          <source>Note that it is important to set the &quot;mode&quot; to &quot;csv&quot; before running the &quot;.import&quot; command. This is necessary to prevent the command-line shell from trying to interpret the input file text as some other format.</source>
          <target state="translated">.import &quot;コマンドを実行する前に &quot;mode &quot;を &quot;csv &quot;に設定することが重要であることに注意してください。これは、コマンドラインシェルが入力ファイルのテキストを他の形式として解釈しようとするのを防ぐために必要です。</target>
        </trans-unit>
        <trans-unit id="aab0f603b95c5838db66d31fe53b5c5afd66afd1" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary for all coordinates in an R*Tree index to be constrained in order for the index search to be efficient. One might, for example, want to query all objects that overlap with the 35th parallel:</source>
          <target state="translated">インデックス検索を効率的に行うためには、R*Treeインデックス内のすべての座標に制約がある必要はないことに注意してください。例えば、35番目の平行線と重なるすべてのオブジェクトを検索したいとします。</target>
        </trans-unit>
        <trans-unit id="750004cbbcdb4b09f134058116396d2802e69e0a" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to quote the $bigstring value. That happens automatically. If $bigstring is a large string or binary object, this technique is not only easier to write, it is also much more efficient since it avoids making a copy of the content of $bigstring.</source>
          <target state="translated">BIGSTRING の値を引用する必要はないことに注意してください。これは自動的に行われます。BIGSTRING が大きな文字列やバイナリオブジェクトの場合は、この方法の方が書きやすいだけでなく、 $BIGSTRING の内容のコピーを作成しなくて済むので、はるかに効率的です。</target>
        </trans-unit>
        <trans-unit id="aedf129a94b2c6ea4cf41bd3da4352659cc6bb37" translate="yes" xml:space="preserve">
          <source>Note that it is perfectly safe for two or more threads to access the same SQLite database file using the SQLite library. The unix drivers for SQLite know about the POSIX advisory locking quirks and work around them. This problem only arises when a thread tries to bypass the SQLite library and read the database file directly.</source>
          <target state="translated">2つ以上のスレッドがSQLiteライブラリを使用して同じSQLiteデータベースファイルにアクセスすることは完全に安全であることに注意してください。SQLite 用の unix ドライバは POSIX 勧告のロックの癖を知っており、それを回避しています。この問題は、スレッドが SQLite ライブラリをバイパスしてデータベースファイルを直接読み込もうとした場合にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="af76f7d3a1b3eb149d8a26a0e9299bf38c7c0401" translate="yes" xml:space="preserve">
          <source>Note that it is very important that the database filename have some kind of extension. If there is no extension, then SQLite creates auxiliary filenames by appending to the base name of the file. Thus, a database named &quot;&lt;code&gt;db01&lt;/code&gt;&quot; would have a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; file named &quot;&lt;code&gt;db01-journal&lt;/code&gt;&quot;. And as this filename has no extension to shorten to 3 characters, it will be used as-is, and will violate 8+3 naming rules.</source>
          <target state="translated">データベースのファイル名になんらかの拡張子を付けることが非常に重要であることに注意してください。拡張子がない場合、SQLiteはファイルのベース名に追加して補助ファイル名を作成します。したがって、「 &lt;code&gt;db01&lt;/code&gt; 」という名前のデータベースには、「 &lt;code&gt;db01-journal&lt;/code&gt; 」という名前の&lt;a href=&quot;lockingv3#rollback&quot;&gt;ロールバックジャーナル&lt;/a&gt;ファイルがあります。また、このファイル名には3文字に短縮する拡張子がないため、そのまま使用され、8 + 3の命名規則に違反します。</target>
        </trans-unit>
        <trans-unit id="19eeeefb37e5b82a70fbf6a86a847157f005c210" translate="yes" xml:space="preserve">
          <source>Note that prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), SQLite did not check the xCreate method for NULL before invoking it. So if an eponymous-only virtual table is registered with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;version 3.8.11.1&lt;/a&gt; (2015-07-29) or earlier and a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; command is attempted against that virtual table module, a jump to a NULL pointer will occur, resulting in a crash.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;バージョン3.9.0&lt;/a&gt;（2015-10-14）より前では、SQLiteは呼び出す前にNULLのxCreateメソッドをチェックしていませんでした。したがって、名前のみの仮想テーブルがSQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;バージョン3.8.11.1&lt;/a&gt;（2015-07-29）以前に登録され、その仮想テーブルモジュールに対して&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;コマンドが試行されると、NULLポインターへのジャンプが発生し、クラッシュ。</target>
        </trans-unit>
        <trans-unit id="7cb63274cd75ba4167c68c8885d57c07e7241aab" translate="yes" xml:space="preserve">
          <source>Note that running SQLite with gcov is not a test of SQLite &amp;mdash; it is a test of the test suite. The gcov run does not test SQLite because the -fprofile-args and -ftest-coverage options cause the compiler to generate different code. The gcov run merely verifies that the test suite provides 100% branch test coverage. The gcov run is a test of the test - a meta-test.</source>
          <target state="translated">gcovでSQLiteを実行することはSQLiteのテストではないことに注意してください&amp;mdash;これはテストスイートのテストです。-fprofile-argsおよび-ftest-coverageオプションによりコンパイラーが異なるコードを生成するため、gcovの実行ではSQLiteをテストしません。gcovの実行は、テストスイートが100％ブランチテストカバレッジを提供することを確認するだけです。gcovの実行は、テストのテスト-メタテストです。</target>
        </trans-unit>
        <trans-unit id="5a5f0aee350ad05534eee4c24d91d936725afa91" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;定数は&lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;コールバックからの潜在的な戻り値としても使用され、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;も&lt;a href=&quot;rescode&quot;&gt;結果コードで&lt;/a&gt;あることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f4daa0a4c8ffbaa8c905b7b2b472738ae1e277cf" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces do not count INSTEAD OF trigger firings, but the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; does count INSTEAD OF trigger firing.</source>
          <target state="translated">&lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes（）&lt;/a&gt;および&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;インターフェースはINSTEAD OFトリガーの起動をカウントしませんが、&lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changesプラグマ&lt;/a&gt;はINSTEAD OFトリガーの起動をカウントすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f4f048e66a09e44bfda0411919740620eea7756a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;定数は&lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;コールバックからの潜在的な戻り値としても使用され、&lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;も&lt;a href=&quot;../rescode&quot;&gt;結果コードで&lt;/a&gt;あることに注意してください。</target>
        </trans-unit>
        <trans-unit id="732e678676cbad83be2195f0c9cbdf90bfcdfbeb" translate="yes" xml:space="preserve">
          <source>Note that the DO UPDATE clause acts only on the single row that experienced the constraint error during INSERT. It is not necessary to include a WHERE clause that restrictions the action to that one row. The only use for the WHERE clause at the end of the DO UPDATE is to optionally change the DO UPDATE into a no-op depending on the original and/or new values. For example:</source>
          <target state="translated">DO UPDATE句は、INSERT時に制約エラーが発生した1つの行に対してのみ動作することに注意してください。アクションをその1行に制限するWHERE句を含める必要はありません。DO UPDATEの最後にあるWHERE句の唯一の使用法は、DO UPDATEを元の値および/または新しい値に応じて、オプションでDO UPDATEをno-opに変更することです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="9e431af898d8e365308f86b50efb344365dfb157" translate="yes" xml:space="preserve">
          <source>Note that the SQLITE_TEXT constant was also used in SQLite version 2 for a completely different meaning. Software that links against both SQLite version 2 and SQLite version 3 should use SQLITE3_TEXT, not SQLITE_TEXT.</source>
          <target state="translated">SQLITE_TEXT 定数は SQLite バージョン 2 でも全く異なる意味で使われていたことに注意してください。SQLite バージョン 2 と SQLite バージョン 3 の両方にリンクするソフトウェアは、SQLITE_TEXT ではなく SQLITE3_TEXT を使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="db7397560741b34c84d7c7b13b86a2bbf792ba5b" translate="yes" xml:space="preserve">
          <source>Note that the SQLite parser will not always generate code to use an index, even if it is possible to do so. The following queries will not currently use the index:</source>
          <target state="translated">SQLite パーサーは、インデックスを使用することが可能であっても、必ずしもインデックスを使用するコードを生成するとは限らないことに注意してください。以下のクエリは現在のところインデックスを使用しません。</target>
        </trans-unit>
        <trans-unit id="021cca6e0a1bc313b828c0c99864715910f5cf3d" translate="yes" xml:space="preserve">
          <source>Note that the UNION ALL operator for compound queries does not use transient indices by itself (though of course the right and left subqueries of the UNION ALL might use transient indices depending on how they are composed.)</source>
          <target state="translated">複合クエリ用のUNION ALL演算子は、それ自体では過渡インデックスを使用しないことに注意してください(もちろん、UNION ALLの右と左の副問い合わせがどのように構成されているかによっては過渡インデックスを使用するかもしれませんが)。</target>
        </trans-unit>
        <trans-unit id="0676f5b60fd19b027ecab9b9999e5b7f746d671c" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_prepare&quot;&gt;オーソライザー&lt;/a&gt;コールバックは、sqlite3_prepare（）またはそのバリアントの間にのみ呼び出されることに注意してください。前の段落で述べたように、sqlite3_step（）がsqlite3_prepare_v2（）を呼び出してスキーマの変更後にステートメントを再準備しない限り、&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;でのステートメント評価中は認可は実行されません。</target>
        </trans-unit>
        <trans-unit id="f1e28776761e0bfe4431c21ae77ea6373668b8fc" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">&lt;a href=&quot;prepare&quot;&gt;オーソライザー&lt;/a&gt;コールバックは、sqlite3_prepare（）またはそのバリアントの間にのみ呼び出されることに注意してください。前の段落で述べたように、sqlite3_step（）がsqlite3_prepare_v2（）を呼び出してスキーマの変更後にステートメントを再準備しない限り、&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;でのステートメント評価中は認可は実行されません。</target>
        </trans-unit>
        <trans-unit id="ac6d36a8492877c1ea3743d0c173020c27937cf2" translate="yes" xml:space="preserve">
          <source>Note that the character encoding mechanism used by SQLite cannot be changed at run-time. This is a compile-time option only. The &lt;b&gt;sqlite_encoding&lt;/b&gt; character string just tells you how the library was compiled.</source>
          <target state="translated">SQLiteが使用する文字エンコーディングメカニズムは、実行時に変更できないことに注意してください。これはコンパイル時のオプションのみです。&lt;b&gt;sqlite_encoding&lt;/b&gt;文字列だけでライブラリがコンパイルされた方法を説明します。</target>
        </trans-unit>
        <trans-unit id="7febee2154ade1b2d3219ad0df6d8ce2b6d91690" translate="yes" xml:space="preserve">
          <source>Note that the checksums in the rollback journal are not necessary if the synchronous setting is FULL. We only depend on the checksums when synchronous is lowered to NORMAL. Nevertheless, the checksums never hurt and so they are included in the rollback journal regardless of the synchronous setting.</source>
          <target state="translated">同期設定がFULLの場合、ロールバックジャーナルのチェックサムは必要ないことに注意してください。チェックサムに依存するのは、 synchronous が NORMAL に下げられたときだけです。とはいえ、チェックサムは決して問題にならないので、同期の設定に関係なくロールバックジャーナルに含まれます。</target>
        </trans-unit>
        <trans-unit id="808239b91162b2ff74019b785a2c4443032a884a" translate="yes" xml:space="preserve">
          <source>Note that the command-line shell program has already enabled extension loading for you (by calling the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface as part of its setup) so the command above works without any special switches, setup, or other complications.</source>
          <target state="translated">コマンドラインシェルプログラムでは、拡張機能のロードが既に有効になっている（&lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt;インターフェイスをセットアップの一部として呼び出すことにより）ため、上記のコマンドは特別なスイッチ、セットアップ、またはその他の複雑な作業なしで機能します。</target>
        </trans-unit>
        <trans-unit id="6e9cc72c28987333ade7d6e3571128f51c3b46dd" translate="yes" xml:space="preserve">
          <source>Note that the destructor function D is for the pointer value P, not for the type string T. The type string T should be a static string with an infinite lifetime.</source>
          <target state="translated">デストラクタ関数Dはポインタ値Pに対するものであり、型文字列Tに対するものではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="4cfa4e46e35f2a19630aea45991cffe3dd621ecd" translate="yes" xml:space="preserve">
          <source>Note that the integer key is one greater than the largest key that was in the table just prior to the insert. The new key will be unique over all keys currently in the table, but it might overlap with keys that have been previously deleted from the table. To create keys that are unique over the lifetime of the table, add the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; keyword to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; declaration. Then the key chosen will be one more than the largest key that has ever existed in that table. If the largest possible key has previously existed in that table, then the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error code.</source>
          <target state="translated">整数キーは、挿入直前のテーブルにあった最大のキーよりも1つ大きいことに注意してください。新しいキーは現在テーブルにあるすべてのキーに対して一意ですが、以前にテーブルから削除されたキーと重複する場合があります。テーブルの存続期間を通じて一意のキーを作成するには、&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;キーワードを&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;宣言に追加します。次に、選択されたキーは、そのテーブルに存在する最大のキーより1つ多くなります。可能な最大のキーが以前にそのテーブルに存在していた場合、&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;は&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;エラーコードで失敗します。</target>
        </trans-unit>
        <trans-unit id="228b63ead1b7d1b62a8c83539d4e8ab64da2dc4c" translate="yes" xml:space="preserve">
          <source>Note that the journal_mode for an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; is either MEMORY or OFF and can not be changed to a different value. An attempt to change the journal_mode of an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; to any setting other than MEMORY or OFF is ignored. Note also that the journal_mode cannot be changed while a transaction is active.</source>
          <target state="translated">&lt;a href=&quot;inmemorydb&quot;&gt;インメモリデータベース&lt;/a&gt;のjournal_mode はMEMORYまたはOFFであり、別の値に変更できないことに注意してください。&lt;a href=&quot;inmemorydb&quot;&gt;インメモリデータベース&lt;/a&gt;のjournal_modeをMEMORYまたはOFF以外の設定に変更しようとしても無視されます。また、トランザクションがアクティブな間は、journal_modeを変更できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="1150442b82dfad6909e59c690e94911009ab738b" translate="yes" xml:space="preserve">
          <source>Note that the list of routines above is conceptual rather than actual. Many of these routines come in multiple versions. For example, the list above shows a single routine named &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; when in fact there are three separate routines that accomplish the same thing in slightly different ways: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The list mentions &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; when in fact no such routine exists. The &quot;sqlite3_column()&quot; shown in the list is a placeholder for an entire family of routines that extra column data in various datatypes.</source>
          <target state="translated">上記のルーチンのリストは実際のものではなく概念的なものであることに注意してください。これらのルーチンの多くには、複数のバージョンがあります。例えば、番組上のリスト、単一の名前付きルーチン&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;実際には、わずかに異なる方法で同じことを達成する3つの別々のルーチンがある場合：&lt;a href=&quot;c3ref/open&quot;&gt;（sqlite3_open）は&lt;/a&gt;、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;と&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（） &lt;/a&gt;。リストには実際にはそのようなルーチンが存在しない場合の&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column（）&lt;/a&gt;が記載されています。リストに示されている「sqlite3_column（）」は、さまざまなデータ型の列データを追加するルーチン全体のプレースホルダーです。</target>
        </trans-unit>
        <trans-unit id="4fdc00a153b8f8752a20bfd3564af15ee4f88900" translate="yes" xml:space="preserve">
          <source>Note that the memory leak detection logic continues to work even when the OOM overlay is being used. This verifies that SQLite does not leak memory even when it encounters memory allocation errors. Note also that the OOM overlay can work with any underlying memory allocator, including the instrumented memory allocator that checks for memory allocation misuse. In this way it is verified that OOM errors do not induce other kinds of memory usage errors.</source>
          <target state="translated">OOM オーバーレイが使用されている場合でも、メモリリーク検出ロジックは動作し続けることに注意してください。これにより、SQLite がメモリ割り当てエラーに遭遇してもメモリリークが発生しないことが確認されます。また、OOM オーバーレイは、メモリ割り当ての不正使用をチェックするインスツルメンテッド・メモリ・アロケータを含む、あらゆる基礎となるメモリ・アロケータで動作することにも注意してください。このようにして、OOM エラーが他の種類のメモリ使用エラーを誘発しないことが検証されています。</target>
        </trans-unit>
        <trans-unit id="a2673a9d4ca364b864416763c5f28c9b8fac9ff0" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">SQLiteが理解できるキーワードの数は、コンパイル時のオプションに依存する可能性があることに注意してください。たとえば、SQLiteが&lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt;オプションを使用してコンパイルされている場合、「VACUUM」はキーワードではありません。また、新しいキーワードがSQLiteの将来のリリースに追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="2d91b980ac2f1529b090c5eabcb20ce64f838c85" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">SQLiteが理解できるキーワードの数は、コンパイル時のオプションに依存する可能性があることに注意してください。たとえば、SQLiteが&lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt;オプションを使用してコンパイルされている場合、「VACUUM」はキーワードではありません。また、新しいキーワードがSQLiteの将来のリリースに追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="4aca65a78510b061ab1efe777d7b5b2943653a08" translate="yes" xml:space="preserve">
          <source>Note that the order of the rules for determining column affinity is important. A column whose declared type is &quot;CHARINT&quot; will match both rules 1 and 2 but the first rule takes precedence and so the column affinity will be INTEGER.</source>
          <target state="translated">カラムの親和性を決定するルールの順序が重要であることに注意してください。宣言された型が &quot;CHARINT &quot;であるカラムは、ルール1と2の両方にマッチしますが、最初のルールが優先されるため、カラムの親和性はINTEGERになります。</target>
        </trans-unit>
        <trans-unit id="1d73e69c69eafce89c99fd09f5dcbc2e6299190a" translate="yes" xml:space="preserve">
          <source>Note that the primary result code is always a part of the extended result code. Given a full 32-bit extended result code, the application can always find the corresponding primary result code merely by extracting the least significant 8 bits of the extended result code.</source>
          <target state="translated">一次結果コードは常に拡張結果コードの一部であることに注意してください。完全な32ビットの拡張結果コードが与えられると、アプリケーションは、拡張結果コードの最下位8ビットを抽出するだけで、対応する主結果コードを常に見つけることができます。</target>
        </trans-unit>
        <trans-unit id="299082c757bfbc2b1a98c9af13620cc48c49d3d4" translate="yes" xml:space="preserve">
          <source>Note that the program for this SELECT query didn't contain the Transaction and Commit instructions used in the INSERT example. Because the SELECT is a read operation that doesn't alter the database, it doesn't require a transaction.</source>
          <target state="translated">このSELECTクエリのプログラムには、INSERTの例で使用したトランザクション命令とコミット命令が含まれていないことに注意してください。SELECTはデータベースを変更しない読み取り操作なので、トランザクションは必要ありません。</target>
        </trans-unit>
        <trans-unit id="f586476195ef53b793699f052ad1af05d3a6c8e4" translate="yes" xml:space="preserve">
          <source>Note that the readfile(X) and writefile(X,Y) functions are extension functions and are not built into the core SQLite library. These routines are available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext/misc/fileio.c&lt;/a&gt; source file in the &lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLite source code repositories&lt;/a&gt;.</source>
          <target state="translated">readfile（X）およびwritefile（X、Y）関数は拡張関数であり、コアSQLiteライブラリに組み込まれていないことに注意してください。これらのルーチンは、&lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLiteソースコードリポジトリ&lt;/a&gt;の&lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext / misc / fileio.c&lt;/a&gt;ソースファイルで&lt;a href=&quot;loadext&quot;&gt;ロード可能な拡張機能&lt;/a&gt;として使用できます。</target>
        </trans-unit>
        <trans-unit id="64553501493418021ca0b221dddc1b5aa622fbc2" translate="yes" xml:space="preserve">
          <source>Note that the result from casting any non-BLOB value into a BLOB and the result from casting any BLOB value into a non-BLOB value may be different depending on whether the database &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; is UTF-8, UTF-16be, or UTF-16le.</source>
          <target state="translated">非BLOB値をBLOBにキャストした結果とBLOB値を非BLOB値にキャストした結果は、データベースの&lt;a href=&quot;pragma#pragma_encoding&quot;&gt;エンコーディング&lt;/a&gt;がUTF-8、UTF-16be、またはUTF-16leのいずれであるかによって異なる場合があることに注意してください。 。</target>
        </trans-unit>
        <trans-unit id="e984670ffac060fe0c3430de1a1c23ffe29028d1" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_apply_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">sqlite3changeset_apply_v2（）APIはまだ&lt;b&gt;実験&lt;/b&gt;段階であり、変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a04165c5ad09a6b0ad2414206038c2e65d87aa51" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_start_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">sqlite3changeset_start_v2（）APIはまだ&lt;b&gt;実験&lt;/b&gt;段階であり、変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6c55c88c2dea7079ec802efa3e99479f764ecf7e" translate="yes" xml:space="preserve">
          <source>Note that the unary *+* operator also removes &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; from an expression, and in some cases this can cause subtle changes in the meaning of an expression. In the example above, if column *x* has &lt;a href=&quot;datatype3#affinity&quot;&gt;TEXT affinity&lt;/a&gt; then the comparison &quot;x=5&quot; will be done as text. But the *+* operator removes the affinity. So the comparison &quot;+x=5&quot; will compare the text in column *x* with the numeric value 5 and will always be false.</source>
          <target state="translated">単項* + *演算子は&lt;a href=&quot;datatype3#affinity&quot;&gt;式&lt;/a&gt;から型の類似性も削除することに注意してください。場合によっては、式の意味に微妙な変化が生じることがあります。上記の例では、列* x *に&lt;a href=&quot;datatype3#affinity&quot;&gt;TEXTアフィニティがある&lt;/a&gt;場合、比較 &quot;x = 5&quot;はテキストとして行われます。ただし、* + *演算子はアフィニティを削除します。したがって、「+ x = 5」の比較では、列* x *のテキストが数値5と比較され、常にfalseになります。</target>
        </trans-unit>
        <trans-unit id="c990d58c5d0bc49b39ec476dafbb19955404bbcd" translate="yes" xml:space="preserve">
          <source>Note that there are paths through the syntax diagrams that are not allowed in practice. Some examples:</source>
          <target state="translated">実際には許可されていない構文図を通るパスがあることに注意してください。いくつかの例があります。</target>
        </trans-unit>
        <trans-unit id="96acc3ff45ab0c01a0b94c0892486dbb72afce32" translate="yes" xml:space="preserve">
          <source>Note that there are two variations of the equals and not equals operators. Equals can be either</source>
          <target state="translated">等号演算子には、等号演算子と等号演算子ではない演算子があります。等号は次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="a67d64fb18ca2294fb42994c6d74eeb61ff03be8" translate="yes" xml:space="preserve">
          <source>Note that this is only a thought experiment. We are not suggesting that OpenDocument be changed. Nor is this article a criticism of the current OpenDocument design. The point of this essay is to suggest ways to improve future file format designs.</source>
          <target state="translated">これはあくまでも思考実験であることに注意してください。私たちは OpenDocument を変更することを提案しているわけではありません。また、この記事は現在の OpenDocument のデザインを批判するものでもありません。このエッセイのポイントは、将来のファイルフォーマットのデザインを改善する方法を提案することです。</target>
        </trans-unit>
        <trans-unit id="99c1505807d577ab62bcd4edbb24d5f3cd06e9f6" translate="yes" xml:space="preserve">
          <source>Note that this problem only occurs if the attempt to acquire the lock resulted in an I/O error. If the lock is simply not granted (because some other thread or process is already holding a conflicting lock) then no corruption will ever occur. We are not aware of any operating systems that will fail with an I/O error while attempting to get a file lock on shared memory. So this is a theoretical problem rather than a real problem. Needless to say, this problem has never been observed in the wild. The problem was discovered while doing stress testing of SQLite in a test harness that simulates I/O errors.</source>
          <target state="translated">この問題は、ロックを取得しようとした結果、I/O エラーが発生した場合にのみ発生することに注意してください。ロックが単に付与されなかった場合(他のスレッドやプロセスが既に競合するロックを保持しているため)、破損は発生しません。共有メモリ上のファイルロックを取得しようとしたときに I/O エラーで失敗するようなオペレーティングシステムはありません。したがって、これは実際の問題ではなく理論上の問題です。言うまでもなく、この問題は実際に観測されたことがありません。この問題は、I/O エラーをシミュレートするテストハーネスで SQLite のストレステストを行っているときに発見されました。</target>
        </trans-unit>
        <trans-unit id="ebff595e74a177f5fa63d87902cc62cb3ce02f96" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp（）&lt;/a&gt;および&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt;と同様に、このルーチンは文字列が一致しない場合、一致時にゼロを返し、ゼロ以外を返すことに注意してください。</target>
        </trans-unit>
        <trans-unit id="0d629b76283bd20b6edf31050b7b9b764c009820" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp（）&lt;/a&gt;および&lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt;と同様に、このルーチンは文字列が一致しない場合、一致時にゼロを返し、ゼロ以外を返すことに注意してください。</target>
        </trans-unit>
        <trans-unit id="c810fa4c8943f66ac3d34092b7e767d31528340e" translate="yes" xml:space="preserve">
          <source>Note that triggers are automatically dropped when the associated table is dropped.</source>
          <target state="translated">関連するテーブルが削除されると、トリガーが自動的に削除されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d606f23ac3535efbf11c3a7516392c25071ecf15" translate="yes" xml:space="preserve">
          <source>Note that when SQLite is compiled with SQLITE_THREADSAFE=0, the code to make SQLite threadsafe is omitted from the build. When this occurs, it is impossible to change the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; at start-time or run-time.</source>
          <target state="translated">SQLiteがSQLITE_THREADSAFE = 0でコンパイルされている場合、SQLiteをスレッドセーフにするコードはビルドから省略されます。これが発生すると、開始時または実行時に&lt;a href=&quot;threadsafe&quot;&gt;スレッドモード&lt;/a&gt;を変更することができません。</target>
        </trans-unit>
        <trans-unit id="32708b7e6e76296f6dad18be6a6d369658183e8b" translate="yes" xml:space="preserve">
          <source>Note that when the SQLITE_DBCONFIG_LEGACY_FILE_FORMAT setting is on, the &lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will fail with an obscure error when attempting to process a table with generated columns and a descending index. This is not considered a bug since SQLite versions 3.3.0 and earlier do not support either generated columns or decending indexes.</source>
          <target state="translated">SQLITE_DBCONFIG_LEGACY_FILE_FORMAT設定がオンの場合、生成された列と降順のインデックスを持つテーブルを処理しようとすると、&lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;コマンドがあいまいなエラーで失敗することに注意してください。SQLiteバージョン3.3.0以前は、生成された列または降順インデックスのいずれもサポートしていないため、これはバグとは見なされません。</target>
        </trans-unit>
        <trans-unit id="3822538f7b251248e21c02ba82556fd2e3a92957" translate="yes" xml:space="preserve">
          <source>Note that when the SQLITE_DBCONFIG_LEGACY_FILE_FORMAT setting is on, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will fail with an obscure error when attempting to process a table with generated columns and a descending index. This is not considered a bug since SQLite versions 3.3.0 and earlier do not support either generated columns or decending indexes.</source>
          <target state="translated">SQLITE_DBCONFIG_LEGACY_FILE_FORMAT設定がオンの場合、生成された列と降順のインデックスを持つテーブルを処理しようとすると、&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;コマンドがあいまいなエラーで失敗することに注意してください。SQLiteバージョン3.3.0以前は、生成された列または降順インデックスのいずれもサポートしていないため、これはバグとは見なされません。</target>
        </trans-unit>
        <trans-unit id="789391b5c680547fd2d7df978b13d5bea4b6c611" translate="yes" xml:space="preserve">
          <source>Note that when the right-hand side of a LIKE or GLOB operator is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement is prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; then the statement is automatically reparsed and recompiled on the first &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call of each run if the binding to the right-hand side parameter has changed since the previous run. This reparse and recompile is essentially the same action that occurs following a schema change. The recompile is necessary so that the query planner can examine the new value bound to the right-hand side of the LIKE or GLOB operator and determine whether or not to employ the optimization described above.</source>
          <target state="translated">LIKEまたはGLOB演算子の右側が&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーターで&lt;/a&gt;あり、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;または&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;を使用してステートメントが準備される場合、ステートメントが自動的に再解析され、各実行の最初の&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;呼び出しで再コンパイルされることに注意してください。右側のパラメーターへのバインドは、前回の実行以降変更されています。この再解析と再コンパイルは、スキーマの変更後に発生するアクションと基本的に同じです。クエリプランナーがLIKEまたはGLOB演算子の右側にバインドされた新しい値を調べて、上記の最適化を採用するかどうかを決定できるように、再コンパイルが必要です。</target>
        </trans-unit>
        <trans-unit id="7aca89c620a18b6fdc63e568bea908a626dcadff" translate="yes" xml:space="preserve">
          <source>Note that when type conversions occur, pointers returned by prior calls to sqlite3_column_blob(), sqlite3_column_text(), and/or sqlite3_column_text16() may be invalidated. Type conversions and pointer invalidations might occur in the following cases:</source>
          <target state="translated">型変換が発生した場合、sqlite3_column_blob(),sqlite3_column_text(),および/または sqlite3_column_text16()の前の呼び出しによって返されたポインタが無効になることがあることに注意してください。以下の場合、型変換やポインタが無効になることがあります。</target>
        </trans-unit>
        <trans-unit id="1368e4859dec1f8b656ae1f17b0c284cfecc238a" translate="yes" xml:space="preserve">
          <source>Note that with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to NORMAL, the checkpoint is the only operation to issue an I/O barrier or sync operation (fsync() on unix or FlushFileBuffers() on windows). If an application therefore runs checkpoint in a separate thread or process, the main thread or process that is doing database queries and updates will never block on a sync operation. This helps to prevent &quot;latch-up&quot; in applications running on a busy disk drive. The downside to this configuration is that transactions are no longer durable and might rollback following a power failure or hard reset.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt;をNORMALに設定すると、チェックポイントがI / Oバリアまたは同期操作（UNIXではfsync（）、WindowsではFlushFileBuffers（））を発行する唯一の操作になることに注意してください。したがって、アプリケーションが別のスレッドまたはプロセスでチェックポイントを実行する場合、データベースクエリと更新を実行しているメインスレッドまたはプロセスが同期操作をブロックすることはありません。これは、ビジーなディスクドライブで実行されているアプリケーションの「ラッチアップ」を防ぐのに役立ちます。この構成の欠点は、トランザクションが永続的でなくなり、電源障害またはハードリセットの後にロールバックされる可能性があることです。</target>
        </trans-unit>
        <trans-unit id="8da0c032621fbb18df4dc03aaa124440bc316a57" translate="yes" xml:space="preserve">
          <source>Note that with ANALYZE the cost estimates are better aligned with reality and algorithm-1 is selected by both NN and N3.</source>
          <target state="translated">ANALYZEでは、コスト推定値がより現実と一致しており、NNとN3の両方でアルゴリズム-1が選択されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="695e607ef01e6db075031ffa227e23ca60904541" translate="yes" xml:space="preserve">
          <source>Note that xBestIndex will always be called before &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;, since the idxNum and idxStr outputs from xBestIndex are required inputs to xFilter. However, there is no guarantee that xFilter will be called following a successful xBestIndex.</source>
          <target state="translated">&lt;a href=&quot;vtab#xfilter&quot;&gt;xBestIndex&lt;/a&gt;からのidxNumおよびidxStr出力はxFilterへの必須入力であるため、xBestIndexは常にxFilterの前に呼び出されることに注意してください。ただし、xBestIndexが成功した後でxFilterが呼び出されるという保証はありません。</target>
        </trans-unit>
        <trans-unit id="d227a38478007bafe1c5681fa0c0259f1628a846" translate="yes" xml:space="preserve">
          <source>Note the &quot;temp.&quot; qualifier before the virtual table name (&quot;stat&quot;). This qualifier causes the virtual table to be temporary - to only exist for the duration of the current database connection. This is the recommended approach.</source>
          <target state="translated">仮想テーブル名 (&quot;stat&quot;)の前に &quot;temp.&quot; という修飾子があることに注意してください。この修飾子により、仮想テーブルは一時的なものとなり、現在のデータベース接続の間だけ存在します。これが推奨されるアプローチです。</target>
        </trans-unit>
        <trans-unit id="984a9d35869a9cec59e40e09a2d60d76afb99304" translate="yes" xml:space="preserve">
          <source>Note the last bullet in particular. The destructor X in sqlite3_set_auxdata(C,N,P,X) might be called immediately, before the sqlite3_set_auxdata() interface even returns. Hence sqlite3_set_auxdata() should be called near the end of the function implementation and the function implementation should not make any use of P after sqlite3_set_auxdata() has been called.</source>
          <target state="translated">特に最後の箇条書きに注意してください。sqlite3_set_auxdata(C,N,P,X)のデストラクタXはsqlite3_set_auxdata()インタフェースが戻る前に呼ばれるかもしれません。したがって、sqlite3_set_auxdata()は関数の実装の終わり近くで呼ばれるべきであり、sqlite3_set_auxdata()が呼ばれた後はPを使ってはいけません。</target>
        </trans-unit>
        <trans-unit id="be13ad345e0dba5ca596ce6f7266fdf09fc32236" translate="yes" xml:space="preserve">
          <source>Note the use of the &lt;a href=&quot;lang_corefunc#quote&quot;&gt;quote() SQL function&lt;/a&gt; in these triggers. The quote() function converts its argument into a form that is appropriate for inclusion in an SQL statement. Numeric values come through unchanged. Single quotes are added before and after strings and any internal single quotes are escaped. BLOB values are rendered using SQL-standard hexadecimal BLOB notation. The use of the quote() function ensures that the SQL statements used to undo and redo are always safe from SQL injection.</source>
          <target state="translated">これらのトリガーでの&lt;a href=&quot;lang_corefunc#quote&quot;&gt;quote（）SQL関数&lt;/a&gt;の使用に注意してください。quote（）関数は、引数をSQLステートメントに含めるのに適した形式に変換します。数値は変更されずに通過します。文字列の前後に単一引用符が追加され、内部の単一引用符はエスケープされます。BLOB値は、SQL標準の16進BLOB表記を使用してレンダリングされます。quote（）関数を使用すると、取り消しとやり直しに使用されるSQLステートメントがSQLインジェクションから常に安全になります。</target>
        </trans-unit>
        <trans-unit id="044b3a09040052b2232feb80c6848441318257d4" translate="yes" xml:space="preserve">
          <source>Note the warnings on the &quot;estimatedRows&quot;, &quot;idxFlags&quot;, and colUsed fields. These fields were added with SQLite versions 3.8.2, 3.9.0, and 3.10.0, respectively. Any extension that reads or writes these fields must first check that the version of the SQLite library in use is greater than or equal to appropriate version - perhaps comparing the value returned from &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; against constants 3008002, 3009000, and/or 3010000. The result of attempting to access these fields in an sqlite3_index_info structure created by an older version of SQLite are undefined.</source>
          <target state="translated">「estimatedRows」、「idxFlags」、およびcolUsedフィールドの警告に注意してください。これらのフィールドは、SQLiteバージョン3.8.2、3.9.0、および3.10.0でそれぞれ追加されました。これらのフィールドを読み書きする拡張機能では、まず、使用中のSQLiteライブラリのバージョンが適切なバージョン以上であることを確認する必要があります。おそらく、&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number（）&lt;/a&gt;から返された値を定数3008002、3009000、3010000 と比較します。古いバージョンのSQLiteによって作成されたsqlite3_index_info構造体のこれらのフィールドにアクセスしようとした結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="49bc1f28a1c9c886ae8bd63cbcbb27c797246229" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;capi3ref&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;capi3ref&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">注：「&lt;small&gt;&lt;i&gt;（exp）&lt;/i&gt;&lt;/small&gt;」でマークされた関数は&lt;a href=&quot;capi3ref&quot;&gt;実験的なもので&lt;/a&gt;あり、名前に&lt;s&gt;取り消し線&lt;/s&gt;が&lt;a href=&quot;capi3ref&quot;&gt;引かれた&lt;/a&gt;関数は非推奨です。</target>
        </trans-unit>
        <trans-unit id="66ee76f5066068620f09c7e62f4bb8c158c87cf7" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;experimental&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;experimental&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">注：「&lt;small&gt;&lt;i&gt;（exp）&lt;/i&gt;&lt;/small&gt;」でマークされた関数は&lt;a href=&quot;experimental&quot;&gt;実験的なもので&lt;/a&gt;あり、名前に&lt;s&gt;取り消し線&lt;/s&gt;が&lt;a href=&quot;experimental&quot;&gt;引かれた&lt;/a&gt;関数は非推奨です。</target>
        </trans-unit>
        <trans-unit id="03b148e28fde4df0887542e9d88b598d5e8f42db" translate="yes" xml:space="preserve">
          <source>Note: Sections 2.0 and 3.0 of this article were added in response to comments on &lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt; and &lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit&lt;/a&gt;.</source>
          <target state="translated">注：この記事のセクション2.0と3.0は、&lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt;と&lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit&lt;/a&gt;へのコメントに応じて追加されました。</target>
        </trans-unit>
        <trans-unit id="85e051b1f236f895d99d48916ab5fd667388aec3" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">注：このメソッドはMacOS X 10.7およびiOSバージョン5.0では無効であり、常にSQLITE_MISUSEを返します。これらのシステムでは、共有キャッシュモードは、ビアごとのデータベース接続を有効にする必要がある&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;と&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHEを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ddf57deb38e4651cb3981116d2b9ec03a6feb885" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">注：このメソッドはMacOS X 10.7およびiOSバージョン5.0では無効であり、常にSQLITE_MISUSEを返します。これらのシステムでは、共有キャッシュモードは、ビアごとのデータベース接続を有効にする必要がある&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;と&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHEを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="b7c62ae6be1885d1c5a81f6a7886c67b36419ed4" translate="yes" xml:space="preserve">
          <source>Notes on the &lt;a href=&quot;optoverview&quot;&gt;query optimizer&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;optoverview&quot;&gt;クエリオプティマイザ&lt;/a&gt;に関する注意事項。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="bb5c89c5cb4409cab6ee44d716c6d95feaaddc62" translate="yes" xml:space="preserve">
          <source>Notice how the LIKE operator is implemented. It is a user-defined function in SQLite, so the address of its function definition is specified in P3. The operand P1 is the number of function arguments for it to take from the stack. In this case the LIKE() function takes 2 arguments. The arguments are taken off the stack in reverse order (right-to-left), so the pattern to match is the top stack element, and the next element is the data to compare. The return value is pushed onto the stack.</source>
          <target state="translated">LIKE 演算子がどのように実装されているかに注目してください。これはSQLiteのユーザー定義関数なので、関数定義のアドレスはP3で指定されています。オペランドP1は、スタックから取得する関数引数の数です。この場合、LIKE()関数は2つの引数を取ります。引数はスタックから逆順(右から左)に取り出されますので、マッチするパターンはスタックの一番上の要素で、次の要素は比較するデータです。戻り値はスタックに押し出されます。</target>
        </trans-unit>
        <trans-unit id="5255c6a9b36d606aac6af8d3dbbceadb0d1f9b02" translate="yes" xml:space="preserve">
          <source>Notice how the query above works: The R*Tree index runs in the outer loop to find entries that are contained within the bounding box of longitude -81..-79.6 and latitude 35.0..36.2. For each object identifier found, SQLite looks up the corresponding entry in the demo_data table. It then uses the boundary field from the demo_data table as a parameter to the contained_in() function and if that function returns true, the objname field from the demo_data table is returned as the next row of query result.</source>
          <target state="translated">上のクエリがどのように動作するかに注目してください。R*Tree インデックスは、経度 -81...-79.6 と緯度 35.0...36.2 のバウンディングボックス内に含まれるエントリを見つけるために外側のループ内で実行されます。見つかった各オブジェクト識別子について、SQLite は demo_data テーブルの対応するエントリを検索します。次に、demo_data テーブルの境界フィールドをパラメータとして contained_in()関数を使用し、その関数が true を返すと、demo_data テーブルの objname フィールドがクエリ結果の次の行として返されます。</target>
        </trans-unit>
        <trans-unit id="3b7384e004cca4a56bb485375c44be1a10c5774f" translate="yes" xml:space="preserve">
          <source>Notice that all other date and time functions can be expressed in terms of strftime():</source>
          <target state="translated">他のすべての日付と時刻の関数は strftime()で表現できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a0897fe8cedb04900939c7986a4c19ddb9b29972" translate="yes" xml:space="preserve">
          <source>Notice that dividing up the content into smaller pieces using an SQLite table gives flexibility to the implementation. The application can choose to read all content into memory at startup. Or it can read just a few pages into memory and keep the rest on disk. Or it can read just single page into memory at a time. And different versions of the application can make different choices without having to make any changes to the file format. Such options are not available when all content is in a single big XML file in a ZIP archive.</source>
          <target state="translated">SQLite テーブルを使用してコンテンツを小さな断片に分割することで、実装に柔軟性を与えることに注意してください。アプリケーションは、起動時にすべてのコンテンツをメモリに読み込むことができます。あるいは、数ページだけをメモリに読み込んで残りをディスクに保存することもできます。あるいは、一度に単一のページだけをメモリに読み込むこともできます。また、アプリケーションの異なるバージョンでは、ファイル形式を変更することなく、異なる選択をすることができます。このようなオプションは、すべてのコンテンツがZIPアーカイブ内の単一の大きなXMLファイルにある場合には利用できません。</target>
        </trans-unit>
        <trans-unit id="8b6637336242d861c3d1aedafa06202a9a576add" translate="yes" xml:space="preserve">
          <source>Notice that the &quot;host&quot; value for the &quot;dummy&quot; record is NULL so the result[] array contains a NULL pointer at that slot.</source>
          <target state="translated">ダミーレコードの &quot;ホスト &quot;の値はNULLなので、result[]配列にはそのスロットにNULLポインタが含まれていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="81da02d10ebbcf526492f91d32dd8afa2884d608" translate="yes" xml:space="preserve">
          <source>Notice that the parameters to functions are now pointers to sqlite3_value structures instead of pointers to strings as in SQLite version 2.X. The following routines are used to extract useful information from these &quot;values&quot;:</source>
          <target state="translated">関数のパラメータがSQLiteバージョン2.Xのように文字列へのポインタではなく、sqlite3_value構造体へのポインタになったことに注目してください。</target>
        </trans-unit>
        <trans-unit id="45ef496d245754f1f4daa860e31545d9feaf1aea" translate="yes" xml:space="preserve">
          <source>Notice that the shared lock is on the operating system disk cache, not on the disk itself. File locks really are just flags within the operating system kernel, usually. (The details depend on the specific OS layer interface.) Hence, the lock will instantly vanish if the operating system crashes or if there is a power loss. It is usually also the case that the lock will vanish if the process that created the lock exits.</source>
          <target state="translated">共有ロックはオペレーティングシステムのディスクキャッシュ上にあり、ディスク自体にはないことに注意してください。ファイルロックは、通常、オペレーティングシステムのカーネル内のフラグに過ぎません (詳細は特定の OS レイヤーインターフェースに依存します)。(詳細は特定の OS レイヤーインターフェースに依存します。)したがって、オペレーティングシステムがクラッシュしたり、電源が切れたりすると、ロックは即座に消えてしまいます。また、ロックを作成したプロセスが終了した場合も、通常はロックは消えます。</target>
        </trans-unit>
        <trans-unit id="f8f4b80268c40011630e5371241e6ab982124215" translate="yes" xml:space="preserve">
          <source>Notice that the tokens in the result set from the fts3tokenize virtual table have been transformed according to the rules of the tokenizer. Since this example used the &quot;porter&quot; tokenizer, the &quot;This&quot; token was converted into &quot;thi&quot;. If the original text of the token is desired, it can be retrieved using the &quot;start&quot; and &quot;end&quot; columns with the &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr()&lt;/a&gt; function. For example:</source>
          <target state="translated">fts3tokenize仮想テーブルからの結果セット内のトークンは、トークナイザーのルールに従って変換されていることに注意してください。この例では「porter」トークナイザーを使用したため、「This」トークンは「thi」に変換されました。トークンの元のテキストが必要な場合は、&lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr（）&lt;/a&gt;関数で「start」列と「end」列を使用して取得できます。例えば：</target>
        </trans-unit>
        <trans-unit id="af54971d34d4b499061179fcac4a7f0e1fee4c0f" translate="yes" xml:space="preserve">
          <source>Notice the similarity between the ListRead and Next instructions. Both operations work according to this rule:</source>
          <target state="translated">ListRead 命令と Next 命令の類似性に注目してください。どちらの操作もこのルールに従って動作します。</target>
        </trans-unit>
        <trans-unit id="7cec2e96076ffe89a48a9bb0d641ff84dbe2e0a2" translate="yes" xml:space="preserve">
          <source>Notice too that there is a tradeoff between average read performance and average write performance. To maximize the read performance, one wants to keep the WAL as small as possible and hence run checkpoints frequently, perhaps as often as every COMMIT. To maximize write performance, one wants to amortize the cost of each checkpoint over as many writes as possible, meaning that one wants to run checkpoints infrequently and let the WAL grow as large as possible before each checkpoint. The decision of how often to run checkpoints may therefore vary from one application to another depending on the relative read and write performance requirements of the application. The default strategy is to run a checkpoint once the WAL reaches 1000 pages and this strategy seems to work well in test applications on workstations, but other strategies might work better on different platforms or for different workloads.</source>
          <target state="translated">平均的な読み込み性能と平均的な書き込み性能の間にはトレードオフがあることにも注意してください。読み込み性能を最大化するためには、WALを可能な限り小さくしたいので、チェックポイントを頻繁に、おそらくCOMMITごとに実行するのと同じくらいの頻度で実行したいと考えます。書き込み性能を最大化するには、各チェックポイントのコストを可能な限り多くの書き込みに渡って償却したいと考えます。したがって、チェックポイントをどのくらいの頻度で実行するかの決定は、アプリケーションの相対的な読み取りと書き込みのパフォーマンス要件に応じて、アプリケーションごとに異なる場合があります。デフォルトの戦略は、WAL が 1000 ページに達したらチェックポイントを実行するというもので、この戦略はワークステーション上のテストアプリケーションではうまく機能しているようですが、他の戦略は異なるプラットフォームや異なるワークロードではよりうまく機能するかもしれません。</target>
        </trans-unit>
        <trans-unit id="d969bb722b85b5d0915700d40ff32bef3f77944d" translate="yes" xml:space="preserve">
          <source>Now compiles on MSVC++6 again</source>
          <target state="translated">MSVC++6で再びコンパイルできるようになりました。</target>
        </trans-unit>
        <trans-unit id="6c31ef81ebda278449acfecbdc59bc58b62b9f81" translate="yes" xml:space="preserve">
          <source>Now compiles on Solaris and OpenBSD and other Unix variants that lack the fdatasync() function</source>
          <target state="translated">Solaris、OpenBSD、および fdatasync()関数を欠いた他の Unix バリアントでのコンパイルが可能になりました。</target>
        </trans-unit>
        <trans-unit id="d8eeae1a57da5c7c1fc46f998bfb914d868defe3" translate="yes" xml:space="preserve">
          <source>Now consider a query to find the names of everyone in the organization that is 180cm tall or taller:</source>
          <target state="translated">では、身長180cm以上の組織内の全員の名前を検索するクエリを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="cace99b617f1285adb8e73b73b38a21bf398149e" translate="yes" xml:space="preserve">
          <source>Now consider the case where M and N are both 3500. Alice nodes are abundant. But suppose each of these nodes is connected by only one or two edges. In this case, option 2 is preferred. With option 2, the outer loop still has to run 3500 times, but the middle loop only runs once or twice for each outer loop and the inner loop will only run once for each middle loop, if at all. So the total number of iterations of the inner loop is around 7000. Option 1, on the other hand, has to run both its outer loop and its middle loop 3500 times each, resulting in 12 million iterations of the middle loop. Thus in the second scenario, option 2 is nearly 2000 times faster than option 1.</source>
          <target state="translated">では、MとNがともに3500の場合を考えてみましょう。アリスノードは豊富にあります。しかし、これらのノードのそれぞれが1つか2つの辺だけでつながっているとします。この場合、オプション2が好ましい。オプション2では、外側のループはまだ3500回実行しなければなりませんが、中間のループは外側のループごとに1回か2回しか実行しませんし、内側のループは中間のループごとに1回しか実行しません(全く実行しない場合)。つまり、内側ループの総反復回数は7000回程度になります。一方、オプション1の場合は、外側ループと中間ループをそれぞれ3500回ずつ実行しなければならず、結果として中間ループの反復回数は1200万回になります。このように、2番目のシナリオでは、オプション2はオプション1の2000倍近く速くなります。</target>
        </trans-unit>
        <trans-unit id="ddfe6464a41b67622d5429681d09c2e30ec73502" translate="yes" xml:space="preserve">
          <source>Now it is time to make the private, custom modifications to SQLite which are the whole point of this exercise. Switch to the private branch (if you are not already there) using the &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; command, then bring up the source files in your text editor and make whatever changes you want to make. Once you have finished making changes, commit those changes using this command:</source>
          <target state="translated">これで、この演習の要点であるSQLiteにプライベートなカスタム変更を加える時がきました。&quot; &lt;code&gt;fossil update private&lt;/code&gt; &quot;コマンドを使用して（まだそこにいない場合）プライベートブランチに切り替え、テキストエディターでソースファイルを表示して、必要な変更を行います。変更が完了したら、次のコマンドを使用してそれらの変更をコミットします。</target>
        </trans-unit>
        <trans-unit id="421feb72f2bd97fb759d08871988b6f039784dca" translate="yes" xml:space="preserve">
          <source>Now let's look at how this index will be used. Consider the following query:</source>
          <target state="translated">では、このインデックスがどのように使われるのか見てみましょう。次のクエリを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="470c0db4772f894a123be1434e95e5d5a6304ade" translate="yes" xml:space="preserve">
          <source>Now suppose the user.phone field contains plain text if the user has only a single phone number and a JSON array if the user has multiple phone numbers. The same question is posed: &quot;Which users have a phone number in the 704 area code?&quot; But now the json_each() function can only be called for those users that have two or more phone numbers since json_each() requires well-formed JSON as its first argument:</source>
          <target state="translated">さて、user.phoneフィールドには、ユーザーが電話番号を1つだけ持っている場合はプレーンテキストが含まれ、ユーザーが複数の電話番号を持っている場合はJSON配列が含まれているとします。同じ質問をします。&quot;どのユーザーが704市外局番に電話番号を持っていますか?&quot; しかし、json_each()は第一引数として整形された JSON を必要とするため、json_each()関数は 2 つ以上の電話番号を持つユーザーに対してのみ呼び出すことができるようになりました。</target>
        </trans-unit>
        <trans-unit id="f22ea5fd82bf1b044f7951c4c771bd645f73f8d1" translate="yes" xml:space="preserve">
          <source>Now that the public and private branches are different, you can run the &quot;&lt;code&gt;fossil update trunk&lt;/code&gt;&quot; and &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; commands and see that fossil really does change the files in the checkout as you switch back and forth between branches.</source>
          <target state="translated">パブリックブランチとプライベートブランチが異なるため、「 &lt;code&gt;fossil update trunk&lt;/code&gt; 」コマンドと「 &lt;code&gt;fossil update private&lt;/code&gt; 」コマンドを実行して、ブランチ間を切り替えると、チェックアウト内のファイルがfossilによって実際に変更されることがわかります。</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="5b7d454836a77f93829b713b5a5d0e3045934959" translate="yes" xml:space="preserve">
          <source>Null-indicator is an optional string that indicates a column value is null. The default is an empty string. Note that column-separator and null-indicator are optional positional arguments; if null-indicator is specified, a column-separator argument must be specified and precede the null-indicator argument.</source>
          <target state="translated">Null-indicatorは、列の値がNULLであることを示すオプションの文字列です。デフォルトは空の文字列です。column-separatorとnull-indicatorはオプションの位置引数であることに注意してください。null-indicatorが指定されている場合は、column-separator引数を指定し、null-indicator引数の前に指定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="a37aacd80c708abde1a03c3d5afe5b13fd00cfc3" translate="yes" xml:space="preserve">
          <source>NullRow</source>
          <target state="translated">NullRow</target>
        </trans-unit>
        <trans-unit id="eb0f5a21c19313cdefd12cf556538964ec1b60c1" translate="yes" xml:space="preserve">
          <source>Number Of Columns In A Result Set</source>
          <target state="translated">結果セットのカラム数</target>
        </trans-unit>
        <trans-unit id="29a85c89c3b665d61a62026778cb1a84d89e00ac" translate="yes" xml:space="preserve">
          <source>Number Of SQL Parameters</source>
          <target state="translated">SQLパラメータの数</target>
        </trans-unit>
        <trans-unit id="a780fc260fcaca2d5e967db2577edefc7720d5d2" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have already been backfilled into the database by prior checkpoints</source>
          <target state="translated">事前のチェックポイントで既にデータベースにバックフィルされているWALフレームの数</target>
        </trans-unit>
        <trans-unit id="2a37475de2d92c9f14f2ea5c38819cea5766eaa7" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have attempted to be backfilled but which might not have been backfilled successfully.</source>
          <target state="translated">バックフィルが試みられたが、バックフィルが成功しなかった可能性のあるWALフレームの数。</target>
        </trans-unit>
        <trans-unit id="3b125f191573ae8fecea26a8fd5c1f85866a1737" translate="yes" xml:space="preserve">
          <source>Number of bytes of payload</source>
          <target state="translated">ペイロードのバイト数</target>
        </trans-unit>
        <trans-unit id="3bacc7e3374d56ead644519a8de907aa11ddb984" translate="yes" xml:space="preserve">
          <source>Number of cells on the current page or btree</source>
          <target state="translated">現在のページまたはbtreeのセル数</target>
        </trans-unit>
        <trans-unit id="93e4ee2802912bc9542ff03c865140e0975aff48" translate="yes" xml:space="preserve">
          <source>Number of columns in a result set</source>
          <target state="translated">結果セットの列数</target>
        </trans-unit>
        <trans-unit id="2b00ff36e6009d3918fa275ec909bb841ed966c0" translate="yes" xml:space="preserve">
          <source>Number of valid and committed frames in the WAL file.</source>
          <target state="translated">WALファイル内の有効なフレーム数とコミットされたフレーム数。</target>
        </trans-unit>
        <trans-unit id="ff84d5af979f34eb1211b7993c06c6a08d3a99e3" translate="yes" xml:space="preserve">
          <source>Number-of-pages</source>
          <target state="translated">Number-of-pages</target>
        </trans-unit>
        <trans-unit id="2f32b7f17e88cd173c751d8cdc7e8c19cbcaed9f" translate="yes" xml:space="preserve">
          <source>Numeric and text types make a difference for the DISTINCT keyword too:</source>
          <target state="translated">DISTINCTキーワードでも、数値型とテキスト型の違いがあります。</target>
        </trans-unit>
        <trans-unit id="c37c2e33a0fa0b90c0fc1ac3254fa39cce3fa242" translate="yes" xml:space="preserve">
          <source>Numeric values (serial types 1 through 9) sort after NULLs and in numeric order.</source>
          <target state="translated">数値(シリアルタイプ1~9)は、NULLの後に数値順にソートします。</target>
        </trans-unit>
        <trans-unit id="16bebfa71033ff1ade58c6f0e6b14f281dfaba25" translate="yes" xml:space="preserve">
          <source>Numeric values sort next in numerical order</source>
          <target state="translated">数値は数値順に次のようにソートされます。</target>
        </trans-unit>
        <trans-unit id="0f5fd79254e55ff1fbee2cde5598536b3ec7dea6" translate="yes" xml:space="preserve">
          <source>Numerous bug fixes and documentation updates.</source>
          <target state="translated">多数のバグ修正とドキュメントの更新。</target>
        </trans-unit>
        <trans-unit id="dc11c061204c46d3ddd7e450955d3893423efff5" translate="yes" xml:space="preserve">
          <source>Numerous code optimizations, specially optimizations designed to make the code footprint smaller.</source>
          <target state="translated">多数のコード最適化、コードフットプリントを小さくするために設計された特別な最適化。</target>
        </trans-unit>
        <trans-unit id="1608a6f49ab43b4c01022e79721183478aa81607" translate="yes" xml:space="preserve">
          <source>Numerous minor bug fixes</source>
          <target state="translated">数々のマイナーなバグ修正</target>
        </trans-unit>
        <trans-unit id="59f5ab25bf1e5a211679172dc18a637343443a9e" translate="yes" xml:space="preserve">
          <source>Numerous other performance enhancements</source>
          <target state="translated">その他多数の性能強化</target>
        </trans-unit>
        <trans-unit id="957b6bbcded8f49f8684b4d5e7a64d7f3a67b7a1" translate="yes" xml:space="preserve">
          <source>OCELOT</source>
          <target state="translated">OCELOT</target>
        </trans-unit>
        <trans-unit id="7481b4b2758d96d6c2ef2af6709c88460dc01560" translate="yes" xml:space="preserve">
          <source>ODP - The Open Document presentation format used by OpenOffice and others</source>
          <target state="translated">ODP-OpenOffice などで使用されているオープンドキュメントのプレゼンテーションフォーマット</target>
        </trans-unit>
        <trans-unit id="2a2888f26efa625ef4871988ca874037d8ea156c" translate="yes" xml:space="preserve">
          <source>ODT - The Open Document format used by OpenOffice and others</source>
          <target state="translated">ODT-OpenOffice などで使用されているオープンドキュメント形式です。</target>
        </trans-unit>
        <trans-unit id="0cf81c47abad8b8dc52569f7edcc1b5b2d3511f9" translate="yes" xml:space="preserve">
          <source>OF</source>
          <target state="translated">OF</target>
        </trans-unit>
        <trans-unit id="acd2081fe0965992b6934d49ae30eed38ac749e0" translate="yes" xml:space="preserve">
          <source>OFFSET</source>
          <target state="translated">OFFSET</target>
        </trans-unit>
        <trans-unit id="4f963961751f0891a23f93bba4882f74f0ade805" translate="yes" xml:space="preserve">
          <source>OFFSET clause ignored on queries without a FROM clause. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</source>
          <target state="translated">FROM句のないクエリでは、OFFSET句は無視されます。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80f83fb7443c61c317b946841f59c0be3182f095" translate="yes" xml:space="preserve">
          <source>OFFSET gives the correct answer. However, OFFSET requires time proportional to the offset value. What really happens with &quot;LIMIT x OFFSET y&quot; is that SQLite computes the query as &quot;LIMIT x+y&quot; and discards the first y values without returning them to the application. So as the window scrolls down toward the bottom of a long list, and the y value becomes larger and larger, successive offset computations take more and more time.</source>
          <target state="translated">OFFSETは正しい答えを与えます。しかし、OFFSETはオフセット値に比例した時間を必要とします。LIMIT x OFFSET y &quot;で実際に何が起こるかというと、SQLiteはクエリを &quot;LIMIT x+y &quot;として計算し、最初のy値をアプリケーションに返さずに破棄します。そのため、ウィンドウが長いリストの一番下に向かって下にスクロールし、y の値がどんどん大きくなっていくと、連続したオフセットの計算に時間がかかります。</target>
        </trans-unit>
        <trans-unit id="9c108e42d4ae43fd2c4c857619aacef018184aee" translate="yes" xml:space="preserve">
          <source>OLD references are valid</source>
          <target state="translated">古い参照は有効です。</target>
        </trans-unit>
        <trans-unit id="387d7a59dbaaef002e0f9ac69ecd4443b9c5cef2" translate="yes" xml:space="preserve">
          <source>ON</source>
          <target state="translated">ON</target>
        </trans-unit>
        <trans-unit id="32bb503cc80e713ad933b48ce9053610aae7664e" translate="yes" xml:space="preserve">
          <source>ON CONFLICT clause</source>
          <target state="translated">オンコンフリクト句</target>
        </trans-unit>
        <trans-unit id="c13d037157d8eb7ac7ee7af0a3380941dabf2fa2" translate="yes" xml:space="preserve">
          <source>OOM testing is accomplished by simulating OOM errors. SQLite allows an application to substitute an alternative malloc() implementation using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;,...) interface. The TCL and TH3 test harnesses are both capable of inserting a modified version of malloc() that can be rigged to fail after a certain number of allocations. These instrumented mallocs can be set to fail only once and then start working again, or to continue failing after the first failure. OOM tests are done in a loop. On the first iteration of the loop, the instrumented malloc is rigged to fail on the first allocation. Then some SQLite operation is carried out and checks are done to make sure SQLite handled the OOM error correctly. Then the time-to-failure counter on the instrumented malloc is increased by one and the test is repeated. The loop continues until the entire operation runs to completion without ever encountering a simulated OOM failure. Tests like this are run twice, once with the instrumented malloc set to fail only once, and again with the instrumented malloc set to fail continuously after the first failure.</source>
          <target state="translated">OOMテストは、OOMエラーをシミュレートすることによって行われます。 SQLiteは、アプリケーションが&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;を使用して代替のmalloc（）実装を置き換えることを可能にします、...） インターフェース。 TCLとTH3のテストハーネスはどちらも、特定の数の割り当て後に失敗するようにリギングできるmalloc（）の変更バージョンを挿入できます。これらのインストルメント化されたmallocは、1回だけ失敗してから再び作業を開始するか、最初の失敗後に失敗し続けるように設定できます。 OOMテストはループで実行されます。ループの最初の反復で、インストルメント化されたmallocは、最初の割り当てで失敗するようにリギングされます。次に、いくつかのSQLite操作が実行され、SQLiteがOOMエラーを正しく処理したことを確認するためのチェックが行われます。次に、インストルメント化されたmallocの障害までの時間カウンターを1つ増やし、テストを繰り返します。ループは、シミュレーション全体のOOM障害に遭遇することなく、操作全体が完了するまで実行されます。このようなテストは2回実行され、一度、インストルメント化されたmallocが1回だけ失敗するように設定し、インストルメント化mallocを設定して、最初の失敗の後に継続的に失敗するように設定します。</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="683e61c81d390d130002106c2c28e827414b7056" translate="yes" xml:space="preserve">
          <source>ORDER</source>
          <target state="translated">ORDER</target>
        </trans-unit>
        <trans-unit id="2164bde64d5e67a9aad0e7c0543250365dc40e72" translate="yes" xml:space="preserve">
          <source>ORDER BY</source>
          <target state="translated">並び順</target>
        </trans-unit>
        <trans-unit id="e4ec6dd8b3c32fb2c490ae23010139de3ea19166" translate="yes" xml:space="preserve">
          <source>ORDER BY and GROUP BY now use bounded memory</source>
          <target state="translated">ORDER BYとGROUP BYでは、制限付きメモリを使用するようになりました。</target>
        </trans-unit>
        <trans-unit id="f9252c387c5a364e0aa75e161fd6ca4b31550d60" translate="yes" xml:space="preserve">
          <source>ORDER BY ignored if the query has an identical GROUP BY. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</source>
          <target state="translated">クエリに同じGROUP BYがある場合、ORDER BYは無視されます。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d00407a3fb0d8ad7b8bcf4535e5d986d53520d0" translate="yes" xml:space="preserve">
          <source>ORDER BY works on subselects</source>
          <target state="translated">ORDER BY はサブセレクトで動作します。</target>
        </trans-unit>
        <trans-unit id="fb1eb08d2d3f0a79b8449be8ce9ee77050e088a5" translate="yes" xml:space="preserve">
          <source>OS Interface</source>
          <target state="translated">OSインタフェース</target>
        </trans-unit>
        <trans-unit id="7ea1a5ba1dffba576fe0a188bb466f1a65ef5c2d" translate="yes" xml:space="preserve">
          <source>OS Interface File Virtual Methods Object</source>
          <target state="translated">OSインタフェースファイル仮想メソッドオブジェクト</target>
        </trans-unit>
        <trans-unit id="2fdd9f0dd04e20b2da0185c9864ac62e0fd49b33" translate="yes" xml:space="preserve">
          <source>OS Interface Object</source>
          <target state="translated">OSインタフェースオブジェクト</target>
        </trans-unit>
        <trans-unit id="e502b880ac4721322e02bb29b5215f15ab6c97e9" translate="yes" xml:space="preserve">
          <source>OS Interface Open File Handle</source>
          <target state="translated">OSインタフェースオープンファイルハンドル</target>
        </trans-unit>
        <trans-unit id="1bea0dbc1c9e6f1262f42405074e1a4e5f89e1c4" translate="yes" xml:space="preserve">
          <source>OSS Fuzz no longer finds historical bugs in SQLite. But it is still running and does occasionally find issues in new development check-ins. Examples: &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=c422afb507dc8757&quot;&gt;[1]&lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=0a2eb949f8a759e5&quot;&gt;[2]&lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=62f2235adf796c72&quot;&gt;[3]&lt;/a&gt;.</source>
          <target state="translated">OSS Fuzzは、SQLiteの過去のバグを検出しなくなりました。ただし、まだ実行中であり、新しい開発チェックインで問題が発生することがあります。例：&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=c422afb507dc8757&quot;&gt;[1] &lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=0a2eb949f8a759e5&quot;&gt;[2] &lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=62f2235adf796c72&quot;&gt;[3]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dee9889ad644e6e58468f0ff85f3a57aa76cfbd9" translate="yes" xml:space="preserve">
          <source>OTHERS</source>
          <target state="translated">OTHERS</target>
        </trans-unit>
        <trans-unit id="a032f6607e24aa99492871d19a553d714048e163" translate="yes" xml:space="preserve">
          <source>OUTER</source>
          <target state="translated">OUTER</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
