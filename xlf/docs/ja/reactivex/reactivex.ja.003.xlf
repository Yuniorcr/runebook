<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="reactivex">
    <body>
      <group id="reactivex">
        <trans-unit id="5e8309810456d4c8a3fb450f989511d4ca97a5f2" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;retry&lt;/code&gt;.</source>
          <target state="translated">RxPHPはこの演算子を &lt;code&gt;retry&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="96be0190f3d3fc503c91d590063f44a320119576" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;scan&lt;/code&gt;.</source>
          <target state="translated">RxPHPはこの演算子を &lt;code&gt;scan&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="a1f0adb2d5724b28a03046eb2fab6cbfbe6b5aaf" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;share&lt;/code&gt;.</source>
          <target state="translated">RxPHPはこの演算子を &lt;code&gt;share&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="07fce018a2c4e1d4d94e654bd3c25c477e5c0c91" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;skip&lt;/code&gt;.</source>
          <target state="translated">RxPHPはこの演算子を &lt;code&gt;skip&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="6570ec1baeff52881f92e79c2ad9a4da861a904f" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;skipLast&lt;/code&gt;.</source>
          <target state="translated">RxPHPはこの演算子を &lt;code&gt;skipLast&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="1dff7eb9ed29c2313f0cfe0f58e8fba3b2c63e5a" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;skipUntil&lt;/code&gt;.</source>
          <target state="translated">RxPHPはこの演算子を &lt;code&gt;skipUntil&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="513b3a413de80dce65d0e00666f5ef5b4c9bf1aa" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;skipWhile&lt;/code&gt;.</source>
          <target state="translated">RxPHPはこの演算子を &lt;code&gt;skipWhile&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="9e88c511ae3daafbdf76d321b9151b57384484df" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="translated">RxPHPはこの演算子を &lt;code&gt;start&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="0c92b4fc46698d2ae7e26b71de9c32b8c2f6d57e" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;startWith&lt;/code&gt;.</source>
          <target state="translated">RxPHPはこの演算子を &lt;code&gt;startWith&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="832b05105e23624efd86948b924c0f1751818125" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;subscribe&lt;/code&gt;.</source>
          <target state="translated">RxPHPはこの演算子を &lt;code&gt;subscribe&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="3c957f67ad24104a39df6f836fb6b54d70740467" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;sum&lt;/code&gt;.</source>
          <target state="translated">RxPHPはこの演算子を &lt;code&gt;sum&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="8bdaa3c05aeaf63bae13f0195ca2226795340d12" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;switch&lt;/code&gt;.</source>
          <target state="translated">RxPHPはこの演算子を &lt;code&gt;switch&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="ce05f8533b11c7671d9d453c18145c2e8aed7a22" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;take&lt;/code&gt;.</source>
          <target state="translated">RxPHPは、この演算子を &lt;code&gt;take&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="a2e8faa39d887fc4a77c0cbb2a2c07c63d30adbe" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;takeLast&lt;/code&gt;.</source>
          <target state="translated">RxPHPは、この演算子を &lt;code&gt;takeLast&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="b9becd98fcde7eb00ee90cbeb4094c495b3d5449" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;takeUntil&lt;/code&gt;.</source>
          <target state="translated">RxPHPはこの演算子を &lt;code&gt;takeUntil&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="7223b628e1c69a31ea40c4223bef42898a005c0e" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;takeWhile&lt;/code&gt;.</source>
          <target state="translated">RxPHPは、この演算子を &lt;code&gt;takeWhile&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="b814ec6e39fbd54b10a0d923b95126e6d3bdfd9b" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;throttle&lt;/code&gt;.</source>
          <target state="translated">RxPHPはこの演算子を &lt;code&gt;throttle&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="254b8b5c4b6eb7da28ffdb42f62793a649138295" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">RxPHPはこの演算子を &lt;code&gt;timeout&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="63a0ffc10f609a37f26f3bbd9752db98ae852d52" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;timer&lt;/code&gt;.</source>
          <target state="translated">RxPHPはこの演算子を &lt;code&gt;timer&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="3b5a871540bb6d5bbc165c1c3a01d55f9f615992" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;timestamp&lt;/code&gt;.</source>
          <target state="translated">RxPHPはこの演算子を &lt;code&gt;timestamp&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="b9e559c3811597bfc4934e6a3753e9dd2d48a76d" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;toArray&lt;/code&gt;.</source>
          <target state="translated">RxPHPはこの演算子を &lt;code&gt;toArray&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="8d89610894d0e11591b07a8d0b5f707e52e20aff" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;zip&lt;/code&gt;.</source>
          <target state="translated">RxPHPはこの演算子を &lt;code&gt;zip&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="693dd13c486759895879d696fa0d950298a01163" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;buffer buffer_with_count buffer_with_time buffer_with_time_or_count pairwise&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;buffer buffer_with_count buffer_with_time buffer_with_time_or_count pairwise&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b08fa4aafa83a12fa7ebfe42e4da8aa1978130dc" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;catch_exception on_error_resume_next&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;catch_exception on_error_resume_next&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f487b92c7d1f5f02bf47e49e97edd32c9562bb8b" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;concat concatAll&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;concat concatAll&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d7f9553e8f51cdbaa07acff1e4f8c35eb5adb9f" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;count&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7140c2e79a019dcc0f9830e029714291144461e3" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;merge merge_all merge_observable&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;merge merge_all merge_observable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c0c81899aa32f6f63c27070385f97d5d03d71bd" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;retry&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;retry&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad2236de8db3968c25d85d2b6cf0e5652cd401c7" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;start_with&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;start_with&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0daa3267a7976fd4c6108e56152747f06dda4357" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;window window_with_count window_with_time window_with_time_or_count&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;window window_with_count window_with_time window_with_time_or_count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="270f2d48778b0f06758b9264a8433fde64b901fd" translate="yes" xml:space="preserve">
          <source>RxPY has several Buffer variants: &lt;code&gt;buffer&lt;/code&gt;, &lt;code&gt;buffer_with_count&lt;/code&gt;, &lt;code&gt;buffer_with_time&lt;/code&gt;, and &lt;code&gt;buffer_with_time_or_count&lt;/code&gt;. For each of these variants there are optional parameters that change the behavior of the operator. As always in RxPY, when an operator may take more than one optional parameter, be sure to name the parameter in the parameter list when you call the operator so as to avoid ambiguity.</source>
          <target state="translated">RxPYにはいくつかのバッファバリアントがあります： &lt;code&gt;buffer&lt;/code&gt; 、 &lt;code&gt;buffer_with_count&lt;/code&gt; 、 &lt;code&gt;buffer_with_time&lt;/code&gt; 、および &lt;code&gt;buffer_with_time_or_count&lt;/code&gt; 。これらのバリアントのそれぞれについて、オペレーターの動作を変更するオプションのパラメーターがあります。常にRxPYと同様に、オペレーターが複数のオプションパラメーターを取る場合は、あいまいさを避けるために、オペレーターを呼び出すときにパラメーターリストでパラメーターに名前を付けてください。</target>
        </trans-unit>
        <trans-unit id="1fd6654db5dccbd88806c19c104c30fa3099b447" translate="yes" xml:space="preserve">
          <source>RxPY implements the Catch operator with two distinct operators:</source>
          <target state="translated">RxPYは2つの異なる演算子を持つCatch演算子を実装しています。</target>
        </trans-unit>
        <trans-unit id="997bbecd73d735cf76caff6f3e11f3b5f278d21c" translate="yes" xml:space="preserve">
          <source>RxPY implements this operator as &lt;code&gt;merge&lt;/code&gt; and &lt;code&gt;merge_all&lt;/code&gt;/&lt;code&gt;merge_observable&lt;/code&gt;.</source>
          <target state="translated">RxPYはこの演算子を &lt;code&gt;merge&lt;/code&gt; および &lt;code&gt;merge_all&lt;/code&gt; / &lt;code&gt;merge_observable&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="64854a6b85df528ef6e41cdcd85374b370c89a23" translate="yes" xml:space="preserve">
          <source>RxPY implements this operator as &lt;code&gt;retry&lt;/code&gt;:</source>
          <target state="translated">RxPYはこの演算子を &lt;code&gt;retry&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="ad669011fa261f9e28135fcb0af82aed927e312b" translate="yes" xml:space="preserve">
          <source>RxPY implements this operator as &lt;code&gt;start_with&lt;/code&gt;. It accepts an array of items which it prepends to the resulting Observable sequence in the order they appear in the array before it emits the items from the source Observable.</source>
          <target state="translated">RxPYはこの演算子を &lt;code&gt;start_with&lt;/code&gt; として実装します。これは、ソースのObservableからアイテムを出力する前に、配列に表示される順序で結果のObservableシーケンスの前に付加されるアイテムの配列を受け入れます。</target>
        </trans-unit>
        <trans-unit id="7ec7900945bed69788945e976470cea403e81661" translate="yes" xml:space="preserve">
          <source>RxPY implements this operator with several variants of four different functions.</source>
          <target state="translated">RxPYはこの演算子を4つの異なる関数のいくつかのバリエーションで実装しています。</target>
        </trans-unit>
        <trans-unit id="f1d67170a06e97a4449045c839dc5d1e2382b69d" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;+:&lt;/code&gt;</source>
          <target state="translated">RxScala &lt;code&gt;+:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcef499d4c4fb2f6d94f8c4cef84a8b26d465d06" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;concat ++&lt;/code&gt;</source>
          <target state="translated">RxScala &lt;code&gt;concat ++&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e990f0e0a54de0238f215152d4442c39ce492c0" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;count length longCount size&lt;/code&gt;</source>
          <target state="translated">RxScala &lt;code&gt;count length longCount size&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed829eaad25e9f641868bfa691741709980df995" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;flatten flattenDelayError merge mergeDelayError&lt;/code&gt;</source>
          <target state="translated">RxScala &lt;code&gt;flatten flattenDelayError merge mergeDelayError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d9b6011a4b7d18c76b5a21d4203132c6cd933ab" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;onErrorFlatMap onErrorResumeNext onErrorReturn onExceptionResumeNext&lt;/code&gt;</source>
          <target state="translated">RxScala &lt;code&gt;onErrorFlatMap onErrorResumeNext onErrorReturn onExceptionResumeNext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="563a94ee27ba81015d3aeed667733daeed349e03" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;retry retryWhen&lt;/code&gt;</source>
          <target state="translated">RxScala &lt;code&gt;retry retryWhen&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e07e71d4f4652a21fd420d1ab1de3e2951e86f7" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;sliding tumbling&lt;/code&gt;</source>
          <target state="translated">RxScala &lt;code&gt;sliding tumbling&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ba1f219f82e8f92570a08b4c69107dc38cc7ceb" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;slidingBuffer tumblingBuffer&lt;/code&gt;</source>
          <target state="translated">RxScala &lt;code&gt;slidingBuffer tumblingBuffer&lt;/code&gt; バッファtumblingBuffer</target>
        </trans-unit>
        <trans-unit id="39a7d257695fedcf6f7513b3c29a4532e1ea9e0b" translate="yes" xml:space="preserve">
          <source>RxScala has two varieties of Buffer &amp;mdash; &lt;code&gt;slidingBuffer&lt;/code&gt; and &lt;code&gt;tumblingBuffer&lt;/code&gt; &amp;mdash; each of which has variants with different ways of assembling the buffers they emit:</source>
          <target state="translated">- RxScalaは、バッファの2種類あり &lt;code&gt;slidingBuffer&lt;/code&gt; と &lt;code&gt;tumblingBuffer&lt;/code&gt; -彼らは発するバッファを組み立てるさまざまな方法で変異体がそれぞれ有するを：</target>
        </trans-unit>
        <trans-unit id="49dbca94ff276bf9d442df62b994dee8a001be10" translate="yes" xml:space="preserve">
          <source>RxScala has two versions of this operator: &lt;code&gt;retry&lt;/code&gt; and &lt;code&gt;retryWhen&lt;/code&gt;.</source>
          <target state="translated">RxScalaには、この演算子の2つのバージョン、 &lt;code&gt;retry&lt;/code&gt; と &lt;code&gt;retryWhen&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="a52c08948f140da58bfdcde6019760eb047a5893" translate="yes" xml:space="preserve">
          <source>RxScala implements this operator as &lt;code&gt;flatten&lt;/code&gt;, &lt;code&gt;flattenDelayError&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt;, and &lt;code&gt;mergeDelayError&lt;/code&gt;.</source>
          <target state="translated">RxScalaはこの演算子を &lt;code&gt;flatten&lt;/code&gt; 、 &lt;code&gt;flattenDelayError&lt;/code&gt; 、 &lt;code&gt;merge&lt;/code&gt; 、および &lt;code&gt;mergeDelayError&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="39eccc9709809defbe492077eaf3cc6d83d3e433" translate="yes" xml:space="preserve">
          <source>RxScala implements this operator as &lt;code&gt;sliding&lt;/code&gt; (creates windows that may overlap or have gaps) and &lt;code&gt;tumbling&lt;/code&gt; (creates windows whose collective emissions match those of the source Observable one-to-one).</source>
          <target state="translated">RxScalaは、このオペレーターを &lt;code&gt;sliding&lt;/code&gt; （オーバーラップするか、ギャップのあるウィンドウを作成する）と &lt;code&gt;tumbling&lt;/code&gt; （ソースのObservableと1対1で一致するエミッションのウィンドウを作成する）として実装します。</target>
        </trans-unit>
        <trans-unit id="abd5b95c1e25b6159372d87c175648f0d5290301" translate="yes" xml:space="preserve">
          <source>RxScala implements this operator in two ways. There is a &lt;code&gt;concat&lt;/code&gt; operator that accepts an Observable of Observables as its parameter, and then concatenates each of these Observables in the order they are emitted. There is also a &lt;code&gt;++&lt;/code&gt; operator that concatenates one Observable to another.</source>
          <target state="translated">RxScalaはこの演算子を2つの方法で実装します。ObservableのObservableをパラメーターとして受け入れ、それらのObservableのそれぞれを、それらが発行された順序で連結する &lt;code&gt;concat&lt;/code&gt; 演算子があります。あるObservableを別のObservableに連結する &lt;code&gt;++&lt;/code&gt; 演算子もあります。</target>
        </trans-unit>
        <trans-unit id="cea120686efc2c1a225b8c5d36b8c8a2546ed795" translate="yes" xml:space="preserve">
          <source>RxScala implements this operator with &lt;code&gt;+:&lt;/code&gt; It takes an item and an Observable as parameters, and prepends the item to the items emitted by the Observable as its own Observable sequence.</source>
          <target state="translated">RxScalaはこの演算子を &lt;code&gt;+:&lt;/code&gt; 実装します。これはアイテムとObservableをパラメーターとして受け取り、Observableが独自のObservableシーケンスとして発行したアイテムの前にアイテムを追加します。</target>
        </trans-unit>
        <trans-unit id="7aee45e741f377a8920ab095d941fa4d0aa645e1" translate="yes" xml:space="preserve">
          <source>RxSwift &lt;code&gt;create generate&lt;/code&gt;</source>
          <target state="translated">RxSwift &lt;code&gt;create generate&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3db1b8cf654b640f6385d1a6b05692292a59ad5f" translate="yes" xml:space="preserve">
          <source>RxSwift &lt;code&gt;from toObservable&lt;/code&gt;</source>
          <target state="translated">toObservable &lt;code&gt;from toObservable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c4c9d6bed1ede16cf84de597f7384adbcd65a4df" translate="yes" xml:space="preserve">
          <source>RxSwift &lt;code&gt;just sequenceOf&lt;/code&gt;</source>
          <target state="translated">RxSwift &lt;code&gt;just sequenceOf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d4e8e91a479b7c9366d77f396ae487f990b467c" translate="yes" xml:space="preserve">
          <source>RxSwift &lt;code&gt;merge&lt;/code&gt;</source>
          <target state="translated">RxSwift &lt;code&gt;merge&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a00334313be967429412cd5d38086f0879ce4fd" translate="yes" xml:space="preserve">
          <source>RxSwift implements this operator as &lt;code&gt;create&lt;/code&gt;.</source>
          <target state="translated">RxSwiftはこの演算子を &lt;code&gt;create&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="588e95814c5e31b0ac881ca2f54f2f8d85b98a60" translate="yes" xml:space="preserve">
          <source>RxSwift implements this operator as &lt;code&gt;merge&lt;/code&gt;.</source>
          <target state="translated">RxSwiftはこの演算子を &lt;code&gt;merge&lt;/code&gt; として実装します。</target>
        </trans-unit>
        <trans-unit id="08fe3e272ac8a840ae0419188778167b77dfba85" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;buffer_with_count buffer_with_time&lt;/code&gt;</source>
          <target state="translated">Rxrb &lt;code&gt;buffer_with_count buffer_with_time&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85e804e67cc2836d4ddbb8cf5a880cac3b949246" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;concat merge_all&lt;/code&gt;</source>
          <target state="translated">Rxrb &lt;code&gt;concat merge_all&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf397e3bfea0116e080b5016e227d6d855282363" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;count&lt;/code&gt;</source>
          <target state="translated">Rxrb &lt;code&gt;count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c58630d6a27e4165c3459321a03d4d7999ee328" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;merge merge_all merge_concurrent&lt;/code&gt;</source>
          <target state="translated">RXRB &lt;code&gt;merge merge_all merge_concurrent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="42b8dfaca4f34d142d3e9d8366843183b5a84671" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;on_error_resume_next rescue_error&lt;/code&gt;</source>
          <target state="translated">Rxrb &lt;code&gt;on_error_resume_next rescue_error&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df48fa3e5b8f8a30e164ea1f4851bd4e9bed232c" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;retry retry_infinitely&lt;/code&gt;</source>
          <target state="translated">RXRB &lt;code&gt;retry retry_infinitely&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a50ff5d458a6a3a00e213fe188f13ef8d6625fa8" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;start_with&lt;/code&gt;</source>
          <target state="translated">Rxrb &lt;code&gt;start_with&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="714fa5ff8b3c9def68b57d14f6d9b843dccdf5c5" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;window_with_count&lt;/code&gt;</source>
          <target state="translated">Rxrb &lt;code&gt;window_with_count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58fabfa70811950fc1a8c6e0d56faec87e4e08cb" translate="yes" xml:space="preserve">
          <source>Sample</source>
          <target state="translated">Sample</target>
        </trans-unit>
        <trans-unit id="db412b35391491a23074f474e3dd7ab6ca4b7fa3" translate="yes" xml:space="preserve">
          <source>Sample Code</source>
          <target state="translated">サンプルコード</target>
        </trans-unit>
        <trans-unit id="28cba55d2aadf568463a9e7e645f8c7b1eed5e8b" translate="yes" xml:space="preserve">
          <source>Scan</source>
          <target state="translated">Scan</target>
        </trans-unit>
        <trans-unit id="cdcb4d8493703e86ddd0f22eb1ff805a9c89e0d9" translate="yes" xml:space="preserve">
          <source>Scheduler</source>
          <target state="translated">Scheduler</target>
        </trans-unit>
        <trans-unit id="e87e52ff4851168a4b90a0a3101d9e9213c6f05e" translate="yes" xml:space="preserve">
          <source>Schedulers</source>
          <target state="translated">Schedulers</target>
        </trans-unit>
        <trans-unit id="67373bb92cd7ecbf243edb9d60ad6f00f86a6052" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">も参照してください。</target>
        </trans-unit>
        <trans-unit id="61a08f389a25b863d0fca5015a2885ff6fd5c8cd" translate="yes" xml:space="preserve">
          <source>See Also:</source>
          <target state="translated">も参照してください。</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">参照:</target>
        </trans-unit>
        <trans-unit id="fe62ba3ec2492fa0dd21300f90b4d59db54088d3" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;start&quot;&gt;Start&lt;/a&gt; operator for more information about those operators.</source>
          <target state="translated">これらの演算子の詳細については、&lt;a href=&quot;start&quot;&gt;Start&lt;/a&gt;演算子を参照してください。</target>
        </trans-unit>
        <trans-unit id="49229070d9275f2e39ff0135c499c3ec82be4d2d" translate="yes" xml:space="preserve">
          <source>SequenceEqual</source>
          <target state="translated">SequenceEqual</target>
        </trans-unit>
        <trans-unit id="6d6721069e94a67d89931555797dda0103cb23bb" translate="yes" xml:space="preserve">
          <source>Serialize</source>
          <target state="translated">Serialize</target>
        </trans-unit>
        <trans-unit id="dd1186892a2f5c2bd17cd7d41f90482e39bd02c5" translate="yes" xml:space="preserve">
          <source>Single</source>
          <target state="translated">Single</target>
        </trans-unit>
        <trans-unit id="3da474537ac378c616d6b301acc1674bc348cecd" translate="yes" xml:space="preserve">
          <source>Skip</source>
          <target state="translated">Skip</target>
        </trans-unit>
        <trans-unit id="cff8beecc61f3252bacde95ccb2d21cb2c7bb3de" translate="yes" xml:space="preserve">
          <source>SkipLast</source>
          <target state="translated">SkipLast</target>
        </trans-unit>
        <trans-unit id="bd69ea5a210dcd2d5ba05305f96e8abd8c637cac" translate="yes" xml:space="preserve">
          <source>SkipUntil</source>
          <target state="translated">SkipUntil</target>
        </trans-unit>
        <trans-unit id="22e179bea92af551a86509fda88cb097314902ec" translate="yes" xml:space="preserve">
          <source>SkipWhile</source>
          <target state="translated">SkipWhile</target>
        </trans-unit>
        <trans-unit id="58ecadbac79fe5cc51359cb68804c30a5376637e" translate="yes" xml:space="preserve">
          <source>Some Notes on Naming Conventions</source>
          <target state="translated">命名規約に関する注意事項</target>
        </trans-unit>
        <trans-unit id="0b85a6daf91059f7033cbb077e016fc28a7f815d" translate="yes" xml:space="preserve">
          <source>Some Observable operators in RxGroovy have alternate forms that allow you to set which Scheduler the operator will use for (at least some part of) its operation. Others do not operate on any particular Scheduler, or operate on a particular default Scheduler. Those that have a particular default Scheduler include:</source>
          <target state="translated">RxGroovyのObservable演算子の中には、演算子が(少なくとも一部の)操作に使用するスケジューラを設定することができる代替フォームを持っているものがあります。その他の演算子は、特定のスケジューラで動作しないものや、特定のデフォルトのスケジューラで動作するものもあります。特定のデフォルトのスケジューラを持つものには、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="fbcdf6312e8b52916c1de7617e91f5554391d0ef" translate="yes" xml:space="preserve">
          <source>Some Observable operators in RxJava have alternate forms that allow you to set which Scheduler the operator will use for (at least some part of) its operation. Others do not operate on any particular Scheduler, or operate on a particular default Scheduler. Those that have a particular default Scheduler include:</source>
          <target state="translated">RxJavaのObservable演算子の中には、演算子がどのスケジューラを使用して(少なくとも一部の操作に)動作するかを設定できるように、別の形式を持っているものがあります。その他の演算子は、特定のスケジューラで動作しないものや、特定のデフォルトのスケジューラで動作するものもあります。特定のデフォルトのスケジューラを持つものには、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="38cb086c4a233cb1a5333ff9d36f701c059eb82f" translate="yes" xml:space="preserve">
          <source>Some ReactiveX Observable operators have variants that take a Scheduler as a parameter. These instruct the operator to do some or all of its work on a particular Scheduler.</source>
          <target state="translated">いくつかの ReactiveX Observable 演算子には、スケジューラをパラメータとして取るバリアントがあります。これらは、特定のスケジューラに対して一部または全部の作業を行うようにオペレータに指示します。</target>
        </trans-unit>
        <trans-unit id="4ac9202dc9541026835ce69df02b385e6fb504c2" translate="yes" xml:space="preserve">
          <source>Somewhat confusingly, there are also &lt;code&gt;BlockingObservable&lt;/code&gt; operators called &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;firstOrDefault&lt;/code&gt; that block and then return items, rather than immediately returning Observables.</source>
          <target state="translated">やや混乱しますが、Observableをすぐに返すのではなく、項目をブロックしてから返す、 &lt;code&gt;first&lt;/code&gt; と &lt;code&gt;firstOrDefault&lt;/code&gt; と呼ばれる &lt;code&gt;BlockingObservable&lt;/code&gt; 演算子もあります。</target>
        </trans-unit>
        <trans-unit id="1fee22cfdb8ade626b92fda4b1958a7e7558e18d" translate="yes" xml:space="preserve">
          <source>Somewhat confusingly, there are also &lt;code&gt;BlockingObservable&lt;/code&gt; operators called &lt;code&gt;last&lt;/code&gt; and &lt;code&gt;lastOrDefault&lt;/code&gt; that block and then return items, rather than immediately returning Observables.</source>
          <target state="translated">やや混乱しますが、Observableをすぐに返すのではなく、項目をブロックしてから返す、 &lt;code&gt;last&lt;/code&gt; および &lt;code&gt;lastOrDefault&lt;/code&gt; と呼ばれる &lt;code&gt;BlockingObservable&lt;/code&gt; 演算子もあります。</target>
        </trans-unit>
        <trans-unit id="2083d000ffd0eaf7ff35e1d13313255d25a9dcad" translate="yes" xml:space="preserve">
          <source>Specialty Observables that have more precisely-controlled subscription dynamics</source>
          <target state="translated">より正確に制御されたサブスクリプションのダイナミクスを持つ特殊な観測対象物</target>
        </trans-unit>
        <trans-unit id="952f375412e89ff213a8aca383d18e5691354347" translate="yes" xml:space="preserve">
          <source>Start</source>
          <target state="translated">Start</target>
        </trans-unit>
        <trans-unit id="c0fcf7ef2af334dc9a60fd70a03cde9ff6d0d67c" translate="yes" xml:space="preserve">
          <source>StartWith</source>
          <target state="translated">StartWith</target>
        </trans-unit>
        <trans-unit id="1bee4f94669039b2e98e1615609a98c4999cb704" translate="yes" xml:space="preserve">
          <source>Store the return value from that method in a variable.</source>
          <target state="translated">そのメソッドからの戻り値を変数に格納します。</target>
        </trans-unit>
        <trans-unit id="8d183dbdcea3b29906090bd83fa6fa37923cc8ec" translate="yes" xml:space="preserve">
          <source>Subject</source>
          <target state="translated">Subject</target>
        </trans-unit>
        <trans-unit id="d6981f74767d6c63d6062ad21b3bdfcd0d0d6602" translate="yes" xml:space="preserve">
          <source>Subscribe</source>
          <target state="translated">Subscribe</target>
        </trans-unit>
        <trans-unit id="b64e02707b3e5c59a9924b22e0b846d7b7419584" translate="yes" xml:space="preserve">
          <source>SubscribeOn</source>
          <target state="translated">SubscribeOn</target>
        </trans-unit>
        <trans-unit id="d43687ae3f766f223ccfd61d7f61537fe7c5cb98" translate="yes" xml:space="preserve">
          <source>Subscribing and Unsubscribing</source>
          <target state="translated">購読と解除</target>
        </trans-unit>
        <trans-unit id="fc9ce14b28c6f2c3b72caf056ca604b2b96f7d2b" translate="yes" xml:space="preserve">
          <source>Sum</source>
          <target state="translated">Sum</target>
        </trans-unit>
        <trans-unit id="3e44c920427e845df4958295eb8c3045b55fcfd5" translate="yes" xml:space="preserve">
          <source>Switch</source>
          <target state="translated">Switch</target>
        </trans-unit>
        <trans-unit id="a5692ec6b5b1da2cd6263a5d9d0a45278c9c4f55" translate="yes" xml:space="preserve">
          <source>Switch subscribes to an Observable that emits Observables. Each time it observes one of these emitted Observables, the Observable returned by Switch unsubscribes from the previously-emitted Observable begins emitting items from the latest Observable. Note that it will unsubscribe from the previously-emitted Observable when a new Observable is emitted from the source Observable, not when the new Observable emits an item. This means that items emitted by the previous Observable between the time the subsequent Observable is emitted and the time that subsequent Observable itself begins emitting items will be dropped (as with the yellow circle in the diagram above).</source>
          <target state="translated">SwitchはObservableを放出するObservableを購読します。それが放出されたObservableの1つを観測するたびに、Switchによって返されたObservableは、以前に放出されたObservableからのサブスクライブを解除し、最新のObservableからアイテムの放出を開始します。新しいObservableがアイテムを放出する時ではなく、新しいObservableがソースObservableから放出された時に、以前に放出されたObservableからのサブスクライブを解除することに注意してください。つまり、後続のObservableが放出されてから後続のObservable自体がアイテムを放出し始めるまでの間に、前のObservableから放出されたアイテムがドロップされることになります(上の図の黄色の丸のように)。</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="56806a1ffdde7ef9980b8850997e6a7523aaf863" translate="yes" xml:space="preserve">
          <source>Take</source>
          <target state="translated">Take</target>
        </trans-unit>
        <trans-unit id="5dcddcd939a62e3fadc4a275cfbff50387ce425c" translate="yes" xml:space="preserve">
          <source>TakeLast</source>
          <target state="translated">TakeLast</target>
        </trans-unit>
        <trans-unit id="9fcf25633e653a4948dd51bdc131ece0fd641fd5" translate="yes" xml:space="preserve">
          <source>TakeLastBuffer</source>
          <target state="translated">TakeLastBuffer</target>
        </trans-unit>
        <trans-unit id="6aa5940e9dd4c148413441073a4cc00a8f767785" translate="yes" xml:space="preserve">
          <source>TakeUntil</source>
          <target state="translated">TakeUntil</target>
        </trans-unit>
        <trans-unit id="3a51f26ad628e90629aea4f7cb0d24e3af6895e3" translate="yes" xml:space="preserve">
          <source>TakeWhile</source>
          <target state="translated">TakeWhile</target>
        </trans-unit>
        <trans-unit id="460dcd29ba7372ee8c706f180c5f17bea77b1f32" translate="yes" xml:space="preserve">
          <source>Takes a transforming function that operates on each element.</source>
          <target state="translated">各要素に作用する変換関数を取ります。</target>
        </trans-unit>
        <trans-unit id="f7b71bba78008ddb77fc959998b4ce8821595bc5" translate="yes" xml:space="preserve">
          <source>Techniques like &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html&quot;&gt;Java Futures&lt;/a&gt; are straightforward to use for &lt;a href=&quot;https://gist.github.com/4670979&quot;&gt;a single level of asynchronous execution&lt;/a&gt; but they start to add &lt;a href=&quot;https://gist.github.com/4671081&quot;&gt;non-trivial complexity&lt;/a&gt; when they&amp;rsquo;re nested.</source>
          <target state="translated">以下のような技術&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html&quot;&gt;のJava先物は、&lt;/a&gt;使用するのは簡単です&lt;a href=&quot;https://gist.github.com/4670979&quot;&gt;非同期実行の単一レベル&lt;/a&gt;が、彼らは追加して起動する&lt;a href=&quot;https://gist.github.com/4671081&quot;&gt;非自明な複雑さを&lt;/a&gt;彼らが入れ子になっているとき。</target>
        </trans-unit>
        <trans-unit id="dd8118896f61d1f07d69ebf7d91ff45f22736deb" translate="yes" xml:space="preserve">
          <source>Test Scheduler</source>
          <target state="translated">テストスケジューラ</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="d10b3f041bfb2c3ec591fc7431252ff0aa39e7c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;merge&quot;&gt;Merge&lt;/a&gt; operator is also similar. It combines the emissions of two or more Observables, but may interleave them, whereas Concat never interleaves the emissions from multiple Observables.</source>
          <target state="translated">&lt;a href=&quot;merge&quot;&gt;マージ&lt;/a&gt;オペレータも同様です。2つ以上のオブザーバブルのエミッションを組み合わせますが、それらをインターリーブする場合がありますが、コンカットは複数のオブザーバブルからのエミッションをインターリーブすることはありません。</target>
        </trans-unit>
        <trans-unit id="6baefa7e9f9fcf85d05a1f29dafd893921c34fe3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;observeon&quot;&gt;ObserveOn&lt;/a&gt; operator is similar, but more limited. It instructs the Observable to send notifications to observers on a specified Scheduler.</source>
          <target state="translated">&lt;a href=&quot;observeon&quot;&gt;ObserveOnの&lt;/a&gt;オペレータは似ていますが、より制限されています。これは、指定されたスケジューラーのオブザーバーに通知を送信するようにObservableに指示します。</target>
        </trans-unit>
        <trans-unit id="f304d9aafcbc1e3a4ceb81b1ed4873b673f3f5eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;startwith&quot;&gt;StartWith&lt;/a&gt; operator is similar to Concat, but &lt;em&gt;prepends&lt;/em&gt;, rather than appends, items or emissions of items to those emitted by a source Observable.</source>
          <target state="translated">&lt;a href=&quot;startwith&quot;&gt;StartWithの&lt;/a&gt;オペレータは連結方式に類似しているが&lt;em&gt;プリペンド&lt;/em&gt;むしろ付加しアイテム又は観測源によって放出されたものと商品の排出量よりも、。</target>
        </trans-unit>
        <trans-unit id="b4fbf4d3f33e46f4107fb78991ae6736b2b937af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;subscribeon&quot;&gt;SubscribeOn&lt;/a&gt; operator is similar, but it instructs the Observable to &lt;em&gt;itself&lt;/em&gt; operate on the specified Scheduler, as well as notifying its observers on that Scheduler.</source>
          <target state="translated">&lt;a href=&quot;subscribeon&quot;&gt;SubscribeOnの&lt;/a&gt;オペレータが類似しているが、それには観測に指示&lt;em&gt;自体は、&lt;/em&gt;指定されたスケジューラ上で動作、並びにそのスケジューラにその観察者に通知します。</target>
        </trans-unit>
        <trans-unit id="49008cbd0eaec3057954e658f6781db5c9ae198a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;window&quot;&gt;Window&lt;/a&gt; operator is similar to Buffer but collects items into separate Observables rather than into data structures before reemitting them.</source>
          <target state="translated">&lt;a href=&quot;window&quot;&gt;ウィンドウ&lt;/a&gt;オペレータは、バッファに似ているが、それらを再放出する前に、データ構造の別々の観測によりもむしろにアイテムを収集します。</target>
        </trans-unit>
        <trans-unit id="b199fbd77dba31c34f4c4ce3e9dfed07aa603b91" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Action&lt;/code&gt; accepts an &lt;code&gt;Observer&lt;/code&gt; and a &lt;code&gt;Subscription&lt;/code&gt;. It uses the &lt;code&gt;Subscription&lt;/code&gt; to check for the &lt;code&gt;isUnsubscribed&lt;/code&gt; condition, upon which it will stop emitting items. You can also manually stop a &lt;code&gt;StoppableObservable&lt;/code&gt; at any time by calling its &lt;code&gt;unsubscribe&lt;/code&gt; method (which will also unsubscribe the &lt;code&gt;Subscription&lt;/code&gt; you have associated with the &lt;code&gt;StoppableObservable&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Action&lt;/code&gt; 受け入れ &lt;code&gt;Observer&lt;/code&gt; と &lt;code&gt;Subscription&lt;/code&gt; 。これは、使用して &lt;code&gt;Subscription&lt;/code&gt; をチェックする &lt;code&gt;isUnsubscribed&lt;/code&gt; それはアイテムを発する停止する際の条件、。また、その &lt;code&gt;unsubscribe&lt;/code&gt; メソッドを呼び出すことにより、いつでも手動で &lt;code&gt;StoppableObservable&lt;/code&gt; を手動で停止できます（これにより、 &lt;code&gt;StoppableObservable&lt;/code&gt; に関連付けた &lt;code&gt;Subscription&lt;/code&gt; もサブスクライブ解除されます）。</target>
        </trans-unit>
        <trans-unit id="4c70ce024057f9c87440087a96f9e5498f333be4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BlockingObservable&lt;/code&gt; Methods</source>
          <target state="translated">&lt;code&gt;BlockingObservable&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="ad1dffc2751d9cb748f91bf966099a5d8311f9ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BlockingObservable&lt;/code&gt; methods do not transform an Observable into another, filtered Observable, but rather they break out of the Observable cascade, blocking until the Observable emits the desired item, and then return that item itself.</source>
          <target state="translated">&lt;code&gt;BlockingObservable&lt;/code&gt; の方法は、他に観察可能な観察可能なフィルタ処理ではなく、彼らが観察発するまで、希望の項目をブロックし、観察可能なカスケードから抜け出すし、そのアイテム自体を返さを変換しません。</target>
        </trans-unit>
        <trans-unit id="e36745296ecb1b3339f4a779c2c85cc4ac305d93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Catch&lt;/code&gt; operator has a variant that allows you to specify which sort of Exception you want to catch. If you use that variant of the operator, any other Exceptions will be passed through to the observer as if the &lt;code&gt;Catch&lt;/code&gt; operator had not been applied.</source>
          <target state="translated">&lt;code&gt;Catch&lt;/code&gt; オペレータは、あなたがキャッチしたい例外の種類を指定することができますバリアントを持っています。そのバリアントの演算子を使用すると、 &lt;code&gt;Catch&lt;/code&gt; 演算子が適用されなかったかのように、他の例外がオブザーバーに渡されます。</target>
        </trans-unit>
        <trans-unit id="bdf5a795f14235ad0056e88296b8e1c0457d71fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ElementAt&lt;/code&gt; operator pulls an item located at a specified index location in the sequence of items emitted by the source Observable and emits that item as its own sole emission.</source>
          <target state="translated">&lt;code&gt;ElementAt&lt;/code&gt; のオペレータは、自身の唯一の排出など項目その観測と放射する光源によって放出されたアイテムのシーケンス内の指定されたインデックス位置にある項目を引っ張ります。</target>
        </trans-unit>
        <trans-unit id="c9ca6a8982e977288317bbaf760bb05436d1fac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Join&lt;/code&gt; operator combines the items emitted by two Observables, and selects which items to combine based on duration-windows that you define on a per-item basis. You implement these windows as Observables whose lifespans begin with each item emitted by either Observable. When such a window-defining Observable either emits an item or completes, the window for the item it is associated with closes. So long as an item&amp;rsquo;s window is open, it will combine with any item emitted by the other Observable. You define the function by which the items combine.</source>
          <target state="translated">&lt;code&gt;Join&lt;/code&gt; 事業者は、あなたが項目ごとに定義することデュレーション・ウィンドウに基づいて統合する項目2つの観測から放出された項目、および選択を兼ね備えています。これらのウィンドウをオブザーバブルとして実装し、そのオブザーバの寿命は、いずれかのオブザーバブルによって放出された各アイテムから始まります。このようなウィンドウを定義するObservableがアイテムを発行するか完了すると、関連付けられているアイテムのウィンドウが閉じます。アイテムのウィンドウが開いている限り、他のObservableによって発行されたアイテムと結合されます。項目を組み合わせる機能を定義します。</target>
        </trans-unit>
        <trans-unit id="49b6f233307919ab9a0d77721efeeeb85eb2427b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StringObservable&lt;/code&gt; class, which is not a default part of RxGroovy, also includes the &lt;code&gt;decode&lt;/code&gt; operator which converts a stream of multibyte characters into an Observable that emits byte arrays that respect the character boundaries.</source>
          <target state="translated">&lt;code&gt;StringObservable&lt;/code&gt; RxGroovyのデフォルトの一部ではないクラスは、また含ま &lt;code&gt;decode&lt;/code&gt; 発する文字の境界を尊重配列をバイトことを観察可能にマルチバイト文字のストリームに変換演算子。</target>
        </trans-unit>
        <trans-unit id="4647c758a074dfb5917c11c1702ea9f0320221fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Worker&lt;/code&gt; is also a &lt;code&gt;Subscription&lt;/code&gt; and so you can (and should, eventually) call its &lt;code&gt;unsubscribe&lt;/code&gt; method to signal that it can halt work and release resources:</source>
          <target state="translated">&lt;code&gt;Worker&lt;/code&gt; また、ある &lt;code&gt;Subscription&lt;/code&gt; 、あなたが（そして、最終的にすべきである）その呼び出すことができますので、 &lt;code&gt;unsubscribe&lt;/code&gt; 、それが作業を停止し、リソースを解放できることを信号にメソッドを：</target>
        </trans-unit>
        <trans-unit id="62aae628c204daa23511b0a50e55402c802b725c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Zip&lt;/code&gt; method returns an Observable that applies a function of your choosing to the combination of items emitted, in sequence, by two (or more) other Observables, with the results of this function becoming the items emitted by the returned Observable. It applies this function in strict sequence, so the first item emitted by the new Observable will be the result of the function applied to the first item emitted by Observable #1 and the first item emitted by Observable #2; the second item emitted by the new zip-Observable will be the result of the function applied to the second item emitted by Observable #1 and the second item emitted by Observable #2; and so forth. It will only emit as many items as the number of items emitted by the source Observable that emits the fewest items.</source>
          <target state="translated">&lt;code&gt;Zip&lt;/code&gt; 方法は、この関数の結果が返さ観測によって放出されたアイテムになっと、2つ（またはそれ以上）で、あなたの順序で、放出された項目の組み合わせを選択する機能を適用し、その観測他の観測を返します。この関数は厳密な順序で適用されるため、新しいObservableによって発行された最初のアイテムは、Observable＃1によって発行された最初のアイテムとObservable＃2によって発行された最初のアイテムに適用された関数の結果になります。新しいzip-Observableが発行する2番目のアイテムは、Observable＃1が発行する2番目のアイテムとObservable＃2が発行する2番目のアイテムに適用される関数の結果です。など。最も少ないアイテムを放出するソースObservableによって放出されたアイテムの数と同じ数のアイテムのみを放出します。</target>
        </trans-unit>
        <trans-unit id="e5691c91ab07a55b1c3fb75c15c16429d75b4d53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cast&lt;/code&gt; operator is a specialized version of Map that transforms each item from the source Observable by casting it into a particular Class before reemitting it.</source>
          <target state="translated">&lt;code&gt;cast&lt;/code&gt; 演算子は、それを再放出する前に、特定のクラスにそれをキャストにより観察源から各項目を変換地図の特殊なバージョンです。</target>
        </trans-unit>
        <trans-unit id="2d52bc5228a5c99adbd13b94db13bf682b4106af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collect&lt;/code&gt; operator is similar to &lt;code&gt;reduce&lt;/code&gt; but is specialized for the purpose of collecting the whole set of items emitted by the source Observable into a single mutable data structure to be emitted by the resulting Observable. Pass it two parameters:</source>
          <target state="translated">&lt;code&gt;collect&lt;/code&gt; 作業者は次のようになる &lt;code&gt;reduce&lt;/code&gt; が、得られた観測によって放出される単一可変データ構造に観測源によって放出されたアイテムのセット全体を収集するために特化されています。2つのパラメータを渡します。</target>
        </trans-unit>
        <trans-unit id="6cf0adfab79277c51e5dafe6774782092f0c83c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;concat*&lt;/code&gt; operator concatenates the Observables emitted by an Observable together, in the order in which they are emitted.</source>
          <target state="translated">&lt;code&gt;concat*&lt;/code&gt; オペレータは、それらが放出されるために、観測一緒にすることによって放出された観測を連結します。</target>
        </trans-unit>
        <trans-unit id="262174a50de88e018bb2bb7470c296853e50fc00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connect&lt;/code&gt; method returns a &lt;code&gt;Disposable&lt;/code&gt;. You can call that &lt;code&gt;Disposable&lt;/code&gt; object&amp;rsquo;s &lt;code&gt;dispose&lt;/code&gt; method to instruct the Observable to stop emitting items to its Subscribers.</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; 方法は返し &lt;code&gt;Disposable&lt;/code&gt; 。その &lt;code&gt;Disposable&lt;/code&gt; オブジェクトの &lt;code&gt;dispose&lt;/code&gt; メソッドを呼び出して、Observableにサブスクライバーへのアイテムの送信を停止するように指示できます。</target>
        </trans-unit>
        <trans-unit id="0f476bb86d90183235c41e4ed71417a68f5fc2ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connect&lt;/code&gt; method returns a &lt;code&gt;Subscription&lt;/code&gt;. You can call that &lt;code&gt;Subscription&lt;/code&gt; object&amp;rsquo;s &lt;code&gt;unsubscribe&lt;/code&gt; method to instruct the Observable to stop emitting items to its Subscribers.</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; 方法は返し &lt;code&gt;Subscription&lt;/code&gt; 。その &lt;code&gt;Subscription&lt;/code&gt; オブジェクトの &lt;code&gt;unsubscribe&lt;/code&gt; メソッドを呼び出して、サブスクライバーへのアイテムの送信を停止するようにObservableに指示できます。</target>
        </trans-unit>
        <trans-unit id="32a0f2e47fcf367aab2c4d2fea54935a14d32d23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;contains&lt;/code&gt; operator in RxJS takes an optional second parameter: a zero-based index into the source Observable&amp;rsquo;s sequence at which to start searching for the item.</source>
          <target state="translated">RxJS の &lt;code&gt;contains&lt;/code&gt; 演算子は、オプションの2番目のパラメーター（項目の検索を開始するソースObservableのシーケンスへのゼロベースのインデックス）を取ります。</target>
        </trans-unit>
        <trans-unit id="13a54029acae7bece88ccff45131ab5c099597a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;debounceWithSelector&lt;/code&gt; operator throttles the source Observable by applying a function to each item it emits, this function generating an Observable. If the source Observable emits another item before this newly-generated Observable terminates, &lt;code&gt;debounce&lt;/code&gt; will suppress the item.</source>
          <target state="translated">&lt;code&gt;debounceWithSelector&lt;/code&gt; のオペレータは、この機能が観察生成、それが放射する各項目に関数を適用することによって観察源を絞ります。この新しく生成されたObservableが終了する前にソースObservableが別のアイテムを放出する場合、 &lt;code&gt;debounce&lt;/code&gt; はアイテムを抑制します。</target>
        </trans-unit>
        <trans-unit id="e81c335785cb73611f872b22bd602a71298e93a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doAfterTerminate&lt;/code&gt; operator registers an &lt;code&gt;Action&lt;/code&gt; which will be called just &lt;em&gt;after&lt;/em&gt; the resulting Observable terminates, whether normally or with an error.</source>
          <target state="translated">&lt;code&gt;doAfterTerminate&lt;/code&gt; のオペレータは、登録 &lt;code&gt;Action&lt;/code&gt; だけ呼び出されます&lt;em&gt;後&lt;/em&gt;、通常またはエラーとするかどうか、結果の観測は終了します。</target>
        </trans-unit>
        <trans-unit id="0623a20ead85e594b09a4929adac2bbbb7b3f224" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnCompleted&lt;/code&gt; operator registers an &lt;code&gt;Action&lt;/code&gt; which will be called if the resulting Observable terminates normally, calling &lt;code&gt;onCompleted&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;doOnCompleted&lt;/code&gt; のオペレータは、登録 &lt;code&gt;Action&lt;/code&gt; の呼び出し、正常に観測が終了した場合に呼び出されます &lt;code&gt;onCompleted&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="e0026ae0169af251d209c2da5abd0bfa704cfab1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnEach&lt;/code&gt; operator allows you to establish a callback that the resulting Observable will call each time it emits an item. You can pass this callback either in the form of an &lt;code&gt;Action&lt;/code&gt; that takes an &lt;code&gt;onNext&lt;/code&gt; variety of &lt;code&gt;Notification&lt;/code&gt; as its sole parameter, or you can pass in an Observer whose &lt;code&gt;onNext&lt;/code&gt; method will be called as if it had subscribed to the Observable.</source>
          <target state="translated">&lt;code&gt;doOnEach&lt;/code&gt; のオペレータを使用すると、結果として観察可能で、それはアイテムを発するたびに呼び出すというコールバックを確立することができます。このコールバックは、 &lt;code&gt;onNext&lt;/code&gt; のさまざまな &lt;code&gt;Notification&lt;/code&gt; を唯一のパラメーターとして取る &lt;code&gt;Action&lt;/code&gt; の形式で渡すか、またはObservableにサブスクライブしたかのように呼び出される &lt;code&gt;onNext&lt;/code&gt; メソッドを持つオブザーバーに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="eabd4c3f21534a441bc83130020ea0729317f2bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnError&lt;/code&gt; operator registers an &lt;code&gt;Action&lt;/code&gt; which will be called if the resulting Observable terminates abnormally, calling &lt;code&gt;onError&lt;/code&gt;. This &lt;code&gt;Action&lt;/code&gt; will be passed the &lt;code&gt;Throwable&lt;/code&gt; representing the error.</source>
          <target state="translated">&lt;code&gt;doOnError&lt;/code&gt; のオペレータレジスタ &lt;code&gt;Action&lt;/code&gt; の呼び出し、異常な観測が終了した場合に呼び出される &lt;code&gt;onError&lt;/code&gt; 。この &lt;code&gt;Action&lt;/code&gt; は、エラーを表す &lt;code&gt;Throwable&lt;/code&gt; が渡されます。</target>
        </trans-unit>
        <trans-unit id="a69c5948b6c36fdf006d228347957b8e8b5a82cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnNext&lt;/code&gt; operator is much like &lt;code&gt;doOnEach(Action1)&lt;/code&gt; except that the &lt;code&gt;Action&lt;/code&gt; that you pass it as a parameter does not accept a &lt;code&gt;Notification&lt;/code&gt; but instead simply accepts the emitted item.</source>
          <target state="translated">&lt;code&gt;doOnNext&lt;/code&gt; の演算子はよく似ている &lt;code&gt;doOnEach(Action1)&lt;/code&gt; ことを除き、 &lt;code&gt;Action&lt;/code&gt; パラメータが受け入れないとして、あなたがそれを渡すことを &lt;code&gt;Notification&lt;/code&gt; 代わりに、単純に放出された項目を受け付けます。</target>
        </trans-unit>
        <trans-unit id="47b3486778ac1c48193054633dd037f987fce4ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnRequest&lt;/code&gt; operator (new in RxGroovy 1.1) registers an &lt;code&gt;Action&lt;/code&gt; which will be called whenever an observer requests additional items from the resulting Observable. That &lt;code&gt;Action&lt;/code&gt; receives as its parameter the number of items that the observer is requesting.</source>
          <target state="translated">&lt;code&gt;doOnRequest&lt;/code&gt; （RxGroovy 1.1で新しい）演算子レジスタ &lt;code&gt;Action&lt;/code&gt; 、観察者は、得られた観測から追加のアイテムを要求するたびに呼び出されます。その &lt;code&gt;Action&lt;/code&gt; は、オブザーバーが要求しているアイテムの数をパラメーターとして受け取ります。</target>
        </trans-unit>
        <trans-unit id="ae2db8da5cb25f3493e2edbab4c991c3a890fa95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnRequest&lt;/code&gt; operator (new in RxJava 1.1) registers an &lt;code&gt;Action&lt;/code&gt; which will be called whenever an observer requests additional items from the resulting Observable. That &lt;code&gt;Action&lt;/code&gt; receives as its parameter the number of items that the observer is requesting.</source>
          <target state="translated">&lt;code&gt;doOnRequest&lt;/code&gt; （RxJava 1.1で新しい）演算子レジスタ &lt;code&gt;Action&lt;/code&gt; 、観察者は、得られた観測から追加のアイテムを要求するたびに呼び出されます。その &lt;code&gt;Action&lt;/code&gt; は、オブザーバーが要求しているアイテムの数をパラメーターとして受け取ります。</target>
        </trans-unit>
        <trans-unit id="a7c2c85aa48da67b4394be68c9693a243657f00f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnSubscribe&lt;/code&gt; operator registers an &lt;code&gt;Action&lt;/code&gt; which will be called whenever an observer subscribes to the resulting Observable.</source>
          <target state="translated">&lt;code&gt;doOnSubscribe&lt;/code&gt; のオペレータは、登録 &lt;code&gt;Action&lt;/code&gt; 得られた観測のたびに、観察者が加入と呼ぶことにします。</target>
        </trans-unit>
        <trans-unit id="22e4b3cb15d1500d61d8e8dd0104bea7baad9fd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnTerminate&lt;/code&gt; operator registers an &lt;code&gt;Action&lt;/code&gt; which will be called just &lt;em&gt;before&lt;/em&gt; the resulting Observable terminates, whether normally or with an error.</source>
          <target state="translated">&lt;code&gt;doOnTerminate&lt;/code&gt; のオペレータは、登録 &lt;code&gt;Action&lt;/code&gt; だけ呼ばれる&lt;em&gt;前に、&lt;/em&gt;通常、またはエラーとするかどうか、結果の観測は終了します。</target>
        </trans-unit>
        <trans-unit id="c98415bf041e0eacfd89ab746aa429e8bbfe6ad5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnUnsubscribe&lt;/code&gt; operator registers an &lt;code&gt;Action&lt;/code&gt; which will be called whenever an observer unsubscribes from the resulting Observable.</source>
          <target state="translated">&lt;code&gt;doOnUnsubscribe&lt;/code&gt; のオペレータは、登録 &lt;code&gt;Action&lt;/code&gt; 得られた観測からたびに、観察者登録解除と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="f94bf58f6f661938712ce1a2d3b96c007a0d9cc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finallyDo&lt;/code&gt; operator registers an &lt;code&gt;Action&lt;/code&gt; which will be called just &lt;em&gt;after&lt;/em&gt; the resulting Observable terminates, whether normally or with an error.</source>
          <target state="translated">&lt;code&gt;finallyDo&lt;/code&gt; のオペレータは、登録 &lt;code&gt;Action&lt;/code&gt; だけ呼び出されます&lt;em&gt;後に&lt;/em&gt;正常にかどうかエラーで、結果の観測は終了します。</target>
        </trans-unit>
        <trans-unit id="ab085823e86e31a61ddfb7113f37699ef32a735d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find&lt;/code&gt; operator is much like &lt;code&gt;first&lt;/code&gt; except that the predicate argument is mandatory, and it behaves differently if no item from the source Observable matches the predicate. While &lt;code&gt;first&lt;/code&gt; will send an &lt;code&gt;onError&lt;/code&gt; notification in such a case, &lt;code&gt;find&lt;/code&gt; will instead emit an &lt;code&gt;undefined&lt;/code&gt; item.</source>
          <target state="translated">&lt;code&gt;find&lt;/code&gt; 演算子は非常に似ている &lt;code&gt;first&lt;/code&gt; 述語の引数が必須であり、観測は述語に一致するソースからノーアイテムならば、それは異なった動作をすることを除いて。このような場合、 &lt;code&gt;first&lt;/code&gt; に &lt;code&gt;onError&lt;/code&gt; 通知が送信され &lt;code&gt;find&lt;/code&gt; が、findは代わりに &lt;code&gt;undefined&lt;/code&gt; アイテムを発行します。</target>
        </trans-unit>
        <trans-unit id="4c6c877a3737234f454d67e02db333027e5f3786" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findIndex&lt;/code&gt; operator in RxJS takes as its parameter a predicate function. It returns an Observable that emits either a single number &amp;mdash; the zero-based index of the first item in the source Observable sequence that matches the predicate &amp;mdash; or &lt;code&gt;&amp;minus;1&lt;/code&gt; if no such item matches.</source>
          <target state="translated">&lt;code&gt;findIndex&lt;/code&gt; の RxJSにおけるオペレータは、そのパラメータとして述語関数を受け取り。これは、単一の数値（述語に一致するソースのObservableシーケンスの最初の項目のゼロベースのインデックス）またはそのような項目が一致しない場合は &lt;code&gt;&amp;minus;1&lt;/code&gt; するObservableを返します。</target>
        </trans-unit>
        <trans-unit id="ed0159e9a2450a5d952076a8e5cd9627bcd97c41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findIndex&lt;/code&gt; operator is similar to &lt;code&gt;find&lt;/code&gt;, except that instead of emitting the item that matches the predicate (or &lt;code&gt;undefined&lt;/code&gt;), it emits the zero-based index of that item in the source Observable&amp;rsquo;s sequence (or &lt;code&gt;-1&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;findIndex&lt;/code&gt; のオペレータがに似て &lt;code&gt;find&lt;/code&gt; 代わりに、述語（又は一致する項目発光のことを除いて、 &lt;code&gt;undefined&lt;/code&gt; ）、それはソース観測の配列（またはその中のアイテムの0から始まるインデックスを発する &lt;code&gt;-1&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="49be14c47d2aafe03c88558e00c4c6dde3f02fbc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;firstOrDefault&lt;/code&gt; operator is similar to &lt;code&gt;first&lt;/code&gt;, but you pass it a default item that it can emit if the source Observable fails to emit any items</source>
          <target state="translated">&lt;code&gt;firstOrDefault&lt;/code&gt; のオペレータは、に似ている &lt;code&gt;first&lt;/code&gt; 、しかし、あなたはそれをソース観察可能で任意の項目を発するように失敗した場合、それが発することができるというデフォルトのアイテムを渡します</target>
        </trans-unit>
        <trans-unit id="488465a4fa2c1a64f9853dcc9ecfc03937a36cce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flatMapIterable&lt;/code&gt; variants pair up source items and generated &lt;code&gt;Iterable&lt;/code&gt;s rather than source items and generated Observables, but otherwise work in much the same way.</source>
          <target state="translated">&lt;code&gt;flatMapIterable&lt;/code&gt; は、ソースアイテムまでペアを変異体および生成された &lt;code&gt;Iterable&lt;/code&gt; ほとんど同じようにソースアイテムと生成された観測が、それ以外の仕事ではなくね。</target>
        </trans-unit>
        <trans-unit id="c4df8dce680a0580207e8db092ab428c79083578" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flatMapLatest&lt;/code&gt; operator behaves much like the standard FlatMap operator, except that whenever a new item is emitted by the source Observable, it will unsubscribe to and stop mirroring the Observable that was generated from the previously-emitted item, and begin only mirroring the current one.</source>
          <target state="translated">&lt;code&gt;flatMapLatest&lt;/code&gt; はるかに標準FlatMapオペレータのようなオペレータ挙動は、新しいアイテムが観測源によって放出されるたびに、それが停止以前に放出されたアイテムから生成された観測ミラーリング解除、及びだけ現在のミラーリング開始することを除い。</target>
        </trans-unit>
        <trans-unit id="c482ae55d97cbd55598c3be35323d33a7e002821" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; operator (and its alias, &lt;code&gt;forIn&lt;/code&gt;) is very similar to &lt;code&gt;concatMap&lt;/code&gt;, though it has a converse flexibility. While &lt;code&gt;concatMap&lt;/code&gt; operates on an Observable source and can use Observable, Promise, or array intermediaries to generate its output sequence; &lt;code&gt;for&lt;/code&gt; always uses Observables as its intermediaries, but can operate on a source that is either an Observable, a Promise, or an array.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; オペレータ（およびその別名、 &lt;code&gt;forIn&lt;/code&gt; する）に非常に類似している &lt;code&gt;concatMap&lt;/code&gt; それは逆の柔軟性を有するものの、。ながら &lt;code&gt;concatMap&lt;/code&gt; は観測源で動作し、その出力シーケンスを生成するために、観測、約束、または配列媒体を使用することができます。 &lt;code&gt;for&lt;/code&gt; は常にObservableを仲介として使用しますが、Observable、Promise、または配列のいずれかのソースを操作できます。</target>
        </trans-unit>
        <trans-unit id="f48d8db17cfa63ab694c9c09d245ea6942591cf0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forEach&lt;/code&gt; operators are simpler versions of &lt;code&gt;subscribe&lt;/code&gt;. You can pass them between one and three functions, which will be interpreted as follows:</source>
          <target state="translated">&lt;code&gt;forEach&lt;/code&gt; 演算子は、より簡単なバージョンです &lt;code&gt;subscribe&lt;/code&gt; 。次のように解釈される1つと3つの関数の間でそれらを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="1a921457487d3264a61dac1881821287ea0f75ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromCallback&lt;/code&gt; operator takes a function as a parameter, calls this function, and emits the value returned from it as its single emission.</source>
          <target state="translated">&lt;code&gt;fromCallback&lt;/code&gt; のオペレータは、パラメータとして関数を取り、この関数を呼び出し、その単一の発光としてそこから返された値を発します。</target>
        </trans-unit>
        <trans-unit id="b504d654fb237651e5ac6a12e8bcfa06d02077fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromEvent&lt;/code&gt; operator takes an &amp;ldquo;element&amp;rdquo; and an event name as parameters, and it then listens for events of that name taking place on that element. It returns an Observable that emits those events. An &amp;ldquo;element&amp;rdquo; may be a simple</source>
          <target state="translated">&lt;code&gt;fromEvent&lt;/code&gt; のオペレータは、パラメータとして「要素」とイベント名を取り、それがその要素で行われて、その名前のイベントをリスンします。これらのイベントを発行するObservableを返します。「要素」は単純な場合があります</target>
        </trans-unit>
        <trans-unit id="0cebc7b8cc69c87290f5ce391d54f63ba6b5075c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromEventPattern&lt;/code&gt; operator is similar, except that instead of taking an element and an event name as parameters, it takes two functions as parameters. The first function attaches an event listener to a variety of events on a variety of elements; the second function removes this set of listeners. In this way you can establish a single Observable that emits items representing a variety of events and a variety of target elements.</source>
          <target state="translated">&lt;code&gt;fromEventPattern&lt;/code&gt; オペレータではなく、パラメータとして要素とイベント名を取る、それはパラメータとしての二つの機能をとることを除いて、同様です。最初の関数は、さまざまな要素のさまざまなイベントにイベントリスナーをアタッチします。2番目の関数は、このリスナーのセットを削除します。このようにして、さまざまなイベントとさまざまなターゲット要素を表すアイテムを放出する単一のObservableを確立できます。</target>
        </trans-unit>
        <trans-unit id="d0506ce1478017fe5fb5c14f3f465e3af698614d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getIterator&lt;/code&gt; operator applies to the &lt;code&gt;BlockingObservable&lt;/code&gt; subclass, so in order to use it, you must first convert your source Observable into a &lt;code&gt;BlockingObservable&lt;/code&gt; by means of either the &lt;code&gt;BlockingObservable.from&lt;/code&gt; method or the &lt;code&gt;Observable.toBlocking&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;getIterator&lt;/code&gt; のオペレータは以下の製品に適用さ &lt;code&gt;BlockingObservable&lt;/code&gt; ので、あなたが最初に観察可能なソースを変換する必要があり、それを使用するためには、サブクラス &lt;code&gt;BlockingObservable&lt;/code&gt; のいずれかによって &lt;code&gt;BlockingObservable.from&lt;/code&gt; の方法や &lt;code&gt;Observable.toBlocking&lt;/code&gt; のオペレーター。</target>
        </trans-unit>
        <trans-unit id="fdfd2efb1b4f9b5b207f496d9028e62a7244995f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;groupJoin&lt;/code&gt; operator takes four parameters:</source>
          <target state="translated">&lt;code&gt;groupJoin&lt;/code&gt; のオペレータは、次の4つのパラメータを取ります。</target>
        </trans-unit>
        <trans-unit id="29d22ca65d9c540689bc8b0ce26cca9ce3db4440" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;indexOf&lt;/code&gt; operator in RxJS is similar to &lt;code&gt;contains&lt;/code&gt; but rather than returning an Observable that emits &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; it returns an Observable that emits the index of the item in the source Observable sequence, or &lt;code&gt;&amp;minus;1&lt;/code&gt; if no such item was emitted.</source>
          <target state="translated">RxJS の &lt;code&gt;indexOf&lt;/code&gt; 演算子はcontainsに似てい &lt;code&gt;contains&lt;/code&gt; が、 &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; を発行するObservableを返すのではなく、ソースのObservableシーケンス内の項目のインデックスを発行するObservableを返します。そのような項目が発行されなかった場合は &lt;code&gt;&amp;minus;1&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="77be1ee57cc41fc2f9e2f8bfb2756ab14303f199" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;indexOf&lt;/code&gt; operator takes an optional second parameter: a zero-based index into the source Observable&amp;rsquo;s sequence at which to start searching for the item. The index value that the resulting Observable emits will be relative to this start point, not to the beginning of the sequence.</source>
          <target state="translated">&lt;code&gt;indexOf&lt;/code&gt; のアイテムの検索を開始するためのソース観測の配列にゼロベースのインデックス：オペレータは、オプションの二番目のパラメータを取ります。結果のObservableが発行するインデックス値は、シーケンスの開始点ではなく、この開始点に関連します。</target>
        </trans-unit>
        <trans-unit id="5552c7e46b5a139352e9da9264ebc154edea5fd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;join&lt;/code&gt; operator takes four parameters:</source>
          <target state="translated">&lt;code&gt;join&lt;/code&gt; 事業者は、4つのパラメータを取ります。</target>
        </trans-unit>
        <trans-unit id="96dab761cc41cd45ea19644cf7e7ad30cb22e0aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lastOrDefault&lt;/code&gt; operator is similar to &lt;code&gt;last&lt;/code&gt;, but you pass it a default item that it can emit if the source Observable fails to emit any items.</source>
          <target state="translated">&lt;code&gt;lastOrDefault&lt;/code&gt; オペレーターは &lt;code&gt;last&lt;/code&gt; に似ていますが、ソースのObservableがアイテムの発行に失敗した場合に発行できるデフォルトのアイテムを渡します。</target>
        </trans-unit>
        <trans-unit id="bb5672f422c4c2cb70cc9c1f677ba66ad8eba847" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;latest&lt;/code&gt; operator is similar, but rather than blocking to wait for the next emitted item, it immediately returns the most-recently-emitted item, and only blocks if the Observable has not yet emitted anything.</source>
          <target state="translated">&lt;code&gt;latest&lt;/code&gt; 演算子も同様ですが、観察可能はまだ何も放出されていない場合は、むしろ次放射された項目を待つためにブロックするよりも、それはすぐに最も最近に放出された項目、およびブロックのみを返します。</target>
        </trans-unit>
        <trans-unit id="72bbe7b92507d29558aef3a62856379c4ffcb4c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; (or &lt;code&gt;letBind&lt;/code&gt;) operator is available in the following packages:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; （または &lt;code&gt;letBind&lt;/code&gt; ）演算子は、次のパッケージで提供されています：</target>
        </trans-unit>
        <trans-unit id="d3bdb3993ae70293143f7eee67ab351fa4c6141f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;manySelect&lt;/code&gt; operator is often described as a &amp;ldquo;comonadic bind.&amp;rdquo; If that clears things up for you, you&amp;rsquo;re welcome. Elsewise, here&amp;rsquo;s an explanation:</source>
          <target state="translated">&lt;code&gt;manySelect&lt;/code&gt; のオペレータは、しばしばとして記述されている「comonadicバインド。」それで問題が解決した場合は、大歓迎です。そうでなければ、ここに説明があります：</target>
        </trans-unit>
        <trans-unit id="36db071dc02b975954bc90d1b46fa778860971d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxBy&lt;/code&gt; operator is similar to &lt;code&gt;max&lt;/code&gt;, but instead of emitting the item with the maximum value, it emits the item with the maximum &lt;em&gt;key&lt;/em&gt;, where that key is generated based on a function you provide to &lt;code&gt;maxBy&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;maxBy&lt;/code&gt; のオペレータは同様である &lt;code&gt;max&lt;/code&gt; 、その代わりに最大値を持つアイテムを放出する、最大でアイテムを発する&lt;em&gt;キー&lt;/em&gt;そのキーはあなたが提供関数に基づいて生成される、 &lt;code&gt;maxBy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13aa9ca81dae630ad2f0bf87c356c068d922d3c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxBy&lt;/code&gt; operator is similar to &lt;code&gt;max&lt;/code&gt;, but instead of emitting the item with the maximum value, it emits the item with the maximum &lt;em&gt;key&lt;/em&gt;, where that key is generated based on a function you provide to &lt;code&gt;maxBy&lt;/code&gt;. &lt;code&gt;maxBy&lt;/code&gt; also takes an optional second parameter: a comparer function that it will use instead of its default to compare the keys of the two items.</source>
          <target state="translated">&lt;code&gt;maxBy&lt;/code&gt; のオペレータは同様である &lt;code&gt;max&lt;/code&gt; 、その代わりに最大値を持つアイテムを放出する、最大でアイテムを発する&lt;em&gt;キー&lt;/em&gt;そのキーはあなたが提供関数に基づいて生成される、 &lt;code&gt;maxBy&lt;/code&gt; 。 &lt;code&gt;maxBy&lt;/code&gt; はオプションの2番目のパラメーターも受け取ります。デフォルトの代わりに2つの項目のキーを比較するために使用する比較関数です。</target>
        </trans-unit>
        <trans-unit id="e62a7b488d66dfd66eccaab522c33c28dcfbaa4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge_all&lt;/code&gt; operator, despite its name, really behaves like a Concat variant in Rx.rb. It accepts an Observable of Observables as its parameter, and concatenates the emissions from these Observables.</source>
          <target state="translated">&lt;code&gt;merge_all&lt;/code&gt; のオペレータは、その名前にもかかわらず、本当にRx.rb.で、連結バリアントのように振る舞います Observable of Observablesをパラメーターとして受け入れ、これらのObservableからのエミッションを連結します。</target>
        </trans-unit>
        <trans-unit id="591507d6d1fd978b9d1b908bc6f44f533f339a37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;minBy&lt;/code&gt; operator is similar to &lt;code&gt;min&lt;/code&gt;, but instead of emitting the item with the minimum value, it emits the item with the minimum &lt;em&gt;key&lt;/em&gt;, where that key is generated based on a function you provide to &lt;code&gt;minBy&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;minBy&lt;/code&gt; の演算子はと類似している &lt;code&gt;min&lt;/code&gt; 、その代わりに最小値とアイテムを放出する、最小でアイテムを発する&lt;em&gt;キー&lt;/em&gt;そのキーはあなたが提供関数に基づいて生成される、 &lt;code&gt;minBy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d75ab372e084506ae5ab756f24870c2c7e50227" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;minBy&lt;/code&gt; operator is similar to &lt;code&gt;min&lt;/code&gt;, but instead of emitting the item with the minimum value, it emits the item with the minimum &lt;em&gt;key&lt;/em&gt;, where that key is generated based on a function you provide to &lt;code&gt;minBy&lt;/code&gt;. &lt;code&gt;minBy&lt;/code&gt; also takes an optional second parameter: a comparer function that it will use instead of its default to compare the keys of the two items.</source>
          <target state="translated">&lt;code&gt;minBy&lt;/code&gt; の演算子はと類似している &lt;code&gt;min&lt;/code&gt; 、その代わりに最小値とアイテムを放出する、最小でアイテムを発する&lt;em&gt;キー&lt;/em&gt;そのキーはあなたが提供関数に基づいて生成される、 &lt;code&gt;minBy&lt;/code&gt; 。 &lt;code&gt;minBy&lt;/code&gt; はオプションの2番目のパラメーターも受け取ります。これは、2つの項目のキーを比較するためにデフォルトの代わりに使用する比較関数です。</target>
        </trans-unit>
        <trans-unit id="d97994082600972d411b156dd140c1aa7e0d3d6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mostRecent&lt;/code&gt; operator similarly allows you to iterate over the emissions of a &lt;code&gt;BlockingObservable&lt;/code&gt;, but its Iterable always immediately returns a value: either a default item you provide (if the &lt;code&gt;BlockingObservable&lt;/code&gt; has not yet emitted an item), or the latest item the &lt;code&gt;BlockingObservable&lt;/code&gt; has emitted.</source>
          <target state="translated">&lt;code&gt;mostRecent&lt;/code&gt; のオペレータは、同様の排出量を反復することができます &lt;code&gt;BlockingObservable&lt;/code&gt; が、その反復処理可能はいつもすぐに値を返します（あればどちらかあなたが提供するデフォルトのアイテムは &lt;code&gt;BlockingObservable&lt;/code&gt; はまだアイテムを放射されていない）、または最新の項目 &lt;code&gt;BlockingObservable&lt;/code&gt; が放出されるました。</target>
        </trans-unit>
        <trans-unit id="40070d4eb2002addde3a0bbcd673ca113e9d039a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multicast&lt;/code&gt; operator is available in the following packages:</source>
          <target state="translated">&lt;code&gt;multicast&lt;/code&gt; オペレータは、次のパッケージで提供されています：</target>
        </trans-unit>
        <trans-unit id="d99a2921d18b7527e96c7b586a0ec6bb398d2cba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt; operator blocks until the &lt;code&gt;BlockingObservable&lt;/code&gt; emits another item, and then returns that item. You can call this function repeatedly to get successive items from the &lt;code&gt;BlockingObservable&lt;/code&gt;, effectively iterating over its emissions in a blocking fashion.</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; オペレータブロックまで &lt;code&gt;BlockingObservable&lt;/code&gt; は、別のアイテムを放出し、そのアイテムを返します。この関数を繰り返し呼び出して、 &lt;code&gt;BlockingObservable&lt;/code&gt; から連続した項目を取得し、その排出をブロックする方法で効果的に反復できます。</target>
        </trans-unit>
        <trans-unit id="85e2b7ee1fbcbbebfd708d668c59aba89dff308d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;of&lt;/code&gt; operator accepts a number of items as parameters, and returns an Observable that emits each of these parameters, in order, as its emitted sequence.</source>
          <target state="translated">オペレータは、パラメータとしてアイテムの数を受け付け、その放出されたシーケンスとして、順番に、これらのパラメータの各々を発する観測を返します。 &lt;code&gt;of&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a820b931d7dd03c56a7bc833c9808fde84e35de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onErrorResumeNext&lt;/code&gt; method returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes &lt;code&gt;onError&lt;/code&gt; in which case, rather than propagating that error to the observer, &lt;code&gt;onErrorResumeNext&lt;/code&gt; will instead begin mirroring a second, backup Observable, as shown in the following sample code:</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; 方法は、ソースのミラー挙動観測は、その観測呼び出す場合を除きこと観測返し &lt;code&gt;onError&lt;/code&gt; その場合、観察者にそのエラーを伝播するのではなく、 &lt;code&gt;onErrorResumeNext&lt;/code&gt; は代わりに第二のミラーリング開始され、バックアップ観測、次のサンプルに示すようにコード：</target>
        </trans-unit>
        <trans-unit id="ad40b93d8ffe52cf75d26afebbdddd1c044c1f25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onErrorResumeNext&lt;/code&gt; method returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes &lt;code&gt;onError&lt;/code&gt; in which case, rather than propagating that error to the observer, &lt;code&gt;onErrorResumeNext&lt;/code&gt; will instead begin mirroring a second, backup Observable.</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; 方法は、ミラーが光源の挙動が観察、その観測呼び出す場合を除きこと観測返し &lt;code&gt;onError&lt;/code&gt; その場合、観察者にそのエラーを伝播するのではなく、 &lt;code&gt;onErrorResumeNext&lt;/code&gt; は代わりに、バックアップ観測第二のミラーリングを開始します。</target>
        </trans-unit>
        <trans-unit id="c4940c7c617c2992ba7a9a3fde9d89a1bdc8cbef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onErrorReturn&lt;/code&gt; method returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes &lt;code&gt;onError&lt;/code&gt; in which case, rather than propagating that error to the observer, &lt;code&gt;onErrorReturn&lt;/code&gt; will instead emit a specified item and invoke the observer&amp;rsquo;s &lt;code&gt;onCompleted&lt;/code&gt; method, as shown in the following sample code:</source>
          <target state="translated">&lt;code&gt;onErrorReturn&lt;/code&gt; 方法は、ミラーが光源の挙動が観察、その観測呼び出す場合を除きこと観測返し &lt;code&gt;onError&lt;/code&gt; その場合、観察者にそのエラーを伝播するのではなく、 &lt;code&gt;onErrorReturn&lt;/code&gt; が代わりに指定された項目と観察のinvoke放出する &lt;code&gt;onCompleted&lt;/code&gt; に示すように、方法次のサンプルコード：</target>
        </trans-unit>
        <trans-unit id="c06d877f3382ecaf88c2f18aa56d9eaa6fd9a9b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onErrorReturn&lt;/code&gt; method returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes &lt;code&gt;onError&lt;/code&gt; in which case, rather than propagating that error to the observer, &lt;code&gt;onErrorReturn&lt;/code&gt; will instead emit a specified item and invoke the observer&amp;rsquo;s &lt;code&gt;onCompleted&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;onErrorReturn&lt;/code&gt; 方法は、ミラーが光源の挙動が観察、その観測呼び出す場合を除きこと観測返し &lt;code&gt;onError&lt;/code&gt; その場合、観察者にそのエラーを伝播するのではなく、 &lt;code&gt;onErrorReturn&lt;/code&gt; が代わりに指定されたアイテムを放出し、観察者呼び出す &lt;code&gt;onCompleted&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="2be807f21af7c141df25f9522d621998041537c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;publishLast&lt;/code&gt; operator is similar to &lt;code&gt;publish&lt;/code&gt;, and takes a similarly-behaving function as its parameter. It differs from &lt;code&gt;publish&lt;/code&gt; in that instead of applying that function to, and emitting an item for &lt;em&gt;every&lt;/em&gt; item emitted by the source Observable subsequent to the connection, it only applies that function to and emits an item for the &lt;em&gt;last&lt;/em&gt; item that was emitted by the source Observable, when that source Observable terminates normally.</source>
          <target state="translated">&lt;code&gt;publishLast&lt;/code&gt; のオペレータは、に似て &lt;code&gt;publish&lt;/code&gt; 、及びそのパラメータと同様に、挙動関数を取ります。これは、接続後にObservableにその関数を適用し、ソースObservableによって &lt;code&gt;publish&lt;/code&gt; された&lt;em&gt;すべての&lt;/em&gt;アイテムのアイテムを発行するのではなく、その関数を適用して、ソースによって発行された&lt;em&gt;最後の&lt;/em&gt;アイテムのアイテムのみを発行するという点で、publishとは異なります。 Observable、そのソースObservableが正常に終了した場合。</target>
        </trans-unit>
        <trans-unit id="0ad4a30567f8a80138c1fb085ce842dcf7162d10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;publishValue&lt;/code&gt; operator takes, in addition to the function described above, an initial item to be emitted by the resulting &lt;code&gt;ConnectableObservable&lt;/code&gt; at connection time before emitting the items from the source Observable. It will not, however, emit this initial item to observers that subscribe after the time of connection.</source>
          <target state="translated">&lt;code&gt;publishValue&lt;/code&gt; のオペレータは、上述した機能に加え、最初のアイテムが得られることによって放出される、かかる &lt;code&gt;ConnectableObservable&lt;/code&gt; 観測ソースからアイテムを放出する前に、接続時。ただし、接続後にサブスクライブするオブザーバーにこの初期アイテムを発行しません。</target>
        </trans-unit>
        <trans-unit id="ef3ba3331ca4825acc2f08213d614824f15ad040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reduce&lt;/code&gt; operator returns an Observable that applies a function of your choosing to the first item emitted by a source Observable, then feeds the result of that function along with the second item emitted by the source Observable into the same function, then feeds the result of that function along with the third item into the same function, and so on until all items have been emitted by the source Observable. Then it emits the final result from the final call to your function as the sole output from the returned Observable.</source>
          <target state="translated">&lt;code&gt;reduce&lt;/code&gt; オペレータがソース観測によって放出された最初の項目にお好みの機能を適用し、その観測を返し、次いで同じ関数に観測源によって放出された2番目の項目と一緒にその関数の結果を供給し、結果を供給するその関数は、3番目のアイテムと同じ関数に入れられ、すべてのアイテムがソースのObservableによって発行されるまで続きます。次に、関数への最後の呼び出しの最終結果を、返されたObservableからの唯一の出力として出力します。</target>
        </trans-unit>
        <trans-unit id="c50635278b4d9cf4361974e6d4a3581ebf3b7068" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;retryWhen&lt;/code&gt; operator is similar to &lt;code&gt;retry&lt;/code&gt; but decides whether or not to resubscribe to and mirror the source Observable by passing the Throwable from the &lt;code&gt;onError&lt;/code&gt; notification to a function that generates a second Observable, and observes its result to determine what to do. If that result is an emitted item, &lt;code&gt;retryWhen&lt;/code&gt; resubscribes to and mirrors the source and the process repeats; if that result is an &lt;code&gt;onError&lt;/code&gt; notification, &lt;code&gt;retryWhen&lt;/code&gt; passes this notification on to its observers and terminates.</source>
          <target state="translated">&lt;code&gt;retryWhen&lt;/code&gt; のオペレータは、に似て &lt;code&gt;retry&lt;/code&gt; だけに再サブスクライブからのThrowableを通過によって観察ソースミラーリングするか否かを判断する &lt;code&gt;onError&lt;/code&gt; 観測秒を生成する機能に通知をし、何をすべきかを決定するために、その結果を観察します。その結果が &lt;code&gt;retryWhen&lt;/code&gt; されたアイテムである場合、retryWhenはソースに再サブスクライブしてミラーリングし、プロセスが繰り返されます。その結果が &lt;code&gt;onError&lt;/code&gt; 通知の場合、 &lt;code&gt;retryWhen&lt;/code&gt; はこの通知をオブザーバに渡し、終了します。</target>
        </trans-unit>
        <trans-unit id="1e6bf6540cbdcb6dcb36a0ac93c13041a34e1638" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;deferFuture&lt;/code&gt; operator. You pass it a function that returns a &lt;code&gt;Future&lt;/code&gt; that returns an Observable. &lt;code&gt;deferFuture&lt;/code&gt; returns an Observable, but does not call the function you provide until such time as an observer subscribes to the Observable it returns. When it does so, it immediately calls &lt;code&gt;get&lt;/code&gt; on the resulting &lt;code&gt;Future&lt;/code&gt;, and then mirrors the emissions from the Observable returned by the &lt;code&gt;Future&lt;/code&gt; as its own emissions.</source>
          <target state="translated">&lt;code&gt;rxjava-async&lt;/code&gt; モジュールはまた、 &lt;code&gt;deferFuture&lt;/code&gt; の演算子を。Observableを返す &lt;code&gt;Future&lt;/code&gt; を返す関数に渡します。 &lt;code&gt;deferFuture&lt;/code&gt; はObservableを返しますが、オブザーバーが返すObservableをサブスクライブするまで、指定した関数を呼び出しません。それはそうと、その直後に呼び出しが &lt;code&gt;get&lt;/code&gt; た上で &lt;code&gt;Future&lt;/code&gt; 、その後、観測からミラー排出量はで返さ &lt;code&gt;Future&lt;/code&gt; 、独自の排出量として。</target>
        </trans-unit>
        <trans-unit id="b6770bc4bfc1cbd7c9c042c3a7028aadacca1d7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;forEachFuture&lt;/code&gt; operator. It is not really a variant of the Start operator, but something all its own. You pass &lt;code&gt;forEachFuture&lt;/code&gt; some subset of the typical observer methods (&lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;, and &lt;code&gt;onCompleted&lt;/code&gt;) and the Observable will call these methods in the usual way. But &lt;code&gt;forEachFuture&lt;/code&gt; itself returns a &lt;code&gt;Future&lt;/code&gt; that blocks on &lt;code&gt;get&lt;/code&gt; until the source Observable completes, then returns either the completion or error, depending on how the Observable completed.</source>
          <target state="translated">&lt;code&gt;rxjava-async&lt;/code&gt; モジュールはまた、 &lt;code&gt;forEachFuture&lt;/code&gt; の演算子を。これは実際にはStartオペレーターのバリアントではなく、独自のものです。 &lt;code&gt;forEachFuture&lt;/code&gt; に一般的なオブザーバーメソッド（ &lt;code&gt;onNext&lt;/code&gt; 、 &lt;code&gt;onError&lt;/code&gt; 、および &lt;code&gt;onCompleted&lt;/code&gt; ）のサブセットを渡し、Observableがこれらのメソッドを通常の方法で呼び出します。ただし、 &lt;code&gt;forEachFuture&lt;/code&gt; 自体は、ソースObservableが完了 &lt;code&gt;get&lt;/code&gt; までgetでブロックする &lt;code&gt;Future&lt;/code&gt; を返し、Observableの完了方法に応じて、完了またはエラーを返します。</target>
        </trans-unit>
        <trans-unit id="af59112ac4850a63fc254aa64a91b1cced9a1539" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;fromAction&lt;/code&gt; operator. It accepts an &lt;code&gt;Action&lt;/code&gt; as its parameter, and returns an Observable that emits the item you pass to &lt;code&gt;fromAction&lt;/code&gt; upon termination of the &lt;code&gt;Action&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rxjava-async&lt;/code&gt; モジュールはまた、 &lt;code&gt;fromAction&lt;/code&gt; の演算子を。それは受け入れ &lt;code&gt;Action&lt;/code&gt; あなたに渡すアイテム放出するパラメータとして、および観測を返す &lt;code&gt;fromAction&lt;/code&gt; の終了時に &lt;code&gt;Action&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eeead452a5c5a5cc79393668e2fbe3048778760f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;fromCallable&lt;/code&gt; operator. It accepts a &lt;code&gt;Callable&lt;/code&gt; as its parameter, and returns an Observable that emits the result of this callable as its sole emission.</source>
          <target state="translated">&lt;code&gt;rxjava-async&lt;/code&gt; モジュールはまた、 &lt;code&gt;fromCallable&lt;/code&gt; 演算子。これは &lt;code&gt;Callable&lt;/code&gt; をパラメーターとして受け入れ、このCallableの結果を唯一の放出として放出するObservableを返します。</target>
        </trans-unit>
        <trans-unit id="869f3624eb8dd7143ac5769078e3b3bf39bdeacb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;fromRunnable&lt;/code&gt; operator. It accepts a &lt;code&gt;Runnable&lt;/code&gt; as its parameter, and returns an Observable that emits the item you pass to &lt;code&gt;fromRunnable&lt;/code&gt; upon termination of the &lt;code&gt;Runnable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rxjava-async&lt;/code&gt; モジュールはまた、 &lt;code&gt;fromRunnable&lt;/code&gt; 演算子。それは受け入れる &lt;code&gt;Runnable&lt;/code&gt; ををあなたに渡すアイテム放出するパラメータとして、および観測を返す &lt;code&gt;fromRunnable&lt;/code&gt; 終了時 &lt;code&gt;Runnable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="469f2cf19937130bc28a1acc9ff8718d9ef9be41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;runAsync&lt;/code&gt; operator. It is peculiar in that it creates a specialization of an Observable called a &lt;code&gt;StoppableObservable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rxjava-async&lt;/code&gt; モジュールはまた、 &lt;code&gt;runAsync&lt;/code&gt; の演算子を。これは、 &lt;code&gt;StoppableObservable&lt;/code&gt; と呼ばれるObservableの特殊化を作成するという点で独特です。</target>
        </trans-unit>
        <trans-unit id="1442c42f4ea4865297a5c8db2d9c56e62b53341d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;startFuture&lt;/code&gt; operator. You pass it a function that returns a &lt;code&gt;Future&lt;/code&gt;. &lt;code&gt;startFuture&lt;/code&gt; calls this function immediately to obtain the &lt;code&gt;Future&lt;/code&gt;, and calls the &lt;code&gt;Future&lt;/code&gt;&amp;rsquo;s &lt;code&gt;get&lt;/code&gt; method to try to obtain its value. It returns an Observable to which it will emit this value to any subsequent observers.</source>
          <target state="translated">&lt;code&gt;rxjava-async&lt;/code&gt; モジュールはまた、 &lt;code&gt;startFuture&lt;/code&gt; の演算子を。 &lt;code&gt;Future&lt;/code&gt; を返す関数を渡します。 &lt;code&gt;startFuture&lt;/code&gt; はこの関数をすぐに呼び出して &lt;code&gt;Future&lt;/code&gt; を取得し、 &lt;code&gt;Future&lt;/code&gt; の &lt;code&gt;get&lt;/code&gt; メソッドを呼び出してその値を取得しようとします。これは、後続のオブザーバーにこの値を出力するObservableを返します。</target>
        </trans-unit>
        <trans-unit id="0110d272415178479fa0159e8336538a9e94137d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;toAsync&lt;/code&gt;, &lt;code&gt;asyncAction&lt;/code&gt;, and &lt;code&gt;asyncFunc&lt;/code&gt; operators. These accept a function or an Action as their parameter. In the case of a function, this variant of the operator calls that function to retrieve a value, and then returns an Observable that will emit that value to each subsequent observer (just as the &lt;code&gt;start&lt;/code&gt; operator does).</source>
          <target state="translated">&lt;code&gt;rxjava-async&lt;/code&gt; モジュールはまた、 &lt;code&gt;toAsync&lt;/code&gt; 、 &lt;code&gt;asyncAction&lt;/code&gt; 、及び &lt;code&gt;asyncFunc&lt;/code&gt; の演算子。これらは、関数またはアクションをパラメーターとして受け入れます。関数の場合、演算子のこのバリアントはその関数を呼び出して値を取得し、その後、その値を後続の各オブザーバーに送信するObservableを返します（ &lt;code&gt;start&lt;/code&gt; 演算子と同じです）。</target>
        </trans-unit>
        <trans-unit id="7be42e7b16a28f4014f78f36d0e314f07de76b6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module includes the &lt;code&gt;start&lt;/code&gt; operator, which accepts a function as its parameter, calls that function to retrieve a value, and then returns an Observable that will emit that value to each subsequent observer.</source>
          <target state="translated">&lt;code&gt;rxjava-async&lt;/code&gt; モジュールは、 &lt;code&gt;start&lt;/code&gt; 、そのパラメータとしての機能を受け付ける操作者に、値を取得するためにその関数を呼び出し、その後、後続の各観察者にその値を放出するその観測を返します。</target>
        </trans-unit>
        <trans-unit id="4f8c7e051e0ffc1dd123fcc2382d4e1c11f27579" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;single&lt;/code&gt; operator is similar to &lt;code&gt;first&lt;/code&gt;, but throws a &lt;code&gt;NoSuchElementException&lt;/code&gt; if the source Observable does not emit exactly one item before successfully completing.</source>
          <target state="translated">&lt;code&gt;single&lt;/code&gt; のオペレータは、に似ている &lt;code&gt;first&lt;/code&gt; が、スロー &lt;code&gt;NoSuchElementException&lt;/code&gt; ソース観察可能が正常に完了する前に、正確に一つの項目を排出しない場合。</target>
        </trans-unit>
        <trans-unit id="bb64af0ef2e08065bfe61294a45e041863a9ac27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;single&lt;/code&gt; operator is similar, except that it only emits its item once the source Observable successfully completes after emitting one item (or one item that matches the predicate). If it emits either no such items or more than one such item, &lt;code&gt;single&lt;/code&gt; will terminate with an &lt;code&gt;onError&lt;/code&gt; notitifcation (&amp;ldquo;&lt;code&gt;Sequence contains no elements.&lt;/code&gt;&amp;rdquo;).</source>
          <target state="translated">&lt;code&gt;single&lt;/code&gt; オペレータが観測ソースが正常に一つの項目（または述語に一致する一つの項目）を放出した後に完了すると、それだけ、そのアイテムを放出することを除いて、同様です。該当するアイテムがないか、該当するアイテムが複数ある場合、 &lt;code&gt;single&lt;/code&gt; は &lt;code&gt;onError&lt;/code&gt; 通知で終了します（「 &lt;code&gt;Sequence contains no elements.&lt;/code&gt; 」）。</target>
        </trans-unit>
        <trans-unit id="975834fced6458372b9bc9efc7befcc06fefa34a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skipLastWithTime&lt;/code&gt; operator takes a temporal duration rather than a quantity of items. It drops those items that are emitted during that final duration of the source Observable&amp;rsquo;s lifespan. You set this duration by passing in a number of milliseconds as a parameter to &lt;code&gt;skipLastWithTime&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;skipLastWithTime&lt;/code&gt; のオペレータは、持続時間ではなく、アイテムの数量をとります。ソースのObservableの寿命の最後の期間中に放出されたアイテムをドロップします。この継続時間を設定するには、 &lt;code&gt;skipLastWithTime&lt;/code&gt; のパラメーターとしてミリ秒数を渡します。</target>
        </trans-unit>
        <trans-unit id="42674eed65675fac56a7f9c41a8d7093c454e05d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skipWhile&lt;/code&gt; operator returns an Observable that discards items emitted by the source Observable until such time as a function, applied to an item emitted by that Observable, returns &lt;code&gt;false&lt;/code&gt;, whereupon the new Observable emits that item and the remainder of the items emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;skipWhile&lt;/code&gt; のオペレータは廃棄項目がその観測によって放出されたアイテム、リターンに適用される、関数などの時間まで観測源によって放出されたことが観測返し &lt;code&gt;false&lt;/code&gt; 、すると新しい観測出射するアイテムとソースによって放出されたアイテムの残り観察可能。</target>
        </trans-unit>
        <trans-unit id="61e37780715c55b30e2b068ed45a07ffc42fa7ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;takeFirst&lt;/code&gt; operator behaves similarly to &lt;code&gt;first&lt;/code&gt;, with the exception of how these operators behave wihen the source Observable emits no items that satisfy the predicate. In such a case, &lt;code&gt;first&lt;/code&gt; will throw a &lt;code&gt;NoSuchElementException&lt;/code&gt; while &lt;code&gt;takeFirst&lt;/code&gt; will return an empty Observable (one that calls &lt;code&gt;onCompleted&lt;/code&gt; but never calls &lt;code&gt;onNext&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;takeFirst&lt;/code&gt; のと同様に、オペレータ挙動 &lt;code&gt;first&lt;/code&gt; これらの演算子の動作方法を除いて、wihenソースが観察発する述語を満たさないアイテムを。そのような場合、 &lt;code&gt;first&lt;/code&gt; に &lt;code&gt;NoSuchElementException&lt;/code&gt; をスローし、 &lt;code&gt;takeFirst&lt;/code&gt; は空のObservable（ &lt;code&gt;onCompleted&lt;/code&gt; を呼び出すがonNextを呼び出さない &lt;code&gt;onNext&lt;/code&gt; ）を返します。</target>
        </trans-unit>
        <trans-unit id="f059b182f05a90e4230cc52c9c5f554288c6cca6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;takeLastWithTime&lt;/code&gt; operator takes a temporal duration rather than a quantity of items. It emits only those items that are emitted during that final duration of the source Observable&amp;rsquo;s lifespan. You set this duration by passing in a number of milliseconds as a parameter to &lt;code&gt;takeLastWithTime&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;takeLastWithTime&lt;/code&gt; のオペレータは、持続時間ではなく、アイテムの数量をとります。これは、ソースのObservableの寿命の最後の期間中に放出されるアイテムのみを放出します。ミリ秒数をパラメーターとして &lt;code&gt;takeLastWithTime&lt;/code&gt; に渡すことにより、この期間を設定します。</target>
        </trans-unit>
        <trans-unit id="d94b28280db1122b56b19ce27ccbcf5cc220169d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;takeWhile&lt;/code&gt; operator returns an Observable that mirrors the behavior of the source Observable until such time as a function, applied to an item emitted by that Observable, returns &lt;code&gt;false&lt;/code&gt;, whereupon the new Observable terminates with an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">&lt;code&gt;takeWhile&lt;/code&gt; のオペレータが観測返すミラーその観測、戻りによって放出された項目に適用される関数のような時間まで観測源の挙動 &lt;code&gt;false&lt;/code&gt; と、そこで新しい観測終了 &lt;code&gt;onCompleted&lt;/code&gt; 通知。</target>
        </trans-unit>
        <trans-unit id="ae782d3a96f85e5b21ff4352810ad74a7d494b59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeInterval&lt;/code&gt; operator converts a source Observable into an Observable that emits indications of the amount of time lapsed between consecutive emissions of the source Observable. The first emission from this new Observable indicates the amount of time lapsed between the time when the observer subscribed to the Observable and the time when the source Observable emitted its first item. There is no corresponding emission marking the amount of time lapsed between the last emission of the source Observable and the subsequent call to &lt;code&gt;onCompleted&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;timeInterval&lt;/code&gt; オペレータが時間量の発する指示が観察源の連続的な排出量との間に経過することを観察可能に観測源を変換します。この新しいObservableからの最初の放出は、オブザーバーがObservableにサブスクライブしてから、ソースObservableが最初のアイテムを放出するまでの間に経過した時間を示します。ソースのObservableの最後のエミッションとそれに続く &lt;code&gt;onCompleted&lt;/code&gt; の呼び出しの間の経過時間を示す対応するエミッションはありません。</target>
        </trans-unit>
        <trans-unit id="bfd66b7722a88e540f0f6db427e117d46daa8c75" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timestamp&lt;/code&gt; method attaches a timestamp to each item emitted by the source Observable before emitting that item as part of its own sequence. The timestamp indicates when the item was emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; 方法は、独自のシーケンスの一部として、そのアイテムを発する前に観測源によって放出された各項目にタイムスタンプを付加します。タイムスタンプは、アイテムがソースObservableによっていつ発行されたかを示します。</target>
        </trans-unit>
        <trans-unit id="d062c9b41bc51b27701d92c9cfc8c88e8ea2c104" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timestamp&lt;/code&gt; method converts an Observable that emits items of type</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; 方法は、型の観測その発するアイテムを変換します</target>
        </trans-unit>
        <trans-unit id="4e038e086711c592371f2bd9b8f09e9f604e3815" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toFuture&lt;/code&gt; operator applies to the &lt;code&gt;BlockingObservable&lt;/code&gt; subclass, so in order to use it, you must first convert your source Observable into a &lt;code&gt;BlockingObservable&lt;/code&gt; by means of either the &lt;code&gt;BlockingObservable.from&lt;/code&gt; method or the &lt;code&gt;Observable.toBlocking&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;toFuture&lt;/code&gt; のオペレータは以下の製品に適用さ &lt;code&gt;BlockingObservable&lt;/code&gt; ので、それを使用するためには、あなたが最初に観察可能なソースを変換する必要があり、サブクラス &lt;code&gt;BlockingObservable&lt;/code&gt; のいずれかによって &lt;code&gt;BlockingObservable.from&lt;/code&gt; の方法や &lt;code&gt;Observable.toBlocking&lt;/code&gt; のオペレーター。</target>
        </trans-unit>
        <trans-unit id="73cc88f0171268077175c8d986e14f4bd5fa9b9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toIterable&lt;/code&gt; operator applies to the &lt;code&gt;BlockingObservable&lt;/code&gt; subclass, so in order to use it, you must first convert your source Observable into a &lt;code&gt;BlockingObservable&lt;/code&gt; by means of either the &lt;code&gt;BlockingObservable.from&lt;/code&gt; method or the &lt;code&gt;Observable.toBlocking&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;toIterable&lt;/code&gt; オペレータは以下の製品に適用さ &lt;code&gt;BlockingObservable&lt;/code&gt; ので、それを使用するためには、あなたが最初に観察可能なソースを変換する必要があり、サブクラス &lt;code&gt;BlockingObservable&lt;/code&gt; のいずれかによって &lt;code&gt;BlockingObservable.from&lt;/code&gt; の方法や &lt;code&gt;Observable.toBlocking&lt;/code&gt; のオペレーター。</target>
        </trans-unit>
        <trans-unit id="10c97d4a81b3f34d3ab42da8c6e198078743bb1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toMap&lt;/code&gt; operator collects the items emitted by the source Observable into a &lt;code&gt;Map&lt;/code&gt; and then emits that map. You supply a function that generates the key for each emitted item. You may also optionally supply a function that converts an emitted item into the value to be stored in the map (by default, the item itself is this value).</source>
          <target state="translated">&lt;code&gt;toMap&lt;/code&gt; のオペレータは、に観測源によって放出されたアイテム収集 &lt;code&gt;Map&lt;/code&gt; し、そのマップを発します。放出された各アイテムのキーを生成する関数を提供します。オプションで、放出されたアイテムをマップに格納される値に変換する関数を指定することもできます（デフォルトでは、アイテム自体がこの値です）。</target>
        </trans-unit>
        <trans-unit id="bd3162034b145b60b1dabc6e226bf4a2715689b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toMap&lt;/code&gt; operator collects the items emitted by the source Observable into a map (by default, a &lt;code&gt;HashMap&lt;/code&gt;, but you can optionally supply a factory function that generates another &lt;code&gt;Map&lt;/code&gt; variety) and then emits that map. You supply a function that generates the key for each emitted item. You may also optionally supply a function that converts an emitted item into the value to be stored in the map (by default, the item itself is this value).</source>
          <target state="translated">&lt;code&gt;toMap&lt;/code&gt; のオペレータが（デフォルトでマップにソース観測によって放出されたアイテムを収集 &lt;code&gt;HashMap&lt;/code&gt; を、しかし必要に応じて別の生成工場機能供給することができる &lt;code&gt;Map&lt;/code&gt; さまざまな）し、そのマップを発します。放出された各アイテムのキーを生成する関数を提供します。オプションで、放出されたアイテムをマップに格納される値に変換する関数を指定することもできます（デフォルトでは、アイテム自体がこの値です）。</target>
        </trans-unit>
        <trans-unit id="8c85856ebe3a9af3c38faf028b0cefff356663db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toMultiMap&lt;/code&gt; operator is similar to &lt;code&gt;toMap&lt;/code&gt; except that the map it generates is also an &lt;code&gt;ArrayList&lt;/code&gt; (by default; or you can pass an optional factory method as a fourth parameter by which you generate the variety of collection you prefer).</source>
          <target state="translated">&lt;code&gt;toMultiMap&lt;/code&gt; のオペレータは同様である &lt;code&gt;toMap&lt;/code&gt; が生成するマップでもあることを除き、 &lt;code&gt;ArrayList&lt;/code&gt; の（デフォルトで、またはあなたがあなたが好むコレクションのさまざまを発生することにより、第四パラメータとして任意ファクトリメソッドを渡すことができます）。</target>
        </trans-unit>
        <trans-unit id="b17e7ff34781fb007d4e482cc00354dcd6940aeb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toSortedList&lt;/code&gt; operator behaves much like &lt;code&gt;toList&lt;/code&gt; except that it sorts the resulting list. By default it sorts the list naturally in ascending order by means of the &lt;code&gt;Comparable&lt;/code&gt; interface. If any of the items emitted by the Observable does not support &lt;code&gt;Comparable&lt;/code&gt; with respect to the type of every other item emitted by the Observable, &lt;code&gt;toSortedList&lt;/code&gt; will throw an exception. However, you can change this default behavior by also passing in to &lt;code&gt;toSortedList&lt;/code&gt; a function that takes as its parameters two items and returns a number; &lt;code&gt;toSortedList&lt;/code&gt; will then use that function instead of &lt;code&gt;Comparable&lt;/code&gt; to sort the items.</source>
          <target state="translated">&lt;code&gt;toSortedList&lt;/code&gt; の多くのようなオペレータの振る舞い &lt;code&gt;toList&lt;/code&gt; 、それは結果のリストをソートすることを除いて。デフォルトでは、 &lt;code&gt;Comparable&lt;/code&gt; インターフェースを使用してリストを自然に昇順でソートします。Observableによって &lt;code&gt;toSortedList&lt;/code&gt; された項目のいずれかが、Observableによって発行された他のすべての項目のタイプに関して &lt;code&gt;Comparable&lt;/code&gt; をサポートしない場合、toSortedListは例外をスローします。ただし、 &lt;code&gt;toSortedList&lt;/code&gt; にパラメーターとして2つの項目を取り、数値を返す関数を渡すことで、このデフォルトの動作を変更できます。次に、 &lt;code&gt;toSortedList&lt;/code&gt; は、 &lt;code&gt;Comparable&lt;/code&gt; ではなくその関数を使用して、アイテムをソートします。</target>
        </trans-unit>
        <trans-unit id="3179857647a979a434a7b8365890ceca652b913a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;zipWith&lt;/code&gt; instance version of this operator always takes two parameters. The first parameter may be either a simple Observable, or an iterable (as in the illustration above).</source>
          <target state="translated">この演算子の &lt;code&gt;zipWith&lt;/code&gt; インスタンスバージョンは、常に2つのパラメーターを取ります。最初のパラメーターは、単純なObservableまたは反復可能（上記の図のよう）のいずれかです。</target>
        </trans-unit>
        <trans-unit id="0c52166841e40a260b713af70e53c187dda20628" translate="yes" xml:space="preserve">
          <source>The Average operator operates on an Observable that emits numbers (or items that can be evaluated as numbers), and emits a single value: the average of all of the numbers emitted by the source Observable.</source>
          <target state="translated">Average演算子は、数値(または数値として評価できる項目)を放出するObservableに対して操作し、1つの値を放出します:元のObservableによって放出されたすべての数値の平均です。</target>
        </trans-unit>
        <trans-unit id="fc6a2968bca993acc6e3b8fced16ce05fe639169" translate="yes" xml:space="preserve">
          <source>The Buffer operator transforms an Observable that emits items into an Observable that emits buffered collections of those items. There are a number of variants in the various language-specific implementations of Buffer that differ in how they choose which items go in which buffers.</source>
          <target state="translated">Buffer 演算子は、項目を出力する Observable を、それらの項目をバッファリングしたコレクションを出力する Observable に変換します。言語固有の実装である Buffer にはいくつかのバリエーションがあり、どの項目をどのバッファに入れるかの選択方法が異なります。</target>
        </trans-unit>
        <trans-unit id="b37590bfa8c82144f5bf2ba003877989832559fd" translate="yes" xml:space="preserve">
          <source>The Catch operator intercepts an &lt;code&gt;onError&lt;/code&gt; notification from the source Observable and, instead of passing it through to any observers, replaces it with some other item or sequence of items, potentially allowing the resulting Observable to terminate normally or not to terminate at all.</source>
          <target state="translated">Catchオペレーターは、ソースObservableからの &lt;code&gt;onError&lt;/code&gt; 通知をインターセプトし、それをオブザーバーに渡す代わりに、他のアイテムまたはアイテムのシーケンスに置き換えます。その結果、結果のObservableが正常に終了するか、まったく終了しない可能性があります。</target>
        </trans-unit>
        <trans-unit id="cfe27529276a28575971e7809bb99f71747e9097" translate="yes" xml:space="preserve">
          <source>The CombineLatest operator behaves in a similar way to Zip, but while Zip emits items only when &lt;em&gt;each&lt;/em&gt; of the zipped source Observables have emitted a previously unzipped item, CombineLatest emits an item whenever &lt;em&gt;any&lt;/em&gt; of the source Observables emits an item (so long as each of the source Observables has emitted at least one item). When any of the source Observables emits an item, CombineLatest combines the most recently emitted items from each of the other source Observables, using a function you provide, and emits the return value from that function.</source>
          <target state="translated">CombineLatestオペレーターはZipと同じように動作し&lt;em&gt;ます&lt;/em&gt;が、Zipは、zipされたソースObservableの&lt;em&gt;それぞれ&lt;/em&gt;が以前にunzipされたアイテムを放出したときにのみアイテムを放出しますが、CombineLatestは、&lt;em&gt;いずれか&lt;/em&gt;のソースObservableがアイテムを放出するたびにアイテムを放出します（各ソースのObservablesが少なくとも1つのアイテムを放出した）。ソースObservableのいずれかがアイテムを発行すると、CombineLatestは、提供された関数を使用して、他の各ソースObservableから最後に発行されたアイテムを結合し、その関数から戻り値を発行します。</target>
        </trans-unit>
        <trans-unit id="4854908f534b02106795e7f1522975b573795081" translate="yes" xml:space="preserve">
          <source>The Concat operator concatenates the output of multiple Observables so that they act like a single Observable, with all of the items emitted by the first Observable being emitted before any of the items emitted by the second Observable (and so forth, if there are more than two).</source>
          <target state="translated">Concat演算子は、複数のObservableの出力を連結して、1つのObservableのように振る舞います。</target>
        </trans-unit>
        <trans-unit id="90fa54f98f8f36aa66596ae7ba4f7c4c568cf2d8" translate="yes" xml:space="preserve">
          <source>The Contract Governing Notifications</source>
          <target state="translated">通知を管理する契約</target>
        </trans-unit>
        <trans-unit id="716ae1fda32d1fa3b632bdf5455ead7fa3ced17a" translate="yes" xml:space="preserve">
          <source>The Count operator transforms an Observable that emits items into an Observable that emits a single value that represents the number of items emitted by the source Observable.</source>
          <target state="translated">Count演算子は、アイテムを放出するObservableを、元のObservableによって放出されたアイテムの数を表す1つの値を放出するObservableに変換します。</target>
        </trans-unit>
        <trans-unit id="eefbe49fbb86c9fbec17d91d5ce7f466a4fe2e49" translate="yes" xml:space="preserve">
          <source>The Debounce operator filters out items emitted by the source Observable that are rapidly followed by another emitted item.</source>
          <target state="translated">Debounce演算子は、ソースObservableによって放出されたアイテムの後に別の放出されたアイテムが急速に続くものをフィルタリングします。</target>
        </trans-unit>
        <trans-unit id="36b504754ec03844f1798737da9f41be4f33e797" translate="yes" xml:space="preserve">
          <source>The DefaultIfEmpty operator simply mirrors the source Observable exactly if the source Observable emits any items. If the source Observable terminates normally (with an &lt;code&gt;onComplete&lt;/code&gt;) without emitting any items, the Observable returned from DefaultIfEmpty will instead emit a default item of your choosing before it too completes.</source>
          <target state="translated">DefaultIfEmptyオペレーターは、ソースObservableがアイテムを放出する場合、ソースObservableをミラーリングするだけです。ソースのObservableがアイテムを放出せずに（ &lt;code&gt;onComplete&lt;/code&gt; で）正常に終了した場合、DefaultIfEmptyから返されたObservableは、完了する前に選択したデフォルトのアイテムを放出します。</target>
        </trans-unit>
        <trans-unit id="8094e68c11bae1e54b9179fa5c2f24a885dbe086" translate="yes" xml:space="preserve">
          <source>The Defer operator waits until an observer subscribes to it, and then it generates an Observable, typically with an Observable factory function. It does this afresh for each subscriber, so although each subscriber may think it is subscribing to the same Observable, in fact each subscriber gets its own individual sequence.</source>
          <target state="translated">Defer 演算子はオブザーバがサブスクライブするまで待機し、Observable を生成します。これは各サブスクライバに対して行われるので、各サブスクライバは同じ Observable をサブスクライブしていると思っていても、実際には各サブスクライバは個々のシーケンスを取得しています。</target>
        </trans-unit>
        <trans-unit id="4453fd69500a642f20d1c4768d4bf67d31976c31" translate="yes" xml:space="preserve">
          <source>The Delay operator modifies its source Observable by pausing for a particular increment of time (that you specify) before emitting each of the source Observable&amp;rsquo;s items. This has the effect of shifting the entire sequence of items emitted by the Observable forward in time by that specified increment.</source>
          <target state="translated">Delayオペレーターは、ソースObservableの各アイテムを放出する前に、（指定した）特定の時間増分で一時停止することにより、ソースObservableを変更します。これは、Observableによって発行されたアイテムのシーケンス全体を、指定された増分だけ時間的に前方にシフトする効果があります。</target>
        </trans-unit>
        <trans-unit id="43e2b2596602d7cec271e9c62cbe5303137d7dc9" translate="yes" xml:space="preserve">
          <source>The Dematerialize operator reverses this process. It operates on an Observable that has previously been transformed by Materialize and returns it to its original form.</source>
          <target state="translated">Dematerialize 演算子はこの処理を逆にします。これは、以前にMaterializeによって変換されたObservableを操作し、元の形に戻します。</target>
        </trans-unit>
        <trans-unit id="b62495a350947c5ebd5c22f8327b5c1e7b3d4cd9" translate="yes" xml:space="preserve">
          <source>The Distinct operator filters an Observable by only allowing items through that have not already been emitted.</source>
          <target state="translated">Distinct 演算子は、まだ放出されていないアイテムのみを通過させることで、Observable をフィルタリングします。</target>
        </trans-unit>
        <trans-unit id="02a861b98764748360b643c6b91378962eece519" translate="yes" xml:space="preserve">
          <source>The Empty, Never, and Throw operators generate Observables with very specific and limited behavior. These are useful for testing purposes, and sometimes also for combining with other Observables or as parameters to operators that expect other Observables as parameters.</source>
          <target state="translated">Empty、Never、Throw演算子は、非常に特殊で限定的な動作をするObservablesを生成します。これらはテスト目的に便利ですが、時には他のObservablesと組み合わせたり、パラメータとして他のObservablesを期待する演算子のパラメータとして使用することもあります。</target>
        </trans-unit>
        <trans-unit id="b833020b17b2958e2855725d6a76e2d9fa4b4dca" translate="yes" xml:space="preserve">
          <source>The Filter operator filters an Observable by only allowing items through that pass a test that you specify in the form of a predicate function.</source>
          <target state="translated">Filter 演算子は、述語関数の形で指定したテストに合格した項目のみを通し、Observable をフィルタリングします。</target>
        </trans-unit>
        <trans-unit id="69c03b864d44f0df8a889b8aea1579db6062a264" translate="yes" xml:space="preserve">
          <source>The Filtering Operators</source>
          <target state="translated">フィルタリングオペレータ</target>
        </trans-unit>
        <trans-unit id="35e86997505ba385effc0556a5f7cfa65bd4638e" translate="yes" xml:space="preserve">
          <source>The FlatMap operator transforms an Observable by applying a function that you specify to each item emitted by the source Observable, where that function returns an Observable that itself emits items. FlatMap then merges the emissions of these resulting Observables, emitting these merged results as its own sequence.</source>
          <target state="translated">FlatMap 演算子は、指定した関数を元の Observable で生成された各アイテムに適用して、Observable を変換します。FlatMap は、結果として生成された Observable をマージし、マージされた結果をそれ自身のシーケンスとして出力します。</target>
        </trans-unit>
        <trans-unit id="fd1bbbdbc4127c19ee97953d85194e7977a5f6a3" translate="yes" xml:space="preserve">
          <source>The GroupBy operator divides an Observable that emits items into an Observable that emits Observables, each one of which emits some subset of the items from the original source Observable. Which items end up on which Observable is typically decided by a discriminating function that evaluates each item and assigns it a key. All items with the same key are emitted by the same Observable.</source>
          <target state="translated">GroupBy演算子は、アイテムを放出するObservableを放出するObservableに分割し、それぞれが元のObservableからアイテムの一部を放出します。どのアイテムがどのObservableで終わるかは、各アイテムを評価してキーを割り当てる識別関数によって決定されます。同じキーを持つすべてのアイテムは、同じObservableによって放出されます。</target>
        </trans-unit>
        <trans-unit id="4906ba388d3e33ac64376a578c10705e279fef4b" translate="yes" xml:space="preserve">
          <source>The IgnoreElements operator suppresses all of the items emitted by the source Observable, but allows its termination notification (either &lt;code&gt;onError&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt;) to pass through unchanged.</source>
          <target state="translated">IgnoreElementsオペレーターは、ソースObservableによって発行されたすべてのアイテムを抑制しますが、終了通知（ &lt;code&gt;onError&lt;/code&gt; または &lt;code&gt;onCompleted&lt;/code&gt; ）を変更せずに通過させます。</target>
        </trans-unit>
        <trans-unit id="244dd77637d5c3358021f0f2debf08aa419dec57" translate="yes" xml:space="preserve">
          <source>The Interval operator returns an Observable that emits an infinite sequence of ascending integers, with a constant interval of time of your choosing between emissions.</source>
          <target state="translated">Interval 演算子は、上昇する整数の無限のシーケンスを放出するObservableを返します。</target>
        </trans-unit>
        <trans-unit id="83607c5f15eb7b829a081b94cbd6b0b250bb3353" translate="yes" xml:space="preserve">
          <source>The Just operator converts an item into an Observable that emits that item.</source>
          <target state="translated">Just演算子は、項目をその項目を放出するObservableに変換します。</target>
        </trans-unit>
        <trans-unit id="5bd2b8fa13d538c5571233b8167d384ea2844854" translate="yes" xml:space="preserve">
          <source>The Map operator applies a function of your choosing to each item emitted by the source Observable, and returns an Observable that emits the results of these function applications.</source>
          <target state="translated">Map演算子は、選択した関数をソースObservableによって放出された各項目に適用し、これらの関数の適用結果を放出するObservableを返します。</target>
        </trans-unit>
        <trans-unit id="2e2bf97ad1f3f2ffc00e16ec5b3d4fbcf84a3701" translate="yes" xml:space="preserve">
          <source>The Max operator operates on an Observable that emits numbers (or items that can be evaluated as numbers), and emits a single item: the item with the largest number.</source>
          <target state="translated">Max演算子は、数値(または数値として評価できる項目)を出力するObservableに対して操作し、1つの項目:最大の数値を持つ項目を出力します。</target>
        </trans-unit>
        <trans-unit id="09deece6c140d29e662b3b8432858ad0d37f4465" translate="yes" xml:space="preserve">
          <source>The Min operator operates on an Observable that emits numbers (or items that can be evaluated as numbers), and emits a single item: the item with the smallest number.</source>
          <target state="translated">Min演算子は、数値(または数値として評価できる項目)を放出するObservableに対して操作し、1つの項目:最小の数値を持つ項目を放出します。</target>
        </trans-unit>
        <trans-unit id="247ee8fc9c213eb2ead2d9c86fe90bf5295d1c49" translate="yes" xml:space="preserve">
          <source>The Observable Contract</source>
          <target state="translated">観察可能な契約</target>
        </trans-unit>
        <trans-unit id="afbdd322f220a1cf0b12ad4fca765fe243613c51" translate="yes" xml:space="preserve">
          <source>The Observable type adds two missing semantics to &lt;a href=&quot;http://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;the Gang of Four&amp;rsquo;s Observer pattern&lt;/a&gt;, to match those that are available in the Iterable type:</source>
          <target state="translated">Observable型は&lt;a href=&quot;http://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;、4つのギャングのオブザーバーパターン&lt;/a&gt;に2つの欠落したセマンティクスを追加し、Iterable型で使用可能なものと一致させます。</target>
        </trans-unit>
        <trans-unit id="f03703c1687e9f63689cb91bc87825dd48181098" translate="yes" xml:space="preserve">
          <source>The Operators of ReactiveX</source>
          <target state="translated">ReactiveXの運営者</target>
        </trans-unit>
        <trans-unit id="bcdd731b4af0f836d80c51d8a9da6714524f68a6" translate="yes" xml:space="preserve">
          <source>The Range operator emits a range of sequential integers, in order, where you select the start of the range and its length.</source>
          <target state="translated">Range演算子は、範囲の開始点と長さを選択した順に、連続した整数の範囲を出力します。</target>
        </trans-unit>
        <trans-unit id="1292751da07b37b3a1750a8a6de0cbc7053adb8e" translate="yes" xml:space="preserve">
          <source>The ReactiveX Observable model allows you to treat streams of asynchronous events with the same sort of simple, composable operations that you use for collections of data items like arrays. It frees you from tangled webs of callbacks, and thereby makes your code more readable and less prone to bugs.</source>
          <target state="translated">ReactiveX Observable モデルでは、非同期イベントのストリームを、配列のようなデータアイテムのコレクションに使うのと同じように、シンプルで構成可能な操作で扱うことができます。これにより、コールバックの絡み合ったウェブから解放され、コードがより読みやすく、バグが発生しにくくなります。</target>
        </trans-unit>
        <trans-unit id="cc1f638a75607049534396bafa35741b496cbeea" translate="yes" xml:space="preserve">
          <source>The Reduce operator applies a function to the first item emitted by the source Observable and then feeds the result of the function back into the function along with the second item emitted by the source Observable, continuing this process until the source Observable emits its final item and completes, whereupon the Observable returned from Reduce emits the final value returned from the function.</source>
          <target state="translated">Reduce 演算子は、関数を元の Observable によって放出された最初の項目に適用し、関数の結果を元の Observable によって放出された 2 番目の項目と一緒に関数にフィードバックし、元の Observable が最後の項目を放出して終了するまでこのプロセスを続けます。</target>
        </trans-unit>
        <trans-unit id="7f8c08d1ff0948c74616bcf19db4f6f8a4e9fe87" translate="yes" xml:space="preserve">
          <source>The RefCount operator automates the process of connecting to and disconnecting from a connectable Observable. It operates on a connectable Observable and returns an ordinary Observable. When the first observer subscribes to this Observable, RefCount connects to the underlying connectable Observable. RefCount then keeps track of how many other observers subscribe to it and does not disconnect from the underlying connectable Observable until the last observer has done so.</source>
          <target state="translated">RefCount演算子は、接続可能なObservableへの接続と切断のプロセスを自動化します。これは、接続可能なObservable上で動作し、通常のObservableを返します。最初のオブザーバがこのObservableをサブスクライブすると、RefCountはその下の接続可能なObservableに接続します。その後、RefCountは他のオブザーバが何人加入したかを追跡し、最後のオブザーバが加入するまで接続可能なObservableとの接続を切断しません。</target>
        </trans-unit>
        <trans-unit id="1cea294e1ffba2cbf07229f7aff488094f37bf6f" translate="yes" xml:space="preserve">
          <source>The Repeat operator emits an item repeatedly. Some implementations of this operator allow you to repeat a &lt;em&gt;sequence&lt;/em&gt; of items, and some permit you to limit the number of repetitions.</source>
          <target state="translated">Repeatオペレーターは、アイテムを繰り返し発行します。この演算子の一部の実装では、アイテムの&lt;em&gt;シーケンス&lt;/em&gt;を繰り返すことができます。一部の実装では、繰り返しの数を制限できます。</target>
        </trans-unit>
        <trans-unit id="badd34737b53e718812dd79b36e046f4b576f530" translate="yes" xml:space="preserve">
          <source>The Retry operator responds to an &lt;code&gt;onError&lt;/code&gt; notification from the source Observable by not passing that call through to its observers, but instead by resubscribing to the source Observable and giving it another opportunity to complete its sequence without error. Retry always passes &lt;code&gt;onNext&lt;/code&gt; notifications through to its observers, even from sequences that terminate with an error, so this can cause duplicate emissions (as shown in the diagram above).</source>
          <target state="translated">Retryオペレーターは、ソースObservableからの &lt;code&gt;onError&lt;/code&gt; 通知に応答して、その呼び出しをオブザーバーに渡さずに、代わりにソースObservableに再サブスクライブし、エラーなしでシーケンスを完了するための別の機会を与えます。エラーで終了するシーケンスからであっても、再試行では常に &lt;code&gt;onNext&lt;/code&gt; 通知がオブザーバーに渡されるため、これにより重複したエミッションが発生する可能性があります（上の図に示すように）。</target>
        </trans-unit>
        <trans-unit id="f9e7265419f42c07e2f8a5a6eb856db0dde19aff" translate="yes" xml:space="preserve">
          <source>The Sample operator periodically looks at an Observable and emits whichever item it has most recently emitted since the previous sampling.</source>
          <target state="translated">Sample演算子は定期的にObservableを見て、前回のサンプリング以降に最も最近放出されたものを放出します。</target>
        </trans-unit>
        <trans-unit id="399e6bf961037a1119d6673c281659e506bab0ce" translate="yes" xml:space="preserve">
          <source>The Scan operator applies a function to the first item emitted by the source Observable and then emits the result of that function as its own first emission. It also feeds the result of the function back into the function along with the second item emitted by the source Observable in order to generate its second emission. It continues to feed back its own subsequent emissions along with the subsequent emissions from the source Observable in order to create the rest of its sequence.</source>
          <target state="translated">Scan演算子は、元のObservableによって放出された最初の項目に関数を適用し、その関数の結果をそれ自身の最初の放出として放出します。また、関数の結果を、Observableによって放出された2番目のアイテムと共に関数にフィードバックし、2番目の放出を生成します。それは、そのシーケンスの残りの部分を生成するために、ソースObservableからの後続の放出と共に、それ自身の後続の放出をフィードバックし続けます。</target>
        </trans-unit>
        <trans-unit id="8619aba5918a01d54d25dd0af57ab74dbd5313ec" translate="yes" xml:space="preserve">
          <source>The SkipUntil subscribes to the source Observable, but ignores its emissions until such time as a second Observable emits an item, at which point SkipUntil begins to mirror the source Observable.</source>
          <target state="translated">SkipUntilはソースObservableを購読しますが、2番目のObservableがアイテムを放出するまではその放出を無視します。</target>
        </trans-unit>
        <trans-unit id="6bb80afbe18d713aa7db356067ed9ca165eb2ac8" translate="yes" xml:space="preserve">
          <source>The SkipWhile subscribes to the source Observable, but ignores its emissions until such time as some condition you specify becomes false, at which point SkipWhile begins to mirror the source Observable.</source>
          <target state="translated">SkipWhileはソースObservableをサブスクライブしますが、指定した条件がfalseになるまではその排出を無視し、その時点でソースObservableのミラーリングを開始します。</target>
        </trans-unit>
        <trans-unit id="321f848f6f6b99a515297203275ce7935c3c1b6c" translate="yes" xml:space="preserve">
          <source>The Subscribe operator is the glue that connects an observer to an Observable. In order for an observer to see the items being emitted by an Observable, or to receive error or completed notifications from the Observable, it must first subscribe to that Observable with this operator.</source>
          <target state="translated">Subscribe 演算子は、オブザーバと Observable をつなぐ接着剤です。オブザーバがObservableによって放出されたアイテムを見たり、Observableからエラーや完了した通知を受け取るためには、まずこの演算子を使ってObservableを購読しなければなりません。</target>
        </trans-unit>
        <trans-unit id="68817eb3363e4643e27a12a3a79cfd77fbc75f84" translate="yes" xml:space="preserve">
          <source>The Sum operator operates on an Observable that emits numbers (or items that can be evaluated as numbers), and emits a single value: the sum of all of the numbers emitted by the source Observable.</source>
          <target state="translated">Sum演算子は、数値(または数値として評価できる項目)を放出するObservableに対して操作し、1つの値を放出します:元のObservableによって放出されたすべての数値の合計。</target>
        </trans-unit>
        <trans-unit id="5499fa88e4c4fbb3fd161535ad060b25542b021f" translate="yes" xml:space="preserve">
          <source>The TakeUntil subscribes and begins mirroring the source Observable. It also monitors a second Observable that you provide. If this second Observable emits an item or sends a termination notification, the Observable returned by TakeUntil stops mirroring the source Observable and terminates.</source>
          <target state="translated">TakeUntil がサブスクライブし、ソース Observable のミラーリングを開始します。また、あなたが提供する 2 番目の Observable も監視します。この 2 番目の Observable がアイテムを出したり、終了通知を送信したりすると、TakeUntil によって返された Observable はソース Observable のミラーリングを停止して終了します。</target>
        </trans-unit>
        <trans-unit id="d6300871c96270a7b7ca7ce40e8b54e51ae2bbe3" translate="yes" xml:space="preserve">
          <source>The TakeWhile mirrors the source Observable until such time as some condition you specify becomes false, at which point TakeWhile stops mirroring the source Observable and terminates its own Observable.</source>
          <target state="translated">TakeWhileは、指定した条件がfalseになるまでObservableをミラーします。</target>
        </trans-unit>
        <trans-unit id="9b9d7306675e43c2b6a657987c0d20922a8ac2b2" translate="yes" xml:space="preserve">
          <source>The TimeInterval operator intercepts the items from the source Observable and emits in their place objects that indicate the amount of time that elapsed between pairs of emissions.</source>
          <target state="translated">TimeInterval演算子は、ソースのObservableから項目をインターセプトし、その場所にあるオブジェクトを放出します。</target>
        </trans-unit>
        <trans-unit id="606d848af5e8d890114a4201e94f633faae68708" translate="yes" xml:space="preserve">
          <source>The Timeout operator allows you to abort an Observable with an &lt;code&gt;onError&lt;/code&gt; termination if that Observable fails to emit any items during a specified span of time.</source>
          <target state="translated">タイムアウトオペレーターを使用すると、指定された期間内にオブザーバブルがアイテムを発行できなかった場合に、 &lt;code&gt;onError&lt;/code&gt; 終了でオブザーバブルを中止できます。</target>
        </trans-unit>
        <trans-unit id="c92d7746cdf82983c7af4d7a45f125b462cfb156" translate="yes" xml:space="preserve">
          <source>The Timer operator creates an Observable that emits one particular item after a span of time that you specify.</source>
          <target state="translated">Timer演算子は、指定した時間の後に特定のアイテムを放出するObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="d6f22a25ac9ea4e36d2fb3e2fc77ff657b78a01f" translate="yes" xml:space="preserve">
          <source>The Timestamp operator attaches a timestamp to each item emitted by the source Observable before reemitting that item in its own sequence. The timestamp indicates at what time the item was emitted.</source>
          <target state="translated">Timestamp 演算子は、元の Observable によって放出された各アイテムにタイムスタンプを付加します。タイムスタンプは、そのアイテムが何時に放出されたかを示します。</target>
        </trans-unit>
        <trans-unit id="f72aef25813cb6cd23e767b6322029a7b84433dd" translate="yes" xml:space="preserve">
          <source>The Using operator is a way you can instruct an Observable to create a resource that exists only during the lifespan of the Observable and is disposed of when the Observable terminates.</source>
          <target state="translated">Using演算子は、Observableの寿命の間だけ存在し、Observableが終了したときに廃棄されるリソースをObservableに作成するように指示する方法です。</target>
        </trans-unit>
        <trans-unit id="28cafaed855fc19783c71ce1747806f4b0aa50d5" translate="yes" xml:space="preserve">
          <source>The above operators are available in the following packages:</source>
          <target state="translated">上記の演算子は、以下のパッケージで利用できます。</target>
        </trans-unit>
        <trans-unit id="c7faf4cedb9be89a2fe4a7e2e6bb1c77cd930efc" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;subscribe&lt;/code&gt; returns an object that implements the &lt;code&gt;Subscription&lt;/code&gt; interface. This interface includes the &lt;code&gt;unsubscribe&lt;/code&gt; method that you can call at any time to sever the subscription that &lt;code&gt;subscribe&lt;/code&gt; established between the Observable and the observer (or the methods that stand in for the observer).</source>
          <target state="translated">&lt;code&gt;subscribe&lt;/code&gt; を呼び出すと、 &lt;code&gt;Subscription&lt;/code&gt; インターフェースを実装するオブジェクトが返されます。このインターフェイスには、Observableとオブザーバーの間で確立された &lt;code&gt;subscribe&lt;/code&gt; するサブスクリプション（またはオブザーバーの代わりとなるメソッド）を切断するためにいつでも呼び出すことができる &lt;code&gt;unsubscribe&lt;/code&gt; メソッドが含まれています。</target>
        </trans-unit>
        <trans-unit id="89f14f94d842a0f3914f20a36dfd9eb22a7c4ee7" translate="yes" xml:space="preserve">
          <source>The combination of the And, Then, and When operators behave much like the Zip operator, but they do so by means of intermediate data structures. And accepts two or more Observables and combines the emissions from each, one set at a time, into &lt;code&gt;Pattern&lt;/code&gt; objects. Then operates on such &lt;code&gt;Pattern&lt;/code&gt; objects, transforming them in a &lt;code&gt;Plan&lt;/code&gt;. When in turn transforms these various &lt;code&gt;Plan&lt;/code&gt; objects into emissions from an Observable.</source>
          <target state="translated">And、Then、Whenの各演算子の組み合わせは、Zip演算子とほとんど同じように動作しますが、中間データ構造を使用して動作します。また、2つ以上のObservableを受け入れ、それぞれからの放出を1つずつセットして、 &lt;code&gt;Pattern&lt;/code&gt; オブジェクトに結合します。次に、そのような &lt;code&gt;Pattern&lt;/code&gt; オブジェクトを操作して、それらを &lt;code&gt;Plan&lt;/code&gt; に変換します。次に、これらのさまざまな &lt;code&gt;Plan&lt;/code&gt; オブジェクトをObservableからの放出に変換します。</target>
        </trans-unit>
        <trans-unit id="db1846a8b74a433edfdaca33027d099c7038cffa" translate="yes" xml:space="preserve">
          <source>The difference between this and &lt;code&gt;Observable.from&lt;/code&gt; is that the latter's parameter is an array or a sequence, and emits each of its element as one emission.</source>
          <target state="translated">thisと &lt;code&gt;Observable.from&lt;/code&gt; の違いは、後者のパラメーターが配列またはシーケンスであり、その各要素を1つの放出として放出することです。</target>
        </trans-unit>
        <trans-unit id="3dd77ae05f13d67f165ceb07a061686373523030" translate="yes" xml:space="preserve">
          <source>The first variant &amp;mdash; called either &lt;code&gt;debounce&lt;/code&gt; or &lt;code&gt;throttleWithTimeout&lt;/code&gt; &amp;mdash; accepts as its parameter a duration, defined as an integer number of milliseconds, and it suppresses any emitted items that are followed by other emitted items during that duration since the first item&amp;rsquo;s emission.</source>
          <target state="translated">最初のバリアント（ &lt;code&gt;debounce&lt;/code&gt; または &lt;code&gt;throttleWithTimeout&lt;/code&gt; のいずれかと呼ばれます）は、ミリ秒単位の整数として定義された期間をパラメーターとして受け入れ、最初のアイテムの放出以降、その期間中に他の放出されたアイテムが続く放出されたアイテムを抑制します。</target>
        </trans-unit>
        <trans-unit id="0c61ffb36d85b092e0b11ad4b92c123ffd6cbe1d" translate="yes" xml:space="preserve">
          <source>The first variant accepts as its parameter a periodicity, defined as an integer number of milliseconds, and it samples the source Observable periodically at that frequency.</source>
          <target state="translated">最初のバリアントは、整数のミリ秒数で定義された周期性をパラメータとして受け取り、その周波数で周期的にソースObservableをサンプリングします。</target>
        </trans-unit>
        <trans-unit id="4d4daf5fefc143f2fe82e85dd951f60c3b004540" translate="yes" xml:space="preserve">
          <source>The first variant accepts parameters that define a duration of time (a quantity of time, and a &lt;code&gt;TimeUnit&lt;/code&gt; that this quantity is denominated in). Each time the source Observable emits an item, &lt;code&gt;timeout&lt;/code&gt; starts a timer, and if that timer exceeds the duration before the source Observable emits another item, &lt;code&gt;timeout&lt;/code&gt; terminates its Observable with an error (&lt;code&gt;TimeoutException&lt;/code&gt;).</source>
          <target state="translated">最初のバリアントは、期間（時間の量、およびこの量を表す &lt;code&gt;TimeUnit&lt;/code&gt; )を定義するパラメーターを受け入れます。ソースのObservableがアイテムを発行するたびに、 &lt;code&gt;timeout&lt;/code&gt; によりタイマーが開始され、そのタイマーがソースのObservableが別のアイテムを &lt;code&gt;TimeoutException&lt;/code&gt; する前の継続時間を超えると、 &lt;code&gt;timeout&lt;/code&gt; によってObservableがエラー（TimeoutException）で終了します。</target>
        </trans-unit>
        <trans-unit id="8cc80ffffa2d22148369eee22ce57927273f33be" translate="yes" xml:space="preserve">
          <source>The first variant of &lt;code&gt;delay&lt;/code&gt; accepts parameters that define a duration of time (a quantity of time, and a &lt;code&gt;TimeUnit&lt;/code&gt; that this quantity is denominated in). Each time the source Observable emits an item, &lt;code&gt;delay&lt;/code&gt; starts a timer, and when that timer reaches the given duration, the Observable returned from &lt;code&gt;delay&lt;/code&gt; emits the same item.</source>
          <target state="translated">&lt;code&gt;delay&lt;/code&gt; の最初のバリアントは、期間（時間の量、およびこの量が &lt;code&gt;TimeUnit&lt;/code&gt; れるTimeUnit）を定義するパラメーターを受け入れます。ソースObservableがアイテムを放出するたびに、 &lt;code&gt;delay&lt;/code&gt; はタイマーを開始し、そのタイマーが指定された期間に達すると、 &lt;code&gt;delay&lt;/code&gt; から返されたObservable が同じアイテムを放出します。</target>
        </trans-unit>
        <trans-unit id="46f0163399b285d3092a9a3d89985a4428677721" translate="yes" xml:space="preserve">
          <source>The first variant of &lt;code&gt;merge&lt;/code&gt; is an instance operator that takes a variable number of Observables as parameters, merging each of these Observables with the source (instance) Observables to produce its single output Observable.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; の最初のバリアントは、可変数のObservableをパラメーターとして取り、これらの各Observableをソース（インスタンス）Observableとマージして、単一の出力Observableを生成するインスタンスオペレーターです。</target>
        </trans-unit>
        <trans-unit id="aa4845689320f7786a7ce0dd8a6cc3a35c2ebdd4" translate="yes" xml:space="preserve">
          <source>The first version of &lt;code&gt;timer&lt;/code&gt; returns an Observable that emits a single item after a delay period you specify. You can specify the delay either as a &lt;code&gt;Date&lt;/code&gt; object (which means, delay until that absolute moment) or as an integer (which means, delay that many milliseconds).</source>
          <target state="translated">&lt;code&gt;timer&lt;/code&gt; の最初のバージョンは、指定した遅延期間後に単一のアイテムを放出するObservableを返します。遅延は、 &lt;code&gt;Date&lt;/code&gt; オブジェクト（絶対時刻までの遅延）または整数（ミリ秒単位の遅延）として指定できます。</target>
        </trans-unit>
        <trans-unit id="654d2ddaea67b293e03667eacbdc39c059d37abf" translate="yes" xml:space="preserve">
          <source>The following code constructs an Observable that emits the numbers between one and a million, and then samples that Observable every ten milliseconds to see what number it is emitting at that moment.</source>
          <target state="translated">次のコードは、1から100万までの数字を出すObservableを構築し、そのObservableを10ミリ秒ごとにサンプリングして、その瞬間に何の数字を出しているのかを確認します。</target>
        </trans-unit>
        <trans-unit id="2de73bda505de7252f71c673c86fe20f971b7d67" translate="yes" xml:space="preserve">
          <source>The following example shows how you can chain a custom operator (in this example: &lt;code&gt;myOperator&lt;/code&gt;) along with standard RxJava operators by using the &lt;code&gt;lift( )&lt;/code&gt; operator:</source>
          <target state="translated">次の例は、 &lt;code&gt;lift( )&lt;/code&gt; 演算子を使用して、標準のRxJava演算子と一緒にカスタム演算子（この例では &lt;code&gt;myOperator&lt;/code&gt; ）をチェーンする方法を示しています。</target>
        </trans-unit>
        <trans-unit id="8d81c2a7bcb04a9212a58697cff7090bccdb6252" translate="yes" xml:space="preserve">
          <source>The following sample code uses &lt;code&gt;groupBy&lt;/code&gt; to transform a list of numbers into two lists, grouped by whether or not the numbers are even:</source>
          <target state="translated">次のサンプルコードは、 &lt;code&gt;groupBy&lt;/code&gt; を使用して、数値のリストを2つのリストに変換し、数値が偶数かどうかによってグループ化します。</target>
        </trans-unit>
        <trans-unit id="ea6ac1a648626d38582a5054601f86ada31f1cdf" translate="yes" xml:space="preserve">
          <source>The following section will show how to form the scaffolding of your operator so that it will work correctly with &lt;code&gt;lift( )&lt;/code&gt;.</source>
          <target state="translated">次のセクションでは、 &lt;code&gt;lift( )&lt;/code&gt; 正しく機能するように、オペレーターの足場を形成する方法を示します。</target>
        </trans-unit>
        <trans-unit id="253b6d42be3a506a59fbdcf2b0d6ab30d54c2bb5" translate="yes" xml:space="preserve">
          <source>The following sections of this page will give marble diagrams that explain these operators schematically. This diagram explains how Singles are represented in marble diagrams:</source>
          <target state="translated">このページの次のセクションでは、これらの演算子を模式的に説明するマーブル図を示します。この図では、マーブル図でシングルスがどのように表現されるかを説明します。</target>
        </trans-unit>
        <trans-unit id="a84f1d1885dd7b824328237a193222ffa087c297" translate="yes" xml:space="preserve">
          <source>The functions described in this section are all found in each of the following distributions:</source>
          <target state="translated">この節で説明した関数は、すべて以下の分布のそれぞれに見られるものです。</target>
        </trans-unit>
        <trans-unit id="aaf5e9f52491f23699e57321ab3d9e121b260a8e" translate="yes" xml:space="preserve">
          <source>The instance version of &lt;code&gt;merge&lt;/code&gt; is &lt;code&gt;mergeWith&lt;/code&gt;, so, for example, in the code sample above, instead of writing &lt;code&gt;Observable.merge(odds,evens)&lt;/code&gt; you could also write &lt;code&gt;odds.mergeWith(evens)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; のインスタンスバージョンは &lt;code&gt;mergeWith&lt;/code&gt; であるため、たとえば上記のコードサンプルでは、 &lt;code&gt;Observable.merge(odds,evens)&lt;/code&gt; &lt;code&gt;odds.mergeWith(evens)&lt;/code&gt; ）を記述する代わりに、odds.mergeWith（evens ）を記述することもできます。</target>
        </trans-unit>
        <trans-unit id="25e8c42029acb7473a36750cf098482de5a83900" translate="yes" xml:space="preserve">
          <source>The instance version of &lt;code&gt;merge&lt;/code&gt; is &lt;code&gt;mergeWith&lt;/code&gt;, so, for example, instead of writing &lt;code&gt;Observable.merge(odds,evens)&lt;/code&gt; you could also write &lt;code&gt;odds.mergeWith(evens)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; のインスタンスバージョンは &lt;code&gt;mergeWith&lt;/code&gt; であるため、たとえば、 &lt;code&gt;Observable.merge(odds,evens)&lt;/code&gt; &lt;code&gt;odds.mergeWith(evens)&lt;/code&gt; ）を記述する代わりに、odds.mergeWith（evens ）を記述することもできます。</target>
        </trans-unit>
        <trans-unit id="7c8953a5933d5a16119ad112dc5a75d223543853" translate="yes" xml:space="preserve">
          <source>The last argument to &lt;code&gt;zip&lt;/code&gt; is a function that accepts an item from each of the Observables being zipped and emits an item to be emitted in response by the Observable returned from &lt;code&gt;zip&lt;/code&gt;. You can provide the Observables to be zipped together to &lt;code&gt;zip&lt;/code&gt; either as between two and nine individual parameters, or as a single parameter: either an Iterable of Observables or an Observable that emits Observables (as in the illustration above).</source>
          <target state="translated">最後の引数 &lt;code&gt;zip&lt;/code&gt; 観測の各々は、zip形式であることからアイテムを受け入れ、から返された観測によって応答して放出される項目発する機能である &lt;code&gt;zip&lt;/code&gt; ファイルを。あなたに観測が圧縮さ一緒になるように提供することができる &lt;code&gt;zip&lt;/code&gt; 観測の反復処理可能または（上図のように）観測を発する観測のいずれか2つのおよび9つの個別のパラメータ、または単一のパラメータとの間のいずれかと。</target>
        </trans-unit>
        <trans-unit id="5fb92e256f51bccbbcb15f80dac8fed9a700c156" translate="yes" xml:space="preserve">
          <source>The parameter, whether a tuple (i.e. &lt;code&gt;(1, 2, 3)&lt;/code&gt;) or an array (i.e. &lt;code&gt;[1,2,3]&lt;/code&gt;) is produced as one emission.</source>
          <target state="translated">タプル（つまり &lt;code&gt;(1, 2, 3)&lt;/code&gt; &lt;code&gt;[1,2,3]&lt;/code&gt; ））でも配列（つまり[1,2,3]）でも、パラメーターは1つの放出として生成されます。</target>
        </trans-unit>
        <trans-unit id="e6863eccf319c5c010a867abbdb3ab75de53a4cc" translate="yes" xml:space="preserve">
          <source>The predicate function itself takes three arguments:</source>
          <target state="translated">述語関数自体は3つの引数を取ります。</target>
        </trans-unit>
        <trans-unit id="55144d4df6ac43ab12e89905c1250932b67b903c" translate="yes" xml:space="preserve">
          <source>The predicate function takes three parameters:</source>
          <target state="translated">述語関数は3つのパラメータを取ります。</target>
        </trans-unit>
        <trans-unit id="f2e56bda3ccada06fa656085e73c8b6e0dee801d" translate="yes" xml:space="preserve">
          <source>The real power comes with the &amp;ldquo;reactive extensions&amp;rdquo; (hence &amp;ldquo;ReactiveX&amp;rdquo;) &amp;mdash; operators that allow you to transform, combine, manipulate, and work with the sequences of items emitted by Observables.</source>
          <target state="translated">本当の力は、「Reactive Extensions」（したがって「ReactiveX」）に付属しています。これにより、Observablesによって放出されたアイテムのシーケンスを変換、結合、操作、および操作することができます。</target>
        </trans-unit>
        <trans-unit id="44eca70b029fe849bd6ef526e9e90e367585dfc9" translate="yes" xml:space="preserve">
          <source>The results of this unsubscription will cascade back through the chain of operators that applies to the Observable that the observer subscribed to, and this will cause each link in the chain to stop emitting items. This is not guaranteed to happen immediately, however, and it is possible for an Observable to generate and attempt to emit items for a while even after no observers remain to observe these emissions.</source>
          <target state="translated">このサブスクリプションの解除の結果は、オブザーバがサブスクライブしたObservableに適用される演算子のチェーンを通ってカスケードバックされ、チェーンの各リンクはアイテムの放出を停止します。しかし、これはすぐに起こることを保証するものではなく、観測者がいなくなった後でも、しばらくの間はObservableがアイテムを生成して放出しようとすることがあります。</target>
        </trans-unit>
        <trans-unit id="0f7d52b3373d09ac8d1c47f35ca4249eb74f508c" translate="yes" xml:space="preserve">
          <source>The second variant accepts as its parameter an Observable, and it samples the source Observable whenever this second Observable emits an item.</source>
          <target state="translated">2 番目のバリアントは Observable をパラメータとして受け入れ、この 2 番目の Observable がアイテムを放出するたびにソースの Observable をサンプリングします。</target>
        </trans-unit>
        <trans-unit id="96a965140ca52079c513552d1152f6627ca655d7" translate="yes" xml:space="preserve">
          <source>The second variant of &lt;code&gt;merge&lt;/code&gt; is a prototype (class) operator that accepts two parameters. The second of these is an Observable that emits the Observables you want to merge. The first is a number that indicates the maximum number of these emitted Observables that you want &lt;code&gt;merge&lt;/code&gt; to attempt to be subscribed to at any moment. Once it reaches this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; の2番目のバリアントは、2つのパラメータを受け入れるプロトタイプ（クラス）演算子です。これらの2番目は、マージするObservableを発行するObservableです。 1つ目は、 &lt;code&gt;merge&lt;/code&gt; していつでもサブスクライブしようとする、これらの発行されたObservableの最大数を示す数値です。この最大サブスクリプション数に達すると、すでにサブスクライブされているObservableの1つが &lt;code&gt;onCompleted&lt;/code&gt; 通知を発行するまで、ソースObservableによって発行された他のObservableをサブスクライブしません。</target>
        </trans-unit>
        <trans-unit id="e968e081d2b1a1b80a32c5783a3beb2f47d20ff6" translate="yes" xml:space="preserve">
          <source>The transforming function gets three parameters:</source>
          <target state="translated">変換関数は3つのパラメータを取得します。</target>
        </trans-unit>
        <trans-unit id="d776b341ab49eb64280d0e25e6eb6356060e9290" translate="yes" xml:space="preserve">
          <source>The variant of &lt;code&gt;delay&lt;/code&gt; that uses a per-item Observable to set the delay has a variant that allows you to pass in a function that returns an Observable that acts as a delay timer for the subscription to the source Observable (in the absence of this, &lt;code&gt;delay&lt;/code&gt; subscribes to the source Observable as soon as an observer subscribes to the Observable returned by &lt;code&gt;delay&lt;/code&gt;).</source>
          <target state="translated">変種 &lt;code&gt;delay&lt;/code&gt; 遅延は、この非存在下でのソース観察可能（へのサブスクリプションの遅延タイマーとして働き戻っ観察可能ということは、関数に渡すことができますバリアントを持って設定するアイテム単位の観察可能な使用しています、 &lt;code&gt;delay&lt;/code&gt; は、 &lt;code&gt;delay&lt;/code&gt; によって返されたObservableをオブザーバーがサブスクライブするとすぐに、ソースObservableをサブスクライブします。</target>
        </trans-unit>
        <trans-unit id="adc1ba9017e6bcdf3a2740ab73cfafc6559474ce" translate="yes" xml:space="preserve">
          <source>The variant of &lt;code&gt;timeout&lt;/code&gt; that uses a per-item Observable to set the timeout has a variant that allows you to pass in a function that returns an Observable that acts as a timeout timer for the very first item emitted by the source Observable (in the absence of this, there would be no timeout for the first item).</source>
          <target state="translated">変異体 &lt;code&gt;timeout&lt;/code&gt; タイムアウトを設定する単位のアイテム観測を使用して、関数に渡すことを可能にする変異を有する戻り非存在下での（観測源によって放出された非常に最初の項目のタイムアウトタイマとして作用する観測をこのうち、最初のアイテムのタイムアウトはありません）。</target>
        </trans-unit>
        <trans-unit id="dac97b2b169057bbb0f51b05b81737a793abbd1a" translate="yes" xml:space="preserve">
          <source>The variant of &lt;code&gt;timeoutWithSelector&lt;/code&gt; that uses a per-item Observable to set the timeout has a variant that allows you to pass in an Observable that acts as a timeout timer for the very first item emitted by the source Observable (in the absence of this, there would be no timeout for the first item; that is to say, the default Observable that governs this first timeout period is &lt;code&gt;Rx.Observable.never()&lt;/code&gt;).</source>
          <target state="translated">アイテムごとのObservableを使用してタイムアウトを設定する &lt;code&gt;timeoutWithSelector&lt;/code&gt; のバリアントには、ソースObservableによって発行された最初のアイテムのタイムアウトタイマーとして機能するObservableを渡すことができるバリアントがあります（これがない場合、最初のアイテムのタイムアウトはありません。つまり、この最初のタイムアウト期間を管理するデフォルトのObservableは &lt;code&gt;Rx.Observable.never()&lt;/code&gt; です）。</target>
        </trans-unit>
        <trans-unit id="76e86c71c2cfc919caec20c620ae9ee1c2891b71" translate="yes" xml:space="preserve">
          <source>The various RxGroovy implementations of Start are found in the optional &lt;code&gt;rxjava-async&lt;/code&gt; module.</source>
          <target state="translated">StartのさまざまなRxGroovy実装は、オプションの &lt;code&gt;rxjava-async&lt;/code&gt; モジュールにあります。</target>
        </trans-unit>
        <trans-unit id="69d9d1fff4b37940fbc6c5e8b43dc2bfa9e40934" translate="yes" xml:space="preserve">
          <source>The various RxJava implementations of Start are found in the optional &lt;code&gt;rxjava-async&lt;/code&gt; module.</source>
          <target state="translated">StartのさまざまなRxJava実装は、オプションの &lt;code&gt;rxjava-async&lt;/code&gt; モジュールにあります。</target>
        </trans-unit>
        <trans-unit id="5d2372405de754e029a63b317c742a70f865da43" translate="yes" xml:space="preserve">
          <source>The various language-specific implementations of ReactiveX have a variety of operators that you can use to convert an Observable, or a sequence of items emitted by an Observable, into another variety of object or data structure. Some of these block until the Observable terminates and then produce an equivalent object or data structure; others return an Observable that emits such an object or data structure.</source>
          <target state="translated">ReactiveX の様々な言語固有の実装には、Observable、または Observable によって放出される一連のアイテムを別の種類のオブジェクトやデータ構造に変換するために使用できる様々な演算子があります。これらの中には、Observable が終了するまでブロックして、等価なオブジェクトやデータ構造を生成するものもあれば、そのようなオブジェクトやデータ構造を放出する Observable を返すものもあります。</target>
        </trans-unit>
        <trans-unit id="8a3803202cc409cc722e7f519df7c21e3cad47af" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;manySelect&lt;/code&gt; passes each of these Observables into a function that you provide, and emits, as the emissions from the Observable that &lt;code&gt;manySelect&lt;/code&gt; returns, the return values from those function calls.</source>
          <target state="translated">次に、 &lt;code&gt;manySelect&lt;/code&gt; はこれらの各Observableを提供する関数に &lt;code&gt;manySelect&lt;/code&gt; 、manySelectが返すObservableからのエミッションとして、それらの関数呼び出しからの戻り値を放出します。</target>
        </trans-unit>
        <trans-unit id="33a18cef9dc87a7ca6a904f01a814fcba80c85d2" translate="yes" xml:space="preserve">
          <source>There are a number of ways that programming languages have for obtaining values as the result of calculations, with names like functions, futures, actions, callables, runnables, and so forth. The operators grouped here under the Start operator category make these things behave like Observables so that they can be chained with other Observables in an Observable cascade</source>
          <target state="translated">プログラミング言語には、計算の結果として値を得るためのいくつかの方法があり、関数、先物、アクション、コールアブル、ランナブルなどの名前が付けられています。Start演算子の下にグループ化された演算子は、これらをObservableのように振る舞い、Observableカスケードの中で他のObservableと連鎖させることができるようにします。</target>
        </trans-unit>
        <trans-unit id="73e88b632040f4debf71d15f62a7edac8dafa11d" translate="yes" xml:space="preserve">
          <source>There are a variety of strategies with which you can exercise flow control and backpressure in ReactiveX in order to alleviate the problems caused when a quickly-producing Observable meets a slow-consuming observer, which include, in some ReactiveX implementations, reactive pull backpressure and some backpressure-specific operators.</source>
          <target state="translated">生産の速いObservableが遅い消費型オブザーバと出会うときに生じる問題を軽減するために、ReactiveXでフローコントロールとバックプレッシャーを行使することができる様々な戦略があります。</target>
        </trans-unit>
        <trans-unit id="e49413915d5649a099917d12a2f59331c6b6ecb2" translate="yes" xml:space="preserve">
          <source>There are also several other operators that perform similar functions.</source>
          <target state="translated">他にも、同様の機能を行う演算子がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="61a06999b013c4f11472882f535a3c0cecf8baa5" translate="yes" xml:space="preserve">
          <source>There are also two operators that convert an ordinary Observable into at &lt;code&gt;PausableObservable&lt;/code&gt;.</source>
          <target state="translated">通常のObservableを &lt;code&gt;PausableObservable&lt;/code&gt; に変換する2つの演算子もあります。</target>
        </trans-unit>
        <trans-unit id="7cd75322c8a8e345487e962bdedb9cc23338cdd4" translate="yes" xml:space="preserve">
          <source>There are also versions of &lt;code&gt;ReplaySubject&lt;/code&gt; that will throw away old items once the replay buffer threatens to grow beyond a certain size, or when a specified timespan has passed since the items were originally emitted.</source>
          <target state="translated">&lt;code&gt;ReplaySubject&lt;/code&gt; のバージョンには、再生バッファーが特定のサイズを超えると脅迫された場合、またはアイテムが最初に発行されてから指定された期間が経過した場合に、古いアイテムを破棄するバージョンもあります。</target>
        </trans-unit>
        <trans-unit id="f6c86c5d109c333c0cb181ff21e7e549c1d9978e" translate="yes" xml:space="preserve">
          <source>There are four varieties of &lt;code&gt;Subject&lt;/code&gt; that are designed for particular use cases. Not all of these are available in all implementations, and some implementations use other naming conventions (for example, in RxScala, what is called a &amp;ldquo;PublishSubject&amp;rdquo; here is known simply as a &amp;ldquo;Subject&amp;rdquo;):</source>
          <target state="translated">特定のユースケース用に設計された4種類の &lt;code&gt;Subject&lt;/code&gt; があります。これらのすべてがすべての実装で使用できるわけではなく、一部の実装では他の命名規則を使用しています（たとえば、RxScalaでは、ここで「PublishSubject」と呼ばれるものを単に「Subject」と呼びます）。</target>
        </trans-unit>
        <trans-unit id="e3d50a06b7b01adde087a728ea4e55f5179a3c5f" translate="yes" xml:space="preserve">
          <source>There are many terms used to describe this model of asynchronous programming and design. This document will use the following terms: An</source>
          <target state="translated">このモデルの非同期プログラミングとデザインを説明するために、多くの用語が使われています。このドキュメントでは以下の用語を使用します。並列計算機の</target>
        </trans-unit>
        <trans-unit id="c22e405785cca51fa4bed377c8c7a316e925a3fa" translate="yes" xml:space="preserve">
          <source>There are other patterns, like the Builder Pattern, in which a variety of methods of a particular class operate on an item of that same class by modifying that object through the operation of the method. These patterns also allow you to chain the methods in a similar way. But while in the Builder Pattern, the order in which the methods appear in the chain does not usually matter, with the Observable operators &lt;em&gt;order matters&lt;/em&gt;.</source>
          <target state="translated">Builderパターンのような他のパターンがあり、特定のクラスのさまざまなメソッドが、メソッドの操作を通じてそのオブジェクトを変更することにより、同じクラスのアイテムを操作します。これらのパターンにより、同様の方法でメソッドを連鎖させることもできます。ただし、ビルダーパターンでは、メソッドがチェーンに表示される順序は通常重要ではなく、監視可能な演算子の&lt;em&gt;順序が重要&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="ea34fdc274aea1e52da5c7d9e60582c49187d9f7" translate="yes" xml:space="preserve">
          <source>There are several variants of the Catch operator, and a variety of names used by different ReactiveX implementations to describe this operation, as you can see in the sections below.</source>
          <target state="translated">Catch 演算子にはいくつかのバリエーションがあり、この操作を説明するために異なる ReactiveX 実装によって使用される様々な名前があります。</target>
        </trans-unit>
        <trans-unit id="6d11bb624ef1904bb9f2ab36c1280a55a7979979" translate="yes" xml:space="preserve">
          <source>There are several variants of the Window operator in Rx.NET.</source>
          <target state="translated">Rx.NET には Window 演算子のバリエーションがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="07798f4e8bae1bc378e7ef680bdb140ecb41085a" translate="yes" xml:space="preserve">
          <source>There are several varieties of Window in RxGroovy.</source>
          <target state="translated">RxGroovyのWindowにはいくつかの種類があります。</target>
        </trans-unit>
        <trans-unit id="fe6adaab352a0a35969e744faa35420dfb689712" translate="yes" xml:space="preserve">
          <source>There are several varieties of Window in RxJava.</source>
          <target state="translated">RxJavaにはいくつかの種類のWindowがあります。</target>
        </trans-unit>
        <trans-unit id="f5e80cf04e90857ed90a075f8cf480a3a0d35901" translate="yes" xml:space="preserve">
          <source>There are several varieties of Window in RxKotlin.</source>
          <target state="translated">RxKotlinのWindowにはいくつかの種類があります。</target>
        </trans-unit>
        <trans-unit id="18c6f13171d4c2450de4807dd5e71c2d51ac49cb" translate="yes" xml:space="preserve">
          <source>There are several, specialized From variants in RxJS:</source>
          <target state="translated">RxJSには、いくつかの特化したFromのバリエーションがあります。</target>
        </trans-unit>
        <trans-unit id="c2aafde972aa8a0b7ac30764bbba82ab7263e0b7" translate="yes" xml:space="preserve">
          <source>There ia also a variant of &lt;code&gt;debounce&lt;/code&gt; (that does not have a &lt;code&gt;throttleWithTimeout&lt;/code&gt; alias) that throttles the source Observable by applying a function to each item it emits, this function generating an Observable. If the source Observable emits another item before this newly-generated Observable terminates, &lt;code&gt;debounce&lt;/code&gt; will suppress the item.</source>
          <target state="translated">また、放出する各アイテムに関数を適用することによってソースObservableを抑制し、この関数がObservableを生成する &lt;code&gt;debounce&lt;/code&gt; バリアント（ &lt;code&gt;throttleWithTimeout&lt;/code&gt; エイリアスを持たない）もあります。この新しく生成されたObservableが終了する前にソースObservableが別のアイテムを放出する場合、 &lt;code&gt;debounce&lt;/code&gt; はアイテムを抑制します。</target>
        </trans-unit>
        <trans-unit id="27a314ac81cd792286fe509248ef7e647165cd74" translate="yes" xml:space="preserve">
          <source>There ia also a variant of &lt;code&gt;sample&lt;/code&gt; (that does not have a &lt;code&gt;throttleLast&lt;/code&gt; alias) that samples the source Observable each time a second Observable emits an item (or when it terminates). You pass in that second Observable as the parameter to &lt;code&gt;sample&lt;/code&gt;.</source>
          <target state="translated">また、2番目のObservableがアイテムを発行するたびに（または終了するときに）ソースのObservableをサンプリングする &lt;code&gt;sample&lt;/code&gt; バリアント（ &lt;code&gt;throttleLast&lt;/code&gt; エイリアスを持たない）もあります。その2番目のObservableをパラメーターとして &lt;code&gt;sample&lt;/code&gt; に渡します。</target>
        </trans-unit>
        <trans-unit id="bb4c828574f32cd2c4544bf3aa850a7f8f332980" translate="yes" xml:space="preserve">
          <source>There is a somewhat similar operator in the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package (it is not part of the standard RxGroovy set of operators). The &lt;code&gt;switchCase&lt;/code&gt; operator conditionally creates and returns one of a set of possible Observables.</source>
          <target state="translated">オプションの &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; パッケージにはやや類似した演算子があります（これは標準のRxGroovy演算子のセットの一部ではありません）。 &lt;code&gt;switchCase&lt;/code&gt; のオペレータは、条件付きで可能な観測のセットのうちの1つを作成して返します。</target>
        </trans-unit>
        <trans-unit id="b0dccba89c1599405c711aa1cf5bd05e76ced379" translate="yes" xml:space="preserve">
          <source>There is a somewhat similar operator in the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package (it is not part of the standard RxJava set of operators). The &lt;code&gt;switchCase&lt;/code&gt; operator conditionally creates and returns one of a set of possible Observables.</source>
          <target state="translated">オプションの &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; パッケージには、多少似た演算子があります（これは、標準のRxJava演算子のセットの一部ではありません）。 &lt;code&gt;switchCase&lt;/code&gt; のオペレータは、条件付きで可能な観測のセットのうちの1つを作成して返します。</target>
        </trans-unit>
        <trans-unit id="8b280f16d9def0775a32cceafee35e54eb2b99f3" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;BlockingObservable&lt;/code&gt; method called &lt;code&gt;forEach&lt;/code&gt; that is somewhat similar. In order to use it, you must first convert your source Observable into a &lt;code&gt;BlockingObservable&lt;/code&gt; by means of either the &lt;code&gt;BlockingObservable.from&lt;/code&gt; method or the &lt;code&gt;Observable.toBlocking&lt;/code&gt; operator.</source>
          <target state="translated">多少似ている &lt;code&gt;forEach&lt;/code&gt; と呼ばれる &lt;code&gt;BlockingObservable&lt;/code&gt; メソッドもあります。これを使用するには、まず &lt;code&gt;BlockingObservable.from&lt;/code&gt; メソッドまたは &lt;code&gt;Observable.toBlocking&lt;/code&gt; 演算子を使用して、ソースObservableを &lt;code&gt;BlockingObservable&lt;/code&gt; に変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="756e49dd09eebbec81d8a98370d0d54627dacd33" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;concatMap&lt;/code&gt; operator, which is like the &lt;code&gt;flatMap&lt;/code&gt; operator, but it concatenates rather than merges the resulting Observables in order to generate its own sequence.</source>
          <target state="translated">また、 &lt;code&gt;concatMap&lt;/code&gt; 演算子に似た &lt;code&gt;flatMap&lt;/code&gt; 演算子もありますが、独自のシーケンスを生成するために、結果のObservableをマージするのではなく連結します。</target>
        </trans-unit>
        <trans-unit id="610870ff67a503579cdb5b83dc6b88cf5b2ca5bd" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;concatMap&lt;/code&gt; operator, which is like the simpler version of the &lt;code&gt;flatMap&lt;/code&gt; operator, but it concatenates rather than merges the resulting Observables in order to generate its own sequence.</source>
          <target state="translated">また、より単純なバージョンの &lt;code&gt;flatMap&lt;/code&gt; オペレーターのような &lt;code&gt;concatMap&lt;/code&gt; オペレーターもありますが、独自のシーケンスを生成するために、結果のObservableをマージするのではなく、連結します。</target>
        </trans-unit>
        <trans-unit id="09afc2ecb73970aa3e173379620bf2dbd67958e3" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;concatMapObserver&lt;/code&gt; operator, which is like the &lt;code&gt;flatMapObserver&lt;/code&gt; operator, in that it creates Observables to merge from both the emissions and terminal notifications of the source Observable, but it concatenates rather than merges these resulting Observables in order to generate its own sequence.</source>
          <target state="translated">また、 &lt;code&gt;concatMapObserver&lt;/code&gt; オペレーターに似ている &lt;code&gt;flatMapObserver&lt;/code&gt; オペレーターもあります。これは、ソースObservableのエミッションとターミナル通知の両方からマージするObservableを作成しますが、独自のシーケンスを生成するために、これらの結果のObservableをマージするのではなく連結します。</target>
        </trans-unit>
        <trans-unit id="f9e703f230d8766cf702a843852917ca049479cb" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;fromNodeCallback&lt;/code&gt; operator, which is specialized for the types of callback functions found in Node.js.</source>
          <target state="translated">Node.jsにあるコールバック関数のタイプに特化した &lt;code&gt;fromNodeCallback&lt;/code&gt; オペレーターもあります。</target>
        </trans-unit>
        <trans-unit id="0adc1cf4895a72eb26c43ab8483af0d51f693087" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;fromPromise&lt;/code&gt; operator that converts a Promise into an Observable, converting its &lt;code&gt;resolve&lt;/code&gt; calls into &lt;code&gt;onNext&lt;/code&gt; notifications, and its &lt;code&gt;reject&lt;/code&gt; calls into &lt;code&gt;onError&lt;/code&gt; notifications.</source>
          <target state="translated">また、PromiseをObservableに変換し、 &lt;code&gt;resolve&lt;/code&gt; 呼び出しを &lt;code&gt;onNext&lt;/code&gt; 通知に変換し、 &lt;code&gt;reject&lt;/code&gt; 呼び出しを &lt;code&gt;onError&lt;/code&gt; 通知に変換する &lt;code&gt;fromPromise&lt;/code&gt; 演算子もあります。</target>
        </trans-unit>
        <trans-unit id="9fa226a63caa5b60f8b21383025ba4a7f512229e" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;jortSort&lt;/code&gt; operator that performs a test on the entire sequence of items emitted by the source Observable. If those items are emitted in sorted order, upon the successful completion of the source Observable, the Observable returned from &lt;code&gt;jortSort&lt;/code&gt; will emit &lt;code&gt;true&lt;/code&gt; and then complete. If any of the items emitted by the source Observable is out of sort order, upon the successful completion of the source Observable, the Observable returned from &lt;code&gt;jortSort&lt;/code&gt; will emit &lt;code&gt;false&lt;/code&gt; and then complete.</source>
          <target state="translated">ソースのObservableによって &lt;code&gt;jortSort&lt;/code&gt; されたアイテムのシーケンス全体に対してテストを実行するjortSortオペレーターもあります。これらのアイテムがソートされた順序で &lt;code&gt;jortSort&lt;/code&gt; される &lt;code&gt;true&lt;/code&gt; 、ソースObservableが正常に完了すると、jortSortから返されたObservable がtrueを発行して完了します。元の正常終了時に観察可能なソート順で出ているソースから放出された項目のいずれか、観察可能な場合は、から返された観察可能 &lt;code&gt;jortSort&lt;/code&gt; が放出する &lt;code&gt;false&lt;/code&gt; その後、完全な。</target>
        </trans-unit>
        <trans-unit id="f9b14ade97497781729ad307d8e9c95d0d12c215" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;jortSortUntil&lt;/code&gt; operator. It does not wait until the source Observable completes to evaluate its sequence for sortedness, as &lt;code&gt;jortSort&lt;/code&gt; does, but waits until a second Observable emits an item to do so.</source>
          <target state="translated">&lt;code&gt;jortSortUntil&lt;/code&gt; 演算子もあります。jortSortのように、ソースObservableがシーケンスの並べ替えの評価を完了するまで待機しませんが、2番目のObservableがアイテムを &lt;code&gt;jortSort&lt;/code&gt; まで待機します。</target>
        </trans-unit>
        <trans-unit id="3b92b6af0c8024980674892ceec6ad6d8a9afe31" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;let&lt;/code&gt; operator (the alias &lt;code&gt;letBind&lt;/code&gt; is available for browsers such as Internet Explorer before IE9 where &amp;ldquo;&lt;code&gt;let&lt;/code&gt;&amp;rdquo; is forbidden). It is similar to &lt;code&gt;multicast&lt;/code&gt; but does not multicast the underlying Observable through a Subject:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 演算子もあります（エイリアス &lt;code&gt;letBind&lt;/code&gt; は、IE9より前のInternet Explorerなどの「 &lt;code&gt;let&lt;/code&gt; 」が禁止されているブラウザで使用できます）。これは &lt;code&gt;multicast&lt;/code&gt; 似ていますが、Subjectを介して基になるObservableをマルチキャストしません。</target>
        </trans-unit>
        <trans-unit id="33bf4c5e7b8fe133a7bee1aa2fed01e21ee7ee8f" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;pairs&lt;/code&gt; operator. This operator accepts an Object, and returns an Observable that emits, as key/value pairs, the attributes of that object.</source>
          <target state="translated">&lt;code&gt;pairs&lt;/code&gt; 演算子もあります。この演算子はオブジェクトを受け入れ、そのオブジェクトの属性をキーと値のペアとして出力するObservableを返します。</target>
        </trans-unit>
        <trans-unit id="106ca88c78fe1594ed237ab370c3a39e226e56bd" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;share&lt;/code&gt; operator, which is the equivalent of applying both the &lt;code&gt;publish&lt;/code&gt; and &lt;code&gt;refCount&lt;/code&gt; operators to an Observable, in that order.</source>
          <target state="translated">&lt;code&gt;share&lt;/code&gt; 演算子もあります。これは、 &lt;code&gt;refCount&lt;/code&gt; 演算子とrefCount演算子の両方をObservableにこの順序で適用 &lt;code&gt;publish&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="a951647b57d362f06673c5f1bcc698b8bc2b55bc" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;share&lt;/code&gt; operator, which is the equivalent of applying both the &lt;code&gt;publish&lt;/code&gt; and &lt;code&gt;refCount&lt;/code&gt; operators to an Observable, in that order. A variant called &lt;code&gt;shareValue&lt;/code&gt; takes as a parameter a single item that it will emit to any subscribers before beginning to emit items from the source Observable.</source>
          <target state="translated">&lt;code&gt;share&lt;/code&gt; 演算子もあります。これは、 &lt;code&gt;refCount&lt;/code&gt; 演算子とrefCount演算子の両方をObservableにこの順序で適用 &lt;code&gt;publish&lt;/code&gt; と同じです。 &lt;code&gt;shareValue&lt;/code&gt; と呼ばれるバリアントは、ソースObservableからアイテムを発行し始める前にサブスクライバーに発行する単一のアイテムをパラメーターとして受け取ります。</target>
        </trans-unit>
        <trans-unit id="5dce3334b047123b8d59d3f575f95fd87a1a54bc" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;shareReplay&lt;/code&gt; operator, which keeps track of the number of observers, and disconnects from the source Observable when that number drops to zero. &lt;code&gt;shareReplay&lt;/code&gt; takes three optional parameters and returns an ordinary Observable:</source>
          <target state="translated">&lt;code&gt;shareReplay&lt;/code&gt; オペレーターもあり、オブザーバーの数を追跡し、その数がゼロになるとソースObservableから切断します。 &lt;code&gt;shareReplay&lt;/code&gt; は3つのオプションパラメータを取り、通常のObservableを返します。</target>
        </trans-unit>
        <trans-unit id="ebdcc8b43b2ed321ef1ee5bf75bf2c4c54ccb1c8" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;skipUntilWithTime&lt;/code&gt; operator to which you can pass an absolute time or an initial duration in place of an Observable, but this is described on the &lt;a href=&quot;skip&quot;&gt;Skip&lt;/a&gt; operator page.</source>
          <target state="translated">Observableの代わりに絶対時間または初期期間を渡すことができる &lt;code&gt;skipUntilWithTime&lt;/code&gt; 演算子もありますが、これについては&lt;a href=&quot;skip&quot;&gt;Skip&lt;/a&gt;演算子のページで説明しています。</target>
        </trans-unit>
        <trans-unit id="13c54d80bc681ecd346bb753e654764813e1a20a" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;takeUntilWithTime&lt;/code&gt; operator to which you can pass an absolute time or an initial duration, but this is described on the &lt;a href=&quot;take&quot;&gt;Take&lt;/a&gt; operator page.</source>
          <target state="translated">絶対時間または初期期間を渡すことができる &lt;code&gt;takeUntilWithTime&lt;/code&gt; オペレーターもありますが、これについては&lt;a href=&quot;take&quot;&gt;Take&lt;/a&gt;オペレーターのページで説明しています。</target>
        </trans-unit>
        <trans-unit id="187361ed609c2e791463629d8bb597c987424287" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;throttleFirst&lt;/code&gt; operator, which differs from &lt;code&gt;sample&lt;/code&gt; in that it emits the &lt;em&gt;first&lt;/em&gt; item emitted by the source Observable in each sampling period rather than the &lt;em&gt;most recently emitted&lt;/em&gt; item.</source>
          <target state="translated">ある &lt;code&gt;throttleFirst&lt;/code&gt; オペレータとは異なる &lt;code&gt;sample&lt;/code&gt; が放出することを&lt;em&gt;第一&lt;/em&gt;各サンプリング周期よりもむしろで観察源によって放出されたアイテム&lt;em&gt;最近放出された&lt;/em&gt;アイテムは。</target>
        </trans-unit>
        <trans-unit id="6a39d834bd09c5835d19907919ecad6d0b1b92c4" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;throttleFirst&lt;/code&gt; operator, which differs from &lt;code&gt;throttleLast&lt;/code&gt;/&lt;code&gt;sample&lt;/code&gt; in that it emits the &lt;em&gt;first&lt;/em&gt; item emitted by the source Observable in each sampling period rather than the &lt;em&gt;most recently emitted&lt;/em&gt; item.</source>
          <target state="translated">ある &lt;code&gt;throttleFirst&lt;/code&gt; オペレータとは異なる &lt;code&gt;throttleLast&lt;/code&gt; / &lt;code&gt;sample&lt;/code&gt; が放出することを&lt;em&gt;第一&lt;/em&gt;各サンプリング周期よりもむしろで観察源によって放出されたアイテム&lt;em&gt;最近放出された&lt;/em&gt;アイテムは。</target>
        </trans-unit>
        <trans-unit id="1abf445457383a8d1a550a4666c34b283fc4d7f8" translate="yes" xml:space="preserve">
          <source>There is also a new operator in RxGroovy 1.1 called &lt;code&gt;switchIfEmpty&lt;/code&gt; that, rather than emitting a backup &lt;em&gt;value&lt;/em&gt; if the source Observable terminates without having emitted any items, it emits the emissions from a backup &lt;em&gt;Observable&lt;/em&gt;.</source>
          <target state="translated">RxGroovy 1.1には &lt;code&gt;switchIfEmpty&lt;/code&gt; と呼ばれる新しいオペレーターもあります。これは、ソースObservableがアイテムを放出せずに終了した場合にバックアップ&lt;em&gt;値&lt;/em&gt;を放出するのではなく、バックアップ&lt;em&gt;Observable&lt;/em&gt;から放出を放出します。</target>
        </trans-unit>
        <trans-unit id="1d407e02d3cef84f4a97e1dea8d87f2761215549" translate="yes" xml:space="preserve">
          <source>There is also a new operator in RxJava 1.1 called &lt;code&gt;switchIfEmpty&lt;/code&gt; that, rather than emitting a backup &lt;em&gt;value&lt;/em&gt; if the source Observable terminates without having emitted any items, it emits the emissions from a backup &lt;em&gt;Observable&lt;/em&gt;.</source>
          <target state="translated">呼び出さRxJava 1.1で新しい演算子もある &lt;code&gt;switchIfEmpty&lt;/code&gt; なくバックアップ発光より、こと&lt;em&gt;値を&lt;/em&gt;任意の項目を出射させずにソース観測終了した場合、それはバックアップからの排出物を放出する&lt;em&gt;観測が&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="88e452542892fa3f048cc208ee51de7ba7b6bfa7" translate="yes" xml:space="preserve">
          <source>There is also a specialized form of the Filter operator in RxGroovy that filters an Observable so that it only emits items of a particular class.</source>
          <target state="translated">RxGroovy には、特定のクラスのアイテムのみを放出するように Observable をフィルタリングする Filter 演算子の特殊な形式もあります。</target>
        </trans-unit>
        <trans-unit id="cad5015a738f042fbcc8fcbefa23870ac6109eda" translate="yes" xml:space="preserve">
          <source>There is also a specialized form of the Filter operator in RxJava that filters an Observable so that it only emits items of a particular class.</source>
          <target state="translated">RxJavaには、特定のクラスのアイテムのみを放出するようにObservableをフィルタリングするFilter演算子の特殊な形式もあります。</target>
        </trans-unit>
        <trans-unit id="30fba8f0a70d3997f65d6c4711bb2800ae22ab62" translate="yes" xml:space="preserve">
          <source>There is also a variant of &lt;code&gt;scan&lt;/code&gt; to which you can pass a seed value to pass to the accumulator function the first time it is called (for the first emission from the source Observable) in place of the result from the missing prior call to the accumulator. Note that if you use this version, &lt;code&gt;scan&lt;/code&gt; will emit this seed value as its own initial emission. Note also that passing a seed of &lt;code&gt;null&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; the same as passing no seed at all. A &lt;code&gt;null&lt;/code&gt; seed is a valid variety of seed.</source>
          <target state="translated">&lt;code&gt;scan&lt;/code&gt; バリアントもあります。シード値を渡して、最初に呼び出されたときにアキュムレータ関数に渡すことができます（ソースObservableからの最初のエミッションの場合）。 。このバージョンを使用する場合、 &lt;code&gt;scan&lt;/code&gt; はこのシード値を独自の初期放出として放出することに注意してください。 &lt;code&gt;null&lt;/code&gt; のシードを渡すことは、シードをまったく渡さ&lt;em&gt;ない&lt;/em&gt;ことと同じでは&lt;em&gt;ない&lt;/em&gt;ことにも注意してください。 &lt;code&gt;null&lt;/code&gt; 種子は、種子の有効な品種です。</target>
        </trans-unit>
        <trans-unit id="c27cc229fc79800fa19cb934a76962c6dbbba751" translate="yes" xml:space="preserve">
          <source>There is also a variant of &lt;code&gt;skip&lt;/code&gt; that takes a temporal duration rather than a quantity of items. It drops those items that are emitted during that initial duration of the source Observable&amp;rsquo;s lifespan. You set this duration by passing in a length of time and the time units this length is denominated in as parameters to &lt;code&gt;skip&lt;/code&gt;.</source>
          <target state="translated">アイテムの数量ではなく、一時的な期間をとる &lt;code&gt;skip&lt;/code&gt; バリアントもあります。これは、ソースのObservableの寿命の初期期間中に放出されたアイテムをドロップします。この期間を設定するには、時間の長さと、この長さを &lt;code&gt;skip&lt;/code&gt; パラメーターとして指定する時間単位を渡します。</target>
        </trans-unit>
        <trans-unit id="9feb05589b0e81a02e0e7767bb09a69dfc4a56cf" translate="yes" xml:space="preserve">
          <source>There is also a variant of &lt;code&gt;skipLast&lt;/code&gt; that takes a temporal duration rather than a quantity of items. It drops those items that are emitted during that final duration of the source Observable&amp;rsquo;s lifespan. You set this duration by passing in a length of time and the time units this length is denominated in as parameters to &lt;code&gt;skipLast&lt;/code&gt;.</source>
          <target state="translated">また、 &lt;code&gt;skipLast&lt;/code&gt; には、アイテムの数ではなく一時的な期間をとるバリアントもあります。ソースのObservableの寿命の最後の期間中に放出されたアイテムをドロップします。この期間を設定するには、時間の長さを渡し、この長さの単位は &lt;code&gt;skipLast&lt;/code&gt; のパラメーターとして指定します。</target>
        </trans-unit>
        <trans-unit id="08051516481f1b3895ac9cf3adcd62adbae06014" translate="yes" xml:space="preserve">
          <source>There is also a variant of &lt;code&gt;take&lt;/code&gt; that takes a temporal duration rather than a quantity of items. It results in an Observable that emits only those items that are emitted during that initial duration of the source Observable&amp;rsquo;s lifespan. You set this duration by passing in a length of time and the time units this length is denominated in as parameters to &lt;code&gt;take&lt;/code&gt;.</source>
          <target state="translated">アイテムの数ではなく、一時的な期間を &lt;code&gt;take&lt;/code&gt; バリアントもあります。これにより、ソースObservableの寿命の初期期間中に放出されたアイテムのみを放出するObservableが生成されます。この期間は、時間の長さを渡すことで設定します。この時間の長さは、 &lt;code&gt;take&lt;/code&gt; パラメータとして指定されます。</target>
        </trans-unit>
        <trans-unit id="449128271b54eccb75227b4a5514bce689da6853" translate="yes" xml:space="preserve">
          <source>There is also a variant of &lt;code&gt;takeLast&lt;/code&gt; that takes a temporal duration rather than a quantity of items. It emits only those items that are emitted during that final duration of the source Observable&amp;rsquo;s lifespan. You set this duration by passing in a length of time and the time units this length is denominated in as parameters to &lt;code&gt;takeLast&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;takeLast&lt;/code&gt; には、アイテムの数ではなく一時的な期間を取るバリエーションもあります。これは、ソースのObservableの寿命の最後の期間中に放出されるアイテムのみを放出します。この期間を設定するには、時間の長さと、この長さを &lt;code&gt;takeLast&lt;/code&gt; のパラメーターとして指定する時間単位を渡します。</target>
        </trans-unit>
        <trans-unit id="a59fb0727f4b59bbb076c9c5305d1643bae8cd28" translate="yes" xml:space="preserve">
          <source>There is also a variant of &lt;code&gt;timeout&lt;/code&gt; that both uses a per-item Observable to set the timeout duration and switches to a backup Observable in case of a timeout.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; バリアントもあり、アイテムごとの監視可能値を使用してタイムアウト期間を設定し、タイムアウトの場合はバックアップ監視可能タイプに切り替えます。</target>
        </trans-unit>
        <trans-unit id="031e84f5098d34601fbcb52c5bc13125fa8050ff" translate="yes" xml:space="preserve">
          <source>There is also a variant of &lt;code&gt;timeoutWithSelector&lt;/code&gt; that both uses a per-item Observable to set the timeout duration and switches to a backup Observable in case of a timeout.</source>
          <target state="translated">&lt;code&gt;timeoutWithSelector&lt;/code&gt; のバリアントもあり、アイテムごとのObservableを使用してタイムアウト期間を設定し、タイムアウトの場合はバックアップのObservableに切り替えます。</target>
        </trans-unit>
        <trans-unit id="36700f3cd710204d79349671ecb78d033b6e018a" translate="yes" xml:space="preserve">
          <source>There is also a variant of this operator that takes a function as a parameter. This function operates on items emitted by the source Observable to generate a &amp;ldquo;key.&amp;rdquo; It is these keys, then, and not the items themselves, that &lt;code&gt;distinct&lt;/code&gt; will compare to determine whether or not two items are distinct.</source>
          <target state="translated">この演算子には、関数をパラメーターとして使用するバリアントもあります。この関数は、ソースObservableによって発行されたアイテムを操作して「キー」を生成します。その後、これらのキーではなく、アイテムそのもの、つまり &lt;code&gt;distinct&lt;/code&gt; 2つの項目が異なっているか否かを決定するために比較されます。</target>
        </trans-unit>
        <trans-unit id="f10041ebeaec7e7413aaa8734dfe5111f3042d93" translate="yes" xml:space="preserve">
          <source>There is also a variant that combines the two methods. It emits the minimum of the number of items emitted during a specified time window &lt;em&gt;or&lt;/em&gt; a particular count of items.</source>
          <target state="translated">2つの方法を組み合わせたバリアントもあります。これは、指定された時間枠&lt;em&gt;または&lt;/em&gt;特定のアイテム数の間に放出されたアイテムの最小数を放出します。</target>
        </trans-unit>
        <trans-unit id="0b8726cf18549a2cf1149657d39c80c83857f5b1" translate="yes" xml:space="preserve">
          <source>There is also a variant that takes a function as a parameter. This function takes an emitted item from the source Observable as a parameter and produces the item that will be emitted in its place by the resulting Observable.</source>
          <target state="translated">パラメータとして関数を取るバリアントもあります。この関数は元のObservableから放出されたアイテムをパラメータとして受け取り、結果のObservableによってその場所に放出されるアイテムを生成します。</target>
        </trans-unit>
        <trans-unit id="dc97cb652e36868458024e656ee272ac5b84c26e" translate="yes" xml:space="preserve">
          <source>There is also a variant that takes a function as a parameter. This function takes as a parameter the &lt;code&gt;ConnectableObservable&lt;/code&gt; that shares a single subscription to the underlying Observable sequence. This function produces and returns a new Observable sequence.</source>
          <target state="translated">関数をパラメーターとして取るバリアントもあります。この関数は、基になるObservableシーケンスへの単一のサブスクリプションを共有する &lt;code&gt;ConnectableObservable&lt;/code&gt; をパラメーターとして受け取ります。この関数は、新しいObservableシーケンスを生成して返します。</target>
        </trans-unit>
        <trans-unit id="e5ae115f084cc2ab1aee05d0a43efa252b4c5426" translate="yes" xml:space="preserve">
          <source>There is also a variety of &lt;code&gt;replay&lt;/code&gt; that returns an ordinary Observable. These variants take as a parameter a transformative function; this function accepts an item emitted by the source Observable as its parameter, and returns an item to be emitted by the resulting Observable. So really, this operator does not replay the source Observable but instead replays the source Observable &lt;em&gt;as transformed&lt;/em&gt; by this function.</source>
          <target state="translated">通常のObservableを返すさまざまな &lt;code&gt;replay&lt;/code&gt; もあります。これらのバリアントは、変換関数をパラメーターとして受け取ります。この関数は、ソースObservableが発行したアイテムをパラメーターとして受け取り、結果のObservableが発行するアイテムを返します。したがって、実際には、この演算子はソースのObservableを再生せず、この関数によって&lt;em&gt;変換&lt;/em&gt;されたソースのObservable &lt;em&gt;を&lt;/em&gt;再生します。</target>
        </trans-unit>
        <trans-unit id="ff00967c6f2b2f7e162cb2796c317c702c4a18eb" translate="yes" xml:space="preserve">
          <source>There is also a variety that takes a &lt;a href=&quot;scheduler&quot;&gt;Scheduler&lt;/a&gt; as an argument:</source>
          <target state="translated">引数として&lt;a href=&quot;scheduler&quot;&gt;スケジューラ&lt;/a&gt;をとるさまざまなものもあります。</target>
        </trans-unit>
        <trans-unit id="6900629b96a56ae8022ad8f2d925a1196485317c" translate="yes" xml:space="preserve">
          <source>There is also a version of &lt;code&gt;delayWithSelector&lt;/code&gt; that takes an additional (first) argument: an Observable that sets a delay before &lt;code&gt;delayWithSelector&lt;/code&gt; subscribes to the source Observable after it itself is subscribed to.</source>
          <target state="translated">追加の（最初の）引数を取る &lt;code&gt;delayWithSelector&lt;/code&gt; のバージョンもあります。それ自体がサブスクライブされた後、 &lt;code&gt;delayWithSelector&lt;/code&gt; がソースObservableにサブスクライブする前に遅延を設定するObservableです。</target>
        </trans-unit>
        <trans-unit id="762fea989b34f515305f58f64134c4f4bcc94a1a" translate="yes" xml:space="preserve">
          <source>There is also a version of &lt;code&gt;interval&lt;/code&gt; that returns an Observable that emits a single zero after a specified delay, and then emits incrementally increasing numbers periodically thereafter on a specified periodicity. This version of &lt;code&gt;interval&lt;/code&gt; was called &lt;a href=&quot;timer&quot;&gt;&lt;code&gt;timer&lt;/code&gt;&lt;/a&gt; in RxGroovy 1.0.0, but that method has since been deprecated in favor of the one named &lt;code&gt;interval&lt;/code&gt; with the same behavior.</source>
          <target state="translated">また、指定された遅延後に単一のゼロを放出し、その後、指定された周期で徐々に増加する数値を定期的に放出するObservableを返すバージョンの &lt;code&gt;interval&lt;/code&gt; もあります。このバージョンの &lt;code&gt;interval&lt;/code&gt; はRxGroovy 1.0.0では&lt;a href=&quot;timer&quot;&gt; &lt;code&gt;timer&lt;/code&gt; &lt;/a&gt;と呼ばれていましたが、同じ動作の名前付き &lt;code&gt;interval&lt;/code&gt; を優先するため、そのメソッドは廃止されました。</target>
        </trans-unit>
        <trans-unit id="522b1ee6207e40a9269cf62e4c01ec31cdfb8604" translate="yes" xml:space="preserve">
          <source>There is also a version of &lt;code&gt;interval&lt;/code&gt; that returns an Observable that emits a single zero after a specified delay, and then emits incrementally increasing numbers periodically thereafter on a specified periodicity. This version of &lt;code&gt;interval&lt;/code&gt; was called &lt;a href=&quot;timer&quot;&gt;&lt;code&gt;timer&lt;/code&gt;&lt;/a&gt; in RxJava 1.0.0, but that method has since been deprecated in favor of the one named &lt;code&gt;interval&lt;/code&gt; with the same behavior.</source>
          <target state="translated">指定された遅延後に単一のゼロを放出し、その後、指定された周期で定期的に増加する数値を放出するObservableを返すバージョンの &lt;code&gt;interval&lt;/code&gt; もあります。このバージョンの &lt;code&gt;interval&lt;/code&gt; はRxJava 1.0.0では&lt;a href=&quot;timer&quot;&gt; &lt;code&gt;timer&lt;/code&gt; &lt;/a&gt;と呼ばれていましたが、同じ動作の名前付き &lt;code&gt;interval&lt;/code&gt; を優先するため、そのメソッドは廃止されました。</target>
        </trans-unit>
        <trans-unit id="fc631c74156b96e656eb92df791645c1d24072f1" translate="yes" xml:space="preserve">
          <source>There is also a version of &lt;code&gt;reduce&lt;/code&gt; to which you can pass a seed item in addition to an accumulator function. Note that passing a &lt;code&gt;null&lt;/code&gt; seed is not the same as not passing a seed. The behavior will be different. If you pass a seed of &lt;code&gt;null&lt;/code&gt;, you will be seeding your reduction with the item &lt;code&gt;null&lt;/code&gt;. Note also that if you do pass in a seed, and the source Observable emits no items, reduce will emit the seed and complete normally without error.</source>
          <target state="translated">アキュムレータ関数に加えて、シード項目を渡すことができる &lt;code&gt;reduce&lt;/code&gt; のバージョンもあります。 &lt;code&gt;null&lt;/code&gt; シードを渡すことは、シードを渡さないことと同じではないことに注意してください。動作は異なります。 &lt;code&gt;null&lt;/code&gt; のシードを渡すと、 &lt;code&gt;null&lt;/code&gt; アイテムで削減をシードします。また、シードを渡し、ソースのObservableがアイテムを発行しない場合、reduceはシードを発行し、エラーなしで正常に完了します。</target>
        </trans-unit>
        <trans-unit id="5202b7fb8ff33cff94a68a1b5e152acba79749b9" translate="yes" xml:space="preserve">
          <source>There is also a version of &lt;code&gt;timer&lt;/code&gt; that returns an Observable that emits a single item after a specified delay, and then emits items periodically thereafter on a specified periodicity. In this way it behaves a bit more like the &lt;a href=&quot;interval&quot;&gt;Interval&lt;/a&gt; operator.</source>
          <target state="translated">指定された遅延後に単一のアイテムを放出し、その後、指定された周期で定期的にアイテムを放出するObservableを返す &lt;code&gt;timer&lt;/code&gt; バージョンもあります。このように、これは&lt;a href=&quot;interval&quot;&gt;Interval&lt;/a&gt;演算子のように動作します。</target>
        </trans-unit>
        <trans-unit id="539cbb5c3fad3008ba0960da437343ef5a498e5a" translate="yes" xml:space="preserve">
          <source>There is also a version of this operator that allows you to perform the delay on a particular &lt;a href=&quot;scheduler&quot;&gt;Scheduler&lt;/a&gt;:</source>
          <target state="translated">この演算子には、特定の&lt;a href=&quot;scheduler&quot;&gt;スケジューラで&lt;/a&gt;遅延を実行できるバージョンもあります。</target>
        </trans-unit>
        <trans-unit id="139c58d44cf810efd4f9f9031e89d1cd0ddb3c18" translate="yes" xml:space="preserve">
          <source>There is also an &lt;code&gt;ofArrayChanges&lt;/code&gt; operator that monitors an Array with the &lt;code&gt;Array.observe&lt;/code&gt; method, and returns an Observable that emits any changes that take place in the array. This operator is found only in the &lt;code&gt;rx.all.js&lt;/code&gt; distribution.</source>
          <target state="translated">また、 &lt;code&gt;Array.observe&lt;/code&gt; メソッドで配列を監視し、配列内で発生した変更を出力するObservableを返す &lt;code&gt;ofArrayChanges&lt;/code&gt; 演算子もあります。この演算子は、 &lt;code&gt;rx.all.js&lt;/code&gt; ディストリビューションにのみ含まれています。</target>
        </trans-unit>
        <trans-unit id="e8eddbc3c124fb70ba958a1ab03bc7c5cb95d456" translate="yes" xml:space="preserve">
          <source>There is also an instance method, &lt;code&gt;concatWith&lt;/code&gt;, such that &lt;code&gt;Observable.concat(a,b)&lt;/code&gt; is equivalent to &lt;code&gt;a.concatWith(b)&lt;/code&gt;.</source>
          <target state="translated">インスタンスメソッド &lt;code&gt;concatWith&lt;/code&gt; もあり、 &lt;code&gt;Observable.concat(a,b)&lt;/code&gt; は &lt;code&gt;a.concatWith(b)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="38523a50cc8364b3f16b29daf3c937099c5ef9b5" translate="yes" xml:space="preserve">
          <source>There is also an instance version of this operator:</source>
          <target state="translated">この演算子のインスタンス版もあります。</target>
        </trans-unit>
        <trans-unit id="a6ab646dfb9f2df1243f7f0eecb8d5ca2c659762" translate="yes" xml:space="preserve">
          <source>There is also an operator called &lt;code&gt;pluck&lt;/code&gt; which is a simpler version of this operator. It transforms the elements emitted by the source Observable by extracting a single named property from those elements and emitting that property in their place.</source>
          <target state="translated">この演算子の簡単なバージョンである &lt;code&gt;pluck&lt;/code&gt; と呼ばれる演算子もあります。これらの要素から単一の名前付きプロパティを抽出し、その場所でそのプロパティを発行することにより、ソースObservableによって発行された要素を変換します。</target>
        </trans-unit>
        <trans-unit id="8a6307e1784a009488a1fd7f31602a8bdede7cc4" translate="yes" xml:space="preserve">
          <source>There is also an operator called &lt;code&gt;repeatWhen&lt;/code&gt;. Rather than buffering and replaying the sequence from the source Observable, it &lt;em&gt;resubscribes&lt;/em&gt; to and mirrors the source Observable, but only conditionally.</source>
          <target state="translated">&lt;code&gt;repeatWhen&lt;/code&gt; という演算子もあります。ソースのObservableのシーケンスをバッファリングして再生するのではなく、ソースのObservableに&lt;em&gt;再サブスクライブ&lt;/em&gt;して&lt;em&gt;ミラーリング&lt;/em&gt;しますが、条件付きでのみ行います。</target>
        </trans-unit>
        <trans-unit id="92996dc580469547aa517e94605bc5bf1f133e10" translate="yes" xml:space="preserve">
          <source>There is also an operator called &lt;code&gt;takeLastBuffer&lt;/code&gt;. It differs in behavior from &lt;code&gt;takeLast&lt;/code&gt; by emitting its items not individually but collected into a single array of items that is emitted as a single item.</source>
          <target state="translated">&lt;code&gt;takeLastBuffer&lt;/code&gt; と呼ばれる演算子もあります。アイテムを個別に &lt;code&gt;takeLast&lt;/code&gt; するのではなく、単一のアイテムとして発行される単一のアイテム配列に収集されるという点で、takeLastとは動​​作が異なります。</target>
        </trans-unit>
        <trans-unit id="e106bef886f7af5b82506fb949433f1cdb132fb9" translate="yes" xml:space="preserve">
          <source>There is also an operator called &lt;code&gt;takeLastBuffer&lt;/code&gt;. It exists in the same set of variants as described above for &lt;code&gt;takeLast&lt;/code&gt;, and only differs in behavior by emitting its items not individually but collected into a single &lt;code&gt;List&lt;/code&gt; of items that is emitted as a single item.</source>
          <target state="translated">&lt;code&gt;takeLastBuffer&lt;/code&gt; と呼ばれる演算子もあります。これは、 &lt;code&gt;takeLast&lt;/code&gt; について上記で説明したのと同じバリアントのセットに存在し、アイテムを個別に放出するのではなく、単一のアイテムとして放出される単一のアイテム &lt;code&gt;List&lt;/code&gt; に収集されることによって動作のみが異なります。</target>
        </trans-unit>
        <trans-unit id="d13d40451e716541ebf0c6d731751a04de4ef9d8" translate="yes" xml:space="preserve">
          <source>There is also an operator with which you can delay the subscription to the source Observable: &lt;code&gt;delaySubscription&lt;/code&gt;. It accepts parameters that define the amount of time to delay (a quantity of time, and a &lt;code&gt;TimeUnit&lt;/code&gt; that this quantity is denominated in).</source>
          <target state="translated">ソースのObservableへのサブスクリプションを遅延できる演算子もあります： &lt;code&gt;delaySubscription&lt;/code&gt; 。これは、遅延する時間の長さを定義するパラメーターを受け入れます（時間の量、およびこの量を表す &lt;code&gt;TimeUnit&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="57b225db5c327853ba9175d45fd1a4710008118b" translate="yes" xml:space="preserve">
          <source>These Rx operators allow you to compose asynchronous sequences together in a declarative manner with all the efficiency benefits of callbacks but without the drawbacks of nesting callback handlers that are typically associated with asynchronous systems.</source>
          <target state="translated">これらのRx演算子を使用することで、非同期シーケンスを宣言的な方法で構成することができます。</target>
        </trans-unit>
        <trans-unit id="b342145d78f94ba5bc005eea9d73e6207c97bba6" translate="yes" xml:space="preserve">
          <source>These are found in the following packages:</source>
          <target state="translated">これらは以下のパッケージに含まれています。</target>
        </trans-unit>
        <trans-unit id="9c99563d62b8dafa8a56d975e28fbd373c39956c" translate="yes" xml:space="preserve">
          <source>These are not part of the core RxJava implementation, but are found as &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;then&lt;/code&gt;, and &lt;code&gt;when&lt;/code&gt; in the &lt;code&gt;rxjava-joins&lt;/code&gt; module.</source>
          <target state="translated">これらはコアRxJava実装の一部ではありませんが、 &lt;code&gt;rxjava-joins&lt;/code&gt; モジュール内に &lt;code&gt;and&lt;/code&gt; 、 &lt;code&gt;then&lt;/code&gt; 、 &lt;code&gt;when&lt;/code&gt; として見つかります。</target>
        </trans-unit>
        <trans-unit id="d9a600662c2fc82f13668558f5d63c8a1fcdcd74" translate="yes" xml:space="preserve">
          <source>These operators do not operate by default on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but &lt;code&gt;empty&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt; optionally take a Scheduler as a parameter, and if you pass them a Scheduler they will issue their termination notifications on that Scheduler.</source>
          <target state="translated">これらの演算子は、デフォルトでは特定の&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;で動作しませんが、 &lt;code&gt;empty&lt;/code&gt; および &lt;code&gt;error&lt;/code&gt; オプションでSchedulerをパラメーターとして受け取り、Schedulerを渡した場合、そのSchedulerで終了通知を発行します。</target>
        </trans-unit>
        <trans-unit id="a0c61cebbcf2a1d3434e4df6af333148712f0bf6" translate="yes" xml:space="preserve">
          <source>These operators do not operate by default on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">これらの演算子は、デフォルトでは特定の&lt;a href=&quot;../scheduler&quot;&gt;スケジューラで&lt;/a&gt;動作しません。</target>
        </trans-unit>
        <trans-unit id="cdd5a1235b46cc038c2c8dfd4ff72d2c0352c88b" translate="yes" xml:space="preserve">
          <source>These pages include information about some operators that are not part of the core of ReactiveX but are implemented in one or more of language-specific implementations and/or optional modules.</source>
          <target state="translated">これらのページには、ReactiveX のコアには含まれていないが、1つ以上の言語固有の実装やオプションモジュールで実装されている演算子についての情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="5c0b03b39df18d437c443c915a55a790fd23c116" translate="yes" xml:space="preserve">
          <source>These two operators are both available in each of the following distributions:</source>
          <target state="translated">これら2つの演算子はどちらも以下の分布のそれぞれで利用可能です。</target>
        </trans-unit>
        <trans-unit id="bcbafb20f7ea21b3026c1ebc35afb9f862e6a451" translate="yes" xml:space="preserve">
          <source>They each require one of the following distributions:</source>
          <target state="translated">彼らはそれぞれ、次のいずれかのディストリビューションを必要とします。</target>
        </trans-unit>
        <trans-unit id="916223df0a0362f110f17d6ced5cde0a2f3c560d" translate="yes" xml:space="preserve">
          <source>They require one of the following distributions:</source>
          <target state="translated">それらは以下のいずれかのディストリビューションを必要とします。</target>
        </trans-unit>
        <trans-unit id="08773d29a7c65ab1b76fc7763b4fa5f4dfb28a6f" translate="yes" xml:space="preserve">
          <source>They require one of the following packages:</source>
          <target state="translated">以下のいずれかのパッケージが必要です。</target>
        </trans-unit>
        <trans-unit id="238cc3432981781641c15b8b2183f3d63f5d3335" translate="yes" xml:space="preserve">
          <source>They requires one of the following:</source>
          <target state="translated">彼らは以下のいずれかを必要とします。</target>
        </trans-unit>
        <trans-unit id="44f376b551befd476ffb7da70312237937318ec6" translate="yes" xml:space="preserve">
          <source>This documentation accompanies its explanations with &amp;ldquo;marble diagrams.&amp;rdquo; Here is how marble diagrams represent Observables and transformations of Observables:</source>
          <target state="translated">このドキュメントには、「大理石の図」による説明が付いています。大理石の図が観測可能要素と観測可能要素の変換を表す方法を次に示します。</target>
        </trans-unit>
        <trans-unit id="5281791692d83f6908a511d623cd74573af6ee17" translate="yes" xml:space="preserve">
          <source>This documentation groups information about &lt;a href=&quot;operators#alphabetical&quot;&gt;the various operators&lt;/a&gt; and examples of their usage into the following pages:</source>
          <target state="translated">このドキュメントで&lt;a href=&quot;operators#alphabetical&quot;&gt;は、さまざまな演算子&lt;/a&gt;に関する情報とその使用例を次のページにまとめています。</target>
        </trans-unit>
        <trans-unit id="d376cbe36ad100032f76fcc1541bba68f850b7f9" translate="yes" xml:space="preserve">
          <source>This first variant of &lt;code&gt;merge&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">この &lt;code&gt;merge&lt;/code&gt; 最初のバリアントは、次のディストリビューションにあります。</target>
        </trans-unit>
        <trans-unit id="a5b5cc4b77c771ca16da88c602c7239a8d8f15cf" translate="yes" xml:space="preserve">
          <source>This implementation borrows the confusing nomenclature from Rx.NET, in which &lt;code&gt;onErrorResumeNext&lt;/code&gt; switches to a back-up Observable both on an error &lt;em&gt;and&lt;/em&gt; on a normal, error-free termination of the source Observable.</source>
          <target state="translated">この実装は、Rx.NETから紛らわしい用語を借用しています。この場合、 &lt;code&gt;onErrorResumeNext&lt;/code&gt; は、エラー&lt;em&gt;と&lt;/em&gt;、ソースObservableの通常のエラーのない終了時の両方で、バックアップObservableに切り替えます。</target>
        </trans-unit>
        <trans-unit id="ed80ee8261095cde1024407fe495ab29a4c3c56e" translate="yes" xml:space="preserve">
          <source>This implementation introduces a confusing nomenclature, in which in spite of its name &lt;code&gt;OnErrorResumeNext&lt;/code&gt; switches to a back-up Observable both on an error &lt;em&gt;and&lt;/em&gt; on a normal, error-free termination of the source Observable. It is therefore more like a concatenation operator.</source>
          <target state="translated">この実装は混乱を招く命名法を導入しています。その名前にもかかわらず、 &lt;code&gt;OnErrorResumeNext&lt;/code&gt; は、エラー時&lt;em&gt;と&lt;/em&gt;、ソースObservableの通常のエラーのない終了時の両方で、バックアップObservableに切り替わります。したがって、より連結演算子に似ています。</target>
        </trans-unit>
        <trans-unit id="0655f655c3305986ec20a3e6752fc22aaa4b2538" translate="yes" xml:space="preserve">
          <source>This method is useful, for example, when you have an Observable that emits a series of items that themselves have Observable members or are in other ways transformable into Observables, so that you can create a new Observable that emits the complete collection of items emitted by the sub-Observables of these items.</source>
          <target state="translated">このメソッドは、例えば、それ自体がObservableのメンバーを持っていたり、他の方法でObservableに変換可能な一連のアイテムを放出するObservableを持っている場合に便利で、これらのアイテムのサブObservableによって放出されるアイテムの完全なコレクションを放出する新しいObservableを作成することができます。</target>
        </trans-unit>
        <trans-unit id="a30ad7717749cac98edadad7cd7de1d8efe78cb2" translate="yes" xml:space="preserve">
          <source>This operator also takes an optional third parameter: a function that accepts the arguments from the event handler as parameters and returns an item to be emitted by the resulting Observable in place of the event.</source>
          <target state="translated">イベントハンドラからの引数をパラメータとして受け取り、結果としてイベントの代わりにObservableによって放出されるアイテムを返す関数です。</target>
        </trans-unit>
        <trans-unit id="f5e313c1df6d6f54ad302fc2dedb052cab252e38" translate="yes" xml:space="preserve">
          <source>This operator also takes three additional, optional parameters:</source>
          <target state="translated">この演算子は、3つの追加のオプションのパラメータも取ります。</target>
        </trans-unit>
        <trans-unit id="851f179b5f78b3880ad3289ce9b914d51abc4285" translate="yes" xml:space="preserve">
          <source>This operator also takes two additional, optional parameters:</source>
          <target state="translated">この演算子は、2 つの追加のオプションのパラメータも取ります。</target>
        </trans-unit>
        <trans-unit id="fcac799407a98fcba63c160676594897d39befce" translate="yes" xml:space="preserve">
          <source>This operator converts an Observable into an &lt;code&gt;Future&lt;/code&gt; that will return the single item emitted by the source Observable. If the source Observable emits more than one item, the &lt;code&gt;Future&lt;/code&gt; will receive an &lt;code&gt;IllegalArgumentException&lt;/code&gt;; if it completes after emitting no items, the &lt;code&gt;Future&lt;/code&gt; will receive a &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">この演算子は、Observableを &lt;code&gt;Future&lt;/code&gt; に変換します。Future は、ソースObservableによって発行された単一のアイテムを返します。ソースObservableが複数のアイテムを発行する場合、 &lt;code&gt;Future&lt;/code&gt; は &lt;code&gt;IllegalArgumentException&lt;/code&gt; を受け取ります。アイテムを &lt;code&gt;NoSuchElementException&lt;/code&gt; せずに完了した場合、 &lt;code&gt;Future&lt;/code&gt; はNoSuchElementExceptionを受け取ります。</target>
        </trans-unit>
        <trans-unit id="96728cf23a02c28de0a99116e4e6f37ac9437def" translate="yes" xml:space="preserve">
          <source>This operator converts an Observable into an &lt;code&gt;Iterable&lt;/code&gt; with which you can iterate over the set of items emitted by the source Observable.</source>
          <target state="translated">この演算子は、Observableを &lt;code&gt;Iterable&lt;/code&gt; に変換します。これを使用して、ソースObservableによって発行されたアイテムのセットを反復できます。</target>
        </trans-unit>
        <trans-unit id="051af4f85d777e94bfacdab9a3b5169cc86dfb4d" translate="yes" xml:space="preserve">
          <source>This operator converts an Observable into an &lt;code&gt;Iterator&lt;/code&gt; with which you can iterate over the set of items emitted by the source Observable.</source>
          <target state="translated">このオペレーターは、Observableを &lt;code&gt;Iterator&lt;/code&gt; 変換します。イテレーターを使用して、ソースObservableによって発行されたアイテムのセットを反復できます。</target>
        </trans-unit>
        <trans-unit id="7773f8dca511285fc6ff6888904509c3878d7c51" translate="yes" xml:space="preserve">
          <source>This operator does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">この演算子は、デフォルトでは特定の&lt;a href=&quot;../scheduler&quot;&gt;スケジューラで&lt;/a&gt;動作しません。</target>
        </trans-unit>
        <trans-unit id="157b4dc6015159c8ffac986b079921217fd87e4b" translate="yes" xml:space="preserve">
          <source>This operator is not in the RxJava core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module, where it is implemented with four type-specific operators: &lt;code&gt;averageDouble&lt;/code&gt;, &lt;code&gt;averageFloat&lt;/code&gt;, &lt;code&gt;averageInteger&lt;/code&gt;, and &lt;code&gt;averageLong&lt;/code&gt;.</source>
          <target state="translated">この演算子はRxJavaコアにはありませんが、別個の &lt;code&gt;rxjava-math&lt;/code&gt; モジュールの一部であり、4つの型固有の演算子（ &lt;code&gt;averageDouble&lt;/code&gt; 、 &lt;code&gt;averageFloat&lt;/code&gt; 、 &lt;code&gt;averageInteger&lt;/code&gt; 、averageLong）で &lt;code&gt;averageLong&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="abc6aa7fb60aaaf411d1cdedf546c6eadb42a5b8" translate="yes" xml:space="preserve">
          <source>This operator is not in the RxJava core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module, where it is implemented with four type-specific operators: &lt;code&gt;sumDouble&lt;/code&gt;, &lt;code&gt;sumFloat&lt;/code&gt;, &lt;code&gt;sumInteger&lt;/code&gt;, and &lt;code&gt;sumLong&lt;/code&gt;.</source>
          <target state="translated">この演算子はRxJavaコアにはありませんが、4つの型固有の演算子 &lt;code&gt;sumDouble&lt;/code&gt; 、 &lt;code&gt;sumFloat&lt;/code&gt; 、 &lt;code&gt;sumInteger&lt;/code&gt; 、および &lt;code&gt;sumLong&lt;/code&gt; で実装される別個の &lt;code&gt;rxjava-math&lt;/code&gt; モジュールの一部です。</target>
        </trans-unit>
        <trans-unit id="6de110854ecb7b4ee552a7ef41d8c72018c80ab1" translate="yes" xml:space="preserve">
          <source>This operator operates by default on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can override this by passing in another Scheduler as an optional second parameter.</source>
          <target state="translated">このオペレーターはデフォルトで &lt;code&gt;timeout&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;スケジューラー&lt;/a&gt;で動作しますが、オプションの2番目のパラメーターとして別のスケジューラーを渡すことで、これをオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="02c50ddd466d3ebbb2748eac79e6fbfb4598c90f" translate="yes" xml:space="preserve">
          <source>This operator takes three additional, optional parameters:</source>
          <target state="translated">この演算子は、3つの追加のオプションのパラメータを取ります。</target>
        </trans-unit>
        <trans-unit id="3dbabee9b79e9df2145ceeeb98aafe6caecdb79f" translate="yes" xml:space="preserve">
          <source>This operator will fail with an &lt;code&gt;IllegalArgumentException&lt;/code&gt; if the source Observable does not emit any items.</source>
          <target state="translated">ソースのObservableがアイテムを発行しない場合、このオペレーターは &lt;code&gt;IllegalArgumentException&lt;/code&gt; で失敗します。</target>
        </trans-unit>
        <trans-unit id="b104d679edb25132e93ff79622e9a5c691555507" translate="yes" xml:space="preserve">
          <source>This page explains what the reactive pattern is and what Observables and observers are (and how observers subscribe to Observables). Other pages show how you use &lt;a href=&quot;operators&quot;&gt;the variety of Observable operators&lt;/a&gt; to link Observables together and change their behaviors.</source>
          <target state="translated">このページでは、リアクティブパターンとは何か、オブザーバブルとオブザーバーは何か（オブザーバーがオブザーバブルをサブスクライブする方法）について説明します。他のページでは&lt;a href=&quot;operators&quot;&gt;、さまざまなObservable演算子&lt;/a&gt;を使用してObservableをリンクし、それらの動作を変更する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="c116dd880801c77b8119160bb66b54963e21fff6" translate="yes" xml:space="preserve">
          <source>This page first lists what could be considered the &amp;ldquo;core&amp;rdquo; operators in ReactiveX, and links to pages that have more in-depth information on how these operators work and how particular language-specific ReactiveX versions have implemented these operators.</source>
          <target state="translated">このページでは、最初にReactiveXの「コア」演算子と見なすことができるもの、およびこれらの演算子がどのように機能するか、および特定の言語固有のReactiveXバージョンがこれらの演算子をどのように実装しているかについての詳細な情報があるページへのリンクをリストします。</target>
        </trans-unit>
        <trans-unit id="77bb9ef85c54fbff31ff241c29acb1a8e1ec2d12" translate="yes" xml:space="preserve">
          <source>This page summarizes The Observable Contract.</source>
          <target state="translated">このページでは、The Observable Contractについてまとめています。</target>
        </trans-unit>
        <trans-unit id="8f1eb87eb26b05c1dd9b754759baaa987adf0fc3" translate="yes" xml:space="preserve">
          <source>This page uses Groovy-like pseudocode for its examples, but there are ReactiveX implementations in many languages.</source>
          <target state="translated">このページでは例としてGroovyライクな擬似コードを使用していますが、多くの言語でReactiveXの実装があります。</target>
        </trans-unit>
        <trans-unit id="b8093fb2efdcee4333d8cd01bcaf5d4c8a8678af" translate="yes" xml:space="preserve">
          <source>This second variant of &lt;code&gt;merge&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">この &lt;code&gt;merge&lt;/code&gt; 2番目のバリアントは、次のディストリビューションにあります。</target>
        </trans-unit>
        <trans-unit id="f5221f3b3887c251e11acd84d5b1946975ecec50" translate="yes" xml:space="preserve">
          <source>This sort of operation is sometimes called &amp;ldquo;accumulate,&amp;rdquo; &amp;ldquo;aggregate,&amp;rdquo; &amp;ldquo;compress,&amp;rdquo; &amp;ldquo;fold,&amp;rdquo; or &amp;ldquo;inject&amp;rdquo; in other contexts.</source>
          <target state="translated">この種の操作は、他のコンテキストでは「累積」、「集約」、「圧縮」、「折りたたみ」、または「注入」と呼ばれることがあります。</target>
        </trans-unit>
        <trans-unit id="edafb359c827bcb10eb8a71786f17d2080d73b14" translate="yes" xml:space="preserve">
          <source>This sort of operator is sometimes called an &amp;ldquo;accumulator&amp;rdquo; in other contexts.</source>
          <target state="translated">この種の演算子は、他のコンテキストでは「アキュムレータ」と呼ばれることがあります。</target>
        </trans-unit>
        <trans-unit id="c2561f854f2cc3c3e7da610a0e22ba37f41c88e2" translate="yes" xml:space="preserve">
          <source>This tree can help you find the ReactiveX Observable operator you&amp;rsquo;re looking for.</source>
          <target state="translated">このツリーは、探しているReactiveX Observableオペレーターを見つけるのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="705b10f8b5e84a3e1368d87690c43d30829c3378" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;Window&lt;/code&gt; opens a window whenever it observes the &lt;code&gt;windowOpenings&lt;/code&gt; Observable emit an &lt;code&gt;TWindowOpening&lt;/code&gt; object and at the same time calls the &lt;code&gt;windowClosingSelector&lt;/code&gt;, passing it that &lt;code&gt;TWindowOpening&lt;/code&gt; object, to generate a closing Observable associated with that window. When that closing Observable emits a &lt;code&gt;TWindowClosing&lt;/code&gt; object, &lt;code&gt;Window&lt;/code&gt; closes the associated window. Since the closing of currently open windows and the opening of new windows are activities that are regulated by independent Observables, this variant of &lt;code&gt;Window&lt;/code&gt; may create windows that overlap (duplicating items from the source Observable) or that leave gaps (discarding items from the source Observable).</source>
          <target state="translated">この &lt;code&gt;Window&lt;/code&gt; のバリアントは、 &lt;code&gt;windowOpenings&lt;/code&gt; Observableが &lt;code&gt;TWindowOpening&lt;/code&gt; オブジェクトを発行するのを監視すると同時にウィンドウを開き、同時に &lt;code&gt;windowClosingSelector&lt;/code&gt; を呼び出してその &lt;code&gt;TWindowOpening&lt;/code&gt; オブジェクトに渡し、そのウィンドウに関連付けられている閉じるObservableを生成します。その閉じるObservableが &lt;code&gt;TWindowClosing&lt;/code&gt; オブジェクトを発行すると、 &lt;code&gt;Window&lt;/code&gt; は関連するウィンドウを閉じます。現在開いているウィンドウを閉じることと新しいウィンドウを開くことは、独立したObservableによって規制されるアクティビティであるため、この &lt;code&gt;Window&lt;/code&gt; バリアント オーバーラップするウィンドウ（ソースObservableのアイテムを複製する）またはギャップを残す（ソースObservableのアイテムを破棄する）ウィンドウを作成する場合があります。</target>
        </trans-unit>
        <trans-unit id="97bf8eec0e5141569863b0c827f33e4e7d535d42" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;Window&lt;/code&gt; opens its first window immediately and calls the &lt;code&gt;windowClosingSelector&lt;/code&gt; function to obtain a second Observable. Whenever this second Observable emits a &lt;code&gt;TWindowClosing&lt;/code&gt; object, &lt;code&gt;Window&lt;/code&gt; closes the currently open window, and immediately opens a new one. It repeats this process until either Observable terminates. In this way, this variant of &lt;code&gt;Window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable, until the closing selector observable terminates.</source>
          <target state="translated">この &lt;code&gt;Window&lt;/code&gt; のバリアントは、最初のウィンドウをすぐに開き、 &lt;code&gt;windowClosingSelector&lt;/code&gt; 関数を呼び出して2番目のObservableを取得します。この2番目のObservableが &lt;code&gt;TWindowClosing&lt;/code&gt; オブジェクトを発行するたびに、 &lt;code&gt;Window&lt;/code&gt; は現在開いているウィンドウを閉じ、すぐに新しいウィンドウを開きます。どちらかのObservableが終了するまで、このプロセスを繰り返します。このようにして、 &lt;code&gt;Window&lt;/code&gt; このバリアントは、一連の重なり合わないウィンドウを放出します。このウィンドウの集合的な放出は、ソースObservableの放出と1対1で対応し、閉じるセレクターObservableが終了します。</target>
        </trans-unit>
        <trans-unit id="98502a842a954982b7ce81f17a6a8c51360051d2" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;Window&lt;/code&gt; opens its first window immediately, and thereafter opens a new window every &lt;code&gt;timeShift&lt;/code&gt; period of time (in the form of a &lt;code&gt;TimeSpan&lt;/code&gt; object, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;IScheduler&lt;/code&gt;&lt;/a&gt;). It closes a currently open window after &lt;code&gt;timeSpan&lt;/code&gt; period of time has passed since that window was opened. It will also close any currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. Depending on how you set &lt;code&gt;timeSpan&lt;/code&gt; and &lt;code&gt;timeShift&lt;/code&gt; the windows that result from this operation may overlap or may have gaps.</source>
          <target state="translated">この &lt;code&gt;Window&lt;/code&gt; のバリアントは、最初のウィンドウをすぐに開き、その後、 &lt;code&gt;timeShift&lt;/code&gt; 期間ごとに（ &lt;code&gt;TimeSpan&lt;/code&gt; オブジェクトの形式で、オプションで特定の&lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;IScheduler&lt;/code&gt; で&lt;/a&gt;）新しいウィンドウを開きます。そのウィンドウが開いてから &lt;code&gt;timeSpan&lt;/code&gt; 期間が経過すると、現在開いているウィンドウを閉じます。また、ソースObservableから &lt;code&gt;onCompleted&lt;/code&gt; または &lt;code&gt;onError&lt;/code&gt; 通知を受け取った場合、現在開いているウィンドウをすべて閉じます。 &lt;code&gt;timeSpan&lt;/code&gt; と &lt;code&gt;timeShift&lt;/code&gt; の設定方法によっては、この操作の結果であるウィンドウが重複したり、ギャップが生じたりすることがあります。</target>
        </trans-unit>
        <trans-unit id="4be1faa38714c36860cdde5e7e666e4a6e9464a1" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;Window&lt;/code&gt; opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;Window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">この &lt;code&gt;Window&lt;/code&gt; バリアントは、最初のウィンドウをすぐに開きます。現在開いているウィンドウを閉じ、現在のウィンドウが &lt;code&gt;count&lt;/code&gt; 個のアイテムを放出した場合は、すぐに新しいウィンドウを開きます。また、ソースObservableから &lt;code&gt;onCompleted&lt;/code&gt; または &lt;code&gt;onError&lt;/code&gt; 通知を受け取った場合、現在開いているウィンドウを閉じます。この &lt;code&gt;Window&lt;/code&gt; のバリアントは、一連の重なり合わないウィンドウを放出します。そのウィンドウの集合的な放出は、ソースObservableの放出と1対1で対応します。</target>
        </trans-unit>
        <trans-unit id="a187c3c7d20ee06b8c8d87d6e5adbb59e83be522" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;Window&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timeSpan&lt;/code&gt; period of time (in the form of a &lt;code&gt;TimeSpan&lt;/code&gt; object, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;IScheduler&lt;/code&gt;&lt;/a&gt;) or whenever the currently open window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">この &lt;code&gt;Window&lt;/code&gt; バリアントは、最初のウィンドウをすぐに開きます。これは、現在開いているウィンドウを閉じ、もう一つごとに開く &lt;code&gt;timeSpan&lt;/code&gt; 時間の期間（の形で &lt;code&gt;TimeSpan&lt;/code&gt; オブジェクトを、そして必要に応じて特定のオン&lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;IScheduler&lt;/code&gt; &lt;/a&gt;）またはたびに、現在開いているウィンドウが放射た &lt;code&gt;count&lt;/code&gt; アイテムを。また、ソースObservableから &lt;code&gt;onCompleted&lt;/code&gt; または &lt;code&gt;onError&lt;/code&gt; 通知を受け取った場合、現在開いているウィンドウを閉じます。この &lt;code&gt;window&lt;/code&gt; バリアントは、一連の重なり合わないウィンドウを放出します。そのウィンドウの集合的な放出は、ソースObservableの放出と1対1で対応します。</target>
        </trans-unit>
        <trans-unit id="55396b207982a5418912406d3afd4bff84fde485" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;Window&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; period of time (in the form of a &lt;code&gt;TimeSpan&lt;/code&gt; object, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;IScheduler&lt;/code&gt;&lt;/a&gt;). It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;Window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">この &lt;code&gt;Window&lt;/code&gt; バリアントは、最初のウィンドウをすぐに開きます。これは、現在開いているウィンドウを閉じて、別の毎開き &lt;code&gt;timespan&lt;/code&gt; （の形で時間の期間 &lt;code&gt;TimeSpan&lt;/code&gt; 、および必要に応じて特定のオブジェクトを&lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;IScheduler&lt;/code&gt; &lt;/a&gt;）。また、ソースObservableから &lt;code&gt;onCompleted&lt;/code&gt; または &lt;code&gt;onError&lt;/code&gt; 通知を受け取った場合、現在開いているウィンドウを閉じます。この &lt;code&gt;Window&lt;/code&gt; のバリアントは、一連の重なり合わないウィンドウを放出します。そのウィンドウの集合的な放出は、ソースObservableの放出と1対1で対応します。</target>
        </trans-unit>
        <trans-unit id="e6921e1d3d31550d1a98f0a86ca02bb1cd8c8379" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;Window&lt;/code&gt; opens its first window immediately. It opens a new window beginning with every &lt;code&gt;skip&lt;/code&gt; item from the source Observable (so, for example, if &lt;code&gt;skip&lt;/code&gt; is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted &lt;code&gt;count&lt;/code&gt; items or if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. If &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; then this behaves the same as &lt;code&gt;Window(source,&amp;nbsp;count)&lt;/code&gt;; if &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; this will emit windows that overlap by &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; items; if &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; this will emit windows that drop &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; items from the source Observable between every window.</source>
          <target state="translated">この &lt;code&gt;Window&lt;/code&gt; バリアントは、最初のウィンドウをすぐに開きます。ソースのObservableからのすべての &lt;code&gt;skip&lt;/code&gt; アイテムで始まる新しいウィンドウを開きます（たとえば、 &lt;code&gt;skip&lt;/code&gt; が3の場合、3つおきのアイテムで始まる新しいウィンドウを開きます）。ウィンドウが &lt;code&gt;count&lt;/code&gt; 個のアイテムを &lt;code&gt;onCompleted&lt;/code&gt; たとき、またはソースObservableからonCompletedまたは &lt;code&gt;onError&lt;/code&gt; 通知を受け取ったときに、各ウィンドウを閉じます。 &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; 場合、これは &lt;code&gt;Window(source,&amp;nbsp;count)&lt;/code&gt; と同じように動作します。 &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; 場合、これはcountで重複するウィンドウを放出し &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; アイテムをスキップします。 &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; 場合これにより、すべてのウィンドウ間で、ソースObservableから &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; アイテムをドロップするウィンドウが放出されます。</target>
        </trans-unit>
        <trans-unit id="c860df6d9d7d7bbc4dffd959fc12e6ab3d15a2a4" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;debounce&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">この &lt;code&gt;debounce&lt;/code&gt; バリアントは、デフォルトでは特定の&lt;a href=&quot;../scheduler&quot;&gt;スケジューラで&lt;/a&gt;動作しません。</target>
        </trans-unit>
        <trans-unit id="bd2f07d1f74443fcca4dba475d554c45d9fefa68" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;delay&lt;/code&gt; by default runs on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can choose a different Scheduler by passing it in as an optional third parameter to &lt;code&gt;delaySubscription&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;delay&lt;/code&gt; バリアントはデフォルトで &lt;code&gt;computation&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;スケジューラ&lt;/a&gt;で実行されますが、オプションの3番目のパラメータとして &lt;code&gt;delaySubscription&lt;/code&gt; に渡すことで、別のスケジューラを選択できます。</target>
        </trans-unit>
        <trans-unit id="89a735f7a290a0e3c83a8ff7f0b53d700ad552f6" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;delay&lt;/code&gt; does not by default run on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">この &lt;code&gt;delay&lt;/code&gt; バリアントは、デフォルトでは特定の&lt;a href=&quot;../scheduler&quot;&gt;スケジューラで&lt;/a&gt;実行されません。</target>
        </trans-unit>
        <trans-unit id="737ad7a4d0393add7f03cd203a8047bab096ef18" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;delaySubscription&lt;/code&gt; does not by default run on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;delaySubscription&lt;/code&gt; のこのバリアントは、デフォルトでは特定の&lt;a href=&quot;../scheduler&quot;&gt;スケジューラで&lt;/a&gt;実行されません。</target>
        </trans-unit>
        <trans-unit id="e6803b366342fa051633884e5aa522cd6078903e" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;sample&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">この &lt;code&gt;sample&lt;/code&gt; バリアントは、デフォルトでは特定の&lt;a href=&quot;../scheduler&quot;&gt;スケジューラで&lt;/a&gt;動作しません。</target>
        </trans-unit>
        <trans-unit id="cf012d47d4bc079503c714e892ebcb4fd79c0201" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;sample&lt;/code&gt; operates by default on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can optionally pass in a Scheduler of your choosing as a third parameter.</source>
          <target state="translated">この &lt;code&gt;sample&lt;/code&gt; バリアントは、デフォルトでは &lt;code&gt;computation&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;スケジューラ&lt;/a&gt;で動作しますが、オプションで、選択したスケジューラを3番目のパラメータとして渡すことができます。</target>
        </trans-unit>
        <trans-unit id="409de3ece48bb2e6d1feb6d3bcfc772fcf41dff8" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;skip&lt;/code&gt; by default operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you may also pass in a Scheduler of your choosing as an optional third parameter.</source>
          <target state="translated">この &lt;code&gt;skip&lt;/code&gt; 変形はデフォルトで &lt;code&gt;computation&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;スケジューラ&lt;/a&gt;で動作しますが、オプションの3番目のパラメータとして、選択したスケジューラを渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="e994cf05c6f2a358611ec5ee6d239a28c7c8c490" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;skip&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">このバリアントの &lt;code&gt;skip&lt;/code&gt; は、デフォルトでは特定の&lt;a href=&quot;../scheduler&quot;&gt;スケジューラで&lt;/a&gt;動作しません。</target>
        </trans-unit>
        <trans-unit id="d44643f63e5b34f4e84daa5e287555095a653012" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;skipLast&lt;/code&gt; by default operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you may also pass in a Scheduler of your choosing as an optional third parameter.</source>
          <target state="translated">この &lt;code&gt;skipLast&lt;/code&gt; のバリアントは、デフォルトでは &lt;code&gt;computation&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;スケジューラ&lt;/a&gt;で動作しますが、オプションの3番目のパラメータとして、選択したスケジューラを渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="653a339a6c160863b57c50e0518e6c234f4a2fbd" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;skipLast&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;skipLast&lt;/code&gt; のこのバリアントは、デフォルトでは特定の&lt;a href=&quot;../scheduler&quot;&gt;スケジューラで&lt;/a&gt;動作しません。</target>
        </trans-unit>
        <trans-unit id="a92f18fffbf6ac36d3ae397e2077eac1256c5a95" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;sliding&lt;/code&gt; opens a window whenever it observes the &lt;code&gt;openings&lt;/code&gt; Observable emit an &lt;code&gt;Opening&lt;/code&gt; object and at the same time calls &lt;code&gt;closings&lt;/code&gt; to generate a closing Observable associated with that window. When that closing Observable emits an item, &lt;code&gt;sliding&lt;/code&gt; closes that window.</source>
          <target state="translated">この変異体 &lt;code&gt;sliding&lt;/code&gt; 、それが観察するたびに窓を開く &lt;code&gt;openings&lt;/code&gt; 観測EMIT &lt;code&gt;Opening&lt;/code&gt; オブジェクトを同時に呼び出す &lt;code&gt;closings&lt;/code&gt; そのウィンドウに関連付けられている閉鎖観測を生成するために。その閉じるObservableがアイテムを放出するとき、 &lt;code&gt;sliding&lt;/code&gt; とそのウィンドウが閉じます。</target>
        </trans-unit>
        <trans-unit id="9d7114d84069bab442e1a2baecd16659f4731291" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;sliding&lt;/code&gt; opens its first window immediately, and thereafter opens a new window every &lt;code&gt;timeshift&lt;/code&gt; period of time (in the form of a &lt;code&gt;Duration&lt;/code&gt; object, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;). It closes a currently open window after &lt;code&gt;timespan&lt;/code&gt; period of time has passed since that window was opened or once &lt;code&gt;count&lt;/code&gt; items have been emitted on that window. It will also close any currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable.</source>
          <target state="translated">この &lt;code&gt;sliding&lt;/code&gt; バリアントは、最初のウィンドウをすぐに開き、その後、 &lt;code&gt;timeshift&lt;/code&gt; 期間ごとに（ &lt;code&gt;Duration&lt;/code&gt; オブジェクトの形式で、オプションで特定の&lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; で&lt;/a&gt;）新しいウィンドウを開きます。そのウィンドウが開かれてから &lt;code&gt;timespan&lt;/code&gt; 期間が経過した後、またはそのウィンドウで &lt;code&gt;count&lt;/code&gt; 個のアイテムが放出されると、現在開いているウィンドウを閉じます。また、ソースObservableから &lt;code&gt;onCompleted&lt;/code&gt; または &lt;code&gt;onError&lt;/code&gt; 通知を受け取った場合、現在開いているウィンドウをすべて閉じます。</target>
        </trans-unit>
        <trans-unit id="48c41e41d48a655cf8b2b53aa6dc1febc83b8551" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;sliding&lt;/code&gt; opens its first window immediately, and thereafter opens a new window every &lt;code&gt;timeshift&lt;/code&gt; period of time (in the form of a &lt;code&gt;Duration&lt;/code&gt; object, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;). It closes a currently open window after &lt;code&gt;timespan&lt;/code&gt; period of time has passed since that window was opened. It will also close any currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable.</source>
          <target state="translated">この &lt;code&gt;sliding&lt;/code&gt; バリアントは、最初のウィンドウをすぐに開き、その後、 &lt;code&gt;timeshift&lt;/code&gt; 期間ごとに（ &lt;code&gt;Duration&lt;/code&gt; オブジェクトの形式で、オプションで特定の&lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; で&lt;/a&gt;）新しいウィンドウを開きます。ウィンドウが開いてから &lt;code&gt;timespan&lt;/code&gt; 期間が経過すると、現在開いているウィンドウを閉じます。また、ソースObservableから &lt;code&gt;onCompleted&lt;/code&gt; または &lt;code&gt;onError&lt;/code&gt; 通知を受け取った場合、現在開いているウィンドウをすべて閉じます。</target>
        </trans-unit>
        <trans-unit id="7c928da076f93edde2602acc469e63d58409880b" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;sliding&lt;/code&gt; opens its first window immediately. It opens a new window beginning with every &lt;code&gt;skip&lt;/code&gt; item from the source Observable (so, for example, if &lt;code&gt;skip&lt;/code&gt; is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted &lt;code&gt;count&lt;/code&gt; items or if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. If &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; then this behaves the same as &lt;code&gt;tumbling(count)&lt;/code&gt;; if &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; this will emit windows that overlap by &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; items; if &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; this will emit windows that drop &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; items from the source Observable between every window.</source>
          <target state="translated">&lt;code&gt;sliding&lt;/code&gt; このバリアントは、最初のウィンドウをすぐに開きます。ソースのObservableからのすべての &lt;code&gt;skip&lt;/code&gt; アイテムで始まる新しいウィンドウを開きます（たとえば、 &lt;code&gt;skip&lt;/code&gt; が3の場合、3つおきのアイテムで始まる新しいウィンドウを開きます）。ウィンドウが &lt;code&gt;count&lt;/code&gt; 個のアイテムを &lt;code&gt;onCompleted&lt;/code&gt; たとき、またはソースObservableからonCompletedまたは &lt;code&gt;onError&lt;/code&gt; 通知を受け取ったときに、各ウィンドウを閉じます。 &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; 場合、これは &lt;code&gt;tumbling(count)&lt;/code&gt; と同じように動作します。 &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; 場合、これはcountで重複するウィンドウを放出し &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; アイテムをスキップします。 &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; 場合これにより、すべてのウィンドウ間で、ソースObservableから &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; アイテムをドロップするウィンドウが放出されます。</target>
        </trans-unit>
        <trans-unit id="89dff3742ba07b7efcc661354ebd2e40382e8a0b" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;take&lt;/code&gt; by default operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you may also pass in a Scheduler of your choosing as an optional third parameter.</source>
          <target state="translated">この &lt;code&gt;take&lt;/code&gt; バリアントはデフォルトで &lt;code&gt;computation&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;スケジューラ&lt;/a&gt;で動作しますが、オプションの3番目のパラメータとして選択したスケジューラを渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="c4faaa677832834fcac1002f1aa24a6e5a6b22a9" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;take&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">このバリエーションの &lt;code&gt;take&lt;/code&gt; は、デフォルトでは特定の&lt;a href=&quot;../scheduler&quot;&gt;スケジューラで&lt;/a&gt;動作しません。</target>
        </trans-unit>
        <trans-unit id="657acbff045486dbea7d27744af10d6c32942c62" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;takeLast&lt;/code&gt; by default operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you may also pass in a Scheduler of your choosing as an optional fourth parameter.</source>
          <target state="translated">&lt;code&gt;takeLast&lt;/code&gt; のこのバリアントは、デフォルトでは &lt;code&gt;computation&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;スケジューラ&lt;/a&gt;で動作しますが、オプションの4番目のパラメータとして選択したスケジューラを渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="72f2d252be7ba01ae12dd933d1af12d7f39d6950" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;takeLast&lt;/code&gt; by default operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you may also pass in a Scheduler of your choosing as an optional third parameter.</source>
          <target state="translated">&lt;code&gt;takeLast&lt;/code&gt; のこのバリアントは、デフォルトでは &lt;code&gt;computation&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;スケジューラ&lt;/a&gt;で動作しますが、オプションの3番目のパラメータとして、選択したスケジューラを渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="042c56433de6cca61a28e4c7ce8ff88898502335" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;takeLast&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;takeLast&lt;/code&gt; のこのバリアントは、デフォルトでは特定の&lt;a href=&quot;../scheduler&quot;&gt;スケジューラで&lt;/a&gt;動作しません。</target>
        </trans-unit>
        <trans-unit id="dcedede039a8ce96e34904dd498d9372ef230b55" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;timeout&lt;/code&gt; by default runs on the &lt;code&gt;immediate&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">この &lt;code&gt;timeout&lt;/code&gt; バリアントは、デフォルトでは &lt;code&gt;immediate&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;スケジューラで&lt;/a&gt;実行されます。</target>
        </trans-unit>
        <trans-unit id="e6e86fc9829ce8349d40eba57712fb2a0d949a58" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;tumbling&lt;/code&gt; opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable.</source>
          <target state="translated">この &lt;code&gt;tumbling&lt;/code&gt; 変種は、最初のウィンドウをすぐに開きます。現在開いているウィンドウを閉じ、現在のウィンドウが &lt;code&gt;count&lt;/code&gt; 個のアイテムを放出した場合は、すぐに新しいウィンドウを開きます。また、ソースObservableから &lt;code&gt;onCompleted&lt;/code&gt; または &lt;code&gt;onError&lt;/code&gt; 通知を受け取った場合、現在開いているウィンドウを閉じます。</target>
        </trans-unit>
        <trans-unit id="6398043bbc04304d7192b07e90caf700ab6ec7c2" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;tumbling&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; period of time (a &lt;code&gt;Duration&lt;/code&gt;, optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;) or whenever the currently open window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable.</source>
          <target state="translated">この &lt;code&gt;tumbling&lt;/code&gt; 変種は、最初のウィンドウをすぐに開きます。現在開いているウィンドウを閉じ、 &lt;code&gt;timespan&lt;/code&gt; 期間ごとに別のウィンドウを開きます（ &lt;code&gt;Duration&lt;/code&gt; 、オプションで特定の&lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; で&lt;/a&gt;測定されます）、または現在開いているウィンドウが &lt;code&gt;count&lt;/code&gt; 個のアイテムを発行したときはいつでも。また、ソースObservableから &lt;code&gt;onCompleted&lt;/code&gt; または &lt;code&gt;onError&lt;/code&gt; 通知を受け取った場合、現在開いているウィンドウを閉じます。</target>
        </trans-unit>
        <trans-unit id="babbf35991f5d12016aa579a5bae94a4d892870e" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;tumbling&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; period of time (a &lt;code&gt;Duration&lt;/code&gt;, optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;scheduler&lt;/code&gt;&lt;/a&gt;). It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable.</source>
          <target state="translated">この &lt;code&gt;tumbling&lt;/code&gt; 変種は、最初のウィンドウをすぐに開きます。現在開いているウィンドウを閉じ、 &lt;code&gt;timespan&lt;/code&gt; 期間ごとに別のウィンドウを開きます（ &lt;code&gt;Duration&lt;/code&gt; 、オプションで特定の&lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;scheduler&lt;/code&gt; &lt;/a&gt;測定されます）。また、ソースObservableから &lt;code&gt;onCompleted&lt;/code&gt; または &lt;code&gt;onError&lt;/code&gt; 通知を受け取った場合、現在開いているウィンドウを閉じます。</target>
        </trans-unit>
        <trans-unit id="4eb801fd5fc446e3c5fb9debba43462e7277a734" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;tumbling&lt;/code&gt; takes a second Observable as a parameter. Whenever this second Observable emits an item, &lt;code&gt;tumbling&lt;/code&gt; closes the current Observable window (if any) and opens a new one.</source>
          <target state="translated">この &lt;code&gt;tumbling&lt;/code&gt; バリアントは、パラメーターとして2番目のObservableを取ります。この2番目のObservableがアイテムを放出するたびに、 &lt;code&gt;tumbling&lt;/code&gt; は現在のObservableウィンドウ（存在する場合）を閉じ、新しいウィンドウを開きます。</target>
        </trans-unit>
        <trans-unit id="5f0586c409a4780239731e2c6e0bc0ef9a26ea29" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens a window whenever it observes the &lt;code&gt;windowOpenings&lt;/code&gt; Observable emit an &lt;code&gt;Opening&lt;/code&gt; object and at the same time calls &lt;code&gt;closingSelector&lt;/code&gt; to generate a closing Observable associated with that window. When that closing Observable emits an object, &lt;code&gt;window&lt;/code&gt; closes that window. Since the closing of currently open windows and the opening of new windows are activities that are regulated by independent Observables, this variant of &lt;code&gt;window&lt;/code&gt; may create windows that overlap (duplicating items from the source Observable) or that leave gaps (discarding items from the source Observable).</source>
          <target state="translated">この &lt;code&gt;window&lt;/code&gt; バリアントは、 &lt;code&gt;windowOpenings&lt;/code&gt; Observableが &lt;code&gt;Opening&lt;/code&gt; オブジェクトを発行するのを観察するたびにウィンドウを開き、同時に &lt;code&gt;closingSelector&lt;/code&gt; を呼び出して、そのウィンドウに関連付けられた閉じるObservableを生成します。その閉じるObservableがオブジェクトを放出すると、 &lt;code&gt;window&lt;/code&gt; はそのウィンドウを閉じます。現在開いているウィンドウを閉じることと新しいウィンドウを開くことは、独立したObservableによって規制されるアクティビティであるため、この &lt;code&gt;window&lt;/code&gt; バリアントは、オーバーラップするウィンドウ（ソースObservableからのアイテムの複製）またはギャップを残すウィンドウ（ソースObservableからのアイテムの破棄）を作成する場合があります）。</target>
        </trans-unit>
        <trans-unit id="91f89b25111f858aab5cff61e3d31bded1300441" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens a window whenever it observes the &lt;code&gt;window_openings&lt;/code&gt; Observable emit an item, and at the same time calls &lt;code&gt;closing_selector&lt;/code&gt; to generate a closing Observable associated with that window. When that closing Observable emits an object, &lt;code&gt;window&lt;/code&gt; closes that window. Since the closing of currently open windows and the opening of new windows are activities that are regulated by independent Observables, this variant of &lt;code&gt;window&lt;/code&gt; may create windows that overlap (duplicating items from the source Observable) or that leave gaps (discarding items from the source Observable).</source>
          <target state="translated">この &lt;code&gt;window&lt;/code&gt; バリアントは、 &lt;code&gt;window_openings&lt;/code&gt; Observableがアイテムを &lt;code&gt;closing_selector&lt;/code&gt; するのを観察するたびにウィンドウを開き、同時にcloseing_selectorを呼び出して、そのウィンドウに関連付けられた閉じるObservableを生成します。その閉じるObservableがオブジェクトを放出すると、 &lt;code&gt;window&lt;/code&gt; はそのウィンドウを閉じます。現在開いているウィンドウを閉じることと新しいウィンドウを開くことは、独立したObservableによって規制されるアクティビティであるため、この &lt;code&gt;window&lt;/code&gt; バリアントは、オーバーラップするウィンドウ（ソースObservableからのアイテムの複製）またはギャップを残すウィンドウ（ソースObservableからのアイテムの破棄）を作成する場合があります）。</target>
        </trans-unit>
        <trans-unit id="5802a2f459856c9c009c204a82bf912f067a1d03" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens its first window immediately and calls the &lt;code&gt;closing_selector&lt;/code&gt; function to obtain a second Observable. When this second Observable emits an item, &lt;code&gt;window&lt;/code&gt; closes the currently open window, immediately opens a new one, and again calls the &lt;code&gt;closing_selector&lt;/code&gt; function to obtain a fresh Observable. It repeats this process until the source Observable terminates. In this way, this variant of &lt;code&gt;window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">この &lt;code&gt;window&lt;/code&gt; バリアントは、最初のウィンドウをすぐに開き、 &lt;code&gt;closing_selector&lt;/code&gt; 関数を呼び出して2番目のObservableを取得します。この2番目のObservableがアイテムを &lt;code&gt;closing_selector&lt;/code&gt; すると、 &lt;code&gt;window&lt;/code&gt; は現在開いているウィンドウを閉じ、すぐに新しいウィンドウを開き、再びcloseing_selector関数を呼び出して新しいObservableを取得します。ソースObservableが終了するまで、このプロセスを繰り返します。このようにして、この &lt;code&gt;window&lt;/code&gt; バリアントは、一連の重なり合わないウィンドウを放出します。このウィンドウの集団的な放出は、ソースObservableの放出と1対1で対応します。</target>
        </trans-unit>
        <trans-unit id="60b2240495a83527d8abfb8bc8f1f606ce11082c" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens its first window immediately, and thereafter opens a new window every &lt;code&gt;timeshift&lt;/code&gt; period of time (measured in &lt;code&gt;unit&lt;/code&gt;, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;). It closes a currently open window after &lt;code&gt;timespan&lt;/code&gt; period of time has passed since that window was opened. It will also close any currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. Depending on how you set &lt;code&gt;timespan&lt;/code&gt; and &lt;code&gt;timeshift&lt;/code&gt; the windows that result from this operation may overlap or may have gaps.</source>
          <target state="translated">この &lt;code&gt;window&lt;/code&gt; バリアントは、最初のウィンドウをすぐに開き、その後、 &lt;code&gt;timeshift&lt;/code&gt; 期間ごとに新しいウィンドウを開きます（ &lt;code&gt;unit&lt;/code&gt; で測定され、オプションで特定の&lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; で&lt;/a&gt;測定されます）。ウィンドウが開いてから &lt;code&gt;timespan&lt;/code&gt; 期間が経過すると、現在開いているウィンドウを閉じます。また、ソースObservableから &lt;code&gt;onCompleted&lt;/code&gt; または &lt;code&gt;onError&lt;/code&gt; 通知を受け取った場合、現在開いているウィンドウをすべて閉じます。 &lt;code&gt;timespan&lt;/code&gt; と &lt;code&gt;timeshift&lt;/code&gt; の設定方法によっては、この操作の結果であるウィンドウが重複したり、ギャップが生じたりする場合があります。</target>
        </trans-unit>
        <trans-unit id="98af2e59befb4b606ae4a25fd5855154e10487fc" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens its first window immediately. It closes the currently open window and immediately opens a new one each time it observes an object emitted by the Observable that is returned from &lt;code&gt;closingSelector&lt;/code&gt;. In this way, this variant of &lt;code&gt;window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">この &lt;code&gt;window&lt;/code&gt; バリアントは、最初のウィンドウをすぐに開きます。現在開いているウィンドウを閉じ、 &lt;code&gt;closingSelector&lt;/code&gt; から返されたObservableによって発行されたオブジェクトを監視するたびに、新しいウィンドウをすぐに開きます。このようにして、この &lt;code&gt;window&lt;/code&gt; バリアントは、一連の重なり合わないウィンドウを放出します。このウィンドウの集団的な放出は、ソースObservableの放出と1対1で対応します。</target>
        </trans-unit>
        <trans-unit id="4ef7ab0b963fc5b8b8684a5afae1268e9e03a08d" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">この &lt;code&gt;window&lt;/code&gt; バリアントは、最初のウィンドウをすぐに開きます。現在開いているウィンドウを閉じ、現在のウィンドウが &lt;code&gt;count&lt;/code&gt; 個のアイテムを放出した場合は、すぐに新しいウィンドウを開きます。また、ソースObservableから &lt;code&gt;onCompleted&lt;/code&gt; または &lt;code&gt;onError&lt;/code&gt; 通知を受け取った場合、現在開いているウィンドウを閉じます。この &lt;code&gt;window&lt;/code&gt; バリアントは、一連の重なり合わないウィンドウを放出します。そのウィンドウの集合的な放出は、ソースObservableの放出と1対1で対応します。</target>
        </trans-unit>
        <trans-unit id="84222676d0cfade4ca7a8b88acdc55ea8a380067" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; period of time (measured in &lt;code&gt;unit&lt;/code&gt;, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;) or whenever the currently open window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">この &lt;code&gt;window&lt;/code&gt; バリアントは、最初のウィンドウをすぐに開きます。これは、現在開いているウィンドウを閉じて、別の毎開き &lt;code&gt;timespan&lt;/code&gt; の時間（で測定 &lt;code&gt;unit&lt;/code&gt; 、および必要に応じて特定のに&lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt;）または現在開いているウィンドウは、放出されたときはいつでも &lt;code&gt;count&lt;/code&gt; アイテムを。また、ソースObservableから &lt;code&gt;onCompleted&lt;/code&gt; または &lt;code&gt;onError&lt;/code&gt; 通知を受け取った場合、現在開いているウィンドウを閉じます。この &lt;code&gt;window&lt;/code&gt; バリアントは、一連の重なり合わないウィンドウを放出します。そのウィンドウの集合的な放出は、ソースObservableの放出と1対1で対応します。</target>
        </trans-unit>
        <trans-unit id="f715198c62a7d5a5035a9d81b75054eaeb4449c4" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; period of time (measured in &lt;code&gt;unit&lt;/code&gt;, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;). It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">この &lt;code&gt;window&lt;/code&gt; バリアントは、最初のウィンドウをすぐに開きます。現在開いているウィンドウを閉じ、 &lt;code&gt;timespan&lt;/code&gt; 期間ごとに別のウィンドウを開きます（ &lt;code&gt;unit&lt;/code&gt; で測定され、オプションで特定の&lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt;測定されます）。また、ソースObservableから &lt;code&gt;onCompleted&lt;/code&gt; または &lt;code&gt;onError&lt;/code&gt; 通知を受け取った場合、現在開いているウィンドウを閉じます。この &lt;code&gt;window&lt;/code&gt; バリアントは、一連の重なり合わないウィンドウを放出します。そのウィンドウの集合的な放出は、ソースObservableの放出と1対1で対応します。</target>
        </trans-unit>
        <trans-unit id="fe556e801e961820cf9915aae7c855117324579e" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens its first window immediately. It opens a new window beginning with every &lt;code&gt;skip&lt;/code&gt; item from the source Observable (so, for example, if &lt;code&gt;skip&lt;/code&gt; is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted &lt;code&gt;count&lt;/code&gt; items or if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. If &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; then this behaves the same as &lt;code&gt;window(source,&amp;nbsp;count)&lt;/code&gt;; if &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; this will emit windows that overlap by &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; items; if &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; this will emit windows that drop &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; items from the source Observable between every window.</source>
          <target state="translated">この &lt;code&gt;window&lt;/code&gt; バリアントは、最初のウィンドウをすぐに開きます。ソースのObservableからのすべての &lt;code&gt;skip&lt;/code&gt; アイテムで始まる新しいウィンドウを開きます（たとえば、 &lt;code&gt;skip&lt;/code&gt; が3の場合、3つおきのアイテムで始まる新しいウィンドウを開きます）。ウィンドウが &lt;code&gt;count&lt;/code&gt; 個のアイテムを &lt;code&gt;onCompleted&lt;/code&gt; たとき、またはソースObservableからonCompletedまたは &lt;code&gt;onError&lt;/code&gt; 通知を受け取ったときに、各ウィンドウを閉じます。 &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; 場合、これは &lt;code&gt;window(source,&amp;nbsp;count)&lt;/code&gt; と同じように動作します。 &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; 場合、これはcountで重複するウィンドウを放出し &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; アイテムをスキップします。 &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; 場合これにより、すべてのウィンドウ間で、ソースObservableから &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; アイテムをドロップするウィンドウが放出されます。</target>
        </trans-unit>
        <trans-unit id="4321575a1449c2aff82db3fafcef6ccd5f15b626" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; takes a second Observable as a parameter. Whenever this second Observable emits an item, &lt;code&gt;window&lt;/code&gt; closes the current Observable window (if any) and opens a new one.</source>
          <target state="translated">この &lt;code&gt;window&lt;/code&gt; バリアントは、パラメーターとして2番目のObservableを取ります。この2番目のObservableがアイテムを放出するたびに、 &lt;code&gt;window&lt;/code&gt; は現在のObservableウィンドウ（存在する場合）を閉じ、新しいウィンドウを開きます。</target>
        </trans-unit>
        <trans-unit id="bae85c1387e45e3514474e9f22e4f754bb1fb7fa" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;windowWithCount&lt;/code&gt; opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;windowWithCount&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">この &lt;code&gt;windowWithCount&lt;/code&gt; のバリアントは、最初のウィンドウをすぐに開きます。現在開いているウィンドウを閉じ、現在のウィンドウが &lt;code&gt;count&lt;/code&gt; 個のアイテムを放出した場合は、すぐに新しいウィンドウを開きます。また、ソースObservableから &lt;code&gt;onCompleted&lt;/code&gt; または &lt;code&gt;onError&lt;/code&gt; 通知を受け取った場合、現在開いているウィンドウを閉じます。この &lt;code&gt;windowWithCount&lt;/code&gt; のバリ​​アントは、一連の重なり合わないウィンドウを放出します。このウィンドウの集合的な放出は、ソースObservableの放出と1対1で対応します。</target>
        </trans-unit>
        <trans-unit id="b0481e8b340ae9dd68d446d8a287e4351ba18f18" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;windowWithCount&lt;/code&gt; opens its first window immediately. It opens a new window beginning with every &lt;code&gt;skip&lt;/code&gt; item from the source Observable (so, for example, if &lt;code&gt;skip&lt;/code&gt; is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted &lt;code&gt;count&lt;/code&gt; items or if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. If &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; then this behaves the same as &lt;code&gt;windowWithCount(count)&lt;/code&gt;; if &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; this will emit windows that overlap by &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; items; if &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; this will emit windows that drop &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; items from the source Observable between every window.</source>
          <target state="translated">この &lt;code&gt;windowWithCount&lt;/code&gt; のバリアントは、最初のウィンドウをすぐに開きます。ソースのObservableからのすべての &lt;code&gt;skip&lt;/code&gt; アイテムで始まる新しいウィンドウを開きます（たとえば、 &lt;code&gt;skip&lt;/code&gt; が3の場合、3つおきのアイテムで始まる新しいウィンドウを開きます）。ウィンドウが &lt;code&gt;count&lt;/code&gt; 個のアイテムを &lt;code&gt;onCompleted&lt;/code&gt; たとき、またはソースObservableからonCompletedまたは &lt;code&gt;onError&lt;/code&gt; 通知を受け取ったときに、各ウィンドウを閉じます。 &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; 場合、これは &lt;code&gt;windowWithCount(count)&lt;/code&gt; と同じように動作します。 &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; 場合、これはcountで重複するウィンドウを放出し &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; アイテムをスキップします。 &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; 場合これにより、すべてのウィンドウ間で、ソースObservableから &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; アイテムをドロップするウィンドウが放出されます。</target>
        </trans-unit>
        <trans-unit id="79476df52b04afcb45a97f5d9a45a69f194d05b3" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;windowWithTime&lt;/code&gt; opens its first window immediately, and thereafter opens a new window every &lt;code&gt;timeshift&lt;/code&gt; milliseconds (optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;). It closes a currently open window after &lt;code&gt;timespan&lt;/code&gt; milliseconds have passed since that window was opened. It will also close any currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. Depending on how you set &lt;code&gt;timespan&lt;/code&gt; and &lt;code&gt;timeshift&lt;/code&gt; the windows that result from this operation may overlap or may have gaps.</source>
          <target state="translated">この &lt;code&gt;windowWithTime&lt;/code&gt; のバリアントは、最初のウィンドウをすぐに開き、その後、 &lt;code&gt;timeshift&lt;/code&gt; ミリ秒ごとに新しいウィンドウを開きます（オプションで特定の&lt;a href=&quot;../scheduler&quot;&gt;Schedulerで&lt;/a&gt;測定されます）。ウィンドウが開いてから &lt;code&gt;timespan&lt;/code&gt; ミリ秒が経過すると、現在開いているウィンドウを閉じます。また、ソースObservableから &lt;code&gt;onCompleted&lt;/code&gt; または &lt;code&gt;onError&lt;/code&gt; 通知を受け取った場合、現在開いているウィンドウをすべて閉じます。 &lt;code&gt;timespan&lt;/code&gt; と &lt;code&gt;timeshift&lt;/code&gt; の設定方法によっては、この操作の結果であるウィンドウが重複したり、ギャップが生じたりすることがあります。</target>
        </trans-unit>
        <trans-unit id="7f022bb9e774776f440984488040ff5dc6603251" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;windowWithTime&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; period of time (in milliseconds, optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;). It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;windowWithTime&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">この &lt;code&gt;windowWithTime&lt;/code&gt; のバリアントは、最初のウィンドウをすぐに開きます。現在開いているウィンドウを閉じ、 &lt;code&gt;timespan&lt;/code&gt; 期間ごとに別のウィンドウを開きます（ミリ秒単位、オプションで特定の&lt;a href=&quot;../scheduler&quot;&gt;Schedulerで&lt;/a&gt;測定）。また、ソースObservableから &lt;code&gt;onCompleted&lt;/code&gt; または &lt;code&gt;onError&lt;/code&gt; 通知を受け取った場合、現在開いているウィンドウを閉じます。この &lt;code&gt;windowWithTime&lt;/code&gt; のバリアントは、一連の重なり合わないウィンドウを放出します。このウィンドウの集団的な放出は、ソースObservableの放出と1対1で対応します。</target>
        </trans-unit>
        <trans-unit id="e39142cb9f93a3df83e5acda2657507e2deb12aa" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window_with_count&lt;/code&gt; opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window_with_count&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">この &lt;code&gt;window_with_count&lt;/code&gt; のバリアントは、最初のウィンドウをすぐに開きます。現在開いているウィンドウを閉じ、現在のウィンドウが &lt;code&gt;count&lt;/code&gt; 個のアイテムを放出した場合は、すぐに新しいウィンドウを開きます。また、ソースObservableから &lt;code&gt;onCompleted&lt;/code&gt; または &lt;code&gt;onError&lt;/code&gt; 通知を受け取った場合、現在開いているウィンドウを閉じます。この &lt;code&gt;window_with_count&lt;/code&gt; のバリ​​アントは、一連の重なり合わないウィンドウを放出します。このウィンドウの集合的な放出は、ソースObservableの放出と1対1で対応します。</target>
        </trans-unit>
        <trans-unit id="25854b53587cc3c28ca12fd6dd37ae3bdb7e4600" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window_with_count&lt;/code&gt; opens its first window immediately. It opens a new window beginning with every &lt;code&gt;skip&lt;/code&gt; item from the source Observable (so, for example, if &lt;code&gt;skip&lt;/code&gt; is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted &lt;code&gt;count&lt;/code&gt; items or if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. If &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; then this behaves the same as &lt;code&gt;window_with_count(count)&lt;/code&gt;; if &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; this will emit windows that overlap by &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; items; if &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; this will emit windows that drop &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; items from the source Observable between every window.</source>
          <target state="translated">この &lt;code&gt;window_with_count&lt;/code&gt; のバリアントは、最初のウィンドウをすぐに開きます。ソースのObservableからのすべての &lt;code&gt;skip&lt;/code&gt; アイテムで始まる新しいウィンドウを開きます（たとえば、 &lt;code&gt;skip&lt;/code&gt; が3の場合、3つおきのアイテムで始まる新しいウィンドウを開きます）。ウィンドウが &lt;code&gt;count&lt;/code&gt; 個のアイテムを &lt;code&gt;onCompleted&lt;/code&gt; たとき、またはソースObservableからonCompletedまたは &lt;code&gt;onError&lt;/code&gt; 通知を受け取ったときに、各ウィンドウを閉じます。 &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; 場合、これは &lt;code&gt;window_with_count(count)&lt;/code&gt; と同じように動作します。 &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; 場合、これはcountで重複するウィンドウを放出し &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; アイテムをスキップします。 &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; 場合これにより、すべてのウィンドウ間で、ソースObservableから &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; アイテムをドロップするウィンドウが放出されます。</target>
        </trans-unit>
        <trans-unit id="cc84f2ccad24fdcfc2f3aff1217a66ac4eb92f9d" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window_with_time&lt;/code&gt; opens its first window immediately. It closes the currently open window after &lt;code&gt;period&lt;/code&gt; amount of time has passed since it was opened, and opens a new window after &lt;code&gt;skip&lt;/code&gt; amount of time has passed since the previous window was opened (both times are Durations, optionally computed by a given Coordination). It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window_with_time&lt;/code&gt; may emit windows that overlap or that have gaps, depending on whether &lt;code&gt;skip&lt;/code&gt; is less than or greater than &lt;code&gt;period&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;window_with_time&lt;/code&gt; のバリアントは、最初のウィンドウをすぐに開きます。開いてから &lt;code&gt;period&lt;/code&gt; 時間が経過すると現在開いているウィンドウを閉じ、前のウィンドウが開いてから &lt;code&gt;skip&lt;/code&gt; 時間が経過すると新しいウィンドウを開きます（両方とも期間であり、オプションで特定の調整によって計算されます）。また、ソースObservableから &lt;code&gt;onCompleted&lt;/code&gt; または &lt;code&gt;onError&lt;/code&gt; 通知を受け取った場合、現在開いているウィンドウを閉じます。この &lt;code&gt;window_with_time&lt;/code&gt; のバリアントは、 &lt;code&gt;skip&lt;/code&gt; が &lt;code&gt;period&lt;/code&gt; よりも短いか大きいかに応じて、オーバーラップしたりギャップのあるウィンドウを出力したりします。</target>
        </trans-unit>
        <trans-unit id="da96fc736c7bbd3922e8cf82442d11cbd4e9db04" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window_with_time&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;period&lt;/code&gt; of time (a Duration, optionally computed by a given Coordination). It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window_with_time&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">この &lt;code&gt;window_with_time&lt;/code&gt; のバリアントは、最初のウィンドウをすぐに開きます。現在開いているウィンドウを閉じ、 &lt;code&gt;period&lt;/code&gt; ごとに別のウィンドウを開きます（期間、任意で特定の調整によって計算されます）。また、ソースObservableから &lt;code&gt;onCompleted&lt;/code&gt; または &lt;code&gt;onError&lt;/code&gt; 通知を受け取った場合、現在開いているウィンドウを閉じます。この &lt;code&gt;window_with_time&lt;/code&gt; のバリアントは、一連の重なり合わないウィンドウを放出します。このウィンドウの集合的な放出は、ソースObservableの放出と1対1で対応します。</target>
        </trans-unit>
        <trans-unit id="98a31bb4d7889c747d26c5c49a2c39000cc2314d" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window_with_time&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; milliseconds (optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;). It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window_with_time&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">この &lt;code&gt;window_with_time&lt;/code&gt; のバリアントは、最初のウィンドウをすぐに開きます。現在開いているウィンドウを閉じ、 &lt;code&gt;timespan&lt;/code&gt; ミリ秒ごとに別のウィンドウを開きます（オプションで特定の&lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; で&lt;/a&gt;測定されます）。また、ソースObservableから &lt;code&gt;onCompleted&lt;/code&gt; または &lt;code&gt;onError&lt;/code&gt; 通知を受け取った場合、現在開いているウィンドウを閉じます。この &lt;code&gt;window_with_time&lt;/code&gt; のバリアントは、一連の重なり合わないウィンドウを放出します。このウィンドウの集合的な放出は、ソースObservableの放出と1対1で対応します。</target>
        </trans-unit>
        <trans-unit id="167c2d5b150d69824425b44c8ee4f720fa8f197f" translate="yes" xml:space="preserve">
          <source>This variant operates by default on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can optionally pass in a Scheduler of your choosing as a third parameter.</source>
          <target state="translated">このバリアントはデフォルトで &lt;code&gt;computation&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;スケジューラ&lt;/a&gt;で動作しますが、オプションで、選択したスケジューラを3番目のパラメータとして渡すことができます。</target>
        </trans-unit>
        <trans-unit id="913db6dde43b42bba235483e6967719c230885b6" translate="yes" xml:space="preserve">
          <source>This, too, has a &lt;a href=&quot;scheduler&quot;&gt;Scheduler&lt;/a&gt;-specific version:</source>
          <target state="translated">これにも、&lt;a href=&quot;scheduler&quot;&gt;スケジューラ&lt;/a&gt;固有のバージョンがあります。</target>
        </trans-unit>
        <trans-unit id="5319f3b89676bc765e966cae99f6cda9b3be1bc1" translate="yes" xml:space="preserve">
          <source>Throw</source>
          <target state="translated">Throw</target>
        </trans-unit>
        <trans-unit id="e0fdbfae633f2d57c9d587ae320cb30eefd7144d" translate="yes" xml:space="preserve">
          <source>Time shifts the observable sequence by dueTime. The relative time intervals between the values are preserved.</source>
          <target state="translated">観測可能なシーケンスを dueTime でタイムシフトします。値の間の相対的な時間間隔は保存されます。</target>
        </trans-unit>
        <trans-unit id="98089835cc8515ca7a14ba6cd9c114f2b93470b4" translate="yes" xml:space="preserve">
          <source>TimeInterval</source>
          <target state="translated">TimeInterval</target>
        </trans-unit>
        <trans-unit id="d4c45de0fe64ac43c72a798c67faaadadfaa1b90" translate="yes" xml:space="preserve">
          <source>Timeout</source>
          <target state="translated">Timeout</target>
        </trans-unit>
        <trans-unit id="c3caddd6872bae63ffdabf37db746583d89bb38d" translate="yes" xml:space="preserve">
          <source>Timeout will cause a Single to abort with an error notification if it does not emit an item in a specified period of time after it is subscribed to. One version allows you to set this time out by means of a number of specified time units:</source>
          <target state="translated">タイムアウトは、シングルが購読してから指定された時間内にアイテムを放出しなかった場合に、エラー通知でアボートさせます。あるバージョンでは、指定された時間単位の数だけこのタイムアウトを設定することができます。</target>
        </trans-unit>
        <trans-unit id="9d9cec22f36fd2bb99d5fe8c4723347bec202ca5" translate="yes" xml:space="preserve">
          <source>Timer</source>
          <target state="translated">Timer</target>
        </trans-unit>
        <trans-unit id="19eabc961735d78f12fc7be906ffcb033853cf85" translate="yes" xml:space="preserve">
          <source>Timestamp</source>
          <target state="translated">Timestamp</target>
        </trans-unit>
        <trans-unit id="ae79ea1e9c6391a9ed83a2e18a031b835feec0c9" translate="yes" xml:space="preserve">
          <source>To</source>
          <target state="translated">To</target>
        </trans-unit>
        <trans-unit id="e81ce27655e65ce085099be185ce85b2137f4e73" translate="yes" xml:space="preserve">
          <source>To filter an Observable so that only its first emission is emitted, use the &lt;code&gt;first&lt;/code&gt; operator with no parameters.</source>
          <target state="translated">最初の放出のみが放出されるようにObservableをフィルタリングするには、パラメーターなしで &lt;code&gt;first&lt;/code&gt; 演算子を使用します。</target>
        </trans-unit>
        <trans-unit id="677b35ca927e319047d1628f637adc41423b0fc2" translate="yes" xml:space="preserve">
          <source>To filter an Observable so that only its last emission is emitted, use the &lt;code&gt;last&lt;/code&gt; operator with no parameters.</source>
          <target state="translated">最後の放出のみが放出されるようにObservableをフィルタリングするには、パラメーターなしで &lt;code&gt;last&lt;/code&gt; 演算子を使用します。</target>
        </trans-unit>
        <trans-unit id="9261d8ddfbd991cfda76aa23a0cd28a0cd4f32c7" translate="yes" xml:space="preserve">
          <source>To retrieve the first emission from a &lt;code&gt;BlockingObservable&lt;/code&gt;, use the &lt;code&gt;first&lt;/code&gt; method with no parameters.</source>
          <target state="translated">&lt;code&gt;BlockingObservable&lt;/code&gt; から最初の放出を取得するには、 &lt;code&gt;first&lt;/code&gt; メソッドをパラメーターなしで使用します。</target>
        </trans-unit>
        <trans-unit id="df8a5a9c1edace12c77d1f92a0f265b88fc37580" translate="yes" xml:space="preserve">
          <source>To retrieve the last emission from a &lt;code&gt;BlockingObservable&lt;/code&gt;, use the &lt;code&gt;last&lt;/code&gt; method with no parameters.</source>
          <target state="translated">&lt;code&gt;BlockingObservable&lt;/code&gt; から最後の放出を取得するには、パラメーターなしで &lt;code&gt;last&lt;/code&gt; メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="e965628b0ee331ec6b34dd39cc3f096b74728b00" translate="yes" xml:space="preserve">
          <source>To schedule recursive calls, you can use &lt;code&gt;schedule&lt;/code&gt; and then &lt;code&gt;schedule(this)&lt;/code&gt; on the Worker object:</source>
          <target state="translated">再帰呼び出しをスケジュールするには、Workerオブジェクトで &lt;code&gt;schedule&lt;/code&gt; を使用してから、 &lt;code&gt;schedule(this)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="1cbffae95212baae30862313515c8962b10bea78" translate="yes" xml:space="preserve">
          <source>To specify on which Scheduler the Observable should invoke its observers&amp;rsquo; &lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onCompleted&lt;/code&gt;, and &lt;code&gt;onError&lt;/code&gt; methods, use the &lt;code&gt;observeOn&lt;/code&gt; operator, passing it the appropriate &lt;code&gt;Scheduler&lt;/code&gt;.</source>
          <target state="translated">Observableがオブザーバーの &lt;code&gt;onNext&lt;/code&gt; 、 &lt;code&gt;onCompleted&lt;/code&gt; 、および &lt;code&gt;onError&lt;/code&gt; メソッドを呼び出す必要があるSchedulerを指定するには、 &lt;code&gt;observeOn&lt;/code&gt; 演算子を使用して、適切な &lt;code&gt;Scheduler&lt;/code&gt; を渡します。</target>
        </trans-unit>
        <trans-unit id="ecf22e1fc7f54c383e5bc0726b6592466baefc6f" translate="yes" xml:space="preserve">
          <source>To specify on which Scheduler the Observable should operate, use the &lt;code&gt;subscribeOn&lt;/code&gt; operator, passing it the appropriate &lt;code&gt;Scheduler&lt;/code&gt;.</source>
          <target state="translated">Observableが動作するスケジューラを指定するには、 &lt;code&gt;subscribeOn&lt;/code&gt; 演算子を使用して、適切な &lt;code&gt;Scheduler&lt;/code&gt; を渡します。</target>
        </trans-unit>
        <trans-unit id="f6f987265c853852ce9a93e90c296aeb2f943f0a" translate="yes" xml:space="preserve">
          <source>To specify which Scheduler observers will use to unsubscribe from an Observable, use the &lt;code&gt;unsubscribeOn&lt;/code&gt; operator, passing it the appropriate &lt;code&gt;Scheduler&lt;/code&gt;.</source>
          <target state="translated">Observableからの退会に使用するSchedulerオブザーバーを指定するには、 &lt;code&gt;unsubscribeOn&lt;/code&gt; 演算子を使用して、適切な &lt;code&gt;Scheduler&lt;/code&gt; を渡します。</target>
        </trans-unit>
        <trans-unit id="3adbd9b7c134b35abb9c049ce0a350bfd10d09c0" translate="yes" xml:space="preserve">
          <source>To turn an Observable into a &lt;code&gt;BlockingObservable&lt;/code&gt; so that you can use these methods, you can use either the &lt;code&gt;Observable.toBlocking&lt;/code&gt; or &lt;code&gt;BlockingObservable.from&lt;/code&gt; methods.</source>
          <target state="translated">Observableを &lt;code&gt;BlockingObservable&lt;/code&gt; に変換してこれらのメソッドを使用できるようにするには、 &lt;code&gt;Observable.toBlocking&lt;/code&gt; または &lt;code&gt;BlockingObservable.from&lt;/code&gt; メソッドのいずれかを使用できます。</target>
        </trans-unit>
        <trans-unit id="07edff8c6ab5d2b6ba73b34c78a1792f548b27e1" translate="yes" xml:space="preserve">
          <source>Transforming</source>
          <target state="translated">Transforming</target>
        </trans-unit>
        <trans-unit id="1dd516e9e95628b37e564d8feed261306c719fd5" translate="yes" xml:space="preserve">
          <source>Transforming Observable Items</source>
          <target state="translated">観測可能な項目の変換</target>
        </trans-unit>
        <trans-unit id="8fb4f0478f90c2349e672d48265339bc5e89dd8a" translate="yes" xml:space="preserve">
          <source>Transforming Observables</source>
          <target state="translated">観測変数の変換</target>
        </trans-unit>
        <trans-unit id="cceb13cc487fca5dfa5ce538df3f2cb18dc1bd3f" translate="yes" xml:space="preserve">
          <source>Transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.</source>
          <target state="translated">観測可能なシーケンスの観測可能なシーケンスを、最新の観測可能なシーケンスからのみ値を生成する観測可能なシーケンスに変換します。</target>
        </trans-unit>
        <trans-unit id="29c0474e6e05b94d2f3f5aceab38058a341249ef" translate="yes" xml:space="preserve">
          <source>Under development, but not part of the 1.0 release, is the &lt;code&gt;withLatestFrom&lt;/code&gt; operator. It is similar to &lt;code&gt;combineLatest&lt;/code&gt;, but only emits items when the single source Observable emits an item (not when &lt;em&gt;any&lt;/em&gt; of the Observables that are passed to the operator do, as &lt;code&gt;combineLatest&lt;/code&gt; does).</source>
          <target state="translated">1.0リリースの一部ではないが、開発中は &lt;code&gt;withLatestFrom&lt;/code&gt; 演算子です。 &lt;code&gt;combineLatest&lt;/code&gt; に似ていますが、単一のソースObservableがアイテムを発行する場合にのみアイテムを発行します（ &lt;code&gt;combineLatest&lt;/code&gt; ように、オペレーターに渡されるObservableの&lt;em&gt;いずれか&lt;/em&gt;が発行する場合はそうではありません）。</target>
        </trans-unit>
        <trans-unit id="89deecaaba97e73598ad6fd0691e91f89a3e40ac" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;subscribe&lt;/code&gt;, &lt;code&gt;forEach&lt;/code&gt; does not return an object with which you can cancel the subscription. Nor do you have the option of passing a parameter that has this capability. So you should only use this operator if you definitely need to operate on all of the emissions and notifications from the Observable.</source>
          <target state="translated">&lt;code&gt;subscribe&lt;/code&gt; とは異なり、 &lt;code&gt;forEach&lt;/code&gt; は、サブスクリプションをキャンセルできるオブジェクトを返しません。また、この機能を持つパラメーターを渡すオプションもありません。したがって、Observableからのすべての放出と通知を確実に操作する必要がある場合にのみ、この演算子を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="834cc0ee6089e541b395509ba562516bcafa78e2" translate="yes" xml:space="preserve">
          <source>Unsubscribe</source>
          <target state="translated">Unsubscribe</target>
        </trans-unit>
        <trans-unit id="0925f1a577d120b3875b4a1d4b2873a36b77c455" translate="yes" xml:space="preserve">
          <source>Unsubscribing</source>
          <target state="translated">Unsubscribing</target>
        </trans-unit>
        <trans-unit id="2c0b5a028cb5b1c2860888c5875c3ebc0d28e8d6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;length&lt;/code&gt; or &lt;code&gt;size&lt;/code&gt; instead if you want to count &lt;em&gt;all&lt;/em&gt; of the items emitted by the source Observable and emit this count as an Integer, or use &lt;code&gt;longCount&lt;/code&gt; to emit it as a Long.</source>
          <target state="translated">ソースObservableによって放出された&lt;em&gt;すべて&lt;/em&gt;のアイテムをカウントしてこのカウントをIntegerとして放出する場合は、代わりに &lt;code&gt;length&lt;/code&gt; または &lt;code&gt;size&lt;/code&gt; 使用するか、 &lt;code&gt;longCount&lt;/code&gt; を使用してLongとして放出する。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ab50a163272616dc7b8c326c9fbd42175ec215ad" translate="yes" xml:space="preserve">
          <source>Use that variable and its new value to do something useful.</source>
          <target state="translated">その変数とその新しい値を使って、何か便利なことをしましょう。</target>
        </trans-unit>
        <trans-unit id="c25de2e83e9fceeee022a34e378748baf14ac201" translate="yes" xml:space="preserve">
          <source>Using</source>
          <target state="translated">Using</target>
        </trans-unit>
        <trans-unit id="09635283d6617f91ae3f074496d5e16cd86942ea" translate="yes" xml:space="preserve">
          <source>Using Schedulers</source>
          <target state="translated">スケジューラの使用</target>
        </trans-unit>
        <trans-unit id="89189507b2a074e98b2e877227343a6e1f27b3ab" translate="yes" xml:space="preserve">
          <source>Utility</source>
          <target state="translated">Utility</target>
        </trans-unit>
        <trans-unit id="fe106a343476b132e8645607f1656889a1e921e3" translate="yes" xml:space="preserve">
          <source>Utility Operators</source>
          <target state="translated">ユーティリティーオペレータ</target>
        </trans-unit>
        <trans-unit id="fbd4e4db25253ae894d708535b43ea5afe51f6bc" translate="yes" xml:space="preserve">
          <source>Variant of distinct that takes a key selector</source>
          <target state="translated">キーセレクタを取る distinct のバリエーション</target>
        </trans-unit>
        <trans-unit id="7cfbea8206dca5542ac656ab9875b461b78d877f" translate="yes" xml:space="preserve">
          <source>Variant of distinctUntilChanged that takes a key selector and the comparer.</source>
          <target state="translated">キーセレクタとコンパレータを取る distinctUntilChanged のバリアント。</target>
        </trans-unit>
        <trans-unit id="90783bfae1cb49ec27875b8d80bbd99d15acdda2" translate="yes" xml:space="preserve">
          <source>Variants of this variety of the &lt;code&gt;replay&lt;/code&gt; operator permit you to set a maximum buffer size to limit the number of items &lt;code&gt;replay&lt;/code&gt; will buffer and replay to subsequent observers, and/or to establish a moving time window that defines when emitted items become too old to buffer and replay.</source>
          <target state="translated">このさまざまな &lt;code&gt;replay&lt;/code&gt; オペレーターのバリアントを使用すると、最大バッファーサイズを設定して、 &lt;code&gt;replay&lt;/code&gt; によってバッファリングされて後続のオブザーバーに再生されるアイテムの数を制限したり、放出されたアイテムが古すぎてバッファーできない時期を定義する移動時間ウィンドウを確立したりできます。そしてリプレイ。</target>
        </trans-unit>
        <trans-unit id="21a0bc424bfc99e307f7ea1edb0fa1c727459368" translate="yes" xml:space="preserve">
          <source>Varieties of Scheduler</source>
          <target state="translated">スケジューラの種類</target>
        </trans-unit>
        <trans-unit id="9b1873d552d24b69c5f119a53f0dc296aa04f44e" translate="yes" xml:space="preserve">
          <source>Varieties of Subject</source>
          <target state="translated">科目の種類</target>
        </trans-unit>
        <trans-unit id="71cd61da34b267e141ea188fbd6c4c966ad1f835" translate="yes" xml:space="preserve">
          <source>When a cold Observable is multicast (when it is converted into a connectable Observable and its &lt;a href=&quot;connect&quot;&gt;Connect&lt;/a&gt; method is called), it effectively becomes hot and for the purposes of backpressure and flow-control it should be treated as a hot Observable.</source>
          <target state="translated">コールドオブザーバブルがマルチキャストである場合（接続可能なObservableに変換され、その&lt;a href=&quot;connect&quot;&gt;Connect&lt;/a&gt;メソッドが呼び出される場合）、コールドオブザーバブルは事実上高温になり、バックプレッシャーとフロー制御のために、ホットオブザーバブルとして扱われる必要があります。</target>
        </trans-unit>
        <trans-unit id="fb6cd998aa458f9efba7d561e3e8223e5f062816" translate="yes" xml:space="preserve">
          <source>When an Observable issues an OnError or OnComplete notification to its observers, this ends the subscription. Observers do not need to issue an Unsubscribe notification to end subscriptions that are ended by the Observable in this way.</source>
          <target state="translated">Observable が OnError または OnComplete 通知をオブザーバーに発行すると、サブスクリプションが終了します。オブザーバは、この方法でObservableによって終了したサブスクリプションを終了するためにUnsubscribe通知を発行する必要はありません。</target>
        </trans-unit>
        <trans-unit id="940033d88560c950b008fe5ed51335ed9f76e48b" translate="yes" xml:space="preserve">
          <source>When an observer issues an Unsubscribe notification to an Observable, the Observable will attempt to stop issuing notifications to the observer. It is not guaranteed, however, that the Observable will issue &lt;em&gt;no&lt;/em&gt; notifications to the observer after an observer issues it an Unsubscribe notification.</source>
          <target state="translated">オブザーバーがオブザーバーへのサブスクライブ解除通知を発行すると、オブザーバーはオブザーバーへの通知の発行を停止しようとします。ただし、オブザーバーがUnsubscribe通知を発行した後、Observableがオブザーバーに通知を発行し&lt;em&gt;ない&lt;/em&gt;ことは保証されていません。</target>
        </trans-unit>
        <trans-unit id="7279bc1e33b61d9f42b615948eb053e0be2afe08" translate="yes" xml:space="preserve">
          <source>When an observer subscribes to a &lt;code&gt;BehaviorSubject&lt;/code&gt;, it begins by emitting the item most recently emitted by the source Observable (or a seed/default value if none has yet been emitted) and then continues to emit any other items emitted later by the source Observable(s).</source>
          <target state="translated">オブザーバーが &lt;code&gt;BehaviorSubject&lt;/code&gt; をサブスクライブすると、最初に、ソースObservableによって最後に発行されたアイテム（または、まだ発行されていない場合はシード/デフォルト値）を発行し、その後、ソースObservable（ s）。</target>
        </trans-unit>
        <trans-unit id="3e29ec19f330a8a47c44f3b9ef38cc21aace1333" translate="yes" xml:space="preserve">
          <source>When an observer subscribes to the Observable returned from &lt;code&gt;using&lt;/code&gt;, &lt;code&gt;using&lt;/code&gt; will use the Observable factory function to create the Observable the observer will observe, while at the same time using the resource factory function to create whichever resource you have designed it to make. To dispose of the resource, call the &lt;code&gt;dispose&lt;/code&gt; method of the subscription that was returned from the &lt;code&gt;subscribe&lt;/code&gt; call you used to subscribe an observer to the Observable that you modified with &lt;code&gt;using&lt;/code&gt;.</source>
          <target state="translated">オブザーバーが &lt;code&gt;using&lt;/code&gt; から返されたObservableをサブスクライブすると、 &lt;code&gt;using&lt;/code&gt; はObservableファクトリー関数を使用してオブザーバーが監視するObservableを作成し、同時にリソースファクトリー関数を使用して、作成するように設計したリソースを作成します。リソースを処分するには、呼び出し &lt;code&gt;dispose&lt;/code&gt; から返されたサブスクリプションの方法を &lt;code&gt;subscribe&lt;/code&gt; 呼び出して、あなたがして修正することを観察可能にオブザーバー購読するために使用 &lt;code&gt;using&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ddf0d21d9cf8853a081099040075ed5d10c739ad" translate="yes" xml:space="preserve">
          <source>When an observer subscribes to the Observable returned from &lt;code&gt;using&lt;/code&gt;, &lt;code&gt;using&lt;/code&gt; will use the Observable factory function to create the Observable the observer will observe, while at the same time using the resource factory function to create whichever resource you have designed it to make. When the observer unsubscribes from the Observable, or when the Observable terminates (normally or with an error), &lt;code&gt;using&lt;/code&gt; will call the third function to dispose of the resource it created.</source>
          <target state="translated">オブザーバーが &lt;code&gt;using&lt;/code&gt; から返されたObservableをサブスクライブすると、 &lt;code&gt;using&lt;/code&gt; はObservableファクトリー関数を使用してオブザーバーが監視するObservableを作成し、同時にリソースファクトリー関数を使用して、作成するように設計したリソースを作成します。場合観測から観察者登録解除、または場合観測終了（正常または異常を有する）、 &lt;code&gt;using&lt;/code&gt; それが作成したリソースを処分する第三の関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="ec187d7479d038f4317479a80baaa369b7917df2" translate="yes" xml:space="preserve">
          <source>When does an Observable begin emitting its sequence of items? It depends on the Observable. A &amp;ldquo;hot&amp;rdquo; Observable may begin emitting items as soon as it is created, and so any observer who later subscribes to that Observable may start observing the sequence somewhere in the middle. A &amp;ldquo;cold&amp;rdquo; Observable, on the other hand, waits until an observer subscribes to it before it begins to emit items, and so such an observer is guaranteed to see the whole sequence from the beginning.</source>
          <target state="translated">Observableはいつアイテムのシーケンスを出力し始めますか？それはObservableに依存します。 「ホット」なObservableは、アイテムが作成されるとすぐにアイテムの放出を開始する可能性があるため、後でそのObservableにサブスクライブするオブザーバーは、シーケンスの中央のどこかで観察を開始できます。一方、「コールド」のObservableは、オブザーバーがアイテムを発行し始める前にサブスクライブするまで待機するため、そのようなオブザーバーはシーケンス全体を最初から確認できます。</target>
        </trans-unit>
        <trans-unit id="d1411f6748866de181ec109dedca11bfcb102f81" translate="yes" xml:space="preserve">
          <source>When it subscribes to the source Observable, &lt;code&gt;Buffer(bufferClosingSelector)&lt;/code&gt; begins to collect its emissions into an &lt;code&gt;IList&lt;/code&gt;, and it also calls &lt;code&gt;bufferClosingSelector&lt;/code&gt; to generate a second Observable. When this second Observable emits an &lt;code&gt;TBufferClosing&lt;/code&gt; object, &lt;code&gt;Buffer&lt;/code&gt; emits the current &lt;code&gt;IList&lt;/code&gt; and repeats this process: beginning a new &lt;code&gt;IList&lt;/code&gt; and calling &lt;code&gt;bufferClosingSelector&lt;/code&gt; to create a new Observable to monitor. It will do this until the source Observable terminates.</source>
          <target state="translated">ソースのObservableをサブスクライブすると、 &lt;code&gt;Buffer(bufferClosingSelector)&lt;/code&gt; はそのエミッションを &lt;code&gt;IList&lt;/code&gt; に収集し始め、さらに &lt;code&gt;bufferClosingSelector&lt;/code&gt; を呼び出して2番目のObservableを生成します。この2番目のObservableが &lt;code&gt;TBufferClosing&lt;/code&gt; オブジェクトを発行すると、 &lt;code&gt;Buffer&lt;/code&gt; は現在の &lt;code&gt;IList&lt;/code&gt; を &lt;code&gt;bufferClosingSelector&lt;/code&gt; し、このプロセスを繰り返します。つまり、新しい &lt;code&gt;IList&lt;/code&gt; を開始してbufferClosingSelectorを呼び出し、監視する新しいObservableを作成します。これは、ソースのObservableが終了するまで行われます。</target>
        </trans-unit>
        <trans-unit id="f7a36d0dfbacea5b279df50792127d6faaec9446" translate="yes" xml:space="preserve">
          <source>When it subscribes to the source Observable, &lt;code&gt;buffer(bufferClosingSelector)&lt;/code&gt; begins to collect its emissions into a &lt;code&gt;List&lt;/code&gt;, and it also calls &lt;code&gt;bufferClosingSelector&lt;/code&gt; to generate a second Observable. When this second Observable emits an &lt;code&gt;TClosing&lt;/code&gt; object, &lt;code&gt;buffer&lt;/code&gt; emits the current &lt;code&gt;List&lt;/code&gt; and repeats this process: beginning a new &lt;code&gt;List&lt;/code&gt; and calling &lt;code&gt;bufferClosingSelector&lt;/code&gt; to create a new Observable to monitor. It will do this until the source Observable terminates.</source>
          <target state="translated">ソースのObservableをサブスクライブすると、 &lt;code&gt;buffer(bufferClosingSelector)&lt;/code&gt; はそのエミッションを &lt;code&gt;List&lt;/code&gt; に収集し始め、さらに &lt;code&gt;bufferClosingSelector&lt;/code&gt; を呼び出して2番目のObservableを生成します。この2番目のObservableが &lt;code&gt;TClosing&lt;/code&gt; オブジェクトを発行すると、 &lt;code&gt;buffer&lt;/code&gt; は現在の &lt;code&gt;List&lt;/code&gt; を &lt;code&gt;bufferClosingSelector&lt;/code&gt; し、このプロセスを繰り返します。新しい &lt;code&gt;List&lt;/code&gt; を開始し、bufferClosingSelectorを呼び出して監視する新しいObservableを作成します。これは、ソースのObservableが終了するまで行われます。</target>
        </trans-unit>
        <trans-unit id="cc62b05b2653ba0fcc8b376464d1a3e50f84f004" translate="yes" xml:space="preserve">
          <source>When it subscribes to the source Observable, &lt;code&gt;buffer(bufferClosingSelector)&lt;/code&gt; begins to collect its emissions into a collection, and it also calls &lt;code&gt;bufferClosingSelector&lt;/code&gt; to generate a second Observable. When this second Observable emits an item, &lt;code&gt;buffer&lt;/code&gt; emits the current collection and repeats this process: beginning a new collection and calling &lt;code&gt;bufferClosingSelector&lt;/code&gt; to create a new Observable to monitor. It will do this until the source Observable terminates.</source>
          <target state="translated">ソースのObservableをサブスクライブすると、 &lt;code&gt;buffer(bufferClosingSelector)&lt;/code&gt; はエミッションのコレクションへの収集を開始し、さらに &lt;code&gt;bufferClosingSelector&lt;/code&gt; を呼び出して2番目のObservableを生成します。この2番目のObservableがアイテムを &lt;code&gt;bufferClosingSelector&lt;/code&gt; すると、 &lt;code&gt;buffer&lt;/code&gt; は現在のコレクションを発行し、このプロセスを繰り返します。つまり、新しいコレクションを開始してbufferClosingSelectorを呼び出し、監視する新しいObservableを作成します。これは、ソースのObservableが終了するまで行われます。</target>
        </trans-unit>
        <trans-unit id="ffdd1094f76c4718e1dd27eb3b69f05cf8376978" translate="yes" xml:space="preserve">
          <source>When you pass a number of source Observables to Amb, it will pass through the emissions and notifications of exactly one of these Observables: the first one that sends a notification to Amb, either by emitting an item or sending an &lt;code&gt;onError&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt; notification. Amb will ignore and discard the emissions and notifications of all of the other source Observables.</source>
          <target state="translated">複数のソースObservableをAmbに渡すと、これらのObservableの1つだけのエミッションと通知を通過します。アイテムを &lt;code&gt;onCompleted&lt;/code&gt; するか、 &lt;code&gt;onError&lt;/code&gt; またはonCompleted通知を送信することによって、Ambに通知を送信する最初のオブザーバブルです。Ambは、他のすべてのソースObservableの放出と通知を無視して破棄します。</target>
        </trans-unit>
        <trans-unit id="ed1d5342173ca839fdf8fe9c0ec24de1dc185152" translate="yes" xml:space="preserve">
          <source>When you work with Observables, it can be more convenient if all of the data you mean to work with can be represented as Observables, rather than as a mixture of Observables and other types. This allows you to use a single set of operators to govern the entire lifespan of the data stream.</source>
          <target state="translated">Observablesを使って作業をするときは、Observablesと他のタイプの混合物ではなく、すべてのデータをObservablesとして表現できると、より便利です。これにより、単一の演算子を使用してデータストリームの全ライフサイクルを管理することができます。</target>
        </trans-unit>
        <trans-unit id="d5d00501ca857ce32d5ad450528deb3276ed4573" translate="yes" xml:space="preserve">
          <source>Which looks something like this:</source>
          <target state="translated">このような感じです。</target>
        </trans-unit>
        <trans-unit id="7f4512b1c261ef620de45b9d8c88794c65d6da35" translate="yes" xml:space="preserve">
          <source>Why Use Observables?</source>
          <target state="translated">なぜ観測可能なものを使うのか?</target>
        </trans-unit>
        <trans-unit id="fd9d4ee647871a00407b827b39eb57cb188c8e9b" translate="yes" xml:space="preserve">
          <source>Will call a specified function when the source terminates on complete or error.</source>
          <target state="translated">ソースが完了またはエラーで終了した場合に、指定した関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="41dfc0a6c92707948578891c51d98c6443be63cc" translate="yes" xml:space="preserve">
          <source>Window</source>
          <target state="translated">Window</target>
        </trans-unit>
        <trans-unit id="9f072c045356efae34e3e1a1f0d76733efc29052" translate="yes" xml:space="preserve">
          <source>Window can reduce a sequence of many items to a sequence of fewer windows-of-items, making them more manageable. You could, for example, emit a window of items from a bursty Observable periodically, at a regular interval of time.</source>
          <target state="translated">Window は、多くのアイテムのシーケンスをより管理しやすくするために、より少ない数の Window-of-Items のシーケンスに減らすことができます。例えば、バースト的なObservableから定期的に一定の時間間隔でアイテムのウィンドウを放出することができます。</target>
        </trans-unit>
        <trans-unit id="aeb46abd228b75a53256f0b9bb6b7b8aa09463a1" translate="yes" xml:space="preserve">
          <source>Window is similar to &lt;a href=&quot;buffer&quot;&gt;Buffer&lt;/a&gt;, but rather than emitting packets of items from the source Observable, it emits Observables, each one of which emits a subset of items from the source Observable and then terminates with an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">Windowは&lt;a href=&quot;buffer&quot;&gt;Buffer&lt;/a&gt;に似ていますが、ソースのObservableからアイテムのパケットを送信するのではなく、Observableを &lt;code&gt;onCompleted&lt;/code&gt; します。Observableはそれぞれ、ソースのObservableからアイテムのサブセットを発行し、onCompleted通知で終了します。</target>
        </trans-unit>
        <trans-unit id="3aa6c126ba6145f7e4e8238692031491a9fffcfd" translate="yes" xml:space="preserve">
          <source>With these additions, ReactiveX harmonizes the Iterable and Observable types. The only difference between them is the direction in which the data flows. This is very important because now any operation you can perform on an Iterable, you can also perform on an Observable.</source>
          <target state="translated">これらの追加により、ReactiveXはIterable型とObservable型を調和させます。これらの間の唯一の違いは、データが流れる方向です。これは非常に重要なことです。なぜなら、イテレート可能で実行できる操作はすべて、Observable でも実行できるからです。</target>
        </trans-unit>
        <trans-unit id="cffe58ca95400ce8524a59a6adb8339fe927b434" translate="yes" xml:space="preserve">
          <source>Write the predicate function so that it returns &lt;code&gt;true&lt;/code&gt; for those items you want to pass through the filter to the next observer, and &lt;code&gt;false&lt;/code&gt; for those items you want the filter to block and suppress.</source>
          <target state="translated">述語関数を記述して、フィルターを通過して次のオブザーバーに渡したい項目に対して &lt;code&gt;true&lt;/code&gt; を返し、フィルターにブロックして抑制させたい項目に対して &lt;code&gt;false&lt;/code&gt; を返すようにします。</target>
        </trans-unit>
        <trans-unit id="7832bd9cbceae7a6fa44c7235cfa89d50900f7e0" translate="yes" xml:space="preserve">
          <source>You can also average not the items themselves but the results of a function applied to each item, as in the illustration above, which emits the average number of sides on the figures emitted by the source Observable.</source>
          <target state="translated">また、上の図のように、項目そのものではなく、各項目に適用された関数の結果を平均化することもできます。</target>
        </trans-unit>
        <trans-unit id="76e485df2d9c2ed235e91bb2f1f26240a5ef6a11" translate="yes" xml:space="preserve">
          <source>You can also pass &lt;code&gt;startWith&lt;/code&gt; an Observable, and it will prepend the emissions from that Observable to those of the source Observable to make its own set of emissions. This is a sort of inverted Concat operation.</source>
          <target state="translated">&lt;code&gt;startWith&lt;/code&gt; a Observableを渡すこともできます。これにより、そのObservableからのエミッションをソースObservableのエミッションに追加して、独自のエミッションセットを作成します。これは一種の逆のConcat演算です。</target>
        </trans-unit>
        <trans-unit id="76151784c054704dd1e5d91a90200d161d4d2c61" translate="yes" xml:space="preserve">
          <source>You can also pass a predicate function to &lt;code&gt;first&lt;/code&gt;, in which case it will produce an Observable that emits only the first item from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">述語関数を &lt;code&gt;first&lt;/code&gt; に渡すこともでき &lt;code&gt;true&lt;/code&gt; 。その場合、述語がtrueと評価するソースObservableから最初の項目のみを出力するObservableが生成されます。</target>
        </trans-unit>
        <trans-unit id="9032178a5997d03df3b49859b578df71837d196d" translate="yes" xml:space="preserve">
          <source>You can also pass a predicate function to &lt;code&gt;last&lt;/code&gt;, in which case it will produce an Observable that emits only the last item from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">述語関数を &lt;code&gt;last&lt;/code&gt; に渡すこともでき &lt;code&gt;true&lt;/code&gt; 。その場合、述語がtrueと評価するソースObservableから最後の項目のみを出力するObservableが生成されます。</target>
        </trans-unit>
        <trans-unit id="d6227d5c7e14a1af665c31d2c7a7754c2eeacf80" translate="yes" xml:space="preserve">
          <source>You can also pass a predicate function to the &lt;code&gt;first&lt;/code&gt; method to retrieve the first emission from a &lt;code&gt;BlockingObservable&lt;/code&gt; that satisfies the predicate.</source>
          <target state="translated">述語関数を &lt;code&gt;first&lt;/code&gt; メソッドに渡して、述語を満たす &lt;code&gt;BlockingObservable&lt;/code&gt; から最初のエミッションを取得することもできます。</target>
        </trans-unit>
        <trans-unit id="ff1fc46b917a6d39b2182685ef034a301d994df2" translate="yes" xml:space="preserve">
          <source>You can also pass a predicate function to the &lt;code&gt;last&lt;/code&gt; method to retrieve the last emission from a &lt;code&gt;BlockingObservable&lt;/code&gt; that satisfies the predicate.</source>
          <target state="translated">述語関数を &lt;code&gt;last&lt;/code&gt; メソッドに渡して、述語を満たす &lt;code&gt;BlockingObservable&lt;/code&gt; から最後のエミッションを取得することもできます。</target>
        </trans-unit>
        <trans-unit id="682f4fb340f16e8f1e5183cc92ab9b56a799d0eb" translate="yes" xml:space="preserve">
          <source>You can also pass an object to &lt;code&gt;findIndex&lt;/code&gt; as an optional second parameter, and that object will be available to the predicate function as &amp;ldquo;&lt;code&gt;this&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">オブジェクトをオプションの2番目のパラメーターとして &lt;code&gt;findIndex&lt;/code&gt; に渡すこともできます。そのオブジェクトは、述語関数で「 &lt;code&gt;this&lt;/code&gt; 」として使用できます。</target>
        </trans-unit>
        <trans-unit id="2f12ce04c127fae5f974652acbf7eb4637f72dc0" translate="yes" xml:space="preserve">
          <source>You can also pass in as an optional fifth parameter a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; that &lt;code&gt;generate&lt;/code&gt; will use to create and emit its sequence (it uses &lt;code&gt;currentThread&lt;/code&gt; by default).</source>
          <target state="translated">オプションの5番目のパラメーターとして、 &lt;code&gt;generate&lt;/code&gt; する&lt;a href=&quot;../scheduler&quot;&gt;スケジューラー&lt;/a&gt;がシーケンスの作成と発行に使用するパラメーターを渡すこともできます（デフォルトでは &lt;code&gt;currentThread&lt;/code&gt; を使用します）。</target>
        </trans-unit>
        <trans-unit id="44fdb21ced818c60966c04e7bd356097a2188b4d" translate="yes" xml:space="preserve">
          <source>You can also pass in as an optional fourth parameter a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; that &lt;code&gt;generate&lt;/code&gt; will use to create and emit its sequence (it uses &lt;code&gt;CurrentThreadScheduler&lt;/code&gt; by default).</source>
          <target state="translated">また、オプションの4番目のパラメーターとして、 &lt;code&gt;generate&lt;/code&gt; する&lt;a href=&quot;../scheduler&quot;&gt;スケジューラー&lt;/a&gt;がシーケンスの作成と発行に使用するパラメーターを渡すこともできます（デフォルトでは &lt;code&gt;CurrentThreadScheduler&lt;/code&gt; を使用します）。</target>
        </trans-unit>
        <trans-unit id="b7cb5ca8203996c413ed3246420ce370e361571c" translate="yes" xml:space="preserve">
          <source>You can also pass in as an optional sixth parameter a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; that &lt;code&gt;generate&lt;/code&gt; will use to create and emit its sequence (it uses &lt;code&gt;currentThread&lt;/code&gt; by default).</source>
          <target state="translated">オプションの6番目のパラメーターとして、 &lt;code&gt;generate&lt;/code&gt; する&lt;a href=&quot;../scheduler&quot;&gt;スケジューラー&lt;/a&gt;がシーケンスの作成と発行に使用するパラメーターを渡すこともできます（デフォルトでは &lt;code&gt;currentThread&lt;/code&gt; を使用します）。</target>
        </trans-unit>
        <trans-unit id="ace5642a3047a0e0c9b280c2c4933542713f93b0" translate="yes" xml:space="preserve">
          <source>You can also pass it between one and three functions; these will be interpreted as follows:</source>
          <target state="translated">また、1つの関数と3つの関数の間で渡すこともできます;これらは次のように解釈されます。</target>
        </trans-unit>
        <trans-unit id="8434b31a397379ba6a2fc9da703aa8991af9359f" translate="yes" xml:space="preserve">
          <source>You can also specify a particular &lt;a href=&quot;scheduler&quot;&gt;Scheduler&lt;/a&gt; for the timer to operate on:</source>
          <target state="translated">タイマーが動作する特定の&lt;a href=&quot;scheduler&quot;&gt;スケジューラー&lt;/a&gt;を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="e502559fdf8b6103a0732d131d6e69a4a29eb47a" translate="yes" xml:space="preserve">
          <source>You can also sum not the items themselves but the results of a function applied to each item, as in the illustration above, which emits the sum number of sides on the figures emitted by the source Observable.</source>
          <target state="translated">また、上の図のように、項目そのものではなく、各項目に適用された関数の結果を合計することもできます。</target>
        </trans-unit>
        <trans-unit id="7247fcf25ac20fbdb5f7aa37835067a9d4093a34" translate="yes" xml:space="preserve">
          <source>You can also sum not the items themselves but the results of a function applied to each item, as in the illustration above, which emits the sum of the number of sides on the figures emitted by the source Observable.</source>
          <target state="translated">また、項目そのものではなく、各項目に適用された関数の結果を合計することもできます。</target>
        </trans-unit>
        <trans-unit id="3b42768d804313cbd5e467001ecd6fd593441e45" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedule(rx.functions.Action0,%20long,%20java.util.concurrent.TimeUnit)&quot;&gt;a version of &lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt; that delays your action on the given Scheduler until a certain timespan has passed. The following example schedules &lt;code&gt;someAction&lt;/code&gt; to be performed on &lt;code&gt;someScheduler&lt;/code&gt; after 500ms have passed according to that Scheduler&amp;rsquo;s clock:</source>
          <target state="translated">特定のタイムスパンが経過するまで、特定のスケジューラでのアクションを遅らせる&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedule(rx.functions.Action0,%20long,%20java.util.concurrent.TimeUnit)&quot;&gt;バージョンの &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt;を使用することもできます。次の例では、スケジューラのクロックに従って500 &lt;code&gt;someScheduler&lt;/code&gt; が経過した後にsomeSchedulerでsomeActionが実行されるようにスケジュールを &lt;code&gt;someAction&lt;/code&gt; しています。</target>
        </trans-unit>
        <trans-unit id="cb20d1dc2545e8aebb8070141dcdcdb2b4514b29" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;connect&lt;/code&gt; method to instruct an Observable to begin emitting items (or, to begin generating items that would be emitted) even before any Subscriber has subscribed to it. In this way you can turn a cold Observable into a hot one.</source>
          <target state="translated">また、 &lt;code&gt;connect&lt;/code&gt; メソッドを使用して、任意のサブスクライバーがサブスクライブする前であっても、Observableにアイテムの発行を開始する（または発行されるアイテムの生成を開始する）ように指示することもできます。このようにして、寒いObservableを暑いObservableに変えることができます。</target>
        </trans-unit>
        <trans-unit id="b6ca8c83a0cdbbc6138ee98a1555b795c9b81a2f" translate="yes" xml:space="preserve">
          <source>You can combine the output of multiple Observables so that they act like a single Observable, by using the Merge operator.</source>
          <target state="translated">Merge 演算子を使用して、複数の Observable の出力を一つの Observable のように結合することができます。</target>
        </trans-unit>
        <trans-unit id="f29f94707670ef1f5bcad38186903f0c22c58ad6" translate="yes" xml:space="preserve">
          <source>You can convert a function into an asynchronous function with the &lt;code&gt;toAsync&lt;/code&gt; method. It takes a function, function parameter, and &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; as parameters, and returns an asynchronous function that will be invoked on the specified Scheduler. The last two parameters are optional; if you do not specify a Scheduler, the &lt;code&gt;timeout&lt;/code&gt; Scheduler will be used by default.</source>
          <target state="translated">&lt;code&gt;toAsync&lt;/code&gt; メソッドを使用して、関数を非同期関数に変換できます。関数、関数パラメーター、および&lt;a href=&quot;../scheduler&quot;&gt;スケジューラー&lt;/a&gt;をパラメーターとして取り、指定されたスケジューラーで呼び出される非同期関数を返します。最後の2つのパラメーターはオプションです。スケジューラを指定しない場合、デフォルトで &lt;code&gt;timeout&lt;/code&gt; スケジューラが使用されます。</target>
        </trans-unit>
        <trans-unit id="d333d5f990bc05873a5bb431e9c19e5cfaa18ed6" translate="yes" xml:space="preserve">
          <source>You can create an Observable from scratch by using the Create operator. You pass this operator a function that accepts the observer as its parameter. Write this function so that it behaves as an Observable &amp;mdash; by calling the observer&amp;rsquo;s &lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;, and &lt;code&gt;onCompleted&lt;/code&gt; methods appropriately.</source>
          <target state="translated">Create演算子を使用して、Observableを最初から作成できます。この演算子には、オブザーバーをパラメーターとして受け入れる関数を渡します。オブザーバーの &lt;code&gt;onNext&lt;/code&gt; 、 &lt;code&gt;onError&lt;/code&gt; 、および &lt;code&gt;onCompleted&lt;/code&gt; メソッドを適切に呼び出して、Observableとして動作するようにこの関数を記述します。</target>
        </trans-unit>
        <trans-unit id="ed592ed573016152e1525943e01beed267c2837e" translate="yes" xml:space="preserve">
          <source>You can either pass &lt;code&gt;merge&lt;/code&gt; a set of Observables as individual parameters, or as a single parameter containing an array of those Observables.</source>
          <target state="translated">どちら通過できる &lt;code&gt;merge&lt;/code&gt; 個々のパラメータとして観測のセットを、又はそれらの観測の配列を含む単一のパラメータとして。</target>
        </trans-unit>
        <trans-unit id="0eb38cbaf446930a95ee352d060e3434e8e6cf5a" translate="yes" xml:space="preserve">
          <source>You can emit only the final</source>
          <target state="translated">最終的な</target>
        </trans-unit>
        <trans-unit id="92e0c405c5fc1dad5fbf0ff45e76df0f8d71a1b7" translate="yes" xml:space="preserve">
          <source>You can emit only the first</source>
          <target state="translated">だけを出すことができます。</target>
        </trans-unit>
        <trans-unit id="0d9ff619b7e4afa4d6d6cf1ea0bbdbec29b9e953" translate="yes" xml:space="preserve">
          <source>You can ignore the final</source>
          <target state="translated">最終的には無視しても構いません。</target>
        </trans-unit>
        <trans-unit id="cdf767f10b63dd6612725c17a1c1242d8039a0f1" translate="yes" xml:space="preserve">
          <source>You can ignore the first</source>
          <target state="translated">最初のものは無視しても構いません。</target>
        </trans-unit>
        <trans-unit id="34e3d5ad83cc701c11204debdb3a9bd100dc16ff" translate="yes" xml:space="preserve">
          <source>You can implement your own Observable operators. This page shows you how.</source>
          <target state="translated">独自のObservable演算子を実装することができます。このページではその方法を紹介します。</target>
        </trans-unit>
        <trans-unit id="a84dee30bbc65f9e86a29ef569240b6c41e82fe7" translate="yes" xml:space="preserve">
          <source>You can optionally pass &lt;code&gt;scan&lt;/code&gt; a seed value as an additional parameter. &lt;code&gt;scan&lt;/code&gt; will pass this seed value to the accumulator function the first time it is called (for the first emission from the source Observable) in place of the result from the missing prior call to the accumulator.</source>
          <target state="translated">オプションで、追加のパラメーターとしてシード値を &lt;code&gt;scan&lt;/code&gt; 渡すことができます。 &lt;code&gt;scan&lt;/code&gt; は、最初に呼び出されたときに、このシード値をアキュムレータ関数に渡します（ソースObservableからの最初のエミッションの場合）。</target>
        </trans-unit>
        <trans-unit id="c8b0aa91f55f3b994e6c69fe1cbb79f3b9e56c6b" translate="yes" xml:space="preserve">
          <source>You can pass &lt;code&gt;Merge&lt;/code&gt; an Array of Observables, an Enumerable of Observables, an Observable of Observables, or two individual Observables.</source>
          <target state="translated">&lt;code&gt;Merge&lt;/code&gt; 配列のObservable、ObservableのEnumerable、ObservableのObservable、または2つの個別のObservable を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="cb8fd78267fbf9d33e89053521ba7ca1d2df2f4d" translate="yes" xml:space="preserve">
          <source>You can pass in a set of 1&amp;ndash;3 individual functions (&lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;, and &lt;code&gt;onCompleted&lt;/code&gt;) that &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;tap&lt;/code&gt; will call along with the similarly-named functions of any of its observers.</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; / &lt;code&gt;tap&lt;/code&gt; がそのオブザーバーの同様の名前の関数と一緒に呼び出す1〜3個の個々の関数（ &lt;code&gt;onNext&lt;/code&gt; 、 &lt;code&gt;onError&lt;/code&gt; 、および &lt;code&gt;onCompleted&lt;/code&gt; ）のセットを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="8e5177ba088da12c6ff9c7a019b4a2d5a68fbc0d" translate="yes" xml:space="preserve">
          <source>You can pass it an Observer, in which case &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;tap&lt;/code&gt; will call that Observer&amp;rsquo;s methods as though that Observer had subscribed to the resulting Observable.</source>
          <target state="translated">オブザーバーに渡すことができます。その場合、 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;tap&lt;/code&gt; は、オブザーバーが結果のObservableにサブスクライブしたかのように、そのオブザーバーのメソッドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="c5c5fca5bde9cdb4b3c8839f8708898dbeeef111" translate="yes" xml:space="preserve">
          <source>You can pass the values you want to prepend to the Observable sequence to &lt;code&gt;startWith&lt;/code&gt; either in a single Iterable or as a series of one to nine function parameters.</source>
          <target state="translated">Observableシーケンスの &lt;code&gt;startWith&lt;/code&gt; する値をstartWithに渡すには、単一のIterableで、または1〜9個の一連の関数パラメーターとして渡すことができます。</target>
        </trans-unit>
        <trans-unit id="d39d86fe689387af19760dd31d8a62bc7e978897" translate="yes" xml:space="preserve">
          <source>You can register callbacks that ReactiveX will call when certain events take place on an Observable, where those callbacks will be called independently from the normal set of notifications associated with an Observable cascade. There are a variety of operators that various ReactiveX implementations have designed to allow for this.</source>
          <target state="translated">Observable 上で特定のイベントが発生したときに ReactiveX が呼び出すコールバックを登録することができ、それらのコールバックは Observable カスケードに関連付けられた通常の通知とは独立して呼び出されます。これを可能にするために、様々なReactiveXの実装が設計した様々な演算子があります。</target>
        </trans-unit>
        <trans-unit id="fb2ee0c05762dad6511a1056f9e75b00a134937e" translate="yes" xml:space="preserve">
          <source>You can think of the Observable class as a &amp;ldquo;push&amp;rdquo; equivalent to &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html&quot;&gt;Iterable&lt;/a&gt;, which is a &amp;ldquo;pull.&amp;rdquo; With an Iterable, the consumer pulls values from the producer and the thread blocks until those values arrive. By contrast, with an Observable the producer pushes values to the consumer whenever values are available. This approach is more flexible, because values can arrive synchronously or asynchronously.</source>
          <target state="translated">Observableクラスは、「プル」である&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html&quot;&gt;Iterable&lt;/a&gt;と同等の「プッシュ」と考えることができます。Iterableでは、コンシューマーはプロデューサーから値をプルし、スレッドはそれらの値が到着するまでブロックします。対照的に、Observableを使用すると、値が利用可能な場合は常にプロデューサーがコンシューマーに値をプッシュします。値は同期または非同期で到着できるため、このアプローチはより柔軟です。</target>
        </trans-unit>
        <trans-unit id="afe2c81139a11756e77093b65fd7ac0096d49a51" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;generate&lt;/code&gt; operator to create simple Observables that can generate their next emissions, and can determine when to terminate, based on the value of the previous emission. The basic form of &lt;code&gt;generate&lt;/code&gt; takes four parameters:</source>
          <target state="translated">&lt;code&gt;generate&lt;/code&gt; オペレーターを使用して、次のエミッションを生成できる単純なObservableを作成し、前のエミッションの値に基づいて、いつ終了するかを決定できます。 &lt;code&gt;generate&lt;/code&gt; の基本形式は4つのパラメーターを取ります。</target>
        </trans-unit>
        <trans-unit id="e60fef6e6f2b9ffc1eea924da1b6d0b36ff75ea1" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;generate&lt;/code&gt; operator to create simple Observables that can generate their next emissions, and can determine when to terminate, based on the value of the previous emission. The basic form of &lt;code&gt;generate&lt;/code&gt; takes three parameters:</source>
          <target state="translated">&lt;code&gt;generate&lt;/code&gt; オペレーターを使用して、次のエミッションを生成できる単純なObservableを作成し、前のエミッションの値に基づいて、いつ終了するかを決定できます。 &lt;code&gt;generate&lt;/code&gt; の基本形式は3つのパラメーターを取ります。</target>
        </trans-unit>
        <trans-unit id="4f52de916cbfb602ee5bae4de129d633704400d7" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;generateWithAbsoluteTime&lt;/code&gt; operator to create simple Observables that can generate their next emissions, and can determine when to terminate, based on the value of the previous emission. The basic form of &lt;code&gt;generateWithAbsoluteTime&lt;/code&gt; takes five parameters:</source>
          <target state="translated">&lt;code&gt;generateWithAbsoluteTime&lt;/code&gt; オペレーターを使用して、次のエミッションを生成できる単純なObservableを作成し、前のエミッションの値に基づいていつ終了するかを決定できます。 &lt;code&gt;generateWithAbsoluteTime&lt;/code&gt; の基本形式は5つのパラメーターを取ります。</target>
        </trans-unit>
        <trans-unit id="530a4df6e9fe7ac23c4071905c1156e707670988" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;generateWithRelativeTime&lt;/code&gt; operator to create simple Observables that can generate their next emissions, and can determine when to terminate, based on the value of the previous emission. The basic form of &lt;code&gt;generateWithRelativeTime&lt;/code&gt; takes five parameters:</source>
          <target state="translated">&lt;code&gt;generateWithRelativeTime&lt;/code&gt; オペレーターを使用して、次のエミッションを生成できる単純なObservableを作成し、前のエミッションの値に基づいていつ終了するかを決定できます。 &lt;code&gt;generateWithRelativeTime&lt;/code&gt; の基本形式は5つのパラメーターを取ります。</target>
        </trans-unit>
        <trans-unit id="3c8e590f92ae7e377643f3cb85ba8d13993cded0" translate="yes" xml:space="preserve">
          <source>You can use the Buffer operator to implement backpressure (that is, to cope with an Observable that may produce items too quickly for its observer to consume).</source>
          <target state="translated">Buffer演算子を使用して、背圧を実装することができます(つまり、オブザーバが消費するためにアイテムを素早く生成しすぎる可能性のあるオブザーバブルに対処するためです)。</target>
        </trans-unit>
        <trans-unit id="6a789db16cf992fb1a0e9a788b8fb01c96ea389d" translate="yes" xml:space="preserve">
          <source>You can use the Window operator to implement backpressure (that is, to cope with an Observable that may produce items too quickly for its observer to consume).</source>
          <target state="translated">Window 演算子を使用して、背圧を実装することができます(つまり、オブザーバが消費するためにアイテムをすぐに生成しすぎてしまう可能性のあるオブザーバブルに対処するためです)。</target>
        </trans-unit>
        <trans-unit id="140e328532101e1bca4082da61b61af7b7bddb4a" translate="yes" xml:space="preserve">
          <source>You can use this if you need a function that blocks until the completion of an Observable.</source>
          <target state="translated">Observableが完了するまでブロックする関数が必要な場合に使用できます。</target>
        </trans-unit>
        <trans-unit id="ec192e441ea90fa4d7c38e5cdb6a09a79315f557" translate="yes" xml:space="preserve">
          <source>You may also, optionally, pass in a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; as a second parameter, and the timer will operate on that Scheduler (&lt;code&gt;skipUntilWithTime&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler by default).</source>
          <target state="translated">オプションで、2番目のパラメーターとして&lt;a href=&quot;../scheduler&quot;&gt;スケジューラー&lt;/a&gt;を渡すこともでき、タイマーはそのスケジューラーで動作します（ &lt;code&gt;skipUntilWithTime&lt;/code&gt; はデフォルトで &lt;code&gt;timeout&lt;/code&gt; スケジューラーを使用します）。</target>
        </trans-unit>
        <trans-unit id="a97be5d8b2c0e88945dca3a58187eeff3b450946" translate="yes" xml:space="preserve">
          <source>You may also, optionally, pass in a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; as a second parameter, and the timer will operate on that Scheduler (&lt;code&gt;takeUntilWithTime&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler by default).</source>
          <target state="translated">オプションで、2番目のパラメーターとして&lt;a href=&quot;../scheduler&quot;&gt;スケジューラー&lt;/a&gt;を渡すこともでき、タイマーはそのスケジューラーで動作します（ &lt;code&gt;takeUntilWithTime&lt;/code&gt; はデフォルトで &lt;code&gt;timeout&lt;/code&gt; スケジューラーを使用します）。</target>
        </trans-unit>
        <trans-unit id="9ee11d62e29bb47499c0f66688f7c75ce6d51ea7" translate="yes" xml:space="preserve">
          <source>You may optionally pass a second parameter to &lt;code&gt;skipWhile&lt;/code&gt;. If so, that item will also be available to your predicate function as &amp;ldquo;&lt;code&gt;this&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">オプションで、2番目のパラメーターを &lt;code&gt;skipWhile&lt;/code&gt; に渡すことができます。その場合、そのアイテムは述語関数で「 &lt;code&gt;this&lt;/code&gt; 」としても使用できます。</target>
        </trans-unit>
        <trans-unit id="023d26f660a72a31c63344590bfe54d9962554f4" translate="yes" xml:space="preserve">
          <source>You may optionally pass a second parameter to &lt;code&gt;takeWhile&lt;/code&gt;. If so, that item will also be available to your predicate function as &amp;ldquo;&lt;code&gt;this&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">オプションで、2番目のパラメーターを &lt;code&gt;takeWhile&lt;/code&gt; に渡すことができます。その場合、そのアイテムは述語関数で「 &lt;code&gt;this&lt;/code&gt; 」としても使用できます。</target>
        </trans-unit>
        <trans-unit id="9d40c04f503ade2f5884377cd47e2bbce06c8245" translate="yes" xml:space="preserve">
          <source>You may optionally pass in a default value that &lt;code&gt;elementAt&lt;/code&gt; will emit if the source Observable emits no values:</source>
          <target state="translated">オプションで、ソースObservableが値を &lt;code&gt;elementAt&lt;/code&gt; ない場合にelementAtが発行するデフォルト値を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="6924eecb0342a630593b97c28a087d0a232f2125" translate="yes" xml:space="preserve">
          <source>You may pass &lt;code&gt;catch_exception&lt;/code&gt; a set of back-up Observables either as individual function parameters or as a single array of Observables. If it encounters an &lt;code&gt;onError&lt;/code&gt; notification from the source Observable, it will subscribe to and begin mirroring the first of these back-up Observables. If this back-up Observable itself issues an &lt;code&gt;onError&lt;/code&gt; notification, &lt;code&gt;catch_exception&lt;/code&gt; will swallow it and switch over to the next back-up Observable. If any of these Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification, &lt;code&gt;catch_exception&lt;/code&gt; will pass this along and will stop.</source>
          <target state="translated">&lt;code&gt;catch_exception&lt;/code&gt; には、個別の関数パラメーターとして、またはObservableの単一の配列として、バックアップObservableのセットを渡すことができます。それが発生した場合 &lt;code&gt;onError&lt;/code&gt; 観察可能なソースからの通知を、それがに加入し、これらのバックアップ観測の最初のミラーリングを開始します。このバックアップObservable自体が &lt;code&gt;onError&lt;/code&gt; 通知を発行すると、 &lt;code&gt;catch_exception&lt;/code&gt; はそれを飲み込み、次のバックアップObservableに切り替えます。これらのObservableのいずれかが &lt;code&gt;onCompleted&lt;/code&gt; 通知を発行した場合、 &lt;code&gt;catch_exception&lt;/code&gt; はこれを渡し、停止します。</target>
        </trans-unit>
        <trans-unit id="b4b837d7135fd3faba51276890ee36e1feca2008" translate="yes" xml:space="preserve">
          <source>You may pass &lt;code&gt;on_error_resume_next&lt;/code&gt; a set of back-up Observables either as individual function parameters, as a single array of Observables, or as a factory function that generates Observables. When the source Observable terminates, whether normally or with an error, &lt;code&gt;on_error_resume_next&lt;/code&gt; will subscribe to and begin mirroring the first of these back-up Observables, and then will recursively continue this concatenation process for each additional Observable until there are no more Observables to mirror, at which time it will pass on the &lt;code&gt;onError&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt; notification from the last of these Observables.</source>
          <target state="translated">&lt;code&gt;on_error_resume_next&lt;/code&gt; には、個別の関数パラメーターとして、Observableの単一の配列として、またはObservableを生成するファクトリー関数として、バックアップObservableのセットを渡すことができます。ソースのObservableが終了すると、通常またはエラーに &lt;code&gt;on_error_resume_next&lt;/code&gt; なく、on_error_resume_nextはこれらのバックアップObservableの最初のサブスクライブとミラーリングを開始し、ミラーリングするObservableがなくなるまで、追加の各Observableに対してこの連結プロセスを再帰的に継続します。その時点で、これらのObservableの最後からの &lt;code&gt;onError&lt;/code&gt; または &lt;code&gt;onCompleted&lt;/code&gt; 通知を渡します。</target>
        </trans-unit>
        <trans-unit id="4a8142ffd2e1b1f1cf04b936490d70f73561a031" translate="yes" xml:space="preserve">
          <source>You may pass &lt;code&gt;rescue_error&lt;/code&gt; either an Observable or a factory action that generates an Observable.</source>
          <target state="translated">&lt;code&gt;rescue_error&lt;/code&gt; には、ObservableまたはObservableを生成するファクトリアクションを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="aa1f229e508d7ff97c8b29afa6b4e506ae8fad77" translate="yes" xml:space="preserve">
          <source>You may replace the first function parameter (the predicate that evaluates the exception) with a class object representing a variety of exception. If you do this, &lt;code&gt;catch*&lt;/code&gt; will treat it as equivalent to predicate that performs an &lt;code&gt;instance?&lt;/code&gt; check to see if the exception from the &lt;code&gt;onError&lt;/code&gt; notification is an instance of the class object. In other words:</source>
          <target state="translated">最初の関数パラメーター（例外を評価する述語）を、さまざまな例外を表すクラスオブジェクトに置き換えることができます。これを行うと、 &lt;code&gt;catch*&lt;/code&gt; は &lt;code&gt;instance?&lt;/code&gt; を実行する述語と同等に扱いますか？ &lt;code&gt;onError&lt;/code&gt; 通知からの例外がクラスオブジェクトのインスタンスであるかどうかを確認します。言い換えると：</target>
        </trans-unit>
        <trans-unit id="fc3c1c1381737d34e9f462554add7c36b53b82e9" translate="yes" xml:space="preserve">
          <source>You obtain a Scheduler from the factory methods described in &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html&quot;&gt;the &lt;code&gt;Schedulers&lt;/code&gt; class&lt;/a&gt;. The following table shows the varieties of Scheduler that are available to you by means of these methods in RxGroovy:</source>
          <target state="translated">Schedulerは&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html&quot;&gt;、 &lt;code&gt;Schedulers&lt;/code&gt; クラスで&lt;/a&gt;説明されているファクトリメソッドから取得します。次の表は、RxGroovyでこれらのメソッドを使用して利用できるスケジューラの種類を示しています。</target>
        </trans-unit>
        <trans-unit id="bf2ca998afcfe4dc5973a75433cef6ddce12e4f3" translate="yes" xml:space="preserve">
          <source>You obtain a Scheduler from the factory methods described in &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html&quot;&gt;the &lt;code&gt;Schedulers&lt;/code&gt; class&lt;/a&gt;. The following table shows the varieties of Scheduler that are available to you by means of these methods in RxJava:</source>
          <target state="translated">Schedulerは&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html&quot;&gt;、 &lt;code&gt;Schedulers&lt;/code&gt; クラスで&lt;/a&gt;説明されているファクトリメソッドから取得します。次の表は、RxJavaのこれらのメソッドを使用して利用できるスケジューラの種類を示しています。</target>
        </trans-unit>
        <trans-unit id="bd39c643b0349c87b3a6306388851ca9feb51b59" translate="yes" xml:space="preserve">
          <source>You pass the &lt;code&gt;using&lt;/code&gt; operator three parameters:</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt; 演算子に3つのパラメータを渡します。</target>
        </trans-unit>
        <trans-unit id="945549399624f25bf835814f45b520f97baa16bc" translate="yes" xml:space="preserve">
          <source>You pass the &lt;code&gt;using&lt;/code&gt; operator two parameters:</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt; 演算子に2つのパラメータを渡します。</target>
        </trans-unit>
        <trans-unit id="1f339160e649a6f3d3ed789c3776e03cdd682087" translate="yes" xml:space="preserve">
          <source>Your operator should check &lt;a href=&quot;observable#unsubscribing&quot;&gt;its Subscriber's &lt;code&gt;isUnsubscribed( )&lt;/code&gt; status&lt;/a&gt; before it emits any item to (or sends any notification to) the Subscriber. Do not waste time generating items that no Subscriber is interested in seeing.</source>
          <target state="translated">オペレーターは&lt;a href=&quot;observable#unsubscribing&quot;&gt;、サブスクライバーに &lt;code&gt;isUnsubscribed( )&lt;/code&gt; &lt;/a&gt;アイテムを送信（または通知を送信）する前に、サブスクライバーのisUnsubscribed（）ステータスを確認する必要があります。購読者が見たくないアイテムを生成する時間を無駄にしないでください。</target>
        </trans-unit>
        <trans-unit id="2de2635fc818fcac53a104f07189e4bb7e893948" translate="yes" xml:space="preserve">
          <source>Your operator should obey the core tenets of the Observable contract:</source>
          <target state="translated">あなたのオペレータは、Observable契約の中核となる原則に従うべきです。</target>
        </trans-unit>
        <trans-unit id="aec742c8cd57ac5fee0ad76b17e91c6d76608cb3" translate="yes" xml:space="preserve">
          <source>Zip</source>
          <target state="translated">Zip</target>
        </trans-unit>
        <trans-unit id="4647f6838148e96f73bbd9c301485a593c564bca" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; on which this operator should operate</source>
          <target state="translated">このオペレーターが操作する&lt;a href=&quot;../scheduler&quot;&gt;スケジューラ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b493c478a21d579a93d747f7559defc353fe9a6b" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; on which you want to run the Node.js callback</source>
          <target state="translated">Node.jsコールバックを実行する&lt;a href=&quot;../scheduler&quot;&gt;スケジューラ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="509f3a9a1a12009f0c68350721b996a8bba83a2d" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;Date&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="094b3142a1b3282411e3d1922e3059844391c692" translate="yes" xml:space="preserve">
          <source>a Single passes this method the Throwable that caused the Single to be unable to emit an item</source>
          <target state="translated">a Singleがこのメソッドに、Singleがアイテムを放出できない原因となったThrowableを渡します。</target>
        </trans-unit>
        <trans-unit id="f8c375880bc159b6da0439d622dda5c5e82f83b0" translate="yes" xml:space="preserve">
          <source>a Single passes this method the sole item that the Single emits</source>
          <target state="translated">a Singleがこのメソッドに渡すのは、Singleが放出する唯一のアイテムです。</target>
        </trans-unit>
        <trans-unit id="6e746c23a5816efea8653e2074fbc7f27840c058" translate="yes" xml:space="preserve">
          <source>a factory function that creates a disposable resource</source>
          <target state="translated">使い捨て資源を生成するファクトリ関数</target>
        </trans-unit>
        <trans-unit id="f9ef51f84c35f84a28720761526b6be0ec85aebe" translate="yes" xml:space="preserve">
          <source>a factory function that creates an Observable</source>
          <target state="translated">Observableを作成するファクトリ関数</target>
        </trans-unit>
        <trans-unit id="47dfc20e0f1b41b426e0e33d0cd2a5b9688c4e57" translate="yes" xml:space="preserve">
          <source>a function that accepts an item emitted by the source Observable and returns a</source>
          <target state="translated">ソースであるObservableから放出されたアイテムを受け取り</target>
        </trans-unit>
        <trans-unit id="2ddd07bf05e2e9d39c05b862f2b8e252591ef85b" translate="yes" xml:space="preserve">
          <source>a function that accepts an item from the first Observable and an Observable that emits items from the second Observable and returns an item to be emitted by the Observable returned from &lt;code&gt;groupJoin&lt;/code&gt;</source>
          <target state="translated">最初のObservableからアイテムを受け入れ、2番目のObservableからアイテムを放出し、 &lt;code&gt;groupJoin&lt;/code&gt; から返されたObservableによって放出されるアイテムを返す関数</target>
        </trans-unit>
        <trans-unit id="76f8801e6c5c9954ce73620d55acd7bf849c2a1a" translate="yes" xml:space="preserve">
          <source>a function that accepts an item from the first Observable and an item from the second Observable and returns an item to be emitted by the Observable returned from &lt;code&gt;join&lt;/code&gt;</source>
          <target state="translated">最初のObservableからのアイテムと2番目のObservableからのアイテムを受け入れ、 &lt;code&gt;join&lt;/code&gt; から返されたObservableによって発行されるアイテムを返す関数</target>
        </trans-unit>
        <trans-unit id="0aff1921b29e2531a19b409ba53bcaa299073931" translate="yes" xml:space="preserve">
          <source>a function that accepts an item from the second Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the first Observable</source>
          <target state="translated">2番目のObservableからアイテムを受け取り、そのアイテムが1番目のObservableからのアイテムと結合するまでの期間を指定したObservableを返す関数。</target>
        </trans-unit>
        <trans-unit id="2537afc91f615219e473b116dd8fce6e8c1a6ff9" translate="yes" xml:space="preserve">
          <source>a function that accepts an item from the source Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the second Observable</source>
          <target state="translated">元のObservableからアイテムを受け取り、そのアイテムが2番目のObservableからのアイテムと結合するまでの期間を指定したObservableを返す関数。</target>
        </trans-unit>
        <trans-unit id="0ea0e4f321f3690c79a053a22c1c77290a7e603e" translate="yes" xml:space="preserve">
          <source>a function that accepts an item from the source Observable and returns an item to be emitted in its place by one of the resulting Observables</source>
          <target state="translated">元のObservableからアイテムを受け取り、結果として得られるObservableの一つであるアイテムを返します。</target>
        </trans-unit>
        <trans-unit id="2e39dfb6e89ec27b2799ac841058cbe1c8622ded" translate="yes" xml:space="preserve">
          <source>a function that accepts two items (or two keys) and compares them for distinctness, returning &lt;code&gt;false&lt;/code&gt; if they are distinct (an equality function is the default if you do not supply your own function here)</source>
          <target state="translated">2つの項目（または2つのキー）を受け入れ、それらが異なるかどうか比較し、それらが異なる場合は &lt;code&gt;false&lt;/code&gt; を返す関数（ここで独自の関数を指定しない場合は、等価関数がデフォルトです）</target>
        </trans-unit>
        <trans-unit id="40c676b1b9cb886b7d849f24b8f8562dc0c7450f" translate="yes" xml:space="preserve">
          <source>a function that disposes of the resource</source>
          <target state="translated">リソースを廃棄する関数</target>
        </trans-unit>
        <trans-unit id="f00fad8955c402d31ecc865bacbf29bf7f7b2e49" translate="yes" xml:space="preserve">
          <source>a function that returns the key that determines which Observable to emit</source>
          <target state="translated">どのObservableを放出するかを決定するキーを返す関数</target>
        </trans-unit>
        <trans-unit id="bf1f078c34ead7a76ff3206e489a656d7ecb0e61" translate="yes" xml:space="preserve">
          <source>a function that returns the mutable data structure</source>
          <target state="translated">変形可能なデータ構造体を返す関数</target>
        </trans-unit>
        <trans-unit id="d3d2297cca8b40c3332e52315a233f4690aa3594" translate="yes" xml:space="preserve">
          <source>a function that, when given the data structure and an item emitted by the source Observable, modifies the data structure appropriately</source>
          <target state="translated">データ構造とObservableによって生成された項目が与えられた場合に、データ構造を適切に修正する関数。</target>
        </trans-unit>
        <trans-unit id="fdcfa4810783cdbb46bc98763bc28d19271f7ac2" translate="yes" xml:space="preserve">
          <source>a function to generate the next item to test and emit based on the value of the previous item</source>
          <target state="translated">前の項目の値に基づいて次の項目をテストして放出するための関数</target>
        </trans-unit>
        <trans-unit id="428d1cdfe3341cf4456bd0ff8a1f09d9b747a991" translate="yes" xml:space="preserve">
          <source>a function to indicate at what time (expressed as a &lt;code&gt;Date&lt;/code&gt;) the generator should emit the the new item</source>
          <target state="translated">ジェネレーターが新しいアイテムをいつ放出するか（ &lt;code&gt;Date&lt;/code&gt; として表される）を示す関数</target>
        </trans-unit>
        <trans-unit id="b9b02313f83c7a5de6f60fa4dae062626ee99890" translate="yes" xml:space="preserve">
          <source>a function to indicate how long, in milliseconds, the generator should wait after the emission of the previous item before emitting this item</source>
          <target state="translated">前のアイテムを放出してからこのアイテムを放出するまでの待ち時間をミリ秒単位で示す関数</target>
        </trans-unit>
        <trans-unit id="9c40d35aa81016b60c5e8f8e5f786a2e228ffcd8" translate="yes" xml:space="preserve">
          <source>a function to test an item to determine whether to emit it (&lt;code&gt;true&lt;/code&gt;) or terminate the Observable (&lt;code&gt;false&lt;/code&gt;)</source>
          <target state="translated">アイテムをテストして、それを発行するか（ &lt;code&gt;true&lt;/code&gt; ）、Observableを終了するか（ &lt;code&gt;false&lt;/code&gt; ）を決定する関数</target>
        </trans-unit>
        <trans-unit id="95323fca49a83a1abac26e79f91ed7eb8a5653bf" translate="yes" xml:space="preserve">
          <source>a function to transform items before emitting them</source>
          <target state="translated">アイテムを変換してから排出する関数</target>
        </trans-unit>
        <trans-unit id="0456183e34019ad3a80b7ade1f97bbdb2982c441" translate="yes" xml:space="preserve">
          <source>a function used to compare two keys for identity (that is, whether items with two keys should be emitted on the same Observable)</source>
          <target state="translated">二つのキーの同一性を比較するための関数 (つまり、二つのキーを持つアイテムが同じObservable上で放出されるべきかどうか)</target>
        </trans-unit>
        <trans-unit id="c37f5d4c24ebe19faceff2fa752f48ced17e4bc7" translate="yes" xml:space="preserve">
          <source>a number</source>
          <target state="translated">すうすう</target>
        </trans-unit>
        <trans-unit id="046c38b0c1d8b4e28f9b3036802beb70f5bc27ff" translate="yes" xml:space="preserve">
          <source>a parameter to give to the callback function</source>
          <target state="translated">コールバック関数に与えるパラメータ</target>
        </trans-unit>
        <trans-unit id="1cde721814013cf593ec03ffb7b7d2acbb857196" translate="yes" xml:space="preserve">
          <source>a parameter to pass to the callback function</source>
          <target state="translated">コールバック関数に渡すパラメータ</target>
        </trans-unit>
        <trans-unit id="b8f7f3c1eda366392609e11b5761750c26f9eb1b" translate="yes" xml:space="preserve">
          <source>a second argument to pass into the transforming function as additional context information</source>
          <target state="translated">追加のコンテキスト情報として変換関数に渡す第二引数</target>
        </trans-unit>
        <trans-unit id="64fcf1af137d36f34598932f6ace3ce897fda0d5" translate="yes" xml:space="preserve">
          <source>a tranforming function that takes the return value of the callback function as input and returns an item to be emitted by the resulting Observable</source>
          <target state="translated">コールバック関数の戻り値を入力として受け取り、結果としてObservableによって放出される項目を返すトランスフォーミング関数です。</target>
        </trans-unit>
        <trans-unit id="d12ef7e3cdfedafdb8947dc6e3897484b12200cc" translate="yes" xml:space="preserve">
          <source>a transforming function that takes an item emitted by the source Observable as its parameter and returns an item to be emitted by the resulting Observable</source>
          <target state="translated">元のObservableから放出されるアイテムをパラメータとして受け取り、結果のObservableから放出されるアイテムを返す変換関数。</target>
        </trans-unit>
        <trans-unit id="6e7e113e681e606f5e008dfe9116078cb537c060" translate="yes" xml:space="preserve">
          <source>a transforming function that takes an item from the array or iterable as input and produces an item to be emitted by the resulting Observable as output</source>
          <target state="translated">配列やイタブルから項目を入力として受け取り、結果としてObservableから出力される項目を生成する変換関数。</target>
        </trans-unit>
        <trans-unit id="ecbebad873608a573c6f88c7adfa7968ec975515" translate="yes" xml:space="preserve">
          <source>a variety of operators that enforce particular flow-control policies</source>
          <target state="translated">特定のフロー制御ポリシーを実行する様々な演算子</target>
        </trans-unit>
        <trans-unit id="75896d78bed7aa685002a0be20721209bce14725" translate="yes" xml:space="preserve">
          <source>additional items have been emitted by that Observable.</source>
          <target state="translated">そのObservableによって追加の項目が放出されました。</target>
        </trans-unit>
        <trans-unit id="f5d953a3114e36aab0e1e2506cada2331d1550b2" translate="yes" xml:space="preserve">
          <source>advances the Scheduler&amp;rsquo;s clock forward by a particular amount of time</source>
          <target state="translated">スケジューラのクロックを特定の時間だけ進めます</target>
        </trans-unit>
        <trans-unit id="8b089b72e7a4725ef2e2624e5e93a0590a197509" translate="yes" xml:space="preserve">
          <source>advances the Scheduler&amp;rsquo;s clock to a particular point in time</source>
          <target state="translated">スケジューラのクロックを特定の時点に進めます</target>
        </trans-unit>
        <trans-unit id="6f6ddadc45f67e2f1110937a7473b4d38d8782fb" translate="yes" xml:space="preserve">
          <source>after a specified delay</source>
          <target state="translated">決められた時間後</target>
        </trans-unit>
        <trans-unit id="25e01a2edb261f8e4f68662596bb4757a3c6699f" translate="yes" xml:space="preserve">
          <source>allows you create a custom operator</source>
          <target state="translated">を使用すると、カスタム演算子を作成することができます。</target>
        </trans-unit>
        <trans-unit id="eb1c47b9488976a153de840013f1e8555fdd7b89" translate="yes" xml:space="preserve">
          <source>an object that associates those keys with particular Observables</source>
          <target state="translated">これらのキーを特定の Observables に関連付けるオブジェクト。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="3ab0c50ba1f5993a1e526134cd25d0da452d1ff0" translate="yes" xml:space="preserve">
          <source>and emit a number indicating how many items were in the sequence</source>
          <target state="translated">を実行して、シーケンス内に何個の項目があったかを示す番号を出力します。</target>
        </trans-unit>
        <trans-unit id="4a96b1b08e9ed381d5574e8e1f21549df303d3ad" translate="yes" xml:space="preserve">
          <source>and emit a single boolean indicating if &lt;em&gt;all&lt;/em&gt; of the items pass some test</source>
          <target state="translated">そして、&lt;em&gt;すべて&lt;/em&gt;の項目が何らかのテストに合格したかどうかを示す単一のブール値を出力します</target>
        </trans-unit>
        <trans-unit id="e69d22261ea99b45a17a8dc23bdd2a7509965bc6" translate="yes" xml:space="preserve">
          <source>and emit a single boolean indicating if the Observable emitted &lt;em&gt;any&lt;/em&gt; item (that passes some test)</source>
          <target state="translated">Observableがアイテムを放出した&lt;em&gt;か&lt;/em&gt;どうかを示す単一のブール値を放出&lt;em&gt;し&lt;/em&gt;ます（テストに合格）</target>
        </trans-unit>
        <trans-unit id="7baf48599e88aaeeb73e266a7efd0e148448e0f5" translate="yes" xml:space="preserve">
          <source>and emit a single boolean indicating if the Observable emitted &lt;em&gt;no&lt;/em&gt; items</source>
          <target state="translated">Observable &lt;em&gt;が&lt;/em&gt;アイテムを放出し&lt;em&gt;なかった&lt;/em&gt;かどうかを示す単一のブール値を放出します</target>
        </trans-unit>
        <trans-unit id="0c0325d25cb3794f2e6a745d0c90cae1126fc1cb" translate="yes" xml:space="preserve">
          <source>and emit a single boolean indicating if the sequence is identical to one emitted by a second Observable</source>
          <target state="translated">を生成し、そのシーケンスが2番目のObservableによって生成されたものと同一であるかどうかを示すブール値を1つ生成します。</target>
        </trans-unit>
        <trans-unit id="0794b1050db960b48a9d04824c91e65f5e00ebf7" translate="yes" xml:space="preserve">
          <source>and emit the average of all of their values</source>
          <target state="translated">の値の平均値を出力します。</target>
        </trans-unit>
        <trans-unit id="97beebc6577539889da30f39e00f6502491523bf" translate="yes" xml:space="preserve">
          <source>and emit the item with the maximum value</source>
          <target state="translated">で、最大値を持つアイテムをエミットします。</target>
        </trans-unit>
        <trans-unit id="00590436e185ea9db814cea817c3ef29f52817d6" translate="yes" xml:space="preserve">
          <source>and emit the item with the minimum value</source>
          <target state="translated">で、最小値のアイテムをエミットします。</target>
        </trans-unit>
        <trans-unit id="34f796b1a15e3b1cfec4260445200a01d2745463" translate="yes" xml:space="preserve">
          <source>and emit the sum of all of their values</source>
          <target state="translated">と、その値のすべての合計を出力します。</target>
        </trans-unit>
        <trans-unit id="8607e552f2d0c2b275785ec61776399b991f6fd1" translate="yes" xml:space="preserve">
          <source>and emitting all of the items from all of the Observables in whatever order they are received</source>
          <target state="translated">と、すべてのオブザーバブルから、受け取った順にすべてのアイテムを放出します。</target>
        </trans-unit>
        <trans-unit id="7e5c7dcffd0e52405e8fd447dc388fee40056ad8" translate="yes" xml:space="preserve">
          <source>and emitting all of the items from all of the Observables, one Observable at a time</source>
          <target state="translated">と、すべてのObservableから1つずつアイテムを放出していきます。</target>
        </trans-unit>
        <trans-unit id="9b0c7ceb92e8fe98a2db7b7ee8fcfb24c07771ee" translate="yes" xml:space="preserve">
          <source>and emitting the items from only the most-recently emitted of those Observables</source>
          <target state="translated">で、それらのObservablesの中で最も新しく放出されたものだけからアイテムを放出します。</target>
        </trans-unit>
        <trans-unit id="378c88957dfb0a305750c2b80287c13f20833b32" translate="yes" xml:space="preserve">
          <source>and then I want to ask it to start</source>
          <target state="translated">を開始するようにお願いしたいと思います。</target>
        </trans-unit>
        <trans-unit id="8be41e709b3249dd05643a847e4cab1c97aa1205" translate="yes" xml:space="preserve">
          <source>and then emits the complete sequence, even to those who subscribe after the sequence has begun</source>
          <target state="translated">を送信し、シーケンスが開始された後に購読した人にも完全なシーケンスを送信します。</target>
        </trans-unit>
        <trans-unit id="7efd76778a88e660bb12fa24328e717c436d5b4b" translate="yes" xml:space="preserve">
          <source>and then only emits the last item in its sequence</source>
          <target state="translated">で、そのシーケンスの最後の項目のみを出力します。</target>
        </trans-unit>
        <trans-unit id="80e361fe647eb090f7f3e23fe1e78f7661315c15" translate="yes" xml:space="preserve">
          <source>apply a function to each item emitted by an Observable, sequentially, and emit each successive value</source>
          <target state="translated">Observableによって放出された各項目に関数を適用し、連続した値を放出します。</target>
        </trans-unit>
        <trans-unit id="2aae0a97beec75e49732de3acf9a51a6e3f35b06" translate="yes" xml:space="preserve">
          <source>apply a function to each item emitted by an Observable, sequentially, and emit the final value</source>
          <target state="translated">Observableによって放出された各項目に関数を適用し、順次最終的な値を放出します。</target>
        </trans-unit>
        <trans-unit id="7d752f2c5e9504352a8b5051da82d8c592e4d092" translate="yes" xml:space="preserve">
          <source>asynchronous</source>
          <target state="translated">asynchronous</target>
        </trans-unit>
        <trans-unit id="82d5635631c9b07663bb7d672111045b85db490e" translate="yes" xml:space="preserve">
          <source>at particular intervals of time</source>
          <target state="translated">刻々と</target>
        </trans-unit>
        <trans-unit id="36a05b8e8ae34dcb7426101165fea84e7c64e32e" translate="yes" xml:space="preserve">
          <source>attach a timestamp to each item emitted by an Observable indicating when it was emitted</source>
          <target state="translated">Observable によって放出された各アイテムに、それがいつ放出されたかを示すタイムスタンプを添付します。</target>
        </trans-unit>
        <trans-unit id="a2093fde1186db0585ea62a388b9cb2943526699" translate="yes" xml:space="preserve">
          <source>based on all of the items that preceded them</source>
          <target state="translated">前身のものを基準にして</target>
        </trans-unit>
        <trans-unit id="09fecbcf0276d272df9099e0daaaa3b7773fd804" translate="yes" xml:space="preserve">
          <source>begins generating items to emit immediately when it is created. Subscribers typically begin observing the sequence of items emitted by a hot Observable from somewhere in the middle of the sequence, beginning with the first item emitted by the Observable subsequent to the establishment of the subscription. Such an Observable emits items at its own pace, and it is up to its observers to keep up. Examples of items emitted by a hot Observable might include mouse &amp;amp; keyboard events, system events, or stock prices.</source>
          <target state="translated">作成されるとすぐに放出するアイテムの生成を開始します。サブスクライバーは通常、サブスクリプションの確立後にObservableによって発行された最初のアイテムから始めて、シーケンスの途中のどこかからホットObservableによって発行されたアイテムのシーケンスの監視を開始します。このようなObservableは、独自のペースでアイテムを放出し、それを維持するかどうかはオブザーバー次第です。ホットなObservableが発行するアイテムの例には、マウスとキーボードのイベント、システムイベント、株価などがあります。</target>
        </trans-unit>
        <trans-unit id="91742200ee81bc6aadca216cd1711c81b8196c3e" translate="yes" xml:space="preserve">
          <source>below)</source>
          <target state="translated">below)</target>
        </trans-unit>
        <trans-unit id="f59062128d67887221611ec80b08fdc406bd1475" translate="yes" xml:space="preserve">
          <source>but I want it to go away once all of its subscribers unsubscribe</source>
          <target state="translated">でも、購読者が全員退会したら消えてほしい。</target>
        </trans-unit>
        <trans-unit id="7d79de2f1adf708e14a324d60741a611cc35ef65" translate="yes" xml:space="preserve">
          <source>by applying an aggregation function to each item in turn and emitting the result</source>
          <target state="translated">各項目に順に集約関数を適用して結果を出力します。</target>
        </trans-unit>
        <trans-unit id="2aece502258035de89ea708eb33596dfd03c34cb" translate="yes" xml:space="preserve">
          <source>by attaching a timestamp to them</source>
          <target state="translated">タイムスタンプを付けることで</target>
        </trans-unit>
        <trans-unit id="3e27bc3f4d066d8b7c01b9fe0d22804704709389" translate="yes" xml:space="preserve">
          <source>by attempting to resubscribe to the upstream Observable</source>
          <target state="translated">上流の Observable への再サブスクライブを試みることで</target>
        </trans-unit>
        <trans-unit id="6adf44d0eb0023d4304115f3180e433f647a2efc" translate="yes" xml:space="preserve">
          <source>by combining the items from two or more Observables sequentially to come up with new items to emit</source>
          <target state="translated">2つ以上のObservablesのアイテムを順番に組み合わせて、新しいアイテムを生成して放出します。</target>
        </trans-unit>
        <trans-unit id="bcd0218297b656000c1ac71599017790bc85c365" translate="yes" xml:space="preserve">
          <source>by delaying my subscription to it for some time after it begins emitting items</source>
          <target state="translated">アイテムを排出し始めてからしばらくの間、私の購読を遅らせることで</target>
        </trans-unit>
        <trans-unit id="f13876a8f487096fa7ed90f9de5112faf9f39485" translate="yes" xml:space="preserve">
          <source>by emitting all of the items emitted by corresponding Observables</source>
          <target state="translated">対応するObservablesによって放出されるすべての項目を放出することによって</target>
        </trans-unit>
        <trans-unit id="1dd53da47c6b8eff8a39ffadc7d377be35e20425" translate="yes" xml:space="preserve">
          <source>by filtering out those that do not match some predicate</source>
          <target state="translated">ある述語にマッチしないものをフィルタリングすることで</target>
        </trans-unit>
        <trans-unit id="d47503a1e21d807bffb852a194a725c2958558e3" translate="yes" xml:space="preserve">
          <source>by means of &lt;code&gt;Pattern&lt;/code&gt; and &lt;code&gt;Plan&lt;/code&gt; intermediaries</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; と &lt;code&gt;Plan&lt;/code&gt; 仲介</target>
        </trans-unit>
        <trans-unit id="63d6688bc3922632efdebc442218b0ecad0527ea" translate="yes" xml:space="preserve">
          <source>by only emitting items that are not followed by other items within some duration</source>
          <target state="translated">一定の期間内に他のアイテムに追従しないアイテムのみを放出することで</target>
        </trans-unit>
        <trans-unit id="988bc528771482a14d8f05b39fe9e424a0118901" translate="yes" xml:space="preserve">
          <source>by retrieving it from a Future</source>
          <target state="translated">から取得することで</target>
        </trans-unit>
        <trans-unit id="869bf59133792be52e036bb3d7b589950917bf15" translate="yes" xml:space="preserve">
          <source>by sampling the Observable periodically</source>
          <target state="translated">定期的にObservableをサンプリングすることで</target>
        </trans-unit>
        <trans-unit id="90a1749d56333543d881676b625ec860961f55ef" translate="yes" xml:space="preserve">
          <source>by suppressing items that are duplicates of already-emitted items</source>
          <target state="translated">既に排出されたアイテムの重複アイテムを抑制することで</target>
        </trans-unit>
        <trans-unit id="7af15572c56ca7d62d1cfa5ddac5af0712b1c125" translate="yes" xml:space="preserve">
          <source>by the Observable to the observer</source>
          <target state="translated">観察者へのオブザーバブルによる</target>
        </trans-unit>
        <trans-unit id="dd78b511d8fcb0430492c6c02e9aa1973bb65655" translate="yes" xml:space="preserve">
          <source>by wrapping them in &lt;code&gt;Notification&lt;/code&gt; objects</source>
          <target state="translated">それらを &lt;code&gt;Notification&lt;/code&gt; オブジェクトでラップする</target>
        </trans-unit>
        <trans-unit id="19068047789a81691f13158a43b02076c65041df" translate="yes" xml:space="preserve">
          <source>calculates the average of numbers emitted by an Observable and emits this average</source>
          <target state="translated">Observableによって放出される数値の平均を計算し、この平均を放出します。</target>
        </trans-unit>
        <trans-unit id="87e72635cfd6cb3993ed2975332903fc2b28069d" translate="yes" xml:space="preserve">
          <source>calculates the sum of numbers emitted by an Observable and emits this sum</source>
          <target state="translated">Observableによって放出される数値の和を計算し、その和を放出します。</target>
        </trans-unit>
        <trans-unit id="ef83875cbdebb3066a5df980de002d8b7230c128" translate="yes" xml:space="preserve">
          <source>cold Observable</source>
          <target state="translated">寒さ 観測可能</target>
        </trans-unit>
        <trans-unit id="6710d8c63778707e72df57fc2aba9fa135efbe94" translate="yes" xml:space="preserve">
          <source>combine items emitted by two Observables whenever an item from one Observable is emitted during a time window defined according to an item emitted by the other Observable</source>
          <target state="translated">一方のObservableからのアイテムが他方のObservableによって放出されたアイテムに応じて定義された時間ウィンドウの間に放出された場合、2つのObservableによって放出されたアイテムを結合します。</target>
        </trans-unit>
        <trans-unit id="d8a85be857c4b8d572be8a8cd2e6f9d20bae0516" translate="yes" xml:space="preserve">
          <source>combine multiple Observables into one by merging their emissions</source>
          <target state="translated">複数の観測可能量の排出量をマージして1つの観測可能量に結合する</target>
        </trans-unit>
        <trans-unit id="d70c4db347b466165449fd0675674217d45894d7" translate="yes" xml:space="preserve">
          <source>combine sets of items emitted by two or more Observables by means of Pattern and Plan intermediaries</source>
          <target state="translated">パターンとプランの仲介により、複数のオブザーバブルから放出されるアイテムの集合を組み合わせる。</target>
        </trans-unit>
        <trans-unit id="aa40fbaa4ea0a034c51bceacc20bdceaa6365554" translate="yes" xml:space="preserve">
          <source>combine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function</source>
          <target state="translated">複数のObservablesの排出を指定された関数を介して結合し、この関数の結果に基づいて各結合に対して単一の項目を排出します。</target>
        </trans-unit>
        <trans-unit id="0737c22d3bfae812339732d14d8c7dbd6dc4e09c" translate="yes" xml:space="preserve">
          <source>complete</source>
          <target state="translated">complete</target>
        </trans-unit>
        <trans-unit id="537bac49fb381519e179be6b0008c6ba0263e54a" translate="yes" xml:space="preserve">
          <source>compose</source>
          <target state="translated">compose</target>
        </trans-unit>
        <trans-unit id="49ba358c3272c2db40fc6ab2c103669678628b68" translate="yes" xml:space="preserve">
          <source>concat</source>
          <target state="translated">concat</target>
        </trans-unit>
        <trans-unit id="d90ad13cbc688a267267cf995a732fd5a221778e" translate="yes" xml:space="preserve">
          <source>concat and concatWith</source>
          <target state="translated">コンカットとコンカットウィズ</target>
        </trans-unit>
        <trans-unit id="5a528204c79768fa06e40aa1f390858060705983" translate="yes" xml:space="preserve">
          <source>concatWith</source>
          <target state="translated">concatWith</target>
        </trans-unit>
        <trans-unit id="4a87f56a7be04873edc5dab9dfcbea43167dcda6" translate="yes" xml:space="preserve">
          <source>concatenates the items emitted by multiple Singles as Observable emissions</source>
          <target state="translated">複数のシングルスから排出された項目をObservable排出量として連結します。</target>
        </trans-unit>
        <trans-unit id="920b046593a982bd8c911c015fbe228693c49096" translate="yes" xml:space="preserve">
          <source>connectable Observable</source>
          <target state="translated">接続可能 オブザーバブル</target>
        </trans-unit>
        <trans-unit id="e07fc362e1775ed78d4cb3db16f025093e05f2f8" translate="yes" xml:space="preserve">
          <source>containing only the last items emitted</source>
          <target state="translated">最後に排出されたものだけを含む</target>
        </trans-unit>
        <trans-unit id="855a0fc1d9acb3d7fad5d79757204568eb80f0d4" translate="yes" xml:space="preserve">
          <source>convert an Observable into another object or data structure</source>
          <target state="translated">オブザーバブルを別のオブジェクトやデータ構造に変換する</target>
        </trans-unit>
        <trans-unit id="d8272ed0eb1bc3fc9a572fe8071362ed69127653" translate="yes" xml:space="preserve">
          <source>convert an Observable that emits Observables into a single Observable that emits the items emitted by the most-recently-emitted of those Observables</source>
          <target state="translated">Observablesを放出するObservableを、それらのObservableのうち最も最近放出された項目を放出する単一のObservableに変換します。</target>
        </trans-unit>
        <trans-unit id="e912523a996828d3bf0fbb542911199b9dcd4945" translate="yes" xml:space="preserve">
          <source>convert an Observable that emits items into one that emits indications of the amount of time elapsed between those emissions</source>
          <target state="translated">アイテムを排出するObservableを、それらの排出の間の経過時間を表示するObservableに変換します。</target>
        </trans-unit>
        <trans-unit id="b3b0d4dac76ddef2f79e3a08df1975b9c86b9d98" translate="yes" xml:space="preserve">
          <source>convert an ordinary Observable into a connectable Observable</source>
          <target state="translated">通常のObservableを接続可能なObservableに変換する</target>
        </trans-unit>
        <trans-unit id="36c287e5fcff20eaf16d26dfb5475062c8618c56" translate="yes" xml:space="preserve">
          <source>convert various other objects and data types into Observables</source>
          <target state="translated">他の様々なオブジェクトやデータ型をObservablesに変換します。</target>
        </trans-unit>
        <trans-unit id="f4ca7b1d875550de063360cab8f9cf4978c92d84" translate="yes" xml:space="preserve">
          <source>converts a Future into a Single</source>
          <target state="translated">未来を一つのものに変える</target>
        </trans-unit>
        <trans-unit id="cb8e1c3f3e599ff85786d96efc6bdfd9903b7f27" translate="yes" xml:space="preserve">
          <source>converts a Single into an Observable that emits the item emitted by the Single and then completes</source>
          <target state="translated">SingleをSingleによって放出されたアイテムを放出するObservableに変換します。</target>
        </trans-unit>
        <trans-unit id="95bc015cb9a9c64e9443baea3c1aaa8ac7f29d16" translate="yes" xml:space="preserve">
          <source>converts a Single that emits a second Single into a Single that emits the item emitted by the second Single</source>
          <target state="translated">2つ目のSingleを排出するSingleを、2つ目のSingleが排出するアイテムを排出するSingleに変換します。</target>
        </trans-unit>
        <trans-unit id="170368d03dc716d2f7e2d2bf74c31d9d92aa4f43" translate="yes" xml:space="preserve">
          <source>converts a Single that makes an error notification into a Single that emits a specified item</source>
          <target state="translated">エラー通知を行うシングルを、指定された項目を放出するシングルに変換します。</target>
        </trans-unit>
        <trans-unit id="21c864aec311796f6a8ee3738b2863e2059f40bf" translate="yes" xml:space="preserve">
          <source>converts an Observable that emits a single item into a Single that emits that item</source>
          <target state="translated">単一の項目を出すObservableを、その項目を出すSingleに変換します。</target>
        </trans-unit>
        <trans-unit id="1888c76c0a8234b805afa72fa84387df9c464cdd" translate="yes" xml:space="preserve">
          <source>conveys an</source>
          <target state="translated">伝える</target>
        </trans-unit>
        <trans-unit id="cc33275c066e42225c7bd44275e209912fa780f0" translate="yes" xml:space="preserve">
          <source>count the number of items emitted by the source Observable and emit only this value</source>
          <target state="translated">ソースObservableによって放出されたアイテムの数をカウントし、この値だけを放出します。</target>
        </trans-unit>
        <trans-unit id="9b7c68a918b17eb053809b198d7c9abfc142f30a" translate="yes" xml:space="preserve">
          <source>create</source>
          <target state="translated">create</target>
        </trans-unit>
        <trans-unit id="fdb38e7814f867156c67f7710cb229b4d10b3201" translate="yes" xml:space="preserve">
          <source>create a Single from scratch by calling subscriber methods explicitly</source>
          <target state="translated">subscriber メソッドを明示的に呼び出して、最初から Single を作成します。</target>
        </trans-unit>
        <trans-unit id="2ae303adc776faa5253a43fb06677635513e17d9" translate="yes" xml:space="preserve">
          <source>create a disposable resource that has the same lifespan as the Observable</source>
          <target state="translated">Observableと同じ寿命を持つ使い捨てのリソースを作成します。</target>
        </trans-unit>
        <trans-unit id="c6a8aff547f069fdb80cd76a7872c7f620a75366" translate="yes" xml:space="preserve">
          <source>create an Observable from scratch by means of a function</source>
          <target state="translated">関数を使って一からObservableを作成する</target>
        </trans-unit>
        <trans-unit id="b33eccb560190edb81875010369904b2976a67f7" translate="yes" xml:space="preserve">
          <source>create an Observable that emits a particular item</source>
          <target state="translated">特定の項目を放出するObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="82295320e101fc0781587bba12bb5acf15af8c48" translate="yes" xml:space="preserve">
          <source>create an Observable that emits a particular item after a given delay</source>
          <target state="translated">与えられた遅延後に特定のアイテムを放出するObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="1e3219e49f0c47c7c71d11d751ede2c8e6c514ac" translate="yes" xml:space="preserve">
          <source>create an Observable that emits a particular item multiple times</source>
          <target state="translated">特定の項目を複数回放出するObservableを作成する</target>
        </trans-unit>
        <trans-unit id="ca0465f5eb874bf38df3fa2364bec78c08742f29" translate="yes" xml:space="preserve">
          <source>create an Observable that emits a particular range of sequential integers</source>
          <target state="translated">特定の範囲の連続した整数を放出するObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="92ee38dc48832f578e61897964a8273e3909af09" translate="yes" xml:space="preserve">
          <source>create an Observable that emits a sequence of integers spaced by a given time interval</source>
          <target state="translated">与えられた時間間隔で間隔をあけて整数のシーケンスを放出するObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="8d4e5b41bfe8dba9a089b2fe7c6570c481c904ad" translate="yes" xml:space="preserve">
          <source>create an Observable that emits no items and does not terminate</source>
          <target state="translated">項目を出さず、終了しないObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="03c73352ceb55a7c10db1ec5d57ebb0ef733141c" translate="yes" xml:space="preserve">
          <source>create an Observable that emits no items and terminates with an error</source>
          <target state="translated">アイテムを放出せず、エラーで終了するObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="32eb01d241a8343531a01127a803a32299028ff2" translate="yes" xml:space="preserve">
          <source>create an Observable that emits no items but terminates normally</source>
          <target state="translated">アイテムを出さずに正常終了するObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="b79d1c80846e9d369b49bcd22a30738b8cdee801" translate="yes" xml:space="preserve">
          <source>create an Observable that emits the return value of a function-like directive</source>
          <target state="translated">関数のようなディレクティブの戻り値を出すObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="a5561cb95df07e2d89b98437823d320627cdba07" translate="yes" xml:space="preserve">
          <source>creates a new thread for each unit of work</source>
          <target state="translated">作業単位ごとに新しいスレッドを作成します。</target>
        </trans-unit>
        <trans-unit id="ab464f0252045aaf075411f0f1a6aed0797306c1" translate="yes" xml:space="preserve">
          <source>delay</source>
          <target state="translated">delay</target>
        </trans-unit>
        <trans-unit id="cb329146a0dd0d566b0628744d67936558741ffa" translate="yes" xml:space="preserve">
          <source>description</source>
          <target state="translated">description</target>
        </trans-unit>
        <trans-unit id="0130195fe419912b70a512541e4691345f6674cd" translate="yes" xml:space="preserve">
          <source>determine whether all items emitted by an Observable meet some criteria</source>
          <target state="translated">Observableによって放出された全てのアイテムがある基準を満たしているかどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="ff3cae2ef561f628b8c891daa60ccb56db8aa32f" translate="yes" xml:space="preserve">
          <source>determine whether an Observable emits a particular item or not</source>
          <target state="translated">Observableが特定の項目を出すかどうかを判断する</target>
        </trans-unit>
        <trans-unit id="7509d1ff7d8d151dbcd5969fef9f3f655099c57a" translate="yes" xml:space="preserve">
          <source>determine whether two Observables emit the same sequence of items</source>
          <target state="translated">2つのObservablesが同じシーケンスの項目を放出するかどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="a3f45eefb0dd1450098d33b7dcd8b10e899ebd54" translate="yes" xml:space="preserve">
          <source>discard any items emitted by an Observable after a second Observable emits an item or terminates</source>
          <target state="translated">2番目のObservableがアイテムを放出した後、または終了した後にObservableから放出されたアイテムを破棄します。</target>
        </trans-unit>
        <trans-unit id="7ef61ce8a5dffd0c260e15eb10d12d5974f6b1e1" translate="yes" xml:space="preserve">
          <source>discard items emitted by an Observable until a second Observable emits an item</source>
          <target state="translated">2番目のObservableがアイテムを放出するまで、Observableから放出されたアイテムを破棄します。</target>
        </trans-unit>
        <trans-unit id="3691b3deaeb85a3b9c3076808d8d13e2c9ca15c4" translate="yes" xml:space="preserve">
          <source>discard items emitted by an Observable until a specified condition becomes false</source>
          <target state="translated">特定の条件がFalseになるまで、Observableから放出されたアイテムを破棄します。</target>
        </trans-unit>
        <trans-unit id="a24279f0df1b28b11e1ed236842b46f562322a29" translate="yes" xml:space="preserve">
          <source>discover error</source>
          <target state="translated">あやまりをみつける</target>
        </trans-unit>
        <trans-unit id="946dc974300f80e10583bc68927d8820e58b6ce8" translate="yes" xml:space="preserve">
          <source>divide an Observable into a set of Observables that each emit a different subset of items from the original Observable</source>
          <target state="translated">Observable を分割して、元の Observable から異なるサブセットのアイテムを放出する Observable のセットにします。</target>
        </trans-unit>
        <trans-unit id="11e6899e09d5b0e21dac51ae558f249603206247" translate="yes" xml:space="preserve">
          <source>do not create the Observable until the observer subscribes, and create a fresh Observable for each observer</source>
          <target state="translated">オブザーバがサブスクライブするまではObservableを作成せず、各オブザーバごとに新しいObservableを作成します。</target>
        </trans-unit>
        <trans-unit id="2332dd1e2b522343e16599f71fb2fde4233ff0ac" translate="yes" xml:space="preserve">
          <source>do not emit any items from an Observable but mirror its termination notification</source>
          <target state="translated">は、Observable からアイテムを放出するのではなく、その終了通知をミラーします。</target>
        </trans-unit>
        <trans-unit id="b0d186043ed808f44ab3b75ef20a1f576b6d7d31" translate="yes" xml:space="preserve">
          <source>doOnError</source>
          <target state="translated">doOnError</target>
        </trans-unit>
        <trans-unit id="7193c8c35518b2a87f4d4244048219ccdb80780b" translate="yes" xml:space="preserve">
          <source>doOnSuccess</source>
          <target state="translated">doOnSuccess</target>
        </trans-unit>
        <trans-unit id="a56b577350353096fb8dd622bb5aca0c9bec85e9" translate="yes" xml:space="preserve">
          <source>does it divide its work over multiple threads that may return data to the caller in any order?</source>
          <target state="translated">呼び出し元に任意の順序でデータを返すことができる複数のスレッドに渡って作業を分割するのでしょうか?</target>
        </trans-unit>
        <trans-unit id="e9a705a6cefc203dae4d8a9f3133b7eb64ecee9b" translate="yes" xml:space="preserve">
          <source>does it use NIO with an event-loop to do asynchronous network access?</source>
          <target state="translated">非同期ネットワークアクセスを行うためにイベントループ付きのNIOを使用していますか?</target>
        </trans-unit>
        <trans-unit id="c61eeb26d4303ae3094656f0c7c99d06a7fd47e5" translate="yes" xml:space="preserve">
          <source>does it use an Actor (or multiple Actors) instead of a thread pool?</source>
          <target state="translated">スレッドプールの代わりにアクター(または複数のアクター)を使用しますか?</target>
        </trans-unit>
        <trans-unit id="d45843eeab32a602d9af842b03276dd264c86fb3" translate="yes" xml:space="preserve">
          <source>does it use an event-loop to separate the work thread from the callback thread?</source>
          <target state="translated">作業スレッドとコールバックスレッドを分離するためにイベントループを使用していますか?</target>
        </trans-unit>
        <trans-unit id="5fa3c300a8b1aa79b5251cfec9489f85c1fe4ecc" translate="yes" xml:space="preserve">
          <source>does it work asynchronously on a distinct thread?</source>
          <target state="translated">は別スレッドで非同期に動作しますか?</target>
        </trans-unit>
        <trans-unit id="90c3f6d02b875e5084eb3ab9fe4d1f72abaab63b" translate="yes" xml:space="preserve">
          <source>does it work synchronously on the same thread as the caller?</source>
          <target state="translated">呼び出し元と同じスレッドで同期的に動作しますか?</target>
        </trans-unit>
        <trans-unit id="710324ca59ab0fb7cedc97294ff18e57250aa3d3" translate="yes" xml:space="preserve">
          <source>element, or a NodeList, jQuery element, Zepto Element, Angular element, Ember.js element, or EventEmitter.</source>
          <target state="translated">要素、またはNodeList、jQuery要素、Zepto要素、Angular要素、Ember.js要素、またはEventEmitter。</target>
        </trans-unit>
        <trans-unit id="543f8528a5a36e0fd63ca3d3b9efd3632fd5f9fe" translate="yes" xml:space="preserve">
          <source>emit a specified sequence of items before beginning to emit the items from the source Observable</source>
          <target state="translated">ソースオブザーバブルからのアイテムの放出を開始する前に、指定されたシーケンスのアイテムを放出します。</target>
        </trans-unit>
        <trans-unit id="769fc1172fe01d37dc2f7e2713413d7a65503510" translate="yes" xml:space="preserve">
          <source>emit items from the source Observable, or a default item if the source Observable emits nothing</source>
          <target state="translated">ソースObservableが何も出さない場合はデフォルトのアイテムを出します。</target>
        </trans-unit>
        <trans-unit id="a115af0876acd2b5e8fcdc6c52560200a454030f" translate="yes" xml:space="preserve">
          <source>emit only item</source>
          <target state="translated">項目だけを出す</target>
        </trans-unit>
        <trans-unit id="02aaf586c2920f9cf2072e5c133fdd3df98c558a" translate="yes" xml:space="preserve">
          <source>emit only the final</source>
          <target state="translated">締めくくりだけを出す</target>
        </trans-unit>
        <trans-unit id="283d4e16f73e8edadb26e90e4c88dd395606afff" translate="yes" xml:space="preserve">
          <source>emit only the first</source>
          <target state="translated">最初のものだけを出す</target>
        </trans-unit>
        <trans-unit id="c1a6d921096c6a9cea1ec58a1d7915ffd2cb0a6c" translate="yes" xml:space="preserve">
          <source>emit only the first item (or the first item that meets some condition) emitted by an Observable</source>
          <target state="translated">Observableによって放出された最初のアイテム(または条件を満たす最初のアイテム)のみを放出します。</target>
        </trans-unit>
        <trans-unit id="f7170ccdd023f5a086caa059f65476d0bdf1f23e" translate="yes" xml:space="preserve">
          <source>emit only the last item (or the last item that meets some condition) emitted by an Observable</source>
          <target state="translated">Observableによって放出された最後のアイテム(または条件を満たす最後のアイテム)のみを放出する</target>
        </trans-unit>
        <trans-unit id="c526ff4f61953d2c1ad9b75959a34d517116b608" translate="yes" xml:space="preserve">
          <source>emit only those items from an Observable that pass a predicate test</source>
          <target state="translated">述語テストに合格したObservableのアイテムだけを放出します。</target>
        </trans-unit>
        <trans-unit id="f2e3b63fe53b455567c0ba6e3aace08cba7b101c" translate="yes" xml:space="preserve">
          <source>emit the emissions from two or more Observables without interleaving them</source>
          <target state="translated">2つ以上のObservablesからの放出を、それらを介在させずに放出する。</target>
        </trans-unit>
        <trans-unit id="5b3c959fdd976b09cc3b28b3011f1ca1bcdb8853" translate="yes" xml:space="preserve">
          <source>emit the most recent items emitted by an Observable within periodic time intervals</source>
          <target state="translated">周期的な時間間隔でObservableから最新のアイテムを放出する</target>
        </trans-unit>
        <trans-unit id="53f9ce69544263d25131c6704271a197bba315a5" translate="yes" xml:space="preserve">
          <source>emits</source>
          <target state="translated">emits</target>
        </trans-unit>
        <trans-unit id="a442b9237df23abb5cc5420387c221e8a2aeccc5" translate="yes" xml:space="preserve">
          <source>emits a particular sequence of items, but can begin emitting this sequence when its observer finds it to be convenient, and at whatever rate the observer desires, without disrupting the integrity of the sequence. For example if you convert a static iterable into an Observable, that Observable will emit the same sequence of items no matter when it is later subscribed to or how frequently those items are observed. Examples of items emitted by a cold Observable might include the results of a database query, file retrieval, or web request.</source>
          <target state="translated">は特定の項目のシーケンスを放出しますが、観測者がそれが便利であると判断したときには、シーケンスの整合性を崩すことなく、観測者が望む速度で、このシーケンスを放出し始めることができます。例えば、静的なiterableをObservableに変換した場合、Observableは、いつそれがサブスクライブされても、どれだけの頻度で観測されても、同じシーケンスのアイテムを放出します。冷たいObservableによって生成されるアイテムの例としては、データベースクエリ、ファイル検索、ウェブリクエストの結果などがあります。</target>
        </trans-unit>
        <trans-unit id="9f22b2c00b19a035731d14ad74cd7c6d05921206" translate="yes" xml:space="preserve">
          <source>emits the item from the source Observable that had the maximum value</source>
          <target state="translated">最大値を持つソースObservableからアイテムを放出します。</target>
        </trans-unit>
        <trans-unit id="74d826ddf8287874d3ee8212bbe2a72b20190f91" translate="yes" xml:space="preserve">
          <source>emits the item from the source Observable that had the minimum value</source>
          <target state="translated">最小値を持つソースObservableからアイテムを放出します。</target>
        </trans-unit>
        <trans-unit id="9665ac3929f268285506b88deec23cb12f0e63bd" translate="yes" xml:space="preserve">
          <source>emitted</source>
          <target state="translated">emitted</target>
        </trans-unit>
        <trans-unit id="88d6618f3561fa3cb57d650ace09305ee6f0d428" translate="yes" xml:space="preserve">
          <source>emitted by an Observable</source>
          <target state="translated">はっしゃ</target>
        </trans-unit>
        <trans-unit id="7e4f940b5782633c616f37bc35675c5163ed9a19" translate="yes" xml:space="preserve">
          <source>emitted by the Observable.</source>
          <target state="translated">によって放出される。</target>
        </trans-unit>
        <trans-unit id="71e9b710ca7e783890b77f938203768b335532b7" translate="yes" xml:space="preserve">
          <source>ensure that all observers see the same sequence of emitted items, even if they subscribe after the Observable has begun emitting items</source>
          <target state="translated">Observable がアイテムを出し始めた後にサブスクライブしても、すべてのオブザーバーが同じシーケンスのアイテムを見ることを保証します。</target>
        </trans-unit>
        <trans-unit id="11f9578d05e6f7bb58a3cdd00107e9f4e3882671" translate="yes" xml:space="preserve">
          <source>error</source>
          <target state="translated">error</target>
        </trans-unit>
        <trans-unit id="5006ed0248a019713b762563076292379daf07b4" translate="yes" xml:space="preserve">
          <source>event</source>
          <target state="translated">event</target>
        </trans-unit>
        <trans-unit id="ccc9d4f948ad94c5bbe07a1feee18738df60b756" translate="yes" xml:space="preserve">
          <source>flatMap</source>
          <target state="translated">flatMap</target>
        </trans-unit>
        <trans-unit id="378ce4f507ad3e73799fb43d9c5ee511ddbf655c" translate="yes" xml:space="preserve">
          <source>flatMapObservable</source>
          <target state="translated">flatMapObservable</target>
        </trans-unit>
        <trans-unit id="4bd229d639cd13fb02a63b1261609ad0439b9c86" translate="yes" xml:space="preserve">
          <source>for each observer that subscribes</source>
          <target state="translated">を購読している各オブザーバに対して</target>
        </trans-unit>
        <trans-unit id="6074cf77c3da497067408b6c04f9a98a7d0a3bf9" translate="yes" xml:space="preserve">
          <source>for unit testing; this allows you to manually manipulate the movement of time</source>
          <target state="translated">これにより、時間の動きを手動で操作することができます。</target>
        </trans-unit>
        <trans-unit id="746e807e0dba440c42eb9deaeab2869069904a18" translate="yes" xml:space="preserve">
          <source>force an Observable to make serialized calls and to be well-behaved</source>
          <target state="translated">Observableに直列化された呼び出しをさせて、うまく振る舞うようにします。</target>
        </trans-unit>
        <trans-unit id="0b1e95cfd9775191a7224d0a218ae79187e80c1d" translate="yes" xml:space="preserve">
          <source>from</source>
          <target state="translated">from</target>
        </trans-unit>
        <trans-unit id="f1d7632831475751406b7847814481cce36b28fc" translate="yes" xml:space="preserve">
          <source>from a timeout by switching to a backup Observable</source>
          <target state="translated">バックアップに切り替えることでタイムアウトから解放されます。</target>
        </trans-unit>
        <trans-unit id="4ab8e53e57dab3b5525830c9e68479df42938a79" translate="yes" xml:space="preserve">
          <source>from an upstream error notification</source>
          <target state="translated">上流のエラー通知から</target>
        </trans-unit>
        <trans-unit id="7338bb521aa9cdd1bef4a257ca363c0096b6e672" translate="yes" xml:space="preserve">
          <source>from scratch, with custom logic</source>
          <target state="translated">カスタムロジックでゼロから</target>
        </trans-unit>
        <trans-unit id="5a492ec6db38b38bc93bc93c566d523b475eca95" translate="yes" xml:space="preserve">
          <source>given two or more source Observables, emit all of the items from only the first of these Observables to emit an item or notification</source>
          <target state="translated">2つ以上のソースObservablesが与えられた場合、最初のObservablesからすべてのアイテムを放出し、アイテムや通知を放出します。</target>
        </trans-unit>
        <trans-unit id="230d0d8c960eb6b08fb0602b808641addcc39716" translate="yes" xml:space="preserve">
          <source>happens-before</source>
          <target state="translated">happens-before</target>
        </trans-unit>
        <trans-unit id="51226a41675d8138b62f4eb13f05814105d80981" translate="yes" xml:space="preserve">
          <source>hot Observable</source>
          <target state="translated">暑い 観測可能</target>
        </trans-unit>
        <trans-unit id="762383040ebcbba981d0e6627015750c613068be" translate="yes" xml:space="preserve">
          <source>if a source Observable emits an error, resubscribe to it in the hopes that it will complete without error</source>
          <target state="translated">ソースObservableがエラーを出した場合は、エラーなしで完了することを期待して再購読します。</target>
        </trans-unit>
        <trans-unit id="b7eef0381b59d94b8b2e60cf2c77d995768de18a" translate="yes" xml:space="preserve">
          <source>if a specified period of time elapses without it emitting an item</source>
          <target state="translated">アイテムを排出せずに一定時間が経過した場合</target>
        </trans-unit>
        <trans-unit id="c07264c1fd314b3c228343a6b7aa32c253cc1c83" translate="yes" xml:space="preserve">
          <source>if they immediately follow the item they are duplicates of</source>
          <target state="translated">の複製です。</target>
        </trans-unit>
        <trans-unit id="847acd37db27d351d2cbeb11978036131dab6677" translate="yes" xml:space="preserve">
          <source>indicates that the Observable has completed successfully and that it will be emitting no further items</source>
          <target state="translated">は、Observableが正常に終了し、それ以上アイテムを放出しないことを示します。</target>
        </trans-unit>
        <trans-unit id="59bab5bf8560c12918e09739c3c2a53cf71eee79" translate="yes" xml:space="preserve">
          <source>indicates that the Observable has terminated with a specified error condition and that it will be emitting no further items</source>
          <target state="translated">は、Observableが指定されたエラー条件で終了し、それ以上の項目を放出しないことを示します。</target>
        </trans-unit>
        <trans-unit id="57c80aa16dbb40cbb50b4685e19ae54bb36188e5" translate="yes" xml:space="preserve">
          <source>indicates that the Observable is ready to accept Request notifications from the observer (see</source>
          <target state="translated">は、Observableがオブザーバからのリクエスト通知を受け付ける準備ができていることを示します。</target>
        </trans-unit>
        <trans-unit id="d80a3dc0bd493e47930194898002eecbd9780bcc" translate="yes" xml:space="preserve">
          <source>indicates that the observer is ready to receive notifications from the Observable</source>
          <target state="translated">は、オブザーバがObservableからの通知を受け取る準備ができていることを示します。</target>
        </trans-unit>
        <trans-unit id="03c2a4397d8fb4d3e801b370f28da5452181212d" translate="yes" xml:space="preserve">
          <source>indicates that the observer no longer wants to receive notifications from the Observable</source>
          <target state="translated">は、オブザーバがObservableからの通知を受け取りたくないことを示します。</target>
        </trans-unit>
        <trans-unit id="7720d844d06776ca6a9a6e7116dc341d37719b6c" translate="yes" xml:space="preserve">
          <source>indicates that the observer wants no more than a particular number of additional OnNext notifications from the Observable (see</source>
          <target state="translated">は、オブザーバーがObservableからのOnNext通知を特定の数以上望んでいないことを示します(</target>
        </trans-unit>
        <trans-unit id="d772411175504239715809db32a049bd5f9a24eb" translate="yes" xml:space="preserve">
          <source>instruct a connectable Observable to begin emitting items to its subscribers</source>
          <target state="translated">接続可能なObservableに、そのサブスクライバにアイテムの放出を開始するように指示します。</target>
        </trans-unit>
        <trans-unit id="3e70b2ffd83c9f25ae3b87ef19a913ca3c280c74" translate="yes" xml:space="preserve">
          <source>instructs an Observable to begin emitting a second Observable sequence if it encounters an error</source>
          <target state="translated">エラーが発生した場合、Observableに2番目のObservableシーケンスの発行を開始するように指示します。</target>
        </trans-unit>
        <trans-unit id="d93ae2066632ae68fa3e9d24a83479d6a6125575" translate="yes" xml:space="preserve">
          <source>instructs an Observable to begin emitting a second Observable sequence if it encounters an error or if the source Observable terminates normally</source>
          <target state="translated">エラーが発生した場合、またはソースのObservableが正常に終了した場合、Observableに2番目のObservableシーケンスの発行を開始するよう指示します。</target>
        </trans-unit>
        <trans-unit id="c0cd3f6eebd1f6d2d2b9042e39803a1c070a6c65" translate="yes" xml:space="preserve">
          <source>instructs an Observable to begin emitting items from another Observable, or from an Observable returned from an action, if it encounters an error</source>
          <target state="translated">エラーが発生した場合、別のObservableやアクションから返されたObservableからアイテムを放出するようにObservableに指示します。</target>
        </trans-unit>
        <trans-unit id="22e38a48635b45db863e539f2c56ed48d008c816" translate="yes" xml:space="preserve">
          <source>instructs an Observable to concatenate items emitted by a set of other Observables, one Observable at a time, regardless of whether the source Observable or any subsequent Observable terminates with an error</source>
          <target state="translated">元のObservableやそれ以降のObservableがエラーで終了するかどうかに関わらず、Observableに他のObservableのセットから放出されるアイテムを一つずつ連結するよう指示します。</target>
        </trans-unit>
        <trans-unit id="488263840997c93e29d532e89e384512092c9225" translate="yes" xml:space="preserve">
          <source>instructs an Observable to concatenate items emitted by another Observable to the sequence emitted by the source Observable, regardless of whether the source Observable terminates normally or with an error</source>
          <target state="translated">ソースObservableが正常終了するかエラーで終了するかに関わらず、別のObservableによって放出されたアイテムをソースObservableによって放出されたシーケンスに連結するようにObservableに指示します。</target>
        </trans-unit>
        <trans-unit id="97c6213e9fd3b3b94003a1080aa20fcc201250e2" translate="yes" xml:space="preserve">
          <source>instructs an Observable to continue emitting items after it encounters an exception (but not another variety of throwable)</source>
          <target state="translated">例外が発生した後もアイテムを放出し続けるようにObservableに指示します(他の種類のスローアブルではありません)。</target>
        </trans-unit>
        <trans-unit id="ffd411015f886b118c92de6b6395db72b3070d73" translate="yes" xml:space="preserve">
          <source>instructs an Observable to emit a particular item when it encounters an error, and then terminate normally</source>
          <target state="translated">エラーが発生したときに特定の項目を出力し、正常終了するようにObservableに指示します。</target>
        </trans-unit>
        <trans-unit id="4d7e5498f8a1b2653573be7dedf0e0305669acdd" translate="yes" xml:space="preserve">
          <source>instructs an Observable, if it encounters an error, to begin emitting items from a set of other Observables, one Observable at a time, until one of those Observables terminates successfully</source>
          <target state="translated">もしエラーが発生した場合、Observable が正常に終了するまで、他のObservable のセットからアイテムを放出するように指示します。</target>
        </trans-unit>
        <trans-unit id="4b601dbe8a076d8fccff82083667b82ac9cbcaf2" translate="yes" xml:space="preserve">
          <source>instructs the Single to call the subscriber methods on a particular &lt;a href=&quot;scheduler&quot;&gt;Scheduler&lt;/a&gt;</source>
          <target state="translated">シングルに、特定の&lt;a href=&quot;scheduler&quot;&gt;スケジューラで&lt;/a&gt;サブスクライバメソッドを呼び出すように指示します</target>
        </trans-unit>
        <trans-unit id="eca0b3496b0773e9004170e5ee17829fa81e2cfc" translate="yes" xml:space="preserve">
          <source>instructs the Single to operate on a particular &lt;a href=&quot;scheduler&quot;&gt;Scheduler&lt;/a&gt;</source>
          <target state="translated">シングルに特定の&lt;a href=&quot;scheduler&quot;&gt;スケジューラ&lt;/a&gt;を操作するように指示します</target>
        </trans-unit>
        <trans-unit id="c357df049720e803767baccb0a0919d8ae438720" translate="yes" xml:space="preserve">
          <source>integers starting with &lt;code&gt;1&lt;/code&gt; and converts it, via &lt;code&gt;scan&lt;/code&gt;, into an Observable that emits the first</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; から始まる整数で、 &lt;code&gt;scan&lt;/code&gt; を介して最初の整数を出力するObservableに変換します</target>
        </trans-unit>
        <trans-unit id="5c66328e63d2651a8680db012ecb04a1e0c9fb8d" translate="yes" xml:space="preserve">
          <source>into an indicator of the amount of time that lapsed before the emission of the item</source>
          <target state="translated">排出までに経過した時間の指標にする。</target>
        </trans-unit>
        <trans-unit id="6e92086dca618f4ee5c9fb6bfd63624bbdfcf042" translate="yes" xml:space="preserve">
          <source>into one that emits objects of type &lt;code&gt;Timestamped&amp;lt;&lt;i&gt;T&lt;/i&gt;&amp;gt;&lt;/code&gt;, where each such object is stamped with the time at which it was originally emitted.</source>
          <target state="translated">タイプが &lt;code&gt;Timestamped&amp;lt;&lt;i&gt;T&lt;/i&gt;&amp;gt;&lt;/code&gt; オブジェクトを放出するオブジェクトに変換します。このような各オブジェクトには、最初に放出された時刻がスタンプされます。</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">に相当します。</target>
        </trans-unit>
        <trans-unit id="f2ab6d76f77af5073047a5a0bc5e4892cf2ac71b" translate="yes" xml:space="preserve">
          <source>it (this also initiates the actions of the Observable).</source>
          <target state="translated">これはObservableのアクションを開始します)。</target>
        </trans-unit>
        <trans-unit id="3a7d9767b1233601ebf8b67495c6dc2ce8b8c2af" translate="yes" xml:space="preserve">
          <source>item</source>
          <target state="translated">item</target>
        </trans-unit>
        <trans-unit id="7316c8b2e74870d9d7e9d30bbc28ecf4cdf945ee" translate="yes" xml:space="preserve">
          <source>items</source>
          <target state="translated">items</target>
        </trans-unit>
        <trans-unit id="54cecc63037672c9d565bd5b413cdb087c5f46ac" translate="yes" xml:space="preserve">
          <source>items before completing, the new, &lt;code&gt;take&lt;/code&gt;-modified Observable will not throw an exception or invoke &lt;code&gt;onError&lt;/code&gt;, but will merely emit this same fewer number of items before it completes.</source>
          <target state="translated">完了する前の項目、新しい &lt;code&gt;take&lt;/code&gt; 変更された Observableは例外をスローしたり、 &lt;code&gt;onError&lt;/code&gt; を呼び出したりせず、完了する前に同じ数の項目を出力するだけです。</target>
        </trans-unit>
        <trans-unit id="5cc703698419188f6748e57d5051172e7578d5ef" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable</source>
          <target state="translated">観測可能な項目</target>
        </trans-unit>
        <trans-unit id="281b0dc3c88a6285d1fcc3248e4b72d6d13752fa" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable and attend only to those items that come after, by modifying the Observable with the Skip operator.</source>
          <target state="translated">Observable を Skip 演算子で変更することで、Observable から放出されたアイテムに注目し、後から来たアイテムだけに注目することができます。</target>
        </trans-unit>
        <trans-unit id="256cbf4eb14c5d64b17e59041c7002ce9915bf97" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable and attend only to those items that come before them, by modifying the Observable with the SkipLast operator.</source>
          <target state="translated">Observable を SkipLast 演算子で修正することで、Observable によって放出されたアイテムに注目し、その前にあるアイテムのみに注目するようになります。</target>
        </trans-unit>
        <trans-unit id="1bcdfca876104995c38c6ca1144b2b6e6f5fa505" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable and attend only to those items that precede them, by modifying the Observable with the &lt;code&gt;skipLast(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; operator. Note that the mechanism by which this is implemented will delay the emission of any item from the source Observable until</source>
          <target state="translated">Observableによって &lt;code&gt;skipLast(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; れ、skiableLast（&lt;i&gt;n&lt;/i&gt;）演算子を使用してObservableを変更することにより、それらの前のアイテムにのみ参加するアイテム。これが実装されるメカニズムは、ソースObservableからのアイテムの放出を、</target>
        </trans-unit>
        <trans-unit id="1ce3138e6873c0e9bb2af30c7b2c8ddfc633bf03" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable and ignore those items that come before them, by modifying the Observable with the TakeLast operator.</source>
          <target state="translated">これは、ObservableをTakeLast演算子で修正することで、Observableによって放出されたアイテムを無視し、その前に来るアイテムを無視します。</target>
        </trans-unit>
        <trans-unit id="627d3004856c8c25ed154bf10b211c198e92ed99" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable and ignore those items that precede them, by modifying the Observable with the &lt;code&gt;takeLast(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; operator. Note that this will delay the emission of any item from the source Observable until that Observable completes.</source>
          <target state="translated">&lt;code&gt;takeLast(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; 演算子を使用してObservableを変更することにより、Observableによって発行され、それらの前のアイテムを無視するアイテム。これにより、Observableが完了するまで、Observableソースからのアイテムの放出が遅延することに注意してください。</target>
        </trans-unit>
        <trans-unit id="e78d9230f84809bd8259c4cdacd12e1311cbf6b2" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable and ignore those items that precede them, by modifying the Observable with the &lt;code&gt;takeLast(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; operator. Note that this will delay the emission of any item from the source Observable until the source Observable completes.</source>
          <target state="translated">&lt;code&gt;takeLast(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; 演算子を使用してObservableを変更することにより、Observableによって発行され、それらの前のアイテムを無視するアイテム。これにより、ソースのObservableが完了するまで、ソースのObservableからのアイテムの放出が遅延することに注意してください。</target>
        </trans-unit>
        <trans-unit id="3bbe910e0e0b20f8e7a00952441aa27949753b14" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable and then complete while ignoring the remainder, by modifying the Observable with the Take operator.</source>
          <target state="translated">ObservableをTake演算子で修正することで、Observableによって放出されたアイテムを、残りを無視して完了させることができます。</target>
        </trans-unit>
        <trans-unit id="8638cd8395daa1b642320bfea0b50152c0b101a3" translate="yes" xml:space="preserve">
          <source>items emitted by the bursty Observable.</source>
          <target state="translated">バーストしたObservableによって放出されるアイテム。</target>
        </trans-unit>
        <trans-unit id="a7b968713a235f777cf138dc3695594bad65a2ed" translate="yes" xml:space="preserve">
          <source>items, which allows the &lt;code&gt;ControlledObservable&lt;/code&gt; to run somewhat ahead of the observer from time to time. &lt;code&gt;windowed(1)&lt;/code&gt; is equivalent to &lt;code&gt;stopAndWait&lt;/code&gt;.</source>
          <target state="translated">これにより、 &lt;code&gt;ControlledObservable&lt;/code&gt; が時々オブザーバーよりいくらか先に実行されるようになります。 &lt;code&gt;stopAndWait&lt;/code&gt; &lt;code&gt;windowed(1)&lt;/code&gt; はstopAndWaitと同等です。</target>
        </trans-unit>
        <trans-unit id="252b793f4b97747e8725e6d8dc5ba3b8321dc7d6" translate="yes" xml:space="preserve">
          <source>jort.technology</source>
          <target state="translated">jort.technology</target>
        </trans-unit>
        <trans-unit id="d95b79cfc988b3b165ceb830a9c8932d1b52cf18" translate="yes" xml:space="preserve">
          <source>just</source>
          <target state="translated">just</target>
        </trans-unit>
        <trans-unit id="a62f2225bf70bfaccbc7f1ef2a397836717377de" translate="yes" xml:space="preserve">
          <source>key</source>
          <target state="translated">key</target>
        </trans-unit>
        <trans-unit id="0c1beb7946903d44f31f6b86cf15dfddb1b73736" translate="yes" xml:space="preserve">
          <source>make a Connectable Observable behave like an ordinary Observable</source>
          <target state="translated">接続可能なObservableを通常のObservableのように動作させる</target>
        </trans-unit>
        <trans-unit id="37745ed7a0f005fb14522c5cc7c1ba3d9e0df579" translate="yes" xml:space="preserve">
          <source>map</source>
          <target state="translated">map</target>
        </trans-unit>
        <trans-unit id="79d67b9fd09cde874d173f35b4df9504ff9198eb" translate="yes" xml:space="preserve">
          <source>meant for I/O-bound work such as asynchronous performance of blocking I/O, this scheduler is backed by a thread-pool that will grow as needed; for ordinary computational work, switch to &lt;code&gt;Schedulers.computation( )&lt;/code&gt;; &lt;code&gt;Schedulers.io( )&lt;/code&gt; by default is a &lt;code&gt;CachedThreadScheduler&lt;/code&gt;, which is something like a new thread scheduler with thread caching</source>
          <target state="translated">ブロッキングI / Oの非同期パフォーマンスなどのI / Oにバインドされた作業のために、このスケジューラは、必要に応じて拡大するスレッドプールによってサポートされます。通常の計算作業では、 &lt;code&gt;Schedulers.computation( )&lt;/code&gt; 切り替えます。 &lt;code&gt;Schedulers.io( )&lt;/code&gt; 、デフォルトでは &lt;code&gt;CachedThreadScheduler&lt;/code&gt; です。これは、スレッドキャッシュを備えた新しいスレッドスケジューラのようなものです。</target>
        </trans-unit>
        <trans-unit id="a1b2d933157904f1909eba2778bc1b0bc5b32a0f" translate="yes" xml:space="preserve">
          <source>meant for computational work such as event-loops and callback processing; do not use this scheduler for I/O (use &lt;code&gt;Schedulers.io( )&lt;/code&gt; instead); the number of threads, by default, is equal to the number of processors</source>
          <target state="translated">イベントループやコールバック処理などの計算作業用。このスケジューラをI / Oに使用しないでください &lt;code&gt;Schedulers.io( )&lt;/code&gt; 代わりにSchedulers.io（）を使用してください）。デフォルトでは、スレッドの数はプロセッサの数と同じです</target>
        </trans-unit>
        <trans-unit id="14091a9f2461267ee7e02525b4f1f2923f1c9849" translate="yes" xml:space="preserve">
          <source>merge</source>
          <target state="translated">merge</target>
        </trans-unit>
        <trans-unit id="b5a02016a0682c002da94900aa3dd08ee317e771" translate="yes" xml:space="preserve">
          <source>merge and mergeWith</source>
          <target state="translated">マージアンドマージウィズ</target>
        </trans-unit>
        <trans-unit id="754ffff9989c69728e41fa3f602dea0149183089" translate="yes" xml:space="preserve">
          <source>mergeWith</source>
          <target state="translated">mergeWith</target>
        </trans-unit>
        <trans-unit id="6d5c675bf8edaff2c66ed7c992b706e5704acdc8" translate="yes" xml:space="preserve">
          <source>merges the items emitted by multiple Singles as Observable emissions</source>
          <target state="translated">複数のシングルスから排出された項目をObservable排出物としてマージします。</target>
        </trans-unit>
        <trans-unit id="1373a31197b556329ac156e7ade9cb2ba85e793d" translate="yes" xml:space="preserve">
          <source>mirror items emitted by an Observable until a specified condition becomes false</source>
          <target state="translated">特定の条件がFalseになるまで、Observableから放出されるアイテムをミラーします。</target>
        </trans-unit>
        <trans-unit id="69e7a4a6098f21dd74f0e5d1f1183014c08998d2" translate="yes" xml:space="preserve">
          <source>mirror the source Observable, but issue an error notification if a particular period of time elapses without any emitted items</source>
          <target state="translated">ソースObservableをミラーリングしますが、ある特定の期間が経過しても何も出てこない場合はエラー通知を発行します。</target>
        </trans-unit>
        <trans-unit id="648302e50e59872ed27b6c579097c5a430271379" translate="yes" xml:space="preserve">
          <source>mirrors items from the source Observable until this absolute time</source>
          <target state="translated">ソースObservableからこの絶対時刻までのアイテムをミラーリングします。</target>
        </trans-unit>
        <trans-unit id="1c73d060d2a786fb5a45214e5514f3329b981c55" translate="yes" xml:space="preserve">
          <source>mirrors items from the source Observable until this many milliseconds have passed since the Observable was subscribed to</source>
          <target state="translated">は、Observableがサブスクライブされてからこのミリ秒が経過するまで、ソースObservableのアイテムをミラーリングします。</target>
        </trans-unit>
        <trans-unit id="da434d1b08108bb48efd1b874843206b9adea4d0" translate="yes" xml:space="preserve">
          <source>move the emission of an item from a Single forward in time</source>
          <target state="translated">シングルからの排出を前倒しにする</target>
        </trans-unit>
        <trans-unit id="a94e19af4af9c51d17a33a85b88b9c524903d431" translate="yes" xml:space="preserve">
          <source>multiple items</source>
          <target state="translated">多項目</target>
        </trans-unit>
        <trans-unit id="d1854cae891ec7b29161ccaf79a24b00c274bdaa" translate="yes" xml:space="preserve">
          <source>n</source>
          <target state="translated">n</target>
        </trans-unit>
        <trans-unit id="1b60d2ed7158736cbc1353d72a6dc44a6772147f" translate="yes" xml:space="preserve">
          <source>notifications</source>
          <target state="translated">notifications</target>
        </trans-unit>
        <trans-unit id="d29d85b4e7d22abd97299321615272b226b96438" translate="yes" xml:space="preserve">
          <source>notifications and understands</source>
          <target state="translated">通知と理解</target>
        </trans-unit>
        <trans-unit id="133b33b5c57f2a5dc33401a8b5b7d96bac8376ad" translate="yes" xml:space="preserve">
          <source>notifications.</source>
          <target state="translated">notifications.</target>
        </trans-unit>
        <trans-unit id="560c4dbd7c1a66afc1b71b103a23f7c108007205" translate="yes" xml:space="preserve">
          <source>observeOn</source>
          <target state="translated">observeOn</target>
        </trans-unit>
        <trans-unit id="307527c227ac648bb119bcb457ebb8466e79827c" translate="yes" xml:space="preserve">
          <source>observer</source>
          <target state="translated">observer</target>
        </trans-unit>
        <trans-unit id="cabaf29399c77e9ce3c5ed70182997a660a42de0" translate="yes" xml:space="preserve">
          <source>onCompleted</source>
          <target state="translated">onCompleted</target>
        </trans-unit>
        <trans-unit id="34c18e24d1dfbbb529faba38b503601cb512f20e" translate="yes" xml:space="preserve">
          <source>onError</source>
          <target state="translated">onError</target>
        </trans-unit>
        <trans-unit id="1ec9553944d373e3c5ccee85191a76e3362aa2c2" translate="yes" xml:space="preserve">
          <source>onErrorReturn</source>
          <target state="translated">onErrorReturn</target>
        </trans-unit>
        <trans-unit id="8cffc1eb25befde35dc9a29caa8d3c1b3fdf164c" translate="yes" xml:space="preserve">
          <source>onNext</source>
          <target state="translated">onNext</target>
        </trans-unit>
        <trans-unit id="bc8d0ce7f27d4c43756b40ce541d77416645f7ef" translate="yes" xml:space="preserve">
          <source>onNext, onCompleted, and onError</source>
          <target state="translated">onNext、onCompleted、onError</target>
        </trans-unit>
        <trans-unit id="df2505265f9a2c8f72075dad202d8fb79cdac569" translate="yes" xml:space="preserve">
          <source>onSuccess</source>
          <target state="translated">onSuccess</target>
        </trans-unit>
        <trans-unit id="b40cdaa970a1b4cc121d9b48173fcaff7e0f15d4" translate="yes" xml:space="preserve">
          <source>one Observable at a time, in the order they are emitted</source>
          <target state="translated">一度に1つのオブザーバブル、それらが放出された順に</target>
        </trans-unit>
        <trans-unit id="9499006797e3e9becedebbe4f06adec371d9a167" translate="yes" xml:space="preserve">
          <source>one at a time with a function</source>
          <target state="translated">関数を使って一つずつ</target>
        </trans-unit>
        <trans-unit id="1b0bb14695267c72adf406bf3902f0603344f4e9" translate="yes" xml:space="preserve">
          <source>only emit an item from an Observable if a particular timespan has passed without it emitting another item</source>
          <target state="translated">特定の期間が経過しても他のアイテムを放出しない場合にのみ、Observableからアイテムを放出します。</target>
        </trans-unit>
        <trans-unit id="8f907d09e23699668d1792d557974f49ae533d7c" translate="yes" xml:space="preserve">
          <source>only if its sequence is empty</source>
          <target state="translated">シーケンスが空の場合のみ</target>
        </trans-unit>
        <trans-unit id="5395918d1a7cce46854ed435b45bff5e7397a9a0" translate="yes" xml:space="preserve">
          <source>operate upon the emissions and notifications from an Observable</source>
          <target state="translated">観察可能な排出物とその通知に基づいて動作します。</target>
        </trans-unit>
        <trans-unit id="fe96dd39756ac41b74283a9292652d366d73931f" translate="yes" xml:space="preserve">
          <source>operator</source>
          <target state="translated">operator</target>
        </trans-unit>
        <trans-unit id="2a8c5cef636d11d3f64dcc36efc3ac4b5978eb60" translate="yes" xml:space="preserve">
          <source>operator converts a source Observable into an Observable that emits indications of the amount of time lapsed between consecutive emissions of the source Observable. The first emission from this new Observable indicates the amount of time lapsed between the time when the observer subscribed to the Observable and the time when the source Observable emitted its first item. There is no corresponding emission marking the amount of time lapsed between the last emission of the source Observable and the subsequent call to &lt;code&gt;onCompleted&lt;/code&gt;.</source>
          <target state="translated">オペレーターは、ソースObservableを、ソースObservableの連続したエミッションの間に経過した時間の量の指標を出力するObservableに変換します。この新しいObservableからの最初の放出は、オブザーバーがObservableにサブスクライブしてから、ソースObservableが最初のアイテムを放出するまでの間に経過した時間を示します。ソースのObservableの最後のエミッションとそれに続く &lt;code&gt;onCompleted&lt;/code&gt; の呼び出しの間の経過時間を示す対応するエミッションはありません。</target>
        </trans-unit>
        <trans-unit id="66fc7ee958ea8e350bc6b87518bc06ff7e386c28" translate="yes" xml:space="preserve">
          <source>or sends</source>
          <target state="translated">または送信</target>
        </trans-unit>
        <trans-unit id="22e3ca60f9f989b91acea4f38bac56355b1ea1e5" translate="yes" xml:space="preserve">
          <source>otherwise: &lt;code&gt;rx.lite.js&lt;/code&gt; or &lt;code&gt;rx.lite.compat.js&lt;/code&gt;</source>
          <target state="translated">それ以外の場合： &lt;code&gt;rx.lite.js&lt;/code&gt; または &lt;code&gt;rx.lite.compat.js&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aebaa77adbf6e1ab8dd65462495edf64837ccf37" translate="yes" xml:space="preserve">
          <source>periodically gather items emitted by an Observable into bundles and emit these bundles rather than emitting the items one at a time</source>
          <target state="translated">オブザーバブルから放出されたアイテムを定期的に束にして放出する。</target>
        </trans-unit>
        <trans-unit id="66566ba8929f0e65118531a524420a0447fc130a" translate="yes" xml:space="preserve">
          <source>periodically subdivide items from an Observable into Observable windows and emit these windows rather than emitting the items one at a time</source>
          <target state="translated">ObservableからのアイテムをObservableウィンドウに定期的に細分化し、アイテムを一度に放出するのではなく、それらのウィンドウを放出します。</target>
        </trans-unit>
        <trans-unit id="231e65684158501c2336cbfcb310e00fcb24c73a" translate="yes" xml:space="preserve">
          <source>purpose</source>
          <target state="translated">purpose</target>
        </trans-unit>
        <trans-unit id="4cc45ea2a949b9dd69fb4880e9ac06e94bde81b9" translate="yes" xml:space="preserve">
          <source>queues work to begin on the current thread after any already-queued work</source>
          <target state="translated">既にキューに入っている作業の後に、現在のスレッドで作業を開始するためのキューを作成します。</target>
        </trans-unit>
        <trans-unit id="9da83891bf1aa57c20a6c75cc2a6001679fd362b" translate="yes" xml:space="preserve">
          <source>recover from an onError notification by continuing the sequence without error</source>
          <target state="translated">エラーなしでシーケンスを継続することで、onError 通知から回復します。</target>
        </trans-unit>
        <trans-unit id="029c86507f454275f2dddfe843b1bf03334a3d19" translate="yes" xml:space="preserve">
          <source>register an action to take upon a variety of Observable lifecycle events</source>
          <target state="translated">様々な観測可能なライフサイクルイベントに対応するための行動を登録する</target>
        </trans-unit>
        <trans-unit id="16529dc63377ab5e64b0efbeca6d2e56779f6316" translate="yes" xml:space="preserve">
          <source>relationship between the notifications.</source>
          <target state="translated">通知の関係を確認することができます。</target>
        </trans-unit>
        <trans-unit id="38bbe4da48e39e37646b87da88c2ef296e178ab7" translate="yes" xml:space="preserve">
          <source>replaces all &lt;code&gt;onError&lt;/code&gt; notifications from a misbehaving Observable into the emissions from a secondary Observable</source>
          <target state="translated">不正なObservableからのすべての &lt;code&gt;onError&lt;/code&gt; 通知を、セカンダリObservableからのエミッションに置き換えます</target>
        </trans-unit>
        <trans-unit id="3f11990ccf2c77aba0c6c6712860414435d406c7" translate="yes" xml:space="preserve">
          <source>represent both the items emitted and the notifications sent as emitted items, or reverse this process</source>
          <target state="translated">は、放出されたアイテムと放出されたアイテムとして送信された通知の両方を表現するか、この処理を逆にします。</target>
        </trans-unit>
        <trans-unit id="fc9aca251c84d76a6a0d931957efb486d507bcc2" translate="yes" xml:space="preserve">
          <source>resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only when the Connect operator is applied to it. In this way you can prompt an Observable to begin emitting items at a time of your choosing.</source>
          <target state="translated">は通常のObservableに似ていますが、サブスクライブされたときにはアイテムの放出を開始せず、Connect演算子が適用されたときにのみアイテムの放出を開始します。このようにして、選択した時間にアイテムの放出を開始するようにObservableを促すことができます。</target>
        </trans-unit>
        <trans-unit id="fd09d85570e685cf25806e8c97a9cae9bc76d4c3" translate="yes" xml:space="preserve">
          <source>resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only when the Connect operator is applied to it. In this way you can wait for all intended observers to subscribe to the Observable before the Observable begins emitting items.</source>
          <target state="translated">は通常のObservableに似ていますが、サブスクライブされたときにはアイテムの放出を開始せず、Connect演算子が適用されたときにのみアイテムの放出を開始します。この方法では、Observableがアイテムを出し始める前に、すべてのオブザーバがObservableを購読するのを待つことができます。</target>
        </trans-unit>
        <trans-unit id="97a2a5e27c5d084c0dd5bee32de01ad786ad79e8" translate="yes" xml:space="preserve">
          <source>retrieve data</source>
          <target state="translated">データを取り出す</target>
        </trans-unit>
        <trans-unit id="414e681ebabcd2f23de1f32468992b9c81c5f909" translate="yes" xml:space="preserve">
          <source>returns</source>
          <target state="translated">returns</target>
        </trans-unit>
        <trans-unit id="614fab05e39a4e771b71b18872fad9237db48830" translate="yes" xml:space="preserve">
          <source>returns a Single that also calls a method you specify when it calls onError</source>
          <target state="translated">onError を呼び出す際に指定したメソッドも呼び出す Single を返します。</target>
        </trans-unit>
        <trans-unit id="2cbcba5aecafd2534b89b0451d26040bd4880f33" translate="yes" xml:space="preserve">
          <source>returns a Single that also calls a method you specify when it calls onSuccess</source>
          <target state="translated">onSuccess を呼び出す際に指定したメソッドも呼び出す Single を返します。</target>
        </trans-unit>
        <trans-unit id="de9f4dcfa7411bbd303b05c9c4d627cf206844d3" translate="yes" xml:space="preserve">
          <source>returns a Single that emits a specified item</source>
          <target state="translated">指定された項目を放出する Single を返します。</target>
        </trans-unit>
        <trans-unit id="789a106c2f647946e92573c3b1777edc55349f0a" translate="yes" xml:space="preserve">
          <source>returns a Single that emits an item that is the result of a function applied to items emitted by two or more other Singles</source>
          <target state="translated">2 つ以上の他のシングルが放出するアイテムに適用された関数の結果であるアイテムを放出するシングルを返します。</target>
        </trans-unit>
        <trans-unit id="19e291b4d133b23269dc04e8ef9d5fe9961d07e2" translate="yes" xml:space="preserve">
          <source>returns a Single that emits the result of a function applied to the item emitted by the source Single</source>
          <target state="translated">は、ソースの Single によって放出された項目に適用された関数の結果を放出する Single を返します。</target>
        </trans-unit>
        <trans-unit id="ae8c346ab8cb11f2953656ad7208884e7770d344" translate="yes" xml:space="preserve">
          <source>returns a Single that immediately notifies subscribers of an error</source>
          <target state="translated">は、エラーが発生したことを即座に加入者に通知する Single を返します。</target>
        </trans-unit>
        <trans-unit id="644da51fb0f4c8e691099129ff2c304b9011980b" translate="yes" xml:space="preserve">
          <source>returns a Single that is the result of a function applied to an item emitted by a Single</source>
          <target state="translated">Singleによって放出されたアイテムに適用された関数の結果であるSingleを返します。</target>
        </trans-unit>
        <trans-unit id="9d99fbe394a3cd2d6250690cb04bc2bae5e7789b" translate="yes" xml:space="preserve">
          <source>returns a Single that makes an error notification if the source Single does not emit a value in a specified time period</source>
          <target state="translated">指定された期間内にソースSingleが値を出力しなかった場合にエラー通知を行うSingleを返します。</target>
        </trans-unit>
        <trans-unit id="ccc187c8d1099bc534bf656707e72f0b93487700" translate="yes" xml:space="preserve">
          <source>returns an Observable that is the result of a function applied to an item emitted by a Single</source>
          <target state="translated">によって放出されたアイテムに適用された関数の結果であるObservableを返します。</target>
        </trans-unit>
        <trans-unit id="2d2ace357f46b9793f247eb0f1b39b5c06f1c284" translate="yes" xml:space="preserve">
          <source>schedules work as soon as possible on the current thread</source>
          <target state="translated">スケジュールは、現在のスレッドで可能な限り早く動作します。</target>
        </trans-unit>
        <trans-unit id="e2a05abe2afd449104bbe88995191b2546c2e36e" translate="yes" xml:space="preserve">
          <source>schedules work as though it were occurring at an arbitrary historical time</source>
          <target state="translated">刻一刻と動く</target>
        </trans-unit>
        <trans-unit id="212804707d4553d4a9de98cd16a47586293da44e" translate="yes" xml:space="preserve">
          <source>schedules work by means of a timed callback</source>
          <target state="translated">スケジュールは、時間を指定したコールバックによって動作します。</target>
        </trans-unit>
        <trans-unit id="0c6afaa2e04609f1ec3894129ba5ef333342b74b" translate="yes" xml:space="preserve">
          <source>schedules work immediately on the current thread</source>
          <target state="translated">スケジュールは現在のスレッドですぐに動作します。</target>
        </trans-unit>
        <trans-unit id="6fd22fa59e4504bd3abe47116c75ba5d9520c2e4" translate="yes" xml:space="preserve">
          <source>schedules work to begin immediately in the current thread</source>
          <target state="translated">現在のスレッドですぐに作業を開始するようにスケジュールします。</target>
        </trans-unit>
        <trans-unit id="ec5b10f224197c50b751cb29d575291de5a89193" translate="yes" xml:space="preserve">
          <source>shift the emissions from an Observable forward in time by a particular amount</source>
          <target state="translated">観測可能領域の排出量を一定量だけ前倒しにする</target>
        </trans-unit>
        <trans-unit id="b6974d3c4c90f4bf308b7ceaad732a8411683831" translate="yes" xml:space="preserve">
          <source>single items</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4685ae520d469fe19757bc73a43fbb3e23d2eb64" translate="yes" xml:space="preserve">
          <source>skips items from the source Observable until this absolute time</source>
          <target state="translated">ソースObservableからこの絶対時刻までアイテムをスキップします。</target>
        </trans-unit>
        <trans-unit id="ec4661659182b1a32546f8ee26df269f5ff633bd" translate="yes" xml:space="preserve">
          <source>skips items from the source Observable until this many milliseconds have passed since the Observable was subscribed to</source>
          <target state="translated">Observableがサブスクライブされてからこのミリ秒が経過するまで、ソースObservableのアイテムをスキップします。</target>
        </trans-unit>
        <trans-unit id="d722e800457c1e3ff47b9919aacf412d58517e76" translate="yes" xml:space="preserve">
          <source>so that similar items end up on the same Observable</source>
          <target state="translated">似たようなものが同じObservable上で終わるように</target>
        </trans-unit>
        <trans-unit id="23f99c77497b013cb84fa93d00cd562cd60bc053" translate="yes" xml:space="preserve">
          <source>specify the Scheduler on which an Observable will operate</source>
          <target state="translated">Observableが動作するスケジューラを指定します。</target>
        </trans-unit>
        <trans-unit id="c1af98d719e46cb1c263d1f07f1d142225f032b5" translate="yes" xml:space="preserve">
          <source>specify the Scheduler on which an observer will observe this Observable</source>
          <target state="translated">オブザーバがこのObservableを観測するスケジューラを指定します。</target>
        </trans-unit>
        <trans-unit id="8cc70babc917973e7be2341bdf842422d8559507" translate="yes" xml:space="preserve">
          <source>start any unstarted actions that have been scheduled for a time equal to or earlier than the present time according to the Scheduler&amp;rsquo;s clock</source>
          <target state="translated">スケジューラーのクロックに従って、現在時刻と同じかそれよりも前の時刻にスケジュールされている未開始のアクションを開始します。</target>
        </trans-unit>
        <trans-unit id="d9b4f1177afce043722bb47561fbe3b4f6b4cb6b" translate="yes" xml:space="preserve">
          <source>strategies for coping with Observables that produce items more rapidly than their observers consume them</source>
          <target state="translated">オブザーバーが消費するよりも早くアイテムを生産するオブザーバーブルに対処するための戦略</target>
        </trans-unit>
        <trans-unit id="22fd962474489207eb05adb7a8bcf49b937562b8" translate="yes" xml:space="preserve">
          <source>subscribe a single function to either the &lt;code&gt;onNext&lt;/code&gt;, the &lt;code&gt;onCompleted&lt;/code&gt;, or &lt;code&gt;onError&lt;/code&gt; notifications from an Observable, with &lt;code&gt;subscribeOnNext&lt;/code&gt;, &lt;code&gt;subscribeOnCompleted&lt;/code&gt;, or &lt;code&gt;subscribeOnError&lt;/code&gt; respectively</source>
          <target state="translated">いずれかに単一の機能をサブスクライブ &lt;code&gt;onNext&lt;/code&gt; 、 &lt;code&gt;onCompleted&lt;/code&gt; 、または &lt;code&gt;onError&lt;/code&gt; と、観測から通知 &lt;code&gt;subscribeOnNext&lt;/code&gt; 、 &lt;code&gt;subscribeOnCompleted&lt;/code&gt; 、又は &lt;code&gt;subscribeOnError&lt;/code&gt; それぞれ</target>
        </trans-unit>
        <trans-unit id="e9b287045b72e71494407f32ddc237ffeab5305a" translate="yes" xml:space="preserve">
          <source>subscribe by passing zero to three individual functions, or an object that implements those three functions, into either the &lt;code&gt;subscribe&lt;/code&gt; or &lt;code&gt;forEach&lt;/code&gt; operator (those operators behave identically).</source>
          <target state="translated">3つの個別の関数、またはこれらの3つの関数を実装するオブジェクトに0を渡すことにより、 &lt;code&gt;subscribe&lt;/code&gt; または &lt;code&gt;forEach&lt;/code&gt; 演算子にサブスクライブします（これらの演算子は同じように動作します）。</target>
        </trans-unit>
        <trans-unit id="ec9eb83261701c10244989eda4480cd0bc34282e" translate="yes" xml:space="preserve">
          <source>subscribeOn</source>
          <target state="translated">subscribeOn</target>
        </trans-unit>
        <trans-unit id="2f11a7869397c6279959fc770e96943449c6adc0" translate="yes" xml:space="preserve">
          <source>subscribes</source>
          <target state="translated">subscribes</target>
        </trans-unit>
        <trans-unit id="e45026cdc19b9b8ae7cd208d230ff92042c526de" translate="yes" xml:space="preserve">
          <source>subscribing</source>
          <target state="translated">subscribing</target>
        </trans-unit>
        <trans-unit id="a73cae38ca4e4c1f5ee35e5e1ab9e4023e603395" translate="yes" xml:space="preserve">
          <source>suppress duplicate items emitted by an Observable</source>
          <target state="translated">Observableによって放出される重複項目を抑制します。</target>
        </trans-unit>
        <trans-unit id="e82088f5062344b73a3c19fab602396d690426d8" translate="yes" xml:space="preserve">
          <source>suppress the final</source>
          <target state="translated">締めくくる</target>
        </trans-unit>
        <trans-unit id="c3865777c46bf1ae284de15cd7c85a4f6890eb77" translate="yes" xml:space="preserve">
          <source>suppress the first</source>
          <target state="translated">抑え込む</target>
        </trans-unit>
        <trans-unit id="771a09735788ce147033478f20360728d165bee2" translate="yes" xml:space="preserve">
          <source>synchronous</source>
          <target state="translated">synchronous</target>
        </trans-unit>
        <trans-unit id="2e573610264014eeec724ea567a1ed662b27b45c" translate="yes" xml:space="preserve">
          <source>that completes without emitting items</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f08197d25304fd5b825dcbe7bf93275b3eb3552" translate="yes" xml:space="preserve">
          <source>that does nothing at all</source>
          <target state="translated">何の役にも立たない</target>
        </trans-unit>
        <trans-unit id="137ab2573eaf4b29b027095f579031c127475086" translate="yes" xml:space="preserve">
          <source>that emits a particular item</source>
          <target state="translated">が出る</target>
        </trans-unit>
        <trans-unit id="6bf394b782612eca525f4d43bc05228830887d33" translate="yes" xml:space="preserve">
          <source>that emits a sequence of integers</source>
          <target state="translated">整数列を放出する</target>
        </trans-unit>
        <trans-unit id="eaba046ca8704fac01dd6cf9c5c9f14a5b897381" translate="yes" xml:space="preserve">
          <source>that emits a sequence of items repeatedly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1576e1882f41d1921a68f8fa5d3280da8029b02" translate="yes" xml:space="preserve">
          <source>that is</source>
          <target state="translated">然れば</target>
        </trans-unit>
        <trans-unit id="d58317eedc0e0cc19a4dc5d96db7c79390bc0b2a" translate="yes" xml:space="preserve">
          <source>that is, after a second Observable emits an item</source>
          <target state="translated">つまり、2番目のObservableがアイテムを放出した後に</target>
        </trans-unit>
        <trans-unit id="b4ced51c288fff2a228b4b03d3034f929b53765c" translate="yes" xml:space="preserve">
          <source>that is, after an initial period of time</source>
          <target state="translated">となると</target>
        </trans-unit>
        <trans-unit id="d502ddf269ba3ba29f4b31ede202ce4f248f11c0" translate="yes" xml:space="preserve">
          <source>that is, after the first</source>
          <target state="translated">而して</target>
        </trans-unit>
        <trans-unit id="01cc9507a2b962ed7290a559771e31f3dd47508e" translate="yes" xml:space="preserve">
          <source>that is, except items emitted after a second Observable emits an item</source>
          <target state="translated">つまり、2番目のObservableがアイテムを放出した後に放出されたアイテムを除いて</target>
        </trans-unit>
        <trans-unit id="89722a4afc7485cc8282bfed94d1db2a8c8f45ed" translate="yes" xml:space="preserve">
          <source>that is, except items emitted during a period of time before the source completes</source>
          <target state="translated">つまり、ソースが完了するまでの期間に放出されたアイテムを除く</target>
        </trans-unit>
        <trans-unit id="86b3a5ff44246b1dc9bf253021af4f997751b277" translate="yes" xml:space="preserve">
          <source>that is, except the last</source>
          <target state="translated">已むを得ず</target>
        </trans-unit>
        <trans-unit id="1c2fb5718217fbc77a780b296d5448ce0bb0e328" translate="yes" xml:space="preserve">
          <source>that is, only item</source>
          <target state="translated">唯一つ</target>
        </trans-unit>
        <trans-unit id="8807128feac25173baec8dcaa137f183e7a46065" translate="yes" xml:space="preserve">
          <source>that is, only the first item</source>
          <target state="translated">つまり、最初の項目のみ</target>
        </trans-unit>
        <trans-unit id="1d01cf788cdb4ae54d6a0508037ae8d98e426919" translate="yes" xml:space="preserve">
          <source>that is, only the first item&lt;em&gt;s&lt;/em&gt;</source>
          <target state="translated">それは、唯一の最初の項目である&lt;em&gt;S&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd465f2210bfb7e46979cf54ded4dff6ec1692e2" translate="yes" xml:space="preserve">
          <source>that is, only the last item</source>
          <target state="translated">つまり、最後の項目だけ</target>
        </trans-unit>
        <trans-unit id="46d9efc58a8899c1bd6830365dfe0851a789a47b" translate="yes" xml:space="preserve">
          <source>that is, only those items after the first items</source>
          <target state="translated">つまり、最初の項目の後の項目のみ</target>
        </trans-unit>
        <trans-unit id="3fd810f67e4b6418880cdf9e79b297644e46f98f" translate="yes" xml:space="preserve">
          <source>that is, those items except the last items</source>
          <target state="translated">つまり、最後の項目を除いた項目</target>
        </trans-unit>
        <trans-unit id="7c8e5e79724ffb693a8f10afdcf74a756e2dfb2e" translate="yes" xml:space="preserve">
          <source>that is, until one of those items matches a predicate</source>
          <target state="translated">つまり、これらの項目のうちの一つが述語と一致するまでは</target>
        </trans-unit>
        <trans-unit id="6c250c837d9328117e7d1fb1c5750a7f1aab95c0" translate="yes" xml:space="preserve">
          <source>that obtains its sequence from a Future</source>
          <target state="translated">からシーケンスを取得する</target>
        </trans-unit>
        <trans-unit id="e6b1daad8550bcc7c6c2ef78b7c5e5eeba2c7ec2" translate="yes" xml:space="preserve">
          <source>that pulls its emissions from a particular &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Iterable&lt;/code&gt;, or something like that</source>
          <target state="translated">特定の &lt;code&gt;Array&lt;/code&gt; 、 &lt;code&gt;Iterable&lt;/code&gt; 、またはそのようなものから放出を引き出します</target>
        </trans-unit>
        <trans-unit id="5446f7a00c20f00c1e1272456e1e623cd6777342" translate="yes" xml:space="preserve">
          <source>that was returned from a function called at subscribe-time</source>
          <target state="translated">が返されました。</target>
        </trans-unit>
        <trans-unit id="36ddf980b2667dd715828894e3fc3042cbedc25b" translate="yes" xml:space="preserve">
          <source>that was returned from an &lt;code&gt;Action&lt;/code&gt;, &lt;code&gt;Callable&lt;/code&gt;, &lt;code&gt;Runnable&lt;/code&gt;, or something of that sort, called at subscribe-time</source>
          <target state="translated">subscribe-timeに呼び出された &lt;code&gt;Action&lt;/code&gt; 、 &lt;code&gt;Callable&lt;/code&gt; 、 &lt;code&gt;Runnable&lt;/code&gt; などから返されたもの</target>
        </trans-unit>
        <trans-unit id="4d322a2a1ed8b229ce64a28e0f9a6b07bd805cb7" translate="yes" xml:space="preserve">
          <source>the &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; on which this operator will operate</source>
          <target state="translated">&lt;a href=&quot;../scheduler&quot;&gt;スケジューラ&lt;/a&gt;この演算子が動作します</target>
        </trans-unit>
        <trans-unit id="f54428f31bc9cd665202c66e3529743413a51ebf" translate="yes" xml:space="preserve">
          <source>the Observable from which that item was emitted</source>
          <target state="translated">その項目が放出されたObservable</target>
        </trans-unit>
        <trans-unit id="45e5c3a5cdeb1e41ae2ba979a9fbbc2879407cb0" translate="yes" xml:space="preserve">
          <source>the Scheduler you want this operator to use</source>
          <target state="translated">この演算子を使用するスケジューラ</target>
        </trans-unit>
        <trans-unit id="619d6ec67e945d9c20afba296213710299061ec9" translate="yes" xml:space="preserve">
          <source>the ability for the producer to signal to the consumer that an error has occurred (an Iterable throws an exception if an error takes place during iteration; an Observable calls its observer&amp;rsquo;s &lt;code&gt;onError&lt;/code&gt; method)</source>
          <target state="translated">エラーが発生したことをプロデューサーがコンシューマーに通知する機能（反復中にエラーが発生した場合、Iterableは例外をスローします; Observableはオブザーバーの &lt;code&gt;onError&lt;/code&gt; メソッドを呼び出します）</target>
        </trans-unit>
        <trans-unit id="ccf54bc28a9d5977bbe47958144f3f09e7562dd0" translate="yes" xml:space="preserve">
          <source>the ability for the producer to signal to the consumer that there is no more data available (a foreach loop on an Iterable completes and returns normally in such a case; an Observable calls its observer&amp;rsquo;s &lt;code&gt;onCompleted&lt;/code&gt; method)</source>
          <target state="translated">利用可能なデータがもうないことをプロデューサーがコンシューマーに通知する機能（Iterableのforeachループは完了し、そのような場合は通常戻ります &lt;code&gt;onCompleted&lt;/code&gt; はオブザーバーのonCompletedメソッドを呼び出します）</target>
        </trans-unit>
        <trans-unit id="d36f5da1557da2000be76f162419f2842d8b6a66" translate="yes" xml:space="preserve">
          <source>the age, in milliseconds, at which items in this buffer may be discarded without being emitted to subsequent observers</source>
          <target state="translated">このバッファ内のアイテムが後続のオブザーバに放出されずに廃棄されるまでの時間をミリ秒単位で表します。</target>
        </trans-unit>
        <trans-unit id="a5c4d53c7c902b1b5cc8e185eede65fdb2de0277" translate="yes" xml:space="preserve">
          <source>the default Observable to emit if the key does not associate with any Observables</source>
          <target state="translated">キーがどのObservablesとも関連づけられていない場合に出力されるデフォルトのObservable。</target>
        </trans-unit>
        <trans-unit id="1d113d4b461ba7203000f1bb511ee26f86e995a0" translate="yes" xml:space="preserve">
          <source>the emitted item</source>
          <target state="translated">はっしんこうもく</target>
        </trans-unit>
        <trans-unit id="85e12c825e42525a7d38c934221156be2a4c8aad" translate="yes" xml:space="preserve">
          <source>the first item it emitted</source>
          <target state="translated">最初に出たアイテム</target>
        </trans-unit>
        <trans-unit id="be4ce820ddeef4daec91cbf71555e93b8ca55a74" translate="yes" xml:space="preserve">
          <source>the first item to emit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe008fb64922cd4f3a3244147ca04018865ec96" translate="yes" xml:space="preserve">
          <source>the index of that item in the sequence of emitted items</source>
          <target state="translated">排出されたアイテムのシーケンスの中でのそのアイテムのインデックス</target>
        </trans-unit>
        <trans-unit id="52694b753f3d0d4d183a51c70e89116a83fafd9c" translate="yes" xml:space="preserve">
          <source>the item emitted by the source Observable</source>
          <target state="translated">ソースによって放出されるアイテム Observable</target>
        </trans-unit>
        <trans-unit id="f6eb842cfde4474cc55d27b11fda28c9d0974ca2" translate="yes" xml:space="preserve">
          <source>the item from the source Observable to be, or not be, filtered</source>
          <target state="translated">ソースからの項目 フィルタリングされる、またはフィルタリングされないオブザーバブル</target>
        </trans-unit>
        <trans-unit id="f63828e115c31506deec5330c6cf7da6f1662e64" translate="yes" xml:space="preserve">
          <source>the last item emitted before it completed</source>
          <target state="translated">完走前の最後のアイテム</target>
        </trans-unit>
        <trans-unit id="4cd52010a84449eec942d8a7eb5de34cdaf5ca8d" translate="yes" xml:space="preserve">
          <source>the maximum number of items to buffer and replay to subsequent observers</source>
          <target state="translated">バッファリングして後続のオブザーバに再生するアイテムの最大数</target>
        </trans-unit>
        <trans-unit id="f19cdb5df71b1ff17e9df3a1799991559db40ebf" translate="yes" xml:space="preserve">
          <source>the second Observable to combine with the source Observable</source>
          <target state="translated">元のObservableと結合するための2番目のObservable</target>
        </trans-unit>
        <trans-unit id="825f395e1e2ab0a50e58a2e578f9cda252845ec2" translate="yes" xml:space="preserve">
          <source>the sole item it emitted</source>
          <target state="translated">唯一つ</target>
        </trans-unit>
        <trans-unit id="c4b48660e367f953c340a09afe02029b181943ea" translate="yes" xml:space="preserve">
          <source>the source Observable</source>
          <target state="translated">ソースオブザーバブル</target>
        </trans-unit>
        <trans-unit id="626662ed5d32414ca0a11f0bb9a64034f3068433" translate="yes" xml:space="preserve">
          <source>the source Observable itself</source>
          <target state="translated">ソースオブザーバブル自体</target>
        </trans-unit>
        <trans-unit id="f2213513da8d036c5bb0db7e96282e717db28520" translate="yes" xml:space="preserve">
          <source>the source Observable object</source>
          <target state="translated">元のObservableオブジェクト</target>
        </trans-unit>
        <trans-unit id="02901a674fe43f7fbed3f5d4d20d10d2585b59f3" translate="yes" xml:space="preserve">
          <source>the zero-based index of that item</source>
          <target state="translated">その項目のゼロベースのインデックス</target>
        </trans-unit>
        <trans-unit id="ff4fd068ef5334d397a2b9b95bad44dfbeb439ec" translate="yes" xml:space="preserve">
          <source>the zero-based index of that item in the sequence of emissions</source>
          <target state="translated">ゼロベースの指数</target>
        </trans-unit>
        <trans-unit id="199a3fba451a63af3f467158fd6bc54160f86199" translate="yes" xml:space="preserve">
          <source>the zero-based index of this item in the source Observable&amp;rsquo;s sequence</source>
          <target state="translated">ソースのObservableのシーケンスにおけるこのアイテムのゼロから始まるインデックス</target>
        </trans-unit>
        <trans-unit id="c9f0ba0696d964a4bf6f877db29a8efb87a7b004" translate="yes" xml:space="preserve">
          <source>throws &lt;code&gt;Exception&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; スローします</target>
        </trans-unit>
        <trans-unit id="5d8d37cb543750abf8a4e771b12e8265926a1ad7" translate="yes" xml:space="preserve">
          <source>timeInterval</source>
          <target state="translated">timeInterval</target>
        </trans-unit>
        <trans-unit id="56d3c9490be2608ac36f5a4805bfec2f21f7f982" translate="yes" xml:space="preserve">
          <source>timeout</source>
          <target state="translated">timeout</target>
        </trans-unit>
        <trans-unit id="11a572aecafbc0f74cba80722d6c2694c9293479" translate="yes" xml:space="preserve">
          <source>times.</source>
          <target state="translated">times.</target>
        </trans-unit>
        <trans-unit id="918300a03ee028633b64dfc10ce94f1efc51260f" translate="yes" xml:space="preserve">
          <source>to an</source>
          <target state="translated">にとって</target>
        </trans-unit>
        <trans-unit id="3d803915a4dc5f4f1acc85a7a1052d8c8f251981" translate="yes" xml:space="preserve">
          <source>to its observers by calling the observers&amp;rsquo; methods.</source>
          <target state="translated">オブザーバーのメソッドを呼び出すことにより、オブザーバーに。</target>
        </trans-unit>
        <trans-unit id="21b9896d15067b60a96aa46fce0956d921771516" translate="yes" xml:space="preserve">
          <source>toObservable</source>
          <target state="translated">toObservable</target>
        </trans-unit>
        <trans-unit id="d8603afc294b77cdaeff4436109d5ad84fb688d6" translate="yes" xml:space="preserve">
          <source>toSingle</source>
          <target state="translated">toSingle</target>
        </trans-unit>
        <trans-unit id="5886afa49f59f5bfc349ccddbbe20abdb26c5961" translate="yes" xml:space="preserve">
          <source>transform the items emitted by an Observable by applying a function to each item</source>
          <target state="translated">各項目に関数を適用することで、Observableによって放出された項目を変換します。</target>
        </trans-unit>
        <trans-unit id="e7e43a876519041c58cbce9e04a1a2a77efd52b2" translate="yes" xml:space="preserve">
          <source>transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable</source>
          <target state="translated">Observableによって放出されたアイテムをObservableに変換し、それらの放出を1つのObservableにフラット化します。</target>
        </trans-unit>
        <trans-unit id="7b55b668d2a03c54e10abf0fd560513c61800ce9" translate="yes" xml:space="preserve">
          <source>uses the specified &lt;code&gt;Executor&lt;/code&gt; as a Scheduler</source>
          <target state="translated">指定された &lt;code&gt;Executor&lt;/code&gt; をスケジューラとして使用します</target>
        </trans-unit>
        <trans-unit id="963d96d958581e9e92f9acda78fb37f3bb8bfb40" translate="yes" xml:space="preserve">
          <source>when an item is emitted by either of two Observables, combine the latest item emitted by each Observable via a specified function and emit items based on the results of this function</source>
          <target state="translated">2つのObservableのどちらかからアイテムが放出された場合、指定された関数を介してそれぞれのObservableから放出された最新のアイテムを組み合わせて、この関数の結果に基づいてアイテムを放出します。</target>
        </trans-unit>
        <trans-unit id="04387f9309cd75011a40ab7c3031310e01c65092" translate="yes" xml:space="preserve">
          <source>when it notifies observers</source>
          <target state="translated">オブザーバーに通知するとき</target>
        </trans-unit>
        <trans-unit id="aae0fdc01ec4cc0d21d70383d00a3276d2b7b563" translate="yes" xml:space="preserve">
          <source>whenever &lt;em&gt;any&lt;/em&gt; of the Observables has emitted a new item</source>
          <target state="translated">Observableの&lt;em&gt;いずれか&lt;/em&gt;が新しいアイテムを放出したとき</target>
        </trans-unit>
        <trans-unit id="6c2b43179a8c8aafdb4b0d4f3fa3fcebb34c76a6" translate="yes" xml:space="preserve">
          <source>whenever &lt;em&gt;each&lt;/em&gt; of the Observables has emitted a new item</source>
          <target state="translated">&lt;em&gt;各&lt;/em&gt; Observableが新しいアイテムを放出したとき</target>
        </trans-unit>
        <trans-unit id="f8e0b9e60ec000d6cd35e093097dfdd7a273c623" translate="yes" xml:space="preserve">
          <source>whenever an item is emitted by one Observable in a window defined by an item emitted by another</source>
          <target state="translated">で定義されたウィンドウで、あるObservableからアイテムが放出されたときに</target>
        </trans-unit>
        <trans-unit id="dd83d0039aa92f3974d649a8a17ef435d5ade767" translate="yes" xml:space="preserve">
          <source>which I can then unwrap again with</source>
          <target state="translated">で再度ラップを解除することができます。</target>
        </trans-unit>
        <trans-unit id="b62562770a1246a8815b67b0d1d644b0e1c1d831" translate="yes" xml:space="preserve">
          <source>which will be used instead of the item itself when comparing two items for distinctness</source>
          <target state="translated">これは、2つの項目を比較する際に、項目そのものの代わりに使用されます。</target>
        </trans-unit>
        <trans-unit id="f13e27693c85aed522df8c3fcb0bb0110ca54e14" translate="yes" xml:space="preserve">
          <source>zip</source>
          <target state="translated">zip</target>
        </trans-unit>
        <trans-unit id="8a5c4039855db169827c66fcbbc8371e8cc25f57" translate="yes" xml:space="preserve">
          <source>zip and zipWith</source>
          <target state="translated">zip と zipWith</target>
        </trans-unit>
        <trans-unit id="cb92618013b7da045d179e02a557fe63872457d2" translate="yes" xml:space="preserve">
          <source>zipWith</source>
          <target state="translated">zipWith</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
