<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="9e26997b358814cca7850a49e412f8a41b34dbe5" translate="yes" xml:space="preserve">
          <source>The floor of each element in &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の各要素の床。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="eaacb373a79b18f285bd66c2cf0778d5b163c8e7" translate="yes" xml:space="preserve">
          <source>The floor of the scalar &lt;code&gt;x&lt;/code&gt; is the largest integer &lt;code&gt;i&lt;/code&gt;, such that &lt;code&gt;i &amp;lt;= x&lt;/code&gt;. It is often denoted as</source>
          <target state="translated">スカラー &lt;code&gt;x&lt;/code&gt; のフロアは、 &lt;code&gt;i &amp;lt;= x&lt;/code&gt; ような最大の整数 &lt;code&gt;i&lt;/code&gt; です。多くの場合、</target>
        </trans-unit>
        <trans-unit id="837a298621c37ae4f32158adfb48d3ae2b900f73" translate="yes" xml:space="preserve">
          <source>The fmax is equivalent to &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</source>
          <target state="translated">x1もx2もNaNでない場合 &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; fmaxはnp.where（x1&amp;gt; = x2、x1、x2）と同等ですが、高速で適切なブロードキャストを行います。</target>
        </trans-unit>
        <trans-unit id="9192d9bcf4b5d5fc29087b97fc9fad549a45ccf6" translate="yes" xml:space="preserve">
          <source>The fmin is equivalent to &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</source>
          <target state="translated">x1もx2もNaNでない場合 &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; fminはnp.where（x1 &amp;lt;= x2、x1、x2）と同等ですが、高速で適切なブロードキャストを行います。</target>
        </trans-unit>
        <trans-unit id="359ddc84e42e1145c1875abe172377b5b248a4ef" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;git config --global&lt;/code&gt; commands:</source>
          <target state="translated">次の &lt;code&gt;git config --global&lt;/code&gt; コマンド：</target>
        </trans-unit>
        <trans-unit id="2933db06c5f57c543942f5ed02bb77ea787c4725" translate="yes" xml:space="preserve">
          <source>The following attributes are used by F2PY:</source>
          <target state="translated">F2PYでは以下の属性を使用しています。</target>
        </trans-unit>
        <trans-unit id="26c655f10b13c11e712f57319bac1772cdc5526b" translate="yes" xml:space="preserve">
          <source>The following attributes contain information about the memory layout of the array:</source>
          <target state="translated">以下の属性には、配列のメモリレイアウトに関する情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="245831b050a7f252080c114fea4739c32457bc6e" translate="yes" xml:space="preserve">
          <source>The following code allows us to look at the call sequences and arguments:</source>
          <target state="translated">以下のコードでは、コールシーケンスと引数を見ることができます。</target>
        </trans-unit>
        <trans-unit id="b09df459a0ad4a5d7d6218f92cc55900d726085b" translate="yes" xml:space="preserve">
          <source>The following comparison does not raise an exception. There are NaNs in the inputs, but they are in the same positions.</source>
          <target state="translated">以下の比較では例外は発生しません。入力にNaNがありますが、同じ位置にあります。</target>
        </trans-unit>
        <trans-unit id="25c3aeb47ccb54f3895f28756398a03c01d886f7" translate="yes" xml:space="preserve">
          <source>The following corresponds to the usual functions except that nans are excluded from the results:</source>
          <target state="translated">以下は、結果からnansを除外する以外は通常の関数に対応しています。</target>
        </trans-unit>
        <trans-unit id="367c359a19964728c01ac0e57fac7d66168d5b07" translate="yes" xml:space="preserve">
          <source>The following data types are &lt;strong&gt;flexible&lt;/strong&gt;: they have no predefined size and the data they describe can be of different length in different arrays. (In the character codes &lt;code&gt;#&lt;/code&gt; is an integer denoting how many elements the data type consists of.)</source>
          <target state="translated">次のデータ型は&lt;strong&gt;柔軟&lt;/strong&gt;です。事前定義されたサイズがなく、それらが記述するデータは、異なる配列で異なる長さになる可能性があります。（文字コードの &lt;code&gt;#&lt;/code&gt; は、データ型を構成する要素の数を示す整数です。）</target>
        </trans-unit>
        <trans-unit id="87cc18e3bbbb39d0641f0c5e5f7aaba73b3bfa17" translate="yes" xml:space="preserve">
          <source>The following example checks that &lt;code&gt;a * a+ * a == a&lt;/code&gt; and &lt;code&gt;a+ * a * a+ == a+&lt;/code&gt;:</source>
          <target state="translated">次の例では、 &lt;code&gt;a * a+ * a == a&lt;/code&gt; および &lt;code&gt;a+ * a * a+ == a+&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="da726617ef56fc847d878f222531de4392ef5079" translate="yes" xml:space="preserve">
          <source>The following example demonstrates that operations on this particular dtype requires Python C-API.</source>
          <target state="translated">以下の例は、この特定のdtypeに対する操作がPythonのC-APIを必要とすることを示しています。</target>
        </trans-unit>
        <trans-unit id="bff8fe87ad1b3faab42fa78be47af40e14a3cdee" translate="yes" xml:space="preserve">
          <source>The following example illustrates how to add user-defined variables to a F2PY generated extension module. Given the following signature file</source>
          <target state="translated">以下の例では、F2PY で生成された拡張モジュールにユーザー定義変数を追加する方法を説明します。以下のシグネチャファイルがあるとします。</target>
        </trans-unit>
        <trans-unit id="601636ce271dc6c59652a4b9ca1697d0ffc34977" translate="yes" xml:space="preserve">
          <source>The following example shows how you might write a wrapper that accepts two input arguments (that will be converted to an array) and an output argument (that must be an array). The function returns None and updates the output array. Note the updated use of WRITEBACKIFCOPY semantics for NumPy v1.14 and above</source>
          <target state="translated">次の例は、2つの入力引数(配列に変換されます)と出力引数(配列でなければなりません)を受け付けるラッパーの書き方を示しています。この関数は None を返し、出力配列を更新します。NumPy v1.14以降では、WRITEBACKIFCOPYのセマンティクスが更新されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9274fe878c5628b41be8c56553474b2bf993bdb4" translate="yes" xml:space="preserve">
          <source>The following import conventions are used throughout the NumPy source and documentation:</source>
          <target state="translated">以下のインポート規約は、NumPyのソースとドキュメント全体で使用されています。</target>
        </trans-unit>
        <trans-unit id="6a11277817c1922ff80f9328abde5fde7dba14c8" translate="yes" xml:space="preserve">
          <source>The following is equivalent to &lt;code&gt;x[:, np.newaxis]&lt;/code&gt;:</source>
          <target state="translated">以下は &lt;code&gt;x[:, np.newaxis]&lt;/code&gt; と同等です：</target>
        </trans-unit>
        <trans-unit id="c9a4cf52932022adac50e43fe76bc932e82c5751" translate="yes" xml:space="preserve">
          <source>The following is equivalent to &lt;code&gt;x[np.newaxis, :]&lt;/code&gt; or &lt;code&gt;x[np.newaxis]&lt;/code&gt;:</source>
          <target state="translated">以下は、 &lt;code&gt;x[np.newaxis, :]&lt;/code&gt; または &lt;code&gt;x[np.newaxis]&lt;/code&gt; ：と同等です。</target>
        </trans-unit>
        <trans-unit id="c7cc30376235469e66891b8aa9bb0978b2dc2799" translate="yes" xml:space="preserve">
          <source>The following is equivalent to &lt;code&gt;x[np.newaxis,:]&lt;/code&gt; or &lt;code&gt;x[np.newaxis]&lt;/code&gt;:</source>
          <target state="translated">以下は &lt;code&gt;x[np.newaxis,:]&lt;/code&gt; または &lt;code&gt;x[np.newaxis]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b1e13d507d651c25d5c30d03b160ce21c4df709" translate="yes" xml:space="preserve">
          <source>The following is probably true, given that 0.6 is roughly twice the standard deviation:</source>
          <target state="translated">0.6が標準偏差の約2倍であることを考えると、以下のことが当てはまるのではないでしょうか。</target>
        </trans-unit>
        <trans-unit id="abb45d568d4c1dc6b1960772da10fbcd2d6bd4ca" translate="yes" xml:space="preserve">
          <source>The following keys are allowed:</source>
          <target state="translated">以下のキーが許可されています。</target>
        </trans-unit>
        <trans-unit id="c7e7738746294a7939f873df246ce33769c08494" translate="yes" xml:space="preserve">
          <source>The following math constants are available in &lt;code&gt;npy_math.h&lt;/code&gt;. Single and extended precision are also available by adding the &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;l&lt;/code&gt; suffixes respectively.</source>
          <target state="translated">&lt;code&gt;npy_math.h&lt;/code&gt; では、次の数学定数を使用できます。単精度と拡張精度は、それぞれ &lt;code&gt;f&lt;/code&gt; と &lt;code&gt;l&lt;/code&gt; 接尾辞を追加することによっても利用できます。</target>
        </trans-unit>
        <trans-unit id="18400fc6ad0ef15f4b4b9f40c34d77a0b29576fd" translate="yes" xml:space="preserve">
          <source>The following methods can be used to access information about the mask or to manipulate the mask.</source>
          <target state="translated">マスクに関する情報にアクセスしたり、マスクを操作したりするには、以下の方法があります。</target>
        </trans-unit>
        <trans-unit id="a7a27e2b2ff01b711d127c91926b8f2614c9b919" translate="yes" xml:space="preserve">
          <source>The following methods implement the pickle protocol:</source>
          <target state="translated">以下のメソッドは、Pickleプロトコルを実装しています。</target>
        </trans-unit>
        <trans-unit id="ebfae704e1370f3e45632884fb2aa5f3e6615469" translate="yes" xml:space="preserve">
          <source>The following new &lt;code&gt;distutils&lt;/code&gt; commands are defined:</source>
          <target state="translated">次の新しい &lt;code&gt;distutils&lt;/code&gt; コマンドが定義されています。</target>
        </trans-unit>
        <trans-unit id="3e142b98cf4f076b7f9b0cce4a8911bba92433dc" translate="yes" xml:space="preserve">
          <source>The following norms can be calculated:</source>
          <target state="translated">以下のノルムを算出することができます。</target>
        </trans-unit>
        <trans-unit id="7d6f7c16ce7db4761de0d3a2abd525b89c4146e9" translate="yes" xml:space="preserve">
          <source>The following predefined named repeat rules are available:</source>
          <target state="translated">以下の定義済みの名前付きリピートルールが利用可能です。</target>
        </trans-unit>
        <trans-unit id="de855448328b5e9f80cc8ce9168a701f985757d7" translate="yes" xml:space="preserve">
          <source>The following rules apply:</source>
          <target state="translated">以下のルールが適用されます。</target>
        </trans-unit>
        <trans-unit id="cb0a5d55704a6c767182c6ac613e21ec8fe0f334" translate="yes" xml:space="preserve">
          <source>The following sections list commonly reported issues depending on your setup. If you have an issue/solution that you think should appear please open a NumPy issue so that it will be added.</source>
          <target state="translated">以下のセクションでは、あなたの設定に応じてよく報告される問題をリストアップしています。表示されるべきだと思われる問題や解決策があれば、NumPyの問題を開いてください。</target>
        </trans-unit>
        <trans-unit id="35ff8f470befc9ac72d0ecaaff54cadb612acf70" translate="yes" xml:space="preserve">
          <source>The following steps are repeated for the beta(s), release candidates(s) and the final release.</source>
          <target state="translated">以下の手順は、ベータ版、リリース候補版、最終リリースの順に繰り返されます。</target>
        </trans-unit>
        <trans-unit id="2238114e4622f64961aa457707939beca3d22430" translate="yes" xml:space="preserve">
          <source>The form of each element of the files sequence is very flexible allowing many combinations of where to get the files from the package and where they should ultimately be installed on the system. The most basic usage is for an element of the files argument sequence to be a simple filename. This will cause that file from the local path to be installed to the installation path of the self.name package (package path). The file argument can also be a relative path in which case the entire relative path will be installed into the package directory. Finally, the file can be an absolute path name in which case the file will be found at the absolute path name but installed to the package path.</source>
          <target state="translated">ファイルシーケンスの各要素の形式は非常に柔軟で、パッケージからファイルを取得する場所や、最終的にシステム上にインストールされるべき場所の多くの組み合わせを可能にします。最も基本的な使い方は、ファイル引数シーケンスの要素を単純なファイル名にすることです。これにより、そのファイルはローカルパスから self.name パッケージのインストールパス (パッケージパス)にインストールされます。ファイルの引数には相対パスを指定することもでき、その場合は相対パス全体がパッケージディレクトリにインストールされます。最後に、ファイルは絶対パス名を指定することもできます。この場合、ファイルは絶対パス名で見つかりますが、パッケージパスにインストールされます。</target>
        </trans-unit>
        <trans-unit id="7343176dc74f7dbd7af11c9825b614f0b44c3446" translate="yes" xml:space="preserve">
          <source>The formal syntax of signatures is as follows:</source>
          <target state="translated">署名の正式な構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="9dfcbb2acec4cf5d146ee3b9671f0f8af54935b6" translate="yes" xml:space="preserve">
          <source>The format description, either specified as a string with comma-separated format descriptions in the form &lt;code&gt;'f8, i4, a5'&lt;/code&gt;, or a list of format description strings in the form &lt;code&gt;['f8', 'i4', 'a5']&lt;/code&gt;.</source>
          <target state="translated">形式の説明。 &lt;code&gt;'f8, i4, a5'&lt;/code&gt; 形式のコンマ区切り形式の説明を含む文字列、または &lt;code&gt;['f8', 'i4', 'a5']&lt;/code&gt; の形式の形式説明文字列のリストとして指定します。</target>
        </trans-unit>
        <trans-unit id="8d7571d646719e6a89afce2ffa8ca97d9a9e64da" translate="yes" xml:space="preserve">
          <source>The format is that required by the &amp;lsquo;descr&amp;rsquo; key in the &lt;code&gt;__array_interface__&lt;/code&gt; attribute.</source>
          <target state="translated">形式は、 &lt;code&gt;__array_interface__&lt;/code&gt; 属性の「descr」キーに必要な形式です。</target>
        </trans-unit>
        <trans-unit id="8a1e4bed9460777336f2b104636d1f996f032590" translate="yes" xml:space="preserve">
          <source>The format of these binary file types is documented in &lt;a href=&quot;generated/numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">これらのバイナリファイルタイプの形式は、&lt;a href=&quot;generated/numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; に&lt;/a&gt;記載されています。</target>
        </trans-unit>
        <trans-unit id="ab7733aff55a201beeb5e33bad2c1efefa91a712" translate="yes" xml:space="preserve">
          <source>The forward 2-dimensional FFT, of which &lt;a href=&quot;#numpy.fft.ifft2&quot;&gt;&lt;code&gt;ifft2&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">フォワード2次元&lt;a href=&quot;#numpy.fft.ifft2&quot;&gt; &lt;code&gt;ifft2&lt;/code&gt; &lt;/a&gt;はその逆です。</target>
        </trans-unit>
        <trans-unit id="0bd56e9c9eb1ee54cf6d17ca53e59f27e56218bd" translate="yes" xml:space="preserve">
          <source>The forward &lt;em&gt;n&lt;/em&gt;-dimensional FFT, of which &lt;a href=&quot;#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">前方&lt;em&gt;n&lt;/em&gt;次元&lt;a href=&quot;#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; &lt;/a&gt;はその逆です。</target>
        </trans-unit>
        <trans-unit id="aeabce19c51398cd914249fe750519a8327c3674" translate="yes" xml:space="preserve">
          <source>The forward n-dimensional FFT of real input, of which &lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">実数入力の順方向n次元&lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; &lt;/a&gt;はその逆です。</target>
        </trans-unit>
        <trans-unit id="86b261d0d21cfe3b6b89e72eae8348c6f9559d44" translate="yes" xml:space="preserve">
          <source>The foundations of Project governance are:</source>
          <target state="translated">プロジェクトガバナンスの基礎は</target>
        </trans-unit>
        <trans-unit id="61a4038ee203c584eee7f06e34f73b9e221966a9" translate="yes" xml:space="preserve">
          <source>The four core distributions (&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt;&lt;code&gt;standard_exponential&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt;&lt;code&gt;standard_gamma&lt;/code&gt;&lt;/a&gt;) all allow existing arrays to be filled using the &lt;code&gt;out&lt;/code&gt; keyword argument. Existing arrays need to be contiguous and well-behaved (writable and aligned). Under normal circumstances, arrays created using the common constructors such as &lt;a href=&quot;../generated/numpy.empty#numpy.empty&quot;&gt;&lt;code&gt;numpy.empty&lt;/code&gt;&lt;/a&gt; will satisfy these requirements.</source>
          <target state="translated">4つのコア分布（&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt; &lt;code&gt;standard_exponential&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt; &lt;code&gt;standard_gamma&lt;/code&gt; &lt;/a&gt;）はすべて、 &lt;code&gt;out&lt;/code&gt; キーワード引数を使用して既存の配列を埋めることができます。既存のアレイは、隣接していて適切に動作する（書き込み可能で整列されている）必要があります。通常の状況では、&lt;a href=&quot;../generated/numpy.empty#numpy.empty&quot;&gt; &lt;code&gt;numpy.empty&lt;/code&gt; &lt;/a&gt;などの一般的なコンストラクターを使用して作成された配列は、これらの要件を満たします。</target>
        </trans-unit>
        <trans-unit id="4e18095a7950042b568262a2f1c7ea1be5258e8f" translate="yes" xml:space="preserve">
          <source>The four values listed above correspond to the number of columns in your array. With a four-column array, you will get four values as your result.</source>
          <target state="translated">上記の4つの値は、配列の列数に対応しています。4 カラムの配列の場合、結果として 4 つの値が得られます。</target>
        </trans-unit>
        <trans-unit id="6b6b0ab0e6259043a789c7cdf6069c9981b5ed51" translate="yes" xml:space="preserve">
          <source>The fourth-order derivative of a 3rd-order polynomial is zero:</source>
          <target state="translated">3次多項式の4次微分は0である。</target>
        </trans-unit>
        <trans-unit id="61efc608056775e101326edefdfb5b3e50b42207" translate="yes" xml:space="preserve">
          <source>The fractional and integral parts are negative if the given number is negative.</source>
          <target state="translated">分数や積分の部分は、与えられた数が負の場合は負になります。</target>
        </trans-unit>
        <trans-unit id="8a03fbb591756592459d393e8bbc5d2c3b77111d" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt;&lt;/a&gt; can always be used to reproduce the old behavior, as it will return a packed copy of the structured array. The code above, for example, can be replaced with:</source>
          <target state="translated">関数&lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt; &lt;/a&gt;は、構造化配列のパックされたコピーを返すため、常に古い動作を再現するために使用できます。たとえば、上記のコードは次のように置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="a275d8e4e1eb223479714f496979856366e2451a" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#numpy.random.default_rng&quot;&gt;&lt;code&gt;numpy.random.default_rng&lt;/code&gt;&lt;/a&gt; will instantiate a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; with numpy&amp;rsquo;s default &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">関数&lt;a href=&quot;#numpy.random.default_rng&quot;&gt; &lt;code&gt;numpy.random.default_rng&lt;/code&gt; &lt;/a&gt;は、numpyのデフォルトの&lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; を&lt;/a&gt;使用して&lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;をインスタンス化します。</target>
        </trans-unit>
        <trans-unit id="3162acb71296218159c712934b3730fe102cab75" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#numpy.random.default_rng&quot;&gt;&lt;code&gt;numpy.random.default_rng&lt;/code&gt;&lt;/a&gt; will instantiate a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; with numpy&amp;rsquo;s default &lt;code&gt;BitGenerator&lt;/code&gt;.</source>
          <target state="translated">関数&lt;a href=&quot;#numpy.random.default_rng&quot;&gt; &lt;code&gt;numpy.random.default_rng&lt;/code&gt; &lt;/a&gt;は、numpyのデフォルトの &lt;code&gt;BitGenerator&lt;/code&gt; で&lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;をインスタンス化します。</target>
        </trans-unit>
        <trans-unit id="2a8219757277659dda8af10246595348c539cf3e" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;../reference/c-api/array#c.PyArray_RemoveSmallest&quot;&gt;&lt;code&gt;PyArray_RemoveSmallest&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;multi&lt;/code&gt; ) can be used to take a multi-iterator object and adjust all the iterators so that iteration does not take place over the largest dimension (it makes that dimension of size 1). The code being looped over that makes use of the pointers will very-likely also need the strides data for each of the iterators. This information is stored in multi-&amp;gt;iters[i]-&amp;gt;strides.</source>
          <target state="translated">関数&lt;a href=&quot;../reference/c-api/array#c.PyArray_RemoveSmallest&quot;&gt; &lt;code&gt;PyArray_RemoveSmallest&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;multi&lt;/code&gt; ）を使用して、マルチイテレーターオブジェクトを取得し、すべてのイテレーターを調整して、最大の次元で反復が行われないようにすることができます（サイズ1の次元になります）。ポインターを使用するループオーバーされるコードは、各イテレーターのストライドデータも必要とする可能性が非常に高くなります。この情報はmulti-&amp;gt; iters [i]-&amp;gt; stridesに保存されます。</target>
        </trans-unit>
        <trans-unit id="9aca3baefb770d49123ec449717dbfcad5a619a9" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;../reference/generated/numpy.column_stack#numpy.column_stack&quot;&gt;&lt;code&gt;column_stack&lt;/code&gt;&lt;/a&gt; stacks 1D arrays as columns into a 2D array. It is equivalent to &lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt; only for 2D arrays:</source>
          <target state="translated">関数&lt;a href=&quot;../reference/generated/numpy.column_stack#numpy.column_stack&quot;&gt; &lt;code&gt;column_stack&lt;/code&gt; &lt;/a&gt;は、1D配列を列として2D配列にスタックします。これは、2D配列の&lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt;のみhstackと同等です。</target>
        </trans-unit>
        <trans-unit id="ada915777af34962f5a155b7336d9374672697e6" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt;&lt;code&gt;busday_offset&lt;/code&gt;&lt;/a&gt; allows you to apply offsets specified in business days to datetimes with a unit of &amp;lsquo;D&amp;rsquo; (day).</source>
          <target state="translated">関数&lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt; &lt;code&gt;busday_offset&lt;/code&gt; を&lt;/a&gt;使用すると、営業日で指定されたオフセットを「D」（日）の単位で日時に適用できます。</target>
        </trans-unit>
        <trans-unit id="b326cd579834eae17571b08e2103d37d7f1ef376" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;gun&lt;/code&gt; may return any number of objects as a tuple. Then following rules are applied:</source>
          <target state="translated">関数 &lt;code&gt;gun&lt;/code&gt; は、任意の数のオブジェクトをタプルとして返すことができます。次に、次のルールが適用されます。</target>
        </trans-unit>
        <trans-unit id="23e4e84916821d7380bf310d4fe3bd37497cc290" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;zeros&lt;/code&gt; creates an array full of zeros, the function &lt;code&gt;ones&lt;/code&gt; creates an array full of ones, and the function &lt;code&gt;empty&lt;/code&gt; creates an array whose initial content is random and depends on the state of the memory. By default, the dtype of the created array is &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;zeros&lt;/code&gt; はゼロでいっぱいの配列を作成し、関数 &lt;code&gt;ones&lt;/code&gt; は1でいっぱいの配列を作成し、関数 &lt;code&gt;empty&lt;/code&gt; は初期の内容がランダムでメモリの状態に依存する配列を作成します。デフォルトでは、作成された配列の &lt;code&gt;float64&lt;/code&gt; はfloat64です。</target>
        </trans-unit>
        <trans-unit id="96d8a0725df6e95677a6e264d7cb37fa566a8b73" translate="yes" xml:space="preserve">
          <source>The function assumes that the number of dimensions of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are the same, if necessary prepending the smallest with ones. If &lt;code&gt;a.shape = (r0,r1,..,rN)&lt;/code&gt; and &lt;code&gt;b.shape = (s0,s1,&amp;hellip;,sN)&lt;/code&gt;, the Kronecker product has shape &lt;code&gt;(r0*s0, r1*s1, &amp;hellip;, rN*SN)&lt;/code&gt;. The elements are products of elements from &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, organized explicitly by:</source>
          <target state="translated">この関数は、 &lt;code&gt;b&lt;/code&gt; とbの次元数が同じで &lt;code&gt;a&lt;/code&gt; と想定し、必要に応じて、最小のものに1を付加します。場合 &lt;code&gt;a.shape = (r0,r1,..,rN)&lt;/code&gt; と &lt;code&gt;b.shape = (s0,s1,&amp;hellip;,sN)&lt;/code&gt; 、クロネッカー積は、形状がある &lt;code&gt;(r0*s0, r1*s1, &amp;hellip;, rN*SN)&lt;/code&gt; 。要素は &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; の要素の積であり、以下によって明示的に編成されます。</target>
        </trans-unit>
        <trans-unit id="af59a6369749b3cb0f9764af498a65709d68b13e" translate="yes" xml:space="preserve">
          <source>The function has a mean of</source>
          <target state="translated">この関数の平均値は</target>
        </trans-unit>
        <trans-unit id="054f865aa3416e437e5f93f6d6b344a94ea0192f" translate="yes" xml:space="preserve">
          <source>The function has its peak (the mode) at</source>
          <target state="translated">関数のピーク(モード)は</target>
        </trans-unit>
        <trans-unit id="6069aba02c2ff9e33d0e7ae153f4ba83da37a833" translate="yes" xml:space="preserve">
          <source>The function has its peak at the mean, and its &amp;ldquo;spread&amp;rdquo; increases with the standard deviation (the function reaches 0.607 times its maximum at</source>
          <target state="translated">関数は平均にピークを持ち、その「広がり」は標準偏差とともに増加します（関数は、最大値の0.607倍に達します</target>
        </trans-unit>
        <trans-unit id="3aafd01a0784838ff12d9b42abaea56f0c51d8d3" translate="yes" xml:space="preserve">
          <source>The function has zeroes where the angle is a multiple of</source>
          <target state="translated">の倍数であるゼロを持つ関数です。</target>
        </trans-unit>
        <trans-unit id="8224b60c460c6d30ff461ee22df630041e59b82c" translate="yes" xml:space="preserve">
          <source>The function is accessed as an attribute of or an item from the loaded shared-library. Thus, if &lt;code&gt;./mylib.so&lt;/code&gt; has a function named &lt;code&gt;cool_function1&lt;/code&gt;, I could access this function either as:</source>
          <target state="translated">関数は、ロードされた共有ライブラリの属性またはアイテムとしてアクセスされます。したがって、もし &lt;code&gt;./mylib.so&lt;/code&gt; はという名前の関数がある &lt;code&gt;cool_function1&lt;/code&gt; を、私はどちらかとこの機能にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="fafbcce3a94cb5de2e94d10e8bc93622f1a9c81d" translate="yes" xml:space="preserve">
          <source>The function is also useful for computing some kinds of days like holidays. In Canada and the U.S., Mother&amp;rsquo;s day is on the second Sunday in May, which can be computed with a custom weekmask.</source>
          <target state="translated">この関数は、休日のようなある種の日の計算にも役立ちます。カナダと米国では、母の日は5月の第2日曜日であり、カスタムの週マスクで計算できます。</target>
        </trans-unit>
        <trans-unit id="67cb306690132e9cba2500b1fa7de5410b4f5260" translate="yes" xml:space="preserve">
          <source>The function is applied to both the _data and the _mask, if any.</source>
          <target state="translated">この関数は、_data と _mask の両方に適用されます。</target>
        </trans-unit>
        <trans-unit id="da183d0fc1832c644fcb348cf07cf8e31326309a" translate="yes" xml:space="preserve">
          <source>The function is called with N parameters, where N is the rank of &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. Each parameter represents the coordinates of the array varying along a specific axis. For example, if &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; were &lt;code&gt;(2, 2)&lt;/code&gt;, then the parameters would be &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; and &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</source>
          <target state="translated">関数はN個のパラメーターで呼び出されます。ここで、Nは&lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;のランクです。各パラメーターは、特定の軸に沿って変化する配列の座標を表します。たとえば、&lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;(2, 2)&lt;/code&gt; 場合、パラメーターは &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; および &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f3d30cf3098994de825e7f6bde3ab7173788815" translate="yes" xml:space="preserve">
          <source>The function is called with N parameters, where N is the rank of &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. Each parameter represents the coordinates of the array varying along a specific axis. For example, if &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; were &lt;code&gt;(2, 2)&lt;/code&gt;, then the parameters would be &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; and &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</source>
          <target state="translated">この関数は、N個のパラメーターを使用して呼び出されます。ここで、Nは&lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;のランクです。各パラメーターは、特定の軸に沿って変化する配列の座標を表します。たとえば、&lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;(2, 2)&lt;/code&gt; 場合、パラメータは &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; および &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d612a9af75e269601691ae7eb90f682a5b996713" translate="yes" xml:space="preserve">
          <source>The function is called with N parameters, where N is the rank of &lt;code&gt;shape&lt;/code&gt;. Each parameter represents the coordinates of the array varying along a specific axis. For example, if &lt;code&gt;shape&lt;/code&gt; were &lt;code&gt;(2, 2)&lt;/code&gt;, then the parameters would be &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; and &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</source>
          <target state="translated">関数はN個のパラメーターで呼び出されます。ここで、Nは &lt;code&gt;shape&lt;/code&gt; のランクです。各パラメーターは、特定の軸に沿って変化する配列の座標を表します。たとえば、 &lt;code&gt;shape&lt;/code&gt; が &lt;code&gt;(2, 2)&lt;/code&gt; 場合、パラメーターは &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; および &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5020746e9a28c81bea9ebded1052af0dc8ae2dc6" translate="yes" xml:space="preserve">
          <source>The function is included as an argument to the python function call to the Fortran subroutine even though it was &lt;em&gt;not&lt;/em&gt; in the Fortran subroutine argument list. The &amp;ldquo;external&amp;rdquo; refers to the C function generated by f2py, not the python function itself. The python function must be supplied to the C function.</source>
          <target state="translated">この関数は、Fortranサブルーチンの引数リストに含まれてい&lt;em&gt;なく&lt;/em&gt;ても、Fortranサブルーチンへのpython関数呼び出しの引数として含まれています。「外部」とは、Python関数自体ではなく、f2pyによって生成されたC関数を指します。Python関数をC関数に指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="8addd0f39cba25bd912a60b0fb5434bfd595dbe3" translate="yes" xml:space="preserve">
          <source>The function pointer type for NpyAuxData clone functions. These functions should never set the Python exception on error, because they may be called from a multi-threaded context.</source>
          <target state="translated">NpyAuxDataクローン関数のための関数ポインタの型です。これらの関数は、マルチスレッドのコンテキストから呼び出される可能性があるため、エラー時にPythonの例外を設定してはいけません。</target>
        </trans-unit>
        <trans-unit id="167c7a543d8ccb24656ce9a1687449c4ecfb1950" translate="yes" xml:space="preserve">
          <source>The function pointer type for NpyAuxData free functions.</source>
          <target state="translated">NpyAuxDataフリー関数の関数ポインタ型です。</target>
        </trans-unit>
        <trans-unit id="a328f1fcd0be371ed7460c86c4fd60c08690a1c3" translate="yes" xml:space="preserve">
          <source>The function returns the coefficients of the polynomial</source>
          <target state="translated">この関数は,多項式</target>
        </trans-unit>
        <trans-unit id="56ed9dbe32b58078e6c4979647428ecdfd02c355" translate="yes" xml:space="preserve">
          <source>The function signature is normally found by introspection and displayed by the help function. For some functions (notably those written in C) the signature is not available, so we have to specify it as the first line of the docstring:</source>
          <target state="translated">関数のシグネチャは通常、イントロスペクションによって発見され、ヘルプ関数によって表示されます。いくつかの関数(特にC言語で書かれたもの)では、シグネチャが利用できないので、docstringの最初の行に指定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="f0b123a5d43604d228ff7e22be71c876bc3f213f" translate="yes" xml:space="preserve">
          <source>The function that is called when x and y are omitted</source>
          <target state="translated">xとyが省略されたときに呼び出される関数</target>
        </trans-unit>
        <trans-unit id="292f9d908dc66f70e34640d48dac32f92d8211ec" translate="yes" xml:space="preserve">
          <source>The function to be approximated. It must be a function of a single variable of the form &lt;code&gt;f(x, a, b, c...)&lt;/code&gt;, where &lt;code&gt;a, b, c...&lt;/code&gt; are extra arguments passed in the &lt;code&gt;args&lt;/code&gt; parameter.</source>
          <target state="translated">近似する関数。これは、 &lt;code&gt;f(x, a, b, c...)&lt;/code&gt; の形式の単一変数の関数である必要があります。ここ &lt;code&gt;a, b, c...&lt;/code&gt; は、 &lt;code&gt;args&lt;/code&gt; パラメーターで渡される追加の引数です。</target>
        </trans-unit>
        <trans-unit id="e68506a39d4f1164408a473e0014c02732a65744" translate="yes" xml:space="preserve">
          <source>The function to be deprecated.</source>
          <target state="translated">非推奨となる関数。</target>
        </trans-unit>
        <trans-unit id="1ed24e8ca86c415e0834a63e6e6d562c0814371f" translate="yes" xml:space="preserve">
          <source>The function to be interpolated. It must be a function of a single variable of the form &lt;code&gt;f(x, a, b, c...)&lt;/code&gt;, where &lt;code&gt;a, b, c...&lt;/code&gt; are extra arguments passed in the &lt;code&gt;args&lt;/code&gt; parameter.</source>
          <target state="translated">補間される関数。これは、形式 &lt;code&gt;f(x, a, b, c...)&lt;/code&gt; 単一変数の関数でなければなりません。ここ &lt;code&gt;a, b, c...&lt;/code&gt; は、 &lt;code&gt;args&lt;/code&gt; パラメーターで渡される追加の引数です。</target>
        </trans-unit>
        <trans-unit id="dd5723a1284c8aa8946aa81b4b7601e07d26020c" translate="yes" xml:space="preserve">
          <source>The functionality is based on &lt;a href=&quot;https://docs.python.org/dev/library/os.path.html#os.path.abspath&quot;&gt;&lt;code&gt;os.path.abspath&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">機能は&lt;a href=&quot;https://docs.python.org/dev/library/os.path.html#os.path.abspath&quot;&gt; &lt;code&gt;os.path.abspath&lt;/code&gt; に&lt;/a&gt;基づいています。</target>
        </trans-unit>
        <trans-unit id="e6e850d04a35d82db7e5c340cdd654a0e7af1cfd" translate="yes" xml:space="preserve">
          <source>The functionality this provides is largely superceded by iterator &lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt; introduced in 1.6, with flag &lt;a href=&quot;c-api.iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt;&lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt;&lt;/a&gt; or with the same dtype parameter for all operands.</source>
          <target state="translated">これが提供する機能の大部分は、フラグ&lt;a href=&quot;c-api.iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt; &lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt; &lt;/a&gt;またはすべてのオペランドに同じdtypeパラメータを使用して、1.6で導入されたイテレータ&lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt; &lt;code&gt;NpyIter&lt;/code&gt; に&lt;/a&gt;取って代わられています。</target>
        </trans-unit>
        <trans-unit id="a07514d8b8d140f4e03babf46c4ca643c0f5e565" translate="yes" xml:space="preserve">
          <source>The functionality this provides is largely superseded by iterator &lt;a href=&quot;iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt; introduced in 1.6, with flag &lt;a href=&quot;iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt;&lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt;&lt;/a&gt; or with the same dtype parameter for all operands.</source>
          <target state="translated">これが提供する機能は、1.6で導入されたイテレータ&lt;a href=&quot;iterator#c.NpyIter&quot;&gt; &lt;code&gt;NpyIter&lt;/code&gt; に&lt;/a&gt;大きく取って代わられ、フラグ&lt;a href=&quot;iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt; &lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt; を使用する&lt;/a&gt;か、すべてのオペランドに同じdtypeパラメーターを使用します。</target>
        </trans-unit>
        <trans-unit id="2962953aa600a37ce10b761bfc967d43ddef0e3d" translate="yes" xml:space="preserve">
          <source>The functions are named with the following conventions:</source>
          <target state="translated">関数の名前は、以下の規約に基づいて付けられます。</target>
        </trans-unit>
        <trans-unit id="9e207dc9abcf693e32399f76b884fbb8a9e3545f" translate="yes" xml:space="preserve">
          <source>The functions called to implement many arithmetic special methods for arrays can be modified using &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">配列の多くの算術特殊メソッドを実装するために呼び出される関数は、&lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;を使用して変更できます。</target>
        </trans-unit>
        <trans-unit id="9d8d64b72fb018cdee0e3f01b29eae167f558f81" translate="yes" xml:space="preserve">
          <source>The functions in the shared library are available as attributes of the ctypes library object (returned from &lt;code&gt;ctypeslib.load_library&lt;/code&gt;) or as items using &lt;code&gt;lib['func_name']&lt;/code&gt; syntax. The latter method for retrieving a function name is particularly useful if the function name contains characters that are not allowable in Python variable names.</source>
          <target state="translated">共有ライブラリの関数は、ctypesライブラリオブジェクト（ &lt;code&gt;ctypeslib.load_library&lt;/code&gt; から返される）の属性として、または &lt;code&gt;lib['func_name']&lt;/code&gt; 構文を使用するアイテムとして使用できます。関数名を取得するための後者の方法は、関数名にPython変数名で許可されていない文字が含まれている場合に特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="df46d6188871c9afe4dd8663a289bd38fe7112b3" translate="yes" xml:space="preserve">
          <source>The functions without &amp;ldquo;standard&amp;rdquo; in their name require additional parameters to describe the distributions.</source>
          <target state="translated">名前に「標準」が含まれていない関数には、分布を記述するための追加のパラメーターが必要です。</target>
        </trans-unit>
        <trans-unit id="780f3f42d3ad6d900b31dca5cc39ba44b8433b34" translate="yes" xml:space="preserve">
          <source>The future value is computed by solving the equation:</source>
          <target state="translated">式を解くことで、将来の値を計算します。</target>
        </trans-unit>
        <trans-unit id="35263bdc6b8f9ed76c3ffddda6ddc106a35e30ef" translate="yes" xml:space="preserve">
          <source>The gains are substantial and the scaling is reasonable even for arrays that are only moderately large. The gains are even larger when compared to a call that does not use an existing array due to array creation overhead.</source>
          <target state="translated">この利得はかなりのものであり,中程度の大きさの配列であってもスケーリングは妥当です.配列作成のオーバーヘッドのために既存の配列を使用しない呼び出しと比較すると,利益はさらに大きくなります.</target>
        </trans-unit>
        <trans-unit id="f54d15f1fff04aaad23c1e30a6699255a7286273" translate="yes" xml:space="preserve">
          <source>The gains are substantial and the scaling is reasonable even for large that are only moderately large. The gains are even larger when compared to a call that does not use an existing array due to array creation overhead.</source>
          <target state="translated">この利得は実質的なものであり,中程度の大きさしかない大規模なものでもスケーリングは合理的です.配列作成のオーバーヘッドのために既存の配列を使用しない呼び出しと比較すると、利益はさらに大きくなります。</target>
        </trans-unit>
        <trans-unit id="3a2348245b14000fc86ba9addf452f0058449713" translate="yes" xml:space="preserve">
          <source>The general concept of broadcasting is also available from Python using the &lt;a href=&quot;generated/numpy.broadcast#numpy.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt; iterator. This object takes</source>
          <target state="translated">ブロードキャストの一般的な概念は、&lt;a href=&quot;generated/numpy.broadcast#numpy.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt;イテレータを使用してPythonからも利用できます。このオブジェクトは</target>
        </trans-unit>
        <trans-unit id="a9641437007836c208f74db848ac79bd7c6780e6" translate="yes" xml:space="preserve">
          <source>The generated file will have the following content:</source>
          <target state="translated">生成されたファイルは以下の内容になります。</target>
        </trans-unit>
        <trans-unit id="1a1433c2f9219adfdc1717ee54946e456e115a63" translate="yes" xml:space="preserve">
          <source>The generated random samples</source>
          <target state="translated">生成されたランダムサンプル</target>
        </trans-unit>
        <trans-unit id="770d667a086582311721a20b1950124d0ed2b0b8" translate="yes" xml:space="preserve">
          <source>The generic hierarchical type objects convert to corresponding type objects according to the associations:</source>
          <target state="translated">一般的な階層型オブジェクトは、関連付けに応じて対応する型オブジェクトに変換されます。</target>
        </trans-unit>
        <trans-unit id="7b9da9a1e497b53c1498ef8728ff28c753a44590" translate="yes" xml:space="preserve">
          <source>The given decorator is applied to all public methods of &lt;code&gt;cls&lt;/code&gt; that are matched by the regular expression &lt;code&gt;testmatch&lt;/code&gt; (&lt;code&gt;testmatch.search(methodname)&lt;/code&gt;). Methods that are private, i.e. start with an underscore, are ignored.</source>
          <target state="translated">指定されたデコレータは、正規表現 &lt;code&gt;testmatch&lt;/code&gt; （ &lt;code&gt;testmatch.search(methodname)&lt;/code&gt; ）によって照合される &lt;code&gt;cls&lt;/code&gt; のすべてのパブリックメソッドに適用されます。プライベートなメソッド、つまりアンダースコアで始まるメソッドは無視されます。</target>
        </trans-unit>
        <trans-unit id="d15ec8784a28b893c0b85001548e5baae80372c7" translate="yes" xml:space="preserve">
          <source>The gradient is computed using second order accurate central differences in the interior points and either first or second order accurate one-sides (forward or backwards) differences at the boundaries. The returned gradient hence has the same shape as the input array.</source>
          <target state="translated">勾配は,内部の点における2次の正確な中心差と,境界での1次または2次の正確な片側(前方または後方)差を用いて計算されます.返される勾配は,入力配列と同じ形をしています.</target>
        </trans-unit>
        <trans-unit id="2b74e85f5516f60e3dbf421bf49f69c39506c265" translate="yes" xml:space="preserve">
          <source>The greatest common divisor</source>
          <target state="translated">最大公約数</target>
        </trans-unit>
        <trans-unit id="1335775c2defd62ddac3bf62f622a970f395fc71" translate="yes" xml:space="preserve">
          <source>The greatest common divisor of the absolute value of the inputs This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">入力の絶対値の最大公約数 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="1ffad58d21fbb0c889485660c6a73c057db064f2" translate="yes" xml:space="preserve">
          <source>The header file &amp;lt;numpy/halffloat.h&amp;gt; provides functions to work with IEEE 754-2008 16-bit floating point values. While this format is not typically used for numerical computations, it is useful for storing values which require floating point but do not need much precision. It can also be used as an educational tool to understand the nature of floating point round-off error.</source>
          <target state="translated">ヘッダーファイル&amp;lt;numpy / halffloat.h&amp;gt;は、IEEE 754-2008 16ビット浮動小数点値を処理する関数を提供します。この形式は通常、数値計算には使用されませんが、浮動小数点を必要とするがあまり精度を必要としない値を格納するのに役立ちます。また、浮動小数点の丸め誤差の性質を理解するための教育ツールとしても使用できます。</target>
        </trans-unit>
        <trans-unit id="d730bb14ffcab30f2844567d44182ca5b3af1815" translate="yes" xml:space="preserve">
          <source>The header of a typical SciPy &lt;code&gt;__init__.py&lt;/code&gt; is:</source>
          <target state="translated">一般的なSciPy &lt;code&gt;__init__.py&lt;/code&gt; のヘッダーは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="881c9d2e47b4057e556e6ff5df02bfb9e5dee04c" translate="yes" xml:space="preserve">
          <source>The highest precision data type of the same kind (&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt;&lt;code&gt;dtype.kind&lt;/code&gt;&lt;/a&gt;) as &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; と同じ種類（&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt; &lt;code&gt;dtype.kind&lt;/code&gt; &lt;/a&gt;）の最も精度の高いデータ型。</target>
        </trans-unit>
        <trans-unit id="f28aa2c9365c3014c1b3133bf8c0527b1b6cd92f" translate="yes" xml:space="preserve">
          <source>The hyperbolic cosine describes the shape of a hanging cable:</source>
          <target state="translated">双曲余弦は、ぶら下がっているケーブルの形状を表します。</target>
        </trans-unit>
        <trans-unit id="5dfe11baf5c84767b263b0b9280dd1d13ec6b531" translate="yes" xml:space="preserve">
          <source>The hypotenuse of the triangle(s). This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">三角形の斜辺。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="b1216f6dc1a8f133c88cabe04669f3d387166a72" translate="yes" xml:space="preserve">
          <source>The idea is to consider all but the first &lt;code&gt;k&lt;/code&gt; singular values in &lt;code&gt;Sigma&lt;/code&gt; (which are the same as in &lt;code&gt;s&lt;/code&gt;) as zeros, keeping &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;Vt&lt;/code&gt; intact, and computing the product of these matrices as the approximation.</source>
          <target state="translated">アイデアは、 &lt;code&gt;Sigma&lt;/code&gt; の最初の &lt;code&gt;k&lt;/code&gt; 個の特異値（ &lt;code&gt;s&lt;/code&gt; と同じ）を除くすべてをゼロと見なし、 &lt;code&gt;U&lt;/code&gt; と &lt;code&gt;Vt&lt;/code&gt; をそのまま維持し、これらの行列の積を近似として計算することです。</target>
        </trans-unit>
        <trans-unit id="a77669c9a72d14b0f58a0186d231f3894219b608" translate="yes" xml:space="preserve">
          <source>The identity array is a square array with ones on the main diagonal.</source>
          <target state="translated">アイデンティティ配列は、主対角線上にあるものを四角い配列にしたものです。</target>
        </trans-unit>
        <trans-unit id="2bf1c25d751d392b46c1da854b9e2214e84ecbda" translate="yes" xml:space="preserve">
          <source>The identity value.</source>
          <target state="translated">アイデンティティの値。</target>
        </trans-unit>
        <trans-unit id="a3a4e04cbf529a826b2105546fd57be959a238a1" translate="yes" xml:space="preserve">
          <source>The imaginary component of the complex argument. If &lt;code&gt;val&lt;/code&gt; is real, the type of &lt;code&gt;val&lt;/code&gt; is used for the output. If &lt;code&gt;val&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">複素引数の虚数成分。場合 &lt;code&gt;val&lt;/code&gt; が本当である、の種類 &lt;code&gt;val&lt;/code&gt; が出力のために使用されています。場合 &lt;code&gt;val&lt;/code&gt; は複雑な要素を持って、返された型はfloatです。</target>
        </trans-unit>
        <trans-unit id="7286bf711b04d53845d16cb5a31eaaaaa02757bf" translate="yes" xml:space="preserve">
          <source>The imaginary part of the array.</source>
          <target state="translated">配列の虚数部.</target>
        </trans-unit>
        <trans-unit id="9bc674154d61adacb44dda1d44c441449cdf2af6" translate="yes" xml:space="preserve">
          <source>The imaginary part of the masked array.</source>
          <target state="translated">マスクされた配列の虚数部。</target>
        </trans-unit>
        <trans-unit id="fd6e842a69d72f29a0581eb97a936eaef8759475" translate="yes" xml:space="preserve">
          <source>The implementation of the tests that produce this information.</source>
          <target state="translated">この情報を生成するテストの実施形態。</target>
        </trans-unit>
        <trans-unit id="aee088812e30b5da0a5df1b95d7c39c9c1258247" translate="yes" xml:space="preserve">
          <source>The implementations of multiplication, division, integration, and differentiation use the algebraic identities &lt;a href=&quot;#r3f3efff98d00-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;:</source>
          <target state="translated">乗算、除算、積分、微分の実装では、代数的恒等式を使用します&lt;a href=&quot;#r3f3efff98d00-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="1e2ea421bf4e67c223dedefb366e2029ced79732" translate="yes" xml:space="preserve">
          <source>The importance that each element has in the computation of the average. The weights array can either be 1-D (in which case its length must be the size of &lt;code&gt;a&lt;/code&gt; along the given axis) or of the same shape as &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;weights=None&lt;/code&gt;, then all data in &lt;code&gt;a&lt;/code&gt; are assumed to have a weight equal to one. If &lt;code&gt;weights&lt;/code&gt; is complex, the imaginary parts are ignored.</source>
          <target state="translated">平均の計算における各要素の重要性。重みアレイは、いずれかの1-D（その長さの大きさでなければならない場合であってもよい所定の軸に沿って）又は同様の形状。 &lt;code&gt;weights=None&lt;/code&gt; の場合、 &lt;code&gt;a&lt;/code&gt; のすべてのデータの重みは1であると想定されます。場合は &lt;code&gt;weights&lt;/code&gt; 複雑で、虚部は無視されます。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b1442547658f9bd4727b8dd9df733953ec22b3e" translate="yes" xml:space="preserve">
          <source>The importance that each element has in the computation of the average. The weights array can either be 1-D (in which case its length must be the size of &lt;code&gt;a&lt;/code&gt; along the given axis) or of the same shape as &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;weights=None&lt;/code&gt;, then all data in &lt;code&gt;a&lt;/code&gt; are assumed to have a weight equal to one. The 1-D calculation is:</source>
          <target state="translated">平均の計算において各要素が持つ重要性。重みアレイは、いずれかの1-D（その長さの大きさでなければならない場合であってもよい所定の軸に沿って）又は同様の形状。 &lt;code&gt;weights=None&lt;/code&gt; の場合、 &lt;code&gt;a&lt;/code&gt; のすべてのデータの重みは1に等しいと見なされます。1次元計算は次のとおりです。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0f3bacce4854001ee5a2b2337e74219eceafb03" translate="yes" xml:space="preserve">
          <source>The include statement is inserted just before the wrapper functions. This feature enables using arbitrary C functions (defined in &lt;code&gt;&amp;lt;includefile&amp;gt;&lt;/code&gt;) in F2PY generated wrappers.</source>
          <target state="translated">includeステートメントは、ラッパー関数の直前に挿入されます。この機能により、F2PYで生成されたラッパーで任意のC関数（ &lt;code&gt;&amp;lt;includefile&amp;gt;&lt;/code&gt; で定義）を使用できます。</target>
        </trans-unit>
        <trans-unit id="3e99cfec9384fa0ceb0f339e2c89b3b94a829c5f" translate="yes" xml:space="preserve">
          <source>The included BitGenerators are:</source>
          <target state="translated">同梱されているBitGeneratorsは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="22391c7101fab8760afe729b1932a0c59fad5983" translate="yes" xml:space="preserve">
          <source>The included generators can be used in parallel, distributed applications in one of three ways:</source>
          <target state="translated">付属のジェネレータは、3つの方法のいずれかで並列分散型アプリケーションで使用できます。</target>
        </trans-unit>
        <trans-unit id="0d9680eef1c6da704d4a94f1afb86f59c497487e" translate="yes" xml:space="preserve">
          <source>The index array consisting of the values 3, 3, 1 and 8 correspondingly create an array of length 4 (same as the index array) where each index is replaced by the value the index array has in the array being indexed.</source>
          <target state="translated">値3、3、1、8からなるインデックス配列は、対応して、各インデックスがインデックスされている配列の中でインデックス配列が持っている値に置き換えられる長さ4の配列(インデックス配列と同じ)を作成します。</target>
        </trans-unit>
        <trans-unit id="c31840bf8111dd67b394647308aa4678f4427cf3" translate="yes" xml:space="preserve">
          <source>The index is tracked by the iterator object itself, and accessible through the &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;multi_index&lt;/code&gt; properties, depending on what was requested. The examples below show printouts demonstrating the progression of the index:</source>
          <target state="translated">インデックスはイテレータオブジェクト自体によって追跡され、要求された内容に応じて、 &lt;code&gt;index&lt;/code&gt; または &lt;code&gt;multi_index&lt;/code&gt; プロパティを介してアクセスできます。以下の例は、インデックスの進行を示すプリントアウトを示しています。</target>
        </trans-unit>
        <trans-unit id="b00c25ebce056fd05b5bde5e2e04470c497a8460" translate="yes" xml:space="preserve">
          <source>The index syntax is very powerful but limiting when dealing with a variable number of indices. For example, if you want to write a function that can handle arguments with various numbers of dimensions without having to write special case code for each number of possible dimensions, how can that be done? If one supplies to the index a tuple, the tuple will be interpreted as a list of indices. For example (using the previous definition for the array z):</source>
          <target state="translated">インデックス構文は非常に強力ですが、可変数のインデックスを扱う場合には制限があります。例えば、可能な次元の数ごとに特別なケースコードを書かなくても、様々な次元数の引数を扱える関数を書きたいとしたら、どのようにすればよいでしょうか?インデックスにタプルを与えると、タプルはインデックスのリストとして解釈されます。例えば,(配列zの前の定義を使用して).</target>
        </trans-unit>
        <trans-unit id="2c2a3bfa2d0e12fb3599b918fb58fa555ca8de7c" translate="yes" xml:space="preserve">
          <source>The indexed result.</source>
          <target state="translated">インデックス化された結果。</target>
        </trans-unit>
        <trans-unit id="03743182a2227ccf2811c37150a243244da1cf36" translate="yes" xml:space="preserve">
          <source>The indexing works on the flattened target array. &lt;a href=&quot;#numpy.put&quot;&gt;&lt;code&gt;put&lt;/code&gt;&lt;/a&gt; is roughly equivalent to:</source>
          <target state="translated">インデックスは、平坦化されたターゲット配列に対して機能します。&lt;a href=&quot;#numpy.put&quot;&gt; &lt;code&gt;put&lt;/code&gt; &lt;/a&gt;はおおよそ次と同等です。</target>
        </trans-unit>
        <trans-unit id="59838ac2347062b68deb1ef0e067a09f0f1f12f7" translate="yes" xml:space="preserve">
          <source>The indices can be used as an index into an array.</source>
          <target state="translated">インデックスは配列へのインデックスとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="41bdc266e504f1b3636c2cdbc5a9368b53208f9c" translate="yes" xml:space="preserve">
          <source>The indices for the triangle. The returned tuple contains two arrays, each with the indices along one dimension of the array.</source>
          <target state="translated">三角形のインデックス.返されるタプルには2つの配列が含まれており,それぞれが配列の1次元に沿ったインデックスを持ちます.</target>
        </trans-unit>
        <trans-unit id="083f53a10046b877a4d17cdf8a047cadb142a0a5" translate="yes" xml:space="preserve">
          <source>The indices for the triangle. The returned tuple contains two arrays, each with the indices along one dimension of the array. Can be used to slice a ndarray of shape(&lt;code&gt;n&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;).</source>
          <target state="translated">三角形のインデックス。返されるタプルには2つの配列が含まれ、それぞれに配列の1次元に沿ったインデックスが付いています。shape（ &lt;code&gt;n&lt;/code&gt; 、 &lt;code&gt;n&lt;/code&gt; ）のndarrayをスライスするために使用できます。</target>
        </trans-unit>
        <trans-unit id="313bb1645ee0bcc96011930b78001b8efa601b2f" translate="yes" xml:space="preserve">
          <source>The indices of first and last non-masked value in the array. Returns None if all values are masked.</source>
          <target state="translated">配列内の最初と最後のマスクされていない値のインデックス。すべての値がマスクされている場合は None を返します。</target>
        </trans-unit>
        <trans-unit id="02de7d9422fcf4d3bd70015e02df12b6de819fce" translate="yes" xml:space="preserve">
          <source>The indices of the current iteration.</source>
          <target state="translated">現在の反復のインデックス。</target>
        </trans-unit>
        <trans-unit id="caeefd07d81c974d4f02d2a7cd29c00df5d3e970" translate="yes" xml:space="preserve">
          <source>The indices of the first occurrences of the common values in &lt;code&gt;ar1&lt;/code&gt;. Only provided if &lt;code&gt;return_indices&lt;/code&gt; is True.</source>
          <target state="translated">&lt;code&gt;ar1&lt;/code&gt; の共通値が最初に出現するインデックス。 &lt;code&gt;return_indices&lt;/code&gt; がTrueの場合にのみ提供されます。</target>
        </trans-unit>
        <trans-unit id="d03a2050722c8950165a7a42c8f8fbec16c8b478" translate="yes" xml:space="preserve">
          <source>The indices of the first occurrences of the common values in &lt;code&gt;ar2&lt;/code&gt;. Only provided if &lt;code&gt;return_indices&lt;/code&gt; is True.</source>
          <target state="translated">&lt;code&gt;ar2&lt;/code&gt; の共通値が最初に出現するインデックス。 &lt;code&gt;return_indices&lt;/code&gt; がTrueの場合にのみ提供されます。</target>
        </trans-unit>
        <trans-unit id="dba5b2feac59133a263255144aa942786b75991f" translate="yes" xml:space="preserve">
          <source>The indices of the first occurrences of the unique values in the original array. Only provided if &lt;code&gt;return_index&lt;/code&gt; is True.</source>
          <target state="translated">元の配列で一意の値が最初に出現するインデックス。 &lt;code&gt;return_index&lt;/code&gt; がTrueの場合にのみ提供されます。</target>
        </trans-unit>
        <trans-unit id="a4f376a3994ea66b3e8fe543f1059936c2c097d7" translate="yes" xml:space="preserve">
          <source>The indices of the matched values can be obtained with &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">一致した値のインデックスは、&lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt;で取得できます。</target>
        </trans-unit>
        <trans-unit id="43a87c99c2b28bd6cf46e8003a99b97203e9c8c1" translate="yes" xml:space="preserve">
          <source>The indices of the values to extract.</source>
          <target state="translated">抽出する値のインデックス。</target>
        </trans-unit>
        <trans-unit id="6ca413808a0cb47ebd7eb463c61ac12f6ed3fe9d" translate="yes" xml:space="preserve">
          <source>The indices to reconstruct the original array from the unique array. Only provided if &lt;code&gt;return_inverse&lt;/code&gt; is True.</source>
          <target state="translated">一意の配列から元の配列を再構築するためのインデックス。 &lt;code&gt;return_inverse&lt;/code&gt; がTrueの場合にのみ提供されます。</target>
        </trans-unit>
        <trans-unit id="76cdf05ced9d0285381afd071b2e4305a0c8b8a1" translate="yes" xml:space="preserve">
          <source>The indices will be valid for square arrays whose dimensions are the same as arr.</source>
          <target state="translated">インデックスは,arr と同じ寸法の正方配列に対して有効になります.</target>
        </trans-unit>
        <trans-unit id="b73635c48b132fb2b59a6aa95f3cc03ac517b9fa" translate="yes" xml:space="preserve">
          <source>The indices will be valid for square arrays.</source>
          <target state="translated">インデックスは正方配列で有効になります。</target>
        </trans-unit>
        <trans-unit id="2408a7bae27e18b5f16ce6bfc6c2e9edbdf96e75" translate="yes" xml:space="preserve">
          <source>The info dict contains the necessary options to use the C library.</source>
          <target state="translated">info dictには、Cライブラリを使用するために必要なオプションが含まれています。</target>
        </trans-unit>
        <trans-unit id="1a162a1581bd9df0f0c132b54dd0bc2b023b7fbc" translate="yes" xml:space="preserve">
          <source>The initialized generator object.</source>
          <target state="translated">初期化されたジェネレーター・オブジェクト。</target>
        </trans-unit>
        <trans-unit id="b17807d1d3d4b02432b9a563a71fb115959130d3" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;a&lt;/code&gt; as a float ndarray.</source>
          <target state="translated">float ndarrayとしての入力 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="223b4394f2d166cb77455c12d7788790c3301749" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;a&lt;/code&gt; in Fortran, or column-major, order.</source>
          <target state="translated">Fortran、または列優先の順序での入力 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75fd22e41868bea41cd02857931f82382a569f45" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;seed&lt;/code&gt; is processed by &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to generate the key. The counter is set to 0.</source>
          <target state="translated">入力 &lt;code&gt;seed&lt;/code&gt; は&lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;によって処理され、キーが生成されます。カウンターは0に設定されます。</target>
        </trans-unit>
        <trans-unit id="528560fa701c687c766a152165432c7d1064754a" translate="yes" xml:space="preserve">
          <source>The input array</source>
          <target state="translated">入力配列</target>
        </trans-unit>
        <trans-unit id="c14ffcb4fd955aec9b7bdb6f4e9b85112587e6c8" translate="yes" xml:space="preserve">
          <source>The input array needs to be of integer dtype, otherwise a TypeError is raised:</source>
          <target state="translated">入力配列は整数の dtype である必要があり、そうでない場合は TypeError が発生します。</target>
        </trans-unit>
        <trans-unit id="8ffb9fe9f3741ba95404f548e61803acdf79b642" translate="yes" xml:space="preserve">
          <source>The input array with invalid entries fixed.</source>
          <target state="translated">無効なエントリが固定された入力配列。</target>
        </trans-unit>
        <trans-unit id="729e431a614c3f0d0d957b108e3ad1877caf7dd5" translate="yes" xml:space="preserve">
          <source>The input array&amp;rsquo;s mask is modified by this function.</source>
          <target state="translated">入力配列のマスクは、この関数によって変更されます。</target>
        </trans-unit>
        <trans-unit id="2bcc0bcc75499b8aa5923f648739bb1e1c9c5f2a" translate="yes" xml:space="preserve">
          <source>The input array, but with all or a subset of the dimensions of length 1 removed. This is always &lt;code&gt;a&lt;/code&gt; itself or a view into &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">入力配列ですが、長さ1の次元のすべてまたはサブセットが削除されています。これは、常に自分自身またはへのビュー。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9c1757f1f00139c3d32d32875dc4cdee7e7573b" translate="yes" xml:space="preserve">
          <source>The input array, but with all or a subset of the dimensions of length 1 removed. This is always &lt;code&gt;a&lt;/code&gt; itself or a view into &lt;code&gt;a&lt;/code&gt;. Note that if all axes are squeezed, the result is a 0d array and not a scalar.</source>
          <target state="translated">入力配列ですが、長さ1の次元のすべてまたはサブセットが削除されています。これは、常に自分自身またはへのビュー。すべての軸が圧縮されている場合、結果は0d配列であり、スカラーではないことに注意してください。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b9eebd6f3c2dccb825ca1eb5d3b6fff39eb990c" translate="yes" xml:space="preserve">
          <source>The input array.</source>
          <target state="translated">入力配列です。</target>
        </trans-unit>
        <trans-unit id="a8dbbfb64079646cc26f949474f62f6d5a8bdb10" translate="yes" xml:space="preserve">
          <source>The input arrays are the coefficients (including any coefficients equal to zero) of the &amp;ldquo;numerator&amp;rdquo; (dividend) and &amp;ldquo;denominator&amp;rdquo; (divisor) polynomials, respectively.</source>
          <target state="translated">入力配列は、それぞれ「分子」（被除数）および「分母」（除数）多項式の係数（ゼロに等しい係数を含む）です。</target>
        </trans-unit>
        <trans-unit id="a4fe0b89df27127c64e2d6a838fb7376eb328411" translate="yes" xml:space="preserve">
          <source>The input can be of any type and shape.</source>
          <target state="translated">入力の種類や形状は問いません。</target>
        </trans-unit>
        <trans-unit id="0756c557e9cd622a4b4a6242d6e56ce5652e83a5" translate="yes" xml:space="preserve">
          <source>The input data type is preserved, list/tuple in means list/tuple out.</source>
          <target state="translated">入力データ型は保存され、list/tuple in は list/tuple out を意味します。</target>
        </trans-unit>
        <trans-unit id="7e65fba32b4c379aee34d72564b929f364329962" translate="yes" xml:space="preserve">
          <source>The input data type. This can be a &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; object or an object that is convertible to a &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">入力データ型。これは、&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;オブジェクトまたはdtypeに変換可能なオブジェクトにすることが&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="8769eb794f5a03165931ba8181e41168fd7a696f" translate="yes" xml:space="preserve">
          <source>The input domain.</source>
          <target state="translated">入力領域。</target>
        </trans-unit>
        <trans-unit id="8cece683eb84b1c6561cdb1ebf8cbf9f503e743a" translate="yes" xml:space="preserve">
          <source>The input is expected to be in the form returned by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, i.e. the real zero-frequency term followed by the complex positive frequency terms in order of increasing frequency. Since the discrete Fourier Transform of real input is Hermitian-symmetric, the negative frequency terms are taken to be the complex conjugates of the corresponding positive frequency terms.</source>
          <target state="translated">入力は、&lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt;によって返される形式であることが期待されます。つまり、実際のゼロ周波数項の後に、周波数の昇順で複素数の正の周波数項が続きます。実際の入力の離散フーリエ変換はエルミート対称であるため、負の周波数項は、対応する正の周波数項の複素共役と見なされます。</target>
        </trans-unit>
        <trans-unit id="6f9750084d20ac908a43842756c2b861e3f42c50" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to fill the whole state. The first element is reset such that only its most significant bit is set.</source>
          <target state="translated">入力シードは&lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;によって処理され、状態全体が満たされます。最初の要素は、最上位ビットのみが設定されるようにリセットされます。</target>
        </trans-unit>
        <trans-unit id="a8974905180f39b4ffd2915ed945588ac5ab3b98" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to generate both values. The increment is not independently settable.</source>
          <target state="translated">入力シードは&lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;によって処理され、両方の値が生成されます。増分は個別に設定できません。</target>
        </trans-unit>
        <trans-unit id="9c7b1d5b6198e399c073a141f7cd1b6b8febb604" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to generate the first 3 values, then the &lt;code&gt;SFC64&lt;/code&gt; algorithm is iterated a small number of times to mix.</source>
          <target state="translated">入力シードは&lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;によって処理され、最初の3つの値が生成されます。次に、 &lt;code&gt;SFC64&lt;/code&gt; アルゴリズムが数回繰り返されて混合されます。</target>
        </trans-unit>
        <trans-unit id="8d2a5838e3e88200b2eb57081e0d55983a6951c5" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to fill the whole state. The first element is reset such that only its most significant bit is set.</source>
          <target state="translated">入力シードは、 &lt;code&gt;SeedSequence&lt;/code&gt; によって処理され、状態全体が埋められます。最初の要素はリセットされ、最上位ビットのみが設定されます。</target>
        </trans-unit>
        <trans-unit id="b59429801bb072b95be274b2cab8c79cb4d9a0af" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to generate both values. The increment is not independently settable.</source>
          <target state="translated">入力シードは &lt;code&gt;SeedSequence&lt;/code&gt; によって処理され、両方の値が生成されます。増分は独立して設定できません。</target>
        </trans-unit>
        <trans-unit id="837326b6e18d83ecb217345cd40ecfada7f873f1" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to generate the first 3 values, then the &lt;code&gt;SFC64&lt;/code&gt; algorithm is iterated a small number of times to mix.</source>
          <target state="translated">入力シードは &lt;code&gt;SeedSequence&lt;/code&gt; によって処理され、最初の3つの値が生成されます。次に、 &lt;code&gt;SFC64&lt;/code&gt; アルゴリズムが少数回反復されて混合されます。</target>
        </trans-unit>
        <trans-unit id="df03e47997abce099faab26366e6f5795a2b583f" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to generate the key. The counter is set to 0.</source>
          <target state="translated">入力シードは、 &lt;code&gt;SeedSequence&lt;/code&gt; によって処理されてキーが生成されます。カウンターは0に設定されます。</target>
        </trans-unit>
        <trans-unit id="9065e71c46c758a421d1a5608c4e7515cdea0b0c" translate="yes" xml:space="preserve">
          <source>The input should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, i.e.,</source>
          <target state="translated">入力は、&lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;が返すのと同じ方法で順序付けする必要があります。つまり、</target>
        </trans-unit>
        <trans-unit id="14cd4f07dbbafbca343da6b376f0bb96ca0ebb1e" translate="yes" xml:space="preserve">
          <source>The input should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;, i.e. as for &lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt; for the final transformation axis, and as for &lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; along all the other axes.</source>
          <target state="translated">入力が返されるのと同じ方法で順序付けされるべき&lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt;用として、すなわち&lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; &lt;/a&gt;最終変換軸用、およびに関しては&lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; &lt;/a&gt;他のすべての軸に沿っ。</target>
        </trans-unit>
        <trans-unit id="44801963410659f1459e257160aa0d4b1ef39ba2" translate="yes" xml:space="preserve">
          <source>The input value(s).</source>
          <target state="translated">入力された値。</target>
        </trans-unit>
        <trans-unit id="519628f03d9ba5d6ae3260f3b709f32afd6fac80" translate="yes" xml:space="preserve">
          <source>The input, analogously to &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;, should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.fft2#numpy.fft.fft2&quot;&gt;&lt;code&gt;fft2&lt;/code&gt;&lt;/a&gt;, i.e. it should have the term for zero frequency in the low-order corner of the two axes, the positive frequency terms in the first half of these axes, the term for the Nyquist frequency in the middle of the axes and the negative frequency terms in the second half of both axes, in order of decreasingly negative frequency.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt;と同様に、入力は&lt;a href=&quot;numpy.fft.fft2#numpy.fft.fft2&quot;&gt; &lt;code&gt;fft2&lt;/code&gt; &lt;/a&gt;によって返されるのと同じ方法で順序付けする必要があります。つまり、2つの軸の低次コーナーにゼロ周波数の項があり、これらの前半に正の周波数項があります。軸、軸の中央のナイキスト周波数の項、および両方の軸の後半の負の周波数の項。負の周波数から順に減少します。</target>
        </trans-unit>
        <trans-unit id="572b4f9e26edc1e967cf68e0ade8b40ff905e225" translate="yes" xml:space="preserve">
          <source>The input, analogously to &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;, should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;, i.e. it should have the term for zero frequency in all axes in the low-order corner, the positive frequency terms in the first half of all axes, the term for the Nyquist frequency in the middle of all axes and the negative frequency terms in the second half of all axes, in order of decreasingly negative frequency.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt;と同様に、入力は&lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt;によって返されるのと同じ方法で順序付けする必要があります。つまり、入力は、低次の隅のすべての軸でゼロ周波数の項、すべての軸の前半で正の周波数項を持つ必要があります、すべての軸の真ん中のナイキスト周波数の項と、すべての軸の後半の負の周波数項を、負の周波数から順に示します。</target>
        </trans-unit>
        <trans-unit id="0d58354ed5e0735b3768fbb2adf71637dbdf3f49" translate="yes" xml:space="preserve">
          <source>The integration constants default to zero, but can be specified:</source>
          <target state="translated">積分定数のデフォルトはゼロですが、指定することができます。</target>
        </trans-unit>
        <trans-unit id="b8cfb0f4ba349fe08f791a3f4e9c32e0be770fb0" translate="yes" xml:space="preserve">
          <source>The intent directive, intent(out) is used to tell f2py that &lt;code&gt;c&lt;/code&gt; is an output variable and should be created by the interface before being passed to the underlying code. The intent(hide) directive tells f2py to not allow the user to specify the variable, &lt;code&gt;n&lt;/code&gt;, but instead to get it from the size of &lt;code&gt;a&lt;/code&gt;. The depend( &lt;code&gt;a&lt;/code&gt; ) directive is necessary to tell f2py that the value of n depends on the input a (so that it won&amp;rsquo;t try to create the variable n until the variable a is created).</source>
          <target state="translated">インテントディレクティブintent（out）は、 &lt;code&gt;c&lt;/code&gt; が出力変数であり、基になるコードに渡される前にインターフェイスによって作成される必要があることをf2pyに通知するために使用されます。 intent（hide）ディレクティブは、ユーザーが変数 &lt;code&gt;n&lt;/code&gt; を指定することを許可せず、代わりに &lt;code&gt;a&lt;/code&gt; のサイズから取得するようにf2pyに指示します。 depend（ &lt;code&gt;a&lt;/code&gt; ）ディレクティブは、nの値が入力aに依存することをf2pyに通知するために必要です（変数aが作成されるまで変数nを作成しようとしないようにするため）。</target>
        </trans-unit>
        <trans-unit id="fef0aef07474fa13f32cd7e44f96fd84d9e33ac9" translate="yes" xml:space="preserve">
          <source>The interface definition file (.pyf) is how you can fine-tune the interface between Python and Fortran. There is decent documentation for f2py found in the numpy/f2py/docs directory where-ever NumPy is installed on your system (usually under site-packages). There is also more information on using f2py (including how to use it to wrap C codes) at &lt;a href=&quot;https://scipy-cookbook.readthedocs.io&quot;&gt;https://scipy-cookbook.readthedocs.io&lt;/a&gt; under the &amp;ldquo;Interfacing With Other Languages&amp;rdquo; heading.</source>
          <target state="translated">インターフェース定義ファイル（.pyf）は、PythonとFortranの間のインターフェースを微調整する方法です。NumPyがシステムにインストールされている場所（通常はsite-packagesの下）のnumpy / f2py / docsディレクトリにf2pyの適切なドキュメントがあります。&lt;a href=&quot;https://scipy-cookbook.readthedocs.io&quot;&gt;https://scipy-cookbook.readthedocs.io&lt;/a&gt;の「InterfacewithOtherLanguages」の見出しの下にあるf2pyの使用に関する詳細（Cコードをラップするための使用方法を含む）もあります。</target>
        </trans-unit>
        <trans-unit id="a5987614ed3add49e80f0f100dd67a16f44fe90c" translate="yes" xml:space="preserve">
          <source>The interpolated values, same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と同じ形状の補間値。</target>
        </trans-unit>
        <trans-unit id="c7907bef880fafa82932152f51dbb34029c0604c" translate="yes" xml:space="preserve">
          <source>The inverse &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt;&lt;code&gt;cos&lt;/code&gt;&lt;/a&gt; is also known as &lt;code&gt;acos&lt;/code&gt; or cos^-1.</source>
          <target state="translated">逆&lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt; &lt;code&gt;cos&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;acos&lt;/code&gt; またはcos ^ -1 とも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="ec2dceba2b532e6fed6c11da573a946f40425e79" translate="yes" xml:space="preserve">
          <source>The inverse DFT is defined as</source>
          <target state="translated">逆DFTは次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="8495a1f69fb848ed573ead2789554fd370f64138" translate="yes" xml:space="preserve">
          <source>The inverse Gaussian distribution was first studied in relationship to Brownian motion. In 1956 M.C.K. Tweedie used the name inverse Gaussian because there is an inverse relationship between the time to cover a unit distance and distance covered in unit time.</source>
          <target state="translated">逆ガウス分布は、ブラウン運動との関係で最初に研究されました。1956年にM.C.K.Tweedieが逆ガウス分布という名前を使ったのは、単位距離をカバーする時間と単位時間でカバーされる距離の間に逆の関係があるからです。</target>
        </trans-unit>
        <trans-unit id="68560eb00ac6299a73ce699655a0c6fd4e05a46a" translate="yes" xml:space="preserve">
          <source>The inverse function.</source>
          <target state="translated">逆関数です。</target>
        </trans-unit>
        <trans-unit id="fe2bbafffa2c0c536b90659aca2befdd2f2ba17e" translate="yes" xml:space="preserve">
          <source>The inverse hyperbolic sine is also known as &lt;code&gt;asinh&lt;/code&gt; or &lt;code&gt;sinh^-1&lt;/code&gt;.</source>
          <target state="translated">逆双曲線正弦は、 &lt;code&gt;asinh&lt;/code&gt; または &lt;code&gt;sinh^-1&lt;/code&gt; とも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="6a141e357fc6a95097873c345fcfc1ca43237a09" translate="yes" xml:space="preserve">
          <source>The inverse hyperbolic tangent is also known as &lt;code&gt;atanh&lt;/code&gt; or &lt;code&gt;tanh^-1&lt;/code&gt;.</source>
          <target state="translated">逆双曲線正接は、 &lt;code&gt;atanh&lt;/code&gt; または &lt;code&gt;tanh^-1&lt;/code&gt; とも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="aed0ee03d4e87b9fedd1788aca12c58fdfb391c4" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;の逆。</target>
        </trans-unit>
        <trans-unit id="0b353ae768e12e71d0fa6bfe266dc15cf5490d90" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;, the inverse &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">逆&lt;a href=&quot;#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt;、逆&lt;em&gt;N&lt;/em&gt;次元FFT。</target>
        </trans-unit>
        <trans-unit id="c086c016e117d897d4f2eb057744861a76634688" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt;の逆です。</target>
        </trans-unit>
        <trans-unit id="9c2cb38b9631386379f4eeff7af3bee02f4b9bd5" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.hfft&quot;&gt;&lt;code&gt;hfft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.hfft&quot;&gt; &lt;code&gt;hfft&lt;/code&gt; &lt;/a&gt;の逆です。</target>
        </trans-unit>
        <trans-unit id="13314fd29e0fae4ac48c552fa0a549b05087d956" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt;の逆です。</target>
        </trans-unit>
        <trans-unit id="ff66e88345498b6e91d7444ef284a6ddd3ab7bea" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;, i.e. the inverse of the n-dimensional FFT of real input.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt;の逆、つまり実数入力のn次元FFTの逆。</target>
        </trans-unit>
        <trans-unit id="9e5b2a4471d9b30f761353eccfa786e46a0a43ee" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;generated/numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt;の逆です。</target>
        </trans-unit>
        <trans-unit id="f58d6b52f1a134a30d097dc36ab0b6c772a15466" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt;&lt;code&gt;cos&lt;/code&gt;&lt;/a&gt; so that, if &lt;code&gt;y = cos(x)&lt;/code&gt;, then &lt;code&gt;x = arccos(y)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt; &lt;code&gt;cos&lt;/code&gt; &lt;/a&gt;の逆なので、 &lt;code&gt;y = cos(x)&lt;/code&gt; 場合、 &lt;code&gt;x = arccos(y)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="55a9d6743075a74b179dcc12407ef1436ea7bf25" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;. Although identical for even-length &lt;code&gt;x&lt;/code&gt;, the functions differ by one sample for odd-length &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt;の逆です。偶数長の &lt;code&gt;x&lt;/code&gt; の場合も同じですが、関数は奇数長の &lt;code&gt;x&lt;/code&gt; の場合のサンプルが1つ異なります。</target>
        </trans-unit>
        <trans-unit id="2b74e3f8abd785dde93a2e8dda9f5c04957251f7" translate="yes" xml:space="preserve">
          <source>The inverse of tan, so that if &lt;code&gt;y = tan(x)&lt;/code&gt; then &lt;code&gt;x = arctan(y)&lt;/code&gt;.</source>
          <target state="translated">tanの逆なので、 &lt;code&gt;y = tan(x)&lt;/code&gt; 場合、 &lt;code&gt;x = arctan(y)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="7167a352b20dee7e079ce80d9af1a1aba672dc81" translate="yes" xml:space="preserve">
          <source>The inverse of the &lt;em&gt;n&lt;/em&gt;-dimensional FFT of real input.</source>
          <target state="translated">実数入力の&lt;em&gt;n&lt;/em&gt;次元FFT の逆。</target>
        </trans-unit>
        <trans-unit id="c880c78696b367269e70a1f53424d9f97028c767" translate="yes" xml:space="preserve">
          <source>The inverse of the &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt;次元FFT の逆。</target>
        </trans-unit>
        <trans-unit id="f53fd91fa9c77430f006f0266202a3482a70bbcc" translate="yes" xml:space="preserve">
          <source>The inverse of the one-dimensional FFT of real input.</source>
          <target state="translated">実数入力の一次元FFTの逆数です。</target>
        </trans-unit>
        <trans-unit id="3905252dc05b002d9515309faf3f78f1dbb4c5f8" translate="yes" xml:space="preserve">
          <source>The inverse of the two-dimensional FFT of real input.</source>
          <target state="translated">実数入力の2次元FFTの逆数です。</target>
        </trans-unit>
        <trans-unit id="3423775348fb08030d24725c90e7b0f2bd7d7c47" translate="yes" xml:space="preserve">
          <source>The inverse operation, adding singleton dimensions</source>
          <target state="translated">逆の操作、シングルトン次元の追加</target>
        </trans-unit>
        <trans-unit id="aa766ce77746577ed5c08c35ec888672cda564ff" translate="yes" xml:space="preserve">
          <source>The inverse operation, removing singleton dimensions</source>
          <target state="translated">逆演算、シングルトン次元の除去</target>
        </trans-unit>
        <trans-unit id="61a85cd6779e9d5a8b6211c3c235036b15ffb999" translate="yes" xml:space="preserve">
          <source>The inverse sine is also known as &lt;code&gt;asin&lt;/code&gt; or sin^{-1}.</source>
          <target state="translated">逆正弦は、 &lt;code&gt;asin&lt;/code&gt; またはsin ^ {-1} とも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="bfedf779c5c4bd6b17ab80b12a0d79168ab5aaa7" translate="yes" xml:space="preserve">
          <source>The inverse sine of each element in &lt;code&gt;x&lt;/code&gt;, in radians and in the closed interval &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 、ラジアン、および閉区間 &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt; の各要素の逆正弦。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="9c1a84044c9dab08c09d55a04b2b48623b8d59b6" translate="yes" xml:space="preserve">
          <source>The inverse tangent is also known as &lt;code&gt;atan&lt;/code&gt; or tan^{-1}.</source>
          <target state="translated">逆正接は、 &lt;code&gt;atan&lt;/code&gt; またはtan ^ {-1} とも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="6981525643a6c5c7fc9e1e7dde681f16ce56e65e" translate="yes" xml:space="preserve">
          <source>The inverse two-dimensional FFT.</source>
          <target state="translated">逆二次元FFTです。</target>
        </trans-unit>
        <trans-unit id="bdb5ead908952013fac6606928f3a4c8d7370b91" translate="yes" xml:space="preserve">
          <source>The irrational number &lt;code&gt;e&lt;/code&gt; is also known as Euler&amp;rsquo;s number. It is approximately 2.718281, and is the base of the natural logarithm, &lt;code&gt;ln&lt;/code&gt; (this means that, if</source>
          <target state="translated">無理数 &lt;code&gt;e&lt;/code&gt; はオイラー数とも呼ばれます。これは約2.718281であり、自然対数 &lt;code&gt;ln&lt;/code&gt; （これは、</target>
        </trans-unit>
        <trans-unit id="3dd3b5ec09656689d6b02dda587489104a598f1e" translate="yes" xml:space="preserve">
          <source>The iterator flag &amp;ldquo;delay_bufalloc&amp;rdquo; is there to allow iterator-allocated reduction operands to exist together with buffering. When this flag is set, the iterator will leave its buffers uninitialized until it receives a reset, after which it will be ready for regular iteration. Here&amp;rsquo;s how the previous example looks if we also enable buffering.</source>
          <target state="translated">イテレータフラグ「delay_bufalloc」は、イテレータ割り当ての縮小オペランドがバッファリングと一緒に存在できるようにするためのものです。このフラグが設定されている場合、イテレーターは、リセットを受け取るまでバッファーを初期化せずに残し、その後、通常の反復の準備が整います。これも、バッファリングを有効にした場合の前の例の外観です。</target>
        </trans-unit>
        <trans-unit id="83edec37e4aaff5eef637f7c874f4dba22293c2c" translate="yes" xml:space="preserve">
          <source>The iterator holds a reference to iter</source>
          <target state="translated">イテレータは、イテレータへの参照を保持します。</target>
        </trans-unit>
        <trans-unit id="ffb4fa1555c6cc08c5edb304e11089604a5e4b03" translate="yes" xml:space="preserve">
          <source>The iterator layout is an internal detail, and user code only sees an incomplete struct.</source>
          <target state="translated">イテレータのレイアウトは内部的な詳細であり、ユーザー・コードは不完全な構造体しか見ていません。</target>
        </trans-unit>
        <trans-unit id="5cd3a081c57ba646ed11444a9ba92c76e9cd9145" translate="yes" xml:space="preserve">
          <source>The iterator object &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt;, introduced in NumPy 1.6, provides many flexible ways to visit all the elements of one or more arrays in a systematic fashion. This page introduces some basic ways to use the object for computations on arrays in Python, then concludes with how one can accelerate the inner loop in Cython. Since the Python exposure of &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; is a relatively straightforward mapping of the C array iterator API, these ideas will also provide help working with array iteration from C or C++.</source>
          <target state="translated">NumPy 1.6で導入されたイテレーターオブジェクト&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; は&lt;/a&gt;、1つ以上の配列のすべての要素を体系的にアクセスする多くの柔軟な方法を提供します。このページでは、Pythonで配列の計算にオブジェクトを使用するいくつかの基本的な方法を紹介し、Cythonの内部ループを加速する方法について結論を出します。&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;のPythonでの公開は、C配列反復子APIの比較的単純なマッピングであるため、これらのアイデアは、CまたはC ++からの配列反復の操作にも役立ちます。</target>
        </trans-unit>
        <trans-unit id="c7cde3e3f66c5a8b8cc8bfff4db276cc023c595e" translate="yes" xml:space="preserve">
          <source>The iterator uses NumPy&amp;rsquo;s casting rules to determine whether a specific conversion is permitted. By default, it enforces &amp;lsquo;safe&amp;rsquo; casting. This means, for example, that it will raise an exception if you try to treat a 64-bit float array as a 32-bit float array. In many cases, the rule &amp;lsquo;same_kind&amp;rsquo; is the most reasonable rule to use, since it will allow conversion from 64 to 32-bit float, but not from float to int or from complex to float.</source>
          <target state="translated">イテレーターは、NumPyのキャスト規則を使用して、特定の変換が許可されているかどうかを判別します。デフォルトでは、「安全な」キャストを強制します。たとえば、64ビットの浮動小数点配列を32ビットの浮動小数点配列として処理しようとすると、例外が発生します。多くの場合、ルール 'same_kind'は、64ビットから32ビットの浮動小数点への変換を許可しますが、浮動小数点から整数への変換、または複素数から浮動小数点への変換を許可しないため、使用する最も合理的なルールです。</target>
        </trans-unit>
        <trans-unit id="cacf8c06cd15c0c88c5430d945ba0f2cf7ba5182" translate="yes" xml:space="preserve">
          <source>The ix_() function</source>
          <target state="translated">ix_()関数</target>
        </trans-unit>
        <trans-unit id="bfb129467dcc5458e92314d1dc23bfece4b4c9b2" translate="yes" xml:space="preserve">
          <source>The jump size is</source>
          <target state="translated">ジャンプサイズは</target>
        </trans-unit>
        <trans-unit id="ce335f317c6680914a491bd8a7fe70c41740c803" translate="yes" xml:space="preserve">
          <source>The jump step is computed using a modified version of Matsumoto&amp;rsquo;s implementation of Horner&amp;rsquo;s method. The step polynomial is precomputed to perform 2**128 steps. The jumped state has been verified to match the state produced using Matsumoto&amp;rsquo;s original code.</source>
          <target state="translated">ジャンプステップは、マツモトのホーナー法の実装の修正バージョンを使用して計算されます。ステップ多項式は、2 ** 128ステップを実行するように事前に計算されています。ジャンプ状態は、松本元のコードを使用して生成された状態と一致することが確認されています。</target>
        </trans-unit>
        <trans-unit id="342e9169764fb77c1b214a706155105da1218b49" translate="yes" xml:space="preserve">
          <source>The key should be either a string or a sequence of string corresponding to the fields used to join the array. An exception is raised if the &lt;code&gt;key&lt;/code&gt; field cannot be found in the two input arrays. Neither &lt;code&gt;r1&lt;/code&gt; nor &lt;code&gt;r2&lt;/code&gt; should have any duplicates along &lt;code&gt;key&lt;/code&gt;: the presence of duplicates will make the output quite unreliable. Note that duplicates are not looked for by the algorithm.</source>
          <target state="translated">キーは、配列の結合に使用されるフィールドに対応する文字列または文字列のシーケンスのいずれかである必要があります。 &lt;code&gt;key&lt;/code&gt; フィールドが2つの入力配列で見つからない場合、例外が発生します。どちら &lt;code&gt;r1&lt;/code&gt; や &lt;code&gt;r2&lt;/code&gt; 一緒に任意の重複していなければならない &lt;code&gt;key&lt;/code&gt; ：重複の存在は、出力はかなり信頼できないようになります。重複はアルゴリズムによって検索されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="1697c380f1179f3bbb3a86f4d75a8de0b46efbc6" translate="yes" xml:space="preserve">
          <source>The keys are:</source>
          <target state="translated">鍵は...</target>
        </trans-unit>
        <trans-unit id="b094a8a56c283a1dca9080c127defb8dc7eabacc" translate="yes" xml:space="preserve">
          <source>The kind of integer data type to get information about.</source>
          <target state="translated">情報を取得するための整数データ型の種類。</target>
        </trans-unit>
        <trans-unit id="41c3ca93d5f02dccd969da26a833b72af9110c68" translate="yes" xml:space="preserve">
          <source>The kwds argument holds a Python dictionary whose keys are the names of the keyword arguments and whose values are the corresponding keyword-argument values. This dictionary can be processed however you see fit. The easiest way to handle it, however, is to replace the &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; (args, format_string, addresses&amp;hellip;) function with a call to &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTupleAndKeywords&quot;&gt;&lt;code&gt;PyArg_ParseTupleAndKeywords&lt;/code&gt;&lt;/a&gt; (args, kwds, format_string, char *kwlist[], addresses&amp;hellip;). The kwlist parameter to this function is a &lt;code&gt;NULL&lt;/code&gt; -terminated array of strings providing the expected keyword arguments. There should be one string for each entry in the format_string. Using this function will raise a TypeError if invalid keyword arguments are passed in.</source>
          <target state="translated">kwds引数は、キーがキーワード引数の名前であり、値が対応するキーワード引数の値であるPython辞書を保持します。この辞書は、適切と思われる方法で処理できます。ただし、これを処理する最も簡単な方法は、&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt;（args、format_string、addresses&amp;hellip;）関数を&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTupleAndKeywords&quot;&gt; &lt;code&gt;PyArg_ParseTupleAndKeywords&lt;/code&gt; &lt;/a&gt;（args、kwds、format_string、char * kwlist []、addresses&amp;hellip;）の呼び出しに置き換えることです。この関数のkwlistパラメーターは、予期されるキーワード引数を提供する文字列の &lt;code&gt;NULL&lt;/code&gt; で終了する配列です。 format_stringのエントリごとに1つの文字列が必要です。この関数を使用すると、無効なキーワード引数が渡された場合にTypeErrorが発生します。</target>
        </trans-unit>
        <trans-unit id="d80fbf99f1073ba593f4b530d71e8ae5f9ae88a1" translate="yes" xml:space="preserve">
          <source>The larger object to compare.</source>
          <target state="translated">比較対象の大きい方。</target>
        </trans-unit>
        <trans-unit id="3b1d6d882f09df5877abb8ef200d99a4552edbcc" translate="yes" xml:space="preserve">
          <source>The largest representable number.</source>
          <target state="translated">表現可能な最大の数。</target>
        </trans-unit>
        <trans-unit id="8c04ea0c745fb65e3a5c6b4d6a06693d11870a3e" translate="yes" xml:space="preserve">
          <source>The last dimension of the input array is converted into a structure, with number of field-elements equal to the size of the last dimension of the input array. By default all output fields have the input array&amp;rsquo;s dtype, but an output structured dtype with an equal number of fields-elements can be supplied instead.</source>
          <target state="translated">入力配列の最後の次元は、入力配列の最後の次元のサイズに等しいフィールド要素の数を持つ構造体に変換されます。デフォルトでは、すべての出力フィールドに入力配列のdtypeがありますが、同じ数のフィールドを持つ出力構造化dtype-代わりに要素を指定できます。</target>
        </trans-unit>
        <trans-unit id="2abbd596290a88e6d12f22ea12675111b689f0a9" translate="yes" xml:space="preserve">
          <source>The last is an instance of freezing a core dimension and can be used to improve ufunc performance</source>
          <target state="translated">最後はコアディメンジョンのフリーズの例で、ufunc のパフォーマンスを向上させるために使用することができます。</target>
        </trans-unit>
        <trans-unit id="64a2253d0a7bf7afbe6eb3cddc1d5520d0b0c60a" translate="yes" xml:space="preserve">
          <source>The last one giving only the first elements because of the extra dimension. Compare &lt;code&gt;rowsum.nonzero()&lt;/code&gt; to understand this example.</source>
          <target state="translated">余分な次元のために、最後の要素は最初の要素のみを与えます。 &lt;code&gt;rowsum.nonzero()&lt;/code&gt; を比較して、この例を理解してください。</target>
        </trans-unit>
        <trans-unit id="d08df5e86170609b57051ef10f9fb3e1c3868c9f" translate="yes" xml:space="preserve">
          <source>The last thing that must be done to finish the extension module is to actually write the code that performs the desired functions. There are two kinds of functions: those that don&amp;rsquo;t accept keyword arguments, and those that do.</source>
          <target state="translated">拡張モジュールを終了するために最後に行う必要があるのは、目的の機能を実行するコードを実際に作成することです。関数には、キーワード引数を受け入れない関数と受け入れる関数の2種類があります。</target>
        </trans-unit>
        <trans-unit id="d5e8d86c6819b2227ff0ab7cafe1755645c6727d" translate="yes" xml:space="preserve">
          <source>The last two are characteristics of ndarrays - in order to support things like array slicing. The complications of subclassing ndarray are due to the mechanisms numpy has to support these latter two routes of instance creation.</source>
          <target state="translated">最後の2つはndarraysの特徴であり、配列のスライスのようなものをサポートするためです。ndarrayのサブクラス化が複雑になるのは、後者の2つのインスタンス生成ルートをサポートするためにnumpyが持っているメカニズムによるものです。</target>
        </trans-unit>
        <trans-unit id="2e8784c819189f431349d4282dd8265432f3285b" translate="yes" xml:space="preserve">
          <source>The latter group of &lt;code&gt;{NAME}s&lt;/code&gt; corresponds to letters used in the array interface typestring specification.</source>
          <target state="translated">後者の &lt;code&gt;{NAME}s&lt;/code&gt; グループは、配列インターフェイスのtypestring仕様で使用される文字に対応しています。</target>
        </trans-unit>
        <trans-unit id="34445ad4113f33f26d89f86d8eb17d5993aa2b33" translate="yes" xml:space="preserve">
          <source>The leftmost and rightmost edges of the bins along each dimension (if not specified explicitly in the &lt;code&gt;bins&lt;/code&gt; parameters): &lt;code&gt;[[xmin, xmax], [ymin, ymax]]&lt;/code&gt;. All values outside of this range will be considered outliers and not tallied in the histogram.</source>
          <target state="translated">各次元に沿ったビンの左端と右端（ &lt;code&gt;bins&lt;/code&gt; パラメーターで明示的に指定されていない場合）： &lt;code&gt;[[xmin, xmax], [ymin, ymax]]&lt;/code&gt; 。この範囲外のすべての値は異常値と見なされ、ヒストグラムで集計されません。</target>
        </trans-unit>
        <trans-unit id="7a57cb0c41d71bfde5dfe132d9a4c3e502a05b10" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;condlist&lt;/code&gt; must correspond to that of &lt;code&gt;funclist&lt;/code&gt;. If one extra function is given, i.e. if &lt;code&gt;len(funclist) == len(condlist) + 1&lt;/code&gt;, then that extra function is the default value, used wherever all conditions are false.</source>
          <target state="translated">&lt;code&gt;condlist&lt;/code&gt; の長さは、funclistの長さに対応している必要があり &lt;code&gt;funclist&lt;/code&gt; 。1つの追加関数が指定されている場合、つまり &lt;code&gt;len(funclist) == len(condlist) + 1&lt;/code&gt; 場合、その追加関数はデフォルト値であり、すべての条件がfalseの場合に使用されます。</target>
        </trans-unit>
        <trans-unit id="fda9f4dafa3b1f4f0bc8667197c7c2f74ba12e70" translate="yes" xml:space="preserve">
          <source>The length of docstring lines should be kept to 75 characters to facilitate reading the docstrings in text terminals.</source>
          <target state="translated">ドクロ文字列の行数は、テキスト端末でドクロ文字列を読みやすくするために、75文字以内に抑える必要があります。</target>
        </trans-unit>
        <trans-unit id="74e1dfe5bb68b99490ab8db3a4549a897ab92285" translate="yes" xml:space="preserve">
          <source>The length of the list of integers. It is assumed safe to access &lt;em&gt;ptr&lt;/em&gt; [0] to &lt;em&gt;ptr&lt;/em&gt; [len-1].</source>
          <target state="translated">整数のリストの長さ。&lt;em&gt;ptr&lt;/em&gt; [0]から&lt;em&gt;ptr&lt;/em&gt; [len-1] にアクセスしても安全であると想定されています。</target>
        </trans-unit>
        <trans-unit id="c7170d6904bad30d46bd752038c157844edf21e6" translate="yes" xml:space="preserve">
          <source>The length of the prefix and suffix strings are used to respectively align and wrap the output. An array is typically printed as:</source>
          <target state="translated">接頭辞と接尾辞の文字列の長さは、それぞれ出力の位置合わせと折り返しに使われます。配列は通常次のように出力されます。</target>
        </trans-unit>
        <trans-unit id="2a29e90467961f11261cb34c5ec7868485d4aa81" translate="yes" xml:space="preserve">
          <source>The length of the resulting strings</source>
          <target state="translated">結果として得られる文字列の長さ</target>
        </trans-unit>
        <trans-unit id="bd80f84b161ca3d681912061b09ff3df6041ed39" translate="yes" xml:space="preserve">
          <source>The length of the returned string if &lt;code&gt;num&lt;/code&gt; is positive, or the length of the two&amp;rsquo;s complement if &lt;code&gt;num&lt;/code&gt; is negative, provided that &lt;code&gt;width&lt;/code&gt; is at least a sufficient number of bits for &lt;code&gt;num&lt;/code&gt; to be represented in the designated form.</source>
          <target state="translated">&lt;code&gt;num&lt;/code&gt; が正の場合は返される文字列の長さ、または &lt;code&gt;num&lt;/code&gt; が負の場合は2の補数の長さ。ただし、 &lt;code&gt;width&lt;/code&gt; が、指定された形式で &lt;code&gt;num&lt;/code&gt; を表すのに十分なビット数である場合。</target>
        </trans-unit>
        <trans-unit id="63e0949a7b519952c49eb749b0448baf6c2dcdf9" translate="yes" xml:space="preserve">
          <source>The length of the segment in bytes.</source>
          <target state="translated">セグメントの長さをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="b0af5a70b649c99b0be522e1c0ad6114744383d4" translate="yes" xml:space="preserve">
          <source>The length of the span is the range of a 64-bit integer times the length of the date or unit. For example, the time span for &amp;lsquo;W&amp;rsquo; (week) is exactly 7 times longer than the time span for &amp;lsquo;D&amp;rsquo; (day), and the time span for &amp;lsquo;D&amp;rsquo; (day) is exactly 24 times longer than the time span for &amp;lsquo;h&amp;rsquo; (hour).</source>
          <target state="translated">スパンの長さは、64ビット整数に日付または単位の長さを掛けた範囲です。たとえば、「W」（週）の期間は「D」（日）の期間よりも正確に7倍長く、「D」（日）の期間は期間よりも正確に24倍長くなります。 「h」（時間）。</target>
        </trans-unit>
        <trans-unit id="c92e142a9e3623399b64df009d94b4d034da17ea" translate="yes" xml:space="preserve">
          <source>The line above represents z**3 + 0*z**2 + 0*z + 0.</source>
          <target state="translated">上の線は、z**3+0*z**2+0*z+0を表しています。</target>
        </trans-unit>
        <trans-unit id="b578e5e67f3e586204e4994bbe5c88c656a6cae7" translate="yes" xml:space="preserve">
          <source>The line above represents z**3 - z/4</source>
          <target state="translated">上の線は z**3-z/4 を表しています。</target>
        </trans-unit>
        <trans-unit id="cb5275e91dcecc0c6dc816bc9710e92658bd3377" translate="yes" xml:space="preserve">
          <source>The linear map &lt;code&gt;offset + scale*x&lt;/code&gt; that maps the domain &lt;code&gt;old&lt;/code&gt; to the domain &lt;code&gt;new&lt;/code&gt; is applied to the points &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">ドメイン &lt;code&gt;old&lt;/code&gt; をドメイン &lt;code&gt;new&lt;/code&gt; にマップ &lt;code&gt;offset + scale*x&lt;/code&gt; 線形マップオフセット+スケール* xは、ポイント &lt;code&gt;x&lt;/code&gt; に適用されます。</target>
        </trans-unit>
        <trans-unit id="2428c8d989723853883bd2c4d45c041f6e455adf" translate="yes" xml:space="preserve">
          <source>The list &lt;code&gt;x&lt;/code&gt; contains 4 items, each which can be accessed individually:</source>
          <target state="translated">リスト &lt;code&gt;x&lt;/code&gt; には4つのアイテムが含まれており、それぞれに個別にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="647499d1a98b89607edcd5f783a0adb1c730bbde" translate="yes" xml:space="preserve">
          <source>The list of arrays from which the output elements are taken. It has to be of the same length as &lt;code&gt;condlist&lt;/code&gt;.</source>
          <target state="translated">出力要素が取得される配列のリスト。 &lt;code&gt;condlist&lt;/code&gt; と同じ長さでなければなりません。</target>
        </trans-unit>
        <trans-unit id="529e159ac14f2e5a4bfd821c54e94a56730b5c46" translate="yes" xml:space="preserve">
          <source>The list of conditions which determine from which array in &lt;code&gt;choicelist&lt;/code&gt; the output elements are taken. When multiple conditions are satisfied, the first one encountered in &lt;code&gt;condlist&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;choicelist&lt;/code&gt; のどの配列から出力要素を取得するかを決定する条件のリスト。複数の条件が満たされた場合、 &lt;code&gt;condlist&lt;/code&gt; で最初に検出された条件が使用されます。</target>
        </trans-unit>
        <trans-unit id="a85b3c79db62cd35117edd96a90c46599648e8f3" translate="yes" xml:space="preserve">
          <source>The list of field names of a structured datatype can be found in the &lt;code&gt;names&lt;/code&gt; attribute of the dtype object:</source>
          <target state="translated">構造化データ型のフィールド名のリストは、dtypeオブジェクトの &lt;code&gt;names&lt;/code&gt; 属性にあります。</target>
        </trans-unit>
        <trans-unit id="92c329f0ce8c711e6636f92601cc50d421b9b226" translate="yes" xml:space="preserve">
          <source>The list of slices, one for each continuous region of masked elements in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">スライスのリストでマスクされた要素の各連続領域のための1つ。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="88a36ffbba49be32da3baf6bb43ea7e384cf3381" translate="yes" xml:space="preserve">
          <source>The list of slices, one for each continuous region of unmasked elements in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">スライスのリスト、でマスクされていない要素のそれぞれの連続した領域に1つ。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7251af1a3271825930cf9fcd1d817e4c55bd823" translate="yes" xml:space="preserve">
          <source>The list of sources may contain functions (&amp;lsquo;source generators&amp;rsquo;) with a pattern &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return
&amp;lt;source(s) or None&amp;gt;&lt;/code&gt;. If &lt;code&gt;funcname&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, no sources are generated. And if the &lt;code&gt;Extension&lt;/code&gt; instance has no sources after processing all source generators, no extension module will be built. This is the recommended way to conditionally define extension modules. Source generator functions are called by the &lt;code&gt;build_src&lt;/code&gt; command of &lt;code&gt;numpy.distutils&lt;/code&gt;.</source>
          <target state="translated">ソースのリストには、パターン &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return &amp;lt;source(s) or None&amp;gt;&lt;/code&gt; 持つ関数（「ソースジェネレーター」）が含まれる場合があります。 &lt;code&gt;funcname&lt;/code&gt; が &lt;code&gt;None&lt;/code&gt; を返す場合、ソースは生成されません。また、すべてのソースジェネレータを処理した後、 &lt;code&gt;Extension&lt;/code&gt; インスタンスにソースがない場合、拡張モジュールはビルドされません。これは、拡張モジュールを条件付きで定義するための推奨される方法です。ソースジェネレータ関数は、 &lt;code&gt;build_src&lt;/code&gt; コマンドによって &lt;code&gt;numpy.distutils&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="70ba9a25afcb1723906c4b12dfd6f0a126515e6c" translate="yes" xml:space="preserve">
          <source>The list of sources may contain functions (&amp;lsquo;source generators&amp;rsquo;) with a pattern &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return
&amp;lt;source(s) or None&amp;gt;&lt;/code&gt;. If &lt;code&gt;funcname&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, no sources are generated. And if the &lt;code&gt;Extension&lt;/code&gt; instance has no sources after processing all source generators, no extension module will be built. This is the recommended way to conditionally define extension modules. Source generator functions are called by the &lt;code&gt;build_src&lt;/code&gt; sub-command of &lt;code&gt;numpy.distutils&lt;/code&gt;.</source>
          <target state="translated">ソースのリストには、パターン &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return &amp;lt;source(s) or None&amp;gt;&lt;/code&gt; 関数（「ソースジェネレーター」）が含まれる場合があります：return &amp;lt;source（s）orNone&amp;gt;。 &lt;code&gt;funcname&lt;/code&gt; が &lt;code&gt;None&lt;/code&gt; を返す場合、ソースは生成されません。また、すべてのソースジェネレータを処理した後、 &lt;code&gt;Extension&lt;/code&gt; インスタンスにソースがない場合、拡張モジュールは構築されません。これは、拡張モジュールを条件付きで定義するための推奨される方法です。ソースジェネレーター関数は、 &lt;code&gt;build_src&lt;/code&gt; サブコマンドによって &lt;code&gt;numpy.distutils&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="e86e6b1dfd4d026f3bb365ed0394b538f40e1c2c" translate="yes" xml:space="preserve">
          <source>The location of the mode of the distribution. Default is 0.</source>
          <target state="translated">ディストリビューションのモードの位置。デフォルトは0です。</target>
        </trans-unit>
        <trans-unit id="f922a603661ce7b289c8f2d5dd79d3f8d12f2d5b" translate="yes" xml:space="preserve">
          <source>The log series distribution is frequently used to represent species richness and occurrence, first proposed by Fisher, Corbet, and Williams in 1943 [2]. It may also be used to model the numbers of occupants seen in cars [3].</source>
          <target state="translated">対数系列分布は,種の豊富さと発生を表現するために頻繁に使用され,1943年にFisher,Corbet,and Williamsによって最初に提案された [2].また,車の中で見られる乗員の数をモデル化するのにも使われることがある [3].</target>
        </trans-unit>
        <trans-unit id="23451df0ca8ba5d5bfbdca9cf8c2255b108c68ac" translate="yes" xml:space="preserve">
          <source>The logarithm to the base 10 of &lt;code&gt;x&lt;/code&gt;, element-wise. NaNs are returned where x is negative. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">要素ごとの &lt;code&gt;x&lt;/code&gt; の 10を底とする対数。NaNは、xが負の場合に返されます。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="4d6739be6bf6c7545bc1a71d692001820b9d7cac" translate="yes" xml:space="preserve">
          <source>The logic behind those functions in more than two dimensions can be strange.</source>
          <target state="translated">二次元以上でのそれらの機能の背後にある論理は、奇妙なものになることがあります。</target>
        </trans-unit>
        <trans-unit id="b8615daefc462d9e38519ed036e0e283940da95b" translate="yes" xml:space="preserve">
          <source>The lower and upper range of the bins. If not provided, range is simply &lt;code&gt;(a.min(), a.max())&lt;/code&gt;. Values outside the range are ignored. The first element of the range must be less than or equal to the second. &lt;code&gt;range&lt;/code&gt; affects the automatic bin computation as well. While bin width is computed to be optimal based on the actual data within &lt;code&gt;range&lt;/code&gt;, the bin count will fill the entire range including portions containing no data.</source>
          <target state="translated">ビンの下限と上限。指定しない場合、範囲は単に &lt;code&gt;(a.min(), a.max())&lt;/code&gt; ます。範囲外の値は無視されます。範囲の最初の要素は、2番目の要素以下でなければなりません。 &lt;code&gt;range&lt;/code&gt; は自動ビン計算にも影響します。ビンの幅は、 &lt;code&gt;range&lt;/code&gt; 内の実際のデータに基づいて最適になるように計算されますが、ビンの数は、データを含まない部分を含む範囲全体を埋めます。</target>
        </trans-unit>
        <trans-unit id="6456e48a0250380ada9bfcdc5cd3014ca07e5eb0" translate="yes" xml:space="preserve">
          <source>The lower bound for the top 1% of the samples is :</source>
          <target state="translated">サンプルの上位1%の下限は.</target>
        </trans-unit>
        <trans-unit id="4e9276b72baca62196e481978e6fcfbd0f0274c3" translate="yes" xml:space="preserve">
          <source>The lower bound of the definite integral.</source>
          <target state="translated">定積分の下界。</target>
        </trans-unit>
        <trans-unit id="37caf12cbe44bfdef1d91bca2e93d01e775cf201" translate="yes" xml:space="preserve">
          <source>The lower bound of the integral. (Default: 0)</source>
          <target state="translated">積分の下界。(デフォルト:0)</target>
        </trans-unit>
        <trans-unit id="a76f1d77a96a5b462f5fae8acc24fa2aae62620a" translate="yes" xml:space="preserve">
          <source>The lowest common multiple</source>
          <target state="translated">最低公倍数</target>
        </trans-unit>
        <trans-unit id="87d6bfa25ac3b02d4e51aa1f4135cd735f016c13" translate="yes" xml:space="preserve">
          <source>The lowest common multiple of the absolute value of the inputs This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">入力の絶対値の最小公倍数 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="6767713cd6108661a0803484e7289fe42459ebb5" translate="yes" xml:space="preserve">
          <source>The main feature of the &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module is the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; class, which is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;. The class, its attributes and methods are described in more details in the &lt;a href=&quot;maskedarray.baseclass#maskedarray-baseclass&quot;&gt;MaskedArray class&lt;/a&gt; section.</source>
          <target state="translated">主な特徴&lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; の&lt;/a&gt;モジュールである&lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; 用&lt;/a&gt;のサブクラスであるクラス、&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt;。クラス、その属性、およびメソッドについては、&lt;a href=&quot;maskedarray.baseclass#maskedarray-baseclass&quot;&gt;MaskedArrayクラス&lt;/a&gt;セクションで詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="52a36a5301780b2d55c316deba861004a7e6a2e2" translate="yes" xml:space="preserve">
          <source>The main page for the &lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;NumPy Documentation&lt;/a&gt; lists several categories. The documents mentioned there live in different places.</source>
          <target state="translated">&lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;NumPyドキュメント&lt;/a&gt;のメインページには、いくつかのカテゴリがリストされています。そこで言及されている文書はさまざまな場所にあります。</target>
        </trans-unit>
        <trans-unit id="48a467f7e54add76d93e3f038ba1d5a3c08c31d6" translate="yes" xml:space="preserve">
          <source>The main routine for obtaining an array from any Python object that can be converted to an array is &lt;a href=&quot;../reference/c-api/array#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt;. This function is very flexible with many input arguments. Several macros make it easier to use the basic function. &lt;a href=&quot;../reference/c-api/array#c.PyArray_FROM_OTF&quot;&gt;&lt;code&gt;PyArray_FROM_OTF&lt;/code&gt;&lt;/a&gt; is arguably the most useful of these macros for the most common uses. It allows you to convert an arbitrary Python object to an array of a specific builtin data-type ( &lt;em&gt;e.g.&lt;/em&gt; float), while specifying a particular set of requirements ( &lt;em&gt;e.g.&lt;/em&gt; contiguous, aligned, and writeable). The syntax is</source>
          <target state="translated">配列に変換できるPythonオブジェクトから配列を取得するためのメインルーチンは、&lt;a href=&quot;../reference/c-api/array#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;です。この関数は非常に柔軟性があり、多くの入力引数があります。いくつかのマクロを使用すると、基本的な機能を簡単に使用できます。&lt;a href=&quot;../reference/c-api/array#c.PyArray_FROM_OTF&quot;&gt; &lt;code&gt;PyArray_FROM_OTF&lt;/code&gt; &lt;/a&gt;は、間違いなく、最も一般的な用途でこれらのマクロの中で最も有用です。それは、データ型（組み込み特定の配列に任意のPythonオブジェクトを変換することができ&lt;em&gt;、例えば&lt;/em&gt;（必要条件の特定の組を指定して、フロート）&lt;em&gt;例えば&lt;/em&gt;連続、整列、および書き込み可能）。構文は</target>
        </trans-unit>
        <trans-unit id="9a6437cd8dced244085d75f5d4ec1f2af95ca5d9" translate="yes" xml:space="preserve">
          <source>The main way to control how the sequences of strings we have read from the file are converted to other types is to set the &lt;code&gt;dtype&lt;/code&gt; argument. Acceptable values for this argument are:</source>
          <target state="translated">ファイルから読み取った文字列のシーケンスを他のタイプに変換する方法を制御する主な方法は、 &lt;code&gt;dtype&lt;/code&gt; 引数を設定することです。この引数の許容値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="b863f0a577a40cd3794882f4e85002ecea6308b0" translate="yes" xml:space="preserve">
          <source>The mantissas &lt;code&gt;x1&lt;/code&gt; and twos exponents &lt;code&gt;x2&lt;/code&gt; are used to construct floating point numbers &lt;code&gt;x1 * 2**x2&lt;/code&gt;.</source>
          <target state="translated">仮数 &lt;code&gt;x1&lt;/code&gt; と2の指数 &lt;code&gt;x2&lt;/code&gt; は、浮動小数点数 &lt;code&gt;x1 * 2**x2&lt;/code&gt; を構成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="1288609b08eeb3cc92c01ebf371043c8f0d81962" translate="yes" xml:space="preserve">
          <source>The map &lt;code&gt;L(x) = offset + scale*x&lt;/code&gt; maps the first domain to the second.</source>
          <target state="translated">マップ &lt;code&gt;L(x) = offset + scale*x&lt;/code&gt; は、最初のドメインを2番目のドメインにマップします。</target>
        </trans-unit>
        <trans-unit id="fd5781bc4f89018e0fb9cd14ef3f3c125e3d74bb" translate="yes" xml:space="preserve">
          <source>The mapping function is defined by &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">マッピング関数は、 &lt;code&gt;off + scl*x&lt;/code&gt; 定義されます。</target>
        </trans-unit>
        <trans-unit id="f0d7698b06a0aedcc32f911c787189d531c3eac9" translate="yes" xml:space="preserve">
          <source>The mask is lost if &lt;code&gt;out&lt;/code&gt; is not a valid &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; !</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; が有効な&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; で&lt;/a&gt;はない場合、マスクは失われます。</target>
        </trans-unit>
        <trans-unit id="649d4874d06fb274533beb59f5f2cd10f5dc2b95" translate="yes" xml:space="preserve">
          <source>The mask is lost if &lt;code&gt;out&lt;/code&gt; is not a valid MaskedArray !</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; が有効なMaskedArrayではない場合、マスクは失われます。</target>
        </trans-unit>
        <trans-unit id="f9bf54dc7bd5e650858bf619f77da75fc06bf1f6" translate="yes" xml:space="preserve">
          <source>The mask of a masked array is accessible through its &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.mask&quot;&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/a&gt; attribute. We must keep in mind that a &lt;code&gt;True&lt;/code&gt; entry in the mask indicates an &lt;em&gt;invalid&lt;/em&gt; data.</source>
          <target state="translated">マスクされた配列のマスクには、その&lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.mask&quot;&gt; &lt;code&gt;mask&lt;/code&gt; &lt;/a&gt;属性を通じてアクセスできます。マスクの &lt;code&gt;True&lt;/code&gt; エントリは&lt;em&gt;無効な&lt;/em&gt;データを示していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5f7d748f7e23f2629a7257e1d7501357c2ce872d" translate="yes" xml:space="preserve">
          <source>The mask of a masked array view is also a view rather than a copy</source>
          <target state="translated">マスクされた配列ビューのマスクは、コピーではなくビューでもあります。</target>
        </trans-unit>
        <trans-unit id="136b0641a8efd21e297d96cb868071b555117d7d" translate="yes" xml:space="preserve">
          <source>The masked arrays for which to compare fill values.</source>
          <target state="translated">塗りつぶし値を比較するためのマスクされた配列。</target>
        </trans-unit>
        <trans-unit id="6a7c669e8d49f546a924fb9ea3a27606961c98f7" translate="yes" xml:space="preserve">
          <source>The matmul function implements the semantics of the &lt;code&gt;@&lt;/code&gt; operator introduced in Python 3.5 following PEP465.</source>
          <target state="translated">関数matmulは、PEP465に続いてPython 3.5で導入された &lt;code&gt;@&lt;/code&gt; 演算子のセマンティクスを実装します。</target>
        </trans-unit>
        <trans-unit id="b0018603311d83d5ccf5c07dff4523d1ca410b48" translate="yes" xml:space="preserve">
          <source>The matrix class is a Python subclass of the ndarray and can be used as a reference for how to construct your own subclass of the ndarray. Matrices can be created from other matrices, strings, and anything else that can be converted to an &lt;code&gt;ndarray&lt;/code&gt; . The name &amp;ldquo;mat &amp;ldquo;is an alias for &amp;ldquo;matrix &amp;ldquo;in NumPy.</source>
          <target state="translated">行列クラスはndarrayのPythonサブクラスであり、ndarrayの独自のサブクラスを作成する方法のリファレンスとして使用できます。行列は、他の行列、文字列、および &lt;code&gt;ndarray&lt;/code&gt; に変換できるその他のものから作成できます。名前「mat」は、NumPyの「matrix」のエイリアスです。</target>
        </trans-unit>
        <trans-unit id="5f8d7cfa51bd7c57bbf7e03577a1825ff994845e" translate="yes" xml:space="preserve">
          <source>The matrix of random values with shape given by &lt;code&gt;*args&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*args&lt;/code&gt; によって与えられる形状を持つランダム値の行列。</target>
        </trans-unit>
        <trans-unit id="608aa6eae8f7f68c13529cd8bd42452f015b4b90" translate="yes" xml:space="preserve">
          <source>The matrix product of the inputs. This is a scalar only when both x1, x2 are 1-d vectors.</source>
          <target state="translated">入力の行列積。これは x1,x2 が共に 1-d ベクトルの場合のみスカラーである。</target>
        </trans-unit>
        <trans-unit id="c658bc86aaba588a6a002ba9982fdea6c89bc9cc" translate="yes" xml:space="preserve">
          <source>The matrix whose condition number is sought.</source>
          <target state="translated">条件番号が求められる行列.</target>
        </trans-unit>
        <trans-unit id="c8c3ef8c7c85bd35de6e1deb7b50a36e856e51b4" translate="yes" xml:space="preserve">
          <source>The matrix, but as a (1, N) matrix if it had shape (N, 1).</source>
          <target state="translated">行列であるが、形状(N,1)を有する場合には(1,N)行列として</target>
        </trans-unit>
        <trans-unit id="d2f91514f11b147277135520b0867d5d6ef7f638" translate="yes" xml:space="preserve">
          <source>The maximum is equivalent to &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are nans, but it is faster and does proper broadcasting.</source>
          <target state="translated">x1もx2もnanでない場合 &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; 最大値はnp.where（x1&amp;gt; = x2、x1、x2）と同等ですが、高速で適切なブロードキャストを行います。</target>
        </trans-unit>
        <trans-unit id="b9ec29a01437d2db772a9e55518ff6e61467f369" translate="yes" xml:space="preserve">
          <source>The maximum number of array arguments that can be used in functions.</source>
          <target state="translated">関数で使用できる配列引数の最大数。</target>
        </trans-unit>
        <trans-unit id="d4b71803b063354491818e9ff7d7f91cb1c1ba7e" translate="yes" xml:space="preserve">
          <source>The maximum number of dimensions allowed in arrays.</source>
          <target state="translated">配列で許可される次元の最大数。</target>
        </trans-unit>
        <trans-unit id="aff70196c900f17cb2833a4c90eb4869b491b830" translate="yes" xml:space="preserve">
          <source>The maximum number of rows to read. Must not be used with skip_footer at the same time. If given, the value must be at least 1. Default is to read the entire file.</source>
          <target state="translated">読み込み可能な最大行数。skip_footerと同時に使用してはいけません。指定した場合、値は少なくとも1でなければなりません。 デフォルトはファイル全体を読み込むことになっています。</target>
        </trans-unit>
        <trans-unit id="bd4584d425d2919fbb0f9bcabce0ec35c9487dde" translate="yes" xml:space="preserve">
          <source>The maximum number of unit in the last place for tolerance (see Notes). Default is 1.</source>
          <target state="translated">許容範囲の最後の位置にある最大単位数(注意事項を参照)。デフォルトは1です。</target>
        </trans-unit>
        <trans-unit id="3cded325e7f85dbd01c8e732779ef69a0c4dfb37" translate="yes" xml:space="preserve">
          <source>The maximum number of units in the last place that elements of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; can differ. Default is 1.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; の要素が異なる可能性がある最後の場所の最大ユニット数。デフォルトは1です。</target>
        </trans-unit>
        <trans-unit id="4d9efaa03fd6ffe081e389f0039d71a839a20c3f" translate="yes" xml:space="preserve">
          <source>The maximum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">要素ごとの &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の最大値。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="0b24f05221f4af03e40635809a9e83b6c24ab35f" translate="yes" xml:space="preserve">
          <source>The maximum value along a given axis.</source>
          <target state="translated">与えられた軸に沿った最大値。</target>
        </trans-unit>
        <trans-unit id="fda69f03e934be306357e5eceaea53c34ff9559a" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, ignores NaNs.</source>
          <target state="translated">指定された軸に沿った配列の最大値で、NaNは無視されます。</target>
        </trans-unit>
        <trans-unit id="7815283b9ba6a866678fcbb140334dc5a033015a" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, ignoring any NaNs.</source>
          <target state="translated">任意のNaNを無視した、指定された軸に沿った配列の最大値。</target>
        </trans-unit>
        <trans-unit id="d4de50ed13c4c863bfa3e8deacb7e5bde93f23df" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, propagates NaNs.</source>
          <target state="translated">与えられた軸に沿った配列の最大値は、NaNを伝播する。</target>
        </trans-unit>
        <trans-unit id="7ea2e2a635f47e2f3d7b25aa79029eb57056d0e6" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, propagating any NaNs.</source>
          <target state="translated">任意のNaNを伝搬する、与えられた軸に沿った配列の最大値。</target>
        </trans-unit>
        <trans-unit id="1062669c35965744b7646a80587bb754273c0111" translate="yes" xml:space="preserve">
          <source>The maximum value of an output element. Must be present to allow computation on empty slice. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">出力要素の最大値。空のスライスでの計算を可能にするために存在する必要があります。詳細については、&lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4217fb4da5a1a61065cf374f0d2db5e29f625661" translate="yes" xml:space="preserve">
          <source>The mean is a coordinate in N-dimensional space, which represents the location where samples are most likely to be generated. This is analogous to the peak of the bell curve for the one-dimensional or univariate normal distribution.</source>
          <target state="translated">平均はN次元空間における座標であり、サンプルが最も発生しやすい位置を表しています。これは、一次元または一変量正規分布のベル曲線のピークに類似している。</target>
        </trans-unit>
        <trans-unit id="3afbef537c228c554c040f21270cfff32d76c2bc" translate="yes" xml:space="preserve">
          <source>The mean is normally calculated as &lt;code&gt;x.sum() / N&lt;/code&gt;, where &lt;code&gt;N = len(x)&lt;/code&gt;. If, however, &lt;code&gt;ddof&lt;/code&gt; is specified, the divisor &lt;code&gt;N - ddof&lt;/code&gt; is used instead. In standard statistical practice, &lt;code&gt;ddof=1&lt;/code&gt; provides an unbiased estimator of the variance of a hypothetical infinite population. &lt;code&gt;ddof=0&lt;/code&gt; provides a maximum likelihood estimate of the variance for normally distributed variables.</source>
          <target state="translated">通常、平均は &lt;code&gt;x.sum() / N&lt;/code&gt; として計算されます。ここで、 &lt;code&gt;N = len(x)&lt;/code&gt; です。ただし、 &lt;code&gt;ddof&lt;/code&gt; が指定されている場合は、除数 &lt;code&gt;N - ddof&lt;/code&gt; が代わりに使用されます。標準的な統計手法では、 &lt;code&gt;ddof=1&lt;/code&gt; は、仮想の無限母集団の分散の不偏推定量を提供します。 &lt;code&gt;ddof=0&lt;/code&gt; は、正規分布変数の分散の最尤推定を提供します。</target>
        </trans-unit>
        <trans-unit id="6de47f27b421a49095ff1b82a99c964834e4c682" translate="yes" xml:space="preserve">
          <source>The mechanism we use to accomplish this goal may be unfamiliar for those who are not experienced with the cultural norms around free/open-source software development. We provide a summary here, and highly recommend that all Contributors additionally read &lt;a href=&quot;http://producingoss.com/en/producingoss.html#social-infrastructure&quot;&gt;Chapter 4: Social and Political Infrastructure&lt;/a&gt; of Karl Fogel&amp;rsquo;s classic &lt;em&gt;Producing Open Source Software&lt;/em&gt;, and in particular the section on &lt;a href=&quot;http://producingoss.com/en/producingoss.html#consensus-democracy&quot;&gt;Consensus-based Democracy&lt;/a&gt;, for a more detailed discussion.</source>
          <target state="translated">この目標を達成するために私たちが使用するメカニズムは、フリー/オープンソースソフトウェア開発に関する文化的規範に精通していない人にはなじみがないかもしれません。ここに要約を示します。詳細については、すべての寄稿者が&lt;a href=&quot;http://producingoss.com/en/producingoss.html#social-infrastructure&quot;&gt;第4章：&lt;/a&gt;カールフォーゲルの古典的な&lt;em&gt;オープンソースソフトウェア&lt;/em&gt;の作成の社会的および政治的インフラストラクチャ、特に&lt;a href=&quot;http://producingoss.com/en/producingoss.html#consensus-democracy&quot;&gt;コンセンサスベースの民主主義&lt;/a&gt;に関するセクションをさらに読むことを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="530a7cbb36983f7e2dde0f52c1c905d90e12e910" translate="yes" xml:space="preserve">
          <source>The mediator will engage with all the parties and seek a resolution that is satisfactory to all. Upon completion, the mediator will provide a report (vetted by all parties to the process) to the Committee, with recommendations on further steps. The Committee will then evaluate these results (whether satisfactory resolution was achieved or not) and decide on any additional action deemed necessary.</source>
          <target state="translated">調停者は、すべての当事者と関わり、すべての当事者が満足できる解決策を模索します。完了した後、調停者は、更なるステップの勧告を含む報告書(プロセスのすべての当事者によって検証された)を委員会に提供します。委員会は、その後、これらの結果(満足のいく解決が達成されたかどうか)を評価し、必要と考えられる追加のアクションを決定します。</target>
        </trans-unit>
        <trans-unit id="476855af021420263dd600a85590e6b055b087d3" translate="yes" xml:space="preserve">
          <source>The members are</source>
          <target state="translated">メンバーは</target>
        </trans-unit>
        <trans-unit id="f25c150719f0aed3ef8299c88981d255d24f240e" translate="yes" xml:space="preserve">
          <source>The members of this structure are</source>
          <target state="translated">この構造のメンバーは</target>
        </trans-unit>
        <trans-unit id="a80fc0f190e501871954ac9917a55a8bb93998fb" translate="yes" xml:space="preserve">
          <source>The memmap object can be used anywhere an ndarray is accepted. Given a memmap &lt;code&gt;fp&lt;/code&gt;, &lt;code&gt;isinstance(fp, numpy.ndarray)&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">memmapオブジェクトは、ndarrayが受け入れられる場所ならどこでも使用できます。memmap &lt;code&gt;fp&lt;/code&gt; を指定すると、 &lt;code&gt;isinstance(fp, numpy.ndarray)&lt;/code&gt; は &lt;code&gt;True&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="afefc9cb88d75583ea623e16ea1f8cf60770f93a" translate="yes" xml:space="preserve">
          <source>The memory layout of an advanced indexing result is optimized for each indexing operation and no particular memory order can be assumed.</source>
          <target state="translated">高度なインデキシング結果のメモリレイアウトは、インデキシング操作ごとに最適化されており、特定のメモリ順序を想定することはできません。</target>
        </trans-unit>
        <trans-unit id="76384eb2a7d5d22bbc5978606ad7f8f1173b53b8" translate="yes" xml:space="preserve">
          <source>The memory layout of structured datatypes allows fields at arbitrary byte offsets. This means the fields can be separated by padding bytes, their offsets can be non-monotonically increasing, and they can overlap.</source>
          <target state="translated">構造化データ型のメモリレイアウトは、任意のバイトオフセットでのフィールドを可能にします。これは、フィールドをパディングバイトで区切ることができ、そのオフセットは非単調に増加することができ、重なり合うことができることを意味します。</target>
        </trans-unit>
        <trans-unit id="5905e557d4f8798f2a63eb67ada3f5b47bd6cef3" translate="yes" xml:space="preserve">
          <source>The memory model for an ndarray admits arbitrary strides in each dimension to advance to the next element of the array. Often, however, you need to interface with code that expects a C-contiguous or a Fortran-contiguous memory layout. In addition, an ndarray can be misaligned (the address of an element is not at an integral multiple of the size of the element) which can cause your program to crash (or at least work more slowly) if you try and dereference a pointer into the array data. Both of these problems can be solved by converting the Python object into an array that is more &amp;ldquo;well-behaved&amp;rdquo; for your specific usage.</source>
          <target state="translated">ndarrayのメモリモデルは、配列の次の要素に進むために、各次元で任意のストライドを許可します。ただし、多くの場合、C連続またはFortran連続のメモリレイアウトを期待するコードとインターフェイスする必要があります。さらに、ndarrayがずれている可能性があり（要素のアドレスが要素のサイズの整数倍ではない）、ポインタを逆参照しようとすると、プログラムがクラッシュする（または少なくとも動作が遅くなる）可能性があります。配列データ。これらの問題は両方とも、Pythonオブジェクトを特定の使用法に対してより「適切に動作する」配列に変換することで解決できます。</target>
        </trans-unit>
        <trans-unit id="aca17bd9cdf5246e194be60887f21d5d2d2f6e20" translate="yes" xml:space="preserve">
          <source>The merged result.</source>
          <target state="translated">結合された結果です。</target>
        </trans-unit>
        <trans-unit id="7df7fe557cb7d0b2f7c1ec9ba89a3700046e049a" translate="yes" xml:space="preserve">
          <source>The method should return either the result of the operation, or &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; if the operation requested is not implemented.</source>
          <target state="translated">メソッドは操作の結果を返すか、要求された操作が実装されていない場合は&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; を返す&lt;/a&gt;必要があります。</target>
        </trans-unit>
        <trans-unit id="a4edd76a8cc0cb5a2a3b89a3543cae8f78bd75ba" translate="yes" xml:space="preserve">
          <source>The method uses the following property for computation: let</source>
          <target state="translated">このメソッドは、次のプロパティを計算に使用します。</target>
        </trans-unit>
        <trans-unit id="ad0d254fa1824d11c17af544fbf486dd80c358ac" translate="yes" xml:space="preserve">
          <source>The methods to estimate the optimal number of bins are well founded in literature, and are inspired by the choices R provides for histogram visualisation. Note that having the number of bins proportional to</source>
          <target state="translated">最適なビンの数を推定する方法は、文献でもよく知られており、Rがヒストグラムの可視化のために提供する選択肢に触発されています。に比例するビンの数を持つことに注意してください。</target>
        </trans-unit>
        <trans-unit id="3d7963e1ce4d80720f0895da566be576ac9149e1" translate="yes" xml:space="preserve">
          <source>The minimal data type.</source>
          <target state="translated">最小限のデータ型です。</target>
        </trans-unit>
        <trans-unit id="24db4b82ce9f82692c92a9ac46d90c6b64d6bb97" translate="yes" xml:space="preserve">
          <source>The minimum is equivalent to &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</source>
          <target state="translated">x1もx2もNaNでない場合 &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; 最小値はnp.where（x1 &amp;lt;= x2、x1、x2）と同等ですが、高速で適切なブロードキャストを行います。</target>
        </trans-unit>
        <trans-unit id="830a82f2ffde76e612c1dc506f1272bc14c9b4a2" translate="yes" xml:space="preserve">
          <source>The minimum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">要素ごとの &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の最小値。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="f7a8e12ffb3a7b028e99ec9cbaae32de38a438d0" translate="yes" xml:space="preserve">
          <source>The minimum representable value.</source>
          <target state="translated">表現可能な最小値。</target>
        </trans-unit>
        <trans-unit id="78d2dd7cf3cdcedef397cc8cfe35854b295317af" translate="yes" xml:space="preserve">
          <source>The minimum value along a given axis.</source>
          <target state="translated">与えられた軸に沿った最小値。</target>
        </trans-unit>
        <trans-unit id="7e0b0cb52a1bf19ef3e6bff0be136a12d77ae7e7" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, ignores NaNs.</source>
          <target state="translated">指定された軸に沿った配列の最小値で、NaNを無視します。</target>
        </trans-unit>
        <trans-unit id="d9e2b0a11e46ec4c3892cf8fdab488270aa4c95b" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, ignoring any NaNs.</source>
          <target state="translated">任意のNaNを無視した、指定された軸に沿った配列の最小値。</target>
        </trans-unit>
        <trans-unit id="77d53ae61484ff6af896adddf96d0d76b8331b4b" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, propagates NaNs.</source>
          <target state="translated">与えられた軸に沿った配列の最小値は、NaNを伝播する。</target>
        </trans-unit>
        <trans-unit id="f3f970ad0b31d892cafa6b5a21e637a9f0353aee" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, propagating any NaNs.</source>
          <target state="translated">任意のNaNを伝播する、与えられた軸に沿った配列の最小値。</target>
        </trans-unit>
        <trans-unit id="9ae224843f4578886c03cad9e1377c9c95d0f44e" translate="yes" xml:space="preserve">
          <source>The minimum value of an output element. Must be present to allow computation on empty slice. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">出力要素の最小値。空のスライスでの計算を可能にするために存在する必要があります。詳細については、&lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d437e19520a89179e90a54d1512529a938dad3c6" translate="yes" xml:space="preserve">
          <source>The mode should be one of:</source>
          <target state="translated">のいずれかのモードであること。</target>
        </trans-unit>
        <trans-unit id="2ec84546189af066d8b391b45bfecb14d0737c14" translate="yes" xml:space="preserve">
          <source>The modified Bessel function evaluated at each of the elements of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の各要素で評価された修正ベッセル関数。</target>
        </trans-unit>
        <trans-unit id="852847496df2ea03e82e7e539f1768f78993a6b8" translate="yes" xml:space="preserve">
          <source>The more common 2-parameter Weibull, including a scale parameter</source>
          <target state="translated">スケールパラメータを含む、より一般的な2パラメータのワイブル</target>
        </trans-unit>
        <trans-unit id="ec8c35dc12f2bc0af45e628c14f8329c8c69aba9" translate="yes" xml:space="preserve">
          <source>The most basic task that can be done with the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; is to visit every element of an array. Each element is provided one by one using the standard Python iterator interface.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;で実行できる最も基本的なタスクは、配列のすべての要素にアクセスすることです。各要素は、標準のPythonイテレータインターフェースを使用して1つずつ提供されます。</target>
        </trans-unit>
        <trans-unit id="d496ee7436ae1753a08460be49874cd0a97104de" translate="yes" xml:space="preserve">
          <source>The most basic way to create datetimes is from strings in ISO 8601 date or datetime format. The unit for internal storage is automatically selected from the form of the string, and can be either a &lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;date unit&lt;/a&gt; or a &lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;time unit&lt;/a&gt;. The date units are years (&amp;lsquo;Y&amp;rsquo;), months (&amp;lsquo;M&amp;rsquo;), weeks (&amp;lsquo;W&amp;rsquo;), and days (&amp;lsquo;D&amp;rsquo;), while the time units are hours (&amp;lsquo;h&amp;rsquo;), minutes (&amp;lsquo;m&amp;rsquo;), seconds (&amp;lsquo;s&amp;rsquo;), milliseconds (&amp;lsquo;ms&amp;rsquo;), and some additional SI-prefix seconds-based units.</source>
          <target state="translated">日時を作成する最も基本的な方法は、ISO 8601の日付または日時形式の文字列から作成することです。内部ストレージの単位は、文字列の形式から自動的に選択され、&lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;日付単位&lt;/a&gt;または&lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;時間単位の&lt;/a&gt;いずれかになります。日付の単位は年（ 'Y'）、月（ 'M'）、週（ 'W'）、日（ 'D'）であり、時間の単位は時間（ 'h'）、分（ 'm' ）、秒（ 's'）、ミリ秒（ 'ms'）、および追加のSIプレフィックス秒ベースの単位。</target>
        </trans-unit>
        <trans-unit id="3f0f24060330e42125d74f607b6b6b61511b55b5" translate="yes" xml:space="preserve">
          <source>The most basic way to create datetimes is from strings in ISO 8601 date or datetime format. The unit for internal storage is automatically selected from the form of the string, and can be either a &lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;date unit&lt;/a&gt; or a &lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;time unit&lt;/a&gt;. The date units are years (&amp;lsquo;Y&amp;rsquo;), months (&amp;lsquo;M&amp;rsquo;), weeks (&amp;lsquo;W&amp;rsquo;), and days (&amp;lsquo;D&amp;rsquo;), while the time units are hours (&amp;lsquo;h&amp;rsquo;), minutes (&amp;lsquo;m&amp;rsquo;), seconds (&amp;lsquo;s&amp;rsquo;), milliseconds (&amp;lsquo;ms&amp;rsquo;), and some additional SI-prefix seconds-based units. The datetime64 data type also accepts the string &amp;ldquo;NAT&amp;rdquo;, in any combination of lowercase/uppercase letters, for a &amp;ldquo;Not A Time&amp;rdquo; value.</source>
          <target state="translated">日時を作成する最も基本的な方法は、ISO8601の日付または日時形式の文字列からです。内部ストレージの単位は、文字列の形式から自動的に選択され、&lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;日付単位&lt;/a&gt;または&lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;時間単位の&lt;/a&gt;いずれかになります。日付の単位は年（「Y」）、月（「M」）、週（「W」）、および日（「D」）であり、時間の単位は時間（「h」）、分（「m」）です。 ）、秒（ 's'）、ミリ秒（ 'ms'）、およびいくつかの追加のSIプレフィックス秒ベースの単位。datetime64データ型は、「Not A Time」値として、小文字/大文字の任意の組み合わせの文字列「NAT」も受け入れます。</target>
        </trans-unit>
        <trans-unit id="66cbaf133a9d7fa2f2885d6f3bc9c4d230706591" translate="yes" xml:space="preserve">
          <source>The most common use of this function is to build a block matrix</source>
          <target state="translated">この関数の最も一般的な使用法は、ブロック行列を構築することです。</target>
        </trans-unit>
        <trans-unit id="d15c9fb7581762b1e666994a9299d27d87d30396" translate="yes" xml:space="preserve">
          <source>The most natural way one can think of for boolean indexing is to use boolean arrays that have &lt;em&gt;the same shape&lt;/em&gt; as the original array:</source>
          <target state="translated">ブールインデックス付けについて考えることができる最も自然な方法は、元の配列&lt;em&gt;と同じ形状の&lt;/em&gt;ブール配列を使用することです。</target>
        </trans-unit>
        <trans-unit id="9781573736aca31c85fa33ce77a1caad972dd370" translate="yes" xml:space="preserve">
          <source>The most negative power of the base (2) consistent with there being no leading 0&amp;rsquo;s in the mantissa.</source>
          <target state="translated">仮数部に先行ゼロがないことと一致する、底の最も負の累乗（2）。</target>
        </trans-unit>
        <trans-unit id="fb15b7417ee56d15205cea48f990a823be057c87" translate="yes" xml:space="preserve">
          <source>The multidimensional histogram of sample x. See normed and weights for the different possible semantics.</source>
          <target state="translated">サンプル x の多次元ヒストグラム.</target>
        </trans-unit>
        <trans-unit id="8be5b73af053c4fe54ab6b95a4f36c70767b3576" translate="yes" xml:space="preserve">
          <source>The multinomial distribution is a multivariate generalization of the binomial distribution. Take an experiment with one of &lt;code&gt;p&lt;/code&gt; possible outcomes. An example of such an experiment is throwing a dice, where the outcome can be 1 through 6. Each sample drawn from the distribution represents &lt;code&gt;n&lt;/code&gt; such experiments. Its values, &lt;code&gt;X_i = [X_0, X_1, ..., X_p]&lt;/code&gt;, represent the number of times the outcome was &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">多項分布は、二項分布の多変量一般化です。 &lt;code&gt;p&lt;/code&gt; 可能な結果の1つを使って実験してください。そのような実験の例は、サイコロを投げることで、結果は1から6になります。分布から抽出された各サンプルは、そのような実験の &lt;code&gt;n&lt;/code&gt; を表します。その値 &lt;code&gt;X_i = [X_0, X_1, ..., X_p]&lt;/code&gt; は、結果が &lt;code&gt;i&lt;/code&gt; であった回数を表します。</target>
        </trans-unit>
        <trans-unit id="6e35df9de409e360898297beb49d42cda54d84d4" translate="yes" xml:space="preserve">
          <source>The multiplication uses the recursion relationship for Hermite polynomials in the form</source>
          <target state="translated">乗算は、エルミテ多項式の再帰関係を使用します。</target>
        </trans-unit>
        <trans-unit id="5d48b11de72371fe59540d3a1093cd7c7ef9026d" translate="yes" xml:space="preserve">
          <source>The multiplication uses the recursion relationship for Laguerre polynomials in the form</source>
          <target state="translated">乗算は、次の形式のラグエール多項式の再帰関係を使用します。</target>
        </trans-unit>
        <trans-unit id="1da9d21187f4507f9a0b400fa81210b7d7adb8cd" translate="yes" xml:space="preserve">
          <source>The multiplication uses the recursion relationship for Legendre polynomials in the form</source>
          <target state="translated">乗算は、レジェンドレ多項式の再帰関係を使用します。</target>
        </trans-unit>
        <trans-unit id="28fc83b7bf97d866e44dde49fafcb06224f49002" translate="yes" xml:space="preserve">
          <source>The multithreaded random number generator can be used to fill an array. The &lt;code&gt;values&lt;/code&gt; attributes shows the zero-value before the fill and the random value after.</source>
          <target state="translated">マルチスレッドの乱数ジェネレーターを使用して、配列を埋めることができます。 &lt;code&gt;values&lt;/code&gt; 塗りつぶしとした後、ランダムな値の前にゼロ値のショーを属性。</target>
        </trans-unit>
        <trans-unit id="b9bbb85b9ae78b76721288cfcfe9a4008f15e026" translate="yes" xml:space="preserve">
          <source>The multivariate hypergeometric distribution is a generalization of the hypergeometric distribution.</source>
          <target state="translated">多変量ハイパージオメトリック分布はハイパージオメトリック分布の一般化です。</target>
        </trans-unit>
        <trans-unit id="4747005456762b666a88180df9655da6422f2a03" translate="yes" xml:space="preserve">
          <source>The multivariate normal, multinormal or Gaussian distribution is a generalization of the one-dimensional normal distribution to higher dimensions. Such a distribution is specified by its mean and covariance matrix. These parameters are analogous to the mean (average or &amp;ldquo;center&amp;rdquo;) and variance (standard deviation, or &amp;ldquo;width,&amp;rdquo; squared) of the one-dimensional normal distribution.</source>
          <target state="translated">多変量正規分布、多正規分布、またはガウス分布は、1次元の正規分布をより高い次元に一般化したものです。そのような分布は、その平均および共分散行列によって指定されます。これらのパラメーターは、1次元正規分布の平均（平均または「中心」）および分散（標準偏差、または「幅」の2乗）に類似しています。</target>
        </trans-unit>
        <trans-unit id="a8b77cd2da64c5a2ad3fe22e334603fd46922d44" translate="yes" xml:space="preserve">
          <source>The mymethods must be an array (usually statically declared) of PyMethodDef structures which contain method names, actual C-functions, a variable indicating whether the method uses keyword arguments or not, and docstrings. These are explained in the next section. If you want to add constants to the module, then you store the returned value from Py_InitModule which is a module object. The most general way to add items to the module is to get the module dictionary using PyModule_GetDict(module). With the module dictionary, you can add whatever you like to the module manually. An easier way to add objects to the module is to use one of three additional Python C-API calls that do not require a separate extraction of the module dictionary. These are documented in the Python documentation, but repeated here for convenience:</source>
          <target state="translated">mymethodsは、メソッド名、実際のC関数、メソッドがキーワード引数を使うかどうかを示す変数、docstringを含むPyMethodDef構造体の配列(通常は静的に宣言されている)でなければなりません。これらについては次のセクションで説明します。定数をモジュールに追加したい場合は、モジュールオブジェクトである Py_InitModule からの戻り値を格納します。モジュールに項目を追加する最も一般的な方法は、PyModule_GetDict(module)を使ってモジュール辞書を取得することです。モジュール辞書があれば、好きなものを手動でモジュールに追加することができます。モジュールにオブジェクトを追加するより簡単な方法は、モジュール辞書の個別の抽出を必要としない 3 つの追加の Python C-API 呼び出しのうちの 1 つを使用することです。これらはPythonのドキュメントに記載されていますが、便宜上ここで繰り返します。</target>
        </trans-unit>
        <trans-unit id="acd94e258d3a5164d9494ffb8bffe2f44669511c" translate="yes" xml:space="preserve">
          <source>The n-dimensional FFT.</source>
          <target state="translated">n次元FFTです。</target>
        </trans-unit>
        <trans-unit id="6c60f6d35e1563484077efd2da3ec7438c9b55d8" translate="yes" xml:space="preserve">
          <source>The n-dimensional array</source>
          <target state="translated">n次元配列</target>
        </trans-unit>
        <trans-unit id="3b220f6b818351a33b819aef741ffc069011f1f9" translate="yes" xml:space="preserve">
          <source>The n-dimensional inverse FFT.</source>
          <target state="translated">n次元の逆FFT。</target>
        </trans-unit>
        <trans-unit id="e1700cb4660502cb99b1ba6b83abc787863343a8" translate="yes" xml:space="preserve">
          <source>The n-th differences. The shape of the output is the same as &lt;code&gt;a&lt;/code&gt; except along &lt;code&gt;axis&lt;/code&gt; where the dimension is smaller by &lt;code&gt;n&lt;/code&gt;. The type of the output is the same as the type of the difference between any two elements of &lt;code&gt;a&lt;/code&gt;. This is the same as the type of &lt;code&gt;a&lt;/code&gt; in most cases. A notable exception is &lt;code&gt;datetime64&lt;/code&gt;, which results in a &lt;code&gt;timedelta64&lt;/code&gt; output array.</source>
          <target state="translated">n番目の違い。出力の形状は、次元が &lt;code&gt;n&lt;/code&gt; だけ小さい &lt;code&gt;axis&lt;/code&gt; に沿って &lt;code&gt;a&lt;/code&gt; 以外は、と同じです。出力のタイプは、任意の2つの要素間の差のタイプと同じです。これは、ほとんどの場合、 &lt;code&gt;a&lt;/code&gt; のタイプと同じです。注目すべき例外は &lt;code&gt;datetime64&lt;/code&gt; で、これにより &lt;code&gt;timedelta64&lt;/code&gt; 出力配列が生成されます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bbebdf33e8d96895ad0ed5b9400d54086fef2b67" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;colors&lt;/code&gt; comes from a common description of the distribution: it is the probability distribution of the number of marbles of each color selected without replacement from an urn containing marbles of different colors; &lt;code&gt;colors[i]&lt;/code&gt; is the number of marbles in the urn with color &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;colors&lt;/code&gt; という名前は、分布の一般的な説明に由来します。これは、異なる色のビー玉を含む壷から交換せずに選択された各色のビー玉の数の確率分布です。 &lt;code&gt;colors[i]&lt;/code&gt; は、色 &lt;code&gt;i&lt;/code&gt; の壷内のビー玉の数です。</target>
        </trans-unit>
        <trans-unit id="0669ec99aeb2d5368091f67cb13b60ba81e67528" translate="yes" xml:space="preserve">
          <source>The name of an encoding</source>
          <target state="translated">エンコーディングの名前</target>
        </trans-unit>
        <trans-unit id="da19f645db8ba8aaf5c7216ec7214ec27975bb88" translate="yes" xml:space="preserve">
          <source>The name of each column, e.g. &lt;code&gt;('x', 'y', 'z')&lt;/code&gt;.</source>
          <target state="translated">各列の名前、たとえば &lt;code&gt;('x', 'y', 'z')&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2c5edd467b851569da4a2dda38a270ee36e54ad" translate="yes" xml:space="preserve">
          <source>The name of the compiled python module</source>
          <target state="translated">コンパイルされた python モジュールの名前</target>
        </trans-unit>
        <trans-unit id="a9271935a282dc40ee28d57c245df327643e67b9" translate="yes" xml:space="preserve">
          <source>The name of the function comes from the acronym for &amp;lsquo;peak to peak&amp;rsquo;.</source>
          <target state="translated">関数の名前は、「ピークツーピーク」の頭字語に由来します。</target>
        </trans-unit>
        <trans-unit id="d407bb92d1b152453450af784d89f7deb9d12336" translate="yes" xml:space="preserve">
          <source>The name of the function to be deprecated. Default is None, in which case the name of &lt;code&gt;func&lt;/code&gt; is used.</source>
          <target state="translated">非推奨になる関数の名前。デフォルトはNoneです。この場合、 &lt;code&gt;func&lt;/code&gt; の名前が使用されます。</target>
        </trans-unit>
        <trans-unit id="bb2cb1a8dd236bcfb532f7c48c470cce2101b1ff" translate="yes" xml:space="preserve">
          <source>The name of the polynomial variable</source>
          <target state="translated">多項式変数の名前</target>
        </trans-unit>
        <trans-unit id="48bd936a95b9da34fbbddac207b9c61cefe6e361" translate="yes" xml:space="preserve">
          <source>The name of the ufunc.</source>
          <target state="translated">ufuncの名前です。</target>
        </trans-unit>
        <trans-unit id="8afcf394e9ae5bb9fa899425c9a8ba31df0dd746" translate="yes" xml:space="preserve">
          <source>The name sinc is short for &amp;ldquo;sine cardinal&amp;rdquo; or &amp;ldquo;sinus cardinalis&amp;rdquo;.</source>
          <target state="translated">sincという名前は、「sin cardinal」または「sinus cardinalis」の略です。</target>
        </trans-unit>
        <trans-unit id="429822cfcff1010e8a45d7946ea2696aeb70a3d1" translate="yes" xml:space="preserve">
          <source>The names are ordered according to increasing byte offset. This can be used, for example, to walk through all of the named fields in offset order.</source>
          <target state="translated">名前は、バイトオフセットの増加に応じて順序付けられます。これは、例えば、名前のついたすべてのフィールドをオフセット順にウォークスルーするために使用することができます。</target>
        </trans-unit>
        <trans-unit id="d89404c184de8cb612b9ba60ba8159aea12d80ca" translate="yes" xml:space="preserve">
          <source>The names for the types in c code follows c naming conventions more closely. The Python names for these types follow Python conventions. Thus, &lt;a href=&quot;#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; picks up a 32-bit float in C, but &lt;code&gt;numpy.float_&lt;/code&gt; in Python corresponds to a 64-bit double. The bit-width names can be used in both Python and C for clarity.</source>
          <target state="translated">cコード内の型の名前は、cの命名規則に厳密に従います。これらのタイプのPython名はPythonの規則に従います。したがって、&lt;a href=&quot;#c.NPY_FLOAT&quot;&gt; &lt;code&gt;NPY_FLOAT&lt;/code&gt; &lt;/a&gt;はCで32ビットの浮動小数点を選択しますが、Pythonの &lt;code&gt;numpy.float_&lt;/code&gt; は64ビットの倍精度に対応します。ビット幅の名前は、わかりやすくするためにPythonとCの両方で使用できます。</target>
        </trans-unit>
        <trans-unit id="7042a6f0e554df217f55061c01efbcd355c420f8" translate="yes" xml:space="preserve">
          <source>The names of the fields are given with the &lt;code&gt;names&lt;/code&gt; arguments, the corresponding values with the &lt;code&gt;data&lt;/code&gt; arguments. If a single field is appended, &lt;code&gt;names&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;dtypes&lt;/code&gt; do not have to be lists but just values.</source>
          <target state="translated">フィールドの名前は &lt;code&gt;names&lt;/code&gt; 引数で指定され、対応する値は &lt;code&gt;data&lt;/code&gt; 引数で指定されます。単一のフィールドが追加されている場合、 &lt;code&gt;names&lt;/code&gt; 、 &lt;code&gt;data&lt;/code&gt; 、および &lt;code&gt;dtypes&lt;/code&gt; はリストである必要はなく、値のみである必要があります。</target>
        </trans-unit>
        <trans-unit id="be2b0c55353c6ed87f255a0400693d129089b164" translate="yes" xml:space="preserve">
          <source>The native NumPy indexing type is &lt;code&gt;intp&lt;/code&gt; and may differ from the default integer array type. &lt;code&gt;intp&lt;/code&gt; is the smallest data type sufficient to safely index any array; for advanced indexing it may be faster than other types.</source>
          <target state="translated">ネイティブのNumPyインデックスタイプは &lt;code&gt;intp&lt;/code&gt; であり、デフォルトの整数配列タイプとは異なる場合があります。 &lt;code&gt;intp&lt;/code&gt; は、配列に安全にインデックスを付けるのに十分な最小のデータ型です。高度なインデックスの場合、他のタイプよりも高速になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="762cb1cca826c6e2247cb37d4810072af245272b" translate="yes" xml:space="preserve">
          <source>The natural log of the absolute value of the determinant.</source>
          <target state="translated">行列式の絶対値の自然対数。</target>
        </trans-unit>
        <trans-unit id="b3888cd1c7265c4b4a7bad4003632b69982812b1" translate="yes" xml:space="preserve">
          <source>The natural logarithm &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; is the inverse of the exponential function, so that &lt;code&gt;log(exp(x)) = x&lt;/code&gt;. The natural logarithm is logarithm in base &lt;a href=&quot;../constants#numpy.e&quot;&gt;&lt;code&gt;e&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">自然対数の&lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt;、指数関数の逆数となるように &lt;code&gt;log(exp(x)) = x&lt;/code&gt; 。自然対数は&lt;a href=&quot;../constants#numpy.e&quot;&gt; &lt;code&gt;e&lt;/code&gt; を&lt;/a&gt;底とする対数です。</target>
        </trans-unit>
        <trans-unit id="133131ae7b63a1c0b2c215fb536c3aee797a1a49" translate="yes" xml:space="preserve">
          <source>The natural logarithm of &lt;code&gt;x&lt;/code&gt;, element-wise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">要素ごとの &lt;code&gt;x&lt;/code&gt; の自然対数。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="79018bd215ed2a4de07a7be8acb4bd00eb575cb1" translate="yes" xml:space="preserve">
          <source>The nditer can no longer be iterated once either &lt;code&gt;close&lt;/code&gt; is called or its context is exited.</source>
          <target state="translated">&lt;code&gt;close&lt;/code&gt; が呼び出されるか、そのコンテキストが終了すると、nditerは反復できなくなります。</target>
        </trans-unit>
        <trans-unit id="fba110cc07d7918f904cb2219cd75774f5e101fe" translate="yes" xml:space="preserve">
          <source>The nditer will then yield writeable buffer arrays which you may modify. However, because the nditer must copy this buffer data back to the original array once iteration is finished, you must signal when the iteration is ended, by one of two methods. You may either:</source>
          <target state="translated">nditerは、書き込み可能なバッファ配列を生成し、これを変更することができます。ただし、 nditer は、 イテレーションが終了するとバッファデータを元の配列に戻さなければならないので、 イテレーションが終了したときには次の 2 つの方法のいずれかで合図を送る必要があります。次のいずれかの方法をとることができます。</target>
        </trans-unit>
        <trans-unit id="36c9f1e0a0257851539d48df01a2ed2f053f22d7" translate="yes" xml:space="preserve">
          <source>The new array is formed from the data in the old array, repeated if necessary to fill out the required number of elements. The data are repeated in the order that they are stored in memory.</source>
          <target state="translated">新しい配列は、古い配列のデータから形成され、必要な要素数を埋めるために必要に応じて繰り返されます。データはメモリに格納されている順に繰り返されます。</target>
        </trans-unit>
        <trans-unit id="a04e3c53d25194cf3b0ad0e57f30edc1bdcf03db" translate="yes" xml:space="preserve">
          <source>The new array will have a new last dimension equal in size to the number of field-elements of the input array. If not supplied, the output datatype is determined from the numpy type promotion rules applied to all the field datatypes.</source>
          <target state="translated">新しい配列の最終次元は、入力配列のフィールド要素の数と同じサイズになります。指定されなかった場合、出力データ型は、すべてのフィールドデータ型に適用されるnumpy型推進規則から決定されます。</target>
        </trans-unit>
        <trans-unit id="f97568b5d149f57d8764f77c287f9f2fe46a132b" translate="yes" xml:space="preserve">
          <source>The new behavior as of Numpy 1.16 leads to extra &amp;ldquo;padding&amp;rdquo; bytes at the location of unindexed fields compared to 1.15. You will need to update any code which depends on the data having a &amp;ldquo;packed&amp;rdquo; layout. For instance code such as:</source>
          <target state="translated">Numpy 1.16の新しい動作により、1.15と比較して、インデックス付けされていないフィールドの場所に余分な「パディング」バイトが発生します。「パックされた」レイアウトのデータに依存するコードを更新する必要があります。たとえば、次のようなコード：</target>
        </trans-unit>
        <trans-unit id="1e027640aca67041dbf9c118ab74b0f73d41441e" translate="yes" xml:space="preserve">
          <source>The new infrastructure takes a different approach to producing random numbers from the &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; object. Random number generation is separated into two components, a bit generator and a random generator.</source>
          <target state="translated">新しいインフラストラクチャは、&lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;オブジェクトから乱数を生成するために異なるアプローチを採用しています。乱数の生成は、ビットジェネレーターとランダムジェネレーターの2つのコンポーネントに分けられます。</target>
        </trans-unit>
        <trans-unit id="5d98e8d2c80f824b8ece662a9850103c0477cac7" translate="yes" xml:space="preserve">
          <source>The new infrastructure takes a different approach to producing random numbers from the &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; object. Random number generation is separated into two components, a bit generator and a random generator.</source>
          <target state="translated">新しいインフラストラクチャは、&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;オブジェクトから乱数を生成するために別のアプローチを採用しています。乱数生成は、ビットジェネレーターとランダムジェネレーターの2つのコンポーネントに分かれています。</target>
        </trans-unit>
        <trans-unit id="125105242ec81f06cd25f403baeb3cf1e8d9cd77" translate="yes" xml:space="preserve">
          <source>The new interface has docstring:</source>
          <target state="translated">新しいインターフェイスにはdocstringがあります。</target>
        </trans-unit>
        <trans-unit id="86aae80fcd76b7ce0d8ebf83a57b3d06b3426d61" translate="yes" xml:space="preserve">
          <source>The new keyword argument interface and &lt;code&gt;excluded&lt;/code&gt; argument support further degrades performance.</source>
          <target state="translated">新しいキーワード引数インターフェイスと &lt;code&gt;excluded&lt;/code&gt; 引数のサポートにより、パフォーマンスがさらに低下します。</target>
        </trans-unit>
        <trans-unit id="d86ea97e67bbca694f01bcdba7b94c4f6336cda1" translate="yes" xml:space="preserve">
          <source>The new name for the function. Default is None, in which case the deprecation message is that &lt;code&gt;old_name&lt;/code&gt; is deprecated. If given, the deprecation message is that &lt;code&gt;old_name&lt;/code&gt; is deprecated and &lt;code&gt;new_name&lt;/code&gt; should be used instead.</source>
          <target state="translated">関数の新しい名前。デフォルトはNoneです。この場合、非推奨メッセージは &lt;code&gt;old_name&lt;/code&gt; が非推奨になることです。指定された場合、非推奨のメッセージは、 &lt;code&gt;old_name&lt;/code&gt; が非推奨になり、代わりに &lt;code&gt;new_name&lt;/code&gt; を使用する必要があることです。</target>
        </trans-unit>
        <trans-unit id="55a87f3b341973ae0ced92b1f1a3e3e7074aa9e8" translate="yes" xml:space="preserve">
          <source>The new shape should be compatible with the original shape. If an integer is supplied, then the result will be a 1-D array of that length.</source>
          <target state="translated">新しい形状は元の形状と互換性のあるものでなければなりません。整数が与えられた場合、結果はその長さの1次元配列となります。</target>
        </trans-unit>
        <trans-unit id="691ae079d9ba62e9263b39950b26bbea5ce21d52" translate="yes" xml:space="preserve">
          <source>The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions.</source>
          <target state="translated">新しい形状は元の形状と互換性のあるものでなければなりません。整数であれば,結果はその長さの1次元配列となります.この場合,配列の長さと残りの次元から値が推測されます.</target>
        </trans-unit>
        <trans-unit id="5388ec77c34409cb3cbd101b8eec670a3d1a1fdf" translate="yes" xml:space="preserve">
          <source>The next 1 byte is an unsigned byte: the major version number of the file format, e.g. &lt;code&gt;\x01&lt;/code&gt;.</source>
          <target state="translated">次の1バイトは符号なしバイトです。たとえば、 &lt;code&gt;\x01&lt;/code&gt; などのファイル形式のメジャーバージョン番号です。</target>
        </trans-unit>
        <trans-unit id="728636cfde682c4ca8ef5825e1a61b87b60f117f" translate="yes" xml:space="preserve">
          <source>The next 1 byte is an unsigned byte: the minor version number of the file format, e.g. &lt;code&gt;\x00&lt;/code&gt;. Note: the version of the file format is not tied to the version of the numpy package.</source>
          <target state="translated">次の1バイトは符号なしバイトです：ファイル形式のマイナーバージョン番号（例： &lt;code&gt;\x00&lt;/code&gt; 。注：ファイル形式のバージョンは、numpyパッケージのバージョンに関連付けられていません。</target>
        </trans-unit>
        <trans-unit id="87a88c47d7bd9a05055f3613db15f890d4b10172" translate="yes" xml:space="preserve">
          <source>The next 2 bytes form a little-endian unsigned short int: the length of the header data HEADER_LEN.</source>
          <target state="translated">次の2バイトはリトルエンディアンの符号なしショートintを形成します:ヘッダデータの長さ HEADER_LEN.</target>
        </trans-unit>
        <trans-unit id="c0777c38aebc3061e6b58d63a6472bc19821f955" translate="yes" xml:space="preserve">
          <source>The next HEADER_LEN bytes form the header data describing the array&amp;rsquo;s format. It is an ASCII string which contains a Python literal expression of a dictionary. It is terminated by a newline (&lt;code&gt;\n&lt;/code&gt;) and padded with spaces (&lt;code&gt;\x20&lt;/code&gt;) to make the total of &lt;code&gt;len(magic string) + 2 + len(length) + HEADER_LEN&lt;/code&gt; be evenly divisible by 64 for alignment purposes.</source>
          <target state="translated">次のHEADER_LENバイトは、配列の形式を説明するヘッダーデータを形成します。辞書のPythonリテラル式を含むASCII文字列です。これは改行（ &lt;code&gt;\n&lt;/code&gt; ）で終了し、スペース（ &lt;code&gt;\x20&lt;/code&gt; ）で埋め込まれて、 &lt;code&gt;len(magic string) + 2 + len(length) + HEADER_LEN&lt;/code&gt; が、整列のために64で割り切れるようにします。</target>
        </trans-unit>
        <trans-unit id="af4ca037dcfe75d78dee9fbf52e144a1bd398782" translate="yes" xml:space="preserve">
          <source>The next floating point value after x1 towards x2</source>
          <target state="translated">x1の次の浮動小数点値をx2に向かって</target>
        </trans-unit>
        <trans-unit id="82fde05cc761629191474fcaee36452854b7c17c" translate="yes" xml:space="preserve">
          <source>The next representable values of &lt;code&gt;x1&lt;/code&gt; in the direction of &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x2&lt;/code&gt; の方向における &lt;code&gt;x1&lt;/code&gt; の次の表現可能な値。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="4935ecbe795efbe6b2d076bc80d266ef9b3d3b31" translate="yes" xml:space="preserve">
          <source>The next step depends on the type of index which was found. If all dimensions are indexed with an integer a scalar is returned or set. A single boolean indexing array will call specialized boolean functions. Indices containing an ellipsis or slice but no advanced indexing will always create a view into the old array by calculating the new strides and memory offset. This view can then either be returned or, for assignments, filled using &lt;code&gt;PyArray_CopyObject&lt;/code&gt;. Note that &lt;code&gt;PyArray_CopyObject&lt;/code&gt; may also be called on temporary arrays in other branches to support complicated assignments when the array is of object dtype.</source>
          <target state="translated">次のステップは、見つかったインデックスのタイプによって異なります。すべての次元に整数のインデックスが付けられている場合、スカラーが返されるか設定されます。単一のブールインデックス配列は、特殊なブール関数を呼び出します。省略記号またはスライスを含むが高度なインデックス付けを含まないインデックスは、新しいストライドとメモリオフセットを計算することにより、常に古い配列へのビューを作成します。次に、このビューを返すか、割り当ての場合は &lt;code&gt;PyArray_CopyObject&lt;/code&gt; を使用して埋めることができます。配列がオブジェクトdtypeの場合、複雑な割り当てをサポートするために、他のブランチの一時配列で &lt;code&gt;PyArray_CopyObject&lt;/code&gt; を呼び出すこともできます。</target>
        </trans-unit>
        <trans-unit id="bdf75a3a6e21cea0d77ec634980ca032f5eeb858" translate="yes" xml:space="preserve">
          <source>The next table presents the performance in percentage relative to values generated by the legacy generator, &lt;code&gt;RandomState(MT19937())&lt;/code&gt;. The overall performance was computed using a geometric mean.</source>
          <target state="translated">次の表は、レガシージェネレーター &lt;code&gt;RandomState(MT19937())&lt;/code&gt; によって生成された値に対するパフォーマンスをパーセンテージで示しています。全体的なパフォーマンスは、幾何平均を使用して計算されました。</target>
        </trans-unit>
        <trans-unit id="5462948418f50794d8b059e0adf72cefb6356af5" translate="yes" xml:space="preserve">
          <source>The nice interface can also be generated automatically by placing the variable directives as special comments in the original fortran code. Thus, if I modify the source code to contain:</source>
          <target state="translated">また、元のFortranコードの中に特別なコメントとして変数ディレクティブを配置することで、素敵なインターフェイスを自動的に生成することができます。したがって、もしソースコードを修正して</target>
        </trans-unit>
        <trans-unit id="0153c9bc357a3afb289f46e1296cad96a6ebfe64" translate="yes" xml:space="preserve">
          <source>The noncentral</source>
          <target state="translated">非中央の</target>
        </trans-unit>
        <trans-unit id="007f1b9babda9d4c7b56259360ff2b4902c7689b" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">正規分布は自然界で頻繁に発生します。たとえば、それは多数の小さなランダムな外乱の影響を受けるサンプルの一般的に発生する分布を表し、それぞれに独自の固有の分布があります&lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2acd5981a8ea796b96e83bb6555be4413ecc4212" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#ra2e838c5ea87-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">正規分布は自然界で頻繁に発生します。たとえば、多数の小さなランダムな外乱の影響を受けたサンプルの一般的に発生する分布について説明し、それぞれに固有の分布があります&lt;a href=&quot;#ra2e838c5ea87-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="edcb775700a94ba4ed282cab54aed1dcf6bc2923" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">正規分布は自然界で頻繁に発生します。たとえば、それは多数の小さなランダムな外乱の影響を受けるサンプルの一般的に発生する分布を表し、それぞれに独自の固有の分布があります&lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e795cd0114f2e83de16303b01c212b1bae08ff6" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#rf578abb8fba2-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">正規分布は自然界で頻繁に発生します。たとえば、多数の小さなランダムな外乱の影響を受けたサンプルの一般的に発生する分布について説明し、それぞれに固有の分布があります&lt;a href=&quot;#rf578abb8fba2-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="966686da674deab5a174046b2e8990436c2787f9" translate="yes" xml:space="preserve">
          <source>The normal, exponential and gamma generators use 256-step Ziggurat methods which are 2-10 times faster than NumPy&amp;rsquo;s default implementation in &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt;&lt;code&gt;standard_exponential&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt;&lt;code&gt;standard_gamma&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常、指数、およびガンマジェネレーターは、256ステップのZigguratメソッドを使用します。これは、&lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt; &lt;code&gt;standard_exponential&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt; &lt;code&gt;standard_gamma&lt;/code&gt; &lt;/a&gt;でのNumPyのデフォルト実装よりも2〜10倍高速です。</target>
        </trans-unit>
        <trans-unit id="725e48eaa30d1b2cbd58c002507d29063f93ce22" translate="yes" xml:space="preserve">
          <source>The normalized (unit &amp;ldquo;length&amp;rdquo;) eigenvectors, such that the column &lt;code&gt;v[:,i]&lt;/code&gt; is the eigenvector corresponding to the eigenvalue &lt;code&gt;w[i]&lt;/code&gt;.</source>
          <target state="translated">列 &lt;code&gt;v[:,i]&lt;/code&gt; が固有値 &lt;code&gt;w[i]&lt;/code&gt; 対応する固有ベクトルになるような、正規化された（単位「長さ」）固有ベクトル。</target>
        </trans-unit>
        <trans-unit id="3299e827c6aa0d2d0f05fb49e420b7948a6917ca" translate="yes" xml:space="preserve">
          <source>The normed arguments of &lt;code&gt;histogramdd&lt;/code&gt; and &lt;code&gt;histogram2d&lt;/code&gt; have been renamed</source>
          <target state="translated">&lt;code&gt;histogramdd&lt;/code&gt; と &lt;code&gt;histogram2d&lt;/code&gt; の標準化された引数の名前が変更されました</target>
        </trans-unit>
        <trans-unit id="4a2bc0ba793eb9bb3e0347a0cebea0eac0618ee5" translate="yes" xml:space="preserve">
          <source>The nuclear norm is the sum of the singular values.</source>
          <target state="translated">核ノルムは特異値の和である。</target>
        </trans-unit>
        <trans-unit id="fb33d48b0d271638a6f54e06bd5c7431683a4b77" translate="yes" xml:space="preserve">
          <source>The number 13 has the binaray representation &lt;code&gt;00001101&lt;/code&gt;. Likewise, 16 is represented by &lt;code&gt;00010000&lt;/code&gt;. The bit-wise OR of 13 and 16 is then &lt;code&gt;000111011&lt;/code&gt;, or 29:</source>
          <target state="translated">数字13は、ビナレイ表現 &lt;code&gt;00001101&lt;/code&gt; です。同様に、16は &lt;code&gt;00010000&lt;/code&gt; で表されます。13と16のビットごとのORは &lt;code&gt;000111011&lt;/code&gt; または29になります。</target>
        </trans-unit>
        <trans-unit id="9301b88af54fb2d08827d44439e6252ad34f0666" translate="yes" xml:space="preserve">
          <source>The number 13 is represented by &lt;code&gt;00001101&lt;/code&gt;. Likewise, 17 is represented by &lt;code&gt;00010001&lt;/code&gt;. The bit-wise AND of 13 and 17 is therefore &lt;code&gt;000000001&lt;/code&gt;, or 1:</source>
          <target state="translated">番号13は &lt;code&gt;00001101&lt;/code&gt; で表されます。同様に、17は &lt;code&gt;00010001&lt;/code&gt; で表されます。したがって、13と17のビット単位のANDは &lt;code&gt;000000001&lt;/code&gt; または1です。</target>
        </trans-unit>
        <trans-unit id="5dd5ca9f1bd4e589a273ee53560b9a52127f59e7" translate="yes" xml:space="preserve">
          <source>The number 13 is represented by &lt;code&gt;00001101&lt;/code&gt;. Likewise, 17 is represented by &lt;code&gt;00010001&lt;/code&gt;. The bit-wise XOR of 13 and 17 is therefore &lt;code&gt;00011100&lt;/code&gt;, or 28:</source>
          <target state="translated">番号13は &lt;code&gt;00001101&lt;/code&gt; で表されます。同様に、17は &lt;code&gt;00010001&lt;/code&gt; で表されます。したがって、13と17のビット単位のXORは &lt;code&gt;00011100&lt;/code&gt; または28です。</target>
        </trans-unit>
        <trans-unit id="d78115c4219b81e0960ff03256ee289bd93dfe48" translate="yes" xml:space="preserve">
          <source>The number &lt;code&gt;w&lt;/code&gt; is an eigenvalue of &lt;code&gt;a&lt;/code&gt; if there exists a vector &lt;code&gt;v&lt;/code&gt; such that &lt;code&gt;a @ v = w * v&lt;/code&gt;. Thus, the arrays &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; satisfy the equations &lt;code&gt;a @ v[:,i] = w[i] * v[:,i]&lt;/code&gt; for</source>
          <target state="translated">数 &lt;code&gt;w&lt;/code&gt; は、 &lt;code&gt;a @ v = w * v&lt;/code&gt; ようなベクトル &lt;code&gt;v&lt;/code&gt; が存在する場合、 &lt;code&gt;a&lt;/code&gt; の固有値です。したがって、配列 &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;w&lt;/code&gt; 、および &lt;code&gt;v&lt;/code&gt; は、次の方程式 &lt;code&gt;a @ v[:,i] = w[i] * v[:,i]&lt;/code&gt; を満たします。</target>
        </trans-unit>
        <trans-unit id="dafcbdde76f7395561c97c3255cdf449984b5af3" translate="yes" xml:space="preserve">
          <source>The number &lt;code&gt;w&lt;/code&gt; is an eigenvalue of &lt;code&gt;a&lt;/code&gt; if there exists a vector &lt;code&gt;v&lt;/code&gt; such that &lt;code&gt;dot(a,v) = w * v&lt;/code&gt;. Thus, the arrays &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; satisfy the equations &lt;code&gt;dot(a[:,:], v[:,i]) = w[i] * v[:,i]&lt;/code&gt; for</source>
          <target state="translated">&lt;code&gt;dot(a,v) = w * v&lt;/code&gt; ようなベクトル &lt;code&gt;v&lt;/code&gt; が存在する場合、数値 &lt;code&gt;w&lt;/code&gt; は &lt;code&gt;a&lt;/code&gt; の固有値です。したがって、アレイは、 &lt;code&gt;w&lt;/code&gt; は、及び &lt;code&gt;v&lt;/code&gt; の式が満足 &lt;code&gt;dot(a[:,:], v[:,i]) = w[i] * v[:,i]&lt;/code&gt; 用 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bb66b4a14636c387bd7dac27c6170702e129db5" translate="yes" xml:space="preserve">
          <source>The number of arguments.</source>
          <target state="translated">引数の数です。</target>
        </trans-unit>
        <trans-unit id="50f26fa4113f32c300038f926f58c5de950b657e" translate="yes" xml:space="preserve">
          <source>The number of arrays that need to be broadcast to the same shape.</source>
          <target state="translated">同じ形状にブロードキャストする必要がある配列の数。</target>
        </trans-unit>
        <trans-unit id="cd1c13079fc7462745575ad6cadd5c1655d5fd8f" translate="yes" xml:space="preserve">
          <source>The number of base units in a step.</source>
          <target state="translated">ステップの基本単位の数。</target>
        </trans-unit>
        <trans-unit id="ddeea3732f7461b0e4b46d4155abe0931176b591" translate="yes" xml:space="preserve">
          <source>The number of bins (of size 1) is one larger than the largest value in &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;minlength&lt;/code&gt; is specified, there will be at least this number of bins in the output array (though it will be longer if necessary, depending on the contents of &lt;code&gt;x&lt;/code&gt;). Each bin gives the number of occurrences of its index value in &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;weights&lt;/code&gt; is specified the input array is weighted by it, i.e. if a value &lt;code&gt;n&lt;/code&gt; is found at position &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;out[n] += weight[i]&lt;/code&gt; instead of &lt;code&gt;out[n] += 1&lt;/code&gt;.</source>
          <target state="translated">（サイズ1の）ビンの数は、 &lt;code&gt;x&lt;/code&gt; の最大値より1つ大きくなります。 &lt;code&gt;minlength&lt;/code&gt; が指定されている場合、出力配列には少なくともこの数のビンがあります（ただし、 &lt;code&gt;x&lt;/code&gt; の内容に応じて、必要に応じて長くなります）。各ビンは、 &lt;code&gt;x&lt;/code&gt; におけるそのインデックス値の出現回数を示します。 &lt;code&gt;weights&lt;/code&gt; が指定されている場合、入力配列はそれによって重み付けされます。つまり、値 &lt;code&gt;n&lt;/code&gt; が位置 &lt;code&gt;i&lt;/code&gt; にある場合、 &lt;code&gt;out[n] += 1&lt;/code&gt; ではなく &lt;code&gt;out[n] += weight[i]&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="961981b3d06507afe179094c308682fa430fda0e" translate="yes" xml:space="preserve">
          <source>The number of bins for all dimensions (nx=ny=&amp;hellip;=bins).</source>
          <target state="translated">すべての次元のビンの数（nx = ny =&amp;hellip;= bins）。</target>
        </trans-unit>
        <trans-unit id="180a01cbfbe39044df94a38205c151e4055dfaef" translate="yes" xml:space="preserve">
          <source>The number of bins for each dimension (nx, ny, &amp;hellip; =bins)</source>
          <target state="translated">各次元のビンの数（nx、ny、&amp;hellip;= bins）</target>
        </trans-unit>
        <trans-unit id="ef8032cee94538f0c3d6bbb995bbf06ce4b1a135" translate="yes" xml:space="preserve">
          <source>The number of bins is only proportional to cube root of &lt;code&gt;a.size&lt;/code&gt;. It tends to overestimate the number of bins and it does not take into account data variability.</source>
          <target state="translated">ビンの数は、 &lt;code&gt;a.size&lt;/code&gt; の立方根にのみ比例します。ビンの数を過大評価する傾向があり、データの変動性は考慮されません。</target>
        </trans-unit>
        <trans-unit id="3c7ac04dd9e94e09e580f7718e7797190217f2db" translate="yes" xml:space="preserve">
          <source>The number of bins is the base 2 log of &lt;code&gt;a.size&lt;/code&gt;. This estimator assumes normality of data and is too conservative for larger, non-normal datasets. This is the default method in R&amp;rsquo;s &lt;code&gt;hist&lt;/code&gt; method.</source>
          <target state="translated">ビンの数は、 &lt;code&gt;a.size&lt;/code&gt; の 2を底とする対数です。この推定量はデータの正規性を想定しており、大規模な非正規データセットには保守的すぎます。これは、Rの &lt;code&gt;hist&lt;/code&gt; メソッドのデフォルトのメソッドです。</target>
        </trans-unit>
        <trans-unit id="ec49cbff29de9e7b90f0c2a06cd3039e0f213a48" translate="yes" xml:space="preserve">
          <source>The number of bits in the exponent including its sign and bias.</source>
          <target state="translated">指数の符号と偏りを含めたビット数。</target>
        </trans-unit>
        <trans-unit id="ffbebedcdf5bf4f1593520cffb80749e6f34262c" translate="yes" xml:space="preserve">
          <source>The number of bits in the exponent portion of the floating point representation.</source>
          <target state="translated">浮動小数点表現の指数部分のビット数。</target>
        </trans-unit>
        <trans-unit id="96302b58629afe268f2042e560d43721a3fc2867" translate="yes" xml:space="preserve">
          <source>The number of bits in the mantissa.</source>
          <target state="translated">マンティッサのビット数です。</target>
        </trans-unit>
        <trans-unit id="792cc1a58f0a3a46d19118877b6d13c493cb98ec" translate="yes" xml:space="preserve">
          <source>The number of bits occupied by the type.</source>
          <target state="translated">型が占有するビット数。</target>
        </trans-unit>
        <trans-unit id="b307f502028d1a8e478a9e28dfcf2d36c5fe0bca" translate="yes" xml:space="preserve">
          <source>The number of bits required to generate a simulated value differs from the number of bits generated by the underlying RNG. For example, two 16-bit integer values can be simulated from a single draw of a 32-bit RNG.</source>
          <target state="translated">シミュレートされた値を生成するのに必要なビット数は、基礎となるRNGで生成されるビット数とは異なります。例えば、32ビットのRNGの1回の描画から2つの16ビットの整数値をシミュレートすることができます。</target>
        </trans-unit>
        <trans-unit id="5b028aff9079ccf79e60389c0ccd1c2bd52c5a13" translate="yes" xml:space="preserve">
          <source>The number of build jobs can also be specified via the environment variable &lt;code&gt;NPY_NUM_BUILD_JOBS&lt;/code&gt;.</source>
          <target state="translated">ビルドジョブの数は、環境変数 &lt;code&gt;NPY_NUM_BUILD_JOBS&lt;/code&gt; を介して指定することもできます。</target>
        </trans-unit>
        <trans-unit id="c523c9c933fe391fb48ef56ebd3c154a68738ed9" translate="yes" xml:space="preserve">
          <source>The number of bytes each item in the array requires.</source>
          <target state="translated">配列の各項目が必要とするバイト数。</target>
        </trans-unit>
        <trans-unit id="accc8d694cc26b9e63438cb6cbca5878ebb2f8ff" translate="yes" xml:space="preserve">
          <source>The number of bytes into the field at which to place &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; を配置するフィールドへのバイト数。</target>
        </trans-unit>
        <trans-unit id="a1bc94a2ea241fcb184442f81754fe01e618cf6a" translate="yes" xml:space="preserve">
          <source>The number of characters per line for the purpose of inserting line breaks (default 75).</source>
          <target state="translated">改行を挿入するための1行あたりの文字数(デフォルトは75)。</target>
        </trans-unit>
        <trans-unit id="e62a5487dfe8294b0662475991a8ef49d96aaa30" translate="yes" xml:space="preserve">
          <source>The number of children already spawned. Only pass this if reconstructing a &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; from a serialized form.</source>
          <target state="translated">すでに発生した子供の数。シリアル化されたフォームから&lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;を再構築する場合にのみこれを渡します。</target>
        </trans-unit>
        <trans-unit id="51818f09691484990d73679da97e27bd0b748a81" translate="yes" xml:space="preserve">
          <source>The number of dimensions and the size of each dimension</source>
          <target state="translated">寸法の数と各寸法の大きさは</target>
        </trans-unit>
        <trans-unit id="20f7440820740cd73bd8bc73940f9eb0da1ec572" translate="yes" xml:space="preserve">
          <source>The number of dimensions in the array.</source>
          <target state="translated">配列の次元数。</target>
        </trans-unit>
        <trans-unit id="d4b953d2df6296d252217619c918790078f1f070" translate="yes" xml:space="preserve">
          <source>The number of dimensions in the broadcasted result.</source>
          <target state="translated">ブロードキャストされた結果の次元数。</target>
        </trans-unit>
        <trans-unit id="16045283fd37589fa60a5d2a0d49dd57ac83ac40" translate="yes" xml:space="preserve">
          <source>The number of dimensions.</source>
          <target state="translated">寸法の数です。</target>
        </trans-unit>
        <trans-unit id="cf23530c90606a0534a47544a2bf03555320f356" translate="yes" xml:space="preserve">
          <source>The number of each type of item in the collection from which a sample is drawn. The values in &lt;code&gt;colors&lt;/code&gt; must be nonnegative. To avoid loss of precision in the algorithm, &lt;code&gt;sum(colors)&lt;/code&gt; must be less than &lt;code&gt;10**9&lt;/code&gt; when &lt;code&gt;method&lt;/code&gt; is &amp;ldquo;marginals&amp;rdquo;.</source>
          <target state="translated">サンプルが抽出されたコレクション内の各タイプのアイテムの番号。 &lt;code&gt;colors&lt;/code&gt; の値は負でない必要があります。アルゴリズムの精度の低下を回避するために、 &lt;code&gt;method&lt;/code&gt; が「周辺」の場合、 &lt;code&gt;sum(colors)&lt;/code&gt; は &lt;code&gt;10**9&lt;/code&gt; 未満である必要があります。</target>
        </trans-unit>
        <trans-unit id="3a0a0191ab6889929bc691e4ea5f7b01d6f77c2e" translate="yes" xml:space="preserve">
          <source>The number of elements to unpack along &lt;code&gt;axis&lt;/code&gt;, provided as a way of undoing the effect of packing a size that is not a multiple of eight. A non-negative number means to only unpack &lt;code&gt;count&lt;/code&gt; bits. A negative number means to trim off that many bits from the end. &lt;code&gt;None&lt;/code&gt; means to unpack the entire array (the default). Counts larger than the available number of bits will add zero padding to the output. Negative counts must not exceed the available number of bits.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; に沿ってアンパックする要素の数。8の倍数ではないサイズのパッキングの効果を元に戻す方法として提供されます。負でない数は、 &lt;code&gt;count&lt;/code&gt; ビットのみをアンパックすることを意味します。負の数は、最後からその数のビットを切り捨てることを意味します。 &lt;code&gt;None&lt;/code&gt; は、アレイ全体をアンパックすることを意味します（デフォルト）。利用可能なビット数よりも大きいカウントは、出力にゼロパディングを追加します。負の数は、使用可能なビット数を超えてはなりません。</target>
        </trans-unit>
        <trans-unit id="9762b9c4461b4320b651627cdc827d526c1d8a36" translate="yes" xml:space="preserve">
          <source>The number of floating-point types</source>
          <target state="translated">浮動小数点型の数</target>
        </trans-unit>
        <trans-unit id="5f79b76db3c0063c4dbecc42a7851ca0e7d61297" translate="yes" xml:space="preserve">
          <source>The number of input arguments.</source>
          <target state="translated">入力引数の数です。</target>
        </trans-unit>
        <trans-unit id="5f16430ff4bbbb029090f84ca5392fa4a978dcbf" translate="yes" xml:space="preserve">
          <source>The number of inputs.</source>
          <target state="translated">入力数です。</target>
        </trans-unit>
        <trans-unit id="ad3ac53999da2a535168ea7e917e83fb83c41419" translate="yes" xml:space="preserve">
          <source>The number of integrations to perform.</source>
          <target state="translated">実行する統合の数。</target>
        </trans-unit>
        <trans-unit id="f51beaacf43aeefc0899893a53af8824382a26f0" translate="yes" xml:space="preserve">
          <source>The number of items selected. &lt;code&gt;nsample&lt;/code&gt; must not be greater than &lt;code&gt;sum(colors)&lt;/code&gt;.</source>
          <target state="translated">選択されたアイテムの数。 &lt;code&gt;nsample&lt;/code&gt; は &lt;code&gt;sum(colors)&lt;/code&gt; より大きくてはなりません。</target>
        </trans-unit>
        <trans-unit id="fb27416d0d8fd4a79bebfa578ec630568a0908f0" translate="yes" xml:space="preserve">
          <source>The number of items to read from &lt;em&gt;iterable&lt;/em&gt;. The default is -1, which means all data is read.</source>
          <target state="translated">&lt;em&gt;イテラブル&lt;/em&gt;から読み取るアイテムの数。デフォルトは-1で、すべてのデータが読み取られることを意味します。</target>
        </trans-unit>
        <trans-unit id="59d7f6376949b026c4f59178cb450cda4e03c50d" translate="yes" xml:space="preserve">
          <source>The number of iterator operands.</source>
          <target state="translated">イテレータのオペランドの数。</target>
        </trans-unit>
        <trans-unit id="906dbe82e1bcf21f6f38450b28f60987840c67b3" translate="yes" xml:space="preserve">
          <source>The number of lines to skip at the beginning of the file.</source>
          <target state="translated">ファイルの先頭でスキップする行数を指定します。</target>
        </trans-unit>
        <trans-unit id="1f9e5bb5bb6065f40b3b5f1acf92ad15826aa414" translate="yes" xml:space="preserve">
          <source>The number of lines to skip at the end of the file.</source>
          <target state="translated">ファイルの最後にスキップする行数を指定します。</target>
        </trans-unit>
        <trans-unit id="36ce98d71e68fb1757547c834a0c7900df88883d" translate="yes" xml:space="preserve">
          <source>The number of numerical NumPy types - of which there are 18 total - on which the ufunc can operate.</source>
          <target state="translated">ufuncが操作可能なNumPyの数値型の数(全部で18個)。</target>
        </trans-unit>
        <trans-unit id="9d9f649df57a2efc7c5d1837c8cce03f4ddffe4d" translate="yes" xml:space="preserve">
          <source>The number of objects returned by &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; によって返されるオブジェクトの数。</target>
        </trans-unit>
        <trans-unit id="cd1491ebeebfc5761455718746328a874537820d" translate="yes" xml:space="preserve">
          <source>The number of output arguments.</source>
          <target state="translated">出力引数の数を指定します。</target>
        </trans-unit>
        <trans-unit id="bb79176b795c17c39b28af054f09df09e008175b" translate="yes" xml:space="preserve">
          <source>The number of outputs.</source>
          <target state="translated">出力数です。</target>
        </trans-unit>
        <trans-unit id="1f9d3b6c33190d8820407a65c8dfbe71f2fb41db" translate="yes" xml:space="preserve">
          <source>The number of periods &lt;code&gt;nper&lt;/code&gt; is computed by solving the equation:</source>
          <target state="translated">期間の数 &lt;code&gt;nper&lt;/code&gt; 方程式を解くことによって計算されます。</target>
        </trans-unit>
        <trans-unit id="9f00991307aeed3ff212ec1f19aa64c4d4a70887" translate="yes" xml:space="preserve">
          <source>The number of places by which elements are shifted. If a tuple, then &lt;code&gt;axis&lt;/code&gt; must be a tuple of the same size, and each of the given axes is shifted by the corresponding number. If an int while &lt;code&gt;axis&lt;/code&gt; is a tuple of ints, then the same value is used for all given axes.</source>
          <target state="translated">要素がシフトされる場所の数。タプルの場合、 &lt;code&gt;axis&lt;/code&gt; は同じサイズのタプルでなければならず、指定された各軸は対応する数だけシフトされます。 &lt;code&gt;axis&lt;/code&gt; がintのタプルである場合、指定されたすべての軸に同じ値が使用されます。</target>
        </trans-unit>
        <trans-unit id="1c87f40038faffc87024cc0b95bb28f19f5ea872" translate="yes" xml:space="preserve">
          <source>The number of repetitions for each element. &lt;code&gt;repeats&lt;/code&gt; is broadcasted to fit the shape of the given axis.</source>
          <target state="translated">各要素の繰り返し数。 &lt;code&gt;repeats&lt;/code&gt; は、指定された軸の形状に合わせてブロードキャストされます。</target>
        </trans-unit>
        <trans-unit id="4fedda7271f10f5b28b1a15e8ad961405e48dbc3" translate="yes" xml:space="preserve">
          <source>The number of repetitions of &lt;code&gt;A&lt;/code&gt; along each axis.</source>
          <target state="translated">各軸に沿った &lt;code&gt;A&lt;/code&gt; の繰り返し数。</target>
        </trans-unit>
        <trans-unit id="1e0a0e5cb024809c54b4083f3e0a5bc9d1d9a145" translate="yes" xml:space="preserve">
          <source>The number of supported data types for the ufunc. This number specifies how many different 1-d loops (of the builtin data types) are available.</source>
          <target state="translated">ufuncでサポートされているデータ型の数。この数は、(組み込みのデータ型の)1-dループの数を指定します。</target>
        </trans-unit>
        <trans-unit id="d384dcdb010cb83d633476edabf26a7cd5dcb98d" translate="yes" xml:space="preserve">
          <source>The number of times &lt;code&gt;a&lt;/code&gt; is repeated along the first and second axes.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; が第1軸と第2軸に沿って繰り返される回数。</target>
        </trans-unit>
        <trans-unit id="84ea540c48d087fa8db5ec94e472c5f5f973f2f5" translate="yes" xml:space="preserve">
          <source>The number of times each of the unique values comes up in the original array. Only provided if &lt;code&gt;return_counts&lt;/code&gt; is True.</source>
          <target state="translated">一意の値のそれぞれが元の配列に出現する回数。 &lt;code&gt;return_counts&lt;/code&gt; がTrueの場合にのみ提供されます。</target>
        </trans-unit>
        <trans-unit id="27ba063589e5e81b80624f4103b1f5b28059f11a" translate="yes" xml:space="preserve">
          <source>The number of times values are differenced. If zero, the input is returned as-is.</source>
          <target state="translated">値が異なる回数を指定します。ゼロの場合、入力はそのまま返されます。</target>
        </trans-unit>
        <trans-unit id="9f0b88f6fb636dd892bff0b33b009c20d79ffb03" translate="yes" xml:space="preserve">
          <source>The number of types.</source>
          <target state="translated">種類の数です。</target>
        </trans-unit>
        <trans-unit id="fddf10cce5774b681c3f0ad6691bdd384810c58d" translate="yes" xml:space="preserve">
          <source>The number of variates to generate, either an integer or a tuple holding the shape of the array of variates. If the given size is, e.g., &lt;code&gt;(k, m)&lt;/code&gt;, then &lt;code&gt;k * m&lt;/code&gt; variates are drawn, where one variate is a vector of length &lt;code&gt;len(colors)&lt;/code&gt;, and the return value has shape &lt;code&gt;(k, m, len(colors))&lt;/code&gt;. If &lt;code&gt;size&lt;/code&gt; is an integer, the output has shape &lt;code&gt;(size, len(colors))&lt;/code&gt;. Default is None, in which case a single variate is returned as an array with shape &lt;code&gt;(len(colors),)&lt;/code&gt;.</source>
          <target state="translated">生成する変量の数。整数または変量の配列の形状を保持するタプルのいずれかです。指定されたサイズがたとえば &lt;code&gt;(k, m)&lt;/code&gt; 場合、 &lt;code&gt;k * m&lt;/code&gt; 変量が描画されます。ここで、1つの変量は長さ &lt;code&gt;len(colors)&lt;/code&gt; のベクトルであり、戻り値は形状 &lt;code&gt;(k, m, len(colors))&lt;/code&gt; 。場合 &lt;code&gt;size&lt;/code&gt; 整数であり、出力は、形状を有している &lt;code&gt;(size, len(colors))&lt;/code&gt; 。デフォルトはNoneです。この場合、単一の変量が形状 &lt;code&gt;(len(colors),)&lt;/code&gt; 配列として返されます。</target>
        </trans-unit>
        <trans-unit id="8a67e415f6489cfd59cc7656bd025411ca29912b" translate="yes" xml:space="preserve">
          <source>The numpy array shares the memory with the ctypes object.</source>
          <target state="translated">numpy配列はctypesオブジェクトとメモリを共有します。</target>
        </trans-unit>
        <trans-unit id="d790ce3a56f19101368186a47de94f2e3aed2abb" translate="yes" xml:space="preserve">
          <source>The numpy core math library (&amp;lsquo;npymath&amp;rsquo;) is a first step in this direction. This library contains most math-related C99 functionality, which can be used on platforms where C99 is not well supported. The core math functions have the same API as the C99 ones, except for the npy_* prefix.</source>
          <target state="translated">numpyコア数学ライブラリ（ 'npymath'）は、この方向への最初のステップです。このライブラリには、ほとんどの数学関連のC99機能が含まれており、C99が十分にサポートされていないプラットフォームで使用できます。コア数学関数は、npy_ *接頭辞を除いて、C99のものと同じAPIを持っています。</target>
        </trans-unit>
        <trans-unit id="6064ebb13dec03f1de88e5067059d7a27df68911" translate="yes" xml:space="preserve">
          <source>The numpy documentation also depends on the &lt;a href=&quot;https://numpydoc.readthedocs.io/en/latest/&quot;&gt;numpydoc&lt;/a&gt; sphinx extension as well as an external sphinx theme. These extensions are included as git submodules and must be initialized before building the docs. From the &lt;code&gt;doc/&lt;/code&gt; directory:</source>
          <target state="translated">numpyのドキュメントは、&lt;a href=&quot;https://numpydoc.readthedocs.io/en/latest/&quot;&gt;numpydocの&lt;/a&gt;sphinx拡張機能と外部のsphinxテーマにも依存します。これらの拡張機能はgitサブモジュールとして含まれており、ドキュメントを作成する前に初期化する必要があります。以下から &lt;code&gt;doc/&lt;/code&gt; ディレクトリ：</target>
        </trans-unit>
        <trans-unit id="d91b51f2620c8e0f1fabe752803d49bce22176fb" translate="yes" xml:space="preserve">
          <source>The numpy.ma module</source>
          <target state="translated">numpy.ma モジュール</target>
        </trans-unit>
        <trans-unit id="2cbe93e7df3a43f9ae71da4b89814ed8fa49c0d4" translate="yes" xml:space="preserve">
          <source>The numpy/core/include/numpy/numpyconfig.h will need a new NPY_X_Y_API_VERSION macro, where X and Y are the major and minor version numbers of the release. The value given to that macro only needs to be increased from the previous version if some of the functions or macros in the include files were deprecated.</source>
          <target state="translated">numpy/core/include/numpy/numpyconfig.h には、新しい NPY_X_Y_API_VERSION マクロが必要です。このマクロに与えられた値は、インクルードファイル内の関数やマクロのいくつかが非推奨となった場合にのみ、前のバージョンから増加させる必要があります。</target>
        </trans-unit>
        <trans-unit id="2fff5784e4a4fb8eb59dd23392ddf836510aaeb1" translate="yes" xml:space="preserve">
          <source>The numpydoc docstring guide</source>
          <target state="translated">numpydoc docstringガイド</target>
        </trans-unit>
        <trans-unit id="dbd675a4d044f8874d7c67d632da0258490296eb" translate="yes" xml:space="preserve">
          <source>The object can be any Python object convertible to an ndarray. If the object is already (a subclass of) the ndarray that satisfies the requirements then a new reference is returned. Otherwise, a new array is constructed. The contents of &lt;em&gt;obj&lt;/em&gt; are copied to the new array unless the array interface is used so that data does not have to be copied. Objects that can be converted to an array include: 1) any nested sequence object, 2) any object exposing the array interface, 3) any object with an &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method (which should return an ndarray), and 4) any scalar object (becomes a zero-dimensional array). Sub-classes of the ndarray that otherwise fit the requirements will be passed through. If you want to ensure a base-class ndarray, then use &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_ENSUREARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt;&lt;/a&gt; in the requirements flag. A copy is made only if necessary. If you want to guarantee a copy, then pass in &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_ENSURECOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSURECOPY&lt;/code&gt;&lt;/a&gt; to the requirements flag.</source>
          <target state="translated">オブジェクトは、ndarrayに変換可能な任意のPythonオブジェクトにすることができます。オブジェクトがすでに要件を満たすndarray（のサブクラス）である場合、新しい参照が返されます。それ以外の場合は、新しいアレイが作成されます。データをコピーする必要がないように配列インターフェイスが使用されていない限り、&lt;em&gt;obj&lt;/em&gt;の内容は新しい配列にコピーされます。配列に変換できるオブジェクトには、1）ネストされたシーケンスオブジェクト、2）配列インターフェイスを公開するオブジェクト、3）&lt;a href=&quot;../reference/arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;メソッドを持つオブジェクト（ndarrayを返す必要がある）、4）スカラーオブジェクト（になる）が含まれます。ゼロ次元配列）。それ以外の場合は要件に適合するndarrayのサブクラスが渡されます。基本クラスのndarrayを確保する場合は、NPY_ARRAY_ENSUREARRAYを使用し&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_ENSUREARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt; &lt;/a&gt;要件フラグで。コピーは必要な場合にのみ作成されます。コピーを保証する場合は、&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_ENSURECOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSURECOPY&lt;/code&gt; &lt;/a&gt;を要件フラグに渡します。</target>
        </trans-unit>
        <trans-unit id="a12e93df39508259f846e57ebebd07dec5405cd4" translate="yes" xml:space="preserve">
          <source>The object of which the type is returned.</source>
          <target state="translated">型が返されるオブジェクト。</target>
        </trans-unit>
        <trans-unit id="892e730df208b39897e2c0d1b1cca7fbb8ae1420" translate="yes" xml:space="preserve">
          <source>The object to be converted to a type-and-requirement-satisfying array.</source>
          <target state="translated">型と要求を満たす配列に変換されるオブジェクト。</target>
        </trans-unit>
        <trans-unit id="bfbfb146acae6cf5d1e2df4b8b0cf4b046d06226" translate="yes" xml:space="preserve">
          <source>The object to check.</source>
          <target state="translated">チェックするオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="0f3ea496874fb4613c3a9be9c6a176f4f24c9e54" translate="yes" xml:space="preserve">
          <source>The object to iterate over.</source>
          <target state="translated">反復するオブジェクト。</target>
        </trans-unit>
        <trans-unit id="45971228cf20d163b0ca1b27e71b0f9a03bee868" translate="yes" xml:space="preserve">
          <source>The object type is also special because an array containing &lt;code&gt;object_&lt;/code&gt; items does not return an &lt;code&gt;object_&lt;/code&gt; object on item access, but instead returns the actual object that the array item refers to.</source>
          <target state="translated">&lt;code&gt;object_&lt;/code&gt; items を含む配列は、アイテムアクセス時に &lt;code&gt;object_&lt;/code&gt; オブジェクトを返さず、代わりに配列itemが参照する実際のオブジェクトを返すため、オブジェクトタイプも特別です。</target>
        </trans-unit>
        <trans-unit id="74fb22be6dfa85b139cc4a823d71b842fbca772d" translate="yes" xml:space="preserve">
          <source>The object which calculated these parameters and holds more detailed information.</source>
          <target state="translated">これらのパラメータを計算し、より詳細な情報を保持しているオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="12dc58a76790d493cfd5ba208610a891b0f1c28f" translate="yes" xml:space="preserve">
          <source>The object will be converted to the desired type only if it can be done without losing precision. Otherwise &lt;code&gt;NULL&lt;/code&gt; will be returned and an error raised. Use &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_FORCECAST&quot;&gt;&lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt;&lt;/a&gt; in the requirements flag to override this behavior.</source>
          <target state="translated">オブジェクトは、精度を失うことなく実行できる場合にのみ、目的のタイプに変換されます。それ以外の場合は &lt;code&gt;NULL&lt;/code&gt; が返され、エラーが発生します。この動作をオーバーライドするには、要件フラグで&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_FORCECAST&quot;&gt; &lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt; &lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="d7678b3e9676e0762f7a3c623921af222c12ff2c" translate="yes" xml:space="preserve">
          <source>The obvious fix for this situation is to change the dtype so it gives the correct endianness:</source>
          <target state="translated">この状況を解決するための明白な方法は、正しいエンディアンを与えるようにdtypeを変更することです。</target>
        </trans-unit>
        <trans-unit id="29b86a58a4365210dddb9297096eac1156c7d098" translate="yes" xml:space="preserve">
          <source>The offset (in bytes) from the file&amp;rsquo;s current position. Defaults to 0. Only permitted for binary files.</source>
          <target state="translated">ファイルの現在位置からのオフセット（バイト単位）。デフォルトは0です。バイナリファイルに対してのみ許可されます。</target>
        </trans-unit>
        <trans-unit id="93c773e560e0498af231d1a157163977066e3d8a" translate="yes" xml:space="preserve">
          <source>The old error handler.</source>
          <target state="translated">古いエラーハンドラです。</target>
        </trans-unit>
        <trans-unit id="1ec4554bb191ce258f048e411e4e87d29267fb91" translate="yes" xml:space="preserve">
          <source>The old iterator API includes functions like PyArrayIter_Check, PyArray_Iter* and PyArray_ITER_*. The multi-iterator array includes PyArray_MultiIter*, PyArray_Broadcast, and PyArray_RemoveSmallest. The new iterator design replaces all of this functionality with a single object and associated API. One goal of the new API is that all uses of the existing iterator should be replaceable with the new iterator without significant effort. In 1.6, the major exception to this is the neighborhood iterator, which does not have corresponding features in this iterator.</source>
          <target state="translated">古いイテレータAPIには、PyArrayIter_Check、PyArray_Iter*、PyArray_ITER_*のような関数が含まれています。マルチイテレータ配列には、PyArray_MultiIter*、PyArray_Broadcast、およびPyArray_RemoveSmallestが含まれています。新しいイテレータのデザインは、これらの機能をすべて単一のオブジェクトと関連するAPIで置き換えます。新しいAPIの目標の1つは、既存のイテレータのすべての使用は、大きな労力をかけずに新しいイテレータで置き換えることができるということです。1.6では、これに対応する主要な例外は近傍イテレータであり、このイテレータには対応する機能がありません。</target>
        </trans-unit>
        <trans-unit id="5bba457e9d70db346759d26e013499c6bff97b55" translate="yes" xml:space="preserve">
          <source>The one-dimensional (forward) FFT, of which &lt;a href=&quot;#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt; is the inverse</source>
          <target state="translated">1次元（フォワード）FFT、その&lt;a href=&quot;#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt;はその逆</target>
        </trans-unit>
        <trans-unit id="b13835d03a9daf8c507b45bfab105cd08fae35d5" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT of general (complex) input.</source>
          <target state="translated">一般的な(複素)入力の一次元FFT。</target>
        </trans-unit>
        <trans-unit id="0cd037d8b0e459e2ea7f7abda9a2074a96ea80a2" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT of real input, of which &lt;a href=&quot;#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt; is inverse.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; &lt;/a&gt;が逆である実数入力の1次元FFT 。</target>
        </trans-unit>
        <trans-unit id="9fbd4ce083fd828af7518629c69fc1b51be085ea" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT of real input.</source>
          <target state="translated">実数入力の一次元FFT。</target>
        </trans-unit>
        <trans-unit id="5c18581fbbf72b4741168098a1d9545410236f6d" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT, with definitions and conventions used.</source>
          <target state="translated">一次元FFTの定義と使用される慣例を示します。</target>
        </trans-unit>
        <trans-unit id="cb7777bd048622e7012600d71666f63fa7ceb74f" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT.</source>
          <target state="translated">一次元FFTです。</target>
        </trans-unit>
        <trans-unit id="225306f7f184d0b92b85104fd4b6b278cc44c9a3" translate="yes" xml:space="preserve">
          <source>The one-dimensional inverse FFT.</source>
          <target state="translated">一次元逆FFT。</target>
        </trans-unit>
        <trans-unit id="ba7c728a6936b18871796d8f180aab8013101b39" translate="yes" xml:space="preserve">
          <source>The only constraint on &lt;code&gt;weights&lt;/code&gt; is that &lt;code&gt;sum(weights)&lt;/code&gt; must not be 0.</source>
          <target state="translated">&lt;code&gt;weights&lt;/code&gt; に関する唯一の制約は、 &lt;code&gt;sum(weights)&lt;/code&gt; が0であってはならないということです。</target>
        </trans-unit>
        <trans-unit id="ff0f1129172422a9679a73fc5e8d6a883951639f" translate="yes" xml:space="preserve">
          <source>The only mandatory argument of &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; is the source of the data. It can be a string, a list of strings, a generator or an open file-like object with a &lt;code&gt;read&lt;/code&gt; method, for example, a file or &lt;a href=&quot;https://docs.python.org/dev/library/io.html#io.StringIO&quot;&gt;&lt;code&gt;io.StringIO&lt;/code&gt;&lt;/a&gt; object. If a single string is provided, it is assumed to be the name of a local or remote file. If a list of strings or a generator returning strings is provided, each string is treated as one line in a file. When the URL of a remote file is passed, the file is automatically downloaded to the current directory and opened.</source>
          <target state="translated">&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;の唯一の必須の引数は、データのソースです。これは、文字列、文字列のリスト、ジェネレーター、またはファイルや&lt;a href=&quot;https://docs.python.org/dev/library/io.html#io.StringIO&quot;&gt; &lt;code&gt;io.StringIO&lt;/code&gt; &lt;/a&gt;オブジェクトなどの &lt;code&gt;read&lt;/code&gt; メソッドを持つ開いているファイルのようなオブジェクトにすることができます。単一の文字列が指定されている場合、それはローカルファイルまたはリモートファイルの名前であると見なされます。文字列のリストまたは文字列を返すジェネレータが提供されている場合、各文字列はファイル内の1行として扱われます。リモートファイルのURLが渡されると、ファイルは自動的に現在のディレクトリにダウンロードされて開かれます。</target>
        </trans-unit>
        <trans-unit id="df0b92ea232e6d8dccfcd905588f89bc51445e3a" translate="yes" xml:space="preserve">
          <source>The operands of some operation whose result type is needed.</source>
          <target state="translated">結果の型が必要な操作のオペランド。</target>
        </trans-unit>
        <trans-unit id="10e5b80590b5efbd493758bd757a312d4d78c228" translate="yes" xml:space="preserve">
          <source>The operation in the inner loop is a straightforward multiplication. Everything to do with the outer product is handled by the iterator setup.</source>
          <target state="translated">内側のループでの操作は単純な乗算です。外積に関するすべての処理はイテレータの設定によって行われます。</target>
        </trans-unit>
        <trans-unit id="471ee7828ebe7c0602cfc5e6e021f9c562ef10fd" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;dtype=None&lt;/code&gt; is provided for convenience. However, it is significantly slower than setting the dtype explicitly.</source>
          <target state="translated">オプション &lt;code&gt;dtype=None&lt;/code&gt; は、便宜上提供されています。ただし、dtypeを明示的に設定するよりも大幅に遅くなります。</target>
        </trans-unit>
        <trans-unit id="5d9c6a82b754562bff3c30cfb164e81b6c34b6c3" translate="yes" xml:space="preserve">
          <source>The optional &amp;lsquo;aligned&amp;rsquo; value can be set to &lt;code&gt;True&lt;/code&gt; to make the automatic offset computation use aligned offsets (see &lt;a href=&quot;#offsets-and-alignment&quot;&gt;Automatic Byte Offsets and Alignment&lt;/a&gt;), as if the &amp;lsquo;align&amp;rsquo; keyword argument of &lt;a href=&quot;../reference/generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;numpy.dtype&lt;/code&gt;&lt;/a&gt; had been set to True.</source>
          <target state="translated">オプションの「aligned」値を &lt;code&gt;True&lt;/code&gt; に設定する&lt;a href=&quot;#offsets-and-alignment&quot;&gt;と&lt;/a&gt;、&lt;a href=&quot;../reference/generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;numpy.dtype&lt;/code&gt; の&lt;/a&gt;「align」キーワード引数がTrueに設定されているかのように、自動オフセット計算で整列オフセットが使用されます（「自動バイトオフセットと整列」を参照）。</target>
        </trans-unit>
        <trans-unit id="03a3e8c483cee1d9d2b1425187728e8a245d58ca" translate="yes" xml:space="preserve">
          <source>The optional &amp;lsquo;titles&amp;rsquo; value should be a list of titles of the same length as &amp;lsquo;names&amp;rsquo;, see &lt;a href=&quot;#titles&quot;&gt;Field Titles&lt;/a&gt; below.</source>
          <target state="translated">オプションの「titles」値は、「names」と同じ長さのタイトルのリストである必要があります。以下の「&lt;a href=&quot;#titles&quot;&gt;フィールドタイトル&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="0af8d6f274a699b745815e9b76bdbe8e97f9313c" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;code&gt;comments&lt;/code&gt; is used to define a character string that marks the beginning of a comment. By default, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; assumes &lt;code&gt;comments='#'&lt;/code&gt;. The comment marker may occur anywhere on the line. Any character present after the comment marker(s) is simply ignored:</source>
          <target state="translated">オプションの引数 &lt;code&gt;comments&lt;/code&gt; は、コメントの開始を示す文字列を定義するために使用されます。デフォルトでは、&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;comments='#'&lt;/code&gt; を想定しています。コメントマーカーは、行のどこにでも配置できます。コメントマーカーの後に存在する文字はすべて無視されます。</target>
        </trans-unit>
        <trans-unit id="94b62b6ba781a5ddd569b811fe572b78fe805c1d" translate="yes" xml:space="preserve">
          <source>The optional output arguments can be used to help you save memory for large calculations. If your arrays are large, complicated expressions can take longer than absolutely necessary due to the creation and (later) destruction of temporary calculation spaces. For example, the expression &lt;code&gt;G = a * b + c&lt;/code&gt; is equivalent to &lt;code&gt;t1 = A * B; G = T1 + C; del t1&lt;/code&gt;. It will be more quickly executed as &lt;code&gt;G = A * B; add(G, C, G)&lt;/code&gt; which is the same as &lt;code&gt;G = A * B; G += C&lt;/code&gt;.</source>
          <target state="translated">オプションの出力引数を使用すると、大規模な計算でメモリを節約できます。配列が大きい場合、複雑な式は、一時計算スペースの作成と（後で）破棄のために、絶対に必要な時間よりも長くかかることがあります。たとえば、式 &lt;code&gt;G = a * b + c&lt;/code&gt; は &lt;code&gt;t1 = A * B; G = T1 + C; del t1&lt;/code&gt; と同等です。G = T1 + C; デルt1。 &lt;code&gt;G = A * B; add(G, C, G)&lt;/code&gt; ように、より速く実行されます。add（G、C、G）これは &lt;code&gt;G = A * B; G += C&lt;/code&gt; と同じです。G + = C。</target>
        </trans-unit>
        <trans-unit id="7b2c78f4cc1b5de9c0c210654a3400e8183ebd83" translate="yes" xml:space="preserve">
          <source>The optional third element &lt;em&gt;field_shape&lt;/em&gt; contains the shape if this field represents an array of the data-type in the second element. Note that a 3-tuple with a third argument equal to 1 is equivalent to a 2-tuple.</source>
          <target state="translated">このフィールドが2番目の要素のデータ型の配列を表す場合、オプションの3番目の要素&lt;em&gt;field_shape&lt;/em&gt;には形状が含まれます。3番目の引数が1の3タプルは2タプルと同等であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="14b215bf63d4b571de67dcde3ac908fb35772330" translate="yes" xml:space="preserve">
          <source>The options &amp;lsquo;reduced&amp;rsquo;, &amp;lsquo;complete, and &amp;lsquo;raw&amp;rsquo; are new in numpy 1.8, see the notes for more information. The default is &amp;lsquo;reduced&amp;rsquo;, and to maintain backward compatibility with earlier versions of numpy both it and the old default &amp;lsquo;full&amp;rsquo; can be omitted. Note that array h returned in &amp;lsquo;raw&amp;rsquo; mode is transposed for calling Fortran. The &amp;lsquo;economic&amp;rsquo; mode is deprecated. The modes &amp;lsquo;full&amp;rsquo; and &amp;lsquo;economic&amp;rsquo; may be passed using only the first letter for backwards compatibility, but all others must be spelled out. See the Notes for more explanation.</source>
          <target state="translated">オプション 'reduced'、 'complete、' raw 'はnumpy 1.8で新しく追加されました。詳細についてはノートを参照してください。デフォルトは 'reduced'であり、以前のバージョンのnumpyとの下位互換性を維持するために、それと古いデフォルトの 'full'の両方を省略できます。「raw」モードで返された配列hは、Fortranを呼び出すために転置されることに注意してください。'economic'モードは非推奨です。後方互換性のために、「full」モードと「economic」モードは最初の文字のみを使用して渡すことができますが、他のすべてのモードは指定する必要があります。詳細については、注を参照してください。</target>
        </trans-unit>
        <trans-unit id="6d9b2da0a0a7c1206d894d6f0fcce902e86c7458" translate="yes" xml:space="preserve">
          <source>The order in which the array data is stored in memory: &amp;lsquo;C&amp;rsquo; -&amp;gt; &amp;ldquo;row major&amp;rdquo; order (the default), &amp;lsquo;F&amp;rsquo; -&amp;gt; &amp;ldquo;column major&amp;rdquo; (Fortran) order.</source>
          <target state="translated">配列データがメモリに格納される順序： 'C'-&amp;gt;「行優先」順序（デフォルト）、「F」-&amp;gt;「列優先」（Fortran）順序。</target>
        </trans-unit>
        <trans-unit id="68929adbb771e5f9d5347a88dc7ca873ea9321af" translate="yes" xml:space="preserve">
          <source>The order in which they are preferred is determined by &lt;code&gt;NPY_BLAS_ILP64_ORDER&lt;/code&gt; and &lt;code&gt;NPY_LAPACK_ILP64_ORDER&lt;/code&gt; environment variables. The default value is &lt;code&gt;openblas64_,openblas_ilp64&lt;/code&gt;.</source>
          <target state="translated">それらが優先される &lt;code&gt;NPY_BLAS_ILP64_ORDER&lt;/code&gt; は、NPY_BLAS_ILP64_ORDERおよび &lt;code&gt;NPY_LAPACK_ILP64_ORDER&lt;/code&gt; 環境変数によって決定されます。デフォルト値は &lt;code&gt;openblas64_,openblas_ilp64&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e18fbd568fd064406da176fc5bb0b9a80dc8baa0" translate="yes" xml:space="preserve">
          <source>The order of &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt; doesn&amp;rsquo;t matter.</source>
          <target state="translated">&lt;code&gt;v1&lt;/code&gt; と &lt;code&gt;v2&lt;/code&gt; の順序は関係ありません。</target>
        </trans-unit>
        <trans-unit id="64c7894d7cfcaaec3478ec1e4aaf0c4a01f8cc6f" translate="yes" xml:space="preserve">
          <source>The order of sub-arrays is changed but their contents remains the same.</source>
          <target state="translated">サブ配列の順序は変更されますが、その内容は変わりません。</target>
        </trans-unit>
        <trans-unit id="1d4e69a308201075218d8a094df1f5f1f4d37aad" translate="yes" xml:space="preserve">
          <source>The order of the elements in the array resulting from ravel() is normally &amp;ldquo;C-style&amp;rdquo;, that is, the rightmost index &amp;ldquo;changes the fastest&amp;rdquo;, so the element after a[0,0] is a[0,1]. If the array is reshaped to some other shape, again the array is treated as &amp;ldquo;C-style&amp;rdquo;. NumPy normally creates arrays stored in this order, so ravel() will usually not need to copy its argument, but if the array was made by taking slices of another array or created with unusual options, it may need to be copied. The functions ravel() and reshape() can also be instructed, using an optional argument, to use FORTRAN-style arrays, in which the leftmost index changes the fastest.</source>
          <target state="translated">ravel（）から得られる配列内の要素の順序は通常「Cスタイル」です。つまり、右端のインデックスが「最も速く変化する」ため、a [0,0]の後の要素はa [0,1]になります。 。配列が他の形状に再形成された場合も、配列は「Cスタイル」として扱われます。 NumPyは通常、この順序で格納された配列を作成するため、ravel（）は通常、引数をコピーする必要はありませんが、配列が別の配列のスライスを取得して作成された場合、または通常とは異なるオプションで作成された場合は、コピーが必要になる場合があります。関数ravel（）およびreshape（）は、オプションの引数を使用して、左端のインデックスが最も速く変更されるFORTRANスタイルの配列を使用するように指示することもできます。</target>
        </trans-unit>
        <trans-unit id="1a665b347299d28c9a4225cbaa35961f7257fdf3" translate="yes" xml:space="preserve">
          <source>The order of the input bits. &amp;lsquo;big&amp;rsquo; will mimic bin(val), &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011 =&amp;gt; ``, 'little' will
reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt;. Defaults to &amp;lsquo;big&amp;rsquo;.</source>
          <target state="translated">入力ビットの順序。'big'はbin（val）を模倣し、 &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011 =&amp;gt; ``, 'little' will reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt; 。デフォルトは「big」です。</target>
        </trans-unit>
        <trans-unit id="6a7badf2486ba3d65f6d452504aadca6f59aa17f" translate="yes" xml:space="preserve">
          <source>The order of the input bits. &amp;lsquo;big&amp;rsquo; will mimic bin(val), &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011&lt;/code&gt;, &amp;lsquo;little&amp;rsquo; will reverse the order so &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt;. Defaults to &amp;lsquo;big&amp;rsquo;.</source>
          <target state="translated">入力ビットの順序。'big'はbin（val）、 &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011&lt;/code&gt; 、 'little'は順序を逆にするので &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt; 1、1、0、0 、 0、0、0、0] =&amp;gt; 3。デフォルトは「big」です。</target>
        </trans-unit>
        <trans-unit id="c023a0582544690f15510a2492956e0e66cdc058" translate="yes" xml:space="preserve">
          <source>The order of the returned bits. &amp;lsquo;big&amp;rsquo; will mimic bin(val), &lt;code&gt;3 = 0b00000011 =&amp;gt; [0, 0, 0, 0, 0, 0, 1, 1]&lt;/code&gt;, &amp;lsquo;little&amp;rsquo; will reverse the order to &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0]&lt;/code&gt;. Defaults to &amp;lsquo;big&amp;rsquo;.</source>
          <target state="translated">返されるビットの順序。'big'はbin（val）を模倣します、 &lt;code&gt;3 = 0b00000011 =&amp;gt; [0, 0, 0, 0, 0, 0, 1, 1]&lt;/code&gt; 、 'little'は[1、1、0、0 &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0]&lt;/code&gt; 。デフォルトは「big」です。</target>
        </trans-unit>
        <trans-unit id="d31a5b9999b59b34b6ad9fdaccda217e19238ad4" translate="yes" xml:space="preserve">
          <source>The order or degree of the polynomial</source>
          <target state="translated">多項式の次数または次数</target>
        </trans-unit>
        <trans-unit id="eea06a8f88d6f17386cd112eab18c7ac9fc8e799" translate="yes" xml:space="preserve">
          <source>The orientation of &lt;code&gt;c&lt;/code&gt; can be changed using the &lt;code&gt;axisc&lt;/code&gt; keyword.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; の方向は、 &lt;code&gt;axisc&lt;/code&gt; キーワードを使用して変更できます。</target>
        </trans-unit>
        <trans-unit id="f6895b0ec7c91fa01ba724c0454c0ecbf9046ad1" translate="yes" xml:space="preserve">
          <source>The original contents of the &lt;code&gt;intent(in)&lt;/code&gt; argument may be altered by the Fortran/C function. F2PY creates an optional argument &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; with the default value &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;intent(in)&lt;/code&gt; 引数の元の内容は、Fortran / C関数によって変更される場合があります。F2PYは、オプションの引数 &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; をデフォルト値 &lt;code&gt;1&lt;/code&gt; で作成します。</target>
        </trans-unit>
        <trans-unit id="5b2e34a61895054c86583de1c9f28efb1bf046c4" translate="yes" xml:space="preserve">
          <source>The other class must have the &lt;code&gt;coef&lt;/code&gt; attribute.</source>
          <target state="translated">他のクラスには &lt;code&gt;coef&lt;/code&gt; 属性が必要です。</target>
        </trans-unit>
        <trans-unit id="beffd1aec86565c0ed7e85fa9756b03e99dc1093" translate="yes" xml:space="preserve">
          <source>The other class must have the &lt;code&gt;domain&lt;/code&gt; attribute.</source>
          <target state="translated">他のクラスには &lt;code&gt;domain&lt;/code&gt; 属性が必要です。</target>
        </trans-unit>
        <trans-unit id="c7b5b660115b8d1bff6ffdc35071c1bc977b44f5" translate="yes" xml:space="preserve">
          <source>The other class must have the &lt;code&gt;window&lt;/code&gt; attribute.</source>
          <target state="translated">他のクラスには &lt;code&gt;window&lt;/code&gt; 属性が必要です。</target>
        </trans-unit>
        <trans-unit id="208270eb05b02b535197d000879d544f3abebcde" translate="yes" xml:space="preserve">
          <source>The out argument specifies where to place the result. If out is NULL, then the output array is created, otherwise the output is placed in out which must be the correct size and type. A new reference to the output array is always returned even when out is not NULL. The caller of the routine has the responsibility to &lt;code&gt;DECREF&lt;/code&gt; out if not NULL or a memory-leak will occur.</source>
          <target state="translated">out引数は、結果を配置する場所を指定します。 outがNULLの場合、出力配列が作成されます。それ以外の場合、出力はoutに配置され、正しいサイズとタイプでなければなりません。 outがNULLでない場合でも、出力配列への新しい参照は常に返されます。ルーチンの呼び出し元は、NULLでない場合、またはメモリリークが発生する場合、 &lt;code&gt;DECREF&lt;/code&gt; を実行する責任があります。</target>
        </trans-unit>
        <trans-unit id="b1eb4436c2a0a0542bae9d8ee0693add2fca6bb8" translate="yes" xml:space="preserve">
          <source>The out argument specifies where to place the result. If out is NULL, then the output array is created, otherwise the output is placed in out which must be the correct size and type. A new reference to the output array is always returned even when out is not NULL. The caller of the routine has the responsibility to &lt;code&gt;Py_DECREF&lt;/code&gt; out if not NULL or a memory-leak will occur.</source>
          <target state="translated">out引数は、結果を配置する場所を指定します。 outがNULLの場合、出力配列が作成されます。それ以外の場合、出力はoutに配置され、正しいサイズとタイプである必要があります。 outがNULLでない場合でも、出力配列への新しい参照が常に返されます。ルーチンの呼び出し元は、NULLでない場合、またはメモリリークが発生した場合に、 &lt;code&gt;Py_DECREF&lt;/code&gt; を出力する責任があります。</target>
        </trans-unit>
        <trans-unit id="d41934f2889307f51eefc25e7532b745714248c8" translate="yes" xml:space="preserve">
          <source>The outer product</source>
          <target state="translated">外装品</target>
        </trans-unit>
        <trans-unit id="eaacd893fa91168722bb422e1bd4cfd1660e87de" translate="yes" xml:space="preserve">
          <source>The output arguments (if any) are then processed and any missing return arrays are constructed. If any provided output array doesn&amp;rsquo;t have the correct type (or is mis-aligned) and is smaller than the buffer size, then a new output array is constructed with the special &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag set. At the end of the function, &lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called so that its contents will be copied back into the output array. Iterators for the output arguments are then processed.</source>
          <target state="translated">次に、出力引数（存在する場合）が処理され、欠落している戻り配列が作成されます。提供された出力配列のいずれかが正しいタイプを持たない（または整列が間違っている）場合、バッファーサイズよりも小さい場合、新しい出力配列は特別な &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; フラグセットを使用して構築されます。関数の最後で&lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;が呼び出され、その内容が出力配列にコピーされます。次に、出力引数の反復子が処理されます。</target>
        </trans-unit>
        <trans-unit id="02fbb66d65f083fd2d9e7a738b5f72feedd2f131" translate="yes" xml:space="preserve">
          <source>The output arguments (if any) are then processed and any missing return arrays are constructed. If any provided output array doesn&amp;rsquo;t have the correct type (or is mis-aligned) and is smaller than the buffer size, then a new output array is constructed with the special &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag set. At the end of the function, &lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called so that its contents will be copied back into the output array. Iterators for the output arguments are then processed.</source>
          <target state="translated">次に、出力引数（存在する場合）が処理され、欠落している戻り配列が作成されます。提供された出力配列のタイプが正しくなく（または位置がずれて）、バッファーサイズよりも小さい場合は、特別な &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; フラグを設定して新しい出力配列が作成されます。関数の最後に、&lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;が呼び出され、その内容が出力配列にコピーされます。次に、出力引数のイテレータが処理されます。</target>
        </trans-unit>
        <trans-unit id="f268497aae1cce8ff8c25da79f231196a245eaac" translate="yes" xml:space="preserve">
          <source>The output array is masked where all the values along the given axis are masked: if the output would have been a scalar and that all the values are masked, then the output is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指定された軸に沿ったすべての値がマスクされる場所で出力配列がマスクされます。出力がスカラーであり、すべての値がマスクされる場合、出力は&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="7cdd30a82881324958754cfed2ed5012e49b5922" translate="yes" xml:space="preserve">
          <source>The output array of type Boolean with the same shape as a and b.</source>
          <target state="translated">a,b と同じ形をした Boolean 型の出力配列。</target>
        </trans-unit>
        <trans-unit id="f55976ddc6094b99d81ee9f07a8be602a3926550" translate="yes" xml:space="preserve">
          <source>The output array, containing the part of the content of &lt;code&gt;file&lt;/code&gt; that was matched by &lt;code&gt;regexp&lt;/code&gt;. &lt;code&gt;output&lt;/code&gt; is always a structured array.</source>
          <target state="translated">&lt;code&gt;regexp&lt;/code&gt; で一致した &lt;code&gt;file&lt;/code&gt; のコンテンツの一部を含む出力配列。 &lt;code&gt;output&lt;/code&gt; は常に構造化配列です。</target>
        </trans-unit>
        <trans-unit id="5aa2c29b27cf9fdf4a29996c1b8c28730e8e0aea" translate="yes" xml:space="preserve">
          <source>The output array, element-wise Heaviside step function of &lt;code&gt;x1&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; の要素ごとのヘビサイドステップ関数の出力配列。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="70719ba0effebe3bb3aa417f56a4a6c01822a6e7" translate="yes" xml:space="preserve">
          <source>The output array.</source>
          <target state="translated">出力配列です。</target>
        </trans-unit>
        <trans-unit id="09c7e58e3fd89577e8de606a001975293d749592" translate="yes" xml:space="preserve">
          <source>The output array. The number of dimensions is the same as &lt;code&gt;a&lt;/code&gt;, but the shape can be different. This depends on whether &lt;code&gt;func&lt;/code&gt; changes the shape of its output with respect to its input.</source>
          <target state="translated">出力配列。次元数は同じであるが、形状が異なっていてもよいです。これは、 &lt;code&gt;func&lt;/code&gt; が入力に対して出力の形状を変更するかどうかによって異なります。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d041e4d25d02f826463aa1a16a95e06fcf896235" translate="yes" xml:space="preserve">
          <source>The output array. The shape of &lt;code&gt;out&lt;/code&gt; is identical to the shape of &lt;code&gt;arr&lt;/code&gt;, except along the &lt;code&gt;axis&lt;/code&gt; dimension. This axis is removed, and replaced with new dimensions equal to the shape of the return value of &lt;code&gt;func1d&lt;/code&gt;. So if &lt;code&gt;func1d&lt;/code&gt; returns a scalar &lt;code&gt;out&lt;/code&gt; will have one fewer dimensions than &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">出力配列。 &lt;code&gt;out&lt;/code&gt; の形状は、 &lt;code&gt;axis&lt;/code&gt; 次元に沿っていることを除いて、 &lt;code&gt;arr&lt;/code&gt; の形状と同じです。この軸は削除され、 &lt;code&gt;func1d&lt;/code&gt; の戻り値の形状に等しい新しい次元に置き換えられます。あれば &lt;code&gt;func1d&lt;/code&gt; はスカラーを返す &lt;code&gt;out&lt;/code&gt; より1つの少ない寸法があります &lt;code&gt;arr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8620240fb2ec2168fe1488fc7c50d1b1766a372e" translate="yes" xml:space="preserve">
          <source>The output at position m is the m-th element of the array in &lt;code&gt;choicelist&lt;/code&gt; where the m-th element of the corresponding array in &lt;code&gt;condlist&lt;/code&gt; is True.</source>
          <target state="translated">位置mの出力は、 &lt;code&gt;choicelist&lt;/code&gt; の配列のm番目の要素で、 &lt;code&gt;condlist&lt;/code&gt; の対応する配列のm番目の要素はTrueです。</target>
        </trans-unit>
        <trans-unit id="0043f09ea13cb649da8f2d6d2895f2519551c732" translate="yes" xml:space="preserve">
          <source>The output data type. It must be specified as either a string of typecode characters or a list of data type specifiers. There should be one data type specifier for each output.</source>
          <target state="translated">出力データ型。これは、タイプコード文字の文字列またはデータ型指定子のリストのいずれかで指定する必要があります。各出力に対して1つのデータ型指定子を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="abacf3469f99309139bddd0efe494fc74e079f06" translate="yes" xml:space="preserve">
          <source>The output has the same shape as the input and each 1-D loop operates over</source>
          <target state="translated">出力は入力と同じ形状をしており、各1次元ループはオーバーで動作します。</target>
        </trans-unit>
        <trans-unit id="63770907dcff4eb26363f61fd3098799f014e4b4" translate="yes" xml:space="preserve">
          <source>The output is a &lt;a href=&quot;https://docs.python.org/dev/tutorial/datastructures.html#tut-tuples&quot;&gt;tuple&lt;/a&gt; with three elements, which means that this is a three-dimensional array. In fact, since this is a color image, and we have used the &lt;code&gt;imread&lt;/code&gt; function to read it, the data is organized in three 2D arrays, representing color channels (in this case, red, green and blue - RGB). You can see this by looking at the shape above: it indicates that we have an array of 3 matrices, each having shape 768x1024.</source>
          <target state="translated">出力は3つの要素を持つ&lt;a href=&quot;https://docs.python.org/dev/tutorial/datastructures.html#tut-tuples&quot;&gt;タプル&lt;/a&gt;です。これは、これが3次元配列であることを意味します。実際、これはカラー画像であり、 &lt;code&gt;imread&lt;/code&gt; 関数を使用して読み取ったため、データは3つの2D配列に編成され、カラーチャネル（この場合は赤、緑、青-RGB）を表します。上記の形状を見ると、これを確認できます。これは、それぞれが768x1024の形状を持つ3つの行列の配列があることを示しています。</target>
        </trans-unit>
        <trans-unit id="2e90afe5c10bc3b541c84caa9141acf978817abb" translate="yes" xml:space="preserve">
          <source>The output is left-padded by the length of the prefix string, and wrapping is forced at the column &lt;code&gt;max_line_width - len(suffix)&lt;/code&gt;. It should be noted that the content of prefix and suffix strings are not included in the output.</source>
          <target state="translated">出力はプレフィックス文字列の長さで左に埋め込まれ、折り返しは列 &lt;code&gt;max_line_width - len(suffix)&lt;/code&gt; 強制されます。接頭辞と接尾辞の文字列の内容は出力に含まれないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="e11dba8a2e35e34ff280ff12d3cc6c9a772a17ab" translate="yes" xml:space="preserve">
          <source>The output is sorted along the key.</source>
          <target state="translated">出力はキーに沿ってソートされます。</target>
        </trans-unit>
        <trans-unit id="8da09507a5558a4c68826bbfbad5a55048ee486a" translate="yes" xml:space="preserve">
          <source>The output is the same shape and type as x and is found by calling the functions in &lt;code&gt;funclist&lt;/code&gt; on the appropriate portions of &lt;code&gt;x&lt;/code&gt;, as defined by the boolean arrays in &lt;code&gt;condlist&lt;/code&gt;. Portions not covered by any condition have a default value of 0.</source>
          <target state="translated">出力は、xと同じ形状およびタイプとの関数を呼び出すことによって見出される &lt;code&gt;funclist&lt;/code&gt; の適切な部分に &lt;code&gt;x&lt;/code&gt; のboolean配列によって定義されるように、 &lt;code&gt;condlist&lt;/code&gt; 。どの条件にも該当しない部分のデフォルト値は0です。</target>
        </trans-unit>
        <trans-unit id="f50dbb1c407bc1480ac12746928854d5651c29cc" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;argwhere&lt;/code&gt; is not suitable for indexing arrays. For this purpose use &lt;code&gt;nonzero(a)&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;argwhere&lt;/code&gt; の出力は、配列のインデックス付けには適していません。この目的には &lt;code&gt;nonzero(a)&lt;/code&gt; 代わりにnonzero（a）を使用してください。</target>
        </trans-unit>
        <trans-unit id="9cad5509a2704fc8189ddac84d202e22c4e895ee" translate="yes" xml:space="preserve">
          <source>The output of the ufunc (and its methods) is not necessarily an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if all input arguments are not &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. Indeed, if any input defines an &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, control will be passed completely to that function, i.e., the ufunc is &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/ufuncs.overrides&quot;&gt;overridden&lt;/a&gt;.</source>
          <target state="translated">すべての入力引数が&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; s&lt;/a&gt;ではない場合、ufunc（およびそのメソッド）の出力は必ずしもndarrayであるとは限りませ&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt;。実際、入力が&lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;メソッドを定義している場合、制御はその関数に完全に渡されます。つまり、ufuncは&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/ufuncs.overrides&quot;&gt;オーバーライドされ&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="6599e81d2d214234687adf6fb69ac2c773f47b7b" translate="yes" xml:space="preserve">
          <source>The output of the ufunc (and its methods) is not necessarily an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if all input arguments are not &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. Indeed, if any input defines an &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, control will be passed completely to that function, i.e., the ufunc is &lt;a href=&quot;https://numpy.org/doc/1.19/reference/ufuncs.overrides&quot;&gt;overridden&lt;/a&gt;.</source>
          <target state="translated">すべての入力引数が&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;でない場合、ufunc（およびそのメソッド）の出力は必ずしもndarrayである必要はありませ&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt;。実際、入力が&lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;メソッドを定義している場合、制御はその関数に完全に渡されます。つまり、ufuncは&lt;a href=&quot;https://numpy.org/doc/1.19/reference/ufuncs.overrides&quot;&gt;オーバーライドされ&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="dffd3ba3dd5dfca8ee836a2b9bb97cc8318013a0" translate="yes" xml:space="preserve">
          <source>The output shape in the dense case is obtained by prepending the number of dimensions in front of the tuple of dimensions, i.e. if &lt;code&gt;dimensions&lt;/code&gt; is a tuple &lt;code&gt;(r0, ..., rN-1)&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the output shape is &lt;code&gt;(N, r0, ..., rN-1)&lt;/code&gt;.</source>
          <target state="translated">密な場合の出力形状は、次元のタプルの前に次元数を付加することによって得られます。つまり、 &lt;code&gt;dimensions&lt;/code&gt; が長さ &lt;code&gt;N&lt;/code&gt; のタプル &lt;code&gt;(r0, ..., rN-1)&lt;/code&gt; である場合、出力形状は &lt;code&gt;(N, r0, ..., rN-1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b58a2d32420f4e758be11c792f006660e86c89ee" translate="yes" xml:space="preserve">
          <source>The output type is determined by evaluating the first element of the input, unless it is specified:</source>
          <target state="translated">出力タイプは、指定されていない限り、入力の最初の要素を評価することで決定されます。</target>
        </trans-unit>
        <trans-unit id="a8b2e53b333d791e589c426b13ebb877541abc09" translate="yes" xml:space="preserve">
          <source>The output, analogously to &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, contains the term for zero frequency in the low-order corner of all axes, the positive frequency terms in the first half of all axes, the term for the Nyquist frequency in the middle of all axes and the negative frequency terms in the second half of all axes, in order of decreasingly negative frequency.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;と同様に、出力には、すべての軸の低次コーナーのゼロ周波数の項、すべての軸の前半の正の周波数項、すべての軸の中央のナイキスト周波数の項、および負の項が含まれます。すべての軸の後半にある周波数の項。負の周波数から順に減少します。</target>
        </trans-unit>
        <trans-unit id="2e04271603cd70e84ef996c185fb1fb3c75eb84c" translate="yes" xml:space="preserve">
          <source>The output, analogously to &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, contains the term for zero frequency in the low-order corner of the transformed axes, the positive frequency terms in the first half of these axes, the term for the Nyquist frequency in the middle of the axes and the negative frequency terms in the second half of the axes, in order of decreasingly negative frequency.</source>
          <target state="translated">出力には、&lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;と同様に、変換された軸の低次コーナーのゼロ周波数の項、これらの軸の前半の正の周波数項、軸の中央のナイキスト周波数の項、および負の周波数の順に、軸の後半の負の周波数の項。</target>
        </trans-unit>
        <trans-unit id="ed35a4029927607a6ec8e44ffef5c4477bb8a981" translate="yes" xml:space="preserve">
          <source>The package ensures that masked entries are not used in computations.</source>
          <target state="translated">このパッケージは、マスクされたエントリが計算で使用されないことを保証します。</target>
        </trans-unit>
        <trans-unit id="f6f78aee1988dc701d01aad263b1da5166d3a53f" translate="yes" xml:space="preserve">
          <source>The padding character to use (default is space).</source>
          <target state="translated">使用するパディング文字(デフォルトはスペース)。</target>
        </trans-unit>
        <trans-unit id="7e8fe55b063cd4163ba4aeac13d68612e9f5d53b" translate="yes" xml:space="preserve">
          <source>The padding function, if used, should modify a rank 1 array in-place. It has the following signature:</source>
          <target state="translated">padding関数が使用されている場合,ランク1の配列をその場で修正しなければなりません.これは次のようなシグネチャを持っています。</target>
        </trans-unit>
        <trans-unit id="91842f7bb32c0502ac19c7e4e8ff23d234b3cdfd" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;oa_ndim&lt;/code&gt;, when not zero or -1, specifies the number of dimensions that will be iterated with customized broadcasting. If it is provided, &lt;code&gt;op_axes&lt;/code&gt; must and &lt;code&gt;itershape&lt;/code&gt; can also be provided. The &lt;code&gt;op_axes&lt;/code&gt; parameter let you control in detail how the axes of the operand arrays get matched together and iterated. In &lt;code&gt;op_axes&lt;/code&gt;, you must provide an array of &lt;code&gt;nop&lt;/code&gt; pointers to &lt;code&gt;oa_ndim&lt;/code&gt;-sized arrays of type &lt;code&gt;npy_intp&lt;/code&gt;. If an entry in &lt;code&gt;op_axes&lt;/code&gt; is NULL, normal broadcasting rules will apply. In &lt;code&gt;op_axes[j][i]&lt;/code&gt; is stored either a valid axis of &lt;code&gt;op[j]&lt;/code&gt;, or -1 which means &lt;code&gt;newaxis&lt;/code&gt;. Within each &lt;code&gt;op_axes[j]&lt;/code&gt; array, axes may not be repeated. The following example is how normal broadcasting applies to a 3-D array, a 2-D array, a 1-D array and a scalar.</source>
          <target state="translated">パラメータ &lt;code&gt;oa_ndim&lt;/code&gt; は、ゼロまたは-1でない場合、カスタマイズされたブロードキャストで反復される次元の数を指定します。提供される場合、 &lt;code&gt;op_axes&lt;/code&gt; は必須であり、 &lt;code&gt;itershape&lt;/code&gt; も提供できます。 &lt;code&gt;op_axes&lt;/code&gt; のパラメータを使用すると、オペランドアレイの軸が一緒にマッチし、繰り返し取得する方法を詳細に制御できます。では &lt;code&gt;op_axes&lt;/code&gt; 、あなたはの配列を提供しなければならない &lt;code&gt;nop&lt;/code&gt; へのポインタを &lt;code&gt;oa_ndim&lt;/code&gt; 型の-sized配列 &lt;code&gt;npy_intp&lt;/code&gt; を。 &lt;code&gt;op_axes&lt;/code&gt; のエントリがNULLの場合、通常のブロードキャストルールが適用されます。 &lt;code&gt;op_axes[j][i]&lt;/code&gt; の有効軸のいずれかの記憶されている &lt;code&gt;op[j]&lt;/code&gt; 、または-1れる手段 &lt;code&gt;newaxis&lt;/code&gt; 。各 &lt;code&gt;op_axes[j]&lt;/code&gt; 配列内では、軸を繰り返すことはできません。次の例は、通常のブロードキャストが3次元配列、2次元配列、1次元配列、およびスカラーにどのように適用されるかを示しています。</target>
        </trans-unit>
        <trans-unit id="6f24110e4501ed427c7d67150722a36e47c9eb87" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;x&lt;/code&gt; is converted to an array only if it is a tuple or a list, otherwise it is treated as a scalar. In either case, either &lt;code&gt;x&lt;/code&gt; or its elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">パラメーター &lt;code&gt;x&lt;/code&gt; は、タプルまたはリストの場合にのみ配列に変換され、それ以外の場合はスカラーとして扱われます。どちらの場合でも、 &lt;code&gt;x&lt;/code&gt; またはその要素は、それ自体と &lt;code&gt;c&lt;/code&gt; の要素の両方で乗算と加算をサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="81b1fc95a0e75fbef51d185592084c9ff4aaba4c" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;x&lt;/code&gt; is converted to an array only if it is a tuple or a list, otherwise it is treated as a scalar. In either case, either &lt;code&gt;x&lt;/code&gt; or its elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">パラメーター &lt;code&gt;x&lt;/code&gt; は、タプルまたはリストの場合にのみ配列に変換され、それ以外の場合はスカラーとして扱われます。どちらの場合でも、 &lt;code&gt;x&lt;/code&gt; またはその要素は、それ自体と &lt;code&gt;r&lt;/code&gt; の要素の両方で乗算と加算をサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="fed3e36a151b3d1051d8c0d0e63efcd30243f871" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;dtype&lt;/em&gt; specifies the data type over which a reduction operation (like summing) should take place. The default reduce data type is the same as the data type of &lt;em&gt;self&lt;/em&gt;. To avoid overflow, it can be useful to perform the reduction using a larger data type.</source>
          <target state="translated">パラメータ&lt;em&gt;dtype&lt;/em&gt;は、（合計などの）縮約操作を実行するデータ型を指定します。デフォルトのreduceデータ型は、&lt;em&gt;selfの&lt;/em&gt;データ型と同じです。オーバーフローを回避するには、より大きなデータ型を使用して削減を実行すると便利です。</target>
        </trans-unit>
        <trans-unit id="5047704927c94b8b6586c636aa20a6789550df01" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars and they must have the same shape after conversion. In either case, either &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">パラメーター &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は、タプルまたはリストの場合にのみ配列に変換されます。それ以外の場合は、スカラーとして扱われ、変換後の形状は同じでなければなりません。どちらの場合でも、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; またはそれらの要素は、自身と &lt;code&gt;c&lt;/code&gt; の要素の両方で乗算と加算をサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="ab30d7deae7ce08d9cafc57f0a0d9da22b443d75" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars. In either case, either &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">パラメーター &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; は、タプルまたはリストの場合にのみ配列に変換されます。それ以外の場合は、スカラーとして扱われます。どちらの場合でも、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; またはそれらの要素は、自身と &lt;code&gt;c&lt;/code&gt; の要素の両方で乗算と加算をサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="dea737cd6cbb9eb4fabc09fa179fafbb398a4ba4" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars and they must have the same shape after conversion. In either case, either &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">パラメーター &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、および &lt;code&gt;z&lt;/code&gt; は、タプルまたはリストの場合にのみ配列に変換されます。それ以外の場合は、スカラーとして扱われ、変換後は同じ形状でなければなりません。どちらの場合でも、 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、および &lt;code&gt;z&lt;/code&gt; またはそれらの要素は、それ自体と &lt;code&gt;c&lt;/code&gt; の要素の両方で乗算と加算をサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="942247face18dfe9d547bf9f163892321bfcd347" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars. In either case, either &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">パラメーター &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、および &lt;code&gt;z&lt;/code&gt; は、タプルまたはリストの場合にのみ配列に変換され、それ以外の場合はスカラーとして扱われます。どちらの場合でも、 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、および &lt;code&gt;z&lt;/code&gt; またはそれらの要素は、それ自体と &lt;code&gt;c&lt;/code&gt; の要素の両方で乗算と加算をサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="2f059fed0e631d6e93c76ef517cee1b4493e82a4" translate="yes" xml:space="preserve">
          <source>The path of the template, relatively to the current package path.</source>
          <target state="translated">テンプレートのパスを、現在のパッケージのパスと相対的に比較したものです。</target>
        </trans-unit>
        <trans-unit id="a3bed8bc2ca97f198b6eb9b3e908d4ed3c7c443d" translate="yes" xml:space="preserve">
          <source>The path to the file for which the doctests are run.</source>
          <target state="translated">Doctests を実行するファイルへのパスです。</target>
        </trans-unit>
        <trans-unit id="decb24fde62e2b923b5a976163e8c054497d68bf" translate="yes" xml:space="preserve">
          <source>The pattern for using nested iterators is as follows.</source>
          <target state="translated">ネストされたイテレータを使用するパターンは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="9db61e58e4763f03cd16195e5ed8a40825c96961" translate="yes" xml:space="preserve">
          <source>The pattern is similar for other, more complex generators. The normal performance of the legacy &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; generator is much lower than the other since it uses the Box-Muller transformation rather than the Ziggurat generator. The performance gap for Exponentials is also large due to the cost of computing the log function to invert the CDF. The column labeled MT19973 is used the same 32-bit generator as &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; but produces random values using &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このパターンは、他のより複雑なジェネレーターでも同様です。従来の&lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;ジェネレーターの通常のパフォーマンスは、ZigguratジェネレーターではなくBox-Muller変換を使用するため、他のジェネレーターよりもはるかに低くなります。 CDFを反転するための対数関数の計算コストのため、指数関数のパフォーマンスギャップも大きくなります。 MT19973標識された列は、同じ32ビットの発生に使用される&lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; し&lt;/a&gt;なく用いたランダム値生成&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82eacc753e4241f8676568f6609cbd6d30cfc9ba" translate="yes" xml:space="preserve">
          <source>The pattern is similar for other, more complex generators. The normal performance of the legacy &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; generator is much lower than the other since it uses the Box-Muller transformation rather than the Ziggurat generator. The performance gap for Exponentials is also large due to the cost of computing the log function to invert the CDF. The column labeled MT19973 is used the same 32-bit generator as &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; but produces random values using &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このパターンは、他のより複雑なジェネレーターでも同様です。レガシー&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;ジェネレーターの通常のパフォーマンスは、ZigguratジェネレーターではなくBox-Muller変換を使用するため、他のジェネレーターよりもはるかに低くなります。指数関数のパフォーマンスギャップは、CDFを反転するログ関数を計算するコストのためにも大きくなります。MT19973というラベルの列は、RandomStateと同じ32ビットジェネレーターを&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;いますが、&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;を使用してランダムな値を生成しています。</target>
        </trans-unit>
        <trans-unit id="5f948cd9daa190278b24b7616c4acaf6e82e63af" translate="yes" xml:space="preserve">
          <source>The payment is computed by solving the equation:</source>
          <target state="translated">支払いは式を解くことで計算されます。</target>
        </trans-unit>
        <trans-unit id="7c38a52dfb1124cf95fad23836990fb2bf0bbca3" translate="yes" xml:space="preserve">
          <source>The percentage of waves larger than 3 meters is:</source>
          <target state="translated">m以上の波の割合は</target>
        </trans-unit>
        <trans-unit id="bf26c5d0de790b76d482846fdfc7d5a573504f09" translate="yes" xml:space="preserve">
          <source>The performance of 64-bit generators on 32-bit Windows is much lower than on 64-bit operating systems due to register width. MT19937, the generator that has been in NumPy since 2005, operates on 32-bit integers.</source>
          <target state="translated">32ビットWindows上での64ビットジェネレータの性能は、レジスタ幅の関係で、64ビットOS上での性能よりもはるかに低い。2005年からNumPyに搭載されているジェネレータMT19937は、32ビット整数で動作します。</target>
        </trans-unit>
        <trans-unit id="02f4c7c728252209e49cade8944d95bdb15fb9ef" translate="yes" xml:space="preserve">
          <source>The place in the code corresponding to the actual computations for the ufunc are marked with /*BEGIN main ufunc computation*/ and /*END main ufunc computation*/. The code in between those lines is the primary thing that must be changed to create your own ufunc.</source>
          <target state="translated">コードの中で、実際の ufunc の計算に対応する場所は、 /*BEGIN main ufunc computation*/と /*END main ufunc computation*/でマークされています。これらの行の間のコードが、自作の ufunc を作成するために変更しなければならない主要なものです。</target>
        </trans-unit>
        <trans-unit id="e0a72aed7747ec5b4e706a7296ecd1eb9faae060" translate="yes" xml:space="preserve">
          <source>The places in the code corresponding to the actual computations for the ufunc are marked with /*BEGIN main ufunc computation*/ and /*END main ufunc computation*/. The code in between those lines is the primary thing that must be changed to create your own ufunc.</source>
          <target state="translated">コードの中で、実際の ufunc の計算に対応する場所は /*BEGIN main ufunc computation*/と /*END main ufunc computation*/でマークされています。これらの行の間のコードが、独自の ufunc を作成するために変更しなければならない主要なものです。</target>
        </trans-unit>
        <trans-unit id="4a5ee23f497e38c29e0616fdcc0bb0ea7d4426f2" translate="yes" xml:space="preserve">
          <source>The points about sequence size and speed are particularly important in scientific computing. As a simple example, consider the case of multiplying each element in a 1-D sequence with the corresponding element in another sequence of the same length. If the data are stored in two Python lists, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, we could iterate over each element:</source>
          <target state="translated">シーケンスのサイズと速度に関するポイントは、科学計算において特に重要です。簡単な例として、1次元シーケンスの各要素に同じ長さの別のシーケンスの対​​応する要素を乗算する場合を考えてみます。データが2つのPythonリスト &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; に格納されている場合、各要素を反復処理できます。</target>
        </trans-unit>
        <trans-unit id="0779c65ec163a12759193f89f82723f01bb394dd" translate="yes" xml:space="preserve">
          <source>The polynomial coefficients</source>
          <target state="translated">多項式係数</target>
        </trans-unit>
        <trans-unit id="daaa36d42f5e3da309c9eab093a92efe7a0076ca" translate="yes" xml:space="preserve">
          <source>The polynomial convenience classes cannot be passed to ufuncs</source>
          <target state="translated">多項式便利クラスは ufuncs に渡すことができません。</target>
        </trans-unit>
        <trans-unit id="b9ed1328025571c1195a04bff5fdf98ece032c1f" translate="yes" xml:space="preserve">
          <source>The polynomial resulting from the multiplication of the inputs. If either inputs is a poly1d object, then the output is also a poly1d object. Otherwise, it is a 1D array of polynomial coefficients from highest to lowest degree.</source>
          <target state="translated">入力の乗算から得られる多項式。どちらかの入力がポリ1次元オブジェクトの場合、出力もポリ1次元オブジェクトとなります。そうでない場合は、最高次数から最低次数までの多項式係数の1次元配列です。</target>
        </trans-unit>
        <trans-unit id="515cfb6ef96288d03850b077c1e2ea4a5a576f0e" translate="yes" xml:space="preserve">
          <source>The polynomial series type class to which the current instance should be converted. If kind is None, then the class of the current instance is used.</source>
          <target state="translated">現在のインスタンスが変換されるべき多項式級数型のクラス。kindがNoneの場合は、現在のインスタンスのクラスが使用されます。</target>
        </trans-unit>
        <trans-unit id="75f7f784e98730c24c6aac1a9a0a155ec4addf47" translate="yes" xml:space="preserve">
          <source>The polynomial&amp;rsquo;s coefficients, in decreasing powers, or if the value of the second parameter is True, the polynomial&amp;rsquo;s roots (values where the polynomial evaluates to 0). For example, &lt;code&gt;poly1d([1, 2, 3])&lt;/code&gt; returns an object that represents</source>
          <target state="translated">多項式の係数、降べきの順、または2番目のパラメーターの値がTrueの場合、多項式の根（多項式が0と評価される値）。たとえば、 &lt;code&gt;poly1d([1, 2, 3])&lt;/code&gt; は、次を表すオブジェクトを返します</target>
        </trans-unit>
        <trans-unit id="80160250c999cde418e5655d194ff040c11e355e" translate="yes" xml:space="preserve">
          <source>The position,</source>
          <target state="translated">位置です。</target>
        </trans-unit>
        <trans-unit id="04babac298b058269a3dd833ef7829f7e3894479" translate="yes" xml:space="preserve">
          <source>The possibly nested list of array elements.</source>
          <target state="translated">入れ子になっている可能性のある配列要素のリスト.</target>
        </trans-unit>
        <trans-unit id="5cb3bd54a03911e525c1ba1e36e3cfe8b319cbe5" translate="yes" xml:space="preserve">
          <source>The power function distribution is just the inverse of the Pareto distribution. It may also be seen as a special case of the Beta distribution.</source>
          <target state="translated">力関数分布は,パレート分布の逆数にすぎません.ベータ分布の特殊なケースと見なすこともできます。</target>
        </trans-unit>
        <trans-unit id="65b60415cb79d4266b3f17e50b1894cd53e37067" translate="yes" xml:space="preserve">
          <source>The preferred way to update the documentation is by submitting a pull request on Github (see the &lt;a href=&quot;docs/index&quot;&gt;Documentation Index&lt;/a&gt;). Please help us to further improve the NumPy documentation!</source>
          <target state="translated">ドキュメントを更新するための推奨される方法は、Githubでプルリクエストを送信することです（&lt;a href=&quot;docs/index&quot;&gt;ドキュメントインデックスを&lt;/a&gt;参照）。NumPyのドキュメントをさらに改善するために私たちを助けてください！</target>
        </trans-unit>
        <trans-unit id="2f79358f94b924f7a1e059d54f311b3bb21fdafb" translate="yes" xml:space="preserve">
          <source>The preferred way to use a BitGenerator in parallel applications is to use the &lt;a href=&quot;generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt;&lt;code&gt;SeedSequence.spawn&lt;/code&gt;&lt;/a&gt; method to obtain entropy values, and to use these to generate new BitGenerators:</source>
          <target state="translated">並列アプリケーションでBitGeneratorを使用する好ましい方法は、&lt;a href=&quot;generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt; &lt;code&gt;SeedSequence.spawn&lt;/code&gt; &lt;/a&gt;メソッドを使用してエントロピー値を取得し、これらを使用して新しいBitGeneratorを生成することです。</target>
        </trans-unit>
        <trans-unit id="bce0b83b0022d3f62b001c90ef9147d9a4659969" translate="yes" xml:space="preserve">
          <source>The preferred way to use a BitGenerator in parallel applications is to use the &lt;code&gt;SeedSequence.spawn&lt;/code&gt; method to obtain entropy values, and to use these to generate new BitGenerators:</source>
          <target state="translated">並列アプリケーションでBitGeneratorを使用する好ましい方法は、 &lt;code&gt;SeedSequence.spawn&lt;/code&gt; メソッドを使用してエントロピー値を取得し、これらを使用して新しいBitGeneratorを生成することです。</target>
        </trans-unit>
        <trans-unit id="7ca668d501fbd18bd9dc320e9a4abf1ee3d102d7" translate="yes" xml:space="preserve">
          <source>The preprocessing of generically typed C source files (whether in NumPy proper or in any third party package using NumPy Distutils) is performed by &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/distutils/conv_template.py&quot;&gt;conv_template.py&lt;/a&gt;. The type specific C files generated (extension: .c) by these modules during the build process are ready to be compiled. This form of generic typing is also supported for C header files (preprocessed to produce .h files).</source>
          <target state="translated">一般的に型付けされたCソースファイルの前処理（NumPyの適切なファイル、またはNumPy Distutilsを使用するサードパーティのパッケージ）は、&lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/distutils/conv_template.py&quot;&gt;conv_template.py&lt;/a&gt;によって実行されます。ビルドプロセス中にこれらのモジュールによって生成されたタイプ固有のCファイル（拡張子：.c）は、コンパイルする準備ができています。この一般的な型付けの形式は、Cヘッダーファイル（.hファイルを生成するために前処理されたもの）でもサポートされています。</target>
        </trans-unit>
        <trans-unit id="79ca2b18555d36b1c58583e3de2322375811401a" translate="yes" xml:space="preserve">
          <source>The presence of &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; also influences how &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; handles binary operations like &lt;code&gt;arr + obj&lt;/code&gt; and &lt;code&gt;arr
&amp;lt; obj&lt;/code&gt; when &lt;code&gt;arr&lt;/code&gt; is an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;obj&lt;/code&gt; is an instance of a custom class. There are two possibilities. If &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; is present and not &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;code&gt;ndarray.__add__&lt;/code&gt; and friends will delegate to the ufunc machinery, meaning that &lt;code&gt;arr + obj&lt;/code&gt; becomes &lt;code&gt;np.add(arr, obj)&lt;/code&gt;, and then &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; invokes &lt;code&gt;obj.__array_ufunc__&lt;/code&gt;. This is useful if you want to define an object that acts like an array.</source>
          <target state="translated">存在&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;も影響どの&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;等ハンドルバイナリ操作 &lt;code&gt;arr + obj&lt;/code&gt; と &lt;code&gt;arr &amp;lt; obj&lt;/code&gt; 場合 &lt;code&gt;arr&lt;/code&gt; ある&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;obj&lt;/code&gt; がカスタムクラスのインスタンスです。2つの可能性があります。&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;でない &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; が存在する場合、 &lt;code&gt;ndarray.__add__&lt;/code&gt; とそのフレンドはufunc機構に委任します。これは、 &lt;code&gt;arr + obj&lt;/code&gt; が &lt;code&gt;np.add(arr, obj)&lt;/code&gt; になり、その後&lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt; &lt;code&gt;add&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; 呼び出すことを意味します。。これは、配列のように機能するオブジェクトを定義する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="40d6e2ba786e2b9884243f86e826abd1b1d0b0e2" translate="yes" xml:space="preserve">
          <source>The presence of &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; also influences how &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; handles binary operations like &lt;code&gt;arr + obj&lt;/code&gt; and &lt;code&gt;arr
&amp;lt; obj&lt;/code&gt; when &lt;code&gt;arr&lt;/code&gt; is an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;obj&lt;/code&gt; is an instance of a custom class. There are two possibilities. If &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; is present and not None, then &lt;code&gt;ndarray.__add__&lt;/code&gt; and friends will delegate to the ufunc machinery, meaning that &lt;code&gt;arr + obj&lt;/code&gt; becomes &lt;code&gt;np.add(arr, obj)&lt;/code&gt;, and then &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; invokes &lt;code&gt;obj.__array_ufunc__&lt;/code&gt;. This is useful if you want to define an object that acts like an array.</source>
          <target state="translated">存在&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;も影響どの&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;等ハンドルバイナリ操作 &lt;code&gt;arr + obj&lt;/code&gt; と &lt;code&gt;arr &amp;lt; obj&lt;/code&gt; 場合 &lt;code&gt;arr&lt;/code&gt; ある&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;obj&lt;/code&gt; がカスタムクラスのインスタンスです。 2つの可能性があります。場合 &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; 存在しないなしで、その後、 &lt;code&gt;ndarray.__add__&lt;/code&gt; や友人がその意味を、ufunc機械に委譲します &lt;code&gt;arr + obj&lt;/code&gt; なり &lt;code&gt;np.add(arr, obj)&lt;/code&gt; した後、&lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt; &lt;code&gt;add&lt;/code&gt; &lt;/a&gt;呼び出す &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; 。これは、配列のように機能するオブジェクトを定義する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="6adb356cfd1303c61f397a436f3cf821b0707e98" translate="yes" xml:space="preserve">
          <source>The presence of a header in the file can hinder data processing. In that case, we need to use the &lt;code&gt;skip_header&lt;/code&gt; optional argument. The values of this argument must be an integer which corresponds to the number of lines to skip at the beginning of the file, before any other action is performed. Similarly, we can skip the last &lt;code&gt;n&lt;/code&gt; lines of the file by using the &lt;code&gt;skip_footer&lt;/code&gt; attribute and giving it a value of &lt;code&gt;n&lt;/code&gt;:</source>
          <target state="translated">ファイル内にヘッダーが存在すると、データ処理が妨げられる可能性があります。その場合、 &lt;code&gt;skip_header&lt;/code&gt; オプションの引数を使用する必要があります。この引数の値は、他のアクションが実行される前に、ファイルの先頭でスキップする行数に対応する整数である必要があります。同様に、 &lt;code&gt;skip_footer&lt;/code&gt; 属性を使用して &lt;code&gt;n&lt;/code&gt; の値を指定することにより、ファイルの最後の &lt;code&gt;n&lt;/code&gt; 行をスキップできます。</target>
        </trans-unit>
        <trans-unit id="e5f36326e83630873ee2db09163f521fed09ccf8" translate="yes" xml:space="preserve">
          <source>The present value is computed by solving the equation:</source>
          <target state="translated">現在値は、式を解くことで計算されます。</target>
        </trans-unit>
        <trans-unit id="601986bff68f0c999502156a5c8a6f32ded002a4" translate="yes" xml:space="preserve">
          <source>The primary advantage of using array scalars is that they preserve the array type (Python may not have a matching scalar type available, e.g. &lt;code&gt;int16&lt;/code&gt;). Therefore, the use of array scalars ensures identical behaviour between arrays and scalars, irrespective of whether the value is inside an array or not. NumPy scalars also have many of the same methods arrays do.</source>
          <target state="translated">配列スカラーを使用する主な利点は、配列型を保持することです（Pythonには、一致するスカラー型がない場合があります（ &lt;code&gt;int16&lt;/code&gt; など））。したがって、配列スカラーを使用すると、値が配列内にあるかどうかに関係なく、配列とスカラーの間で同じ動作が保証されます。NumPyスカラーにも、配列と同じメソッドが多数あります。</target>
        </trans-unit>
        <trans-unit id="8c51c177d3ffae7eeb654a1cd5049b77b590c4db" translate="yes" xml:space="preserve">
          <source>The primitive types supported are tied closely to those in C:</source>
          <target state="translated">サポートされているプリミティブ型は、C言語のものと密接に結びついています。</target>
        </trans-unit>
        <trans-unit id="8faab5fdb76f1a3f47be9fc86bef262e2ab4b27a" translate="yes" xml:space="preserve">
          <source>The probabilities associated with each entry in a. If not given the sample assumes a uniform distribution over all entries in a.</source>
          <target state="translated">与えられていない場合は,標本はaのすべての項目について一様分布を仮定しています.</target>
        </trans-unit>
        <trans-unit id="8e475ecd8059b20acc5cee6528910a74a85f3b11" translate="yes" xml:space="preserve">
          <source>The probability density for the Gamma distribution is</source>
          <target state="translated">ガンマ分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="de744fd74c21b122de22a0d8e948a2a51ccc2b96" translate="yes" xml:space="preserve">
          <source>The probability density for the Gaussian distribution is</source>
          <target state="translated">ガウス分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="5905e8ef12f7d0d9eb54f382d72998ae48c8ef44" translate="yes" xml:space="preserve">
          <source>The probability density for the Gumbel distribution is</source>
          <target state="translated">ガンベル分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="bfb8724927e73ab8d936772b36c634818f86c5a4" translate="yes" xml:space="preserve">
          <source>The probability density for the Hypergeometric distribution is</source>
          <target state="translated">ハイパージオメトリック分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="f8985b96e26b0408a1f84b2787ee767e62c90303" translate="yes" xml:space="preserve">
          <source>The probability density for the Log Series distribution is</source>
          <target state="translated">対数系列分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="99fc9473ccfc113313d9fd374b914f025b58f310" translate="yes" xml:space="preserve">
          <source>The probability density for the Logistic distribution is</source>
          <target state="translated">ロジスティック分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="7985bdd977289b5652a3a0bba81a5da1bd3adf6d" translate="yes" xml:space="preserve">
          <source>The probability density for the Pareto distribution is</source>
          <target state="translated">パレート分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="238160654ada0174d17d83e1f0d7a26707c02c8d" translate="yes" xml:space="preserve">
          <source>The probability density for the Weibull distribution is</source>
          <target state="translated">ワイブル分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="fc3b79ebd29285bfc80812044ba5bd995aaaa06a" translate="yes" xml:space="preserve">
          <source>The probability density for the Zipf distribution is</source>
          <target state="translated">Zipf分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="bb707b06597dece119e6e3ebea40c8f15c1cb44f" translate="yes" xml:space="preserve">
          <source>The probability density for the binomial distribution is</source>
          <target state="translated">二項分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="6264a2e3e986c29af2fd700f69cafdda6f6c9d98" translate="yes" xml:space="preserve">
          <source>The probability density for the von Mises distribution is</source>
          <target state="translated">フォン・ミーゼス分布の確率密度は</target>
        </trans-unit>
        <trans-unit id="2e977910510c195394a91f298d7c9556abc16027" translate="yes" xml:space="preserve">
          <source>The probability density function</source>
          <target state="translated">確率密度関数</target>
        </trans-unit>
        <trans-unit id="a293dce90e3fe47dddc6a55e94ccb69a8fef9b0c" translate="yes" xml:space="preserve">
          <source>The probability density function for the Rayleigh distribution is</source>
          <target state="translated">レイリー分布の確率密度関数は</target>
        </trans-unit>
        <trans-unit id="d3e0872e16a6ab7b6c0ee2a22d52dd0d2e1ca84e" translate="yes" xml:space="preserve">
          <source>The probability density function for the Wald distribution is</source>
          <target state="translated">ウォルト分布の確率密度関数は</target>
        </trans-unit>
        <trans-unit id="2f149a65fa2739e5de1eec985af9c1621ffacc73" translate="yes" xml:space="preserve">
          <source>The probability density function for the full Cauchy distribution is</source>
          <target state="translated">完全コーキー分布の確率密度関数は</target>
        </trans-unit>
        <trans-unit id="6b0dc98514227cdd44ff47b528c8a0bcaf89c265" translate="yes" xml:space="preserve">
          <source>The probability density function for the noncentral Chi-square distribution is</source>
          <target state="translated">非中心カイ二乗分布の確率密度関数は</target>
        </trans-unit>
        <trans-unit id="c30948020144257a9fb38966abff7c99e81c50e9" translate="yes" xml:space="preserve">
          <source>The probability density function for the t distribution is</source>
          <target state="translated">t分布の確率密度関数は</target>
        </trans-unit>
        <trans-unit id="dcdbad2794701215e8c40510ff713b7913263c5a" translate="yes" xml:space="preserve">
          <source>The probability density function for the triangular distribution is</source>
          <target state="translated">三角分布の確率密度関数は</target>
        </trans-unit>
        <trans-unit id="6467351c7a0571530575123e2ae036078aaa2303" translate="yes" xml:space="preserve">
          <source>The probability density function is</source>
          <target state="translated">確率密度関数は</target>
        </trans-unit>
        <trans-unit id="ee41aab696af2a63a045005f9a20ab50a30087b5" translate="yes" xml:space="preserve">
          <source>The probability density function of the chi-squared distribution is</source>
          <target state="translated">カイ二乗分布の確率密度関数は</target>
        </trans-unit>
        <trans-unit id="c5e3eadc4ee0ddfc376707a7c47e36bdec30614e" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="translated">正規分布の確率密度関数は、最初にDe Moivreによって導き出され、200年後にGaussとLaplaceの両方によって独立して導出されます&lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id1&quot;&gt;[2]が&lt;/a&gt;、その特徴的な形状のために、ベルカーブと呼ばれることがよくあります（下の例を参照）。</target>
        </trans-unit>
        <trans-unit id="2297eee1a9ef2ae469ffb4ffe7c7db8f4e4f83da" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#ra2e838c5ea87-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="translated">正規分布の確率密度関数は、最初にDe Moivreによって導出され、200年後にGaussとLaplaceの両方によって独立して導出されました&lt;a href=&quot;#ra2e838c5ea87-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;。その特徴的な形状から、ベルカーブと呼ばれることがよくあります（以下の例を参照）。</target>
        </trans-unit>
        <trans-unit id="d7e2875a44ce7ebdc83cb0f55dc114499ca0e8b1" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="translated">正規分布の確率密度関数は、最初にDe Moivreによって導き出され、200年後にGaussとLaplaceの両方によって独立して導出されます&lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id1&quot;&gt;[2]が&lt;/a&gt;、その特徴的な形状のために、ベルカーブと呼ばれることがよくあります（下の例を参照）。</target>
        </trans-unit>
        <trans-unit id="31415e3883f5ad2cde00e0bf903f48cc5ab3d293" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#rf578abb8fba2-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="translated">正規分布の確率密度関数は、最初にDe Moivreによって導出され、200年後にGaussとLaplaceの両方によって独立して導出されました&lt;a href=&quot;#rf578abb8fba2-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;。その特徴的な形状から、ベルカーブと呼ばれることがよくあります（以下の例を参照）。</target>
        </trans-unit>
        <trans-unit id="2755556e2db9bd446cf581401e578c5337420320" translate="yes" xml:space="preserve">
          <source>The probability density function of the uniform distribution is</source>
          <target state="translated">一様分布の確率密度関数は</target>
        </trans-unit>
        <trans-unit id="415051b020f7949a62618fb53ef560dee4613543" translate="yes" xml:space="preserve">
          <source>The probability inputs should be normalized. As an implementation detail, the value of the last entry is ignored and assumed to take up any leftover probability mass, but this should not be relied on. A biased coin which has twice as much weight on one side as on the other should be sampled like so:</source>
          <target state="translated">確率入力は正規化されるべきである。実装の詳細として、最後のエントリの値は無視され、残された確率の質量を取ると仮定されますが、これに依存すべきではありません。片側に2倍の重みを持つ偏ったコインは、このようにサンプリングされるべきです。</target>
        </trans-unit>
        <trans-unit id="8e4c202be333253a1251675439dcd7f21c1ef125" translate="yes" xml:space="preserve">
          <source>The probability mass function for the Log Series distribution is</source>
          <target state="translated">対数系列分布の確率質量関数は</target>
        </trans-unit>
        <trans-unit id="2d117aed0c4f59861c0b3330028791db8f91f6f5" translate="yes" xml:space="preserve">
          <source>The probability mass function of the geometric distribution is</source>
          <target state="translated">幾何学的分布の確率質量関数は</target>
        </trans-unit>
        <trans-unit id="53c49feadffaed0acd89d507cebd4872b9032162" translate="yes" xml:space="preserve">
          <source>The probability mass function of the negative binomial distribution is</source>
          <target state="translated">負の二項分布の確率質量関数は</target>
        </trans-unit>
        <trans-unit id="f1f5e6e451a12ecc1dfa7cb3123b997ae141c402" translate="yes" xml:space="preserve">
          <source>The probability of success of an individual trial.</source>
          <target state="translated">個々の試験が成功する確率。</target>
        </trans-unit>
        <trans-unit id="c0419d3f3c0dd14cc710a6332bd5b9e9f12f94e6" translate="yes" xml:space="preserve">
          <source>The problem here is that there is one dimension argument and two array arguments, and our typemaps are set up for dimensions that apply to a single array (in fact, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; does not provide a mechanism for associating &lt;code&gt;len&lt;/code&gt; with &lt;code&gt;vec2&lt;/code&gt; that takes two Python input arguments). The recommended solution is the following:</source>
          <target state="translated">ここでの問題は、1つの次元引数と2つの配列引数があり、タイプマップが単一の配列に適用される次元用に設定されていることです（実際、&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;は、 &lt;code&gt;len&lt;/code&gt; を &lt;code&gt;vec2&lt;/code&gt; に関連付けて2つのPython入力引数を取るメカニズムを提供していません）。推奨される解決策は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="258606759bb8ded772cb41c8f492be953461a647" translate="yes" xml:space="preserve">
          <source>The problem is solved exactly. In this case, the function returns True only if there is an element shared between the arrays.</source>
          <target state="translated">問題は正確に解決されます。この場合、この関数は配列間で共有されている要素がある場合にのみTrueを返します。</target>
        </trans-unit>
        <trans-unit id="4ad89e6d069e4dfa2e5a4dc8cd5ea0ef4b308ab4" translate="yes" xml:space="preserve">
          <source>The problem is solved exactly. In this case, the function returns True only if there is an element shared between the arrays. Finding the exact solution may take extremely long in some cases.</source>
          <target state="translated">問題は正確に解決されます。この場合、この関数は、配列間で共有されている要素がある場合にのみTrueを返します。場合によっては,正確な解を見つけるのに非常に時間がかかることがあります.</target>
        </trans-unit>
        <trans-unit id="12f7b79ffc79e216081a6d98b051a230198244d5" translate="yes" xml:space="preserve">
          <source>The product of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">要素ごとの &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の積。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="3f6e1c408d5c694acb6e117eca1f17a66ff95359" translate="yes" xml:space="preserve">
          <source>The product of an empty array is the neutral element 1:</source>
          <target state="translated">空の配列の積が中立要素1となります。</target>
        </trans-unit>
        <trans-unit id="75994948d8c7e15ea47031e7a198364fb67ad040" translate="yes" xml:space="preserve">
          <source>The project management structure can be found at our &lt;a href=&quot;dev/governance/index&quot;&gt;governance page&lt;/a&gt;</source>
          <target state="translated">プロジェクト管理の構造は、&lt;a href=&quot;dev/governance/index&quot;&gt;ガバナンスページにあります。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0cb319efd0acc22671f035a1669648180fbd73bb" translate="yes" xml:space="preserve">
          <source>The promoted data type.</source>
          <target state="translated">昇格したデータ型。</target>
        </trans-unit>
        <trans-unit id="6912cd62e766bc5197bb815c3a7a6d0beffe9f0f" translate="yes" xml:space="preserve">
          <source>The pseudo Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Chebyshev polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">疑似ヴァンダーモンド行列。返される行列の形状は &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; 。ここで、最後のインデックスは対応するチェビシェフ多項式の次数です。dtypeは、変換された &lt;code&gt;x&lt;/code&gt; と同じになります。</target>
        </trans-unit>
        <trans-unit id="4ae75dbae228045f6a44f16a4959415e52a060af" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Hermite polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">疑似ヴァンダーモンド行列。返される行列の形状は &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; 。ここで、最後のインデックスは対応するエルミート多項式の次数です。dtypeは、変換された &lt;code&gt;x&lt;/code&gt; と同じになります。</target>
        </trans-unit>
        <trans-unit id="88145706d808f4e5b4b300c092c6d0b48707e827" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding HermiteE polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">疑似ヴァンダーモンド行列。返される行列の形状は &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; 。ここで、最後のインデックスは対応するHermiteE多項式の次数です。dtypeは、変換された &lt;code&gt;x&lt;/code&gt; と同じになります。</target>
        </trans-unit>
        <trans-unit id="461d6f363a2da4bb21861bdd9199b9a080f1058c" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Laguerre polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">疑似ヴァンダーモンド行列。返される行列の形状は &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; 。ここで、最後のインデックスは対応するラゲール多項式の次数です。dtypeは、変換された &lt;code&gt;x&lt;/code&gt; と同じになります。</target>
        </trans-unit>
        <trans-unit id="a9fac4b82ab694bb7879684258269647508526ed" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Legendre polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">疑似ヴァンダーモンド行列。返される行列の形状は &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; です。最後のインデックスは、対応するルジャンドル多項式の次数です。dtypeは、変換された &lt;code&gt;x&lt;/code&gt; と同じになります。</target>
        </trans-unit>
        <trans-unit id="14e8343a4bfc8bf0e783456b4d87d1a38896cde9" translate="yes" xml:space="preserve">
          <source>The pseudo-inverse of &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;matrix&lt;/code&gt; instance, then so is &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">の擬似逆。場合である &lt;code&gt;matrix&lt;/code&gt; インスタンスは、そのようになる &lt;code&gt;B&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c9935b0bcef3c9f2790af77d395c4f7367a5b4f9" translate="yes" xml:space="preserve">
          <source>The pseudo-inverse of a matrix A, denoted</source>
          <target state="translated">行列 A の擬似逆行列である</target>
        </trans-unit>
        <trans-unit id="43268b21480b8908d11ac78845b26e8a85b3d3ad" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;code&gt;F2PY&lt;/code&gt; &amp;ndash;&lt;em&gt;Fortran to Python interface generator&lt;/em&gt;&amp;ndash; is to provide a connection between Python and Fortran languages. F2PY is a part of &lt;a href=&quot;https://www.numpy.org/&quot;&gt;NumPy&lt;/a&gt; (&lt;code&gt;numpy.f2py&lt;/code&gt;) and also available as a standalone command line tool &lt;code&gt;f2py&lt;/code&gt; when &lt;code&gt;numpy&lt;/code&gt; is installed that facilitates creating/building Python C/API extension modules that make it possible</source>
          <target state="translated">&lt;code&gt;F2PY&lt;/code&gt; &amp;ndash; &lt;em&gt;FortranからPythonへのインターフェースジェネレーター&lt;/em&gt;&amp;ndash;の目的は、PythonとFortran言語間の接続を提供することです。F2PYは&lt;a href=&quot;https://www.numpy.org/&quot;&gt;NumPy&lt;/a&gt;（ &lt;code&gt;numpy.f2py&lt;/code&gt; ）の一部であり、 &lt;code&gt;numpy&lt;/code&gt; がインストールされている場合はスタンドアロンのコマンドラインツール &lt;code&gt;f2py&lt;/code&gt; としても利用できます。これにより、Python C / API拡張モジュールの作成/構築が容易になります。</target>
        </trans-unit>
        <trans-unit id="273d622b1bbcac1e58ca2d1b74d9ecdc471af9f8" translate="yes" xml:space="preserve">
          <source>The purpose of the reference count check is to make sure you do not use this array as a buffer for another Python object and then reallocate the memory. However, reference counts can increase in other ways so if you are sure that you have not shared the memory for this array with another Python object, then you may safely set &lt;code&gt;refcheck&lt;/code&gt; to False.</source>
          <target state="translated">参照カウントチェックの目的は、この配列を別のPythonオブジェクトのバッファとして使用しないようにし、メモリを再割り当てすることです。ただし、他の方法で参照カウントが増加する可能性があるため、この配列のメモリを別のPythonオブジェクトと共有していないことが確実な場合は、 &lt;code&gt;refcheck&lt;/code&gt; を安全にFalse に設定できます。</target>
        </trans-unit>
        <trans-unit id="cd4694d2cc663a00201267e4370ce5da08336131" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to formalize the governance process used by the NumPy project in both ordinary and extraordinary situations, and to clarify how decisions are made and how the various elements of our community interact, including the relationship between open source collaborative development and work that may be funded by for-profit or non-profit entities.</source>
          <target state="translated">この文書の目的は、NumPyプロジェクトが通常の状況と非日常の状況の両方で使用するガバナンスプロセスを正式化し、決定がどのように行われるかを明確にし、オープンソースの共同開発と営利団体や非営利団体から資金提供される可能性のある仕事との関係を含めて、コミュニティの様々な要素がどのように相互作用するかを明らかにすることです。</target>
        </trans-unit>
        <trans-unit id="fd1af1501c6ee7b4f0b0aa9bb7ca5e17785491ff" translate="yes" xml:space="preserve">
          <source>The quadrant (i.e., branch) is chosen so that &lt;code&gt;arctan2(x1, x2)&lt;/code&gt; is the signed angle in radians between the ray ending at the origin and passing through the point (1,0), and the ray ending at the origin and passing through the point (&lt;code&gt;x2&lt;/code&gt;, &lt;code&gt;x1&lt;/code&gt;). (Note the role reversal: the &amp;ldquo;&lt;code&gt;y&lt;/code&gt;-coordinate&amp;rdquo; is the first function parameter, the &amp;ldquo;&lt;code&gt;x&lt;/code&gt;-coordinate&amp;rdquo; is the second.) By IEEE convention, this function is defined for &lt;code&gt;x2&lt;/code&gt; = +/-0 and for either or both of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; = +/-inf (see Notes for specific values).</source>
          <target state="translated">象限（つまり、ブランチ）は、 &lt;code&gt;arctan2(x1, x2)&lt;/code&gt; が、原点で終了し、点（1,0）を通過する光線と、原点で終了し、通過する光線の間のラジアン単位の符号付き角度になるように選択されます。点（ &lt;code&gt;x2&lt;/code&gt; 、 &lt;code&gt;x1&lt;/code&gt; ）を通過します。 （役割の逆転に注意してください。「 &lt;code&gt;y&lt;/code&gt; 座標」は最初の関数パラメーター、「 &lt;code&gt;x&lt;/code&gt; 座標」は2番目です）。IEEE規則により、この関数は &lt;code&gt;x2&lt;/code&gt; = +/- 0に対して、および &lt;code&gt;x1&lt;/code&gt; および &lt;code&gt;x2&lt;/code&gt; = +/- inf（特定の値については、注を参照）。</target>
        </trans-unit>
        <trans-unit id="a6498ac12126ab973a1934f179594a987afb7844" translate="yes" xml:space="preserve">
          <source>The quick and smart way</source>
          <target state="translated">手っ取り早くて賢い方法</target>
        </trans-unit>
        <trans-unit id="8b0770ff789fdc985036394e871929fde93eb9a9" translate="yes" xml:space="preserve">
          <source>The quick way</source>
          <target state="translated">素早い方法</target>
        </trans-unit>
        <trans-unit id="d041efcac5d4fa984fd9e585c0e674ab20c24a98" translate="yes" xml:space="preserve">
          <source>The quickest way to wrap the Fortran subroutine &lt;code&gt;FIB&lt;/code&gt; to Python is to run</source>
          <target state="translated">Fortranサブルーチン &lt;code&gt;FIB&lt;/code&gt; をPythonにラップする最も簡単な方法は、実行することです。</target>
        </trans-unit>
        <trans-unit id="ef42c4d34d6fe180bfd554c782fbff1345844332" translate="yes" xml:space="preserve">
          <source>The random numbers generated are reproducible in the sense that the same seed will produce the same outputs, given that the number of threads does not change.</source>
          <target state="translated">生成された乱数は、スレッドの数が変化しないことを考えると、同じシードでも同じ出力が得られるという意味で再現性があります。</target>
        </trans-unit>
        <trans-unit id="d11423e3cc4bf0ed835c8b796b2965976e8e77d3" translate="yes" xml:space="preserve">
          <source>The random values are simulated using a rejection-based method and so, on average, more than one value from the underlying RNG is required to generate an single draw.</source>
          <target state="translated">乱数値は棄却ベースの方法でシミュレートされるため、平均して1回のドローを生成するには基礎となるRNGから1つ以上の値が必要となります。</target>
        </trans-unit>
        <trans-unit id="28da8ed4d2357ec2f5fb90d47c281e28c8eefc86" translate="yes" xml:space="preserve">
          <source>The random values produced by &lt;a href=&quot;../generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; orignate in a BitGenerator. The BitGenerators do not directly provide random numbers and only contains methods used for seeding, getting or setting the state, jumping or advancing the state, and for accessing low-level wrappers for consumption by code that can efficiently access the functions provided, e.g., &lt;a href=&quot;https://numba.pydata.org&quot;&gt;numba&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;によって生成されたランダムな値は、BitGeneratorで調整されます。BitGeneratorsは直接、例えば、乱数を提供してのみ、播種の状態を取得または設定し、ジャンプや状態を進めるために、かつ効率的に提供する機能にアクセスすることができ、コードによる消費のために低レベルのラッパーにアクセスするために使用する方法が含まれていません&lt;a href=&quot;https://numba.pydata.org&quot;&gt;numbaを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ad47a80d273e6280e7c076840353be5436abdd4" translate="yes" xml:space="preserve">
          <source>The random variate of the F distribution (also known as the Fisher distribution) is a continuous probability distribution that arises in ANOVA tests, and is the ratio of two chi-square variates.</source>
          <target state="translated">F 分布のランダム分散量(フィッシャー分布としても知られている)は、ANOVA検定で生じる連続確率分布で、2つのカイ2乗分散量の比率である。</target>
        </trans-unit>
        <trans-unit id="0add6113b9556467f5d4df18305b83fe87d90739" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;a href=&quot;numpy.full#numpy.full&quot;&gt;&lt;code&gt;full&lt;/code&gt;&lt;/a&gt; = False.</source>
          <target state="translated">最小二乗近似における係数行列のランクが不十分です。この警告は、&lt;a href=&quot;numpy.full#numpy.full&quot;&gt; &lt;code&gt;full&lt;/code&gt; &lt;/a&gt; = Falseの場合にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="b6ce678d6ccc2a705d695d4a88057837caab615e" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;code&gt;full&lt;/code&gt; = False.</source>
          <target state="translated">最小二乗近似における係数行列のランクが不十分です。この警告は、 &lt;code&gt;full&lt;/code&gt; = Falseの場合にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="bd75ec6be6b0946c94eb5124dc2c270b7f45fc83" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;code&gt;full&lt;/code&gt; = False. The warnings can be turned off by</source>
          <target state="translated">最小二乗近似における係数行列のランクが不十分です。この警告は、 &lt;code&gt;full&lt;/code&gt; = Falseの場合にのみ発生します。警告はオフにすることができます</target>
        </trans-unit>
        <trans-unit id="2c0ff958aa13b6c22519b1f58af607e808b9fc81" translate="yes" xml:space="preserve">
          <source>The rate of interest is computed by iteratively solving the (non-linear) equation:</source>
          <target state="translated">利率は、(非線形の)方程式を反復的に解くことによって計算されます。</target>
        </trans-unit>
        <trans-unit id="b661d55a0a19500a077ffd4c961cfcdd8af11a0d" translate="yes" xml:space="preserve">
          <source>The real and imaginary parts of complex numbers are rounded separately. The result of rounding a float is a float.</source>
          <target state="translated">複素数の実数部と虚数部は別々に丸められます。丸めた結果が浮動小数点数になります。</target>
        </trans-unit>
        <trans-unit id="207d8f1e0e497b598f007938a1132510a97a9210" translate="yes" xml:space="preserve">
          <source>The real component of the complex argument. If &lt;code&gt;val&lt;/code&gt; is real, the type of &lt;code&gt;val&lt;/code&gt; is used for the output. If &lt;code&gt;val&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">複素引数の実数コンポーネント。場合 &lt;code&gt;val&lt;/code&gt; が本当である、の種類 &lt;code&gt;val&lt;/code&gt; が出力のために使用されています。場合 &lt;code&gt;val&lt;/code&gt; は複雑な要素を持って、返された型はfloatです。</target>
        </trans-unit>
        <trans-unit id="bcba5206897319bd4dfef5984f33a61e7bfd3a3e" translate="yes" xml:space="preserve">
          <source>The real part of the array.</source>
          <target state="translated">配列の実際の部分。</target>
        </trans-unit>
        <trans-unit id="f76c20342380d19b36138a77680129546c04ac6d" translate="yes" xml:space="preserve">
          <source>The real part of the masked array.</source>
          <target state="translated">マスクされた配列の実際の部分。</target>
        </trans-unit>
        <trans-unit id="f8c34f7042b404b994731920ea347bbd1e355fae" translate="yes" xml:space="preserve">
          <source>The recommended approach to multithreaded iteration is to first create an iterator with the flags &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt;&lt;code&gt;NPY_ITER_RANGED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt;&lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt;&lt;/a&gt;, and possibly &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt;. Create a copy of this iterator for each thread (minus one for the first iterator). Then, take the iteration index range &lt;code&gt;[0, NpyIter_GetIterSize(iter))&lt;/code&gt; and split it up into tasks, for example using a TBB parallel_for loop. When a thread gets a task to execute, it then uses its copy of the iterator by calling &lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt;&lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt;&lt;/a&gt; and iterating over the full range.</source>
          <target state="translated">マルチスレッド反復の推奨アプローチは、最初にフラグ&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt; &lt;code&gt;NPY_ITER_RANGED&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt; &lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt; &lt;/a&gt;、および場合によっては&lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; を&lt;/a&gt;使用してイテレーターを作成することです。このイテレータのコピーをスレッドごとに作成します（最初のイテレータの場合は1を引きます）。次に、反復インデックスの範囲 &lt;code&gt;[0, NpyIter_GetIterSize(iter))&lt;/code&gt; を取得して、たとえばTBBのparallel_forループを使用して、タスクに分割します。スレッドは、実行するタスクを取得すると、&lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt; &lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt; &lt;/a&gt;を呼び出して全範囲を反復することにより、イテレータのコピーを使用します。</target>
        </trans-unit>
        <trans-unit id="8ebf9173277c6dd7ef8e96321015ddb67f853d5b" translate="yes" xml:space="preserve">
          <source>The recommended generator for general use is &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt;. It is statistically high quality, full-featured, and fast on most platforms, but somewhat slow when compiled for 32-bit processes.</source>
          <target state="translated">一般的な使用に推奨されるジェネレーターは&lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;です。統計的に高品質で、フル機能を備え、ほとんどのプラットフォームで高速ですが、32ビットプロセス用にコンパイルするとやや遅くなります。</target>
        </trans-unit>
        <trans-unit id="5447919d67b87c18366730a8d862cd10ecf68752" translate="yes" xml:space="preserve">
          <source>The recommended generator for general use is &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt;. It is statistically high quality, full-featured, and fast on most platforms, but somewhat slow when compiled for 32-bit processes.</source>
          <target state="translated">一般的な使用に推奨されるジェネレータは&lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;です。統計的に高品質でフル機能を備え、ほとんどのプラットフォームで高速ですが、32ビットプロセス用にコンパイルすると多少遅くなります。</target>
        </trans-unit>
        <trans-unit id="1ecded761aa3b896fb25df737596c852ad7e09c5" translate="yes" xml:space="preserve">
          <source>The recommended practice for initializing &lt;code&gt;mask&lt;/code&gt; with a scalar boolean value is to use &lt;code&gt;True&lt;/code&gt;/&lt;code&gt;False&lt;/code&gt; rather than &lt;code&gt;np.True_&lt;/code&gt;/&lt;code&gt;np.False_&lt;/code&gt;. The reason is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is represented internally as &lt;code&gt;np.False_&lt;/code&gt;.</source>
          <target state="translated">初期化するためのお勧め &lt;code&gt;mask&lt;/code&gt; スカラーブール値では使用することです &lt;code&gt;True&lt;/code&gt; / &lt;code&gt;False&lt;/code&gt; のではなく、 &lt;code&gt;np.True_&lt;/code&gt; / &lt;code&gt;np.False_&lt;/code&gt; 。その理由は、&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;が内部的に &lt;code&gt;np.False_&lt;/code&gt; として表されるためです。</target>
        </trans-unit>
        <trans-unit id="f1f83ab16efb108e21fd8dc9140501bac936f974" translate="yes" xml:space="preserve">
          <source>The recommended way to mark one or several specific entries of a masked array as invalid is to assign the special value &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; to them:</source>
          <target state="translated">無効としてマスクされた配列の一つまたは複数の特定のエントリをマークする場合に推奨される方法は、特別な値割り当てることで&lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt;、それらには：</target>
        </trans-unit>
        <trans-unit id="8e71a8b22e3d3f7dda123223a571d40b785e19ae" translate="yes" xml:space="preserve">
          <source>The recommended way to store and load data:</source>
          <target state="translated">データの保存・読み込みにおすすめの方法をご紹介します。</target>
        </trans-unit>
        <trans-unit id="8911e36d75ead22da4c98276ac7d48a14f617b1b" translate="yes" xml:space="preserve">
          <source>The reduceat function is a generalization of both the reduce and accumulate functions. It implements a reduce over ranges of the input array specified by indices. The extra indices argument is checked to be sure that every input is not too large for the input array along the selected dimension before the loop calculations take place. The loop implementation is handled using code that is very similar to the reduce code repeated as many times as there are elements in the indices input. In particular: the first input pointer passed to the underlying 1-D computational loop points to the input array at the correct location indicated by the index array. In addition, the output pointer and the second input pointer passed to the underlying 1-D loop point to the same position in memory. The size of the 1-D computational loop is fixed to be the difference between the current index and the next index (when the current index is the last index, then the next index is assumed to be the length of the array along the selected dimension). In this way, the 1-D loop will implement a reduce over the specified indices.</source>
          <target state="translated">reduceat 関数は,reduce と accumulate の両方の関数を一般化したものです.これは,インデックスで指定された入力配列の範囲を対象としたリダクションを実装しています.余分なindices引数は,ループ計算が行われる前に,選択された次元に沿った入力配列に対して,すべての入力が大きすぎないことを確認するためにチェックされます.ループの実装は,indicesの入力に要素がある限り何度でも繰り返されるreduceコードと非常によく似たコードを用いて処理されます.特に:基礎となる1次元計算ループに渡される最初の入力ポインタは,インデックス配列によって示される正しい位置にある入力配列を指します.さらに、基礎となる1次元ループに渡される出力ポインタと第2の入力ポインタは、メモリ内の同じ位置を指す。1次元計算ループのサイズは、現在のインデックスと次のインデックスとの差(現在のインデックスが最後のインデックスである場合、次のインデックスは、選択された次元に沿った配列の長さであると仮定される)に固定されている。このようにして,1次元ループは,指定されたインデックスに対するリダクションを実装します.</target>
        </trans-unit>
        <trans-unit id="7b43a1a08f82a3b68e452cbd124797f3f5925ce7" translate="yes" xml:space="preserve">
          <source>The reduced array. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to it.</source>
          <target state="translated">縮小された配列。 &lt;code&gt;out&lt;/code&gt; が指定されている場合、 &lt;code&gt;r&lt;/code&gt; はそれへの参照です。</target>
        </trans-unit>
        <trans-unit id="d46d2581ba496f8d142f6a4f33e8d4c920183656" translate="yes" xml:space="preserve">
          <source>The reduced values. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">削減された値。 &lt;code&gt;out&lt;/code&gt; が指定された場合、 &lt;code&gt;r&lt;/code&gt; は &lt;code&gt;out&lt;/code&gt; への参照です。</target>
        </trans-unit>
        <trans-unit id="3281b17df16674bbe40c7e1efbe54eb9d464c9ee" translate="yes" xml:space="preserve">
          <source>The regular expression. Default value is None, in which case the nose default (&lt;code&gt;re.compile(r'(?:^|[\b_\.%s-])[Tt]est' % os.sep)&lt;/code&gt;) is used. If &lt;code&gt;testmatch&lt;/code&gt; is a string, it is compiled to a regular expression first.</source>
          <target state="translated">正規表現。デフォルト値はNoneです。この場合、ノーズのデフォルト（ &lt;code&gt;re.compile(r'(?:^|[\b_\.%s-])[Tt]est' % os.sep)&lt;/code&gt; ）が使用されます。 &lt;code&gt;testmatch&lt;/code&gt; が文字列の場合、最初に正規表現にコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="bd0a0dfb20db6ba5c33bc9ca8a9fe1a01f1841cf" translate="yes" xml:space="preserve">
          <source>The relative performance on 64-bit Linux and 64-bit Windows is broadly similar.</source>
          <target state="translated">64ビットLinuxと64ビットWindowsの相対的なパフォーマンスは大まかに似ています。</target>
        </trans-unit>
        <trans-unit id="7989f6ae8fcd58319573d40c534aa46fe0a84b96" translate="yes" xml:space="preserve">
          <source>The relative tolerance parameter (see Notes).</source>
          <target state="translated">相対的な許容範囲パラメータ(注記を参照)。</target>
        </trans-unit>
        <trans-unit id="3e03b7da726f71e414e37015d45ecfcbfb010c83" translate="yes" xml:space="preserve">
          <source>The release should be announced on the mailing lists of NumPy and SciPy, to python-announce, and possibly also those of Matplotlib, IPython and/or Pygame.</source>
          <target state="translated">このリリースは、NumPyとSciPyのメーリングリスト、python-announceで発表されるべきです。</target>
        </trans-unit>
        <trans-unit id="96164d49d0f26476a5104ba2b3a4aa7deeeccb58" translate="yes" xml:space="preserve">
          <source>The release should be announced on the numpy-discussion, scipy-devel, scipy-user, and python-announce-list mailing lists. Look at previous announcements for the basic template. The contributor and PR lists are the same as generated for the release notes above. If you crosspost, make sure that python-announce-list is BCC so that replies will not be sent to that list.</source>
          <target state="translated">リリースは numpy-discussion,scipy-devel,scipy-user,そして python-announce-list メーリングリストで発表されるべきです。基本的なテンプレートは過去のアナウンスを参照してください。貢献者リストとPRリストは、上記のリリースノートで生成されたものと同じです。クロスポストする場合は、 python-announce-list が BCC になっていることを確認して、そのリストに返信が送られないようにしてください。</target>
        </trans-unit>
        <trans-unit id="12f91fe84c2d74d72d982ce47fb9a64711667ccc" translate="yes" xml:space="preserve">
          <source>The release tag should have the release number in the annotation (tag message). Unfortunately, the name of a tag can be changed without breaking the signature, the contents of the message cannot.</source>
          <target state="translated">リリースタグには、アノテーション(タグメッセージ)にリリース番号を入れておく必要があります。残念ながら、タグの名前はシグネチャを壊さずに変更できますが、メッセージの内容は変更できません。</target>
        </trans-unit>
        <trans-unit id="dafb58a5db48e1dfe53af56fea252537c1419b45" translate="yes" xml:space="preserve">
          <source>The remainder of the division of &lt;code&gt;x1&lt;/code&gt; by &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; を &lt;code&gt;x2&lt;/code&gt; で割った余り。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="45876a6251302c94b60ea59421b48e6f10e76b32" translate="yes" xml:space="preserve">
          <source>The required alignment (bytes) of this data-type according to the compiler.</source>
          <target state="translated">コンパイラによるこのデータ型の必要なアラインメント(バイト数)。</target>
        </trans-unit>
        <trans-unit id="13ef7d8fa51bbebbe1bd1d3ed4d25fe31e0c8b11" translate="yes" xml:space="preserve">
          <source>The required data type(s) of the operands. If copying or buffering is enabled, the data will be converted to/from their original types.</source>
          <target state="translated">オペランドの必要なデータ型です。コピーまたはバッファリングが有効な場合、データは元の型に変換されます。</target>
        </trans-unit>
        <trans-unit id="0a7d78831f72627736ecbbe6affd07acc842cf9c" translate="yes" xml:space="preserve">
          <source>The required data-type. If None preserve the current dtype. If your application requires the data to be in native byteorder, include a byteorder specification as a part of the dtype specification.</source>
          <target state="translated">必要なデータ型。None の場合は、現在の dtype を保持します。アプリケーションでデータがネイティブのバイト順であることが必要な場合は、dtype 仕様の一部としてバイト順仕様を含めてください。</target>
        </trans-unit>
        <trans-unit id="65e5c657147f8f6206b51f162cff2b0b35eade26" translate="yes" xml:space="preserve">
          <source>The requirements flag allows specification of what kind of array is acceptable. If the object passed in does not satisfy this requirements then a copy is made so that thre returned object will satisfy the requirements. these ndarray can use a very generic pointer to memory. This flag allows specification of the desired properties of the returned array object. All of the flags are explained in the detailed API chapter. The flags most commonly needed are &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_IN_ARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_IN_ARRAY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../reference/c-api/array#c.NPY_OUT_ARRAY&quot;&gt;&lt;code&gt;NPY_OUT_ARRAY&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_INOUT_ARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_INOUT_ARRAY&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要件フラグを使用すると、許容できる配列の種類を指定できます。渡されたオブジェクトがこの要件を満たさない場合は、返されたオブジェクトが要件を満たすようにコピーが作成されます。これらのndarrayは、メモリへの非常に一般的なポインタを使用できます。このフラグを使用すると、返される配列オブジェクトの目的のプロパティを指定できます。すべてのフラグは、詳細なAPIの章で説明されています。最も一般的に必要なフラグは、&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_IN_ARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_IN_ARRAY&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../reference/c-api/array#c.NPY_OUT_ARRAY&quot;&gt; &lt;code&gt;NPY_OUT_ARRAY&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_INOUT_ARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_INOUT_ARRAY&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="bb180b40fee6aef0d41f93f405142f00de46dd28" translate="yes" xml:space="preserve">
          <source>The requirements list can be any of the following</source>
          <target state="translated">要件リストは以下のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="bf0f3cb688cf9b5f44c6080748b72439b46fb978" translate="yes" xml:space="preserve">
          <source>The reshaping operation cannot guarantee that a copy will not be made, to modify the shape in place, use &lt;code&gt;a.shape = s&lt;/code&gt;</source>
          <target state="translated">形状変更操作では、コピーが作成されないことを保証できません。形状を変更するには、 &lt;code&gt;a.shape = s&lt;/code&gt; 使用します</target>
        </trans-unit>
        <trans-unit id="f3c22a2794d4be1171f3bb3051bbeb72ad7588dd" translate="yes" xml:space="preserve">
          <source>The rest of the story</source>
          <target state="translated">物語の残りの部分</target>
        </trans-unit>
        <trans-unit id="2b262525b3075625bc8ca490c385d67e383e0b64" translate="yes" xml:space="preserve">
          <source>The rest of this document discusses working on the NumPy code base and documentation. We&amp;rsquo;re in the process of updating our descriptions of other activities and roles. If you are interested in these other activities, please contact us! You can do this via the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;numpy-discussion mailing list&lt;/a&gt;, or on &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;GitHub&lt;/a&gt; (open an issue or comment on a relevant issue). These are our preferred communication channels (open source is open by nature!), however if you prefer to discuss in private first, please reach out to our community coordinators at &lt;code&gt;numpy-team@googlegroups.com&lt;/code&gt; or &lt;code&gt;numpy-team.slack.com&lt;/code&gt; (send an email to &lt;code&gt;numpy-team@googlegroups.com&lt;/code&gt; for an invite the first time).</source>
          <target state="translated">このドキュメントの残りの部分では、NumPyコードベースとドキュメントでの作業について説明します。現在、他の活動や役割の説明を更新中です。これらの他の活動に興味がある場合は、お問い合わせください！これは、&lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;numpy-discussionメーリングリスト&lt;/a&gt;または&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;GitHubで&lt;/a&gt;行うことができます（問題を開くか、関連する問題にコメントします）。これらは私たちが好むコミュニケーションチャネルです（オープンソースは本質的にオープンです！）が、最初にプライベートで話し合うことを好む場合は、 &lt;code&gt;numpy-team@googlegroups.com&lt;/code&gt; または &lt;code&gt;numpy-team.slack.com&lt;/code&gt; （numpy-team.slack.com）のコミュニティコーディネーターに連絡してください。初めて招待するために &lt;code&gt;numpy-team@googlegroups.com&lt;/code&gt; にメールを送信してください）。</target>
        </trans-unit>
        <trans-unit id="efae226cd4ce4ec97472c40d085c0b19d6b0deb7" translate="yes" xml:space="preserve">
          <source>The rest of this page will give you a basic idea of how to add unit tests to modules in SciPy. It is extremely important for us to have extensive unit testing since this code is going to be used by scientists and researchers and is being developed by a large number of people spread across the world. So, if you are writing a package that you&amp;rsquo;d like to become part of SciPy, please write the tests as you develop the package. Also since much of SciPy is legacy code that was originally written without unit tests, there are still several modules that don&amp;rsquo;t have tests yet. Please feel free to choose one of these modules and develop tests for it as you read through this introduction.</source>
          <target state="translated">このページの残りの部分では、ユニットテストをSciPyのモジュールに追加する方法の基本的な考え方を説明します。このコードは科学者や研究者によって使用され、世界中に広がる多数の人々によって開発されているため、広範なユニットテストを実施することは非常に重要です。したがって、SciPyの一部になりたいパッケージを作成している場合は、パッケージを開発するときにテストを作成してください。また、SciPyの多くは元々ユニットテストなしで作成されたレガシーコードであるため、まだテストを行っていないモジュールがいくつかあります。この紹介を読みながら、これらのモジュールの1つを選択してテストを開発してください。</target>
        </trans-unit>
        <trans-unit id="90738a573063433b40a2bef8dfa08dda95ee95c6" translate="yes" xml:space="preserve">
          <source>The result can be used to construct a datetime that uses the same units as a timedelta</source>
          <target state="translated">その結果を使って、timedeltaと同じ単位を使ったdatetimeを構築することができます。</target>
        </trans-unit>
        <trans-unit id="8baf21a4c319c73c6c3f91016a95ecc1ae5e1dca" translate="yes" xml:space="preserve">
          <source>The result depends on the bit-width:</source>
          <target state="translated">結果はビット幅に依存します。</target>
        </trans-unit>
        <trans-unit id="7a004033c9a8a28e785dfe7afb00d43720c2d90c" translate="yes" xml:space="preserve">
          <source>The result is &lt;strong&gt;not&lt;/strong&gt; a MaskedArray!</source>
          <target state="translated">結果はMaskedArrayではあり&lt;strong&gt;ません&lt;/strong&gt;！</target>
        </trans-unit>
        <trans-unit id="88b2f160b598518e6df066363213cebfd6339e40" translate="yes" xml:space="preserve">
          <source>The result is an inverse for &lt;code&gt;a&lt;/code&gt; relative to the tensordot operation &lt;code&gt;tensordot(a, b, ind)&lt;/code&gt;, i. e., up to floating-point accuracy, &lt;code&gt;tensordot(tensorinv(a), a, ind)&lt;/code&gt; is the &amp;ldquo;identity&amp;rdquo; tensor for the tensordot operation.</source>
          <target state="translated">結果は、テンソルドット演算 &lt;code&gt;tensordot(a, b, ind)&lt;/code&gt; に対する &lt;code&gt;a&lt;/code&gt; の逆です。つまり、浮動小数点精度まで、 &lt;code&gt;tensordot(tensorinv(a), a, ind)&lt;/code&gt; は、テンソルドットの「同一性」テンソルです操作。</target>
        </trans-unit>
        <trans-unit id="1513bc4b365343f54e37e3a0463aec42e49631e5" translate="yes" xml:space="preserve">
          <source>The result is equivalent to the previous example where &lt;code&gt;b&lt;/code&gt; was an array. We can think of the scalar &lt;code&gt;b&lt;/code&gt; being &lt;em&gt;stretched&lt;/em&gt; during the arithmetic operation into an array with the same shape as &lt;code&gt;a&lt;/code&gt;. The new elements in &lt;code&gt;b&lt;/code&gt; are simply copies of the original scalar. The stretching analogy is only conceptual. NumPy is smart enough to use the original scalar value without actually making copies so that broadcasting operations are as memory and computationally efficient as possible.</source>
          <target state="translated">結果は、 &lt;code&gt;b&lt;/code&gt; が配列である前の例と同等です。我々は、スカラーと考えることができ &lt;code&gt;b&lt;/code&gt; れて&lt;em&gt;延伸&lt;/em&gt;と同じ形状を持つ配列に演算中。 &lt;code&gt;b&lt;/code&gt; の新しい要素は、元のスカラーの単なるコピーです。ストレッチのアナロジーは概念的なものにすぎません。 NumPyは、実際にコピーを作成せずに元のスカラー値を使用するのに十分スマートであるため、ブロードキャスト操作は可能な限りメモリと計算効率が高くなります。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b234fdc2574c2d15c385cc66cebde459f6f8d571" translate="yes" xml:space="preserve">
          <source>The result is equivalent to the previous example where &lt;code&gt;b&lt;/code&gt; was an array. We can think of the scalar &lt;code&gt;b&lt;/code&gt; being stretched during the arithmetic operation into an array with the same shape as &lt;code&gt;a&lt;/code&gt;. The new elements in &lt;code&gt;b&lt;/code&gt;, as shown in &lt;a href=&quot;#figure-1&quot;&gt;Figure 1&lt;/a&gt;, are simply copies of the original scalar. The stretching analogy is only conceptual. numpy is smart enough to use the original scalar value without actually making copies so that broadcasting operations are as memory and computationally efficient as possible. Because &lt;a href=&quot;#example-2&quot;&gt;Example 2&lt;/a&gt; moves less memory, (&lt;code&gt;b&lt;/code&gt; is a scalar, not an array) around during the multiplication, it is about 10% faster than &lt;a href=&quot;#example-1&quot;&gt;Example 1&lt;/a&gt; using the standard numpy on Windows 2000 with one million element arrays.</source>
          <target state="translated">結果は、 &lt;code&gt;b&lt;/code&gt; が配列である前の例と同等です。我々は、スカラーと考えることができ &lt;code&gt;b&lt;/code&gt; と同じ形状を持つ配列に演算中に延伸されます。&lt;a href=&quot;#figure-1&quot;&gt;図1&lt;/a&gt;に示すように、 &lt;code&gt;b&lt;/code&gt; の新しい要素は、元のスカラーの単なるコピーです。ストレッチのアナロジーは概念的なものにすぎません。 numpyは、実際にコピーを作成せずに元のスカラー値を使用できるほどスマートであるため、ブロードキャスト操作は可能な限りメモリと計算効率が高くなります。&lt;a href=&quot;#example-2&quot;&gt;例2&lt;/a&gt;は、乗算中に移動するメモリが少ないため（ &lt;code&gt;b&lt;/code&gt; はスカラーであり、配列ではありません）、&lt;a href=&quot;#example-1&quot;&gt;例1&lt;/a&gt;よりも約10％高速です。 &lt;code&gt;a&lt;/code&gt; 100万個の要素配列を持つWindows2000の標準numpyを使用します。</target>
        </trans-unit>
        <trans-unit id="d98fd654993b2c5bc8c34d84506f2eeb585bf55f" translate="yes" xml:space="preserve">
          <source>The result is padded to full bytes by inserting zero bits at the end.</source>
          <target state="translated">結果は、最後にゼロビットを挿入することでフルバイトにパディングされます。</target>
        </trans-unit>
        <trans-unit id="a05d82855a760b96ff01a98014b6f39cd92699f0" translate="yes" xml:space="preserve">
          <source>The result is returned as a boolean array.</source>
          <target state="translated">結果はブール値の配列として返されます。</target>
        </trans-unit>
        <trans-unit id="f9d8170d98950c22e6026933d7548298a3e52f98" translate="yes" xml:space="preserve">
          <source>The result is:</source>
          <target state="translated">結果が出ています。</target>
        </trans-unit>
        <trans-unit id="f485f36eec65ddcecdc4119f77e3da3d4540a73e" translate="yes" xml:space="preserve">
          <source>The result masks values that are masked in either &lt;code&gt;m1&lt;/code&gt; or &lt;code&gt;m2&lt;/code&gt;.</source>
          <target state="translated">結果は、 &lt;code&gt;m1&lt;/code&gt; または &lt;code&gt;m2&lt;/code&gt; のいずれかでマスクされている値をマスクします。</target>
        </trans-unit>
        <trans-unit id="93fabead91587e60c1a08bfee6b05728d77a4b94" translate="yes" xml:space="preserve">
          <source>The result may be a view on &lt;code&gt;m1&lt;/code&gt; or &lt;code&gt;m2&lt;/code&gt; if the other is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; (i.e. False).</source>
          <target state="translated">結果は、他の&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;がない場合（False）、 &lt;code&gt;m1&lt;/code&gt; または &lt;code&gt;m2&lt;/code&gt; のビューになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="12ea562d907c93ffb2a2a48a2ff38a17f82a53ed" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;cPickle.loads(strg)&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;cPickle.loads(strg)&lt;/code&gt; の結果が返されます。</target>
        </trans-unit>
        <trans-unit id="437933320e33dbd911c7ecb653e24b023c9820e4" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;x1 * 2**x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1 * 2**x2&lt;/code&gt; の結果。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="d200549129cf50987e2e3db04a3ddae4d86fd86e" translate="yes" xml:space="preserve">
          <source>The result of binning the input array. The length of &lt;code&gt;out&lt;/code&gt; is equal to &lt;code&gt;np.amax(x)+1&lt;/code&gt;.</source>
          <target state="translated">入力配列をビニングした結果。 &lt;code&gt;out&lt;/code&gt; の長さは &lt;code&gt;np.amax(x)+1&lt;/code&gt; に等しくなります。</target>
        </trans-unit>
        <trans-unit id="c6126cff082b1038f45f0cf4b879a12e8909f651" translate="yes" xml:space="preserve">
          <source>The result of indexing with a multi-field index is a view into the original array, as follows:</source>
          <target state="translated">マルチフィールドインデックスでインデックスを作成した結果は、以下のように元の配列へのビューとなります。</target>
        </trans-unit>
        <trans-unit id="b74fd032efc344495e89da82ba5cefb838c783f0" translate="yes" xml:space="preserve">
          <source>The result of masking &lt;code&gt;a&lt;/code&gt; where &lt;code&gt;condition&lt;/code&gt; is True.</source>
          <target state="translated">マスキングの結果 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;condition&lt;/code&gt; 真であるが。</target>
        </trans-unit>
        <trans-unit id="2f9d4558b4365ff73c9c67d9671ab31c28b67b0f" translate="yes" xml:space="preserve">
          <source>The result of masking &lt;code&gt;x&lt;/code&gt; where approximately equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">マスキングの結果 &lt;code&gt;x&lt;/code&gt; にほぼ等しい &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c8d1e813923a2b2b410b1cadd9d90a6a3b27803" translate="yes" xml:space="preserve">
          <source>The result of masking &lt;code&gt;x&lt;/code&gt; where equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; に等しい &lt;code&gt;x&lt;/code&gt; をマスキングした結果。</target>
        </trans-unit>
        <trans-unit id="20b27291ef8731ea508bbd0cd5e12a0ad3afd15b" translate="yes" xml:space="preserve">
          <source>The result of repeating &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">を繰り返し &lt;code&gt;a&lt;/code&gt; 結果。</target>
        </trans-unit>
        <trans-unit id="080be4f2b719d17ca857f6ff65fc2c9ddc4f8015" translate="yes" xml:space="preserve">
          <source>The result of the call to &lt;code&gt;function&lt;/code&gt; is passed back directly. Therefore the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; is completely determined by &lt;code&gt;function&lt;/code&gt;. If &lt;code&gt;function&lt;/code&gt; returns a scalar value, the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; would not match the &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; の呼び出しの結果は直接返されます。したがって、&lt;a href=&quot;#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt;の形状は &lt;code&gt;function&lt;/code&gt; によって完全に決定されます。 &lt;code&gt;function&lt;/code&gt; がスカラー値を返す場合、&lt;a href=&quot;#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt;の&lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;は形状パラメーターと一致しません。</target>
        </trans-unit>
        <trans-unit id="5a3504d8e95aae2a9b20b749f6d2c5a3889c5102" translate="yes" xml:space="preserve">
          <source>The result of the call to &lt;code&gt;function&lt;/code&gt; is passed back directly. Therefore the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; is completely determined by &lt;code&gt;function&lt;/code&gt;. If &lt;code&gt;function&lt;/code&gt; returns a scalar value, the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; would not match the &lt;code&gt;shape&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; の呼び出しの結果は直接渡されます。したがって、&lt;a href=&quot;#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt;の形状は完全に &lt;code&gt;function&lt;/code&gt; によって決まります。 &lt;code&gt;function&lt;/code&gt; がスカラー値を返す場合、&lt;a href=&quot;#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt;の &lt;code&gt;shape&lt;/code&gt; は形状パラメーターと一致しません。</target>
        </trans-unit>
        <trans-unit id="02a8e58b3d72e0b52f3592cd0fcb4ec46672a2f6" translate="yes" xml:space="preserve">
          <source>The result of the call to &lt;code&gt;function&lt;/code&gt; is passed back directly. Therefore the shape of &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; is completely determined by &lt;code&gt;function&lt;/code&gt;. If &lt;code&gt;function&lt;/code&gt; returns a scalar value, the shape of &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; would not match the &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; の呼び出しの結果は直接渡されます。したがって、&lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt;の形状は完全に &lt;code&gt;function&lt;/code&gt; によって決まります。 &lt;code&gt;function&lt;/code&gt; がスカラー値を返す場合、&lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt;の&lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;は形状パラメーターと一致しません。</target>
        </trans-unit>
        <trans-unit id="be63aee25a235ea7ecaebcc7084bf9b89e5f1ba3" translate="yes" xml:space="preserve">
          <source>The result of the inverse real 2-D FFT.</source>
          <target state="translated">逆実2次元FFTの結果。</target>
        </trans-unit>
        <trans-unit id="0a8c1e8c657004ada13d1bd67fea4f58af8cdb70" translate="yes" xml:space="preserve">
          <source>The result of the modulo operation for negative dividend and divisors is bound by conventions. For &lt;a href=&quot;#numpy.fmod&quot;&gt;&lt;code&gt;fmod&lt;/code&gt;&lt;/a&gt;, the sign of result is the sign of the dividend, while for &lt;a href=&quot;numpy.remainder#numpy.remainder&quot;&gt;&lt;code&gt;remainder&lt;/code&gt;&lt;/a&gt; the sign of the result is the sign of the divisor. The &lt;a href=&quot;#numpy.fmod&quot;&gt;&lt;code&gt;fmod&lt;/code&gt;&lt;/a&gt; function is equivalent to the Matlab(TM) &lt;code&gt;rem&lt;/code&gt; function.</source>
          <target state="translated">負の被除数と除数のモジュロ演算の結果は、慣例に拘束されます。ため&lt;a href=&quot;#numpy.fmod&quot;&gt; &lt;code&gt;fmod&lt;/code&gt; &lt;/a&gt;ためながら、結果の符号は、被除数の符号である&lt;a href=&quot;numpy.remainder#numpy.remainder&quot;&gt; &lt;code&gt;remainder&lt;/code&gt; &lt;/a&gt;結果の符号は除数の符号です。&lt;a href=&quot;#numpy.fmod&quot;&gt; &lt;code&gt;fmod&lt;/code&gt; &lt;/a&gt;関数は、MATLAB（登録商標）と同等である &lt;code&gt;rem&lt;/code&gt; 機能。</target>
        </trans-unit>
        <trans-unit id="432755e899e9d369003d6c1f79ef56f8c75f0660" translate="yes" xml:space="preserve">
          <source>The result of the real 2-D FFT.</source>
          <target state="translated">実質2次元FFTの結果。</target>
        </trans-unit>
        <trans-unit id="a62988dd4c556a700006b20bcac64bfa1f21b000" translate="yes" xml:space="preserve">
          <source>The result of this is always a 2d array, with a row for each non-zero element.</source>
          <target state="translated">この結果は常に2次元配列となり、0以外の要素にはそれぞれ行が入ります。</target>
        </trans-unit>
        <trans-unit id="552e732df1a7e97a3ac3793f40b01156b930c9d2" translate="yes" xml:space="preserve">
          <source>The result of trimming the input. The input data type is preserved.</source>
          <target state="translated">入力をトリミングした結果です。入力データ型は保存されます。</target>
        </trans-unit>
        <trans-unit id="0ff6806d85e8fabd807a03dd151b7e1cdd284df8" translate="yes" xml:space="preserve">
          <source>The result type.</source>
          <target state="translated">結果の種類。</target>
        </trans-unit>
        <trans-unit id="101ce3a3f58e25741f8924a6b8d0cfd25472eeff" translate="yes" xml:space="preserve">
          <source>The result will be multidimensional if y has more dimensions than b. For example:</source>
          <target state="translated">例えば、yがbよりも多くの次元を持っている場合、結果は多次元になります。</target>
        </trans-unit>
        <trans-unit id="e2a369eb25dfa6d23e15865ad12a81c98b2538db" translate="yes" xml:space="preserve">
          <source>The result.</source>
          <target state="translated">結果が出ました。</target>
        </trans-unit>
        <trans-unit id="d1fb43fabbedcad07c574b0e98cbace4463e697f" translate="yes" xml:space="preserve">
          <source>The resulting approximation of</source>
          <target state="translated">の結果として得られる近似値は</target>
        </trans-unit>
        <trans-unit id="8f5a6724cd845387db9fbc4a8e08fe47ae3e4ec1" translate="yes" xml:space="preserve">
          <source>The resulting array is a view into the original array. It shares the same memory locations and writing to the view will modify the original array.</source>
          <target state="translated">結果として得られる配列は、元の配列へのビューとなります。これは同じメモリ位置を共有しており、ビューへの書き込みは元の配列を変更します。</target>
        </trans-unit>
        <trans-unit id="a4450860735a4299b5638f4df95ccd877c9615a2" translate="yes" xml:space="preserve">
          <source>The resulting array therefore has a value &lt;code&gt;fn(x, y, z)&lt;/code&gt; at coordinate &lt;code&gt;(x, y, z)&lt;/code&gt;.</source>
          <target state="translated">したがって、結果の配列は、座標 &lt;code&gt;(x, y, z)&lt;/code&gt; 値 &lt;code&gt;fn(x, y, z)&lt;/code&gt; を持ちます。</target>
        </trans-unit>
        <trans-unit id="8e45fa029de06ce207816940e254f28318e174ec" translate="yes" xml:space="preserve">
          <source>The resulting path indicates which terms of the input contraction should be contracted first, the result of this contraction is then appended to the end of the contraction list. This list can then be iterated over until all intermediate contractions are complete.</source>
          <target state="translated">結果として得られるパスは、入力された縮約のどの項を最初に縮約すべきかを示し、この縮約の結果が縮約リストの最後に追加されます。このリストは、すべての中間縮約が完了するまで繰り返し実行されます。</target>
        </trans-unit>
        <trans-unit id="b0397bb7d27e88275099d7a9e2663ecd158fec65" translate="yes" xml:space="preserve">
          <source>The resulting signature for the function add.zadd is exactly the same one that was created previously. If the original source code had contained &lt;code&gt;A(N)&lt;/code&gt; instead of &lt;code&gt;A(*)&lt;/code&gt; and so forth with &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;, then I could obtain (nearly) the same interface simply by placing the &lt;code&gt;INTENT(OUT) :: C&lt;/code&gt; comment line in the source code. The only difference is that &lt;code&gt;N&lt;/code&gt; would be an optional input that would default to the length of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">関数add.zaddの結果の署名は、以前に作成されたものとまったく同じです。元のソースコードに &lt;code&gt;B&lt;/code&gt; と &lt;code&gt;C&lt;/code&gt; で &lt;code&gt;A(*)&lt;/code&gt; などの代わりに &lt;code&gt;A(N)&lt;/code&gt; が含まれていた場合、 &lt;code&gt;INTENT(OUT) :: C&lt;/code&gt; コメント行をに配置するだけで（ほぼ）同じインターフェイスを取得できます。ソースコード。唯一の違いは、 &lt;code&gt;N&lt;/code&gt; がオプションの入力であり、デフォルトで &lt;code&gt;A&lt;/code&gt; の長さになることです。</target>
        </trans-unit>
        <trans-unit id="4e44a556cdbd9e08c1c73c688efe96d93b4a9c2d" translate="yes" xml:space="preserve">
          <source>The results have only been tested up to degree 100 higher degrees may be problematic. The weights are determined by using the fact that</source>
          <target state="translated">結果は100度までしか検証されていませんが、問題があるかもしれません。という事実を利用して重みを決定しています。</target>
        </trans-unit>
        <trans-unit id="ef4a7d2bf5791e871493bd9bc1998dc73f56d092" translate="yes" xml:space="preserve">
          <source>The results have only been tested up to degree 100, higher degrees may be problematic. For Gauss-Chebyshev there are closed form solutions for the sample points and weights. If n = &lt;code&gt;deg&lt;/code&gt;, then</source>
          <target state="translated">結果は100度までしかテストされていないため、より高い度数では問題が生じる可能性があります。Gauss-Chebyshevの場合、サンプルポイントと重みの閉形式の解があります。n = &lt;code&gt;deg&lt;/code&gt; の場合、</target>
        </trans-unit>
        <trans-unit id="7a2a5f718e6f28fd9a2d71c1fb3ee2ee9fe5b2fb" translate="yes" xml:space="preserve">
          <source>The results have only been tested up to degree 100, higher degrees may be problematic. The weights are determined by using the fact that</source>
          <target state="translated">結果は度数100までしかテストされていないので、それ以上の度数は問題があるかもしれません。重みは、次のような事実を利用して決定されます。</target>
        </trans-unit>
        <trans-unit id="af6fbd4d24683930cbf1a134289a3df4c1b144c3" translate="yes" xml:space="preserve">
          <source>The results will be placed in this array. It may be the input array for in-place clipping. &lt;code&gt;out&lt;/code&gt; must be of the right shape to hold the output. Its type is preserved.</source>
          <target state="translated">結果はこの配列に配置されます。インプレースクリッピングの入力配列になる場合があります。 &lt;code&gt;out&lt;/code&gt; 出力を保持する権利形状のものでなければなりません。そのタイプは保持されます。</target>
        </trans-unit>
        <trans-unit id="c6b62851dacdc54d8864ac2edf1604fc62b66dd6" translate="yes" xml:space="preserve">
          <source>The return statement should &lt;em&gt;not&lt;/em&gt; get redundant parentheses:</source>
          <target state="translated">returnステートメントは冗長な括弧を取得し&lt;em&gt;ないで&lt;/em&gt;ください。</target>
        </trans-unit>
        <trans-unit id="9002868afc12284eedaa4f924eaaabb6a7944154" translate="yes" xml:space="preserve">
          <source>The return type will always be an inexact (i.e. floating point) scalar type, even if all the arrays are integer arrays. If one of the inputs is an integer array, the minimum precision type that is returned is a 64-bit floating point dtype.</source>
          <target state="translated">すべての配列が整数配列であっても,戻り値の型は常に不正確な(つまり浮動小数点の)スカラ型になります.入力の1つが整数配列の場合、返される最小精度の型は64ビット浮動小数点dtypeです。</target>
        </trans-unit>
        <trans-unit id="273dde020fc2e47183998cc14b3fb20e4a9436a7" translate="yes" xml:space="preserve">
          <source>The return value is 0 on success, -1 on failure.</source>
          <target state="translated">成功した場合は0、失敗した場合は-1を返します。</target>
        </trans-unit>
        <trans-unit id="95baf9f3feb186151992e17419a9d52bee50a218" translate="yes" xml:space="preserve">
          <source>The return value is the same shape and type as &lt;code&gt;M&lt;/code&gt;; if the exponent is positive or zero then the type of the elements is the same as those of &lt;code&gt;M&lt;/code&gt;. If the exponent is negative the elements are floating-point.</source>
          <target state="translated">戻り値は &lt;code&gt;M&lt;/code&gt; と同じ形状と型です。指数が正またはゼロの場合、要素のタイプは &lt;code&gt;M&lt;/code&gt; のタイプと同じです。指数が負の場合、要素は浮動小数点です。</target>
        </trans-unit>
        <trans-unit id="55801c938cbd16156c4c8c48d17f11e40e4107d9" translate="yes" xml:space="preserve">
          <source>The return value of failed converter functions which are called using the &amp;ldquo;O&amp;amp;&amp;rdquo; syntax in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt;-like functions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; の&lt;/a&gt;ような関数で「O＆」構文を使用して呼び出された、失敗したコンバーター関数の戻り値。</target>
        </trans-unit>
        <trans-unit id="41e4fb8b6c4e49bb724d556b26ed34481cfcd6dd" translate="yes" xml:space="preserve">
          <source>The return value of successful converter functions which are called using the &amp;ldquo;O&amp;amp;&amp;rdquo; syntax in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt;-like functions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; の&lt;/a&gt;ような関数で「O＆」構文を使用して呼び出された、成功したコンバーター関数の戻り値。</target>
        </trans-unit>
        <trans-unit id="c05aab266b5f8aae47c5e7319a883da33ec4e284" translate="yes" xml:space="preserve">
          <source>The return value, False if &lt;code&gt;x&lt;/code&gt; is of a complex type.</source>
          <target state="translated">戻り値、 &lt;code&gt;x&lt;/code&gt; が複合型の場合はFalse 。</target>
        </trans-unit>
        <trans-unit id="c002d9b8869cd4388cf5943fa7426632d76c13b5" translate="yes" xml:space="preserve">
          <source>The return value, True if &lt;code&gt;x&lt;/code&gt; is of a complex type or has at least one complex element.</source>
          <target state="translated">戻り値、 &lt;code&gt;x&lt;/code&gt; が複合型の場合、または少なくとも1つの複合要素がある場合はTrue 。</target>
        </trans-unit>
        <trans-unit id="8cacfcdc238ffe8ba32e3f60b54d5d84f6258480" translate="yes" xml:space="preserve">
          <source>The returned array has the same type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">返される配列は、同じタイプ有します。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8984b85b3f1b178d24103374b554ddde5426110f" translate="yes" xml:space="preserve">
          <source>The returned array is always 1D.</source>
          <target state="translated">返される配列は常に1Dです。</target>
        </trans-unit>
        <trans-unit id="59afb62c6311159c3a4c4a5a09d0fcb3d683db81" translate="yes" xml:space="preserve">
          <source>The returned array is always a structured array, and is constructed from all matches of the regular expression in the file. Groups in the regular expression are converted to fields of the structured array.</source>
          <target state="translated">返される配列は常に構造化された配列で、ファイル内の正規表現のすべてのマッチから構築されます。正規表現のグループは構造化配列のフィールドに変換されます。</target>
        </trans-unit>
        <trans-unit id="235ae9f13128943772ff554e126bc69621884d0e" translate="yes" xml:space="preserve">
          <source>The returned array will be guaranteed to have the listed requirements by making a copy if needed.</source>
          <target state="translated">返された配列は、必要に応じてコピーを作成することで、リストされた要件を持つことが保証されます。</target>
        </trans-unit>
        <trans-unit id="4d7c736b03b1eeb7cc2b9172d888763588690bd3" translate="yes" xml:space="preserve">
          <source>The returned array will have at least &lt;code&gt;ndmin&lt;/code&gt; dimensions. Otherwise mono-dimensional axes will be squeezed. Legal values: 0 (default), 1 or 2.</source>
          <target state="translated">返される配列には、少なくとも &lt;code&gt;ndmin&lt;/code&gt; の次元があります。そうしないと、1次元の軸が圧縮されます。有効な値：0（デフォルト）、1または2。</target>
        </trans-unit>
        <trans-unit id="0991fc7713b9227f260fa7eb1775e9a559dcb08f" translate="yes" xml:space="preserve">
          <source>The returned class can be of different type than the current instance and/or have a different domain and/or different window.</source>
          <target state="translated">返されるクラスは、現在のインスタンスとは異なるタイプのものであってもよいし、異なるドメインおよび/または異なるウィンドウを持つものであってもよい。</target>
        </trans-unit>
        <trans-unit id="f40fdf0f51a86b8b90c8d1563cabe3126d1130f1" translate="yes" xml:space="preserve">
          <source>The returned float array &lt;code&gt;f&lt;/code&gt; contains the frequency bin centers in cycles per unit of the sample spacing (with zero at the start). For instance, if the sample spacing is in seconds, then the frequency unit is cycles/second.</source>
          <target state="translated">返されるfloat配列 &lt;code&gt;f&lt;/code&gt; には、周波数間隔の中心がサンプル間隔の単位あたりのサイクルで含まれます（最初はゼロ）。たとえば、サンプル間隔が秒単位の場合、周波数の単位はサイクル/秒です。</target>
        </trans-unit>
        <trans-unit id="235d36eec348db0a4ce24e42c9d6a7df17b250d1" translate="yes" xml:space="preserve">
          <source>The returned indices will be valid to access arrays of shape (n, n).</source>
          <target state="translated">返されたインデックスは、シェイプ(n,n)の配列にアクセスするために有効になります。</target>
        </trans-unit>
        <trans-unit id="ae4549a46a428a48cedb9424b21a41ed06873386" translate="yes" xml:space="preserve">
          <source>The returned list contains array(s) of dtype double, complex double, or object. A 1-d argument of shape &lt;code&gt;(N,)&lt;/code&gt; is parsed into &lt;code&gt;N&lt;/code&gt; arrays of size one; a 2-d argument of shape &lt;code&gt;(M,N)&lt;/code&gt; is parsed into &lt;code&gt;M&lt;/code&gt; arrays of size &lt;code&gt;N&lt;/code&gt; (i.e., is &amp;ldquo;parsed by row&amp;rdquo;); and a higher dimensional array raises a Value Error if it is not first reshaped into either a 1-d or 2-d array.</source>
          <target state="translated">返されるリストには、dtype double、complex double、またはオブジェクトの配列が含まれています。形状 &lt;code&gt;(N,)&lt;/code&gt; の1次元引数は、サイズ1の &lt;code&gt;N&lt;/code&gt; 個の配列に解析されます。形状 &lt;code&gt;(M,N)&lt;/code&gt; 2次元引数は、サイズ &lt;code&gt;N&lt;/code&gt; の &lt;code&gt;M&lt;/code&gt; 配列に解析されます（つまり、「行で解析」されます）。より高次元の配列は、最初に1次元または2次元配列に再形成されない場合、値エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="14f1e30e33046331e7dfbbcb8096ad0d5112d69f" translate="yes" xml:space="preserve">
          <source>The returned object is an object of Python-type &lt;em&gt;subtype&lt;/em&gt;, which must be a subtype of &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;. The array has &lt;em&gt;nd&lt;/em&gt; dimensions, described by &lt;em&gt;dims&lt;/em&gt;. The data-type descriptor of the new array is &lt;em&gt;descr&lt;/em&gt;.</source>
          <target state="translated">返されるオブジェクトはPythonタイプの&lt;em&gt;サブタイプの&lt;/em&gt;オブジェクトであり、&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; の&lt;/a&gt;&lt;em&gt;サブタイプ&lt;/em&gt;である必要があります。配列には、&lt;em&gt;dims&lt;/em&gt;によって記述される&lt;em&gt;nd&lt;/em&gt;次元があります。新しい配列のデータ型記述子は&lt;em&gt;descr&lt;/em&gt;です。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="32e057c6946960f31384643bb71f5913a86433e2" translate="yes" xml:space="preserve">
          <source>The returned object is an object of Python-type &lt;em&gt;subtype&lt;/em&gt;, which must be a subtype of &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;. The array has &lt;em&gt;nd&lt;/em&gt; dimensions, described by &lt;em&gt;dims&lt;/em&gt;. The data-type descriptor of the new array is &lt;em&gt;descr&lt;/em&gt;.</source>
          <target state="translated">返されるオブジェクトはPythonタイプの&lt;em&gt;サブタイプの&lt;/em&gt;オブジェクトであり、&lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; の&lt;/a&gt;&lt;em&gt;サブタイプ&lt;/em&gt;である必要があります。配列には、&lt;em&gt;dims&lt;/em&gt;で記述された&lt;em&gt;nd&lt;/em&gt;次元があります。新しい配列のデータ型記述子は&lt;em&gt;descr&lt;/em&gt;です。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5d88cddc6712bcffcc47387ee400aa7949d299dc" translate="yes" xml:space="preserve">
          <source>The returned order &lt;code&gt;m&lt;/code&gt; antiderivative &lt;code&gt;P&lt;/code&gt; of polynomial &lt;code&gt;p&lt;/code&gt; satisfies</source>
          <target state="translated">返された次数 &lt;code&gt;m&lt;/code&gt; 不定積分 &lt;code&gt;P&lt;/code&gt; 多項式の &lt;code&gt;p&lt;/code&gt; 個の満足</target>
        </trans-unit>
        <trans-unit id="0b8999800a1f602548a03b4247be14d85063c532" translate="yes" xml:space="preserve">
          <source>The returned pointer will keep a reference to the array.</source>
          <target state="translated">返されたポインタは配列への参照を保持します。</target>
        </trans-unit>
        <trans-unit id="592b730c2fcc65333034a0c7238210b05d5a5c20" translate="yes" xml:space="preserve">
          <source>The returned tuple can be passed as the second argument of &lt;code&gt;numpy.datetime64&lt;/code&gt; and &lt;code&gt;numpy.timedelta64&lt;/code&gt;.</source>
          <target state="translated">返されるタプルは、 &lt;code&gt;numpy.datetime64&lt;/code&gt; および &lt;code&gt;numpy.timedelta64&lt;/code&gt; の 2番目の引数として渡すことができます。</target>
        </trans-unit>
        <trans-unit id="f91874be1de458c40a0f1f04bc921bf313bf20d4" translate="yes" xml:space="preserve">
          <source>The returned tuple has the following items:</source>
          <target state="translated">返されたタプルには以下の項目があります。</target>
        </trans-unit>
        <trans-unit id="cef76c21baa4e56901ef823fceedd7a7068daf4e" translate="yes" xml:space="preserve">
          <source>The returned type character must represent the smallest size dtype such that an array of the returned type can handle the data from an array of all types in &lt;code&gt;typechars&lt;/code&gt; (or if &lt;code&gt;typechars&lt;/code&gt; is an array, then its dtype.char).</source>
          <target state="translated">返される型の文字は、返される型の配列が &lt;code&gt;typechars&lt;/code&gt; のすべての型の配列からのデータを処理できるように、最小サイズのdtypeを表す必要があります（または &lt;code&gt;typechars&lt;/code&gt; が配列の場合は、そのdtype.char）。</target>
        </trans-unit>
        <trans-unit id="4fcc4213866e3a2e0117cc077e63fcf825ea6d85" translate="yes" xml:space="preserve">
          <source>The returned ufunc always returns PyObject arrays.</source>
          <target state="translated">返された ufunc は常に PyObject の配列を返します。</target>
        </trans-unit>
        <trans-unit id="a3367f678ba189a0a7553569bd4ae4f1aabaa222" translate="yes" xml:space="preserve">
          <source>The returned ufunc object is a callable Python object. It should be placed in a (module) dictionary under the same name as was used in the name argument to the ufunc-creation routine. The following example is adapted from the umath module</source>
          <target state="translated">返される ufunc オブジェクトは、呼び出し可能な Python オブジェクトです。これは、ufunc-creationルーチンのname引数で使用された名前と同じ名前で、(モジュール)辞書に配置されなければなりません。以下の例は umath モジュールの</target>
        </trans-unit>
        <trans-unit id="15355fac5e58f997eedbca2c4b98e86da4be8c2c" translate="yes" xml:space="preserve">
          <source>The returned values define a linear map &lt;code&gt;off + scl*x&lt;/code&gt; that is applied to the input arguments before the series is evaluated. The map depends on the &lt;code&gt;domain&lt;/code&gt; and &lt;code&gt;window&lt;/code&gt;; if the current &lt;code&gt;domain&lt;/code&gt; is equal to the &lt;code&gt;window&lt;/code&gt; the resulting map is the identity. If the coefficients of the series instance are to be used by themselves outside this class, then the linear function must be substituted for the &lt;code&gt;x&lt;/code&gt; in the standard representation of the base polynomials.</source>
          <target state="translated">戻り値は、シリーズが評価される前に入力引数に適用される線形マップ &lt;code&gt;off + scl*x&lt;/code&gt; を定義します。マップは &lt;code&gt;domain&lt;/code&gt; と &lt;code&gt;window&lt;/code&gt; によって異なります。現在の &lt;code&gt;domain&lt;/code&gt; が &lt;code&gt;window&lt;/code&gt; と等しい場合、結果のマップはアイデンティティです。系列インスタンスの係数をこのクラスの外で単独で使用する場合は、基本多項式の標準表現の &lt;code&gt;x&lt;/code&gt; を線形関数で置き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="0b9b48003d17ce5e05cd985e616cb02707b4abeb" translate="yes" xml:space="preserve">
          <source>The role of &lt;code&gt;__array_finalize__&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__array_finalize__&lt;/code&gt; の役割</target>
        </trans-unit>
        <trans-unit id="ee620d4452ada0e1d6c1803fadfa839462d12739" translate="yes" xml:space="preserve">
          <source>The root estimates are obtained as the eigenvalues of the companion matrix, Roots far from the origin of the complex plane may have large errors due to the numerical instability of the power series for such values. Roots with multiplicity greater than 1 will also show larger errors as the value of the series near such points is relatively insensitive to errors in the roots. Isolated roots near the origin can be improved by a few iterations of Newton&amp;rsquo;s method.</source>
          <target state="translated">根の推定値は、コンパニオンマトリックスの固有値として取得されます。複素平面の原点から離れた根には、そのような値のべき級数の数値的不安定性のために大きな誤差が生じる可能性があります。多重度が1より大きい根も、そのような点の近くの系列の値が根の誤差に比較的鈍感であるため、より大きい誤差を示します。原点近くの孤立した根は、ニュートン法を数回繰り返すことで改善できます。</target>
        </trans-unit>
        <trans-unit id="f62c87e72745436aa10f6d1a92b0a21eb2cc7b33" translate="yes" xml:space="preserve">
          <source>The root estimates are obtained as the eigenvalues of the companion matrix, Roots far from the origin of the complex plane may have large errors due to the numerical instability of the series for such values. Roots with multiplicity greater than 1 will also show larger errors as the value of the series near such points is relatively insensitive to errors in the roots. Isolated roots near the origin can be improved by a few iterations of Newton&amp;rsquo;s method.</source>
          <target state="translated">根の推定値は、コンパニオンマトリックスの固有値として取得されます。複素平面の原点から離れた根は、そのような値の系列の数値的不安定性のために大きな誤差を生じる可能性があります。多重度が1より大きい根も、そのような点の近くの系列の値が根の誤差に比較的鈍感であるため、より大きい誤差を示します。原点近くの孤立した根は、ニュートン法を数回繰り返すことで改善できます。</target>
        </trans-unit>
        <trans-unit id="a8ae81d114b6feba67040d0b0dda1df226f1fa7e" translate="yes" xml:space="preserve">
          <source>The roots of the polynomial, where self(x) == 0</source>
          <target state="translated">self(x)==0 である多項式の根</target>
        </trans-unit>
        <trans-unit id="b31543f4d0be4f9892b87954c40031df062dff89" translate="yes" xml:space="preserve">
          <source>The row dimension of the arrays for which the returned indices will be valid.</source>
          <target state="translated">返されたインデックスが有効になる配列の行の次元。</target>
        </trans-unit>
        <trans-unit id="0cdec07351f87c4df86a480e3a89d1fead72ecd2" translate="yes" xml:space="preserve">
          <source>The rtype argument specifies the data-type the reduction should take place over. This is important if the data-type of the array is not &amp;ldquo;large&amp;rdquo; enough to handle the output. By default, all integer data-types are made at least as large as &lt;a href=&quot;c-api.dtype#c.NPY_LONG&quot;&gt;&lt;code&gt;NPY_LONG&lt;/code&gt;&lt;/a&gt; for the &amp;ldquo;add&amp;rdquo; and &amp;ldquo;multiply&amp;rdquo; ufuncs (which form the basis for mean, sum, cumsum, prod, and cumprod functions).</source>
          <target state="translated">rtype引数は、削減が行われるデータ型を指定します。配列のデータ型が出力を処理するのに十分な大きさでない場合、これは重要です。デフォルトでは、すべての整数データ型は、少なくとも限り大きく作られる&lt;a href=&quot;c-api.dtype#c.NPY_LONG&quot;&gt; &lt;code&gt;NPY_LONG&lt;/code&gt; &lt;/a&gt;「追加」と（平均、合計、CUMSUM、PROD、及びcumprod機能のための基礎を形成する）、「乗算」ufuncsため。</target>
        </trans-unit>
        <trans-unit id="81acb42027d32e73c24e9573f794b96cf5d260da" translate="yes" xml:space="preserve">
          <source>The rtype argument specifies the data-type the reduction should take place over. This is important if the data-type of the array is not &amp;ldquo;large&amp;rdquo; enough to handle the output. By default, all integer data-types are made at least as large as &lt;a href=&quot;dtype#c.NPY_LONG&quot;&gt;&lt;code&gt;NPY_LONG&lt;/code&gt;&lt;/a&gt; for the &amp;ldquo;add&amp;rdquo; and &amp;ldquo;multiply&amp;rdquo; ufuncs (which form the basis for mean, sum, cumsum, prod, and cumprod functions).</source>
          <target state="translated">rtype引数は、削減が行われるべきデータ型を指定します。これは、配列のデータ型が出力を処理するのに十分な「大きさ」ではない場合に重要です。デフォルトでは、すべての整数データ型は、少なくとも限り大きく作られる&lt;a href=&quot;dtype#c.NPY_LONG&quot;&gt; &lt;code&gt;NPY_LONG&lt;/code&gt; &lt;/a&gt;「追加」と（平均、合計、CUMSUM、PROD、及びcumprod機能のための基礎を形成する）、「乗算」ufuncsため。</target>
        </trans-unit>
        <trans-unit id="bec28ce661286e5b1ead8f4ea14b439b8431742d" translate="yes" xml:space="preserve">
          <source>The rule governing whether two arrays have compatible shapes for broadcasting can be expressed in a single sentence.</source>
          <target state="translated">2つの配列が放送用に互換性のある形状を持つかどうかを規定するルールは、一文で表現することができる。</target>
        </trans-unit>
        <trans-unit id="3014977f10c304b722035fb1a265596f0e833693" translate="yes" xml:space="preserve">
          <source>The rules for ABI and API compatibilities can be summarized as follows:</source>
          <target state="translated">ABIとAPIの互換性に関するルールをまとめると以下のようになります。</target>
        </trans-unit>
        <trans-unit id="db5c92fbe4ce9110548aea4ebd5e7c863e8e7523" translate="yes" xml:space="preserve">
          <source>The same analysis could be done with several different interest rates and/or payments and/or total amounts to produce an entire table.</source>
          <target state="translated">同じ分析を、いくつかの異なる金利および/または支払額および/または合計額で行って、表全体を作成することができます。</target>
        </trans-unit>
        <trans-unit id="48a74e2709e394bc98ff4e370f8920b6550d09a0" translate="yes" xml:space="preserve">
          <source>The same function can operate on a 4-D array:</source>
          <target state="translated">4次元配列でも同じ機能を動作させることができます。</target>
        </trans-unit>
        <trans-unit id="54bfa0763e872f148814a7d73d89f2039603e607" translate="yes" xml:space="preserve">
          <source>The same gcc version is used as the one with which Python itself is built on each platform. At the moment this means:</source>
          <target state="translated">Python自体が各プラットフォームで構築されているものと同じgcc版を使用しています。現時点ではこれを意味します。</target>
        </trans-unit>
        <trans-unit id="db94598647ae75e98a229d31f17501768537975a" translate="yes" xml:space="preserve">
          <source>The same results can be obtained by using the name of the second column (&lt;code&gt;&quot;p&quot;&lt;/code&gt;) as key instead of its index (1):</source>
          <target state="translated">インデックス（1）の代わりに2番目の列の名前（ &lt;code&gt;&quot;p&quot;&lt;/code&gt; ）をキーとして使用しても、同じ結果を得ることができます。</target>
        </trans-unit>
        <trans-unit id="0259137762b94ac22ad991901b42b9be660a1c59" translate="yes" xml:space="preserve">
          <source>The same works for max and min, if you expand the dimensions:</source>
          <target state="translated">寸法を拡大すれば、maxとminでも同じように動作します。</target>
        </trans-unit>
        <trans-unit id="2941e8dc3350840406ccff2f87675580f31546c3" translate="yes" xml:space="preserve">
          <source>The sample points corresponding to the &lt;code&gt;y&lt;/code&gt; values. If &lt;code&gt;x&lt;/code&gt; is None, the sample points are assumed to be evenly spaced &lt;code&gt;dx&lt;/code&gt; apart. The default is None.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 値に対応するサンプルポイント。場合 &lt;code&gt;x&lt;/code&gt; Noneです、サンプルポイントが等間隔されているものとする &lt;code&gt;dx&lt;/code&gt; 離れ。デフォルトは「なし」です。</target>
        </trans-unit>
        <trans-unit id="52ca25ab3ba5f07f393e1c15a4222278fa9f69d6" translate="yes" xml:space="preserve">
          <source>The scale of the gamma distribution. Must be non-negative. Default is equal to 1.</source>
          <target state="translated">ガンマ分布のスケール。非負でなければなりません。デフォルトは1です。</target>
        </trans-unit>
        <trans-unit id="db0a2a364021746365e2e2dca54712719a934f9d" translate="yes" xml:space="preserve">
          <source>The scale parameter of the distribution. Default is 1. Must be non- negative.</source>
          <target state="translated">分布のスケール・パラメータ。デフォルトは1です。</target>
        </trans-unit>
        <trans-unit id="da19b6d80b0b211e043d20a99e868d2264fb18da" translate="yes" xml:space="preserve">
          <source>The scale parameter,</source>
          <target state="translated">スケールパラメータ。</target>
        </trans-unit>
        <trans-unit id="162cbdbbbf1e2c84bee29866f841c84cd6b13d80" translate="yes" xml:space="preserve">
          <source>The scaling of the covariance matrix in &lt;code&gt;np.polyfit&lt;/code&gt; is different</source>
          <target state="translated">&lt;code&gt;np.polyfit&lt;/code&gt; の共分散行列のスケーリングが異なります</target>
        </trans-unit>
        <trans-unit id="7f0e6c0ce58755cae988a618ed26819ae121acf3" translate="yes" xml:space="preserve">
          <source>The scipy implementation is recommended over this function: it is a proper ufunc written in C, and more than an order of magnitude faster.</source>
          <target state="translated">scipy の実装はこの関数よりも推奨されます:C で書かれた適切な ufunc であり、桁違いに高速です。</target>
        </trans-unit>
        <trans-unit id="678645818896e353218894b08bcbb6e53102fa78" translate="yes" xml:space="preserve">
          <source>The scipy.org should be a PR at &lt;a href=&quot;https://github.com/scipy/scipy.org&quot;&gt;https://github.com/scipy/scipy.org&lt;/a&gt;. The file that needs modification is &lt;code&gt;www/index.rst&lt;/code&gt;. Search for &lt;code&gt;News&lt;/code&gt;.</source>
          <target state="translated">scipy.orgは&lt;a href=&quot;https://github.com/scipy/scipy.org&quot;&gt;https://github.com/scipy/scipy.orgの&lt;/a&gt;PRである必要があります。変更が必要なファイルは &lt;code&gt;www/index.rst&lt;/code&gt; です。 &lt;code&gt;News&lt;/code&gt; 検索します。</target>
        </trans-unit>
        <trans-unit id="076d96a74fdcb13373554cd33f5faa0a5c841024" translate="yes" xml:space="preserve">
          <source>The second argument passed in to the Py_InitModule function is a structure that makes it easy to to define functions in the module. In the example given above, the mymethods structure would have been defined earlier in the file (usually right before the init{name} subroutine) to:</source>
          <target state="translated">Py_InitModule 関数に渡される第二引数は、モジュール内の関数を簡単に定義できるようにするための構造体です。上の例では、mymethods 構造体はファイルの早い段階で(通常は init{name}サブルーチンの直前で)定義されています。</target>
        </trans-unit>
        <trans-unit id="f1d1e93a16e6953d6dc31578f1bc0e4185a42885" translate="yes" xml:space="preserve">
          <source>The second element, &lt;em&gt;field_dtype&lt;/em&gt;, can be anything that can be interpreted as a data-type.</source>
          <target state="translated">2番目の要素である&lt;em&gt;field_dtype&lt;/em&gt;は、データ型として解釈できるものであれば何でも&lt;em&gt;かまいませ&lt;/em&gt;ん。</target>
        </trans-unit>
        <trans-unit id="4ebced32cc87e2c3435e9151b36d6b3c2cfaf845" translate="yes" xml:space="preserve">
          <source>The second is to set the error-handler to &amp;lsquo;log&amp;rsquo;, using &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;. Floating-point errors then trigger a call to the &amp;lsquo;write&amp;rsquo; method of the provided object.</source>
          <target state="translated">2つ目は、&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt;を使用して、エラーハンドラーを 'log'に設定することです。次に、浮動小数点エラーにより、提供されたオブジェクトの「write」メソッドの呼び出しがトリガーされます。</target>
        </trans-unit>
        <trans-unit id="6f31ccc451074791f12a3d0394615bd3d0e3cdd2" translate="yes" xml:space="preserve">
          <source>The second issue to understand is how indices correspond to the order the array is stored in memory. In Fortran the first index is the most rapidly varying index when moving through the elements of a two dimensional array as it is stored in memory. If you adopt the matrix convention for indexing, then this means the matrix is stored one column at a time (since the first index moves to the next row as it changes). Thus Fortran is considered a Column-major language. C has just the opposite convention. In C, the last index changes most rapidly as one moves through the array as stored in memory. Thus C is a Row-major language. The matrix is stored by rows. Note that in both cases it presumes that the matrix convention for indexing is being used, i.e., for both Fortran and C, the first index is the row. Note this convention implies that the indexing convention is invariant and that the data order changes to keep that so.</source>
          <target state="translated">理解すべき2番目の問題は,配列がメモリに格納されている順序にインデックスがどのように対応するかということです.Fortranでは,メモリに格納されている2次元配列の要素を移動する際に,最初のインデックスが最も急激に変化するインデックスとなります.インデックス付けに行列の規則を採用すると、行列が一度に1列ずつ格納されることを意味します(最初のインデックスが変化すると次の行に移動するので)。このようにして、Fortranは列メジャー言語と考えられています。C言語は,ちょうどその逆の規則を持っています.C言語では、メモリに格納されている配列を移動する際に、最後のインデックスが最も速く変化します。したがって,C は行メジャー言語です.行列は行によって格納されます.どちらの場合も,行列のインデックス付けの規則が使用されていることを前提としていることに注意してください.この規則は,インデックス付けの規則が不変であることと,それを維持するためにデータの順序が変化することを意味していることに注意してください.</target>
        </trans-unit>
        <trans-unit id="453559558db2eb56414a46dbdb5de2376ea80083" translate="yes" xml:space="preserve">
          <source>The second rule of broadcasting ensures that arrays with a size of 1 along a particular dimension act as if they had the size of the array with the largest shape along that dimension. The value of the array element is assumed to be the same along that dimension for the &amp;ldquo;broadcast&amp;rdquo; array.</source>
          <target state="translated">ブロードキャストの2番目のルールは、特定の次元に沿ってサイズが1の配列が、その次元に沿って最大の形状を持つ配列のサイズを持っているかのように動作することを保証します。配列要素の値は、「ブロードキャスト」配列のその次元に沿って同じであると想定されます。</target>
        </trans-unit>
        <trans-unit id="fe0109b90f8697e3f57d897bca8c421d8285d2b1" translate="yes" xml:space="preserve">
          <source>The second way is to upload the PKG_INFO file inside the sdist dir in the web interface of PyPI. The source tarball can also be uploaded through this interface.</source>
          <target state="translated">2つ目の方法は、PyPI の Web インターフェースの sdist ディレクトリに PKG_INFO ファイルをアップロードすることです。ソースの tarball もこのインターフェイスからアップロードすることができます。</target>
        </trans-unit>
        <trans-unit id="7aabd3a3162d932dde5dce5c1f8c9f863c647d1b" translate="yes" xml:space="preserve">
          <source>The second way of indexing with booleans is more similar to integer indexing; for each dimension of the array we give a 1D boolean array selecting the slices we want:</source>
          <target state="translated">ブール値を用いたインデックス作成の2番目の方法は、整数インデックス作成に似ています。配列の各次元に対して、スライスを選択する1次元のブール値配列を与えます。</target>
        </trans-unit>
        <trans-unit id="66a3455570bd434e86d6f052ed9b9a1d4a2c4251" translate="yes" xml:space="preserve">
          <source>The sections of a function&amp;rsquo;s docstring are:</source>
          <target state="translated">関数のdocstringのセクションは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="8eb125eefbda7190ce972cb7d8270d5ae89dc7b7" translate="yes" xml:space="preserve">
          <source>The self.paths(&amp;hellip;) method is applied to all lists that may contain paths.</source>
          <target state="translated">self.paths（&amp;hellip;）メソッドは、パスを含む可能性のあるすべてのリストに適用されます。</target>
        </trans-unit>
        <trans-unit id="8c7148486ba5b770e99fd7463ec63c216dee7366" translate="yes" xml:space="preserve">
          <source>The separation between elements for each dimension (the &amp;lsquo;stride&amp;rsquo;). This does not have to be a multiple of the element size</source>
          <target state="translated">各次元の要素間の分離（「ストライド」）。これは要素サイズの倍数である必要はありません</target>
        </trans-unit>
        <trans-unit id="9cd2ff64b895aeb8d0b16f3694ac2aea08560437" translate="yes" xml:space="preserve">
          <source>The series in this context are finite sums of the corresponding polynomial basis functions multiplied by coefficients. For instance, a power series looks like</source>
          <target state="translated">この文脈での級数は、対応する多項式基底関数の有限和に係数を掛けたものです。例えば、累乗級数は次のようになります。</target>
        </trans-unit>
        <trans-unit id="9285a776c2a659ee75e7938ac17b155070381205" translate="yes" xml:space="preserve">
          <source>The series instance to be converted.</source>
          <target state="translated">変換対象のシリーズインスタンス。</target>
        </trans-unit>
        <trans-unit id="89a518ad1f6d727d2464d8f222f198c518f126e6" translate="yes" xml:space="preserve">
          <source>The series is reduced to degree &lt;code&gt;deg&lt;/code&gt; by discarding the high order terms. The value of &lt;code&gt;deg&lt;/code&gt; must be a non-negative integer.</source>
          <target state="translated">級数は、高次の項を破棄することにより、 &lt;code&gt;deg&lt;/code&gt; 度まで削減されます。 &lt;code&gt;deg&lt;/code&gt; の値は負でない整数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="adbbacc122f5859d958a7eb7009d4955c1c2c537" translate="yes" xml:space="preserve">
          <source>The series is reduced to length &lt;code&gt;size&lt;/code&gt; by discarding the high degree terms. The value of &lt;code&gt;size&lt;/code&gt; must be a positive integer.</source>
          <target state="translated">高次の項を破棄することにより、シリーズは長さ &lt;code&gt;size&lt;/code&gt; 縮小されます。 &lt;code&gt;size&lt;/code&gt; の値は正の整数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="38262a9c7d66cebff5a42640a9df021a775761be" translate="yes" xml:space="preserve">
          <source>The set of available codecs comes from the Python standard library, and may be extended at runtime. For more information, see the &lt;a href=&quot;https://docs.python.org/dev/library/codecs.html#module-codecs&quot;&gt;&lt;code&gt;codecs&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">利用可能なコーデックのセットはPython標準ライブラリからのものであり、実行時に拡張される場合があります。詳細については、&lt;a href=&quot;https://docs.python.org/dev/library/codecs.html#module-codecs&quot;&gt; &lt;code&gt;codecs&lt;/code&gt; &lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="a717e3302b8636b7790364bffe6b5a183f3f6e7f" translate="yes" xml:space="preserve">
          <source>The set of available codecs comes from the Python standard library, and may be extended at runtime. For more information, see the codecs module.</source>
          <target state="translated">利用可能なコーデックのセットはPython標準ライブラリから来ており、実行時に拡張される可能性があります。詳細はコーデックモジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="f3119f479b7378be171f9e5461ebc7ae89470f50" translate="yes" xml:space="preserve">
          <source>The set of characters that the returned character is chosen from. The default set is &amp;lsquo;GDFgdf&amp;rsquo;.</source>
          <target state="translated">返される文字が選択される文字のセット。デフォルトのセットは「GDFgdf」です。</target>
        </trans-unit>
        <trans-unit id="a3a4541aef2e0618e33ebd5e18d9c022d28bcaa8" translate="yes" xml:space="preserve">
          <source>The set of functions that convert the data of a column to a value. The converters can also be used to provide a default value for missing data: &lt;code&gt;converters = {3: lambda s: float(s or 0)}&lt;/code&gt;.</source>
          <target state="translated">列のデータを値に変換する関数のセット。コンバーターを使用して、欠損データのデフォルト値を提供することもできます： &lt;code&gt;converters = {3: lambda s: float(s or 0)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e26f5391f4384da7c676eb1e9d468550abb0eb1" translate="yes" xml:space="preserve">
          <source>The set of int values is not a subset of the uint values for types with the same number of bits, something not reflected in &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt;, but handled as a special case in PyArray_ResultType.</source>
          <target state="translated">int値のセットは、同じビット数の型のuint値のサブセットではありません。これは、&lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt; &lt;code&gt;PyArray_MinScalarType&lt;/code&gt; &lt;/a&gt;には反映されませんが、PyArray_ResultTypeでは特殊なケースとして処理されます。</target>
        </trans-unit>
        <trans-unit id="e76841686484db8628455fd162b8197749bc84c1" translate="yes" xml:space="preserve">
          <source>The set of int values is not a subset of the uint values for types with the same number of bits, something not reflected in &lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt;&lt;code&gt;min_scalar_type&lt;/code&gt;&lt;/a&gt;, but handled as a special case in &lt;a href=&quot;#numpy.result_type&quot;&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">int値のセットは、同じビット数の型のuint値のサブセットではありません。これは、&lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt; &lt;code&gt;min_scalar_type&lt;/code&gt; &lt;/a&gt;には反映されませんが、&lt;a href=&quot;#numpy.result_type&quot;&gt; &lt;code&gt;result_type&lt;/code&gt; で&lt;/a&gt;特殊なケースとして処理されます。</target>
        </trans-unit>
        <trans-unit id="561107923e2d5ef74733b059316312382b1f95e9" translate="yes" xml:space="preserve">
          <source>The set of strings corresponding to missing data.</source>
          <target state="translated">欠損データに対応する文字列の集合。</target>
        </trans-unit>
        <trans-unit id="3c3fdff23bd130c5708b43d7769884cc7638d9dc" translate="yes" xml:space="preserve">
          <source>The set of values to be used as default when the data are missing.</source>
          <target state="translated">データが欠落しているときにデフォルトで使用する値のセットです。</target>
        </trans-unit>
        <trans-unit id="40c5a46b247f5eb179525001f8ba092f80c0ed2a" translate="yes" xml:space="preserve">
          <source>The setup function for all three methods is &lt;code&gt;construct_reduce&lt;/code&gt;. This function creates a reducing loop object and fills it with parameters needed to complete the loop. All of the methods only work on ufuncs that take 2-inputs and return 1 output. Therefore, the underlying 1-D loop is selected assuming a signature of [ &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt; ] where &lt;code&gt;otype&lt;/code&gt; is the requested reduction data-type. The buffer size and error handling is then retrieved from (per-thread) global storage. For small arrays that are mis-aligned or have incorrect data-type, a copy is made so that the un-buffered section of code is used. Then, the looping strategy is selected. If there is 1 element or 0 elements in the array, then a simple looping method is selected. If the array is not mis-aligned and has the correct data-type, then strided looping is selected. Otherwise, buffered looping must be performed. Looping parameters are then established, and the return array is constructed. The output array is of a different shape depending on whether the method is reduce, accumulate, or reduceat. If an output array is already provided, then it&amp;rsquo;s shape is checked. If the output array is not C-contiguous, aligned, and of the correct data type, then a temporary copy is made with the WRITEBACKIFCOPY flag set. In this way, the methods will be able to work with a well-behaved output array but the result will be copied back into the true output array when &lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called at function completion. Finally, iterators are set up to loop over the correct axis (depending on the value of axis provided to the method) and the setup routine returns to the actual computation routine.</source>
          <target state="translated">3つのメソッドすべてのセットアップ関数は、 &lt;code&gt;construct_reduce&lt;/code&gt; です。この関数は、縮小ループオブジェクトを作成し、ループを完了するために必要なパラメーターをそのオブジェクトに入力します。すべてのメソッドは、2つの入力を取り、1つの出力を返すufuncでのみ機能します。したがって、[ &lt;code&gt;otype&lt;/code&gt; 、 &lt;code&gt;otype&lt;/code&gt; 、 &lt;code&gt;otype&lt;/code&gt; ]のシグネチャを想定して、基礎となる1次元ループが選択されます。ここで &lt;code&gt;otype&lt;/code&gt; 要求された削減データタイプです。バッファサイズとエラー処理は、（スレッドごとの）グローバルストレージから取得されます。整列が正しくない、またはデータ型が正しくない小さな配列の場合、バッファリングされていないコードのセクションが使用されるようにコピーが作成されます。次に、ループ戦略が選択されます。配列に1要素または0要素がある場合、単純なループ方法が選択されます。配列が正しく整列されておらず、正しいデータ型である場合、ストライドループが選択されます。それ以外の場合は、バッファリングされたループを実行する必要があります。次に、ループパラメーターが確立され、戻り配列が作成されます。出力配列は、メソッドがreduce、accumulate、reduceatのいずれであるかによって異なる形状になります。出力配列がすでに提供されている場合は、その形状がチェックされます。出力配列がC隣接ではなく、整列されている場合、正しいデータタイプの場合、WRITEBACKIFCOPYフラグを設定して一時コピーが作成されます。このようにして、メソッドは正常に動作する出力配列を処理できますが、結果は実際の出力配列にコピーされます。&lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;は関数の完了時に呼び出されます。最後に、（メソッドに提供された軸の値に応じて）正しい軸をループするように反復子が設定され、設定ルーチンが実際の計算ルーチンに戻ります。</target>
        </trans-unit>
        <trans-unit id="26040668927e88fa78277a9dd0406a200dc72c4f" translate="yes" xml:space="preserve">
          <source>The setup function for all three methods is &lt;code&gt;construct_reduce&lt;/code&gt;. This function creates a reducing loop object and fills it with parameters needed to complete the loop. All of the methods only work on ufuncs that take 2-inputs and return 1 output. Therefore, the underlying 1-D loop is selected assuming a signature of [ &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt; ] where &lt;code&gt;otype&lt;/code&gt; is the requested reduction data-type. The buffer size and error handling is then retrieved from (per-thread) global storage. For small arrays that are mis-aligned or have incorrect data-type, a copy is made so that the un-buffered section of code is used. Then, the looping strategy is selected. If there is 1 element or 0 elements in the array, then a simple looping method is selected. If the array is not mis-aligned and has the correct data-type, then strided looping is selected. Otherwise, buffered looping must be performed. Looping parameters are then established, and the return array is constructed. The output array is of a different shape depending on whether the method is reduce, accumulate, or reduceat. If an output array is already provided, then it&amp;rsquo;s shape is checked. If the output array is not C-contiguous, aligned, and of the correct data type, then a temporary copy is made with the WRITEBACKIFCOPY flag set. In this way, the methods will be able to work with a well-behaved output array but the result will be copied back into the true output array when &lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called at function completion. Finally, iterators are set up to loop over the correct axis (depending on the value of axis provided to the method) and the setup routine returns to the actual computation routine.</source>
          <target state="translated">3つのメソッドすべてのセットアップ関数は &lt;code&gt;construct_reduce&lt;/code&gt; です。この関数は、縮小ループオブジェクトを作成し、ループを完了するために必要なパラメーターをオブジェクトに入力します。すべてのメソッドは、2つの入力を受け取り1つの出力を返すufuncでのみ機能します。したがって、基になる1-Dループは、[ &lt;code&gt;otype&lt;/code&gt; 、 &lt;code&gt;otype&lt;/code&gt; 、 &lt;code&gt;otype&lt;/code&gt; ]の署名を想定して選択されます。ここで &lt;code&gt;otype&lt;/code&gt; 要求された削減データ型です。次に、バッファサイズとエラー処理が（スレッドごとの）グローバルストレージから取得されます。位置がずれているか、データ型が正しくない小さな配列の場合、コードのバッファリングされていないセクションが使用されるようにコピーが作成されます。次に、ループ戦略が選択されます。配列に1要素または0要素がある場合は、単純なループ方法が選択されます。配列の位置がずれておらず、データ型が正しい場合は、ストライドループが選択されます。それ以外の場合は、バッファループを実行する必要があります。次に、ループパラメータが確立され、戻り配列が作成されます。出力配列は、メソッドがreduce、accumulate、reduceatのいずれであるかによって形状が異なります。出力配列がすでに提供されている場合は、その形状がチェックされます。出力配列がC連続でない場合、整列され、正しいデータ型の場合、WRITEBACKIFCOPYフラグを設定して一時コピーが作成されます。このようにして、メソッドは正常に動作する出力配列で機能できますが、結果は次の場合に真の出力配列にコピーされます。&lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;は、関数の完了時に呼び出されます。最後に、イテレータは（メソッドに提供された軸の値に応じて）正しい軸をループするように設定され、設定ルーチンは実際の計算ルーチンに戻ります。</target>
        </trans-unit>
        <trans-unit id="780e857a060059f3e4636a17060f123b8f85b3b2" translate="yes" xml:space="preserve">
          <source>The shape (always C-style contiguous) of the sub-array as a Python tuple.</source>
          <target state="translated">Pythonのタプルとしての部分配列の形状(常にCスタイルの連続)。</target>
        </trans-unit>
        <trans-unit id="9bd591fada3b4117c12a2a1f4d689c069ec359b8" translate="yes" xml:space="preserve">
          <source>The shape and data-type of &lt;code&gt;a&lt;/code&gt; define these same attributes of the returned array.</source>
          <target state="translated">形状とデータ型返される配列のこれらの同じ属性を定義します。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea4fdc5d91eb3f313e977fbfd63ada0a25a66896" translate="yes" xml:space="preserve">
          <source>The shape and data-type of &lt;code&gt;prototype&lt;/code&gt; define these same attributes of the returned array.</source>
          <target state="translated">&lt;code&gt;prototype&lt;/code&gt; の形状とデータ型は、返される配列のこれらと同じ属性を定義します。</target>
        </trans-unit>
        <trans-unit id="de0758f703e3713cedaff1b24e8618c254649ffe" translate="yes" xml:space="preserve">
          <source>The shape of an array can be changed with various commands. Note that the following three commands all return a modified array, but do not change the original array:</source>
          <target state="translated">配列の形状は様々なコマンドで変更することができます。以下の3つのコマンドはすべて変更された配列を返しますが、元の配列は変更されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="55cbdf85b9592ec5dbddfd31ccd2c86de9452ccc" translate="yes" xml:space="preserve">
          <source>The shape of array into which the indices from &lt;code&gt;multi_index&lt;/code&gt; apply.</source>
          <target state="translated">&lt;code&gt;multi_index&lt;/code&gt; のインデックスが適用される配列の形状。</target>
        </trans-unit>
        <trans-unit id="86ea4631bc5657813d3aa6a6102c3531d8908358" translate="yes" xml:space="preserve">
          <source>The shape of each output is determined from the loop dimensions plus the output&amp;rsquo;s core dimensions</source>
          <target state="translated">各出力の形状は、ループの次元と出力のコアの次元から決定されます</target>
        </trans-unit>
        <trans-unit id="432cd297e760e974a03d449cad5f33c7ccb0d645" translate="yes" xml:space="preserve">
          <source>The shape of the array is preserved, but the elements are reordered.</source>
          <target state="translated">配列の形状は保持されますが,要素は並び替えられます.</target>
        </trans-unit>
        <trans-unit id="fb341212b6f41ae91b019292b043b6094616b784" translate="yes" xml:space="preserve">
          <source>The shape of the array to be iterated over.</source>
          <target state="translated">反復される配列の形状.</target>
        </trans-unit>
        <trans-unit id="a015ba13ffb4171bac494c802f272bfb87417c5d" translate="yes" xml:space="preserve">
          <source>The shape of the array to use for unraveling &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;indices&lt;/code&gt; 解明に使用する配列の形状。</target>
        </trans-unit>
        <trans-unit id="9865a6cbf282f8b0812325650b93441342efdd22" translate="yes" xml:space="preserve">
          <source>The shape of the array.</source>
          <target state="translated">配列の形状。</target>
        </trans-unit>
        <trans-unit id="634c22963834ab0f96135fc087ba541ef29a9351" translate="yes" xml:space="preserve">
          <source>The shape of the broadcasted result (only &lt;code&gt;nd&lt;/code&gt; slots are used).</source>
          <target state="translated">ブロードキャスト結果の形状（ &lt;code&gt;nd&lt;/code&gt; スロットのみが使用されます）。</target>
        </trans-unit>
        <trans-unit id="b35ba9f7409c5e79b96888dfb9fe12c59d8276ca" translate="yes" xml:space="preserve">
          <source>The shape of the desired array.</source>
          <target state="translated">希望する配列の形状。</target>
        </trans-unit>
        <trans-unit id="f8fd7f6a4e1f2e482a2f6d64364dd79594585ba9" translate="yes" xml:space="preserve">
          <source>The shape of the gamma distribution. Must be non-negative.</source>
          <target state="translated">ガンマ分布の形状。非負でなければなりません。</target>
        </trans-unit>
        <trans-unit id="40d55544c4b29b3e5cccb47aa9255a7413094e32" translate="yes" xml:space="preserve">
          <source>The shape of the grid.</source>
          <target state="translated">グリッドの形状。</target>
        </trans-unit>
        <trans-unit id="666be679bea4cf4401944751286d85ef9bcbd1ab" translate="yes" xml:space="preserve">
          <source>The shape of the new array. Defaults to &lt;code&gt;x.shape&lt;/code&gt;.</source>
          <target state="translated">新しい配列の形状。デフォルトは &lt;code&gt;x.shape&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="be82fcdcf7279745a92907a11f17b40fb49cfa8e" translate="yes" xml:space="preserve">
          <source>The shape of the output depends on the size of &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt;, and may be larger than &lt;code&gt;a&lt;/code&gt; (this happens if &lt;code&gt;len(indices) &amp;gt; a.shape[axis]&lt;/code&gt;).</source>
          <target state="translated">出力の形状は&lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt;のサイズに依存し、 &lt;code&gt;a&lt;/code&gt; よりも大きくなる可能性があります（これは &lt;code&gt;len(indices) &amp;gt; a.shape[axis]&lt;/code&gt; 場合に発生します）。</target>
        </trans-unit>
        <trans-unit id="fed05fc9900417f6dd9d3b1246dc76a2025a600b" translate="yes" xml:space="preserve">
          <source>The shape of the result consists of the non-contracted axes of the first tensor, followed by the non-contracted axes of the second.</source>
          <target state="translated">結果の形状は、第1のテンソルの非拘束軸と、第2のテンソルの非拘束軸とで構成されています。</target>
        </trans-unit>
        <trans-unit id="dac69f494ba7fae89ed73806775a3c39622a5622" translate="yes" xml:space="preserve">
          <source>The shape of the return value is described above.</source>
          <target state="translated">戻り値の形状については、上記のとおりである。</target>
        </trans-unit>
        <trans-unit id="e988320cd7cc6c4a6c3dd57d84589dcf99664d33" translate="yes" xml:space="preserve">
          <source>The shape of the returned array is described above.</source>
          <target state="translated">返された配列の形状は上記の通りです。</target>
        </trans-unit>
        <trans-unit id="3b10de911cd8ce2a5b2b31e29ac9a30a0aac3857" translate="yes" xml:space="preserve">
          <source>The shape of the returned matrix is &lt;code&gt;x.shape + (order,)&lt;/code&gt;, where</source>
          <target state="translated">返される行列の形状は &lt;code&gt;x.shape + (order,)&lt;/code&gt; 。ここで、</target>
        </trans-unit>
        <trans-unit id="80077b48358a43ab7ec659d3d5fde9d46b95fb86" translate="yes" xml:space="preserve">
          <source>The shape parameter must be given if converting from a ctypes POINTER. The shape parameter is ignored if converting from a ctypes array</source>
          <target state="translated">ctypes POINTERから変換する場合は、shapeパラメータを指定する必要があります。ctypesの配列から変換する場合、このshapeパラメータは無視されます。</target>
        </trans-unit>
        <trans-unit id="fd56dfcd2507095f44b621f1654fe8bcd97f2720" translate="yes" xml:space="preserve">
          <source>The shape property is usually used to get the current shape of an array, but may also be used to reshape the array in-place by assigning a tuple of array dimensions to it. As with &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;numpy.reshape&lt;/code&gt;&lt;/a&gt;, one of the new shape dimensions can be -1, in which case its value is inferred from the size of the array and the remaining dimensions. Reshaping an array in-place will fail if a copy is required.</source>
          <target state="translated">shapeプロパティは通常、配列の現在の形状を取得するために使用されますが、配列次元のタプルをそれに割り当てることにより、配列をその場で再形成するために使用することもできます。&lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;numpy.reshape&lt;/code&gt; &lt;/a&gt;と同様に、新しい形状の次元の1つを-1にすることができます。この場合、その値は配列のサイズと残りの次元から推測されます。コピーが必要な場合、アレイをインプレースで再形成すると失敗します。</target>
        </trans-unit>
        <trans-unit id="80c5a27079e0e5c1026de7841cb52daa2c677404" translate="yes" xml:space="preserve">
          <source>The shapes of x, y, and the condition are broadcast together:</source>
          <target state="translated">x,y,条件の形が一緒に放送されます。</target>
        </trans-unit>
        <trans-unit id="18b788b2f85a3ae45e9f183bcbf59e96d87edbee" translate="yes" xml:space="preserve">
          <source>The shifted array.</source>
          <target state="translated">シフトされた配列です。</target>
        </trans-unit>
        <trans-unit id="a03c5ad272b253bf040f55b1c50d0da307be8ac5" translate="yes" xml:space="preserve">
          <source>The sign of &lt;code&gt;x2&lt;/code&gt; is copied to &lt;code&gt;x1&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">&lt;code&gt;x2&lt;/code&gt; の符号が &lt;code&gt;x1&lt;/code&gt; にコピーされます。 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状にブロードキャスト可能でなければなりません（これが出力の形状になります）。</target>
        </trans-unit>
        <trans-unit id="9a96a866f0e16363f3d77343ed89edc57a089b06" translate="yes" xml:space="preserve">
          <source>The sign of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の符号。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="39e50e1c53e79cf4e2679a1929a8b236a790ceb1" translate="yes" xml:space="preserve">
          <source>The signature defines &amp;ldquo;core&amp;rdquo; dimensionality of input and output variables, and thereby also defines the contraction of the dimensions. The signature is represented by a string of the following format:</source>
          <target state="translated">シグネチャは、入力変数と出力変数の「コア」次元を定義し、それによって次元の縮小も定義します。署名は、次の形式の文字列で表されます。</target>
        </trans-unit>
        <trans-unit id="077a1bbb529dbf66c684eb23b600d5d4d40598cf" translate="yes" xml:space="preserve">
          <source>The signature determines how the dimensions of each input/output array are split into core and loop dimensions:</source>
          <target state="translated">シグネチャは、各入出力配列の次元をコア次元とループ次元にどのように分割するかを決定します。</target>
        </trans-unit>
        <trans-unit id="b9b7ac7b939268ddc59ac1f05c9ebd5e07bf4b21" translate="yes" xml:space="preserve">
          <source>The signature file is saved to &lt;code&gt;fib1.pyf&lt;/code&gt; (see &lt;code&gt;-h&lt;/code&gt; flag) and its contents is shown below.</source>
          <target state="translated">署名ファイルは &lt;code&gt;fib1.pyf&lt;/code&gt; に保存され（ &lt;code&gt;-h&lt;/code&gt; フラグを参照）、その内容を以下に示します。</target>
        </trans-unit>
        <trans-unit id="f03fcdecb4ad7904d6d08273575b7efc1ecd0bcc" translate="yes" xml:space="preserve">
          <source>The signature of &lt;code&gt;__array_finalize__&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;__array_finalize__&lt;/code&gt; の署名は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="51657129c6ecba9775cfcd86518eea063cc02856" translate="yes" xml:space="preserve">
          <source>The signature of &lt;code&gt;__array_ufunc__&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;__array_ufunc__&lt;/code&gt; の署名は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="7eceedf301ec9322c1f2e0e1b62bac4ce44cf0b3" translate="yes" xml:space="preserve">
          <source>The signature of a Fortran block data has the following structure:</source>
          <target state="translated">Fortranブロックデータのシグネチャは、以下のような構造になっています。</target>
        </trans-unit>
        <trans-unit id="07cca1f52e338494fc6137e9ab73032ffedaab99" translate="yes" xml:space="preserve">
          <source>The signature of a Fortran routine has the following structure:</source>
          <target state="translated">Fortranルーチンのシグネチャは次のような構造になっています。</target>
        </trans-unit>
        <trans-unit id="29c6d5e035a62abf39bca07984559eb4c2eed470" translate="yes" xml:space="preserve">
          <source>The simplest and fastest estimator. Only takes into account the data size.</source>
          <target state="translated">最もシンプルで最速の推定器。データサイズのみを考慮する。</target>
        </trans-unit>
        <trans-unit id="f68339a598fdad0949b432ba0f071db76d4162b2" translate="yes" xml:space="preserve">
          <source>The simplest case of indexing with &lt;em&gt;N&lt;/em&gt; integers returns an &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;array scalar&lt;/a&gt; representing the corresponding item. As in Python, all indices are zero-based: for the &lt;em&gt;i&lt;/em&gt;-th index</source>
          <target state="translated">&lt;em&gt;N個の&lt;/em&gt;整数を使用したインデックス付けの最も単純なケースは、対応するアイテムを表す&lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;配列スカラーを&lt;/a&gt;返します。Pythonと同様に、すべてのインデックスはゼロベースです：&lt;em&gt;i&lt;/em&gt;番目のインデックスの場合</target>
        </trans-unit>
        <trans-unit id="7ff2686b623caae27117f3c5885c7d6ae7623a3a" translate="yes" xml:space="preserve">
          <source>The simplest way to assign values to a structured array is using python tuples. Each assigned value should be a tuple of length equal to the number of fields in the array, and not a list or array as these will trigger numpy&amp;rsquo;s broadcasting rules. The tuple&amp;rsquo;s elements are assigned to the successive fields of the array, from left to right:</source>
          <target state="translated">構造化配列に値を割り当てる最も簡単な方法は、Pythonタプルを使用することです。割り当てられた各値は、配列内のフィールドの数に等しい長さのタプルである必要があり、リストや配列ではありません。これらはnumpyのブロードキャストルールをトリガーするためです。タプルの要素は、配列の連続するフィールドに左から右に割り当てられます。</target>
        </trans-unit>
        <trans-unit id="082b93c290be349a4bf83756ecca01f8d723b944" translate="yes" xml:space="preserve">
          <source>The simplest way to create a record array is with &lt;code&gt;numpy.rec.array&lt;/code&gt;:</source>
          <target state="translated">レコード配列を作成する最も簡単な方法は、 &lt;code&gt;numpy.rec.array&lt;/code&gt; を使用することです。</target>
        </trans-unit>
        <trans-unit id="47091f34475faaaa1ba4de46a8ad6549a8d5a1f2" translate="yes" xml:space="preserve">
          <source>The simulation of a C-style array is not complete for 2-d and 3-d arrays. For example, the simulated arrays of pointers cannot be passed to subroutines expecting specific, statically-defined 2-d and 3-d arrays. To pass to functions requiring those kind of inputs, you must statically define the required array and copy data.</source>
          <target state="translated">Cスタイルの配列のシミュレーションは,2-dおよび3-d配列については完全ではありません.例えば、シミュレートされたポインタの配列は、静的に定義された特定の2次元配列や3次元配列を期待してサブルーチンに渡すことはできません。そのような入力を必要とする関数に渡すには、必要な配列を静的に定義してデータをコピーしなければなりません。</target>
        </trans-unit>
        <trans-unit id="51abf12252a4d92a90b52830906a8c2bd4002537" translate="yes" xml:space="preserve">
          <source>The sinc function is</source>
          <target state="translated">sinc関数は</target>
        </trans-unit>
        <trans-unit id="ca8287ab64739fe1883b42785585fd67081d297d" translate="yes" xml:space="preserve">
          <source>The sinc function is used in various signal processing applications, including in anti-aliasing, in the construction of a Lanczos resampling filter, and in interpolation.</source>
          <target state="translated">sinc関数は、アンチエイリアシング、ランチョス再サンプリングフィルタの構築、補間など、様々な信号処理アプリケーションで使用されています。</target>
        </trans-unit>
        <trans-unit id="237e09976f401d9a2f1baabe777a697734eddddd" translate="yes" xml:space="preserve">
          <source>The sine is one of the fundamental functions of trigonometry (the mathematical study of triangles). Consider a circle of radius 1 centered on the origin. A ray comes in from the</source>
          <target state="translated">サインは三角法(三角形の数学的研究)の基本的な関数の一つである。原点を中心とする半径 1 の円を考えてみましょう。線が</target>
        </trans-unit>
        <trans-unit id="eeee63a3a1e6205f2e90fb5ed65d351e3798fee5" translate="yes" xml:space="preserve">
          <source>The sine of each element of x. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">xの各要素の正弦。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="b9c09c4d5914f0dda5c0b150c5f3b90e766bd841" translate="yes" xml:space="preserve">
          <source>The single threaded call directly uses the BitGenerator.</source>
          <target state="translated">シングル スレッドの呼び出しは、BitGenerator を直接使用します。</target>
        </trans-unit>
        <trans-unit id="4e52363a0d1aff84bc0a45f224b49ba218e2396a" translate="yes" xml:space="preserve">
          <source>The situation with numpy makes this issue yet more complicated. The internal machinery of numpy arrays is flexible enough to accept any ordering of indices. One can simply reorder indices by manipulating the internal stride information for arrays without reordering the data at all. NumPy will know how to map the new index order to the data without moving the data.</source>
          <target state="translated">numpyの状況は、この問題をさらに複雑にしています。numpy配列の内部機構は、インデックスの並び順を自由に変更できる柔軟性を持っています。配列の内部ストライド情報を操作することで、データを全く並べ替えることなくインデックスを並べ替えることができます。NumPyは、データを移動することなく、新しいインデックスの順序をデータにマッピングする方法を知っているでしょう。</target>
        </trans-unit>
        <trans-unit id="6d5ab6e4dc0fec0528be17bc5d4e3ad5f3c1a900" translate="yes" xml:space="preserve">
          <source>The size in each dimension of the output shape is the maximum of all the input sizes in that dimension.</source>
          <target state="translated">出力形状の各次元のサイズは,その次元のすべての入力サイズの最大値である.</target>
        </trans-unit>
        <trans-unit id="0f600bd12887e2a8896ddc5bed9d6833c21b9000" translate="yes" xml:space="preserve">
          <source>The size of each dimension of the array.</source>
          <target state="translated">配列の各次元のサイズ.</target>
        </trans-unit>
        <trans-unit id="bcfaa2928c38d19614d82820fec94f09b6747c0f" translate="yes" xml:space="preserve">
          <source>The size of each word. This should only be either &lt;code&gt;uint32&lt;/code&gt; or &lt;code&gt;uint64&lt;/code&gt;. Strings (&lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt;, &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt;) are fine. Note that requesting &lt;code&gt;uint64&lt;/code&gt; will draw twice as many bits as &lt;code&gt;uint32&lt;/code&gt; for the same &lt;code&gt;n_words&lt;/code&gt;. This is a convenience for &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; arrays.</source>
          <target state="translated">各単語のサイズ。これは &lt;code&gt;uint32&lt;/code&gt; または &lt;code&gt;uint64&lt;/code&gt; のいずれかでなければなりません。文字 &lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt; （'uint32'、 &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt; ）は問題ありません。 &lt;code&gt;uint64&lt;/code&gt; を要求すると、同じ &lt;code&gt;n_words&lt;/code&gt; に対して &lt;code&gt;uint32&lt;/code&gt; の 2倍のビット数が描画されることに注意してください。これは、 &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; 配列」として表すBitGeneratorにとって便利です。</target>
        </trans-unit>
        <trans-unit id="28a984c9bdd908f87770bb977436d6a66f4306a1" translate="yes" xml:space="preserve">
          <source>The size of the array minus 1 in each dimension.</source>
          <target state="translated">配列のサイズから各次元で1を引いた値。</target>
        </trans-unit>
        <trans-unit id="c41c1278613c7ed690de9865ed90f9449e9899a0" translate="yes" xml:space="preserve">
          <source>The size of the arrays for which the returned indices will be valid.</source>
          <target state="translated">返されるインデックスが有効になる配列のサイズ。</target>
        </trans-unit>
        <trans-unit id="d186d8343ee709824ee3589500ce1f21e3851f01" translate="yes" xml:space="preserve">
          <source>The size of the dtype element in bytes.</source>
          <target state="translated">dtype要素のサイズをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="b0386b240ebd0571b8a05df9bc4fa0aef34289c1" translate="yes" xml:space="preserve">
          <source>The size, along each dimension, of the arrays for which the returned indices can be used.</source>
          <target state="translated">返されたインデックスが使用できる配列の各次元に沿ったサイズ.</target>
        </trans-unit>
        <trans-unit id="14747cd54a2f3abe194636cc52acff3e4c5bb985" translate="yes" xml:space="preserve">
          <source>The slice is a &lt;em&gt;view&lt;/em&gt; onto the original &lt;code&gt;c_arr&lt;/code&gt; data. So, when we take a view from the ndarray, we return a new ndarray, of the same class, that points to the data in the original.</source>
          <target state="translated">スライスは、元の &lt;code&gt;c_arr&lt;/code&gt; データの&lt;em&gt;ビュー&lt;/em&gt;です。したがって、ndarrayからビューを取得すると、元のデータを指す同じクラスの新しいndarrayが返されます。</target>
        </trans-unit>
        <trans-unit id="eb79b94dc729ec0da33bab5d4cd377a2401e89f0" translate="yes" xml:space="preserve">
          <source>The smaller object to check.</source>
          <target state="translated">小さい方のオブジェクトをチェックします。</target>
        </trans-unit>
        <trans-unit id="c2b26e02affe13f7769ad145c9ef05f90265c054" translate="yes" xml:space="preserve">
          <source>The smallest positive power of the base (2) that causes overflow.</source>
          <target state="translated">オーバーフローの原因となるベース(2)の最小の正の乗。</target>
        </trans-unit>
        <trans-unit id="52e11ee8daa6593b3d750ee5dc32dda2fcbf193b" translate="yes" xml:space="preserve">
          <source>The smallest positive usable number. Type of &lt;code&gt;tiny&lt;/code&gt; is an appropriate floating point type.</source>
          <target state="translated">使用可能な正の最小数。 &lt;code&gt;tiny&lt;/code&gt; タイプは適切な浮動小数点タイプです。</target>
        </trans-unit>
        <trans-unit id="af2a8dd9510ac11ca6b963d4ee773dcefbea79aa" translate="yes" xml:space="preserve">
          <source>The smallest representable number, typically &lt;code&gt;-max&lt;/code&gt;.</source>
          <target state="translated">表現可能な最小の数値、通常 &lt;code&gt;-max&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a159db5ccf6a60aac5543438bfb54acff104da1e" translate="yes" xml:space="preserve">
          <source>The smallest representable positive number such that &lt;code&gt;1.0 + eps != 1.0&lt;/code&gt;. Type of &lt;code&gt;eps&lt;/code&gt; is an appropriate floating point type.</source>
          <target state="translated">&lt;code&gt;1.0 + eps != 1.0&lt;/code&gt; 最小の表現可能な正の数。 &lt;code&gt;eps&lt;/code&gt; のタイプは、適切な浮動小数点タイプです。</target>
        </trans-unit>
        <trans-unit id="d9321ebdb39683114ce6992ea6b9cc620e5ef480" translate="yes" xml:space="preserve">
          <source>The smallest representable positive number such that &lt;code&gt;1.0 - epsneg != 1.0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;1.0 - epsneg != 1.0&lt;/code&gt; ような、表現可能な最小の正の数。</target>
        </trans-unit>
        <trans-unit id="528bc510a2ddc52e9f705a28a08910ff17c4b364" translate="yes" xml:space="preserve">
          <source>The smart way</source>
          <target state="translated">賢い方法</target>
        </trans-unit>
        <trans-unit id="fdf4e6a27441f2bc059f1e2263f51d77fbf6e55a" translate="yes" xml:space="preserve">
          <source>The so-called F2PY directives allow using F2PY signature file constructs also in Fortran 77/90 source codes. With this feature you can skip (almost) completely intermediate signature file generations and apply F2PY directly to Fortran source codes.</source>
          <target state="translated">いわゆる F2PY ディレクティブは、Fortran 77/90 ソースコードでも F2PY 署名ファイル構造を使用することを可能にします。この機能により、(ほぼ)完全に中間の署名ファイル生成をスキップして、Fortranソースコードに直接F2PYを適用することができます。</target>
        </trans-unit>
        <trans-unit id="fff36344b5ce01b9f9447846bf8f8d0ca8bf20cf" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Chebyshev series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解は、加重二乗誤差の合計を最小化するチェビシェフシリーズ &lt;code&gt;p&lt;/code&gt; の係数です。</target>
        </trans-unit>
        <trans-unit id="d7b342b5e308288dae8bce1f9ff3a83bc7ae73a3" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Hermite series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解は、加重二乗誤差の合計を最小化するエルミート系列 &lt;code&gt;p&lt;/code&gt; の係数です。</target>
        </trans-unit>
        <trans-unit id="e858f502931c190b84210ff73e4892a2231f8dea" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the HermiteE series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解は、加重二乗誤差の合計を最小化するHermiteEシリーズ &lt;code&gt;p&lt;/code&gt; の係数です。</target>
        </trans-unit>
        <trans-unit id="cac2b42634eddb5565b046dffc57149ff94fb5e5" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Laguerre series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解は、重み付き二乗誤差の合計を最小にするラゲール級数 &lt;code&gt;p&lt;/code&gt; の係数です。</target>
        </trans-unit>
        <trans-unit id="acc0f8a9120be725868622995211f9656fc88e64" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Legendre series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解は、重み付き二乗誤差の合計を最小化するルジャンドル級数 &lt;code&gt;p&lt;/code&gt; の係数です。</target>
        </trans-unit>
        <trans-unit id="132408df155a153e982d44f873f2076aed312f9a" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the polynomial &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解は、重み付き二乗誤差の合計を最小化する多項式 &lt;code&gt;p&lt;/code&gt; の係数です。</target>
        </trans-unit>
        <trans-unit id="727489824facdfd8e793d7820b6d48d439e20ed1" translate="yes" xml:space="preserve">
          <source>The solution minimizes the squared error</source>
          <target state="translated">解は,二乗誤差を最小化します.</target>
        </trans-unit>
        <trans-unit id="905babbec7af7dc86acc47da182cc43822ce2de5" translate="yes" xml:space="preserve">
          <source>The solution will be to either:</source>
          <target state="translated">解決策はどちらかになります。</target>
        </trans-unit>
        <trans-unit id="ea7110277074b52a752297c7e2a8351687eb1a36" translate="yes" xml:space="preserve">
          <source>The solutions are computed using LAPACK routine &lt;code&gt;_gesv&lt;/code&gt;.</source>
          <target state="translated">解はLAPACKルーチン &lt;code&gt;_gesv&lt;/code&gt; を使用して計算されます。</target>
        </trans-unit>
        <trans-unit id="2324f65c28650d2bb749a64e0d6878a8a423096e" translate="yes" xml:space="preserve">
          <source>The sort order for complex numbers is lexicographic. If both the real and imaginary parts are non-nan then the order is determined by the real parts except when they are equal, in which case the order is determined by the imaginary parts.</source>
          <target state="translated">複素数のソート順は辞書的なものである.実部と虚部の両方が非ナンである場合は、実部が等しい場合を除いて実部によって順序が決定されますが、その場合は虚部によって順序が決定されます。</target>
        </trans-unit>
        <trans-unit id="94fa27637cf0004fe36c14f580e547f6911b6110" translate="yes" xml:space="preserve">
          <source>The sorted unique values.</source>
          <target state="translated">ソートされた一意の値。</target>
        </trans-unit>
        <trans-unit id="c380c0b74f7e3ca7cbe5b2bb1b45003f6fb70837" translate="yes" xml:space="preserve">
          <source>The sorting algorithm used.</source>
          <target state="translated">使用されているソートアルゴリズム。</target>
        </trans-unit>
        <trans-unit id="e03d33ebb9f3232a066dd4b0991b32cb56211358" translate="yes" xml:space="preserve">
          <source>The source and destination arrays during assignment.</source>
          <target state="translated">代入時のソース配列とデスティネーション配列。</target>
        </trans-unit>
        <trans-unit id="2132b1a1146e5e5ced071e842080bf9a009b6944" translate="yes" xml:space="preserve">
          <source>The source array.</source>
          <target state="translated">ソース配列です。</target>
        </trans-unit>
        <trans-unit id="f3a4e63ab5a7b2b3732df5942d36a724d124f0ea" translate="yes" xml:space="preserve">
          <source>The source code is only returned for objects written in Python.</source>
          <target state="translated">ソースコードはPythonで書かれたオブジェクトに対してのみ返されます。</target>
        </trans-unit>
        <trans-unit id="cf16b74745b78ed96effaeceb909805fb279ce98" translate="yes" xml:space="preserve">
          <source>The source code is only returned for objects written in Python. Many functions and classes are defined in C and will therefore not return useful information.</source>
          <target state="translated">ソースコードが返されるのは、Pythonで書かれたオブジェクトのみです。多くの関数やクラスはC言語で定義されているため、有用な情報は返されません。</target>
        </trans-unit>
        <trans-unit id="809a1cfd22069f38c46105c92eebf5c576bb4207" translate="yes" xml:space="preserve">
          <source>The source string can be any valid Fortran code. If you want to save the extension-module source code then a suitable file-name can be provided by the &lt;code&gt;source_fn&lt;/code&gt; keyword to the compile function.</source>
          <target state="translated">ソース文字列は、任意の有効なFortranコードにすることができます。拡張モジュールのソースコードを保存する場合は、適切なファイル名を &lt;code&gt;source_fn&lt;/code&gt; キーワードでコンパイル関数に指定できます。</target>
        </trans-unit>
        <trans-unit id="cd5904ef77ea8bffca88dd379e736043b3ab2537" translate="yes" xml:space="preserve">
          <source>The spacing between sample points when &lt;code&gt;x&lt;/code&gt; is None. The default is 1.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; がNoneの場合のサンプルポイント間の間隔。デフォルトは1です。</target>
        </trans-unit>
        <trans-unit id="f3c0291e43c18442ce997268f6d827c51450c140" translate="yes" xml:space="preserve">
          <source>The spacing of values of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の値の間隔。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="90f7163cd42de5312873857f6e49d754d0181393" translate="yes" xml:space="preserve">
          <source>The specific algorithm used is as follows.</source>
          <target state="translated">具体的なアルゴリズムは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="87dcde88b185fa2a9572c4ddf0c6760b6d6e72a4" translate="yes" xml:space="preserve">
          <source>The specified line is given by &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">指定された行は、 &lt;code&gt;off + scl*x&lt;/code&gt; 指定されます。</target>
        </trans-unit>
        <trans-unit id="6ffe340425612aa0e424be1bcdd9b7a397555dd0" translate="yes" xml:space="preserve">
          <source>The stacked array has one more dimension than the input arrays.</source>
          <target state="translated">積層された配列は,入力配列よりも1つ多くの次元を持っています.</target>
        </trans-unit>
        <trans-unit id="b5df163136221ee565809e31a5ec5ce477690b37" translate="yes" xml:space="preserve">
          <source>The standard array can have 24 different data types (and has some support for adding your own types). These data types all have an enumerated type, an enumerated type-character, and a corresponding array scalar Python type object (placed in a hierarchy). There are also standard C typedefs to make it easier to manipulate elements of the given data type. For the numeric types, there are also bit-width equivalent C typedefs and named typenumbers that make it easier to select the precision desired.</source>
          <target state="translated">標準の配列は24種類のデータ型を持つことができます(独自の型を追加するためのサポートもあります)。これらのデータ型はすべて、列挙型、列挙型文字列、対応する配列スカラPython型オブジェクト(階層に配置されています)を持っています。また、与えられたデータ型の要素をより簡単に操作できるようにするための標準的なCの型定義もあります。数値型については、ビット幅に相当するCの型定義や名前付きの型数もあり、希望する精度を簡単に選択できるようになっています。</target>
        </trans-unit>
        <trans-unit id="45b18b5cfbbed3fbae9c681cc6f3c1fa70483591" translate="yes" xml:space="preserve">
          <source>The standard casting rules ensure that a scalar cannot up-cast an array unless the scalar is of a fundamentally different kind of data (i.e. under a different hierarchy in the data type hierarchy) then the array:</source>
          <target state="translated">標準的なキャストルールでは,スカラが配列とは根本的に異なる種類のデータ(つまり,データ型の階層が異なる)でない限り,スカラが配列をアップキャストすることはできないことが保証されています.</target>
        </trans-unit>
        <trans-unit id="3b087bfb5ae783fa5041fbcb80716e85b4cfcd9d" translate="yes" xml:space="preserve">
          <source>The standard deviation is the square root of the average of the squared deviations from the mean, i.e., &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt;.</source>
          <target state="translated">標準偏差は、平均からの偏差の二乗の平均の平方根です。つまり、 &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3f057ac9f65af78fe632de7c8031e6f6e2ae80dc" translate="yes" xml:space="preserve">
          <source>The standard deviation is the square root of the average of the squared deviations from the mean: &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt;.</source>
          <target state="translated">標準偏差は、平均からの偏差の二乗の平均の平方根です &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9194bef8dfee2642aab9789d8b2c457a98f783af" translate="yes" xml:space="preserve">
          <source>The standard rules of sequence slicing apply to basic slicing on a per-dimension basis (including using a step index). Some useful concepts to remember include:</source>
          <target state="translated">シーケンス・スライシングの標準的なルールは、基本的なスライシングを寸法ごとに適用します(ステップ・インデックスの使用を含む)。覚えておくと便利な概念をいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="903735d28aa358318c996f0fbe6f9bd887af58b8" translate="yes" xml:space="preserve">
          <source>The start of the data within the data buffer (an offset relative to the beginning of the data buffer).</source>
          <target state="translated">データバッファ内のデータの開始点(データバッファの先頭からの相対的なオフセット)。</target>
        </trans-unit>
        <trans-unit id="df2af17caf9f66a81db3bc6a51eb1b52d78258be" translate="yes" xml:space="preserve">
          <source>The start of type numbers used for Custom Data types.</source>
          <target state="translated">カスタムデータ型に使用される型番号の先頭です。</target>
        </trans-unit>
        <trans-unit id="e63c738294e147bc42d8454a2cacbd481d845725" translate="yes" xml:space="preserve">
          <source>The starting value for this product. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">この製品の開始値。詳細については、&lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b49e967087e1769cf1a280ea97d2d8fd93d40ef9" translate="yes" xml:space="preserve">
          <source>The starting value of the sequence.</source>
          <target state="translated">シーケンスの開始値。</target>
        </trans-unit>
        <trans-unit id="be3a2f4f7af9d19db4503332628441741d474403" translate="yes" xml:space="preserve">
          <source>The state of the returned big generator is jumped as-if 2**(128 * jumps) random numbers have been generated.</source>
          <target state="translated">2**(128*ジャンプ)の乱数が生成されていれば、ビッグジェネレータの状態がジャンプされます。</target>
        </trans-unit>
        <trans-unit id="9f0543dedf6d1409b4f87e0823027e644cab05a9" translate="yes" xml:space="preserve">
          <source>The step size is phi-1 when multiplied by 2**128 where phi is the golden ratio.</source>
          <target state="translated">ステップサイズは、2**128を乗じたときのphi-1であり、ここでphiは黄金比である。</target>
        </trans-unit>
        <trans-unit id="ed6404a00884e4a1c814b4fe32b4f8e4142164f0" translate="yes" xml:space="preserve">
          <source>The steps are:</source>
          <target state="translated">ステップがあります。</target>
        </trans-unit>
        <trans-unit id="da99252ecc9a954c9ea523c42dd589060111b276" translate="yes" xml:space="preserve">
          <source>The strides of the array. How many bytes needed to jump to the next element in each dimension.</source>
          <target state="translated">配列のストライド。各次元の次の要素にジャンプするのに必要なバイト数。</target>
        </trans-unit>
        <trans-unit id="6bea4f23f51bf1c5c1b134b3c31652eb62271512" translate="yes" xml:space="preserve">
          <source>The strides of the new array. Defaults to &lt;code&gt;x.strides&lt;/code&gt;.</source>
          <target state="translated">新しい配列のストライド。デフォルトは &lt;code&gt;x.strides&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0e7d4c32101a82d4a575c51fa47c579d84a90ccb" translate="yes" xml:space="preserve">
          <source>The string character corresponding to the scalar type.</source>
          <target state="translated">スカラー型に対応する文字列文字。</target>
        </trans-unit>
        <trans-unit id="280cdfd9e5006321af13d97ed1dea840dc6157dc" translate="yes" xml:space="preserve">
          <source>The string representation of a structured datatype is shown in the &amp;ldquo;list of tuples&amp;rdquo; form if possible, otherwise numpy falls back to using the more general dictionary form.</source>
          <target state="translated">構造化データ型の文字列表現は、可能であれば「タプルのリスト」形式で表示されます。それ以外の場合、numpyはより一般的な辞書形式の使用にフォールバックします。</target>
        </trans-unit>
        <trans-unit id="56e3689374848f3f51b64947b16bec4c3ea61c9e" translate="yes" xml:space="preserve">
          <source>The string representation of an array.</source>
          <target state="translated">配列の文字列表現。</target>
        </trans-unit>
        <trans-unit id="3e6678ed1379ae4a29d74cf130ddd533a3d54faa" translate="yes" xml:space="preserve">
          <source>The string representation of the floating point value</source>
          <target state="translated">浮動小数点値の文字列表現</target>
        </trans-unit>
        <trans-unit id="a73fe28c8757ab0f0da0e2f4243de7dc56a5b482" translate="yes" xml:space="preserve">
          <source>The string separating numbers in the data; extra whitespace between elements is also ignored.</source>
          <target state="translated">データ内の数値を区切る文字列、要素間の余分な空白も無視されます。</target>
        </trans-unit>
        <trans-unit id="3dd7799be74e76e0df59b70e60e88893f1e79944" translate="yes" xml:space="preserve">
          <source>The string to load.</source>
          <target state="translated">ロードする文字列。</target>
        </trans-unit>
        <trans-unit id="fe1a3737165141949913fff90aaf8e13cf8c53af" translate="yes" xml:space="preserve">
          <source>The string to test for equality against the expected string.</source>
          <target state="translated">期待される文字列との等質性をテストするための文字列。</target>
        </trans-unit>
        <trans-unit id="abd4042bc9b171ded494b956ae5b9d9577f995c1" translate="yes" xml:space="preserve">
          <source>The string used to separate values. By default, any consecutive whitespaces act as delimiter. An integer or sequence of integers can also be provided as width(s) of each field.</source>
          <target state="translated">値を区切るために使用する文字列。デフォルトでは、連続した空白が区切り文字として機能します。各フィールドの幅として、整数または整数のシーケンスを指定することもできます。</target>
        </trans-unit>
        <trans-unit id="af52fb130d33fe69945cefb6f52e5cf4ca3f8766" translate="yes" xml:space="preserve">
          <source>The string used to separate values. For backwards compatibility, byte strings will be decoded as &amp;lsquo;latin1&amp;rsquo;. The default is whitespace.</source>
          <target state="translated">値を区切るために使用される文字列。下位互換性のために、バイト文字列は「latin1」としてデコードされます。デフォルトは空白です。</target>
        </trans-unit>
        <trans-unit id="9d54c543599ad13e3bb6b6bb26859ee068b06992" translate="yes" xml:space="preserve">
          <source>The strings produced by the Python float.hex method can be used as input for floats.</source>
          <target state="translated">Pythonのfloat.hexメソッドで生成された文字列をfloatの入力として使用することができます。</target>
        </trans-unit>
        <trans-unit id="4e980753b02b50913c2b5e0d5a5fa0dd49eac85d" translate="yes" xml:space="preserve">
          <source>The structured dtype of the output array</source>
          <target state="translated">出力配列の構造化された dtype</target>
        </trans-unit>
        <trans-unit id="05daa592464e6166b985d1ccf981f505cab14119" translate="yes" xml:space="preserve">
          <source>The sub-arrays whose main diagonals we just obtained; note that each corresponds to fixing the right-most (column) axis, and that the diagonals are &amp;ldquo;packed&amp;rdquo; in rows.</source>
          <target state="translated">主な対角線を取得したサブ配列。それぞれが右端（列）の軸の固定に対応し、対角線が行に「パック」されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="032fe52a10dbbb96d8d2155ebf017c5a37d540fb" translate="yes" xml:space="preserve">
          <source>The sub-diagonal at and below which the array is filled. &lt;code&gt;k&lt;/code&gt; = 0 is the main diagonal, while &lt;code&gt;k&lt;/code&gt; &amp;lt; 0 is below it, and &lt;code&gt;k&lt;/code&gt; &amp;gt; 0 is above. The default is 0.</source>
          <target state="translated">配列が塗りつぶされるその下の対角線以下。 &lt;code&gt;k&lt;/code&gt; = 0は主対角線で、 &lt;code&gt;k&lt;/code&gt; &amp;lt;0はその下、 &lt;code&gt;k&lt;/code&gt; &amp;gt; 0は上です。デフォルトは0です。</target>
        </trans-unit>
        <trans-unit id="8e6c361139d8c7c0ac565e0bf2e23b72d7fed91d" translate="yes" xml:space="preserve">
          <source>The subarrays &lt;code&gt;grid[k]&lt;/code&gt; contains the N-D array of indices along the &lt;code&gt;k-th&lt;/code&gt; axis. Explicitly:</source>
          <target state="translated">サブ配列 &lt;code&gt;grid[k]&lt;/code&gt; には、 &lt;code&gt;k-th&lt;/code&gt; 軸に沿ったインデックスのND配列が含まれています。明示的に：</target>
        </trans-unit>
        <trans-unit id="c73621fe8c8d7b0663f28b8d7e7772440297f53c" translate="yes" xml:space="preserve">
          <source>The subscripts string is a comma-separated list of subscript labels, where each label refers to a dimension of the corresponding operand. Whenever a label is repeated it is summed, so &lt;code&gt;np.einsum('i,i', a, b)&lt;/code&gt; is equivalent to &lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt;&lt;code&gt;np.inner(a,b)&lt;/code&gt;&lt;/a&gt;. If a label appears only once, it is not summed, so &lt;code&gt;np.einsum('i', a)&lt;/code&gt; produces a view of &lt;code&gt;a&lt;/code&gt; with no changes. A further example &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; describes traditional matrix multiplication and is equivalent to &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;np.matmul(a,b)&lt;/code&gt;&lt;/a&gt;. Repeated subscript labels in one operand take the diagonal. For example, &lt;code&gt;np.einsum('ii', a)&lt;/code&gt; is equivalent to &lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt;&lt;code&gt;np.trace(a)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">下付き文字列は、下付きラベルのコンマ区切りのリストです。各ラベルは対応するオペランドの次元を参照します。ラベルが繰り返される場合は常に合計されるため、 &lt;code&gt;np.einsum('i,i', a, b)&lt;/code&gt; は&lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt; &lt;code&gt;np.inner(a,b)&lt;/code&gt; &lt;/a&gt; a、b）と同等です。ラベルは一度しか表示された場合は、それが合計されていないので、 &lt;code&gt;np.einsum('i', a)&lt;/code&gt; のビュー生成変更なしに。さらなる例 &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; は、従来の行列乗算を説明して&lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;np.matmul(a,b)&lt;/code&gt; &lt;/a&gt;と同等です。 1つのオペランドで繰り返される添え字ラベルは対角になります。たとえば、 &lt;code&gt;np.einsum('ii', a)&lt;/code&gt; は&lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt; &lt;code&gt;np.trace(a)&lt;/code&gt; &lt;/a&gt;と同等です。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="67e5fbff128f593f5baf173c69fe839b3262add2" translate="yes" xml:space="preserve">
          <source>The substring to search for.</source>
          <target state="translated">検索する部分文字列。</target>
        </trans-unit>
        <trans-unit id="965c999c4a333ea7538f32117fa173b48c1340d4" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">要素ごとの &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の合計。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="6ad40e475222ea9afc0452e8c7fd45129517c8c0" translate="yes" xml:space="preserve">
          <source>The sum of an empty array is the neutral element 0:</source>
          <target state="translated">空の配列の和は中立要素0です。</target>
        </trans-unit>
        <trans-unit id="d51acbb68e0ec9e47200775b381bf1325a23c32a" translate="yes" xml:space="preserve">
          <source>The sum of the inputs. If either input is a poly1d object, then the output is also a poly1d object. Otherwise, it is a 1D array of polynomial coefficients from highest to lowest degree.</source>
          <target state="translated">入力の合計。どちらかの入力がポリ1次元オブジェクトの場合、出力もポリ1次元オブジェクトとなります。そうでない場合は、最高次数から最低次数までの多項式係数の1次元配列です。</target>
        </trans-unit>
        <trans-unit id="a83a6a324c47c50fcc7b05d36f9de3513626990f" translate="yes" xml:space="preserve">
          <source>The suppression behavior is selected with the &lt;code&gt;axis&lt;/code&gt; parameter.</source>
          <target state="translated">抑制動作は &lt;code&gt;axis&lt;/code&gt; パラメーターで選択されます。</target>
        </trans-unit>
        <trans-unit id="ac5e9039faffaa312745861609180dbee345923d" translate="yes" xml:space="preserve">
          <source>The symbol suffix avoids the symbol name clashes between 32-bit and 64-bit BLAS/LAPACK libraries.</source>
          <target state="translated">シンボルサフィックスは、32ビットと64ビットのBLAS/LAPACKライブラリ間のシンボル名の衝突を回避します。</target>
        </trans-unit>
        <trans-unit id="d22d2ca3e9d62707042d4e5eab8a754482cb7bf9" translate="yes" xml:space="preserve">
          <source>The syntax of signature files is presented below.</source>
          <target state="translated">署名ファイルの構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="dc008fb51ab0096c0ab2810136d6a94b39d8b6ae" translate="yes" xml:space="preserve">
          <source>The syntax specification for signature files (.pyf files) is borrowed from the Fortran 90/95 language specification. Almost all Fortran 90/95 standard constructs are understood, both in free and fixed format (recall that Fortran 77 is a subset of Fortran 90/95). F2PY introduces also some extensions to Fortran 90/95 language specification that help designing Fortran to Python interface, make it more &amp;ldquo;Pythonic&amp;rdquo;.</source>
          <target state="translated">署名ファイル（.pyfファイル）の構文仕様は、Fortran90 / 95言語仕様から借用されています。ほとんどすべてのFortran90 / 95標準構造は、自由形式と固定形式の両方で理解されます（Fortran77はFortran90 / 95のサブセットであることを思い出してください）。F2PYは、Fortran 90/95言語仕様にいくつかの拡張機能も導入しており、FortranからPythonへのインターフェースの設計を支援し、より「Pythonic」にします。</target>
        </trans-unit>
        <trans-unit id="4cac57b443c7e139444cef039c708d06cc974fbe" translate="yes" xml:space="preserve">
          <source>The t test is based on an assumption that the data come from a Normal distribution. The t test provides a way to test whether the sample mean (that is the mean calculated from the data) is a good estimate of the true mean.</source>
          <target state="translated">t 検定は,データが正規分布から来ているという仮定に基づいている.t 検定は,標本平均(データから計算された平均)が真の平均の良い推定値であるかどうかを検定する方法を提供する.</target>
        </trans-unit>
        <trans-unit id="9a7fcb5dad38e6ecd0517ba513e487ccaccafb31" translate="yes" xml:space="preserve">
          <source>The table below gives rough equivalents for some common MATLAB&amp;reg; expressions. &lt;strong&gt;These are not exact equivalents&lt;/strong&gt;, but rather should be taken as hints to get you going in the right direction. For more detail read the built-in documentation on the NumPy functions.</source>
          <target state="translated">次の表は、いくつかの一般的なMATLAB&amp;reg;式の大まかな同等物を示しています。&lt;strong&gt;これらは完全に同等&lt;/strong&gt;で&lt;strong&gt;はありません&lt;/strong&gt;が、正しい方向に進むためのヒントとしてとらえる必要があります。詳細については、NumPy関数の組み込みドキュメントをお読みください。</target>
        </trans-unit>
        <trans-unit id="1feedf873323b1df0d515f29065f1cceac91a5f6" translate="yes" xml:space="preserve">
          <source>The template language blocks are delimited by &lt;code&gt;/**begin repeat&lt;/code&gt; and &lt;code&gt;/**end repeat**/&lt;/code&gt; lines, which may also be nested using consecutively numbered delimiting lines such as &lt;code&gt;/**begin repeat1&lt;/code&gt; and &lt;code&gt;/**end repeat1**/&lt;/code&gt;:</source>
          <target state="translated">テンプレート言語ブロックは、 &lt;code&gt;/**begin repeat&lt;/code&gt; および &lt;code&gt;/**end repeat**/&lt;/code&gt; 行で区切られます。これらの行は、 &lt;code&gt;/**begin repeat1&lt;/code&gt; や &lt;code&gt;/**end repeat1**/&lt;/code&gt; などの連続番号の区切り線を使用してネストすることもできます。</target>
        </trans-unit>
        <trans-unit id="2a419cbcd05b123b547d845ae2a3bfd3fd96fc50" translate="yes" xml:space="preserve">
          <source>The tensor dot product of the input.</source>
          <target state="translated">入力のテンソル点積。</target>
        </trans-unit>
        <trans-unit id="babafa633a1d5ffe1e85308352efa2b576e666e1" translate="yes" xml:space="preserve">
          <source>The term broadcasting describes how numpy treats arrays with different shapes during arithmetic operations. Subject to certain constraints, the smaller array is &amp;ldquo;broadcast&amp;rdquo; across the larger array so that they have compatible shapes. Broadcasting provides a means of vectorizing array operations so that looping occurs in C instead of Python. It does this without making needless copies of data and usually leads to efficient algorithm implementations. There are, however, cases where broadcasting is a bad idea because it leads to inefficient use of memory that slows computation.</source>
          <target state="translated">ブロードキャストという用語は、numpyが算術演算中にさまざまな形状の配列を処理する方法を説明しています。特定の制約に従い、小さい方のアレイは大きい方のアレイ全体に「ブロードキャスト」されるため、互換性のある形状になります。ブロードキャストは、PythonではなくCでループが発生するように、配列操作をベクトル化する手段を提供します。これは、データの不必要なコピーを作成することなくこれを行い、通常、効率的なアルゴリズムの実装につながります。ただし、ブロードキャストはメモリの非効率的な使用につながり、計算が遅くなるため、悪い考えである場合があります。</target>
        </trans-unit>
        <trans-unit id="0567674780e936db24c51c4154cb1e7bb19a5fb1" translate="yes" xml:space="preserve">
          <source>The test can also be inverted:</source>
          <target state="translated">また、試験は反転も可能です。</target>
        </trans-unit>
        <trans-unit id="a043640318788c216d9c35c72474b86e64a58875" translate="yes" xml:space="preserve">
          <source>The test is equivalent to &lt;code&gt;allclose(actual, desired, rtol, atol)&lt;/code&gt; (note that &lt;code&gt;allclose&lt;/code&gt; has different default values). It compares the difference between &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; to &lt;code&gt;atol + rtol * abs(desired)&lt;/code&gt;.</source>
          <target state="translated">このテストは &lt;code&gt;allclose(actual, desired, rtol, atol)&lt;/code&gt; と同等です（ &lt;code&gt;allclose&lt;/code&gt; のデフォルト値は異なることに注意してください）。 &lt;code&gt;actual&lt;/code&gt; &lt;code&gt;atol + rtol * abs(desired)&lt;/code&gt; と &lt;code&gt;desired&lt;/code&gt; 値の差をatol + rtol * abs（desired）と比較します。</target>
        </trans-unit>
        <trans-unit id="d949a99e166ed49b879032942f22bd239ac73b6e" translate="yes" xml:space="preserve">
          <source>The test is marked as skipped if &lt;code&gt;SkipMyTest&lt;/code&gt; evaluates to nonzero, and the message in verbose test output is the second argument given to &lt;code&gt;skipif&lt;/code&gt;. Similarly, a test can be marked as a known failure by using &lt;code&gt;xfail&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;SkipMyTest&lt;/code&gt; の評価がゼロ以外の場合、テストはスキップされたとマークされ、詳細なテスト出力のメッセージは &lt;code&gt;skipif&lt;/code&gt; に 2番目の引数として与えられます。同様に、 &lt;code&gt;xfail&lt;/code&gt; を使用して、テストを既知の失敗としてマークできます。</target>
        </trans-unit>
        <trans-unit id="85bd6917449fe181340a2938e0dac494fbfea5fe" translate="yes" xml:space="preserve">
          <source>The test method may take two or more arguments; the first, &lt;code&gt;label&lt;/code&gt; is a string specifying what should be tested and the second, &lt;code&gt;verbose&lt;/code&gt; is an integer giving the level of output verbosity. See the docstring for numpy.test for details. The default value for &lt;code&gt;label&lt;/code&gt; is &amp;lsquo;fast&amp;rsquo; - which will run the standard tests. The string &amp;lsquo;full&amp;rsquo; will run the full battery of tests, including those identified as being slow to run. If &lt;code&gt;verbose&lt;/code&gt; is 1 or less, the tests will just show information messages about the tests that are run; but if it is greater than 1, then the tests will also provide warnings on missing tests. So if you want to run every test and get messages about which modules don&amp;rsquo;t have tests:</source>
          <target state="translated">テストメソッドは2つ以上の引数を取る場合があります。最初の &lt;code&gt;label&lt;/code&gt; はテスト対象を指定する文字列で、2番目の &lt;code&gt;verbose&lt;/code&gt; は出力の詳細度のレベルを示す整数です。詳細については、numpy.testのdocstringを参照してください。 &lt;code&gt;label&lt;/code&gt; のデフォルト値は 'fast'で、標準のテストを実行します。文字列 'full'は、実行が遅いと識別されたものを含め、一連のテストをすべて実行します。場合は &lt;code&gt;verbose&lt;/code&gt; 1以下であり、テストは単に実行されるテストに関する情報メッセージが表示されます。しかし、それが1より大きい場合、テストは欠落しているテストに関する警告も提供します。したがって、すべてのテストを実行して、どのモジュールにテストがないかに関するメッセージを取得する場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="03733f354e779af14d028cdbdf0476c16657d14e" translate="yes" xml:space="preserve">
          <source>The test to label as slow.</source>
          <target state="translated">遅いとレッテルを貼るテスト。</target>
        </trans-unit>
        <trans-unit id="28bda9f13cb5fd35de4d1871d5d1a6b158a05b66" translate="yes" xml:space="preserve">
          <source>The test verifies identical shapes and that the elements of &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; satisfy.</source>
          <target state="translated">テストは、同一の形状を検証し、 &lt;code&gt;actual&lt;/code&gt; の要素と &lt;code&gt;desired&lt;/code&gt; 要素が満たすことを検証します。</target>
        </trans-unit>
        <trans-unit id="a7fabe2aaa71feebc60270bd4d75ad9164f05bed" translate="yes" xml:space="preserve">
          <source>The test verifies that the elements of &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; satisfy.</source>
          <target state="translated">テストでは、 &lt;code&gt;actual&lt;/code&gt; の要素と &lt;code&gt;desired&lt;/code&gt; 要素が満たされていることを確認します。</target>
        </trans-unit>
        <trans-unit id="bf9247f40709953bae5128ab011a3c6a23e1bb6b" translate="yes" xml:space="preserve">
          <source>The three dimensional series is evaluated at the points &lt;code&gt;(x, y, z)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; must have the same shape. If any of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, or &lt;code&gt;z&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn&amp;rsquo;t an ndarray it is treated as a scalar.</source>
          <target state="translated">3次元シリーズは、ポイント &lt;code&gt;(x, y, z)&lt;/code&gt; で評価されます。ここで、 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、および &lt;code&gt;z&lt;/code&gt; は同じ形状でなければなりません。 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、または &lt;code&gt;z&lt;/code&gt; のいずれかがリストまたはタプルの場合、最初にndarrayに変換されます。それ以外の場合は変更されず、ndarrayでない場合はスカラーとして扱われます。</target>
        </trans-unit>
        <trans-unit id="ababec7c614f8cc809a5f4b9df993b70ee13a8f8" translate="yes" xml:space="preserve">
          <source>The three dimensional series is evaluated at the points in the Cartesian product of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt;,`y`, or &lt;code&gt;z&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">3次元シリーズは、 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、および &lt;code&gt;z&lt;/code&gt; のデカルト積のポイントで評価されます。場合 &lt;code&gt;x&lt;/code&gt; 、 `y`、又は &lt;code&gt;z&lt;/code&gt; 、リストまたはタプルであるが最初ndarrayに変換され、それ以外の場合は、それがndarrayない場合、それはスカラーとして扱われ、変更されないままとされます。</target>
        </trans-unit>
        <trans-unit id="3f792b485609224acbb4d7367551edb56b3d1d82" translate="yes" xml:space="preserve">
          <source>The three division operators are all defined; &lt;code&gt;div&lt;/code&gt; is active by default, &lt;code&gt;truediv&lt;/code&gt; is active when &lt;a href=&quot;https://docs.python.org/dev/library/__future__.html#module-__future__&quot;&gt;&lt;code&gt;__future__&lt;/code&gt;&lt;/a&gt; division is in effect.</source>
          <target state="translated">3つの除算演算子がすべて定義されています。 &lt;code&gt;div&lt;/code&gt; はデフォルトでアクティブであり、&lt;a href=&quot;https://docs.python.org/dev/library/__future__.html#module-__future__&quot;&gt; &lt;code&gt;__future__&lt;/code&gt; &lt;/a&gt;除算が有効な場合、 &lt;code&gt;truediv&lt;/code&gt; はアクティブです。</target>
        </trans-unit>
        <trans-unit id="6953aff01d51815d13e09f72484f920fa7369db2" translate="yes" xml:space="preserve">
          <source>The thresholds above deal with floating point roundoff error in the calculation of the SVD. However, you may have more information about the sources of error in &lt;code&gt;M&lt;/code&gt; that would make you consider other tolerance values to detect &lt;em&gt;effective&lt;/em&gt; rank deficiency. The most useful measure of the tolerance depends on the operations you intend to use on your matrix. For example, if your data come from uncertain measurements with uncertainties greater than floating point epsilon, choosing a tolerance near that uncertainty may be preferable. The tolerance may be absolute if the uncertainties are absolute rather than relative.</source>
          <target state="translated">上記のしきい値は、SVDの計算における浮動小数点丸め誤差を扱います。ただし、 &lt;code&gt;M&lt;/code&gt; の誤差の原因についてより多くの情報があり、他の許容値を検討して&lt;em&gt;有効な&lt;/em&gt;ランクの不足を検出する場合があります。許容誤差の最も有用な尺度は、マトリックスで使用する操作によって異なります。たとえば、データが浮動小数点イプシロンより大きい不確実性を伴う不確かな測定から得られた場合、その不確実性に近い許容誤差を選択することが望ましい場合があります。不確実性が相対的ではなく絶対的な場合、許容誤差は絶対的な場合があります。</target>
        </trans-unit>
        <trans-unit id="64c20447e1e6f9694ec0f7bb75ec43f4f4cb6058" translate="yes" xml:space="preserve">
          <source>The tiled output array.</source>
          <target state="translated">タイル化された出力配列。</target>
        </trans-unit>
        <trans-unit id="8bc4b16e1cf995efdf33020e8a2b8f7760d88f9e" translate="yes" xml:space="preserve">
          <source>The time required to produce using multiple threads can be compared to the time required to generate using a single thread.</source>
          <target state="translated">複数のスレッドを使用して生成する場合の所要時間と、1つのスレッドを使用して生成する場合の所要時間を比較することができます。</target>
        </trans-unit>
        <trans-unit id="bcdefbec5fdfd59d604b41a08eaf1010ff1f9f3b" translate="yes" xml:space="preserve">
          <source>The timings below are the time in ns to produce 1 random value from a specific distribution. The original &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; generator is much slower since it requires 2 32-bit values to equal the output of the faster generators.</source>
          <target state="translated">以下のタイミングは、特定の分布から1つのランダム値を生成するためのns単位の時間です。元の&lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt;ジェネレーターは、高速ジェネレーターの出力と等しくなるために2つの32ビット値を必要とするため、はるかに低速です。</target>
        </trans-unit>
        <trans-unit id="343a5bcbcad72b541893cb8c8e45cc7f466bba8b" translate="yes" xml:space="preserve">
          <source>The timings below are the time in ns to produce 1 random value from a specific distribution. The original &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; generator is much slower since it requires 2 32-bit values to equal the output of the faster generators.</source>
          <target state="translated">以下のタイミングは、特定の分布から1つのランダムな値を生成するためのns単位の時間です。元の&lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt;ジェネレーターは、より高速なジェネレーターの出力と等しくするために2つの32ビット値を必要とするため、かなり低速です。</target>
        </trans-unit>
        <trans-unit id="1d2c30ac9be07be723e9ef95eaf137f9bc73af0a" translate="yes" xml:space="preserve">
          <source>The tolerance values are positive, typically very small numbers. The relative difference (&lt;code&gt;rtol&lt;/code&gt; * abs(&lt;code&gt;b&lt;/code&gt;)) and the absolute difference &lt;code&gt;atol&lt;/code&gt; are added together to compare against the absolute difference between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">許容値は正で、通常は非常に小さい数値です。相対差（ &lt;code&gt;rtol&lt;/code&gt; * ABS（ &lt;code&gt;b&lt;/code&gt; ））との差分絶対 &lt;code&gt;atol&lt;/code&gt; 差の絶対値と比較するために一緒に追加されると &lt;code&gt;b&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52a51aeadfd53cc309968068f2e1965d359a3909" translate="yes" xml:space="preserve">
          <source>The total broadcasted size.</source>
          <target state="translated">放送されたサイズの合計。</target>
        </trans-unit>
        <trans-unit id="df3d0e81279bb92508eaea005084a0b02573f0f5" translate="yes" xml:space="preserve">
          <source>The total number of arguments (&lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt;). This must be less than &lt;a href=&quot;array#c.NPY_MAXARGS&quot;&gt;&lt;code&gt;NPY_MAXARGS&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">引数の総数（&lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt;）。これは&lt;a href=&quot;array#c.NPY_MAXARGS&quot;&gt; &lt;code&gt;NPY_MAXARGS&lt;/code&gt; &lt;/a&gt;未満である必要があります。</target>
        </trans-unit>
        <trans-unit id="1470f5efa816c498ec2cdd99dd6bc7fe2a058b68" translate="yes" xml:space="preserve">
          <source>The total number of arguments (&lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt;). This must be less than &lt;code&gt;NPY_MAXARGS&lt;/code&gt;.</source>
          <target state="translated">引数の合計数（&lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt;）。これは &lt;code&gt;NPY_MAXARGS&lt;/code&gt; 未満でなければなりません。</target>
        </trans-unit>
        <trans-unit id="af0d1953b87871e5f5c2cfb05eba9aaf99050200" translate="yes" xml:space="preserve">
          <source>The total number of built-in NumPy types. The enumeration covers the range from 0 to NPY_NTYPES-1.</source>
          <target state="translated">組み込みのNumPy型の総数。列挙は 0 から NPY_NTYPES-1 までの範囲をカバーしています。</target>
        </trans-unit>
        <trans-unit id="abe92a5e4aa66a77153ec46749bbd30d898eb468" translate="yes" xml:space="preserve">
          <source>The total number of masked elements (axis=None) or the number of masked elements along each slice of the given axis.</source>
          <target state="translated">マスクされた要素の合計数(axis=None)、または与えられた軸の各スライスに沿ったマスクされた要素の数。</target>
        </trans-unit>
        <trans-unit id="7423c677797c62eaba11c700e763c8330a87769e" translate="yes" xml:space="preserve">
          <source>The total payment is made up of payment against principal plus interest.</source>
          <target state="translated">支払総額は、元金に対する支払いに利息を加えて構成されています。</target>
        </trans-unit>
        <trans-unit id="b7226d44903c768f342634b37f3cd2cbe870d83c" translate="yes" xml:space="preserve">
          <source>The total size of the underlying array.</source>
          <target state="translated">基礎となる配列の合計サイズ。</target>
        </trans-unit>
        <trans-unit id="b17ef49a2b827517f40e328c2cdae6675b6f65d6" translate="yes" xml:space="preserve">
          <source>The transform for real input is performed over the last transformation axis, as by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, then the transform over the remaining axes is performed as by &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;. The order of the output is as for &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt; for the final transformation axis, and as for &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt; for the remaining transformation axes.</source>
          <target state="translated">実際の入力の変換は、&lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; の&lt;/a&gt;ように最後の変換軸で実行され、次に残りの軸の変換は&lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; で&lt;/a&gt;実行されます。出力の順序は、最終変換軸の場合は&lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt;、残りの変換軸の場合は&lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="85975e151b66ed8086ffe0edc17f692849490b8d" translate="yes" xml:space="preserve">
          <source>The transpose of a C-ordered array is a FORTRAN-ordered array.</source>
          <target state="translated">C順配列の転置はFORTRAN順配列です。</target>
        </trans-unit>
        <trans-unit id="be8d0d980a1c43a49c10382a49da454ce905c4ef" translate="yes" xml:space="preserve">
          <source>The transposed array.</source>
          <target state="translated">転置配列です。</target>
        </trans-unit>
        <trans-unit id="ded8f77d9cba6691688303bd624c72d17c97324f" translate="yes" xml:space="preserve">
          <source>The tree in &lt;code&gt;numpy&lt;/code&gt; will now have the latest changes from the initial repository.</source>
          <target state="translated">&lt;code&gt;numpy&lt;/code&gt; のツリーには、初期リポジトリからの最新の変更が含まれます。</target>
        </trans-unit>
        <trans-unit id="362e7b5f1deb8afe588bc61b11c57a486aa6b58d" translate="yes" xml:space="preserve">
          <source>The triangular distribution is a continuous probability distribution with lower limit left, peak at mode, and upper limit right. Unlike the other distributions, these parameters directly define the shape of the pdf.</source>
          <target state="translated">三角分布は,下限左,モードでのピーク,上限右を持つ連続確率分布である。他の分布とは異なり、これらのパラメータはpdfの形状を直接定義します。</target>
        </trans-unit>
        <trans-unit id="1d2039a815b5ec90474a824463e862d2894a1c82" translate="yes" xml:space="preserve">
          <source>The triangular distribution is often used in ill-defined problems where the underlying distribution is not known, but some knowledge of the limits and mode exists. Often it is used in simulations.</source>
          <target state="translated">三角分布は、基礎となる分布が知られていないが、限界とモードの知識がある程度存在するような不明確な問題でよく使われます。しばしばシミュレーションで使用されます。</target>
        </trans-unit>
        <trans-unit id="6a93dc1adb33729debf6e5480c2814c2157666fd" translate="yes" xml:space="preserve">
          <source>The triangular window, with the maximum value normalized to one (the value one appears only if the number of samples is odd), with the first and last samples equal to zero.</source>
          <target state="translated">三角形のウィンドウで、最大値が1に正規化されており(サンプル数が奇数の場合にのみ値1が表示されます)、最初と最後のサンプルは0に等しくなっています。</target>
        </trans-unit>
        <trans-unit id="24e66129ed79808afe1e2c37f4c9f61c91ca2839" translate="yes" xml:space="preserve">
          <source>The true value of &lt;code&gt;exp(1e-10) - 1&lt;/code&gt; is &lt;code&gt;1.00000000005e-10&lt;/code&gt; to about 32 significant digits. This example shows the superiority of expm1 in this case.</source>
          <target state="translated">&lt;code&gt;exp(1e-10) - 1&lt;/code&gt; の真の値は、 &lt;code&gt;1.00000000005e-10&lt;/code&gt; から約32桁の有効数字です。この例は、この場合のexpm1の優位性を示しています。</target>
        </trans-unit>
        <trans-unit id="973da8e077b17711228349d2b08c7d0d4f2d3661" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above.</source>
          <target state="translated">上記のパラメーターのセクションで説明したように、axesによって示される &lt;code&gt;axes&lt;/code&gt; 沿って、または &lt;code&gt;s&lt;/code&gt; と &lt;code&gt;a&lt;/code&gt; の組み合わせによって変換された、切り捨てられた入力またはゼロが埋め込まれた入力。</target>
        </trans-unit>
        <trans-unit id="0cef9d8907fc4d88debbd9a6424b4425ec58e68f" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above. The length of the last axis transformed will be &lt;code&gt;s[-1]//2+1&lt;/code&gt;, while the remaining transformed axes will have lengths according to &lt;code&gt;s&lt;/code&gt;, or unchanged from the input.</source>
          <target state="translated">上記のパラメーターのセクションで説明したように、axesによって示される &lt;code&gt;axes&lt;/code&gt; 沿って、または &lt;code&gt;s&lt;/code&gt; と &lt;code&gt;a&lt;/code&gt; の組み合わせによって変換された、切り捨てられた入力またはゼロが埋め込まれた入力。変換された最後の軸の長さは &lt;code&gt;s[-1]//2+1&lt;/code&gt; になりますが、残りの変換された軸の長さは &lt;code&gt;s&lt;/code&gt; に従うか、入力から変化しません。</target>
        </trans-unit>
        <trans-unit id="9c91d131105a38ed60b366938edb9bb82399cba7" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above.</source>
          <target state="translated">上記のパラメーターのセクションで説明したように、axesによって示される &lt;code&gt;axes&lt;/code&gt; 沿って、または &lt;code&gt;s&lt;/code&gt; または &lt;code&gt;a&lt;/code&gt; の組み合わせによって変換された、切り捨てられた、またはゼロが埋め込まれた入力。</target>
        </trans-unit>
        <trans-unit id="879b9a05c20a089a225b78254a5b2e292b149d60" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above. The length of each transformed axis is as given by the corresponding element of &lt;code&gt;s&lt;/code&gt;, or the length of the input in every axis except for the last one if &lt;code&gt;s&lt;/code&gt; is not given. In the final transformed axis the length of the output when &lt;code&gt;s&lt;/code&gt; is not given is &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the final transformed axis of the input. To get an odd number of output points in the final axis, &lt;code&gt;s&lt;/code&gt; must be specified.</source>
          <target state="translated">上記のパラメーターのセクションで説明したように、axesによって示される &lt;code&gt;axes&lt;/code&gt; 沿って、または &lt;code&gt;s&lt;/code&gt; または &lt;code&gt;a&lt;/code&gt; の組み合わせによって変換された、切り捨てられた、またはゼロが埋め込まれた入力。変換された各軸の長さは、 &lt;code&gt;s&lt;/code&gt; の対応する要素によって与えられるか、または &lt;code&gt;s&lt;/code&gt; が与えられない場合は最後の軸を除くすべての軸の入力の長さです。最終変換軸では、 &lt;code&gt;s&lt;/code&gt; が指定されていない場合の出力の長さは &lt;code&gt;2*(m-1)&lt;/code&gt; ここで、 &lt;code&gt;m&lt;/code&gt; は入力の最終変換軸の長さです。最終軸で奇数の出力ポイントを取得するには、 &lt;code&gt;s&lt;/code&gt; を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="933c6e0a0fb2fd7449c8d46cb7e6572b1c3279dd" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or the last two axes if &lt;code&gt;axes&lt;/code&gt; is not given.</source>
          <target state="translated">軸に沿って転換切り捨てまたはゼロパディング入力は、で示される &lt;code&gt;axes&lt;/code&gt; 場合、または最後の二つの軸 &lt;code&gt;axes&lt;/code&gt; 与えられていません。</target>
        </trans-unit>
        <trans-unit id="bdca2715ebaff6edc1c47e7d7cb69eb535ec549b" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified.</source>
          <target state="translated">axisで示された &lt;code&gt;axis&lt;/code&gt; 沿って変換された、切り捨てられた、またはゼロが埋め込まれた入力、または &lt;code&gt;axis&lt;/code&gt; が指定されていない場合は最後の入力。</target>
        </trans-unit>
        <trans-unit id="f4095a8db5d8ecd4ba9c0d3227d91d6c6751102f" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. If &lt;code&gt;n&lt;/code&gt; is even, the length of the transformed axis is &lt;code&gt;(n/2)+1&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is odd, the length is &lt;code&gt;(n+1)/2&lt;/code&gt;.</source>
          <target state="translated">axisで示された &lt;code&gt;axis&lt;/code&gt; 沿って変換された、切り捨てられた、またはゼロが埋め込まれた入力、または &lt;code&gt;axis&lt;/code&gt; が指定されていない場合は最後の入力。 &lt;code&gt;n&lt;/code&gt; が偶数の場合、変換された軸の長さは &lt;code&gt;(n/2)+1&lt;/code&gt; です。場合 &lt;code&gt;n&lt;/code&gt; は奇数である、長さが &lt;code&gt;(n+1)/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="210fa87b6170797ddb3ab263d911a488e3f1f97e" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n//2 + 1&lt;/code&gt;.</source>
          <target state="translated">axisで示された &lt;code&gt;axis&lt;/code&gt; 沿って変換された、切り捨てられた、またはゼロが埋め込まれた入力、または &lt;code&gt;axis&lt;/code&gt; が指定されていない場合は最後の入力。変換後の軸の長さは &lt;code&gt;n//2 + 1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1026feb255ba9e4ae695f12a04d60bbc57c49ac5" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n&lt;/code&gt;, or, if &lt;code&gt;n&lt;/code&gt; is not given, &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the transformed axis of the input. To get an odd number of output points, &lt;code&gt;n&lt;/code&gt; must be specified.</source>
          <target state="translated">axisで示された &lt;code&gt;axis&lt;/code&gt; 沿って変換された、切り捨てられた、またはゼロが埋め込まれた入力、または &lt;code&gt;axis&lt;/code&gt; が指定されていない場合は最後の入力。変換された軸の長さは &lt;code&gt;n&lt;/code&gt; です &lt;code&gt;n&lt;/code&gt; が指定されていない場合は、 &lt;code&gt;2*(m-1)&lt;/code&gt; ここで、 &lt;code&gt;m&lt;/code&gt; は入力の変換された軸の長さです。奇数の出力ポイントを取得するには、 &lt;code&gt;n&lt;/code&gt; を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="785f913e97e6f2c077e366a11b3d02d03922b2c4" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n&lt;/code&gt;, or, if &lt;code&gt;n&lt;/code&gt; is not given, &lt;code&gt;2*m - 2&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the transformed axis of the input. To get an odd number of output points, &lt;code&gt;n&lt;/code&gt; must be specified, for instance as &lt;code&gt;2*m - 1&lt;/code&gt; in the typical case,</source>
          <target state="translated">axisで示された &lt;code&gt;axis&lt;/code&gt; 沿って変換された、切り捨てられた、またはゼロが埋め込まれた入力、または &lt;code&gt;axis&lt;/code&gt; が指定されていない場合は最後の入力。変換された軸の長さは &lt;code&gt;n&lt;/code&gt; です &lt;code&gt;n&lt;/code&gt; が指定されていない場合は、 &lt;code&gt;2*m - 2&lt;/code&gt; ここで、 &lt;code&gt;m&lt;/code&gt; は入力の変換された軸の長さです。奇数の出力ポイントを取得するには、 &lt;code&gt;n&lt;/code&gt; を指定する必要があります。たとえば、通常の場合は &lt;code&gt;2*m - 1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="890cb80542174800559555fcc8928d47ac767144" translate="yes" xml:space="preserve">
          <source>The truncated value of each element in &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の各要素の切り捨てられた値。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="d225104697ad1c2e4adc5e266a19505669d514fa" translate="yes" xml:space="preserve">
          <source>The truncated value of the scalar &lt;code&gt;x&lt;/code&gt; is the nearest integer &lt;code&gt;i&lt;/code&gt; which is closer to zero than &lt;code&gt;x&lt;/code&gt; is. In short, the fractional part of the signed number &lt;code&gt;x&lt;/code&gt; is discarded.</source>
          <target state="translated">スカラーの切り捨て値 &lt;code&gt;x&lt;/code&gt; は整数最も近い &lt;code&gt;i&lt;/code&gt; 近いゼロよりなる &lt;code&gt;x&lt;/code&gt; があります。つまり、符号付き数値 &lt;code&gt;x&lt;/code&gt; の小数部分は破棄されます。</target>
        </trans-unit>
        <trans-unit id="7473e98cdd8b9577d457a4ec3ae00062b1e0d1c1" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;args&lt;/code&gt; and dict &lt;code&gt;kwargs&lt;/code&gt; are directly passed on from the original call.</source>
          <target state="translated">タプル &lt;code&gt;args&lt;/code&gt; とdict &lt;code&gt;kwargs&lt;/code&gt; は、元の呼び出しから直接渡されます。</target>
        </trans-unit>
        <trans-unit id="462bd3332737c1c0e3c136e2df99165ffa307b94" translate="yes" xml:space="preserve">
          <source>The tuple returned from __array_interface__[&amp;lsquo;data&amp;rsquo;] used to be a hex-string (now it is an integer or a long integer).</source>
          <target state="translated">__array_interface __ ['data']から返されたタプルは、以前は16進文字列でした（現在は整数または長整数です）。</target>
        </trans-unit>
        <trans-unit id="ac07e35413d52171420d0546afbc516e4675dfc6" translate="yes" xml:space="preserve">
          <source>The two arrays are of the same length, so there is only one position where they completely overlap:</source>
          <target state="translated">2つの配列は同じ長さなので、完全に重なる位置は1つだけです。</target>
        </trans-unit>
        <trans-unit id="a1576896c14768083aa4b0494018f6de168f9aa6" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points &lt;code&gt;(x, y)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must have the same shape. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn&amp;rsquo;t an ndarray it is treated as a scalar.</source>
          <target state="translated">2次元の系列は、ポイント &lt;code&gt;(x, y)&lt;/code&gt; で評価されます。ここで、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は同じ形状でなければなりません。場合 &lt;code&gt;x&lt;/code&gt; または &lt;code&gt;y&lt;/code&gt; リストまたはタプルである、それは最初ndarrayに変換され、そうでない場合は変更されないままであり、それはndarrayない場合には、スカラーとして扱われます。</target>
        </trans-unit>
        <trans-unit id="2eba9ab6dc5fc4a672b7a559261dcf61c08663b7" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points &lt;code&gt;(x, y)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must have the same shape. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">2次元の系列は、ポイント &lt;code&gt;(x, y)&lt;/code&gt; で評価されます。ここで、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は同じ形状でなければなりません。場合 &lt;code&gt;x&lt;/code&gt; または &lt;code&gt;y&lt;/code&gt; リストまたはタプルであるが最初ndarrayに変換され、それ以外の場合は、それがndarrayない場合、それはスカラーとして扱われ、変更されないままとされます。</target>
        </trans-unit>
        <trans-unit id="0688b7907322e12f298dd8f02d187105297d15b2" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">2次元系列は、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; のデカルト積の点で評価されます。場合 &lt;code&gt;x&lt;/code&gt; または &lt;code&gt;y&lt;/code&gt; リストまたはタプルであるが最初ndarrayに変換され、それ以外の場合は、それがndarrayない場合、それはスカラーとして扱われ、変更されないままとされます。</target>
        </trans-unit>
        <trans-unit id="d4aa44f129ba54b421bffe3762821ce4945dce60" translate="yes" xml:space="preserve">
          <source>The two domains that determine the map. Each must (successfully) convert to 1-d arrays containing precisely two values.</source>
          <target state="translated">マップを決定する2つのドメイン。それぞれが(成功して)正確に2つの値を含む1-d配列に変換しなければなりません。</target>
        </trans-unit>
        <trans-unit id="0027adc4d9c51b047c70705863099ef3efdd05ff" translate="yes" xml:space="preserve">
          <source>The two methods do not return the same sequence of variates.</source>
          <target state="translated">2つのメソッドは、同じシーケンスのバリアートを返しません。</target>
        </trans-unit>
        <trans-unit id="810d0511d5cc6182785b949cef8752429de415c1" translate="yes" xml:space="preserve">
          <source>The two&amp;rsquo;s complement is returned when the input number is negative and width is specified:</source>
          <target state="translated">入力数値が負で幅が指定されている場合、2の補数が返されます。</target>
        </trans-unit>
        <trans-unit id="584450aea06b04e9037daf43c6af1e81a83e775a" translate="yes" xml:space="preserve">
          <source>The two-dimensional FFT of real input.</source>
          <target state="translated">実数入力の2次元FFT。</target>
        </trans-unit>
        <trans-unit id="9b11970984391ed9339a62d69846a84202600584" translate="yes" xml:space="preserve">
          <source>The two-dimensional FFT.</source>
          <target state="translated">二次元FFTです。</target>
        </trans-unit>
        <trans-unit id="93378f6188f826db256b9d6c37c0794ddd0149ba" translate="yes" xml:space="preserve">
          <source>The two-dimensional example we created using Fortran is just as easy to write in Cython:</source>
          <target state="translated">Fortranを使って作った二次元の例は、Cythonで書くのと同じように簡単です。</target>
        </trans-unit>
        <trans-unit id="cc89089001cef3c7a737f8de3b95a6b67d11a175" translate="yes" xml:space="preserve">
          <source>The two-dimensional inverse FFT.</source>
          <target state="translated">2次元の逆FFT。</target>
        </trans-unit>
        <trans-unit id="9f5faf584fb30081780464310b34017103e73128" translate="yes" xml:space="preserve">
          <source>The type above can either refer to an actual Python type (e.g. &lt;code&gt;int&lt;/code&gt;), or describe the type of the variable in more detail, e.g. &lt;code&gt;(N,) ndarray&lt;/code&gt; or &lt;code&gt;array_like&lt;/code&gt;.</source>
          <target state="translated">上記の型は、実際のP​​ython型（ &lt;code&gt;int&lt;/code&gt; など）を参照することも、変数の型をより詳細に説明することもできます &lt;code&gt;(N,) ndarray&lt;/code&gt; や &lt;code&gt;array_like&lt;/code&gt; など）。</target>
        </trans-unit>
        <trans-unit id="66cebb62b229032f20fef01d3cd3e2d8c08b92d1" translate="yes" xml:space="preserve">
          <source>The type object used to instantiate a scalar of this data-type.</source>
          <target state="translated">このデータ型のスカラのインスタンスを作成するために使用される型オブジェクト。</target>
        </trans-unit>
        <trans-unit id="6e4f0a20a4e71ba4f55f61f65f81013f324f6ce9" translate="yes" xml:space="preserve">
          <source>The type of the array can also be explicitly specified at creation time:</source>
          <target state="translated">配列の型は、作成時に明示的に指定することもできます。</target>
        </trans-unit>
        <trans-unit id="fa0bd68b05131d508a3464e6044d68f87729d81c" translate="yes" xml:space="preserve">
          <source>The type of the data can be accessed through the &lt;a href=&quot;#numpy.ma.MaskedArray.baseclass&quot;&gt;&lt;code&gt;baseclass&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">データのタイプは、&lt;a href=&quot;#numpy.ma.MaskedArray.baseclass&quot;&gt; &lt;code&gt;baseclass&lt;/code&gt; &lt;/a&gt;属性を介してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="4e723834a8970a250a2a2d214449437cb2b1463f" translate="yes" xml:space="preserve">
          <source>The type of the data can be accessed through the &lt;a href=&quot;numpy.ma.masked_array.baseclass#numpy.ma.masked_array.baseclass&quot;&gt;&lt;code&gt;baseclass&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">データのタイプには、&lt;a href=&quot;numpy.ma.masked_array.baseclass#numpy.ma.masked_array.baseclass&quot;&gt; &lt;code&gt;baseclass&lt;/code&gt; &lt;/a&gt;属性を介してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="55666432b4662cbbcca855eedc915c8dbb074f43" translate="yes" xml:space="preserve">
          <source>The type of the data is described by the following &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; attributes:</source>
          <target state="translated">データのタイプは、次の&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;属性によって記述されます。</target>
        </trans-unit>
        <trans-unit id="7c7e8530225fc135f4d9b6eea552288840993321" translate="yes" xml:space="preserve">
          <source>The type of the input is checked, not the value. Even if the input has an imaginary part equal to zero, &lt;a href=&quot;#numpy.iscomplexobj&quot;&gt;&lt;code&gt;iscomplexobj&lt;/code&gt;&lt;/a&gt; evaluates to True.</source>
          <target state="translated">値ではなく、入力のタイプがチェックされます。入力にゼロに等しい虚数部がある場合でも、&lt;a href=&quot;#numpy.iscomplexobj&quot;&gt; &lt;code&gt;iscomplexobj&lt;/code&gt; &lt;/a&gt;はTrueと評価されます。</target>
        </trans-unit>
        <trans-unit id="1a2c8e641184f0940417186c9bd1b40520bec6a6" translate="yes" xml:space="preserve">
          <source>The type of the input is checked, not the value. So even if the input has an imaginary part equal to zero, &lt;a href=&quot;#numpy.isrealobj&quot;&gt;&lt;code&gt;isrealobj&lt;/code&gt;&lt;/a&gt; evaluates to False if the data type is complex.</source>
          <target state="translated">値ではなく、入力のタイプがチェックされます。したがって、入力の虚数部がゼロに等しい場合でも、データ型が複素数の場合、&lt;a href=&quot;#numpy.isrealobj&quot;&gt; &lt;code&gt;isrealobj&lt;/code&gt; &lt;/a&gt;はFalseと評価されます。</target>
        </trans-unit>
        <trans-unit id="ea61e4d42852a1b3d6a2054bbf717a4dcd45c615" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not given, infer the data type from the other input arguments.</source>
          <target state="translated">出力配列のタイプ。&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;が指定されていない場合は、他の入力引数からデータ型を推測します。</target>
        </trans-unit>
        <trans-unit id="2c73d98907158f7fb67c4efa759cdbb5f806f2d4" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;code&gt;dtype&lt;/code&gt; is not given, infer the data type from the other input arguments.</source>
          <target state="translated">出力配列のタイプ。 &lt;code&gt;dtype&lt;/code&gt; が指定されていない場合は、他の入力引数からデータ型を推測します。</target>
        </trans-unit>
        <trans-unit id="a61a6b8f22a17e9cfb7771cdc6f2f0f745c54b06" translate="yes" xml:space="preserve">
          <source>The type of the result will depend on the encoding specified.</source>
          <target state="translated">結果の型は、指定されたエンコーディングに依存します。</target>
        </trans-unit>
        <trans-unit id="9f964988f963b226cae3c6098e96762218b96f31" translate="yes" xml:space="preserve">
          <source>The type of the returned array and of the accumulator in which the elements are summed. By default, the dtype of &lt;code&gt;a&lt;/code&gt; is used. An exception is when &lt;code&gt;a&lt;/code&gt; has an integer type with less precision than the platform (u)intp. In that case, the default will be either (u)int32 or (u)int64 depending on whether the platform is 32 or 64 bits. For inexact inputs, dtype must be inexact.</source>
          <target state="translated">返された配列の型と、要素が合計されるアキュムレータの型。デフォルトでは、のdtypeは使用されています。例外は、 &lt;code&gt;a&lt;/code&gt; がプラットフォーム（u）intpよりも精度が低い整数型の場合です。その場合、プラットフォームが32ビットか64ビットかによって、デフォルトは（u）int32または（u）int64になります。不正確な入力の場合、dtypeは不正確でなければなりません。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fae2388276bf4adee2baf6958155240f0239ec9b" translate="yes" xml:space="preserve">
          <source>The type of the returned array and of the accumulator in which the elements are summed. The dtype of &lt;code&gt;a&lt;/code&gt; is used by default unless &lt;code&gt;a&lt;/code&gt; has an integer dtype of less precision than the default platform integer. In that case, if &lt;code&gt;a&lt;/code&gt; is signed then the platform integer is used while if &lt;code&gt;a&lt;/code&gt; is unsigned then an unsigned integer of the same precision as the platform integer is used.</source>
          <target state="translated">返された配列の型と、要素が合計されるアキュムレータの型。 DTYPE ない限り、デフォルトで使用されるデフォルトプラットフォームの整数未満の精度の整数DTYPEを有しています。場合この場合、次に署名されている場合ながらプラットフォームの整数が使用され、次に署名され、プラットフォームの整数と同じ精度の符号なし整数が使用されます。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd79c4b3d3f0f1be1ec3ce5a1aa5d47271e61a5b" translate="yes" xml:space="preserve">
          <source>The type of the returned array, as well as of the accumulator in which the elements are multiplied. The dtype of &lt;code&gt;a&lt;/code&gt; is used by default unless &lt;code&gt;a&lt;/code&gt; has an integer dtype of less precision than the default platform integer. In that case, if &lt;code&gt;a&lt;/code&gt; is signed then the platform integer is used while if &lt;code&gt;a&lt;/code&gt; is unsigned then an unsigned integer of the same precision as the platform integer is used.</source>
          <target state="translated">返される配列の型と、要素が乗算されるアキュムレータの型。 DTYPE ない限り、デフォルトで使用されるデフォルトプラットフォームの整数未満の精度の整数DTYPEを有しています。場合この場合、次に署名されている場合ながらプラットフォームの整数が使用され、次に署名され、プラットフォームの整数と同じ精度の符号なし整数が使用されます。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3a7bb2863553d52f83413fb23d739a7fea567ae" translate="yes" xml:space="preserve">
          <source>The type used to represent the intermediate results. Defaults to the data type of the output array if this is provided, or the data type of the input array if no output array is provided.</source>
          <target state="translated">中間結果の表現に用いられる型。デフォルトは、出力配列が指定されている場合は出力配列のデータ型、出力配列が指定されていない場合は入力配列のデータ型となります。</target>
        </trans-unit>
        <trans-unit id="f46b668fbc5ae74dc471bbfdc9b1c8b2040c3ed5" translate="yes" xml:space="preserve">
          <source>The type used to represent the intermediate results. Defaults to the data-type of the output array if this is provided, or the data-type of the input array if no output array is provided.</source>
          <target state="translated">中間結果の表現に用いられる型。デフォルトは、出力配列が指定されている場合は出力配列のデータ型、出力配列が指定されていない場合は入力配列のデータ型となります。</target>
        </trans-unit>
        <trans-unit id="3d1a1953424d5a7364adfc318f2ceeb8ef42f6ff" translate="yes" xml:space="preserve">
          <source>The typemap directives provided by &lt;code&gt;numpy.i&lt;/code&gt; for arrays of different data types, say &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt;, and dimensions of different types, say &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;, are identical to one another except for the C and NumPy type specifications. The typemaps are therefore implemented (typically behind the scenes) via a macro:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; によって提供される、 &lt;code&gt;double&lt;/code&gt; および &lt;code&gt;int&lt;/code&gt; などの異なるデータ型の配列、および &lt;code&gt;int&lt;/code&gt; または &lt;code&gt;long&lt;/code&gt; などの異なる型の次元に対して提供されるtypemapディレクティブは、CおよびNumPy型の指定を除いて、互いに同じです。したがって、タイプマップはマクロを介して（通常は裏で）実装されます。</target>
        </trans-unit>
        <trans-unit id="dff7b3c37fb51796f178f8cb67e96939e35d8847" translate="yes" xml:space="preserve">
          <source>The typemap signatures are largely differentiated on the name given to the buffer pointer. Names with &lt;code&gt;FARRAY&lt;/code&gt; are for Fortran-ordered arrays, and names with &lt;code&gt;ARRAY&lt;/code&gt; are for C-ordered (or 1D arrays).</source>
          <target state="translated">タイプマップシグネチャは、バッファポインタに付けられた名前で大きく異なります。 &lt;code&gt;FARRAY&lt;/code&gt; が付いた名前はFortran順の配列用で、 &lt;code&gt;ARRAY&lt;/code&gt; が付いた名前はC順（または1D配列）用です。</target>
        </trans-unit>
        <trans-unit id="d316f93b51d10bd2681fb7336deed9067a473d1a" translate="yes" xml:space="preserve">
          <source>The typemaps from &lt;code&gt;numpy.i&lt;/code&gt; are responsible for the following lines of code: 12&amp;ndash;20, 25 and 30. Line 10 parses the input to the &lt;code&gt;rms&lt;/code&gt; function. From the format string &lt;code&gt;&quot;O:rms&quot;&lt;/code&gt;, we can see that the argument list is expected to be a single Python object (specified by the &lt;code&gt;O&lt;/code&gt; before the colon) and whose pointer is stored in &lt;code&gt;obj0&lt;/code&gt;. A number of functions, supplied by &lt;code&gt;numpy.i&lt;/code&gt;, are called to make and check the (possible) conversion from a generic Python object to a NumPy array. These functions are explained in the section &lt;a href=&quot;#helper-functions&quot;&gt;Helper Functions&lt;/a&gt;, but hopefully their names are self-explanatory. At line 12 we use &lt;code&gt;obj0&lt;/code&gt; to construct a NumPy array. At line 17, we check the validity of the result: that it is non-null and that it has a single dimension of arbitrary length. Once these states are verified, we extract the data buffer and length in lines 19 and 20 so that we can call the underlying C function at line 22. Line 25 performs memory management for the case where we have created a new array that is no longer needed.</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; のタイプマップは、次のコード行を担当します：12&amp;ndash;20、25、および30。10行目は、 &lt;code&gt;rms&lt;/code&gt; 関数への入力を解析します。フォーマット文字列 &lt;code&gt;&quot;O:rms&quot;&lt;/code&gt; から、引数リストは単一のPythonオブジェクト（コロンの前の &lt;code&gt;O&lt;/code&gt; で指定）であることが期待され、そのポインターは &lt;code&gt;obj0&lt;/code&gt; に格納されていることがわかります。 &lt;code&gt;numpy.i&lt;/code&gt; によって提供される多数の関数が呼び出され、汎用のPythonオブジェクトからNumPy配列への（可能な）変換を実行およびチェックします。これらの関数については、「&lt;a href=&quot;#helper-functions&quot;&gt;ヘルパー関数&lt;/a&gt;」セクションで説明していますが、名前が一目でわかるようになっています。 12行目では &lt;code&gt;obj0&lt;/code&gt; を使用していますNumPy配列を作成します。 17行目では、結果の有効性を確認します。それがnullでないこと、および任意の長さの単一の次元を持っていることを確認します。これらの状態が確認されたら、19行目と20行目でデータバッファーと長さを抽出し、22行目で基礎となるC関数を呼び出すことができます。25行目は、もはや存在しない新しい配列を作成した場合のメモリ管理を実行します必要。</target>
        </trans-unit>
        <trans-unit id="94a9db34d902a4524ad7871b0441ea5be9c4a8b8" translate="yes" xml:space="preserve">
          <source>The typical looping construct is as follows.</source>
          <target state="translated">典型的なループ構造は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="93f339cfb377248f9f368c97945ac549c08d48eb" translate="yes" xml:space="preserve">
          <source>The ufunc object is implemented by creation of the &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt;&lt;code&gt;PyUFunc_Type&lt;/code&gt;&lt;/a&gt;. It is a very simple type that implements only basic getattribute behavior, printing behavior, and has call behavior which allows these objects to act like functions. The basic idea behind the ufunc is to hold a reference to fast 1-dimensional (vector) loops for each data type that supports the operation. These one-dimensional loops all have the same signature and are the key to creating a new ufunc. They are called by the generic looping code as appropriate to implement the N-dimensional function. There are also some generic 1-d loops defined for floating and complexfloating arrays that allow you to define a ufunc using a single scalar function (&lt;em&gt;e.g.&lt;/em&gt; atanh).</source>
          <target state="translated">ufuncオブジェクトはの創設によって実装され&lt;a href=&quot;#c.PyUFunc_Type&quot;&gt; &lt;code&gt;PyUFunc_Type&lt;/code&gt; &lt;/a&gt;。これは、基本的なgetattribute動作と印刷動作のみを実装する非常に単純なタイプであり、これらのオブジェクトを関数のように動作させる呼び出し動作を持っています。ufuncの背後にある基本的な考え方は、操作をサポートする各データ型の高速1次元（ベクトル）ループへの参照を保持することです。これらの1次元ループはすべて同じシグネチャを持ち、新しいufuncを作成するための鍵となります。これらは、N次元関数を実装するために、必要に応じて汎用ループコードによって呼び出されます。単一のスカラー関数（&lt;em&gt;例えば&lt;/em&gt; atanh）を使用してufuncを定義できる、浮動配列および複素浮動配列に対して定義されたいくつかの一般的な1-dループもあります。</target>
        </trans-unit>
        <trans-unit id="cf8db1044487cf17b16ec5dfd6f051754480a0fd" translate="yes" xml:space="preserve">
          <source>The ufunc still returns its output(s) even if you use the optional output argument(s).</source>
          <target state="translated">ufuncは、オプションの出力引数(s)を使用しても、その出力(s)を返します。</target>
        </trans-unit>
        <trans-unit id="a13b64ddac2c6f9c4757f678876470a35b9dd260" translate="yes" xml:space="preserve">
          <source>The umath module is a computer-generated C-module that creates many ufuncs. It provides a great many examples of how to create a universal function. Creating your own ufunc that will make use of the ufunc machinery is not difficult either. Suppose you have a function that you want to operate element-by-element over its inputs. By creating a new ufunc you will obtain a function that handles</source>
          <target state="translated">umathモジュールは、多くのufuncsを作成するコンピュータ生成のCモジュールです。普遍的な関数を作成する方法について、非常に多くの例を提供しています。ufuncの機械を利用した独自のufuncを作成することも難しくはありません。例えば、入力に対して要素ごとに操作したい関数があるとします。ufuncを新規に作成することで、以下のような関数が得られます。</target>
        </trans-unit>
        <trans-unit id="6d199d62fee4302579457e386e4a80ba73f82400" translate="yes" xml:space="preserve">
          <source>The underlying data of a masked array can be accessed in several ways:</source>
          <target state="translated">マスクされた配列の基礎となるデータには,いくつかの方法でアクセスすることができます.</target>
        </trans-unit>
        <trans-unit id="11e8796701c0b67707f7be52c1081d9ae533b8cd" translate="yes" xml:space="preserve">
          <source>The underlying file descriptor is closed when exiting the &amp;lsquo;with&amp;rsquo; block.</source>
          <target state="translated">「with」ブロックを終了すると、基になるファイル記述子が閉じます。</target>
        </trans-unit>
        <trans-unit id="8a7d26eedaa6e3c6ca58f22a4d3a1445aae9ed58" translate="yes" xml:space="preserve">
          <source>The upper-triangular matrix.</source>
          <target state="translated">上三角行列。</target>
        </trans-unit>
        <trans-unit id="4d3a2d4644c583ea8315d7ff8cedb605a3b103a4" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;fib1.fib&lt;/code&gt; in Python is very similar to using &lt;code&gt;FIB&lt;/code&gt; in Fortran. However, using &lt;em&gt;in situ&lt;/em&gt; output arguments in Python indicates a poor style as there is no safety mechanism in Python with respect to wrong argument types. When using Fortran or C, compilers naturally discover any type mismatches during compile time but in Python the types must be checked in runtime. So, using &lt;em&gt;in situ&lt;/em&gt; output arguments in Python may cause difficult to find bugs, not to mention that the codes will be less readable when all required type checks are implemented.</source>
          <target state="translated">Pythonでの &lt;code&gt;fib1.fib&lt;/code&gt; の使用法は、Fortranでの &lt;code&gt;FIB&lt;/code&gt; の使用法と非常によく似ています。ただし、Python&lt;em&gt;でinsitu&lt;/em&gt;出力引数を使用&lt;em&gt;する&lt;/em&gt;と、間違った引数タイプに関する安全メカニズムがPythonにないため、スタイルが不適切であることを示します。FortranまたはCを使用する場合、コンパイラーはコンパイル時に型の不一致を自然に検出しますが、Pythonでは実行時に型をチェックする必要があります。そのため、Python&lt;em&gt;でその場での&lt;/em&gt;出力引数を使用&lt;em&gt;する&lt;/em&gt;と、必要なすべての型チェックが実装されるとコードが読みにくくなることは言うまでもなく、バグを見つけるのが困難になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="e4cb9fef2603ca49b4b7d883decd87bdc8eb544d" translate="yes" xml:space="preserve">
          <source>The use of random number generation is an important part of the configuration and evaluation of many numerical and machine learning algorithms. Whether you need to randomly initialize weights in an artificial neural network, split data into random sets, or randomly shuffle your dataset, being able to generate random numbers (actually, repeatable pseudo-random numbers) is essential.</source>
          <target state="translated">乱数生成の使用は、多くの数値計算や機械学習アルゴリズムの構成や評価の重要な部分です。人工ニューラルネットワークで重みをランダムに初期化する場合でも、データをランダムなセットに分割する場合でも、データセットをランダムにシャッフルする場合でも、乱数(実際には再現性のある擬似乱数)を生成できることは必須です。</target>
        </trans-unit>
        <trans-unit id="638520b9fcb56661a86b8addd734b2116df46c53" translate="yes" xml:space="preserve">
          <source>The use of this form of specification is discouraged, but documented here because older numpy code may use it. The keys of the dictionary are the field names and the values are tuples specifying type and offset:</source>
          <target state="translated">この形式の仕様の使用は推奨されませんが、古いnumpyコードが使用する可能性があるため、ここでは文書化しています。辞書のキーはフィールド名で、値は型とオフセットを指定するタプルです。</target>
        </trans-unit>
        <trans-unit id="4fb07adf94a9c0d15c6277e214f78bd8de82a95e" translate="yes" xml:space="preserve">
          <source>The user always has the option of converting to a normal &lt;code&gt;numpy.ndarray&lt;/code&gt; with &lt;a href=&quot;../reference/generated/numpy.asarray#numpy.asarray&quot;&gt;&lt;code&gt;numpy.asarray&lt;/code&gt;&lt;/a&gt; and using standard numpy from there.</source>
          <target state="translated">ユーザーは常に、&lt;a href=&quot;../reference/generated/numpy.asarray#numpy.asarray&quot;&gt; &lt;code&gt;numpy.asarray&lt;/code&gt; &lt;/a&gt;を使用して通常の &lt;code&gt;numpy.ndarray&lt;/code&gt; に変換し、そこから標準のnumpyを使用するオプションがあります。</target>
        </trans-unit>
        <trans-unit id="8fcd141d1c403551e053ceda2314596f85b55796" translate="yes" xml:space="preserve">
          <source>The usual caution for verifying equality with floating point numbers is advised.</source>
          <target state="translated">浮動小数点数で等号を検証する際には、通常の注意が必要です。</target>
        </trans-unit>
        <trans-unit id="6f6231b1c986a1cae99123ebb4b0aec8cf8b789f" translate="yes" xml:space="preserve">
          <source>The usual companion matrix of the Laguerre polynomials is already symmetric when &lt;code&gt;c&lt;/code&gt; is a basis Laguerre polynomial, so no scaling is applied.</source>
          <target state="translated">ラゲール多項式の通常のコンパニオン行列は、 &lt;code&gt;c&lt;/code&gt; が基底ラゲール多項式である場合、すでに対称であるため、スケーリングは適用されません。</target>
        </trans-unit>
        <trans-unit id="f77acab0966818b5a377ef30b38be521ef7f7b59" translate="yes" xml:space="preserve">
          <source>The value of the function when x1 is 0. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">x1が0の場合の関数の値 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状（出力の形状になる）にブロードキャスト可能でなければなりません。</target>
        </trans-unit>
        <trans-unit id="03d358ce11030b4d51f9879722053df717a3fe53" translate="yes" xml:space="preserve">
          <source>The value of this argument is typically a dictionary with column indices or column names as keys and a conversion functions as values. These conversion functions can either be actual functions or lambda functions. In any case, they should accept only a string as input and output only a single element of the wanted type.</source>
          <target state="translated">この引数の値は、典型的には、列インデックスまたは列名をキーとし、変換関数を値とする辞書である。これらの変換関数は,実際の関数でもラムダ関数でもよい。いずれにしても,これらの関数は,入力として文字列のみを受け入れ,希望する型の単一の要素のみを出力しなければならない。</target>
        </trans-unit>
        <trans-unit id="c3e9e5da5ef1ee5aadaa824ae3c6fd2914c94c23" translate="yes" xml:space="preserve">
          <source>The value of this attribute is used to determine what type of object to return in situations where there is more than one possibility for the Python type of the returned object. Subclasses inherit a default value of 0.0 for this attribute.</source>
          <target state="translated">この属性の値は、返されるオブジェクトの Python 型が複数の可能性がある場合に、どのような型のオブジェクトを返すかを決定するために使用されます。サブクラスはこの属性のデフォルト値 0.0 を継承します。</target>
        </trans-unit>
        <trans-unit id="8bcc816a3b6323731b656c466ec0a5744f30e87e" translate="yes" xml:space="preserve">
          <source>The value to convert. Positive and negative values are handled.</source>
          <target state="translated">変換する値。正の値と負の値を扱います。</target>
        </trans-unit>
        <trans-unit id="32b4c5a64bc9a7f3fa379e6006c427acc72a2601" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; attribute of the array is used instead.</source>
          <target state="translated">無効なエントリに使用する値（デフォルトではなし）。Noneの場合、代わりに配列の&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;属性が使用されます。</target>
        </trans-unit>
        <trans-unit id="46bea3445bf9a264b60905faf1d0effc77e2e249" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, then this argument is inferred from the passed &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, or in its absence the original array, as discussed in the notes below.</source>
          <target state="translated">無効なエントリに使用する値（デフォルトではなし）。Noneの場合、この引数は、渡された&lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;から推測されます。それがない場合は、以下の注で説明するように、元の配列から推測されます。</target>
        </trans-unit>
        <trans-unit id="a8455fb8033504388eae171a33ad0ef930322f1e" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, then this argument is inferred from the passed &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, or in its absence the original array, as discussed in the notes below.</source>
          <target state="translated">無効なエントリに使用する値（デフォルトではなし）。Noneの場合、この引数は、渡された&lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;から推測されます。それがない場合は、以下の注で説明するように、元の配列から推測されます。</target>
        </trans-unit>
        <trans-unit id="2e873302c473555951f6bce102181f00086c301d" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries. Can be scalar or non-scalar. If non-scalar, the resulting ndarray must be broadcastable over input array. Default is None, in which case, the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; attribute of the array is used instead.</source>
          <target state="translated">無効なエントリに使用する値。スカラーまたは非スカラーにすることができます。非スカラーの場合、結果のndarrayは入力配列を介してブロードキャスト可能である必要があります。デフォルトはNoneです。この場合、代わりに配列の&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;属性が使用されます。</target>
        </trans-unit>
        <trans-unit id="1880e242040c0aab4362eb1a0863297a32bd5f4b" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries. Can be scalar or non-scalar. If non-scalar, the resulting ndarray must be broadcastable over input array. Default is None, in which case, the &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; attribute of the array is used instead.</source>
          <target state="translated">無効なエントリに使用する値。スカラーまたは非スカラーにすることができます。非スカラーの場合、結果のndarrayは入力配列を介してブロードキャスト可能である必要があります。デフォルトはNoneです。この場合、代わりに配列の&lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;属性が使用されます。</target>
        </trans-unit>
        <trans-unit id="11b1837d34a4ca9f6b2279399c10c60d4b55936a" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries. Default is None.</source>
          <target state="translated">無効なエントリに使用する値。デフォルトは None です。</target>
        </trans-unit>
        <trans-unit id="54be798891264cab731a931b04ea9772cdab541c" translate="yes" xml:space="preserve">
          <source>The value to use for the &lt;a href=&quot;numpy.ufunc.identity#numpy.ufunc.identity&quot;&gt;&lt;code&gt;identity&lt;/code&gt;&lt;/a&gt; attribute of the resulting object. If specified, this is equivalent to setting the underlying C &lt;code&gt;identity&lt;/code&gt; field to &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt;. If omitted, the identity is set to &lt;code&gt;PyUFunc_None&lt;/code&gt;. Note that this is _not_ equivalent to setting the identity to &lt;code&gt;None&lt;/code&gt;, which implies the operation is reorderable.</source>
          <target state="translated">結果のオブジェクトの&lt;a href=&quot;numpy.ufunc.identity#numpy.ufunc.identity&quot;&gt; &lt;code&gt;identity&lt;/code&gt; &lt;/a&gt;属性に使用する値。指定された場合、これは、基礎となるCの設定と同等です &lt;code&gt;identity&lt;/code&gt; にフィールドを &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt; 。省略した場合、IDは &lt;code&gt;PyUFunc_None&lt;/code&gt; に設定されます。これは、IDを &lt;code&gt;None&lt;/code&gt; に設定することと同等ではないことに注意してください。これは、操作が並べ替え可能であることを意味します。</target>
        </trans-unit>
        <trans-unit id="adfb1baad553fefd1bd16dad3fa307f22463d54c" translate="yes" xml:space="preserve">
          <source>The value where the peak of the distribution occurs. The value must fulfill the condition &lt;code&gt;left &amp;lt;= mode &amp;lt;= right&lt;/code&gt;.</source>
          <target state="translated">分布のピークが発生する値。値は、条件 &lt;code&gt;left &amp;lt;= mode &amp;lt;= right&lt;/code&gt; 満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="686c0ef41d4f40d919659043042cba31d0a83ddd" translate="yes" xml:space="preserve">
          <source>The value whose minimal data type is to be found.</source>
          <target state="translated">データ型が最小となる値。</target>
        </trans-unit>
        <trans-unit id="ec08073e01c06623c4f6388732ecfb40030e861d" translate="yes" xml:space="preserve">
          <source>The value with which to start the reduction. If the ufunc has no identity or the dtype is object, this defaults to None - otherwise it defaults to ufunc.identity. If &lt;code&gt;None&lt;/code&gt; is given, the first element of the reduction is used, and an error is thrown if the reduction is empty.</source>
          <target state="translated">削減を開始する値。ufuncにIDがない場合、またはdtypeがオブジェクトの場合、これはデフォルトでNoneになります。それ以外の場合は、デフォルトでufunc.identityになります。 &lt;code&gt;None&lt;/code&gt; が指定された場合、削減の最初の要素が使用され、削減が空の場合はエラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="930e3ad8c3851bb30a80a559ca4a2af60560b1ff" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;ar1[in1d]&lt;/code&gt; are in &lt;code&gt;ar2&lt;/code&gt;.</source>
          <target state="translated">値 &lt;code&gt;ar1[in1d]&lt;/code&gt; は &lt;code&gt;ar2&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="a4cb91abe1a0f589bcf1ee9ebaba06339dc294dc" translate="yes" xml:space="preserve">
          <source>The values against which to test each value of &lt;code&gt;ar1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ar1&lt;/code&gt; の各値をテストする値。</target>
        </trans-unit>
        <trans-unit id="55096101173292ac6a418aa55429cc3cfcc3d718" translate="yes" xml:space="preserve">
          <source>The values against which to test each value of &lt;code&gt;element&lt;/code&gt;. This argument is flattened if it is an array or array_like. See notes for behavior with non-array-like parameters.</source>
          <target state="translated">&lt;code&gt;element&lt;/code&gt; の各値をテストする値。この引数は、配列またはarray_likeの場合、フラット化されます。配列のようなパラメータ以外の動作については、注意を参照してください。</target>
        </trans-unit>
        <trans-unit id="10fa1bca5c63978c522a37d289203eb7633c9fb5" translate="yes" xml:space="preserve">
          <source>The values in the rank-1 array &lt;code&gt;p&lt;/code&gt; are coefficients of a polynomial. If the length of &lt;code&gt;p&lt;/code&gt; is n+1 then the polynomial is described by:</source>
          <target state="translated">ランク1の配列 &lt;code&gt;p&lt;/code&gt; の値は、多項式の係数です。 &lt;code&gt;p&lt;/code&gt; の長さがn + 1の場合、多項式は次のように記述されます。</target>
        </trans-unit>
        <trans-unit id="427b2ca25633b731d69a885f7ebcb443f1d11f04" translate="yes" xml:space="preserve">
          <source>The values in the result follow so-called &amp;ldquo;standard&amp;rdquo; order: If &lt;code&gt;A =
fft(a, n)&lt;/code&gt;, then &lt;code&gt;A[0]&lt;/code&gt; contains the zero-frequency term (the sum of the signal), which is always purely real for real inputs. Then &lt;code&gt;A[1:n/2]&lt;/code&gt; contains the positive-frequency terms, and &lt;code&gt;A[n/2+1:]&lt;/code&gt; contains the negative-frequency terms, in order of decreasingly negative frequency. For an even number of input points, &lt;code&gt;A[n/2]&lt;/code&gt; represents both positive and negative Nyquist frequency, and is also purely real for real input. For an odd number of input points, &lt;code&gt;A[(n-1)/2]&lt;/code&gt; contains the largest positive frequency, while &lt;code&gt;A[(n+1)/2]&lt;/code&gt; contains the largest negative frequency. The routine &lt;code&gt;np.fft.fftfreq(n)&lt;/code&gt; returns an array giving the frequencies of corresponding elements in the output. The routine &lt;code&gt;np.fft.fftshift(A)&lt;/code&gt; shifts transforms and their frequencies to put the zero-frequency components in the middle, and &lt;code&gt;np.fft.ifftshift(A)&lt;/code&gt; undoes that shift.</source>
          <target state="translated">結果の値は、いわゆる「標準」の順序に従います &lt;code&gt;A = fft(a, n)&lt;/code&gt; 場合、 &lt;code&gt;A[0]&lt;/code&gt; は、ゼロ周波数の項（信号の合計）が含まれます。入力。次に、 &lt;code&gt;A[1:n/2]&lt;/code&gt; には正の周波数の項が含まれ、 &lt;code&gt;A[n/2+1:]&lt;/code&gt; には負の周波数の項が含まれ、負の周波数の順に減少します。偶数の入力ポイントの場合、 &lt;code&gt;A[n/2]&lt;/code&gt; は正と負の両方のナイキスト周波数を表し、実際の入力では純粋に実数になります。奇数の入力ポイントの場合、 &lt;code&gt;A[(n-1)/2]&lt;/code&gt; は最大の正の周波数を含み、 &lt;code&gt;A[(n+1)/2]&lt;/code&gt; は最大の負の周波数を含みます。ルーチン &lt;code&gt;np.fft.fftfreq(n)&lt;/code&gt; は、出力内の対応する要素の頻度を示す配列を返します。ルーチン &lt;code&gt;np.fft.fftshift(A)&lt;/code&gt; は変換とその周波数をシフトしてゼロ周波数成分を中央に &lt;code&gt;np.fft.ifftshift(A)&lt;/code&gt; 、np.fft.ifftshift（A）はそのシフトを元に戻します。</target>
        </trans-unit>
        <trans-unit id="049629d5662346c69d1da68173623b07fbd3ce2f" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;R&lt;/code&gt; are between -1 and 1, inclusive.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; の値は-1から1の間です。</target>
        </trans-unit>
        <trans-unit id="9be1b3aaf13595cf59a1cfa63bbe9d63fd300725" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;x1&lt;/code&gt; with the sign of &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x2&lt;/code&gt; の符号付きの &lt;code&gt;x1&lt;/code&gt; の値。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="0b6f0a3f189dc33bd74c3b4b3649d7d6ee49f75c" translate="yes" xml:space="preserve">
          <source>The values of the histogram. See &lt;code&gt;density&lt;/code&gt; and &lt;code&gt;weights&lt;/code&gt; for a description of the possible semantics.</source>
          <target state="translated">ヒストグラムの値。可能なセマンティクスの説明については、 &lt;code&gt;density&lt;/code&gt; と &lt;code&gt;weights&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="94c9275f5f339f7a7296146a88f4dacc4958d420" translate="yes" xml:space="preserve">
          <source>The values of the multidimension polynomial on points formed with triples of corresponding values from &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、 &lt;code&gt;z&lt;/code&gt; からの対応する値のトリプルで形成された点の多次元多項式の値。</target>
        </trans-unit>
        <trans-unit id="000e1e6aea9b8f07ac10536f42598c0ea9bb0313" translate="yes" xml:space="preserve">
          <source>The values of the multidimensional polynomial on points formed with triples of corresponding values from &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、 &lt;code&gt;z&lt;/code&gt; からの対応する値のトリプルで形成された点の多次元多項式の値。</target>
        </trans-unit>
        <trans-unit id="04875120c52fa413c52d82fe0fc8626bcc9f10c7" translate="yes" xml:space="preserve">
          <source>The values of the time series of cash flows. The (fixed) time interval between cash flow &amp;ldquo;events&amp;rdquo; must be the same as that for which &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; is given (i.e., if &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; is per year, then precisely a year is understood to elapse between each cash flow event). By convention, investments or &amp;ldquo;deposits&amp;rdquo; are negative, income or &amp;ldquo;withdrawals&amp;rdquo; are positive; &lt;code&gt;values&lt;/code&gt; must begin with the initial investment, thus &lt;code&gt;values[0]&lt;/code&gt; will typically be negative.</source>
          <target state="translated">キャッシュフローの時系列の値。キャッシュフローの「イベント」間の（固定）時間間隔は、&lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt;が指定されている時間間隔と同じでなければなりません（つまり、&lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt;が1年あたりの場合、各キャッシュフローイベント間で正確に1年が経過すると理解されます）。慣例により、投資または「預金」はマイナスであり、収入または「引き出し」はプラスです。 &lt;code&gt;values&lt;/code&gt; は初期投資で始まる必要があるため、 &lt;code&gt;values[0]&lt;/code&gt; は通常負になります。</target>
        </trans-unit>
        <trans-unit id="1a3aeed326405c6ff97973ff76e3c1ac5b78c950" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Chebyshev series at points formed from pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; からの対応する値のペアから形成された点での2次元チェビシェフシリーズの値。</target>
        </trans-unit>
        <trans-unit id="d500e0f26328b27b56cc6ea280ce335971a39a93" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Chebyshev series at points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; のデカルト積の点における2次元のチェビシェフシリーズの値。</target>
        </trans-unit>
        <trans-unit id="118ceee048eeb019cc7036790e58ad86a6694410" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Legendre series at points formed from pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; からの対応する値のペアから形成された点での2次元ルジャンドル系列の値。</target>
        </trans-unit>
        <trans-unit id="75bce5c26e8d20f2a28b76fe4bee99ba20e34131" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional polynomial at points formed with pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; からの対応する値のペアで形成された点の2次元多項式の値。</target>
        </trans-unit>
        <trans-unit id="fb47214ec0ab61ed4f83b6664e41c0aa8a83d3ed" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional polynomial at points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; のデカルト積の点における2次元多項式の値。</target>
        </trans-unit>
        <trans-unit id="7d3e958b62535b85e2d7d32e34bc42123eb7d409" translate="yes" xml:space="preserve">
          <source>The values reported are normalized relative to the speed of MT19937 in each table. A value of 100 indicates that the performance matches the MT19937. Higher values indicate improved performance. These values cannot be compared across tables.</source>
          <target state="translated">報告された値は、各テーブルのMT19937の速度と比較して正規化されています。100の値は、性能がMT19937と一致していることを示しています。値が大きいほど性能が向上していることを示しています。これらの値は、テーブル間で比較することはできません。</target>
        </trans-unit>
        <trans-unit id="d8a3da63b70322018b836bf5f65f57d16d3ac651" translate="yes" xml:space="preserve">
          <source>The values whose cube-roots are required.</source>
          <target state="translated">立方根が必要とされる値。</target>
        </trans-unit>
        <trans-unit id="b42bae2bd42a8c9e82a7332d1979f8a09c759feb" translate="yes" xml:space="preserve">
          <source>The values whose square-roots are required.</source>
          <target state="translated">平方根が必要な値。</target>
        </trans-unit>
        <trans-unit id="187833930bd2cba800be6e8dd52776f374cc2f1c" translate="yes" xml:space="preserve">
          <source>The variable obtained by summing the squares of &lt;code&gt;df&lt;/code&gt; independent, standard normally distributed random variables:</source>
          <target state="translated">&lt;code&gt;df&lt;/code&gt; 独立した標準正規分布確率変数の2乗を合計して得られる変数：</target>
        </trans-unit>
        <trans-unit id="fddb7e65a48e5500c69e424836450e7732656827" translate="yes" xml:space="preserve">
          <source>The variable used in the string representation of &lt;code&gt;p&lt;/code&gt; can be modified, using the &lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt;&lt;code&gt;variable&lt;/code&gt;&lt;/a&gt; parameter:</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; の文字列表現で使用される&lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt; &lt;code&gt;variable&lt;/code&gt; &lt;/a&gt;は、variableパラメーターを使用して変更できます。</target>
        </trans-unit>
        <trans-unit id="032af5a223b6a82b2905b5c850f693e8fec137cd" translate="yes" xml:space="preserve">
          <source>The variance is the average of the squared deviations from the mean, i.e., &lt;code&gt;var = mean(abs(x - x.mean())**2)&lt;/code&gt;.</source>
          <target state="translated">分散は、平均からの偏差の二乗の平均です。つまり、 &lt;code&gt;var = mean(abs(x - x.mean())**2)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="598bba43a5fa13ecb982a04e1ac2dcfa3fb5a79a" translate="yes" xml:space="preserve">
          <source>The various character codes indicating certain types are also part of an enumerated list. References to type characters (should they be needed at all) should always use these enumerations. The form of them is &lt;code&gt;NPY_{NAME}LTR&lt;/code&gt; where &lt;code&gt;{NAME}&lt;/code&gt; can be</source>
          <target state="translated">特定のタイプを示すさまざまな文字コードも、列挙リストの一部です。タイプ文字への参照（必要な場合）は、常にこれらの列挙を使用する必要があります。それらの形式は &lt;code&gt;NPY_{NAME}LTR&lt;/code&gt; で、 &lt;code&gt;{NAME}&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="d2bf21ee585f4c470168bc467b8b8760de8826fd" translate="yes" xml:space="preserve">
          <source>The various routines in the Polynomial package all deal with series whose coefficients go from degree zero upward, which is the &lt;em&gt;reverse order&lt;/em&gt; of the Poly1d convention. The easy way to remember this is that indexes correspond to degree, i.e., coef[i] is the coefficient of the term of degree i.</source>
          <target state="translated">多項式パッケージのさまざまなルーチンの係数である、上方度ゼロから行くシリーズのすべての契約&lt;em&gt;逆順&lt;/em&gt; Poly1d大会の。これを覚える簡単な方法は、インデックスが次数に対応することです。つまり、coef [i]は次数iの項の係数です。</target>
        </trans-unit>
        <trans-unit id="40dcb2f33f2d122b10f89906b0fa578dee7f50c3" translate="yes" xml:space="preserve">
          <source>The various selection algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The available algorithms have the following properties:</source>
          <target state="translated">様々なソートアルゴリズムは、平均速度、最悪の場合の性能、作業スペースの大きさ、安定しているかどうかによって特徴づけられています。安定したソートは、同じキーを持つアイテムを同じ相対順序で保持します。利用可能なアルゴリズムは以下のような特性を持っています。</target>
        </trans-unit>
        <trans-unit id="cc8322a9b3a11e0738c1dc848dd44452ebdc9f34" translate="yes" xml:space="preserve">
          <source>The various sorting algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The four algorithms implemented in NumPy have the following properties:</source>
          <target state="translated">様々なソートアルゴリズムは、平均速度、最悪の場合の性能、作業スペースの大きさ、安定しているかどうかによって特徴づけられています。安定したソートとは、同じキーを持つアイテムを同じ相対順序で並べ替えることです。NumPyで実装されている4つのアルゴリズムは、以下のような特性を持っています。</target>
        </trans-unit>
        <trans-unit id="909b1eaadbbd85f2064b83f98f4324e7aba0802c" translate="yes" xml:space="preserve">
          <source>The vdot(&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;) function handles complex numbers differently than dot(&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;). If the first argument is complex the complex conjugate of the first argument is used for the calculation of the dot product.</source>
          <target state="translated">vdot（ &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; ）関数は、dot（ &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; ）とは異なる方法で複素数を処理します。最初の引数が複素数の場合、最初の引数の複素共役が内積の計算に使用されます。</target>
        </trans-unit>
        <trans-unit id="f8aeebbf639e209f314766460959c079ab13f5dd" translate="yes" xml:space="preserve">
          <source>The version 1.0 format only allowed the array header to have a total size of 65535 bytes. This can be exceeded by structured arrays with a large number of columns. The version 2.0 format extends the header size to 4 GiB. &lt;a href=&quot;numpy.save#numpy.save&quot;&gt;&lt;code&gt;numpy.save&lt;/code&gt;&lt;/a&gt; will automatically save in 2.0 format if the data requires it, else it will always use the more compatible 1.0 format.</source>
          <target state="translated">バージョン1.0形式では、配列ヘッダーの合計サイズは65535バイトのみでした。これは、列の数が多い構造化配列では超過する可能性があります。バージョン2.0形式では、ヘッダーサイズが4 GiBに拡張されています。&lt;a href=&quot;numpy.save#numpy.save&quot;&gt; &lt;code&gt;numpy.save&lt;/code&gt; &lt;/a&gt;は、データに必要な場合は自動的に2.0形式で保存します。それ以外の場合は、常により互換性のある1.0形式を使用します。</target>
        </trans-unit>
        <trans-unit id="7a92769f6aa86193f32ae6d12aa9581114703198" translate="yes" xml:space="preserve">
          <source>The version 2 interface was very similar. The differences were largely aesthetic. In particular:</source>
          <target state="translated">バージョン2のインターフェイスは非常に似ていました。違いは主に審美的なものでした。特に</target>
        </trans-unit>
        <trans-unit id="73bb55ce329b913976b213535f9642d82795177e" translate="yes" xml:space="preserve">
          <source>The version numbering of these formats is independent of NumPy version numbering. If the format is upgraded, the code in &lt;code&gt;numpy.io&lt;/code&gt; will still be able to read and write Version 1.0 files.</source>
          <target state="translated">これらのフォーマットのバージョン番号は、NumPyのバージョン番号とは無関係です。フォーマットがアップグレードされた場合でも、 &lt;code&gt;numpy.io&lt;/code&gt; のコードはバージョン1.0ファイルを読み書きできます。</target>
        </trans-unit>
        <trans-unit id="d465b2400649c410304e54f051f7d49aa970de97" translate="yes" xml:space="preserve">
          <source>The von Mises distribution (also known as the circular normal distribution) is a continuous probability distribution on the unit circle. It may be thought of as the circular analogue of the normal distribution.</source>
          <target state="translated">フォン・ミーゼス分布(円正規分布としても知られている)は,単位円上の連続確率分布である.正規分布の円のアナログと考えられています。</target>
        </trans-unit>
        <trans-unit id="08a316a93b85a841b11a6055717875d0502f2c60" translate="yes" xml:space="preserve">
          <source>The von Mises is named for Richard Edler von Mises, who was born in Austria-Hungary, in what is now the Ukraine. He fled to the United States in 1939 and became a professor at Harvard. He worked in probability theory, aerodynamics, fluid mechanics, and philosophy of science.</source>
          <target state="translated">フォン・ミーゼスは、オーストリア・ハンガリー、現在のウクライナに生まれたリチャード・エドラー・フォン・ミーゼスにちなんで命名された。1939年にアメリカに亡命し、ハーバード大学の教授となった。確率論、空気力学、流体力学、科学哲学などを研究した。</target>
        </trans-unit>
        <trans-unit id="c66491ff606b4dc91911613d519dc8370dc0d225" translate="yes" xml:space="preserve">
          <source>The warnings can be turned off by</source>
          <target state="translated">警告は</target>
        </trans-unit>
        <trans-unit id="a3b6182c6d54b721f88f41929f57467a3fff8892" translate="yes" xml:space="preserve">
          <source>The weight function at &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; での重み関数。</target>
        </trans-unit>
        <trans-unit id="88ba21dce5f8f071e2673c0f1f06439caa2807d7" translate="yes" xml:space="preserve">
          <source>The weight function is</source>
          <target state="translated">重量関数は</target>
        </trans-unit>
        <trans-unit id="308836c1d8a38528ab14ca4524532677c1153f22" translate="yes" xml:space="preserve">
          <source>The weight function of the Chebyshev polynomials.</source>
          <target state="translated">チェビシェフ多項式の重み関数。</target>
        </trans-unit>
        <trans-unit id="adb5d593e92bd3e7a619595dc278c8d8865de5f1" translate="yes" xml:space="preserve">
          <source>The wheels and source should be uploaded to PyPI.</source>
          <target state="translated">ホイールとソースはPyPIにアップロードしておきます。</target>
        </trans-unit>
        <trans-unit id="8a75026ea8d79cfa948ad8144c46e90db33a682b" translate="yes" xml:space="preserve">
          <source>The wheels, once built, appear at &lt;a href=&quot;https://anaconda.org/multibuild-wheels-staging/numpy&quot;&gt;https://anaconda.org/multibuild-wheels-staging/numpy&lt;/a&gt;</source>
          <target state="translated">ホイールが構築されると、&lt;a href=&quot;https://anaconda.org/multibuild-wheels-staging/numpy&quot;&gt;https：//anaconda.org/multibuild-wheels-staging/numpy&lt;/a&gt;に表示されます</target>
        </trans-unit>
        <trans-unit id="9b231b3ccfadec2079a40387b8d56e7ec8b9bb3d" translate="yes" xml:space="preserve">
          <source>The window of the converted series. If the value is None, the default window of &lt;code&gt;kind&lt;/code&gt; is used.</source>
          <target state="translated">変換されたシリーズのウィンドウ。値がNoneの場合、デフォルトの &lt;code&gt;kind&lt;/code&gt; ウィンドウが使用されます。</target>
        </trans-unit>
        <trans-unit id="1da2fe6ad3abf125b431351fbdd12b7a74edc3f3" translate="yes" xml:space="preserve">
          <source>The window, with the maximum value normalized to one (the value one appears only if &lt;code&gt;M&lt;/code&gt; is odd).</source>
          <target state="translated">最大値を1に正規化したウィンドウ（値1 は &lt;code&gt;M&lt;/code&gt; が奇数の場合にのみ表示されます）。</target>
        </trans-unit>
        <trans-unit id="48ac736d93f8e7e8643c8e0f7b0c321855533edd" translate="yes" xml:space="preserve">
          <source>The window, with the maximum value normalized to one (the value one appears only if the number of samples is odd).</source>
          <target state="translated">最大値を1に正規化したウィンドウ(サンプル数が奇数の場合のみ値1が表示されます)。</target>
        </trans-unit>
        <trans-unit id="523eb308fcdc8d9a4d1dacdeabc03bc7b0a18f42" translate="yes" xml:space="preserve">
          <source>The word &amp;ldquo;non-zero&amp;rdquo; is in reference to the Python 2.x built-in method &lt;code&gt;__nonzero__()&lt;/code&gt; (renamed &lt;code&gt;__bool__()&lt;/code&gt; in Python 3.x) of Python objects that tests an object&amp;rsquo;s &amp;ldquo;truthfulness&amp;rdquo;. For example, any number is considered truthful if it is nonzero, whereas any string is considered truthful if it is not the empty string. Thus, this function (recursively) counts how many elements in &lt;code&gt;a&lt;/code&gt; (and in sub-arrays thereof) have their &lt;code&gt;__nonzero__()&lt;/code&gt; or &lt;code&gt;__bool__()&lt;/code&gt; method evaluated to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">「非ゼロ」という言葉は、オブジェクトの「真実性」をテストするPythonオブジェクトのPython 2.x組み込みメソッド &lt;code&gt;__nonzero__()&lt;/code&gt; （Python 3.xでは &lt;code&gt;__bool__()&lt;/code&gt; に名前が変更された）を参照しています。たとえば、ゼロ以外の数値は真であると見なされ、空の文字列ではない文字列は真であると見なされます。したがって、この関数は（再帰的に） &lt;code&gt;a&lt;/code&gt; （およびそのサブ配列）内の &lt;code&gt;__nonzero__()&lt;/code&gt; または &lt;code&gt;__bool__()&lt;/code&gt; メソッドが &lt;code&gt;True&lt;/code&gt; に評価された要素の数をカウントします。</target>
        </trans-unit>
        <trans-unit id="a3f383c240aa5414ebaced6e3034416ca7d1b6af" translate="yes" xml:space="preserve">
          <source>The wrap option affects only tall matrices:</source>
          <target state="translated">wrap オプシ ョ ンは、 背の高い行列にのみ影響を与えます。</target>
        </trans-unit>
        <trans-unit id="fc81c936c38ae025ba8146e1222f7da14b956b1d" translate="yes" xml:space="preserve">
          <source>The x-coordinate sequence is expected to be increasing, but this is not explicitly enforced. However, if the sequence &lt;code&gt;xp&lt;/code&gt; is non-increasing, interpolation results are meaningless.</source>
          <target state="translated">x座標シーケンスは増加すると予想されますが、これは明示的に強制されていません。ただし、シーケンス &lt;code&gt;xp&lt;/code&gt; が増加していない場合、補間結果は無意味です。</target>
        </trans-unit>
        <trans-unit id="f30f1b95441858e7d3037adb27c5185133726d2e" translate="yes" xml:space="preserve">
          <source>The x-coordinates at which to evaluate the interpolated values.</source>
          <target state="translated">補間された値を評価するx座標。</target>
        </trans-unit>
        <trans-unit id="98e412a8d1f1dc441497184c5505f308bf594274" translate="yes" xml:space="preserve">
          <source>The x-coordinates of the data points, must be increasing if argument &lt;code&gt;period&lt;/code&gt; is not specified. Otherwise, &lt;code&gt;xp&lt;/code&gt; is internally sorted after normalizing the periodic boundaries with &lt;code&gt;xp = xp % period&lt;/code&gt;.</source>
          <target state="translated">引数の &lt;code&gt;period&lt;/code&gt; が指定されていない場合、データポイントのx座標は増加している必要があります。それ以外の場合、 &lt;code&gt;xp&lt;/code&gt; &lt;code&gt;xp = xp % period&lt;/code&gt; 周期境界を正規化した後、xpは内部的にソートされます。</target>
        </trans-unit>
        <trans-unit id="5fb42b6312c1e1cea4c01b6bb567b8d84d30c4b2" translate="yes" xml:space="preserve">
          <source>The y-coordinates of the data points, same length as &lt;code&gt;xp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;xp&lt;/code&gt; と同じ長さのデータポイントのy座標。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
