<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="58f4a5191b04c275b13b1266e03ae0e69f92c2c1" translate="yes" xml:space="preserve">
          <source>Structured type, two fields: the first field contains an unsigned int, the second an int32:</source>
          <target state="translated">構造化型で、2 つのフィールド:最初のフィールドには unsigned int、2 番目のフィールドには int32 が含まれます。</target>
        </trans-unit>
        <trans-unit id="ca4456203ca66897ff0941bbafc31276906d7671" translate="yes" xml:space="preserve">
          <source>Structured view(s) of &lt;a href=&quot;numpy.nditer.operands#numpy.nditer.operands&quot;&gt;&lt;code&gt;operands&lt;/code&gt;&lt;/a&gt; in memory, matching the reordered and optimized iterator access pattern. Valid only before the iterator is closed.</source>
          <target state="translated">メモリ内の&lt;a href=&quot;numpy.nditer.operands#numpy.nditer.operands&quot;&gt; &lt;code&gt;operands&lt;/code&gt; &lt;/a&gt;の構造化ビュー。並べ替えられて最適化されたイテレータアクセスパターンと一致します。イテレータが閉じられる前にのみ有効です。</target>
        </trans-unit>
        <trans-unit id="64b82b877494406e2f3a32e02b06a27f71eea3a4" translate="yes" xml:space="preserve">
          <source>Style Guide for C Code</source>
          <target state="translated">Cコードのスタイルガイド</target>
        </trans-unit>
        <trans-unit id="01d5cb7a8cd071c4380d4985485547b9c9160ad6" translate="yes" xml:space="preserve">
          <source>Style Guide for Python Code</source>
          <target state="translated">Pythonコードのスタイルガイド</target>
        </trans-unit>
        <trans-unit id="0404cfe2117190faccc065f3c4e76c4322b57e18" translate="yes" xml:space="preserve">
          <source>Stylistic Guidelines</source>
          <target state="translated">スタイリスティックガイドライン</target>
        </trans-unit>
        <trans-unit id="803fd087e54001bfefdde2c389864825258535d4" translate="yes" xml:space="preserve">
          <source>Sub-arrays always have a C-contiguous memory layout.</source>
          <target state="translated">サブアレイは常にC-連続メモリレイアウトを持っています。</target>
        </trans-unit>
        <trans-unit id="b5f988ec613aba03f62b8fb5c8cfc27a7a1a6d0f" translate="yes" xml:space="preserve">
          <source>Sub-optimal &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; (due to repeated path calculation time): ~330ms</source>
          <target state="translated">準最適な&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;（繰り返されるパス計算時間のため）：〜330ms</target>
        </trans-unit>
        <trans-unit id="fa0a23c0a00071a5375730590cb136590b810c95" translate="yes" xml:space="preserve">
          <source>Subclasses of &lt;code&gt;ndarray&lt;/code&gt; are preserved except for the &amp;lsquo;raw&amp;rsquo; mode. So if &lt;code&gt;a&lt;/code&gt; is of type &lt;code&gt;matrix&lt;/code&gt;, all the return values will be matrices too.</source>
          <target state="translated">「raw」モードを除いて、 &lt;code&gt;ndarray&lt;/code&gt; のサブクラスは保持されます。したがって、 &lt;code&gt;a&lt;/code&gt; が &lt;code&gt;matrix&lt;/code&gt; 型の場合、すべての戻り値も行列になります。</target>
        </trans-unit>
        <trans-unit id="a9ce918753c36dd7a183b105790cb0ccc1e3d737" translate="yes" xml:space="preserve">
          <source>Subclassing a &lt;code&gt;numpy.ndarray&lt;/code&gt; is possible but if your goal is to create an array with &lt;em&gt;modified&lt;/em&gt; behavior, as do dask arrays for distributed computation and cupy arrays for GPU-based computation, subclassing is discouraged. Instead, using numpy&amp;rsquo;s &lt;a href=&quot;../user/basics.dispatch#basics-dispatch&quot;&gt;dispatch mechanism&lt;/a&gt; is recommended.</source>
          <target state="translated">&lt;code&gt;numpy.ndarray&lt;/code&gt; のサブクラス化は可能ですが、分散計算用のdask配列やGPUベースの計算用のcupy配列の&lt;em&gt;ように、&lt;/em&gt;動作が&lt;em&gt;変更され&lt;/em&gt;た配列を作成することが目標である場合、サブクラス化はお勧めしません。代わりに、numpyの&lt;a href=&quot;../user/basics.dispatch#basics-dispatch&quot;&gt;ディスパッチメカニズム&lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="9d147ab8047bc6066411af552791a9504b59a189" translate="yes" xml:space="preserve">
          <source>Subclassing a &lt;code&gt;numpy.ndarray&lt;/code&gt; is possible but if your goal is to create an array with &lt;em&gt;modified&lt;/em&gt; behavior, as do dask arrays for distributed computation and cupy arrays for GPU-based computation, subclassing is discouraged. Instead, using numpy&amp;rsquo;s &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.dispatch.html#basics-dispatch&quot;&gt;dispatch mechanism&lt;/a&gt; is recommended.</source>
          <target state="translated">&lt;code&gt;numpy.ndarray&lt;/code&gt; のサブクラス化は可能ですが、分散計算用のdask配列やGPUベースの計算用のcupy配列の&lt;em&gt;ように、&lt;/em&gt;動作が&lt;em&gt;変更され&lt;/em&gt;た配列を作成することが目的の場合、サブクラス化は推奨されません。代わりに、numpyの&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.dispatch.html#basics-dispatch&quot;&gt;ディスパッチメカニズム&lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="272f065bb249898427d153b9ddec706f4a4c8ea8" translate="yes" xml:space="preserve">
          <source>Subclassing and Downstream Compatibility</source>
          <target state="translated">サブクラス化とダウンストリームの互換性</target>
        </trans-unit>
        <trans-unit id="33bc88cf96b41fa0646c461894f505af99f67ac1" translate="yes" xml:space="preserve">
          <source>Subclassing is preserved. This means that if, e.g., the data part of the masked array is a recarray, &lt;a href=&quot;numpy.ma.filled#numpy.ma.filled&quot;&gt;&lt;code&gt;filled&lt;/code&gt;&lt;/a&gt; returns a recarray:</source>
          <target state="translated">サブクラス化は保持されます。これは、たとえば、マスクされた配列のデータ部分がrecarrayである場合、&lt;a href=&quot;numpy.ma.filled#numpy.ma.filled&quot;&gt; &lt;code&gt;filled&lt;/code&gt; &lt;/a&gt;はrecarrayを返すことを意味します。</target>
        </trans-unit>
        <trans-unit id="dcd026d87f16ab5d865099378d38748e1049d4d8" translate="yes" xml:space="preserve">
          <source>Subclassing ndarray</source>
          <target state="translated">ndarrayのサブクラス</target>
        </trans-unit>
        <trans-unit id="b7c286e3d93f3ece394b3827e135e8a12233cdf1" translate="yes" xml:space="preserve">
          <source>Subclassing ndarray is complicated by the fact that new instances of ndarray classes can come about in three different ways. These are:</source>
          <target state="translated">ndarrayのサブクラス化は、ndarrayクラスの新しいインスタンスが3つの異なる方法で発生するという事実によって複雑になっています。これらは次の3つの方法です。</target>
        </trans-unit>
        <trans-unit id="9a44ddbc8fd0076edc9e53d1235eba11c7929dc0" translate="yes" xml:space="preserve">
          <source>Subclassing ndarray is relatively simple, but it has some complications compared to other Python objects. On this page we explain the machinery that allows you to subclass ndarray, and the implications for implementing a subclass.</source>
          <target state="translated">ndarrayのサブクラス化は比較的簡単ですが、他のPythonオブジェクトと比べるとややこしい部分があります。このページでは、ndarrayをサブクラス化するための仕組みと、サブクラスを実装する上での意味合いを説明します。</target>
        </trans-unit>
        <trans-unit id="63f32464b42a864e77739b2bee513b261ea02191" translate="yes" xml:space="preserve">
          <source>Subcommittees</source>
          <target state="translated">Subcommittees</target>
        </trans-unit>
        <trans-unit id="d9952117e8cb53d0fd7ca6ba7d99ad537965d8c9" translate="yes" xml:space="preserve">
          <source>Subdivide &lt;code&gt;int16&lt;/code&gt; into 2 &lt;code&gt;int8&lt;/code&gt;&amp;rsquo;s, called x and y. 0 and 1 are the offsets in bytes:</source>
          <target state="translated">&lt;code&gt;int16&lt;/code&gt; をxとyと呼ばれる2つの &lt;code&gt;int8&lt;/code&gt; に分割します。0と1はバイト単位のオフセットです。</target>
        </trans-unit>
        <trans-unit id="7cd760711c541e202c788fb098af0b33b391721e" translate="yes" xml:space="preserve">
          <source>Subsequence with trailing zeros removed. If the resulting sequence would be empty, return the first element. The returned sequence may or may not be a view.</source>
          <target state="translated">末尾のゼロを除去した部分シーケンス。結果のシーケンスが空の場合は、最初の要素を返します。返されるシーケンスは、ビューであってもビューでなくても構いません。</target>
        </trans-unit>
        <trans-unit id="c763109714f2536fc1c4a6c89fdf2646454177e1" translate="yes" xml:space="preserve">
          <source>Substantial portions of this document were adapted from the &lt;a href=&quot;https://github.com/jupyter/governance/blob/master/governance.md&quot;&gt;Jupyter/IPython project&amp;rsquo;s governance document&lt;/a&gt;.</source>
          <target state="translated">このドキュメントの大部分は、&lt;a href=&quot;https://github.com/jupyter/governance/blob/master/governance.md&quot;&gt;Jupyter / IPythonプロジェクトのガバナンスドキュメント&lt;/a&gt;から採用されました。</target>
        </trans-unit>
        <trans-unit id="259ff26648e77d2b9a5ec16a4f186ec8e1c65753" translate="yes" xml:space="preserve">
          <source>Substitute a polynomial for x and expand the result. Here we substitute p in itself leading to a new polynomial of degree 4 after expansion. If the polynomials are regarded as functions this is composition of functions:</source>
          <target state="translated">x に多項式を代入し、結果を展開します。ここでは、展開後に次数4の新しい多項式につながるpをそれ自体に代入します。多項式が関数とみなされる場合、これは関数の合成です。</target>
        </trans-unit>
        <trans-unit id="8d18e7a773fc8ec030ec151dbf7cd596c836697a" translate="yes" xml:space="preserve">
          <source>Substitution:</source>
          <target state="translated">Substitution:</target>
        </trans-unit>
        <trans-unit id="976370d3324e5eaaec19ed99a261ec090486b0fa" translate="yes" xml:space="preserve">
          <source>Subtract arguments, element-wise.</source>
          <target state="translated">要素ごとに引数を減算します。</target>
        </trans-unit>
        <trans-unit id="8567fbb4d729f4cd5b7fbe5674c01c465635fa47" translate="yes" xml:space="preserve">
          <source>Subtract one Chebyshev series from another.</source>
          <target state="translated">チェビシェフ級数を別の級数から引き算します。</target>
        </trans-unit>
        <trans-unit id="a494f472ea255a2aaa4f1c8f52b90c62196690f5" translate="yes" xml:space="preserve">
          <source>Subtract one Hermite series from another.</source>
          <target state="translated">1つのハーミット系列から別のハーミット系列を引き算します。</target>
        </trans-unit>
        <trans-unit id="60b31c93b32c6d82ec367e99b58e2a7fd1690435" translate="yes" xml:space="preserve">
          <source>Subtract one Laguerre series from another.</source>
          <target state="translated">1つのラゲール級数から別のラゲール級数を引き算します。</target>
        </trans-unit>
        <trans-unit id="09477810015d786e3a1ce0d9827bfd9d00039de6" translate="yes" xml:space="preserve">
          <source>Subtract one Legendre series from another.</source>
          <target state="translated">レジェンドレシリーズを1つ減算します。</target>
        </trans-unit>
        <trans-unit id="a2407a57a6647eba13b915586134c7e1d7534217" translate="yes" xml:space="preserve">
          <source>Subtract one polynomial from another.</source>
          <target state="translated">1つの多項式を別の多項式から引き算します。</target>
        </trans-unit>
        <trans-unit id="5de67be97d964e12a293477e154e8fa146741938" translate="yes" xml:space="preserve">
          <source>Subtract other from self in-place.</source>
          <target state="translated">その場で自己から他を引き算します。</target>
        </trans-unit>
        <trans-unit id="b3957443ea74659d4523c7bc9e466d304ba155cf" translate="yes" xml:space="preserve">
          <source>Subtract other from self, and return a new masked array.</source>
          <target state="translated">selfからotherを引き、新しいマスクされた配列を返します。</target>
        </trans-unit>
        <trans-unit id="6cf676697a4c117ec3074a618da8a2b0fca9cd14" translate="yes" xml:space="preserve">
          <source>Subtract self from other, and return a new masked array.</source>
          <target state="translated">他の配列から自己を引き算し、新しいマスクされた配列を返します。</target>
        </trans-unit>
        <trans-unit id="77a74ccf7fd60ada9c57d2300edad576a2eb6285" translate="yes" xml:space="preserve">
          <source>Subtyping the ndarray in C</source>
          <target state="translated">C言語でのndarrayのサブタイプ</target>
        </trans-unit>
        <trans-unit id="d0b818b7784e48b243d98be89f763b62cb9fc7bd" translate="yes" xml:space="preserve">
          <source>Successfully tested on:</source>
          <target state="translated">テストに成功しました</target>
        </trans-unit>
        <trans-unit id="7f477dc5121884706ef8fed21e4d11c24e6db091" translate="yes" xml:space="preserve">
          <source>Sum across array propagating NaNs.</source>
          <target state="translated">アレイ伝搬するNaN全体の和。</target>
        </trans-unit>
        <trans-unit id="b2cc82eaee79a7562889de3502bb827b013693aa" translate="yes" xml:space="preserve">
          <source>Sum along diagonals.</source>
          <target state="translated">対角線に沿った和。</target>
        </trans-unit>
        <trans-unit id="b221abad8e52361732192c7acb9613f67b076ac3" translate="yes" xml:space="preserve">
          <source>Sum array elements.</source>
          <target state="translated">配列の要素を合計します。</target>
        </trans-unit>
        <trans-unit id="96c00e26cd369dd11b081a1035d4633225e7965d" translate="yes" xml:space="preserve">
          <source>Sum of array elements over a given axis.</source>
          <target state="translated">指定された軸上の配列要素の合計。</target>
        </trans-unit>
        <trans-unit id="6302a8aa98d30db8a3e7186cb73eb9e4337d618b" translate="yes" xml:space="preserve">
          <source>Sum over an axis (requires explicit form):</source>
          <target state="translated">軸上の和(明示的な形式が必要)。</target>
        </trans-unit>
        <trans-unit id="1c979daf2b6e4cef98bd537ad236de258dbc0d5a" translate="yes" xml:space="preserve">
          <source>Sum over axes 0 and 2. The result has same number of dimensions as the original array:</source>
          <target state="translated">軸 0 と軸 2 の和。結果は元の配列と同じ次元数になります。</target>
        </trans-unit>
        <trans-unit id="1103f1f7acbd2c5b9349bcbddbb45121fae537eb" translate="yes" xml:space="preserve">
          <source>Sum products over arbitrary axes.</source>
          <target state="translated">任意の軸上の積を合計します。</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="bf661fd6213ae079ce34c2c9dd00db526c359e2b" translate="yes" xml:space="preserve">
          <source>Sums of residuals; squared Euclidean 2-norm for each column in &lt;code&gt;b - a*x&lt;/code&gt;. If the rank of &lt;code&gt;a&lt;/code&gt; is &amp;lt; N or M &amp;lt;= N, this is an empty array. If &lt;code&gt;b&lt;/code&gt; is 1-dimensional, this is a (1,) shape array. Otherwise the shape is (K,).</source>
          <target state="translated">残差の合計; &lt;code&gt;b - a*x&lt;/code&gt; 各列の2乗ユークリッド2ノルム。ランク場合&amp;lt;N又はM &amp;lt;= Nであり、これは空の配列です。場合 &lt;code&gt;b&lt;/code&gt; 1次元であり、これは（1）形状のアレイです。それ以外の場合、形状は（K、）です。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6c71b95244ccde5ac8df906b9633b9278b04563" translate="yes" xml:space="preserve">
          <source>Sums, products, differences</source>
          <target state="translated">和・積・差</target>
        </trans-unit>
        <trans-unit id="56cedb0b6384ebe895f048d3113a97e19adce9ed" translate="yes" xml:space="preserve">
          <source>SunOS 5.9, Python 2.2, 2.3.2</source>
          <target state="translated">SunOS 5.9、Python 2.2、2.3.2</target>
        </trans-unit>
        <trans-unit id="67fd60fec12a23f41f4967a1b913d9c8325a3d58" translate="yes" xml:space="preserve">
          <source>Superposes arrays fields by fields</source>
          <target state="translated">配列のフィールドをフィールドごとに重ね合わせる</target>
        </trans-unit>
        <trans-unit id="a1f3a3e0dca6bfb201866f4e02f7f0f252f0503d" translate="yes" xml:space="preserve">
          <source>Supplying additional compiler flags</source>
          <target state="translated">追加のコンパイラフラグの提供</target>
        </trans-unit>
        <trans-unit id="bd465d5e53c115d109beacd89675429e7fe9e2eb" translate="yes" xml:space="preserve">
          <source>Support for 64-bit OpenBLAS</source>
          <target state="translated">64ビットのOpenBLASに対応</target>
        </trans-unit>
        <trans-unit id="05979ff1799bf4b31c7aaaf6575b3a44600e6938" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;decimal.Decimal&lt;/code&gt; in &lt;code&gt;np.lib.financial&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;decimal.Decimal&lt;/code&gt; での &lt;code&gt;np.lib.financial&lt;/code&gt; サポート</target>
        </trans-unit>
        <trans-unit id="94bf5963bbdc6b1a3677d96a194c63df08cc0ebe" translate="yes" xml:space="preserve">
          <source>Support for PGI flang compiler on Windows</source>
          <target state="translated">Windows での PGI flang コンパイラのサポート</target>
        </trans-unit>
        <trans-unit id="8dcbec54e843ff9113eeef63ba5ba94427429af2" translate="yes" xml:space="preserve">
          <source>Support for cross-platform builds for iOS</source>
          <target state="translated">iOS用のクロスプラットフォームビルドをサポート</target>
        </trans-unit>
        <trans-unit id="d4312602ded392453d6506535641b2fe8fc3f434" translate="yes" xml:space="preserve">
          <source>Support for linear algebra on stacked arrays</source>
          <target state="translated">スタックされた配列上での線形代数のサポート</target>
        </trans-unit>
        <trans-unit id="d1486bb007dde41a6cd27d40051180a9824cbf65" translate="yes" xml:space="preserve">
          <source>Support for median and percentile in nanfunctions</source>
          <target state="translated">ナノファンクションにおける中央値とパーセンタイルのサポート</target>
        </trans-unit>
        <trans-unit id="5732c875d678ed7bc376f8bdb01c865cd0e57b5f" translate="yes" xml:space="preserve">
          <source>Support for multiple insertions when &lt;code&gt;obj&lt;/code&gt; is a single scalar or a sequence with one element (similar to calling insert multiple times).</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; が単一のスカラーまたは1つの要素を持つシーケンスである場合の複数の挿入のサポート（挿入を複数回呼び出すのと同様）。</target>
        </trans-unit>
        <trans-unit id="4c2c6be525f6d9a610c57848f9ef0612672209f9" translate="yes" xml:space="preserve">
          <source>Support for reading lzma compressed text files in Python 3</source>
          <target state="translated">Python 3 での lzma 圧縮テキストファイルの読み込みをサポート</target>
        </trans-unit>
        <trans-unit id="57ebd340f9cd250715efd00bc82361318ecaf77c" translate="yes" xml:space="preserve">
          <source>Support for returning arrays of arbitrary dimensions in &lt;code&gt;apply_along_axis&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;apply_along_axis&lt;/code&gt; で任意の次元の配列を返すためのサポート</target>
        </trans-unit>
        <trans-unit id="2d5e2188fd70bec3fdf433ddaeea9f504cb04b41" translate="yes" xml:space="preserve">
          <source>Support for the &amp;lsquo;@&amp;rsquo; operator in Python 3.5+</source>
          <target state="translated">Python3.5以降での「@」演算子のサポート</target>
        </trans-unit>
        <trans-unit id="96793ccd7b743fcb4b68f47fc4a80f55eade2824" translate="yes" xml:space="preserve">
          <source>Support for the &lt;strong&gt;Yields&lt;/strong&gt; section was added in &lt;a href=&quot;https://github.com/numpy/numpydoc&quot;&gt;numpydoc&lt;/a&gt; version 0.6.</source>
          <target state="translated">&lt;strong&gt;Yields&lt;/strong&gt;セクションのサポートは、&lt;a href=&quot;https://github.com/numpy/numpydoc&quot;&gt;numpydoc&lt;/a&gt;バージョン0.6で追加されました。</target>
        </trans-unit>
        <trans-unit id="729714232faf9c660ac35de89eac7db896893cb6" translate="yes" xml:space="preserve">
          <source>Support for tracemalloc in Python 3.6</source>
          <target state="translated">Python 3.6 での tracemalloc のサポート</target>
        </trans-unit>
        <trans-unit id="08bf3021612bda0edd29ed3bce556141bfaab8f8" translate="yes" xml:space="preserve">
          <source>Support of object arrays in &lt;code&gt;matmul&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;matmul&lt;/code&gt; でのオブジェクト配列のサポート</target>
        </trans-unit>
        <trans-unit id="738f921dd6d285f914885c453cfc677ad8fc0e6b" translate="yes" xml:space="preserve">
          <source>Support path-like objects for more functions</source>
          <target state="translated">より多くの機能のためにパスライクなオブジェクトをサポート</target>
        </trans-unit>
        <trans-unit id="6d95257e0d6b5ee52701ed6e60955d7b5cf2355f" translate="yes" xml:space="preserve">
          <source>Supported BitGenerators</source>
          <target state="translated">サポートされているビットジェネレーター</target>
        </trans-unit>
        <trans-unit id="35d1294934e4cc4b101779bccdbe627fdf3b5b49" translate="yes" xml:space="preserve">
          <source>Supported platforms and versions</source>
          <target state="translated">サポートされているプラットフォームとバージョン</target>
        </trans-unit>
        <trans-unit id="090678b79c24d0799aa7434df5ba4e013c0ea2ff" translate="yes" xml:space="preserve">
          <source>Supports Fortran-contiguous arrays directly.</source>
          <target state="translated">Fortranに連続した配列を直接サポートします.</target>
        </trans-unit>
        <trans-unit id="62c4a407a3644c899b58964ef70d8d5ea099dfdd" translate="yes" xml:space="preserve">
          <source>Supports full broadcasting of the inputs.</source>
          <target state="translated">入力のフル放送に対応しています。</target>
        </trans-unit>
        <trans-unit id="12f46de9102cae348756a951378fba972f726b07" translate="yes" xml:space="preserve">
          <source>Supports rolling over multiple dimensions simultaneously.</source>
          <target state="translated">複数の寸法を同時に転がすことに対応しています。</target>
        </trans-unit>
        <trans-unit id="c531221221ae570c082e108201b731a1c902860f" translate="yes" xml:space="preserve">
          <source>Supports the method &lt;a href=&quot;generated/numpy.random.pcg64.advance#numpy.random.PCG64.advance&quot;&gt;&lt;code&gt;advance&lt;/code&gt;&lt;/a&gt; to advance the RNG an arbitrary number of steps. The state of the PCG-64 RNG is represented by 2 128-bit unsigned integers.</source>
          <target state="translated">RNGを任意のステップ数だけ&lt;a href=&quot;generated/numpy.random.pcg64.advance#numpy.random.PCG64.advance&quot;&gt; &lt;code&gt;advance&lt;/code&gt; &lt;/a&gt;ためのメソッドアドバンスをサポートします。PCG-64 RNGの状態は、2つの128ビット符号なし整数で表されます。</target>
        </trans-unit>
        <trans-unit id="d97b0cce7cf0a1a8ea78834b26b7eaa1e93207d9" translate="yes" xml:space="preserve">
          <source>Supports the method &lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt;&lt;code&gt;advance&lt;/code&gt;&lt;/a&gt; to advance the RNG an arbitrary number of steps. The state of the PCG-64 RNG is represented by 2 128-bit unsigned integers.</source>
          <target state="translated">メソッドサポート&lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt; &lt;code&gt;advance&lt;/code&gt; &lt;/a&gt; RNGに任意のステップを進めます。PCG-64 RNGの状態は、2つの128ビット符号なし整数で表されます。</target>
        </trans-unit>
        <trans-unit id="34c5f00d14223115d609ab63804b8bf6dbd38059" translate="yes" xml:space="preserve">
          <source>Suppose &lt;code&gt;x.shape&lt;/code&gt; is (10,20,30) and &lt;code&gt;ind&lt;/code&gt; is a (2,3,4)-shaped indexing &lt;code&gt;intp&lt;/code&gt; array, then &lt;code&gt;result = x[...,ind,:]&lt;/code&gt; has shape (10,2,3,4,30) because the (20,)-shaped subspace has been replaced with a (2,3,4)-shaped broadcasted indexing subspace. If we let &lt;em&gt;i, j, k&lt;/em&gt; loop over the (2,3,4)-shaped subspace then &lt;code&gt;result[...,i,j,k,:] = x[...,ind[i,j,k],:]&lt;/code&gt;. This example produces the same result as &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt;&lt;code&gt;x.take(ind, axis=-2)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">仮定 &lt;code&gt;x.shape&lt;/code&gt; がある（10,20,30）及び &lt;code&gt;ind&lt;/code&gt; （2,3,4）形状のインデキシングされ &lt;code&gt;intp&lt;/code&gt; アレイ、その後 &lt;code&gt;result = x[...,ind,:]&lt;/code&gt; 形状（10,2,3を有します、4,30）（20、）形のサブスペースが（2,3,4）形のブロードキャストインデックスサブスペースに置き換えられたため。&lt;em&gt;i、j、kを&lt;/em&gt;（2,3,4）形の部分空間でループさせると、 &lt;code&gt;result[...,i,j,k,:] = x[...,ind[i,j,k],:]&lt;/code&gt; 。この例は、&lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt; &lt;code&gt;x.take(ind, axis=-2)&lt;/code&gt; &lt;/a&gt;と同じ結果を生成します。</target>
        </trans-unit>
        <trans-unit id="ab6e03b971eeb9906907892d695f98f70c00c465" translate="yes" xml:space="preserve">
          <source>Suppose I have two files coolmodule.c and coolhelper.c which need to be compiled and linked into a single extension module. Suppose coolmodule.c contains the required initcool module initialization function (with the import_array() function called). Then, coolmodule.c would have at the top:</source>
          <target state="translated">二つのファイル coolmodule.c と coolhelper.c をコンパイルして一つの拡張モジュールにリンクする必要があるとします。coolmodule.c に必要な initcool モジュールの初期化関数 (import_array()関数を呼び出したもの)が含まれているとします。そうすると、coolmodule.c の先頭には、以下のような記述があります。</target>
        </trans-unit>
        <trans-unit id="1a06be2cc716b778d6a1c32b124922e42d2cce52" translate="yes" xml:space="preserve">
          <source>Suppose now that we wish to print that same data, but with the missing values replaced by the average value.</source>
          <target state="translated">同じデータを、欠落した値を平均値に置き換えて印刷したいとします。</target>
        </trans-unit>
        <trans-unit id="c30e0906e4415225d057040ed0740bd62f0ab08e" translate="yes" xml:space="preserve">
          <source>Suppose that the commit history looks like this:</source>
          <target state="translated">コミット履歴が以下のようになっているとします。</target>
        </trans-unit>
        <trans-unit id="5dca6dc181cc53601add013bc2ada72709458943" translate="yes" xml:space="preserve">
          <source>Suppose the first operand is one dimensional and the second operand is two dimensional. The iterator will have three dimensions, so &lt;code&gt;op_axes&lt;/code&gt; will have two 3-element lists. The first list picks out the one axis of the first operand, and is -1 for the rest of the iterator axes, with a final result of [0, -1, -1]. The second list picks out the two axes of the second operand, but shouldn&amp;rsquo;t overlap with the axes picked out in the first operand. Its list is [-1, 0, 1]. The output operand maps onto the iterator axes in the standard manner, so we can provide None instead of constructing another list.</source>
          <target state="translated">最初のオペランドが1次元で、2番目のオペランドが2次元であるとします。イテレータには3つの次元があるため、 &lt;code&gt;op_axes&lt;/code&gt; には2つの3要素リストがあります。最初のリストは、最初のオペランドの1つの軸を選択し、残りの反復子軸では-1であり、最終結果は[0、-1、-1]です。 2番目のリストは、2番目のオペランドの2つの軸を選択しますが、最初のオペランドで選択された軸と重複してはなりません。そのリストは[-1、0、1]です。出力オペランドは標準的な方法でイテレータ軸にマッピングされるため、別のリストを作成する代わりにNoneを提供できます。</target>
        </trans-unit>
        <trans-unit id="ffbff519fe81519b5859278de1db83d3776384bb" translate="yes" xml:space="preserve">
          <source>Suppose you have a SciPy module &lt;code&gt;scipy/xxx/yyy.py&lt;/code&gt; containing a function &lt;code&gt;zzz()&lt;/code&gt;. To test this function you would create a test module called &lt;code&gt;test_yyy.py&lt;/code&gt;. If you only need to test one aspect of &lt;code&gt;zzz&lt;/code&gt;, you can simply add a test function:</source>
          <target state="translated">関数 &lt;code&gt;zzz()&lt;/code&gt; を含むSciPyモジュール &lt;code&gt;scipy/xxx/yyy.py&lt;/code&gt; があるとします。この関数をテストするには、 &lt;code&gt;test_yyy.py&lt;/code&gt; というテストモジュールを作成します。 &lt;code&gt;zzz&lt;/code&gt; の 1つの側面のみをテストする必要がある場合は、テスト関数を追加するだけです。</target>
        </trans-unit>
        <trans-unit id="561e62ec5d03ac50c21e0a257548d3eb990ac028" translate="yes" xml:space="preserve">
          <source>Suppose you have an urn with 15 white and 15 black marbles. If you pull 15 marbles at random, how likely is it that 12 or more of them are one color?</source>
          <target state="translated">15個の白と15個の黒のビー玉が入った骨壷があるとします。15個のビー玉をランダムに引いた場合、12個以上のビー玉が1色である可能性はどのくらいでしょうか?</target>
        </trans-unit>
        <trans-unit id="7c7cd36a0c21d430e2827a371600cad0b35b80b7" translate="yes" xml:space="preserve">
          <source>Suppress the rows and/or columns of a 2-D array that contain masked values.</source>
          <target state="translated">マスクされた値を含む2次元配列の行や列を抑制します.</target>
        </trans-unit>
        <trans-unit id="00f54cf02ad98c4bd3014ede43830053636d4545" translate="yes" xml:space="preserve">
          <source>Suppress whole columns of a 2-D array that contain masked values.</source>
          <target state="translated">マスクされた値を含む2次元配列の列全体を抑制します.</target>
        </trans-unit>
        <trans-unit id="685b0c43425911b6f904fe6d170e96c0345d4cbf" translate="yes" xml:space="preserve">
          <source>Suppress whole rows of a 2-D array that contain masked values.</source>
          <target state="translated">マスクされた値を含む2次元配列の全行を抑制します.</target>
        </trans-unit>
        <trans-unit id="b11d9a95741366c39b17b9d4fd94445d808b15b4" translate="yes" xml:space="preserve">
          <source>Swap the bytes of the array elements</source>
          <target state="translated">配列要素のバイトを入れ替える</target>
        </trans-unit>
        <trans-unit id="bbdcf90ffec6f9d47a9ac51cf19b00a93a140fa9" translate="yes" xml:space="preserve">
          <source>Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned.</source>
          <target state="translated">戻り値の性質を決定するスイッチです。False(デフォルト)の場合は係数のみが返され、Trueの場合は特異値分解の診断情報も返されます。</target>
        </trans-unit>
        <trans-unit id="6b3384dea957229bd45073ab4c8cae823f791969" translate="yes" xml:space="preserve">
          <source>Switch determining the nature of the return value. When &lt;code&gt;False&lt;/code&gt; (the default) just the coefficients are returned; when &lt;code&gt;True&lt;/code&gt;, diagnostic information from the singular value decomposition (used to solve the fit&amp;rsquo;s matrix equation) is also returned.</source>
          <target state="translated">戻り値の性質を決定するスイッチ。とき &lt;code&gt;False&lt;/code&gt; （デフォルト）だけ係数が返されます。 &lt;code&gt;True&lt;/code&gt; の場合、特異値分解（当てはめの行列方程式を解くために使用される）からの診断情報も返されます。</target>
        </trans-unit>
        <trans-unit id="7af38070c59fd5383f5319f90871324cb011240a" translate="yes" xml:space="preserve">
          <source>System Entropy</source>
          <target state="translated">エントロピー系</target>
        </trans-unit>
        <trans-unit id="1b1430441b7b7dd5a90d83f42f914deacc5fd0e5" translate="yes" xml:space="preserve">
          <source>System configuration</source>
          <target state="translated">システム構成</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="29f1b70dfc7cd7e2755985e321ea4063c37e7f58" translate="yes" xml:space="preserve">
          <source>T (numpy.char.chararray attribute)</source>
          <target state="translated">T (numpy.char.chararray 属性)</target>
        </trans-unit>
        <trans-unit id="08fb6d4b20d17768263265c26a0d6392cfb83ed1" translate="yes" xml:space="preserve">
          <source>T() (numpy.ma.masked_array property)</source>
          <target state="translated">T()(numpy.ma.masked_arrayプロパティ)</target>
        </trans-unit>
        <trans-unit id="494db6c744e0093634443456957eafcc51937e81" translate="yes" xml:space="preserve">
          <source>THE RESULTING LOGIT FUNCTION IS NOT FAST! numpy.vectorize simply loops over spam.logit. The loop is done at the C level, but the numpy array is constantly being parsed and build back up. This is expensive. When the author compared numpy.vectorize(spam.logit) against the logit ufuncs constructed below, the logit ufuncs were almost exactly 4 times faster. Larger or smaller speedups are, of course, possible depending on the nature of the function.</source>
          <target state="translated">結果のlogit関数は高速ではありません! numpy.vectorizeは単にspam.logitの上をループしています。ループはCレベルで行われますが、numpy配列は常に解析されてビルドアップされています。これにはコストがかかります。作者がnumpy.vectorize(spam.logit)を以下に構築したlogit ufuncsと比較したところ、logit ufuncsの方がほぼ正確に4倍速くなりました。もちろん、関数の性質にもよりますが、それ以上でもそれ以下でも高速化は可能です。</target>
        </trans-unit>
        <trans-unit id="8d06ee651a160babb28eda47548bd9fad2ca6df2" translate="yes" xml:space="preserve">
          <source>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &amp;ldquo;AS IS&amp;rdquo; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</source>
          <target state="translated">このソフトウェアは、著作権所有者および寄稿者によって「現状有姿」で提供され、商品性および特定目的への適合性の黙示の保証を含むがこれに限定されない、明示または黙示の保証は否認されます。いかなる場合も、著作権所有者または寄稿者は、直接的、間接的、偶発的、特別、模範的、または結果的な損害（代替商品またはサービスの調達、使用、データ、または利益の損失を含むがこれらに限定されない）に対して責任を負わないものとします。またはビジネスの中断）ただし、契約、無過失責任、または不法行為（過失またはその他を含む）にかかわらず、このソフトウェアの使用から何らかの形で生じた責任の理論に基づいて、このソフトウェアの使用から生じたものです。</target>
        </trans-unit>
        <trans-unit id="8e0d354392fe3fc9d2a5d83e7fd5a6f24a2b815a" translate="yes" xml:space="preserve">
          <source>TODO: Maybe it would be better to introduce a function &lt;code&gt;NpyIter_GetWrappedOutput&lt;/code&gt; and remove this flag?</source>
          <target state="translated">TODO：関数 &lt;code&gt;NpyIter_GetWrappedOutput&lt;/code&gt; を導入してこのフラグを削除する方がよいでしょうか？</target>
        </trans-unit>
        <trans-unit id="c398f641b79127cbb5368a052c9c18ee4b191edd" translate="yes" xml:space="preserve">
          <source>TODO: This feature can be easily extended for Fortran 90 codes as well. Let us know if you would need such a feature.</source>
          <target state="translated">TODO:この機能はFortran 90コードにも簡単に拡張できます。このような機能が必要な場合は、私たちに教えてください。</target>
        </trans-unit>
        <trans-unit id="8cfd932f7721749006331a6f950d4068e186ddf4" translate="yes" xml:space="preserve">
          <source>Table of Rough MATLAB-NumPy Equivalents</source>
          <target state="translated">ラフMATLAB-NumPyの等価物の表</target>
        </trans-unit>
        <trans-unit id="b2e0fad2c7303a14e3d40f2816778e4a945515d7" translate="yes" xml:space="preserve">
          <source>Tag the release</source>
          <target state="translated">リリースにタグを付ける</target>
        </trans-unit>
        <trans-unit id="d2bf59208074c19e062d597b69c91e24c1b3f65d" translate="yes" xml:space="preserve">
          <source>Take a sequence of 1-D arrays and stack them as columns to make a single 2-D array. 2-D arrays are stacked as-is, just like with &lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt;. 1-D arrays are turned into 2-D columns first.</source>
          <target state="translated">1次元配列のシーケンスを受け取り、それらを列としてスタックして、1つの2次元配列を作成します。2次元配列は、&lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt;と同様に、そのままスタックされます。1次元配列は、最初に2次元列に変換されます。</target>
        </trans-unit>
        <trans-unit id="a7063ff9c282b69776d4b6c1965ce5cc8d3d21f1" translate="yes" xml:space="preserve">
          <source>Take a sequence of 1-D arrays and stack them as columns to make a single 2-D array. 2-D arrays are stacked as-is, just like with &lt;a href=&quot;numpy.ma.hstack#numpy.ma.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt;. 1-D arrays are turned into 2-D columns first.</source>
          <target state="translated">1次元配列のシーケンスを受け取り、それらを列としてスタックして、1つの2次元配列を作成します。2次元配列は、&lt;a href=&quot;numpy.ma.hstack#numpy.ma.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt;と同様に、そのままスタックされます。1次元配列は、最初に2次元列に変換されます。</target>
        </trans-unit>
        <trans-unit id="948650b27c1b2b9784a79436cafe48d7d653c938" translate="yes" xml:space="preserve">
          <source>Take along an axis, using the same indices for every 1d slice</source>
          <target state="translated">1次元スライスごとに同じインデックスを使用して、軸に沿って取る</target>
        </trans-unit>
        <trans-unit id="750d821c9fa304621f4be0f3b88564bf9278e152" translate="yes" xml:space="preserve">
          <source>Take elements by matching the array and the index arrays</source>
          <target state="translated">配列とインデックス配列を一致させて要素を取る</target>
        </trans-unit>
        <trans-unit id="e11fd16230a195030272e04871b014d038eef9ab" translate="yes" xml:space="preserve">
          <source>Take elements from an array along an axis.</source>
          <target state="translated">配列から軸に沿って要素を取り出します。</target>
        </trans-unit>
        <trans-unit id="2bd0abec8d18fb4f628e5467a962eaf329bb6905" translate="yes" xml:space="preserve">
          <source>Take elements using a boolean mask</source>
          <target state="translated">ブール型マスクを使って要素を取る</target>
        </trans-unit>
        <trans-unit id="b8cd92f0049ea13b3db726f84fc3411287caeddf" translate="yes" xml:space="preserve">
          <source>Take the fields dictionary, &lt;em&gt;dict&lt;/em&gt;, such as the one attached to a data-type object and construct an ordered-list of field names such as is stored in the names field of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">データ型オブジェクトに接続されているようなフィールド辞書&lt;em&gt;dictを&lt;/em&gt;&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;、PyArray_Descrオブジェクトの名前フィールドに格納されているようなフィールド名の順序付きリストを作成します。</target>
        </trans-unit>
        <trans-unit id="8588b385cd332763c111b95b02976dcd4b8a50f6" translate="yes" xml:space="preserve">
          <source>Take the fields dictionary, &lt;em&gt;dict&lt;/em&gt;, such as the one attached to a data-type object and construct an ordered-list of field names such as is stored in the names field of the &lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">データ型オブジェクトに添付されているものなどのフィールドディクショナリ&lt;em&gt;dictを&lt;/em&gt;取得し、&lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;オブジェクトのnamesフィールドに格納されているようなフィールド名の順序付きリストを作成します。</target>
        </trans-unit>
        <trans-unit id="673397230d0da22f7147b4eeece871fd1294c5ff" translate="yes" xml:space="preserve">
          <source>Take values from the input array by matching 1d index and data slices</source>
          <target state="translated">1次元インデックスとデータスライスをマッチングさせて入力配列から値を取得する</target>
        </trans-unit>
        <trans-unit id="7f4b8f1ca46302f3d1aba5fbdc3749dad60f0480" translate="yes" xml:space="preserve">
          <source>Take values from the input array by matching 1d index and data slices.</source>
          <target state="translated">1次元インデックスとデータスライスをマッチングさせて、入力配列から値を取得します。</target>
        </trans-unit>
        <trans-unit id="567aaaa85050a78f736c937e4e349477825e7c6c" translate="yes" xml:space="preserve">
          <source>Takes an arbitrary Python function and returns a NumPy ufunc.</source>
          <target state="translated">任意のPython関数を受け取り、NumPy ufuncを返します。</target>
        </trans-unit>
        <trans-unit id="ad884a5ab2796ce61beab25497caa48a0c350a18" translate="yes" xml:space="preserve">
          <source>Takes an arbitrary Python function and returns a ufunc</source>
          <target state="translated">任意の Python 関数を受け取り、ufunc を返します。</target>
        </trans-unit>
        <trans-unit id="4fe8421f7b4bac2910c2919a03e01d32f910e006" translate="yes" xml:space="preserve">
          <source>Taking an example cited in Wikipedia, this distribution can be used if one wanted to cut strings (each of initial length 1.0) into K pieces with different lengths, where each piece had, on average, a designated average length, but allowing some variation in the relative sizes of the pieces.</source>
          <target state="translated">ウィキペディアで引用されている例を例にすると、この分布は、(それぞれの初期長さ1.0の)弦を異なる長さのK個に切断したい場合に使用することができ、各個は平均的に指定された平均長さを持っていますが、相対的な大きさの変化を許容します。</target>
        </trans-unit>
        <trans-unit id="a8980c440e8f502e5c59dc6cdcc36215481bcc7e" translate="yes" xml:space="preserve">
          <source>Taking no further action</source>
          <target state="translated">これ以上の行動を取らない</target>
        </trans-unit>
        <trans-unit id="af1237aaefe517f485a7a53e6bb8a3bb8a86a6a4" translate="yes" xml:space="preserve">
          <source>Target array.</source>
          <target state="translated">ターゲットの配列。</target>
        </trans-unit>
        <trans-unit id="51038a1a794fec6114fafbb47a8bce902f23294f" translate="yes" xml:space="preserve">
          <source>Target indices, interpreted as integers.</source>
          <target state="translated">整数として解釈されるターゲットインデックス。</target>
        </trans-unit>
        <trans-unit id="695f8bb0287f4fc300e17fa93e5262f0b53e9bb1" translate="yes" xml:space="preserve">
          <source>Temporary directories are deleted when the DataSource is deleted.</source>
          <target state="translated">一時的なディレクトリは、DataSourceが削除されると削除されます。</target>
        </trans-unit>
        <trans-unit id="b3d2d960e69084c198868bb0c51081b279e6d57d" translate="yes" xml:space="preserve">
          <source>Temporary elision</source>
          <target state="translated">一時的なエリシオン</target>
        </trans-unit>
        <trans-unit id="6701dda5ea2a62c52d8395d7a5c8f390a0ab64df" translate="yes" xml:space="preserve">
          <source>Tensor contraction:</source>
          <target state="translated">テンソルの収縮。</target>
        </trans-unit>
        <trans-unit id="7e786b6ecaa33c3bfa2a663250579b348bbb6678" translate="yes" xml:space="preserve">
          <source>Tensor contractions, &lt;a href=&quot;numpy.tensordot#numpy.tensordot&quot;&gt;&lt;code&gt;numpy.tensordot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">テンソル収縮、&lt;a href=&quot;numpy.tensordot#numpy.tensordot&quot;&gt; &lt;code&gt;numpy.tensordot&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8aa53899fcc2f4722e3aaa13b02a9f0c21a58b0c" translate="yes" xml:space="preserve">
          <source>Tensor to &amp;lsquo;invert&amp;rsquo;. Its shape must be &amp;lsquo;square&amp;rsquo;, i. e., &lt;code&gt;prod(a.shape[:ind]) == prod(a.shape[ind:])&lt;/code&gt;.</source>
          <target state="translated">「反転」するテンソル。その形状は「正方形」でなければなりません。つまり、 &lt;code&gt;prod(a.shape[:ind]) == prod(a.shape[ind:])&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="5a7912060e7ae8d981d410c16692b658bc5a8653" translate="yes" xml:space="preserve">
          <source>Tensors to &amp;ldquo;dot&amp;rdquo;.</source>
          <target state="translated">「ドット」へのテンソル。</target>
        </trans-unit>
        <trans-unit id="71218d40834bc4913fe2fbb95e52de19a584b43a" translate="yes" xml:space="preserve">
          <source>Test Running</source>
          <target state="translated">テストの実行</target>
        </trans-unit>
        <trans-unit id="2ec99dbb44d0090912e3c4ddf71222f3cee61914" translate="yes" xml:space="preserve">
          <source>Test Support (&lt;code&gt;numpy.testing&lt;/code&gt;)</source>
          <target state="translated">テストサポート（ &lt;code&gt;numpy.testing&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c35554b04739c6c6869f7c83d9841e0dda4c5073" translate="yes" xml:space="preserve">
          <source>Test Support (numpy.testing)</source>
          <target state="translated">テストサポート (numpy.testing)</target>
        </trans-unit>
        <trans-unit id="a0b0d520e3181fa7765d42a80050b97cb70dbe30" translate="yes" xml:space="preserve">
          <source>Test coverage</source>
          <target state="translated">テストカバレッジ</target>
        </trans-unit>
        <trans-unit id="59afddee1692b59da457c30d92a5b65f5e31115a" translate="yes" xml:space="preserve">
          <source>Test element-wise for NaN and return result as a boolean array.</source>
          <target state="translated">NaNを要素ごとにテストし、結果をブール値の配列として返します。</target>
        </trans-unit>
        <trans-unit id="ed391a308f11ca7f40c17a765e9b20cc4e1035a2" translate="yes" xml:space="preserve">
          <source>Test element-wise for NaT (not a time) and return result as a boolean array.</source>
          <target state="translated">NaTを要素ごとにテストし(時間ではなく)、結果をブール値の配列として返します。</target>
        </trans-unit>
        <trans-unit id="9f34997c659f4457d18a667e13e9b54ff7ea7b5d" translate="yes" xml:space="preserve">
          <source>Test element-wise for finiteness (not infinity or not Not a Number).</source>
          <target state="translated">有限性(無限大ではないか、数ではないか)を要素ごとにテストします。</target>
        </trans-unit>
        <trans-unit id="b73482f0dd7c13ea3e95362c875b37244def5b6c" translate="yes" xml:space="preserve">
          <source>Test element-wise for negative infinity, return result as bool array.</source>
          <target state="translated">負の無限大を要素ごとにテストし、結果をbool配列で返します。</target>
        </trans-unit>
        <trans-unit id="f441420173d81baeaa59a4fb443d5293972df75a" translate="yes" xml:space="preserve">
          <source>Test element-wise for positive infinity, return result as bool array.</source>
          <target state="translated">正の無限大を要素ごとにテストし、結果をbool配列で返します。</target>
        </trans-unit>
        <trans-unit id="f76286ad13fcd1d6939365b38ad9443c5711054b" translate="yes" xml:space="preserve">
          <source>Test element-wise for positive or negative infinity.</source>
          <target state="translated">正の無限大か負の無限大かを要素ごとにテストします。</target>
        </trans-unit>
        <trans-unit id="a54ae1b5fd87138bbeb065cc5056362be6e773bd" translate="yes" xml:space="preserve">
          <source>Test if &lt;code&gt;path&lt;/code&gt; exists as (and in this order):</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; が次のように（この順序で）存在するかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="6db21c53daecd81068cb27c5716c17cf9ec8f853" translate="yes" xml:space="preserve">
          <source>Test if path exists.</source>
          <target state="translated">パスが存在するかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="ab9c97d91f47360ac72bf2e9386f7b26c75db7d2" translate="yes" xml:space="preserve">
          <source>Test if two strings are equal.</source>
          <target state="translated">2つの文字列が等しいかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="90c99592ef3a4e369f5b8438543a142bc4a6d8c8" translate="yes" xml:space="preserve">
          <source>Test support</source>
          <target state="translated">テストサポート</target>
        </trans-unit>
        <trans-unit id="fe6e53750db930a15ff2a9eb0786f6b4b0dd49e8" translate="yes" xml:space="preserve">
          <source>Test whether &lt;code&gt;ary&lt;/code&gt; is contiguous. If so, return 1. Otherwise, set a Python error and return 0.</source>
          <target state="translated">&lt;code&gt;ary&lt;/code&gt; が隣接しているかどうかをテストします。その場合は1を返します。それ以外の場合は、Pythonエラーを設定して0を返します。</target>
        </trans-unit>
        <trans-unit id="e52099e2b541a96f27cc77aa438f266ac05e538f" translate="yes" xml:space="preserve">
          <source>Test whether all array elements along a given axis evaluate to True.</source>
          <target state="translated">指定された軸に沿ったすべての配列要素がTrueに評価されるかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="7d4c1c04414d7af36c37c81837979d62019dac75" translate="yes" xml:space="preserve">
          <source>Test whether all elements along a given axis evaluate to True.</source>
          <target state="translated">指定された軸に沿ったすべての要素がTrueに評価されるかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="8dcb7ed405671230192b179ae33bab118c7f5996" translate="yes" xml:space="preserve">
          <source>Test whether all matrix elements along a given axis evaluate to True.</source>
          <target state="translated">指定された軸に沿ったすべての行列要素がTrueに評価されるかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="a8cd365e47952360dc676cadf55d3bc2ecae44b5" translate="yes" xml:space="preserve">
          <source>Test whether any array element along a given axis evaluates to True.</source>
          <target state="translated">指定された軸に沿った配列要素がTrueと評価されるかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="e54011a9e26f7c9e97e1ca23a771785990f7e7d4" translate="yes" xml:space="preserve">
          <source>Test whether any element along a given axis evaluates to True.</source>
          <target state="translated">指定された軸に沿った要素がTrueに評価されるかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="3c5d24b0586eac0954dbcb6d49897a1641c89d36" translate="yes" xml:space="preserve">
          <source>Test whether each element of a 1-D array is also present in a second array.</source>
          <target state="translated">1次元配列の各要素が2番目の配列にも存在するかどうかをテストします.</target>
        </trans-unit>
        <trans-unit id="025a700084bfede250ccd79227b915c047f7f35d" translate="yes" xml:space="preserve">
          <source>Test whether input is an instance of MaskedArray.</source>
          <target state="translated">入力がMaskedArrayのインスタンスであるかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="5904fc9bcfebbe0d053c7cdc88d0d4fdd88cf00c" translate="yes" xml:space="preserve">
          <source>Tester (in module numpy.testing)</source>
          <target state="translated">テスター</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="43d2fa7f4fbc625f4df01f08ea6653e49f950cbd" translate="yes" xml:space="preserve">
          <source>Testing Guidelines</source>
          <target state="translated">テストガイドライン</target>
        </trans-unit>
        <trans-unit id="ef9606fae34bdb52d82ad257949ec42aea0b9b12" translate="yes" xml:space="preserve">
          <source>Testing Header Files</source>
          <target state="translated">ヘッダーファイルのテスト</target>
        </trans-unit>
        <trans-unit id="d322a0e8fe52f19dbe7d5bd52156ee63071b90d8" translate="yes" xml:space="preserve">
          <source>Testing Organization</source>
          <target state="translated">試験機関</target>
        </trans-unit>
        <trans-unit id="e3148b0ff766bdb8347a198898838253aab4da96" translate="yes" xml:space="preserve">
          <source>Testing Python Scripts</source>
          <target state="translated">Python スクリプトのテスト</target>
        </trans-unit>
        <trans-unit id="8c3a61a48bb499744371cb7fc30761102d86f229" translate="yes" xml:space="preserve">
          <source>Testing SWIG Interface Files</source>
          <target state="translated">SWIGインターフェースファイルのテスト</target>
        </trans-unit>
        <trans-unit id="34d08d85bddb11f11da76ad84dab43a94d74c7ed" translate="yes" xml:space="preserve">
          <source>Testing Source Files</source>
          <target state="translated">ソースファイルのテスト</target>
        </trans-unit>
        <trans-unit id="ad0aa0ce3fefa4686bfefac5eb7c9ff2df0a50c6" translate="yes" xml:space="preserve">
          <source>Testing builds</source>
          <target state="translated">ビルドのテスト</target>
        </trans-unit>
        <trans-unit id="7704b172077f920ddd46d5adbcffe86730e58a19" translate="yes" xml:space="preserve">
          <source>Testing looks for module-level or class-level setup and teardown functions by name; thus:</source>
          <target state="translated">テストでは、モジュールレベルまたはクラスレベルのセットアップとティアダウン関数を名前で探します。</target>
        </trans-unit>
        <trans-unit id="45ece46e91d1fe305feeee99aed2fad182be7b30" translate="yes" xml:space="preserve">
          <source>Testing the numpy.i Typemaps</source>
          <target state="translated">numpy.i型マップのテスト</target>
        </trans-unit>
        <trans-unit id="00774e7f83f997b0fda8acccd1c59071701a2ddf" translate="yes" xml:space="preserve">
          <source>Tests can also be run with &lt;code&gt;pytest numpy&lt;/code&gt;, however then the NumPy-specific plugin is not found which causes strange side effects</source>
          <target state="translated">&lt;code&gt;pytest numpy&lt;/code&gt; を使用してテストを実行することもできますが、NumPy固有のプラグインが見つからないため、奇妙な副作用が発生します。</target>
        </trans-unit>
        <trans-unit id="7f86100126c53e2e34ca1a3d91679a3a06b6d132" translate="yes" xml:space="preserve">
          <source>Tests for a module should ideally cover all code in that module, i.e., statement coverage should be at 100%.</source>
          <target state="translated">モジュールのテストは、理想的にはそのモジュール内のすべてのコードをカバーしなければなりません。</target>
        </trans-unit>
        <trans-unit id="417d130b240483956f423e540d6cb689832b6f9e" translate="yes" xml:space="preserve">
          <source>Tests on random data</source>
          <target state="translated">ランダムデータのテスト</target>
        </trans-unit>
        <trans-unit id="f3d72180c504c070f745ad049bd21c11042867d1" translate="yes" xml:space="preserve">
          <source>Tests on random data are good, but since test failures are meant to expose new bugs or regressions, a test that passes most of the time but fails occasionally with no code changes is not helpful. Make the random data deterministic by setting the random number seed before generating it. Use either Python&amp;rsquo;s &lt;code&gt;random.seed(some_number)&lt;/code&gt; or NumPy&amp;rsquo;s &lt;code&gt;numpy.random.seed(some_number)&lt;/code&gt;, depending on the source of random numbers.</source>
          <target state="translated">ランダムデータでのテストは適切ですが、テストの失敗は新しいバグやリグレッションを明らかにすることを目的としているため、ほとんどの場合合格しますが、コードを変更せずに失敗するテストは役に立ちません。乱数シードを生成する前に設定して、ランダムデータを確定的にします。乱数のソースに応じて、Pythonの &lt;code&gt;random.seed(some_number)&lt;/code&gt; またはNumPyの &lt;code&gt;numpy.random.seed(some_number)&lt;/code&gt; のいずれかを使用します。</target>
        </trans-unit>
        <trans-unit id="927f696caa5bf0529c4f0991bbe8b99afb2fa55b" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float has a value equal to zero. This may be slightly faster than calling npy_half_eq(h, NPY_ZERO).</source>
          <target state="translated">半精度フロートの値が0に等しいかどうかを調べます。これは、npy_half_eq(h,NPY_ZERO)を呼び出すよりも若干速いかもしれません。</target>
        </trans-unit>
        <trans-unit id="b3be553d33f0513a6775eaa86f3391147a1aac09" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is a NaN.</source>
          <target state="translated">半精度フロートがNaNであるかどうかを判定します。</target>
        </trans-unit>
        <trans-unit id="6424a62751d70065c8ad2d16d22d5e29e4d2e45c" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is finite (not NaN or Inf).</source>
          <target state="translated">半精度フロートが有限であるかどうかをテストします(NaNやInfではありません)。</target>
        </trans-unit>
        <trans-unit id="b796fd95ec3aee28c84902e310b3fcc5e87bd087" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is plus or minus Inf.</source>
          <target state="translated">半精度フロートがプラスかマイナスかを判定します。</target>
        </trans-unit>
        <trans-unit id="9cad929af9630184e2ec9f960cd674271afcf718" translate="yes" xml:space="preserve">
          <source>Tests, that send messages to stderr, fail when executed from MSYS prompt because the messages are lost at some point.</source>
          <target state="translated">stderr にメッセージを送信するテストは、MSYS プロンプトから実行するとメッセージが失われるため失敗します。</target>
        </trans-unit>
        <trans-unit id="d627254d7ccb3ce266ce9cf0341eff8096cd2a09" translate="yes" xml:space="preserve">
          <source>Texlive (or MikTeX on Windows)</source>
          <target state="translated">Texlive (WindowsではMikTeX)</target>
        </trans-unit>
        <trans-unit id="0a988a505d4f9bd1f41a57f4c2458a2423baedc7" translate="yes" xml:space="preserve">
          <source>Text files</source>
          <target state="translated">テキストファイル</target>
        </trans-unit>
        <trans-unit id="4ba343aecd438b7c22876dbbd27f537f09be5607" translate="yes" xml:space="preserve">
          <source>Text formatting options</source>
          <target state="translated">テキストの書式設定オプション</target>
        </trans-unit>
        <trans-unit id="839b1da5d3ca352faa5ce69a674d5b04a8fa489d" translate="yes" xml:space="preserve">
          <source>Thanks to Yarik Halchenko for this explanation.</source>
          <target state="translated">この説明をしてくれたYarik Halchenkoさんに感謝します。</target>
        </trans-unit>
        <trans-unit id="5219411122630dca47bf818c11bfaef89c8f5266" translate="yes" xml:space="preserve">
          <source>That also takes extra arguments, like &lt;code&gt;--pdb&lt;/code&gt; which drops you into the Python debugger when a test fails or an exception is raised.</source>
          <target state="translated">これには、テストが失敗したときや例外が発生したときにPythonデバッガーにドロップする &lt;code&gt;--pdb&lt;/code&gt; などの追加の引数も必要です。</target>
        </trans-unit>
        <trans-unit id="90e8faeace432448f3522160a796443560f628f2" translate="yes" xml:space="preserve">
          <source>That can be one of 12 different scalar types: &lt;code&gt;signed char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, &lt;code&gt;unsigned long long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;signed char&lt;/code&gt; 、 &lt;code&gt;unsigned char&lt;/code&gt; 、 &lt;code&gt;short&lt;/code&gt; 、 &lt;code&gt;unsigned short&lt;/code&gt; 、 &lt;code&gt;int&lt;/code&gt; 、 &lt;code&gt;unsigned int&lt;/code&gt; 、 &lt;code&gt;long&lt;/code&gt; 、 &lt;code&gt;unsigned long&lt;/code&gt; 、 &lt;code&gt;long long&lt;/code&gt; 、 &lt;code&gt;unsigned long long&lt;/code&gt; 、 &lt;code&gt;float&lt;/code&gt; および &lt;code&gt;double&lt;/code&gt; の12種類のスカラー型のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="be4b72468f984c83d93633e8f8bf75388e94a047" translate="yes" xml:space="preserve">
          <source>That is a looser test than originally documented, but agrees with what the actual implementation did up to rounding vagaries. An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">これは元々文書化されていたテストよりも緩いテストですが、実際の実装が丸めのばらつきまで行ったものと一致しています。形状の不一致や値が競合する場合に例外が発生します。numpy の標準的な使い方とは対照的に、NaN は数字と同じように比較され、両方のオブジェクトが同じ位置に NaN を持っていてもアサーションは発生しません。</target>
        </trans-unit>
        <trans-unit id="31ca174a88927a9e0e7f8f15283f8ce9b3459f51" translate="yes" xml:space="preserve">
          <source>That is a looser test than originally documented, but agrees with what the actual implementation in &lt;a href=&quot;numpy.testing.assert_array_almost_equal#numpy.testing.assert_array_almost_equal&quot;&gt;&lt;code&gt;assert_array_almost_equal&lt;/code&gt;&lt;/a&gt; did up to rounding vagaries. An exception is raised at conflicting values. For ndarrays this delegates to assert_array_almost_equal</source>
          <target state="translated">これは、最初に文書化されたものよりも緩いテストですが、&lt;a href=&quot;numpy.testing.assert_array_almost_equal#numpy.testing.assert_array_almost_equal&quot;&gt; &lt;code&gt;assert_array_almost_equal&lt;/code&gt; &lt;/a&gt;の実際の実装が丸めのばらつきまで何をしたかと一致します。値が競合すると例外が発生します。ndarraysの場合、これはassert_array_almost_equalに委任します</target>
        </trans-unit>
        <trans-unit id="89910f6f21cfa928fbf09ccc006fad6eb4f77601" translate="yes" xml:space="preserve">
          <source>That is, each index specified selects the array corresponding to the rest of the dimensions selected. In the above example, choosing 0 means that the remaining dimension of length 5 is being left unspecified, and that what is returned is an array of that dimensionality and size. It must be noted that the returned array is not a copy of the original, but points to the same values in memory as does the original array. In this case, the 1-D array at the first position (0) is returned. So using a single index on the returned array, results in a single element being returned. That is:</source>
          <target state="translated">つまり,指定された各インデックスは,選択された残りの次元に対応する配列を選択します.上の例では,0を選ぶということは,長さ5の残りの次元が指定されていないことを意味し,返されるのはその次元とサイズの配列です.返される配列は,元の配列のコピーではなく,メモリ上で元の配列と同じ値を指していることに注意しなければなりません.この場合,最初の位置(0)の1次元配列が返されます.つまり、返される配列のインデックスを1つにすると、1つの要素が返されることになります。つまり</target>
        </trans-unit>
        <trans-unit id="9424a0780491d95b42071bfcb7519b4471231e07" translate="yes" xml:space="preserve">
          <source>That solves the problem of returning views of the same type, but now we have a new problem. The machinery of ndarray can set the class this way, in its standard methods for taking views, but the ndarray &lt;code&gt;__new__&lt;/code&gt; method knows nothing of what we have done in our own &lt;code&gt;__new__&lt;/code&gt; method in order to set attributes, and so on. (Aside - why not call &lt;code&gt;obj = subdtype.__new__(...&lt;/code&gt; then? Because we may not have a &lt;code&gt;__new__&lt;/code&gt; method with the same call signature).</source>
          <target state="translated">これで同じタイプのビューが返されるという問題は解決しましたが、新しい問題が発生しました。ndarrayの機構は、ビューを取得するための標準メソッドでこの方法でクラスを設定できますが、ndarray &lt;code&gt;__new__&lt;/code&gt; メソッドは、属性を設定するために独自の &lt;code&gt;__new__&lt;/code&gt; メソッドで行ったことなどを何も知りません。（余談ですが、 &lt;code&gt;obj = subdtype.__new__(...&lt;/code&gt; then？同じ呼び出しシグネチャを持つ &lt;code&gt;__new__&lt;/code&gt; メソッドがない可能性があるため）を呼び出さないのはなぜですか。</target>
        </trans-unit>
        <trans-unit id="b5240cf478eeccab2d778da09495ef32dd780cc8" translate="yes" xml:space="preserve">
          <source>That support 74 different argument signatures for each data type, including:</source>
          <target state="translated">を含む、各データ型の74の異なる引数シグネチャをサポートしています。</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="5c4c1c79691cc97764af36fe5679519dac98f423" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;busday&amp;rdquo; functions can additionally check a list of &amp;ldquo;holiday&amp;rdquo; dates, specific dates that are not valid days.</source>
          <target state="translated">「バスデー」機能はさらに、「休日」の日付のリスト、有効な日ではない特定の日付をチェックできます。</target>
        </trans-unit>
        <trans-unit id="b6c70d4694de1c6fa7fc40232e3591d1a1b102a5" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;count&amp;rdquo; algorithm is roughly equivalent to the following numpy code:</source>
          <target state="translated">「カウント」アルゴリズムは、次のnumpyコードとほぼ同等です。</target>
        </trans-unit>
        <trans-unit id="6a2e889671201d8619d4999f2673b8d825f07526" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;count&amp;rdquo; algorithm uses a temporary array of integers with length &lt;code&gt;sum(colors)&lt;/code&gt;.</source>
          <target state="translated">「カウント」アルゴリズムは、長さ &lt;code&gt;sum(colors)&lt;/code&gt; の整数の一時配列を使用します。</target>
        </trans-unit>
        <trans-unit id="701df984a45b35c07efc7a2ab11dc3b2d9004e29" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;four quadrant&amp;rdquo; arctan of the angle formed by (&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;) and the positive &lt;code&gt;x&lt;/code&gt;-axis.</source>
          <target state="translated">（ &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; ）と正の &lt;code&gt;x&lt;/code&gt; 軸によって形成される角度の「4象限」アークタン。</target>
        </trans-unit>
        <trans-unit id="7af7d8f19766359bdf4ea2069305031d08b0663c" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;marginals&amp;rdquo; algorithm generates a variate by using repeated calls to the univariate hypergeometric sampler. It is roughly equivalent to:</source>
          <target state="translated">「周辺」アルゴリズムは、単変量超幾何サンプラーへの繰り返し呼び出しを使用して変量を生成します。これは、次とほぼ同等です。</target>
        </trans-unit>
        <trans-unit id="72e5831aa41d1e2f9af8c987044c60e05af0be5f" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;smart way&amp;rdquo; of wrapping Fortran functions, as explained above, is suitable for wrapping (e.g. third party) Fortran codes for which modifications to their source codes are not desirable nor even possible.</source>
          <target state="translated">上で説明したように、Fortran関数をラップする「スマートな方法」は、ソースコードへの変更が望ましくなく、不可能でさえあるFortranコード（サードパーティなど）をラップするのに適しています。</target>
        </trans-unit>
        <trans-unit id="2adc5d4e116d43dd248737cacbfac03ed3ef63f9" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;y-intercept&amp;rdquo; and &amp;ldquo;slope&amp;rdquo; of the line, respectively.</source>
          <target state="translated">ラインの「y切片」と「勾配」。</target>
        </trans-unit>
        <trans-unit id="e4a0235cef14b392c275cecc105837cde82d5723" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;a&amp;rsquo; variable is unstripped from c[1] because whitespace leading.</source>
          <target state="translated">空白文字が先行しているため、 'a'変数はc [1]から取り除かれます。</target>
        </trans-unit>
        <trans-unit id="bda37a7da4e6885245e567c4fedb24dc646e8a1c" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;out&amp;rsquo; keyword argument is expected to be a tuple with one entry per output (which can be &lt;code&gt;None&lt;/code&gt; for arrays to be allocated by the ufunc). For ufuncs with a single output, passing a single array (instead of a tuple holding a single array) is also valid.</source>
          <target state="translated">'out'キーワード引数は、出力ごとに1つのエントリを持つタプルであることが期待されます（ufuncによって割り当てられる配列の場合は &lt;code&gt;None&lt;/code&gt; にすることができます）。単一の出力を持つufuncの場合、（単一の配列を保持するタプルの代わりに）単一の配列を渡すことも有効です。</target>
        </trans-unit>
        <trans-unit id="db204a13b36f2cf86d7bd1794820137a1ac066ee" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;out&amp;rsquo; keyword argument is expected to be a tuple with one entry per output (which can be None for arrays to be allocated by the ufunc). For ufuncs with a single output, passing a single array (instead of a tuple holding a single array) is also valid.</source>
          <target state="translated">'out'キーワード引数は、出力ごとに1つのエントリを持つタプルであることが期待されます（配列がufuncによって割り当てられる場合はNoneにすることができます）。単一の出力を持つufuncの場合、（単一の配列を保持するタプルの代わりに）単一の配列を渡すことも有効です。</target>
        </trans-unit>
        <trans-unit id="34701f78458bf915d5b828bf9386058d6824fbe4" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;per&amp;rsquo; variable represents the periods of the loan. Remember that financial equations start the period count at 1!</source>
          <target state="translated">「per」変数はローンの期間を表します。財務方程式は期間カウントを1から開始することを忘れないでください！</target>
        </trans-unit>
        <trans-unit id="cb090179fdd970838b19c1b214a4530cfcd16ee3" translate="yes" xml:space="preserve">
          <source>The (non-conjugated) transpose of the matrix.</source>
          <target state="translated">行列の(非共役の)転置。</target>
        </trans-unit>
        <trans-unit id="2c0a3ac18c0e35ff547f3a4005419b0e018f9e8e" translate="yes" xml:space="preserve">
          <source>The 1.6 implementation of datetime does not convert between units correctly.:</source>
          <target state="translated">1.6 の datetime の実装では、単位間の変換が正しく行われませんでした。</target>
        </trans-unit>
        <trans-unit id="f72725eb7318a896f41cd0cf447d8c91f324fb0d" translate="yes" xml:space="preserve">
          <source>The 1.6 implementation of datetime only works correctly for a small subset of arithmetic operations. Here we show some simple cases.:</source>
          <target state="translated">datetimeの1.6の実装は、算術演算の小さなサブセットに対してのみ正しく動作します。ここでは、いくつかの簡単なケースを示します。</target>
        </trans-unit>
        <trans-unit id="887cfe3b8a793575511e5fe48982dbd8c7813d6e" translate="yes" xml:space="preserve">
          <source>The 2-D output array.</source>
          <target state="translated">2次元出力配列です。</target>
        </trans-unit>
        <trans-unit id="8d40d72287619706da0622aa60cf9b527faa81be" translate="yes" xml:space="preserve">
          <source>The 24 built-in &lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;array scalar type objects&lt;/a&gt; all convert to an associated data-type object. This is true for their sub-classes as well.</source>
          <target state="translated">24個の組み込み&lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;配列スカラー型オブジェクトは&lt;/a&gt;すべて、関連するデータ型オブジェクトに変換されます。これは、サブクラスにも当てはまります。</target>
        </trans-unit>
        <trans-unit id="3182f1dfa2639174f8b34fe5f092a96393f1cf6d" translate="yes" xml:space="preserve">
          <source>The 64-bit OpenBLAS with &lt;code&gt;64_&lt;/code&gt; symbol suffix is obtained by compiling OpenBLAS with settings:</source>
          <target state="translated">&lt;code&gt;64_&lt;/code&gt; シンボルサフィックスが付いた64ビットOpenBLASは、OpenBLASを次の設定でコンパイルすることによって取得されます。</target>
        </trans-unit>
        <trans-unit id="44abfc0b778e06539587a775fdc8b33ee9085231" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; array flags can be &amp;ldquo;calculated&amp;rdquo; from the array object itself. This routine updates one or more of these flags of &lt;em&gt;arr&lt;/em&gt; as specified in &lt;em&gt;flagmask&lt;/em&gt; by performing the required calculation.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;、及び&lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;アレイフラグは配列オブジェクト自体から「計算」することができます。このルーチンは、必要な計算を実行することにより、&lt;em&gt;flagmaskで&lt;/em&gt;指定された&lt;em&gt;arr&lt;/em&gt;のこれらのフラグの1つ以上を更新します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5ab1d9e20a833c167142777c07717d8769b7541" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; is the built-in type of the data-type-descriptor objects used to describe how the bytes comprising the array are to be interpreted. There are 21 statically-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects for the built-in data-types. While these participate in reference counting, their reference count should never reach zero. There is also a dynamic table of user-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects that is also maintained. Once a data-type-descriptor object is &amp;ldquo;registered&amp;rdquo; it should never be deallocated either. The function &lt;a href=&quot;array#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to retrieve a &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object from an enumerated type-number (either built-in or user- defined).</source>
          <target state="translated">&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; は、&lt;/a&gt;組み込みデータ型の記述子のタイプは、アレイを含むバイトが解釈される方法を記述するのに使用されるオブジェクトです。組み込みデータ型用に静的に定義された21&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;オブジェクトがあります。これらは参照カウントに参加しますが、参照カウントがゼロに達することはありません。また、維持されるユーザー定義の&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;オブジェクトの動的テーブルもあります。データ型記述子オブジェクトが「登録」されると、割り当てを解除することもできません。関数&lt;a href=&quot;array#c.PyArray_DescrFromType&quot;&gt; &lt;code&gt;PyArray_DescrFromType&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）を使用して、列挙型番号（組み込みまたはユーザー定義）から&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;オブジェクトを取得できます。</target>
        </trans-unit>
        <trans-unit id="83e501c171dddeb86862ef16beddd704b5bc114a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; is the built-in type of the data-type-descriptor objects used to describe how the bytes comprising the array are to be interpreted. There are 21 statically-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects for the built-in data-types. While these participate in reference counting, their reference count should never reach zero. There is also a dynamic table of user-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects that is also maintained. Once a data-type-descriptor object is &amp;ldquo;registered&amp;rdquo; it should never be deallocated either. The function &lt;a href=&quot;c-api.array#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to retrieve a &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object from an enumerated type-number (either built-in or user- defined).</source>
          <target state="translated">&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; は、&lt;/a&gt;組み込みデータ型の記述子のタイプは、アレイを含むバイトが解釈される方法を記述するのに使用されるオブジェクトです。組み込みのデータ型には21の静的に定義された&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;オブジェクトがあります。これらは参照カウントに参加していますが、参照カウントがゼロになることはありません。また、維持されているユーザー定義の&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;オブジェクトの動的テーブルもあります。 data-type-descriptorオブジェクトが「登録」されると、割り当て解除することはできません。関数&lt;a href=&quot;c-api.array#c.PyArray_DescrFromType&quot;&gt; &lt;code&gt;PyArray_DescrFromType&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）を使用して、列挙されたtype-number（組み込みまたはユーザー定義のいずれか）から&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;オブジェクトを取得できます。</target>
        </trans-unit>
        <trans-unit id="3bd6fb4bf6c794847df919e4e53f9f40e8a12e37" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure is defined so that NumPy and other extension modules can use the rapid array interface protocol. The &lt;code&gt;__array_struct__&lt;/code&gt; method of an object that supports the rapid array interface protocol should return a &lt;code&gt;PyCObject&lt;/code&gt; that contains a pointer to a &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure with the relevant details of the array. After the new array is created, the attribute should be &lt;code&gt;DECREF&lt;/code&gt;&amp;rsquo;d which will free the &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure. Remember to &lt;code&gt;INCREF&lt;/code&gt; the object (whose &lt;code&gt;__array_struct__&lt;/code&gt; attribute was retrieved) and point the base member of the new &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; to this same object. In this way the memory for the array will be managed correctly.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; の&lt;/a&gt; numpyの及び他の拡張モジュールが急速配列インタフェースプロトコルを使用することができるように構造が定義されています。高速配列インターフェースプロトコルをサポートするオブジェクトの &lt;code&gt;__array_struct__&lt;/code&gt; メソッドは、配列の関連詳細を含む&lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;構造へのポインターを含む &lt;code&gt;PyCObject&lt;/code&gt; を返す必要があります。新しい配列が作成された後、&lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;構造を解放する属性を &lt;code&gt;DECREF&lt;/code&gt; する必要があります。覚え &lt;code&gt;INCREF&lt;/code&gt; （そのオブジェクト &lt;code&gt;__array_struct__&lt;/code&gt; 属性取得された）と新規のベース部材ポイント&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; を&lt;/a&gt;この同じオブジェクトに。このようにして、アレイのメモリは正しく管理されます。</target>
        </trans-unit>
        <trans-unit id="cd84e3bef1191839ce6ab3739e785dd2e1559188" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; C-structure contains all of the required information for an array. All instances of an ndarray (and its subclasses) will have this structure. For future compatibility, these structure members should normally be accessed using the provided macros. If you need a shorter name, then you can make use of &lt;code&gt;NPY_AO&lt;/code&gt; (deprecated) which is defined to be equivalent to &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; C-構造は、アレイに必要な情報のすべてを含みます。ndarray（およびそのサブクラス）のすべてのインスタンスは、この構造になります。将来の互換性のために、これらの構造体メンバーは通常、提供されたマクロを使用してアクセスする必要があります。あなたは短い名前が必要な場合は、利用することができ &lt;code&gt;NPY_AO&lt;/code&gt; と同等になるように定義されている（非推奨）&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef190e5abe2d8e5d647d302d7a90a94792c8ed21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; C-structure contains all of the required information for an array. All instances of an ndarray (and its subclasses) will have this structure. For future compatibility, these structure members should normally be accessed using the provided macros. If you need a shorter name, then you can make use of &lt;code&gt;NPY_AO&lt;/code&gt; (deprecated) which is defined to be equivalent to &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;. Direct access to the struct fields are deprecated. Use the &lt;code&gt;PyArray_*(arr)&lt;/code&gt; form instead.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; C-構造は、アレイに必要な情報のすべてを含みます。ndarray（およびそのサブクラス）のすべてのインスタンスは、この構造になります。将来の互換性のために、これらの構造体メンバーは通常、提供されたマクロを使用してアクセスする必要があります。あなたは短い名前が必要な場合は、利用することができ &lt;code&gt;NPY_AO&lt;/code&gt; と同等になるように定義されている（非推奨）&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;。構造体フィールドへの直接アクセスは非推奨です。代わりに、 &lt;code&gt;PyArray_*(arr)&lt;/code&gt; フォームを使用してください。</target>
        </trans-unit>
        <trans-unit id="9d2c044849f6b8be8bb6f06a8ac4ced885f369cf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure lies at the heart of the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt;. While it is described here for completeness, it should be considered internal to NumPy and manipulated via &lt;code&gt;PyArrayDescr_*&lt;/code&gt; or &lt;code&gt;PyDataType*&lt;/code&gt; functions and macros. The size of this structure is subject to change across versions of NumPy. To ensure compatibility:</source>
          <target state="translated">&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; の&lt;/a&gt;構造はの中心に位置&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt;。完全を &lt;code&gt;PyArrayDescr_*&lt;/code&gt; ためにここで説明しますが、NumPyの内部と見なして、PyArrayDescr_ *または &lt;code&gt;PyDataType*&lt;/code&gt; 関数とマクロを介して操作する必要があります。この構造のサイズは、NumPyのバージョン間で変更される可能性があります。互換性を確保するには：</target>
        </trans-unit>
        <trans-unit id="2e3e60e01ee7ee0a4514d09bc8a1e601d0467625" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; typeobject implements many of the features of &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyTypeObject&quot;&gt;&lt;code&gt;Python objects&lt;/code&gt;&lt;/a&gt; including the &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_number&quot;&gt;&lt;code&gt;tp_as_number&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_sequence&quot;&gt;&lt;code&gt;tp_as_sequence&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_mapping&quot;&gt;&lt;code&gt;tp_as_mapping&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_buffer&quot;&gt;&lt;code&gt;tp_as_buffer&lt;/code&gt;&lt;/a&gt; interfaces. The &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.richcmpfunc&quot;&gt;&lt;code&gt;rich comparison&lt;/code&gt;&lt;/a&gt;) is also used along with new-style attribute lookup for member (&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_members&quot;&gt;&lt;code&gt;tp_members&lt;/code&gt;&lt;/a&gt;) and properties (&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_getset&quot;&gt;&lt;code&gt;tp_getset&lt;/code&gt;&lt;/a&gt;). The &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; can also be sub-typed.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; の&lt;/a&gt; typeobject器具の機能の多く&lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyTypeObject&quot;&gt; &lt;code&gt;Python objects&lt;/code&gt; &lt;/a&gt;を含む&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_number&quot;&gt; &lt;code&gt;tp_as_number&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_sequence&quot;&gt; &lt;code&gt;tp_as_sequence&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_mapping&quot;&gt; &lt;code&gt;tp_as_mapping&lt;/code&gt; &lt;/a&gt;、及び&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_buffer&quot;&gt; &lt;code&gt;tp_as_buffer&lt;/code&gt; の&lt;/a&gt;インターフェース。&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.richcmpfunc&quot;&gt; &lt;code&gt;rich comparison&lt;/code&gt; &lt;/a&gt;）また、新しいスタイルの属性メンバ（のルックアップと一緒に使用され&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_members&quot;&gt; &lt;code&gt;tp_members&lt;/code&gt; &lt;/a&gt;）とプロパティ（&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_getset&quot;&gt; &lt;code&gt;tp_getset&lt;/code&gt; &lt;/a&gt;）。&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; は&lt;/a&gt;、サブ入力することもできます。</target>
        </trans-unit>
        <trans-unit id="aa6c6f999e9bb42f4a925a834755e66032534d3b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.bitgen_t&quot;&gt;&lt;code&gt;bitgen_t&lt;/code&gt;&lt;/a&gt; holds the current state of the BitGenerator and pointers to functions that return standard C types while advancing the state.</source>
          <target state="translated">&lt;a href=&quot;#c.bitgen_t&quot;&gt; &lt;code&gt;bitgen_t&lt;/code&gt; は、&lt;/a&gt;状態を進めながら、標準的なC型を返す関数にBitGeneratorとポインタの現在の状態を保持します。</target>
        </trans-unit>
        <trans-unit id="f2f36b5d156bf75520af226984583d62ec445b7c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module provides a set of vectorized string operations for arrays of type &lt;code&gt;numpy.string_&lt;/code&gt; or &lt;code&gt;numpy.unicode_&lt;/code&gt;. All of them are based on the string methods in the Python standard library.</source>
          <target state="translated">&lt;a href=&quot;#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; の&lt;/a&gt;モジュールは、型の配列のためのベクトル化文字列操作のセット提供 &lt;code&gt;numpy.string_&lt;/code&gt; 又は &lt;code&gt;numpy.unicode_&lt;/code&gt; を。これらはすべて、Python標準ライブラリの文字列メソッドに基づいています。</target>
        </trans-unit>
        <trans-unit id="2314014335c763a38d9f2613dc7158883ea47e7a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module can be used as an addition to &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; の&lt;/a&gt;モジュールへの追加として使用することができる&lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; の&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc31921d14e06fe1077c1cf00e508c39081a2db7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module comes with a specific implementation of most ufuncs. Unary and binary functions that have a validity domain (such as &lt;a href=&quot;generated/numpy.log#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.divide#numpy.divide&quot;&gt;&lt;code&gt;divide&lt;/code&gt;&lt;/a&gt;) return the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; constant whenever the input is masked or falls outside the validity domain:</source>
          <target state="translated">&lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; の&lt;/a&gt;モジュールは、ほとんどのufuncsの具体的な実装が付属しています。有効性ドメイン（&lt;a href=&quot;generated/numpy.log#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;generated/numpy.divide#numpy.divide&quot;&gt; &lt;code&gt;divide&lt;/code&gt; など&lt;/a&gt;）を持つ単項関数とバイナリ関数は、入力がマスクされるか、有効性ドメインの外にある場合は常に、&lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt;定数を返します。</target>
        </trans-unit>
        <trans-unit id="b2581729cb5a508c4225155bce5e9d0c211d34fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">&lt;a href=&quot;#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;クラスはNumarrayとの後方互換性のために存在し、それが新たな開発のために推奨されていません。numpy 1.4以降、文字列の配列が必要な場合は、&lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; 、 &lt;code&gt;string_&lt;/code&gt; または &lt;code&gt;unicode_&lt;/code&gt; の配列を使用し、&lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt;モジュールの無料の関数を使用して高速ベクトル化された文字列操作を行うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="bfd56b98bdff55bc0967f4255e8d608e0cada88c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.char.chararray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.char.chararray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;オブジェクトは、辞書のように（同様にアクセスすることができる &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ）、または（同様に小文字の属性名を使用して &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短いフラグ名は、辞書アクセスでのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="5b3e9186bfdffbf3c12bbb5a751b0411b0862a0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">&lt;a href=&quot;#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;クラスはNumarrayとの後方互換性のために存在し、それが新たな開発のために推奨されていません。numpy 1.4以降、文字列の配列が必要な場合は、&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; 、 &lt;code&gt;string_&lt;/code&gt; または &lt;code&gt;unicode_&lt;/code&gt; の配列を使用し、&lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt;モジュールの無料の関数を使用して高速ベクトル化された文字列操作を行うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="680a1891b2c8f5bcdb98b3e8673e99320813b4a5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.chararray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.chararray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;オブジェクトは、辞書のように（同様にアクセスすることができる &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ）、または（同様に小文字の属性名を使用して &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短いフラグ名は、辞書アクセスでのみサポートされます。</target>
        </trans-unit>
        <trans-unit id="3c48c115471617c80e93a7432dc970b4f61e8b90" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.MaskedArray.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt;, as a regular &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt; of any shape or datatype (the data).</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.MaskedArray.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt;正規として、&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt;任意の形状またはデータ型（データ）。</target>
        </trans-unit>
        <trans-unit id="a0df6452154474f3f899180d65ac301d22c1fea9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.MaskedArray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.MaskedArray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;オブジェクトは、辞書のように（同様にアクセスすることができる &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ）、または（同様に小文字の属性名を使用して &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短いフラグ名は、辞書アクセスでのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="768878a0d288c4cac805d022d60e3e5c74cdd571" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; constant is a special case of &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, with a float datatype and a null shape. It is used to test whether a specific entry of a masked array is masked, or to mask one or several entries of a masked array:</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt;定数は、特殊なケースである&lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;フロートデータ型及びヌル形状を有します。これは、マスクされた配列の特定のエントリがマスクされているかどうかをテストするため、またはマスクされた配列の1つまたは複数のエントリをマスクするために使用されます。</target>
        </trans-unit>
        <trans-unit id="7aed7dc2945cfed4e354b7948f5becc4b487bdfa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.masked_array.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.masked_array.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;オブジェクトは、辞書のように（同様にアクセスすることができる &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ）、または（同様に小文字の属性名を使用して &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短いフラグ名は、辞書アクセスでのみサポートされます。</target>
        </trans-unit>
        <trans-unit id="146a5b50c3ebb2fb745630d24192949df345a171" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.matrix.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.matrix.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;オブジェクトは、辞書のように（同様にアクセスすることができる &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ）、または（同様に小文字の属性名を使用して &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短いフラグ名は、辞書アクセスでのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="3f13797b1afe52954d80b3598ced06b92d07000d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.memmap.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.memmap.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;オブジェクトは、辞書のように（同様にアクセスすることができる &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ）、または（同様に小文字の属性名を使用して &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短いフラグ名は、辞書アクセスでのみサポートされます。</target>
        </trans-unit>
        <trans-unit id="59336961ce31b9039ac38b42d5319606fa0f917b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ndarray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ndarray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;オブジェクトは、辞書のように（同様にアクセスすることができる &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ）、または（同様に小文字の属性名を使用して &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短いフラグ名は、辞書アクセスでのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="6d0bd00bbf169f78d9e7d2f8db44466c1472859d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; provides access to a wide range of distributions, and served as a replacement for &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. The main difference between the two is that &lt;code&gt;Generator&lt;/code&gt; relies on an additional BitGenerator to manage state and generate the random bits, which are then transformed into random values from useful distributions. The default BitGenerator used by &lt;code&gt;Generator&lt;/code&gt; is &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt;. The BitGenerator can be changed by passing an instantized BitGenerator to &lt;code&gt;Generator&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;ディストリビューションの広い範囲へのアクセスを提供し、そしてのための代替を務め&lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;。 2つの主な違いは、 &lt;code&gt;Generator&lt;/code&gt; が追加のBitGeneratorに依存して状態を管理し、ランダムビットを生成し、それらが有用な分布からランダム値に変換されることです。 &lt;code&gt;Generator&lt;/code&gt; で使用されるデフォルトのBitGeneratorは&lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;です。 BitGeneratorは、インスタンス化されたBitGeneratorを &lt;code&gt;Generator&lt;/code&gt; に渡すことで変更できます。</target>
        </trans-unit>
        <trans-unit id="550894140eb6b413b0c8bb49cded0a5d50198b4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; provides access to a wide range of distributions, and served as a replacement for &lt;code&gt;RandomState&lt;/code&gt;. The main difference between the two is that &lt;code&gt;Generator&lt;/code&gt; relies on an additional BitGenerator to manage state and generate the random bits, which are then transformed into random values from useful distributions. The default BitGenerator used by &lt;code&gt;Generator&lt;/code&gt; is &lt;code&gt;PCG64&lt;/code&gt;. The BitGenerator can be changed by passing an instantized BitGenerator to &lt;code&gt;Generator&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;ディストリビューションの広い範囲へのアクセスを提供し、そしてのための代替を務め &lt;code&gt;RandomState&lt;/code&gt; 。 2つの主な違いは、 &lt;code&gt;Generator&lt;/code&gt; が追加のBitGeneratorに依存して状態を管理し、ランダムビットを生成することです。ランダムビットは、有用な分布からランダムな値に変換されます。 &lt;code&gt;Generator&lt;/code&gt; で使用されるデフォルトのBitGenerator は &lt;code&gt;PCG64&lt;/code&gt; です。 BitGeneratorは、インスタンス化されたBitGeneratorを &lt;code&gt;Generator&lt;/code&gt; に渡すことで変更できます。</target>
        </trans-unit>
        <trans-unit id="f79d27f6e9c849366cec196aa3ca02a3888f3ef3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; provides access to legacy generators. This generator is considered frozen and will have no further improvements. It is guaranteed to produce the same values as the final point release of NumPy v1.16. These all depend on Box-Muller normals or inverse CDF exponentials or gammas. This class should only be used if it is essential to have randoms that are identical to what would have been produced by previous versions of NumPy.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; は、&lt;/a&gt;従来の発電機へのアクセスを提供します。このジェネレーターは凍結されていると見なされ、それ以上の改善はありません。NumPyv1.16の最終ポイントリリースと同じ値を生成することが保証されています。これらはすべて、ボックスミュラー法線または逆CDF指数またはガンマに依存します。このクラスは、以前のバージョンのNumPyで生成されたものと同じランダムを使用することが不可欠な場合にのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="c4a823e24105a263472e6db5aa11ef1abc5d69b0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; provides access to legacy generators. This generator is considered frozen and will have no further improvements. It is guaranteed to produce the same values as the final point release of NumPy v1.16. These all depend on Box-Muller normals or inverse CDF exponentials or gammas. This class should only be used if it is essential to have randoms that are identical to what would have been produced by previous versions of NumPy.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; は、&lt;/a&gt;従来の発電機へのアクセスを提供します。このジェネレーターはフリーズされていると見なされ、これ以上の改善はありません。NumPy v1.16の最終ポイントリリースと同じ値が生成されることが保証されています。これらはすべて、Box-Muller法線または逆CDF指数またはガンマに依存します。このクラスは、以前のバージョンのNumPyによって生成されたものと同一の乱数を持つことが不可欠である場合にのみ使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="81979ac862ad90b476e52b55f8477208f98b95b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.recarray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.recarray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;オブジェクトは、辞書のように（同様にアクセスすることができる &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ）、または（同様に小文字の属性名を使用して &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短いフラグ名は、辞書アクセスでのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="84da36ced33272fa147152f5a355ea7313e10b52" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.sign&quot;&gt;&lt;code&gt;sign&lt;/code&gt;&lt;/a&gt; function returns &lt;code&gt;-1 if x &amp;lt; 0, 0 if x==0, 1 if x &amp;gt; 0&lt;/code&gt;. nan is returned for nan inputs.</source>
          <target state="translated">&lt;a href=&quot;#numpy.sign&quot;&gt; &lt;code&gt;sign&lt;/code&gt; &lt;/a&gt;関数戻り &lt;code&gt;-1 if x &amp;lt; 0, 0 if x==0, 1 if x &amp;gt; 0&lt;/code&gt; 。nanは、nan入力に対して返されます。</target>
        </trans-unit>
        <trans-unit id="158d36e54da803a47a7693e104765168fbd40d0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.testing.dec.deprecated&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt; decorator itself.</source>
          <target state="translated">&lt;a href=&quot;#numpy.testing.dec.deprecated&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt;デコレータ自体。</target>
        </trans-unit>
        <trans-unit id="c8f5bdf7e480a14edfbd94978da2fd35d2b6fd26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.testing.decorators.deprecated&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt; decorator itself.</source>
          <target state="translated">&lt;a href=&quot;#numpy.testing.decorators.deprecated&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt;デコレータ自体。</target>
        </trans-unit>
        <trans-unit id="f00c158e6b19c749648df9ba6c6e65d03c7d496b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.vectorize&quot;&gt;&lt;code&gt;vectorize&lt;/code&gt;&lt;/a&gt; function is provided primarily for convenience, not for performance. The implementation is essentially a for loop.</source>
          <target state="translated">&lt;a href=&quot;#numpy.vectorize&quot;&gt; &lt;code&gt;vectorize&lt;/code&gt; &lt;/a&gt;機能はありません、パフォーマンスのために、主に便宜のために提供されます。実装は基本的にforループです。</target>
        </trans-unit>
        <trans-unit id="5870961c86339efdff46c3532a51705af2f592f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;datetime unit&lt;/a&gt; on which this dtype is based.</source>
          <target state="translated">&lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;日時単位&lt;/a&gt;このDTYPEが基づいています。</target>
        </trans-unit>
        <trans-unit id="3bf8c2953924a9568aac6e665e279dc1312c55ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/c-api/array#c.PyArray_IterAllButAxis&quot;&gt;&lt;code&gt;PyArray_IterAllButAxis&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;array&lt;/code&gt;, &lt;code&gt;&amp;amp;dim&lt;/code&gt; ) constructs an iterator object that is modified so that it will not iterate over the dimension indicated by dim. The only restriction on this iterator object, is that the &lt;code&gt;PyArray_Iter_GOTO1D&lt;/code&gt; ( &lt;code&gt;it&lt;/code&gt;, &lt;code&gt;ind&lt;/code&gt; ) macro cannot be used (thus flat indexing won&amp;rsquo;t work either if you pass this object back to Python &amp;mdash; so you shouldn&amp;rsquo;t do this). Note that the returned object from this routine is still usually cast to PyArrayIterObject *. All that&amp;rsquo;s been done is to modify the strides and dimensions of the returned iterator to simulate iterating over array[&amp;hellip;,0,&amp;hellip;] where 0 is placed on the</source>
          <target state="translated">&lt;a href=&quot;../reference/c-api/array#c.PyArray_IterAllButAxis&quot;&gt; &lt;code&gt;PyArray_IterAllButAxis&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;array&lt;/code&gt; 、 &lt;code&gt;&amp;amp;dim&lt;/code&gt; ）、それは寸法がDIMで示される反復処理しないように改変されたイテレータオブジェクトを構築します。このイテレータオブジェクトの唯一の制限は、 &lt;code&gt;PyArray_Iter_GOTO1D&lt;/code&gt; （ &lt;code&gt;it&lt;/code&gt; 、 &lt;code&gt;ind&lt;/code&gt; ）マクロを使用できないことです（したがって、このオブジェクトをPythonに戻すと、フラットインデックスも機能しません。したがって、これを行うべきではありません）。このルーチンから返されるオブジェクトは、通常もPyArrayIterObject *にキャストされることに注意してください。行われたのは、返されたイテレータのストライドと次元を変更して、配列[&amp;hellip;、0、&amp;hellip;]の反復をシミュレートすることだけです。ここで、0は</target>
        </trans-unit>
        <trans-unit id="26c941be06c3bf21e3b8632eab293bedde5eb0c6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; function can be used to combine different vectors so as to obtain the result for each n-uplet. For example, if you want to compute all the a+b*c for all the triplets taken from each of the vectors a, b and c:</source>
          <target state="translated">&lt;a href=&quot;../reference/generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt;関数は、それぞれのn-upletのための結果を得るように異なるベクターを結合するために使用することができます。たとえば、ベクトルa、b、cのそれぞれから取得したすべてのトリプレットのすべてのa + b * cを計算する場合は次のようになります。</target>
        </trans-unit>
        <trans-unit id="7647b692ad78d569f80f8f518b4edab8e65fa5cd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/generated/numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;reshape&lt;/code&gt;&lt;/a&gt; function returns its argument with a modified shape, whereas the &lt;a href=&quot;../reference/generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt;&lt;code&gt;ndarray.resize&lt;/code&gt;&lt;/a&gt; method modifies the array itself:</source>
          <target state="translated">&lt;a href=&quot;../reference/generated/numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;reshape&lt;/code&gt; &lt;/a&gt;一方関数は、修飾された形状とその引数を返す&lt;a href=&quot;../reference/generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt; &lt;code&gt;ndarray.resize&lt;/code&gt; &lt;/a&gt;方法は、アレイ自体を変更します。</target>
        </trans-unit>
        <trans-unit id="28dfdb3c00777ce3fdb3f61c50c67ab257910e81" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/routines.linalg#module-numpy.linalg&quot;&gt;&lt;code&gt;linalg&lt;/code&gt;&lt;/a&gt; module includes a &lt;code&gt;norm&lt;/code&gt; function, which computes the norm of a vector or matrix represented in a NumPy array. For example, from the SVD explanation above, we would expect the norm of the difference between &lt;code&gt;img_gray&lt;/code&gt; and the reconstructed SVD product to be small. As expected, you should see something like</source>
          <target state="translated">&lt;a href=&quot;../reference/routines.linalg#module-numpy.linalg&quot;&gt; &lt;code&gt;linalg&lt;/code&gt; の&lt;/a&gt;モジュールは、 &lt;code&gt;norm&lt;/code&gt; numpyの配列で表され、ベクトルまたは行列のノルムを計算する関数を、。たとえば、上記のSVDの説明から、 &lt;code&gt;img_gray&lt;/code&gt; と再構成されたSVD積の差のノルムは小さいと予想されます。予想通り、次のようなものが表示されます</target>
        </trans-unit>
        <trans-unit id="a98bd2e9d383259ba90aad2f3b46a4c0ddbbec99" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../routines.testing#module-numpy.testing&quot;&gt;&lt;code&gt;numpy.testing&lt;/code&gt;&lt;/a&gt; module includes &lt;code&gt;import decorators as dec&lt;/code&gt;. A test can be decorated as slow like this:</source>
          <target state="translated">&lt;a href=&quot;../routines.testing#module-numpy.testing&quot;&gt; &lt;code&gt;numpy.testing&lt;/code&gt; の&lt;/a&gt;モジュールは、 &lt;code&gt;import decorators as dec&lt;/code&gt; 。テストは次のように遅くなるように装飾できます：</target>
        </trans-unit>
        <trans-unit id="081ce1a530a1e04a18f2e8f054e26ae81b0c4d57" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; has a limited set of responsibilities. It manages state and provides functions to produce random doubles and random unsigned 32- and 64-bit values.</source>
          <target state="translated">&lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; は、&lt;/a&gt;責任の限定セットを持っています。状態を管理し、ランダムなdoubleとランダムな符号なし32ビットおよび64ビット値を生成する関数を提供します。</target>
        </trans-unit>
        <trans-unit id="c4d94d478ef39d11efc586cafc38818b04af19cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt; function takes the iterators that have already been defined and uses them to determine the broadcast shape in each dimension (to create the iterators at the same time that broadcasting occurs then use the &lt;code&gt;PyMultiIter_New&lt;/code&gt; function). Then, the iterators are adjusted so that each iterator thinks it is iterating over an array with the broadcast size. This is done by adjusting the iterators number of dimensions, and the shape in each dimension. This works because the iterator strides are also adjusted. Broadcasting only adjusts (or adds) length-1 dimensions. For these dimensions, the strides variable is simply set to 0 so that the data-pointer for the iterator over that array doesn&amp;rsquo;t move as the broadcasting operation operates over the extended dimension.</source>
          <target state="translated">&lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; の&lt;/a&gt;機能は、既に定義されているイテレータを取り、（放送が次に使用発生と同時にイテレータを作成するために、各次元における放送形状を決定するためにそれらを使用 &lt;code&gt;PyMultiIter_New&lt;/code&gt; の機能）。次に、各イテレータがブロードキャストサイズの配列を反復していると各イテレータが考えるように、イテレータが調整されます。これは、反復子の次元数、および各次元の形状を調整することによって行われます。これは、反復子のストライドも調整されるため機能します。ブロードキャストでは、長さ1の寸法のみが調整（または追加）されます。これらの次元の場合、ストライド変数は単に0に設定されるため、その配列に対するイテレーターのデータポインターは、ブロードキャスト操作が拡張次元で動作するときに移動しません。</target>
        </trans-unit>
        <trans-unit id="725a4957fd19b096134c24b6194f54dd74c72c01" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt; function takes the iterators that have already been defined and uses them to determine the broadcast shape in each dimension (to create the iterators at the same time that broadcasting occurs then use the &lt;code&gt;PyMultiIter_New&lt;/code&gt; function). Then, the iterators are adjusted so that each iterator thinks it is iterating over an array with the broadcast size. This is done by adjusting the iterators number of dimensions, and the shape in each dimension. This works because the iterator strides are also adjusted. Broadcasting only adjusts (or adds) length-1 dimensions. For these dimensions, the strides variable is simply set to 0 so that the data-pointer for the iterator over that array doesn&amp;rsquo;t move as the broadcasting operation operates over the extended dimension.</source>
          <target state="translated">&lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; の&lt;/a&gt;機能は、既に定義されているイテレータを取り、（放送が次に使用発生と同時にイテレータを作成するために、各次元における放送形状を決定するためにそれらを使用 &lt;code&gt;PyMultiIter_New&lt;/code&gt; の機能）。次に、各イテレータがブロードキャストサイズの配列を反復していると見なすように、イテレータが調整されます。これは、イテレータの次元数と各次元の形状を調整することによって行われます。これは、イテレータのストライドも調整されるため機能します。ブロードキャストは、長さ1の次元のみを調整（または追加）します。これらの次元の場合、strides変数は単純に0に設定されるため、ブロードキャスト操作が拡張次元で動作するときに、その配列上のイテレーターのデータポインターは移動しません。</target>
        </trans-unit>
        <trans-unit id="d36f842f2997c8193b726b30df3debd673ecb729" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object can be used in all slicing operations to create an axis of length one. &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; is an alias for &amp;lsquo;None&amp;rsquo;, and &amp;lsquo;None&amp;rsquo; can be used in place of this with the same result.</source>
          <target state="translated">&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; の&lt;/a&gt;オブジェクトは、長さ1の軸線を作成するために、すべてのスライス操作で使用することができます。&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;は 'None'のエイリアスであり、これの代わりに 'None'を使用しても同じ結果になります。</target>
        </trans-unit>
        <trans-unit id="149f4058a1754093961b02f9ea6b9d5dd9c10925" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;クラスはNumarrayとの後方互換性のために存在し、それが新たな開発のために推奨されていません。numpy 1.4以降、文字列の配列が必要な場合は、&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; 、 &lt;code&gt;string_&lt;/code&gt; または &lt;code&gt;unicode_&lt;/code&gt; の配列を使用し、&lt;a href=&quot;routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt;モジュールの無料の関数を使用して高速ベクトル化された文字列操作を行うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f9537bf435fae2ec4edc2520b8aeb23abd0ca21e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; can be inherited from (in Python or in C) if desired. Therefore, it can form a foundation for many useful classes. Often whether to sub-class the array object or to simply use the core array component as an internal part of a new class is a difficult decision, and can be simply a matter of choice. NumPy has several tools for simplifying how your new object interacts with other array objects, and so the choice may not be significant in the end. One way to simplify the question is by asking yourself if the object you are interested in can be replaced as a single array or does it really require two or more arrays at its core.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; は、&lt;/a&gt;所望であれば、（PythonでまたはC）から継承することができます。したがって、多くの有用なクラスの基礎を形成できます。多くの場合、配列オブジェクトをサブクラス化するか、単にコア配列コンポーネントを新しいクラスの内部部分として使用するかは難しい決定であり、単に選択の問題にすぎません。 NumPyには、新しいオブジェクトが他の配列オブジェクトとどのように相互作用するかを簡略化するためのツールがいくつかあります。そのため、最終的には重要な選択ではない場合があります。質問を簡単にする1つの方法は、関心のあるオブジェクトを単一の配列として置き換えることができるか、それともコアに2つ以上の配列が本当に必要かどうかを自問することです。</target>
        </trans-unit>
        <trans-unit id="c0cd171dc2a149543f352698d4bc596e7f8afac8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; will try to provide chunks that are as large as possible to the inner loop. By forcing &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; order, we get different external loop sizes. This mode is enabled by specifying an iterator flag.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; は、&lt;/a&gt;内側のループにできるだけ大きい塊を提供しようとします。「C」と「F」の順序を強制することにより、異なる外部ループサイズが得られます。このモードは、反復子フラグを指定することで有効になります。</target>
        </trans-unit>
        <trans-unit id="60bea32ad7ce3442c75308b468830ac8ceb23fe9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; is the user-facing object that is nearly identical to &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. The canonical method to initialize a generator passes a &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; bit generator as the sole argument.</source>
          <target state="translated">&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;とほぼ同じであるユーザー向けのオブジェクトである&lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;。ジェネレーターを初期化する標準的なメソッドは、&lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;ビットジェネレーターを唯一の引数として渡します。</target>
        </trans-unit>
        <trans-unit id="f0287b2a9be936e86bf33e5d1e69557ad4042b14" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; is the user-facing object that is nearly identical to &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. The canonical method to initialize a generator passes a &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; bit generator as the sole argument.</source>
          <target state="translated">&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;とほぼ同じであるユーザー向けのオブジェクトである&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;。ジェネレーターを初期化する標準的な方法では、&lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;ビットジェネレーターを唯一の引数として渡します。</target>
        </trans-unit>
        <trans-unit id="a44536d85a990a438123d796af5725162190334f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;random generator&lt;/code&gt;&lt;/a&gt; takes the bit generator-provided stream and transforms them into more useful distributions, e.g., simulated normal random values. This structure allows alternative bit generators to be used with little code duplication.</source>
          <target state="translated">&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;random generator&lt;/code&gt; &lt;/a&gt;、通常のランダムな値をシミュレートし、例えば、ビットジェネレータが提供するストリームを取り、より有用ディストリビューションにそれらを変換します。この構造により、コードの重複がほとんどなく、代替ビットジェネレーターを使用できます。</target>
        </trans-unit>
        <trans-unit id="65fbb3e3590895ec54d650742d5a8544c871fca6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tom.preston-werner.com/2009/05/19/the-git-parable.html&quot;&gt;git parable&lt;/a&gt; is an easy read explaining the concepts behind git.</source>
          <target state="translated">&lt;a href=&quot;http://tom.preston-werner.com/2009/05/19/the-git-parable.html&quot;&gt;gitの寓話は、&lt;/a&gt; gitの背後にある概念を説明する簡単な読み取りです。</target>
        </trans-unit>
        <trans-unit id="f7f755efceb36d8200d20dc31c04e76cd3c9faf2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; type checking and conversion system is a complicated combination of C macros, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; macros, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; typemaps and &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; fragments. Fragments are a way to conditionally insert code into your wrapper file if it is needed, and not insert it if not needed. If multiple typemaps require the same fragment, the fragment only gets inserted into your wrapper code once.</source>
          <target state="translated">&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIGの&lt;/a&gt;型チェックと変換システムは、Cマクロの複雑な組み合わせです&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIGの&lt;/a&gt;マクロ、&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIGの&lt;/a&gt;タイプマップと&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIGの&lt;/a&gt;断片。フラグメントは、必要に応じてラッパーファイルに条件付きでコードを挿入し、不要な場合は挿入しない方法です。複数のタイプマップが同じフラグメントを必要とする場合、フラグメントはラッパーコードに1回だけ挿入されます。</target>
        </trans-unit>
        <trans-unit id="03230fc37f6936da8ac6bdd751efc6bea8b56636" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://book.git-scm.com/&quot;&gt;git community book&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://book.git-scm.com/&quot;&gt;gitのコミュニティブック&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="81e8045e59daf616aee34810d48dbb7db178f9f3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Python tutorial&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Pythonのチュートリアル&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e3ce3d1a866c8fe3ec8d4e7bfc02ebc4b98d4d1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://git-scm.com/book/&quot;&gt;pro git book&lt;/a&gt; is a good in-depth book on git.</source>
          <target state="translated">&lt;a href=&quot;https://git-scm.com/book/&quot;&gt;プロGitの本は&lt;/a&gt;gitのには良いの深い本です。</target>
        </trans-unit>
        <trans-unit id="c5b683753cdf3b551962126ba95310173bb4c1cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/gittutorial.html&quot;&gt;git tutorial&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/gittutorial.html&quot;&gt;gitのチュートリアル&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bccf408a44196396f7493f86e249b28e7b329b3e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/user-manual.html&quot;&gt;git user manual&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/user-manual.html&quot;&gt;Gitのマニュアル&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a20426fc7bb4d929b1ae303283b379020fbc254" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;numpy.polynomial.polynomial.polynomial.fit#numpy.polynomial.polynomial.Polynomial.fit&quot;&gt;&lt;code&gt;Polynomial.fit&lt;/code&gt;&lt;/a&gt; class method is recommended for new code as it is more stable numerically. See the documentation of the method for more information.</source>
          <target state="translated">&lt;a href=&quot;numpy.polynomial.polynomial.polynomial.fit#numpy.polynomial.polynomial.Polynomial.fit&quot;&gt; &lt;code&gt;Polynomial.fit&lt;/code&gt; の&lt;/a&gt;それはより安定した数値であるように、クラスメソッドは、新しいコードのために推奨されます。詳細については、メソッドのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="3210c2d9abaca33a8760be87735591310e75c5cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; operators always return &lt;code&gt;False&lt;/code&gt; when comparing void structured arrays, and arithmetic and bitwise operations are not supported.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt; と &lt;code&gt;&amp;gt;&lt;/code&gt; 演算子は常に返す &lt;code&gt;False&lt;/code&gt; のボイド構造化された配列を比較するとき、演算やビット演算がサポートされていません。</target>
        </trans-unit>
        <trans-unit id="7efea03dca2b9d161f9ef2bba68b5604f07ac3fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;argument/variable attribute statement&amp;gt;&lt;/code&gt; is &lt;code&gt;&amp;lt;argument/variable type declaration&amp;gt;&lt;/code&gt; without &lt;code&gt;&amp;lt;typespec&amp;gt;&lt;/code&gt;. In addition, in an attribute statement one cannot use other attributes, also &lt;code&gt;&amp;lt;entitydecl&amp;gt;&lt;/code&gt; can be only a list of names.</source>
          <target state="translated">&lt;code&gt;&amp;lt;argument/variable attribute statement&amp;gt;&lt;/code&gt; で &lt;code&gt;&amp;lt;argument/variable type declaration&amp;gt;&lt;/code&gt; なし &lt;code&gt;&amp;lt;typespec&amp;gt;&lt;/code&gt; 。さらに、属性ステートメントでは、他の属性を使用することはできません。また、 &lt;code&gt;&amp;lt;entitydecl&amp;gt;&lt;/code&gt; は名前のリストのみにすることができます。</target>
        </trans-unit>
        <trans-unit id="7fa4578e6de9d14302f059bb642ff99cac46413e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;other statement&amp;gt;&lt;/code&gt; part refers to any other Fortran language constructs that are not described above. F2PY ignores most of them except</source>
          <target state="translated">&lt;code&gt;&amp;lt;other statement&amp;gt;&lt;/code&gt; の部分は、上記に記載されていない他のFortran言語構造を指します。F2PYはそれらのほとんどを無視します</target>
        </trans-unit>
        <trans-unit id="03addd0e1d3adac1696638d2556f4f3e8a49b2fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-s&lt;/code&gt; flag makes a PGP (usually GPG) signed tag. Please do sign the release tags.</source>
          <target state="translated">&lt;code&gt;-s&lt;/code&gt; フラグは、PGP（通常GPG）署名されたタグを行います。リリースタグに署名してください。</target>
        </trans-unit>
        <trans-unit id="a1f02257b982558ed0038cd836405c4aaec01705" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-v&lt;/code&gt; flag gives verbose feedback, &lt;code&gt;-s&lt;/code&gt; causes the script to sign the wheels with your GPG key before upload. Don&amp;rsquo;t forget to upload the wheels before the source tarball, so there is no period for which people switch from an expected binary install to a source install from PyPI.</source>
          <target state="translated">&lt;code&gt;-v&lt;/code&gt; フラグは、フィードバックVERBOSE与え &lt;code&gt;-s&lt;/code&gt; は、アップロードする前に、あなたのGPGキーとホイールに署名するスクリプトが発生します。ソースtarballの前にホイールをアップロードすることを忘れないでください。そのため、予想されるバイナリインストールからPyPIからのソースインストールに切り替える期間はありません。</target>
        </trans-unit>
        <trans-unit id="1ea1937064d555fd6f04fc2b57ae9e905ce9bf17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npy&lt;/code&gt; format is the standard binary file format in NumPy for persisting a &lt;em&gt;single&lt;/em&gt; arbitrary NumPy array on disk. The format stores all of the shape and dtype information necessary to reconstruct the array correctly even on another machine with a different architecture. The format is designed to be as simple as possible while achieving its limited goals.</source>
          <target state="translated">&lt;code&gt;.npy&lt;/code&gt; フォーマットが持続するためのnumpyのに標準的なバイナリファイル形式である&lt;em&gt;単一の&lt;/em&gt;ディスク上の任意のnumpyのアレイ。このフォーマットは、異なるアーキテクチャーを持つ別のマシンでもアレイを正しく再構築するために必要なすべての形状とdtype情報を保存します。フォーマットは、その限られた目標を達成しながら、できるだけシンプルになるように設計されています。</target>
        </trans-unit>
        <trans-unit id="d25fde9120bc920bdf839700f32d6b700adf8720" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npy&lt;/code&gt; format, including motivation for creating it and a comparison of alternatives, is described in the &lt;a href=&quot;https://www.numpy.org/neps/nep-0001-npy-format.html&quot;&gt;&amp;ldquo;npy-format&amp;rdquo; NEP&lt;/a&gt;, however details have evolved with time and this document is more current.</source>
          <target state="translated">&lt;code&gt;.npy&lt;/code&gt; それを作成するための動機および代替の比較を含むフォーマットは、に記載されている&lt;a href=&quot;https://www.numpy.org/neps/nep-0001-npy-format.html&quot;&gt;「NPYフォーマット」NEP&lt;/a&gt;詳細は時間とともに進化しており、この文書は、より多くの電流であるが、。</target>
        </trans-unit>
        <trans-unit id="22e53f126c53ee44cfae93fe323456796e3a7525" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; file format is a zipped archive of files named after the variables they contain. The archive is compressed with &lt;code&gt;zipfile.ZIP_DEFLATED&lt;/code&gt; and each file in the archive contains one variable in &lt;code&gt;.npy&lt;/code&gt; format. For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.npz&lt;/code&gt; ファイル形式は、そこに含まれる変数名にちなんで名付けられたファイルのzip形式のアーカイブです。アーカイブは &lt;code&gt;zipfile.ZIP_DEFLATED&lt;/code&gt; で圧縮されており、アーカイブ内の各ファイルには &lt;code&gt;.npy&lt;/code&gt; 形式の変数が1つ含まれています。説明については &lt;code&gt;.npy&lt;/code&gt; 形式、参照&lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b51e4d01309ff5a759f392af08bb39d1e99043e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; file format is a zipped archive of files named after the variables they contain. The archive is not compressed and each file in the archive contains one variable in &lt;code&gt;.npy&lt;/code&gt; format. For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.npz&lt;/code&gt; ファイル形式は、そこに含まれる変数名にちなんで名付けられたファイルのzip形式のアーカイブです。アーカイブは圧縮されておらず、アーカイブ内の各ファイルには &lt;code&gt;.npy&lt;/code&gt; 形式の変数が1つ含まれています。説明については &lt;code&gt;.npy&lt;/code&gt; 形式、参照&lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5c00dd2aa73f26e18024a200e3875179deacef9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; format is the standard format for persisting &lt;em&gt;multiple&lt;/em&gt; NumPy arrays on disk. A &lt;code&gt;.npz&lt;/code&gt; file is a zip file containing multiple &lt;code&gt;.npy&lt;/code&gt; files, one for each array.</source>
          <target state="translated">&lt;code&gt;.npz&lt;/code&gt; フォーマットは、持続するための標準フォーマットである&lt;em&gt;複数&lt;/em&gt;のディスク上のnumpyのアレイ。 &lt;code&gt;.npz&lt;/code&gt; ファイルが複数含むzipファイルである &lt;code&gt;.npy&lt;/code&gt; ファイル、各アレイの1を。</target>
        </trans-unit>
        <trans-unit id="19658579206ac4f8753c064c0302ad76f2f72a46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ALIGNED&lt;/code&gt; flag of an ndarray, computed in &lt;code&gt;IsAligned&lt;/code&gt; and checked by &lt;code&gt;PyArray_ISALIGNED&lt;/code&gt;. This is computed from &lt;code&gt;dtype.alignment&lt;/code&gt;. It is set to &lt;code&gt;True&lt;/code&gt; if every item in the array is at a memory location consistent with &lt;code&gt;dtype.alignment&lt;/code&gt;, which is the case if the data ptr and all strides of the array are multiples of that alignment.</source>
          <target state="translated">&lt;code&gt;ALIGNED&lt;/code&gt; ndarrayのフラグで計算 &lt;code&gt;IsAligned&lt;/code&gt; によって確認 &lt;code&gt;PyArray_ISALIGNED&lt;/code&gt; 。これは &lt;code&gt;dtype.alignment&lt;/code&gt; から計算されます。配列のすべての項目が &lt;code&gt;dtype.alignment&lt;/code&gt; と一致するメモリ位置にある場合は &lt;code&gt;True&lt;/code&gt; に設定されます。これは、データのptrと配列のすべてのストライドがその配置の倍数である場合です。</target>
        </trans-unit>
        <trans-unit id="85388f353d8827d53025cb4498ec7c4f7175db9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BitGenerator&lt;/code&gt; has a limited set of responsibilities. It manages state and provides functions to produce random doubles and random unsigned 32- and 64-bit values.</source>
          <target state="translated">&lt;code&gt;BitGenerator&lt;/code&gt; は、責任の限定セットを持っています。状態を管理し、ランダムなdoubleおよびランダムな符号なし32ビットおよび64ビット値を生成する関数を提供します。</target>
        </trans-unit>
        <trans-unit id="29642d4a46e1b1f330f5d899a27d8931b3675855" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Configuration&lt;/code&gt; constructor has a fourth optional argument, &lt;code&gt;package_path&lt;/code&gt;, that can be used when package files are located in a different location than the directory of the &lt;code&gt;setup.py&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;Configuration&lt;/code&gt; コンストラクタは、第四オプションの引数、持ってい &lt;code&gt;package_path&lt;/code&gt; パッケージファイルがあるディレクトリとは異なる場所に配置されているときに使用することができ、 &lt;code&gt;setup.py&lt;/code&gt; ファイルを。</target>
        </trans-unit>
        <trans-unit id="831e4b75031bb8f9a8d29e89a9890ddda53ce469" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LibraryInfo&lt;/code&gt; instance containing the build information.</source>
          <target state="translated">&lt;code&gt;LibraryInfo&lt;/code&gt; のビルド情報を含むインスタンス。</target>
        </trans-unit>
        <trans-unit id="d942d62411c592ee85272583cee21a0d612eb9cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MT19937&lt;/code&gt; state vector consists of a 624-element array of 32-bit unsigned integers plus a single integer value between 0 and 624 that indexes the current position within the main array.</source>
          <target state="translated">&lt;code&gt;MT19937&lt;/code&gt; 状態ベクトルは、32ビット符号なし整数の624素子アレイプラス単一の整数値で構成され、0〜624に索引メインアレイ内の現在の位置。</target>
        </trans-unit>
        <trans-unit id="a95fd45cabac9b94aa97772f024779835dc306b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Makefile&lt;/code&gt; calls &lt;code&gt;swig&lt;/code&gt; to generate &lt;code&gt;Vector.py&lt;/code&gt; and &lt;code&gt;Vector_wrap.cxx&lt;/code&gt;, and also executes the &lt;code&gt;setup.py&lt;/code&gt; script that compiles &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; and links together the extension module &lt;code&gt;_Vector.so&lt;/code&gt; or &lt;code&gt;_Vector.dylib&lt;/code&gt;, depending on the platform. This extension module and the proxy file &lt;code&gt;Vector.py&lt;/code&gt; are both placed in a subdirectory under the &lt;code&gt;build&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;Makefile&lt;/code&gt; は呼び出し &lt;code&gt;swig&lt;/code&gt; 生成する &lt;code&gt;Vector.py&lt;/code&gt; と &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; を、また実行 &lt;code&gt;setup.py&lt;/code&gt; コンパイルスクリプト &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; 拡張モジュールとリンクを一緒に &lt;code&gt;_Vector.so&lt;/code&gt; または &lt;code&gt;_Vector.dylib&lt;/code&gt; をプラットフォームに応じて、。この拡張モジュールとプロキシファイル &lt;code&gt;Vector.py&lt;/code&gt; は、どちらも &lt;code&gt;build&lt;/code&gt; ディレクトリの下のサブディレクトリに配置されます。</target>
        </trans-unit>
        <trans-unit id="a509290375510505b589158f3b8f2b07b506f6b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MaskedArray&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;MaskedArray&lt;/code&gt; クラス</target>
        </trans-unit>
        <trans-unit id="b55e755e6d26d2135c464a8b79f8ff9c154dcada" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NPY_SIZEOF_{CTYPE}&lt;/code&gt; constants are defined so that sizeof information is available to the pre-processor.</source>
          <target state="translated">&lt;code&gt;NPY_SIZEOF_{CTYPE}&lt;/code&gt; 定数はsizeof情報をプリプロセッサに利用可能であるように定義されます。</target>
        </trans-unit>
        <trans-unit id="d0911aba3c1681f9c5a1ccf39d3f2fd5866ac6b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NpzFile&lt;/code&gt; returned by &lt;code&gt;np.savez&lt;/code&gt; is now a &lt;code&gt;collections.abc.Mapping&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;NpzFile&lt;/code&gt; によって返さ &lt;code&gt;np.savez&lt;/code&gt; は今ある &lt;code&gt;collections.abc.Mapping&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d918fc830e6f124f45ecb19bab96030d1a7583a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PCG64&lt;/code&gt; state vector consists of 2 unsigned 128-bit values, which are represented externally as Python ints. One is the state of the PRNG, which is advanced by a linear congruential generator (LCG). The second is a fixed odd increment used in the LCG.</source>
          <target state="translated">&lt;code&gt;PCG64&lt;/code&gt; の状態ベクトルは、Python int値として外部表される2符号なしの128ビット値、から成ります。1つはPRNGの状態で、線形合同法ジェネレーター（LCG）によって進められます。2番目は、LCGで使用される固定の奇数の増分です。</target>
        </trans-unit>
        <trans-unit id="c1a90ac63bb863a062bb153b73df1e64c4857aff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Philox&lt;/code&gt; state vector consists of a 256-bit value encoded as a 4-element uint64 array and a 128-bit value encoded as a 2-element uint64 array. The former is a counter which is incremented by 1 for every 4 64-bit randoms produced. The second is a key which determined the sequence produced. Using different keys produces independent sequences.</source>
          <target state="translated">&lt;code&gt;Philox&lt;/code&gt; の状態ベクトルは、4素子UINT64アレイと2要素UINT64アレイとして符号化された128ビット値として符号化された256ビット値から成ります。前者は、4つの64ビットランダムが生成されるたびに1ずつ増加するカウンターです。2番目は、生成されるシーケンスを決定するキーです。異なるキーを使用すると、独立したシーケンスが生成されます。</target>
        </trans-unit>
        <trans-unit id="4d1f94165781d8145f1fd80c467f6bd0f760f0b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SFC64&lt;/code&gt; state vector consists of 4 unsigned 64-bit values. The last is a 64-bit counter that increments by 1 each iteration.</source>
          <target state="translated">&lt;code&gt;SFC64&lt;/code&gt; の状態ベクトルは、4符号なしの64ビット値から成ります。最後は64ビットのカウンターで、反復ごとに1ずつ増加します。</target>
        </trans-unit>
        <trans-unit id="a79e711795f6e28c85d83994efa93c2930d50249" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__array_ufunc__&lt;/code&gt; receives:</source>
          <target state="translated">&lt;code&gt;__array_ufunc__&lt;/code&gt; は、受信します：</target>
        </trans-unit>
        <trans-unit id="7be3375866469167b9378a498844a5222b829ab9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__complex__&lt;/code&gt; method has been implemented for the ndarrays</source>
          <target state="translated">&lt;code&gt;__complex__&lt;/code&gt; の方法はndarraysのために実装されました</target>
        </trans-unit>
        <trans-unit id="395b8858a352467f67b6a09c4a5fc424e26cfad2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__init__.py&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;__init__.py&lt;/code&gt; ファイル</target>
        </trans-unit>
        <trans-unit id="55e0b71eae2cfd6e566258a88d10c513a1a5a113" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; keyword of the dtype constructor, which only affects structured arrays. If the structure&amp;rsquo;s field offsets are not manually provided numpy determines offsets automatically. In that case, &lt;code&gt;align=True&lt;/code&gt; pads the structure so that each field is &amp;ldquo;true&amp;rdquo; aligned in memory and sets &lt;code&gt;dtype.alignment&lt;/code&gt; to be the largest of the field &amp;ldquo;true&amp;rdquo; alignments. This is like what C-structs usually do. Otherwise if offsets or itemsize were manually provided &lt;code&gt;align=True&lt;/code&gt; simply checks that all the fields are &amp;ldquo;true&amp;rdquo; aligned and that the total itemsize is a multiple of the largest field alignment. In either case &lt;code&gt;dtype.isalignedstruct&lt;/code&gt; is also set to True.</source>
          <target state="translated">dtypeコンストラクターの &lt;code&gt;align&lt;/code&gt; キーワード。構造化配列にのみ影響します。構造体のフィールドオフセットが手動で提供されない場合、numpyはオフセットを自動的に決定します。その場合、 &lt;code&gt;align=True&lt;/code&gt; は、各フィールドがメモリ内で「true」に整列されるように構造体を &lt;code&gt;dtype.alignment&lt;/code&gt; し、dtype.alignmentをフィールドの「true」整列の最大値に設定します。これはC構造体が通常行うことと似ています。それ以外の場合、オフセットまたはitemsizeが手動で提供 &lt;code&gt;align=True&lt;/code&gt; れた場合、align = Trueは、すべてのフィールドが「true」に配置されていること、および合計itemsizeが最大のフィールド配置の倍数であることを単にチェックします。どちらの場合も、 &lt;code&gt;dtype.isalignedstruct&lt;/code&gt; もTrueに設定されます。</target>
        </trans-unit>
        <trans-unit id="ed305f750328762db1dc6ead8c6be67eaf77ffcb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;array&lt;/code&gt; constructor &lt;strong&gt;takes (nested) Python sequences as initializers&lt;/strong&gt;. As in, &lt;code&gt;array([[1,2,3],[4,5,6]])&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;array&lt;/code&gt; コンストラクタは&lt;strong&gt;イニシャライザとして（ネスト）Pythonの配列をとります&lt;/strong&gt;。のように、 &lt;code&gt;array([[1,2,3],[4,5,6]])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7af29f13d56d1534071fc5be1d8e6902e6aa373" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;array&lt;/code&gt; is thus much more advisable to use. Indeed, we intend to deprecate &lt;code&gt;matrix&lt;/code&gt; eventually.</source>
          <target state="translated">したがって、 &lt;code&gt;array&lt;/code&gt; を使用することをお勧めします。実際、最終的には &lt;code&gt;matrix&lt;/code&gt; を非推奨にする予定です。</target>
        </trans-unit>
        <trans-unit id="dd27c9fa716237737a1b850fd84a88e9e84db97b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt;-clause of the &lt;code&gt;with&lt;/code&gt;-statement gives the current print options:</source>
          <target state="translated">-clause &lt;code&gt;with&lt;/code&gt; -statementは、現在の印刷オプションを提供します： &lt;code&gt;as&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2c28e104a97f1a1f15fc38cbcd9f731be438b4c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autostrip&lt;/code&gt; argument</source>
          <target state="translated">&lt;code&gt;autostrip&lt;/code&gt; の引数</target>
        </trans-unit>
        <trans-unit id="ad906fe89b0c268cf5fd9b3376621745175a9a41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;axis&lt;/code&gt; argument to &lt;code&gt;numpy.ma.mask_cols&lt;/code&gt; and &lt;code&gt;numpy.ma.mask_row&lt;/code&gt; is deprecated</source>
          <target state="translated">&lt;code&gt;numpy.ma.mask_cols&lt;/code&gt; および &lt;code&gt;numpy.ma.mask_row&lt;/code&gt; への &lt;code&gt;axis&lt;/code&gt; 引数は非推奨になりました</target>
        </trans-unit>
        <trans-unit id="caa858c948295450c18bcef4c572e68d7eda67a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;axis&lt;/code&gt; keyword can be used to specify a subset of axes of which the gradient is calculated</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; キーワードは、勾配が計算された軸のサブセットを指定するために使用することができます</target>
        </trans-unit>
        <trans-unit id="c68a2d64e2aeed4fdf4077c45259bb4b7c07822e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;axis&lt;/code&gt; parameter specifies the index of the new axis in the dimensions of the result. For example, if &lt;code&gt;axis=0&lt;/code&gt; it will be the first dimension and if &lt;code&gt;axis=-1&lt;/code&gt; it will be the last dimension.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; パラメータは、結果の次元で新しい軸のインデックスを指定します。たとえば、 &lt;code&gt;axis=0&lt;/code&gt; の場合は最初の次元になり、 &lt;code&gt;axis=-1&lt;/code&gt; の場合は最後の次元になります。</target>
        </trans-unit>
        <trans-unit id="285d55a28a1a269db45a5f84582658fc7e3a43b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;base&lt;/code&gt; attribute is useful in being able to tell whether we have a view or the original array. This in turn can be useful if we need to know whether or not to do some specific cleanup when the subclassed array is deleted. For example, we may only want to do the cleanup if the original array is deleted, but not the views. For an example of how this can work, have a look at the &lt;code&gt;memmap&lt;/code&gt; class in &lt;code&gt;numpy.core&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 属性は、我々がビューまたは元の配列を持っているかどうかを伝えることができることに有用です。これは、サブクラス化された配列が削除されたときに特定のクリーンアップを実行するかどうかを知る必要がある場合に役立ちます。たとえば、元の配列が削除された場合にのみクリーンアップを実行し、ビューは削除しない場合があります。これがどのように機能するかの例については、 &lt;code&gt;memmap&lt;/code&gt; クラスを &lt;code&gt;numpy.core&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d4cb66724d02c13ff5f50a065c67d6d75a20a6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool_&lt;/code&gt; data type is very similar to the Python &lt;code&gt;BooleanType&lt;/code&gt; but does not inherit from it because Python&amp;rsquo;s &lt;code&gt;BooleanType&lt;/code&gt; does not allow itself to be inherited from, and on the C-level the size of the actual bool data is not the same as a Python Boolean scalar.</source>
          <target state="translated">&lt;code&gt;bool_&lt;/code&gt; のデータ型は、Pythonと非常に似て &lt;code&gt;BooleanType&lt;/code&gt; が、Pythonのため、それを継承しません &lt;code&gt;BooleanType&lt;/code&gt; は、それ自体から継承することはできません。また、C-レベルで実際のブールデータのサイズは、Pythonのブールと同じではありませんスカラー。</target>
        </trans-unit>
        <trans-unit id="1a9ec4df6ec3fb7357baf90864b29d969f59440a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool_&lt;/code&gt; type is not a subclass of the &lt;code&gt;int_&lt;/code&gt; type (the &lt;code&gt;bool_&lt;/code&gt; is not even a number type). This is different than Python&amp;rsquo;s default implementation of &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; as a sub-class of int.</source>
          <target state="translated">&lt;code&gt;bool_&lt;/code&gt; のタイプのサブクラスではない &lt;code&gt;int_&lt;/code&gt; タイプ（ &lt;code&gt;bool_&lt;/code&gt; は偶数タイプではありません）。これは、intのサブクラスとしての&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; の&lt;/a&gt; Pythonのデフォルト実装とは異なります。</target>
        </trans-unit>
        <trans-unit id="3f5c3b6d52d4becfb53cc5a7dd0ae6b04cdb9085" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a prefix or suffix; rather, all combinations of its values are stripped.</source>
          <target state="translated">&lt;code&gt;chars&lt;/code&gt; 引数には、削除する文字のセットを指定する文字列です。省略されるかNoneの場合、 &lt;code&gt;chars&lt;/code&gt; 引数はデフォルトで空白を削除します。 &lt;code&gt;chars&lt;/code&gt; 引数は、接頭辞や接尾辞ではありません。むしろ、その値のすべての組み合わせが取り除かれます。</target>
        </trans-unit>
        <trans-unit id="44ca716c299a61027880c154634feb6b89178fc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a prefix; rather, all combinations of its values are stripped.</source>
          <target state="translated">&lt;code&gt;chars&lt;/code&gt; 引数には、削除する文字のセットを指定する文字列です。省略されるかNoneの場合、 &lt;code&gt;chars&lt;/code&gt; 引数はデフォルトで空白を削除します。 &lt;code&gt;chars&lt;/code&gt; 引数は、接頭辞ではありません。むしろ、その値のすべての組み合わせが取り除かれます。</target>
        </trans-unit>
        <trans-unit id="3ab81d1fe754db2126af526470043294b9859fdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a suffix; rather, all combinations of its values are stripped.</source>
          <target state="translated">&lt;code&gt;chars&lt;/code&gt; 引数には、削除する文字のセットを指定する文字列です。省略されるかNoneの場合、 &lt;code&gt;chars&lt;/code&gt; 引数はデフォルトで空白を削除します。 &lt;code&gt;chars&lt;/code&gt; 引数が接尾辞ではありません。むしろ、その値のすべての組み合わせが取り除かれます。</target>
        </trans-unit>
        <trans-unit id="c5f389d1809eca65fc531558b3a6934398b93db5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;code.c&lt;/code&gt; file also contains the function &lt;code&gt;dfilter2d&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;code.c&lt;/code&gt; のファイルも、関数が含まれ &lt;code&gt;dfilter2d&lt;/code&gt; を：</target>
        </trans-unit>
        <trans-unit id="1062b010a751d11306d8dd6990fc1281fafefff6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;comments&lt;/code&gt; argument</source>
          <target state="translated">&lt;code&gt;comments&lt;/code&gt; 引数</target>
        </trans-unit>
        <trans-unit id="b3f924ee1f48ac861086d833eab7f0e461342200" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;converters&lt;/code&gt; argument</source>
          <target state="translated">&lt;code&gt;converters&lt;/code&gt; 引数</target>
        </trans-unit>
        <trans-unit id="1bf25618f0e89873a8966e075d9cc930c281ddb2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; method makes a complete copy of the array and its data.</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; 方法は、配列とそのデータの完全なコピーを作成します。</target>
        </trans-unit>
        <trans-unit id="04c7d601eb1b28391adc5c0db2ef77348e27c0e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defaultfmt&lt;/code&gt; argument</source>
          <target state="translated">&lt;code&gt;defaultfmt&lt;/code&gt; の引数</target>
        </trans-unit>
        <trans-unit id="a534898d388f95602366c3e92d612246a0ec8f63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delimiter&lt;/code&gt; argument</source>
          <target state="translated">&lt;code&gt;delimiter&lt;/code&gt; の引数</target>
        </trans-unit>
        <trans-unit id="961750d0f31ee27657eeda3c0b92ff071d0d3872" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doc/swig&lt;/code&gt; directory moved</source>
          <target state="translated">&lt;code&gt;doc/swig&lt;/code&gt; 移動ディレクトリ</target>
        </trans-unit>
        <trans-unit id="c5f33c0fec12debe8698b9f3d00999bb3fb759ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype.alignment&lt;/code&gt; attribute (&lt;code&gt;descr-&amp;gt;alignment&lt;/code&gt; in C). This is meant to reflect the &amp;ldquo;true alignment&amp;rdquo; of the type. It has arch-dependent default values for all datatypes, with the exception of structured types created with &lt;code&gt;align=True&lt;/code&gt; as described below.</source>
          <target state="translated">&lt;code&gt;dtype.alignment&lt;/code&gt; 属性（ &lt;code&gt;descr-&amp;gt;alignment&lt;/code&gt; Cで）。これは、タイプの「真の調整」を反映することを意味します。以下に説明するように &lt;code&gt;align=True&lt;/code&gt; で作成された構造化タイプを除いて、すべてのデータタイプにアーチ依存のデフォルト値があります。</target>
        </trans-unit>
        <trans-unit id="323a6b614fe91ba8419451439d97b4868d61c2a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype.fields&lt;/code&gt; dictionary will contain titles as keys, if any titles are used. This means effectively that a field with a title will be represented twice in the fields dictionary. The tuple values for these fields will also have a third element, the field title. Because of this, and because the &lt;code&gt;names&lt;/code&gt; attribute preserves the field order while the &lt;code&gt;fields&lt;/code&gt; attribute may not, it is recommended to iterate through the fields of a dtype using the &lt;code&gt;names&lt;/code&gt; attribute of the dtype, which will not list titles, as in:</source>
          <target state="translated">&lt;code&gt;dtype.fields&lt;/code&gt; のいずれかのタイトルが使用されている場合は辞書は、キーとしてのタイトルが含まれています。これは事実上、タイトルのあるフィールドがフィールドディクショナリで2回表されることを意味します。これらのフィールドのタプル値には、3番目の要素であるフィールドタイトルも含まれます。このため、また、 &lt;code&gt;names&lt;/code&gt; 属性はフィールドの順序を保持しますが、 &lt;code&gt;fields&lt;/code&gt; 属性は保持しない場合があるため、次のように、タイトルを一覧表示しないdtypeの &lt;code&gt;names&lt;/code&gt; 属性を使用してdtypeのフィールドを反復処理することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="4e0428300bbf21ef1b533ffa3e86adb5ceddd8dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype&lt;/code&gt; parameter defines the underlying data type.</source>
          <target state="translated">&lt;code&gt;dtype&lt;/code&gt; パラメータは、基礎となるデータ・タイプを定義します。</target>
        </trans-unit>
        <trans-unit id="93f7d511e2846b265125fabe4d5030e15709832e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;excluded&lt;/code&gt; argument can be used to prevent vectorizing over certain arguments. This can be useful for array-like arguments of a fixed length such as the coefficients for a polynomial as in &lt;a href=&quot;numpy.polyval#numpy.polyval&quot;&gt;&lt;code&gt;polyval&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;excluded&lt;/code&gt; 引数は、特定の引数の上にベクトル化を防止するために使用することができます。これは、&lt;a href=&quot;numpy.polyval#numpy.polyval&quot;&gt; &lt;code&gt;polyval&lt;/code&gt; の&lt;/a&gt;ような多項式の係数など、固定長の配列のような引数に役立ちます。</target>
        </trans-unit>
        <trans-unit id="359c30915e6710377793414f9e99d77e6eeeea63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;f2py -c&lt;/code&gt; option must be applied either to an existing &lt;code&gt;.pyf&lt;/code&gt; file (plus the source/object/library files) or one must specify the &lt;code&gt;-m &amp;lt;modulename&amp;gt;&lt;/code&gt; option (plus the sources/object/library files). Use one of the following options:</source>
          <target state="translated">&lt;code&gt;f2py -c&lt;/code&gt; オプションは、既存のいずれかに適用されなければならない &lt;code&gt;.pyf&lt;/code&gt; ファイル（プラスソース/オブジェクト/ライブラリファイル）または1つを指定する必要があり &lt;code&gt;-m &amp;lt;modulename&amp;gt;&lt;/code&gt; オプション（プラスソース/オブジェクト/ライブラリファイル）。次のいずれかのオプションを使用します。</target>
        </trans-unit>
        <trans-unit id="2beff53e54fda1bd096a7e81c4708f352287d275" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; attribute of the &lt;code&gt;PyArrayObject&lt;/code&gt; structure contains important information about the memory used by the array (pointed to by the data member) This flag information must be kept accurate or strange results and even segfaults may result.</source>
          <target state="translated">&lt;code&gt;PyArrayObject&lt;/code&gt; 構造体の &lt;code&gt;flags&lt;/code&gt; 属性には、配列で使用されるメモリに関する重要な情報が含まれます（データメンバーによってポイントされます）。このフラグ情報は、正確または奇妙な結果を維持する必要があり、segfaultsも発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8cff4dd26e77da7e42ef944b6a6e55860dbd33d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;genfromtxt&lt;/code&gt; function provides two other complementary mechanisms: the &lt;code&gt;missing_values&lt;/code&gt; argument is used to recognize missing data and a second argument, &lt;code&gt;filling_values&lt;/code&gt;, is used to process these missing data.</source>
          <target state="translated">&lt;code&gt;genfromtxt&lt;/code&gt; 関数他の2つの相補的なメカニズムを提供する： &lt;code&gt;missing_values&lt;/code&gt; の引数が欠落しているデータを認識するために使用され、第二引数、 &lt;code&gt;filling_values&lt;/code&gt; は、これらの欠落したデータを処理するために使用されます。</target>
        </trans-unit>
        <trans-unit id="8b08d522b6b1cfd800cd6bda4d86b04d644f1baf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int_&lt;/code&gt; type does &lt;strong&gt;not&lt;/strong&gt; inherit from the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; built-in under Python 3, because type &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; is no longer a fixed-width integer type.</source>
          <target state="translated">&lt;code&gt;int_&lt;/code&gt; タイプがない&lt;strong&gt;ではない&lt;/strong&gt;から継承していない&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;型ので、ビルトインのPython 3の下&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; は&lt;/a&gt;もはや固定幅の整数型です。</target>
        </trans-unit>
        <trans-unit id="5032550323e57bc7dec27d8af2d8f9df18642750" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;itershape&lt;/code&gt; parameter allows you to force the iterator to have a specific iteration shape. It is an array of length &lt;code&gt;oa_ndim&lt;/code&gt;. When an entry is negative, its value is determined from the operands. This parameter allows automatically allocated outputs to get additional dimensions which don&amp;rsquo;t match up with any dimension of an input.</source>
          <target state="translated">&lt;code&gt;itershape&lt;/code&gt; のパラメータを使用すると、特定の反復形状を有するようにイテレータを強制することができます。長さ &lt;code&gt;oa_ndim&lt;/code&gt; の配列です。エントリが負の場合、その値はオペランドから決定されます。このパラメーターを使用すると、出力が自動的に割り当てられ、入力のどの次元とも一致しない追加の次元を取得できます。</target>
        </trans-unit>
        <trans-unit id="d1b139e99319cf8723f8471165f727072e0de12d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;k&lt;/code&gt; different &amp;ldquo;columns&amp;rdquo; to be sorted. The last column (or row if &lt;code&gt;keys&lt;/code&gt; is a 2D array) is the primary sort key.</source>
          <target state="translated">&lt;code&gt;k&lt;/code&gt; ソートする別の「列」。最後の列（または &lt;code&gt;keys&lt;/code&gt; が2D配列の場合は行）がプライマリソートキーです。</target>
        </trans-unit>
        <trans-unit id="bf501ea6ca94cccfb99a424407f3991a7fe0b23a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mask&lt;/code&gt; can be initialized with an array of boolean values with the same shape as &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mask&lt;/code&gt; 同じ形状のブール値の配列で初期化することができる &lt;code&gt;data&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7a81ce30e9985e9cc6aff4a084478e80352aabd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;matrix&lt;/code&gt; constructor additionally &lt;strong&gt;takes a convenient string initializer&lt;/strong&gt;. As in &lt;code&gt;matrix(&quot;[1&amp;nbsp;2&amp;nbsp;3;&amp;nbsp;4&amp;nbsp;5&amp;nbsp;6]&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;matrix&lt;/code&gt; コンストラクタは、さらに&lt;strong&gt;便利な文字列の初期化子をとります&lt;/strong&gt;。以下のように &lt;code&gt;matrix(&quot;[1&amp;nbsp;2&amp;nbsp;3;&amp;nbsp;4&amp;nbsp;5&amp;nbsp;6]&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab61433b884d13cbf28918d009f77e172c843e81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt; arrays of indices corresponding to the locations where &lt;code&gt;mask_func(np.ones((n, n)), k)&lt;/code&gt; is True.</source>
          <target state="translated">&lt;code&gt;mask_func(np.ones((n, n)), k)&lt;/code&gt; がTrueである場所に対応するインデックスの &lt;code&gt;n&lt;/code&gt; 個の配列。</target>
        </trans-unit>
        <trans-unit id="69bba282bdcb3fd4a040d50fe46e42c40f81a639" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;names&lt;/code&gt; argument</source>
          <target state="translated">&lt;code&gt;names&lt;/code&gt; 引数</target>
        </trans-unit>
        <trans-unit id="68e43d8a15f5f97ea384a5e71f1342015a6bc434" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ndarray&lt;/code&gt; is an object that provide a python array interface to data in memory.</source>
          <target state="translated">&lt;code&gt;ndarray&lt;/code&gt; は、メモリ内のデータへのPython配列インタフェースを提供するオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="68dcfe0b1fdf3a267f300958e2039277e48ae02c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new_order&lt;/code&gt; code can be any from the following:</source>
          <target state="translated">&lt;code&gt;new_order&lt;/code&gt; のコードは、次のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="8693a0f592844bcf9978c5fbaa78f4621036206e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nonzero&lt;/code&gt; method of the condition array can also be called.</source>
          <target state="translated">条件配列の &lt;code&gt;nonzero&lt;/code&gt; メソッドも呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="119598850fcb719f758c8505ecbfd545e55a9647" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;np.einsum&lt;/code&gt; function will use BLAS when possible and optimize by default</source>
          <target state="translated">&lt;code&gt;np.einsum&lt;/code&gt; 可能な場合は、デフォルトで最適化機能は、BLASを使用します。</target>
        </trans-unit>
        <trans-unit id="e03ccb4d87ad4f35f1ad3c43da765c8e7da17640" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;np.percentile&lt;/code&gt; &amp;lsquo;midpoint&amp;rsquo; interpolation method fixed for exact indices</source>
          <target state="translated">&lt;code&gt;np.percentile&lt;/code&gt; 正確な指標のために固定「中間」補間法</target>
        </trans-unit>
        <trans-unit id="eabf6694e45f9bef7f8445dcaf6ddb978e5e6f05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;npy_3kcompat.h&lt;/code&gt; header changed</source>
          <target state="translated">&lt;code&gt;npy_3kcompat.h&lt;/code&gt; ヘッダが変更され</target>
        </trans-unit>
        <trans-unit id="d18c665ad6cff39ded6fc90bc8648963ab9ee138" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; file contains several macros and routines that it uses internally to build its typemaps. However, these functions may be useful elsewhere in your interface file. These macros and routines are implemented as fragments, which are described briefly in the previous section. If you try to use one or more of the following macros or functions, but your compiler complains that it does not recognize the symbol, then you need to force these fragments to appear in your code using:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; ファイルは、そのタイプマップを構築するために内部的に使用されるいくつかのマクロおよびルーチンが含まれています。ただし、これらの関数は、インターフェースファイルの他の場所で役立つ場合があります。これらのマクロとルーチンは、前のセクションで簡単に説明したフラグメントとして実装されます。以下のマクロまたは関数を1つ以上使用しようとしたが、コンパイラーがシンボルを認識しないと不平を言った場合、以下を使用してこれらのフラグメントを強制的にコードに表示する必要があります。</target>
        </trans-unit>
        <trans-unit id="9f4cb37fdc51e8b1f5c2b248e5fd15fdd94aa9b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; file is currently located in the &lt;code&gt;tools/swig&lt;/code&gt; sub-directory under the &lt;code&gt;numpy&lt;/code&gt; installation directory. Typically, you will want to copy it to the directory where you are developing your wrappers.</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; のファイルは、現在に位置している &lt;code&gt;tools/swig&lt;/code&gt; 下のサブディレクトリ &lt;code&gt;numpy&lt;/code&gt; のインストールディレクトリ。通常、ラッパーを開発しているディレクトリにコピーします。</target>
        </trans-unit>
        <trans-unit id="96831ff16133b13c87cfe870992604959917c570" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file also provides additional tools for wrapper developers, including:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; インターフェイスファイルも含めて、ラッパー開発者向けの追加ツールを提供しています。</target>
        </trans-unit>
        <trans-unit id="d04832f55eba99f2bc4cc0dceb3d718f68b6cac8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file does not support typemaps for output arrays, for several reasons. First, C/C++ return arguments are limited to a single value. This prevents obtaining dimension information in a general way. Second, arrays with hard-coded lengths are not permitted as return arguments. In other words:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; インターフェイスファイルは、いくつかの理由で、出力配列のためのタイプマップをサポートしていません。まず、C / C ++の戻り引数は単一の値に制限されます。これにより、一般的な方法で次元情報を取得できなくなります。次に、ハードコーディングされた長さの配列は、戻り引数として許可されていません。言い換えると：</target>
        </trans-unit>
        <trans-unit id="65e8b572ae6dc55c16aea9abc0f0766e897fe055" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file uses the &lt;code&gt;%numpy_typemaps&lt;/code&gt; macro to implement typemaps for the following C data types and &lt;code&gt;int&lt;/code&gt; dimension types:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; インターフェイスファイルが使用 &lt;code&gt;%numpy_typemaps&lt;/code&gt; 以下のCデータ型とするためのタイプマップを実装するマクロ &lt;code&gt;int&lt;/code&gt; 寸法タイプ：</target>
        </trans-unit>
        <trans-unit id="d99e0e96fa984690444350c5bb3087380beb5586" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.ma&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;numpy.ma&lt;/code&gt; のモジュール</target>
        </trans-unit>
        <trans-unit id="1f4db4ab31f145b9bac6edb4b0915cc64c0ea3a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.ndarray&lt;/code&gt; constructor no longer interprets &lt;code&gt;strides=()&lt;/code&gt; as &lt;code&gt;strides=None&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.ndarray&lt;/code&gt; のコンストラクタもはや解釈 &lt;code&gt;strides=()&lt;/code&gt; など &lt;code&gt;strides=None&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70a302d51ef0fc934fa61a7faa2fee138940dfc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.rec&lt;/code&gt; module provides a number of other convenience functions for creating record arrays, see &lt;a href=&quot;../reference/routines.array-creation#routines-array-creation-rec&quot;&gt;record array creation routines&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;numpy.rec&lt;/code&gt; モジュールは、レコードの配列を作成するための他の便利な機能の数を提供し、参照&lt;a href=&quot;../reference/routines.array-creation#routines-array-creation-rec&quot;&gt;レコードアレイ作成ルーチン&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c8ade543f0e1c46d97cf061c562c3116b9639d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;order&lt;/code&gt; keyword gives the index ordering both for &lt;em&gt;fetching&lt;/em&gt; the values from &lt;code&gt;a&lt;/code&gt;, and then &lt;em&gt;placing&lt;/em&gt; the values into the output array. For example, let&amp;rsquo;s say you have an array:</source>
          <target state="translated">&lt;code&gt;order&lt;/code&gt; キーワードはのために、両方のインデックスの順序与える&lt;em&gt;フェッチ&lt;/em&gt;からの値を、その後、&lt;em&gt;確定&lt;/em&gt;出力配列に値を。たとえば、次のような配列があるとします。 &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b38e6e5718f484c9be916df67070a4920d8e24c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repr&lt;/code&gt; of &lt;code&gt;np.polynomial&lt;/code&gt; classes is more explicit</source>
          <target state="translated">&lt;code&gt;repr&lt;/code&gt; の &lt;code&gt;np.polynomial&lt;/code&gt; クラスは、より明示的です</target>
        </trans-unit>
        <trans-unit id="7075c0200f067381f77164e531b354de40ba5d19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;savetxt()&lt;/code&gt; and &lt;code&gt;loadtxt()&lt;/code&gt; functions accept additional optional parameters such as header, footer, and delimiter. While text files can be easier for sharing, .npy and .npz files are smaller and faster to read. If you need more sophisticated handling of your text file (for example, if you need to work with lines that contain missing values), you will want to use the &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;savetxt()&lt;/code&gt; と &lt;code&gt;loadtxt()&lt;/code&gt; 関数は、ヘッダ、フッタ、および区切り文字などの追加のオプションのパラメータを受け入れます。テキストファイルは共有しやすい場合がありますが、.npyファイルと.npzファイルは小さくて読みやすくなっています。テキストファイルのより高度な処理が必要な場合（たとえば、欠落している値を含む行を処理する必要がある場合）、&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;関数を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="022ed8cd0b6cf9d8c83ca5b8b482f20886ea6324" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;series&lt;/code&gt; is expected to be an instance of some polynomial series of one of the types supported by by the numpy.polynomial module, but could be some other class that supports the convert method.</source>
          <target state="translated">&lt;code&gt;series&lt;/code&gt; numpy.polynomialモジュールによってでサポートされているタイプのいずれかのいくつかの多項式一連のインスタンスであると予想されるが、変換メソッドをサポートするいくつかの他のクラスであってもよいです。</target>
        </trans-unit>
        <trans-unit id="f4910f2b9024b32efada1e65d4c1134f65374f1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setup.py&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;setup.py&lt;/code&gt; ファイル</target>
        </trans-unit>
        <trans-unit id="0948550106d7d72b97910c4e4918bcddbe3d6d6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;signature&lt;/code&gt; argument allows for vectorizing functions that act on non-scalar arrays of fixed length. For example, you can use it for a vectorized calculation of Pearson correlation coefficient and its p-value:</source>
          <target state="translated">&lt;code&gt;signature&lt;/code&gt; 引数は、固定長の非スカラー配列に作用する機能をベクトル化することを可能にします。たとえば、ピアソン相関係数とそのp値のベクトル化された計算に使用できます。</target>
        </trans-unit>
        <trans-unit id="692ace7013c4ccf7dfcd73ad9c88abfaeb03c00c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip_header&lt;/code&gt; and &lt;code&gt;skip_footer&lt;/code&gt; arguments</source>
          <target state="translated">&lt;code&gt;skip_header&lt;/code&gt; と &lt;code&gt;skip_footer&lt;/code&gt; 引数</target>
        </trans-unit>
        <trans-unit id="19cc10b9b9bd6104c6aeb8b9be441a8dc8445028" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; argument must be a sequence that contains the following elements:</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; 引数には、次の要素を含むシーケンスである必要があります。</target>
        </trans-unit>
        <trans-unit id="28db18b99085783cc1cb19c430887ae4c1bd2dc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; tuple has the following items:</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; タプルは以下の項目があります。</target>
        </trans-unit>
        <trans-unit id="0e4c35736a2eec986972a33d172a5be16d326f7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tp_as_number&lt;/code&gt; methods use a generic approach to call whatever function has been registered for handling the operation. When the &lt;code&gt;_multiarray_umath module&lt;/code&gt; is imported, it sets the numeric operations for all arrays to the corresponding ufuncs. This choice can be changed with &lt;a href=&quot;c-api.ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt;&lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt;&lt;/a&gt; The &lt;code&gt;tp_str&lt;/code&gt; and &lt;code&gt;tp_repr&lt;/code&gt; methods can also be altered using &lt;a href=&quot;c-api.array#c.PyArray_SetStringFunction&quot;&gt;&lt;code&gt;PyArray_SetStringFunction&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;tp_as_number&lt;/code&gt; の方法は操作を処理するために登録されているものは何でも関数を呼び出すために、一般的なアプローチを使用します。場合 &lt;code&gt;_multiarray_umath module&lt;/code&gt; インポートされ、対応するufuncsにすべてのアレイのための数値演算を設定します。この選択はして変更することができ&lt;a href=&quot;c-api.ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt; &lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt; &lt;/a&gt; &lt;code&gt;tp_str&lt;/code&gt; と &lt;code&gt;tp_repr&lt;/code&gt; ハンドラのそれと方法も使用して変更することができます&lt;a href=&quot;c-api.array#c.PyArray_SetStringFunction&quot;&gt; &lt;code&gt;PyArray_SetStringFunction&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="008291952c69e3c178208fe3d11495f165132897" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tp_as_number&lt;/code&gt; methods use a generic approach to call whatever function has been registered for handling the operation. When the &lt;code&gt;_multiarray_umath module&lt;/code&gt; is imported, it sets the numeric operations for all arrays to the corresponding ufuncs. This choice can be changed with &lt;a href=&quot;ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt;&lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt;&lt;/a&gt; The &lt;code&gt;tp_str&lt;/code&gt; and &lt;code&gt;tp_repr&lt;/code&gt; methods can also be altered using &lt;a href=&quot;array#c.PyArray_SetStringFunction&quot;&gt;&lt;code&gt;PyArray_SetStringFunction&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;tp_as_number&lt;/code&gt; の方法は操作を処理するために登録されているものは何でも関数を呼び出すために、一般的なアプローチを使用します。場合 &lt;code&gt;_multiarray_umath module&lt;/code&gt; インポートされ、対応するufuncsにすべてのアレイのための数値演算を設定します。この選択はして変更することができ&lt;a href=&quot;ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt; &lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt; &lt;/a&gt; &lt;code&gt;tp_str&lt;/code&gt; と &lt;code&gt;tp_repr&lt;/code&gt; ハンドラのそれと方法も使用して変更することができます&lt;a href=&quot;array#c.PyArray_SetStringFunction&quot;&gt; &lt;code&gt;PyArray_SetStringFunction&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed5f797071b24065d3a9e203b1fcea474546397a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;usecols&lt;/code&gt; argument</source>
          <target state="translated">&lt;code&gt;usecols&lt;/code&gt; の引数</target>
        </trans-unit>
        <trans-unit id="5186f89054917ad06c4418d857ded8a6ad552d9f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Documentation&lt;/em&gt; for a software project is the set of reference, instructional, educational, informative material generated by the project developers and contributors, as well as discussions, presentations, videos and other user-generated content. It may include learning-oriented content (such as tutorials and how-tos), use-cases or in-depth explanations and reference for developers.</source>
          <target state="translated">ソフトウェアプロジェクトの&lt;em&gt;ドキュメント&lt;/em&gt;は、プロジェクトの開発者と寄稿者によって生成された一連のリファレンス、教育、教育、有益な資料、およびディスカッション、プレゼンテーション、ビデオ、その他のユーザー生成コンテンツです。これには、学習指向のコンテンツ（チュートリアルやハウツーなど）、ユースケース、または開発者向けの詳細な説明とリファレンスが含まれる場合があります。</target>
        </trans-unit>
        <trans-unit id="88a54cde186ec5ee99014b55275737fd8ded4abc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;bounds&lt;/em&gt; argument is expected to be a (2 * iter-&amp;gt;ao-&amp;gt;nd) arrays, such as the range bound[2*i]-&amp;gt;bounds[2*i+1] defines the range where to walk for dimension i (both bounds are included in the walked coordinates). The bounds should be ordered for each dimension (bounds[2*i] &amp;lt;= bounds[2*i+1]).</source>
          <target state="translated">&lt;em&gt;境界&lt;/em&gt; &amp;gt;境界[2 * I + 1]の次元iについて歩く範囲を定義-引数は、[2 * i]には、結合した範囲（2 * iter-&amp;gt; AO-&amp;gt; ND）アレイであると期待されます（両方の境界は、ウォークされた座標に含まれます）。境界は、次元ごとに順序付けする必要があります（bounds [2 * i] &amp;lt;= bounds [2 * i + 1]）。</target>
        </trans-unit>
        <trans-unit id="167173497ff130611588ae9a0a550c00ffde124f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;compile-time&lt;/em&gt; environment variables:</source>
          <target state="translated">&lt;em&gt;コンパイル時の&lt;/em&gt;環境変数：</target>
        </trans-unit>
        <trans-unit id="ea1fe523a0552e237800f38d8997bfcb72c8d0f5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;func&lt;/em&gt;, &lt;em&gt;data&lt;/em&gt;, &lt;em&gt;types&lt;/em&gt;, &lt;em&gt;name&lt;/em&gt;, and &lt;em&gt;doc&lt;/em&gt; arguments are not copied by &lt;a href=&quot;#c.PyUFunc_FromFuncAndData&quot;&gt;&lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt;&lt;/a&gt;. The caller must ensure that the memory used by these arrays is not freed as long as the ufunc object is alive.</source>
          <target state="translated">&lt;em&gt;FUNC&lt;/em&gt;、&lt;em&gt;データ&lt;/em&gt;、&lt;em&gt;種類&lt;/em&gt;、&lt;em&gt;名前&lt;/em&gt;、および&lt;em&gt;ドキュメントの&lt;/em&gt;引数はでコピーされません&lt;a href=&quot;#c.PyUFunc_FromFuncAndData&quot;&gt; &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; &lt;/a&gt;。呼び出し元は、これらの配列で使用されているメモリがufuncオブジェクトが有効である限り解放されないようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="20c9d63d4d93167ef641a021fb26c115a182b092" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;itemsize&lt;/em&gt; key allows the total size of the dtype to be set, and must be an integer large enough so all the fields are within the dtype. If the dtype being constructed is aligned, the &lt;em&gt;itemsize&lt;/em&gt; must also be divisible by the struct alignment. Total dtype &lt;em&gt;itemsize&lt;/em&gt; is limited to &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt;&lt;code&gt;ctypes.c_int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;itemsize&lt;/em&gt;キーはDTYPEの合計サイズを設定することができ、そしてすべてのフィールドがDTYPE内にあるように、整数十分な大きさでなければなりません。構築さDTYPEが整列されている場合、&lt;em&gt;itemsizeは&lt;/em&gt;また、構造体の配向で割り切れなければなりません。合計dtype &lt;em&gt;itemsize&lt;/em&gt;は&lt;em&gt;ctypes.c_int&lt;/em&gt;に制限されてい&lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt; &lt;code&gt;ctypes.c_int&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ed9f0881461d81b2f7af8ce5229589ca6d28abd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;-dimensional FFT of real input.</source>
          <target state="translated">実数入力の&lt;em&gt;n&lt;/em&gt;次元FFT。</target>
        </trans-unit>
        <trans-unit id="35066a9f7cb50260dfe6cd2d771163f62f1011ce" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">&lt;em&gt;N&lt;/em&gt;次元FFT。</target>
        </trans-unit>
        <trans-unit id="1f82e353fb8bee88c46f056efaf0e1b9b205e05a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;out&lt;/em&gt; argument to &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt; is not supported, &lt;code&gt;third&lt;/code&gt; has to be None.</source>
          <target state="translated">&lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt;への&lt;em&gt;out&lt;/em&gt;引数はサポートされていません。3 &lt;code&gt;third&lt;/code&gt; はNoneでなければなりません。</target>
        </trans-unit>
        <trans-unit id="17d0c90784f11b0394d45b1939c2a01c10fdf407" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;shape&lt;/em&gt; is the fixed shape of the sub-array described by this data type, and &lt;em&gt;item_dtype&lt;/em&gt; the data type of the array.</source>
          <target state="translated">&lt;em&gt;形状は、&lt;/em&gt;このデータ型によって記述サブアレイの固定された形状であり、&lt;em&gt;item_dtype&lt;/em&gt;アレイのデータ・タイプ。</target>
        </trans-unit>
        <trans-unit id="e35e90d2e4f0ba849a49c1795babe3ab2a9f08fe" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;side&lt;/em&gt; argument indicates whether the index returned should be that of the first suitable location (if &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt;) or of the last (if &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;側&lt;/em&gt;引数が返されるインデックスがなければならないかどうかを示す第一の適切な位置の（IF &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt; ）または最後の（場合 &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="099bc64f90d3db4f6c006d553b07493bf40349bd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sorter&lt;/em&gt; argument, if not &lt;code&gt;NULL&lt;/code&gt;, must be a 1D array of integer indices the same length as &lt;em&gt;self&lt;/em&gt;, that sorts it into ascending order. This is typically the result of a call to &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt;&lt;code&gt;PyArray_ArgSort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) Binary search is used to find the required insertion points.</source>
          <target state="translated">&lt;em&gt;ソータ&lt;/em&gt;ない場合引数は、 &lt;code&gt;NULL&lt;/code&gt; 、整数インデックスの1次元配列と同じ長さでなければならない&lt;em&gt;自己&lt;/em&gt;、昇順にソートしてあります。これは通常、&lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt; &lt;code&gt;PyArray_ArgSort&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）の呼び出しの結果です。必要な挿入ポイントを見つけるために、バイナリ検索が使用されます。</target>
        </trans-unit>
        <trans-unit id="9171c42e0d10b56599a94002523d8b2e0c0e8b3e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;.npy&lt;/strong&gt; and &lt;strong&gt;.npz&lt;/strong&gt; files store data, shape, dtype, and other information required to reconstruct the ndarray in a way that allows the array to be correctly retrieved, even when the file is on another machine with different architecture.</source>
          <target state="translated">&lt;strong&gt;.npy&lt;/strong&gt;と&lt;strong&gt;.npz&lt;/strong&gt;ファイルストアデータ、形状、DTYPE、およびその他の情報は、ファイルが別のアーキテクチャを用いて別のマシン上にある場合でも、アレイが正しく取得されることを可能にする方法でndarrayを再構成するために必要。</target>
        </trans-unit>
        <trans-unit id="a635945c029e67349a5e1c329cf33ef8efa9b4ec" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;dots&lt;/strong&gt; (&lt;code&gt;...&lt;/code&gt;) represent as many colons as needed to produce a complete indexing tuple. For example, if &lt;code&gt;x&lt;/code&gt; is an array with 5 axes, then</source>
          <target state="translated">&lt;strong&gt;ドット&lt;/strong&gt;（ &lt;code&gt;...&lt;/code&gt; は、完全なインデックスタプルを生成するために、必要に応じて）多くのコロンとして表します。たとえば、 &lt;code&gt;x&lt;/code&gt; が5軸の配列の場合、</target>
        </trans-unit>
        <trans-unit id="7fad9b84d117a49a76f66aa7359451abb9299209" translate="yes" xml:space="preserve">
          <source>The API exposed by NumPy for third-party extensions has grown over years of releases, and has allowed programmers to directly access NumPy functionality from C. This API can be best described as &amp;ldquo;organic&amp;rdquo;. It has emerged from multiple competing desires and from multiple points of view over the years, strongly influenced by the desire to make it easy for users to move to NumPy from Numeric and Numarray. The core API originated with Numeric in 1995 and there are patterns such as the heavy use of macros written to mimic Python&amp;rsquo;s C-API as well as account for compiler technology of the late 90&amp;rsquo;s. There is also only a small group of volunteers who have had very little time to spend on improving this API.</source>
          <target state="translated">サードパーティの拡張機能のためにNumPyによって公開されたAPIは、長年にわたってリリースされており、プログラマーはCからNumPy機能に直接アクセスできるようになりました。このAPIは「オーガニック」として最もよく説明できます。これは、ユーザーがNumericおよびNumarrayからNumPyに簡単に移行できるようにしたいという強い影響を受けて、長年にわたる複数の競合する欲求および複数の視点から浮上しました。コアAPIは1995年にNumericで開発され、PythonのC-APIを模倣して90年代後半のコンパイラーテクノロジーを説明するために書かれたマクロの多用などのパターンがあります。また、このAPIの改善に費やす時間がほとんどないボランティアの小さなグループしかありません。</target>
        </trans-unit>
        <trans-unit id="00284168716cc312202174053f58f3f176efd9f0" translate="yes" xml:space="preserve">
          <source>The Array Interface</source>
          <target state="translated">配列インターフェース</target>
        </trans-unit>
        <trans-unit id="0126a67e2a45442b450ea70b10470e175bf968af" translate="yes" xml:space="preserve">
          <source>The Bartlett window is defined as</source>
          <target state="translated">バートレットウィンドウは次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="937ca2e1b9d54c371bf73ce20e57493839ccf829" translate="yes" xml:space="preserve">
          <source>The Bartlett window is very similar to a triangular window, except that the end points are at zero. It is often used in signal processing for tapering a signal, without generating too much ripple in the frequency domain.</source>
          <target state="translated">バートレット窓は三角窓に非常に似ていますが、終点がゼロであることを除いては、三角窓に似ています。バートレット窓は、周波数領域でのリップルをあまり発生させずに信号を先細りさせるために、信号処理でよく使用されます。</target>
        </trans-unit>
        <trans-unit id="a093f7952b1838c4dd6aeda28ea5e1fc38030960" translate="yes" xml:space="preserve">
          <source>The Basics</source>
          <target state="translated">基本的なこと</target>
        </trans-unit>
        <trans-unit id="9c87b609239622a7f33fd7054a79bbe3b69d99bf" translate="yes" xml:space="preserve">
          <source>The Beta distribution is a special case of the Dirichlet distribution, and is related to the Gamma distribution. It has the probability distribution function</source>
          <target state="translated">ベータ分布は、ディリクレ分布の特殊なケースであり、ガンマ分布に関連しています。これは確率分布関数</target>
        </trans-unit>
        <trans-unit id="2fd0f76d8d8eab0518886bc71aed9b0148fca33e" translate="yes" xml:space="preserve">
          <source>The BitGenerator can also be directly accessed using the members of the &lt;code&gt;bitgen_t&lt;/code&gt; struct.</source>
          <target state="translated">BitGeneratorは、 &lt;code&gt;bitgen_t&lt;/code&gt; 構造体のメンバーを使用して直接アクセスすることもできます。</target>
        </trans-unit>
        <trans-unit id="b111fe41355b271c80f9d028d2e71b1df692e910" translate="yes" xml:space="preserve">
          <source>The BitGenerator can also be directly accessed using the members of the basic RNG structure.</source>
          <target state="translated">BitGeneratorは、基本的なRNG構造のメンバーを使用して直接アクセスすることもできます。</target>
        </trans-unit>
        <trans-unit id="fe9a0ff0e1aba5f3307dd340548f412e309bd12d" translate="yes" xml:space="preserve">
          <source>The BitGenerators have been designed to be extendable using standard tools for high-performance Python &amp;ndash; numba and Cython. The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; object can also be used with user-provided BitGenerators as long as these export a small set of required functions.</source>
          <target state="translated">BitGeneratorsは、高性能Pythonの標準ツールであるnumbaおよびCythonを使用して拡張できるように設計されています。&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;オブジェクトは、これらの輸出限りユーザ提供BitGeneratorsで必要な機能の小さなセットを使用することができます。</target>
        </trans-unit>
        <trans-unit id="d038e7d7a9d5b6013d6bf710bb0f42c26b9ffb86" translate="yes" xml:space="preserve">
          <source>The Blackman window is a taper formed by using the first three terms of a summation of cosines. It was designed to have close to the minimal leakage possible. It is close to optimal, only slightly worse than a Kaiser window.</source>
          <target state="translated">ブラックマン窓は、余弦の和の最初の3項を使用して形成されたテーパーです。これは、可能な限り漏れを最小限に抑えるように設計されています。最適に近く、カイザー窓よりもわずかに悪いだけです。</target>
        </trans-unit>
        <trans-unit id="df8aff554aa2b04bd579ded0666721d3f45ae21e" translate="yes" xml:space="preserve">
          <source>The Blackman window is defined as</source>
          <target state="translated">ブラックマンウィンドウは次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="b108efac05f697f2e430596f72b3bb61068c8903" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using &lt;code&gt;Generator&lt;/code&gt; for the normal distribution or any other distribution that relies on the normal such as the &lt;a href=&quot;generated/numpy.random.generator.gamma#numpy.random.Generator.gamma&quot;&gt;&lt;code&gt;Generator.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.generator.standard_t#numpy.random.Generator.standard_t&quot;&gt;&lt;code&gt;Generator.standard_t&lt;/code&gt;&lt;/a&gt;. If you require bitwise backward compatible streams, use &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;, i.e., &lt;a href=&quot;generated/numpy.random.randomstate.gamma#numpy.random.RandomState.gamma&quot;&gt;&lt;code&gt;RandomState.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.randomstate.standard_t#numpy.random.RandomState.standard_t&quot;&gt;&lt;code&gt;RandomState.standard_t&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NumPyの法線を生成するために使用されるBox-Muller法は、&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;では使用できなくなりました。正規分布または&lt;a href=&quot;generated/numpy.random.generator.gamma#numpy.random.Generator.gamma&quot;&gt; &lt;code&gt;Generator.gamma&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;generated/numpy.random.generator.standard_t#numpy.random.Generator.standard_t&quot;&gt; &lt;code&gt;Generator.standard_t&lt;/code&gt; &lt;/a&gt;などの正規に依存するその他の分布に対して、 &lt;code&gt;Generator&lt;/code&gt; を使用して正確なランダム値を再現することはできません。ビット単位の下位互換性のあるストリームが必要な場合は、&lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;、つまり&lt;a href=&quot;generated/numpy.random.randomstate.gamma#numpy.random.RandomState.gamma&quot;&gt; &lt;code&gt;RandomState.gamma&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;generated/numpy.random.randomstate.standard_t#numpy.random.RandomState.standard_t&quot;&gt; &lt;code&gt;RandomState.standard_t&lt;/code&gt; を使用し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="201133c822c73c7e6eedbd7735bf455db76c868e" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using &lt;code&gt;Generator&lt;/code&gt; for the normal distribution or any other distribution that relies on the normal such as the &lt;code&gt;gamma&lt;/code&gt; or &lt;code&gt;standard_t&lt;/code&gt;. If you require bitwise backward compatible streams, use &lt;code&gt;RandomState&lt;/code&gt;.</source>
          <target state="translated">NumPyの法線を生成するために使用されるBox-Mullerメソッドは、&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;では使用できなくなりました。 &lt;code&gt;Generator&lt;/code&gt; を使用して正規分布や、 &lt;code&gt;gamma&lt;/code&gt; や &lt;code&gt;standard_t&lt;/code&gt; などの正規分布に依存する他の分布に対して正確なランダム値を再現することはできません。ビット単位の下位互換性のあるストリームが必要な場合は、 &lt;code&gt;RandomState&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="530afb1a91925fe435a9294f8360e96b319ffb64" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using Generator for the normal distribution or any other distribution that relies on the normal such as the &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.gamma#numpy.random.mtrand.RandomState.gamma&quot;&gt;&lt;code&gt;RandomState.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.standard_t#numpy.random.mtrand.RandomState.standard_t&quot;&gt;&lt;code&gt;RandomState.standard_t&lt;/code&gt;&lt;/a&gt;. If you require bitwise backward compatible streams, use &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NumPyの法線を生成するために使用されるBox-Mullerメソッドは、&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;では使用できなくなりました。&lt;a href=&quot;generated/numpy.random.mtrand.randomstate.gamma#numpy.random.mtrand.RandomState.gamma&quot;&gt; &lt;code&gt;RandomState.gamma&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;generated/numpy.random.mtrand.randomstate.standard_t#numpy.random.mtrand.RandomState.standard_t&quot;&gt; &lt;code&gt;RandomState.standard_t&lt;/code&gt; &lt;/a&gt;などの正規分布または正規分布に依存するその他の分布に対して、Generatorを使用して正確なランダム値を再現することはできません。ビット単位の下位互換性のあるストリームが必要な場合は、&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="21ca435d6d38aadf77947319cb2cc6cd824fa4fc" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using Generator for the normal distribution or any other distribution that relies on the normal such as the &lt;a href=&quot;generated/numpy.random.randomstate.gamma#numpy.random.RandomState.gamma&quot;&gt;&lt;code&gt;RandomState.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.randomstate.standard_t#numpy.random.RandomState.standard_t&quot;&gt;&lt;code&gt;RandomState.standard_t&lt;/code&gt;&lt;/a&gt;. If you require bitwise backward compatible streams, use &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NumPyの法線を生成するために使用されるBox-Muller法は、&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;では使用できなくなりました。正規分布または&lt;a href=&quot;generated/numpy.random.randomstate.gamma#numpy.random.RandomState.gamma&quot;&gt; &lt;code&gt;RandomState.gamma&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;generated/numpy.random.randomstate.standard_t#numpy.random.RandomState.standard_t&quot;&gt; &lt;code&gt;RandomState.standard_t&lt;/code&gt; &lt;/a&gt;などの正規に依存するその他の分布に対してGeneratorを使用して正確なランダム値を再現することはできません。ビット単位の下位互換性のあるストリームが必要な場合は、&lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="08ca8f1d4aa8ba16007dde802489e6ef41f52bf0" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available.</source>
          <target state="translated">NumPyの法線を生成するために使用されるBox-Mullerメソッドは使用できなくなりました。</target>
        </trans-unit>
        <trans-unit id="2ae4a149c67359ea20a856b43946c0a1b6f16635" translate="yes" xml:space="preserve">
          <source>The Broadcasting Rule</source>
          <target state="translated">放送ルール</target>
        </trans-unit>
        <trans-unit id="9895a5af5b1d937c582f3977255f2f51e2fa8cde" translate="yes" xml:space="preserve">
          <source>The C ABI version number in numpy/core/setup_common.py should only be updated for a major release.</source>
          <target state="translated">numpy/core/setup_common.pyのC ABIのバージョン番号は、メジャーリリースの場合のみ更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="9f1ca425ef21b0d3713606817fa90d6d2d43ef46" translate="yes" xml:space="preserve">
          <source>The C API version needs to be tracked in three places</source>
          <target state="translated">C API のバージョンを 3 つの場所で追跡する必要があります。</target>
        </trans-unit>
        <trans-unit id="12c85becd504bcc9e1840ed9b25393915f66f319" translate="yes" xml:space="preserve">
          <source>The C code to be wrapped for argoutview arrays are characterized by pointers: pointers to the dimensions and double pointers to the data, so that these values can be passed back to the user. The argoutview typemap signatures are therefore</source>
          <target state="translated">argoutview配列のためにラップされるCコードは,次元へのポインタとデータへのダブルポインタというポインタによって特徴づけられます.したがって、argoutviewのタイプマップのシグネチャは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="21de11f0f6aeb101275d43918daa34e6c36dce23" translate="yes" xml:space="preserve">
          <source>The C file is given below.</source>
          <target state="translated">Cファイルは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="ce59a78e88c7f509dea5f34f975be44fdfb7e3ba" translate="yes" xml:space="preserve">
          <source>The C file is given below. The ufunc generated takes two arguments A and B. It returns a tuple whose first element is A*B and whose second element is logit(A*B). Note that it automatically supports broadcasting, as well as all other properties of a ufunc.</source>
          <target state="translated">Cファイルは以下の通りです。ufuncはAとBの2つの引数をとり、最初の要素がA*B、2番目の要素がlogit(A*B)であるタプルを返します。ufuncの他の特性と同様に、自動的にブロードキャストをサポートしていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="3b86dcfa016c911d4342c93c728710eb6da34647" translate="yes" xml:space="preserve">
          <source>The C-API is actually an array of function pointers. This array is created (and pointed to by a global variable) by import_ufunc. The global variable is either statically defined or allowed to be seen by other files depending on the state of &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt;&lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C-APIは、実際には関数ポインタの配列です。この配列は、import_ufuncによって作成（およびグローバル変数によってポイント）されます。グローバル変数は、&lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt; &lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt; の&lt;/a&gt;状態に応じて、静的に定義されるか、他のファイルからの参照を許可されます。</target>
        </trans-unit>
        <trans-unit id="96e666c1c0b5a663da4c4f946173e189e8d49d4f" translate="yes" xml:space="preserve">
          <source>The C-code generated by Cython is hard to read and modify (and typically compiles with annoying but harmless warnings).</source>
          <target state="translated">Cythonで生成されたCコードは読みにくく、修正が困難です(そして、典型的には迷惑だが無害な警告を伴ってコンパイルされています)。</target>
        </trans-unit>
        <trans-unit id="27ac48dd933ed72b23987767613d8001cf662454" translate="yes" xml:space="preserve">
          <source>The C-structure corresponding to an object of &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; is used to keep track of a pointer into an N-dimensional array. It contains associated information used to quickly march through the array. The pointer can be adjusted in three basic ways: 1) advance to the &amp;ldquo;next&amp;rdquo; position in the array in a C-style contiguous fashion, 2) advance to an arbitrary N-dimensional coordinate in the array, and 3) advance to an arbitrary one-dimensional index into the array. The members of the &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; structure are used in these calculations. Iterator objects keep their own dimension and strides information about an array. This can be adjusted as needed for &amp;ldquo;broadcasting,&amp;rdquo; or to loop over only specific dimensions.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; の&lt;/a&gt;オブジェクトに対応するC構造体は&lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;です。&lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; は、&lt;/a&gt; N次元配列にポインタを追跡するために使用されます。これには、アレイ全体をすばやく移動するために使用される関連情報が含まれています。ポインターは、3つの基本的な方法で調整できます。1）Cスタイルの連続した方法で配列の「次の」位置に進む、2）配列の任意のN次元座標に進む、3）配列に進む配列への任意の1次元インデックス。&lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;のメンバーこれらの計算では構造が使用されます。イテレータオブジェクトは独自の次元を保持し、配列に関する情報をストライドします。これは、「ブロードキャスト」、または特定のディメンションのみをループするために、必要に応じて調整できます。</target>
        </trans-unit>
        <trans-unit id="5b65035b5e2ef1f9ddd680e8269d8b6e8cd78edf" translate="yes" xml:space="preserve">
          <source>The C-structure corresponding to an object of &lt;a href=&quot;#c.PyArrayNeighborhoodIter_Type&quot;&gt;&lt;code&gt;PyArrayNeighborhoodIter_Type&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;#c.PyArrayNeighborhoodIterObject&quot;&gt;&lt;code&gt;PyArrayNeighborhoodIterObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArrayNeighborhoodIter_Type&quot;&gt; &lt;code&gt;PyArrayNeighborhoodIter_Type&lt;/code&gt; の&lt;/a&gt;オブジェクトに対応するC構造体は&lt;a href=&quot;#c.PyArrayNeighborhoodIterObject&quot;&gt; &lt;code&gt;PyArrayNeighborhoodIterObject&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="b70a592ea3e52c944c4250fca143b3a7150ee3c2" translate="yes" xml:space="preserve">
          <source>The Cauchy distribution arises in the solution to the driven harmonic oscillator problem, and also describes spectral line broadening. It also describes the distribution of values at which a line tilted at a random angle will cut the x axis.</source>
          <target state="translated">Cauchy 分布は、従動高調波発振器問題の解で発生し、スペクトル線の広がりを記述します。また、ランダムな角度で傾いた線がx軸を切る値の分布も記述しています。</target>
        </trans-unit>
        <trans-unit id="7e16b7bac76fd95a18826e75104c29f03fcae229" translate="yes" xml:space="preserve">
          <source>The Chebyshev class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the methods listed below.</source>
          <target state="translated">Chebyshevクラスは、標準のPython数値メソッド「+」、「-」、「*」、「//」、「％」、「divmod」、「**」、および「（）」と、リストされたメソッドを提供します未満。</target>
        </trans-unit>
        <trans-unit id="c6a112ce3f849b264d8d346313df28993dc02ff9" translate="yes" xml:space="preserve">
          <source>The Chebyshev points of the first kind are the points &lt;code&gt;cos(x)&lt;/code&gt;, where &lt;code&gt;x = [pi*(k + .5)/npts for k in range(npts)]&lt;/code&gt;.</source>
          <target state="translated">第1種のChebyshev点は、点 &lt;code&gt;cos(x)&lt;/code&gt; です。ここで、 &lt;code&gt;x = [pi*(k + .5)/npts for k in range(npts)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b0a900a5e45540387f1b83ea73e67c934d19eae" translate="yes" xml:space="preserve">
          <source>The Chebyshev points of the first kind.</source>
          <target state="translated">第一種のチェビシェフポイント。</target>
        </trans-unit>
        <trans-unit id="ca4f0f30abc65b046f7d9e6e691b51c78603fec0" translate="yes" xml:space="preserve">
          <source>The Chebyshev points of the second kind are the points &lt;code&gt;cos(x)&lt;/code&gt;, where &lt;code&gt;x = [pi*k/(npts - 1) for k in range(npts)]&lt;/code&gt;.</source>
          <target state="translated">第2の種類のChebyshev点は、点 &lt;code&gt;cos(x)&lt;/code&gt; です。ここで、 &lt;code&gt;x = [pi*k/(npts - 1) for k in range(npts)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="196d20b8bbd6f4729eb062a203e433edbc71fdcc" translate="yes" xml:space="preserve">
          <source>The Chebyshev points of the second kind.</source>
          <target state="translated">第二種のチェビシェフポイント。</target>
        </trans-unit>
        <trans-unit id="18aa36d5e6637359f0f8c985312900157e497010" translate="yes" xml:space="preserve">
          <source>The Chebyshev polynomials used in the interpolation are orthogonal when sampled at the Chebyshev points of the first kind. If it is desired to constrain some of the coefficients they can simply be set to the desired value after the interpolation, no new interpolation or fit is needed. This is especially useful if it is known apriori that some of coefficients are zero. For instance, if the function is even then the coefficients of the terms of odd degree in the result can be set to zero.</source>
          <target state="translated">補間に使用されるチェビシェフ多項式は、第1種のチェビシェフ点でサンプリングされたときに直交します。係数のいくつかを拘束したい場合は、補間後に単に所望の値に設定することができ、新しい補間や適合は必要ありません。これは、係数のいくつかがゼロであることが事前にわかっている場合に特に有用です。例えば、関数が偶数の場合、結果の奇数次数の項の係数をゼロに設定することができます。</target>
        </trans-unit>
        <trans-unit id="993466511b9f370f4f72797c543b0fe46fcac4af" translate="yes" xml:space="preserve">
          <source>The Chebyshev series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">チェビシェフ級数の基底多項式は &lt;code&gt;x&lt;/code&gt; のべき乗ではないため、この関数の結果は直観的に見えない可能性があります。</target>
        </trans-unit>
        <trans-unit id="46d5d357969a2c2d8e943734dcd70f209f532e7d" translate="yes" xml:space="preserve">
          <source>The Cholesky decomposition is often used as a fast way of solving</source>
          <target state="translated">コレスキー分解は、次のような問題を解くための高速な方法としてよく使われます。</target>
        </trans-unit>
        <trans-unit id="794b3c9b410012bd85aeaac5a58c341f1529d513" translate="yes" xml:space="preserve">
          <source>The Code of Conduct Committee should aim to have a resolution agreed upon within two weeks. In the event that a resolution can&amp;rsquo;t be determined in that time, the committee will respond to the reporter(s) with an update and projected timeline for resolution.</source>
          <target state="translated">行動規範委員会は、2週間以内に決議に合意することを目指すべきです。その時間内に解決策を決定できない場合、委員会は、解決策の更新と予定されたタイムラインで記者に応答します。</target>
        </trans-unit>
        <trans-unit id="df5489514988058a36fb9ae08de6595979ec21a6" translate="yes" xml:space="preserve">
          <source>The Code of Conduct Committee will formally review and sign off on all cases where this mechanism has been applied to make sure it is not being used to control ordinary heated disagreement.</source>
          <target state="translated">行動規範委員会は、この仕組みが適用された全てのケースについて、通常の加熱した意見の相違をコントロールするために使用されていないことを確認するために、正式にレビューし、サインオフします。</target>
        </trans-unit>
        <trans-unit id="4e3bda4dc5a743a992fdb89cad8080af0867b844" translate="yes" xml:space="preserve">
          <source>The Council can create subcommittees that provide leadership and guidance for specific aspects of the project. Like the Council as a whole, subcommittees should conduct their business in an open and public manner unless privacy is specifically called for. Private subcommittee communications should happen on the main private mailing list of the Council unless specifically called for.</source>
          <target state="translated">審議会は、プロジェクトの特定の側面について指導と指導を行う小委員会を設置することができます。審議会全体と同様に、分科委員会も、特にプライバシーの保護が求められない限り、公開された方法で業務を行うべきである。分科委員会の非公開の連絡は、特に要請がない限り、審議会のメインの非公開メーリングリストで行うべきである。</target>
        </trans-unit>
        <trans-unit id="7cca4e29456fdc96aaa3058f6b88f125bd4fb528" translate="yes" xml:space="preserve">
          <source>The Council reserves the right to eject current Members, if they are deemed to be actively harmful to the project&amp;rsquo;s well-being, and attempts at communication and conflict resolution have failed. This requires the consensus of the remaining Members.</source>
          <target state="translated">評議会は、現在のメンバーがプロジェクトの幸福に積極的に有害であると見なされ、コミュニケーションと紛争解決の試みが失敗した場合、メンバーを解任する権利を留保します。これには、残りのメンバーのコンセンサスが必要です。</target>
        </trans-unit>
        <trans-unit id="777c1bc322cb9c22bf40b3217235aef27f1cd1cf" translate="yes" xml:space="preserve">
          <source>The Council will maintain one narrowly focused subcommittee to manage its interactions with NumFOCUS.</source>
          <target state="translated">協議会は、NumFOCUSとの相互作用を管理するために、1つの絞られた小委員会を維持する。</target>
        </trans-unit>
        <trans-unit id="7319ec02e3cbbaab7add308cd0a417516f369a3b" translate="yes" xml:space="preserve">
          <source>The DFT is defined, with the conventions used in this implementation, in the documentation for the &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">DFTは、この実装で使用される規則&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt;、numpy.fftモジュールのドキュメントで定義されています。</target>
        </trans-unit>
        <trans-unit id="c850428d828f95dc2c92af14d3b7a369fbb6f873" translate="yes" xml:space="preserve">
          <source>The DFT is in general defined for complex inputs and outputs, and a single-frequency component at linear frequency</source>
          <target state="translated">DFTは一般的に複雑な入力と出力に対して定義され、線形周波数での単一周波数成分</target>
        </trans-unit>
        <trans-unit id="e1f0dbe8081449397bad0aa2cc6ad0fe41215d23" translate="yes" xml:space="preserve">
          <source>The Datetime and Timedelta data types support a large number of time units, as well as generic units which can be coerced into any of the other units based on input data.</source>
          <target state="translated">Datetime と Timedelta データ型は、多数の時間単位と、入力データに基づいて他の単位に強制的に変換できる汎用単位をサポートしています。</target>
        </trans-unit>
        <trans-unit id="fcc8fbde1f068047c588e86f64b1d9bca100dc12" translate="yes" xml:space="preserve">
          <source>The Dirichlet distribution is a distribution over vectors</source>
          <target state="translated">ディリクレ分布はベクトルに対する分布である</target>
        </trans-unit>
        <trans-unit id="a4edf1637ded5c0257b8e49c407baa1302046498" translate="yes" xml:space="preserve">
          <source>The Einstein summation convention can be used to compute many multi-dimensional, linear algebraic array operations. &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; provides a succinct way of representing these.</source>
          <target state="translated">Einstein総和規則を使用して、多くの多次元線形代数配列演算を計算できます。&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;は、これらを表現する簡潔な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="28b073ac0a61d366802edc13aac74cfca673e0d2" translate="yes" xml:space="preserve">
          <source>The Euler constant</source>
          <target state="translated">オイラー定数</target>
        </trans-unit>
        <trans-unit id="e516b8e0c93fdf83378c5af74b4c3f11ab8b2eec" translate="yes" xml:space="preserve">
          <source>The F statistic is used to compare in-group variances to between-group variances. Calculating the distribution depends on the sampling, and so it is a function of the respective degrees of freedom in the problem. The variable &lt;code&gt;dfnum&lt;/code&gt; is the number of samples minus one, the between-groups degrees of freedom, while &lt;code&gt;dfden&lt;/code&gt; is the within-groups degrees of freedom, the sum of the number of samples in each group minus the number of groups.</source>
          <target state="translated">F統計は、グループ内の分散とグループ間の分散を比較するために使用されます。分布の計算はサンプリングに依存するため、問題のそれぞれの自由度の関数です。変数 &lt;code&gt;dfnum&lt;/code&gt; は、サンプル数から1を引いたもので、グループ間の自由度です。一方、 &lt;code&gt;dfden&lt;/code&gt; は、グループ内の自由度で、各グループのサンプル数の合計からグループ数を引いたものです。</target>
        </trans-unit>
        <trans-unit id="ec341083311bc5d9e93dc0e719289499e7876f9f" translate="yes" xml:space="preserve">
          <source>The F2PY interface to Fortran 90 module data is similar to Fortran 77 common blocks.</source>
          <target state="translated">Fortran 90 モジュールデータへの F2PY インターフェイスは、Fortran 77 の共通ブロックに似ています。</target>
        </trans-unit>
        <trans-unit id="255611abe871551a6f0d10449c721d9ac320d3a5" translate="yes" xml:space="preserve">
          <source>The Frobenius norm is given by &lt;a href=&quot;#rac1c834adb66-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;:</source>
          <target state="translated">フロベニウスノルムは&lt;a href=&quot;#rac1c834adb66-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;によって与えられます。</target>
        </trans-unit>
        <trans-unit id="4ebf7b4a74f003f8630476569ef53bec8c91caed" translate="yes" xml:space="preserve">
          <source>The GIL is released for all &lt;code&gt;np.einsum&lt;/code&gt; variations</source>
          <target state="translated">GILはすべての &lt;code&gt;np.einsum&lt;/code&gt; バリエーションでリリースされます</target>
        </trans-unit>
        <trans-unit id="7783b7563d5c19477bd0cec8f560b128f37ead00" translate="yes" xml:space="preserve">
          <source>The Gamma distribution is often used to model the times to failure of electronic components, and arises naturally in processes for which the waiting times between Poisson distributed events are relevant.</source>
          <target state="translated">ガンマ分布は、電子部品の故障までの時間をモデル化するためによく使用され、ポアソン分布イベント間の待ち時間が関連するプロセスで自然に発生します。</target>
        </trans-unit>
        <trans-unit id="9c990e445bfb7966adc1e3b9adac640f1e0e9113" translate="yes" xml:space="preserve">
          <source>The Generator&amp;rsquo;s normal, exponential and gamma functions use 256-step Ziggurat methods which are 2-10 times faster than NumPy&amp;rsquo;s Box-Muller or inverse CDF implementations.</source>
          <target state="translated">ジェネレーターの通常の指数関数およびガンマ関数は、NumPyのBox-Mullerまたは逆CDF実装よりも2〜10倍速い256ステップのZigguratメソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="5fd129bc188ef44c6bd32a38b068d9f3ddc783f7" translate="yes" xml:space="preserve">
          <source>The Gumbel (named for German mathematician Emil Julius Gumbel) was used very early in the hydrology literature, for modeling the occurrence of flood events. It is also used for modeling maximum wind speed and rainfall rates. It is a &amp;ldquo;fat-tailed&amp;rdquo; distribution - the probability of an event in the tail of the distribution is larger than if one used a Gaussian, hence the surprisingly frequent occurrence of 100-year floods. Floods were initially modeled as a Gaussian process, which underestimated the frequency of extreme events.</source>
          <target state="translated">ガンベル（ドイツの数学者エミルジュリアスガンベルにちなんで名付けられました）は、洪水の発生をモデル化するために、水文学の非常に早い段階で使用されました。また、最大風速と降雨率のモデリングにも使用されます。これは「ファットテール」分布です。分布のテールでのイベントの確率は、ガウス分布を使用した場合よりも大きいため、驚くほど頻繁に100年の洪水が発生します。洪水は当初、ガウス過程としてモデル化され、極端なイベントの頻度を過小評価していました。</target>
        </trans-unit>
        <trans-unit id="aa1cbdb34f4d0d2f5ba482222c9284e53a83897b" translate="yes" xml:space="preserve">
          <source>The Gumbel (or Smallest Extreme Value (SEV) or the Smallest Extreme Value Type I) distribution is one of a class of Generalized Extreme Value (GEV) distributions used in modeling extreme value problems. The Gumbel is a special case of the Extreme Value Type I distribution for maximums from distributions with &amp;ldquo;exponential-like&amp;rdquo; tails.</source>
          <target state="translated">ガンベル（または最小極値（SEV）または最小極値タイプI）分布は、極値問題のモデリングで使用される一般化極値（GEV）分布のクラスの1つです。ガンベルは、「指数のような」裾をもつ分布からの最大値に対する極値タイプI分布の特殊なケースです。</target>
        </trans-unit>
        <trans-unit id="d38e3c533241c1cffef7a77e2fb316d839d0e953" translate="yes" xml:space="preserve">
          <source>The Hamming was named for R. W. Hamming, an associate of J. W. Tukey and is described in Blackman and Tukey. It was recommended for smoothing the truncated autocovariance function in the time domain. Most references to the Hamming window come from the signal processing literature, where it is used as one of many windowing functions for smoothing values. It is also known as an apodization (which means &amp;ldquo;removing the foot&amp;rdquo;, i.e. smoothing discontinuities at the beginning and end of the sampled signal) or tapering function.</source>
          <target state="translated">ハミングは、JWチューキーの仲間であるRWハミングにちなんで名付けられ、BlackmanとTukeyで説明されています。時間領域で打ち切られた自己共分散関数を平滑化するために推奨されました。ハミングウィンドウへのほとんどの参照は、値を平滑化するための多くのウィンドウ関数の1つとして使用される信号処理の文献から来ています。これは、アポダイゼーション（「足を取り除く」、つまり、サンプリングされた信号の最初と最後の不連続性を滑らかにすること）またはテーパー機能としても知られています。</target>
        </trans-unit>
        <trans-unit id="f6f99a10c7b1d0ed496e360cabc47ad0e8b4f95f" translate="yes" xml:space="preserve">
          <source>The Hamming window is a taper formed by using a weighted cosine.</source>
          <target state="translated">ハミング窓は、加重余弦を用いて形成されたテーパーである。</target>
        </trans-unit>
        <trans-unit id="c543c8775de7884a498fb8d25199a6da7865f313" translate="yes" xml:space="preserve">
          <source>The Hamming window is defined as</source>
          <target state="translated">ハミング窓は次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="c53c036c06b914f30dfda36ac484fab584082b10" translate="yes" xml:space="preserve">
          <source>The Hanning was named for Julius von Hann, an Austrian meteorologist. It is also known as the Cosine Bell. Some authors prefer that it be called a Hann window, to help avoid confusion with the very similar Hamming window.</source>
          <target state="translated">ハニングはオーストリアの気象学者ユリウス・フォン・ハンにちなんで名付けられた。コサインベルとしても知られています。ハミング窓との混同を避けるために、ハニング窓と呼ぶことを好む人もいます。</target>
        </trans-unit>
        <trans-unit id="ff9ff54dbcac5fb28018a438cebbfd23097afaae" translate="yes" xml:space="preserve">
          <source>The Hanning window is a taper formed by using a weighted cosine.</source>
          <target state="translated">ハニング窓は、重み付き余弦を用いて形成されたテーパである。</target>
        </trans-unit>
        <trans-unit id="7063e81cb7e74fa0cdbf05d1c6333c059e7c5e09" translate="yes" xml:space="preserve">
          <source>The Hanning window is defined as</source>
          <target state="translated">ハニングウィンドウは次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="48a86546760e1edd4295f33a270bba0337fe9c75" translate="yes" xml:space="preserve">
          <source>The Heaviside step function is defined as:</source>
          <target state="translated">ヘビサイドステップ関数は、次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="a4ab8a335073ed439b508ce34550cc0419ac6836" translate="yes" xml:space="preserve">
          <source>The Hermite class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Hermiteクラスは、標準のPython数値メソッド「+」、「-」、「*」、「//」、「％」、「divmod」、「**」、および「（）」、および属性と &lt;code&gt;ABCPolyBase&lt;/code&gt; のドキュメントにリストされているメソッド。</target>
        </trans-unit>
        <trans-unit id="18c51c2fe8d0823ca52707c91973d012f1770684" translate="yes" xml:space="preserve">
          <source>The Hermite series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">エルミート級数の基底多項式は &lt;code&gt;x&lt;/code&gt; のべき乗ではないため、この関数の結果は直観的に見えない可能性があります。</target>
        </trans-unit>
        <trans-unit id="29f886dede3063b00d8467b1f756a147bc393097" translate="yes" xml:space="preserve">
          <source>The HermiteE class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">HermiteEクラスは、標準のPython数値メソッド「+」、「-」、「*」、「//」、「％」、「divmod」、「**」、および「（）」、および属性と &lt;code&gt;ABCPolyBase&lt;/code&gt; のドキュメントにリストされているメソッド。</target>
        </trans-unit>
        <trans-unit id="8cc8b1724a44c8d63d2cfd0d81bc585f17fc260c" translate="yes" xml:space="preserve">
          <source>The HermiteE series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">HermiteEシリーズの基底多項式は &lt;code&gt;x&lt;/code&gt; のべき乗ではないため、この関数の結果は直観的に見えない可能性があります。</target>
        </trans-unit>
        <trans-unit id="d4c697a75ca6fe93876f5946baa1a9463872c64a" translate="yes" xml:space="preserve">
          <source>The IRR is perhaps best understood through an example (illustrated using np.irr in the Examples section below). Suppose one invests 100 units and then makes the following withdrawals at regular (fixed) intervals: 39, 59, 55, 20. Assuming the ending value is 0, one&amp;rsquo;s 100 unit investment yields 173 units; however, due to the combination of compounding and the periodic withdrawals, the &amp;ldquo;average&amp;rdquo; rate of return is neither simply 0.73/4 nor (1.73)^0.25-1. Rather, it is the solution (for</source>
          <target state="translated">IRRはおそらく、例（下記の例のセクションでnp.irrを使用して示されています）によって最もよく理解されます。100ユニットを投資し、定期的（固定）間隔で次の引き出しを行うとします。39、59、55、20。終了値が0であるとすると、100ユニットの投資は173ユニットになります。ただし、調合と定期的な引き出しの組み合わせにより、「平均」収益率は単に0.73 / 4でも（1.73）^ 0.25-1でもありません。むしろ、それはソリューションです（</target>
        </trans-unit>
        <trans-unit id="ddbfb62d79e442dbada344aa5b0b7d3f75bd62fd" translate="yes" xml:space="preserve">
          <source>The Kaiser can approximate many other windows by varying the beta parameter.</source>
          <target state="translated">カイザーはβパラメータを変化させることで、他の多くの窓を近似することができます。</target>
        </trans-unit>
        <trans-unit id="61a6a7b7c0a7a3c07a636b9187a5aa5c8ed22e80" translate="yes" xml:space="preserve">
          <source>The Kaiser was named for Jim Kaiser, who discovered a simple approximation to the DPSS window based on Bessel functions. The Kaiser window is a very good approximation to the Digital Prolate Spheroidal Sequence, or Slepian window, which is the transform which maximizes the energy in the main lobe of the window relative to total energy.</source>
          <target state="translated">カイザーは、ベッセル関数に基づいてDPSS窓への単純な近似を発見したジム・カイザーにちなんで命名されました。カイザー窓は、全エネルギーに対して窓の主ローブのエネルギーを最大化する変換であるデジタル・プロレート・スフェロイダル・シーケンス(Slepian window)の非常に優れた近似である。</target>
        </trans-unit>
        <trans-unit id="3c47d6f84b8a7a5230ef01c3b24f485faf045505" translate="yes" xml:space="preserve">
          <source>The Kaiser window is a taper formed by using a Bessel function.</source>
          <target state="translated">カイザー窓は、ベッセル関数を用いて形成されたテーパである。</target>
        </trans-unit>
        <trans-unit id="d40317952ac62ac63be6a7eb42d8bb031447a844" translate="yes" xml:space="preserve">
          <source>The Kaiser window is defined as</source>
          <target state="translated">カイザー窓は次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="de389ba4bc7accb91ca973f3199d4d09bb36d074" translate="yes" xml:space="preserve">
          <source>The Laguerre class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Laguerreクラスは、標準のPython数値メソッド「+」、「-」、「*」、「//」、「％」、「divmod」、「**」、および「（）」、および属性と &lt;code&gt;ABCPolyBase&lt;/code&gt; のドキュメントにリストされているメソッド。</target>
        </trans-unit>
        <trans-unit id="673da347447c32096475798f43cd3eae37f1e962" translate="yes" xml:space="preserve">
          <source>The Laguerre series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">ラゲール級数の基底多項式は &lt;code&gt;x&lt;/code&gt; のべき乗ではないため、この関数の結果は直感的に見えない可能性があります。</target>
        </trans-unit>
        <trans-unit id="beacaa427ac9dd11f90d057bc9c94b6f47608f00" translate="yes" xml:space="preserve">
          <source>The Laplace distribution is similar to the Gaussian/normal distribution, but is sharper at the peak and has fatter tails. It represents the difference between two independent, identically distributed exponential random variables.</source>
          <target state="translated">ラプラス分布は、ガウス分布/正規分布に似ていますが、ピークでシャープになり、尾が太くなります。これは、2つの独立した、同じように分布する指数関数的なランダム変数の間の差を表します。</target>
        </trans-unit>
        <trans-unit id="9f6965544802824fa340cc542a5a8e5ec41b1a8a" translate="yes" xml:space="preserve">
          <source>The Legendre class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Legendreクラスは、標準のPython数値メソッド「+」、「-」、「*」、「//」、「％」、「divmod」、「**」、および「（）」、および属性と &lt;code&gt;ABCPolyBase&lt;/code&gt; のドキュメントにリストされているメソッド。</target>
        </trans-unit>
        <trans-unit id="083c119f1df4d844bfc4b2160deea854a1daea76" translate="yes" xml:space="preserve">
          <source>The Legendre series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">ルジャンドル級数の基底多項式は &lt;code&gt;x&lt;/code&gt; のべき乗ではないため、この関数の結果は直観的に見えない可能性があります。</target>
        </trans-unit>
        <trans-unit id="191a6c01d66efbf4468b0c4b76d708edbb3efb30" translate="yes" xml:space="preserve">
          <source>The Logistic distribution is used in Extreme Value problems where it can act as a mixture of Gumbel distributions, in Epidemiology, and by the World Chess Federation (FIDE) where it is used in the Elo ranking system, assuming the performance of each player is a logistically distributed random variable.</source>
          <target state="translated">ロジスティック分布は、各プレーヤーのパフォーマンスがロジスティックに分布するランダム変数であると仮定して、それがEloランキングシステムで使用されている世界チェス連盟(FIDE)によって、疫学で、それがGumbel分布の混合物として機能することができる極端な値の問題で使用されます。</target>
        </trans-unit>
        <trans-unit id="7e46f1b490ad93ea0aa4b70cea1c8217c1eeec4d" translate="yes" xml:space="preserve">
          <source>The Lomax or Pareto II distribution is a shifted Pareto distribution. The classical Pareto distribution can be obtained from the Lomax distribution by adding 1 and multiplying by the scale parameter &lt;code&gt;m&lt;/code&gt; (see Notes). The smallest value of the Lomax distribution is zero while for the classical Pareto distribution it is &lt;code&gt;mu&lt;/code&gt;, where the standard Pareto distribution has location &lt;code&gt;mu = 1&lt;/code&gt;. Lomax can also be considered as a simplified version of the Generalized Pareto distribution (available in SciPy), with the scale set to one and the location set to zero.</source>
          <target state="translated">LomaxまたはパレートII分布は、シフトされたパレート分布です。古典的なパレート分布は、Lomax分布から1を加算し、スケールパラメーター &lt;code&gt;m&lt;/code&gt; を掛けることで取得できます（「注」を参照）。Lomax分布の最小値はゼロですが、従来のパレート分布の場合は &lt;code&gt;mu&lt;/code&gt; であり、標準のパレート分布の位置は &lt;code&gt;mu = 1&lt;/code&gt; です。Lomaxは、スケールが1に設定され、位置が0に設定された、一般化されたパレート分布（SciPyで利用可能）の簡易バージョンと見なすこともできます。</target>
        </trans-unit>
        <trans-unit id="913eec14ed443e489cdc77c2f2c24950a32724fd" translate="yes" xml:space="preserve">
          <source>The MATLAB &lt;code&gt;rem&lt;/code&gt; function and or the C &lt;code&gt;%&lt;/code&gt; operator which is the complement to &lt;code&gt;int(x1 / x2)&lt;/code&gt;.</source>
          <target state="translated">MATLABの &lt;code&gt;rem&lt;/code&gt; 関数、または &lt;code&gt;int(x1 / x2)&lt;/code&gt; 補数であるC &lt;code&gt;%&lt;/code&gt; 演算子。</target>
        </trans-unit>
        <trans-unit id="accc4f84d711af6e82c6efbbd034211d91d17fc7" translate="yes" xml:space="preserve">
          <source>The MaskedArray class</source>
          <target state="translated">MaskedArray クラス</target>
        </trans-unit>
        <trans-unit id="5110aa799914ad12dc0bd211beae0c5585bdbc96" translate="yes" xml:space="preserve">
          <source>The Matrix class</source>
          <target state="translated">マトリックスクラス</target>
        </trans-unit>
        <trans-unit id="aae8587a9f8f2d6d760d4e3f9211a40fc1df3fef" translate="yes" xml:space="preserve">
          <source>The N-dimensional array (&lt;code&gt;ndarray&lt;/code&gt;)</source>
          <target state="translated">N次元配列（ &lt;code&gt;ndarray&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ebbab7ca4ee7572bcfa080543866bf18ac7ca419" translate="yes" xml:space="preserve">
          <source>The N-dimensional array (ndarray)</source>
          <target state="translated">N次元配列(ndarray)</target>
        </trans-unit>
        <trans-unit id="9062ffe94800b2d5eac1ade12a3d3195e3fb90d9" translate="yes" xml:space="preserve">
          <source>The NPV of the input cash flow series &lt;code&gt;values&lt;/code&gt; at the discount &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">割引&lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt;での入力キャッシュフローシリーズ &lt;code&gt;values&lt;/code&gt; のNPV 。</target>
        </trans-unit>
        <trans-unit id="cb50b084062a9f4384d9b2a21c7bda6e285e1c12" translate="yes" xml:space="preserve">
          <source>The NumFOCUS Subcommittee is comprised of 5 persons who manage project funding that comes through NumFOCUS. It is expected that these funds will be spent in a manner that is consistent with the non-profit mission of NumFOCUS and the direction of the Project as determined by the full Council.</source>
          <target state="translated">NumFOCUS小委員会は、NumFOCUSを経由してくるプロジェクト資金を管理する5人で構成されています。これらの資金は、NumFOCUSの非営利的な使命とプロジェクトの方向性に合致した方法で使用されることが期待されています。</target>
        </trans-unit>
        <trans-unit id="06341e3da348b45983c3d2e0a0cf15e91944f0fa" translate="yes" xml:space="preserve">
          <source>The NumPy 1.6 release includes a more primitive datetime data type than 1.7. This section documents many of the changes that have taken place.</source>
          <target state="translated">NumPy 1.6のリリースには、1.7よりも原始的なデータ型が含まれています。このセクションでは、これまでに行われた変更点の多くを文書化しています。</target>
        </trans-unit>
        <trans-unit id="5b56ea0dc221ea864b938eecd7f439b2151cafda" translate="yes" xml:space="preserve">
          <source>The NumPy &lt;code&gt;histogram&lt;/code&gt; function applied to an array returns a pair of vectors: the histogram of the array and a vector of the bin edges. Beware: &lt;code&gt;matplotlib&lt;/code&gt; also has a function to build histograms (called &lt;code&gt;hist&lt;/code&gt;, as in Matlab) that differs from the one in NumPy. The main difference is that &lt;code&gt;pylab.hist&lt;/code&gt; plots the histogram automatically, while &lt;code&gt;numpy.histogram&lt;/code&gt; only generates the data.</source>
          <target state="translated">配列に適用されたNumPy &lt;code&gt;histogram&lt;/code&gt; 関数は、ベクトルのペアを返します。配列のヒストグラムとビンエッジのベクトルです。注意： &lt;code&gt;matplotlib&lt;/code&gt; には、NumPyのものとは異なるヒストグラム（Matlabでは &lt;code&gt;hist&lt;/code&gt; と呼ばれる）を作成する関数もあります。主な違いは、 &lt;code&gt;pylab.hist&lt;/code&gt; がヒストグラムを自動的にプロットするのに対し、 &lt;code&gt;numpy.histogram&lt;/code&gt; はデータのみを生成することです。</target>
        </trans-unit>
        <trans-unit id="7115851ea78ca88c35b2190db524dfdbfb383870" translate="yes" xml:space="preserve">
          <source>The NumPy C coding conventions are based on Python PEP-0007 by Guido van Rossum with a few added strictures. There are many C coding conventions and it must be emphasized that the primary goal of the NumPy conventions isn&amp;rsquo;t to choose the &amp;lsquo;best&amp;rsquo;, about which there is certain to be disagreement, but to achieve uniformity. Because the NumPy conventions are very close to those in PEP-0007, that PEP is used as a template below with the NumPy additions and variations in the appropriate spots.</source>
          <target state="translated">NumPy Cのコーディング規約は、Guido vanRossumによるPythonPEP-0007に基づいており、いくつかの制限が追加されています。多くのCコーディング規約があり、NumPy規約の主な目的は、不一致が確実にある「最良」を選択することではなく、均一性を実現することであることを強調する必要があります。 NumPyの規則はPEP-0007の規則に非常に近いため、そのPEPは、適切な場所でNumPyを追加および変更して、以下のテンプレートとして使用されます。</target>
        </trans-unit>
        <trans-unit id="04034fa7b7a5e94b567d768903257e06b83fadc3" translate="yes" xml:space="preserve">
          <source>The NumPy Project (The Project) is an open source software project affiliated with the 501(c)3 NumFOCUS Foundation. The goal of The Project is to develop open source software for array-based computing in Python, and in particular the &lt;code&gt;numpy&lt;/code&gt; package, along with related software such as &lt;code&gt;f2py&lt;/code&gt; and the NumPy Sphinx extensions. The Software developed by The Project is released under the BSD (or similar) open source license, developed openly and hosted on public GitHub repositories under the &lt;code&gt;numpy&lt;/code&gt; GitHub organization.</source>
          <target state="translated">NumPyプロジェクト（プロジェクト）は、501（c）3 NumFOCUSFoundationと提携しているオープンソースソフトウェアプロジェクトです。プロジェクトの目標は、Pythonでの配列ベースのコンピューティング用のオープンソースソフトウェア、特に &lt;code&gt;numpy&lt;/code&gt; パッケージを、 &lt;code&gt;f2py&lt;/code&gt; やNumPySphinx拡張機能などの関連ソフトウェアとともに開発することです。プロジェクトによって開発されたソフトウェアは、BSD（または同様の）オープンソースライセンスの下でリリースされ、オープンに開発され、 &lt;code&gt;numpy&lt;/code&gt; GitHub組織の下の公開GitHubリポジトリでホストされます。</target>
        </trans-unit>
        <trans-unit id="318543629420726d92de226b61b0ea2568472ff7" translate="yes" xml:space="preserve">
          <source>The NumPy library contains multidimensional array and matrix data structures (you&amp;rsquo;ll find more information about this in later sections). It provides &lt;strong&gt;ndarray&lt;/strong&gt;, a homogeneous n-dimensional array object, with methods to efficiently operate on it. NumPy can be used to perform a wide variety of mathematical operations on arrays. It adds powerful data structures to Python that guarantee efficient calculations with arrays and matrices and it supplies an enormous library of high-level mathematical functions that operate on these arrays and matrices.</source>
          <target state="translated">NumPyライブラリには、多次元の配列と行列のデータ構造が含まれています（これについての詳細は、後のセクションで説明します）。これは、同種のn次元配列オブジェクトである&lt;strong&gt;ndarrayに&lt;/strong&gt;、効率的に操作するためのメソッドを提供します。NumPyを使用して、配列に対してさまざまな数学演算を実行できます。配列と行列を使用した効率的な計算を保証する強力なデータ構造をPythonに追加し、これらの配列と行列を操作する高レベルの数学関数の膨大なライブラリを提供します。</target>
        </trans-unit>
        <trans-unit id="22808a8257a77bd3771514110cd88913c8cbfe31" translate="yes" xml:space="preserve">
          <source>The NumPy linear algebra functions rely on BLAS and LAPACK to provide efficient low level implementations of standard linear algebra algorithms. Those libraries may be provided by NumPy itself using C versions of a subset of their reference implementations but, when possible, highly optimized libraries that take advantage of specialized processor functionality are preferred. Examples of such libraries are &lt;a href=&quot;https://www.openblas.net/&quot;&gt;OpenBLAS&lt;/a&gt;, MKL (TM), and ATLAS. Because those libraries are multithreaded and processor dependent, environmental variables and external packages such as &lt;a href=&quot;https://github.com/joblib/threadpoolctl&quot;&gt;threadpoolctl&lt;/a&gt; may be needed to control the number of threads or specify the processor architecture.</source>
          <target state="translated">NumPy線形代数関数は、BLASおよびLAPACKに依存して、標準線形代数アルゴリズムの効率的な低レベル実装を提供します。これらのライブラリは、リファレンス実装のサブセットのCバージョンを使用してNumPy自体によって提供される場合がありますが、可能であれば、専用のプロセッサ機能を利用する高度に最適化されたライブラリが推奨されます。そのようなライブラリーの例は、&lt;a href=&quot;https://www.openblas.net/&quot;&gt;OpenBLAS&lt;/a&gt;、MKL（TM）、およびATLASです。これらのライブラリはマルチスレッドでプロセッサに依存しているため、スレッド数の制御やプロセッサアーキテクチャの指定には、環境変数や&lt;a href=&quot;https://github.com/joblib/threadpoolctl&quot;&gt;threadpoolctl&lt;/a&gt;などの外部パッケージが必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="d47a0c6ae88af6350c5a45d963a159c319eddcab" translate="yes" xml:space="preserve">
          <source>The NumPy project welcomes and encourages participation by everyone. We are committed to being a community that everyone enjoys being part of. Although we may not always be able to accommodate each individual&amp;rsquo;s preferences, we try our best to treat everyone kindly.</source>
          <target state="translated">NumPyプロジェクトは、すべての人の参加を歓迎し、奨励しています。私たちは、誰もが参加できるコミュニティになることをお約束します。一人ひとりの好みに対応できるとは限りませんが、皆様のご愛顧に努めております。</target>
        </trans-unit>
        <trans-unit id="d3df208d2d18d19aa23dcbfeea9ad1c54e2544eb" translate="yes" xml:space="preserve">
          <source>The NumPy source code includes an example of a custom data-type as part of its test suite. The file &lt;code&gt;_rational_tests.c.src&lt;/code&gt; in the source code directory &lt;code&gt;numpy/numpy/core/src/umath/&lt;/code&gt; contains an implementation of a data-type that represents a rational number as the ratio of two 32 bit integers.</source>
          <target state="translated">NumPyソースコードには、テストスイートの一部としてカスタムデータ型の例が含まれています。ソースコードディレクトリ &lt;code&gt;numpy/numpy/core/src/umath/&lt;/code&gt; のファイル &lt;code&gt;_rational_tests.c.src&lt;/code&gt; には、2つの32ビット整数の比率として有理数を表すデータ型の実装が含まれています。</target>
        </trans-unit>
        <trans-unit id="5abe575872513074969d9820a4d531c3d12a22f7" translate="yes" xml:space="preserve">
          <source>The Pareto distribution must be greater than zero, and is unbounded above. It is also known as the &amp;ldquo;80-20 rule&amp;rdquo;. In this distribution, 80 percent of the weights are in the lowest 20 percent of the range, while the other 20 percent fill the remaining 80 percent of the range.</source>
          <target state="translated">パレート分布はゼロより大きくなければならず、上に制限はありません。 「80-20ルール」としても知られています。この分布では、重みの80％が範囲の最低20％にあり、残りの20％が範囲の残りの80％を占めています。</target>
        </trans-unit>
        <trans-unit id="b64969899a77da87dee3d04492ed6838966132f3" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#r3973533a530a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="translated">イタリアの経済学者ヴィルフレドパレートにちなんで名付けられたパレート分布は、多くの現実世界の問題で役立つべき法則の確率分布です。経済学の分野以外では、一般的にブラッドフォード分布と呼ばれています。パレートは、経済における富の分布を説明するために分布を開発しました。また、保険、Webページのアクセス統計、油田のサイズ、およびSourceforgeのプロジェクトのダウンロード頻度を含む他の多くの問題にも使用されています&lt;a href=&quot;#r3973533a530a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。これは、いわゆる「ファットテール」分布の1つです。</target>
        </trans-unit>
        <trans-unit id="7bc6e3f7c2b1acfa8159e10332ced928c3809746" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#r4338a4b3d731-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="translated">イタリアの経済学者ヴィルフレドパレートにちなんで名付けられたパレート分布は、多くの現実世界の問題で役立つべき法則の確率分布です。経済学の分野以外では、一般的にブラッドフォード分布と呼ばれています。パレートは、経済における富の分布を説明するために分布を開発しました。また、保険、Webページのアクセス統計、油田のサイズ、およびSourceforgeのプロジェクトのダウンロード頻度を含む他の多くの問題にも使用されています&lt;a href=&quot;#r4338a4b3d731-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。これは、いわゆる「ファットテール」分布の1つです。</target>
        </trans-unit>
        <trans-unit id="ed5b998678bc3c838f5d54a5f0beb5816b99470d" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#r8689274e67cd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="translated">イタリアの経済学者Vilfredo Paretoにちなんで名付けられたパレート分布は、多くの現実世界の問題で役立つべき法則確率分布です。経済学の分野以外では、一般にブラッドフォード分布と呼ばれます。パレートは、経済における富の分布を表すために分布を開発しました。また、保険、Webページのアクセス統計、油田のサイズ、およびSourceforgeのプロジェクトのダウンロード頻度など、他の多くの問題にも使用されています&lt;a href=&quot;#r8689274e67cd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。いわゆる「太った」分布の1つです。</target>
        </trans-unit>
        <trans-unit id="2867a07ee69e6406fe64c658305fdda7fb7b8075" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#rc338d9f74bfc-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="translated">イタリアの経済学者Vilfredo Paretoにちなんで名付けられたパレート分布は、多くの現実世界の問題で役立つべき法則確率分布です。経済学の分野以外では、一般にブラッドフォード分布と呼ばれます。パレートは、経済における富の分布を表すために分布を開発しました。また、保険、Webページのアクセス統計、油田のサイズ、およびSourceforgeのプロジェクトのダウンロード頻度など、他の多くの問題にも使用されています&lt;a href=&quot;#rc338d9f74bfc-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。いわゆる「太った」分布の1つです。</target>
        </trans-unit>
        <trans-unit id="8aa87161535a17c7b4517b9679a26277a14402b5" translate="yes" xml:space="preserve">
          <source>The Poisson distribution</source>
          <target state="translated">ポアソン分布</target>
        </trans-unit>
        <trans-unit id="0ebdde94b2528198e1aa6a1394f362ff4a94706c" translate="yes" xml:space="preserve">
          <source>The Poisson distribution is the limit of the binomial distribution for large N.</source>
          <target state="translated">ポアソン分布は、大きなNに対する二項分布の限界です。</target>
        </trans-unit>
        <trans-unit id="9280ad29766a65718d4060a0ccabd4c148a5c905" translate="yes" xml:space="preserve">
          <source>The Polynomial class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Polynomialクラスは、標準のPython数値メソッド「+」、「-」、「*」、「//」、「％」、「divmod」、「**」、および「（）」、および属性と &lt;code&gt;ABCPolyBase&lt;/code&gt; のドキュメントにリストされているメソッド。</target>
        </trans-unit>
        <trans-unit id="ababcd2092c790cd48094defea5bb6fa5036c0d6" translate="yes" xml:space="preserve">
          <source>The Project</source>
          <target state="translated">プロジェクト</target>
        </trans-unit>
        <trans-unit id="9cd0ae31276093703b68264061cf438be92cd228" translate="yes" xml:space="preserve">
          <source>The Project Community consists of all Contributors and Users of the Project. Contributors work on behalf of and are responsible to the larger Project Community and we strive to keep the barrier between Contributors and Users as low as possible.</source>
          <target state="translated">プロジェクトコミュニティは、プロジェクトのすべてのコントリビューターとユーザーで構成されています。貢献者は、より大きなプロジェクトコミュニティを代表して働き、その責任を負っています。</target>
        </trans-unit>
        <trans-unit id="5d50f5379e9d76b5e7242532277a2b9c64fd49c0" translate="yes" xml:space="preserve">
          <source>The Project is developed by a team of distributed developers, called Contributors. Contributors are individuals who have contributed code, documentation, designs or other work to the Project. Anyone can be a Contributor. Contributors can be affiliated with any legal entity or none. Contributors participate in the project by submitting, reviewing and discussing GitHub Pull Requests and Issues and participating in open and public Project discussions on GitHub, mailing lists, and other channels. The foundation of Project participation is openness and transparency.</source>
          <target state="translated">プロジェクトは、コントリビューターと呼ばれる分散開発者のチームによって開発されています。貢献者とは、プロジェクトにコード、ドキュメント、デザイン、その他の作業を貢献した個人のことです。誰でもコントリビューターになることができます。貢献者は、いかなる法人と提携していてもよいし、提携していなくてもよい。貢献者は、GitHub Pull Requests や Issues を提出したり、レビューしたり、議論したり、GitHub やメーリングリスト、その他のチャンネルで開かれた公開のプロジェクトの議論に参加したりすることで、プロジェクトに参加します。プロジェクトへの参加の基本は、オープン性と透明性です。</target>
        </trans-unit>
        <trans-unit id="c1c2647aef99f143f4382e220b44eada277008ef" translate="yes" xml:space="preserve">
          <source>The Project is formally affiliated with the 501(c)3 NumFOCUS Foundation (&lt;a href=&quot;http://numfocus.org&quot;&gt;http://numfocus.org&lt;/a&gt;), which serves as its fiscal sponsor, may hold project trademarks and other intellectual property, helps manage project donations and acts as a parent legal entity. NumFOCUS is the only legal entity that has a formal relationship with the project (see Institutional Partners section below).</source>
          <target state="translated">プロジェクトは、501（c）3 NumFOCUS Foundation（&lt;a href=&quot;http://numfocus.org&quot;&gt;http://numfocus.org&lt;/a&gt;）と正式に提携しています。この財団は、財政スポンサーとして機能し、プロジェクトの商標やその他の知的財産を保有し、プロジェクトの寄付の管理を支援し、親会社として機能します。エンティティ。NumFOCUSは、プロジェクトと正式な関係を持つ唯一の法人です（以下の機関パートナーのセクションを参照）。</target>
        </trans-unit>
        <trans-unit id="3f211023ee392fd3cd9d9691f710a52d06a9bae2" translate="yes" xml:space="preserve">
          <source>The Project will have a Steering Council that consists of Project Contributors who have produced contributions that are substantial in quality and quantity, and sustained over at least one year. The overall role of the Council is to ensure, with input from the Community, the long-term well-being of the project, both technically and as a community.</source>
          <target state="translated">プロジェクトには、質・量ともに充実した貢献をした貢献者で構成される運営委員会があり、少なくとも 1 年以上の継続的な貢献をしている。運営協議会の全体的な役割は、技術的にもコミュニティとしても、コミュニティからの意見を取り入れながら、プロジェクトの長期的な健全性を確保することである。</target>
        </trans-unit>
        <trans-unit id="827ba55564ba45b324c36aacf3e17c27674e9dcd" translate="yes" xml:space="preserve">
          <source>The PyArrayInterface structure had no descr member at the end (and therefore no flag ARR_HAS_DESCR)</source>
          <target state="translated">PyArrayInterface 構造体の最後には descr メンバがありません (したがって ARR_HAS_DESCR フラグもありません)。</target>
        </trans-unit>
        <trans-unit id="41d158f9c0cb59631db3742cfa40b5047248d25c" translate="yes" xml:space="preserve">
          <source>The PyArrayInterface structure is defined in &lt;code&gt;numpy/ndarrayobject.h&lt;/code&gt; as:</source>
          <target state="translated">PyArrayInterface構造体は、 &lt;code&gt;numpy/ndarrayobject.h&lt;/code&gt; で次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="5f9e4e5af356a67d9cce5fec6bebfc002a3fe5b0" translate="yes" xml:space="preserve">
          <source>The Python exposure supplies two iteration interfaces, one which follows the Python iterator protocol, and another which mirrors the C-style do-while pattern. The native Python approach is better in most cases, but if you need the coordinates or index of an iterator, use the C-style pattern.</source>
          <target state="translated">1つはPythonのイテレータプロトコルに従うもので、もう1つはC-styleのdo-whileパターンをミラーするものです。ほとんどの場合、Pythonのネイティブなアプローチの方が良いでしょうが、イテレータの座標やインデックスが必要な場合はC-styleパターンを使用してください。</target>
        </trans-unit>
        <trans-unit id="52c071d4e6dd56561ca8fc870ab3c5e829454e91" translate="yes" xml:space="preserve">
          <source>The Python function &lt;code&gt;max()&lt;/code&gt; will find the maximum over a one-dimensional array, but it will do so using a slower sequence interface. The reduce method of the maximum ufunc is much faster. Also, the &lt;code&gt;max()&lt;/code&gt; method will not give answers you might expect for arrays with greater than one dimension. The reduce method of minimum also allows you to compute a total minimum over an array.</source>
          <target state="translated">Python関数 &lt;code&gt;max()&lt;/code&gt; は、1次元配列の最大値を検出しますが、より遅いシーケンスインターフェイスを使用して検出します。最大ufuncのreduceメソッドははるかに高速です。また、 &lt;code&gt;max()&lt;/code&gt; メソッドは、1次元を超える配列に対して期待する回答を提供しません。また、reduceメソッドのminimumを使用すると、配列全体の合計最小値を計算することもできます。</target>
        </trans-unit>
        <trans-unit id="faf8bfa039d6b92e8c05db35a7f948162088fe3f" translate="yes" xml:space="preserve">
          <source>The Python interactive interpreter unfortunately prints out the values of expressions inside the while loop during each iteration of the loop. We have modified the output in the examples using this looping construct in order to be more readable.</source>
          <target state="translated">Python の対話型インタプリタは、残念ながらループの各反復中に while ループ内の式の値を出力してしまいます。より読みやすくするために、このループ構造を使用した例の出力を修正しました。</target>
        </trans-unit>
        <trans-unit id="4b9b366242a59401489f5a3a46b627dbab76f505" translate="yes" xml:space="preserve">
          <source>The Python interface that we want is:</source>
          <target state="translated">欲しいのはPythonのインターフェースです。</target>
        </trans-unit>
        <trans-unit id="a4e789fdc99a292c8a541209ecbc17b1d6c5f8c7" translate="yes" xml:space="preserve">
          <source>The Python iterator protocol doesn&amp;rsquo;t have a natural way to query these additional values from the iterator, so we introduce an alternate syntax for iterating with an &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt;. This syntax explicitly works with the iterator object itself, so its properties are readily accessible during iteration. With this looping construct, the current value is accessible by indexing into the iterator, and the index being tracked is the property &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;multi_index&lt;/code&gt; depending on what was requested.</source>
          <target state="translated">Pythonイテレータプロトコルには、イテレータからこれらの追加の値をクエリする自然な方法がないため、&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;で反復するための代替構文を紹介します。この構文はイテレータオブジェクト自体と明示的に連携するため、反復中にそのプロパティに簡単にアクセスできます。このループ構成では、反復子に &lt;code&gt;index&lt;/code&gt; &lt;code&gt;multi_index&lt;/code&gt; ことで現在の値にアクセスでき、追跡されているインデックスは、要求されたものに応じてプロパティインデックスまたはmulti_indexになります。</target>
        </trans-unit>
        <trans-unit id="6867d7144d35416337495ca1b602061770d80f10" translate="yes" xml:space="preserve">
          <source>The Python list representation of the masked array.</source>
          <target state="translated">マスクされた配列のPythonリスト表現。</target>
        </trans-unit>
        <trans-unit id="10730a9ceb03252e7c33bf729de07821aa7c70e5" translate="yes" xml:space="preserve">
          <source>The Python object this chunk of memory comes from. Needed so that memory can be accounted for properly.</source>
          <target state="translated">このメモリのチャンクは Python オブジェクトから来ています。メモリを適切に説明できるようにするために必要です。</target>
        </trans-unit>
        <trans-unit id="0d4a1c83a85c3f9ef90edda93dbe3641642446d4" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &amp;ldquo;random&amp;rdquo; also contains a Mersenne Twister pseudo-random number generator with a number of methods that are similar to the ones available in &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="translated">Python stdlibモジュール「random」には、&lt;a href=&quot;#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; で&lt;/a&gt;使用可能なものと同様のメソッドを備えたMersenneTwister疑似乱数ジェネレーターも含まれています。&lt;a href=&quot;#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; は&lt;/a&gt;、NumPyに対応しているだけでなく、選択できる確率分布の数がはるかに多いという利点があります。</target>
        </trans-unit>
        <trans-unit id="8a0585dac865895f74c0e37d281119c6e2073a73" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &amp;ldquo;random&amp;rdquo; also contains a Mersenne Twister pseudo-random number generator with a number of methods that are similar to the ones available in &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="translated">Python stdlibモジュール「random」には、&lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; で&lt;/a&gt;使用可能なものと同様のいくつかのメソッドを備えたMersenne Twister疑似乱数ジェネレーターも含まれています。&lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; は&lt;/a&gt;、NumPy対応であることに加えて、選択できる確率分布の数がはるかに多いという利点があります。</target>
        </trans-unit>
        <trans-unit id="e2bba830daa553cb7faa782d38dcb55b1552bd1f" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &amp;ldquo;random&amp;rdquo; also contains a Mersenne Twister pseudo-random number generator.</source>
          <target state="translated">Python stdlibモジュール「ランダム」には、Mersenne Twister疑似乱数ジェネレータも含まれています。</target>
        </trans-unit>
        <trans-unit id="d16bb9351563ad26c9ac5328e3a25381d78f799b" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; contains pseudo-random number generator with a number of methods that are similar to the ones available in &lt;code&gt;Generator&lt;/code&gt;. It uses Mersenne Twister, and this bit generator can be accessed using &lt;code&gt;MT19937&lt;/code&gt;. &lt;code&gt;Generator&lt;/code&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="translated">Python stdlibモジュール&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; に&lt;/a&gt;は、 &lt;code&gt;Generator&lt;/code&gt; で利用可能なものと同様のいくつかのメソッドを持つ疑似乱数ジェネレータが含まれています。Mersenne Twisterを使用しており、このビットジェネレーターには &lt;code&gt;MT19937&lt;/code&gt; を使用してアクセスできます。 &lt;code&gt;Generator&lt;/code&gt; は、NumPy対応であることに加えて、選択できる確率分布の数がはるかに多いという利点があります。</target>
        </trans-unit>
        <trans-unit id="da363cfdc7ce6e2caf650d00ffad698f370feca3" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &lt;a href=&quot;generated/numpy.random.random#numpy.random.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; contains pseudo-random number generator with a number of methods that are similar to the ones available in &lt;code&gt;Generator&lt;/code&gt;. It uses Mersenne Twister, and this bit generator can be accessed using &lt;code&gt;MT19937&lt;/code&gt;. &lt;code&gt;Generator&lt;/code&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="translated">Python stdlibモジュール&lt;a href=&quot;generated/numpy.random.random#numpy.random.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; に&lt;/a&gt;は、 &lt;code&gt;Generator&lt;/code&gt; で使用できるものと同様のメソッドを備えた疑似乱数ジェネレーターが含まれています。メルセンヌツイスターを使用しており、このビットジェネレーターには &lt;code&gt;MT19937&lt;/code&gt; を使用してアクセスできます。 &lt;code&gt;Generator&lt;/code&gt; は、NumPyに対応しているだけでなく、選択できる確率分布の数がはるかに多いという利点があります。</target>
        </trans-unit>
        <trans-unit id="bbfe8c34ab4f057b17acc33f18a11bfdb2e17b46" translate="yes" xml:space="preserve">
          <source>The Python type of the ndarray is &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;. In C, every ndarray is a pointer to a &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure. The ob_type member of this structure contains a pointer to the &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; typeobject.</source>
          <target state="translated">ndarrayのPythonタイプは&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;です。Cでは、すべてのndarrayは&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;構造体へのポインターです。この構造体のob_typeメンバーには、&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; typeobject へのポインターが含まれています。</target>
        </trans-unit>
        <trans-unit id="92e614f1f8b5e40429cf0717c65db8d5a132db4d" translate="yes" xml:space="preserve">
          <source>The Rayleigh distribution would arise, for example, if the East and North components of the wind velocity had identical zero-mean Gaussian distributions. Then the wind speed would have a Rayleigh distribution.</source>
          <target state="translated">レイリー分布は、例えば、風速の東成分と北成分が同一のゼロ平均ガウス分布を持つ場合に発生します。そうすると、風速はレイリー分布を持つことになります。</target>
        </trans-unit>
        <trans-unit id="d73f8fe753523f4db33185ee7a9f4cc2e7b4d46f" translate="yes" xml:space="preserve">
          <source>The SciPy Code of Conduct</source>
          <target state="translated">SciPy 行動規範</target>
        </trans-unit>
        <trans-unit id="43e766ac17c08bb4c8b9b072ff682fb439dd2765" translate="yes" xml:space="preserve">
          <source>The SciPy library also contains a &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt;&lt;code&gt;linalg&lt;/code&gt;&lt;/a&gt; submodule, and there is overlap in the functionality provided by the SciPy and NumPy submodules. SciPy contains functions not found in &lt;a href=&quot;#module-numpy.linalg&quot;&gt;&lt;code&gt;numpy.linalg&lt;/code&gt;&lt;/a&gt;, such as functions related to LU decomposition and the Schur decomposition, multiple ways of calculating the pseudoinverse, and matrix transcendentals such as the matrix logarithm. Some functions that exist in both have augmented functionality in &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt;&lt;code&gt;scipy.linalg&lt;/code&gt;&lt;/a&gt;. For example, &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eig.html#scipy.linalg.eig&quot;&gt;&lt;code&gt;scipy.linalg.eig&lt;/code&gt;&lt;/a&gt; can take a second matrix argument for solving generalized eigenvalue problems. Some functions in NumPy, however, have more flexible broadcasting options. For example, &lt;a href=&quot;generated/numpy.linalg.solve#numpy.linalg.solve&quot;&gt;&lt;code&gt;numpy.linalg.solve&lt;/code&gt;&lt;/a&gt; can handle &amp;ldquo;stacked&amp;rdquo; arrays, while &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve.html#scipy.linalg.solve&quot;&gt;&lt;code&gt;scipy.linalg.solve&lt;/code&gt;&lt;/a&gt; accepts only a single square array as its first argument.</source>
          <target state="translated">SciPyライブラリには&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt; &lt;code&gt;linalg&lt;/code&gt; &lt;/a&gt;サブモジュールも含まれており、SciPyサブモジュールとNumPyサブモジュールによって提供される機能には重複があります。 SciPyには、LU分解とSchur分解に関連する関数、&lt;a href=&quot;#module-numpy.linalg&quot;&gt; &lt;code&gt;numpy.linalg&lt;/code&gt; &lt;/a&gt;逆行列を計算する複数の方法、行列の対数などの超越行列など、numpy.linalgにはない関数が含まれています。両方に存在するいくつかの関数は、&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt; &lt;code&gt;scipy.linalg&lt;/code&gt; の&lt;/a&gt;機能が拡張されています。たとえば、&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eig.html#scipy.linalg.eig&quot;&gt; &lt;code&gt;scipy.linalg.eig&lt;/code&gt; &lt;/a&gt;は、一般化された固有値問題を解くために2番目の行列引数を取ることができます。ただし、NumPyの一部の機能には、より柔軟なブロードキャストオプションがあります。たとえば、&lt;a href=&quot;generated/numpy.linalg.solve#numpy.linalg.solve&quot;&gt; &lt;code&gt;numpy.linalg.solve&lt;/code&gt; &lt;/a&gt;は「スタックされた」配列を処理できますが、&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve.html#scipy.linalg.solve&quot;&gt; &lt;code&gt;scipy.linalg.solve&lt;/code&gt; &lt;/a&gt;は、最初の引数として単一の正方形配列のみを受け入れます。</target>
        </trans-unit>
        <trans-unit id="0175f443d47358199cf2723ff7e49526482ab828" translate="yes" xml:space="preserve">
          <source>The Simple Wrapper and Interface Generator (or &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;) is a powerful tool for generating wrapper code for interfacing to a wide variety of scripting languages. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; can parse header files, and using only the code prototypes, create an interface to the target language. But &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; is not omnipotent. For example, it cannot know from the prototype:</source>
          <target state="translated">Simple Wrapper and Interface Generator（または&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;）は、さまざまなスクリプト言語とインターフェースするためのラッパーコードを生成するための強力なツールです。&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;はヘッダーファイルを解析でき、コードプロトタイプのみを使用して、ターゲット言語へのインターフェイスを作成します。しかし、&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;は全能ではありません。たとえば、プロトタイプからはわかりません。</target>
        </trans-unit>
        <trans-unit id="50fd73730ba7e10c720fa72fd00d9f7e0810994f" translate="yes" xml:space="preserve">
          <source>The Steering Council and its Members play a special role in certain situations. In particular, the Council may, if necessary:</source>
          <target state="translated">運営協議会とそのメンバーは、特定の状況において特別な役割を果たします。特に、運営協議会は、必要に応じて、その役割を果たすことができる。</target>
        </trans-unit>
        <trans-unit id="fd611f012e4b731c3416db83b8b9fa4821f6de96" translate="yes" xml:space="preserve">
          <source>The Steering Council are the primary leadership for the project. No outside institution, individual or legal entity has the ability to own, control, usurp or influence the project other than by participating in the Project as Contributors and Council Members. However, because institutions can be an important funding mechanism for the project, it is important to formally acknowledge institutional participation in the project. These are Institutional Partners.</source>
          <target state="translated">運営協議会は、本プロジェクトの主要な指導者である。外部の機関、個人、法人は、コントリビューターや評議会メンバーとしてプロジェクトに参加する以外に、プロジェクトを所有したり、支配したり、簒奪したり、影響を与えたりすることはできません。しかし、機関はプロジェクトの重要な資金調達メカニズムとなり得るため、プロジェクトへの機関の参加を正式に認めることが重要です。これらは機関のパートナーです。</target>
        </trans-unit>
        <trans-unit id="3486112e5f71acaa9b7cc7fff52d1dbfa7f50dd3" translate="yes" xml:space="preserve">
          <source>The Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where the last index is the power of &lt;code&gt;x&lt;/code&gt;. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">ヴァンダーモンド行列。返される行列の形状は &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; で、最後のインデックスは &lt;code&gt;x&lt;/code&gt; のべき乗です。dtypeは、変換された &lt;code&gt;x&lt;/code&gt; と同じになります。</target>
        </trans-unit>
        <trans-unit id="39a7c567f58b9f21ca516451a55bb90e053dd395" translate="yes" xml:space="preserve">
          <source>The Weibull (or Type III asymptotic extreme value distribution for smallest values, SEV Type III, or Rosin-Rammler distribution) is one of a class of Generalized Extreme Value (GEV) distributions used in modeling extreme value problems. This class includes the Gumbel and Frechet distributions.</source>
          <target state="translated">ワイブル(または最小値のためのIII型漸近極限値分布、SEV III型、またはRosin-Rammler分布)は、極限値問題のモデル化に使用される一般化極限値(GEV)分布のクラスの1つです。このクラスには、ガンベル分布とフレッシェ分布が含まれます。</target>
        </trans-unit>
        <trans-unit id="201b34b560ffa9f638b13b95cb2b860322d162bb" translate="yes" xml:space="preserve">
          <source>The Zipf distribution (also known as the zeta distribution) is a continuous probability distribution that satisfies Zipf&amp;rsquo;s law: the frequency of an item is inversely proportional to its rank in a frequency table.</source>
          <target state="translated">Zipf分布（ゼータ分布とも呼ばれます）は、Zipfの法則を満たす連続確率分布です。アイテムの頻度は、頻度テーブルのランクに反比例します。</target>
        </trans-unit>
        <trans-unit id="9f96ae0b2c3d21dc0c18c679782e710a2d562c21" translate="yes" xml:space="preserve">
          <source>The __array_finalize__ method</source>
          <target state="translated">配列_finalize__メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="b8acfe985a2bfa5e5957d0281e0418889b56a0c2" translate="yes" xml:space="preserve">
          <source>The __array_priority__ attribute</source>
          <target state="translated">属性の __array_priority__は</target>
        </trans-unit>
        <trans-unit id="8c8638dacd7dbc859e55b29c8e0ee5d2ee1f9573" translate="yes" xml:space="preserve">
          <source>The __array_wrap__ method</source>
          <target state="translated">配列を作成するための __array_wrap__メソッド</target>
        </trans-unit>
        <trans-unit id="cb048510e93bd94f0172757e215cb9cb29cef573" translate="yes" xml:space="preserve">
          <source>The ability to be used as a context manager is new in NumPy v1.11.0.</source>
          <target state="translated">コンテキストマネージャとして使用できる機能は、NumPy v1.11.0では新しくなりました。</target>
        </trans-unit>
        <trans-unit id="10ff963859461b5262a67238fd0cc7b697172b26" translate="yes" xml:space="preserve">
          <source>The above does not hold for in-place operators, for which &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; never returns &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt;. Hence, &lt;code&gt;arr += obj&lt;/code&gt; would always lead to a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. This is because for arrays in-place operations cannot generically be replaced by a simple reverse operation. (For instance, by default, &lt;code&gt;arr += obj&lt;/code&gt; would be translated to &lt;code&gt;arr =
arr + obj&lt;/code&gt;, i.e., &lt;code&gt;arr&lt;/code&gt; would be replaced, contrary to what is expected for in-place array operations.)</source>
          <target state="translated">上記は、&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;が&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt;を返さないインプレース演算子には当てはまりません。したがって、 &lt;code&gt;arr += obj&lt;/code&gt; は常に&lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; を&lt;/a&gt;引き起こします。これは、配列の場合、インプレース操作を単純な逆操作で一般的に置き換えることはできないためです。（たとえば、デフォルトでは、 &lt;code&gt;arr += obj&lt;/code&gt; は &lt;code&gt;arr = arr + obj&lt;/code&gt; に変換されます。つまり、インプレース配列演算に期待されるものとは逆に、 &lt;code&gt;arr&lt;/code&gt; は置き換えられます。）</target>
        </trans-unit>
        <trans-unit id="68e86910bcee8988f5fee730ecb24162fd22e6a7" translate="yes" xml:space="preserve">
          <source>The above equation is not symmetric in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, so that &lt;code&gt;allclose(a, b)&lt;/code&gt; might be different from &lt;code&gt;allclose(b, a)&lt;/code&gt; in some rare cases.</source>
          <target state="translated">上記の式は &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; で対称ではないため、 &lt;code&gt;allclose(a, b)&lt;/code&gt; が &lt;code&gt;allclose(b, a)&lt;/code&gt; a）と異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="6185045f653324c861d3553f34d55db24911888b" translate="yes" xml:space="preserve">
          <source>The above is &lt;strong&gt;not&lt;/strong&gt; true for advanced indexing.</source>
          <target state="translated">上記は、高度なインデックス作成に&lt;strong&gt;は&lt;/strong&gt;当てはまり&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="21db79b1f2f5936ea0ef3cfbbfc9697c308c56be" translate="yes" xml:space="preserve">
          <source>The above rules may be clearer in the following template source example:</source>
          <target state="translated">以下のテンプレートソースの例では、上記のルールがより明確になっているかもしれません。</target>
        </trans-unit>
        <trans-unit id="bbd30ffed27aefb02b7cc5cbecba164ede0884a8" translate="yes" xml:space="preserve">
          <source>The absolute tolerance parameter (see Notes).</source>
          <target state="translated">絶対許容範囲パラメータ(注記を参照)。</target>
        </trans-unit>
        <trans-unit id="b410151dc56a82d87375b78c87d1aad1438a967a" translate="yes" xml:space="preserve">
          <source>The absolute values of &lt;code&gt;x&lt;/code&gt;, the returned values are always floats. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の絶対値。戻り値は常に浮動小数点です。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="a714cd42c4750db7daf108e375247bf95502ae46" translate="yes" xml:space="preserve">
          <source>The accumulate function is very similar to the reduce function in that the output and the second input both point to the output. The difference is that the second input points to memory one stride behind the current output pointer. Thus, the operation performed is</source>
          <target state="translated">アキュムレート関数は、出力と2番目の入力の両方が出力を指すという点で、リデュース関数と非常に似ています。違いは、2番目の入力が現在の出力ポインタの1ストライド後ろのメモリを指していることです。したがって、実行される操作は</target>
        </trans-unit>
        <trans-unit id="09fde86411dc88385ee0c9001b20e47aa778341c" translate="yes" xml:space="preserve">
          <source>The accumulated values. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">累積値。 &lt;code&gt;out&lt;/code&gt; が指定されている場合、 &lt;code&gt;r&lt;/code&gt; は &lt;code&gt;out&lt;/code&gt; への参照です。</target>
        </trans-unit>
        <trans-unit id="ea47ba00873e187022bea737541efbc8a18ba099" translate="yes" xml:space="preserve">
          <source>The actual object to check.</source>
          <target state="translated">実際にチェックするオブジェクト。</target>
        </trans-unit>
        <trans-unit id="2c2156efeae8cdcc13e079cd68ed8ee62442ae55" translate="yes" xml:space="preserve">
          <source>The actual testing takes place with a Python script named:</source>
          <target state="translated">実際のテストは、Pythonスクリプトという名前で行われます。</target>
        </trans-unit>
        <trans-unit id="b137bb987f3be59004e7fe6c03cebc2b50e503bc" translate="yes" xml:space="preserve">
          <source>The addition of an &lt;code&gt;axis&lt;/code&gt; keyword argument to methods such as &lt;a href=&quot;generated/numpy.random.generator.choice#numpy.random.Generator.choice&quot;&gt;&lt;code&gt;Generator.choice&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt;&lt;code&gt;Generator.permutation&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt;&lt;code&gt;Generator.shuffle&lt;/code&gt;&lt;/a&gt; improves support for sampling from and shuffling multi-dimensional arrays.</source>
          <target state="translated">添加は &lt;code&gt;axis&lt;/code&gt; のような方法には、キーワード引数を&lt;a href=&quot;generated/numpy.random.generator.choice#numpy.random.Generator.choice&quot;&gt; &lt;code&gt;Generator.choice&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt; &lt;code&gt;Generator.permutation&lt;/code&gt; &lt;/a&gt;、及び&lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt; &lt;code&gt;Generator.shuffle&lt;/code&gt; は&lt;/a&gt;からサンプリングし、多次元配列をシャッフルするためのサポートを向上させることができます。</target>
        </trans-unit>
        <trans-unit id="e611ef52ce3f87e2cae1cb595f38cf187d2711d5" translate="yes" xml:space="preserve">
          <source>The advanced indexes are all next to each other. For example &lt;code&gt;x[..., arr1, arr2, :]&lt;/code&gt; but &lt;em&gt;not&lt;/em&gt;&lt;code&gt;x[arr1, :, 1]&lt;/code&gt; since &lt;code&gt;1&lt;/code&gt; is an advanced index in this regard.</source>
          <target state="translated">高度なインデックスはすべて互いに隣接しています。たとえば、 &lt;code&gt;x[..., arr1, arr2, :]&lt;/code&gt; が&lt;em&gt;、&lt;/em&gt; &lt;code&gt;x[arr1, :, 1]&lt;/code&gt; はあり&lt;em&gt;ません&lt;/em&gt;。これは、 &lt;code&gt;1&lt;/code&gt; がこの点で高度なインデックスだからです。</target>
        </trans-unit>
        <trans-unit id="31c1e1991e0db334efbc077fcf4425ba78851bf7" translate="yes" xml:space="preserve">
          <source>The advanced indexes are separated by a slice, &lt;code&gt;Ellipsis&lt;/code&gt; or &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt;. For example &lt;code&gt;x[arr1, :, arr2]&lt;/code&gt;.</source>
          <target state="translated">高度なインデックスはスライス、で区切られて &lt;code&gt;Ellipsis&lt;/code&gt; や&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;。たとえば、 &lt;code&gt;x[arr1, :, arr2]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a0943937a225e08eb4e31b510a59e3603b58c132" translate="yes" xml:space="preserve">
          <source>The advantage of the hand-generated wrapper is that you have complete control over how the C-library gets used and called which can lead to a lean and tight interface with minimal over-head. The disadvantage is that you have to write, debug, and maintain C-code, although most of it can be adapted using the time-honored technique of &amp;ldquo;cutting-pasting-and-modifying&amp;rdquo; from other extension modules. Because, the procedure of calling out to additional C-code is fairly regimented, code-generation procedures have been developed to make this process easier. One of these code-generation techniques is distributed with NumPy and allows easy integration with Fortran and (simple) C code. This package, f2py, will be covered briefly in the next section.</source>
          <target state="translated">手作業で生成されたラッパーの利点は、Cライブラリの使用方法と呼び出し方法を完全に制御できることです。これにより、最小限のオーバーヘッドで無駄のないタイトなインターフェイスを実現できます。欠点は、Cコードを記述、デバッグ、および保守する必要があることですが、そのほとんどは、他の拡張モジュールからの「切り取り、貼り付け、および変更」という昔ながらの手法を使用して適合させることができます。追加のCコードを呼び出す手順はかなり管理されているため、このプロセスを簡単にするためにコード生成手順が開発されました。これらのコード生成手法の1つはNumPyとともに配布されており、Fortranおよび（単純な）Cコードと簡単に統合できます。このパッケージf2pyについては、次のセクションで簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="d764668c927e5f32ce22801332fbd537f1d04076" translate="yes" xml:space="preserve">
          <source>The advantage of this creation function is that one can guarantee the number of elements and the starting and end point, which arange() generally will not do for arbitrary start, stop, and step values.</source>
          <target state="translated">この作成関数の利点は、要素数と始点と終点を保証できることですが、これは一般的に任意の開始値、停止値、ステップ値に対しては arange()ではできません。</target>
        </trans-unit>
        <trans-unit id="51620b35cf3af304da0134bf0e98ad6e2d38905c" translate="yes" xml:space="preserve">
          <source>The advantage of this version of reduce compared to the normal ufunc.reduce is that it makes use of the &lt;a href=&quot;tentative_numpy_tutorial#head-c43f3f81719d84f09ae2b33a22eaf50b26333db8&quot;&gt;Broadcasting Rules&lt;/a&gt; in order to avoid creating an argument array the size of the output times the number of vectors.</source>
          <target state="translated">通常のufunc.reduceと比較したこのバージョンのreduceの利点は、出力のサイズにベクトルの数を掛けた引数配列の作成を回避するために、&lt;a href=&quot;tentative_numpy_tutorial#head-c43f3f81719d84f09ae2b33a22eaf50b26333db8&quot;&gt;ブロードキャストルール&lt;/a&gt;を利用することです。</target>
        </trans-unit>
        <trans-unit id="cbeaf56d095a4acc2c96fd5080608f5dcf659b8a" translate="yes" xml:space="preserve">
          <source>The advantages over random generation include tools to replay and share failures without requiring a fixed seed, reporting &lt;em&gt;minimal&lt;/em&gt; examples for each failure, and better-than-naive-random techniques for triggering bugs.</source>
          <target state="translated">ランダム生成に対する利点には、固定シードを必要とせずに障害を再生および共有するツール、各障害の&lt;em&gt;最小限の&lt;/em&gt;例を報告するツール、およびバグをトリガーするためのナイーブよりも優れたランダム手法が含まれます。</target>
        </trans-unit>
        <trans-unit id="e14666a8704d081387416d669f25517240f5f545" translate="yes" xml:space="preserve">
          <source>The aim of this document is to describe how to add new tools to SciPy.</source>
          <target state="translated">このドキュメントの目的は SciPy に新しいツールを追加する方法を説明することです。</target>
        </trans-unit>
        <trans-unit id="ddbe83e4c507cabc5c6e4f89a6b5af846c612df5" translate="yes" xml:space="preserve">
          <source>The algorithm is carefully designed to eliminate a number of possible ways to collide. For example, if one only does one level of spawning, it is guaranteed that all states will be unique. But it&amp;rsquo;s easier to estimate the naive upper bound on a napkin and take comfort knowing that the probability is actually lower.</source>
          <target state="translated">アルゴリズムは、衝突する可能性のあるいくつかの方法を排除するように慎重に設計されています。たとえば、1レベルのスポーンしか行わない場合、すべての状態が一意になることが保証されます。しかし、ナプキンのナイーブな上限を見積もり、確率が実際には低いことを知って安心する方が簡単です。</target>
        </trans-unit>
        <trans-unit id="31b40688fb93dbcbc32e9b43e4ccf1abfa448a2d" translate="yes" xml:space="preserve">
          <source>The algorithm relies on computing the eigenvalues of the companion matrix &lt;a href=&quot;#r01a8f58ef25b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;.</source>
          <target state="translated">アルゴリズムは、コンパニオン行列&lt;a href=&quot;#r01a8f58ef25b-1&quot; id=&quot;id1&quot;&gt;[1]の&lt;/a&gt;固有値の計算に依存しています。</target>
        </trans-unit>
        <trans-unit id="ddd22305ce6ff69cc69c0e35a34dfdaaddbe6b6d" translate="yes" xml:space="preserve">
          <source>The algorithm works by first finding a &amp;ldquo;running dimension&amp;rdquo;, along which the blocks will be extracted. Given an array of dimensions &lt;code&gt;(d1, d2, ..., dn)&lt;/code&gt;, e.g. if &lt;code&gt;buf_size&lt;/code&gt; is smaller than &lt;code&gt;d1&lt;/code&gt;, the first dimension will be used. If, on the other hand, &lt;code&gt;d1 &amp;lt; buf_size &amp;lt; d1*d2&lt;/code&gt; the second dimension will be used, and so on. Blocks are extracted along this dimension, and when the last block is returned the process continues from the next dimension, until all elements have been read.</source>
          <target state="translated">このアルゴリズムは、最初に「実行中の次元」を見つけることで機能し、それに沿ってブロックが抽出されます。次元の配列 &lt;code&gt;(d1, d2, ..., dn)&lt;/code&gt; 与えられた場合、たとえば、 &lt;code&gt;buf_size&lt;/code&gt; が &lt;code&gt;d1&lt;/code&gt; より小さい場合、最初の次元が使用されます。一方、 &lt;code&gt;d1 &amp;lt; buf_size &amp;lt; d1*d2&lt;/code&gt; 、2番目の次元が使用されます。ブロックはこの次元に沿って抽出され、最後のブロックが返されると、すべての要素が読み取られるまで、プロセスは次の次元から続行されます。</target>
        </trans-unit>
        <trans-unit id="bddd09a9de7b4e7a6ce50c8c2ab936314f5f7ae0" translate="yes" xml:space="preserve">
          <source>The angle of the ray intersecting the unit circle at the given &lt;code&gt;x&lt;/code&gt;-coordinate in radians [0, pi]. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">ラジアン[0、pi]で指定された &lt;code&gt;x&lt;/code&gt; 座標で単位円と交差する光線の角度。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="a13da23a8343744c8c54019aa364c899333968f0" translate="yes" xml:space="preserve">
          <source>The anti-diagonal can be filled by reversing the order of elements using either &lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt;&lt;code&gt;numpy.flipud&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt;&lt;code&gt;numpy.fliplr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">対角線は、&lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt; &lt;code&gt;numpy.flipud&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt; &lt;code&gt;numpy.fliplr&lt;/code&gt; の&lt;/a&gt;いずれかを使用して要素の順序を逆にすることで埋めることができます。</target>
        </trans-unit>
        <trans-unit id="900a13fc7d937db8f345df515885761fbb0acd80" translate="yes" xml:space="preserve">
          <source>The anti-diagonal can be obtained by reversing the order of elements using either &lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt;&lt;code&gt;numpy.flipud&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt;&lt;code&gt;numpy.fliplr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">対角要素は、&lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt; &lt;code&gt;numpy.flipud&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt; &lt;code&gt;numpy.fliplr&lt;/code&gt; &lt;/a&gt;を使用して要素の順序を逆にすることで取得できます。</target>
        </trans-unit>
        <trans-unit id="bdd6673496c6fd17d43bfb63694d67b1a23e7074" translate="yes" xml:space="preserve">
          <source>The approximate decimal resolution of this type, i.e., &lt;code&gt;10**-precision&lt;/code&gt;.</source>
          <target state="translated">このタイプのおおよその10進分解能、つまり &lt;code&gt;10**-precision&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6b2d49779da2fb225e5136c9ad3c68e119d3fee" translate="yes" xml:space="preserve">
          <source>The approximate number of decimal digits to which this kind of float is precise.</source>
          <target state="translated">この種のフロートが正確な小数点以下の桁数の目安。</target>
        </trans-unit>
        <trans-unit id="179dbf39b5fae7c06c4d27f6dfe6017b20eda9b8" translate="yes" xml:space="preserve">
          <source>The argument is considered as a return variable. It is appended to the &lt;code&gt;&amp;lt;returned variables&amp;gt;&lt;/code&gt; list. Using &lt;code&gt;intent(out)&lt;/code&gt; sets &lt;code&gt;intent(hide)&lt;/code&gt; automatically, unless also &lt;code&gt;intent(in)&lt;/code&gt; or &lt;code&gt;intent(inout)&lt;/code&gt; were used.</source>
          <target state="translated">引数は戻り変数と見なされます。 &lt;code&gt;&amp;lt;returned variables&amp;gt;&lt;/code&gt; リストに追加されます。 &lt;code&gt;intent(out)&lt;/code&gt; を使用すると、 &lt;code&gt;intent(in)&lt;/code&gt; または &lt;code&gt;intent(inout)&lt;/code&gt; も使用されていない限り、 &lt;code&gt;intent(hide)&lt;/code&gt; が自動的に設定されます。</target>
        </trans-unit>
        <trans-unit id="c118204e070c804541b682daff7d70c7213a6696" translate="yes" xml:space="preserve">
          <source>The argument is considered as an input-only argument. It means that the value of the argument is passed to Fortran/C function and that function is expected not to change the value of an argument.</source>
          <target state="translated">引数は入力専用の引数とみなされます。これは、引数の値がFortran/C関数に渡され、その関数は引数の値を変更しないことが期待されることを意味します。</target>
        </trans-unit>
        <trans-unit id="7586639cfc35e105e2ea737d69664cf533fb71d1" translate="yes" xml:space="preserve">
          <source>The argument is considered as an input/output or &lt;em&gt;in situ&lt;/em&gt; output argument. &lt;code&gt;intent(inout)&lt;/code&gt; arguments can be only &amp;ldquo;contiguous&amp;rdquo; NumPy arrays with proper type and size. Here &amp;ldquo;contiguous&amp;rdquo; can be either in Fortran or C sense. The latter one coincides with the contiguous concept used in NumPy and is effective only if &lt;code&gt;intent(c)&lt;/code&gt; is used. Fortran contiguity is assumed by default.</source>
          <target state="translated">引数は、入力/出力または&lt;em&gt;その場での&lt;/em&gt;出力引数と見なされます。 &lt;code&gt;intent(inout)&lt;/code&gt; 引数は、適切なタイプとサイズの「連続した」NumPy配列のみにすることができます。ここで「連続」とは、FortranまたはCの意味のいずれかです。後者は、NumPyで使用されている連続した概念と一致し、 &lt;code&gt;intent(c)&lt;/code&gt; が使用されている場合にのみ有効です。デフォルトでは、Fortranの隣接が想定されています。</target>
        </trans-unit>
        <trans-unit id="958b7637686a26352441daf916242ddf2818e972" translate="yes" xml:space="preserve">
          <source>The argument is considered as an input/output or &lt;em&gt;in situ&lt;/em&gt; output argument. &lt;code&gt;intent(inplace)&lt;/code&gt; arguments must be NumPy arrays with proper size. If the type of an array is not &amp;ldquo;proper&amp;rdquo; or the array is non-contiguous then the array will be changed in-place to fix the type and make it contiguous.</source>
          <target state="translated">引数は、入力/出力または&lt;em&gt;その場での&lt;/em&gt;出力引数と見なされます。 &lt;code&gt;intent(inplace)&lt;/code&gt; 引数は、適切なサイズのNumPy配列である必要があります。配列のタイプが「適切」でない場合、または配列が連続していない場合、配列はインプレースで変更されてタイプが修正され、連続します。</target>
        </trans-unit>
        <trans-unit id="f19b8026a1e189b122954edffa090fdbeb3a72f0" translate="yes" xml:space="preserve">
          <source>The argument is removed from the list of required or optional arguments. Typically &lt;code&gt;intent(hide)&lt;/code&gt; is used with &lt;code&gt;intent(out)&lt;/code&gt; or when &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; completely determines the value of the argument like in the following example:</source>
          <target state="translated">引数は、必須またはオプションの引数のリストから削除されます。通常、 &lt;code&gt;intent(hide)&lt;/code&gt; は &lt;code&gt;intent(out)&lt;/code&gt; とともに使用されるか、次の例のように &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; が引数の値を完全に決定するときに使用されます。</target>
        </trans-unit>
        <trans-unit id="898b40f4d53206c78d6c1d07150f357243064d8d" translate="yes" xml:space="preserve">
          <source>The argument is treated as a C scalar or C array argument. In the case of a scalar argument, its value is passed to C function as a C scalar argument (recall that Fortran scalar arguments are actually C pointer arguments). In the case of an array argument, the wrapper function is assumed to treat multidimensional arrays as C-contiguous arrays.</source>
          <target state="translated">引数はCスカラまたはC配列の引数として扱われます。スカラ引数の場合,その値はCスカラ引数としてC関数に渡されます(Fortranのスカラ引数は実際にはCポインタ引数であることを思い出してください).配列引数の場合,ラッパー関数は多次元配列をC連続配列として扱うことを前提としています.</target>
        </trans-unit>
        <trans-unit id="f859808cd7ae59bcb9315c9be074383ed18866fa" translate="yes" xml:space="preserve">
          <source>The argument is treated as a junk of memory. No Fortran nor C contiguity checks are carried out. Using &lt;code&gt;intent(cache)&lt;/code&gt; makes sense only for array arguments, also in connection with &lt;code&gt;intent(hide)&lt;/code&gt; or &lt;code&gt;optional&lt;/code&gt; attributes.</source>
          <target state="translated">引数はメモリのジャンクとして扱われます。FortranやCの隣接性チェックは実行されません。 &lt;code&gt;intent(cache)&lt;/code&gt; の使用は、 &lt;code&gt;intent(hide)&lt;/code&gt; または &lt;code&gt;optional&lt;/code&gt; 属性に関連して、配列引数に対してのみ意味があります。</target>
        </trans-unit>
        <trans-unit id="0fe8c5bbb5b2bd70ddad0ccf0217bddc268f6835" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;ngood&lt;/code&gt; and &lt;code&gt;nbad&lt;/code&gt; each must be less than &lt;code&gt;10**9&lt;/code&gt;. For extremely large arguments, the algorithm that is used to compute the samples &lt;a href=&quot;#r688e4aa3bfc3-4&quot; id=&quot;id1&quot;&gt;[4]&lt;/a&gt; breaks down because of loss of precision in floating point calculations. For such large values, if &lt;code&gt;nsample&lt;/code&gt; is not also large, the distribution can be approximated with the binomial distribution, &lt;code&gt;binomial(n=nsample, p=ngood/(ngood + nbad))&lt;/code&gt;.</source>
          <target state="translated">引数 &lt;code&gt;ngood&lt;/code&gt; と &lt;code&gt;nbad&lt;/code&gt; はそれぞれ &lt;code&gt;10**9&lt;/code&gt; 未満でなければなりません。引数が非常に大きい場合、サンプルの計算に使用されるアルゴリズム&lt;a href=&quot;#r688e4aa3bfc3-4&quot; id=&quot;id1&quot;&gt;[4]&lt;/a&gt;は、浮動小数点計算の精度が失われるために機能しなくなります。このような大きな値の場合、 &lt;code&gt;nsample&lt;/code&gt; も大きくない場合、分布は二項分布 &lt;code&gt;binomial(n=nsample, p=ngood/(ngood + nbad))&lt;/code&gt; で近似できます。</target>
        </trans-unit>
        <trans-unit id="2d355dbffda7b60d25c8fd14c77261de1c537b59" translate="yes" xml:space="preserve">
          <source>The arguments of the &lt;code&gt;configuration&lt;/code&gt; function specify the name of parent SciPy package (&lt;code&gt;parent_package&lt;/code&gt;) and the directory location of the main &lt;code&gt;setup.py&lt;/code&gt; script (&lt;code&gt;top_path&lt;/code&gt;). These arguments, along with the name of the current package, should be passed to the &lt;code&gt;Configuration&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;configuration&lt;/code&gt; 関数の引数は、親SciPyパッケージの名前（ &lt;code&gt;parent_package&lt;/code&gt; ）とメインの &lt;code&gt;setup.py&lt;/code&gt; スクリプトのディレクトリの場所（ &lt;code&gt;top_path&lt;/code&gt; ）を指定します。これらの引数は、現在のパッケージの名前とともに、 &lt;code&gt;Configuration&lt;/code&gt; コンストラクターに渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="5e50719893eed3edf2e32e25c59bbd130545cd4a" translate="yes" xml:space="preserve">
          <source>The arguments that &lt;code&gt;__array_finalize__&lt;/code&gt; receives differ for the three methods of instance creation above.</source>
          <target state="translated">&lt;code&gt;__array_finalize__&lt;/code&gt; が受け取る引数は、上記のインスタンス作成の3つの方法で異なります。</target>
        </trans-unit>
        <trans-unit id="9b1212b40ba5f9b8205d7b64e2e9c20d35b415b3" translate="yes" xml:space="preserve">
          <source>The arithmetic mean is the sum of the elements along the axis divided by the number of elements.</source>
          <target state="translated">算術平均は、軸に沿った要素の総和を要素数で割ったものです。</target>
        </trans-unit>
        <trans-unit id="149dc5ada110e245afebc011f82badc7bfaf2c21" translate="yes" xml:space="preserve">
          <source>The arithmetic mean is the sum of the non-NaN elements along the axis divided by the number of non-NaN elements.</source>
          <target state="translated">算術平均は、軸に沿った非NaN要素の合計を非NaN要素の数で割ったものである。</target>
        </trans-unit>
        <trans-unit id="893ac85ca56066bc9e23a82ef1519d73c4482726" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;v&lt;/code&gt; of eigenvectors may not be of maximum rank, that is, some of the columns may be linearly dependent, although round-off error may obscure that fact. If the eigenvalues are all different, then theoretically the eigenvectors are linearly independent and &lt;code&gt;a&lt;/code&gt; can be diagonalized by a similarity transformation using &lt;code&gt;v&lt;/code&gt;, i.e, &lt;code&gt;inv(v) @ a @ v&lt;/code&gt; is diagonal.</source>
          <target state="translated">固有ベクトルの配列 &lt;code&gt;v&lt;/code&gt; は最大ランクではない可能性があります。つまり、丸め誤差によってその事実が不明瞭になる可能性がありますが、一部の列は線形従属である可能性があります。固有値がすべて異なる場合、理論的には固有ベクトルは線形独立であり &lt;code&gt;a&lt;/code&gt; &lt;code&gt;v&lt;/code&gt; を使用した相似変換によってaを対角化できます。つまり、 &lt;code&gt;inv(v) @ a @ v&lt;/code&gt; は対角です。</target>
        </trans-unit>
        <trans-unit id="a686d6fd794f1b48b235aeae1a3e22a10c775aa4" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;v&lt;/code&gt; of eigenvectors may not be of maximum rank, that is, some of the columns may be linearly dependent, although round-off error may obscure that fact. If the eigenvalues are all different, then theoretically the eigenvectors are linearly independent. Likewise, the (complex-valued) matrix of eigenvectors &lt;code&gt;v&lt;/code&gt; is unitary if the matrix &lt;code&gt;a&lt;/code&gt; is normal, i.e., if &lt;code&gt;dot(a, a.H) = dot(a.H, a)&lt;/code&gt;, where &lt;code&gt;a.H&lt;/code&gt; denotes the conjugate transpose of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">固有ベクトルの配列 &lt;code&gt;v&lt;/code&gt; は最大ランクではない可能性があります。つまり、丸め誤差によりその事実が不明瞭になる可能性がありますが、一部の列は線形従属である可能性があります。固有値がすべて異なる場合、理論的には固有ベクトルは線形独立です。同様に、固有ベクトル &lt;code&gt;v&lt;/code&gt; の（複素数値）行列は、行列 &lt;code&gt;a&lt;/code&gt; が正規の場合、つまり &lt;code&gt;dot(a, a.H) = dot(a.H, a)&lt;/code&gt; 場合、ユニタリーです。ここで、 &lt;code&gt;a.H&lt;/code&gt; は &lt;code&gt;a&lt;/code&gt; の共役転置を示します。</target>
        </trans-unit>
        <trans-unit id="539630988d5b7ef9eff53456e4a77b468fdbbd35" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;x&lt;/code&gt; is prefilled with its filling value.</source>
          <target state="translated">配列 &lt;code&gt;x&lt;/code&gt; には、その充填値が事前に入力されています。</target>
        </trans-unit>
        <trans-unit id="048ae46227673b90cff5c0388062d4ed48f2b030" translate="yes" xml:space="preserve">
          <source>The array assembled from the given blocks.</source>
          <target state="translated">与えられたブロックから組み立てられた配列。</target>
        </trans-unit>
        <trans-unit id="f6532b7ade94739e158787e37c1d9655afff859b" translate="yes" xml:space="preserve">
          <source>The array can be indexed using Python container-like syntax:</source>
          <target state="translated">配列は、Pythonのコンテナのような構文を使ってインデックスを作成することができます。</target>
        </trans-unit>
        <trans-unit id="a7b308d78b11f2c07c75c1db0756393dc3ae53a1" translate="yes" xml:space="preserve">
          <source>The array data-type or scalar for which the default fill value is returned.</source>
          <target state="translated">デフォルトの塗りつぶし値が返される配列のデータ型またはスカラ。</target>
        </trans-unit>
        <trans-unit id="3821c84ea0df179e936beb82ec9c4a845023032b" translate="yes" xml:space="preserve">
          <source>The array element of the current iteration.</source>
          <target state="translated">現在の反復の配列要素。</target>
        </trans-unit>
        <trans-unit id="930ed301b34bfc297be655fe9a537d3e2971d137" translate="yes" xml:space="preserve">
          <source>The array flags cannot be set arbitrarily:</source>
          <target state="translated">配列フラグを任意に設定することはできません。</target>
        </trans-unit>
        <trans-unit id="67bdbd5d8bcbe5caab95cc4d4f8dabba43280775" translate="yes" xml:space="preserve">
          <source>The array for which the string representation of the pickle is returned.</source>
          <target state="translated">ピクルスの文字列表現が返される配列。</target>
        </trans-unit>
        <trans-unit id="2a33c6111cdd8f36d42a5e94437f624d1b58746f" translate="yes" xml:space="preserve">
          <source>The array for which to count non-zeros.</source>
          <target state="translated">ゼロ以外の値をカウントする配列。</target>
        </trans-unit>
        <trans-unit id="ceccbd318dae2746e4f8b98dac923588a6a52441" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays, will be at least 2-D.</source>
          <target state="translated">与えられた配列を積み重ねて形成される配列は、少なくとも2次元となる。</target>
        </trans-unit>
        <trans-unit id="2568bf2e437e715b60f945dc9695881ce8ef667f" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays, will be at least 3-D.</source>
          <target state="translated">与えられた配列を積み重ねて形成された配列は、少なくとも3次元となる。</target>
        </trans-unit>
        <trans-unit id="b2c061ec289a87d3c0d4e9e7c64e5126014d42ed" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays.</source>
          <target state="translated">与えられた配列を積み重ねて形成される配列。</target>
        </trans-unit>
        <trans-unit id="8e505b1ebbfcf9d9aa6a8f699f88f4ba40304f40" translate="yes" xml:space="preserve">
          <source>The array from which values are copied.</source>
          <target state="translated">値がコピーされる配列。</target>
        </trans-unit>
        <trans-unit id="2d987760deb151bcafba733adc9b3a186c4d7f93" translate="yes" xml:space="preserve">
          <source>The array function protocol which allows array-like objects to hook into the NumPy API is currently enabled by default. This option exists since NumPy 1.16 and is enabled by default since NumPy 1.17. It can be disabled using:</source>
          <target state="translated">配列のようなオブジェクトをNumPy APIにフックできるようにする配列関数プロトコルは、現在のところデフォルトで有効になっています。このオプションはNumPy 1.16以降に存在し、NumPy 1.17以降はデフォルトで有効になっています。を使って無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="7c8fb39bbbe950fa5ba32f6dec4764ff1752adf1" translate="yes" xml:space="preserve">
          <source>The array h contains the Householder reflectors that generate q along with r. The tau array contains scaling factors for the reflectors. In the deprecated &amp;lsquo;economic&amp;rsquo; mode only h is returned.</source>
          <target state="translated">配列hには、rとともにqを生成するハウスホルダーリフレクターが含まれています。タウ配列には、リフレクターのスケーリング係数が含まれています。非推奨の「経済的」モードでは、hのみが返されます。</target>
        </trans-unit>
        <trans-unit id="d2932d4203636051c0cde3cab914ac5caf308f90" translate="yes" xml:space="preserve">
          <source>The array interface (sometimes called array protocol) was created in 2005 as a means for array-like Python objects to re-use each other&amp;rsquo;s data buffers intelligently whenever possible. The homogeneous N-dimensional array interface is a default mechanism for objects to share N-dimensional array memory and information. The interface consists of a Python-side and a C-side using two attributes. Objects wishing to be considered an N-dimensional array in application code should support at least one of these attributes. Objects wishing to support an N-dimensional array in application code should look for at least one of these attributes and use the information provided appropriately.</source>
          <target state="translated">配列インターフェイス（配列プロトコルとも呼ばれる）は、配列のようなPythonオブジェクトが互いのデータバッファーを可能な限りインテリジェントに再利用するための手段として2005年に作成されました。同種のN次元配列インターフェースは、オブジェクトがN次元配列のメモリと情報を共有するためのデフォルトのメカニズムです。インターフェースは、2つの属性を使用するPython側とC側で構成されます。アプリケーションコードでN次元配列と見なされるオブジェクトは、これらの属性の少なくとも1つをサポートする必要があります。アプリケーションコードでN次元配列をサポートするオブジェクトは、これらの属性の少なくとも1つを探し、適切に提供された情報を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="3b7adbdac3eaf5c6305f1f61b91018f4287bec67" translate="yes" xml:space="preserve">
          <source>The array into which values are copied.</source>
          <target state="translated">値がコピーされる配列。</target>
        </trans-unit>
        <trans-unit id="8a281d694c98742955f6444ee26a08d74603ea7a" translate="yes" xml:space="preserve">
          <source>The array is filled with a fill value before the string conversion.</source>
          <target state="translated">配列は文字列変換前のフィル値で埋められています。</target>
        </trans-unit>
        <trans-unit id="fba8708c42061e69f757d72f0e5d1d004653f4bc" translate="yes" xml:space="preserve">
          <source>The array is rotated in the plane defined by the axes. Axes must be different.</source>
          <target state="translated">配列は軸で定義された平面内で回転します。軸は異なるものでなければなりません。</target>
        </trans-unit>
        <trans-unit id="9a1223a8243cbae9aaa7753c7ea500a550cf52c0" translate="yes" xml:space="preserve">
          <source>The array iterator encapsulates many of the key features in ufuncs, allowing user code to support features like output parameters, preservation of memory layouts, and buffering of data with the wrong alignment or type, without requiring difficult coding.</source>
          <target state="translated">配列イテレータは ufuncs の主要な機能の多くをカプセル化しており、ユーザーコードは難しいコーディングを必要とせずに、出力パラメータ、メモリレイアウトの保存、間違ったアライメントや型のデータのバッファリングなどの機能をサポートすることができます。</target>
        </trans-unit>
        <trans-unit id="c6e1241b8c7d132ea91621f870c2bd3aaf572b4c" translate="yes" xml:space="preserve">
          <source>The array may be recreated via &lt;code&gt;a = np.array(a.tolist())&lt;/code&gt;, although this may sometimes lose precision.</source>
          <target state="translated">配列は &lt;code&gt;a = np.array(a.tolist())&lt;/code&gt; して再作成できますが、精度が低下する場合があります。</target>
        </trans-unit>
        <trans-unit id="1eee9d9d69514705c81523ac5b902691363a28a0" translate="yes" xml:space="preserve">
          <source>The array of UTC timestamps to format.</source>
          <target state="translated">フォーマットする UTC タイムスタンプの配列。</target>
        </trans-unit>
        <trans-unit id="c75d57d539a00e02934380f0ab251d1c277b5e1c" translate="yes" xml:space="preserve">
          <source>The array of dates to process.</source>
          <target state="translated">処理する日付の配列。</target>
        </trans-unit>
        <trans-unit id="cc2f192e213603a4bcf402844b3339c10f79380e" translate="yes" xml:space="preserve">
          <source>The array of numbers for which the absolute values are required. If &lt;code&gt;x&lt;/code&gt; is a scalar, the result &lt;code&gt;y&lt;/code&gt; will also be a scalar.</source>
          <target state="translated">絶対値が必要な数値の配列。場合 &lt;code&gt;x&lt;/code&gt; はスカラーであり、結果 &lt;code&gt;y&lt;/code&gt; はまたスカラーであろう。</target>
        </trans-unit>
        <trans-unit id="f9c4960d6bbbc8f2591cc039cfe68db4d8e24d90" translate="yes" xml:space="preserve">
          <source>The array of offsets, which is broadcast with &lt;code&gt;dates&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dates&lt;/code&gt; とともにブロードキャストされるオフセットの配列。</target>
        </trans-unit>
        <trans-unit id="2d674fe1383c12f697c52fd3b5198eb57b81bcb7" translate="yes" xml:space="preserve">
          <source>The array of rounded numbers</source>
          <target state="translated">丸められた数字の配列</target>
        </trans-unit>
        <trans-unit id="202adb7679573040b63e561db69df0e93b9eb75e" translate="yes" xml:space="preserve">
          <source>The array of the end dates for counting, which are excluded from the count themselves.</source>
          <target state="translated">カウントの終了日の配列で、カウント自体から除外されます。</target>
        </trans-unit>
        <trans-unit id="f508cbbca81c78d6c3819b4c01ca29622bef56f6" translate="yes" xml:space="preserve">
          <source>The array of the first dates for counting.</source>
          <target state="translated">カウントする最初の日付の配列。</target>
        </trans-unit>
        <trans-unit id="a4e03a6eeebaef72c6a7e32f280b123bbf142ff2" translate="yes" xml:space="preserve">
          <source>The array or list to be shuffled.</source>
          <target state="translated">シャッフルされる配列またはリスト.</target>
        </trans-unit>
        <trans-unit id="1f6abc9406bedaa275a3843a6290b585462b97a3" translate="yes" xml:space="preserve">
          <source>The array or matrix to be repeated.</source>
          <target state="translated">繰り返し行われる配列または行列.</target>
        </trans-unit>
        <trans-unit id="53aead7fb32cb3de7311369b48d13d4953d0adc5" translate="yes" xml:space="preserve">
          <source>The array owns the memory it uses or borrows it from another object.</source>
          <target state="translated">配列は、使用するメモリを所有したり、別のオブジェクトから借りたりします。</target>
        </trans-unit>
        <trans-unit id="8abf01fdd64396d234195c26c60e850e4a12a8d7" translate="yes" xml:space="preserve">
          <source>The array scalar objects have an &lt;code&gt;array priority&lt;/code&gt; of &lt;a href=&quot;c-api.array#c.NPY_SCALAR_PRIORITY&quot;&gt;&lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt;&lt;/a&gt; (-1,000,000.0). They also do not (yet) have a &lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; attribute. Otherwise, they share the same attributes as arrays:</source>
          <target state="translated">配列スカラーオブジェクトの &lt;code&gt;array priority&lt;/code&gt; は&lt;a href=&quot;c-api.array#c.NPY_SCALAR_PRIORITY&quot;&gt; &lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt; &lt;/a&gt;（-1,000,000.0）です。また、（まだ）&lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt;属性も持っていません。それ以外の場合は、配列と同じ属性を共有します。</target>
        </trans-unit>
        <trans-unit id="5774b39bb119ab7d3a197a6eee5e164f12892112" translate="yes" xml:space="preserve">
          <source>The array scalar objects have an &lt;code&gt;array priority&lt;/code&gt; of &lt;a href=&quot;c-api/array#c.NPY_SCALAR_PRIORITY&quot;&gt;&lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt;&lt;/a&gt; (-1,000,000.0). They also do not (yet) have a &lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; attribute. Otherwise, they share the same attributes as arrays:</source>
          <target state="translated">配列スカラーオブジェクトの &lt;code&gt;array priority&lt;/code&gt; は&lt;a href=&quot;c-api/array#c.NPY_SCALAR_PRIORITY&quot;&gt; &lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt; &lt;/a&gt;（-1,000,000.0）です。また、（まだ）&lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt;属性もありません。それ以外の場合、それらは配列と同じ属性を共有します。</target>
        </trans-unit>
        <trans-unit id="8c0162c81e2783b3bcbb0dd799de5c3ba91aba6a" translate="yes" xml:space="preserve">
          <source>The array scalars also offer the same methods and attributes as arrays with the intent that the same code can be used to support arbitrary dimensions (including 0-dimensions). The array scalars are read-only (immutable) with the exception of the void scalar which can also be written to so that structured array field setting works more naturally (a[0][&amp;lsquo;f1&amp;rsquo;] = &lt;code&gt;value&lt;/code&gt; ).</source>
          <target state="translated">配列スカラーは、同じコードを使用して任意の次元（0次元を含む）をサポートできるという意図で、配列と同じメソッドと属性も提供します。配列スカラーは読み取り専用（不変）ですが、構造化配列フィールドの設定がより自然に機能するように書き込むことができるvoidスカラーは例外です（a [0] ['f1'] = &lt;code&gt;value&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d0afa5fdfdf427a8322c75c5712091eca91eabac" translate="yes" xml:space="preserve">
          <source>The array scalars offer a hierarchy of Python types that allow a one- to-one correspondence between the data-type stored in an array and the Python-type that is returned when an element is extracted from the array. An exception to this rule was made with object arrays. Object arrays are heterogeneous collections of arbitrary Python objects. When you select an item from an object array, you get back the original Python object (and not an object array scalar which does exist but is rarely used for practical purposes).</source>
          <target state="translated">配列スカラは、配列に格納されているデータ型と、配列から要素が抽出されたときに返されるPython型との間で1対1の対応を可能にするPython型の階層を提供します。このルールの例外がオブジェクト配列で作られました。オブジェクト配列は任意のPythonオブジェクトの異種コレクションです。オブジェクト配列からアイテムを選択すると、元のPythonオブジェクトが返されます(オブジェクト配列のスカラーではなく、オブジェクト配列のスカラーが存在しますが、実用的な目的ではほとんど使われません)。</target>
        </trans-unit>
        <trans-unit id="4e947f26c0ecf6d9ff639e9f27b5b5f852135d7e" translate="yes" xml:space="preserve">
          <source>The array to act on.</source>
          <target state="translated">操作する配列。</target>
        </trans-unit>
        <trans-unit id="7000ca786d20479930ea43aa17e050c42578abc2" translate="yes" xml:space="preserve">
          <source>The array to be pickled.</source>
          <target state="translated">漬け込む配列。</target>
        </trans-unit>
        <trans-unit id="25694c63a056a35911c5654e87ce1708648d0cd3" translate="yes" xml:space="preserve">
          <source>The array to broadcast.</source>
          <target state="translated">放送するための配列。</target>
        </trans-unit>
        <trans-unit id="61fa35e69f8b8bb03ffef7462ad7cef9c9cdddeb" translate="yes" xml:space="preserve">
          <source>The array to mask. If not a MaskedArray instance (or if no array elements are masked). The result is a MaskedArray with &lt;code&gt;mask&lt;/code&gt; set to &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; (False). Must be a 2D array.</source>
          <target state="translated">マスクする配列。MaskedArrayインスタンスでない場合（または配列要素がマスクされていない場合）。結果は、 &lt;code&gt;mask&lt;/code&gt; が&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;（False）に設定されたMaskedArrayです。2D配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="9a0afda668850edc1a593d4069db9a58418e2d74" translate="yes" xml:space="preserve">
          <source>The array to operate on. If not a MaskedArray instance (or if no array elements are masked), &lt;code&gt;x&lt;/code&gt; is interpreted as a MaskedArray with &lt;code&gt;mask&lt;/code&gt; set to &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;. Must be a 2D array.</source>
          <target state="translated">操作するアレイ。MaskedArrayインスタンスでない場合（または配列要素がマスクされていない場合）、 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;mask&lt;/code&gt; が&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; に&lt;/a&gt;設定されたMaskedArrayとして解釈されます。2D配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="da7df7a6420823a6b7e45bca218ba68631febc25" translate="yes" xml:space="preserve">
          <source>The array to pad.</source>
          <target state="translated">パッドにする配列。</target>
        </trans-unit>
        <trans-unit id="8966af5b1934b124717f0c80ec9988807e784cf9" translate="yes" xml:space="preserve">
          <source>The array to perform in place operation on.</source>
          <target state="translated">その場で操作を行う配列。</target>
        </trans-unit>
        <trans-unit id="1a2586a66b67a305c2797e7e06685302608f4ea4" translate="yes" xml:space="preserve">
          <source>The array whose axes should be reordered.</source>
          <target state="translated">軸の並び替えが必要な配列。</target>
        </trans-unit>
        <trans-unit id="81f5ca8ebafc1afb8a9d51589c5e138b4b807e19" translate="yes" xml:space="preserve">
          <source>The array(s) to be iterated over. Valid only before the iterator is closed.</source>
          <target state="translated">イテレータが終了する前にのみ有効です。イテレータが閉じられる前にのみ有効です。</target>
        </trans-unit>
        <trans-unit id="8c52ea12181e4277b350926a7c51f79608004cd5" translate="yes" xml:space="preserve">
          <source>The array(s) to iterate over.</source>
          <target state="translated">反復処理を行う配列.</target>
        </trans-unit>
        <trans-unit id="ae34a0f5008cfcf7a204a6ae1b41350a0a8ffea9" translate="yes" xml:space="preserve">
          <source>The array-protocol typestring of this data-type object.</source>
          <target state="translated">このデータ型オブジェクトの配列プロトコル型文字列。</target>
        </trans-unit>
        <trans-unit id="342be16484b97c95949f88958c455899735a9596" translate="yes" xml:space="preserve">
          <source>The arrays all have exactly the same shape.</source>
          <target state="translated">配列はすべて全く同じ形をしています。</target>
        </trans-unit>
        <trans-unit id="d48d7d91bb3512b8a648b512669295a09d607ddf" translate="yes" xml:space="preserve">
          <source>The arrays all have the same number of dimensions and the length of each dimensions is either a common length or 1.</source>
          <target state="translated">配列はすべて同じ数の次元を持ち、各次元の長さは共通の長さか1である。</target>
        </trans-unit>
        <trans-unit id="3b32b95e95ce590daa0a88406a7282f0b6f9ae1f" translate="yes" xml:space="preserve">
          <source>The arrays holding the elements to be compared. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">比較する要素を保持する配列。 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状にブロードキャスト可能でなければなりません（これが出力の形状になります）。</target>
        </trans-unit>
        <trans-unit id="b72974524c2659f265dc742386bd383e243bc4a6" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the first axis. 1-D arrays must have the same length.</source>
          <target state="translated">配列は,第1軸以外のすべての軸に沿って同じ形状でなければなりません.1次元配列は,同じ長さでなければなりません.</target>
        </trans-unit>
        <trans-unit id="9548b85aa3e636c88bbbc65cfcdf4e6b5fff4585" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the second axis, except 1-D arrays which can be any length.</source>
          <target state="translated">配列は,任意の長さの1次元配列を除いて,第2軸以外のすべての軸に沿って同じ形状でなければなりません.</target>
        </trans-unit>
        <trans-unit id="34736140b85990281116cda8321b303d602cfb2e" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the third axis. 1-D or 2-D arrays must have the same shape.</source>
          <target state="translated">配列は,3 番目の軸以外のすべての軸に沿って同じ形をしていなければなりません.1次元または2次元の配列は,同じ形状でなければなりません.</target>
        </trans-unit>
        <trans-unit id="250d7318b7910004f5ade9c6bf7fa2a62b2d0aa6" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape, except in the dimension corresponding to &lt;code&gt;axis&lt;/code&gt; (the first, by default).</source>
          <target state="translated">配列は、 &lt;code&gt;axis&lt;/code&gt; 対応する次元（デフォルトでは最初）を除いて、同じ形状でなければなりません。</target>
        </trans-unit>
        <trans-unit id="3650412314ab8d0d6cc595877979b22653a06cac" translate="yes" xml:space="preserve">
          <source>The arrays that have too few dimensions can have their shapes prepended with a dimension of length 1 to satisfy property 2.</source>
          <target state="translated">次元が少なすぎる配列は,特性2を満たすために,その形状の前に長さ1の次元を付加することができます.</target>
        </trans-unit>
        <trans-unit id="3c7fb6624c1c578e967064538473cd4324bc56b1" translate="yes" xml:space="preserve">
          <source>The arrays to be added. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">追加する配列。 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状にブロードキャスト可能でなければなりません（これが出力の形状になります）。</target>
        </trans-unit>
        <trans-unit id="61831d63f8eb03ec54ea81f37b4edf92245e6861" translate="yes" xml:space="preserve">
          <source>The arrays to be subtracted from each other. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">互いに減算される配列。 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状にブロードキャスト可能でなければなりません（これが出力の形状になります）。</target>
        </trans-unit>
        <trans-unit id="b989bf28be4c34813d52a00110756329cfab3199" translate="yes" xml:space="preserve">
          <source>The arrays to broadcast.</source>
          <target state="translated">放送する配列。</target>
        </trans-unit>
        <trans-unit id="4bc127992ac15b346e5ebc50b22b2084cc253474" translate="yes" xml:space="preserve">
          <source>The available functions are defined in &amp;lt;numpy/npy_math.h&amp;gt; - please refer to this header when in doubt.</source>
          <target state="translated">利用可能な関数は&amp;lt;numpy / npy_math.h&amp;gt;で定義されています-不明な場合はこのヘッダーを参照してください。</target>
        </trans-unit>
        <trans-unit id="4c1200844d5256d1bf5c45cf0a767eb7723d9e5e" translate="yes" xml:space="preserve">
          <source>The average along the specified axis. When returned is &lt;code&gt;True&lt;/code&gt;, return a tuple with the average as the first element and the sum of the weights as the second element. The return type is &lt;code&gt;np.float64&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is of integer type and floats smaller than &lt;code&gt;float64&lt;/code&gt;, or the input data-type, otherwise. If returned, &lt;code&gt;sum_of_weights&lt;/code&gt; is always &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">指定された軸に沿った平均。 &lt;code&gt;True&lt;/code&gt; の場合、最初の要素として平均を、2番目の要素として重みの合計を含むタプルを返します。 &lt;code&gt;a&lt;/code&gt; が整数型で &lt;code&gt;float64&lt;/code&gt; より小さい浮動小数点数の場合、戻り値の型は &lt;code&gt;np.float64&lt;/code&gt; です。それ以外の場合は、入力データ型です。返される場合、 &lt;code&gt;sum_of_weights&lt;/code&gt; は常に &lt;code&gt;float64&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="542875b084a7c351a7a1f8a6d2d600675ca4d2a7" translate="yes" xml:space="preserve">
          <source>The average squared deviation is normally calculated as &lt;code&gt;x.sum() / N&lt;/code&gt;, where &lt;code&gt;N = len(x)&lt;/code&gt;. If, however, &lt;code&gt;ddof&lt;/code&gt; is specified, the divisor &lt;code&gt;N - ddof&lt;/code&gt; is used instead. In standard statistical practice, &lt;code&gt;ddof=1&lt;/code&gt; provides an unbiased estimator of the variance of the infinite population. &lt;code&gt;ddof=0&lt;/code&gt; provides a maximum likelihood estimate of the variance for normally distributed variables. The standard deviation computed in this function is the square root of the estimated variance, so even with &lt;code&gt;ddof=1&lt;/code&gt;, it will not be an unbiased estimate of the standard deviation per se.</source>
          <target state="translated">通常、平均二乗偏差は &lt;code&gt;x.sum() / N&lt;/code&gt; として計算されます。ここで、 &lt;code&gt;N = len(x)&lt;/code&gt; です。ただし、 &lt;code&gt;ddof&lt;/code&gt; が指定されている場合は、除数 &lt;code&gt;N - ddof&lt;/code&gt; が代わりに使用されます。標準的な統計手法では、 &lt;code&gt;ddof=1&lt;/code&gt; は、無限母集団の分散の不偏推定量を提供します。 &lt;code&gt;ddof=0&lt;/code&gt; は、正規分布変数の分散の最尤推定を提供します。この関数で計算される標準偏差は、推定された分散の平方根であるため、 &lt;code&gt;ddof=1&lt;/code&gt; を使用しても、標準偏差自体の公平な推定にはなりません。</target>
        </trans-unit>
        <trans-unit id="21ebdcee890d352b954472165e15ea262b078aa8" translate="yes" xml:space="preserve">
          <source>The axes over which to compute the inverse fft. Default is the last two axes.</source>
          <target state="translated">逆ftを計算する軸。デフォルトは最後の2軸です。</target>
        </trans-unit>
        <trans-unit id="3f6da36d69c95a72b5592c0677dd407fdc9cfa2c" translate="yes" xml:space="preserve">
          <source>The axis along which &lt;code&gt;v&lt;/code&gt; are appended. If &lt;code&gt;axis&lt;/code&gt; is not given, both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are flattened before use.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; が追加される軸。場合は &lt;code&gt;axis&lt;/code&gt; 与えられていない、両方の &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; 使用前に平坦化されています。</target>
        </trans-unit>
        <trans-unit id="071585631d8d75cc42162ae0da0a1b91474572d1" translate="yes" xml:space="preserve">
          <source>The axis along which &lt;code&gt;values&lt;/code&gt; are appended. If &lt;code&gt;axis&lt;/code&gt; is not given, both &lt;code&gt;arr&lt;/code&gt; and &lt;code&gt;values&lt;/code&gt; are flattened before use.</source>
          <target state="translated">&lt;code&gt;values&lt;/code&gt; が追加される軸。 &lt;code&gt;axis&lt;/code&gt; が指定されていない場合、 &lt;code&gt;arr&lt;/code&gt; と &lt;code&gt;values&lt;/code&gt; 両方が使用前にフラット化されます。</target>
        </trans-unit>
        <trans-unit id="d25eb0541fd006d52dcbebc548c80309c583cc52" translate="yes" xml:space="preserve">
          <source>The axis along which the arrays will be joined. Default is 0.</source>
          <target state="translated">配列が結合される軸。デフォルトは0です。</target>
        </trans-unit>
        <trans-unit id="ab324f8b42b072f0ce80303066858390de817e59" translate="yes" xml:space="preserve">
          <source>The axis along which the arrays will be joined. If axis is None, arrays are flattened before use. Default is 0.</source>
          <target state="translated">配列を結合する軸。axis が None の場合、配列は使用前に平坦化されます。デフォルトは0です。</target>
        </trans-unit>
        <trans-unit id="b85856e591095eebb92c2f542dccaa68776b00c8" translate="yes" xml:space="preserve">
          <source>The axis along which the difference is taken, default is the last axis.</source>
          <target state="translated">デフォルトは最後の軸です。</target>
        </trans-unit>
        <trans-unit id="848f8430ea7a17384babb0b6d388a2e2e8bda711" translate="yes" xml:space="preserve">
          <source>The axis along which the selection is performed. The default, 0, selects by row.</source>
          <target state="translated">選択が実行される軸。デフォルトの 0 は、行単位で選択します。</target>
        </trans-unit>
        <trans-unit id="db9105950615faa8709d8dba888767b4f466811c" translate="yes" xml:space="preserve">
          <source>The axis along which to apply the accumulation; default is zero.</source>
          <target state="translated">累積を適用する軸。</target>
        </trans-unit>
        <trans-unit id="b45496da67ff059714d0b1ae6911029e831dd2fd" translate="yes" xml:space="preserve">
          <source>The axis along which to apply the reduceat.</source>
          <target state="translated">リダクションを適用する軸。</target>
        </trans-unit>
        <trans-unit id="ef9dbd3a8e7509325fd10ad7183022f46facda83" translate="yes" xml:space="preserve">
          <source>The axis along which to delete the subarray defined by &lt;code&gt;obj&lt;/code&gt;. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;obj&lt;/code&gt; is applied to the flattened array.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; で定義された部分配列を削除する軸。 &lt;code&gt;axis&lt;/code&gt; がNoneの場合、 &lt;code&gt;obj&lt;/code&gt; はフラット化された配列に適用されます。</target>
        </trans-unit>
        <trans-unit id="3c27f5e5d6b589ff51ec356603f9f33684d0e877" translate="yes" xml:space="preserve">
          <source>The axis along which to find the minima. Default is None, in which case the minimum value in the whole array is returned.</source>
          <target state="translated">最小値を求める軸。デフォルトは None で、この場合は配列全体の最小値が返されます。</target>
        </trans-unit>
        <trans-unit id="5932d4cf836b6b58485bd9f15e2f20474363c36f" translate="yes" xml:space="preserve">
          <source>The axis along which to integrate.</source>
          <target state="translated">積分する軸。</target>
        </trans-unit>
        <trans-unit id="0011917dec1b66b996673fed4476058c1c23ee6e" translate="yes" xml:space="preserve">
          <source>The axis along which to repeat values. By default, use the flattened input array, and return a flat output array.</source>
          <target state="translated">値を繰り返す軸。デフォルトでは、平坦化された入力配列を使用し、平坦な出力配列を返します。</target>
        </trans-unit>
        <trans-unit id="407371d3199afc3105f3e75619a63b4981063028" translate="yes" xml:space="preserve">
          <source>The axis along which to split, default is 0.</source>
          <target state="translated">分割する軸、デフォルトは0です。</target>
        </trans-unit>
        <trans-unit id="40f4cb16df8166b16f689cc3f6a27ceb034ca2a8" translate="yes" xml:space="preserve">
          <source>The axis currently being calculated.</source>
          <target state="translated">現在計算中の軸。</target>
        </trans-unit>
        <trans-unit id="779396c94c96c008627d39cce908fca96b699246" translate="yes" xml:space="preserve">
          <source>The axis in the result array along which the input arrays are stacked.</source>
          <target state="translated">入力配列がスタックされる結果配列の軸.</target>
        </trans-unit>
        <trans-unit id="f53c3f1c70993fc128dae4ee501fb80cbace06f6" translate="yes" xml:space="preserve">
          <source>The axis in the result to store the samples. Relevant only if start or stop are array-like. By default (0), the samples will be along a new axis inserted at the beginning. Use -1 to get an axis at the end.</source>
          <target state="translated">サンプルを格納する結果の軸。start または stop が配列のようになっている場合にのみ関係します。デフォルト(0)では、サンプルは最初に挿入された新しい軸に沿って配置されます。最後に軸を取得するには -1 を使用します。</target>
        </trans-unit>
        <trans-unit id="5d9b30084a3b37c792a839c94c54a5cdb7a8cfce" translate="yes" xml:space="preserve">
          <source>The axis is rolled until it lies before this position. The default, 0, results in a &amp;ldquo;complete&amp;rdquo; roll.</source>
          <target state="translated">軸は、この位置の前にくるまでロールされます。デフォルトの0は、「完全な」ロールになります。</target>
        </trans-unit>
        <trans-unit id="bb67daef266f9ea49c20107e1bf4911d74a22608" translate="yes" xml:space="preserve">
          <source>The axis over which to select values. By default, the flattened input array is used.</source>
          <target state="translated">値を選択する軸。デフォルトでは、平坦化された入力配列が使用されます。</target>
        </trans-unit>
        <trans-unit id="6a2ce88413f2bc22b3ef2d3c9420680ad19eebe6" translate="yes" xml:space="preserve">
          <source>The axis to be rolled. The positions of the other axes do not change relative to one another.</source>
          <target state="translated">圧延する軸。他の軸の位置は互いに相対的に変化しません。</target>
        </trans-unit>
        <trans-unit id="d0edfc48d57e03c356c790b28b9213c10fc98a8b" translate="yes" xml:space="preserve">
          <source>The axis to operate on. If None, &lt;code&gt;ar&lt;/code&gt; will be flattened. If an integer, the subarrays indexed by the given axis will be flattened and treated as the elements of a 1-D array with the dimension of the given axis, see the notes for more details. Object arrays or structured arrays that contain objects are not supported if the &lt;code&gt;axis&lt;/code&gt; kwarg is used. The default is None.</source>
          <target state="translated">操作する軸。Noneの場合、 &lt;code&gt;ar&lt;/code&gt; はフラット化されます。整数の場合、指定された軸によってインデックスが付けられたサブ配列は平坦化され、指定された軸の次元を持つ1次元配列の要素として扱われます。詳細については、注を参照してください。 &lt;code&gt;axis&lt;/code&gt; kwargが使用されている場合、オブジェクト配列またはオブジェクトを含む構造化配列はサポートされません。デフォルトは「なし」です。</target>
        </trans-unit>
        <trans-unit id="b9493a9f29cafe569828c852de6864aa7f5d0ff6" translate="yes" xml:space="preserve">
          <source>The axis to roll backwards. The positions of the other axes do not change relative to one another.</source>
          <target state="translated">逆転させる軸。他の軸の位置は互いに相対的に変化しない。</target>
        </trans-unit>
        <trans-unit id="340d3fc196833339a77972eea60efcdfd52ba73c" translate="yes" xml:space="preserve">
          <source>The axis to take 1d slices along. If axis is None, the destination array is treated as if a flattened 1d view had been created of it.</source>
          <target state="translated">1 次元のスライスを取る軸。axis が None の場合,出力配列は,平坦化された 1 次元ビューが作成されたかのように扱われます.</target>
        </trans-unit>
        <trans-unit id="a049beb1044c250e5951941014a3acba639cb49d" translate="yes" xml:space="preserve">
          <source>The axis to take 1d slices along. If axis is None, the input array is treated as if it had first been flattened to 1d, for consistency with &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1dスライスをとる軸。axisがNoneの場合、入力配列は、最初に1dにフラット化されたかのように扱われ、&lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt;との一貫性が保たれます。</target>
        </trans-unit>
        <trans-unit id="a5f8cd862df0c3dc198b03cdec5c823ff5bfd3ca" translate="yes" xml:space="preserve">
          <source>The axis which &lt;code&gt;x&lt;/code&gt; is shuffled along. Default is 0.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; がシャッフルされる軸。デフォルトは0です。</target>
        </trans-unit>
        <trans-unit id="24f5f1b01f9d6c3c18ebf1e91b8c1b0eb06217c1" translate="yes" xml:space="preserve">
          <source>The axis which &lt;code&gt;x&lt;/code&gt; is shuffled along. Default is 0. It is only supported on &lt;code&gt;ndarray&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; がシャッフルされる軸。デフォルトは0です &lt;code&gt;ndarray&lt;/code&gt; オブジェクトでのみサポートされます。</target>
        </trans-unit>
        <trans-unit id="8262154fa6203f128694759e7e2ae715f81f6fa1" translate="yes" xml:space="preserve">
          <source>The base BitGenerator.state must be overridden by a subclass</source>
          <target state="translated">ベースの BitGenerator.state は、サブクラスでオーバーライドする必要があります。</target>
        </trans-unit>
        <trans-unit id="98787e1071b5327d0b2e07537c81bb27588db08e" translate="yes" xml:space="preserve">
          <source>The base case for this recursion is a 0D array:</source>
          <target state="translated">この再帰のベースケースは0次元配列です。</target>
        </trans-unit>
        <trans-unit id="88d21dfd4e25736b7184078ba7f33b64bea753e0" translate="yes" xml:space="preserve">
          <source>The base of an array that owns its memory is None:</source>
          <target state="translated">メモリを所有する配列の基底は None です。</target>
        </trans-unit>
        <trans-unit id="074b16b582d8ec2099beaee8dcbc987839646a35" translate="yes" xml:space="preserve">
          <source>The base of the log space. The step size between the elements in &lt;code&gt;ln(samples) / ln(base)&lt;/code&gt; (or &lt;code&gt;log_base(samples)&lt;/code&gt;) is uniform. Default is 10.0.</source>
          <target state="translated">ログスペースのベース。 &lt;code&gt;ln(samples) / ln(base)&lt;/code&gt; （または &lt;code&gt;log_base(samples)&lt;/code&gt; ）の要素間のステップサイズは均一です。デフォルトは10.0です。</target>
        </trans-unit>
        <trans-unit id="535897fba7f592c8b7dd04c68596d9a31edf2e11" translate="yes" xml:space="preserve">
          <source>The bases in &lt;code&gt;x1&lt;/code&gt; raised to the exponents in &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; の底は &lt;code&gt;x2&lt;/code&gt; の指数に累乗されます。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="707f28b031c35e2bf30d29bbd42946a1e8c7dc8c" translate="yes" xml:space="preserve">
          <source>The bases.</source>
          <target state="translated">基地です。</target>
        </trans-unit>
        <trans-unit id="5bc92f7e413935d311df16000ae397f9e815d85b" translate="yes" xml:space="preserve">
          <source>The basic data element&amp;rsquo;s size in bytes</source>
          <target state="translated">基本データ要素のサイズ（バイト単位）</target>
        </trans-unit>
        <trans-unit id="68fe9eda4da762f1f4d04299c59c07412dcd5a69" translate="yes" xml:space="preserve">
          <source>The basic slice syntax is &lt;code&gt;i:j:k&lt;/code&gt; where &lt;em&gt;i&lt;/em&gt; is the starting index, &lt;em&gt;j&lt;/em&gt; is the stopping index, and &lt;em&gt;k&lt;/em&gt; is the step (</source>
          <target state="translated">基本的なスライス構文は &lt;code&gt;i:j:k&lt;/code&gt; です。ここで、&lt;em&gt;i&lt;/em&gt;は開始インデックス、&lt;em&gt;j&lt;/em&gt;は停止インデックス、&lt;em&gt;k&lt;/em&gt;はステップ（</target>
        </trans-unit>
        <trans-unit id="aeeddb45e8f2002e147b881df220bd44abec802b" translate="yes" xml:space="preserve">
          <source>The basic type character codes are:</source>
          <target state="translated">基本的なタイプの文字コードは</target>
        </trans-unit>
        <trans-unit id="94f38793f86bdba698e5ca03402c847550f50738" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is a Chebyshev basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">基底多項式は、 &lt;code&gt;c&lt;/code&gt; がチェビシェフ基底多項式であるときにコンパニオン行列が対称になるようにスケーリングされます。これは、スケーリングされていない場合よりも優れた固有値推定を提供します。基底多項式の場合、&lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt;を使用してそれらを取得すると、固有値は実数であることが保証されます。</target>
        </trans-unit>
        <trans-unit id="fd443fcafad8cfc7235ab73b5edb8fa2361feb5f" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an Hermite basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">基底多項式は、 &lt;code&gt;c&lt;/code&gt; がエルミート基底多項式である場合にコンパニオン行列が対称になるようにスケーリングされます。これは、スケーリングされていない場合よりも優れた固有値推定を提供します。基底多項式の場合、&lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt;を使用してそれらを取得すると、固有値は実数であることが保証されます。</target>
        </trans-unit>
        <trans-unit id="e1520a86bfcd397936d59363e21a13733e7a71b7" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an HermiteE basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">基底多項式は、 &lt;code&gt;c&lt;/code&gt; がHermiteE基底多項式であるときにコンパニオン行列が対称になるようにスケーリングされます。これは、スケーリングされていない場合よりも優れた固有値推定を提供します。基底多項式の場合、&lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt;を使用してそれらを取得すると、固有値は実数であることが保証されます。</target>
        </trans-unit>
        <trans-unit id="31e8496a7482cd5cd28cb680bd285957a80df61e" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an Legendre basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">基底多項式は、 &lt;code&gt;c&lt;/code&gt; がルジャンドル基底多項式のときにコンパニオン行列が対称になるようにスケーリングされます。これは、スケーリングされていない場合よりも優れた固有値推定を提供します。基底多項式の場合、&lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt;を使用してそれらを取得すると、固有値は実数であることが保証されます。</target>
        </trans-unit>
        <trans-unit id="f437318ff72364f761b90a9b7cf38009e657db81" translate="yes" xml:space="preserve">
          <source>The behavior depends on the arguments in the following way.</source>
          <target state="translated">挙動は以下のように引数に依存します。</target>
        </trans-unit>
        <trans-unit id="52cedd9e4737e7d41b9c0573b9212f2735c44e68" translate="yes" xml:space="preserve">
          <source>The behavior of multi-field indexes changed from Numpy 1.15 to Numpy 1.16.</source>
          <target state="translated">Numpy 1.15からNumpy 1.16へとマルチフィールドインデックスの挙動が変更されました。</target>
        </trans-unit>
        <trans-unit id="7c61d26e0bac97d24671e4708fc43eaa9dd53127" translate="yes" xml:space="preserve">
          <source>The behaviour of NumPy and Python integer types differs significantly for integer overflows and may confuse users expecting NumPy integers to behave similar to Python&amp;rsquo;s &lt;code&gt;int&lt;/code&gt;. Unlike NumPy, the size of Python&amp;rsquo;s &lt;code&gt;int&lt;/code&gt; is flexible. This means Python integers may expand to accommodate any integer and will not overflow.</source>
          <target state="translated">NumPyとPythonの整数型の動作は整数オーバーフローでは大幅に異なり、NumPy整数がPythonの &lt;code&gt;int&lt;/code&gt; と同様に動作することを期待しているユーザーを混乱させる可能性があります。NumPyとは異なり、Pythonの &lt;code&gt;int&lt;/code&gt; のサイズは柔軟です。これは、Python整数が任意の整数に対応するように拡張でき、オーバーフローしないことを意味します。</target>
        </trans-unit>
        <trans-unit id="226707a677bb2dfd051d5e6d30579822a26a8454" translate="yes" xml:space="preserve">
          <source>The benchmark parameters etc. should not depend on which NumPy version is installed.</source>
          <target state="translated">ベンチマークパラメータなどは、インストールされているNumPyのバージョンに依存しないようにしてください。</target>
        </trans-unit>
        <trans-unit id="52a11e20913e7d4cf3019155d32cde05064b5abf" translate="yes" xml:space="preserve">
          <source>The benchmark suite should be importable with any NumPy version.</source>
          <target state="translated">ベンチマークスイートは、NumPyのどのバージョンでもインポート可能でなければなりません。</target>
        </trans-unit>
        <trans-unit id="e2bdcfca6c07efc9e236b5653fc2391d3452350a" translate="yes" xml:space="preserve">
          <source>The best practice is to &lt;strong&gt;not&lt;/strong&gt; reseed a BitGenerator, rather to recreate a new one. This method is here for legacy reasons. This example demonstrates best practice.</source>
          <target state="translated">ベストプラクティスは、BitGeneratorを再シードし&lt;strong&gt;ないで&lt;/strong&gt;、新しいものを再作成することです。この方法はレガシーの理由でここにあります。この例は、ベストプラクティスを示しています。</target>
        </trans-unit>
        <trans-unit id="c109a555c27db42b8f7688c8df998553f8ab7653" translate="yes" xml:space="preserve">
          <source>The best strategy to better understand the code base is to pick something you want to change and start reading the code to figure out how it works. When in doubt, you can ask questions on the mailing list. It is perfectly okay if your pull requests aren&amp;rsquo;t perfect, the community is always happy to help. As a volunteer project, things do sometimes get dropped and it&amp;rsquo;s totally fine to ping us if something has sat without a response for about two to four weeks.</source>
          <target state="translated">コードベースをよりよく理解するための最良の戦略は、変更したいものを選び、コードを読み始めて、それがどのように機能するかを理解することです。疑問がある場合は、メーリングリストで質問することができます。プルリクエストが完全でなくてもまったく問題ありません。コミュニティはいつでも喜んでお手伝いします。ボランティアプロジェクトとして、物事が落ちてしまうことがあります。2〜4週間ほど応答がない場合は、pingを送信しても問題ありません。</target>
        </trans-unit>
        <trans-unit id="aae59e3eb6aeca266807eb2b03def986d4d70e96" translate="yes" xml:space="preserve">
          <source>The best way to become familiar with the iterator is to look at its usage within the NumPy codebase itself. For example, here is a slightly tweaked version of the code for &lt;a href=&quot;array#c.PyArray_CountNonzero&quot;&gt;&lt;code&gt;PyArray_CountNonzero&lt;/code&gt;&lt;/a&gt;, which counts the number of non-zero elements in an array.</source>
          <target state="translated">イテレータに慣れるための最良の方法は、NumPyコードベース自体の中での使用法を調べることです。たとえば、&lt;a href=&quot;array#c.PyArray_CountNonzero&quot;&gt; &lt;code&gt;PyArray_CountNonzero&lt;/code&gt; &lt;/a&gt;のコードを少し調整したバージョンを次に示します。これは、配列内のゼロ以外の要素の数をカウントします。</target>
        </trans-unit>
        <trans-unit id="b917d701e1031f727f4614d1e3412a655c750b99" translate="yes" xml:space="preserve">
          <source>The best way to become familiar with the iterator is to look at its usage within the NumPy codebase itself. For example, here is a slightly tweaked version of the code for &lt;a href=&quot;c-api.array#c.PyArray_CountNonzero&quot;&gt;&lt;code&gt;PyArray_CountNonzero&lt;/code&gt;&lt;/a&gt;, which counts the number of non-zero elements in an array.</source>
          <target state="translated">イテレーターに慣れるための最良の方法は、NumPyコードベース自体での使用法を確認することです。たとえば、これは&lt;a href=&quot;c-api.array#c.PyArray_CountNonzero&quot;&gt; &lt;code&gt;PyArray_CountNonzero&lt;/code&gt; &lt;/a&gt;のコードを少し調整したバージョンで、配列内のゼロ以外の要素の数をカウントします。</target>
        </trans-unit>
        <trans-unit id="de71d7b03048d0ddf7e9d872a2d91138dd227be5" translate="yes" xml:space="preserve">
          <source>The best way to encode the options required to link against the specified C libraries is to use a &amp;ldquo;libname.ini&amp;rdquo; file, and use &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.get_info&quot;&gt;&lt;code&gt;get_info&lt;/code&gt;&lt;/a&gt; to retrieve the required options (see &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt;&lt;code&gt;add_npy_pkg_config&lt;/code&gt;&lt;/a&gt; for more information).</source>
          <target state="translated">指定されたCライブラリへのリンクに必要なオプションをエンコードする最良の方法は、「libname.ini」ファイルを使用し、&lt;a href=&quot;#numpy.distutils.misc_util.Configuration.get_info&quot;&gt; &lt;code&gt;get_info&lt;/code&gt; &lt;/a&gt;を使用して必要なオプションを取得することです（詳細については、&lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt; &lt;code&gt;add_npy_pkg_config&lt;/code&gt; &lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="bd068dc6ad18c4bdc86034d17ab908d7b76c4670" translate="yes" xml:space="preserve">
          <source>The best way to encode the options required to link against the specified C libraries is to use a &amp;ldquo;libname.ini&amp;rdquo; file, and use &lt;a href=&quot;distutils/misc_util#numpy.distutils.misc_util.get_info&quot;&gt;&lt;code&gt;get_info&lt;/code&gt;&lt;/a&gt; to retrieve the required options (see &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt;&lt;code&gt;add_npy_pkg_config&lt;/code&gt;&lt;/a&gt; for more information).</source>
          <target state="translated">指定されたCライブラリに対してリンクするために必要なオプションをエンコードする最良の方法は、「libname.ini」ファイルを使用し、&lt;a href=&quot;distutils/misc_util#numpy.distutils.misc_util.get_info&quot;&gt; &lt;code&gt;get_info&lt;/code&gt; &lt;/a&gt;を使用して必要なオプションを取得することです（詳細については、&lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt; &lt;code&gt;add_npy_pkg_config&lt;/code&gt; &lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="1969d49698b808b6d276d97e5d8d4c69483e3b58" translate="yes" xml:space="preserve">
          <source>The bi-dimensional histogram of samples &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Values in &lt;code&gt;x&lt;/code&gt; are histogrammed along the first dimension and values in &lt;code&gt;y&lt;/code&gt; are histogrammed along the second dimension.</source>
          <target state="translated">サンプル &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の2次元ヒストグラム。 &lt;code&gt;x&lt;/code&gt; の値は最初の次元に沿ってヒストグラムが作成され、 &lt;code&gt;y&lt;/code&gt; の値は2番目の次元に沿ってヒストグラムが作成されます。</target>
        </trans-unit>
        <trans-unit id="ccfae57716d7eef7191c06c0e81d2ccf59d9fed0" translate="yes" xml:space="preserve">
          <source>The biggest difficulty when writing extension modules is reference counting. It is an important reason for the popularity of f2py, weave, Cython, ctypes, etc&amp;hellip;. If you mis-handle reference counts you can get problems from memory-leaks to segmentation faults. The only strategy I know of to handle reference counts correctly is blood, sweat, and tears. First, you force it into your head that every Python variable has a reference count. Then, you understand exactly what each function does to the reference count of your objects, so that you can properly use DECREF and INCREF when you need them. Reference counting can really test the amount of patience and diligence you have towards your programming craft. Despite the grim depiction, most cases of reference counting are quite straightforward with the most common difficulty being not using DECREF on objects before exiting early from a routine due to some error. In second place, is the common error of not owning the reference on an object that is passed to a function or macro that is going to steal the reference ( &lt;em&gt;e.g.&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/dev/c-api/tuple.html#c.PyTuple_SET_ITEM&quot;&gt;&lt;code&gt;PyTuple_SET_ITEM&lt;/code&gt;&lt;/a&gt;, and most functions that take &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects).</source>
          <target state="translated">拡張モジュールを作成する際の最大の問題は、参照カウントです。これは、f2py、weave、Cython、ctypesなどの人気の重要な理由です。参照カウントを誤って処理すると、メモリリークからセグメンテーション違反まで問題が発生する可能性があります。参照カウントを正しく処理するために私が知っている唯一の戦略は、血、汗、涙です。まず、すべてのPython変数に参照カウントがあることを頭に入れます。次に、各関数がオブジェクトの参照カウントに対して何を行うかを正確に理解し、必要なときにDECREFとINCREFを適切に使用できるようにします。参照カウントは、プログラミング技術に対する忍耐力と勤勉さを実際にテストできます。厳しい描写にもかかわらず、参照カウントのほとんどのケースは非常に単純であり、最も一般的な問題は、エラーのためにルーチンを早期に終了する前にオブジェクトでDECREFを使用しないことです。第二に、参照を盗もうとしている関数またはマクロに渡されるオブジェクトの参照を所有していないという一般的なエラーです（&lt;em&gt;例：&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/dev/c-api/tuple.html#c.PyTuple_SET_ITEM&quot;&gt; &lt;code&gt;PyTuple_SET_ITEM&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;オブジェクトを受け取るほとんどの関数）。</target>
        </trans-unit>
        <trans-unit id="14050b2975e92118c403ebf94bd3985c0b813e9c" translate="yes" xml:space="preserve">
          <source>The bin edges along the first dimension.</source>
          <target state="translated">1次元に沿ったビンのエッジ。</target>
        </trans-unit>
        <trans-unit id="4350d5e237c7d985f1cac8ee28f6158f7c836a6a" translate="yes" xml:space="preserve">
          <source>The bin edges along the second dimension.</source>
          <target state="translated">ビンの端は第2の次元に沿っています。</target>
        </trans-unit>
        <trans-unit id="a2867162a2727e5c2d9c039d549ef3ce42449ec8" translate="yes" xml:space="preserve">
          <source>The bin specification:</source>
          <target state="translated">ビンの仕様です。</target>
        </trans-unit>
        <trans-unit id="60d93abeda71712ad2c6a79ef8adc26f40d2aa9b" translate="yes" xml:space="preserve">
          <source>The binwidth is proportional to the interquartile range (IQR) and inversely proportional to cube root of a.size. Can be too conservative for small datasets, but is quite good for large datasets. The IQR is very robust to outliers.</source>
          <target state="translated">bin幅は,四分位間範囲(IQR)に比例し,a.sizeの立方根に反比例する.小規模なデータセットでは保守的すぎることもありますが、大規模なデータセットでは非常に優れています。IQRは,外れ値に対して非常にロバストである.</target>
        </trans-unit>
        <trans-unit id="fcdd8e437719df337fcbc4c74083d021a1773472" translate="yes" xml:space="preserve">
          <source>The binwidth is proportional to the standard deviation of the data and inversely proportional to cube root of &lt;code&gt;x.size&lt;/code&gt;. Can be too conservative for small datasets, but is quite good for large datasets. The standard deviation is not very robust to outliers. Values are very similar to the Freedman-Diaconis estimator in the absence of outliers.</source>
          <target state="translated">ビン幅はデータの標準偏差に比例し、 &lt;code&gt;x.size&lt;/code&gt; の立方根に反比例します。小さなデータセットには控えめすぎる可能性がありますが、大きなデータセットには非常に適しています。標準偏差は外れ値に対して非常にロバストではありません。外れ値がない場合、値はFreedman-Diaconis推定量と非常に似ています。</target>
        </trans-unit>
        <trans-unit id="4bfe7be4cfb5e7ee31495fab431c2ade90ea37b4" translate="yes" xml:space="preserve">
          <source>The bit generator instance used by the generator</source>
          <target state="translated">が使用するビットジェネレーターのインスタンス</target>
        </trans-unit>
        <trans-unit id="1c9ceb11680f6c0c1b9aff1a5015653854b99511" translate="yes" xml:space="preserve">
          <source>The bit generators can be used in downstream projects via &lt;a href=&quot;extending#random-cython&quot;&gt;Cython&lt;/a&gt;.</source>
          <target state="translated">ビットジェネレータは、&lt;a href=&quot;extending#random-cython&quot;&gt;Cython&lt;/a&gt;を介したダウンストリームプロジェクトで使用できます。</target>
        </trans-unit>
        <trans-unit id="c5d3462c76522066d7ff9beefce9a7effa7d1a7a" translate="yes" xml:space="preserve">
          <source>The bit generators can be used in downstream projects via &lt;a href=&quot;extending#randomgen-cython&quot;&gt;Cython&lt;/a&gt;.</source>
          <target state="translated">ビットジェネレーターは、&lt;a href=&quot;extending#randomgen-cython&quot;&gt;Cython&lt;/a&gt;を介してダウンストリームプロジェクトで使用できます。</target>
        </trans-unit>
        <trans-unit id="bb60b63a1d593f422d320c08f605d5c913dee609" translate="yes" xml:space="preserve">
          <source>The bit generators can be used in downstream projects via Cython.</source>
          <target state="translated">ビットジェネレーターは、Cythonを介して下流のプロジェクトで使用することができます。</target>
        </trans-unit>
        <trans-unit id="6e4e6fbd0cb3401b8c573dd3679e44e3f4f81dbf" translate="yes" xml:space="preserve">
          <source>The bit-width names can also be used (e.g. &lt;a href=&quot;c-api.dtype#c.NPY_INT32&quot;&gt;&lt;code&gt;NPY_INT32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_COMPLEX128&quot;&gt;&lt;code&gt;NPY_COMPLEX128&lt;/code&gt;&lt;/a&gt; ) if desired.</source>
          <target state="translated">必要に応じて、ビット幅の名前（&lt;a href=&quot;c-api.dtype#c.NPY_INT32&quot;&gt; &lt;code&gt;NPY_INT32&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;c-api.dtype#c.NPY_COMPLEX128&quot;&gt; &lt;code&gt;NPY_COMPLEX128&lt;/code&gt; など&lt;/a&gt;）も使用できます。</target>
        </trans-unit>
        <trans-unit id="bc2ab75ee612016fcf37354aa06f319d50bc9810" translate="yes" xml:space="preserve">
          <source>The bit-width names can also be used (e.g. &lt;a href=&quot;dtype#c.NPY_INT32&quot;&gt;&lt;code&gt;NPY_INT32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;dtype#c.NPY_COMPLEX128&quot;&gt;&lt;code&gt;NPY_COMPLEX128&lt;/code&gt;&lt;/a&gt; ) if desired.</source>
          <target state="translated">必要に応じて、ビット幅の名前（&lt;a href=&quot;dtype#c.NPY_INT32&quot;&gt; &lt;code&gt;NPY_INT32&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;dtype#c.NPY_COMPLEX128&quot;&gt; &lt;code&gt;NPY_COMPLEX128&lt;/code&gt; など&lt;/a&gt;）を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="81d10a070991358c5aabcf2c4a0f8549725777dd" translate="yes" xml:space="preserve">
          <source>The bit-wise operators &amp;amp; and | are the proper way to perform element-by-element array comparisons. Be sure you understand the operator precedence: &lt;code&gt;(a &amp;gt; 2) &amp;amp; (a &amp;lt; 5)&lt;/code&gt; is the proper syntax because &lt;code&gt;a &amp;gt; 2 &amp;amp; a &amp;lt; 5&lt;/code&gt; will result in an error due to the fact that &lt;code&gt;2 &amp;amp; a&lt;/code&gt; is evaluated first.</source>
          <target state="translated">ビットごとの演算子＆および| 要素ごとの配列比較を実行する適切な方法です。演算子の優先順位を必ず理解してください。 &lt;code&gt;(a &amp;gt; 2) &amp;amp; (a &amp;lt; 5)&lt;/code&gt; は適切な構文です。これは &lt;code&gt;a &amp;gt; 2 &amp;amp; a &amp;lt; 5&lt;/code&gt; 場合、 &lt;code&gt;2 &amp;amp; a&lt;/code&gt; が最初に評価されるため、エラーが発生するためです。</target>
        </trans-unit>
        <trans-unit id="023be86065ffa72daa5873059c9ec3d6c37210a4" translate="yes" xml:space="preserve">
          <source>The bits that are inherited for the parent data-type if these bits are set in any field of the data-type. Currently ( &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt;&lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt;&lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt;&lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt;&lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">これらのビットがデータ型のいずれかのフィールドに設定されている場合に親データ型に継承されるビット。現在（&lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt; &lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt; &lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt; &lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt; &lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="eec4adb38715609db3c28173012b3acac012a710" translate="yes" xml:space="preserve">
          <source>The broadcasting mechanism permits index arrays to be combined with scalars for other indices. The effect is that the scalar value is used for all the corresponding values of the index arrays:</source>
          <target state="translated">ブロードキャスト機構は,インデックス配列を他のインデックスのスカラ値と組み合わせることを可能にします.その効果は,スカラ値がインデックス配列の対応するすべての値に利用されることです.</target>
        </trans-unit>
        <trans-unit id="4cdfeeb979f5beeacca8e8ed28ded2c7c6f59236" translate="yes" xml:space="preserve">
          <source>The buffer size. If &lt;code&gt;buf_size&lt;/code&gt; is supplied, the maximum amount of data that will be read into memory is &lt;code&gt;buf_size&lt;/code&gt; elements. Default is None, which will read as many element as possible into memory.</source>
          <target state="translated">バッファサイズ。 &lt;code&gt;buf_size&lt;/code&gt; が指定されている場合、メモリに読み込まれるデータの最大量は &lt;code&gt;buf_size&lt;/code&gt; 要素です。デフォルトはNoneで、可能な限り多くの要素をメモリに読み込みます。</target>
        </trans-unit>
        <trans-unit id="2e41256de81634e573afba6a93755e0b3e1dcc73" translate="yes" xml:space="preserve">
          <source>The built-in scalar types are shown below. Along with their (mostly) C-derived names, the integer, float, and complex data-types are also available using a bit-width convention so that an array of the right size can always be ensured (e.g. &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;). Two aliases (&lt;code&gt;intp&lt;/code&gt; and &lt;code&gt;uintp&lt;/code&gt;) pointing to the integer type that is sufficiently large to hold a C pointer are also provided. The C-like names are associated with character codes, which are shown in the table. Use of the character codes, however, is discouraged.</source>
          <target state="translated">組み込みスカラー型を以下に示します。それらの（ほとんど）Cから派生した名前に加えて、ビット幅の規則を使用して整数、浮動小数点、および複素数のデータ型も利用できるため、適切なサイズの配列を常に確保できます（たとえば、 &lt;code&gt;int8&lt;/code&gt; 、 &lt;code&gt;float64&lt;/code&gt; 、 &lt;code&gt;complex128&lt;/code&gt; ）。 。二つのエイリアス（ &lt;code&gt;intp&lt;/code&gt; と &lt;code&gt;uintp&lt;/code&gt; Cポインタを保持するのに十分な大きさである整数型を指す）も提供されます。Cのような名前は、表に示す文字コードに関連付けられています。ただし、文字コードの使用はお勧めしません。</target>
        </trans-unit>
        <trans-unit id="c0f5f929adb8df8a6adc766b8c78557ffdeb6dfb" translate="yes" xml:space="preserve">
          <source>The byte offset of element &lt;code&gt;(i[0], i[1], ..., i[n])&lt;/code&gt; in an array &lt;code&gt;a&lt;/code&gt; is:</source>
          <target state="translated">配列 &lt;code&gt;a&lt;/code&gt; の要素 &lt;code&gt;(i[0], i[1], ..., i[n])&lt;/code&gt; のバイトオフセットは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="4e1d8f651723be5f774ab2e5c504d861c7a87264" translate="yes" xml:space="preserve">
          <source>The byte offsets of the fields within the structure and the total structure itemsize are determined automatically.</source>
          <target state="translated">構造体内のフィールドのバイトオフセットと構造体全体のアイテムサイズは自動的に決定されます。</target>
        </trans-unit>
        <trans-unit id="a157c5730d5626d8d468cb6666e1e8a306635908" translate="yes" xml:space="preserve">
          <source>The byte order of the data (which may not be the native byte order)</source>
          <target state="translated">データのバイト順(ネイティブのバイト順ではない場合もあります</target>
        </trans-unit>
        <trans-unit id="54750603ecbabb9e0fbfb396fe440127b1696b3c" translate="yes" xml:space="preserve">
          <source>The byteswapped array. If &lt;code&gt;inplace&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, this is a view to self.</source>
          <target state="translated">バイトスワップされた配列。 &lt;code&gt;inplace&lt;/code&gt; が &lt;code&gt;True&lt;/code&gt; の場合、これは自分へのビューです。</target>
        </trans-unit>
        <trans-unit id="50ca95011c00b72a055aafd7f7fd748d3ee5666f" translate="yes" xml:space="preserve">
          <source>The calculation based on the Einstein summation convention.</source>
          <target state="translated">アインシュタインの和算規約に基づいた計算。</target>
        </trans-unit>
        <trans-unit id="f28022cc3c759ea7fff9649dace591b586e47f2a" translate="yes" xml:space="preserve">
          <source>The call function takes two arguments. The first is a string describing the type of error (such as &amp;ldquo;divide by zero&amp;rdquo;, &amp;ldquo;overflow&amp;rdquo;, &amp;ldquo;underflow&amp;rdquo;, or &amp;ldquo;invalid value&amp;rdquo;), and the second is the status flag. The flag is a byte, whose four least-significant bits indicate the type of error, one of &amp;ldquo;divide&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, &amp;ldquo;invalid&amp;rdquo;:</source>
          <target state="translated">call関数は2つの引数を取ります。1つ目はエラーの種類を説明する文字列（「ゼロ除算」、「オーバーフロー」、「アンダーフロー」、「無効な値」など）で、2つ目はステータスフラグです。フラグはバイトであり、その最下位4ビットがエラーのタイプを示し、「除算」、「オーバー」、「アンダー」、「無効」のいずれかです。</target>
        </trans-unit>
        <trans-unit id="65bfb33c8f536eca2e334a181b45563504281f94" translate="yes" xml:space="preserve">
          <source>The callable to test.</source>
          <target state="translated">テストするための呼び出し可能なもの。</target>
        </trans-unit>
        <trans-unit id="a3a1c9abf4ffccd45f5331c5f42edc1f3d2d1d9d" translate="yes" xml:space="preserve">
          <source>The callback function may also be explicitly set in the module. Then it is not necessary to pass the function in the argument list to the Fortran function. This may be desired if the Fortran function calling the python callback function is itself called by another Fortran function.</source>
          <target state="translated">コールバック関数は、モジュール内で明示的に設定することもできます。その場合、引数リストにある関数をFortran関数に渡す必要はありません。これは、Pythonコールバック関数を呼び出すFortran関数自体が別のFortran関数によって呼び出されている場合に望ましいかもしれません。</target>
        </trans-unit>
        <trans-unit id="431e9b7795bdf48241d6bec5990fb4a0130d071a" translate="yes" xml:space="preserve">
          <source>The ceil of the scalar &lt;code&gt;x&lt;/code&gt; is the smallest integer &lt;code&gt;i&lt;/code&gt;, such that &lt;code&gt;i &amp;gt;= x&lt;/code&gt;. It is often denoted as</source>
          <target state="translated">スカラー &lt;code&gt;x&lt;/code&gt; のceilは、 &lt;code&gt;i &amp;gt;= x&lt;/code&gt; ような最小の整数 &lt;code&gt;i&lt;/code&gt; です。多くの場合、</target>
        </trans-unit>
        <trans-unit id="e9d3cf326f9a7a53ec955615e43eb638c61eb8ef" translate="yes" xml:space="preserve">
          <source>The ceiling of each element in &lt;code&gt;x&lt;/code&gt;, with &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; dtype. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">各要素の天井 &lt;code&gt;x&lt;/code&gt; と、&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; DTYPE。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="39a8dcb488a9fc6fc34cf5a558688abf07d39d3f" translate="yes" xml:space="preserve">
          <source>The character representing the minimum-size type that was found.</source>
          <target state="translated">見つかった最小サイズのタイプを表す文字。</target>
        </trans-unit>
        <trans-unit id="97cbe8e263bc4b6b77075dcb6bab028e565a01e7" translate="yes" xml:space="preserve">
          <source>The character to use for padding</source>
          <target state="translated">パディングに使用する文字</target>
        </trans-unit>
        <trans-unit id="6c4bf24ea0f35b24c677f85fded0fd7b09f23149" translate="yes" xml:space="preserve">
          <source>The character used to indicate the start of a comment. All the characters occurring on a line after a comment are discarded</source>
          <target state="translated">コメントの開始を示すために使用される文字。コメントの後の行にある文字はすべて破棄されます。</target>
        </trans-unit>
        <trans-unit id="d85f382686a835461ae276491d1cc1f7d794fafc" translate="yes" xml:space="preserve">
          <source>The characteristic polynomial,</source>
          <target state="translated">特徴的な多項式。</target>
        </trans-unit>
        <trans-unit id="95fe0ca98cff261937758debf60dec87c78a570a" translate="yes" xml:space="preserve">
          <source>The characters or list of characters used to indicate the start of a comment. None implies no comments. For backwards compatibility, byte strings will be decoded as &amp;lsquo;latin1&amp;rsquo;. The default is &amp;lsquo;#&amp;rsquo;.</source>
          <target state="translated">コメントの開始を示すために使用される文字または文字のリスト。なしはコメントがないことを意味します。下位互換性のために、バイト文字列は「latin1」としてデコードされます。デフォルトは「＃」です。</target>
        </trans-unit>
        <trans-unit id="16535da2d1a6378c09b05298f374b6373da93c3c" translate="yes" xml:space="preserve">
          <source>The choice and location of linked libraries such as BLAS and LAPACK as well as include paths and other such build options can be specified in a &lt;code&gt;site.cfg&lt;/code&gt; file located in the NumPy root repository or a &lt;code&gt;.numpy-site.cfg&lt;/code&gt; file in your home directory. See the &lt;code&gt;site.cfg.example&lt;/code&gt; example file included in the NumPy repository or sdist for documentation.</source>
          <target state="translated">BLASやLAPACKなどのリンクされたライブラリの選択と場所、およびインクルードパスやその他のそのようなビルドオプションは、NumPyルートリポジトリにある &lt;code&gt;site.cfg&lt;/code&gt; ファイルまたはホームディレクトリの &lt;code&gt;.numpy-site.cfg&lt;/code&gt; ファイルで指定できます。 。ドキュメントについては、NumPyリポジトリまたはsdistに含まれている &lt;code&gt;site.cfg.example&lt;/code&gt; サンプルファイルを参照してください。</target>
        </trans-unit>
        <trans-unit id="5b3f50108009441cc91c801c6a0d50e7f118400f" translate="yes" xml:space="preserve">
          <source>The class defining the warning that &lt;code&gt;func&lt;/code&gt; is expected to throw.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; がスローすると予想される警告を定義するクラス。</target>
        </trans-unit>
        <trans-unit id="da74e7889b120a1d89220abab914f35b23ca6ac5" translate="yes" xml:space="preserve">
          <source>The clear choice to wrap Fortran code is &lt;a href=&quot;https://docs.scipy.org/doc/numpy/f2py/&quot;&gt;f2py&lt;/a&gt;.</source>
          <target state="translated">Fortranコードをラップするための明確な選択は&lt;a href=&quot;https://docs.scipy.org/doc/numpy/f2py/&quot;&gt;f2py&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="3182c5f9b369539a27f1bc7716b92f10416add66" translate="yes" xml:space="preserve">
          <source>The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for these alternatives. For example, any of &amp;lsquo;&amp;gt;&amp;rsquo; or &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;brian&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">コードは、これらの代替案について &lt;code&gt;new_order&lt;/code&gt; の最初の文字で大文字と小文字を区別しないチェックを行います。たとえば、ビッグエンディアンを指定するには、「&amp;gt;」、「B」、「b」、「brian」のいずれも有効です。</target>
        </trans-unit>
        <trans-unit id="80380a308ceba94a9432deb39fde76dbd31d736a" translate="yes" xml:space="preserve">
          <source>The code in the second example is more efficient than that in the first because broadcasting moves less memory around during the multiplication (&lt;code&gt;b&lt;/code&gt; is a scalar rather than an array).</source>
          <target state="translated">2番目の例のコードは、最初の例のコードよりも効率的です。これは、ブロードキャストが乗算中に移動するメモリが少ないためです（ &lt;code&gt;b&lt;/code&gt; は配列ではなくスカラーです）。</target>
        </trans-unit>
        <trans-unit id="b154e2d8d3173f85d365231f520eaf5d3d14ed4d" translate="yes" xml:space="preserve">
          <source>The code to produce the figures is part of the &lt;a href=&quot;http://www.astroml.org/book_figures/appendix/fig_broadcast_visual.html&quot;&gt;AstroML book&lt;/a&gt;</source>
          <target state="translated">図を作成するためのコードは、&lt;a href=&quot;http://www.astroml.org/book_figures/appendix/fig_broadcast_visual.html&quot;&gt;AstroMLブックの&lt;/a&gt;一部です。</target>
        </trans-unit>
        <trans-unit id="3d7fde77cc6d2864c99d7d852dc9654a8a2c232a" translate="yes" xml:space="preserve">
          <source>The coefficient array representing their sum.</source>
          <target state="translated">それらの和を表す係数配列.</target>
        </trans-unit>
        <trans-unit id="8877be945db0e0267ce25ed710aea10434e74470" translate="yes" xml:space="preserve">
          <source>The coefficient matrix of the coefficients &lt;code&gt;p&lt;/code&gt; is a Vandermonde matrix.</source>
          <target state="translated">係数 &lt;code&gt;p&lt;/code&gt; の係数行列は、ヴァンダーモンド行列です。</target>
        </trans-unit>
        <trans-unit id="1749ca10e1fd82b0f81734b8e3040c222ba10138" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is 1 for monic polynomials in this form.</source>
          <target state="translated">この形式の単項多項式では、最後の項の係数は1である。</target>
        </trans-unit>
        <trans-unit id="7f518b8b3d036f3e65aa1004d0ce4c9fe4f469f2" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Chebyshev form.</source>
          <target state="translated">最後の項の係数は、チェビシェフ形式の単項多項式では一般的に1ではない。</target>
        </trans-unit>
        <trans-unit id="c6e27aff7bd03298a7abe7cdd24c2851e78ffc19" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Hermite form.</source>
          <target state="translated">エルミート形式の単項多項式では、最後の項の係数は一概に1とは言えません。</target>
        </trans-unit>
        <trans-unit id="d8180193920e1d179284839e524518471959f55d" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in HermiteE form.</source>
          <target state="translated">HermiteE形式の単項多項式では、最後の項の係数は一般的に1ではありません。</target>
        </trans-unit>
        <trans-unit id="870417532aa77b335abb3ff61d44b3280649b54a" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Laguerre form.</source>
          <target state="translated">ラゲール形式の単項多項式では、最後の項の係数は一概に1とは言えません。</target>
        </trans-unit>
        <trans-unit id="d2eb9fcb4c7fc816e015e2f1263164865a84ea2c" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Legendre form.</source>
          <target state="translated">レジェンドレ形式の単項多項式では、最後の項の係数は一概に1とは言えません。</target>
        </trans-unit>
        <trans-unit id="c0eab4462e93f35863c8383ff656ddde3733b00b" translate="yes" xml:space="preserve">
          <source>The coefficients are determined by multiplying together linear factors of the form &lt;code&gt;(x - r_i)&lt;/code&gt;, i.e.</source>
          <target state="translated">係数は、一緒にフォームの線形係数乗算することによって決定される &lt;code&gt;(x - r_i)&lt;/code&gt; 、すなわち</target>
        </trans-unit>
        <trans-unit id="96b42532f49d3b3a4358a0737c1292c860f167f7" translate="yes" xml:space="preserve">
          <source>The column &lt;code&gt;v[:, i]&lt;/code&gt; is the normalized eigenvector corresponding to the eigenvalue &lt;code&gt;w[i]&lt;/code&gt;. Will return a matrix object if &lt;code&gt;a&lt;/code&gt; is a matrix object.</source>
          <target state="translated">列 &lt;code&gt;v[:, i]&lt;/code&gt; は、固有値 &lt;code&gt;w[i]&lt;/code&gt; 対応する正規化された固有ベクトルです。場合は行列オブジェクトを返しますマトリックスオブジェクトです。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="05afae6f6316038b8a077ed2d79753233c9700ab" translate="yes" xml:space="preserve">
          <source>The column dimension of the arrays for which the returned arrays will be valid. By default &lt;code&gt;m&lt;/code&gt; is taken equal to &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">返される配列が有効になる配列の列次元。デフォルト &lt;code&gt;m&lt;/code&gt; は、mは &lt;code&gt;n&lt;/code&gt; と等しくなります。</target>
        </trans-unit>
        <trans-unit id="049227627bd4dfed2d2a3d0a02023afddf2ece4d" translate="yes" xml:space="preserve">
          <source>The columns of the output matrix are powers of the input vector. The order of the powers is determined by the &lt;code&gt;increasing&lt;/code&gt; boolean argument. Specifically, when &lt;code&gt;increasing&lt;/code&gt; is False, the &lt;code&gt;i&lt;/code&gt;-th output column is the input vector raised element-wise to the power of &lt;code&gt;N - i - 1&lt;/code&gt;. Such a matrix with a geometric progression in each row is named for Alexandre- Theophile Vandermonde.</source>
          <target state="translated">出力行列の列は、入力ベクトルのべき乗です。累乗の順序は、 &lt;code&gt;increasing&lt;/code&gt; ブール引数によって決定されます。具体的には、 &lt;code&gt;increasing&lt;/code&gt; がFalseの場合、 &lt;code&gt;i&lt;/code&gt; 番目の出力列は、要素ごとに &lt;code&gt;N - i - 1&lt;/code&gt; 累乗された入力ベクトルです。各行に幾何学的な進行があるこのような行列は、Alexandre-Theophile Vandermondeにちなんで名付けられました。</target>
        </trans-unit>
        <trans-unit id="fd5ff7ed1e1b0436ec4f4722206a381ca973b853" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;make test&lt;/code&gt; will ensure that all of the test software is built and then run all three test scripts.</source>
          <target state="translated">&lt;code&gt;make test&lt;/code&gt; コマンドは、すべてのテストソフトウェアがビルドされていることを確認してから、3つのテストスクリプトをすべて実行します。</target>
        </trans-unit>
        <trans-unit id="e66bb28254c2c47afebe31be29c7f178c6baf9ce" translate="yes" xml:space="preserve">
          <source>The committee must agree on a resolution by consensus. If the group cannot reach consensus and deadlocks for over a week, the group will turn the matter over to the Steering Council for resolution.</source>
          <target state="translated">委員会は、コンセンサスによる決議に合意しなければならない。合意が得られず、1週間以上膠着状態が続いた場合は、その問題を運営協議会に引き継ぎ、決議を求めます。</target>
        </trans-unit>
        <trans-unit id="f296a348ca6c5f048bde7ff72475becfa99bfb54" translate="yes" xml:space="preserve">
          <source>The committee will never publicly discuss the issue; all public statements will be made by the chair of the Code of Conduct Committee or the NumPy Steering Council.</source>
          <target state="translated">委員会は決して公の場で問題を議論することはなく、すべての公の場での発言は、行動規範委員会の委員長またはNumPy運営協議会によって行われる。</target>
        </trans-unit>
        <trans-unit id="1da455687a62d6eecd2b4975d23b71811215c8f1" translate="yes" xml:space="preserve">
          <source>The committee will respond to any report as soon as possible, and at most within 72 hours.</source>
          <target state="translated">委員会は、いかなる報告に対しても、可能な限り速やかに、長くても72時間以内に回答する。</target>
        </trans-unit>
        <trans-unit id="b080620b2cb81b4501691bc62009a0f3cdee2b1d" translate="yes" xml:space="preserve">
          <source>The committee will then review the incident and determine, to the best of their ability:</source>
          <target state="translated">その後、委員会は、事件を検討し、可能な限り、決定します。</target>
        </trans-unit>
        <trans-unit id="24aa155f0fb452987333532fc0871b6b96e25258" translate="yes" xml:space="preserve">
          <source>The common data type, which is the maximum of &lt;code&gt;array_types&lt;/code&gt; ignoring &lt;code&gt;scalar_types&lt;/code&gt;, unless the maximum of &lt;code&gt;scalar_types&lt;/code&gt; is of a different kind (&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt;&lt;code&gt;dtype.kind&lt;/code&gt;&lt;/a&gt;). If the kind is not understood, then None is returned.</source>
          <target state="translated">最大値である共通データ型、 &lt;code&gt;array_types&lt;/code&gt; 無視 &lt;code&gt;scalar_types&lt;/code&gt; を最大ない限り、 &lt;code&gt;scalar_types&lt;/code&gt; が異なる種類（である&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt; &lt;code&gt;dtype.kind&lt;/code&gt; &lt;/a&gt;）。種類が理解できない場合は、Noneが返されます。</target>
        </trans-unit>
        <trans-unit id="6557c9bc2aa7a334ee156279cd2e6ed26882b290" translate="yes" xml:space="preserve">
          <source>The common fill value, or None.</source>
          <target state="translated">共通の塗りつぶし値、または None。</target>
        </trans-unit>
        <trans-unit id="792a2de181f669c74b9db5a5aeebd6abe9c93185" translate="yes" xml:space="preserve">
          <source>The common situations in which you need to change byte ordering are:</source>
          <target state="translated">バイト順を変更する必要がある一般的な状況は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="c7c4929011c41aa057f46d2bc4e51aaccf9a85a1" translate="yes" xml:space="preserve">
          <source>The companion matrix for power series cannot be made symmetric by scaling the basis, so this function differs from those for the orthogonal polynomials.</source>
          <target state="translated">力系列のコンパニオン行列は基底をスケーリングして対称にすることができないので、直交多項式のコンパニオン行列とは異なります。</target>
        </trans-unit>
        <trans-unit id="50728cc7411772baf0d23ae9dab7a04fd085919c" translate="yes" xml:space="preserve">
          <source>The comparison of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; uses standard broadcasting, which means that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; need not have the same shape in order for &lt;code&gt;allclose(a, b)&lt;/code&gt; to evaluate to True. The same is true for &lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt;&lt;code&gt;equal&lt;/code&gt;&lt;/a&gt; but not &lt;a href=&quot;numpy.array_equal#numpy.array_equal&quot;&gt;&lt;code&gt;array_equal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">比較と &lt;code&gt;b&lt;/code&gt; があることを意味標準放送、使用および &lt;code&gt;b&lt;/code&gt; 必要性のためのために、同じ形状を有していない &lt;code&gt;allclose(a, b)&lt;/code&gt; Trueに評価することを。&lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt; &lt;code&gt;equal&lt;/code&gt; &lt;/a&gt;が&lt;a href=&quot;numpy.array_equal#numpy.array_equal&quot;&gt; &lt;code&gt;array_equal&lt;/code&gt; に&lt;/a&gt;は同じことが当てはまりません。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed9a376f5659e4753c56a46ffbea586e1c5b762b" translate="yes" xml:space="preserve">
          <source>The complex conjugate of &lt;code&gt;x&lt;/code&gt;, with same dtype as &lt;code&gt;y&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; と同じdtypeを持つ &lt;code&gt;x&lt;/code&gt; の複素共役。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="d1ca0ff74dd3394813701dd385de23f306fa9c69" translate="yes" xml:space="preserve">
          <source>The complex conjugate of a complex number is obtained by changing the sign of its imaginary part.</source>
          <target state="translated">複素数の複素共役は、その虚数部の符号を変えることで得られる。</target>
        </trans-unit>
        <trans-unit id="41eb6fa093181f73897902c7f0874292edf29e51" translate="yes" xml:space="preserve">
          <source>The compressed array.</source>
          <target state="translated">圧縮された配列です。</target>
        </trans-unit>
        <trans-unit id="5eb5823a400c379807aed8ab125dee97f320721d" translate="yes" xml:space="preserve">
          <source>The concatenated array with any masked entries preserved.</source>
          <target state="translated">マスクされたエントリが保存された連結配列。</target>
        </trans-unit>
        <trans-unit id="a37868502a5a0d6add95945d1a64803e757adeaa" translate="yes" xml:space="preserve">
          <source>The concatenated array.</source>
          <target state="translated">連結された配列。</target>
        </trans-unit>
        <trans-unit id="3af59c1bb124d9d3dff66fb6d58de527a5027e82" translate="yes" xml:space="preserve">
          <source>The concept of a behaved segment is used in the description of the function pointers. A behaved segment is one that is aligned and in native machine byte-order for the data-type. The &lt;code&gt;nonzero&lt;/code&gt;, &lt;code&gt;copyswap&lt;/code&gt;, &lt;code&gt;copyswapn&lt;/code&gt;, &lt;code&gt;getitem&lt;/code&gt;, and &lt;code&gt;setitem&lt;/code&gt; functions can (and must) deal with mis-behaved arrays. The other functions require behaved memory segments.</source>
          <target state="translated">動作セグメントの概念は、関数ポインターの説明で使用されます。動作するセグメントは、データ型に合わせて調整され、ネイティブマシンのバイト順であるセグメントです。 &lt;code&gt;nonzero&lt;/code&gt; 、 &lt;code&gt;copyswap&lt;/code&gt; 、 &lt;code&gt;copyswapn&lt;/code&gt; 、 &lt;code&gt;getitem&lt;/code&gt; 、および &lt;code&gt;setitem&lt;/code&gt; 機能することができる（及びなければならない）ミス行儀アレイとの契約。その他の機能には、動作するメモリセグメントが必要です。</target>
        </trans-unit>
        <trans-unit id="46e686c81ff0f33a7ee42cbdb148b2206e722231" translate="yes" xml:space="preserve">
          <source>The condition number of &lt;code&gt;x&lt;/code&gt; is defined as the norm of &lt;code&gt;x&lt;/code&gt; times the norm of the inverse of &lt;code&gt;x&lt;/code&gt;&lt;a href=&quot;#r611900c44d60-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;; the norm can be the usual L2-norm (root-of-sum-of-squares) or one of a number of other matrix norms.</source>
          <target state="translated">条件数 &lt;code&gt;x&lt;/code&gt; がのノルムとして定義され &lt;code&gt;x&lt;/code&gt; 時間の逆数のノルム &lt;code&gt;x&lt;/code&gt; &lt;a href=&quot;#r611900c44d60-1&quot; id=&quot;id1&quot;&gt;[1] &lt;/a&gt;。ノルムは、通常のL2ノルム（平方根の平方根）または他の多数の行列ノルムのいずれかです。</target>
        </trans-unit>
        <trans-unit id="7ed508e4defcab357510ceacda28d2924496cd06" translate="yes" xml:space="preserve">
          <source>The condition number of the matrix. May be infinite.</source>
          <target state="translated">行列の条件番号。無限になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="c901451fe41cf6f1482465c84b6a4c739cbccbff" translate="yes" xml:space="preserve">
          <source>The config file generated from &lt;code&gt;template&lt;/code&gt; is installed in the given install directory, using &lt;code&gt;subst_dict&lt;/code&gt; for variable substitution.</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; から生成された設定ファイルは、変数置換に &lt;code&gt;subst_dict&lt;/code&gt; を使用して、指定されたインストールディレクトリにインストールされます。</target>
        </trans-unit>
        <trans-unit id="2fe0070d6ccb31708b92b4e4ed2caabdfe3d249d" translate="yes" xml:space="preserve">
          <source>The constants &lt;strong&gt;NPY_INTP&lt;/strong&gt; and &lt;strong&gt;NPY_UINTP&lt;/strong&gt; refer to an enumerated integer type that is large enough to hold a pointer on the platform. Index arrays should always be converted to &lt;strong&gt;NPY_INTP&lt;/strong&gt; , because the dimension of the array is of type npy_intp.</source>
          <target state="translated">定数&lt;strong&gt;NPY_INTP&lt;/strong&gt;および&lt;strong&gt;NPY_UINTP&lt;/strong&gt;は、プラットフォーム上でポインターを保持するのに十分な大きさの列挙整数型を参照します。配列の次元は&lt;strong&gt;npy_intp型&lt;/strong&gt;であるため、インデックス配列は常に&lt;strong&gt;NPY_INTP&lt;/strong&gt;に変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="fd8a200b77c06e1513f552e8d61858be6438182d" translate="yes" xml:space="preserve">
          <source>The constructed array.</source>
          <target state="translated">構築された配列。</target>
        </trans-unit>
        <trans-unit id="8c8c3ae23d3b8b9d4c2965f608e114605317b1d2" translate="yes" xml:space="preserve">
          <source>The constructed extension module is saved as &lt;code&gt;&amp;lt;modulename&amp;gt;module.c&lt;/code&gt; to the current directory.</source>
          <target state="translated">構築された拡張モジュールは、 &lt;code&gt;&amp;lt;modulename&amp;gt;module.c&lt;/code&gt; として現在のディレクトリに保存されます。</target>
        </trans-unit>
        <trans-unit id="1564bd8e09196ae3556506f90562583aff6d8fc2" translate="yes" xml:space="preserve">
          <source>The content of a modified version of &lt;code&gt;fib1.pyf&lt;/code&gt; (saved as &lt;code&gt;fib2.pyf&lt;/code&gt;) is as follows:</source>
          <target state="translated">修正されたバージョンの内容 &lt;code&gt;fib1.pyf&lt;/code&gt; （として保存 &lt;code&gt;fib2.pyf&lt;/code&gt; は次のように）です。</target>
        </trans-unit>
        <trans-unit id="6f12164e316c899cbeec8a520db14b994fa35a8e" translate="yes" xml:space="preserve">
          <source>The contiguous constraint applies only to the inner loop, successive inner loops may have arbitrary pointer changes.</source>
          <target state="translated">連続制約は内側ループにのみ適用され、連続する内側ループでは任意のポインタ変更が可能です。</target>
        </trans-unit>
        <trans-unit id="a28f32d0e2528be0855bfa01e7539cc0e939d215" translate="yes" xml:space="preserve">
          <source>The convenience classes provided by the polynomial package are:</source>
          <target state="translated">多項式パッケージで提供される便利なクラスは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="5a4e9570e8f8bcacc96f206106a01eefad39bd6f" translate="yes" xml:space="preserve">
          <source>The convert method can also convert domain and window:</source>
          <target state="translated">また、convertメソッドはドメインやウィンドウの変換も可能です。</target>
        </trans-unit>
        <trans-unit id="60131768e228b843852dbff6de95273c5e8b7bcb" translate="yes" xml:space="preserve">
          <source>The converted data-type.</source>
          <target state="translated">変換されたデータ型。</target>
        </trans-unit>
        <trans-unit id="1fc6b89fce1f12a34477c12a69d7cd751ad23c91" translate="yes" xml:space="preserve">
          <source>The convolution operator is often seen in signal processing, where it models the effect of a linear time-invariant system on a signal &lt;a href=&quot;#r95849f33d2b1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. In probability theory, the sum of two independent random variables is distributed according to the convolution of their individual distributions.</source>
          <target state="translated">たたみ込み演算子は信号処理でよく見られ、信号に対する線形時不変システムの影響をモデル化します&lt;a href=&quot;#r95849f33d2b1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。確率論では、2つの独立確率変数の合計は、個々の分布の畳み込みに従って分布します。</target>
        </trans-unit>
        <trans-unit id="1b7a113f553d13745aed52a84f8c20493ad427e3" translate="yes" xml:space="preserve">
          <source>The coordinates member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; structure maintains the current N-d counter unless the underlying array is C-contiguous in which case the coordinate counting is by-passed. The index member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the current flat index of the iterator. It is updated by the &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">&lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;構造体の座標メンバーは、基になる配列がC隣接していない限り、現在のNdカウンターを維持します。この場合、座標カウントはバイパスされます。&lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;のインデックスメンバーは、イテレータの現在のフラットインデックスを追跡します。&lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt;マクロによって更新されます。</target>
        </trans-unit>
        <trans-unit id="a60368fcddf184df8cd7ef5081ac979bc50c50f2" translate="yes" xml:space="preserve">
          <source>The coordinates member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; structure maintains the current N-d counter unless the underlying array is C-contiguous in which case the coordinate counting is by-passed. The index member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the current flat index of the iterator. It is updated by the &lt;a href=&quot;c-api/array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">&lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;構造体の座標メンバーは、基になる配列がC連続である場合を除き、現在のNdカウンターを維持します。C連続の場合、座標カウントはバイパスされます。&lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;のインデックスメンバーは、イテレータの現在のフラットインデックスを追跡します。これは、&lt;a href=&quot;c-api/array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt;マクロによって更新されます。</target>
        </trans-unit>
        <trans-unit id="893c6dfe4a5a151e44d6687fac35fbd3b646a45a" translate="yes" xml:space="preserve">
          <source>The core dimensions are removed from all inputs and the remaining dimensions are broadcast together, defining the loop dimensions.</source>
          <target state="translated">コアディメンジョンはすべての入力から削除され、残りのディメンジョンは一緒にブロードキャストされ、ループディメンジョンが定義されます。</target>
        </trans-unit>
        <trans-unit id="72b350bebf37a78a10162e24af07cb3168e9e839" translate="yes" xml:space="preserve">
          <source>The core of the ufunc is the &lt;a href=&quot;#c.PyUFuncObject&quot;&gt;&lt;code&gt;PyUFuncObject&lt;/code&gt;&lt;/a&gt; which contains all the information needed to call the underlying C-code loops that perform the actual work. While it is described here for completeness, it should be considered internal to NumPy and manipulated via &lt;code&gt;PyUFunc_*&lt;/code&gt; functions. The size of this structure is subject to change across versions of NumPy. To ensure compatibility:</source>
          <target state="translated">ufuncの中核は&lt;a href=&quot;#c.PyUFuncObject&quot;&gt; &lt;code&gt;PyUFuncObject&lt;/code&gt; &lt;/a&gt;で、実際の作業を実行する基本的なCコードループを呼び出すために必要なすべての情報が含まれています。完全を &lt;code&gt;PyUFunc_*&lt;/code&gt; ためにここで説明しますが、NumPyの内部と見なして、PyUFunc_ *関数を介して操作する必要があります。この構造のサイズは、NumPyのバージョン間で変更される可能性があります。互換性を確保するには：</target>
        </trans-unit>
        <trans-unit id="773b5bb85bcdc60b3e588df5ec27ee1692be9141" translate="yes" xml:space="preserve">
          <source>The correct interpretation of the hermitian input depends on the length of the original data, as given by &lt;code&gt;n&lt;/code&gt;. This is because each input shape could correspond to either an odd or even length signal. By default, &lt;a href=&quot;#numpy.fft.hfft&quot;&gt;&lt;code&gt;hfft&lt;/code&gt;&lt;/a&gt; assumes an even output length which puts the last entry at the Nyquist frequency; aliasing with its symmetric counterpart. By Hermitian symmetry, the value is thus treated as purely real. To avoid losing information, the shape of the full signal &lt;strong&gt;must&lt;/strong&gt; be given.</source>
          <target state="translated">エルミート入力の正しい解釈は、 &lt;code&gt;n&lt;/code&gt; で与えられるように、元のデータの長さに依存します。これは、各入力形状が奇数または偶数の長さの信号に対応する可能性があるためです。デフォルトでは、&lt;a href=&quot;#numpy.fft.hfft&quot;&gt; &lt;code&gt;hfft&lt;/code&gt; &lt;/a&gt;は、最後のエントリをナイキスト周波数に置く偶数の出力長を想定しています。対称的な対応物によるエイリアシング。したがって、エルミート対称性により、値は純粋に実数として扱われます。情報の損失を防ぐために、完全な信号の形状を指定する&lt;strong&gt;必要&lt;/strong&gt;が&lt;strong&gt;あり&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="b5b1507243ebb36968e1fec7c90425484cafd21a" translate="yes" xml:space="preserve">
          <source>The correct interpretation of the hermitian input depends on the length of the original data, as given by &lt;code&gt;n&lt;/code&gt;. This is because each input shape could correspond to either an odd or even length signal. By default, &lt;a href=&quot;#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt; assumes an even output length which puts the last entry at the Nyquist frequency; aliasing with its symmetric counterpart. By Hermitian symmetry, the value is thus treated as purely real. To avoid losing information, the correct length of the real input &lt;strong&gt;must&lt;/strong&gt; be given.</source>
          <target state="translated">エルミート入力の正しい解釈は、 &lt;code&gt;n&lt;/code&gt; で与えられるように、元のデータの長さに依存します。これは、各入力形状が奇数または偶数の長さの信号に対応する可能性があるためです。デフォルトでは、&lt;a href=&quot;#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; &lt;/a&gt;は、最後のエントリをナイキスト周波数に置く偶数の出力長を想定しています。対称的な対応物によるエイリアシング。したがって、エルミート対称性により、値は純粋に実数として扱われます。情報が失われ&lt;strong&gt;ない&lt;/strong&gt;ようにするには、実際の入力の正しい長さを指定する&lt;strong&gt;必要&lt;/strong&gt;が&lt;strong&gt;あり&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="37beab5b2e24a56105c7c01133a885f5a78e9481" translate="yes" xml:space="preserve">
          <source>The correct interpretation of the hermitian input depends on the shape of the original data, as given by &lt;code&gt;s&lt;/code&gt;. This is because each input shape could correspond to either an odd or even length signal. By default, &lt;a href=&quot;#numpy.fft.irfftn&quot;&gt;&lt;code&gt;irfftn&lt;/code&gt;&lt;/a&gt; assumes an even output length which puts the last entry at the Nyquist frequency; aliasing with its symmetric counterpart. When performing the final complex to real transform, the last value is thus treated as purely real. To avoid losing information, the correct shape of the real input &lt;strong&gt;must&lt;/strong&gt; be given.</source>
          <target state="translated">エルミート入力の正しい解釈は、 &lt;code&gt;s&lt;/code&gt; で与えられるように、元のデータの形状に依存します。これは、各入力形状が奇数または偶数の長さの信号に対応する可能性があるためです。デフォルトでは、&lt;a href=&quot;#numpy.fft.irfftn&quot;&gt; &lt;code&gt;irfftn&lt;/code&gt; &lt;/a&gt;は、最後のエントリをナイキスト周波数に置く偶数の出力長を想定しています。対称的な対応物によるエイリアシング。したがって、最終的な複素数から実数への変換を実行する場合、最後の値は純粋に実数として扱われます。情報の損失を避けるために、実際の入力の正しい形状を指定する&lt;strong&gt;必要&lt;/strong&gt;が&lt;strong&gt;あり&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="76b4be14cc8fe5491309195ba608e3525321fc00" translate="yes" xml:space="preserve">
          <source>The correlation coefficient matrix of the variables.</source>
          <target state="translated">変数の相関係数行列。</target>
        </trans-unit>
        <trans-unit id="f4e710373f0588180cd5157b94f36ff64a509ad5" translate="yes" xml:space="preserve">
          <source>The corresponding angle in degrees. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">度単位の対応する角度。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="a2c63fcb50ab2a66bb9a9ad01ce9f4ff69c1d271" translate="yes" xml:space="preserve">
          <source>The corresponding angle in radians. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">ラジアンでの対応する角度。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="1f2189e088542b025710d6c9de389530dc9fecea" translate="yes" xml:space="preserve">
          <source>The corresponding argument is a function provided by user. The signature of this so-called call-back function can be defined</source>
          <target state="translated">対応する引数は、ユーザが提供する関数です。このいわゆるコールバック関数のシグネチャは、以下のように定義することができます。</target>
        </trans-unit>
        <trans-unit id="f35b3b067b2fb40c400d505d2d253ac20a239da1" translate="yes" xml:space="preserve">
          <source>The corresponding argument is considered as a required one. This is default. You need to specify &lt;code&gt;required&lt;/code&gt; only if there is a need to disable automatic &lt;code&gt;optional&lt;/code&gt; setting when &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; is used.</source>
          <target state="translated">対応する引数は必須の引数と見なされます。これはデフォルトです。 &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; を使用するときに自動 &lt;code&gt;optional&lt;/code&gt; 設定を無効にする必要がある場合にのみ、 &lt;code&gt;required&lt;/code&gt; を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="4b483a77dd25e17d676f790b212de11141a0187e" translate="yes" xml:space="preserve">
          <source>The corresponding argument is moved to the end of &lt;code&gt;&amp;lt;optional
arguments&amp;gt;&lt;/code&gt; list. A default value for an optional argument can be specified &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt;, see &lt;code&gt;entitydecl&lt;/code&gt; definition. Note that the default value must be given as a valid C expression.</source>
          <target state="translated">対応する引数が &lt;code&gt;&amp;lt;optional arguments&amp;gt;&lt;/code&gt; リストの最後に移動されます。オプションの引数のデフォルト値は &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; で指定できます &lt;code&gt;entitydecl&lt;/code&gt; 定義を参照してください。デフォルト値は有効なC式として指定する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c2babda63010514076aef395fac45645683b9564" translate="yes" xml:space="preserve">
          <source>The corresponding array scalar type is &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="translated">対応する配列スカラー型は &lt;code&gt;int32&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="cd11fa4205dd5b33a3e2b183413534954599bad7" translate="yes" xml:space="preserve">
          <source>The corresponding cosine values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">対応するコサイン値。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="6d98f6605847a59a64fcad02a0b3d4fdfd44ca3d" translate="yes" xml:space="preserve">
          <source>The corresponding degree values; if &lt;code&gt;out&lt;/code&gt; was supplied this is a reference to it. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">対応する次数の値。 &lt;code&gt;out&lt;/code&gt; が指定された場合、これはそれへの参照です。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="2584010810109879710934f24451582df80fa088" translate="yes" xml:space="preserve">
          <source>The corresponding hyperbolic sine values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">対応する双曲線正弦値。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="2f46b05f80b785698faf42d321e3104fa7625e8a" translate="yes" xml:space="preserve">
          <source>The corresponding hyperbolic tangent values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">対応する双曲線正接値。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="d9ca95035c9f509708b9e99487c1ebe9e3ab11bd" translate="yes" xml:space="preserve">
          <source>The corresponding radian values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">対応するラジアン値。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="c1e4a7360c69977ad10edc5bee560d5ac06dcf90" translate="yes" xml:space="preserve">
          <source>The corresponding tangent values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">対応する接線の値。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="794da0dacd34a3a537b8957b7fa2b5dd6a0fb954" translate="yes" xml:space="preserve">
          <source>The corresponding user-provided Python function are then:</source>
          <target state="translated">そして、対応するユーザー提供のPython関数です。</target>
        </trans-unit>
        <trans-unit id="b0e664cdf4ef8fa1adefc68661d3976d497abf20" translate="yes" xml:space="preserve">
          <source>The corresponding variable is Fortran 90 allocatable array defined as Fortran 90 module data.</source>
          <target state="translated">対応する変数は、Fortran 90 モジュールデータとして定義された Fortran 90 アロケート可能な配列です。</target>
        </trans-unit>
        <trans-unit id="48e42f957c48b62c124f0261112a23bae77caa2c" translate="yes" xml:space="preserve">
          <source>The corresponding variable is a parameter and it must have a fixed value. F2PY replaces all parameter occurrences by their corresponding values.</source>
          <target state="translated">対応する変数はパラメータであり、固定値を持たなければなりません。F2PY は、すべてのパラメータの出現を対応する値に置き換えます。</target>
        </trans-unit>
        <trans-unit id="c2320966ba7c65e57cb9263bdefeef1fa1cb2d7e" translate="yes" xml:space="preserve">
          <source>The corresponding variable is considered as an array with given dimensions in &lt;code&gt;&amp;lt;arrayspec&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">対応する変数は、 &lt;code&gt;&amp;lt;arrayspec&amp;gt;&lt;/code&gt; で指定された次元の配列と見なされます。</target>
        </trans-unit>
        <trans-unit id="f1763b6e0e62ea8d29f68696fab1bd4ea96474d4" translate="yes" xml:space="preserve">
          <source>The cost for a matrix multiplication can be calculated with the following function:</source>
          <target state="translated">行列の乗算にかかるコストは、以下の関数で計算できます。</target>
        </trans-unit>
        <trans-unit id="6933bada15117031adec212786a3dbdf77a91aff" translate="yes" xml:space="preserve">
          <source>The costs for the two different parenthesizations are as follows:</source>
          <target state="translated">2つの異なる括弧を付けた場合の費用は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="71417050531966fa2bba7739241abcc4b67310e0" translate="yes" xml:space="preserve">
          <source>The counterclockwise angle from the positive real axis on the complex plane in the range &lt;code&gt;(-pi, pi]&lt;/code&gt;, with dtype as numpy.float64.</source>
          <target state="translated">範囲 &lt;code&gt;(-pi, pi]&lt;/code&gt; の複素平面上の正の実軸からの反時計回りの角度。dtypeはnumpy.float64です。</target>
        </trans-unit>
        <trans-unit id="1b6aacea9be65b883730cfcba5386d3d1b9a0223" translate="yes" xml:space="preserve">
          <source>The cov input is used to compute a factor matrix A such that &lt;code&gt;A @ A.T = cov&lt;/code&gt;. This argument is used to select the method used to compute the factor matrix A. The default method &amp;lsquo;svd&amp;rsquo; is the slowest, while &amp;lsquo;cholesky&amp;rsquo; is the fastest but less robust than the slowest method. The method &lt;code&gt;eigh&lt;/code&gt; uses eigen decomposition to compute A and is faster than svd but slower than cholesky.</source>
          <target state="translated">cov入力は、 &lt;code&gt;A @ A.T = cov&lt;/code&gt; ような因子行列Aを計算するために使用されます。この引数は、因子行列Aの計算に使用される方法を選択するために使用されます。デフォルトの方法「svd」が最も遅く、「コレスキー」が最も速くなりますが、最も遅い方法よりも堅牢ではありません。メソッド &lt;code&gt;eigh&lt;/code&gt; は、固有分解を使用してAを計算し、svdよりも高速ですが、コレスキーよりも低速です。</target>
        </trans-unit>
        <trans-unit id="703b92f1857fec3346f55e95a27ed079fdf918ac" translate="yes" xml:space="preserve">
          <source>The covariance matrix of the variables.</source>
          <target state="translated">変数の共分散行列。</target>
        </trans-unit>
        <trans-unit id="f56bfc3801b5981a49e90ddd94a5011933b03e11" translate="yes" xml:space="preserve">
          <source>The cross product of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in</source>
          <target state="translated">外積と &lt;code&gt;b&lt;/code&gt; で &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="430c46a913654deeda9ef3928a00e710ee9f7b73" translate="yes" xml:space="preserve">
          <source>The ctypes attribute of an ndarray is also endowed with additional attributes that may be convenient when passing additional information about the array into a ctypes function. The attributes &lt;strong&gt;data&lt;/strong&gt;, &lt;strong&gt;shape&lt;/strong&gt;, and &lt;strong&gt;strides&lt;/strong&gt; can provide ctypes compatible types corresponding to the data-area, the shape, and the strides of the array. The data attribute returns a &lt;code&gt;c_void_p&lt;/code&gt; representing a pointer to the data area. The shape and strides attributes each return an array of ctypes integers (or None representing a NULL pointer, if a 0-d array). The base ctype of the array is a ctype integer of the same size as a pointer on the platform. There are also methods &lt;code&gt;data_as({ctype})&lt;/code&gt;, &lt;code&gt;shape_as(&amp;lt;base ctype&amp;gt;)&lt;/code&gt;, and &lt;code&gt;strides_as(&amp;lt;base
ctype&amp;gt;)&lt;/code&gt;. These return the data as a ctype object of your choice and the shape/strides arrays using an underlying base type of your choice. For convenience, the &lt;code&gt;ctypeslib&lt;/code&gt; module also contains &lt;code&gt;c_intp&lt;/code&gt; as a ctypes integer data-type whose size is the same as the size of &lt;code&gt;c_void_p&lt;/code&gt; on the platform (its value is None if ctypes is not installed).</source>
          <target state="translated">ndarrayのctypes属性には、配列に関する追加情報をctypes関数に渡すときに便利な追加の属性もあります。属性&lt;strong&gt;data&lt;/strong&gt;、&lt;strong&gt;shape&lt;/strong&gt;、およびstridesは、配列のデータ領域、&lt;strong&gt;形状&lt;/strong&gt;、および&lt;strong&gt;ストライドに&lt;/strong&gt;対応するctypes互換タイプを提供できます。 data属性は、データ領域へのポインタを表す &lt;code&gt;c_void_p&lt;/code&gt; を返します。 shape属性とstrides属性はそれぞれ、ctypes整数の配列を返します（または、0-d配列の場合はNoneがNULLポインターを表します）。配列の基本ctypeは、プラットフォーム上のポインターと同じサイズのctype整数です。メソッド &lt;code&gt;data_as({ctype})&lt;/code&gt; 、 &lt;code&gt;shape_as(&amp;lt;base ctype&amp;gt;)&lt;/code&gt; もあります、および &lt;code&gt;strides_as(&amp;lt;base ctype&amp;gt;)&lt;/code&gt; 。これらは、選択したctypeオブジェクトとしてデータを返し、選択した基本タイプを使用して形状/ストライド配列を返します。便宜上、 &lt;code&gt;ctypeslib&lt;/code&gt; モジュールには、プラットフォーム上の &lt;code&gt;c_void_p&lt;/code&gt; のサイズと同じサイズのctypes整数データ型として &lt;code&gt;c_intp&lt;/code&gt; も含まれています（ctypesがインストールされていない場合の値はNoneです）。</target>
        </trans-unit>
        <trans-unit id="d70737d8a9b599cea578eef90e469f4ec5cade8d" translate="yes" xml:space="preserve">
          <source>The cumulative product for each column (i.e., over the rows) of &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">の各列（すなわち、行以上）の累積生成物： &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4974aaba8d216c55c50471b0bc56ddd6323d0ebc" translate="yes" xml:space="preserve">
          <source>The cumulative product for each row (i.e. over the columns) of &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; の各行（つまり列）の累積積：</target>
        </trans-unit>
        <trans-unit id="50631d91282d5f6763c8dcfd14a90d74339342d9" translate="yes" xml:space="preserve">
          <source>The current (1-d) index into the broadcasted result.</source>
          <target state="translated">放送された結果への現在の(1-d)インデックス。</target>
        </trans-unit>
        <trans-unit id="8c233acaa927b0b3ae6437f9077a3fae3621ed5f" translate="yes" xml:space="preserve">
          <source>The current 1-d index into the array.</source>
          <target state="translated">配列への現在の1-dインデックス.</target>
        </trans-unit>
        <trans-unit id="2fbbd9d31a318df9bc191ffa89f350440a39a71f" translate="yes" xml:space="preserve">
          <source>The current Python interface to the &lt;code&gt;f2py&lt;/code&gt; module is not mature and may change in the future.</source>
          <target state="translated">&lt;code&gt;f2py&lt;/code&gt; モジュールへの現在のPythonインターフェースは成熟しておらず、将来変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="cbb3baf8a681bbb5337a5050d23b30de4d838c39" translate="yes" xml:space="preserve">
          <source>The current error handler. If no handler was set through &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">現在のエラーハンドラ。&lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt;でハンドラが設定されていない場合は、 &lt;code&gt;None&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="67a8fb2d19e8571c91416871498dce96f7ad1021" translate="yes" xml:space="preserve">
          <source>The current info on building and releasing NumPy and SciPy is scattered in several places. It should be summarized in one place, updated, and where necessary described in more detail. The sections below list all places where useful info can be found.</source>
          <target state="translated">NumPy と SciPy のビルドとリリースに関する現在の情報は、いくつかの場所に散らばっています。一箇所にまとめ、更新し、必要に応じてより詳細に説明してください。以下のセクションでは、有用な情報が見つかる場所をリストアップしています。</target>
        </trans-unit>
        <trans-unit id="fcd1e82b97c62204928be3c1426e12c2f8f2093c" translate="yes" xml:space="preserve">
          <source>The current interface remains unchanged, and &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; can still be used to implement (specialized) ufuncs, consisting of scalar elementary functions.</source>
          <target state="translated">現在のインターフェースは変更されないままであり、 &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; は、スカラ基本関数で構成される（特殊化された）ufuncを実装するために引き続き使用できます。</target>
        </trans-unit>
        <trans-unit id="0ec2778c22d5d6f2fae8e55f79998855331eeed7" translate="yes" xml:space="preserve">
          <source>The current membership of the NumFOCUS Subcommittee is listed at the page &lt;a href=&quot;people#governance-people&quot;&gt;Current steering council and institutional partners&lt;/a&gt;.</source>
          <target state="translated">NumFOCUS小委員会の現在のメンバーシップは、&lt;a href=&quot;people#governance-people&quot;&gt;現在の運営評議会および機関パートナーの&lt;/a&gt;ページにリストされています。</target>
        </trans-unit>
        <trans-unit id="4809e84f7d3a9eb68e3d6e9384c7ac43b19e108c" translate="yes" xml:space="preserve">
          <source>The current version of the ndarray object (check to see if this variable is defined to guarantee the numpy/arrayobject.h header is being used).</source>
          <target state="translated">ndarrayオブジェクトの現在のバージョン(numpy/arrayobject.hヘッダが使用されていることを保証するためにこの変数が定義されているかどうかを確認してください)。</target>
        </trans-unit>
        <trans-unit id="d02692cc2b9183733a0e1ac33e907e722f2cb651" translate="yes" xml:space="preserve">
          <source>The data actually stored in object arrays (&lt;em&gt;i.e.&lt;/em&gt;, arrays having dtype &lt;code&gt;object_&lt;/code&gt;) are references to Python objects, not the objects themselves. Hence, object arrays behave more like usual Python &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt;&lt;code&gt;lists&lt;/code&gt;&lt;/a&gt;, in the sense that their contents need not be of the same Python type.</source>
          <target state="translated">オブジェクト配列（&lt;em&gt;つまり&lt;/em&gt;、dtype &lt;code&gt;object_&lt;/code&gt; を持つ配列）に実際に格納されているデータは、オブジェクト自体ではなく、Pythonオブジェクトへの参照です。したがって、オブジェクト配列&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt; &lt;code&gt;lists&lt;/code&gt; &lt;/a&gt;、その内容が同じPythonタイプである必要がないという意味で、通常のPython リストのように動作します。</target>
        </trans-unit>
        <trans-unit id="2b8f4fa1516918fd8297afcfb360ffa13708823d" translate="yes" xml:space="preserve">
          <source>The data and all elements are aligned appropriately for the hardware.</source>
          <target state="translated">データと全ての要素がハードウェアに合わせて適切に配置されています。</target>
        </trans-unit>
        <trans-unit id="3286aa81b485c3d7add58cb76776a5c44fcb4bf2" translate="yes" xml:space="preserve">
          <source>The data area and all array elements are aligned appropriately.</source>
          <target state="translated">データ領域とすべての配列要素が適切に整列されます。</target>
        </trans-unit>
        <trans-unit id="c1365a86184a90bddcccd2199d804c180d307014" translate="yes" xml:space="preserve">
          <source>The data area can be written to.</source>
          <target state="translated">データ領域に書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="539587e7a7889df8e80a73151cc3ac06f87c111c" translate="yes" xml:space="preserve">
          <source>The data area can be written to. Setting this to False locks the data, making it read-only. A view (slice, etc.) inherits WRITEABLE from its base array at creation time, but a view of a writeable array may be subsequently locked while the base array remains writeable. (The opposite is not true, in that a view of a locked array may not be made writeable. However, currently, locking a base object does not lock any views that already reference it, so under that circumstance it is possible to alter the contents of a locked array via a previously created writeable view onto it.) Attempting to change a non-writeable array raises a RuntimeError exception.</source>
          <target state="translated">データ領域に書き込むことができます。これを False に設定すると、データがロックされ、読み取り専用になります。ビュー(スライスなど)は、作成時にベース配列からWRITEABLEを継承しますが、書き込み可能な配列のビューは、その後ベース配列が書き込み可能なままロックされることがあります(逆は真ではありません)。(逆は真ではなく、ロックされた配列のビューを書き込み可能にすることはできません。しかし、現在のところ、ベースオブジェクトをロックしても、すでに参照しているビューはロックされないので、そのような状況下では、以前に作成された書き込み可能なビューを介して、ロックされた配列の内容を変更することが可能です)。書き込み不可能な配列を変更しようとすると、RuntimeError 例外が発生します。</target>
        </trans-unit>
        <trans-unit id="dfe7ced9a654feaf927f01f408558bf43f63134c" translate="yes" xml:space="preserve">
          <source>The data area is in C-style contiguous order (last index varies the fastest).</source>
          <target state="translated">データ領域はC形式で連続しています(最後のインデックスが最も早く変化します)。</target>
        </trans-unit>
        <trans-unit id="28271e4f2d83215b5c3293be14583eebd0638934" translate="yes" xml:space="preserve">
          <source>The data area is in Fortran-style contiguous order (first index varies the fastest).</source>
          <target state="translated">データ領域はFortran形式の連続した順序(最初のインデックスが最も速い順に変化します)です。</target>
        </trans-unit>
        <trans-unit id="a2e621a0b9254b737a1faf535f1456a6f33c01ae" translate="yes" xml:space="preserve">
          <source>The data area is owned by this array.</source>
          <target state="translated">データ領域はこの配列が所有しています。</target>
        </trans-unit>
        <trans-unit id="ca9e054ad351441ecdb18cea4952500858e11b12" translate="yes" xml:space="preserve">
          <source>The data area represents a (well-behaved) copy whose information should be transferred back to the original when &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">データ領域は（適切に動作する）コピーを表し、その情報は&lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;が呼び出されたときに元に戻されます。</target>
        </trans-unit>
        <trans-unit id="15eb3cf2a1c1abdf07a79e9fe9ea7b5a63c62afd" translate="yes" xml:space="preserve">
          <source>The data in the array is returned as a single string. This function is similar to &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt;, the difference being that &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt; also returns information on the kind of array and its data type.</source>
          <target state="translated">配列のデータは単一の文字列として返されます。この関数は&lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt;に似ていますが、&lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt;は配列の種類とそのデータ型に関する情報も返す点が異なります。</target>
        </trans-unit>
        <trans-unit id="4cbbe8ca710f692f60ad1bfe0fc2af00b27f6fa9" translate="yes" xml:space="preserve">
          <source>The data in the same field can be heterogeneous, they will be promoted to the highest data type. This method is intended for creating smaller record arrays. If used to create large array without formats defined</source>
          <target state="translated">同じフィールド内のデータは異種である可能性があり、それらは最も高いデータ型に昇格します。このメソッドは、より小さなレコード配列を作成するためのものです。フォーマットが定義されていない大きな配列を作成するために使用される場合</target>
        </trans-unit>
        <trans-unit id="f030fb38724d73d189a884d6cd4eaca4e1c69e90" translate="yes" xml:space="preserve">
          <source>The data is in a single, C-style contiguous segment.</source>
          <target state="translated">データは1つのCスタイルの連続したセグメントにあります。</target>
        </trans-unit>
        <trans-unit id="5f1d8da4b437441472e9916d9ae01c496d02e5d4" translate="yes" xml:space="preserve">
          <source>The data is in a single, Fortran-style contiguous segment.</source>
          <target state="translated">データはFortranスタイルの単一の連続セグメントにあります。</target>
        </trans-unit>
        <trans-unit id="56a1a480524e7bf67ab594cb10c3c6101b00713c" translate="yes" xml:space="preserve">
          <source>The data of the resulting array will not be byteswapped, but will be interpreted correctly.</source>
          <target state="translated">結果として得られる配列のデータはバイトスワップされず、正しく解釈されます。</target>
        </trans-unit>
        <trans-unit id="b88d2dbaff9987ad87362817ef4a120d93a6244e" translate="yes" xml:space="preserve">
          <source>The data to be histogrammed.</source>
          <target state="translated">ヒストグラム化するデータ。</target>
        </trans-unit>
        <trans-unit id="5386b778229b14d65914edc6d972b4efb28b5001" translate="yes" xml:space="preserve">
          <source>The data type object associated with the array can be found in the &lt;a href=&quot;generated/numpy.ndarray.dtype#numpy.ndarray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; attribute:</source>
          <target state="translated">配列に関連付けられたデータ型オブジェクトは、&lt;a href=&quot;generated/numpy.ndarray.dtype#numpy.ndarray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;属性にあります。</target>
        </trans-unit>
        <trans-unit id="1c7886ffa6332318e280aa7625497d4df1ee7f24" translate="yes" xml:space="preserve">
          <source>The data type of &lt;code&gt;rep&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rep&lt;/code&gt; のデータ型。</target>
        </trans-unit>
        <trans-unit id="4b822d3fbc39f811ebad48ba4194f76d214d3123" translate="yes" xml:space="preserve">
          <source>The data type of an operand with this flag should be either &lt;a href=&quot;c-api.dtype#c.NPY_BOOL&quot;&gt;&lt;code&gt;NPY_BOOL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_MASK&quot;&gt;&lt;code&gt;NPY_MASK&lt;/code&gt;&lt;/a&gt;, or a struct dtype whose fields are all valid mask dtypes. In the latter case, it must match up with a struct operand being WRITEMASKED, as it is specifying a mask for each field of that array.</source>
          <target state="translated">このフラグを持つオペランドのデータ型は、&lt;a href=&quot;c-api.dtype#c.NPY_BOOL&quot;&gt; &lt;code&gt;NPY_BOOL&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;c-api.dtype#c.NPY_MASK&quot;&gt; &lt;code&gt;NPY_MASK&lt;/code&gt; &lt;/a&gt;、またはフィールドがすべて有効なマスクdtypeであるstruct dtypeのいずれかである必要があります。後者の場合、その配列の各フィールドのマスクを指定しているため、構造体のオペランドがWRITEMASKEDであることと一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="ba40ae5f60c6c9bf8317272fcf427a71c0e5f01a" translate="yes" xml:space="preserve">
          <source>The data type of an operand with this flag should be either &lt;a href=&quot;dtype#c.NPY_BOOL&quot;&gt;&lt;code&gt;NPY_BOOL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;dtype#c.NPY_MASK&quot;&gt;&lt;code&gt;NPY_MASK&lt;/code&gt;&lt;/a&gt;, or a struct dtype whose fields are all valid mask dtypes. In the latter case, it must match up with a struct operand being WRITEMASKED, as it is specifying a mask for each field of that array.</source>
          <target state="translated">このフラグを持つオペランドのデータ型は、&lt;a href=&quot;dtype#c.NPY_BOOL&quot;&gt; &lt;code&gt;NPY_BOOL&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;dtype#c.NPY_MASK&quot;&gt; &lt;code&gt;NPY_MASK&lt;/code&gt; &lt;/a&gt;、またはフィールドがすべて有効なマスクdtypeであるstructdtypeのいずれかである必要があります。後者の場合、その配列の各フィールドにマスクを指定しているため、WRITEMASKEDである構造体オペランドと一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="11db59fda83e28216c250b45f855268127882d3e" translate="yes" xml:space="preserve">
          <source>The data type of the array; default: float. For binary input data, the data must be in exactly this format.</source>
          <target state="translated">配列のデータ型。デフォルトは float です。バイナリ入力データの場合、データは正確にこの形式でなければなりません。</target>
        </trans-unit>
        <trans-unit id="7ef4dd0c7cf28c23f4cb2015d84e3c63ca538a1e" translate="yes" xml:space="preserve">
          <source>The data type of the array; default: float. For binary input data, the data must be in exactly this format. Most builtin numeric types are supported and extension types may be supported.</source>
          <target state="translated">配列のデータ型。デフォルトは float です。バイナリ入力データの場合、データは正確にこの形式でなければなりません。ほとんどの組み込みの数値型がサポートされており、拡張型もサポートされている場合があります。</target>
        </trans-unit>
        <trans-unit id="6121c8d9cd39c4f61e9ffef0d098e3b7d36639d6" translate="yes" xml:space="preserve">
          <source>The data type of the output of &lt;code&gt;vectorized&lt;/code&gt; is determined by calling the function with the first element of the input. This can be avoided by specifying the &lt;code&gt;otypes&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;vectorized&lt;/code&gt; された出力のデータ型は、入力の最初の要素で関数を呼び出すことによって決定されます。これは、 &lt;code&gt;otypes&lt;/code&gt; 引数を指定することで回避できます。</target>
        </trans-unit>
        <trans-unit id="bc2814a7f847db35d30b7458174ec64d03a7e7a5" translate="yes" xml:space="preserve">
          <source>The data type of the view. The dtype size of the view can not be larger than that of the array itself.</source>
          <target state="translated">ビューのデータ型。ビューのdtypeのサイズは、配列自体のサイズより大きくすることはできません。</target>
        </trans-unit>
        <trans-unit id="99643c3f7e25f9a00992f90ee5d0bdd7cb79f63e" translate="yes" xml:space="preserve">
          <source>The data types of the values provided in &lt;a href=&quot;numpy.nditer.value#numpy.nditer.value&quot;&gt;&lt;code&gt;value&lt;/code&gt;&lt;/a&gt;. This may be different from the operand data types if buffering is enabled. Valid only before the iterator is closed.</source>
          <target state="translated">valueで提供される&lt;a href=&quot;numpy.nditer.value#numpy.nditer.value&quot;&gt; &lt;code&gt;value&lt;/code&gt; &lt;/a&gt;のデータ型。これは、バッファリングが有効になっている場合、オペランドのデータ型と異なる場合があります。イテレータが閉じられる前にのみ有効です。</target>
        </trans-unit>
        <trans-unit id="9d016fef105a6db00651ac782a1c7e9c999e6600" translate="yes" xml:space="preserve">
          <source>The data-type is an important abstraction of the ndarray. Operations will look to the data-type to provide the key functionality that is needed to operate on the array. This functionality is provided in the list of function pointers pointed to by the &amp;lsquo;f&amp;rsquo; member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure. In this way, the number of data-types can be extended simply by providing a &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure with suitable function pointers in the &amp;lsquo;f&amp;rsquo; member. For built-in types there are some optimizations that by-pass this mechanism, but the point of the data- type abstraction is to allow new data-types to be added.</source>
          <target state="translated">データ型は、ndarrayの重要な抽象化です。操作では、データ型を参照して、アレイの操作に必要な主要な機能を提供します。この機能は、&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;構造体の'f'メンバーが指す関数ポインターのリストで提供されます。このように、&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;構造体に 'f'メンバーの適切な関数ポインターを提供するだけで、データ型の数を拡張できます。組み込み型の場合、このメカニズムを回避するいくつかの最適化がありますが、データ型の抽象化のポイントは、新しいデータ型を追加できるようにすることです。</target>
        </trans-unit>
        <trans-unit id="3bc7ca60ba414cbf4855ce7f1e99de3ef90f6929" translate="yes" xml:space="preserve">
          <source>The data-type is an important abstraction of the ndarray. Operations will look to the data-type to provide the key functionality that is needed to operate on the array. This functionality is provided in the list of function pointers pointed to by the &amp;lsquo;f&amp;rsquo; member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure. In this way, the number of data-types can be extended simply by providing a &lt;a href=&quot;c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure with suitable function pointers in the &amp;lsquo;f&amp;rsquo; member. For built-in types there are some optimizations that by-pass this mechanism, but the point of the data- type abstraction is to allow new data-types to be added.</source>
          <target state="translated">データ型は、ndarrayの重要な抽象化です。操作はデータ型を調べて、配列を操作するために必要な主要な機能を提供します。この機能は、&lt;a href=&quot;c-api/types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;構造体の「f」メンバーが指す関数ポインターのリストで提供されます。このように、データ型の数は、&lt;a href=&quot;c-api/types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;構造体に「f」メンバーに適切な関数ポインターを提供するだけで拡張できます。組み込み型の場合、このメカニズムをバイパスするいくつかの最適化がありますが、データ型の抽象化のポイントは、新しいデータ型を追加できるようにすることです。</target>
        </trans-unit>
        <trans-unit id="b58fbdafeaa8107e58c408c096a3cb8ca5d659d7" translate="yes" xml:space="preserve">
          <source>The data-type of the returned array.</source>
          <target state="translated">返された配列のデータ型。</target>
        </trans-unit>
        <trans-unit id="5c8d679fa5d2836b35d4e189ea3c3c42c4a9bfcc" translate="yes" xml:space="preserve">
          <source>The data-type used to interpret the file contents. Default is &lt;code&gt;uint8&lt;/code&gt;.</source>
          <target state="translated">ファイルの内容を解釈するために使用されるデータ型。デフォルトは &lt;code&gt;uint8&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e1e17b816f5aa8d3b539033dd4f8579bd040ce7c" translate="yes" xml:space="preserve">
          <source>The data-type used to represent the intermediate results. Defaults to the data-type of the output array if such is provided, or the the data-type of the input array if no output array is provided.</source>
          <target state="translated">中間結果の表現に用いられるデータ型.デフォルトは,出力配列が指定されている場合はそのデータ型,出力配列が指定されていない場合は入力配列のデータ型となります.</target>
        </trans-unit>
        <trans-unit id="932e882a29033e270334b0a0ca27c7a0b749d38c" translate="yes" xml:space="preserve">
          <source>The data-type-descriptor object of the base-type.</source>
          <target state="translated">ベースタイプのdata-type-descriptorオブジェクト。</target>
        </trans-unit>
        <trans-unit id="d6987a7425e0ff97a8320c32ec6abc8ee62f4f4d" translate="yes" xml:space="preserve">
          <source>The datatype determines which of &amp;lsquo;mergesort&amp;rsquo; or &amp;lsquo;timsort&amp;rsquo; is actually used, even if &amp;lsquo;mergesort&amp;rsquo; is specified. User selection at a finer scale is not currently available.</source>
          <target state="translated">データ型は、「mergesort」が指定されている場合でも、「mergesort」または「timsort」のどちらが実際に使用されるかを決定します。より細かいスケールでのユーザー選択は現在利用できません。</target>
        </trans-unit>
        <trans-unit id="f8494cadb009486b1d5ee5b6a13352cbf85e331c" translate="yes" xml:space="preserve">
          <source>The datetime API is &lt;em&gt;experimental&lt;/em&gt; in 1.7.0, and may undergo changes in future versions of NumPy.</source>
          <target state="translated">日時APIは1.7.0で&lt;em&gt;実験的&lt;/em&gt;であり、NumPyの将来のバージョンで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="5a29e38fde2fbef6d304ea68f9f28e90e826577d" translate="yes" xml:space="preserve">
          <source>The datetime object represents a single moment in time. If two datetimes have different units, they may still be representing the same moment of time, and converting from a bigger unit like months to a smaller unit like days is considered a &amp;lsquo;safe&amp;rsquo; cast because the moment of time is still being represented exactly.</source>
          <target state="translated">datetimeオブジェクトは、1つの瞬間を表します。2つの日時の単位が異なる場合でも、それらは同じ瞬間を表している可能性があり、月のような大きな単位から日のような小さな単位への変換は、瞬間がまだ正確に表されているため、「安全な」キャストと見なされます。</target>
        </trans-unit>
        <trans-unit id="96194d206533dca35ec887829a70fc8982e7d450" translate="yes" xml:space="preserve">
          <source>The datetime string parser in NumPy 1.6 is very liberal in what it accepts, and silently allows invalid input without raising errors. The parser in NumPy 1.7 is quite strict about only accepting ISO 8601 dates, with a few convenience extensions. 1.6 always creates microsecond (us) units by default, whereas 1.7 detects a unit based on the format of the string. Here is a comparison.:</source>
          <target state="translated">NumPy 1.6のdatetime文字列パーサは、受け入れるものに対して非常に自由で、エラーを発生させることなく、無効な入力を黙って許可します。NumPy 1.7のパーサは、ISO 8601の日付のみを受け入れるという非常に厳格なものですが、いくつかの便利な拡張機能があります。1.6ではデフォルトで常にマイクロ秒(us)単位を作成しますが、1.7では文字列のフォーマットに基づいて単位を検出します。以下に比較を示します。</target>
        </trans-unit>
        <trans-unit id="1369383d5a514fcfed8df04d6ed924de54d6f3b1" translate="yes" xml:space="preserve">
          <source>The datetime type works with many common NumPy functions, for example &lt;a href=&quot;generated/numpy.arange#numpy.arange&quot;&gt;&lt;code&gt;arange&lt;/code&gt;&lt;/a&gt; can be used to generate ranges of dates.</source>
          <target state="translated">日時型は、多くの一般的なNumPy関数で機能します。たとえば、&lt;a href=&quot;generated/numpy.arange#numpy.arange&quot;&gt; &lt;code&gt;arange&lt;/code&gt; &lt;/a&gt;を使用して日付の範囲を生成できます。</target>
        </trans-unit>
        <trans-unit id="60d7f83834880a987611358eebe758ac593dc7d2" translate="yes" xml:space="preserve">
          <source>The decomposition is performed using LAPACK routine &lt;code&gt;_gesdd&lt;/code&gt;.</source>
          <target state="translated">分解はLAPACKルーチン &lt;code&gt;_gesdd&lt;/code&gt; を使用して実行されます。</target>
        </trans-unit>
        <trans-unit id="e1516fc7b62e4a0344208958aa595053689db869" translate="yes" xml:space="preserve">
          <source>The decorated test &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">装飾されたテスト &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9657b7f30a96eb6a9709525e36cff8e84658cbb" translate="yes" xml:space="preserve">
          <source>The decorator itself is decorated with the &lt;code&gt;nose.tools.make_decorator&lt;/code&gt; function in order to transmit function name, and various other metadata.</source>
          <target state="translated">関数名やその他のさまざまなメタデータを送信するために、デコレータ自体が &lt;code&gt;nose.tools.make_decorator&lt;/code&gt; 関数で修飾されています。</target>
        </trans-unit>
        <trans-unit id="4a37da8a9aa52a4088272dd54ccf6dae2a209ad8" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;atol&lt;/code&gt; is not appropriate for comparing numbers that are much smaller than one (see Notes).</source>
          <target state="translated">デフォルトの &lt;code&gt;atol&lt;/code&gt; は、1より小さい数値の比較には適していません（「注意」を参照）。</target>
        </trans-unit>
        <trans-unit id="cb5293865f62263e0a19bbfa34c77f6486814f1d" translate="yes" xml:space="preserve">
          <source>The default __array_priority__ of matrix objects is 10.0, and therefore mixed operations with ndarrays always produce matrices.</source>
          <target state="translated">行列オブジェクトのデフォルトの __array_priority__は 10.0 であるため、ndarrays との混合操作は常に行列を生成します。</target>
        </trans-unit>
        <trans-unit id="cd69cae26ca025156d4d72a557a24e650bb3e040" translate="yes" xml:space="preserve">
          <source>The default character, this is returned if none of the characters in &lt;code&gt;typechars&lt;/code&gt; matches a character in &lt;code&gt;typeset&lt;/code&gt;.</source>
          <target state="translated">デフォルトの文字 &lt;code&gt;typechars&lt;/code&gt; の文字もtypesetの文字と一致しない場合に返され &lt;code&gt;typeset&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9f67bac25f1e9fa1addb151018aeaf9def3b945" translate="yes" xml:space="preserve">
          <source>The default data type in NumPy is &lt;code&gt;float_&lt;/code&gt;.</source>
          <target state="translated">NumPyのデフォルトのデータ型は &lt;code&gt;float_&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1cb916c2a199dec22e3c7d35ff5ca943ade2af02" translate="yes" xml:space="preserve">
          <source>The default data type: &lt;code&gt;float_&lt;/code&gt;.</source>
          <target state="translated">デフォルトのデータ型： &lt;code&gt;float_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="585140e706eb572d257d276596c7c62733d99ac8" translate="yes" xml:space="preserve">
          <source>The default fill value.</source>
          <target state="translated">デフォルトの塗りつぶし値。</target>
        </trans-unit>
        <trans-unit id="a6dbb84bde95674721b5026ade7be2a1d41460db" translate="yes" xml:space="preserve">
          <source>The default filling value depends on the datatype of the input array or the type of the input scalar:</source>
          <target state="translated">デフォルトの充填値は,入力配列のデータ型または入力スカラの型に依存します.</target>
        </trans-unit>
        <trans-unit id="d172f7f7da97c607ca46d821dc996e8763c04a60" translate="yes" xml:space="preserve">
          <source>The default for busday functions is that the only valid days are Monday through Friday (the usual business days). The implementation is based on a &amp;ldquo;weekmask&amp;rdquo; containing 7 Boolean flags to indicate valid days; custom weekmasks are possible that specify other sets of valid days.</source>
          <target state="translated">busday関数のデフォルトでは、有効な日は月曜日から金曜日（通常の営業日）のみです。実装は、有効な日を示す7つのブールフラグを含む「週マスク」に基づいています。有効な曜日の他のセットを指定するカスタム週マスクが可能です。</target>
        </trans-unit>
        <trans-unit id="b9e6f3b39a9841c2072fe28c903a4873d59b58cf" translate="yes" xml:space="preserve">
          <source>The default for most operations, raises an exception if an index is out of bounds.</source>
          <target state="translated">ほとんどの操作のデフォルトでは、インデックスが範囲外の場合に例外を発生させます。</target>
        </trans-unit>
        <trans-unit id="f01d70d1a58c31eb28ef483c3e412b7730114894" translate="yes" xml:space="preserve">
          <source>The default interface is a very literal translation of the fortran code into Python. The Fortran array arguments must now be NumPy arrays and the integer argument should be an integer. The interface will attempt to convert all arguments to their required types (and shapes) and issue an error if unsuccessful. However, because it knows nothing about the semantics of the arguments (such that C is an output and n should really match the array sizes), it is possible to abuse this function in ways that can cause Python to crash. For example:</source>
          <target state="translated">デフォルトのインターフェイスは、FortranのコードをPythonに非常にリテラルに変換したものです。Fortran配列の引数はNumPy配列でなければならず、整数の引数は整数でなければなりません。インターフェースはすべての引数を必要な型(と形状)に変換しようとし、失敗した場合はエラーを出します。しかし、引数のセマンティクスについては何も知らないので (C は出力であり、n は本当に配列のサイズと一致しなければなりません)、Python をクラッシュさせるような方法でこの関数を悪用することが可能です。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0b3aadfe669f7dc7282a8bf3bc7021b967d5f363" translate="yes" xml:space="preserve">
          <source>The default is not to change the current behavior.</source>
          <target state="translated">デフォルトでは、現在の動作を変更しないようになっています。</target>
        </trans-unit>
        <trans-unit id="35460c572d36a32620dc9fa812780440e2fcffff" translate="yes" xml:space="preserve">
          <source>The default is to &lt;code&gt;'warn'&lt;/code&gt; for &lt;code&gt;invalid&lt;/code&gt;, &lt;code&gt;divide&lt;/code&gt;, and &lt;code&gt;overflow&lt;/code&gt; and &lt;code&gt;'ignore'&lt;/code&gt; for &lt;code&gt;underflow&lt;/code&gt;. But this can be changed, and it can be set individually for different kinds of exceptions. The different behaviors are:</source>
          <target state="translated">デフォルトでは、することです &lt;code&gt;'warn'&lt;/code&gt; のために &lt;code&gt;invalid&lt;/code&gt; 、 &lt;code&gt;divide&lt;/code&gt; 、および &lt;code&gt;overflow&lt;/code&gt; と &lt;code&gt;'ignore'&lt;/code&gt; のために &lt;code&gt;underflow&lt;/code&gt; 。ただし、これは変更でき、さまざまな種類の例外に対して個別に設定できます。さまざまな動作は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="13f5430198109332da2b945e817fa963554a0039" translate="yes" xml:space="preserve">
          <source>The default iterator of an ndarray object is the default Python iterator of a sequence type. Thus, when the array object itself is used as an iterator. The default behavior is equivalent to:</source>
          <target state="translated">ndarrayオブジェクトのデフォルトのイテレータは、配列型のPythonのデフォルトのイテレータです。このように、配列オブジェクト自体をイテレータとして使用する場合。デフォルトの動作と同等になります。</target>
        </trans-unit>
        <trans-unit id="aac361851a1a42c7bb314d3f5e868ac753b52020" translate="yes" xml:space="preserve">
          <source>The default method is &amp;ldquo;marginals&amp;rdquo;. For some cases (e.g. when &lt;code&gt;colors&lt;/code&gt; contains relatively small integers), the &amp;ldquo;count&amp;rdquo; method can be significantly faster than the &amp;ldquo;marginals&amp;rdquo; method. If performance of the algorithm is important, test the two methods with typical inputs to decide which works best.</source>
          <target state="translated">デフォルトの方法は「周辺」です。場合によっては（たとえば、 &lt;code&gt;colors&lt;/code&gt; に比較的小さな整数が含まれている場合）、「count」メソッドは「marginals」メソッドよりも大幅に高速になる可能性があります。アルゴリズムのパフォーマンスが重要な場合は、一般的な入力を使用して2つの方法をテストし、どちらが最適かを判断します。</target>
        </trans-unit>
        <trans-unit id="d0a1e3c85492f9a28cfa2d6a52018d6303212281" translate="yes" xml:space="preserve">
          <source>The default normalization has the direct transforms unscaled and the inverse transforms are scaled by</source>
          <target state="translated">デフォルトの正規化では、直接変換はスケーリングされず、逆変換は</target>
        </trans-unit>
        <trans-unit id="294bd9e52acfdc133dee5d5ce445aefb23018ef1" translate="yes" xml:space="preserve">
          <source>The default order for the libraries are:</source>
          <target state="translated">ライブラリのデフォルトの順番は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="d79f5666dde2a74098ca71f007435f35059e5b3e" translate="yes" xml:space="preserve">
          <source>The default threshold to detect rank deficiency is a test on the magnitude of the singular values of &lt;code&gt;M&lt;/code&gt;. By default, we identify singular values less than &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; as indicating rank deficiency (with the symbols defined above). This is the algorithm MATLAB uses [1]. It also appears in &lt;em&gt;Numerical recipes&lt;/em&gt; in the discussion of SVD solutions for linear least squares [2].</source>
          <target state="translated">ランクの不足を検出するための既定のしきい値は、 &lt;code&gt;M&lt;/code&gt; の特異値の大きさのテストです。デフォルトでは、 &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; 未満の特異値は、ランクの不足を示すものとして識別されます（上で定義されたシンボルを使用）。これは、MATLABが使用するアルゴリズムです[1]。また、線形最小二乗法のSVDソリューションの説明の&lt;em&gt;数値レシピ&lt;/em&gt;にも記載されています[2]。</target>
        </trans-unit>
        <trans-unit id="fabcee56c3086c9123fae22826809a0d986ec9e3" translate="yes" xml:space="preserve">
          <source>The default type to use when no dtype is explicitly specified, for example when calling np.zero(shape). This is equivalent to &lt;a href=&quot;#c.NPY_DOUBLE&quot;&gt;&lt;code&gt;NPY_DOUBLE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">np.zero（shape）を呼び出すときなど、dtypeが明示的に指定されていない場合に使用するデフォルトのタイプ。これは&lt;a href=&quot;#c.NPY_DOUBLE&quot;&gt; &lt;code&gt;NPY_DOUBLE&lt;/code&gt; &lt;/a&gt;と同等です。</target>
        </trans-unit>
        <trans-unit id="a62d7fdf404d547735e1b655e9c601557613abc2" translate="yes" xml:space="preserve">
          <source>The default valid days are Monday through Friday (&amp;ldquo;business days&amp;rdquo;). A busdaycalendar object can be specified with any set of weekly valid days, plus an optional &amp;ldquo;holiday&amp;rdquo; dates that always will be invalid.</source>
          <target state="translated">デフォルトの有効日は月曜日から金曜日（「営業日」）です。busdaycalendarオブジェクトは、週単位の有効な日と、常に無効になるオプションの「休日」の日付のセットで指定できます。</target>
        </trans-unit>
        <trans-unit id="203757e2bdf5bbe5e651d506c476783cf6e50edd" translate="yes" xml:space="preserve">
          <source>The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order. The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for the alternatives above. For example, any of &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;biggish&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">デフォルト値（ 'S'）の場合、現在のバイト順が入れ替わります。コードは、上記の代替案の &lt;code&gt;new_order&lt;/code&gt; の最初の文字で大文字と小文字を区別しないチェックを行います。たとえば、ビッグエンディアンを指定するには、「B」、「b」、「biggish」のいずれも有効です。</target>
        </trans-unit>
        <trans-unit id="86906072113e4cc2809d8408fb9acbe0a4443ef7" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;names&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;. If we give any other value to the keyword, the new names will overwrite the field names we may have defined with the dtype:</source>
          <target state="translated">&lt;code&gt;names&lt;/code&gt; のデフォルト値は &lt;code&gt;None&lt;/code&gt; です。キーワードに他の値を指定すると、新しい名前によって、dtypeで定義したフィールド名が上書きされます。</target>
        </trans-unit>
        <trans-unit id="19a5ab6c7c39a905e845eb64d8df075515c15636" translate="yes" xml:space="preserve">
          <source>The defining property of the antiderivative:</source>
          <target state="translated">反誘導体の定義的な性質。</target>
        </trans-unit>
        <trans-unit id="7a4397ef8c9f537d85068ef5bbb9a575412a21fb" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;C&lt;/code&gt; is the same as before, but for &lt;code&gt;D&lt;/code&gt;, the &lt;code&gt;__new__&lt;/code&gt; method returns an instance of class &lt;code&gt;C&lt;/code&gt; rather than &lt;code&gt;D&lt;/code&gt;. Note that the &lt;code&gt;__init__&lt;/code&gt; method of &lt;code&gt;D&lt;/code&gt; does not get called. In general, when the &lt;code&gt;__new__&lt;/code&gt; method returns an object of class other than the class in which it is defined, the &lt;code&gt;__init__&lt;/code&gt; method of that class is not called.</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; の定義は以前と同じですが、 &lt;code&gt;D&lt;/code&gt; の場合、 &lt;code&gt;__new__&lt;/code&gt; メソッドは &lt;code&gt;D&lt;/code&gt; ではなくクラス &lt;code&gt;C&lt;/code&gt; のインスタンスを返します。 &lt;code&gt;D&lt;/code&gt; の &lt;code&gt;__init__&lt;/code&gt; メソッドは呼び出されないことに注意してください。一般に、 &lt;code&gt;__new__&lt;/code&gt; メソッドが、それが定義されているクラス以外のクラスのオブジェクトを返す場合、そのクラスの &lt;code&gt;__init__&lt;/code&gt; メソッドは呼び出されません。</target>
        </trans-unit>
        <trans-unit id="a1b5640a64fc73d8755c0223b335feaa121479d8" translate="yes" xml:space="preserve">
          <source>The definition of advanced indexing means that &lt;code&gt;x[(1,2,3),]&lt;/code&gt; is fundamentally different than &lt;code&gt;x[(1,2,3)]&lt;/code&gt;. The latter is equivalent to &lt;code&gt;x[1,2,3]&lt;/code&gt; which will trigger basic selection while the former will trigger advanced indexing. Be sure to understand why this occurs.</source>
          <target state="translated">高度割り出し手段の定義は、その &lt;code&gt;x[(1,2,3),]&lt;/code&gt; は基本的に異なる &lt;code&gt;x[(1,2,3)]&lt;/code&gt; 。後者は &lt;code&gt;x[1,2,3]&lt;/code&gt; と同等で、基本的な選択をトリガーしますが、前者は高度なインデックス作成をトリガーします。これが発生する理由を必ず理解してください。</target>
        </trans-unit>
        <trans-unit id="61496dee2f3816bd693a7ce0398282c8ea47a960" translate="yes" xml:space="preserve">
          <source>The definition of correlation above is not unique and sometimes correlation may be defined differently. Another common definition is:</source>
          <target state="translated">上記の相関関係の定義は一意ではなく、場合によっては異なる定義になることもあります。もう一つの一般的な定義は</target>
        </trans-unit>
        <trans-unit id="938e670c022b166026c1f3d97b60b6e6eed3f831" translate="yes" xml:space="preserve">
          <source>The definition of the &lt;code&gt;&amp;lt;argument/variable type declaration&amp;gt;&lt;/code&gt; part is</source>
          <target state="translated">&lt;code&gt;&amp;lt;argument/variable type declaration&amp;gt;&lt;/code&gt; 部分の定義は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="f1f4801e8c8f57fdee23b9a4f5485bae04f50607" translate="yes" xml:space="preserve">
          <source>The definition of the &lt;code&gt;&amp;lt;common block statement&amp;gt;&lt;/code&gt; part is</source>
          <target state="translated">&lt;code&gt;&amp;lt;common block statement&amp;gt;&lt;/code&gt; 部分の定義は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d5ed0cf6ae14e241898a603f2c9052eee0f3ff8c" translate="yes" xml:space="preserve">
          <source>The definition of the &lt;code&gt;&amp;lt;use statement&amp;gt;&lt;/code&gt; part is</source>
          <target state="translated">&lt;code&gt;&amp;lt;use statement&amp;gt;&lt;/code&gt; 部分の定義は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e5f33fe407bab51cea8bacccfd88b8a5036810dc" translate="yes" xml:space="preserve">
          <source>The degree of the series.</source>
          <target state="translated">シリーズの度合。</target>
        </trans-unit>
        <trans-unit id="155faa0de8c44a325761ca30fe7a5e7dbf74e6e4" translate="yes" xml:space="preserve">
          <source>The depends list contains paths to files or directories that the sources of the extension module depend on. If any path in the depends list is newer than the extension module, then the module will be rebuilt.</source>
          <target state="translated">依存リストには、拡張モジュールのソースが依存している ファイルやディレクトリへのパスが含まれています。もし depends リストのパスが拡張モジュールよりも新しいものであれば、 モジュールは再構築されます。</target>
        </trans-unit>
        <trans-unit id="8add200746bc778285c2910a22d91b2b8b258c85" translate="yes" xml:space="preserve">
          <source>The deprecated function.</source>
          <target state="translated">非推奨の機能です。</target>
        </trans-unit>
        <trans-unit id="63644093036e4f3b360649808afd2f026edeffe7" translate="yes" xml:space="preserve">
          <source>The derivation of the t-distribution was first published in 1908 by William Gosset while working for the Guinness Brewery in Dublin. Due to proprietary issues, he had to publish under a pseudonym, and so he used the name Student.</source>
          <target state="translated">t分布の派生は、ダブリンのギネス醸造所で働いていたウィリアム・ゴセットが1908年に初めて発表しました。プロプライエタリな問題のため、彼は偽名で出版しなければならなかったので、スチューデントという名前を使いました。</target>
        </trans-unit>
        <trans-unit id="7db2e5319fb072c88d575bc92b04bca324abdb47" translate="yes" xml:space="preserve">
          <source>The derivative of the polynomial</source>
          <target state="translated">多項式の微分</target>
        </trans-unit>
        <trans-unit id="e38da7322eec5dfeb19db7a40e7e799054f3e9fa" translate="yes" xml:space="preserve">
          <source>The desc member of the PyCObject returned from __array_struct__ was not specified. Usually, it was the object exposing the array (so that a reference to it could be kept and destroyed when the C-object was destroyed). Now it must be a tuple whose first element is a string with &amp;ldquo;PyArrayInterface Version #&amp;rdquo; and whose second element is the object exposing the array.</source>
          <target state="translated">__array_struct__から返されたPyCObjectのdescメンバーが指定されていません。通常、これは配列を公開するオブジェクトでした（Cオブジェクトが破棄されたときに、その参照を保持および破棄できるようにするため）。これは、最初の要素が「PyArrayInterface Version＃」の文字列で、2番目の要素が配列を公開するオブジェクトであるタプルである必要があります。</target>
        </trans-unit>
        <trans-unit id="d7dbcb2541cf001d7b26e25e4170575fd900c8ee" translate="yes" xml:space="preserve">
          <source>The description of the fourth element of the header therefore has become: &amp;ldquo;The next 4 bytes form a little-endian unsigned int: the length of the header data HEADER_LEN.&amp;rdquo;</source>
          <target state="translated">したがって、ヘッダーの4番目の要素の説明は次のようになっています。</target>
        </trans-unit>
        <trans-unit id="877e58bc0c85ccf0ef190f149115500e0d385da1" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array The default, None, means</source>
          <target state="translated">配列に必要なデータ型を指定します デフォルトの None は</target>
        </trans-unit>
        <trans-unit id="f4a52cabb32fca3b74ad0388e9c1cbe1cf8d25b1" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array, e.g., &lt;code&gt;numpy.int8&lt;/code&gt;. Default is &lt;code&gt;numpy.float64&lt;/code&gt;.</source>
          <target state="translated">配列に必要なデータ型（例： &lt;code&gt;numpy.int8&lt;/code&gt; )。デフォルトは &lt;code&gt;numpy.float64&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a0a8a7651b0b383e3707246aaf8cd38e2e169098" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array. If not given, then the type will be determined as the minimum type required to hold the objects in the sequence.</source>
          <target state="translated">配列に必要なデータ型.与えられなかった場合は、シーケンス内のオブジェクトを保持するために必要な最小の型として決定されます。</target>
        </trans-unit>
        <trans-unit id="f7534f7cefc524ae1e988328a3c98ad10f344592" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array. If not given, then the type will be determined as the minimum type required to hold the objects in the sequence. This argument can only be used to &amp;lsquo;upcast&amp;rsquo; the array. For downcasting, use the .astype(t) method.</source>
          <target state="translated">配列に必要なデータ型。指定しない場合、タイプは、シーケンス内のオブジェクトを保持するために必要な最小タイプとして決定されます。この引数は、配列を「アップキャスト」するためにのみ使用できます。ダウンキャストには、.astype（t）メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="50dd3f94578e7376ef4b1fc5b09b342ebb1fed2e" translate="yes" xml:space="preserve">
          <source>The desired data-type for the matrix, default is float.</source>
          <target state="translated">デフォルトは float です.</target>
        </trans-unit>
        <trans-unit id="07d678da86d17478a0143d6947f08f3fa51a5f65" translate="yes" xml:space="preserve">
          <source>The desired data-type for the matrix, default is np.float64.</source>
          <target state="translated">デフォルトは np.float64 です.</target>
        </trans-unit>
        <trans-unit id="d07509f4b4964e751a91c8805000083d2ee4926c" translate="yes" xml:space="preserve">
          <source>The desired data-type. By default, the data-type is determined from &lt;code&gt;formats&lt;/code&gt;, &lt;code&gt;names&lt;/code&gt;, &lt;code&gt;titles&lt;/code&gt;, &lt;code&gt;aligned&lt;/code&gt; and &lt;code&gt;byteorder&lt;/code&gt;.</source>
          <target state="translated">目的のデータ型。デフォルトでは、データ型は、 &lt;code&gt;formats&lt;/code&gt; 、 &lt;code&gt;names&lt;/code&gt; 、 &lt;code&gt;titles&lt;/code&gt; 、 &lt;code&gt;byteorder&lt;/code&gt; &lt;code&gt;aligned&lt;/code&gt; 、バイトオーダーから決定されます。</target>
        </trans-unit>
        <trans-unit id="3c998f357ef80cf65beb1c4220aff1c69081dd53" translate="yes" xml:space="preserve">
          <source>The desired shape of the array. If &lt;code&gt;mode == 'r'&lt;/code&gt; and the number of remaining bytes after &lt;code&gt;offset&lt;/code&gt; is not a multiple of the byte-size of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, you must specify &lt;a href=&quot;numpy.memmap.shape#numpy.memmap.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. By default, the returned array will be 1-D with the number of elements determined by file size and data-type.</source>
          <target state="translated">アレイの目的の形状。場合 &lt;code&gt;mode == 'r'&lt;/code&gt; と後の残りのバイト数 &lt;code&gt;offset&lt;/code&gt; バイトサイズの倍数でない&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; は&lt;/a&gt;、次のように指定しなければならない&lt;a href=&quot;numpy.memmap.shape#numpy.memmap.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;。デフォルトでは、返される配列は1次元で、要素の数はファイルサイズとデータ型によって決まります。</target>
        </trans-unit>
        <trans-unit id="c217d27d3179585b289f1730298cd76c28917559" translate="yes" xml:space="preserve">
          <source>The desired shape of the array. If &lt;code&gt;mode == 'r'&lt;/code&gt; and the number of remaining bytes after &lt;code&gt;offset&lt;/code&gt; is not a multiple of the byte-size of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, you must specify &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. By default, the returned array will be 1-D with the number of elements determined by file size and data-type.</source>
          <target state="translated">アレイの望ましい形状。場合 &lt;code&gt;mode == 'r'&lt;/code&gt; と後の残りのバイト数 &lt;code&gt;offset&lt;/code&gt; バイトサイズの倍数でない&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; は&lt;/a&gt;、次のように指定しなければならない&lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;。デフォルトでは、返される配列は1次元であり、要素の数はファイルサイズとデータ型によって決定されます。</target>
        </trans-unit>
        <trans-unit id="cdd86af715375b55e1d483d875bf1753af5d922f" translate="yes" xml:space="preserve">
          <source>The desired shape of the iterator. This allows &lt;code&gt;allocate&lt;/code&gt; operands with a dimension mapped by op_axes not corresponding to a dimension of a different operand to get a value not equal to 1 for that dimension.</source>
          <target state="translated">イテレータの目的の形状。これにより、異なるオペランドの次元に対応しないop_axesによってマップされた次元を持つオペランドを &lt;code&gt;allocate&lt;/code&gt; て、その次元に対して1以外の値を取得できます。</target>
        </trans-unit>
        <trans-unit id="84971317bba10bc74f9aaf650dccf1acca028d13" translate="yes" xml:space="preserve">
          <source>The desired, expected object.</source>
          <target state="translated">目的とする、期待されるオブジェクト。</target>
        </trans-unit>
        <trans-unit id="40c65673e654df212bffc77b7c4cf508b802ea94" translate="yes" xml:space="preserve">
          <source>The determinant is computed via LU factorization using the LAPACK routine &lt;code&gt;z/dgetrf&lt;/code&gt;.</source>
          <target state="translated">行列式は、LAPACKルーチン &lt;code&gt;z/dgetrf&lt;/code&gt; を使用したLU分解によって計算されます。</target>
        </trans-unit>
        <trans-unit id="94f9591a378d3f5d467509648f89e89bcee5af83" translate="yes" xml:space="preserve">
          <source>The determinant of a 2-D array &lt;code&gt;[[a, b], [c, d]]&lt;/code&gt; is &lt;code&gt;ad - bc&lt;/code&gt;:</source>
          <target state="translated">2次元配列 &lt;code&gt;[[a, b], [c, d]]&lt;/code&gt; の行列式は &lt;code&gt;ad - bc&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="67af8ebad34e1dbafff04ba3dd64dccd7934523b" translate="yes" xml:space="preserve">
          <source>The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:</source>
          <target state="translated">2次元配列[[a,b],[c,d]]の行列式はad-bcである.</target>
        </trans-unit>
        <trans-unit id="e56bde2e38a2da31d0e2d0f24b802753579a52ca" translate="yes" xml:space="preserve">
          <source>The determinant of a square Vandermonde matrix is the product of the differences between the values of the input vector:</source>
          <target state="translated">正方形のヴァンデルモンデ行列の行列式は、入力ベクトルの値の差の積である。</target>
        </trans-unit>
        <trans-unit id="60279460274321ba74cf96556a38bac9a87c73c6" translate="yes" xml:space="preserve">
          <source>The diagonal and diag functions return readonly views.</source>
          <target state="translated">対角線と対角線関数は、読み取り専用のビューを返します。</target>
        </trans-unit>
        <trans-unit id="34c13c034ad3086185d61530fb01b7940b4e4527" translate="yes" xml:space="preserve">
          <source>The dictionary contains three keys:</source>
          <target state="translated">辞書には3つのキーが含まれています。</target>
        </trans-unit>
        <trans-unit id="7980c83ed9b10778dab7b594015b0c4b8c1b820c" translate="yes" xml:space="preserve">
          <source>The dictionary has two required keys, &amp;lsquo;names&amp;rsquo; and &amp;lsquo;formats&amp;rsquo;, and four optional keys, &amp;lsquo;offsets&amp;rsquo;, &amp;lsquo;itemsize&amp;rsquo;, &amp;lsquo;aligned&amp;rsquo; and &amp;lsquo;titles&amp;rsquo;. The values for &amp;lsquo;names&amp;rsquo; and &amp;lsquo;formats&amp;rsquo; should respectively be a list of field names and a list of dtype specifications, of the same length. The optional &amp;lsquo;offsets&amp;rsquo; value should be a list of integer byte-offsets, one for each field within the structure. If &amp;lsquo;offsets&amp;rsquo; is not given the offsets are determined automatically. The optional &amp;lsquo;itemsize&amp;rsquo; value should be an integer describing the total size in bytes of the dtype, which must be large enough to contain all the fields.</source>
          <target state="translated">辞書には、「names」と「formats」の2つの必須キーと、「offsets」、「itemsize」、「aligned」、「titles」の4つのオプションのキーがあります。'names'と 'formats'の値は、それぞれ同じ長さのフィールド名のリストとdtype仕様のリストである必要があります。オプションの「オフセット」値は、構造内の各フィールドに1つずつ、整数バイトオフセットのリストである必要があります。'offsets'が指定されていない場合、オフセットは自動的に決定されます。オプションの「itemsize」値は、dtypeの合計サイズをバイト単位で表す整数である必要があります。これは、すべてのフィールドを含むのに十分な大きさである必要があります。</target>
        </trans-unit>
        <trans-unit id="bd944e951e9799c3343f288ae6c347a06ac11e23" translate="yes" xml:space="preserve">
          <source>The dictionary is indexed by keys that are the names of the fields. Each entry in the dictionary is a tuple fully describing the field:</source>
          <target state="translated">辞書は、フィールドの名前であるキーによってインデックス化されます。辞書の各エントリは、フィールドを完全に記述したタプルです。</target>
        </trans-unit>
        <trans-unit id="fc72cbc84ea7846d80156db81f03031e6342d2d0" translate="yes" xml:space="preserve">
          <source>The dictionary with build information.</source>
          <target state="translated">ビルド情報のある辞書。</target>
        </trans-unit>
        <trans-unit id="88918f47eb3cf48e5a0737e099c91aa35bc38894" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the next smallest representable float larger than 1.0. For example, for 64-bit binary floats in the IEEE-754 standard, &lt;code&gt;eps = 2**-52&lt;/code&gt;, approximately 2.22e-16.</source>
          <target state="translated">1.0と、1.0より大きい次に小さい表現可能なフロートとの差。たとえば、IEEE-754標準の64ビットバイナリフロートの場合、 &lt;code&gt;eps = 2**-52&lt;/code&gt; 、約2.22e-16です。</target>
        </trans-unit>
        <trans-unit id="c1d6f22ac980a152a56489087bf48f813ef3afe4" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the next smallest representable float less than 1.0. For example, for 64-bit binary floats in the IEEE-754 standard, &lt;code&gt;epsneg = 2**-53&lt;/code&gt;, approximately 1.11e-16.</source>
          <target state="translated">1.0と1.0未満の次に小さい表現可能なフロートとの差。たとえば、IEEE-754標準の64ビットバイナリフロートの場合、 &lt;code&gt;epsneg = 2**-53&lt;/code&gt; 、約1.11e-16です。</target>
        </trans-unit>
        <trans-unit id="162f606f6e0310c46fbb8198beb3cd00b92c6224" translate="yes" xml:space="preserve">
          <source>The difference of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">要素ごとの &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の違い。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="07942ea7f660d79ad7e6e73de1169306977fb28a" translate="yes" xml:space="preserve">
          <source>The differences between consecutive elements of an array.</source>
          <target state="translated">配列の連続した要素間の差。</target>
        </trans-unit>
        <trans-unit id="f62761da3d9dc37e999ceb43677343bc26056903" translate="yes" xml:space="preserve">
          <source>The differences. Loosely, this is &lt;code&gt;ary.flat[1:] - ary.flat[:-1]&lt;/code&gt;.</source>
          <target state="translated">違い。大まかに言うと、これは &lt;code&gt;ary.flat[1:] - ary.flat[:-1]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e2f3cc77955898f687e1a89336e253a34038e978" translate="yes" xml:space="preserve">
          <source>The different types of interpolation can be visualized graphically:</source>
          <target state="translated">補間の種類の違いをグラフィカルに可視化することができます。</target>
        </trans-unit>
        <trans-unit id="0f5b79f9447070c03232c2c0b7664e2645b9b9cd" translate="yes" xml:space="preserve">
          <source>The dimension over which bit-packing is done. &lt;code&gt;None&lt;/code&gt; implies packing the flattened array.</source>
          <target state="translated">ビットパッキングが行われる次元。 &lt;code&gt;None&lt;/code&gt; 、フラット化された配列をパックすることを意味しません。</target>
        </trans-unit>
        <trans-unit id="dfa565d5af13bd83cac275f338d5f2b3b4b7544c" translate="yes" xml:space="preserve">
          <source>The dimension over which bit-unpacking is done. &lt;code&gt;None&lt;/code&gt; implies unpacking the flattened array.</source>
          <target state="translated">ビットアンパッキングが行われる次元。 &lt;code&gt;None&lt;/code&gt; は、フラット化された配列をアンパックすることを意味します。</target>
        </trans-unit>
        <trans-unit id="db3013243a57c5e7a96cffb61f2f631ca09ac6ac" translate="yes" xml:space="preserve">
          <source>The dimensionality of each input/output of an elementary function is defined by its core dimensions (zero core dimensions correspond to a scalar input/output). The core dimensions are mapped to the last dimensions of the input/output arrays.</source>
          <target state="translated">初等関数の各入出力の次元性は,そのコア次元によって定義される(コア次元がゼロの場合はスカラー入出力に対応する).コア次元は,入出力配列の最後の次元にマップされます.</target>
        </trans-unit>
        <trans-unit id="bbd2ce0767215831bee7913f7b1f8113fac9632a" translate="yes" xml:space="preserve">
          <source>The dimensionality of the output is equal to the greatest of: * the dimensionality of all the inputs * the depth to which the input list is nested</source>
          <target state="translated">出力の次元は,以下のうち最大のものに等しい.*すべての入力の次元性*入力リストが入れ子にされる深さ</target>
        </trans-unit>
        <trans-unit id="169b189aee12891e66fa6116bc6ee28490426b80" translate="yes" xml:space="preserve">
          <source>The dimensions beyond the core dimensions are called &amp;ldquo;loop&amp;rdquo; dimensions. In the above example, this corresponds to &lt;code&gt;(3, 5)&lt;/code&gt;.</source>
          <target state="translated">コア寸法を超える寸法は、「ループ」寸法と呼ばれます。上記の例では、これは &lt;code&gt;(3, 5)&lt;/code&gt; 対応します。</target>
        </trans-unit>
        <trans-unit id="f513b3b85fff0b6f84da786029bafd05ba0e618b" translate="yes" xml:space="preserve">
          <source>The dimensions of the iterator.</source>
          <target state="translated">イテレータの寸法。</target>
        </trans-unit>
        <trans-unit id="5ecf20054a40c0975aa34c7a074c143c2ad5eb76" translate="yes" xml:space="preserve">
          <source>The dimensions of the returned array, must be non-negative. If no argument is given a single Python float is returned.</source>
          <target state="translated">返される配列の次元は、非負でなければなりません。引数が与えられなかった場合は、単一の Python float が返されます。</target>
        </trans-unit>
        <trans-unit id="1962b62fe3553b6c10eaad6d82d38bd0027b1eca" translate="yes" xml:space="preserve">
          <source>The direction where to look for the next representable value of &lt;code&gt;x1&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; の次の表現可能な値を探す方向。 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状にブロードキャスト可能でなければなりません（これが出力の形状になります）。</target>
        </trans-unit>
        <trans-unit id="712dcab95da2336dfeef7d45bac02b258dccf977" translate="yes" xml:space="preserve">
          <source>The discount rate.</source>
          <target state="translated">割引率です。</target>
        </trans-unit>
        <trans-unit id="0706686baa5fd5b913d978e6a5e5bd325098b037" translate="yes" xml:space="preserve">
          <source>The discrete convolution operation is defined as</source>
          <target state="translated">離散畳み込み演算は次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="0c3ebfde94166d29a8529279eac1b981ebfd74c7" translate="yes" xml:space="preserve">
          <source>The distance between a value and the nearest adjacent number</source>
          <target state="translated">値と最も近い隣接する数との間の距離</target>
        </trans-unit>
        <trans-unit id="eb9069c190fd0543a41e23dc5a8c21be130414b2" translate="yes" xml:space="preserve">
          <source>The docstring consists of a number of sections separated by headings (except for the deprecation warning). Each heading should be underlined in hyphens, and the section ordering should be consistent with the description below.</source>
          <target state="translated">docstringは、見出しで区切られたいくつかのセクションから構成されています(非推奨の警告を除く)。各見出しにはハイフンで下線を引き、セクションの順序は以下の説明と一致していなければなりません。</target>
        </trans-unit>
        <trans-unit id="12a1ae320e29367bfe14ad50414fe949007c38e7" translate="yes" xml:space="preserve">
          <source>The docstring for the function. If &lt;code&gt;None&lt;/code&gt;, the docstring will be the &lt;code&gt;pyfunc.__doc__&lt;/code&gt;.</source>
          <target state="translated">関数のドキュメント文字列。場合 &lt;code&gt;None&lt;/code&gt; 、ドキュメンテーション文字列になります &lt;code&gt;pyfunc.__doc__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f20cb6df02e7c9d27955f240a3eb4c2a8d28a69" translate="yes" xml:space="preserve">
          <source>The docstring for the function. If None, the docstring will be the &lt;code&gt;pyfunc.__doc__&lt;/code&gt;.</source>
          <target state="translated">関数のdocstring。Noneの場合、docstringは &lt;code&gt;pyfunc.__doc__&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="72a23a7f9d3c84d9ccb7d9d4e76905cf07195965" translate="yes" xml:space="preserve">
          <source>The docstring is taken from the input function to &lt;a href=&quot;#numpy.vectorize&quot;&gt;&lt;code&gt;vectorize&lt;/code&gt;&lt;/a&gt; unless it is specified:</source>
          <target state="translated">docstringは、指定されていない限り、&lt;a href=&quot;#numpy.vectorize&quot;&gt; &lt;code&gt;vectorize&lt;/code&gt; &lt;/a&gt;するために入力関数から取得されます。</target>
        </trans-unit>
        <trans-unit id="82bd10e4e262158659ec5e27575297c3e33fb51b" translate="yes" xml:space="preserve">
          <source>The doctests are run as if they are in a fresh Python instance which has executed &lt;code&gt;import numpy as np&lt;/code&gt;. Tests that are part of a SciPy subpackage will have that subpackage already imported. E.g. for a test in &lt;code&gt;scipy/linalg/tests/&lt;/code&gt;, the namespace will be created such that &lt;code&gt;from scipy import linalg&lt;/code&gt; has already executed.</source>
          <target state="translated">doctestは、 &lt;code&gt;import numpy as np&lt;/code&gt; 実行した新しいPythonインスタンス内にあるかのように実行されます。SciPyサブパッケージの一部であるテストには、そのサブパッケージがすでにインポートされています。たとえば、 &lt;code&gt;scipy/linalg/tests/&lt;/code&gt; 場合、 &lt;code&gt;from scipy import linalg&lt;/code&gt; がすでに実行されるように名前空間が作成されます。</target>
        </trans-unit>
        <trans-unit id="4e34de0083248d68455464ce3b6cb6cff4a615e4" translate="yes" xml:space="preserve">
          <source>The doctests can be run by adding the &lt;code&gt;doctests&lt;/code&gt; argument to the &lt;code&gt;test()&lt;/code&gt; call; for example, to run all tests (including doctests) for numpy.lib:</source>
          <target state="translated">doctestは、 &lt;code&gt;test()&lt;/code&gt; 呼び出しに &lt;code&gt;doctests&lt;/code&gt; 引数を追加することで実行できます。たとえば、numpy.libのすべてのテスト（doctestを含む）を実行するには：</target>
        </trans-unit>
        <trans-unit id="914dd900bd888e0ac2a856c709956c6c77b685df" translate="yes" xml:space="preserve">
          <source>The doctests can be run by the user/developer by adding the &lt;code&gt;doctests&lt;/code&gt; argument to the &lt;code&gt;test()&lt;/code&gt; call. For example, to run all tests (including doctests) for &lt;code&gt;numpy.lib&lt;/code&gt;:</source>
          <target state="translated">doctestは、 &lt;code&gt;test()&lt;/code&gt; 呼び出しに &lt;code&gt;doctests&lt;/code&gt; 引数を追加することにより、ユーザー/開発者が実行できます。たとえば、 &lt;code&gt;numpy.lib&lt;/code&gt; のすべてのテスト（doctestを含む）を実行するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="f8aa7b1eda9c3eb10663105fc5334308467be1f5" translate="yes" xml:space="preserve">
          <source>The documentation for NumPy distributed at &lt;a href=&quot;https://numpy.org/doc&quot;&gt;https://numpy.org/doc&lt;/a&gt; in html and pdf format is also built with &lt;code&gt;make dist&lt;/code&gt;. See &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/doc/HOWTO_RELEASE.rst.txt&quot;&gt;HOWTO RELEASE&lt;/a&gt; for details on how to update &lt;a href=&quot;https://numpy.org/doc&quot;&gt;https://numpy.org/doc&lt;/a&gt;.</source>
          <target state="translated">numpyのためのドキュメントはで配布&lt;a href=&quot;https://numpy.org/doc&quot;&gt;https://numpy.org/doc&lt;/a&gt; HTMLにPDF形式もで構築された &lt;code&gt;make dist&lt;/code&gt; 。参照&lt;a href=&quot;https://github.com/numpy/numpy/blob/master/doc/HOWTO_RELEASE.rst.txt&quot;&gt;HOWTO RELEASE&lt;/a&gt;更新する方法の詳細については&lt;a href=&quot;https://numpy.org/doc&quot;&gt;https://numpy.org/docを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5b422de92d847bc36480d44f7ae27cfbb5060f6f" translate="yes" xml:space="preserve">
          <source>The documentation includes mathematical formulae with LaTeX formatting. A working LaTeX document production system (e.g. &lt;a href=&quot;https://www.tug.org/texlive/&quot;&gt;texlive&lt;/a&gt;) is required for the proper rendering of the LaTeX math in the documentation.</source>
          <target state="translated">ドキュメントには、LaTeXフォーマットの数式が含まれています。ドキュメント内のLaTeX数学を適切にレンダリングするには、動作するLaTeXドキュメント作成システム（&lt;a href=&quot;https://www.tug.org/texlive/&quot;&gt;texliveなど&lt;/a&gt;）が必要です。</target>
        </trans-unit>
        <trans-unit id="400ca1ed6dc999bcaec7408745f9b97e9991d699" translate="yes" xml:space="preserve">
          <source>The documentation is written in restructuredText, which is the format required by Sphinx, the tool most Python projects use to automatically build and link the documentation within the project. You can read the &lt;a href=&quot;https://docutils.sourceforge.io/docs/user/rst/quickref.html&quot;&gt;Quick reStructuredText Guide&lt;/a&gt; or the &lt;a href=&quot;http://www.sphinx-doc.org/en/stable/usage/restructuredtext/basics.html&quot;&gt;reStructuredText Primer&lt;/a&gt; for more information.</source>
          <target state="translated">ドキュメントはrestructuredTextで記述されています。これは、ほとんどのPythonプロジェクトがプロジェクト内のドキュメントを自動的にビルドしてリンクするために使用するツールであるSphinxに必要な形式です。詳細については、&lt;a href=&quot;https://docutils.sourceforge.io/docs/user/rst/quickref.html&quot;&gt;クイックreStructuredTextガイド&lt;/a&gt;または&lt;a href=&quot;http://www.sphinx-doc.org/en/stable/usage/restructuredtext/basics.html&quot;&gt;reStructuredText入門書&lt;/a&gt;をお読みください。</target>
        </trans-unit>
        <trans-unit id="b01857d163ce7be746891e6a1ddb4df8d280228b" translate="yes" xml:space="preserve">
          <source>The domain of the converted series. If the value is None, the default domain of &lt;code&gt;kind&lt;/code&gt; is used.</source>
          <target state="translated">変換されたシリーズのドメイン。値がNoneの場合、デフォルトの &lt;code&gt;kind&lt;/code&gt; ドメインが使用されます。</target>
        </trans-unit>
        <trans-unit id="3910d27792e65700eaf0cb459a12293f622c5605" translate="yes" xml:space="preserve">
          <source>The drawn samples, of shape (size, alpha.ndim).</source>
          <target state="translated">描画されたサンプルの形状(size,alpha.ndim)。</target>
        </trans-unit>
        <trans-unit id="3a196841b4dbf99e3d83d366571811ca5768d106" translate="yes" xml:space="preserve">
          <source>The drawn samples, of shape &lt;code&gt;(size, k)&lt;/code&gt;.</source>
          <target state="translated">形状 &lt;code&gt;(size, k)&lt;/code&gt; の描画されたサンプル。</target>
        </trans-unit>
        <trans-unit id="caba47af25cacb65ea654dc8b3910b7df6c6afc4" translate="yes" xml:space="preserve">
          <source>The drawn samples, of shape &lt;em&gt;size&lt;/em&gt;, if that was provided. If not, the shape is &lt;code&gt;(N,)&lt;/code&gt;.</source>
          <target state="translated">提供されている場合、形状&lt;em&gt;サイズ&lt;/em&gt;の描画されたサンプル。そうでない場合、形状は &lt;code&gt;(N,)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="40b0e929b6fe8b38b46b38ce838182fe7c7332dc" translate="yes" xml:space="preserve">
          <source>The drawn samples.</source>
          <target state="translated">描かれたサンプル。</target>
        </trans-unit>
        <trans-unit id="7c49825e402bb2a6069cc023cee23e3ad1ab0d7c" translate="yes" xml:space="preserve">
          <source>The dtype object also has a dictionary-like attribute, &lt;code&gt;fields&lt;/code&gt;, whose keys are the field names (and &lt;a href=&quot;#titles&quot;&gt;Field Titles&lt;/a&gt;, see below) and whose values are tuples containing the dtype and byte offset of each field.</source>
          <target state="translated">dtypeオブジェクトには、辞書のような属性 &lt;code&gt;fields&lt;/code&gt; もあります。この属性のキーはフィールド名（および&lt;a href=&quot;#titles&quot;&gt;フィールドタイトル&lt;/a&gt;、以下を参照）であり、値は各フィールドのdtypeとバイトオフセットを含むタプルです。</target>
        </trans-unit>
        <trans-unit id="aa44e17b8461776ae7df4f43d6abddd8f6a24f76" translate="yes" xml:space="preserve">
          <source>The dtype object, which must be a &lt;code&gt;datetime64&lt;/code&gt; or &lt;code&gt;timedelta64&lt;/code&gt; type.</source>
          <target state="translated">でなければならないDTYPEオブジェクト、 &lt;code&gt;datetime64&lt;/code&gt; 又は &lt;code&gt;timedelta64&lt;/code&gt; タイプ。</target>
        </trans-unit>
        <trans-unit id="8fb6faafe66ffccb238a2fd43e44c5a7f5fbd5ca" translate="yes" xml:space="preserve">
          <source>The dtype of the masked array matches the dtype of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">マスクされた配列のdtypeは、 &lt;code&gt;arr&lt;/code&gt; のdtypeと一致します。</target>
        </trans-unit>
        <trans-unit id="1cb33880062e286521366b55fc98dd4daef4b644" translate="yes" xml:space="preserve">
          <source>The dtype of the output unstructured array.</source>
          <target state="translated">出力される非構造化配列のdtype。</target>
        </trans-unit>
        <trans-unit id="a55d71e165e1e48cb124a8472e43c4880e17aca7" translate="yes" xml:space="preserve">
          <source>The dtype to convert</source>
          <target state="translated">変換する dtype</target>
        </trans-unit>
        <trans-unit id="5ecd0c1cb739e638a2efc7fc65026ccc752fcf9a" translate="yes" xml:space="preserve">
          <source>The dtype to convert.</source>
          <target state="translated">変換するdtype。</target>
        </trans-unit>
        <trans-unit id="0d0946ed17f6fb426bc55c84df183c8474945340" translate="yes" xml:space="preserve">
          <source>The dummy argument is not used in this context and can be safely ignored. The &lt;em&gt;args&lt;/em&gt; argument contains all of the arguments passed in to the function as a tuple. You can do anything you want at this point, but usually the easiest way to manage the input arguments is to call &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; (args, format_string, addresses_to_C_variables&amp;hellip;) or &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_UnpackTuple&quot;&gt;&lt;code&gt;PyArg_UnpackTuple&lt;/code&gt;&lt;/a&gt; (tuple, &amp;ldquo;name&amp;rdquo;, min, max, &amp;hellip;). A good description of how to use the first function is contained in the Python C-API reference manual under section 5.5 (Parsing arguments and building values). You should pay particular attention to the &amp;ldquo;O&amp;amp;&amp;rdquo; format which uses converter functions to go between the Python object and the C object. All of the other format functions can be (mostly) thought of as special cases of this general rule. There are several converter functions defined in the NumPy C-API that may be of use. In particular, the &lt;a href=&quot;../reference/c-api/array#c.PyArray_DescrConverter&quot;&gt;&lt;code&gt;PyArray_DescrConverter&lt;/code&gt;&lt;/a&gt; function is very useful to support arbitrary data-type specification. This function transforms any valid data-type Python object into a &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; object. Remember to pass in the address of the C-variables that should be filled in.</source>
          <target state="translated">ダミー引数はこのコンテキストでは使用されないため、無視しても問題ありません。&lt;em&gt;引数の&lt;/em&gt;引数はタプルとして関数に渡される引数のすべてが含まれています。この時点で何でもできますが、通常、入力引数を管理する最も簡単な方法は、&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt;（args、format_string、addresses_to_C_variables&amp;hellip;）または&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_UnpackTuple&quot;&gt; &lt;code&gt;PyArg_UnpackTuple&lt;/code&gt; を呼び出すことです。&lt;/a&gt;（タプル、「名前」、最小、最大、&amp;hellip;）。最初の関数の使用方法の適切な説明は、セクション5.5（引数の解析と値の構築）のPythonC-APIリファレンスマニュアルに含まれています。 PythonオブジェクトとCオブジェクトの間を行き来するためにコンバーター関数を使用する「O＆」フォーマットに特に注意を払う必要があります。他のすべてのフォーマット関数は、（ほとんど）この一般的なルールの特殊なケースと考えることができます。 NumPy C-APIで定義されている、役立つ可能性のあるいくつかのコンバーター関数があります。特に、&lt;a href=&quot;../reference/c-api/array#c.PyArray_DescrConverter&quot;&gt; &lt;code&gt;PyArray_DescrConverter&lt;/code&gt; &lt;/a&gt;関数は、任意のデータ型の指定をサポートするのに非常に役立ちます。この関数は、有効なデータ型のPythonオブジェクトを&lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr *&lt;/code&gt; &lt;/a&gt;オブジェクトに変換します。入力する必要のあるC変数のアドレスを渡すことを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="dcd01c48a9de1d18adee046a1ef49445b20e2304" translate="yes" xml:space="preserve">
          <source>The ease of implementing mathematical formulas that work on arrays is one of the things that make NumPy so widely used in the scientific Python community.</source>
          <target state="translated">配列上で動作する数式の実装が容易であることは、NumPyが科学的なPythonコミュニティで広く使われている理由の一つです。</target>
        </trans-unit>
        <trans-unit id="0624587fa2f7d6454c0f9d5829dab19d01e4bd1b" translate="yes" xml:space="preserve">
          <source>The easiest way to understand the situation may be to think in terms of the result shape. There are two parts to the indexing operation, the subspace defined by the basic indexing (excluding integers) and the subspace from the advanced indexing part. Two cases of index combination need to be distinguished:</source>
          <target state="translated">一番わかりやすいのは、結果の形で考えることかもしれません。インデックス操作には2つの部分があり、基本的なインデックス付け(整数を除く)で定義された部分空間と、高度なインデックス付けの部分からの部分空間です。インデックスの組み合わせについては、2つのケースを区別する必要があります。</target>
        </trans-unit>
        <trans-unit id="f92b730683a3cb47168faa379ee22ac3235eed0f" translate="yes" xml:space="preserve">
          <source>The easy way to do conversions between polynomial basis sets is to use the convert method of a class instance.</source>
          <target state="translated">多項式基底集合間の変換を簡単に行う方法は、クラスインスタンスのconvertメソッドを使用することです。</target>
        </trans-unit>
        <trans-unit id="7ad876c221bb9757cd689d05f17e08510f826f3e" translate="yes" xml:space="preserve">
          <source>The edges retuned by &lt;code&gt;histogram`&lt;/code&gt; and &lt;code&gt;histogramdd&lt;/code&gt; now match the data float type</source>
          <target state="translated">&lt;code&gt;histogram`&lt;/code&gt; `と &lt;code&gt;histogramdd&lt;/code&gt; ddによって再調整されたエッジがデータフロートタイプと一致するようになりました</target>
        </trans-unit>
        <trans-unit id="2fc5d8b78173f52a2c49af3f59f052a25e59fb4f" translate="yes" xml:space="preserve">
          <source>The edges to pass into &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt;に渡すエッジ</target>
        </trans-unit>
        <trans-unit id="d2d8a6b76e19500caa5bf07c8a328b68c38bc616" translate="yes" xml:space="preserve">
          <source>The editing workflow</source>
          <target state="translated">編集作業の流れ</target>
        </trans-unit>
        <trans-unit id="b6f1be0a37063a8a4026cc94c7cf86f62cf5bdd8" translate="yes" xml:space="preserve">
          <source>The effect of broadcasting.</source>
          <target state="translated">放送の効果。</target>
        </trans-unit>
        <trans-unit id="a34abd23a6e4bdf2596a3b4673affad53721777d" translate="yes" xml:space="preserve">
          <source>The eigenvalues are computed using LAPACK routines &lt;code&gt;_syevd&lt;/code&gt;, &lt;code&gt;_heevd&lt;/code&gt;.</source>
          <target state="translated">固有値はLAPACKルーチン &lt;code&gt;_syevd&lt;/code&gt; 、 &lt;code&gt;_heevd&lt;/code&gt; を使用して計算されます。</target>
        </trans-unit>
        <trans-unit id="7701e5ef9799c4995d19bac48ad9fa82db4dc5c5" translate="yes" xml:space="preserve">
          <source>The eigenvalues in ascending order, each repeated according to its multiplicity.</source>
          <target state="translated">固有値を昇順に並べ、それぞれの多重度に応じて繰り返します。</target>
        </trans-unit>
        <trans-unit id="af42e28434cbe95fe6890df4d996c2c99e9b2481" translate="yes" xml:space="preserve">
          <source>The eigenvalues of real symmetric or complex Hermitian matrices are always real. &lt;a href=&quot;#rc702e98a756a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; The array &lt;code&gt;v&lt;/code&gt; of (column) eigenvectors is unitary and &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; satisfy the equations &lt;code&gt;dot(a, v[:, i]) = w[i] * v[:, i]&lt;/code&gt;.</source>
          <target state="translated">実対称または複素エルミート行列の固有値は常に実数です。&lt;a href=&quot;#rc702e98a756a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;（列）固有ベクトルの配列 &lt;code&gt;v&lt;/code&gt; はユニタリであり &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;w&lt;/code&gt; 、および &lt;code&gt;v&lt;/code&gt; は等式 &lt;code&gt;dot(a, v[:, i]) = w[i] * v[:, i]&lt;/code&gt; 満たします。</target>
        </trans-unit>
        <trans-unit id="2ff4d23698273b360b1d6366e444e95ea540f28f" translate="yes" xml:space="preserve">
          <source>The eigenvalues, each repeated according to its multiplicity. The eigenvalues are not necessarily ordered. The resulting array will be of complex type, unless the imaginary part is zero in which case it will be cast to a real type. When &lt;code&gt;a&lt;/code&gt; is real the resulting eigenvalues will be real (0 imaginary part) or occur in conjugate pairs</source>
          <target state="translated">それぞれがその多重度に従って繰り返される固有値。固有値は必ずしも順序付けられていません。結果の配列は複素数型になります。ただし、虚数部がゼロの場合は、実数型にキャストされます。 &lt;code&gt;a&lt;/code&gt; が実数の場合、結果の固有値は実数（0の虚数部）または共役ペアで発生します</target>
        </trans-unit>
        <trans-unit id="9cfc7ae7c9df4df4270a01f781a7985d0061b823" translate="yes" xml:space="preserve">
          <source>The eigenvalues, each repeated according to its multiplicity. They are not necessarily ordered, nor are they necessarily real for real matrices.</source>
          <target state="translated">固有値は,それぞれがその倍数に応じて繰り返される.固有値は必ずしも順序付けされているわけではなく,実数行列の場合は必ずしも実数ではありません.</target>
        </trans-unit>
        <trans-unit id="fedbdf07c41c58b01420971d15b808683a8a1612" translate="yes" xml:space="preserve">
          <source>The eigenvalues/eigenvectors are computed using LAPACK routines &lt;code&gt;_syevd&lt;/code&gt;, &lt;code&gt;_heevd&lt;/code&gt;.</source>
          <target state="translated">固有値/固有ベクトルは、LAPACKルーチン &lt;code&gt;_syevd&lt;/code&gt; 、 &lt;code&gt;_heevd&lt;/code&gt; を使用して計算されます。</target>
        </trans-unit>
        <trans-unit id="672eac8f0267740479f9ff389b02d40f57b3ff35" translate="yes" xml:space="preserve">
          <source>The element inserted in &lt;code&gt;output&lt;/code&gt; when all conditions evaluate to False.</source>
          <target state="translated">すべての条件がFalseと評価されたときに &lt;code&gt;output&lt;/code&gt; に挿入される要素。</target>
        </trans-unit>
        <trans-unit id="c154db2e01512028a28319b3317262699278c799" translate="yes" xml:space="preserve">
          <source>The element size of this data-type object.</source>
          <target state="translated">このデータ型オブジェクトの要素サイズ。</target>
        </trans-unit>
        <trans-unit id="100849a009dc981ce005b4c12bbdd30342f43ac6" translate="yes" xml:space="preserve">
          <source>The element-wise remainder of the quotient &lt;code&gt;floor_divide(x1, x2)&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">商 &lt;code&gt;floor_divide(x1, x2)&lt;/code&gt; の要素ごとの剰余。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="55f57b3f397334c809b04b980612f0a5ab349a62" translate="yes" xml:space="preserve">
          <source>The elements are binary-valued (0 or 1).</source>
          <target state="translated">要素は2値(0または1)です。</target>
        </trans-unit>
        <trans-unit id="4e3cc7c953fc2e3ea61645fad74045ef41161886" translate="yes" xml:space="preserve">
          <source>The elements in a NumPy array are all required to be of the same data type, and thus will be the same size in memory. The exception: one can have arrays of (Python, including NumPy) objects, thereby allowing for arrays of different sized elements.</source>
          <target state="translated">NumPyの配列の要素はすべて同じデータ型であることが要求され、メモリ上では同じサイズになります。例外:(Python、NumPyを含む)オブジェクトの配列を持つことができ、異なるサイズの要素の配列を作ることができます。</target>
        </trans-unit>
        <trans-unit id="18d658a71c2e23e5ce04fb215c6cdc657f3c41d2" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;a&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;m&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; の要素は、このインデックスの順序を使用して読み取られます。 「C」は、Cのような順序で要素にインデックスを付けることを意味し、最後の軸のインデックスが最も速く変化し、最初の軸のインデックスが最も遅く変化します。 「F」は、最初のインデックスが最も速く変化し、最後のインデックスが最も遅く変化するFortranのようなインデックスの順序で要素にインデックスを付けることを意味します。 'C'および 'F'オプションは、基になる配列のメモリレイアウトを考慮せず、軸のインデックスの順序のみを参照することに注意してください。 'A'は、 &lt;code&gt;m&lt;/code&gt; がメモリ内でFortranに&lt;em&gt;隣接&lt;/em&gt;している場合はFortranに似たインデックス順で、それ以外はCに似た順序で要素を読み取ることを意味します。 'K'は、ストライドが負の場合にデータを反転することを除いて、メモリ内で発生した順に要素を読み取ることを意味します。デフォルトでは、「C」インデックス順が使用されます。</target>
        </trans-unit>
        <trans-unit id="27ccf6e9acce055e532ad81d9bdd8638f9a4a262" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;a&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in row-major, C-style order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in column-major, Fortran-style order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;a&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; の要素は、このインデックスの順序を使用して読み取られます。「C」は、要素を行優先、Cスタイルの順序でインデックス付けすることを意味し、最後の軸のインデックスが最も速く変化し、最初の軸のインデックスが最も遅く変化します。'F'は、最初のインデックスが最も速く変化し、最後のインデックスが最も遅く変化する、列優先のFortranスタイルの順序で要素にインデックスを付けることを意味します。'C'および 'F'オプションは、基になる配列のメモリレイアウトを考慮せず、軸のインデックスの順序のみを参照することに注意してください。「A」は、 &lt;code&gt;a&lt;/code&gt; が&lt;em&gt;連続した&lt;/em&gt; Fortranの場合、要素をFortranに似たインデックス順で読み取ることを意味します&lt;em&gt;&lt;/em&gt;メモリでは、それ以外はCのような順序です。'K'は、ストライドが負の場合にデータを反転することを除いて、メモリ内で発生した順に要素を読み取ることを意味します。デフォルトでは、「C」インデックス順が使用されます。</target>
        </trans-unit>
        <trans-unit id="8bfe90d8bb9b3a44603b03bac0e42210874e7808" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;m&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;m&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; の要素は、このインデックスの順序を使用して読み取られます。 「C」は、Cのような順序で要素にインデックスを付けることを意味し、最後の軸のインデックスが最も速く変化し、最初の軸のインデックスが最も遅く変化します。 「F」は、最初のインデックスが最も速く変化し、最後のインデックスが最も遅く変化するFortranのようなインデックスの順序で要素にインデックスを付けることを意味します。 'C'および 'F'オプションは、基になる配列のメモリレイアウトを考慮せず、軸のインデックスの順序のみを参照することに注意してください。 'A'は、 &lt;code&gt;m&lt;/code&gt; がメモリ内でFortranに&lt;em&gt;隣接&lt;/em&gt;している場合はFortranに似たインデックス順で、それ以外はCに似た順序で要素を読み取ることを意味します。 'K'は、ストライドが負の場合にデータを反転することを除いて、メモリ内で発生した順に要素を読み取ることを意味します。デフォルトでは、「C」インデックス順が使用されます。</target>
        </trans-unit>
        <trans-unit id="d8d7a05ea4e76ed025da3efb7e37c3722ae9fddb" translate="yes" xml:space="preserve">
          <source>The elements of both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;a.T&lt;/code&gt; get traversed in the same order, namely the order they are stored in memory, whereas the elements of &lt;code&gt;a.T.copy(order=&amp;rsquo;C&amp;rsquo;)&lt;/code&gt; get visited in a different order because they have been put into a different memory layout.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; と &lt;code&gt;a.T&lt;/code&gt; の両方の要素は同じ順序、つまりメモリに格納されている順序でトラバースされますが、 &lt;code&gt;a.T.copy(order=&amp;rsquo;C&amp;rsquo;)&lt;/code&gt; の要素は異なるメモリに配置されているため、異なる順序でアクセスされますレイアウト。</target>
        </trans-unit>
        <trans-unit id="7c09282fb5ba8925fe26507ed54970dbeacf3bc3" translate="yes" xml:space="preserve">
          <source>The elements of the shape tuple give the lengths of the corresponding array dimensions.</source>
          <target state="translated">形状タプルの要素は,対応する配列の次元の長さを与えます.</target>
        </trans-unit>
        <trans-unit id="d08dc6baf6d1de4ff7af87aa1f35d18925c1f47b" translate="yes" xml:space="preserve">
          <source>The elements of this structure are:</source>
          <target state="translated">この構造の要素は</target>
        </trans-unit>
        <trans-unit id="c3ccba03f1b5d3bd5cacb97014f1795b1e1620ff" translate="yes" xml:space="preserve">
          <source>The ellipsis syntax maybe used to indicate selecting in full any remaining unspecified dimensions. For example:</source>
          <target state="translated">省略記号構文は、指定されていない残りのディメンジョンを完全に選択することを示すために使用されるかもしれません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="d0777cee700edf703f03cd8f123c44ac46b607f9" translate="yes" xml:space="preserve">
          <source>The end value of the sequence, unless &lt;code&gt;endpoint&lt;/code&gt; is set to False. In that case, the sequence consists of all but the last of &lt;code&gt;num + 1&lt;/code&gt; evenly spaced samples, so that &lt;code&gt;stop&lt;/code&gt; is excluded. Note that the step size changes when &lt;code&gt;endpoint&lt;/code&gt; is False.</source>
          <target state="translated">シーケンスの終了値（ &lt;code&gt;endpoint&lt;/code&gt; がFalseに設定されていない場合）。その場合、シーケンスは、 &lt;code&gt;num + 1&lt;/code&gt; 等間隔のサンプルの最後を除くすべてで構成されるため、その &lt;code&gt;stop&lt;/code&gt; は除外されます。 &lt;code&gt;endpoint&lt;/code&gt; がFalseの場合、ステップサイズが変化することに注意してください。</target>
        </trans-unit>
        <trans-unit id="61c8a67ac747d5eb7d80852565d6317e805901a1" translate="yes" xml:space="preserve">
          <source>The endpoint of the interval can optionally be excluded.</source>
          <target state="translated">区間の終点は、オプションで除外することができます。</target>
        </trans-unit>
        <trans-unit id="7c70e4957abd94f2cb0f87772d68554c90cbe5b2" translate="yes" xml:space="preserve">
          <source>The entropy for creating a &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;を作成するためのエントロピー。</target>
        </trans-unit>
        <trans-unit id="0807164c2e58b526f47d2a17d970242e2786a8ed" translate="yes" xml:space="preserve">
          <source>The enumeration value for ASCII strings of a selectable size. The strings have a fixed maximum size within a given array.</source>
          <target state="translated">選択可能なサイズのASCII文字列の列挙値。文字列は、指定された配列内で固定の最大サイズを持ちます。</target>
        </trans-unit>
        <trans-unit id="4486c486e9b2ccc0519632048cae0af33e6f2bea" translate="yes" xml:space="preserve">
          <source>The enumeration value for UCS4 strings of a selectable size. The strings have a fixed maximum size within a given array.</source>
          <target state="translated">選択可能なサイズのUCS4文字列の列挙値。文字列は、与えられた配列内で固定の最大サイズを持つ。</target>
        </trans-unit>
        <trans-unit id="ceb80d4c945347bb465d428088d951fae89cf7e9" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 128-bit/16-byte complex type made up of two NPY_DOUBLE values.</source>
          <target state="translated">2 つの NPY_DOUBLE 値からなる 128 ビット/16 バイト複素型の列挙値。</target>
        </trans-unit>
        <trans-unit id="022dd3242a4f7ab9f354ab53434df9783dde262d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte IEEE 754-2008 compatible floating point type.</source>
          <target state="translated">16ビット/2バイトのIEEE 754-2008互換浮動小数点型の列挙値。</target>
        </trans-unit>
        <trans-unit id="54200391c747968ffe444d868d0f00fe22c905a7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte signed integer.</source>
          <target state="translated">16ビット/2バイト符号付き整数の列挙値。</target>
        </trans-unit>
        <trans-unit id="24e698054b91536d27ff27c354d21704b0ff5fa7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte unsigned integer.</source>
          <target state="translated">16ビット/2バイトの符号なし整数の列挙値。</target>
        </trans-unit>
        <trans-unit id="48c93b25a09888099a2fa0e8cc423bbdd97aec51" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte IEEE 754 compatible floating point type.</source>
          <target state="translated">32ビット/4バイトのIEEE 754互換浮動小数点型の列挙値です。</target>
        </trans-unit>
        <trans-unit id="0767688f1013b974d66b67bec323cce162186c28" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte signed integer.</source>
          <target state="translated">32ビット/4バイト符号付き整数の列挙値。</target>
        </trans-unit>
        <trans-unit id="61e002f4aaa6d35ff73356572d5e52edd07749bc" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte unsigned integer.</source>
          <target state="translated">32ビット/4バイト符号なし整数の列挙値。</target>
        </trans-unit>
        <trans-unit id="13bb2de2cc37c2d6613c3c408dc1f6c1a04bcaf7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte IEEE 754 compatible floating point type.</source>
          <target state="translated">64ビット/8バイトのIEEE 754互換浮動小数点型の列挙値。</target>
        </trans-unit>
        <trans-unit id="712e85738302795b01166defaa51ce15d788398b" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte complex type made up of two NPY_FLOAT values.</source>
          <target state="translated">2つのNPY_FLOAT値からなる64ビット/8バイト複素型の列挙値。</target>
        </trans-unit>
        <trans-unit id="6fcce91d25d23bb25fdb72e7335d026c8e38fbfa" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte signed integer.</source>
          <target state="translated">64ビット/8バイト符号付き整数の列挙値。</target>
        </trans-unit>
        <trans-unit id="d2fd87ac5f2fe419cf576e3d1240b873a7fd353f" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte unsigned integer.</source>
          <target state="translated">64ビット/8バイトの符号なし整数の列挙値。</target>
        </trans-unit>
        <trans-unit id="7aee8554ea2f116b0ced362cc168497aed3b5e7d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a data type which holds dates or datetimes with a precision based on selectable date or time units.</source>
          <target state="translated">選択可能な日付または時間単位に基づいた精度で日付または日付時刻を保持するデータ型の列挙値。</target>
        </trans-unit>
        <trans-unit id="81373e1b16d0b1374953b29f2c2ce84e5c1e7ca6" translate="yes" xml:space="preserve">
          <source>The enumeration value for a data type which holds lengths of times in integers of selectable date or time units.</source>
          <target state="translated">選択可能な日付または時間単位の整数で時間の長さを保持するデータ型の列挙値。</target>
        </trans-unit>
        <trans-unit id="025565ff9d1efa7089189ec4ae9c78d4afba6baf" translate="yes" xml:space="preserve">
          <source>The enumeration value for a platform-specific complex floating point type which is made up of two NPY_LONGDOUBLE values.</source>
          <target state="translated">2つのNPY_LONGDOUBLE値からなるプラットフォーム固有の複素浮動小数点型の列挙値。</target>
        </trans-unit>
        <trans-unit id="02ee59a76dc8246cf577894e400f4aef4b3c2cdb" translate="yes" xml:space="preserve">
          <source>The enumeration value for a platform-specific floating point type which is at least as large as NPY_DOUBLE, but larger on many platforms.</source>
          <target state="translated">プラットフォーム固有の浮動小数点型の列挙値で、少なくとも NPY_DOUBLE と同じくらいの大きさですが、多くのプラットフォームではそれよりも大きい値になります。</target>
        </trans-unit>
        <trans-unit id="12bd9d6078665b062a610e653e29b9b8b5cd0f4d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a signed integer type which is the same size as a (void *) pointer. This is the type used by all arrays of indices.</source>
          <target state="translated">(void *)ポインタと同じサイズの符号付き整数型の列挙値。これはインデックスのすべての配列で使用される型です。</target>
        </trans-unit>
        <trans-unit id="1915b2aac968e6b707b08a802a86e659f6b7b54c" translate="yes" xml:space="preserve">
          <source>The enumeration value for an 8-bit/1-byte signed integer.</source>
          <target state="translated">8ビット/1バイト符号付き整数の列挙値。</target>
        </trans-unit>
        <trans-unit id="e2cde6e55c74a7eec76c04ac7971b58aabed014c" translate="yes" xml:space="preserve">
          <source>The enumeration value for an 8-bit/1-byte unsigned integer.</source>
          <target state="translated">8ビット/1バイト符号なし整数の列挙値。</target>
        </trans-unit>
        <trans-unit id="3bc60c39b304a6beb211c263d892c90730d59bf2" translate="yes" xml:space="preserve">
          <source>The enumeration value for an unsigned integer type which is the same size as a (void *) pointer.</source>
          <target state="translated">(void *)ポインタと同じサイズの符号なし整数型の列挙値。</target>
        </trans-unit>
        <trans-unit id="00cb2e716adb7d63188da00709d01e2a11b34089" translate="yes" xml:space="preserve">
          <source>The enumeration value for references to arbitrary Python objects.</source>
          <target state="translated">任意のPythonオブジェクトへの参照のための列挙値。</target>
        </trans-unit>
        <trans-unit id="dbec8c6917cdb1fb9cc672eba6fd415b762d7774" translate="yes" xml:space="preserve">
          <source>The enumeration value for the boolean type, stored as one byte. It may only be set to the values 0 and 1.</source>
          <target state="translated">ブール型の列挙値で、1バイトとして格納されています。値0と1にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="f6d7694b75b473ad222039c05e89641ad1c019cb" translate="yes" xml:space="preserve">
          <source>The enumeration value of the type used for masks, such as with the &lt;a href=&quot;c-api.iterator#c.NPY_ITER_ARRAYMASK&quot;&gt;&lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt;&lt;/a&gt; iterator flag. This is equivalent to &lt;a href=&quot;#c.NPY_UINT8&quot;&gt;&lt;code&gt;NPY_UINT8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c-api.iterator#c.NPY_ITER_ARRAYMASK&quot;&gt; &lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt; &lt;/a&gt;イテレータフラグなど、マスクに使用されるタイプの列挙値。これは&lt;a href=&quot;#c.NPY_UINT8&quot;&gt; &lt;code&gt;NPY_UINT8&lt;/code&gt; &lt;/a&gt;と同等です。</target>
        </trans-unit>
        <trans-unit id="470c7c6a0fdea0ae871ac319202aa3679b0d2b38" translate="yes" xml:space="preserve">
          <source>The enumeration value of the type used for masks, such as with the &lt;a href=&quot;iterator#c.NPY_ITER_ARRAYMASK&quot;&gt;&lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt;&lt;/a&gt; iterator flag. This is equivalent to &lt;a href=&quot;#c.NPY_UINT8&quot;&gt;&lt;code&gt;NPY_UINT8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;iterator#c.NPY_ITER_ARRAYMASK&quot;&gt; &lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt; &lt;/a&gt;イテレータフラグなど、マスクに使用されるタイプの列挙値。これは&lt;a href=&quot;#c.NPY_UINT8&quot;&gt; &lt;code&gt;NPY_UINT8&lt;/code&gt; &lt;/a&gt;と同等です。</target>
        </trans-unit>
        <trans-unit id="60104b59eca7223d2be466212e148860409e987c" translate="yes" xml:space="preserve">
          <source>The equivalent for floating point data types.</source>
          <target state="translated">浮動小数点データ型に相当します。</target>
        </trans-unit>
        <trans-unit id="4e36288c483218b6153f62263e1c19e0918537e1" translate="yes" xml:space="preserve">
          <source>The equivalent for integer data types.</source>
          <target state="translated">整数データ型に相当します。</target>
        </trans-unit>
        <trans-unit id="f007c7cbd53c8448e809d2bc2019ae342707c904" translate="yes" xml:space="preserve">
          <source>The error also has additional information to help you troubleshoot:</source>
          <target state="translated">このエラーには、トラブルシューティングに役立つ追加情報も含まれています。</target>
        </trans-unit>
        <trans-unit id="7c428e56ed9d259c349566498573b0b72cf82c45" translate="yes" xml:space="preserve">
          <source>The error mask is a single integer that holds the treatment information on all four floating point errors. The information for each error type is contained in three bits of the integer. If we print it in base 8, we can see what treatment is set for &amp;ldquo;invalid&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, and &amp;ldquo;divide&amp;rdquo; (in that order). The printed string can be interpreted with</source>
          <target state="translated">エラーマスクは、4つの浮動小数点エラーすべての処理情報を保持する単一の整数です。各エラータイプの情報は、整数の3ビットに含まれています。ベース8で印刷すると、「無効」、「下」、「上」、「分割」の順に設定された処理がわかります。印刷された文字列は、</target>
        </trans-unit>
        <trans-unit id="6236f64a81230ccb9458bf1fe006ba3279baed6f" translate="yes" xml:space="preserve">
          <source>The error message to be printed in case of failure.</source>
          <target state="translated">失敗した場合に表示されるエラーメッセージ。</target>
        </trans-unit>
        <trans-unit id="46e36d39518380daadad6b1e62b8973365b854c8" translate="yes" xml:space="preserve">
          <source>The error object contains all information that defines the error handling behavior in NumPy. &lt;a href=&quot;#numpy.geterrobj&quot;&gt;&lt;code&gt;geterrobj&lt;/code&gt;&lt;/a&gt; is used internally by the other functions that get and set error handling behavior (&lt;a href=&quot;numpy.geterr#numpy.geterr&quot;&gt;&lt;code&gt;geterr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.geterrcall#numpy.geterrcall&quot;&gt;&lt;code&gt;geterrcall&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">エラーオブジェクトには、NumPyでのエラー処理動作を定義するすべての情報が含まれています。&lt;a href=&quot;#numpy.geterrobj&quot;&gt; &lt;code&gt;geterrobj&lt;/code&gt; &lt;/a&gt;は、エラー処理動作を取得および設定する他の関数（&lt;a href=&quot;numpy.geterr#numpy.geterr&quot;&gt; &lt;code&gt;geterr&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;numpy.geterrcall#numpy.geterrcall&quot;&gt; &lt;code&gt;geterrcall&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt;）によって内部的に使用されます。</target>
        </trans-unit>
        <trans-unit id="d7bceac49145568dab2a83ccab3ab1eea9b12faf" translate="yes" xml:space="preserve">
          <source>The error object contains all information that defines the error handling behavior in NumPy. &lt;a href=&quot;#numpy.seterrobj&quot;&gt;&lt;code&gt;seterrobj&lt;/code&gt;&lt;/a&gt; is used internally by the other functions that set error handling behavior (&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">エラーオブジェクトには、NumPyでのエラー処理動作を定義するすべての情報が含まれています。&lt;a href=&quot;#numpy.seterrobj&quot;&gt; &lt;code&gt;seterrobj&lt;/code&gt; &lt;/a&gt;は、エラー処理動作を設定する他の関数（&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt;）によって内部的に使用されます。</target>
        </trans-unit>
        <trans-unit id="717ffb083d9a010e39e00d26ae4cbb3686fdec82" translate="yes" xml:space="preserve">
          <source>The error object, a list containing three elements: [internal numpy buffer size, error mask, error callback function].</source>
          <target state="translated">エラーオブジェクトは、3つの要素を含むリストです。内部numpyバッファサイズ、エラーマスク、エラーコールバック関数]の3つの要素を含むリストです。</target>
        </trans-unit>
        <trans-unit id="9f5b3632192f41c961bfe841ce3532fd1faa0967" translate="yes" xml:space="preserve">
          <source>The evaluation uses Clenshaw recursion, aka synthetic division.</source>
          <target state="translated">評価はクレンショーの再帰、別名合成分割を使用しています。</target>
        </trans-unit>
        <trans-unit id="9a7486fe20eefd44f8d5d46a29c17743d8baf71d" translate="yes" xml:space="preserve">
          <source>The evaluation uses Horner&amp;rsquo;s method.</source>
          <target state="translated">評価はホーナーの方法を使用しています。</target>
        </trans-unit>
        <trans-unit id="db5640fe4648623a565ed032ffc116fcc6e293bd" translate="yes" xml:space="preserve">
          <source>The exact definition of a slow test is obviously both subjective and hardware-dependent, but in general any individual test that requires more than a second or two should be labeled as slow (the whole suite consists of thousands of tests, so even a second is significant).</source>
          <target state="translated">遅いテストの正確な定義は、明らかに主観的であり、ハードウェアに依存しますが、一般的には、1~2秒以上かかる個々のテストは、遅いと表示されるべきです(スイート全体では何千ものテストで構成されているため、1秒でも重要です)。</target>
        </trans-unit>
        <trans-unit id="0fe09946a84bc00c7ff87cc3c4856ae88e30a696" translate="yes" xml:space="preserve">
          <source>The example also demonstrates Cython&amp;rsquo;s &amp;ldquo;typed memoryviews&amp;rdquo;, which are like NumPy arrays at the C level, in the sense that they are shaped and strided arrays that know their own extent (unlike a C array addressed through a bare pointer). The syntax &lt;code&gt;double complex[:]&lt;/code&gt; denotes a one-dimensional array (vector) of doubles, with arbitrary strides. A contiguous array of ints would be &lt;code&gt;int[::1]&lt;/code&gt;, while a matrix of floats would be &lt;code&gt;float[:, :]&lt;/code&gt;.</source>
          <target state="translated">この例は、Cythonの「型付きメモリビュー」も示しています。これは、CレベルのNumPy配列に似ており、（裸のポインターを介してアドレス指定されたC配列とは異なり）独自の範囲を知っている形状とストライド配列です。構文 &lt;code&gt;double complex[:]&lt;/code&gt; は、任意のストライドを持つdoubleの1次元配列（ベクトル）を示します。連続するintの配列はint &lt;code&gt;int[::1]&lt;/code&gt; であり、 &lt;code&gt;float[:, :]&lt;/code&gt; 行列はfloat [：、：]です。</target>
        </trans-unit>
        <trans-unit id="d3927b62f1cd7d72e0062722877a649b50aac359" translate="yes" xml:space="preserve">
          <source>The example code may be split across multiple lines, with each line after the first starting with &amp;lsquo;&amp;hellip; &amp;lsquo;:</source>
          <target state="translated">サンプルコードは複数の行に分割される場合があり、各行は最初の行が「&amp;hellip;」で始まります。</target>
        </trans-unit>
        <trans-unit id="3c6b68db229268c95185c669cea481b3a1f2e9b2" translate="yes" xml:space="preserve">
          <source>The examples may assume that &lt;code&gt;import numpy as np&lt;/code&gt; is executed before the example code in &lt;em&gt;numpy&lt;/em&gt;. Additional examples may make use of &lt;em&gt;matplotlib&lt;/em&gt; for plotting, but should import it explicitly, e.g., &lt;code&gt;import matplotlib.pyplot as plt&lt;/code&gt;. All other imports, including the demonstrated function, must be explicit.</source>
          <target state="translated">例では、&lt;em&gt;numpyの&lt;/em&gt;サンプルコードの前に &lt;code&gt;import numpy as np&lt;/code&gt; が実行されると想定している場合があります。追加の例では、プロットに&lt;em&gt;matplotlib&lt;/em&gt;を使用する場合がありますが、明示的にインポートする必要があります。たとえば、 &lt;code&gt;import matplotlib.pyplot as plt&lt;/code&gt; 。実証された関数を含む他のすべてのインポートは、明示的でなければなりません。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4a28216e8d502daba2aa9f77ed97bda4ac746a41" translate="yes" xml:space="preserve">
          <source>The exceptions to the above rules are given below:</source>
          <target state="translated">上記のルールの例外については、以下の通りです。</target>
        </trans-unit>
        <trans-unit id="ea2c7bd23b14b815638891431083c6a5af9b6f5a" translate="yes" xml:space="preserve">
          <source>The execution will now stop at the corresponding C function and you can step through it as usual. A number of useful Python-specific commands are available. For example to see where in the Python code you are, use &lt;code&gt;py-list&lt;/code&gt;. For more details, see &lt;a href=&quot;https://wiki.python.org/moin/DebuggingWithGdb&quot;&gt;DebuggingWithGdb&lt;/a&gt;. Here are some commonly used commands:</source>
          <target state="translated">これで、対応するC関数で実行が停止し、通常どおりに実行できます。便利なPython固有のコマンドが多数用意されています。たとえば、Pythonコードのどこにいるかを確認するには、 &lt;code&gt;py-list&lt;/code&gt; を使用します。詳細については、&lt;a href=&quot;https://wiki.python.org/moin/DebuggingWithGdb&quot;&gt;DebuggingWithGdbを&lt;/a&gt;参照してください。一般的に使用されるコマンドは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="8953035a1ae2630eb8257139de6a8432deef2d8b" translate="yes" xml:space="preserve">
          <source>The expected object.</source>
          <target state="translated">期待されるオブジェクト。</target>
        </trans-unit>
        <trans-unit id="ec4e2a0cf38710bdb603b5d339066519f8b6c301" translate="yes" xml:space="preserve">
          <source>The expected string.</source>
          <target state="translated">期待される文字列。</target>
        </trans-unit>
        <trans-unit id="59f101f805e4afd5d4f5aac41091912e82f52cce" translate="yes" xml:space="preserve">
          <source>The exponent can be any integer or long integer, positive, negative, or zero.</source>
          <target state="translated">指数は、任意の整数または長整数、正、負、ゼロのいずれかである。</target>
        </trans-unit>
        <trans-unit id="48bfe58fce3c9524a47514144118fc15384f8ce9" translate="yes" xml:space="preserve">
          <source>The exponent that yields &lt;code&gt;eps&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eps&lt;/code&gt; を生成する指数。</target>
        </trans-unit>
        <trans-unit id="8728d1625b1f4800f5da44ea73eddec8a90b29f7" translate="yes" xml:space="preserve">
          <source>The exponent that yields &lt;code&gt;epsneg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;epsneg&lt;/code&gt; を生成する指数。</target>
        </trans-unit>
        <trans-unit id="3d2aac84d1e998e3af66433136551e2122fcd6db" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#r0dbb9b01ef9c-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#r0dbb9b01ef9c-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">指数分布は、幾何分布の連続的な類似物です。多くの暴風雨で測定された雨滴のサイズ&lt;a href=&quot;#r0dbb9b01ef9c-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;や、ウィキペディアへのページリクエスト間の時間&lt;a href=&quot;#r0dbb9b01ef9c-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;など、多くの一般的な状況を説明します。</target>
        </trans-unit>
        <trans-unit id="379909a59d38e5f49bfe83c94188ec2a18000b03" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#r3cbd6af2d0d3-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#r3cbd6af2d0d3-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">指数分布は、幾何分布の連続的な類似物です。多くの暴風雨で測定された雨滴のサイズ&lt;a href=&quot;#r3cbd6af2d0d3-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;や、ウィキペディアへのページリクエスト間の時間&lt;a href=&quot;#r3cbd6af2d0d3-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;など、多くの一般的な状況について説明しています。</target>
        </trans-unit>
        <trans-unit id="ae0234d51209697de2e3092417cea04cdd633ab5" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#rcf497e7bc958-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#rcf497e7bc958-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">指数分布は、幾何分布の連続的な類似物です。多くの暴風雨で測定された雨滴のサイズ&lt;a href=&quot;#rcf497e7bc958-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;や、ウィキペディアへのページリクエスト間の時間&lt;a href=&quot;#rcf497e7bc958-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;など、多くの一般的な状況を説明します。</target>
        </trans-unit>
        <trans-unit id="9d68d926a5db1e2f83fa605bc0a4678131d567b9" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#rcfd3e98ffb09-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#rcfd3e98ffb09-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">指数分布は、幾何分布の連続的な類似物です。多くの暴風雨で測定された雨滴のサイズ&lt;a href=&quot;#rcfd3e98ffb09-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;や、ウィキペディアへのページリクエスト間の時間&lt;a href=&quot;#rcfd3e98ffb09-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;など、多くの一般的な状況について説明しています。</target>
        </trans-unit>
        <trans-unit id="33ed180d63f4fd6bda2a99808d388e4ba0b2acb0" translate="yes" xml:space="preserve">
          <source>The exponents. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">指数。 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状にブロードキャスト可能でなければなりません（これが出力の形状になります）。</target>
        </trans-unit>
        <trans-unit id="4a0678b00019c9d465c7278be4782e4ae402fa1c" translate="yes" xml:space="preserve">
          <source>The expression within brackets in &lt;code&gt;b[i]&lt;/code&gt; is treated as an &lt;code&gt;i&lt;/code&gt; followed by as many instances of &lt;code&gt;:&lt;/code&gt; as needed to represent the remaining axes. NumPy also allows you to write this using dots as &lt;code&gt;b[i,...]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b[i]&lt;/code&gt; 内の括弧内の式は、 &lt;code&gt;i&lt;/code&gt; として扱われ、その後に残りの軸を表すために必要な &lt;code&gt;:&lt;/code&gt; インスタンスが続きます。NumPyでは、ドットを &lt;code&gt;b[i,...]&lt;/code&gt; として使用してこれを記述することもできます。</target>
        </trans-unit>
        <trans-unit id="330beb4f458d2c8c447ab8cdae27158e06bf7cb9" translate="yes" xml:space="preserve">
          <source>The extracted diagonal or constructed diagonal array.</source>
          <target state="translated">抽出された対角線または構築された対角線配列。</target>
        </trans-unit>
        <trans-unit id="53a8a2b8a609081b147379c06e4ca152c3e8819c" translate="yes" xml:space="preserve">
          <source>The f2py method of linking compiled code is currently the most sophisticated and integrated approach. It allows clean separation of Python with compiled code while still allowing for separate distribution of the extension module. The only draw-back is that it requires the existence of a Fortran compiler in order for a user to install the code. However, with the existence of the free-compilers g77, gfortran, and g95, as well as high-quality commercial compilers, this restriction is not particularly onerous. In my opinion, Fortran is still the easiest way to write fast and clear code for scientific computing. It handles complex numbers, and multi-dimensional indexing in the most straightforward way. Be aware, however, that some Fortran compilers will not be able to optimize code as well as good hand- written C-code.</source>
          <target state="translated">コンパイルされたコードをリンクするf2pyメソッドは、現在最も洗練された統合されたアプローチです。これは、Pythonとコンパイルされたコードをきれいに分離することを可能にし、同時に、拡張モジュールを別々に配布することを可能にします。唯一の欠点は、ユーザーがコードをインストールするためにFortranコンパイラが必要なことです。しかし、フリーのコンパイラ g77,gfortran,g95 や高品質の商用コンパイラが存在するので、この制限は特に厳しくありません。私の考えでは,Fortranは科学計算のための高速で明快なコードを書くための最も簡単な方法だと思います.Fortranは複雑な数値や多次元のインデックスを最も簡単に扱うことができます。しかし、Fortranコンパイラの中には、手書きのCコードのようにコードを最適化できないものがあることに注意してください。</target>
        </trans-unit>
        <trans-unit id="555daf4232eb1ce31031f68a76fe276dbf717736" translate="yes" xml:space="preserve">
          <source>The f2py program is written in Python and can be run from inside your code to compile Fortran code at runtime, as follows:</source>
          <target state="translated">f2pyプログラムはPythonで書かれており、以下のようにコード内部から実行してFortranコードを実行時にコンパイルすることができます。</target>
        </trans-unit>
        <trans-unit id="06e74a78df99ca864f56978dd8124a3fb8da4ff4" translate="yes" xml:space="preserve">
          <source>The field names may be modified by assigning to the &lt;code&gt;names&lt;/code&gt; attribute using a sequence of strings of the same length.</source>
          <target state="translated">フィールド名は、同じ長さの文字列のシーケンスを使用して &lt;code&gt;names&lt;/code&gt; 属性に割り当てることで変更できます。</target>
        </trans-unit>
        <trans-unit id="c76b262eba97deb65c7a5b3c9fb6314561e8e763" translate="yes" xml:space="preserve">
          <source>The field names, either specified as a comma-separated string in the form &lt;code&gt;'col1, col2, col3'&lt;/code&gt;, or as a list or tuple of strings in the form &lt;code&gt;['col1', 'col2', 'col3']&lt;/code&gt;. An empty list can be used, in that case default field names (&amp;lsquo;f0&amp;rsquo;, &amp;lsquo;f1&amp;rsquo;, &amp;hellip;) are used.</source>
          <target state="translated">フィールド名。 &lt;code&gt;'col1, col2, col3'&lt;/code&gt; の形式でコンマ区切りの文字列として、または &lt;code&gt;['col1', 'col2', 'col3']&lt;/code&gt; の形式で文字列のリストまたはタプルとして指定します。空のリストを使用できます。その場合、デフォルトのフィールド名（ 'f0'、 'f1'、&amp;hellip;）が使用されます。</target>
        </trans-unit>
        <trans-unit id="abdb8363ba033add56efe121cf142ecd7ff5e4f2" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;doc/changelog/1.14.5-changelog.rst&lt;/code&gt; should be updated to reflect the final list of changes and contributors. This text can be generated by:</source>
          <target state="translated">ファイル &lt;code&gt;doc/changelog/1.14.5-changelog.rst&lt;/code&gt; は、変更と貢献者の最終リストを反映するように更新する必要があります。このテキストは、次の方法で生成できます。</target>
        </trans-unit>
        <trans-unit id="0a3f62236ba0b0b8ce93c2fc463e81343db95a91" translate="yes" xml:space="preserve">
          <source>The file contains an object array, but allow_pickle=False given.</source>
          <target state="translated">ファイルにはオブジェクト配列が含まれていますが、allow_pickle=Falseが与えられています。</target>
        </trans-unit>
        <trans-unit id="cd858c6c51a98e96ec8ac35aea8fe45863b797ca" translate="yes" xml:space="preserve">
          <source>The file is opened in this mode:</source>
          <target state="translated">このモードでファイルを開きます。</target>
        </trans-unit>
        <trans-unit id="5b33f093bafabe18517ca8ac91b17b43d100f40c" translate="yes" xml:space="preserve">
          <source>The file name or file object to be used as the array data buffer.</source>
          <target state="translated">配列データバッファとして使用するファイル名またはファイルオブジェクト。</target>
        </trans-unit>
        <trans-unit id="26bdea2d86889049bdd7c48c4150155a14c6f9d5" translate="yes" xml:space="preserve">
          <source>The file or file name to load.</source>
          <target state="translated">読み込むファイルまたはファイル名。</target>
        </trans-unit>
        <trans-unit id="410bba1d09731e6c1884743045c51541ebe57e5e" translate="yes" xml:space="preserve">
          <source>The file to pickle &lt;code&gt;a&lt;/code&gt; to. If a string, the full path to the file.</source>
          <target state="translated">ピクル &lt;code&gt;a&lt;/code&gt; ファイル。文字列の場合、ファイルへの完全パス。</target>
        </trans-unit>
        <trans-unit id="48b7a50cb95566779f051ba6cb8275f9d03a7f05" translate="yes" xml:space="preserve">
          <source>The file to read. File-like objects must support the &lt;code&gt;seek()&lt;/code&gt; and &lt;code&gt;read()&lt;/code&gt; methods. Pickled files require that the file-like object support the &lt;code&gt;readline()&lt;/code&gt; method as well.</source>
          <target state="translated">読み取るファイル。ファイルのようなオブジェクトは &lt;code&gt;seek()&lt;/code&gt; および &lt;code&gt;read()&lt;/code&gt; メソッドをサポートする必要があります。ピクルされたファイルでは、ファイルのようなオブジェクトが &lt;code&gt;readline()&lt;/code&gt; メソッドもサポートしている必要があります。</target>
        </trans-unit>
        <trans-unit id="68f5b58fd976e02c0c3bbbefcb6355b0422acf86" translate="yes" xml:space="preserve">
          <source>The fill_value is set to &lt;code&gt;value&lt;/code&gt; and the mask is set to &lt;code&gt;nomask&lt;/code&gt; if possible.</source>
          <target state="translated">fill_valueは &lt;code&gt;value&lt;/code&gt; に設定され、 &lt;code&gt;nomask&lt;/code&gt; マスクはnomaskに設定されます。</target>
        </trans-unit>
        <trans-unit id="ac0cc14c76ce415edde3f9c0f5c15cc239b98f83" translate="yes" xml:space="preserve">
          <source>The filled array.</source>
          <target state="translated">埋め尽くされた配列。</target>
        </trans-unit>
        <trans-unit id="02297c05ffd69a001bc553284a8c48319db02e69" translate="yes" xml:space="preserve">
          <source>The filling value of the masked array is a scalar.</source>
          <target state="translated">マスクされた配列の充填値はスカラです。</target>
        </trans-unit>
        <trans-unit id="104abb4185415b9595a8eb2fd00671acf84e203a" translate="yes" xml:space="preserve">
          <source>The filling value of the masked array is a scalar. When setting, None will set to a default based on the data type.</source>
          <target state="translated">マスクされた配列の充填値はスカラです。設定すると、データ型に応じて None がデフォルトで設定されます。</target>
        </trans-unit>
        <trans-unit id="0bd5aa8a98810899514ee710bc2579712901ebe5" translate="yes" xml:space="preserve">
          <source>The final value of the sequence, unless &lt;code&gt;endpoint&lt;/code&gt; is False. In that case, &lt;code&gt;num + 1&lt;/code&gt; values are spaced over the interval in log-space, of which all but the last (a sequence of length &lt;code&gt;num&lt;/code&gt;) are returned.</source>
          <target state="translated">&lt;code&gt;endpoint&lt;/code&gt; がFalse でない限り、シーケンスの最終値。その場合、 &lt;code&gt;num + 1&lt;/code&gt; 値はlog-spaceの間隔で間隔をあけて配置され、最後以外のすべて（長さ &lt;code&gt;num&lt;/code&gt; のシーケンス）が返されます。</target>
        </trans-unit>
        <trans-unit id="5b6f2d1ecce5ed0ec2d0e715086fccc9259a6627" translate="yes" xml:space="preserve">
          <source>The first 6 bytes are a magic string: exactly &lt;code&gt;\x93NUMPY&lt;/code&gt;.</source>
          <target state="translated">最初の6バイトはマジックストリングです。正確には &lt;code&gt;\x93NUMPY&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="df3f3dac6a267f56fafa2c760b8d38d59413267f" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;nargs&lt;/code&gt; elements of &lt;code&gt;steps&lt;/code&gt; remain the same as for scalar ufuncs. The following elements contain the strides of all core dimensions for all arguments in order.</source>
          <target state="translated">&lt;code&gt;steps&lt;/code&gt; の最初の &lt;code&gt;nargs&lt;/code&gt; 要素は、スカラーufuncの場合と同じです。次の要素には、すべての引数のすべてのコアディメンションのストライドが順番に含まれています。</target>
        </trans-unit>
        <trans-unit id="b9577dc8ae8dc3d75fe0e9351485a971c104657b" translate="yes" xml:space="preserve">
          <source>The first argument contains the Extension instance that can be useful to access its attributes like &lt;code&gt;depends&lt;/code&gt;, &lt;code&gt;sources&lt;/code&gt;, etc. lists and modify them during the building process. The second argument gives a path to a build directory that must be used when creating files to a disk.</source>
          <target state="translated">最初の引数には、 &lt;code&gt;depends&lt;/code&gt; 、 &lt;code&gt;sources&lt;/code&gt; などの属性にアクセスし、ビルドプロセス中にそれらを変更するのに役立つExtensionインスタンスが含まれています。2番目の引数は、ディスクにファイルを作成するときに使用する必要があるビルドディレクトリへのパスを指定します。</target>
        </trans-unit>
        <trans-unit id="98f417ae094b593aad4f373856f9d75fc3caadf1" translate="yes" xml:space="preserve">
          <source>The first argument is any object that can be converted into a fixed-size data-type object. The second argument is the desired shape of this type. If the shape parameter is 1, then the data-type object is equivalent to fixed dtype. If &lt;em&gt;shape&lt;/em&gt; is a tuple, then the new dtype defines a sub-array of the given shape.</source>
          <target state="translated">最初の引数は、固定サイズのデータ​​型オブジェクトに変換できる任意のオブジェクトです。2番目の引数は、このタイプの望ましい形状です。shapeパラメータが1の場合、データ型オブジェクトは固定dtypeと同等です。&lt;em&gt;shape&lt;/em&gt;がタプルの場合、新しいdtypeは指定された形状のサブ配列を定義します。</target>
        </trans-unit>
        <trans-unit id="8dca1bab679e35ad504daad1a00ee24ea2d780cc" translate="yes" xml:space="preserve">
          <source>The first argument is any object that can be converted into a fixed-size data-type object. The second argument is the desired shape of this type. If the shape parameter is 1, then the data-type object used to be equivalent to fixed dtype. This behaviour is deprecated since NumPy 1.17 and will raise an error in the future. If &lt;em&gt;shape&lt;/em&gt; is a tuple, then the new dtype defines a sub-array of the given shape.</source>
          <target state="translated">最初の引数は、固定サイズのデータ​​型オブジェクトに変換できる任意のオブジェクトです。2番目の引数は、このタイプの望ましい形状です。形状パラメーターが1の場合、データ型オブジェクトは固定dtypeと同等でした。この動作はNumPy1.17以降非推奨であり、将来的にエラーが発生します。&lt;em&gt;shape&lt;/em&gt;がタプルの場合、新しいdtypeは指定された形状のサブ配列を定義します。</target>
        </trans-unit>
        <trans-unit id="ddb3620809413337a1b624decfe7e8c4e4d1dcd2" translate="yes" xml:space="preserve">
          <source>The first argument is the newly created sub-type. The second argument (if not NULL) is the &amp;ldquo;parent&amp;rdquo; array (if the array was created using slicing or some other operation where a clearly-distinguishable parent is present). This routine can do anything it wants to. It should return a -1 on error and 0 otherwise.</source>
          <target state="translated">最初の引数は、新しく作成されたサブタイプです。2番目の引数（NULLでない場合）は「親」配列です（配列がスライスまたは明確に区別できる親が存在するその他の操作を使用して作成された場合）。このルーチンは、やりたいことを何でもできます。エラーの場合は-1を返し、それ以外の場合は0を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="2a0c10acae5d14d1b06af72f8c3df392eea96371" translate="yes" xml:space="preserve">
          <source>The first argument must be an object that is converted to a zero-sized flexible data-type object, the second argument is an integer providing the desired itemsize.</source>
          <target state="translated">第一引数はゼロサイズの柔軟なデータ型オブジェクトに変換されたオブジェクトでなければならず、第二引数は希望するアイテムサイズを提供する整数です。</target>
        </trans-unit>
        <trans-unit id="4ab185078e9e031c6680e1f1eab45ad50f864a10" translate="yes" xml:space="preserve">
          <source>The first array shows the outcomes of throwing the dice 10 times, and the second shows the outcomes from throwing the dice 20 times.</source>
          <target state="translated">最初の配列はサイコロを10回投げたときの結果を示し、2番目の配列はサイコロを20回投げたときの結果を示します。</target>
        </trans-unit>
        <trans-unit id="251cc7294c3d03a290266d04d53995289d0bed50" translate="yes" xml:space="preserve">
          <source>The first assert does not raise an exception:</source>
          <target state="translated">最初のアサートでは例外は発生しません。</target>
        </trans-unit>
        <trans-unit id="0135e65581d52468c8b55907d113ce790f408aef" translate="yes" xml:space="preserve">
          <source>The first business day on or after a date:</source>
          <target state="translated">日付が入った日以降の最初の営業日。</target>
        </trans-unit>
        <trans-unit id="034408f6ac73256e0eb3a019833e3b1d26d2adb1" translate="yes" xml:space="preserve">
          <source>The first business day strictly after a date:</source>
          <target state="translated">厳密にはデートの後の最初の営業日。</target>
        </trans-unit>
        <trans-unit id="d4d700653c3699a51205d4e8a1ce2d74d29df2ba" translate="yes" xml:space="preserve">
          <source>The first character specifies the kind of data and the remaining characters specify the number of bytes per item, except for Unicode, where it is interpreted as the number of characters. The item size must correspond to an existing type, or an error will be raised. The supported kinds are</source>
          <target state="translated">最初の文字はデータの種類を指定し、残りの文字は項目ごとのバイト数を指定します。項目のサイズは既存の型に対応していなければならず、そうしないとエラーが発生します。サポートされている種類は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="fce5520747cac508bb51c31e51bc43340f4f28dc" translate="yes" xml:space="preserve">
          <source>The first difference is given by &lt;code&gt;out[i] = a[i+1] - a[i]&lt;/code&gt; along the given axis, higher differences are calculated by using &lt;a href=&quot;#numpy.diff&quot;&gt;&lt;code&gt;diff&lt;/code&gt;&lt;/a&gt; recursively.</source>
          <target state="translated">最初の差は、与えられた軸に沿って &lt;code&gt;out[i] = a[i+1] - a[i]&lt;/code&gt; で与えられます。より高い差は、&lt;a href=&quot;#numpy.diff&quot;&gt; &lt;code&gt;diff&lt;/code&gt; を&lt;/a&gt;再帰的に使用して計算されます。</target>
        </trans-unit>
        <trans-unit id="a9df17052dacee8cafb40ea7e55b18075cf5de14" translate="yes" xml:space="preserve">
          <source>The first element, &lt;em&gt;field_name&lt;/em&gt;, is the field name (if this is &lt;code&gt;''&lt;/code&gt; then a standard field name, &lt;code&gt;'f#'&lt;/code&gt;, is assigned). The field name may also be a 2-tuple of strings where the first string is either a &amp;ldquo;title&amp;rdquo; (which may be any string or unicode string) or meta-data for the field which can be any object, and the second string is the &amp;ldquo;name&amp;rdquo; which must be a valid Python identifier.</source>
          <target state="translated">最初の要素&lt;em&gt;field_name&lt;/em&gt;はフィールド名です（これが &lt;code&gt;''&lt;/code&gt; の場合、標準のフィールド名 &lt;code&gt;'f#'&lt;/code&gt; が割り当てられます）。フィールド名は2タプルの文字列でもかまいません。最初の文字列は「タイトル」（任意の文字列またはUnicode文字列）または任意のオブジェクトであるフィールドのメタデータで、2番目の文字列は有効なPython識別子である必要がある「名前」。</target>
        </trans-unit>
        <trans-unit id="67d77719eacdaf274558e4a616994274e8d068b0" translate="yes" xml:space="preserve">
          <source>The first example integrates &lt;code&gt;p&lt;/code&gt; once, the second example integrates it twice. By default, the lower bound of the integration and the integration constant are 0, but both can be specified.:</source>
          <target state="translated">最初の例は &lt;code&gt;p&lt;/code&gt; を 1回積分し、2番目の例は2回積分します。デフォルトでは、積分の下限と積分定数は0ですが、両方を指定できます。</target>
        </trans-unit>
        <trans-unit id="311abfb54dbdf5d2ba16af23aef0589cc8d8cc86" translate="yes" xml:space="preserve">
          <source>The first form should be preferred.</source>
          <target state="translated">第一形態が好ましい。</target>
        </trans-unit>
        <trans-unit id="efb03ce57a81f162cb7b4a2a4999809358d24fef" translate="yes" xml:space="preserve">
          <source>The first integer is the first byte of the array, the second integer is just past the last byte of the array. If &lt;code&gt;a&lt;/code&gt; is not contiguous it will not use every byte between the (&lt;code&gt;low&lt;/code&gt;, &lt;code&gt;high&lt;/code&gt;) values.</source>
          <target state="translated">最初の整数は配列の最初のバイトであり、2番目の整数は配列の最後のバイトをちょうど過ぎています。場合は連続していない、それは（間のすべてのバイトは使用されません &lt;code&gt;low&lt;/code&gt; 、 &lt;code&gt;high&lt;/code&gt; ）の値を。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19fd42d2f3f6ab1e3a2844cd4d5055ea1cbf31a0" translate="yes" xml:space="preserve">
          <source>The first is the use of the &lt;code&gt;ndarray.__new__&lt;/code&gt; method for the main work of object initialization, rather then the more usual &lt;code&gt;__init__&lt;/code&gt; method. The second is the use of the &lt;code&gt;__array_finalize__&lt;/code&gt; method to allow subclasses to clean up after the creation of views and new instances from templates.</source>
          <target state="translated">1つ目は、より一般的な &lt;code&gt;__init__&lt;/code&gt; メソッドではなく、オブジェクト初期化の主な作業に &lt;code&gt;ndarray.__new__&lt;/code&gt; メソッドを使用することです。2つ目は、 &lt;code&gt;__array_finalize__&lt;/code&gt; メソッドを使用して、テンプレートからビューと新しいインスタンスを作成した後にサブクラスをクリーンアップできるようにすることです。</target>
        </trans-unit>
        <trans-unit id="eb41b42b24f210f1f4be6981685ada6a1cb54412" translate="yes" xml:space="preserve">
          <source>The first law of Laplace, from 1774, states that the frequency of an error can be expressed as an exponential function of the absolute magnitude of the error, which leads to the Laplace distribution. For many problems in economics and health sciences, this distribution seems to model the data better than the standard Gaussian distribution.</source>
          <target state="translated">1774年のラプラスの第1法則は、誤差の頻度が誤差の絶対的な大きさの指数関数として表現できることを述べており、これがラプラス分布につながります。経済学や健康科学の多くの問題では、この分布は、標準のガウス分布よりもデータをよりよくモデル化しているようです。</target>
        </trans-unit>
        <trans-unit id="f7deea27a398e3cec5cdd6f79c6e53fb0be11445" translate="yes" xml:space="preserve">
          <source>The first output can be provided as either a positional or a keyword parameter. Keyword &amp;lsquo;out&amp;rsquo; arguments are incompatible with positional ones.</source>
          <target state="translated">最初の出力は、位置パラメータまたはキーワードパラメータとして提供できます。キーワードの「out」引数は、位置引数と互換性がありません。</target>
        </trans-unit>
        <trans-unit id="6c26c4fe0578c2071a8b45fe1c269e9b84d2d403" translate="yes" xml:space="preserve">
          <source>The first parameter, arr, must be an ndarray or subclass. The parameter, &lt;em&gt;flags&lt;/em&gt;, should be an integer consisting of bitwise combinations of the possible flags an array can have: &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt;&lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">最初のパラメーターarrは、ndarrayまたはサブクラスでなければなりません。パラメータ&lt;em&gt;フラグは&lt;/em&gt;、配列が持つことができる可能なフラグのビット単位の組み合わせからなる整数でなければならない：&lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt; &lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a463555884e9f663755cbacb732bc60283f30e4e" translate="yes" xml:space="preserve">
          <source>The first rule of broadcasting is that if all input arrays do not have the same number of dimensions, a &amp;ldquo;1&amp;rdquo; will be repeatedly prepended to the shapes of the smaller arrays until all the arrays have the same number of dimensions.</source>
          <target state="translated">ブロードキャストの最初のルールは、すべての入力配列の次元数が同じでない場合、すべての配列の次元数が同じになるまで、小さい配列の形状に「1」が繰り返し付加されることです。</target>
        </trans-unit>
        <trans-unit id="a8639bf3cb0cf6544a568d7a40bcc68d44fbb8c9" translate="yes" xml:space="preserve">
          <source>The first signature listed, &lt;code&gt;( DATA_TYPE IN_ARRAY[ANY] )&lt;/code&gt; is for one-dimensional arrays with hard-coded dimensions. Likewise, &lt;code&gt;( DATA_TYPE IN_ARRAY2[ANY][ANY] )&lt;/code&gt; is for two-dimensional arrays with hard-coded dimensions, and similarly for three-dimensional.</source>
          <target state="translated">リストされている最初のシグネチャ &lt;code&gt;( DATA_TYPE IN_ARRAY[ANY] )&lt;/code&gt; は、ハードコードされた次元を持つ1次元配列用です。同様に、 &lt;code&gt;( DATA_TYPE IN_ARRAY2[ANY][ANY] )&lt;/code&gt; は、ハードコードされた次元を持つ2次元配列用であり、同様に3次元用です。</target>
        </trans-unit>
        <trans-unit id="21bc00ee1c8a15912cb2e713abebe2d2f93cd1e7" translate="yes" xml:space="preserve">
          <source>The first thing done is to look-up in the thread-specific global dictionary the current values for the buffer-size, the error mask, and the associated error object. The state of the error mask controls what happens when an error condition is found. It should be noted that checking of the hardware error flags is only performed after each 1-D loop is executed. This means that if the input and output arrays are contiguous and of the correct type so that a single 1-D loop is performed, then the flags may not be checked until all elements of the array have been calculated. Looking up these values in a thread- specific dictionary takes time which is easily ignored for all but very small arrays.</source>
          <target state="translated">最初に行われることは、スレッド固有のグローバル辞書でバッファサイズ、エラーマスク、関連するエラーオブジェクトの現在の値を調べることです。エラーマスクの状態は、エラー状態が発見されたときに何が起こるかを制御します。ハードウェアエラーフラグのチェックは、各1-Dループが実行された後にのみ実行されることに注意する必要があります。これは,入力配列と出力配列が連続しており,1 つの 1-D ループが実行されるように正しい型である場合,配列のすべての要素が計算されるまでフラグはチェックされない可能性があることを意味します.これらの値をスレッド固有の辞書で調べるには時間がかかりますが,非常に小さな配列以外は簡単に無視できます.</target>
        </trans-unit>
        <trans-unit id="eec0cb9e2856c8840ae3269c16ee7eee2770a458" translate="yes" xml:space="preserve">
          <source>The first thing to understand is that there are two conflicting conventions for indexing 2-dimensional arrays. Matrix notation uses the first index to indicate which row is being selected and the second index to indicate which column is selected. This is opposite the geometrically oriented-convention for images where people generally think the first index represents x position (i.e., column) and the second represents y position (i.e., row). This alone is the source of much confusion; matrix-oriented users and image-oriented users expect two different things with regard to indexing.</source>
          <target state="translated">まず最初に理解すべきことは、2次元配列のインデックス付けには2つの相反する慣習があるということです。行列の記法では、どの行が選択されているかを示すために最初のインデックスを使用し、どの列が選択されているかを示すために2番目のインデックスを使用します。これは、画像の幾何学的に指向された慣習とは逆で、一般的には最初のインデックスがxの位置(つまり列)を表し、2番目のインデックスがyの位置(つまり行)を表していると考えられています。これだけでも多くの混乱の原因となっています。行列指向のユーザーと画像指向のユーザーは、インデックスに関して2つの異なることを期待しています。</target>
        </trans-unit>
        <trans-unit id="43a31061c48404a506dd1e24e7517ade62790639" translate="yes" xml:space="preserve">
          <source>The fixed size of NumPy numeric types may cause overflow errors when a value requires more memory than available in the data type. For example, &lt;a href=&quot;../reference/generated/numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt; evaluates &lt;code&gt;100 * 10 ** 8&lt;/code&gt; correctly for 64-bit integers, but gives 1874919424 (incorrect) for a 32-bit integer.</source>
          <target state="translated">NumPy数値型の固定サイズは、値がデータ型で使用可能なよりも多くのメモリを必要とする場合にオーバーフローエラーを引き起こす可能性があります。たとえば、&lt;a href=&quot;../reference/generated/numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt;は64ビット整数では &lt;code&gt;100 * 10 ** 8&lt;/code&gt; 正しく評価しますが、32ビット整数では1874919424（正しくない）を返します。</target>
        </trans-unit>
        <trans-unit id="dae27e752e6250bcf53dd15428c26bfc6c4aff24" translate="yes" xml:space="preserve">
          <source>The flags member may consist of 5 bits showing how the data should be interpreted and one bit showing how the Interface should be interpreted. The data-bits are &lt;code&gt;CONTIGUOUS&lt;/code&gt; (0x1), &lt;code&gt;FORTRAN&lt;/code&gt; (0x2), &lt;code&gt;ALIGNED&lt;/code&gt; (0x100), &lt;code&gt;NOTSWAPPED&lt;/code&gt; (0x200), and &lt;code&gt;WRITEABLE&lt;/code&gt; (0x400). A final flag &lt;code&gt;ARR_HAS_DESCR&lt;/code&gt; (0x800) indicates whether or not this structure has the arrdescr field. The field should not be accessed unless this flag is present.</source>
          <target state="translated">フラグメンバーは、データの解釈方法を示す5ビットと、インターフェイスの解釈方法を示す1ビットで構成されます。データビットは、 &lt;code&gt;CONTIGUOUS&lt;/code&gt; （0x1）、 &lt;code&gt;FORTRAN&lt;/code&gt; （0x2）、 &lt;code&gt;ALIGNED&lt;/code&gt; （0x100）、 &lt;code&gt;NOTSWAPPED&lt;/code&gt; （0x200）、および &lt;code&gt;WRITEABLE&lt;/code&gt; （0x400）です。最後のフラグ &lt;code&gt;ARR_HAS_DESCR&lt;/code&gt; （0x800）は、この構造体にarrdescrフィールドがあるかどうかを示します。このフラグが存在しない限り、フィールドにアクセスしないでください。</target>
        </trans-unit>
        <trans-unit id="80d94b3bc99b1a4e8e2a1a02a0e27c0ae964964b" translate="yes" xml:space="preserve">
          <source>The flexible type array that is returned will have two fields:</source>
          <target state="translated">返されるフレキシブル型の配列は、2つのフィールドを持ちます。</target>
        </trans-unit>
        <trans-unit id="bd686ab267e11ccd8dcbb950337101a32f2aa2c7" translate="yes" xml:space="preserve">
          <source>The float printing routines use an accurate but much more computationally demanding algorithm to compute the number of digits after the decimal point.</source>
          <target state="translated">浮動小数点の印刷ルーチンは、小数点以下の桁数を計算するために、正確なアルゴリズムを使用していますが、より計算量の多いアルゴリズムを使用しています。</target>
        </trans-unit>
        <trans-unit id="9b521c71cd9d32371a352dcf94d2ff132ccb79f4" translate="yes" xml:space="preserve">
          <source>The floating-point exceptions are defined in the IEEE 754 standard &lt;a href=&quot;#r4cab4292821f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;:</source>
          <target state="translated">浮動小数点例外は、IEEE 754標準&lt;a href=&quot;#r4cab4292821f-1&quot; id=&quot;id1&quot;&gt;[1]で&lt;/a&gt;定義されています。</target>
        </trans-unit>
        <trans-unit id="25cd839f1fa0397dfd8a073d288328126b03cd06" translate="yes" xml:space="preserve">
          <source>The floor division operator &lt;code&gt;//&lt;/code&gt; was added in Python 2.2 making &lt;code&gt;//&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; equivalent operators. The default floor division operation of &lt;code&gt;/&lt;/code&gt; can be replaced by true division with &lt;code&gt;from
__future__ import division&lt;/code&gt;.</source>
          <target state="translated">フロア除算演算子 &lt;code&gt;//&lt;/code&gt; は、Python 2.2で追加され、 &lt;code&gt;//&lt;/code&gt; および &lt;code&gt;/&lt;/code&gt; 同等の演算子を作成します。 &lt;code&gt;/&lt;/code&gt; のデフォルトの床除算演算は、 &lt;code&gt;from __future__ import division&lt;/code&gt; による真の除算に置き換えることができます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
