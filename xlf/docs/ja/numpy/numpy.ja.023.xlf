<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="7f0e6c0ce58755cae988a618ed26819ae121acf3" translate="yes" xml:space="preserve">
          <source>The scipy implementation is recommended over this function: it is a proper ufunc written in C, and more than an order of magnitude faster.</source>
          <target state="translated">scipy の実装はこの関数よりも推奨されます:C で書かれた適切な ufunc であり、桁違いに高速です。</target>
        </trans-unit>
        <trans-unit id="678645818896e353218894b08bcbb6e53102fa78" translate="yes" xml:space="preserve">
          <source>The scipy.org should be a PR at &lt;a href=&quot;https://github.com/scipy/scipy.org&quot;&gt;https://github.com/scipy/scipy.org&lt;/a&gt;. The file that needs modification is &lt;code&gt;www/index.rst&lt;/code&gt;. Search for &lt;code&gt;News&lt;/code&gt;.</source>
          <target state="translated">scipy.orgは&lt;a href=&quot;https://github.com/scipy/scipy.org&quot;&gt;https://github.com/scipy/scipy.orgの&lt;/a&gt;PRである必要があります。変更が必要なファイルは &lt;code&gt;www/index.rst&lt;/code&gt; です。 &lt;code&gt;News&lt;/code&gt; 検索します。</target>
        </trans-unit>
        <trans-unit id="076d96a74fdcb13373554cd33f5faa0a5c841024" translate="yes" xml:space="preserve">
          <source>The second argument passed in to the Py_InitModule function is a structure that makes it easy to to define functions in the module. In the example given above, the mymethods structure would have been defined earlier in the file (usually right before the init{name} subroutine) to:</source>
          <target state="translated">Py_InitModule 関数に渡される第二引数は、モジュール内の関数を簡単に定義できるようにするための構造体です。上の例では、mymethods 構造体はファイルの早い段階で(通常は init{name}サブルーチンの直前で)定義されています。</target>
        </trans-unit>
        <trans-unit id="f1d1e93a16e6953d6dc31578f1bc0e4185a42885" translate="yes" xml:space="preserve">
          <source>The second element, &lt;em&gt;field_dtype&lt;/em&gt;, can be anything that can be interpreted as a data-type.</source>
          <target state="translated">2番目の要素である&lt;em&gt;field_dtype&lt;/em&gt;は、データ型として解釈できるものであれば何でも&lt;em&gt;かまいませ&lt;/em&gt;ん。</target>
        </trans-unit>
        <trans-unit id="4ebced32cc87e2c3435e9151b36d6b3c2cfaf845" translate="yes" xml:space="preserve">
          <source>The second is to set the error-handler to &amp;lsquo;log&amp;rsquo;, using &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;. Floating-point errors then trigger a call to the &amp;lsquo;write&amp;rsquo; method of the provided object.</source>
          <target state="translated">2つ目は、&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt;を使用して、エラーハンドラーを 'log'に設定することです。次に、浮動小数点エラーにより、提供されたオブジェクトの「write」メソッドの呼び出しがトリガーされます。</target>
        </trans-unit>
        <trans-unit id="6f31ccc451074791f12a3d0394615bd3d0e3cdd2" translate="yes" xml:space="preserve">
          <source>The second issue to understand is how indices correspond to the order the array is stored in memory. In Fortran the first index is the most rapidly varying index when moving through the elements of a two dimensional array as it is stored in memory. If you adopt the matrix convention for indexing, then this means the matrix is stored one column at a time (since the first index moves to the next row as it changes). Thus Fortran is considered a Column-major language. C has just the opposite convention. In C, the last index changes most rapidly as one moves through the array as stored in memory. Thus C is a Row-major language. The matrix is stored by rows. Note that in both cases it presumes that the matrix convention for indexing is being used, i.e., for both Fortran and C, the first index is the row. Note this convention implies that the indexing convention is invariant and that the data order changes to keep that so.</source>
          <target state="translated">理解すべき2番目の問題は,配列がメモリに格納されている順序にインデックスがどのように対応するかということです.Fortranでは,メモリに格納されている2次元配列の要素を移動する際に,最初のインデックスが最も急激に変化するインデックスとなります.インデックス付けに行列の規則を採用すると、行列が一度に1列ずつ格納されることを意味します(最初のインデックスが変化すると次の行に移動するので)。このようにして、Fortranは列メジャー言語と考えられています。C言語は,ちょうどその逆の規則を持っています.C言語では、メモリに格納されている配列を移動する際に、最後のインデックスが最も速く変化します。したがって,C は行メジャー言語です.行列は行によって格納されます.どちらの場合も,行列のインデックス付けの規則が使用されていることを前提としていることに注意してください.この規則は,インデックス付けの規則が不変であることと,それを維持するためにデータの順序が変化することを意味していることに注意してください.</target>
        </trans-unit>
        <trans-unit id="453559558db2eb56414a46dbdb5de2376ea80083" translate="yes" xml:space="preserve">
          <source>The second rule of broadcasting ensures that arrays with a size of 1 along a particular dimension act as if they had the size of the array with the largest shape along that dimension. The value of the array element is assumed to be the same along that dimension for the &amp;ldquo;broadcast&amp;rdquo; array.</source>
          <target state="translated">ブロードキャストの2番目のルールは、特定の次元に沿ってサイズが1の配列が、その次元に沿って最大の形状を持つ配列のサイズを持っているかのように動作することを保証します。配列要素の値は、「ブロードキャスト」配列のその次元に沿って同じであると想定されます。</target>
        </trans-unit>
        <trans-unit id="df98d64a8c2e83a203df1c7d9ac9de7f5c519eeb" translate="yes" xml:space="preserve">
          <source>The second through seventh row contain summary data that is of a different type than that which we are going to examine, so we will need to exclude that from the data with which we will work.</source>
          <target state="translated">2列目から7列目には、今回検証するデータとは異なる種類のサマリーデータが含まれているため、作業対象となるデータから除外する必要があります。</target>
        </trans-unit>
        <trans-unit id="fe0109b90f8697e3f57d897bca8c421d8285d2b1" translate="yes" xml:space="preserve">
          <source>The second way is to upload the PKG_INFO file inside the sdist dir in the web interface of PyPI. The source tarball can also be uploaded through this interface.</source>
          <target state="translated">2つ目の方法は、PyPI の Web インターフェースの sdist ディレクトリに PKG_INFO ファイルをアップロードすることです。ソースの tarball もこのインターフェイスからアップロードすることができます。</target>
        </trans-unit>
        <trans-unit id="7aabd3a3162d932dde5dce5c1f8c9f863c647d1b" translate="yes" xml:space="preserve">
          <source>The second way of indexing with booleans is more similar to integer indexing; for each dimension of the array we give a 1D boolean array selecting the slices we want:</source>
          <target state="translated">ブール値を用いたインデックス作成の2番目の方法は、整数インデックス作成に似ています。配列の各次元に対して、スライスを選択する1次元のブール値配列を与えます。</target>
        </trans-unit>
        <trans-unit id="66a3455570bd434e86d6f052ed9b9a1d4a2c4251" translate="yes" xml:space="preserve">
          <source>The sections of a function&amp;rsquo;s docstring are:</source>
          <target state="translated">関数のdocstringのセクションは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="8eb125eefbda7190ce972cb7d8270d5ae89dc7b7" translate="yes" xml:space="preserve">
          <source>The self.paths(&amp;hellip;) method is applied to all lists that may contain paths.</source>
          <target state="translated">self.paths（&amp;hellip;）メソッドは、パスを含む可能性のあるすべてのリストに適用されます。</target>
        </trans-unit>
        <trans-unit id="8c7148486ba5b770e99fd7463ec63c216dee7366" translate="yes" xml:space="preserve">
          <source>The separation between elements for each dimension (the &amp;lsquo;stride&amp;rsquo;). This does not have to be a multiple of the element size</source>
          <target state="translated">各次元の要素間の分離（「ストライド」）。これは要素サイズの倍数である必要はありません</target>
        </trans-unit>
        <trans-unit id="9cd2ff64b895aeb8d0b16f3694ac2aea08560437" translate="yes" xml:space="preserve">
          <source>The series in this context are finite sums of the corresponding polynomial basis functions multiplied by coefficients. For instance, a power series looks like</source>
          <target state="translated">この文脈での級数は、対応する多項式基底関数の有限和に係数を掛けたものです。例えば、累乗級数は次のようになります。</target>
        </trans-unit>
        <trans-unit id="9285a776c2a659ee75e7938ac17b155070381205" translate="yes" xml:space="preserve">
          <source>The series instance to be converted.</source>
          <target state="translated">変換対象のシリーズインスタンス。</target>
        </trans-unit>
        <trans-unit id="89a518ad1f6d727d2464d8f222f198c518f126e6" translate="yes" xml:space="preserve">
          <source>The series is reduced to degree &lt;code&gt;deg&lt;/code&gt; by discarding the high order terms. The value of &lt;code&gt;deg&lt;/code&gt; must be a non-negative integer.</source>
          <target state="translated">級数は、高次の項を破棄することにより、 &lt;code&gt;deg&lt;/code&gt; 度まで削減されます。 &lt;code&gt;deg&lt;/code&gt; の値は負でない整数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="adbbacc122f5859d958a7eb7009d4955c1c2c537" translate="yes" xml:space="preserve">
          <source>The series is reduced to length &lt;code&gt;size&lt;/code&gt; by discarding the high degree terms. The value of &lt;code&gt;size&lt;/code&gt; must be a positive integer.</source>
          <target state="translated">高次の項を破棄することにより、シリーズは長さ &lt;code&gt;size&lt;/code&gt; 縮小されます。 &lt;code&gt;size&lt;/code&gt; の値は正の整数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="38262a9c7d66cebff5a42640a9df021a775761be" translate="yes" xml:space="preserve">
          <source>The set of available codecs comes from the Python standard library, and may be extended at runtime. For more information, see the &lt;a href=&quot;https://docs.python.org/dev/library/codecs.html#module-codecs&quot;&gt;&lt;code&gt;codecs&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">利用可能なコーデックのセットはPython標準ライブラリからのものであり、実行時に拡張される場合があります。詳細については、&lt;a href=&quot;https://docs.python.org/dev/library/codecs.html#module-codecs&quot;&gt; &lt;code&gt;codecs&lt;/code&gt; &lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="a717e3302b8636b7790364bffe6b5a183f3f6e7f" translate="yes" xml:space="preserve">
          <source>The set of available codecs comes from the Python standard library, and may be extended at runtime. For more information, see the codecs module.</source>
          <target state="translated">利用可能なコーデックのセットはPython標準ライブラリから来ており、実行時に拡張される可能性があります。詳細はコーデックモジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="f3119f479b7378be171f9e5461ebc7ae89470f50" translate="yes" xml:space="preserve">
          <source>The set of characters that the returned character is chosen from. The default set is &amp;lsquo;GDFgdf&amp;rsquo;.</source>
          <target state="translated">返される文字が選択される文字のセット。デフォルトのセットは「GDFgdf」です。</target>
        </trans-unit>
        <trans-unit id="a3a4541aef2e0618e33ebd5e18d9c022d28bcaa8" translate="yes" xml:space="preserve">
          <source>The set of functions that convert the data of a column to a value. The converters can also be used to provide a default value for missing data: &lt;code&gt;converters = {3: lambda s: float(s or 0)}&lt;/code&gt;.</source>
          <target state="translated">列のデータを値に変換する関数のセット。コンバーターを使用して、欠損データのデフォルト値を提供することもできます： &lt;code&gt;converters = {3: lambda s: float(s or 0)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e26f5391f4384da7c676eb1e9d468550abb0eb1" translate="yes" xml:space="preserve">
          <source>The set of int values is not a subset of the uint values for types with the same number of bits, something not reflected in &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt;, but handled as a special case in PyArray_ResultType.</source>
          <target state="translated">int値のセットは、同じビット数の型のuint値のサブセットではありません。これは、&lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt; &lt;code&gt;PyArray_MinScalarType&lt;/code&gt; &lt;/a&gt;には反映されませんが、PyArray_ResultTypeでは特殊なケースとして処理されます。</target>
        </trans-unit>
        <trans-unit id="e76841686484db8628455fd162b8197749bc84c1" translate="yes" xml:space="preserve">
          <source>The set of int values is not a subset of the uint values for types with the same number of bits, something not reflected in &lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt;&lt;code&gt;min_scalar_type&lt;/code&gt;&lt;/a&gt;, but handled as a special case in &lt;a href=&quot;#numpy.result_type&quot;&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">int値のセットは、同じビット数の型のuint値のサブセットではありません。これは、&lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt; &lt;code&gt;min_scalar_type&lt;/code&gt; &lt;/a&gt;には反映されませんが、&lt;a href=&quot;#numpy.result_type&quot;&gt; &lt;code&gt;result_type&lt;/code&gt; で&lt;/a&gt;特殊なケースとして処理されます。</target>
        </trans-unit>
        <trans-unit id="561107923e2d5ef74733b059316312382b1f95e9" translate="yes" xml:space="preserve">
          <source>The set of strings corresponding to missing data.</source>
          <target state="translated">欠損データに対応する文字列の集合。</target>
        </trans-unit>
        <trans-unit id="3c3fdff23bd130c5708b43d7769884cc7638d9dc" translate="yes" xml:space="preserve">
          <source>The set of values to be used as default when the data are missing.</source>
          <target state="translated">データが欠落しているときにデフォルトで使用する値のセットです。</target>
        </trans-unit>
        <trans-unit id="40c5a46b247f5eb179525001f8ba092f80c0ed2a" translate="yes" xml:space="preserve">
          <source>The setup function for all three methods is &lt;code&gt;construct_reduce&lt;/code&gt;. This function creates a reducing loop object and fills it with parameters needed to complete the loop. All of the methods only work on ufuncs that take 2-inputs and return 1 output. Therefore, the underlying 1-D loop is selected assuming a signature of [ &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt; ] where &lt;code&gt;otype&lt;/code&gt; is the requested reduction data-type. The buffer size and error handling is then retrieved from (per-thread) global storage. For small arrays that are mis-aligned or have incorrect data-type, a copy is made so that the un-buffered section of code is used. Then, the looping strategy is selected. If there is 1 element or 0 elements in the array, then a simple looping method is selected. If the array is not mis-aligned and has the correct data-type, then strided looping is selected. Otherwise, buffered looping must be performed. Looping parameters are then established, and the return array is constructed. The output array is of a different shape depending on whether the method is reduce, accumulate, or reduceat. If an output array is already provided, then it&amp;rsquo;s shape is checked. If the output array is not C-contiguous, aligned, and of the correct data type, then a temporary copy is made with the WRITEBACKIFCOPY flag set. In this way, the methods will be able to work with a well-behaved output array but the result will be copied back into the true output array when &lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called at function completion. Finally, iterators are set up to loop over the correct axis (depending on the value of axis provided to the method) and the setup routine returns to the actual computation routine.</source>
          <target state="translated">3つのメソッドすべてのセットアップ関数は、 &lt;code&gt;construct_reduce&lt;/code&gt; です。この関数は、縮小ループオブジェクトを作成し、ループを完了するために必要なパラメーターをそのオブジェクトに入力します。すべてのメソッドは、2つの入力を取り、1つの出力を返すufuncでのみ機能します。したがって、[ &lt;code&gt;otype&lt;/code&gt; 、 &lt;code&gt;otype&lt;/code&gt; 、 &lt;code&gt;otype&lt;/code&gt; ]のシグネチャを想定して、基礎となる1次元ループが選択されます。ここで &lt;code&gt;otype&lt;/code&gt; 要求された削減データタイプです。バッファサイズとエラー処理は、（スレッドごとの）グローバルストレージから取得されます。整列が正しくない、またはデータ型が正しくない小さな配列の場合、バッファリングされていないコードのセクションが使用されるようにコピーが作成されます。次に、ループ戦略が選択されます。配列に1要素または0要素がある場合、単純なループ方法が選択されます。配列が正しく整列されておらず、正しいデータ型である場合、ストライドループが選択されます。それ以外の場合は、バッファリングされたループを実行する必要があります。次に、ループパラメーターが確立され、戻り配列が作成されます。出力配列は、メソッドがreduce、accumulate、reduceatのいずれであるかによって異なる形状になります。出力配列がすでに提供されている場合は、その形状がチェックされます。出力配列がC隣接ではなく、整列されている場合、正しいデータタイプの場合、WRITEBACKIFCOPYフラグを設定して一時コピーが作成されます。このようにして、メソッドは正常に動作する出力配列を処理できますが、結果は実際の出力配列にコピーされます。&lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;は関数の完了時に呼び出されます。最後に、（メソッドに提供された軸の値に応じて）正しい軸をループするように反復子が設定され、設定ルーチンが実際の計算ルーチンに戻ります。</target>
        </trans-unit>
        <trans-unit id="26040668927e88fa78277a9dd0406a200dc72c4f" translate="yes" xml:space="preserve">
          <source>The setup function for all three methods is &lt;code&gt;construct_reduce&lt;/code&gt;. This function creates a reducing loop object and fills it with parameters needed to complete the loop. All of the methods only work on ufuncs that take 2-inputs and return 1 output. Therefore, the underlying 1-D loop is selected assuming a signature of [ &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt; ] where &lt;code&gt;otype&lt;/code&gt; is the requested reduction data-type. The buffer size and error handling is then retrieved from (per-thread) global storage. For small arrays that are mis-aligned or have incorrect data-type, a copy is made so that the un-buffered section of code is used. Then, the looping strategy is selected. If there is 1 element or 0 elements in the array, then a simple looping method is selected. If the array is not mis-aligned and has the correct data-type, then strided looping is selected. Otherwise, buffered looping must be performed. Looping parameters are then established, and the return array is constructed. The output array is of a different shape depending on whether the method is reduce, accumulate, or reduceat. If an output array is already provided, then it&amp;rsquo;s shape is checked. If the output array is not C-contiguous, aligned, and of the correct data type, then a temporary copy is made with the WRITEBACKIFCOPY flag set. In this way, the methods will be able to work with a well-behaved output array but the result will be copied back into the true output array when &lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called at function completion. Finally, iterators are set up to loop over the correct axis (depending on the value of axis provided to the method) and the setup routine returns to the actual computation routine.</source>
          <target state="translated">3つのメソッドすべてのセットアップ関数は &lt;code&gt;construct_reduce&lt;/code&gt; です。この関数は、縮小ループオブジェクトを作成し、ループを完了するために必要なパラメーターをオブジェクトに入力します。すべてのメソッドは、2つの入力を受け取り1つの出力を返すufuncでのみ機能します。したがって、基になる1-Dループは、[ &lt;code&gt;otype&lt;/code&gt; 、 &lt;code&gt;otype&lt;/code&gt; 、 &lt;code&gt;otype&lt;/code&gt; ]の署名を想定して選択されます。ここで &lt;code&gt;otype&lt;/code&gt; 要求された削減データ型です。次に、バッファサイズとエラー処理が（スレッドごとの）グローバルストレージから取得されます。位置がずれているか、データ型が正しくない小さな配列の場合、コードのバッファリングされていないセクションが使用されるようにコピーが作成されます。次に、ループ戦略が選択されます。配列に1要素または0要素がある場合は、単純なループ方法が選択されます。配列の位置がずれておらず、データ型が正しい場合は、ストライドループが選択されます。それ以外の場合は、バッファループを実行する必要があります。次に、ループパラメータが確立され、戻り配列が作成されます。出力配列は、メソッドがreduce、accumulate、reduceatのいずれであるかによって形状が異なります。出力配列がすでに提供されている場合は、その形状がチェックされます。出力配列がC連続でない場合、整列され、正しいデータ型の場合、WRITEBACKIFCOPYフラグを設定して一時コピーが作成されます。このようにして、メソッドは正常に動作する出力配列で機能できますが、結果は次の場合に真の出力配列にコピーされます。&lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;は、関数の完了時に呼び出されます。最後に、イテレータは（メソッドに提供された軸の値に応じて）正しい軸をループするように設定され、設定ルーチンは実際の計算ルーチンに戻ります。</target>
        </trans-unit>
        <trans-unit id="780e857a060059f3e4636a17060f123b8f85b3b2" translate="yes" xml:space="preserve">
          <source>The shape (always C-style contiguous) of the sub-array as a Python tuple.</source>
          <target state="translated">Pythonのタプルとしての部分配列の形状(常にCスタイルの連続)。</target>
        </trans-unit>
        <trans-unit id="9bd591fada3b4117c12a2a1f4d689c069ec359b8" translate="yes" xml:space="preserve">
          <source>The shape and data-type of &lt;code&gt;a&lt;/code&gt; define these same attributes of the returned array.</source>
          <target state="translated">形状とデータ型返される配列のこれらの同じ属性を定義します。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea4fdc5d91eb3f313e977fbfd63ada0a25a66896" translate="yes" xml:space="preserve">
          <source>The shape and data-type of &lt;code&gt;prototype&lt;/code&gt; define these same attributes of the returned array.</source>
          <target state="translated">&lt;code&gt;prototype&lt;/code&gt; の形状とデータ型は、返される配列のこれらと同じ属性を定義します。</target>
        </trans-unit>
        <trans-unit id="de0758f703e3713cedaff1b24e8618c254649ffe" translate="yes" xml:space="preserve">
          <source>The shape of an array can be changed with various commands. Note that the following three commands all return a modified array, but do not change the original array:</source>
          <target state="translated">配列の形状は様々なコマンドで変更することができます。以下の3つのコマンドはすべて変更された配列を返しますが、元の配列は変更されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="55cbdf85b9592ec5dbddfd31ccd2c86de9452ccc" translate="yes" xml:space="preserve">
          <source>The shape of array into which the indices from &lt;code&gt;multi_index&lt;/code&gt; apply.</source>
          <target state="translated">&lt;code&gt;multi_index&lt;/code&gt; のインデックスが適用される配列の形状。</target>
        </trans-unit>
        <trans-unit id="86ea4631bc5657813d3aa6a6102c3531d8908358" translate="yes" xml:space="preserve">
          <source>The shape of each output is determined from the loop dimensions plus the output&amp;rsquo;s core dimensions</source>
          <target state="translated">各出力の形状は、ループの次元と出力のコアの次元から決定されます</target>
        </trans-unit>
        <trans-unit id="345c4787e4fcac13ce0e228d7aa0f85b31312232" translate="yes" xml:space="preserve">
          <source>The shape of the array if we are creating a new file in &amp;ldquo;write&amp;rdquo; mode, in which case this parameter is required. Otherwise, this parameter is ignored and is thus optional.</source>
          <target state="translated">「書き込み」モードで新しいファイルを作成する場合の配列の形状。この場合、このパラメーターは必須です。それ以外の場合、このパラメーターは無視されるため、オプションです。</target>
        </trans-unit>
        <trans-unit id="432cd297e760e974a03d449cad5f33c7ccb0d645" translate="yes" xml:space="preserve">
          <source>The shape of the array is preserved, but the elements are reordered.</source>
          <target state="translated">配列の形状は保持されますが,要素は並び替えられます.</target>
        </trans-unit>
        <trans-unit id="fb341212b6f41ae91b019292b043b6094616b784" translate="yes" xml:space="preserve">
          <source>The shape of the array to be iterated over.</source>
          <target state="translated">反復される配列の形状.</target>
        </trans-unit>
        <trans-unit id="a015ba13ffb4171bac494c802f272bfb87417c5d" translate="yes" xml:space="preserve">
          <source>The shape of the array to use for unraveling &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;indices&lt;/code&gt; 解明に使用する配列の形状。</target>
        </trans-unit>
        <trans-unit id="9865a6cbf282f8b0812325650b93441342efdd22" translate="yes" xml:space="preserve">
          <source>The shape of the array.</source>
          <target state="translated">配列の形状。</target>
        </trans-unit>
        <trans-unit id="634c22963834ab0f96135fc087ba541ef29a9351" translate="yes" xml:space="preserve">
          <source>The shape of the broadcasted result (only &lt;code&gt;nd&lt;/code&gt; slots are used).</source>
          <target state="translated">ブロードキャスト結果の形状（ &lt;code&gt;nd&lt;/code&gt; スロットのみが使用されます）。</target>
        </trans-unit>
        <trans-unit id="b35ba9f7409c5e79b96888dfb9fe12c59d8276ca" translate="yes" xml:space="preserve">
          <source>The shape of the desired array.</source>
          <target state="translated">希望する配列の形状。</target>
        </trans-unit>
        <trans-unit id="f8fd7f6a4e1f2e482a2f6d64364dd79594585ba9" translate="yes" xml:space="preserve">
          <source>The shape of the gamma distribution. Must be non-negative.</source>
          <target state="translated">ガンマ分布の形状。非負でなければなりません。</target>
        </trans-unit>
        <trans-unit id="40d55544c4b29b3e5cccb47aa9255a7413094e32" translate="yes" xml:space="preserve">
          <source>The shape of the grid.</source>
          <target state="translated">グリッドの形状。</target>
        </trans-unit>
        <trans-unit id="666be679bea4cf4401944751286d85ef9bcbd1ab" translate="yes" xml:space="preserve">
          <source>The shape of the new array. Defaults to &lt;code&gt;x.shape&lt;/code&gt;.</source>
          <target state="translated">新しい配列の形状。デフォルトは &lt;code&gt;x.shape&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="91c1116d9a62d56b653126b73ba2224a6c45b6f9" translate="yes" xml:space="preserve">
          <source>The shape of the output depends on the size of &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt;, and may be larger than &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; (this happens if &lt;code&gt;len(indices) &amp;gt; array.shape[axis]&lt;/code&gt;).</source>
          <target state="translated">出力の形状は&lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt;のサイズに依存し、&lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt;よりも大きくなる場合があります（これは、 &lt;code&gt;len(indices) &amp;gt; array.shape[axis]&lt;/code&gt; 場合に発生します）。</target>
        </trans-unit>
        <trans-unit id="be82fcdcf7279745a92907a11f17b40fb49cfa8e" translate="yes" xml:space="preserve">
          <source>The shape of the output depends on the size of &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt;, and may be larger than &lt;code&gt;a&lt;/code&gt; (this happens if &lt;code&gt;len(indices) &amp;gt; a.shape[axis]&lt;/code&gt;).</source>
          <target state="translated">出力の形状は&lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt;のサイズに依存し、 &lt;code&gt;a&lt;/code&gt; よりも大きくなる可能性があります（これは &lt;code&gt;len(indices) &amp;gt; a.shape[axis]&lt;/code&gt; 場合に発生します）。</target>
        </trans-unit>
        <trans-unit id="fed05fc9900417f6dd9d3b1246dc76a2025a600b" translate="yes" xml:space="preserve">
          <source>The shape of the result consists of the non-contracted axes of the first tensor, followed by the non-contracted axes of the second.</source>
          <target state="translated">結果の形状は、第1のテンソルの非拘束軸と、第2のテンソルの非拘束軸とで構成されています。</target>
        </trans-unit>
        <trans-unit id="dac69f494ba7fae89ed73806775a3c39622a5622" translate="yes" xml:space="preserve">
          <source>The shape of the return value is described above.</source>
          <target state="translated">戻り値の形状については、上記のとおりである。</target>
        </trans-unit>
        <trans-unit id="e988320cd7cc6c4a6c3dd57d84589dcf99664d33" translate="yes" xml:space="preserve">
          <source>The shape of the returned array is described above.</source>
          <target state="translated">返された配列の形状は上記の通りです。</target>
        </trans-unit>
        <trans-unit id="3b10de911cd8ce2a5b2b31e29ac9a30a0aac3857" translate="yes" xml:space="preserve">
          <source>The shape of the returned matrix is &lt;code&gt;x.shape + (order,)&lt;/code&gt;, where</source>
          <target state="translated">返される行列の形状は &lt;code&gt;x.shape + (order,)&lt;/code&gt; 。ここで、</target>
        </trans-unit>
        <trans-unit id="80077b48358a43ab7ec659d3d5fde9d46b95fb86" translate="yes" xml:space="preserve">
          <source>The shape parameter must be given if converting from a ctypes POINTER. The shape parameter is ignored if converting from a ctypes array</source>
          <target state="translated">ctypes POINTERから変換する場合は、shapeパラメータを指定する必要があります。ctypesの配列から変換する場合、このshapeパラメータは無視されます。</target>
        </trans-unit>
        <trans-unit id="fd56dfcd2507095f44b621f1654fe8bcd97f2720" translate="yes" xml:space="preserve">
          <source>The shape property is usually used to get the current shape of an array, but may also be used to reshape the array in-place by assigning a tuple of array dimensions to it. As with &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;numpy.reshape&lt;/code&gt;&lt;/a&gt;, one of the new shape dimensions can be -1, in which case its value is inferred from the size of the array and the remaining dimensions. Reshaping an array in-place will fail if a copy is required.</source>
          <target state="translated">shapeプロパティは通常、配列の現在の形状を取得するために使用されますが、配列次元のタプルをそれに割り当てることにより、配列をその場で再形成するために使用することもできます。&lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;numpy.reshape&lt;/code&gt; &lt;/a&gt;と同様に、新しい形状の次元の1つを-1にすることができます。この場合、その値は配列のサイズと残りの次元から推測されます。コピーが必要な場合、アレイをインプレースで再形成すると失敗します。</target>
        </trans-unit>
        <trans-unit id="80c5a27079e0e5c1026de7841cb52daa2c677404" translate="yes" xml:space="preserve">
          <source>The shapes of x, y, and the condition are broadcast together:</source>
          <target state="translated">x,y,条件の形が一緒に放送されます。</target>
        </trans-unit>
        <trans-unit id="052d67151c1ebcb6fedc9c36859ec35b9f5a3388" translate="yes" xml:space="preserve">
          <source>The shapes to be broadcast against each other.</source>
          <target state="translated">互いに放送される形。</target>
        </trans-unit>
        <trans-unit id="18b788b2f85a3ae45e9f183bcbf59e96d87edbee" translate="yes" xml:space="preserve">
          <source>The shifted array.</source>
          <target state="translated">シフトされた配列です。</target>
        </trans-unit>
        <trans-unit id="a03c5ad272b253bf040f55b1c50d0da307be8ac5" translate="yes" xml:space="preserve">
          <source>The sign of &lt;code&gt;x2&lt;/code&gt; is copied to &lt;code&gt;x1&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">&lt;code&gt;x2&lt;/code&gt; の符号が &lt;code&gt;x1&lt;/code&gt; にコピーされます。 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状にブロードキャスト可能でなければなりません（これが出力の形状になります）。</target>
        </trans-unit>
        <trans-unit id="9a96a866f0e16363f3d77343ed89edc57a089b06" translate="yes" xml:space="preserve">
          <source>The sign of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の符号。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="39e50e1c53e79cf4e2679a1929a8b236a790ceb1" translate="yes" xml:space="preserve">
          <source>The signature defines &amp;ldquo;core&amp;rdquo; dimensionality of input and output variables, and thereby also defines the contraction of the dimensions. The signature is represented by a string of the following format:</source>
          <target state="translated">シグネチャは、入力変数と出力変数の「コア」次元を定義し、それによって次元の縮小も定義します。署名は、次の形式の文字列で表されます。</target>
        </trans-unit>
        <trans-unit id="077a1bbb529dbf66c684eb23b600d5d4d40598cf" translate="yes" xml:space="preserve">
          <source>The signature determines how the dimensions of each input/output array are split into core and loop dimensions:</source>
          <target state="translated">シグネチャは、各入出力配列の次元をコア次元とループ次元にどのように分割するかを決定します。</target>
        </trans-unit>
        <trans-unit id="b9b7ac7b939268ddc59ac1f05c9ebd5e07bf4b21" translate="yes" xml:space="preserve">
          <source>The signature file is saved to &lt;code&gt;fib1.pyf&lt;/code&gt; (see &lt;code&gt;-h&lt;/code&gt; flag) and its contents is shown below.</source>
          <target state="translated">署名ファイルは &lt;code&gt;fib1.pyf&lt;/code&gt; に保存され（ &lt;code&gt;-h&lt;/code&gt; フラグを参照）、その内容を以下に示します。</target>
        </trans-unit>
        <trans-unit id="f03fcdecb4ad7904d6d08273575b7efc1ecd0bcc" translate="yes" xml:space="preserve">
          <source>The signature of &lt;code&gt;__array_finalize__&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;__array_finalize__&lt;/code&gt; の署名は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="51657129c6ecba9775cfcd86518eea063cc02856" translate="yes" xml:space="preserve">
          <source>The signature of &lt;code&gt;__array_ufunc__&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;__array_ufunc__&lt;/code&gt; の署名は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="7eceedf301ec9322c1f2e0e1b62bac4ce44cf0b3" translate="yes" xml:space="preserve">
          <source>The signature of a Fortran block data has the following structure:</source>
          <target state="translated">Fortranブロックデータのシグネチャは、以下のような構造になっています。</target>
        </trans-unit>
        <trans-unit id="07cca1f52e338494fc6137e9ab73032ffedaab99" translate="yes" xml:space="preserve">
          <source>The signature of a Fortran routine has the following structure:</source>
          <target state="translated">Fortranルーチンのシグネチャは次のような構造になっています。</target>
        </trans-unit>
        <trans-unit id="29c6d5e035a62abf39bca07984559eb4c2eed470" translate="yes" xml:space="preserve">
          <source>The simplest and fastest estimator. Only takes into account the data size.</source>
          <target state="translated">最もシンプルで最速の推定器。データサイズのみを考慮する。</target>
        </trans-unit>
        <trans-unit id="f68339a598fdad0949b432ba0f071db76d4162b2" translate="yes" xml:space="preserve">
          <source>The simplest case of indexing with &lt;em&gt;N&lt;/em&gt; integers returns an &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;array scalar&lt;/a&gt; representing the corresponding item. As in Python, all indices are zero-based: for the &lt;em&gt;i&lt;/em&gt;-th index</source>
          <target state="translated">&lt;em&gt;N個の&lt;/em&gt;整数を使用したインデックス付けの最も単純なケースは、対応するアイテムを表す&lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;配列スカラーを&lt;/a&gt;返します。Pythonと同様に、すべてのインデックスはゼロベースです：&lt;em&gt;i&lt;/em&gt;番目のインデックスの場合</target>
        </trans-unit>
        <trans-unit id="7ff2686b623caae27117f3c5885c7d6ae7623a3a" translate="yes" xml:space="preserve">
          <source>The simplest way to assign values to a structured array is using python tuples. Each assigned value should be a tuple of length equal to the number of fields in the array, and not a list or array as these will trigger numpy&amp;rsquo;s broadcasting rules. The tuple&amp;rsquo;s elements are assigned to the successive fields of the array, from left to right:</source>
          <target state="translated">構造化配列に値を割り当てる最も簡単な方法は、Pythonタプルを使用することです。割り当てられた各値は、配列内のフィールドの数に等しい長さのタプルである必要があり、リストや配列ではありません。これらはnumpyのブロードキャストルールをトリガーするためです。タプルの要素は、配列の連続するフィールドに左から右に割り当てられます。</target>
        </trans-unit>
        <trans-unit id="082b93c290be349a4bf83756ecca01f8d723b944" translate="yes" xml:space="preserve">
          <source>The simplest way to create a record array is with &lt;code&gt;numpy.rec.array&lt;/code&gt;:</source>
          <target state="translated">レコード配列を作成する最も簡単な方法は、 &lt;code&gt;numpy.rec.array&lt;/code&gt; を使用することです。</target>
        </trans-unit>
        <trans-unit id="47091f34475faaaa1ba4de46a8ad6549a8d5a1f2" translate="yes" xml:space="preserve">
          <source>The simulation of a C-style array is not complete for 2-d and 3-d arrays. For example, the simulated arrays of pointers cannot be passed to subroutines expecting specific, statically-defined 2-d and 3-d arrays. To pass to functions requiring those kind of inputs, you must statically define the required array and copy data.</source>
          <target state="translated">Cスタイルの配列のシミュレーションは,2-dおよび3-d配列については完全ではありません.例えば、シミュレートされたポインタの配列は、静的に定義された特定の2次元配列や3次元配列を期待してサブルーチンに渡すことはできません。そのような入力を必要とする関数に渡すには、必要な配列を静的に定義してデータをコピーしなければなりません。</target>
        </trans-unit>
        <trans-unit id="51abf12252a4d92a90b52830906a8c2bd4002537" translate="yes" xml:space="preserve">
          <source>The sinc function is</source>
          <target state="translated">sinc関数は</target>
        </trans-unit>
        <trans-unit id="ca8287ab64739fe1883b42785585fd67081d297d" translate="yes" xml:space="preserve">
          <source>The sinc function is used in various signal processing applications, including in anti-aliasing, in the construction of a Lanczos resampling filter, and in interpolation.</source>
          <target state="translated">sinc関数は、アンチエイリアシング、ランチョス再サンプリングフィルタの構築、補間など、様々な信号処理アプリケーションで使用されています。</target>
        </trans-unit>
        <trans-unit id="237e09976f401d9a2f1baabe777a697734eddddd" translate="yes" xml:space="preserve">
          <source>The sine is one of the fundamental functions of trigonometry (the mathematical study of triangles). Consider a circle of radius 1 centered on the origin. A ray comes in from the</source>
          <target state="translated">サインは三角法(三角形の数学的研究)の基本的な関数の一つである。原点を中心とする半径 1 の円を考えてみましょう。線が</target>
        </trans-unit>
        <trans-unit id="eeee63a3a1e6205f2e90fb5ed65d351e3798fee5" translate="yes" xml:space="preserve">
          <source>The sine of each element of x. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">xの各要素の正弦。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="b9c09c4d5914f0dda5c0b150c5f3b90e766bd841" translate="yes" xml:space="preserve">
          <source>The single threaded call directly uses the BitGenerator.</source>
          <target state="translated">シングル スレッドの呼び出しは、BitGenerator を直接使用します。</target>
        </trans-unit>
        <trans-unit id="4e52363a0d1aff84bc0a45f224b49ba218e2396a" translate="yes" xml:space="preserve">
          <source>The situation with numpy makes this issue yet more complicated. The internal machinery of numpy arrays is flexible enough to accept any ordering of indices. One can simply reorder indices by manipulating the internal stride information for arrays without reordering the data at all. NumPy will know how to map the new index order to the data without moving the data.</source>
          <target state="translated">numpyの状況は、この問題をさらに複雑にしています。numpy配列の内部機構は、インデックスの並び順を自由に変更できる柔軟性を持っています。配列の内部ストライド情報を操作することで、データを全く並べ替えることなくインデックスを並べ替えることができます。NumPyは、データを移動することなく、新しいインデックスの順序をデータにマッピングする方法を知っているでしょう。</target>
        </trans-unit>
        <trans-unit id="6d5ab6e4dc0fec0528be17bc5d4e3ad5f3c1a900" translate="yes" xml:space="preserve">
          <source>The size in each dimension of the output shape is the maximum of all the input sizes in that dimension.</source>
          <target state="translated">出力形状の各次元のサイズは,その次元のすべての入力サイズの最大値である.</target>
        </trans-unit>
        <trans-unit id="9a3ff85912460f4dce83d9377238c987b64400fb" translate="yes" xml:space="preserve">
          <source>The size of each dimension of the array can be passed as individual parameters or as the elements of a tuple.</source>
          <target state="translated">配列の各次元のサイズは、個々のパラメータとして、またはタプルの要素として渡すことができます。</target>
        </trans-unit>
        <trans-unit id="0f600bd12887e2a8896ddc5bed9d6833c21b9000" translate="yes" xml:space="preserve">
          <source>The size of each dimension of the array.</source>
          <target state="translated">配列の各次元のサイズ.</target>
        </trans-unit>
        <trans-unit id="53e85438a85fb68e962963fce436f922d4bad0ac" translate="yes" xml:space="preserve">
          <source>The size of each word. This should only be either &lt;a href=&quot;../../../arrays.scalars#numpy.uint32&quot;&gt;&lt;code&gt;uint32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../arrays.scalars#numpy.uint64&quot;&gt;&lt;code&gt;uint64&lt;/code&gt;&lt;/a&gt;. Strings (&lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt;, &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt;) are fine. Note that requesting &lt;a href=&quot;../../../arrays.scalars#numpy.uint64&quot;&gt;&lt;code&gt;uint64&lt;/code&gt;&lt;/a&gt; will draw twice as many bits as &lt;a href=&quot;../../../arrays.scalars#numpy.uint32&quot;&gt;&lt;code&gt;uint32&lt;/code&gt;&lt;/a&gt; for the same &lt;code&gt;n_words&lt;/code&gt;. This is a convenience for &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; arrays.</source>
          <target state="translated">各単語のサイズ。これは、&lt;a href=&quot;../../../arrays.scalars#numpy.uint32&quot;&gt; &lt;code&gt;uint32&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../../../arrays.scalars#numpy.uint64&quot;&gt; &lt;code&gt;uint64&lt;/code&gt; の&lt;/a&gt;いずれかである必要があります。文字 &lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt; （'uint32'、 &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt; ）は問題ありません。&lt;a href=&quot;../../../arrays.scalars#numpy.uint64&quot;&gt; &lt;code&gt;uint64&lt;/code&gt; &lt;/a&gt;を要求すると、同じ &lt;code&gt;n_words&lt;/code&gt; に対して&lt;a href=&quot;../../../arrays.scalars#numpy.uint32&quot;&gt; &lt;code&gt;uint32&lt;/code&gt; の&lt;/a&gt;2倍のビットが描画されることに注意してください。これは、 &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; 配列として表現するBitGenerator`にとって便利です。</target>
        </trans-unit>
        <trans-unit id="bcfaa2928c38d19614d82820fec94f09b6747c0f" translate="yes" xml:space="preserve">
          <source>The size of each word. This should only be either &lt;code&gt;uint32&lt;/code&gt; or &lt;code&gt;uint64&lt;/code&gt;. Strings (&lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt;, &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt;) are fine. Note that requesting &lt;code&gt;uint64&lt;/code&gt; will draw twice as many bits as &lt;code&gt;uint32&lt;/code&gt; for the same &lt;code&gt;n_words&lt;/code&gt;. This is a convenience for &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; arrays.</source>
          <target state="translated">各単語のサイズ。これは &lt;code&gt;uint32&lt;/code&gt; または &lt;code&gt;uint64&lt;/code&gt; のいずれかでなければなりません。文字 &lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt; （'uint32'、 &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt; ）は問題ありません。 &lt;code&gt;uint64&lt;/code&gt; を要求すると、同じ &lt;code&gt;n_words&lt;/code&gt; に対して &lt;code&gt;uint32&lt;/code&gt; の 2倍のビット数が描画されることに注意してください。これは、 &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; 配列」として表すBitGeneratorにとって便利です。</target>
        </trans-unit>
        <trans-unit id="28a984c9bdd908f87770bb977436d6a66f4306a1" translate="yes" xml:space="preserve">
          <source>The size of the array minus 1 in each dimension.</source>
          <target state="translated">配列のサイズから各次元で1を引いた値。</target>
        </trans-unit>
        <trans-unit id="c41c1278613c7ed690de9865ed90f9449e9899a0" translate="yes" xml:space="preserve">
          <source>The size of the arrays for which the returned indices will be valid.</source>
          <target state="translated">返されるインデックスが有効になる配列のサイズ。</target>
        </trans-unit>
        <trans-unit id="d186d8343ee709824ee3589500ce1f21e3851f01" translate="yes" xml:space="preserve">
          <source>The size of the dtype element in bytes.</source>
          <target state="translated">dtype要素のサイズをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="b0386b240ebd0571b8a05df9bc4fa0aef34289c1" translate="yes" xml:space="preserve">
          <source>The size, along each dimension, of the arrays for which the returned indices can be used.</source>
          <target state="translated">返されたインデックスが使用できる配列の各次元に沿ったサイズ.</target>
        </trans-unit>
        <trans-unit id="14747cd54a2f3abe194636cc52acff3e4c5bb985" translate="yes" xml:space="preserve">
          <source>The slice is a &lt;em&gt;view&lt;/em&gt; onto the original &lt;code&gt;c_arr&lt;/code&gt; data. So, when we take a view from the ndarray, we return a new ndarray, of the same class, that points to the data in the original.</source>
          <target state="translated">スライスは、元の &lt;code&gt;c_arr&lt;/code&gt; データの&lt;em&gt;ビュー&lt;/em&gt;です。したがって、ndarrayからビューを取得すると、元のデータを指す同じクラスの新しいndarrayが返されます。</target>
        </trans-unit>
        <trans-unit id="eb79b94dc729ec0da33bab5d4cd377a2401e89f0" translate="yes" xml:space="preserve">
          <source>The smaller object to check.</source>
          <target state="translated">小さい方のオブジェクトをチェックします。</target>
        </trans-unit>
        <trans-unit id="ebb19de9c6970f0b74d4dc788893b77a8ab0bd68" translate="yes" xml:space="preserve">
          <source>The smallest positive floating point number with full precision (see Notes).</source>
          <target state="translated">正の浮動小数点数の最小値で、全精度です(「注記」を参照)。</target>
        </trans-unit>
        <trans-unit id="c2b26e02affe13f7769ad145c9ef05f90265c054" translate="yes" xml:space="preserve">
          <source>The smallest positive power of the base (2) that causes overflow.</source>
          <target state="translated">オーバーフローの原因となるベース(2)の最小の正の乗。</target>
        </trans-unit>
        <trans-unit id="52e11ee8daa6593b3d750ee5dc32dda2fcbf193b" translate="yes" xml:space="preserve">
          <source>The smallest positive usable number. Type of &lt;code&gt;tiny&lt;/code&gt; is an appropriate floating point type.</source>
          <target state="translated">使用可能な正の最小数。 &lt;code&gt;tiny&lt;/code&gt; タイプは適切な浮動小数点タイプです。</target>
        </trans-unit>
        <trans-unit id="af2a8dd9510ac11ca6b963d4ee773dcefbea79aa" translate="yes" xml:space="preserve">
          <source>The smallest representable number, typically &lt;code&gt;-max&lt;/code&gt;.</source>
          <target state="translated">表現可能な最小の数値、通常 &lt;code&gt;-max&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a159db5ccf6a60aac5543438bfb54acff104da1e" translate="yes" xml:space="preserve">
          <source>The smallest representable positive number such that &lt;code&gt;1.0 + eps != 1.0&lt;/code&gt;. Type of &lt;code&gt;eps&lt;/code&gt; is an appropriate floating point type.</source>
          <target state="translated">&lt;code&gt;1.0 + eps != 1.0&lt;/code&gt; 最小の表現可能な正の数。 &lt;code&gt;eps&lt;/code&gt; のタイプは、適切な浮動小数点タイプです。</target>
        </trans-unit>
        <trans-unit id="d9321ebdb39683114ce6992ea6b9cc620e5ef480" translate="yes" xml:space="preserve">
          <source>The smallest representable positive number such that &lt;code&gt;1.0 - epsneg != 1.0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;1.0 - epsneg != 1.0&lt;/code&gt; ような、表現可能な最小の正の数。</target>
        </trans-unit>
        <trans-unit id="528bc510a2ddc52e9f705a28a08910ff17c4b364" translate="yes" xml:space="preserve">
          <source>The smart way</source>
          <target state="translated">賢い方法</target>
        </trans-unit>
        <trans-unit id="fdf4e6a27441f2bc059f1e2263f51d77fbf6e55a" translate="yes" xml:space="preserve">
          <source>The so-called F2PY directives allow using F2PY signature file constructs also in Fortran 77/90 source codes. With this feature you can skip (almost) completely intermediate signature file generations and apply F2PY directly to Fortran source codes.</source>
          <target state="translated">いわゆる F2PY ディレクティブは、Fortran 77/90 ソースコードでも F2PY 署名ファイル構造を使用することを可能にします。この機能により、(ほぼ)完全に中間の署名ファイル生成をスキップして、Fortranソースコードに直接F2PYを適用することができます。</target>
        </trans-unit>
        <trans-unit id="fff36344b5ce01b9f9447846bf8f8d0ca8bf20cf" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Chebyshev series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解は、加重二乗誤差の合計を最小化するチェビシェフシリーズ &lt;code&gt;p&lt;/code&gt; の係数です。</target>
        </trans-unit>
        <trans-unit id="d7b342b5e308288dae8bce1f9ff3a83bc7ae73a3" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Hermite series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解は、加重二乗誤差の合計を最小化するエルミート系列 &lt;code&gt;p&lt;/code&gt; の係数です。</target>
        </trans-unit>
        <trans-unit id="e858f502931c190b84210ff73e4892a2231f8dea" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the HermiteE series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解は、加重二乗誤差の合計を最小化するHermiteEシリーズ &lt;code&gt;p&lt;/code&gt; の係数です。</target>
        </trans-unit>
        <trans-unit id="cac2b42634eddb5565b046dffc57149ff94fb5e5" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Laguerre series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解は、重み付き二乗誤差の合計を最小にするラゲール級数 &lt;code&gt;p&lt;/code&gt; の係数です。</target>
        </trans-unit>
        <trans-unit id="acc0f8a9120be725868622995211f9656fc88e64" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Legendre series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解は、重み付き二乗誤差の合計を最小化するルジャンドル級数 &lt;code&gt;p&lt;/code&gt; の係数です。</target>
        </trans-unit>
        <trans-unit id="132408df155a153e982d44f873f2076aed312f9a" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the polynomial &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解は、重み付き二乗誤差の合計を最小化する多項式 &lt;code&gt;p&lt;/code&gt; の係数です。</target>
        </trans-unit>
        <trans-unit id="727489824facdfd8e793d7820b6d48d439e20ed1" translate="yes" xml:space="preserve">
          <source>The solution minimizes the squared error</source>
          <target state="translated">解は,二乗誤差を最小化します.</target>
        </trans-unit>
        <trans-unit id="905babbec7af7dc86acc47da182cc43822ce2de5" translate="yes" xml:space="preserve">
          <source>The solution will be to either:</source>
          <target state="translated">解決策はどちらかになります。</target>
        </trans-unit>
        <trans-unit id="ea7110277074b52a752297c7e2a8351687eb1a36" translate="yes" xml:space="preserve">
          <source>The solutions are computed using LAPACK routine &lt;code&gt;_gesv&lt;/code&gt;.</source>
          <target state="translated">解はLAPACKルーチン &lt;code&gt;_gesv&lt;/code&gt; を使用して計算されます。</target>
        </trans-unit>
        <trans-unit id="2324f65c28650d2bb749a64e0d6878a8a423096e" translate="yes" xml:space="preserve">
          <source>The sort order for complex numbers is lexicographic. If both the real and imaginary parts are non-nan then the order is determined by the real parts except when they are equal, in which case the order is determined by the imaginary parts.</source>
          <target state="translated">複素数のソート順は辞書的なものである.実部と虚部の両方が非ナンである場合は、実部が等しい場合を除いて実部によって順序が決定されますが、その場合は虚部によって順序が決定されます。</target>
        </trans-unit>
        <trans-unit id="94fa27637cf0004fe36c14f580e547f6911b6110" translate="yes" xml:space="preserve">
          <source>The sorted unique values.</source>
          <target state="translated">ソートされた一意の値。</target>
        </trans-unit>
        <trans-unit id="c380c0b74f7e3ca7cbe5b2bb1b45003f6fb70837" translate="yes" xml:space="preserve">
          <source>The sorting algorithm used.</source>
          <target state="translated">使用されているソートアルゴリズム。</target>
        </trans-unit>
        <trans-unit id="e03d33ebb9f3232a066dd4b0991b32cb56211358" translate="yes" xml:space="preserve">
          <source>The source and destination arrays during assignment.</source>
          <target state="translated">代入時のソース配列とデスティネーション配列。</target>
        </trans-unit>
        <trans-unit id="2132b1a1146e5e5ced071e842080bf9a009b6944" translate="yes" xml:space="preserve">
          <source>The source array.</source>
          <target state="translated">ソース配列です。</target>
        </trans-unit>
        <trans-unit id="f3a4e63ab5a7b2b3732df5942d36a724d124f0ea" translate="yes" xml:space="preserve">
          <source>The source code is only returned for objects written in Python.</source>
          <target state="translated">ソースコードはPythonで書かれたオブジェクトに対してのみ返されます。</target>
        </trans-unit>
        <trans-unit id="cf16b74745b78ed96effaeceb909805fb279ce98" translate="yes" xml:space="preserve">
          <source>The source code is only returned for objects written in Python. Many functions and classes are defined in C and will therefore not return useful information.</source>
          <target state="translated">ソースコードが返されるのは、Pythonで書かれたオブジェクトのみです。多くの関数やクラスはC言語で定義されているため、有用な情報は返されません。</target>
        </trans-unit>
        <trans-unit id="809a1cfd22069f38c46105c92eebf5c576bb4207" translate="yes" xml:space="preserve">
          <source>The source string can be any valid Fortran code. If you want to save the extension-module source code then a suitable file-name can be provided by the &lt;code&gt;source_fn&lt;/code&gt; keyword to the compile function.</source>
          <target state="translated">ソース文字列は、任意の有効なFortranコードにすることができます。拡張モジュールのソースコードを保存する場合は、適切なファイル名を &lt;code&gt;source_fn&lt;/code&gt; キーワードでコンパイル関数に指定できます。</target>
        </trans-unit>
        <trans-unit id="cd5904ef77ea8bffca88dd379e736043b3ab2537" translate="yes" xml:space="preserve">
          <source>The spacing between sample points when &lt;code&gt;x&lt;/code&gt; is None. The default is 1.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; がNoneの場合のサンプルポイント間の間隔。デフォルトは1です。</target>
        </trans-unit>
        <trans-unit id="f3c0291e43c18442ce997268f6d827c51450c140" translate="yes" xml:space="preserve">
          <source>The spacing of values of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の値の間隔。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="90f7163cd42de5312873857f6e49d754d0181393" translate="yes" xml:space="preserve">
          <source>The specific algorithm used is as follows.</source>
          <target state="translated">具体的なアルゴリズムは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="87dcde88b185fa2a9572c4ddf0c6760b6d6e72a4" translate="yes" xml:space="preserve">
          <source>The specified line is given by &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">指定された行は、 &lt;code&gt;off + scl*x&lt;/code&gt; 指定されます。</target>
        </trans-unit>
        <trans-unit id="80beaa85dfa05c582a58cbd93778b4e21b5c2873" translate="yes" xml:space="preserve">
          <source>The square root of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; was a scalar, so is &lt;code&gt;out&lt;/code&gt;, otherwise an array is returned.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の平方根。 &lt;code&gt;x&lt;/code&gt; がスカラーだった場合は、 &lt;code&gt;out&lt;/code&gt; です。そうでない場合は、配列が返されます。</target>
        </trans-unit>
        <trans-unit id="6ffe340425612aa0e424be1bcdd9b7a397555dd0" translate="yes" xml:space="preserve">
          <source>The stacked array has one more dimension than the input arrays.</source>
          <target state="translated">積層された配列は,入力配列よりも1つ多くの次元を持っています.</target>
        </trans-unit>
        <trans-unit id="b5df163136221ee565809e31a5ec5ce477690b37" translate="yes" xml:space="preserve">
          <source>The standard array can have 24 different data types (and has some support for adding your own types). These data types all have an enumerated type, an enumerated type-character, and a corresponding array scalar Python type object (placed in a hierarchy). There are also standard C typedefs to make it easier to manipulate elements of the given data type. For the numeric types, there are also bit-width equivalent C typedefs and named typenumbers that make it easier to select the precision desired.</source>
          <target state="translated">標準の配列は24種類のデータ型を持つことができます(独自の型を追加するためのサポートもあります)。これらのデータ型はすべて、列挙型、列挙型文字列、対応する配列スカラPython型オブジェクト(階層に配置されています)を持っています。また、与えられたデータ型の要素をより簡単に操作できるようにするための標準的なCの型定義もあります。数値型については、ビット幅に相当するCの型定義や名前付きの型数もあり、希望する精度を簡単に選択できるようになっています。</target>
        </trans-unit>
        <trans-unit id="45b18b5cfbbed3fbae9c681cc6f3c1fa70483591" translate="yes" xml:space="preserve">
          <source>The standard casting rules ensure that a scalar cannot up-cast an array unless the scalar is of a fundamentally different kind of data (i.e. under a different hierarchy in the data type hierarchy) then the array:</source>
          <target state="translated">標準的なキャストルールでは,スカラが配列とは根本的に異なる種類のデータ(つまり,データ型の階層が異なる)でない限り,スカラが配列をアップキャストすることはできないことが保証されています.</target>
        </trans-unit>
        <trans-unit id="3b087bfb5ae783fa5041fbcb80716e85b4cfcd9d" translate="yes" xml:space="preserve">
          <source>The standard deviation is the square root of the average of the squared deviations from the mean, i.e., &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt;.</source>
          <target state="translated">標準偏差は、平均からの偏差の二乗の平均の平方根です。つまり、 &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="57c54b3c6804893f71da6c87373c7bbb983d07a9" translate="yes" xml:space="preserve">
          <source>The standard deviation is the square root of the average of the squared deviations from the mean, i.e., &lt;code&gt;std = sqrt(mean(x))&lt;/code&gt;, where &lt;code&gt;x = abs(a - a.mean())**2&lt;/code&gt;.</source>
          <target state="translated">標準偏差は、平均からの偏差の2乗の平均の平方根です。つまり、 &lt;code&gt;std = sqrt(mean(x))&lt;/code&gt; 、ここで &lt;code&gt;x = abs(a - a.mean())**2&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3f057ac9f65af78fe632de7c8031e6f6e2ae80dc" translate="yes" xml:space="preserve">
          <source>The standard deviation is the square root of the average of the squared deviations from the mean: &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt;.</source>
          <target state="translated">標準偏差は、平均からの偏差の二乗の平均の平方根です &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9194bef8dfee2642aab9789d8b2c457a98f783af" translate="yes" xml:space="preserve">
          <source>The standard rules of sequence slicing apply to basic slicing on a per-dimension basis (including using a step index). Some useful concepts to remember include:</source>
          <target state="translated">シーケンス・スライシングの標準的なルールは、基本的なスライシングを寸法ごとに適用します(ステップ・インデックスの使用を含む)。覚えておくと便利な概念をいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="903735d28aa358318c996f0fbe6f9bd887af58b8" translate="yes" xml:space="preserve">
          <source>The start of the data within the data buffer (an offset relative to the beginning of the data buffer).</source>
          <target state="translated">データバッファ内のデータの開始点(データバッファの先頭からの相対的なオフセット)。</target>
        </trans-unit>
        <trans-unit id="df2af17caf9f66a81db3bc6a51eb1b52d78258be" translate="yes" xml:space="preserve">
          <source>The start of type numbers used for Custom Data types.</source>
          <target state="translated">カスタムデータ型に使用される型番号の先頭です。</target>
        </trans-unit>
        <trans-unit id="e63c738294e147bc42d8454a2cacbd481d845725" translate="yes" xml:space="preserve">
          <source>The starting value for this product. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">この製品の開始値。詳細については、&lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b49e967087e1769cf1a280ea97d2d8fd93d40ef9" translate="yes" xml:space="preserve">
          <source>The starting value of the sequence.</source>
          <target state="translated">シーケンスの開始値。</target>
        </trans-unit>
        <trans-unit id="be3a2f4f7af9d19db4503332628441741d474403" translate="yes" xml:space="preserve">
          <source>The state of the returned big generator is jumped as-if 2**(128 * jumps) random numbers have been generated.</source>
          <target state="translated">2**(128*ジャンプ)の乱数が生成されていれば、ビッグジェネレータの状態がジャンプされます。</target>
        </trans-unit>
        <trans-unit id="9f0543dedf6d1409b4f87e0823027e644cab05a9" translate="yes" xml:space="preserve">
          <source>The step size is phi-1 when multiplied by 2**128 where phi is the golden ratio.</source>
          <target state="translated">ステップサイズは、2**128を乗じたときのphi-1であり、ここでphiは黄金比である。</target>
        </trans-unit>
        <trans-unit id="ed6404a00884e4a1c814b4fe32b4f8e4142164f0" translate="yes" xml:space="preserve">
          <source>The steps are:</source>
          <target state="translated">ステップがあります。</target>
        </trans-unit>
        <trans-unit id="da99252ecc9a954c9ea523c42dd589060111b276" translate="yes" xml:space="preserve">
          <source>The strides of the array. How many bytes needed to jump to the next element in each dimension.</source>
          <target state="translated">配列のストライド。各次元の次の要素にジャンプするのに必要なバイト数。</target>
        </trans-unit>
        <trans-unit id="6bea4f23f51bf1c5c1b134b3c31652eb62271512" translate="yes" xml:space="preserve">
          <source>The strides of the new array. Defaults to &lt;code&gt;x.strides&lt;/code&gt;.</source>
          <target state="translated">新しい配列のストライド。デフォルトは &lt;code&gt;x.strides&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0e7d4c32101a82d4a575c51fa47c579d84a90ccb" translate="yes" xml:space="preserve">
          <source>The string character corresponding to the scalar type.</source>
          <target state="translated">スカラー型に対応する文字列文字。</target>
        </trans-unit>
        <trans-unit id="280cdfd9e5006321af13d97ed1dea840dc6157dc" translate="yes" xml:space="preserve">
          <source>The string representation of a structured datatype is shown in the &amp;ldquo;list of tuples&amp;rdquo; form if possible, otherwise numpy falls back to using the more general dictionary form.</source>
          <target state="translated">構造化データ型の文字列表現は、可能であれば「タプルのリスト」形式で表示されます。それ以外の場合、numpyはより一般的な辞書形式の使用にフォールバックします。</target>
        </trans-unit>
        <trans-unit id="56e3689374848f3f51b64947b16bec4c3ea61c9e" translate="yes" xml:space="preserve">
          <source>The string representation of an array.</source>
          <target state="translated">配列の文字列表現。</target>
        </trans-unit>
        <trans-unit id="3e6678ed1379ae4a29d74cf130ddd533a3d54faa" translate="yes" xml:space="preserve">
          <source>The string representation of the floating point value</source>
          <target state="translated">浮動小数点値の文字列表現</target>
        </trans-unit>
        <trans-unit id="a73fe28c8757ab0f0da0e2f4243de7dc56a5b482" translate="yes" xml:space="preserve">
          <source>The string separating numbers in the data; extra whitespace between elements is also ignored.</source>
          <target state="translated">データ内の数値を区切る文字列、要素間の余分な空白も無視されます。</target>
        </trans-unit>
        <trans-unit id="3dd7799be74e76e0df59b70e60e88893f1e79944" translate="yes" xml:space="preserve">
          <source>The string to load.</source>
          <target state="translated">ロードする文字列。</target>
        </trans-unit>
        <trans-unit id="fe1a3737165141949913fff90aaf8e13cf8c53af" translate="yes" xml:space="preserve">
          <source>The string to test for equality against the expected string.</source>
          <target state="translated">期待される文字列との等質性をテストするための文字列。</target>
        </trans-unit>
        <trans-unit id="abd4042bc9b171ded494b956ae5b9d9577f995c1" translate="yes" xml:space="preserve">
          <source>The string used to separate values. By default, any consecutive whitespaces act as delimiter. An integer or sequence of integers can also be provided as width(s) of each field.</source>
          <target state="translated">値を区切るために使用する文字列。デフォルトでは、連続した空白が区切り文字として機能します。各フィールドの幅として、整数または整数のシーケンスを指定することもできます。</target>
        </trans-unit>
        <trans-unit id="af52fb130d33fe69945cefb6f52e5cf4ca3f8766" translate="yes" xml:space="preserve">
          <source>The string used to separate values. For backwards compatibility, byte strings will be decoded as &amp;lsquo;latin1&amp;rsquo;. The default is whitespace.</source>
          <target state="translated">値を区切るために使用される文字列。下位互換性のために、バイト文字列は「latin1」としてデコードされます。デフォルトは空白です。</target>
        </trans-unit>
        <trans-unit id="9d54c543599ad13e3bb6b6bb26859ee068b06992" translate="yes" xml:space="preserve">
          <source>The strings produced by the Python float.hex method can be used as input for floats.</source>
          <target state="translated">Pythonのfloat.hexメソッドで生成された文字列をfloatの入力として使用することができます。</target>
        </trans-unit>
        <trans-unit id="4e980753b02b50913c2b5e0d5a5fa0dd49eac85d" translate="yes" xml:space="preserve">
          <source>The structured dtype of the output array</source>
          <target state="translated">出力配列の構造化された dtype</target>
        </trans-unit>
        <trans-unit id="05daa592464e6166b985d1ccf981f505cab14119" translate="yes" xml:space="preserve">
          <source>The sub-arrays whose main diagonals we just obtained; note that each corresponds to fixing the right-most (column) axis, and that the diagonals are &amp;ldquo;packed&amp;rdquo; in rows.</source>
          <target state="translated">主な対角線を取得したサブ配列。それぞれが右端（列）の軸の固定に対応し、対角線が行に「パック」されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="032fe52a10dbbb96d8d2155ebf017c5a37d540fb" translate="yes" xml:space="preserve">
          <source>The sub-diagonal at and below which the array is filled. &lt;code&gt;k&lt;/code&gt; = 0 is the main diagonal, while &lt;code&gt;k&lt;/code&gt; &amp;lt; 0 is below it, and &lt;code&gt;k&lt;/code&gt; &amp;gt; 0 is above. The default is 0.</source>
          <target state="translated">配列が塗りつぶされるその下の対角線以下。 &lt;code&gt;k&lt;/code&gt; = 0は主対角線で、 &lt;code&gt;k&lt;/code&gt; &amp;lt;0はその下、 &lt;code&gt;k&lt;/code&gt; &amp;gt; 0は上です。デフォルトは0です。</target>
        </trans-unit>
        <trans-unit id="8e6c361139d8c7c0ac565e0bf2e23b72d7fed91d" translate="yes" xml:space="preserve">
          <source>The subarrays &lt;code&gt;grid[k]&lt;/code&gt; contains the N-D array of indices along the &lt;code&gt;k-th&lt;/code&gt; axis. Explicitly:</source>
          <target state="translated">サブ配列 &lt;code&gt;grid[k]&lt;/code&gt; には、 &lt;code&gt;k-th&lt;/code&gt; 軸に沿ったインデックスのND配列が含まれています。明示的に：</target>
        </trans-unit>
        <trans-unit id="c73621fe8c8d7b0663f28b8d7e7772440297f53c" translate="yes" xml:space="preserve">
          <source>The subscripts string is a comma-separated list of subscript labels, where each label refers to a dimension of the corresponding operand. Whenever a label is repeated it is summed, so &lt;code&gt;np.einsum('i,i', a, b)&lt;/code&gt; is equivalent to &lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt;&lt;code&gt;np.inner(a,b)&lt;/code&gt;&lt;/a&gt;. If a label appears only once, it is not summed, so &lt;code&gt;np.einsum('i', a)&lt;/code&gt; produces a view of &lt;code&gt;a&lt;/code&gt; with no changes. A further example &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; describes traditional matrix multiplication and is equivalent to &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;np.matmul(a,b)&lt;/code&gt;&lt;/a&gt;. Repeated subscript labels in one operand take the diagonal. For example, &lt;code&gt;np.einsum('ii', a)&lt;/code&gt; is equivalent to &lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt;&lt;code&gt;np.trace(a)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">下付き文字列は、下付きラベルのコンマ区切りのリストです。各ラベルは対応するオペランドの次元を参照します。ラベルが繰り返される場合は常に合計されるため、 &lt;code&gt;np.einsum('i,i', a, b)&lt;/code&gt; は&lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt; &lt;code&gt;np.inner(a,b)&lt;/code&gt; &lt;/a&gt; a、b）と同等です。ラベルは一度しか表示された場合は、それが合計されていないので、 &lt;code&gt;np.einsum('i', a)&lt;/code&gt; のビュー生成変更なしに。さらなる例 &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; は、従来の行列乗算を説明して&lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;np.matmul(a,b)&lt;/code&gt; &lt;/a&gt;と同等です。 1つのオペランドで繰り返される添え字ラベルは対角になります。たとえば、 &lt;code&gt;np.einsum('ii', a)&lt;/code&gt; は&lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt; &lt;code&gt;np.trace(a)&lt;/code&gt; &lt;/a&gt;と同等です。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="67e5fbff128f593f5baf173c69fe839b3262add2" translate="yes" xml:space="preserve">
          <source>The substring to search for.</source>
          <target state="translated">検索する部分文字列。</target>
        </trans-unit>
        <trans-unit id="965c999c4a333ea7538f32117fa173b48c1340d4" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">要素ごとの &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の合計。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="6ad40e475222ea9afc0452e8c7fd45129517c8c0" translate="yes" xml:space="preserve">
          <source>The sum of an empty array is the neutral element 0:</source>
          <target state="translated">空の配列の和は中立要素0です。</target>
        </trans-unit>
        <trans-unit id="d51acbb68e0ec9e47200775b381bf1325a23c32a" translate="yes" xml:space="preserve">
          <source>The sum of the inputs. If either input is a poly1d object, then the output is also a poly1d object. Otherwise, it is a 1D array of polynomial coefficients from highest to lowest degree.</source>
          <target state="translated">入力の合計。どちらかの入力がポリ1次元オブジェクトの場合、出力もポリ1次元オブジェクトとなります。そうでない場合は、最高次数から最低次数までの多項式係数の1次元配列です。</target>
        </trans-unit>
        <trans-unit id="a83a6a324c47c50fcc7b05d36f9de3513626990f" translate="yes" xml:space="preserve">
          <source>The suppression behavior is selected with the &lt;code&gt;axis&lt;/code&gt; parameter.</source>
          <target state="translated">抑制動作は &lt;code&gt;axis&lt;/code&gt; パラメーターで選択されます。</target>
        </trans-unit>
        <trans-unit id="ac5e9039faffaa312745861609180dbee345923d" translate="yes" xml:space="preserve">
          <source>The symbol suffix avoids the symbol name clashes between 32-bit and 64-bit BLAS/LAPACK libraries.</source>
          <target state="translated">シンボルサフィックスは、32ビットと64ビットのBLAS/LAPACKライブラリ間のシンボル名の衝突を回避します。</target>
        </trans-unit>
        <trans-unit id="d22d2ca3e9d62707042d4e5eab8a754482cb7bf9" translate="yes" xml:space="preserve">
          <source>The syntax of signature files is presented below.</source>
          <target state="translated">署名ファイルの構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="dc008fb51ab0096c0ab2810136d6a94b39d8b6ae" translate="yes" xml:space="preserve">
          <source>The syntax specification for signature files (.pyf files) is borrowed from the Fortran 90/95 language specification. Almost all Fortran 90/95 standard constructs are understood, both in free and fixed format (recall that Fortran 77 is a subset of Fortran 90/95). F2PY introduces also some extensions to Fortran 90/95 language specification that help designing Fortran to Python interface, make it more &amp;ldquo;Pythonic&amp;rdquo;.</source>
          <target state="translated">署名ファイル（.pyfファイル）の構文仕様は、Fortran90 / 95言語仕様から借用されています。ほとんどすべてのFortran90 / 95標準構造は、自由形式と固定形式の両方で理解されます（Fortran77はFortran90 / 95のサブセットであることを思い出してください）。F2PYは、Fortran 90/95言語仕様にいくつかの拡張機能も導入しており、FortranからPythonへのインターフェースの設計を支援し、より「Pythonic」にします。</target>
        </trans-unit>
        <trans-unit id="4cac57b443c7e139444cef039c708d06cc974fbe" translate="yes" xml:space="preserve">
          <source>The t test is based on an assumption that the data come from a Normal distribution. The t test provides a way to test whether the sample mean (that is the mean calculated from the data) is a good estimate of the true mean.</source>
          <target state="translated">t 検定は,データが正規分布から来ているという仮定に基づいている.t 検定は,標本平均(データから計算された平均)が真の平均の良い推定値であるかどうかを検定する方法を提供する.</target>
        </trans-unit>
        <trans-unit id="09daeca7b9767c35345c4b41aa696722f6d0ab8e" translate="yes" xml:space="preserve">
          <source>The table below gives rough equivalents for some common MATLAB expressions. These are similar expressions, not equivalents. For details, see the &lt;a href=&quot;../reference/index#reference&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">次の表は、いくつかの一般的なMATLAB式の大まかな同等物を示しています。これらは類似した表現であり、同等のものではありません。詳細については、&lt;a href=&quot;../reference/index#reference&quot;&gt;ドキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9a7fcb5dad38e6ecd0517ba513e487ccaccafb31" translate="yes" xml:space="preserve">
          <source>The table below gives rough equivalents for some common MATLAB&amp;reg; expressions. &lt;strong&gt;These are not exact equivalents&lt;/strong&gt;, but rather should be taken as hints to get you going in the right direction. For more detail read the built-in documentation on the NumPy functions.</source>
          <target state="translated">次の表は、いくつかの一般的なMATLAB&amp;reg;式の大まかな同等物を示しています。&lt;strong&gt;これらは完全に同等&lt;/strong&gt;で&lt;strong&gt;はありません&lt;/strong&gt;が、正しい方向に進むためのヒントとしてとらえる必要があります。詳細については、NumPy関数の組み込みドキュメントをお読みください。</target>
        </trans-unit>
        <trans-unit id="1feedf873323b1df0d515f29065f1cceac91a5f6" translate="yes" xml:space="preserve">
          <source>The template language blocks are delimited by &lt;code&gt;/**begin repeat&lt;/code&gt; and &lt;code&gt;/**end repeat**/&lt;/code&gt; lines, which may also be nested using consecutively numbered delimiting lines such as &lt;code&gt;/**begin repeat1&lt;/code&gt; and &lt;code&gt;/**end repeat1**/&lt;/code&gt;:</source>
          <target state="translated">テンプレート言語ブロックは、 &lt;code&gt;/**begin repeat&lt;/code&gt; および &lt;code&gt;/**end repeat**/&lt;/code&gt; 行で区切られます。これらの行は、 &lt;code&gt;/**begin repeat1&lt;/code&gt; や &lt;code&gt;/**end repeat1**/&lt;/code&gt; などの連続番号の区切り線を使用してネストすることもできます。</target>
        </trans-unit>
        <trans-unit id="2a419cbcd05b123b547d845ae2a3bfd3fd96fc50" translate="yes" xml:space="preserve">
          <source>The tensor dot product of the input.</source>
          <target state="translated">入力のテンソル点積。</target>
        </trans-unit>
        <trans-unit id="babafa633a1d5ffe1e85308352efa2b576e666e1" translate="yes" xml:space="preserve">
          <source>The term broadcasting describes how numpy treats arrays with different shapes during arithmetic operations. Subject to certain constraints, the smaller array is &amp;ldquo;broadcast&amp;rdquo; across the larger array so that they have compatible shapes. Broadcasting provides a means of vectorizing array operations so that looping occurs in C instead of Python. It does this without making needless copies of data and usually leads to efficient algorithm implementations. There are, however, cases where broadcasting is a bad idea because it leads to inefficient use of memory that slows computation.</source>
          <target state="translated">ブロードキャストという用語は、numpyが算術演算中にさまざまな形状の配列を処理する方法を説明しています。特定の制約に従い、小さい方のアレイは大きい方のアレイ全体に「ブロードキャスト」されるため、互換性のある形状になります。ブロードキャストは、PythonではなくCでループが発生するように、配列操作をベクトル化する手段を提供します。これは、データの不必要なコピーを作成することなくこれを行い、通常、効率的なアルゴリズムの実装につながります。ただし、ブロードキャストはメモリの非効率的な使用につながり、計算が遅くなるため、悪い考えである場合があります。</target>
        </trans-unit>
        <trans-unit id="0567674780e936db24c51c4154cb1e7bb19a5fb1" translate="yes" xml:space="preserve">
          <source>The test can also be inverted:</source>
          <target state="translated">また、試験は反転も可能です。</target>
        </trans-unit>
        <trans-unit id="a043640318788c216d9c35c72474b86e64a58875" translate="yes" xml:space="preserve">
          <source>The test is equivalent to &lt;code&gt;allclose(actual, desired, rtol, atol)&lt;/code&gt; (note that &lt;code&gt;allclose&lt;/code&gt; has different default values). It compares the difference between &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; to &lt;code&gt;atol + rtol * abs(desired)&lt;/code&gt;.</source>
          <target state="translated">このテストは &lt;code&gt;allclose(actual, desired, rtol, atol)&lt;/code&gt; と同等です（ &lt;code&gt;allclose&lt;/code&gt; のデフォルト値は異なることに注意してください）。 &lt;code&gt;actual&lt;/code&gt; &lt;code&gt;atol + rtol * abs(desired)&lt;/code&gt; と &lt;code&gt;desired&lt;/code&gt; 値の差をatol + rtol * abs（desired）と比較します。</target>
        </trans-unit>
        <trans-unit id="d949a99e166ed49b879032942f22bd239ac73b6e" translate="yes" xml:space="preserve">
          <source>The test is marked as skipped if &lt;code&gt;SkipMyTest&lt;/code&gt; evaluates to nonzero, and the message in verbose test output is the second argument given to &lt;code&gt;skipif&lt;/code&gt;. Similarly, a test can be marked as a known failure by using &lt;code&gt;xfail&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;SkipMyTest&lt;/code&gt; の評価がゼロ以外の場合、テストはスキップされたとマークされ、詳細なテスト出力のメッセージは &lt;code&gt;skipif&lt;/code&gt; に 2番目の引数として与えられます。同様に、 &lt;code&gt;xfail&lt;/code&gt; を使用して、テストを既知の失敗としてマークできます。</target>
        </trans-unit>
        <trans-unit id="7223f3e04a5764585f35605ea5b6d016c41f2fa7" translate="yes" xml:space="preserve">
          <source>The test method may take two or more arguments; the first &lt;code&gt;label&lt;/code&gt; is a string specifying what should be tested and the second &lt;code&gt;verbose&lt;/code&gt; is an integer giving the level of output verbosity. See the docstring &lt;a href=&quot;#numpy.test&quot;&gt;&lt;code&gt;numpy.test&lt;/code&gt;&lt;/a&gt; for details. The default value for &lt;code&gt;label&lt;/code&gt; is &amp;lsquo;fast&amp;rsquo; - which will run the standard tests. The string &amp;lsquo;full&amp;rsquo; will run the full battery of tests, including those identified as being slow to run. If &lt;code&gt;verbose&lt;/code&gt; is 1 or less, the tests will just show information messages about the tests that are run; but if it is greater than 1, then the tests will also provide warnings on missing tests. So if you want to run every test and get messages about which modules don&amp;rsquo;t have tests:</source>
          <target state="translated">テストメソッドは2つ以上の引数を取ることができます。最初の &lt;code&gt;label&lt;/code&gt; はテスト対象を指定する文字列で、2番目の &lt;code&gt;verbose&lt;/code&gt; は出力の詳細レベルを示す整数です。ドキュメント文字列を参照してください&lt;a href=&quot;#numpy.test&quot;&gt; &lt;code&gt;numpy.test&lt;/code&gt; &lt;/a&gt;詳細については、を。 &lt;code&gt;label&lt;/code&gt; のデフォルト値は「fast」です。これは標準テストを実行します。文字列「full」は、実行が遅いと識別されたテストを含む、一連のテストを実行します。 &lt;code&gt;verbose&lt;/code&gt; が1以下の場合、テストには実行されたテストに関する情報メッセージのみが表示されます。ただし、1より大きい場合、テストは欠落しているテストに関する警告も提供します。したがって、すべてのテストを実行して、テストがないモジュールに関するメッセージを取得する場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="85bd6917449fe181340a2938e0dac494fbfea5fe" translate="yes" xml:space="preserve">
          <source>The test method may take two or more arguments; the first, &lt;code&gt;label&lt;/code&gt; is a string specifying what should be tested and the second, &lt;code&gt;verbose&lt;/code&gt; is an integer giving the level of output verbosity. See the docstring for numpy.test for details. The default value for &lt;code&gt;label&lt;/code&gt; is &amp;lsquo;fast&amp;rsquo; - which will run the standard tests. The string &amp;lsquo;full&amp;rsquo; will run the full battery of tests, including those identified as being slow to run. If &lt;code&gt;verbose&lt;/code&gt; is 1 or less, the tests will just show information messages about the tests that are run; but if it is greater than 1, then the tests will also provide warnings on missing tests. So if you want to run every test and get messages about which modules don&amp;rsquo;t have tests:</source>
          <target state="translated">テストメソッドは2つ以上の引数を取る場合があります。最初の &lt;code&gt;label&lt;/code&gt; はテスト対象を指定する文字列で、2番目の &lt;code&gt;verbose&lt;/code&gt; は出力の詳細度のレベルを示す整数です。詳細については、numpy.testのdocstringを参照してください。 &lt;code&gt;label&lt;/code&gt; のデフォルト値は 'fast'で、標準のテストを実行します。文字列 'full'は、実行が遅いと識別されたものを含め、一連のテストをすべて実行します。場合は &lt;code&gt;verbose&lt;/code&gt; 1以下であり、テストは単に実行されるテストに関する情報メッセージが表示されます。しかし、それが1より大きい場合、テストは欠落しているテストに関する警告も提供します。したがって、すべてのテストを実行して、どのモジュールにテストがないかに関するメッセージを取得する場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="03733f354e779af14d028cdbdf0476c16657d14e" translate="yes" xml:space="preserve">
          <source>The test to label as slow.</source>
          <target state="translated">遅いとレッテルを貼るテスト。</target>
        </trans-unit>
        <trans-unit id="28bda9f13cb5fd35de4d1871d5d1a6b158a05b66" translate="yes" xml:space="preserve">
          <source>The test verifies identical shapes and that the elements of &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; satisfy.</source>
          <target state="translated">テストは、同一の形状を検証し、 &lt;code&gt;actual&lt;/code&gt; の要素と &lt;code&gt;desired&lt;/code&gt; 要素が満たすことを検証します。</target>
        </trans-unit>
        <trans-unit id="a7fabe2aaa71feebc60270bd4d75ad9164f05bed" translate="yes" xml:space="preserve">
          <source>The test verifies that the elements of &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; satisfy.</source>
          <target state="translated">テストでは、 &lt;code&gt;actual&lt;/code&gt; の要素と &lt;code&gt;desired&lt;/code&gt; 要素が満たされていることを確認します。</target>
        </trans-unit>
        <trans-unit id="bf9247f40709953bae5128ab011a3c6a23e1bb6b" translate="yes" xml:space="preserve">
          <source>The three dimensional series is evaluated at the points &lt;code&gt;(x, y, z)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; must have the same shape. If any of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, or &lt;code&gt;z&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn&amp;rsquo;t an ndarray it is treated as a scalar.</source>
          <target state="translated">3次元シリーズは、ポイント &lt;code&gt;(x, y, z)&lt;/code&gt; で評価されます。ここで、 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、および &lt;code&gt;z&lt;/code&gt; は同じ形状でなければなりません。 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、または &lt;code&gt;z&lt;/code&gt; のいずれかがリストまたはタプルの場合、最初にndarrayに変換されます。それ以外の場合は変更されず、ndarrayでない場合はスカラーとして扱われます。</target>
        </trans-unit>
        <trans-unit id="ababec7c614f8cc809a5f4b9df993b70ee13a8f8" translate="yes" xml:space="preserve">
          <source>The three dimensional series is evaluated at the points in the Cartesian product of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt;,`y`, or &lt;code&gt;z&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">3次元シリーズは、 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、および &lt;code&gt;z&lt;/code&gt; のデカルト積のポイントで評価されます。場合 &lt;code&gt;x&lt;/code&gt; 、 `y`、又は &lt;code&gt;z&lt;/code&gt; 、リストまたはタプルであるが最初ndarrayに変換され、それ以外の場合は、それがndarrayない場合、それはスカラーとして扱われ、変更されないままとされます。</target>
        </trans-unit>
        <trans-unit id="3f792b485609224acbb4d7367551edb56b3d1d82" translate="yes" xml:space="preserve">
          <source>The three division operators are all defined; &lt;code&gt;div&lt;/code&gt; is active by default, &lt;code&gt;truediv&lt;/code&gt; is active when &lt;a href=&quot;https://docs.python.org/dev/library/__future__.html#module-__future__&quot;&gt;&lt;code&gt;__future__&lt;/code&gt;&lt;/a&gt; division is in effect.</source>
          <target state="translated">3つの除算演算子がすべて定義されています。 &lt;code&gt;div&lt;/code&gt; はデフォルトでアクティブであり、&lt;a href=&quot;https://docs.python.org/dev/library/__future__.html#module-__future__&quot;&gt; &lt;code&gt;__future__&lt;/code&gt; &lt;/a&gt;除算が有効な場合、 &lt;code&gt;truediv&lt;/code&gt; はアクティブです。</target>
        </trans-unit>
        <trans-unit id="6953aff01d51815d13e09f72484f920fa7369db2" translate="yes" xml:space="preserve">
          <source>The thresholds above deal with floating point roundoff error in the calculation of the SVD. However, you may have more information about the sources of error in &lt;code&gt;M&lt;/code&gt; that would make you consider other tolerance values to detect &lt;em&gt;effective&lt;/em&gt; rank deficiency. The most useful measure of the tolerance depends on the operations you intend to use on your matrix. For example, if your data come from uncertain measurements with uncertainties greater than floating point epsilon, choosing a tolerance near that uncertainty may be preferable. The tolerance may be absolute if the uncertainties are absolute rather than relative.</source>
          <target state="translated">上記のしきい値は、SVDの計算における浮動小数点丸め誤差を扱います。ただし、 &lt;code&gt;M&lt;/code&gt; の誤差の原因についてより多くの情報があり、他の許容値を検討して&lt;em&gt;有効な&lt;/em&gt;ランクの不足を検出する場合があります。許容誤差の最も有用な尺度は、マトリックスで使用する操作によって異なります。たとえば、データが浮動小数点イプシロンより大きい不確実性を伴う不確かな測定から得られた場合、その不確実性に近い許容誤差を選択することが望ましい場合があります。不確実性が相対的ではなく絶対的な場合、許容誤差は絶対的な場合があります。</target>
        </trans-unit>
        <trans-unit id="64c20447e1e6f9694ec0f7bb75ec43f4f4cb6058" translate="yes" xml:space="preserve">
          <source>The tiled output array.</source>
          <target state="translated">タイル化された出力配列。</target>
        </trans-unit>
        <trans-unit id="8bc4b16e1cf995efdf33020e8a2b8f7760d88f9e" translate="yes" xml:space="preserve">
          <source>The time required to produce using multiple threads can be compared to the time required to generate using a single thread.</source>
          <target state="translated">複数のスレッドを使用して生成する場合の所要時間と、1つのスレッドを使用して生成する場合の所要時間を比較することができます。</target>
        </trans-unit>
        <trans-unit id="bcdefbec5fdfd59d604b41a08eaf1010ff1f9f3b" translate="yes" xml:space="preserve">
          <source>The timings below are the time in ns to produce 1 random value from a specific distribution. The original &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; generator is much slower since it requires 2 32-bit values to equal the output of the faster generators.</source>
          <target state="translated">以下のタイミングは、特定の分布から1つのランダム値を生成するためのns単位の時間です。元の&lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt;ジェネレーターは、高速ジェネレーターの出力と等しくなるために2つの32ビット値を必要とするため、はるかに低速です。</target>
        </trans-unit>
        <trans-unit id="343a5bcbcad72b541893cb8c8e45cc7f466bba8b" translate="yes" xml:space="preserve">
          <source>The timings below are the time in ns to produce 1 random value from a specific distribution. The original &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; generator is much slower since it requires 2 32-bit values to equal the output of the faster generators.</source>
          <target state="translated">以下のタイミングは、特定の分布から1つのランダムな値を生成するためのns単位の時間です。元の&lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt;ジェネレーターは、より高速なジェネレーターの出力と等しくするために2つの32ビット値を必要とするため、かなり低速です。</target>
        </trans-unit>
        <trans-unit id="1d2c30ac9be07be723e9ef95eaf137f9bc73af0a" translate="yes" xml:space="preserve">
          <source>The tolerance values are positive, typically very small numbers. The relative difference (&lt;code&gt;rtol&lt;/code&gt; * abs(&lt;code&gt;b&lt;/code&gt;)) and the absolute difference &lt;code&gt;atol&lt;/code&gt; are added together to compare against the absolute difference between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">許容値は正で、通常は非常に小さい数値です。相対差（ &lt;code&gt;rtol&lt;/code&gt; * ABS（ &lt;code&gt;b&lt;/code&gt; ））との差分絶対 &lt;code&gt;atol&lt;/code&gt; 差の絶対値と比較するために一緒に追加されると &lt;code&gt;b&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52a51aeadfd53cc309968068f2e1965d359a3909" translate="yes" xml:space="preserve">
          <source>The total broadcasted size.</source>
          <target state="translated">放送されたサイズの合計。</target>
        </trans-unit>
        <trans-unit id="df3d0e81279bb92508eaea005084a0b02573f0f5" translate="yes" xml:space="preserve">
          <source>The total number of arguments (&lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt;). This must be less than &lt;a href=&quot;array#c.NPY_MAXARGS&quot;&gt;&lt;code&gt;NPY_MAXARGS&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">引数の総数（&lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt;）。これは&lt;a href=&quot;array#c.NPY_MAXARGS&quot;&gt; &lt;code&gt;NPY_MAXARGS&lt;/code&gt; &lt;/a&gt;未満である必要があります。</target>
        </trans-unit>
        <trans-unit id="1470f5efa816c498ec2cdd99dd6bc7fe2a058b68" translate="yes" xml:space="preserve">
          <source>The total number of arguments (&lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt;). This must be less than &lt;code&gt;NPY_MAXARGS&lt;/code&gt;.</source>
          <target state="translated">引数の合計数（&lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt;）。これは &lt;code&gt;NPY_MAXARGS&lt;/code&gt; 未満でなければなりません。</target>
        </trans-unit>
        <trans-unit id="af0d1953b87871e5f5c2cfb05eba9aaf99050200" translate="yes" xml:space="preserve">
          <source>The total number of built-in NumPy types. The enumeration covers the range from 0 to NPY_NTYPES-1.</source>
          <target state="translated">組み込みのNumPy型の総数。列挙は 0 から NPY_NTYPES-1 までの範囲をカバーしています。</target>
        </trans-unit>
        <trans-unit id="abe92a5e4aa66a77153ec46749bbd30d898eb468" translate="yes" xml:space="preserve">
          <source>The total number of masked elements (axis=None) or the number of masked elements along each slice of the given axis.</source>
          <target state="translated">マスクされた要素の合計数(axis=None)、または与えられた軸の各スライスに沿ったマスクされた要素の数。</target>
        </trans-unit>
        <trans-unit id="7423c677797c62eaba11c700e763c8330a87769e" translate="yes" xml:space="preserve">
          <source>The total payment is made up of payment against principal plus interest.</source>
          <target state="translated">支払総額は、元金に対する支払いに利息を加えて構成されています。</target>
        </trans-unit>
        <trans-unit id="b7226d44903c768f342634b37f3cd2cbe870d83c" translate="yes" xml:space="preserve">
          <source>The total size of the underlying array.</source>
          <target state="translated">基礎となる配列の合計サイズ。</target>
        </trans-unit>
        <trans-unit id="b17ef49a2b827517f40e328c2cdae6675b6f65d6" translate="yes" xml:space="preserve">
          <source>The transform for real input is performed over the last transformation axis, as by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, then the transform over the remaining axes is performed as by &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;. The order of the output is as for &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt; for the final transformation axis, and as for &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt; for the remaining transformation axes.</source>
          <target state="translated">実際の入力の変換は、&lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; の&lt;/a&gt;ように最後の変換軸で実行され、次に残りの軸の変換は&lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; で&lt;/a&gt;実行されます。出力の順序は、最終変換軸の場合は&lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt;、残りの変換軸の場合は&lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="85975e151b66ed8086ffe0edc17f692849490b8d" translate="yes" xml:space="preserve">
          <source>The transpose of a C-ordered array is a FORTRAN-ordered array.</source>
          <target state="translated">C順配列の転置はFORTRAN順配列です。</target>
        </trans-unit>
        <trans-unit id="be8d0d980a1c43a49c10382a49da454ce905c4ef" translate="yes" xml:space="preserve">
          <source>The transposed array.</source>
          <target state="translated">転置配列です。</target>
        </trans-unit>
        <trans-unit id="ded8f77d9cba6691688303bd624c72d17c97324f" translate="yes" xml:space="preserve">
          <source>The tree in &lt;code&gt;numpy&lt;/code&gt; will now have the latest changes from the initial repository.</source>
          <target state="translated">&lt;code&gt;numpy&lt;/code&gt; のツリーには、初期リポジトリからの最新の変更が含まれます。</target>
        </trans-unit>
        <trans-unit id="362e7b5f1deb8afe588bc61b11c57a486aa6b58d" translate="yes" xml:space="preserve">
          <source>The triangular distribution is a continuous probability distribution with lower limit left, peak at mode, and upper limit right. Unlike the other distributions, these parameters directly define the shape of the pdf.</source>
          <target state="translated">三角分布は,下限左,モードでのピーク,上限右を持つ連続確率分布である。他の分布とは異なり、これらのパラメータはpdfの形状を直接定義します。</target>
        </trans-unit>
        <trans-unit id="1d2039a815b5ec90474a824463e862d2894a1c82" translate="yes" xml:space="preserve">
          <source>The triangular distribution is often used in ill-defined problems where the underlying distribution is not known, but some knowledge of the limits and mode exists. Often it is used in simulations.</source>
          <target state="translated">三角分布は、基礎となる分布が知られていないが、限界とモードの知識がある程度存在するような不明確な問題でよく使われます。しばしばシミュレーションで使用されます。</target>
        </trans-unit>
        <trans-unit id="6a93dc1adb33729debf6e5480c2814c2157666fd" translate="yes" xml:space="preserve">
          <source>The triangular window, with the maximum value normalized to one (the value one appears only if the number of samples is odd), with the first and last samples equal to zero.</source>
          <target state="translated">三角形のウィンドウで、最大値が1に正規化されており(サンプル数が奇数の場合にのみ値1が表示されます)、最初と最後のサンプルは0に等しくなっています。</target>
        </trans-unit>
        <trans-unit id="24e66129ed79808afe1e2c37f4c9f61c91ca2839" translate="yes" xml:space="preserve">
          <source>The true value of &lt;code&gt;exp(1e-10) - 1&lt;/code&gt; is &lt;code&gt;1.00000000005e-10&lt;/code&gt; to about 32 significant digits. This example shows the superiority of expm1 in this case.</source>
          <target state="translated">&lt;code&gt;exp(1e-10) - 1&lt;/code&gt; の真の値は、 &lt;code&gt;1.00000000005e-10&lt;/code&gt; から約32桁の有効数字です。この例は、この場合のexpm1の優位性を示しています。</target>
        </trans-unit>
        <trans-unit id="973da8e077b17711228349d2b08c7d0d4f2d3661" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above.</source>
          <target state="translated">上記のパラメーターのセクションで説明したように、axesによって示される &lt;code&gt;axes&lt;/code&gt; 沿って、または &lt;code&gt;s&lt;/code&gt; と &lt;code&gt;a&lt;/code&gt; の組み合わせによって変換された、切り捨てられた入力またはゼロが埋め込まれた入力。</target>
        </trans-unit>
        <trans-unit id="0cef9d8907fc4d88debbd9a6424b4425ec58e68f" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above. The length of the last axis transformed will be &lt;code&gt;s[-1]//2+1&lt;/code&gt;, while the remaining transformed axes will have lengths according to &lt;code&gt;s&lt;/code&gt;, or unchanged from the input.</source>
          <target state="translated">上記のパラメーターのセクションで説明したように、axesによって示される &lt;code&gt;axes&lt;/code&gt; 沿って、または &lt;code&gt;s&lt;/code&gt; と &lt;code&gt;a&lt;/code&gt; の組み合わせによって変換された、切り捨てられた入力またはゼロが埋め込まれた入力。変換された最後の軸の長さは &lt;code&gt;s[-1]//2+1&lt;/code&gt; になりますが、残りの変換された軸の長さは &lt;code&gt;s&lt;/code&gt; に従うか、入力から変化しません。</target>
        </trans-unit>
        <trans-unit id="9c91d131105a38ed60b366938edb9bb82399cba7" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above.</source>
          <target state="translated">上記のパラメーターのセクションで説明したように、axesによって示される &lt;code&gt;axes&lt;/code&gt; 沿って、または &lt;code&gt;s&lt;/code&gt; または &lt;code&gt;a&lt;/code&gt; の組み合わせによって変換された、切り捨てられた、またはゼロが埋め込まれた入力。</target>
        </trans-unit>
        <trans-unit id="879b9a05c20a089a225b78254a5b2e292b149d60" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above. The length of each transformed axis is as given by the corresponding element of &lt;code&gt;s&lt;/code&gt;, or the length of the input in every axis except for the last one if &lt;code&gt;s&lt;/code&gt; is not given. In the final transformed axis the length of the output when &lt;code&gt;s&lt;/code&gt; is not given is &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the final transformed axis of the input. To get an odd number of output points in the final axis, &lt;code&gt;s&lt;/code&gt; must be specified.</source>
          <target state="translated">上記のパラメーターのセクションで説明したように、axesによって示される &lt;code&gt;axes&lt;/code&gt; 沿って、または &lt;code&gt;s&lt;/code&gt; または &lt;code&gt;a&lt;/code&gt; の組み合わせによって変換された、切り捨てられた、またはゼロが埋め込まれた入力。変換された各軸の長さは、 &lt;code&gt;s&lt;/code&gt; の対応する要素によって与えられるか、または &lt;code&gt;s&lt;/code&gt; が与えられない場合は最後の軸を除くすべての軸の入力の長さです。最終変換軸では、 &lt;code&gt;s&lt;/code&gt; が指定されていない場合の出力の長さは &lt;code&gt;2*(m-1)&lt;/code&gt; ここで、 &lt;code&gt;m&lt;/code&gt; は入力の最終変換軸の長さです。最終軸で奇数の出力ポイントを取得するには、 &lt;code&gt;s&lt;/code&gt; を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="933c6e0a0fb2fd7449c8d46cb7e6572b1c3279dd" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or the last two axes if &lt;code&gt;axes&lt;/code&gt; is not given.</source>
          <target state="translated">軸に沿って転換切り捨てまたはゼロパディング入力は、で示される &lt;code&gt;axes&lt;/code&gt; 場合、または最後の二つの軸 &lt;code&gt;axes&lt;/code&gt; 与えられていません。</target>
        </trans-unit>
        <trans-unit id="bdca2715ebaff6edc1c47e7d7cb69eb535ec549b" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified.</source>
          <target state="translated">axisで示された &lt;code&gt;axis&lt;/code&gt; 沿って変換された、切り捨てられた、またはゼロが埋め込まれた入力、または &lt;code&gt;axis&lt;/code&gt; が指定されていない場合は最後の入力。</target>
        </trans-unit>
        <trans-unit id="f4095a8db5d8ecd4ba9c0d3227d91d6c6751102f" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. If &lt;code&gt;n&lt;/code&gt; is even, the length of the transformed axis is &lt;code&gt;(n/2)+1&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is odd, the length is &lt;code&gt;(n+1)/2&lt;/code&gt;.</source>
          <target state="translated">axisで示された &lt;code&gt;axis&lt;/code&gt; 沿って変換された、切り捨てられた、またはゼロが埋め込まれた入力、または &lt;code&gt;axis&lt;/code&gt; が指定されていない場合は最後の入力。 &lt;code&gt;n&lt;/code&gt; が偶数の場合、変換された軸の長さは &lt;code&gt;(n/2)+1&lt;/code&gt; です。場合 &lt;code&gt;n&lt;/code&gt; は奇数である、長さが &lt;code&gt;(n+1)/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="210fa87b6170797ddb3ab263d911a488e3f1f97e" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n//2 + 1&lt;/code&gt;.</source>
          <target state="translated">axisで示された &lt;code&gt;axis&lt;/code&gt; 沿って変換された、切り捨てられた、またはゼロが埋め込まれた入力、または &lt;code&gt;axis&lt;/code&gt; が指定されていない場合は最後の入力。変換後の軸の長さは &lt;code&gt;n//2 + 1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1026feb255ba9e4ae695f12a04d60bbc57c49ac5" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n&lt;/code&gt;, or, if &lt;code&gt;n&lt;/code&gt; is not given, &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the transformed axis of the input. To get an odd number of output points, &lt;code&gt;n&lt;/code&gt; must be specified.</source>
          <target state="translated">axisで示された &lt;code&gt;axis&lt;/code&gt; 沿って変換された、切り捨てられた、またはゼロが埋め込まれた入力、または &lt;code&gt;axis&lt;/code&gt; が指定されていない場合は最後の入力。変換された軸の長さは &lt;code&gt;n&lt;/code&gt; です &lt;code&gt;n&lt;/code&gt; が指定されていない場合は、 &lt;code&gt;2*(m-1)&lt;/code&gt; ここで、 &lt;code&gt;m&lt;/code&gt; は入力の変換された軸の長さです。奇数の出力ポイントを取得するには、 &lt;code&gt;n&lt;/code&gt; を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="785f913e97e6f2c077e366a11b3d02d03922b2c4" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n&lt;/code&gt;, or, if &lt;code&gt;n&lt;/code&gt; is not given, &lt;code&gt;2*m - 2&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the transformed axis of the input. To get an odd number of output points, &lt;code&gt;n&lt;/code&gt; must be specified, for instance as &lt;code&gt;2*m - 1&lt;/code&gt; in the typical case,</source>
          <target state="translated">axisで示された &lt;code&gt;axis&lt;/code&gt; 沿って変換された、切り捨てられた、またはゼロが埋め込まれた入力、または &lt;code&gt;axis&lt;/code&gt; が指定されていない場合は最後の入力。変換された軸の長さは &lt;code&gt;n&lt;/code&gt; です &lt;code&gt;n&lt;/code&gt; が指定されていない場合は、 &lt;code&gt;2*m - 2&lt;/code&gt; ここで、 &lt;code&gt;m&lt;/code&gt; は入力の変換された軸の長さです。奇数の出力ポイントを取得するには、 &lt;code&gt;n&lt;/code&gt; を指定する必要があります。たとえば、通常の場合は &lt;code&gt;2*m - 1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="890cb80542174800559555fcc8928d47ac767144" translate="yes" xml:space="preserve">
          <source>The truncated value of each element in &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の各要素の切り捨てられた値。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="d225104697ad1c2e4adc5e266a19505669d514fa" translate="yes" xml:space="preserve">
          <source>The truncated value of the scalar &lt;code&gt;x&lt;/code&gt; is the nearest integer &lt;code&gt;i&lt;/code&gt; which is closer to zero than &lt;code&gt;x&lt;/code&gt; is. In short, the fractional part of the signed number &lt;code&gt;x&lt;/code&gt; is discarded.</source>
          <target state="translated">スカラーの切り捨て値 &lt;code&gt;x&lt;/code&gt; は整数最も近い &lt;code&gt;i&lt;/code&gt; 近いゼロよりなる &lt;code&gt;x&lt;/code&gt; があります。つまり、符号付き数値 &lt;code&gt;x&lt;/code&gt; の小数部分は破棄されます。</target>
        </trans-unit>
        <trans-unit id="7473e98cdd8b9577d457a4ec3ae00062b1e0d1c1" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;args&lt;/code&gt; and dict &lt;code&gt;kwargs&lt;/code&gt; are directly passed on from the original call.</source>
          <target state="translated">タプル &lt;code&gt;args&lt;/code&gt; とdict &lt;code&gt;kwargs&lt;/code&gt; は、元の呼び出しから直接渡されます。</target>
        </trans-unit>
        <trans-unit id="8a95ef02498e39d8be9ecf72e13e2817e4a11b13" translate="yes" xml:space="preserve">
          <source>The tuple returned from &lt;code&gt;__array_interface__['data']&lt;/code&gt; used to be a hex-string (now it is an integer or a long integer).</source>
          <target state="translated">&lt;code&gt;__array_interface__['data']&lt;/code&gt; から返されるタプルは、以前は16進文字列でした（現在は整数または長整数です）。</target>
        </trans-unit>
        <trans-unit id="462bd3332737c1c0e3c136e2df99165ffa307b94" translate="yes" xml:space="preserve">
          <source>The tuple returned from __array_interface__[&amp;lsquo;data&amp;rsquo;] used to be a hex-string (now it is an integer or a long integer).</source>
          <target state="translated">__array_interface __ ['data']から返されたタプルは、以前は16進文字列でした（現在は整数または長整数です）。</target>
        </trans-unit>
        <trans-unit id="ac07e35413d52171420d0546afbc516e4675dfc6" translate="yes" xml:space="preserve">
          <source>The two arrays are of the same length, so there is only one position where they completely overlap:</source>
          <target state="translated">2つの配列は同じ長さなので、完全に重なる位置は1つだけです。</target>
        </trans-unit>
        <trans-unit id="a1576896c14768083aa4b0494018f6de168f9aa6" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points &lt;code&gt;(x, y)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must have the same shape. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn&amp;rsquo;t an ndarray it is treated as a scalar.</source>
          <target state="translated">2次元の系列は、ポイント &lt;code&gt;(x, y)&lt;/code&gt; で評価されます。ここで、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は同じ形状でなければなりません。場合 &lt;code&gt;x&lt;/code&gt; または &lt;code&gt;y&lt;/code&gt; リストまたはタプルである、それは最初ndarrayに変換され、そうでない場合は変更されないままであり、それはndarrayない場合には、スカラーとして扱われます。</target>
        </trans-unit>
        <trans-unit id="2eba9ab6dc5fc4a672b7a559261dcf61c08663b7" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points &lt;code&gt;(x, y)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must have the same shape. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">2次元の系列は、ポイント &lt;code&gt;(x, y)&lt;/code&gt; で評価されます。ここで、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は同じ形状でなければなりません。場合 &lt;code&gt;x&lt;/code&gt; または &lt;code&gt;y&lt;/code&gt; リストまたはタプルであるが最初ndarrayに変換され、それ以外の場合は、それがndarrayない場合、それはスカラーとして扱われ、変更されないままとされます。</target>
        </trans-unit>
        <trans-unit id="0688b7907322e12f298dd8f02d187105297d15b2" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">2次元系列は、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; のデカルト積の点で評価されます。場合 &lt;code&gt;x&lt;/code&gt; または &lt;code&gt;y&lt;/code&gt; リストまたはタプルであるが最初ndarrayに変換され、それ以外の場合は、それがndarrayない場合、それはスカラーとして扱われ、変更されないままとされます。</target>
        </trans-unit>
        <trans-unit id="d4aa44f129ba54b421bffe3762821ce4945dce60" translate="yes" xml:space="preserve">
          <source>The two domains that determine the map. Each must (successfully) convert to 1-d arrays containing precisely two values.</source>
          <target state="translated">マップを決定する2つのドメイン。それぞれが(成功して)正確に2つの値を含む1-d配列に変換しなければなりません。</target>
        </trans-unit>
        <trans-unit id="0027adc4d9c51b047c70705863099ef3efdd05ff" translate="yes" xml:space="preserve">
          <source>The two methods do not return the same sequence of variates.</source>
          <target state="translated">2つのメソッドは、同じシーケンスのバリアートを返しません。</target>
        </trans-unit>
        <trans-unit id="810d0511d5cc6182785b949cef8752429de415c1" translate="yes" xml:space="preserve">
          <source>The two&amp;rsquo;s complement is returned when the input number is negative and width is specified:</source>
          <target state="translated">入力数値が負で幅が指定されている場合、2の補数が返されます。</target>
        </trans-unit>
        <trans-unit id="584450aea06b04e9037daf43c6af1e81a83e775a" translate="yes" xml:space="preserve">
          <source>The two-dimensional FFT of real input.</source>
          <target state="translated">実数入力の2次元FFT。</target>
        </trans-unit>
        <trans-unit id="9b11970984391ed9339a62d69846a84202600584" translate="yes" xml:space="preserve">
          <source>The two-dimensional FFT.</source>
          <target state="translated">二次元FFTです。</target>
        </trans-unit>
        <trans-unit id="93378f6188f826db256b9d6c37c0794ddd0149ba" translate="yes" xml:space="preserve">
          <source>The two-dimensional example we created using Fortran is just as easy to write in Cython:</source>
          <target state="translated">Fortranを使って作った二次元の例は、Cythonで書くのと同じように簡単です。</target>
        </trans-unit>
        <trans-unit id="cc89089001cef3c7a737f8de3b95a6b67d11a175" translate="yes" xml:space="preserve">
          <source>The two-dimensional inverse FFT.</source>
          <target state="translated">2次元の逆FFT。</target>
        </trans-unit>
        <trans-unit id="9f5faf584fb30081780464310b34017103e73128" translate="yes" xml:space="preserve">
          <source>The type above can either refer to an actual Python type (e.g. &lt;code&gt;int&lt;/code&gt;), or describe the type of the variable in more detail, e.g. &lt;code&gt;(N,) ndarray&lt;/code&gt; or &lt;code&gt;array_like&lt;/code&gt;.</source>
          <target state="translated">上記の型は、実際のP​​ython型（ &lt;code&gt;int&lt;/code&gt; など）を参照することも、変数の型をより詳細に説明することもできます &lt;code&gt;(N,) ndarray&lt;/code&gt; や &lt;code&gt;array_like&lt;/code&gt; など）。</target>
        </trans-unit>
        <trans-unit id="66cebb62b229032f20fef01d3cd3e2d8c08b92d1" translate="yes" xml:space="preserve">
          <source>The type object used to instantiate a scalar of this data-type.</source>
          <target state="translated">このデータ型のスカラのインスタンスを作成するために使用される型オブジェクト。</target>
        </trans-unit>
        <trans-unit id="6e4f0a20a4e71ba4f55f61f65f81013f324f6ce9" translate="yes" xml:space="preserve">
          <source>The type of the array can also be explicitly specified at creation time:</source>
          <target state="translated">配列の型は、作成時に明示的に指定することもできます。</target>
        </trans-unit>
        <trans-unit id="fa0bd68b05131d508a3464e6044d68f87729d81c" translate="yes" xml:space="preserve">
          <source>The type of the data can be accessed through the &lt;a href=&quot;#numpy.ma.MaskedArray.baseclass&quot;&gt;&lt;code&gt;baseclass&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">データのタイプは、&lt;a href=&quot;#numpy.ma.MaskedArray.baseclass&quot;&gt; &lt;code&gt;baseclass&lt;/code&gt; &lt;/a&gt;属性を介してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="4e723834a8970a250a2a2d214449437cb2b1463f" translate="yes" xml:space="preserve">
          <source>The type of the data can be accessed through the &lt;a href=&quot;numpy.ma.masked_array.baseclass#numpy.ma.masked_array.baseclass&quot;&gt;&lt;code&gt;baseclass&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">データのタイプには、&lt;a href=&quot;numpy.ma.masked_array.baseclass#numpy.ma.masked_array.baseclass&quot;&gt; &lt;code&gt;baseclass&lt;/code&gt; &lt;/a&gt;属性を介してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="55666432b4662cbbcca855eedc915c8dbb074f43" translate="yes" xml:space="preserve">
          <source>The type of the data is described by the following &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; attributes:</source>
          <target state="translated">データのタイプは、次の&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;属性によって記述されます。</target>
        </trans-unit>
        <trans-unit id="7c7e8530225fc135f4d9b6eea552288840993321" translate="yes" xml:space="preserve">
          <source>The type of the input is checked, not the value. Even if the input has an imaginary part equal to zero, &lt;a href=&quot;#numpy.iscomplexobj&quot;&gt;&lt;code&gt;iscomplexobj&lt;/code&gt;&lt;/a&gt; evaluates to True.</source>
          <target state="translated">値ではなく、入力のタイプがチェックされます。入力にゼロに等しい虚数部がある場合でも、&lt;a href=&quot;#numpy.iscomplexobj&quot;&gt; &lt;code&gt;iscomplexobj&lt;/code&gt; &lt;/a&gt;はTrueと評価されます。</target>
        </trans-unit>
        <trans-unit id="1a2c8e641184f0940417186c9bd1b40520bec6a6" translate="yes" xml:space="preserve">
          <source>The type of the input is checked, not the value. So even if the input has an imaginary part equal to zero, &lt;a href=&quot;#numpy.isrealobj&quot;&gt;&lt;code&gt;isrealobj&lt;/code&gt;&lt;/a&gt; evaluates to False if the data type is complex.</source>
          <target state="translated">値ではなく、入力のタイプがチェックされます。したがって、入力の虚数部がゼロに等しい場合でも、データ型が複素数の場合、&lt;a href=&quot;#numpy.isrealobj&quot;&gt; &lt;code&gt;isrealobj&lt;/code&gt; &lt;/a&gt;はFalseと評価されます。</target>
        </trans-unit>
        <trans-unit id="ea61e4d42852a1b3d6a2054bbf717a4dcd45c615" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not given, infer the data type from the other input arguments.</source>
          <target state="translated">出力配列のタイプ。&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;が指定されていない場合は、他の入力引数からデータ型を推測します。</target>
        </trans-unit>
        <trans-unit id="32f8e95967dee5b6024af49a6833df8b96400b41" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not given, the data type is inferred from &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;. The inferred dtype will never be an integer; &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; is chosen even if the arguments would produce an array of integers.</source>
          <target state="translated">出力配列のタイプ。&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;が指定されていない場合、データ型は &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;stop&lt;/code&gt; から推測されます。推測されるdtypeが整数になることはありません。引数が整数の配列を生成する場合でも、&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt;が選択されます。</target>
        </trans-unit>
        <trans-unit id="b4f2b2af4ea00b9069f29f29630cfed5b29605d4" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not given, the data type is inferred from &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;. The inferred type will never be an integer; &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; is chosen even if the arguments would produce an array of integers.</source>
          <target state="translated">出力配列のタイプ。&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;が指定されていない場合、データ型は &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;stop&lt;/code&gt; から推測されます。推測される型が整数になることはありません。引数が整数の配列を生成する場合でも、&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt;が選択されます。</target>
        </trans-unit>
        <trans-unit id="2c73d98907158f7fb67c4efa759cdbb5f806f2d4" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;code&gt;dtype&lt;/code&gt; is not given, infer the data type from the other input arguments.</source>
          <target state="translated">出力配列のタイプ。 &lt;code&gt;dtype&lt;/code&gt; が指定されていない場合は、他の入力引数からデータ型を推測します。</target>
        </trans-unit>
        <trans-unit id="a61a6b8f22a17e9cfb7771cdc6f2f0f745c54b06" translate="yes" xml:space="preserve">
          <source>The type of the result will depend on the encoding specified.</source>
          <target state="translated">結果の型は、指定されたエンコーディングに依存します。</target>
        </trans-unit>
        <trans-unit id="9f964988f963b226cae3c6098e96762218b96f31" translate="yes" xml:space="preserve">
          <source>The type of the returned array and of the accumulator in which the elements are summed. By default, the dtype of &lt;code&gt;a&lt;/code&gt; is used. An exception is when &lt;code&gt;a&lt;/code&gt; has an integer type with less precision than the platform (u)intp. In that case, the default will be either (u)int32 or (u)int64 depending on whether the platform is 32 or 64 bits. For inexact inputs, dtype must be inexact.</source>
          <target state="translated">返された配列の型と、要素が合計されるアキュムレータの型。デフォルトでは、のdtypeは使用されています。例外は、 &lt;code&gt;a&lt;/code&gt; がプラットフォーム（u）intpよりも精度が低い整数型の場合です。その場合、プラットフォームが32ビットか64ビットかによって、デフォルトは（u）int32または（u）int64になります。不正確な入力の場合、dtypeは不正確でなければなりません。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fae2388276bf4adee2baf6958155240f0239ec9b" translate="yes" xml:space="preserve">
          <source>The type of the returned array and of the accumulator in which the elements are summed. The dtype of &lt;code&gt;a&lt;/code&gt; is used by default unless &lt;code&gt;a&lt;/code&gt; has an integer dtype of less precision than the default platform integer. In that case, if &lt;code&gt;a&lt;/code&gt; is signed then the platform integer is used while if &lt;code&gt;a&lt;/code&gt; is unsigned then an unsigned integer of the same precision as the platform integer is used.</source>
          <target state="translated">返された配列の型と、要素が合計されるアキュムレータの型。 DTYPE ない限り、デフォルトで使用されるデフォルトプラットフォームの整数未満の精度の整数DTYPEを有しています。場合この場合、次に署名されている場合ながらプラットフォームの整数が使用され、次に署名され、プラットフォームの整数と同じ精度の符号なし整数が使用されます。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd79c4b3d3f0f1be1ec3ce5a1aa5d47271e61a5b" translate="yes" xml:space="preserve">
          <source>The type of the returned array, as well as of the accumulator in which the elements are multiplied. The dtype of &lt;code&gt;a&lt;/code&gt; is used by default unless &lt;code&gt;a&lt;/code&gt; has an integer dtype of less precision than the default platform integer. In that case, if &lt;code&gt;a&lt;/code&gt; is signed then the platform integer is used while if &lt;code&gt;a&lt;/code&gt; is unsigned then an unsigned integer of the same precision as the platform integer is used.</source>
          <target state="translated">返される配列の型と、要素が乗算されるアキュムレータの型。 DTYPE ない限り、デフォルトで使用されるデフォルトプラットフォームの整数未満の精度の整数DTYPEを有しています。場合この場合、次に署名されている場合ながらプラットフォームの整数が使用され、次に署名され、プラットフォームの整数と同じ精度の符号なし整数が使用されます。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3a7bb2863553d52f83413fb23d739a7fea567ae" translate="yes" xml:space="preserve">
          <source>The type used to represent the intermediate results. Defaults to the data type of the output array if this is provided, or the data type of the input array if no output array is provided.</source>
          <target state="translated">中間結果の表現に用いられる型。デフォルトは、出力配列が指定されている場合は出力配列のデータ型、出力配列が指定されていない場合は入力配列のデータ型となります。</target>
        </trans-unit>
        <trans-unit id="f46b668fbc5ae74dc471bbfdc9b1c8b2040c3ed5" translate="yes" xml:space="preserve">
          <source>The type used to represent the intermediate results. Defaults to the data-type of the output array if this is provided, or the data-type of the input array if no output array is provided.</source>
          <target state="translated">中間結果の表現に用いられる型。デフォルトは、出力配列が指定されている場合は出力配列のデータ型、出力配列が指定されていない場合は入力配列のデータ型となります。</target>
        </trans-unit>
        <trans-unit id="3d1a1953424d5a7364adfc318f2ceeb8ef42f6ff" translate="yes" xml:space="preserve">
          <source>The typemap directives provided by &lt;code&gt;numpy.i&lt;/code&gt; for arrays of different data types, say &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt;, and dimensions of different types, say &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;, are identical to one another except for the C and NumPy type specifications. The typemaps are therefore implemented (typically behind the scenes) via a macro:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; によって提供される、 &lt;code&gt;double&lt;/code&gt; および &lt;code&gt;int&lt;/code&gt; などの異なるデータ型の配列、および &lt;code&gt;int&lt;/code&gt; または &lt;code&gt;long&lt;/code&gt; などの異なる型の次元に対して提供されるtypemapディレクティブは、CおよびNumPy型の指定を除いて、互いに同じです。したがって、タイプマップはマクロを介して（通常は裏で）実装されます。</target>
        </trans-unit>
        <trans-unit id="dff7b3c37fb51796f178f8cb67e96939e35d8847" translate="yes" xml:space="preserve">
          <source>The typemap signatures are largely differentiated on the name given to the buffer pointer. Names with &lt;code&gt;FARRAY&lt;/code&gt; are for Fortran-ordered arrays, and names with &lt;code&gt;ARRAY&lt;/code&gt; are for C-ordered (or 1D arrays).</source>
          <target state="translated">タイプマップシグネチャは、バッファポインタに付けられた名前で大きく異なります。 &lt;code&gt;FARRAY&lt;/code&gt; が付いた名前はFortran順の配列用で、 &lt;code&gt;ARRAY&lt;/code&gt; が付いた名前はC順（または1D配列）用です。</target>
        </trans-unit>
        <trans-unit id="d316f93b51d10bd2681fb7336deed9067a473d1a" translate="yes" xml:space="preserve">
          <source>The typemaps from &lt;code&gt;numpy.i&lt;/code&gt; are responsible for the following lines of code: 12&amp;ndash;20, 25 and 30. Line 10 parses the input to the &lt;code&gt;rms&lt;/code&gt; function. From the format string &lt;code&gt;&quot;O:rms&quot;&lt;/code&gt;, we can see that the argument list is expected to be a single Python object (specified by the &lt;code&gt;O&lt;/code&gt; before the colon) and whose pointer is stored in &lt;code&gt;obj0&lt;/code&gt;. A number of functions, supplied by &lt;code&gt;numpy.i&lt;/code&gt;, are called to make and check the (possible) conversion from a generic Python object to a NumPy array. These functions are explained in the section &lt;a href=&quot;#helper-functions&quot;&gt;Helper Functions&lt;/a&gt;, but hopefully their names are self-explanatory. At line 12 we use &lt;code&gt;obj0&lt;/code&gt; to construct a NumPy array. At line 17, we check the validity of the result: that it is non-null and that it has a single dimension of arbitrary length. Once these states are verified, we extract the data buffer and length in lines 19 and 20 so that we can call the underlying C function at line 22. Line 25 performs memory management for the case where we have created a new array that is no longer needed.</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; のタイプマップは、次のコード行を担当します：12&amp;ndash;20、25、および30。10行目は、 &lt;code&gt;rms&lt;/code&gt; 関数への入力を解析します。フォーマット文字列 &lt;code&gt;&quot;O:rms&quot;&lt;/code&gt; から、引数リストは単一のPythonオブジェクト（コロンの前の &lt;code&gt;O&lt;/code&gt; で指定）であることが期待され、そのポインターは &lt;code&gt;obj0&lt;/code&gt; に格納されていることがわかります。 &lt;code&gt;numpy.i&lt;/code&gt; によって提供される多数の関数が呼び出され、汎用のPythonオブジェクトからNumPy配列への（可能な）変換を実行およびチェックします。これらの関数については、「&lt;a href=&quot;#helper-functions&quot;&gt;ヘルパー関数&lt;/a&gt;」セクションで説明していますが、名前が一目でわかるようになっています。 12行目では &lt;code&gt;obj0&lt;/code&gt; を使用していますNumPy配列を作成します。 17行目では、結果の有効性を確認します。それがnullでないこと、および任意の長さの単一の次元を持っていることを確認します。これらの状態が確認されたら、19行目と20行目でデータバッファーと長さを抽出し、22行目で基礎となるC関数を呼び出すことができます。25行目は、もはや存在しない新しい配列を作成した場合のメモリ管理を実行します必要。</target>
        </trans-unit>
        <trans-unit id="94a9db34d902a4524ad7871b0441ea5be9c4a8b8" translate="yes" xml:space="preserve">
          <source>The typical looping construct is as follows.</source>
          <target state="translated">典型的なループ構造は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="93f339cfb377248f9f368c97945ac549c08d48eb" translate="yes" xml:space="preserve">
          <source>The ufunc object is implemented by creation of the &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt;&lt;code&gt;PyUFunc_Type&lt;/code&gt;&lt;/a&gt;. It is a very simple type that implements only basic getattribute behavior, printing behavior, and has call behavior which allows these objects to act like functions. The basic idea behind the ufunc is to hold a reference to fast 1-dimensional (vector) loops for each data type that supports the operation. These one-dimensional loops all have the same signature and are the key to creating a new ufunc. They are called by the generic looping code as appropriate to implement the N-dimensional function. There are also some generic 1-d loops defined for floating and complexfloating arrays that allow you to define a ufunc using a single scalar function (&lt;em&gt;e.g.&lt;/em&gt; atanh).</source>
          <target state="translated">ufuncオブジェクトはの創設によって実装され&lt;a href=&quot;#c.PyUFunc_Type&quot;&gt; &lt;code&gt;PyUFunc_Type&lt;/code&gt; &lt;/a&gt;。これは、基本的なgetattribute動作と印刷動作のみを実装する非常に単純なタイプであり、これらのオブジェクトを関数のように動作させる呼び出し動作を持っています。ufuncの背後にある基本的な考え方は、操作をサポートする各データ型の高速1次元（ベクトル）ループへの参照を保持することです。これらの1次元ループはすべて同じシグネチャを持ち、新しいufuncを作成するための鍵となります。これらは、N次元関数を実装するために、必要に応じて汎用ループコードによって呼び出されます。単一のスカラー関数（&lt;em&gt;例えば&lt;/em&gt; atanh）を使用してufuncを定義できる、浮動配列および複素浮動配列に対して定義されたいくつかの一般的な1-dループもあります。</target>
        </trans-unit>
        <trans-unit id="cf8db1044487cf17b16ec5dfd6f051754480a0fd" translate="yes" xml:space="preserve">
          <source>The ufunc still returns its output(s) even if you use the optional output argument(s).</source>
          <target state="translated">ufuncは、オプションの出力引数(s)を使用しても、その出力(s)を返します。</target>
        </trans-unit>
        <trans-unit id="a13b64ddac2c6f9c4757f678876470a35b9dd260" translate="yes" xml:space="preserve">
          <source>The umath module is a computer-generated C-module that creates many ufuncs. It provides a great many examples of how to create a universal function. Creating your own ufunc that will make use of the ufunc machinery is not difficult either. Suppose you have a function that you want to operate element-by-element over its inputs. By creating a new ufunc you will obtain a function that handles</source>
          <target state="translated">umathモジュールは、多くのufuncsを作成するコンピュータ生成のCモジュールです。普遍的な関数を作成する方法について、非常に多くの例を提供しています。ufuncの機械を利用した独自のufuncを作成することも難しくはありません。例えば、入力に対して要素ごとに操作したい関数があるとします。ufuncを新規に作成することで、以下のような関数が得られます。</target>
        </trans-unit>
        <trans-unit id="a59f16e305808090335d01a0996ae1722a21eee6" translate="yes" xml:space="preserve">
          <source>The unary &lt;code&gt;+&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.positive&lt;/code&gt; on ndarrays.</source>
          <target state="translated">単項 &lt;code&gt;+&lt;/code&gt; 演算子は、 &lt;code&gt;np.positive&lt;/code&gt; 省略形として使用できます。</target>
        </trans-unit>
        <trans-unit id="3520cc99bc38dec23789298886ad1bf0cd8d3a9e" translate="yes" xml:space="preserve">
          <source>The unary &lt;code&gt;-&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.negative&lt;/code&gt; on ndarrays.</source>
          <target state="translated">単項 &lt;code&gt;-&lt;/code&gt; 演算子は、の省略形として使用することができます &lt;code&gt;np.negative&lt;/code&gt; ndarraysに。</target>
        </trans-unit>
        <trans-unit id="6d199d62fee4302579457e386e4a80ba73f82400" translate="yes" xml:space="preserve">
          <source>The underlying data of a masked array can be accessed in several ways:</source>
          <target state="translated">マスクされた配列の基礎となるデータには,いくつかの方法でアクセスすることができます.</target>
        </trans-unit>
        <trans-unit id="11e8796701c0b67707f7be52c1081d9ae533b8cd" translate="yes" xml:space="preserve">
          <source>The underlying file descriptor is closed when exiting the &amp;lsquo;with&amp;rsquo; block.</source>
          <target state="translated">「with」ブロックを終了すると、基になるファイル記述子が閉じます。</target>
        </trans-unit>
        <trans-unit id="8a7d26eedaa6e3c6ca58f22a4d3a1445aae9ed58" translate="yes" xml:space="preserve">
          <source>The upper-triangular matrix.</source>
          <target state="translated">上三角行列。</target>
        </trans-unit>
        <trans-unit id="4d3a2d4644c583ea8315d7ff8cedb605a3b103a4" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;fib1.fib&lt;/code&gt; in Python is very similar to using &lt;code&gt;FIB&lt;/code&gt; in Fortran. However, using &lt;em&gt;in situ&lt;/em&gt; output arguments in Python indicates a poor style as there is no safety mechanism in Python with respect to wrong argument types. When using Fortran or C, compilers naturally discover any type mismatches during compile time but in Python the types must be checked in runtime. So, using &lt;em&gt;in situ&lt;/em&gt; output arguments in Python may cause difficult to find bugs, not to mention that the codes will be less readable when all required type checks are implemented.</source>
          <target state="translated">Pythonでの &lt;code&gt;fib1.fib&lt;/code&gt; の使用法は、Fortranでの &lt;code&gt;FIB&lt;/code&gt; の使用法と非常によく似ています。ただし、Python&lt;em&gt;でinsitu&lt;/em&gt;出力引数を使用&lt;em&gt;する&lt;/em&gt;と、間違った引数タイプに関する安全メカニズムがPythonにないため、スタイルが不適切であることを示します。FortranまたはCを使用する場合、コンパイラーはコンパイル時に型の不一致を自然に検出しますが、Pythonでは実行時に型をチェックする必要があります。そのため、Python&lt;em&gt;でその場での&lt;/em&gt;出力引数を使用&lt;em&gt;する&lt;/em&gt;と、必要なすべての型チェックが実装されるとコードが読みにくくなることは言うまでもなく、バグを見つけるのが困難になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="e4cb9fef2603ca49b4b7d883decd87bdc8eb544d" translate="yes" xml:space="preserve">
          <source>The use of random number generation is an important part of the configuration and evaluation of many numerical and machine learning algorithms. Whether you need to randomly initialize weights in an artificial neural network, split data into random sets, or randomly shuffle your dataset, being able to generate random numbers (actually, repeatable pseudo-random numbers) is essential.</source>
          <target state="translated">乱数生成の使用は、多くの数値計算や機械学習アルゴリズムの構成や評価の重要な部分です。人工ニューラルネットワークで重みをランダムに初期化する場合でも、データをランダムなセットに分割する場合でも、データセットをランダムにシャッフルする場合でも、乱数(実際には再現性のある擬似乱数)を生成できることは必須です。</target>
        </trans-unit>
        <trans-unit id="638520b9fcb56661a86b8addd734b2116df46c53" translate="yes" xml:space="preserve">
          <source>The use of this form of specification is discouraged, but documented here because older numpy code may use it. The keys of the dictionary are the field names and the values are tuples specifying type and offset:</source>
          <target state="translated">この形式の仕様の使用は推奨されませんが、古いnumpyコードが使用する可能性があるため、ここでは文書化しています。辞書のキーはフィールド名で、値は型とオフセットを指定するタプルです。</target>
        </trans-unit>
        <trans-unit id="4fb07adf94a9c0d15c6277e214f78bd8de82a95e" translate="yes" xml:space="preserve">
          <source>The user always has the option of converting to a normal &lt;code&gt;numpy.ndarray&lt;/code&gt; with &lt;a href=&quot;../reference/generated/numpy.asarray#numpy.asarray&quot;&gt;&lt;code&gt;numpy.asarray&lt;/code&gt;&lt;/a&gt; and using standard numpy from there.</source>
          <target state="translated">ユーザーは常に、&lt;a href=&quot;../reference/generated/numpy.asarray#numpy.asarray&quot;&gt; &lt;code&gt;numpy.asarray&lt;/code&gt; &lt;/a&gt;を使用して通常の &lt;code&gt;numpy.ndarray&lt;/code&gt; に変換し、そこから標準のnumpyを使用するオプションがあります。</target>
        </trans-unit>
        <trans-unit id="c853de173592dd7ca97d9f29062998fe65a116cb" translate="yes" xml:space="preserve">
          <source>The user should always check the final report through the build log to verify the enabled features.</source>
          <target state="translated">ユーザーは常にビルドログを通して最終レポートをチェックし、有効な機能を確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="8fcd141d1c403551e053ceda2314596f85b55796" translate="yes" xml:space="preserve">
          <source>The usual caution for verifying equality with floating point numbers is advised.</source>
          <target state="translated">浮動小数点数で等号を検証する際には、通常の注意が必要です。</target>
        </trans-unit>
        <trans-unit id="6f6231b1c986a1cae99123ebb4b0aec8cf8b789f" translate="yes" xml:space="preserve">
          <source>The usual companion matrix of the Laguerre polynomials is already symmetric when &lt;code&gt;c&lt;/code&gt; is a basis Laguerre polynomial, so no scaling is applied.</source>
          <target state="translated">ラゲール多項式の通常のコンパニオン行列は、 &lt;code&gt;c&lt;/code&gt; が基底ラゲール多項式である場合、すでに対称であるため、スケーリングは適用されません。</target>
        </trans-unit>
        <trans-unit id="ab74e1cb912398a285a4b8e03a0b11ad44100129" translate="yes" xml:space="preserve">
          <source>The validation process for the requsted optimizations when it comes to &lt;code&gt;--cpu-baseline&lt;/code&gt; isn&amp;rsquo;t strict. For example, if the user requested &lt;code&gt;AVX2&lt;/code&gt; but the compiler doesn&amp;rsquo;t support it then we just skip it and return the maximum optimization that the compiler can handle depending on the implied features of &lt;code&gt;AVX2&lt;/code&gt;, let us assume &lt;code&gt;AVX&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--cpu-baseline&lt;/code&gt; に関しては、必要な最適化の検証プロセスは厳密ではありません。ユーザーが要求した場合たとえば、 &lt;code&gt;AVX2&lt;/code&gt; のが、コンパイラがそれをサポートしていない、我々はそれをスキップして、コンパイラがの暗黙の機能に応じて処理できる最大の最適化を返す &lt;code&gt;AVX2&lt;/code&gt; を、私たちが想定してみましょう &lt;code&gt;AVX&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="1624b44eda9b54e7f0bf73b95d72ca30534e15ac" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;--cpu-baseline&lt;/code&gt; will be treated as &amp;ldquo;native&amp;rdquo; if compiler native flag &lt;code&gt;-march=native&lt;/code&gt; or &lt;code&gt;-xHost&lt;/code&gt; or &lt;code&gt;QxHost&lt;/code&gt; is enabled through environment variable &lt;code&gt;CFLAGS&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--cpu-baseline&lt;/code&gt; の値は、コンパイラのネイティブフラグ &lt;code&gt;-march=native&lt;/code&gt; または &lt;code&gt;-xHost&lt;/code&gt; または &lt;code&gt;QxHost&lt;/code&gt; が環境変数 &lt;code&gt;CFLAGS&lt;/code&gt; によって有効になっている場合、「ネイティブ」として扱われます。</target>
        </trans-unit>
        <trans-unit id="f5374a35aef1f1111ab75965c88b8c317b197461" translate="yes" xml:space="preserve">
          <source>The value of &lt;em&gt;newendian&lt;/em&gt; is one of these macros:</source>
          <target state="translated">&lt;em&gt;newendian&lt;/em&gt;の値は、次のマクロの1つです。</target>
        </trans-unit>
        <trans-unit id="f77acab0966818b5a377ef30b38be521ef7f7b59" translate="yes" xml:space="preserve">
          <source>The value of the function when x1 is 0. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">x1が0の場合の関数の値 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状（出力の形状になる）にブロードキャスト可能でなければなりません。</target>
        </trans-unit>
        <trans-unit id="03d358ce11030b4d51f9879722053df717a3fe53" translate="yes" xml:space="preserve">
          <source>The value of this argument is typically a dictionary with column indices or column names as keys and a conversion functions as values. These conversion functions can either be actual functions or lambda functions. In any case, they should accept only a string as input and output only a single element of the wanted type.</source>
          <target state="translated">この引数の値は、典型的には、列インデックスまたは列名をキーとし、変換関数を値とする辞書である。これらの変換関数は,実際の関数でもラムダ関数でもよい。いずれにしても,これらの関数は,入力として文字列のみを受け入れ,希望する型の単一の要素のみを出力しなければならない。</target>
        </trans-unit>
        <trans-unit id="c3e9e5da5ef1ee5aadaa824ae3c6fd2914c94c23" translate="yes" xml:space="preserve">
          <source>The value of this attribute is used to determine what type of object to return in situations where there is more than one possibility for the Python type of the returned object. Subclasses inherit a default value of 0.0 for this attribute.</source>
          <target state="translated">この属性の値は、返されるオブジェクトの Python 型が複数の可能性がある場合に、どのような型のオブジェクトを返すかを決定するために使用されます。サブクラスはこの属性のデフォルト値 0.0 を継承します。</target>
        </trans-unit>
        <trans-unit id="8bcc816a3b6323731b656c466ec0a5744f30e87e" translate="yes" xml:space="preserve">
          <source>The value to convert. Positive and negative values are handled.</source>
          <target state="translated">変換する値。正の値と負の値を扱います。</target>
        </trans-unit>
        <trans-unit id="32b4c5a64bc9a7f3fa379e6006c427acc72a2601" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; attribute of the array is used instead.</source>
          <target state="translated">無効なエントリに使用する値（デフォルトではなし）。Noneの場合、代わりに配列の&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;属性が使用されます。</target>
        </trans-unit>
        <trans-unit id="de21d1a60175f56eb618a4e1b78157f5a0b80498" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, then this argument is inferred from the passed &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, or in its absence the original array, as discussed in the notes below.</source>
          <target state="translated">無効なエントリに使用する値（デフォルトではなし）。Noneの場合、この引数は、渡された&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;から推測されます。それがない場合は、以下の注で説明するように、元の配列から推測されます。</target>
        </trans-unit>
        <trans-unit id="46bea3445bf9a264b60905faf1d0effc77e2e249" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, then this argument is inferred from the passed &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, or in its absence the original array, as discussed in the notes below.</source>
          <target state="translated">無効なエントリに使用する値（デフォルトではなし）。Noneの場合、この引数は、渡された&lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;から推測されます。それがない場合は、以下の注で説明するように、元の配列から推測されます。</target>
        </trans-unit>
        <trans-unit id="a8455fb8033504388eae171a33ad0ef930322f1e" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, then this argument is inferred from the passed &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, or in its absence the original array, as discussed in the notes below.</source>
          <target state="translated">無効なエントリに使用する値（デフォルトではなし）。Noneの場合、この引数は、渡された&lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;から推測されます。それがない場合は、以下の注で説明するように、元の配列から推測されます。</target>
        </trans-unit>
        <trans-unit id="2e873302c473555951f6bce102181f00086c301d" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries. Can be scalar or non-scalar. If non-scalar, the resulting ndarray must be broadcastable over input array. Default is None, in which case, the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; attribute of the array is used instead.</source>
          <target state="translated">無効なエントリに使用する値。スカラーまたは非スカラーにすることができます。非スカラーの場合、結果のndarrayは入力配列を介してブロードキャスト可能である必要があります。デフォルトはNoneです。この場合、代わりに配列の&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;属性が使用されます。</target>
        </trans-unit>
        <trans-unit id="1880e242040c0aab4362eb1a0863297a32bd5f4b" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries. Can be scalar or non-scalar. If non-scalar, the resulting ndarray must be broadcastable over input array. Default is None, in which case, the &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; attribute of the array is used instead.</source>
          <target state="translated">無効なエントリに使用する値。スカラーまたは非スカラーにすることができます。非スカラーの場合、結果のndarrayは入力配列を介してブロードキャスト可能である必要があります。デフォルトはNoneです。この場合、代わりに配列の&lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;属性が使用されます。</target>
        </trans-unit>
        <trans-unit id="11b1837d34a4ca9f6b2279399c10c60d4b55936a" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries. Default is None.</source>
          <target state="translated">無効なエントリに使用する値。デフォルトは None です。</target>
        </trans-unit>
        <trans-unit id="54be798891264cab731a931b04ea9772cdab541c" translate="yes" xml:space="preserve">
          <source>The value to use for the &lt;a href=&quot;numpy.ufunc.identity#numpy.ufunc.identity&quot;&gt;&lt;code&gt;identity&lt;/code&gt;&lt;/a&gt; attribute of the resulting object. If specified, this is equivalent to setting the underlying C &lt;code&gt;identity&lt;/code&gt; field to &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt;. If omitted, the identity is set to &lt;code&gt;PyUFunc_None&lt;/code&gt;. Note that this is _not_ equivalent to setting the identity to &lt;code&gt;None&lt;/code&gt;, which implies the operation is reorderable.</source>
          <target state="translated">結果のオブジェクトの&lt;a href=&quot;numpy.ufunc.identity#numpy.ufunc.identity&quot;&gt; &lt;code&gt;identity&lt;/code&gt; &lt;/a&gt;属性に使用する値。指定された場合、これは、基礎となるCの設定と同等です &lt;code&gt;identity&lt;/code&gt; にフィールドを &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt; 。省略した場合、IDは &lt;code&gt;PyUFunc_None&lt;/code&gt; に設定されます。これは、IDを &lt;code&gt;None&lt;/code&gt; に設定することと同等ではないことに注意してください。これは、操作が並べ替え可能であることを意味します。</target>
        </trans-unit>
        <trans-unit id="adfb1baad553fefd1bd16dad3fa307f22463d54c" translate="yes" xml:space="preserve">
          <source>The value where the peak of the distribution occurs. The value must fulfill the condition &lt;code&gt;left &amp;lt;= mode &amp;lt;= right&lt;/code&gt;.</source>
          <target state="translated">分布のピークが発生する値。値は、条件 &lt;code&gt;left &amp;lt;= mode &amp;lt;= right&lt;/code&gt; 満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="686c0ef41d4f40d919659043042cba31d0a83ddd" translate="yes" xml:space="preserve">
          <source>The value whose minimal data type is to be found.</source>
          <target state="translated">データ型が最小となる値。</target>
        </trans-unit>
        <trans-unit id="ec08073e01c06623c4f6388732ecfb40030e861d" translate="yes" xml:space="preserve">
          <source>The value with which to start the reduction. If the ufunc has no identity or the dtype is object, this defaults to None - otherwise it defaults to ufunc.identity. If &lt;code&gt;None&lt;/code&gt; is given, the first element of the reduction is used, and an error is thrown if the reduction is empty.</source>
          <target state="translated">削減を開始する値。ufuncにIDがない場合、またはdtypeがオブジェクトの場合、これはデフォルトでNoneになります。それ以外の場合は、デフォルトでufunc.identityになります。 &lt;code&gt;None&lt;/code&gt; が指定された場合、削減の最初の要素が使用され、削減が空の場合はエラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="c02e60b2cf88beea9b6213b9d1e3b2c17ab885eb" translate="yes" xml:space="preserve">
          <source>The value(s) whose arccos is (are) required.</source>
          <target state="translated">arccosが必要な値(複数可)です。</target>
        </trans-unit>
        <trans-unit id="183fa270f0d1fa6f702a51a2364673ed5612bfd2" translate="yes" xml:space="preserve">
          <source>The value(s) whose arcsin is (are) required.</source>
          <target state="translated">arcsinが必要な値です。</target>
        </trans-unit>
        <trans-unit id="1d4cd85936bff2c0840b52fb0d1f9b2b867275e7" translate="yes" xml:space="preserve">
          <source>The value(s) whose arctanh is (are) required.</source>
          <target state="translated">arctanhの値が必要です。</target>
        </trans-unit>
        <trans-unit id="d21864f90829a08fd0ce039dcaefd6c6c1041816" translate="yes" xml:space="preserve">
          <source>The value(s) whose log base 10 is (are) required.</source>
          <target state="translated">log base 10の値が必要となります。</target>
        </trans-unit>
        <trans-unit id="3a56b30d194880ee472ad588027f66ef7c7510ff" translate="yes" xml:space="preserve">
          <source>The value(s) whose log base 2 is (are) required.</source>
          <target state="translated">log base 2の値が必要です。</target>
        </trans-unit>
        <trans-unit id="bfb30aa30026604ddea308e1175db0c56c2dbb97" translate="yes" xml:space="preserve">
          <source>The value(s) whose log base &lt;code&gt;n&lt;/code&gt; is (are) required.</source>
          <target state="translated">対数基数 &lt;code&gt;n&lt;/code&gt; が必要な値。</target>
        </trans-unit>
        <trans-unit id="b2591ea528e39e4354f5f1d5877efb3bad7380af" translate="yes" xml:space="preserve">
          <source>The value(s) whose log is (are) required.</source>
          <target state="translated">ログが必要な値(複数可)。</target>
        </trans-unit>
        <trans-unit id="930e3ad8c3851bb30a80a559ca4a2af60560b1ff" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;ar1[in1d]&lt;/code&gt; are in &lt;code&gt;ar2&lt;/code&gt;.</source>
          <target state="translated">値 &lt;code&gt;ar1[in1d]&lt;/code&gt; は &lt;code&gt;ar2&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="a4cb91abe1a0f589bcf1ee9ebaba06339dc294dc" translate="yes" xml:space="preserve">
          <source>The values against which to test each value of &lt;code&gt;ar1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ar1&lt;/code&gt; の各値をテストする値。</target>
        </trans-unit>
        <trans-unit id="55096101173292ac6a418aa55429cc3cfcc3d718" translate="yes" xml:space="preserve">
          <source>The values against which to test each value of &lt;code&gt;element&lt;/code&gt;. This argument is flattened if it is an array or array_like. See notes for behavior with non-array-like parameters.</source>
          <target state="translated">&lt;code&gt;element&lt;/code&gt; の各値をテストする値。この引数は、配列またはarray_likeの場合、フラット化されます。配列のようなパラメータ以外の動作については、注意を参照してください。</target>
        </trans-unit>
        <trans-unit id="10fa1bca5c63978c522a37d289203eb7633c9fb5" translate="yes" xml:space="preserve">
          <source>The values in the rank-1 array &lt;code&gt;p&lt;/code&gt; are coefficients of a polynomial. If the length of &lt;code&gt;p&lt;/code&gt; is n+1 then the polynomial is described by:</source>
          <target state="translated">ランク1の配列 &lt;code&gt;p&lt;/code&gt; の値は、多項式の係数です。 &lt;code&gt;p&lt;/code&gt; の長さがn + 1の場合、多項式は次のように記述されます。</target>
        </trans-unit>
        <trans-unit id="427b2ca25633b731d69a885f7ebcb443f1d11f04" translate="yes" xml:space="preserve">
          <source>The values in the result follow so-called &amp;ldquo;standard&amp;rdquo; order: If &lt;code&gt;A =
fft(a, n)&lt;/code&gt;, then &lt;code&gt;A[0]&lt;/code&gt; contains the zero-frequency term (the sum of the signal), which is always purely real for real inputs. Then &lt;code&gt;A[1:n/2]&lt;/code&gt; contains the positive-frequency terms, and &lt;code&gt;A[n/2+1:]&lt;/code&gt; contains the negative-frequency terms, in order of decreasingly negative frequency. For an even number of input points, &lt;code&gt;A[n/2]&lt;/code&gt; represents both positive and negative Nyquist frequency, and is also purely real for real input. For an odd number of input points, &lt;code&gt;A[(n-1)/2]&lt;/code&gt; contains the largest positive frequency, while &lt;code&gt;A[(n+1)/2]&lt;/code&gt; contains the largest negative frequency. The routine &lt;code&gt;np.fft.fftfreq(n)&lt;/code&gt; returns an array giving the frequencies of corresponding elements in the output. The routine &lt;code&gt;np.fft.fftshift(A)&lt;/code&gt; shifts transforms and their frequencies to put the zero-frequency components in the middle, and &lt;code&gt;np.fft.ifftshift(A)&lt;/code&gt; undoes that shift.</source>
          <target state="translated">結果の値は、いわゆる「標準」の順序に従います &lt;code&gt;A = fft(a, n)&lt;/code&gt; 場合、 &lt;code&gt;A[0]&lt;/code&gt; は、ゼロ周波数の項（信号の合計）が含まれます。入力。次に、 &lt;code&gt;A[1:n/2]&lt;/code&gt; には正の周波数の項が含まれ、 &lt;code&gt;A[n/2+1:]&lt;/code&gt; には負の周波数の項が含まれ、負の周波数の順に減少します。偶数の入力ポイントの場合、 &lt;code&gt;A[n/2]&lt;/code&gt; は正と負の両方のナイキスト周波数を表し、実際の入力では純粋に実数になります。奇数の入力ポイントの場合、 &lt;code&gt;A[(n-1)/2]&lt;/code&gt; は最大の正の周波数を含み、 &lt;code&gt;A[(n+1)/2]&lt;/code&gt; は最大の負の周波数を含みます。ルーチン &lt;code&gt;np.fft.fftfreq(n)&lt;/code&gt; は、出力内の対応する要素の頻度を示す配列を返します。ルーチン &lt;code&gt;np.fft.fftshift(A)&lt;/code&gt; は変換とその周波数をシフトしてゼロ周波数成分を中央に &lt;code&gt;np.fft.ifftshift(A)&lt;/code&gt; 、np.fft.ifftshift（A）はそのシフトを元に戻します。</target>
        </trans-unit>
        <trans-unit id="049629d5662346c69d1da68173623b07fbd3ce2f" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;R&lt;/code&gt; are between -1 and 1, inclusive.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; の値は-1から1の間です。</target>
        </trans-unit>
        <trans-unit id="9be1b3aaf13595cf59a1cfa63bbe9d63fd300725" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;x1&lt;/code&gt; with the sign of &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x2&lt;/code&gt; の符号付きの &lt;code&gt;x1&lt;/code&gt; の値。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="0b6f0a3f189dc33bd74c3b4b3649d7d6ee49f75c" translate="yes" xml:space="preserve">
          <source>The values of the histogram. See &lt;code&gt;density&lt;/code&gt; and &lt;code&gt;weights&lt;/code&gt; for a description of the possible semantics.</source>
          <target state="translated">ヒストグラムの値。可能なセマンティクスの説明については、 &lt;code&gt;density&lt;/code&gt; と &lt;code&gt;weights&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="94c9275f5f339f7a7296146a88f4dacc4958d420" translate="yes" xml:space="preserve">
          <source>The values of the multidimension polynomial on points formed with triples of corresponding values from &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、 &lt;code&gt;z&lt;/code&gt; からの対応する値のトリプルで形成された点の多次元多項式の値。</target>
        </trans-unit>
        <trans-unit id="000e1e6aea9b8f07ac10536f42598c0ea9bb0313" translate="yes" xml:space="preserve">
          <source>The values of the multidimensional polynomial on points formed with triples of corresponding values from &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、 &lt;code&gt;z&lt;/code&gt; からの対応する値のトリプルで形成された点の多次元多項式の値。</target>
        </trans-unit>
        <trans-unit id="04875120c52fa413c52d82fe0fc8626bcc9f10c7" translate="yes" xml:space="preserve">
          <source>The values of the time series of cash flows. The (fixed) time interval between cash flow &amp;ldquo;events&amp;rdquo; must be the same as that for which &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; is given (i.e., if &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; is per year, then precisely a year is understood to elapse between each cash flow event). By convention, investments or &amp;ldquo;deposits&amp;rdquo; are negative, income or &amp;ldquo;withdrawals&amp;rdquo; are positive; &lt;code&gt;values&lt;/code&gt; must begin with the initial investment, thus &lt;code&gt;values[0]&lt;/code&gt; will typically be negative.</source>
          <target state="translated">キャッシュフローの時系列の値。キャッシュフローの「イベント」間の（固定）時間間隔は、&lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt;が指定されている時間間隔と同じでなければなりません（つまり、&lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt;が1年あたりの場合、各キャッシュフローイベント間で正確に1年が経過すると理解されます）。慣例により、投資または「預金」はマイナスであり、収入または「引き出し」はプラスです。 &lt;code&gt;values&lt;/code&gt; は初期投資で始まる必要があるため、 &lt;code&gt;values[0]&lt;/code&gt; は通常負になります。</target>
        </trans-unit>
        <trans-unit id="1a3aeed326405c6ff97973ff76e3c1ac5b78c950" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Chebyshev series at points formed from pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; からの対応する値のペアから形成された点での2次元チェビシェフシリーズの値。</target>
        </trans-unit>
        <trans-unit id="d500e0f26328b27b56cc6ea280ce335971a39a93" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Chebyshev series at points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; のデカルト積の点における2次元のチェビシェフシリーズの値。</target>
        </trans-unit>
        <trans-unit id="118ceee048eeb019cc7036790e58ad86a6694410" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Legendre series at points formed from pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; からの対応する値のペアから形成された点での2次元ルジャンドル系列の値。</target>
        </trans-unit>
        <trans-unit id="75bce5c26e8d20f2a28b76fe4bee99ba20e34131" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional polynomial at points formed with pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; からの対応する値のペアで形成された点の2次元多項式の値。</target>
        </trans-unit>
        <trans-unit id="fb47214ec0ab61ed4f83b6664e41c0aa8a83d3ed" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional polynomial at points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; のデカルト積の点における2次元多項式の値。</target>
        </trans-unit>
        <trans-unit id="7d3e958b62535b85e2d7d32e34bc42123eb7d409" translate="yes" xml:space="preserve">
          <source>The values reported are normalized relative to the speed of MT19937 in each table. A value of 100 indicates that the performance matches the MT19937. Higher values indicate improved performance. These values cannot be compared across tables.</source>
          <target state="translated">報告された値は、各テーブルのMT19937の速度と比較して正規化されています。100の値は、性能がMT19937と一致していることを示しています。値が大きいほど性能が向上していることを示しています。これらの値は、テーブル間で比較することはできません。</target>
        </trans-unit>
        <trans-unit id="d8a3da63b70322018b836bf5f65f57d16d3ac651" translate="yes" xml:space="preserve">
          <source>The values whose cube-roots are required.</source>
          <target state="translated">立方根が必要とされる値。</target>
        </trans-unit>
        <trans-unit id="b42bae2bd42a8c9e82a7332d1979f8a09c759feb" translate="yes" xml:space="preserve">
          <source>The values whose square-roots are required.</source>
          <target state="translated">平方根が必要な値。</target>
        </trans-unit>
        <trans-unit id="187833930bd2cba800be6e8dd52776f374cc2f1c" translate="yes" xml:space="preserve">
          <source>The variable obtained by summing the squares of &lt;code&gt;df&lt;/code&gt; independent, standard normally distributed random variables:</source>
          <target state="translated">&lt;code&gt;df&lt;/code&gt; 独立した標準正規分布確率変数の2乗を合計して得られる変数：</target>
        </trans-unit>
        <trans-unit id="fddb7e65a48e5500c69e424836450e7732656827" translate="yes" xml:space="preserve">
          <source>The variable used in the string representation of &lt;code&gt;p&lt;/code&gt; can be modified, using the &lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt;&lt;code&gt;variable&lt;/code&gt;&lt;/a&gt; parameter:</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; の文字列表現で使用される&lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt; &lt;code&gt;variable&lt;/code&gt; &lt;/a&gt;は、variableパラメーターを使用して変更できます。</target>
        </trans-unit>
        <trans-unit id="032af5a223b6a82b2905b5c850f693e8fec137cd" translate="yes" xml:space="preserve">
          <source>The variance is the average of the squared deviations from the mean, i.e., &lt;code&gt;var = mean(abs(x - x.mean())**2)&lt;/code&gt;.</source>
          <target state="translated">分散は、平均からの偏差の二乗の平均です。つまり、 &lt;code&gt;var = mean(abs(x - x.mean())**2)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="4bc052e3f44988f0e29422c1a7d1c9ad7fd6f4a4" translate="yes" xml:space="preserve">
          <source>The variance is the average of the squared deviations from the mean, i.e., &lt;code&gt;var = mean(x)&lt;/code&gt;, where &lt;code&gt;x = abs(a - a.mean())**2&lt;/code&gt;.</source>
          <target state="translated">分散は、平均からの偏差の2乗の平均です。つまり、 &lt;code&gt;var = mean(x)&lt;/code&gt; 、ここで &lt;code&gt;x = abs(a - a.mean())**2&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="598bba43a5fa13ecb982a04e1ac2dcfa3fb5a79a" translate="yes" xml:space="preserve">
          <source>The various character codes indicating certain types are also part of an enumerated list. References to type characters (should they be needed at all) should always use these enumerations. The form of them is &lt;code&gt;NPY_{NAME}LTR&lt;/code&gt; where &lt;code&gt;{NAME}&lt;/code&gt; can be</source>
          <target state="translated">特定のタイプを示すさまざまな文字コードも、列挙リストの一部です。タイプ文字への参照（必要な場合）は、常にこれらの列挙を使用する必要があります。それらの形式は &lt;code&gt;NPY_{NAME}LTR&lt;/code&gt; で、 &lt;code&gt;{NAME}&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="d2bf21ee585f4c470168bc467b8b8760de8826fd" translate="yes" xml:space="preserve">
          <source>The various routines in the Polynomial package all deal with series whose coefficients go from degree zero upward, which is the &lt;em&gt;reverse order&lt;/em&gt; of the Poly1d convention. The easy way to remember this is that indexes correspond to degree, i.e., coef[i] is the coefficient of the term of degree i.</source>
          <target state="translated">多項式パッケージのさまざまなルーチンの係数である、上方度ゼロから行くシリーズのすべての契約&lt;em&gt;逆順&lt;/em&gt; Poly1d大会の。これを覚える簡単な方法は、インデックスが次数に対応することです。つまり、coef [i]は次数iの項の係数です。</target>
        </trans-unit>
        <trans-unit id="40dcb2f33f2d122b10f89906b0fa578dee7f50c3" translate="yes" xml:space="preserve">
          <source>The various selection algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The available algorithms have the following properties:</source>
          <target state="translated">様々なソートアルゴリズムは、平均速度、最悪の場合の性能、作業スペースの大きさ、安定しているかどうかによって特徴づけられています。安定したソートは、同じキーを持つアイテムを同じ相対順序で保持します。利用可能なアルゴリズムは以下のような特性を持っています。</target>
        </trans-unit>
        <trans-unit id="cc8322a9b3a11e0738c1dc848dd44452ebdc9f34" translate="yes" xml:space="preserve">
          <source>The various sorting algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The four algorithms implemented in NumPy have the following properties:</source>
          <target state="translated">様々なソートアルゴリズムは、平均速度、最悪の場合の性能、作業スペースの大きさ、安定しているかどうかによって特徴づけられています。安定したソートとは、同じキーを持つアイテムを同じ相対順序で並べ替えることです。NumPyで実装されている4つのアルゴリズムは、以下のような特性を持っています。</target>
        </trans-unit>
        <trans-unit id="909b1eaadbbd85f2064b83f98f4324e7aba0802c" translate="yes" xml:space="preserve">
          <source>The vdot(&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;) function handles complex numbers differently than dot(&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;). If the first argument is complex the complex conjugate of the first argument is used for the calculation of the dot product.</source>
          <target state="translated">vdot（ &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; ）関数は、dot（ &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; ）とは異なる方法で複素数を処理します。最初の引数が複素数の場合、最初の引数の複素共役が内積の計算に使用されます。</target>
        </trans-unit>
        <trans-unit id="f8aeebbf639e209f314766460959c079ab13f5dd" translate="yes" xml:space="preserve">
          <source>The version 1.0 format only allowed the array header to have a total size of 65535 bytes. This can be exceeded by structured arrays with a large number of columns. The version 2.0 format extends the header size to 4 GiB. &lt;a href=&quot;numpy.save#numpy.save&quot;&gt;&lt;code&gt;numpy.save&lt;/code&gt;&lt;/a&gt; will automatically save in 2.0 format if the data requires it, else it will always use the more compatible 1.0 format.</source>
          <target state="translated">バージョン1.0形式では、配列ヘッダーの合計サイズは65535バイトのみでした。これは、列の数が多い構造化配列では超過する可能性があります。バージョン2.0形式では、ヘッダーサイズが4 GiBに拡張されています。&lt;a href=&quot;numpy.save#numpy.save&quot;&gt; &lt;code&gt;numpy.save&lt;/code&gt; &lt;/a&gt;は、データに必要な場合は自動的に2.0形式で保存します。それ以外の場合は、常により互換性のある1.0形式を使用します。</target>
        </trans-unit>
        <trans-unit id="7a92769f6aa86193f32ae6d12aa9581114703198" translate="yes" xml:space="preserve">
          <source>The version 2 interface was very similar. The differences were largely aesthetic. In particular:</source>
          <target state="translated">バージョン2のインターフェイスは非常に似ていました。違いは主に審美的なものでした。特に</target>
        </trans-unit>
        <trans-unit id="73bb55ce329b913976b213535f9642d82795177e" translate="yes" xml:space="preserve">
          <source>The version numbering of these formats is independent of NumPy version numbering. If the format is upgraded, the code in &lt;code&gt;numpy.io&lt;/code&gt; will still be able to read and write Version 1.0 files.</source>
          <target state="translated">これらのフォーマットのバージョン番号は、NumPyのバージョン番号とは無関係です。フォーマットがアップグレードされた場合でも、 &lt;code&gt;numpy.io&lt;/code&gt; のコードはバージョン1.0ファイルを読み書きできます。</target>
        </trans-unit>
        <trans-unit id="d465b2400649c410304e54f051f7d49aa970de97" translate="yes" xml:space="preserve">
          <source>The von Mises distribution (also known as the circular normal distribution) is a continuous probability distribution on the unit circle. It may be thought of as the circular analogue of the normal distribution.</source>
          <target state="translated">フォン・ミーゼス分布(円正規分布としても知られている)は,単位円上の連続確率分布である.正規分布の円のアナログと考えられています。</target>
        </trans-unit>
        <trans-unit id="08a316a93b85a841b11a6055717875d0502f2c60" translate="yes" xml:space="preserve">
          <source>The von Mises is named for Richard Edler von Mises, who was born in Austria-Hungary, in what is now the Ukraine. He fled to the United States in 1939 and became a professor at Harvard. He worked in probability theory, aerodynamics, fluid mechanics, and philosophy of science.</source>
          <target state="translated">フォン・ミーゼスは、オーストリア・ハンガリー、現在のウクライナに生まれたリチャード・エドラー・フォン・ミーゼスにちなんで命名された。1939年にアメリカに亡命し、ハーバード大学の教授となった。確率論、空気力学、流体力学、科学哲学などを研究した。</target>
        </trans-unit>
        <trans-unit id="c66491ff606b4dc91911613d519dc8370dc0d225" translate="yes" xml:space="preserve">
          <source>The warnings can be turned off by</source>
          <target state="translated">警告は</target>
        </trans-unit>
        <trans-unit id="a3b6182c6d54b721f88f41929f57467a3fff8892" translate="yes" xml:space="preserve">
          <source>The weight function at &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; での重み関数。</target>
        </trans-unit>
        <trans-unit id="88ba21dce5f8f071e2673c0f1f06439caa2807d7" translate="yes" xml:space="preserve">
          <source>The weight function is</source>
          <target state="translated">重量関数は</target>
        </trans-unit>
        <trans-unit id="308836c1d8a38528ab14ca4524532677c1153f22" translate="yes" xml:space="preserve">
          <source>The weight function of the Chebyshev polynomials.</source>
          <target state="translated">チェビシェフ多項式の重み関数。</target>
        </trans-unit>
        <trans-unit id="adb5d593e92bd3e7a619595dc278c8d8865de5f1" translate="yes" xml:space="preserve">
          <source>The wheels and source should be uploaded to PyPI.</source>
          <target state="translated">ホイールとソースはPyPIにアップロードしておきます。</target>
        </trans-unit>
        <trans-unit id="8a75026ea8d79cfa948ad8144c46e90db33a682b" translate="yes" xml:space="preserve">
          <source>The wheels, once built, appear at &lt;a href=&quot;https://anaconda.org/multibuild-wheels-staging/numpy&quot;&gt;https://anaconda.org/multibuild-wheels-staging/numpy&lt;/a&gt;</source>
          <target state="translated">ホイールが構築されると、&lt;a href=&quot;https://anaconda.org/multibuild-wheels-staging/numpy&quot;&gt;https：//anaconda.org/multibuild-wheels-staging/numpy&lt;/a&gt;に表示されます</target>
        </trans-unit>
        <trans-unit id="9b231b3ccfadec2079a40387b8d56e7ec8b9bb3d" translate="yes" xml:space="preserve">
          <source>The window of the converted series. If the value is None, the default window of &lt;code&gt;kind&lt;/code&gt; is used.</source>
          <target state="translated">変換されたシリーズのウィンドウ。値がNoneの場合、デフォルトの &lt;code&gt;kind&lt;/code&gt; ウィンドウが使用されます。</target>
        </trans-unit>
        <trans-unit id="1da2fe6ad3abf125b431351fbdd12b7a74edc3f3" translate="yes" xml:space="preserve">
          <source>The window, with the maximum value normalized to one (the value one appears only if &lt;code&gt;M&lt;/code&gt; is odd).</source>
          <target state="translated">最大値を1に正規化したウィンドウ（値1 は &lt;code&gt;M&lt;/code&gt; が奇数の場合にのみ表示されます）。</target>
        </trans-unit>
        <trans-unit id="48ac736d93f8e7e8643c8e0f7b0c321855533edd" translate="yes" xml:space="preserve">
          <source>The window, with the maximum value normalized to one (the value one appears only if the number of samples is odd).</source>
          <target state="translated">最大値を1に正規化したウィンドウ(サンプル数が奇数の場合のみ値1が表示されます)。</target>
        </trans-unit>
        <trans-unit id="523eb308fcdc8d9a4d1dacdeabc03bc7b0a18f42" translate="yes" xml:space="preserve">
          <source>The word &amp;ldquo;non-zero&amp;rdquo; is in reference to the Python 2.x built-in method &lt;code&gt;__nonzero__()&lt;/code&gt; (renamed &lt;code&gt;__bool__()&lt;/code&gt; in Python 3.x) of Python objects that tests an object&amp;rsquo;s &amp;ldquo;truthfulness&amp;rdquo;. For example, any number is considered truthful if it is nonzero, whereas any string is considered truthful if it is not the empty string. Thus, this function (recursively) counts how many elements in &lt;code&gt;a&lt;/code&gt; (and in sub-arrays thereof) have their &lt;code&gt;__nonzero__()&lt;/code&gt; or &lt;code&gt;__bool__()&lt;/code&gt; method evaluated to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">「非ゼロ」という言葉は、オブジェクトの「真実性」をテストするPythonオブジェクトのPython 2.x組み込みメソッド &lt;code&gt;__nonzero__()&lt;/code&gt; （Python 3.xでは &lt;code&gt;__bool__()&lt;/code&gt; に名前が変更された）を参照しています。たとえば、ゼロ以外の数値は真であると見なされ、空の文字列ではない文字列は真であると見なされます。したがって、この関数は（再帰的に） &lt;code&gt;a&lt;/code&gt; （およびそのサブ配列）内の &lt;code&gt;__nonzero__()&lt;/code&gt; または &lt;code&gt;__bool__()&lt;/code&gt; メソッドが &lt;code&gt;True&lt;/code&gt; に評価された要素の数をカウントします。</target>
        </trans-unit>
        <trans-unit id="a3f383c240aa5414ebaced6e3034416ca7d1b6af" translate="yes" xml:space="preserve">
          <source>The wrap option affects only tall matrices:</source>
          <target state="translated">wrap オプシ ョ ンは、 背の高い行列にのみ影響を与えます。</target>
        </trans-unit>
        <trans-unit id="fc81c936c38ae025ba8146e1222f7da14b956b1d" translate="yes" xml:space="preserve">
          <source>The x-coordinate sequence is expected to be increasing, but this is not explicitly enforced. However, if the sequence &lt;code&gt;xp&lt;/code&gt; is non-increasing, interpolation results are meaningless.</source>
          <target state="translated">x座標シーケンスは増加すると予想されますが、これは明示的に強制されていません。ただし、シーケンス &lt;code&gt;xp&lt;/code&gt; が増加していない場合、補間結果は無意味です。</target>
        </trans-unit>
        <trans-unit id="f30f1b95441858e7d3037adb27c5185133726d2e" translate="yes" xml:space="preserve">
          <source>The x-coordinates at which to evaluate the interpolated values.</source>
          <target state="translated">補間された値を評価するx座標。</target>
        </trans-unit>
        <trans-unit id="98e412a8d1f1dc441497184c5505f308bf594274" translate="yes" xml:space="preserve">
          <source>The x-coordinates of the data points, must be increasing if argument &lt;code&gt;period&lt;/code&gt; is not specified. Otherwise, &lt;code&gt;xp&lt;/code&gt; is internally sorted after normalizing the periodic boundaries with &lt;code&gt;xp = xp % period&lt;/code&gt;.</source>
          <target state="translated">引数の &lt;code&gt;period&lt;/code&gt; が指定されていない場合、データポイントのx座標は増加している必要があります。それ以外の場合、 &lt;code&gt;xp&lt;/code&gt; &lt;code&gt;xp = xp % period&lt;/code&gt; 周期境界を正規化した後、xpは内部的にソートされます。</target>
        </trans-unit>
        <trans-unit id="5fb42b6312c1e1cea4c01b6bb567b8d84d30c4b2" translate="yes" xml:space="preserve">
          <source>The y-coordinates of the data points, same length as &lt;code&gt;xp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;xp&lt;/code&gt; と同じ長さのデータポイントのy座標。</target>
        </trans-unit>
        <trans-unit id="0716cf4800278ada150f876e9ddcae3c99250b13" translate="yes" xml:space="preserve">
          <source>Their are two basic approaches to calling compiled code: writing an extension module that is then imported to Python using the import command, or calling a shared-library subroutine directly from Python using the &lt;a href=&quot;https://docs.python.org/3/library/ctypes.html&quot;&gt;ctypes&lt;/a&gt; module. Writing an extension module is the most common method.</source>
          <target state="translated">これらは、コンパイル済みコードを呼び出すための2つの基本的なアプローチです。importコマンドを使用してPythonにインポートされる拡張モジュールを作成するか、&lt;a href=&quot;https://docs.python.org/3/library/ctypes.html&quot;&gt;ctypes&lt;/a&gt;モジュールを使用してPythonから直接共有ライブラリサブルーチンを呼び出します。拡張モジュールを作成するのが最も一般的な方法です。</target>
        </trans-unit>
        <trans-unit id="13617ef6d1ed670620e3eee1fe6521faed558f33" translate="yes" xml:space="preserve">
          <source>Their contents are described below.</source>
          <target state="translated">その内容は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="d67a14bba38674d133aa6326e1d56a5430227ffd" translate="yes" xml:space="preserve">
          <source>Then modify it as follows</source>
          <target state="translated">その後、以下のように修正します。</target>
        </trans-unit>
        <trans-unit id="629d9c8c7e969c90c99e3fcb123c3c923c445b2e" translate="yes" xml:space="preserve">
          <source>Then set your name and email:</source>
          <target state="translated">続いて、お名前とEメールを設定します。</target>
        </trans-unit>
        <trans-unit id="18de376fec5af9b24c105e03578c15d330983aed" translate="yes" xml:space="preserve">
          <source>Then you can obtain a lot of useful information (first details about &lt;code&gt;a&lt;/code&gt; itself, followed by the docstring of &lt;code&gt;ndarray&lt;/code&gt; of which &lt;code&gt;a&lt;/code&gt; is an instance):</source>
          <target state="translated">そして、あなたは（約最初の詳細有益な情報をたくさん得ることができますのドキュメント文字列が続い自体、 &lt;code&gt;ndarray&lt;/code&gt; そのインスタンスです）： &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="beca14a81e09ec62e1fbfc41746f56a23c04a2b2" translate="yes" xml:space="preserve">
          <source>Then, I can compile the extension module using:</source>
          <target state="translated">それから、拡張モジュールを使ってコンパイルすることができます。</target>
        </trans-unit>
        <trans-unit id="daa5af99f0618068c146112b2487469ac95f27c4" translate="yes" xml:space="preserve">
          <source>Then, all the HTML files will be generated in &lt;code&gt;doc/build/html/&lt;/code&gt;. Since the documentation is based on docstrings, the appropriate version of numpy must be installed in the host python used to run sphinx.</source>
          <target state="translated">次に、すべてのHTMLファイルが &lt;code&gt;doc/build/html/&lt;/code&gt; 生成されます。ドキュメントはdocstringに基づいているため、sphinxの実行に使用されるホストPythonに適切なバージョンのnumpyをインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="7bbaffa25ddeac5ba58545ce47397f8a88d6c19f" translate="yes" xml:space="preserve">
          <source>Then, create a new branch based on the master branch of the upstream repository:</source>
          <target state="translated">そして、上流のリポジトリのマスターブランチをベースに新しいブランチを作成します。</target>
        </trans-unit>
        <trans-unit id="a64f3ff6d48531fcbe93b1b844e9cc7950b3eeb4" translate="yes" xml:space="preserve">
          <source>Then, go to your forked repository github page, say &lt;code&gt;https://github.com/your-user-name/numpy&lt;/code&gt;</source>
          <target state="translated">次に、フォークされたリポジトリのgithubページに移動します。たとえば、 &lt;code&gt;https://github.com/your-user-name/numpy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="2a2d6eb0d79238cba7c8636b58f3ce6ad4b5b344" translate="yes" xml:space="preserve">
          <source>There are 4 relevant uses of the word &lt;code&gt;align&lt;/code&gt; used in numpy:</source>
          <target state="translated">numpyで使用される &lt;code&gt;align&lt;/code&gt; という単語の4つの関連する用途があります。</target>
        </trans-unit>
        <trans-unit id="d627a19c8c5bea4de4ec9dd15face492281b6f90" translate="yes" xml:space="preserve">
          <source>There are 5 basic numerical types representing booleans (bool), integers (int), unsigned integers (uint) floating point (float) and complex. Those with numbers in their name indicate the bitsize of the type (i.e. how many bits are needed to represent a single value in memory). Some types, such as &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;intp&lt;/code&gt;, have differing bitsizes, dependent on the platforms (e.g. 32-bit vs. 64-bit machines). This should be taken into account when interfacing with low-level code (such as C or Fortran) where the raw memory is addressed.</source>
          <target state="translated">ブール（bool）、整数（int）、符号なし整数（uint）浮動小数点（float）、および複素数を表す5つの基本的な数値タイプがあります。名前に数字が含まれているものは、タイプのビットサイズ（つまり、メモリ内の単一の値を表すために必要なビット数）を示します。 &lt;code&gt;int&lt;/code&gt; や &lt;code&gt;intp&lt;/code&gt; などの一部のタイプは、プラットフォームに応じてビットサイズが異なります（32ビットマシンと64ビットマシンなど）。これは、生のメモリがアドレス指定される低レベルのコード（CやFortranなど）とインターフェイスするときに考慮に入れる必要があります。</target>
        </trans-unit>
        <trans-unit id="17bb2653ac2aa7153e927fc1353ff32c9d0fadd9" translate="yes" xml:space="preserve">
          <source>There are 5 general mechanisms for creating arrays:</source>
          <target state="translated">配列を作成するための一般的な仕組みは5つあります。</target>
        </trans-unit>
        <trans-unit id="4a7e737fa7ec2df18d82d046fe4547a421ecb3b7" translate="yes" xml:space="preserve">
          <source>There are 6 (binary) flags that describe the memory area used by the data buffer. These constants are defined in &lt;code&gt;arrayobject.h&lt;/code&gt; and determine the bit-position of the flag. Python exposes a nice attribute- based interface as well as a dictionary-like interface for getting (and, if appropriate, setting) these flags.</source>
          <target state="translated">データバッファーによって使用されるメモリ領域を説明する6つの（バイナリ）フラグがあります。これらの定数は &lt;code&gt;arrayobject.h&lt;/code&gt; で定義され、フラグのビット位置を決定します。Pythonは、これらのフラグを取得（および必要に応じて設定）するための、辞書に似たインターフェースだけでなく、属性ベースのインターフェースも公開しています。</target>
        </trans-unit>
        <trans-unit id="92880b58f6bd9442d0573770c5bcc16b810e1cdc" translate="yes" xml:space="preserve">
          <source>There are &lt;code&gt;num&lt;/code&gt; equally spaced samples in the closed interval &lt;code&gt;[start, stop]&lt;/code&gt; or the half-open interval &lt;code&gt;[start, stop)&lt;/code&gt; (depending on whether &lt;code&gt;endpoint&lt;/code&gt; is True or False).</source>
          <target state="translated">閉じた間隔 &lt;code&gt;[start, stop]&lt;/code&gt; または半分開いた間隔 &lt;code&gt;[start, stop)&lt;/code&gt; ]に、等間隔のサンプルが &lt;code&gt;num&lt;/code&gt; 個あります（ &lt;code&gt;endpoint&lt;/code&gt; がTrueかFalse かによって異なります）。</target>
        </trans-unit>
        <trans-unit id="8269e59da4433043c91490542198a44ae2a7bd22" translate="yes" xml:space="preserve">
          <source>There are a few commonly reported issues depending on your system/setup. If none of the following tips help you, please be sure to note the following:</source>
          <target state="translated">お使いのシステム/設定によっては、一般的に報告されている問題がいくつかあります。以下のヒントのどれも役に立たない場合は、必ず以下の点に注意してください。</target>
        </trans-unit>
        <trans-unit id="c1df47117b7e4e6ae3cadbfbaa9a3f7c95c99296" translate="yes" xml:space="preserve">
          <source>There are a few situations where masked arrays can be more useful than just eliminating the invalid entries of an array:</source>
          <target state="translated">マスキングされた配列は、単に配列の無効なエントリを排除するだけでなく、より有用な状況がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="6f20349ffc92d6259aa973ed6765d972938b14bd" translate="yes" xml:space="preserve">
          <source>There are a number of ways to assign values to a structured array: Using python tuples, using scalar values, or using other structured arrays.</source>
          <target state="translated">構造化配列に値を代入する方法はいくつかあります。pythonのタプルを使う、スカラ値を使う、他の構造化配列を使う、などです。</target>
        </trans-unit>
        <trans-unit id="aabadb6a5aa99979671de060b5cf5eb2bfdc73b8" translate="yes" xml:space="preserve">
          <source>There are a variety of approaches one can use. If the file has a relatively simple format then one can write a simple I/O library and use the numpy fromfile() function and .tofile() method to read and write numpy arrays directly (mind your byteorder though!) If a good C or C++ library exists that read the data, one can wrap that library with a variety of techniques though that certainly is much more work and requires significantly more advanced knowledge to interface with C or C++.</source>
          <target state="translated">様々なアプローチがあります。ファイルの形式が比較的単純な場合は、単純なI/Oライブラリを書いて、numpy fromfile()関数と.tofile()メソッドを使ってnumpy配列を直接読み書きすることができます(ただし、バイトオーダーには注意してください!)。データを読み込めるCやC++ライブラリが存在する場合は、そのライブラリを様々なテクニックでラップすることができますが、確かにそれはより多くの作業を必要とし、CやC++とのインターフェースにはかなり高度な知識が必要です。</target>
        </trans-unit>
        <trans-unit id="6009b813cfbdbc400ba73901cd26bc8dc165215e" translate="yes" xml:space="preserve">
          <source>There are also typedefs for signed integers, unsigned integers, floating point, and complex floating point types of specific bit- widths. The available type names are</source>
          <target state="translated">また、符号付き整数、符号なし整数、浮動小数点、および特定のビット幅の複素浮動小数点型の型定義もあります。利用可能な型名は以下のとおりです。</target>
        </trans-unit>
        <trans-unit id="2cd3e7355c4c3985bff39b5837a16202e8c1540c" translate="yes" xml:space="preserve">
          <source>There are currently more than 60 universal functions defined in &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; on one or more types, covering a wide variety of operations. Some of these ufuncs are called automatically on arrays when the relevant infix notation is used (&lt;em&gt;e.g.&lt;/em&gt;, &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt;&lt;code&gt;add(a, b)&lt;/code&gt;&lt;/a&gt; is called internally when &lt;code&gt;a + b&lt;/code&gt; is written and &lt;em&gt;a&lt;/em&gt; or &lt;em&gt;b&lt;/em&gt; is an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;). Nevertheless, you may still want to use the ufunc call in order to use the optional output argument(s) to place the output(s) in an object (or objects) of your choice.</source>
          <target state="translated">現在、1つ以上の型で&lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; &lt;/a&gt;で定義されている60を超える汎用関数があり、さまざまな操作をカバーしています。これらのufuncの一部は、関連するインフィックス表記法が使用されると、配列で自動的に呼び出されます（&lt;em&gt;たとえば&lt;/em&gt;&lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt; &lt;code&gt;add(a, b)&lt;/code&gt; &lt;/a&gt; &lt;code&gt;a + b&lt;/code&gt; が書き込まれ、&lt;em&gt;a&lt;/em&gt;または&lt;em&gt;b&lt;/em&gt;が&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; である&lt;/a&gt;場合、add（a、b）は内部で呼び出されます）。それでも、オプションの出力引数を使用して、選択した1つまたは複数のオブジェクトに出力を配置するために、ufunc呼び出しを使用したい場合があります。</target>
        </trans-unit>
        <trans-unit id="775b5ff21441ff77356a90016945326f51981b32" translate="yes" xml:space="preserve">
          <source>There are fairly common issues when using PyCharm together with Anaconda, please see the &lt;a href=&quot;https://www.jetbrains.com/help/pycharm/conda-support-creating-conda-virtual-environment.html&quot;&gt;PyCharm support&lt;/a&gt;</source>
          <target state="translated">PyCharmをAnacondaと一緒に使用する場合、かなり一般的な問題があります&lt;a href=&quot;https://www.jetbrains.com/help/pycharm/conda-support-creating-conda-virtual-environment.html&quot;&gt;。PyCharmサポート&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="63abd249d8d4c496fdec07d0a25a5469a4e4f4df" translate="yes" xml:space="preserve">
          <source>There are formulas for writing useful documents, and four formulas cover nearly everything. There are four formulas because there are four categories of document &amp;ndash; &lt;code&gt;tutorial&lt;/code&gt;, &lt;code&gt;how-to guide&lt;/code&gt;, &lt;code&gt;explanation&lt;/code&gt;, and &lt;code&gt;reference&lt;/code&gt;. The insight that docs divide up this way belongs to Daniele Procida, who goes on &lt;a href=&quot;https://documentation.divio.com/&quot;&gt;in this short article&lt;/a&gt; to explain the differences and reveal the formulas. When you begin a document or propose one, have in mind which of these types it will be.</source>
          <target state="translated">有用な文書を書くための公式があり、4つの公式がほぼすべてをカバーしています。ドキュメントには、 &lt;code&gt;tutorial&lt;/code&gt; 、 &lt;code&gt;how-to guide&lt;/code&gt; 、 &lt;code&gt;explanation&lt;/code&gt; 、 &lt;code&gt;reference&lt;/code&gt; 4つのカテゴリがあるため、4つの式があります。ドキュメントがこのように分割される洞察は&lt;a href=&quot;https://documentation.divio.com/&quot;&gt;、この短い記事で&lt;/a&gt;違いを説明し、式を明らかにするDanieleProcidaに属します。ドキュメントを作成したり提案したりするときは、これらのタイプのどれになるかを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="3438358c09e82d3e17ac10e9485821f710c7159e" translate="yes" xml:space="preserve">
          <source>There are libraries that can be used to generate arrays for special purposes and it isn&amp;rsquo;t possible to enumerate all of them. The most common uses are use of the many array generation functions in random that can generate arrays of random values, and some utility functions to generate special matrices (e.g. diagonal).</source>
          <target state="translated">特別な目的で配列を生成するために使用できるライブラリがあり、それらすべてを列挙することはできません。最も一般的な使用法は、ランダムな値の配列を生成できるランダムな多くの配列生成関数の使用と、特別な行列（対角など）を生成するためのいくつかのユーティリティ関数です。</target>
        </trans-unit>
        <trans-unit id="c69a32040141b3969da2a2cbb310c56f38084713" translate="yes" xml:space="preserve">
          <source>There are lots of examples of how to use &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; throughout the NumPy source code. The standard usage is like this:</source>
          <target state="translated">NumPyソースコード全体で&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt;を使用する方法の例はたくさんあります。標準的な使用法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="68b9dbbab83df5d12e3f17adf9850959d4114286" translate="yes" xml:space="preserve">
          <source>There are many C or C++ array/NumPy array situations not covered by a simple &lt;code&gt;%include &quot;numpy.i&quot;&lt;/code&gt; and subsequent &lt;code&gt;%apply&lt;/code&gt; directives.</source>
          <target state="translated">単純な &lt;code&gt;%include &quot;numpy.i&quot;&lt;/code&gt; とそれに続く &lt;code&gt;%apply&lt;/code&gt; ディレクティブではカバーされない多くのCまたはC ++配列/ NumPy配列の状況があります。</target>
        </trans-unit>
        <trans-unit id="db56cb5ed387c40b2bc60fa8c76803719afb40fe" translate="yes" xml:space="preserve">
          <source>There are many online tutorials to help you &lt;a href=&quot;https://try.github.io/&quot;&gt;learn git&lt;/a&gt;. For discussions of specific git workflows, see these discussions on &lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;linux git workflow&lt;/a&gt;, and &lt;a href=&quot;https://mail.python.org/pipermail/ipython-dev/2010-October/005632.html&quot;&gt;ipython git workflow&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://try.github.io/&quot;&gt;git&lt;/a&gt;を学ぶのに役立つ多くのオンラインチュートリアルがあります。特定のgitワークフローの説明については、&lt;a href=&quot;https://mail.python.org/pipermail/ipython-dev/2010-October/005632.html&quot;&gt;linuxgitワークフロー&lt;/a&gt;およびipythongit&lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;ワークフロー&lt;/a&gt;に関するこれらの説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="a3c7bbd8e8aff936bd091f138c70193c9efdefe3" translate="yes" xml:space="preserve">
          <source>There are many online tutorials to help you &lt;a href=&quot;https://www.atlassian.com/git/tutorials/&quot;&gt;learn git&lt;/a&gt;. For discussions of specific git workflows, see these discussions on &lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;linux git workflow&lt;/a&gt;, and &lt;a href=&quot;http://mail.python.org/pipermail/ipython-dev/2010-October/006746.html&quot;&gt;ipython git workflow&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.atlassian.com/git/tutorials/&quot;&gt;git&lt;/a&gt;を学ぶのに役立つ多くのオンラインチュートリアルがあります。特定のgitワークフローの説明については、&lt;a href=&quot;http://mail.python.org/pipermail/ipython-dev/2010-October/006746.html&quot;&gt;linuxgitワークフロー&lt;/a&gt;およびipythongit&lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;ワークフロー&lt;/a&gt;に関するこれらの説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="4e7a362f552d6539941413dc2279097986613078" translate="yes" xml:space="preserve">
          <source>There are many ways of working with &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt;; here are some posts on the rules of thumb that other projects have come up with:</source>
          <target state="translated">&lt;a href=&quot;https://git-scm.com/&quot;&gt;gitを操作&lt;/a&gt;する方法はたくさんあります。他のプロジェクトが思いついた経験則に関するいくつかの投稿は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="850bf20dccfb45fbea5bb3bf4cc123a24de9ce74" translate="yes" xml:space="preserve">
          <source>There are many ways to define the DFT, varying in the sign of the exponent, normalization, etc. In this implementation, the DFT is defined as</source>
          <target state="translated">指数の符号、正規化など様々な方法でDFTを定義する方法があります。この実装では、DFTは次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="76da8844fec054fd5276e6ad85d740b68fcb82e8" translate="yes" xml:space="preserve">
          <source>There are no general requirements on the return value from &lt;code&gt;__array_function__&lt;/code&gt;, although most sensible implementations should probably return array(s) with the same type as one of the function&amp;rsquo;s arguments.</source>
          <target state="translated">&lt;code&gt;__array_function__&lt;/code&gt; からの戻り値に関する一般的な要件はありませんが、賢明な実装のほとんどは、関数の引数の1つと同じ型の配列を返すはずです。</target>
        </trans-unit>
        <trans-unit id="06faa5c6fcba06f9dd8ca92063029df6a41e4c58" translate="yes" xml:space="preserve">
          <source>There are often instances where we want NumPy to initialize the values of an array. NumPy offers functions like &lt;code&gt;ones()&lt;/code&gt; and &lt;code&gt;zeros()&lt;/code&gt;, and the &lt;code&gt;random.Generator&lt;/code&gt; class for random number generation for that. All you need to do is pass in the number of elements you want it to generate:</source>
          <target state="translated">NumPyに配列の値を初期化させたい場合がよくあります。NumPyは、 &lt;code&gt;ones()&lt;/code&gt; や &lt;code&gt;zeros()&lt;/code&gt; などの &lt;code&gt;random.Generator&lt;/code&gt; と、そのための乱数生成用のrandom.Generatorクラスを提供します。あなたがする必要があるのはあなたがそれが生成したい要素の数を渡すことです：</target>
        </trans-unit>
        <trans-unit id="95381d820ed4d179172c69e3a1efc8e39007df94" translate="yes" xml:space="preserve">
          <source>There are only integer array indices so that no subarray exists.</source>
          <target state="translated">配列のインデックスは整数だけなので、部分配列は存在しません。</target>
        </trans-unit>
        <trans-unit id="115526010a225042aa40f787fc2f47f797982daf" translate="yes" xml:space="preserve">
          <source>There are other points in the use of ndarrays where we need such views, such as copying arrays (&lt;code&gt;c_arr.copy()&lt;/code&gt;), creating ufunc output arrays (see also &lt;a href=&quot;#array-wrap&quot;&gt;__array_wrap__ for ufuncs and other functions&lt;/a&gt;), and reducing methods (like &lt;code&gt;c_arr.mean()&lt;/code&gt;).</source>
          <target state="translated">その他の点については、我々は、そのようなアレイ（コピーなどの景色、必要ndarraysの使用である &lt;code&gt;c_arr.copy()&lt;/code&gt; 、）ufunc出力アレイを作成する（参照&lt;a href=&quot;#array-wrap&quot;&gt;ufuncsおよび他の機能のために__array_wrap__&lt;/a&gt;など）、および方法を低減（ &lt;code&gt;c_arr.mean()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="72e1214b4766467e55cb3f8f030a4456afbf45a2" translate="yes" xml:space="preserve">
          <source>There are other wrapping situations in which &lt;code&gt;numpy.i&lt;/code&gt; may be helpful when you encounter them.</source>
          <target state="translated">他にも、 &lt;code&gt;numpy.i&lt;/code&gt; が発生したときに役立つようなラップ状況があります。</target>
        </trans-unit>
        <trans-unit id="318856ec210de70f7b88df3c75c2a12aaa8c93b2" translate="yes" xml:space="preserve">
          <source>There are pros and cons to using both:</source>
          <target state="translated">両方を使うことには賛否両論あります。</target>
        </trans-unit>
        <trans-unit id="f83bfa0078610ce5c1a2e851fa86300b3de47263" translate="yes" xml:space="preserve">
          <source>There are several disadvantages of using Cython:</source>
          <target state="translated">Cythonを使うことにはいくつかのデメリットがあります。</target>
        </trans-unit>
        <trans-unit id="1c928426bd7e5582ef0057cd443cd0554ec0f93c" translate="yes" xml:space="preserve">
          <source>There are several examples of using the multi-iterator in the NumPy source code as it makes N-dimensional broadcasting-code very simple to write. Browse the source for more examples.</source>
          <target state="translated">NumPyのソースコードには、N次元放送コードを非常に簡単に書けるようにするために、マルチイテレータを使用したいくつかの例があります。より多くの例はソースを参照してください。</target>
        </trans-unit>
        <trans-unit id="27bf18c3e68f395d5dcf853e32e810c666f7a43d" translate="yes" xml:space="preserve">
          <source>There are several requirements for a shared library that can be used with ctypes that are platform specific. This guide assumes you have some familiarity with making a shared library on your system (or simply have a shared library available to you). Items to remember are:</source>
          <target state="translated">プラットフォーム固有のctypesで使用できる共有ライブラリには、いくつかの要件があります。このガイドでは、システム上で共有ライブラリを作成することにある程度慣れていることを前提としています (あるいは単に共有ライブラリを利用できるようにしているだけです)。覚えておくべき項目は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="b82ec3b39568bfec9a11840bdb7b6ec4c84323cc" translate="yes" xml:space="preserve">
          <source>There are several ways to construct a masked array.</source>
          <target state="translated">マスクされた配列を構築する方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="c4a7e4b025b48bc40d3703a29b57ae48e3043f29" translate="yes" xml:space="preserve">
          <source>There are several ways to create arrays.</source>
          <target state="translated">配列を作成する方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="ffbc541dfd45825fd321c5ec3bdf633ecc4c702b" translate="yes" xml:space="preserve">
          <source>There are some informational attributes that universal functions possess. None of the attributes can be set.</source>
          <target state="translated">普遍的な関数が持つ情報属性があります。いずれの属性も設定することはできません。</target>
        </trans-unit>
        <trans-unit id="25b081aeb44044a8abafdf90f986afb1775ac9ea" translate="yes" xml:space="preserve">
          <source>There are sometimes issues reported on Raspberry Pi setups when installing using &lt;code&gt;pip3 install&lt;/code&gt; (or &lt;code&gt;pip&lt;/code&gt; install). These will typically mention:</source>
          <target state="translated">&lt;code&gt;pip3 install&lt;/code&gt; （または &lt;code&gt;pip&lt;/code&gt; install）を使用してインストールすると、RaspberryPiのセットアップで問題が報告されることがあります。これらは通常、次のように言及します。</target>
        </trans-unit>
        <trans-unit id="014e04d63bbb11cf7242b7931500c73711d0520d" translate="yes" xml:space="preserve">
          <source>There are standard variable types for each of the numeric data types and the bool data type. Some of these are already available in the C-specification. You can create variables in extension code with these types.</source>
          <target state="translated">数値データ型とboolデータ型のそれぞれに標準的な変数型があります。これらのうちのいくつかは、C-specificationですでに利用可能です。これらの型を使って拡張コードで変数を作成することができます。</target>
        </trans-unit>
        <trans-unit id="d266f8d3fc00db82d70a1cf8a8ecaaaa80431033" translate="yes" xml:space="preserve">
          <source>There are three independent testing frameworks supported, for one-, two-, and three-dimensional arrays respectively. For one-dimensional arrays, there are two C++ files, a header and a source, named:</source>
          <target state="translated">それぞれ1次元配列、2次元配列、3次元配列の3つの独立したテストフレームワークがサポートされています。1次元配列の場合、ヘッダとソースという名前の2つのC++ファイルがあります。</target>
        </trans-unit>
        <trans-unit id="a98d06ff6365cb9b94028f7c87529f8503c9281a" translate="yes" xml:space="preserve">
          <source>There are three methods of ufuncs that require calculation similar to the general-purpose ufuncs. These are reduce, accumulate, and reduceat. Each of these methods requires a setup command followed by a loop. There are four loop styles possible for the methods corresponding to no-elements, one-element, strided-loop, and buffered- loop. These are the same basic loop styles as implemented for the general purpose function call except for the no-element and one- element cases which are special-cases occurring when the input array objects have 0 and 1 elements respectively.</source>
          <target state="translated">汎用的なufuncsと同様に計算が必要なufuncsには3つの方法があります。これらは、reduce、accumulate、reduceatです。これらのメソッドはそれぞれセットアップコマンドとループを必要とします。ループスタイルには、no-elements、one-element、strided-loop、buffered-loopの4種類があります。これらは,入力配列オブジェクトがそれぞれ0と1の要素を持つ場合に発生する特殊なケースである無要素と1要素のケースを除いては,汎用関数呼び出しに実装されているのと同じ基本的なループスタイルです.</target>
        </trans-unit>
        <trans-unit id="79149af5bd80302b7d9a0d00bba8113083202d98" translate="yes" xml:space="preserve">
          <source>There are three steps to the process.</source>
          <target state="translated">そのプロセスには3つのステップがあります。</target>
        </trans-unit>
        <trans-unit id="30d692f23dd01af5033268a8ed1b02fd45c32c1c" translate="yes" xml:space="preserve">
          <source>There are three strategies implemented that can be used to produce repeatable pseudo-random numbers across multiple processes (local or distributed).</source>
          <target state="translated">複数のプロセス(ローカルまたは分散)で再現性のある疑似乱数を生成するために使用できる3つの戦略が実装されています。</target>
        </trans-unit>
        <trans-unit id="9dfb3a62923157363de4f21bfcb4cc89da91a3e2" translate="yes" xml:space="preserve">
          <source>There are three use-cases related to memory alignment in numpy (as of 1.14):</source>
          <target state="translated">numpy のメモリアラインメントに関連したユースケースは 3 つあります (1.14 現在)。</target>
        </trans-unit>
        <trans-unit id="1878e6ac9e299677e2b59b09c76f88c728c9412d" translate="yes" xml:space="preserve">
          <source>There are times when it is important to visit the elements of an array in a specific order, irrespective of the layout of the elements in memory. The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object provides an &lt;code&gt;order&lt;/code&gt; parameter to control this aspect of iteration. The default, having the behavior described above, is order=&amp;rsquo;K&amp;rsquo; to keep the existing order. This can be overridden with order=&amp;rsquo;C&amp;rsquo; for C order and order=&amp;rsquo;F&amp;rsquo; for Fortran order.</source>
          <target state="translated">メモリ内の要素のレイアウトに関係なく、特定の順序で配列の要素にアクセスすることが重要な場合があります。&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; の&lt;/a&gt;オブジェクトが提供 &lt;code&gt;order&lt;/code&gt; 反復のこの局面を制御するパラメータ。上記の動作を持つデフォルトは、既存の順序を維持するためにorder = 'K'です。これは、Cオーダーの場合はorder = 'C'、Fortranオーダーの場合はorder = 'F'でオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="8bcb408782f4cab8808f9329f353388438a050d8" translate="yes" xml:space="preserve">
          <source>There are times when it is necessary to treat an array as a different data type than it is stored as. For instance, one may want to do all computations on 64-bit floats, even if the arrays being manipulated are 32-bit floats. Except when writing low-level C code, it&amp;rsquo;s generally better to let the iterator handle the copying or buffering instead of casting the data type yourself in the inner loop.</source>
          <target state="translated">配列を、格納されているのとは異なるデータ型として扱う必要がある場合があります。たとえば、操作される配列が32ビットの浮動小数点数であっても、64ビットの浮動小数点数ですべての計算を実行したい場合があります。低レベルのCコードを作成する場合を除いて、内部ループで自分でデータ型をキャストするのではなく、イテレータにコピーまたはバッファリングを処理させる方が一般的には適切です。</target>
        </trans-unit>
        <trans-unit id="49296589bf54025f71f98956452ad22438eb00b7" translate="yes" xml:space="preserve">
          <source>There are times when you might want to carry out an operation between an array and a single number (also called &lt;em&gt;an operation between a vector and a scalar&lt;/em&gt;) or between arrays of two different sizes. For example, your array (we&amp;rsquo;ll call it &amp;ldquo;data&amp;rdquo;) might contain information about distance in miles but you want to convert the information to kilometers. You can perform this operation with:</source>
          <target state="translated">配列と単一の数値の&lt;em&gt;間の演算&lt;/em&gt;（&lt;em&gt;ベクトルとスカラーの間の演算&lt;/em&gt;とも呼ばれます）または2つの異なるサイズの配列の間で演算を実行したい場合があります。たとえば、配列（これを「データ」と呼びます）には、マイル単位の距離に関する情報が含まれているが、その情報をキロメートルに変換したい場合があります。この操作は、次の方法で実行できます。</target>
        </trans-unit>
        <trans-unit id="52cac18f5846d7a58eabeae3e5d687453dc981d9" translate="yes" xml:space="preserve">
          <source>There are two Timedelta units (&amp;lsquo;Y&amp;rsquo;, years and &amp;lsquo;M&amp;rsquo;, months) which are treated specially, because how much time they represent changes depending on when they are used. While a timedelta day unit is equivalent to 24 hours, there is no way to convert a month unit into days, because different months have different numbers of days.</source>
          <target state="translated">2つのTimedelta単位（「Y」、年と「M」、月）があり、それらが使用される時間に応じてそれらが表す時間の長さが変化するため、特別に扱われます。timedelta日の単位は24時間に相当しますが、月によって日数が異なるため、月の単位を日に変換する方法はありません。</target>
        </trans-unit>
        <trans-unit id="47ec50226de8d5ba6a84cfb19309924a297ce7ae" translate="yes" xml:space="preserve">
          <source>There are two aspects to the machinery that ndarray uses to support views and new-from-template in subclasses.</source>
          <target state="translated">ndarrayがビューとサブクラスのnew-from-templateをサポートするために使用している機構には2つの側面があります。</target>
        </trans-unit>
        <trans-unit id="ced97d88ae2c849acfa28a2cee713cefa36672d2" translate="yes" xml:space="preserve">
          <source>There are two major new types: the ndarray ( &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; ) and the ufunc ( &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt;&lt;code&gt;PyUFunc_Type&lt;/code&gt;&lt;/a&gt; ). Additional types play a supportive role: the &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt;&lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; . The &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt; is the type for a flat iterator for an ndarray (the object that is returned when getting the flat attribute). The &lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt;&lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt;&lt;/a&gt; is the type of the object returned when calling &lt;code&gt;broadcast&lt;/code&gt; (). It handles iteration and broadcasting over a collection of nested sequences. Also, the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; is the data-type-descriptor type whose instances describe the data. Finally, there are 21 new scalar-array types which are new Python scalars corresponding to each of the fundamental data types available for arrays. An additional 10 other types are place holders that allow the array scalars to fit into a hierarchy of actual Python types.</source>
          <target state="translated">二つの主要な新しい種類があります。ndarray（&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;）とufunc（&lt;a href=&quot;#c.PyUFunc_Type&quot;&gt; &lt;code&gt;PyUFunc_Type&lt;/code&gt; &lt;/a&gt;）。追加のタイプは支援的な役割を果たし：&lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt; &lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; を&lt;/a&gt;。&lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; は&lt;/a&gt; ndarray（フラット属性を取得するときに返されるオブジェクト）用のフラットイテレータの型です。&lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt; &lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt; は、&lt;/a&gt;呼び出し時に返されるオブジェクトの型である &lt;code&gt;broadcast&lt;/code&gt; ）（。ネストされたシーケンスのコレクションを介した反復とブロードキャストを処理します。また、&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt;インスタンスがデータを記述するデータタイプ記述子タイプです。最後に、21の新しいスカラー配列型があります。これらは、配列で使用できる基本的なデータ型のそれぞれに対応する新しいPythonスカラーです。その他の10の型はプレースホルダーで、配列スカラーを実際のPython型の階層に適合させることができます。</target>
        </trans-unit>
        <trans-unit id="c37fba99ab33d4532607fe9319066dc8a4405878" translate="yes" xml:space="preserve">
          <source>There are two mechanisms which allow this to be done, temporary copies and buffering mode. With temporary copies, a copy of the entire array is made with the new data type, then iteration is done in the copy. Write access is permitted through a mode which updates the original array after all the iteration is complete. The major drawback of temporary copies is that the temporary copy may consume a large amount of memory, particularly if the iteration data type has a larger itemsize than the original one.</source>
          <target state="translated">これを可能にするメカニズムには,一時的なコピーとバッファリングモードの2つがあります.一時的なコピーでは,新しいデータ型で配列全体のコピーを作成し,そのコピーで反復処理を行います.書き込みアクセスは,すべての反復処理が完了した後に元の配列を更新するモードで許可されます.一時コピーの主な欠点は,一時コピーが大量のメモリを消費する可能性があること,特に反復データ型が元のデータ型よりも大きなアイテムサイズを持つ場合には,メモリを大量に消費する可能性があることです.</target>
        </trans-unit>
        <trans-unit id="bbd0e93d84494368770e6b417effb4b358f4babd" translate="yes" xml:space="preserve">
          <source>There are two modes of creating an array using &lt;code&gt;__new__&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;__new__&lt;/code&gt; を使用して配列を作成するには、2つのモードがあります。</target>
        </trans-unit>
        <trans-unit id="e95a2d13ee09be4667ba99a7e23d783a62c61eb8" translate="yes" xml:space="preserve">
          <source>There are two popular ways to flatten an array: &lt;code&gt;.flatten()&lt;/code&gt; and &lt;code&gt;.ravel()&lt;/code&gt;. The primary difference between the two is that the new array created using &lt;code&gt;ravel()&lt;/code&gt; is actually a reference to the parent array (i.e., a &amp;ldquo;view&amp;rdquo;). This means that any changes to the new array will affect the parent array as well. Since &lt;code&gt;ravel&lt;/code&gt; does not create a copy, it&amp;rsquo;s memory efficient.</source>
          <target state="translated">配列をフラット化する一般的な方法は、 &lt;code&gt;.flatten()&lt;/code&gt; と &lt;code&gt;.ravel()&lt;/code&gt; の2つです。 2つの主な違いは、 &lt;code&gt;ravel()&lt;/code&gt; を使用して作成された新しい配列は、実際には親配列（つまり、「ビュー」）への参照であるということです。これは、新しいアレイへの変更が親アレイにも影響することを意味します。以来 &lt;code&gt;ravel&lt;/code&gt; コピーを作成しません、それはメモリ効率的です。</target>
        </trans-unit>
        <trans-unit id="97769fec67515ece6f805db56bd64883845242d0" translate="yes" xml:space="preserve">
          <source>There are two types of proper-contiguous NumPy arrays:</source>
          <target state="translated">適切に連続するNumPy配列には2つのタイプがあります。</target>
        </trans-unit>
        <trans-unit id="0373fb682b5018f30be6571b2e08840bdbbdebff" translate="yes" xml:space="preserve">
          <source>There are two ways to capture floating-point error messages. The first is to set the error-handler to &amp;lsquo;call&amp;rsquo;, using &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;. Then, set the function to call using this function.</source>
          <target state="translated">浮動小数点エラーメッセージをキャプチャするには、2つの方法があります。1つ目は、&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt;を使用して、エラーハンドラーを 'call'に設定することです。次に、この関数を使用して呼び出す関数を設定します。</target>
        </trans-unit>
        <trans-unit id="7822fba8682a2c5b4fec5101c082332701ec52bb" translate="yes" xml:space="preserve">
          <source>There are two ways to effectively define a new array scalar type (apart from composing structured types &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtypes&lt;/a&gt; from the built-in scalar types): One way is to simply subclass the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and overwrite the methods of interest. This will work to a degree, but internally certain behaviors are fixed by the data type of the array. To fully customize the data type of an array you need to define a new data-type, and register it with NumPy. Such new types can only be defined in C, using the &lt;a href=&quot;c-api#c-api&quot;&gt;NumPy C-API&lt;/a&gt;.</source>
          <target state="translated">新しい配列スカラー型を効果的に定義するには、2つの方法があります（組み込みのスカラー型から構造化型&lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtype&lt;/a&gt;を構成することは別として）。1つは、&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;をサブクラス化し、対象のメソッドを上書きする方法です。これはある程度機能しますが、内部では特定の動作が配列のデータ型によって修正されています。配列のデータ型を完全にカスタマイズするには、新しいデータ型を定義し、それをNumPyに登録する必要があります。このような新しい型は、&lt;a href=&quot;c-api#c-api&quot;&gt;NumPy C-API&lt;/a&gt;を使用してCでのみ定義できます。</target>
        </trans-unit>
        <trans-unit id="5c78474a57486cf4a85d9232cd27ee1937bd696d" translate="yes" xml:space="preserve">
          <source>There are two ways to effectively define a new array scalar type (apart from composing structured types &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtypes&lt;/a&gt; from the built-in scalar types): One way is to simply subclass the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and overwrite the methods of interest. This will work to a degree, but internally certain behaviors are fixed by the data type of the array. To fully customize the data type of an array you need to define a new data-type, and register it with NumPy. Such new types can only be defined in C, using the &lt;a href=&quot;c-api/index#c-api&quot;&gt;NumPy C-API&lt;/a&gt;.</source>
          <target state="translated">新しい配列スカラー型を効果的に定義するには、2つの方法があります（組み込みスカラー型から構造化型&lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtype&lt;/a&gt;を作成する以外に）：1つの方法は、単に&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;をサブクラス化し、対象のメソッドを上書きすることです。これはある程度機能しますが、内部的には特定の動作が配列のデータ型によって修正されます。配列のデータ型を完全にカスタマイズするには、新しいデータ型を定義し、それをNumPyに登録する必要があります。このような新しいタイプは、&lt;a href=&quot;c-api/index#c-api&quot;&gt;NumPyC-API&lt;/a&gt;を使用してCでのみ定義できます。</target>
        </trans-unit>
        <trans-unit id="cedb91ab21e9adb6003c75e29f535939f4382660" translate="yes" xml:space="preserve">
          <source>There are two ways to update the source release on PyPI, the first one is:</source>
          <target state="translated">PyPIでソースリリースを更新する方法は2つあります。</target>
        </trans-unit>
        <trans-unit id="07256ff1dd075c50fc2daea66eb388157aacb269" translate="yes" xml:space="preserve">
          <source>There are two ways to use the interface: A Python side and a C-side. Both are separate attributes.</source>
          <target state="translated">インターフェースの使い方は2通りあります。Python側とC側です。どちらも別属性です。</target>
        </trans-unit>
        <trans-unit id="b03a9c50082003b4ef01f90e63c960011178dda8" translate="yes" xml:space="preserve">
          <source>There has been no consistent prefix for NumPy public functions, but they all begin with a prefix of some sort, followed by an underscore, and are in camel case: &lt;code&gt;PyArray_DescrAlignConverter&lt;/code&gt;, &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt;. In the future the names should be of the form &lt;code&gt;Npy*_PublicFunction&lt;/code&gt;, where the star is something appropriate.</source>
          <target state="translated">NumPyパブリック関数には一貫したプレフィックスはありませんが、それらはすべて、ある種のプレフィックスで始まり、その後にアンダースコアが続き、キャメルケースの場合は &lt;code&gt;PyArray_DescrAlignConverter&lt;/code&gt; 、 &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt; です。将来的には、名前は &lt;code&gt;Npy*_PublicFunction&lt;/code&gt; の形式になるはずです。ここで、星は適切なものです。</target>
        </trans-unit>
        <trans-unit id="dde43af7d13c44f94f0d79c46e9390e7c8216335" translate="yes" xml:space="preserve">
          <source>There is a Python type for each of the different built-in data types that can be present in the array Most of these are simple wrappers around the corresponding data type in C. The C-names for these types are &lt;code&gt;Py{TYPE}ArrType_Type&lt;/code&gt; where &lt;code&gt;{TYPE}&lt;/code&gt; can be</source>
          <target state="translated">配列内に存在できるさまざまな組み込みデータ型ごとにPython型があります。これらのほとんどは、Cの対応するデータ型の単純なラッパーです。これらの型のC名は &lt;code&gt;Py{TYPE}ArrType_Type&lt;/code&gt; 。 &lt;code&gt;{TYPE}&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="07c5411b83a37216eb927b90741cd5630b9b2108" translate="yes" xml:space="preserve">
          <source>There is a clear distinction between element-wise operations and linear algebra operations.</source>
          <target state="translated">要素別演算と線形代数演算は明確に区別されています。</target>
        </trans-unit>
        <trans-unit id="c0d05d2bbb1d4347eb1dace6314a1a3b989e2daa" translate="yes" xml:space="preserve">
          <source>There is a fragment for converting a Python integer to a C &lt;code&gt;long&lt;/code&gt;. There is a different fragment that converts a Python integer to a C &lt;code&gt;int&lt;/code&gt;, that calls the routine defined in the &lt;code&gt;long&lt;/code&gt; fragment. We can make the changes we want here by changing the definition for the &lt;code&gt;long&lt;/code&gt; fragment. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; determines the active definition for a fragment using a &amp;ldquo;first come, first served&amp;rdquo; system. That is, we need to define the fragment for &lt;code&gt;long&lt;/code&gt; conversions prior to &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; doing it internally. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; allows us to do this by putting our fragment definitions in the file &lt;code&gt;pyfragments.swg&lt;/code&gt;. If we were to put the new fragment definitions in &lt;code&gt;numpy.i&lt;/code&gt;, they would be ignored.</source>
          <target state="translated">Python整数をC &lt;code&gt;long&lt;/code&gt; に変換するフラグメントがあります。 Python整数をC &lt;code&gt;int&lt;/code&gt; に変換する別のフラグメントがあり、 &lt;code&gt;long&lt;/code&gt; フラグメントで定義されたルーチンを呼び出します。 &lt;code&gt;long&lt;/code&gt; フラグメントの定義を変更することで、ここで必要な変更を加えることができます。&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIGは&lt;/a&gt;、「先着順」のシステムを使用して、フラグメントのアクティブな定義を決定します。つまり、&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIGが&lt;/a&gt;内部で行う前に、 &lt;code&gt;long&lt;/code&gt; 変換のフラグメントを定義する必要があります。&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;では、フラグメント定義をファイル &lt;code&gt;pyfragments.swg&lt;/code&gt; に配置することでこれを行うことができます。新しいフラグメントの定義を &lt;code&gt;numpy.i&lt;/code&gt; 、それらは無視されます。</target>
        </trans-unit>
        <trans-unit id="d31593a379a881f2302877c7bf40c8ae65305ffb" translate="yes" xml:space="preserve">
          <source>There is a general need for looping over not only functions on scalars but also over functions on vectors (or arrays). This concept is realized in NumPy by generalizing the universal functions (ufuncs). In regular ufuncs, the elementary function is limited to element-by-element operations, whereas the generalized version (gufuncs) supports &amp;ldquo;sub-array&amp;rdquo; by &amp;ldquo;sub-array&amp;rdquo; operations. The Perl vector library PDL provides a similar functionality and its terms are re-used in the following.</source>
          <target state="translated">スカラーの関数だけでなく、ベクトル（または配列）の関数もループする必要があります。この概念は、汎用関数（ufunc）を一般化することによってNumPyで実現されます。通常のufuncでは、基本関数は要素ごとの操作に制限されていますが、一般化バージョン（gufuncs）は「サブ配列」による「サブ配列」操作をサポートしています。PerlベクターライブラリPDLは同様の機能を提供し、その用語は以下で再利用されます。</target>
        </trans-unit>
        <trans-unit id="16ce9fcfde9d0ef11eba9dffd6932b4fb7fe6e10" translate="yes" xml:space="preserve">
          <source>There is a list of enumerated types defined providing the basic 24 data types plus some useful generic names. Whenever the code requires a type number, one of these enumerated types is requested. The types are all called &lt;code&gt;NPY_{NAME}&lt;/code&gt;:</source>
          <target state="translated">定義された列挙型のリストがあり、基本的な24のデータ型といくつかの有用な総称名を提供します。コードで型番号が必要な場合は常に、これらの列挙型の1つが要求されます。タイプはすべて &lt;code&gt;NPY_{NAME}&lt;/code&gt; と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="fd095b1a939a3168566a681ecc0b30a59e81e682" translate="yes" xml:space="preserve">
          <source>There is a small difference between &lt;a href=&quot;#numpy.ma.masked_array.mini&quot;&gt;&lt;code&gt;mini&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.ma.min#numpy.ma.min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.masked_array.mini&quot;&gt; &lt;code&gt;mini&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;numpy.ma.min#numpy.ma.min&quot;&gt; &lt;code&gt;min&lt;/code&gt; に&lt;/a&gt;は小さな違いがあります：</target>
        </trans-unit>
        <trans-unit id="426d6a71d6ada6c4fe36711b0bf2acc4eb8a1d92" translate="yes" xml:space="preserve">
          <source>There is a subarray but it has exactly one element. This case can be handled as if there is no subarray, but needs some care during setup.</source>
          <target state="translated">部分配列はあるが、要素は1つだけである。この場合はサブアレイがない場合と同じように扱うことができますが、設定時には注意が必要です。</target>
        </trans-unit>
        <trans-unit id="a1e2cb9284c447866f4fcfbd5e36a19034ca7940" translate="yes" xml:space="preserve">
          <source>There is also a &amp;ldquo;flat&amp;rdquo; in-place array for situations in which you would like to modify or process each element, regardless of the number of dimensions. One example is a &amp;ldquo;quantization&amp;rdquo; function that quantizes each element of an array in-place, be it 1D, 2D or whatever. This form checks for continuity but allows either C or Fortran ordering.</source>
          <target state="translated">次元の数に関係なく、各要素を変更または処理する状況向けの「フラット」インプレース配列もあります。1つの例は、1D、2Dなど、配列の各要素をインプレースで量子化する「量子化」関数です。このフォームは連続性をチェックしますが、CまたはFortranの順序を許可します。</target>
        </trans-unit>
        <trans-unit id="42d7ce17e767848814f251a3d945724bdcad4394" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;../arrays.nditer#arrays-nditer&quot;&gt;introductory guide to array iteration&lt;/a&gt; which may be of interest for those using this C API. In many instances, testing out ideas by creating the iterator in Python is a good idea before writing the C iteration code.</source>
          <target state="translated">この&lt;a href=&quot;../arrays.nditer#arrays-nditer&quot;&gt;CAPI&lt;/a&gt;を使用している人にとって興味深い、配列反復の入門ガイドがあります。多くの場合、C反復コードを作成する前に、Pythonでイテレーターを作成してアイデアをテストすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="89b73fe8185f285d3a10cd617f08eb8cadb40473" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;arrays.nditer#arrays-nditer&quot;&gt;introductory guide to array iteration&lt;/a&gt; which may be of interest for those using this C API. In many instances, testing out ideas by creating the iterator in Python is a good idea before writing the C iteration code.</source>
          <target state="translated">このC APIを使用するユーザーにとって興味深い&lt;a href=&quot;arrays.nditer#arrays-nditer&quot;&gt;配列反復の入門ガイド&lt;/a&gt;があります。多くの場合、Pythonでイテレーターを作成してアイデアをテストすることは、C反復コードを作成する前に行うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="606a479ef2292dc711e91c789c67dff3002d3e8e" translate="yes" xml:space="preserve">
          <source>There is an ongoing effort to improve the API. It is important in this effort to ensure that code that compiles for NumPy 1.X continues to compile for NumPy 1.X. At the same time, certain API&amp;rsquo;s will be marked as deprecated so that future-looking code can avoid these API&amp;rsquo;s and follow better practices.</source>
          <target state="translated">APIを改善するための継続的な取り組みがあります。この取り組みでは、NumPy 1.X用にコンパイルされるコードがNumPy 1.X用に引き続きコンパイルされるようにすることが重要です。同時に、特定のAPIは非推奨としてマークされるため、将来を見据えたコードでこれらのAPIを回避し、より適切なプラクティスに従うことができます。</target>
        </trans-unit>
        <trans-unit id="2d9dbfa834497f6482a194ae6bc42d9b31e1c027" translate="yes" xml:space="preserve">
          <source>There is exactly one function that must be defined in your C-code in order for Python to use it as an extension module. The function must be called init{name} where {name} is the name of the module from Python. This function must be declared so that it is visible to code outside of the routine. Besides adding the methods and constants you desire, this subroutine must also contain calls like &lt;code&gt;import_array()&lt;/code&gt; and/or &lt;code&gt;import_ufunc()&lt;/code&gt; depending on which C-API is needed. Forgetting to place these commands will show itself as an ugly segmentation fault (crash) as soon as any C-API subroutine is actually called. It is actually possible to have multiple init{name} functions in a single file in which case multiple modules will be defined by that file. However, there are some tricks to get that to work correctly and it is not covered here.</source>
          <target state="translated">Pythonが拡張モジュールとして使用するために、Cコードで定義する必要のある関数は1つだけです。この関数はinit {name}と呼ばれる必要があります。{name}はPythonのモジュールの名前です。この関数は、ルーチンの外部のコードから見えるように宣言する必要があります。あなたが望む方法と定数を追加することに加えて、このサブルーチンのような呼び出しも含まれている必要があります &lt;code&gt;import_array()&lt;/code&gt; および/または &lt;code&gt;import_ufunc()&lt;/code&gt; 必要なC-APIによって異なります。これらのコマンドを配置し忘れると、C-APIサブルーチンが実際に呼び出されるとすぐに、醜いセグメンテーション違反（クラッシュ）として表示されます。実際には、1つのファイルに複数のinit {name}関数を含めることができます。その場合、そのファイルによって複数のモジュールが定義されます。ただし、それを正しく機能させるためのいくつかのトリックがあり、ここでは説明しません。</target>
        </trans-unit>
        <trans-unit id="c951415e0655e2f1d542beb400e29df172840589" translate="yes" xml:space="preserve">
          <source>There is more than one definition of sign in common use for complex numbers. The definition used here is equivalent to</source>
          <target state="translated">複素数で一般的に使われている符号の定義は1つだけではありません。ここで使われている定義は</target>
        </trans-unit>
        <trans-unit id="81f07ae1e9b8a43b5991326dbec6dd373febf78b" translate="yes" xml:space="preserve">
          <source>There is no need to use &lt;code&gt;intent(c)&lt;/code&gt; for one-dimensional arrays, no matter if the wrapped function is either a Fortran or a C function. This is because the concepts of Fortran- and C contiguity overlap in one-dimensional cases.</source>
          <target state="translated">ラップされた関数がFortran関数であるかC関数であるかに関係なく、1次元配列に &lt;code&gt;intent(c)&lt;/code&gt; を使用する必要はありません。これは、FortranとCの隣接の概念が1次元の場合に重複するためです。</target>
        </trans-unit>
        <trans-unit id="b1c5400df70c93e783da6a5dac7fee87f2f1e727" translate="yes" xml:space="preserve">
          <source>There is no standard way in Python distutils to create a standard shared library (an extension module is a &amp;ldquo;special&amp;rdquo; shared library Python understands) in a cross-platform manner. Thus, a big disadvantage of ctypes at the time of writing this book is that it is difficult to distribute in a cross-platform manner a Python extension that uses ctypes and includes your own code which should be compiled as a shared library on the users system.</source>
          <target state="translated">Python distutilsには、クロスプラットフォームの方法で標準の共有ライブラリ（拡張モジュールはPythonが理解する「特別な」共有ライブラリ）を作成する標準的な方法はありません。したがって、この本を書いている時点でのctypesの大きな欠点は、ctypesを使用し、ユーザーシステムで共有ライブラリとしてコンパイルする必要がある独自のコードを含むPython拡張機能をクロスプラットフォームで配布することが難しいことです。 。</target>
        </trans-unit>
        <trans-unit id="54b0268bf735345a9f64350e8e77b1a81c8688d9" translate="yes" xml:space="preserve">
          <source>There is one indexing array and it, as well as the assignment array, can be iterated trivially. For example they may be contiguous. Also the indexing array must be of &lt;a href=&quot;arrays.scalars#numpy.intp&quot;&gt;&lt;code&gt;intp&lt;/code&gt;&lt;/a&gt; type and the value array in assignments should be of the correct type. This is purely a fast path.</source>
          <target state="translated">インデックス配列が1つあり、それと割り当て配列を簡単に繰り返すことができます。たとえば、それらは隣接している場合があります。また、インデックス配列は&lt;a href=&quot;arrays.scalars#numpy.intp&quot;&gt; &lt;code&gt;intp&lt;/code&gt; &lt;/a&gt;型である必要があり、割り当ての値配列は正しい型である必要があります。これは純粋に高速なパスです。</target>
        </trans-unit>
        <trans-unit id="23297908101e96f4ab7052c44ca172ce18526477" translate="yes" xml:space="preserve">
          <source>There is one indexing array and it, as well as the assignment array, can be iterated trivially. For example they may be contiguous. Also the indexing array must be of &lt;code&gt;intp&lt;/code&gt; type and the value array in assignments should be of the correct type. This is purely a fast path.</source>
          <target state="translated">インデックス配列が1つあり、割り当て配列と同様に、簡単に繰り返すことができます。たとえば、それらは隣接している場合があります。また、インデックス配列は &lt;code&gt;intp&lt;/code&gt; タイプでなければならず、割り当ての値配列は正しいタイプでなければなりません。これは純粋に高速パスです。</target>
        </trans-unit>
        <trans-unit id="d8fac7ab155f3d88da854276783ffad458c19c82" translate="yes" xml:space="preserve">
          <source>There is one notable exception to this behavior: if the optional argument &lt;code&gt;names=True&lt;/code&gt;, the first commented line will be examined for names.</source>
          <target state="translated">この動作には1つの注目すべき例外があります。オプションの引数 &lt;code&gt;names=True&lt;/code&gt; の場合、最初にコメントされた行で名前が調べられます。</target>
        </trans-unit>
        <trans-unit id="df9a641fbd94988d395fb4542afcc38f2bd13355" translate="yes" xml:space="preserve">
          <source>There must be at least 1 argument, and define the last argument as &lt;em&gt;item&lt;/em&gt;. Then, &lt;code&gt;a.itemset(*args)&lt;/code&gt; is equivalent to but faster than &lt;code&gt;a[args] = item&lt;/code&gt;. The item should be a scalar value and &lt;code&gt;args&lt;/code&gt; must select a single item in the array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">少なくとも1つの引数が必要で、最後の引数を&lt;em&gt;item&lt;/em&gt;として定義し&lt;em&gt;ます&lt;/em&gt;。その場合、 &lt;code&gt;a.itemset(*args)&lt;/code&gt; は &lt;code&gt;a[args] = item&lt;/code&gt; と同等ですが、それより高速です。アイテムはスカラー値である必要があり、 &lt;code&gt;args&lt;/code&gt; は配列 &lt;code&gt;a&lt;/code&gt; 内の単一のアイテムを選択する必要があります。</target>
        </trans-unit>
        <trans-unit id="d9bdbeac0f4a4a2c09a4382d5b665ee480b88e7d" translate="yes" xml:space="preserve">
          <source>There was no &lt;code&gt;__array_interface__&lt;/code&gt; attribute instead all of the keys (except for version) in the &lt;code&gt;__array_interface__&lt;/code&gt; dictionary were their own attribute: Thus to obtain the Python-side information you had to access separately the attributes:</source>
          <target state="translated">何もありませんでした &lt;code&gt;__array_interface__&lt;/code&gt; の中に（バージョンを除く）の代わりに、すべてのキーの属性 &lt;code&gt;__array_interface__&lt;/code&gt; の辞書には、独自の属性は以下の通りであった。したがって、あなたは別に属性にアクセスしなければならなかったのPython側の情報を取得します：</target>
        </trans-unit>
        <trans-unit id="bc33808ec0ca031cf8b9c1fdd7c9278c78f0db38" translate="yes" xml:space="preserve">
          <source>There was no __array_interface__ attribute instead all of the keys (except for version) in the __array_interface__ dictionary were their own attribute: Thus to obtain the Python-side information you had to access separately the attributes:</source>
          <target state="translated">その代わりに__array_interface__属性は存在せず、__array_interface__辞書の全てのキー(バージョンを除く)はそれぞれの属性でした。このように、Python側の情報を得るためには、個別に属性にアクセスしなければなりませんでした。</target>
        </trans-unit>
        <trans-unit id="1d3ca63c0d0c4fb92d45d132b89354f4e2a0e2fc" translate="yes" xml:space="preserve">
          <source>There will not be anything &lt;em&gt;wrong&lt;/em&gt; with the results, per se; even a seed of 0 is perfectly fine thanks to the processing that &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; does. If you just need &lt;em&gt;some&lt;/em&gt; fixed value for unit tests or debugging, feel free to use whatever seed you like. But if you want to make inferences from the results or publish them, drawing from a larger set of seeds is good practice.</source>
          <target state="translated">それ自体、結果に&lt;em&gt;問題&lt;/em&gt;はありません。&lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;が行う処理のおかげで、シードが0でも完全に問題ありません。あなただけが必要な場合は&lt;em&gt;、いくつかの&lt;/em&gt;ユニットテストのための固定値をやデバッグ、あなたが好きな種子を使用して自由に感じます。しかし、結果から推論したり、それらを公開したりする場合は、より大きなシードのセットから描画することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="1a33a5d0a80b8b553aad5ef6b8b9d3cf3a744293" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s an embarrassing typo in a commit you made? Or perhaps the you made several false starts you would like the posterity not to see.</source>
          <target state="translated">あなたが行ったコミットに恥ずかしいタイプミスがありますか？あるいは、後世に見られたくない不正スタートを何度か行ったのかもしれません。</target>
        </trans-unit>
        <trans-unit id="7586899d52e7cb2e4afcaa41a1d9614a067b4661" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s an embarrassing typo in a commit you made? Or perhaps you made several false starts you would like the posterity not to see.</source>
          <target state="translated">あなたが行ったコミットに恥ずかしいタイプミスがありますか？あるいは、後世に見られたくないいくつかの誤ったスタートをしたかもしれません。</target>
        </trans-unit>
        <trans-unit id="de5a5e9111615649ff06d77b214a9aa4744c2e9e" translate="yes" xml:space="preserve">
          <source>These Boolean-valued flags affect how numpy interprets the memory area used by &lt;code&gt;a&lt;/code&gt; (see Notes below). The ALIGNED flag can only be set to True if the data is actually aligned according to the type. The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set to True. The flag WRITEABLE can only be set to True if the array owns its own memory, or the ultimate owner of the memory exposes a writeable buffer interface, or is a string. (The exception for string is made so that unpickling can be done without copying memory.)</source>
          <target state="translated">これらのブール値のフラグは、numpyが &lt;code&gt;a&lt;/code&gt; によって使用されるメモリ領域を解釈する方法に影響を与えます（下記の注を参照）。 ALIGNEDフラグをTrueに設定できるのは、データが実際にタイプに従って配置されている場合のみです。 WRITEBACKIFCOPYフラグと（非推奨）UPDATEIFCOPYフラグをTrueに設定することはできません。フラグWRITEABLEをTrueに設定できるのは、配列が独自のメモリを所有している場合、またはメモリの最終的な所有者が書き込み可能なバッファインターフェイスを公開している場合、または文字列の場合のみです。 （stringの例外は、メモリをコピーせずにunpickleを実行できるようにするためです。）</target>
        </trans-unit>
        <trans-unit id="a6788920c31464c6803c23f30203598688f71c50" translate="yes" xml:space="preserve">
          <source>These additional dependencies for building the documentation are listed in &lt;code&gt;doc_requirements.txt&lt;/code&gt; and can be conveniently installed with:</source>
          <target state="translated">ドキュメントを構築するためのこれらの追加の依存関係は、 &lt;code&gt;doc_requirements.txt&lt;/code&gt; にリストされており、次のコマンドで簡単にインストールできます。</target>
        </trans-unit>
        <trans-unit id="7faf38a4c03dd7b8b5f6a940a17e52f4253526ca" translate="yes" xml:space="preserve">
          <source>These all achieve the same result:</source>
          <target state="translated">これらはすべて同じ結果をもたらします。</target>
        </trans-unit>
        <trans-unit id="ca33633bc8f8738d475e05fabdb7eda73e305c81" translate="yes" xml:space="preserve">
          <source>These are defined for &lt;code&gt;{bits}&lt;/code&gt; = 8, 16, 32, 64, 128, and 256 and provide the maximum (minimum) value of the corresponding (unsigned) integer type. Note: the actual integer type may not be available on all platforms (i.e. 128-bit and 256-bit integers are rare).</source>
          <target state="translated">これらは &lt;code&gt;{bits}&lt;/code&gt; = 8、16、32、64、128、および256 に対して定義され、対応する（符号なし）整数型の最大（最小）値を提供します。注：実際の整数タイプは、すべてのプラットフォームで使用できるわけではありません（つまり、128ビットおよび256ビットの整数はまれです）。</target>
        </trans-unit>
        <trans-unit id="e68165dfdce046a2deae960fcc7bcd8c7c8919ea" translate="yes" xml:space="preserve">
          <source>These are enhanced arrays of either &lt;a href=&quot;arrays.scalars#numpy.str_&quot;&gt;&lt;code&gt;str_&lt;/code&gt;&lt;/a&gt; type or &lt;a href=&quot;arrays.scalars#numpy.bytes_&quot;&gt;&lt;code&gt;bytes_&lt;/code&gt;&lt;/a&gt; type. These arrays inherit from the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, but specially-define the operations &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and &lt;code&gt;%&lt;/code&gt; on a (broadcasting) element-by-element basis. These operations are not available on the standard &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; of character type. In addition, the &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; has all of the standard &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;) methods, executing them on an element-by-element basis. Perhaps the easiest way to create a chararray is to use &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;self.view(chararray)&lt;/code&gt;&lt;/a&gt; where &lt;em&gt;self&lt;/em&gt; is an ndarray of str or unicode data-type. However, a chararray can also be created using the &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;numpy.chararray&lt;/code&gt;&lt;/a&gt; constructor, or via the &lt;a href=&quot;generated/numpy.core.defchararray.array#numpy.core.defchararray.array&quot;&gt;&lt;code&gt;numpy.char.array&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">これらは、&lt;a href=&quot;arrays.scalars#numpy.str_&quot;&gt; &lt;code&gt;str_&lt;/code&gt; type&lt;/a&gt;または&lt;a href=&quot;arrays.scalars#numpy.bytes_&quot;&gt; &lt;code&gt;bytes_&lt;/code&gt; typeの&lt;/a&gt;いずれかの拡張配列です。これらの配列は&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; を&lt;/a&gt;継承しますが、特別に- （ブロードキャスト）要素ごとに操作 &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、および &lt;code&gt;%&lt;/code&gt; を定義します。これらの操作は、文字タイプの標準&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;では使用できません。さらに、&lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; に&lt;/a&gt;はすべての標準&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;（および&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;）メソッドがあり、要素ごとに実行されます。おそらくchararrayを作成する最も簡単な方法は、使用することです&lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt; &lt;code&gt;self.view(chararray)&lt;/code&gt; を&lt;/a&gt;&lt;em&gt;自己&lt;/em&gt;strまたはunicodeデータ型のndarrayです。ただし、chararrayは、&lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;numpy.chararray&lt;/code&gt; &lt;/a&gt;コンストラクターを使用するか、&lt;a href=&quot;generated/numpy.core.defchararray.array#numpy.core.defchararray.array&quot;&gt; &lt;code&gt;numpy.char.array&lt;/code&gt; &lt;/a&gt;関数を使用して作成することもできます。</target>
        </trans-unit>
        <trans-unit id="8ddb00a13475a7300c7d1510545ce91de444184f" translate="yes" xml:space="preserve">
          <source>These are enhanced arrays of either &lt;code&gt;string_&lt;/code&gt; type or &lt;code&gt;unicode_&lt;/code&gt; type. These arrays inherit from the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, but specially-define the operations &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and &lt;code&gt;%&lt;/code&gt; on a (broadcasting) element-by-element basis. These operations are not available on the standard &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; of character type. In addition, the &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; has all of the standard &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; (and &lt;code&gt;unicode&lt;/code&gt;) methods, executing them on an element-by-element basis. Perhaps the easiest way to create a chararray is to use &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;self.view(chararray)&lt;/code&gt;&lt;/a&gt; where &lt;em&gt;self&lt;/em&gt; is an ndarray of str or unicode data-type. However, a chararray can also be created using the &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;numpy.chararray&lt;/code&gt;&lt;/a&gt; constructor, or via the &lt;a href=&quot;generated/numpy.core.defchararray.array#numpy.core.defchararray.array&quot;&gt;&lt;code&gt;numpy.char.array&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">これらは、 &lt;code&gt;string_&lt;/code&gt; タイプまたは &lt;code&gt;unicode_&lt;/code&gt; タイプの拡張配列です。これらの配列は&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;から継承しますが、（ブロードキャストする）要素ごとに、演算 &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、および &lt;code&gt;%&lt;/code&gt; を特別に定義します。これらの操作は、文字型の標準&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;では使用できません。さらに、&lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; に&lt;/a&gt;はすべての標準&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt;（および &lt;code&gt;unicode&lt;/code&gt; ）メソッドがあり、要素ごとに実行されます。おそらくchararrayを作成する最も簡単な方法は、使用することです&lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt; &lt;code&gt;self.view(chararray)&lt;/code&gt; を&lt;/a&gt;&lt;em&gt;自己&lt;/em&gt;strまたはunicodeデータ型のndarrayです。ただし、charpyは&lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;numpy.chararray&lt;/code&gt; &lt;/a&gt;コンストラクターを使用して、または&lt;a href=&quot;generated/numpy.core.defchararray.array#numpy.core.defchararray.array&quot;&gt; &lt;code&gt;numpy.char.array&lt;/code&gt; &lt;/a&gt;関数を介して作成することもできます。</target>
        </trans-unit>
        <trans-unit id="5c5d09f4ce60946e76740852fd56ca7c8c49e5bd" translate="yes" xml:space="preserve">
          <source>These are roughly ordered from least-to-most precision.</source>
          <target state="translated">これらは、大まかには最小精度のものから順に並べられています。</target>
        </trans-unit>
        <trans-unit id="2ce5765c6141294e2d5121321badaf2a8b57c10d" translate="yes" xml:space="preserve">
          <source>These are some detailed notes, which are not of importance for day to day indexing (in no particular order):</source>
          <target state="translated">これらは、日々のインデックス作成にはあまり重要ではない詳細なメモです(順不同)。</target>
        </trans-unit>
        <trans-unit id="3f20305498e715f2e7a95c2c0aa48306a2b1d79a" translate="yes" xml:space="preserve">
          <source>These are the arrays for the operation.</source>
          <target state="translated">これらは操作のための配列です。</target>
        </trans-unit>
        <trans-unit id="7a1ac004102d237171aefc6abd621531cd490cc4" translate="yes" xml:space="preserve">
          <source>These are the constants and functions for accessing the ufunc C-API from extension modules in precisely the same way as the array C-API can be accessed. The &lt;code&gt;import_ufunc&lt;/code&gt; () function must always be called (in the initialization subroutine of the extension module). If your extension module is in one file then that is all that is required. The other two constants are useful if your extension module makes use of multiple files. In that case, define &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; to something unique to your code and then in source files that do not contain the module initialization function but still need access to the UFUNC API, define &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; to the same name used previously and also define &lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt;&lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これらは、配列C-APIにアクセスできるのとまったく同じ方法で、拡張モジュールからufunc C-APIにアクセスするための定数と関数です。 &lt;code&gt;import_ufunc&lt;/code&gt; （）関数は、常に、（拡張モジュールの初期化サブルーチンで）呼び出されなければなりません。拡張モジュールが1つのファイルにある場合は、それだけで十分です。他の2つの定数は、拡張モジュールが複数のファイルを使用する場合に役立ちます。その場合には、定義&lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; を&lt;/a&gt;あなたのコードに固有のものにして、モジュールの初期化機能が含まれているが、それでもUFUNC APIへのアクセスを必要としないソースファイルで、定義&lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; を&lt;/a&gt;同じ名前に以前に使用しても定義&lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt; &lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0aaea1e5f2c4b6d0e0dc28a8aa40e102fa58beb" translate="yes" xml:space="preserve">
          <source>These are the indices that would allow you to access the upper triangular part of any 3x3 array:</source>
          <target state="translated">これらは、3x3配列の上部の三角形部分にアクセスできるようにするためのインデックスです。</target>
        </trans-unit>
        <trans-unit id="38bc2b8e25d17f4fb4231aea381549f2e431c561" translate="yes" xml:space="preserve">
          <source>These are the instructions if you just want to follow the latest &lt;em&gt;NumPy&lt;/em&gt; source, but you don&amp;rsquo;t need to do any development for now. If you do want to contribute a patch (excellent!) or do more extensive NumPy development, see &lt;a href=&quot;../development_workflow#development-workflow&quot;&gt;Development workflow&lt;/a&gt;.</source>
          <target state="translated">これらは、最新の&lt;em&gt;NumPy&lt;/em&gt;ソースをフォローしたいだけの場合の手順ですが、今のところ開発を行う必要はありません。パッチを提供したい場合（すばらしい！）、またはより広範なNumPy開発を行う場合は、&lt;a href=&quot;../development_workflow#development-workflow&quot;&gt;開発ワークフローを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="43efdc6f451764645e6025c80a5a83f304f68569" translate="yes" xml:space="preserve">
          <source>These are typically used in situations where in C/C++, you would allocate a(n) array(s) on the heap, and call the function to fill the array(s) values. In Python, the arrays are allocated for you and returned as new array objects.</source>
          <target state="translated">これらは通常、C/C++ではヒープ上に(n)個の配列を確保し、その配列の値を埋めるために関数を呼び出すような状況で使用されます。Pythonでは、配列はあなたのために確保され、新しい配列オブジェクトとして返されます。</target>
        </trans-unit>
        <trans-unit id="f04a7bcc6ce293328ac2b1079d0f95ad7b19da67" translate="yes" xml:space="preserve">
          <source>These are written in doctest format, and should illustrate how to use the function.</source>
          <target state="translated">これらはdoctest形式で書かれており、関数の使い方を説明しています。</target>
        </trans-unit>
        <trans-unit id="a93c5dc49de55891886f179425b788a1c6ad1b35" translate="yes" xml:space="preserve">
          <source>These arrays are views on the original arrays. They are typically not contiguous. Furthermore, more than one element of a broadcasted array may refer to a single memory location. If you need to write to the arrays, make copies first. While you can set the &lt;code&gt;writable&lt;/code&gt; flag True, writing to a single output value may end up changing more than one location in the output array.</source>
          <target state="translated">これらの配列は、元の配列のビューです。それらは通常隣接していません。さらに、ブロードキャストされた配列の複数の要素が単一のメモリ位置を参照する場合があります。アレイに書き込む必要がある場合は、最初にコピーを作成してください。 &lt;code&gt;writable&lt;/code&gt; フラグをTrueに設定できますが、単一の出力値に書き込むと、出力配列の複数の場所が変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="95e5069d3636251c2ff01dcc947b04bbf8ba1923" translate="yes" xml:space="preserve">
          <source>These behaviors can be set for all kinds of errors or specific ones:</source>
          <target state="translated">これらの動作は、すべての種類のエラーや特定のエラーに対して設定することができます。</target>
        </trans-unit>
        <trans-unit id="7f0acac4ec85b4b4bd7ae1e0ff5a3f9603fcfbc3" translate="yes" xml:space="preserve">
          <source>These constants are used in &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; (and its macro forms) to specify desired properties of the new array.</source>
          <target state="translated">これらの定数は&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;（およびそのマクロ形式）で使用され、新しい配列の必要なプロパティを指定します。</target>
        </trans-unit>
        <trans-unit id="3d245bb5214c903868626d468b5ef8607e3f9a4a" translate="yes" xml:space="preserve">
          <source>These cover almost the whole array (two diagonals right of the main one):</source>
          <target state="translated">これらは、配列のほぼ全体をカバーしています(主なものの右にある2つの斜めのもの)。</target>
        </trans-unit>
        <trans-unit id="f7e900132de2199b00f5d74615e0a1848ce14490" translate="yes" xml:space="preserve">
          <source>These cover only a small part of the whole array (two diagonals right of the main one):</source>
          <target state="translated">これらは、アレイ全体のごく一部をカバーしています(主なものの右にある2つの斜めをカバーしています)。</target>
        </trans-unit>
        <trans-unit id="1adc6f5a53325e3aa2e7cccdff9469027b73b4ce" translate="yes" xml:space="preserve">
          <source>These documents are intended as an introductory overview of NumPy and its features. For detailed reference documentation of the functions and classes contained in the package, see the &lt;a href=&quot;../reference/index#reference&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">これらのドキュメントは、NumPyとその機能の概要を説明することを目的としています。パッケージに含まれる関数とクラスの詳細なリファレンスドキュメントについては、&lt;a href=&quot;../reference/index#reference&quot;&gt;APIリファレンスを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca02dca00e56b01dd5323ec3c2c51c9bba04e9a2" translate="yes" xml:space="preserve">
          <source>These documents are intended as recipes to common tasks using NumPy. For detailed reference documentation of the functions and classes contained in the package, see the &lt;a href=&quot;../reference/index#reference&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">これらのドキュメントは、NumPyを使用する一般的なタスクのレシピとして意図されています。パッケージに含まれる関数とクラスの詳細なリファレンスドキュメントについては、&lt;a href=&quot;../reference/index#reference&quot;&gt;APIリファレンスを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad1b854bfa000aee75512c8df139be2e2841e0fd" translate="yes" xml:space="preserve">
          <source>These documents are intended to explain in detail the concepts and techniques used in NumPy. For the reference documentation of the functions and classes contained in the package, see the &lt;a href=&quot;../reference/index#reference&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">これらのドキュメントは、NumPyで使用される概念と手法を詳細に説明することを目的としています。パッケージに含まれている関数とクラスのリファレンスドキュメントについては、&lt;a href=&quot;../reference/index#reference&quot;&gt;APIリファレンスを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63868acfbf699fe963e728a55308e7d3a9b22eb9" translate="yes" xml:space="preserve">
          <source>These examples illustrate the low-level &lt;a href=&quot;#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; constructor. Refer to the &lt;code&gt;See Also&lt;/code&gt; section above for easier ways of constructing an ndarray.</source>
          <target state="translated">これらの例は、低レベルの&lt;a href=&quot;#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;コンストラクターを示しています。ndarrayを作成する簡単な方法については、上記の &lt;code&gt;See Also&lt;/code&gt; セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="8a348b17d2fb1b33a90b7baa8a557d9af808a018" translate="yes" xml:space="preserve">
          <source>These function all require integer arguments and they manipulate the bit-pattern of those arguments.</source>
          <target state="translated">これらの関数はすべて整数の引数を必要とし、それらの引数のビットパターンを操作します。</target>
        </trans-unit>
        <trans-unit id="d7e647d09c10f9f4521e851e5661f2624622c65e" translate="yes" xml:space="preserve">
          <source>These functions along with a minimal setup file are included in the examples folder.</source>
          <target state="translated">これらの関数と最小限のセットアップファイルは、examples フォルダに含まれています。</target>
        </trans-unit>
        <trans-unit id="47c8ad5dd0ea816b255a3666826ae66a37ff3a15" translate="yes" xml:space="preserve">
          <source>These functions and macros provide easy access to elements of the ndarray from C. These work for all arrays. You may need to take care when accessing the data in the array, however, if it is not in machine byte-order, misaligned, or not writeable. In other words, be sure to respect the state of the flags unless you know what you are doing, or have previously guaranteed an array that is writeable, aligned, and in machine byte-order using &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt;. If you wish to handle all types of arrays, the copyswap function for each type is useful for handling misbehaved arrays. Some platforms (e.g. Solaris) do not like misaligned data and will crash if you de-reference a misaligned pointer. Other platforms (e.g. x86 Linux) will just work more slowly with misaligned data.</source>
          <target state="translated">これらの関数とマクロにより、Cからndarrayの要素に簡単にアクセスできます。これらはすべての配列で機能します。ただし、配列内のデータにアクセスするときは、マシンのバイト順、整列不良、または書き込み可能でない場合は、注意が必要な場合があります。言い換えれば、何をしているのかが分からない場合、または&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;を使用して書き込み可能で整列されたマシンのバイト順の配列が以前に保証されていない限り、フラグの状態を尊重するようにしてください。すべてのタイプの配列を処理したい場合、各タイプのcopyswap関数は、正しく動作しない配列の処理に役立ちます。一部のプラットフォーム（Solarisなど）は、不整合データを好まないため、不整合ポインタを逆参照するとクラッシュします。他のプラットフォーム（x86 Linuxなど）は、データの位置がずれていると動作が遅くなります。</target>
        </trans-unit>
        <trans-unit id="a0b164307df93568d43c0a9ad269b4dbe393e0e6" translate="yes" xml:space="preserve">
          <source>These functions are included here because they are used at least once in the array object&amp;rsquo;s methods. The function returns -1 (without setting a Python Error) if one of the objects being assigned is not callable.</source>
          <target state="translated">これらの関数は、配列オブジェクトのメソッドで少なくとも1回使用されるため、ここに含まれています。関数は、割り当てられているオブジェクトの1つが呼び出し可能でない場合、（Pythonエラーを設定せずに）-1を返します。</target>
        </trans-unit>
        <trans-unit id="8de7e7b6b1e1ede303832d725868059c022d2d0a" translate="yes" xml:space="preserve">
          <source>These functions are very similar to functions without keyword arguments. The only difference is that the function signature is:</source>
          <target state="translated">これらの関数は、キーワード引数のない関数と非常によく似ています。唯一の違いは、関数のシグネチャが</target>
        </trans-unit>
        <trans-unit id="474e0e7c22745c37837977d2aed3d481ae32dc24" translate="yes" xml:space="preserve">
          <source>These identities allow a Chebyshev series to be expressed as a finite, symmetric Laurent series. In this module, this sort of Laurent series is referred to as a &amp;ldquo;z-series.&amp;rdquo;</source>
          <target state="translated">これらのアイデンティティにより、チェビシェフシリーズを有限の対称ローラン級数として表現できます。このモジュールでは、この種のローラン級数を「z級数」と呼びます。</target>
        </trans-unit>
        <trans-unit id="21ed26c6390b302396f6eeab85800f1a745f670f" translate="yes" xml:space="preserve">
          <source>These macros access the &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure members and are defined in &lt;code&gt;ndarraytypes.h&lt;/code&gt;. The input argument, &lt;em&gt;arr&lt;/em&gt;, can be any &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that is directly interpretable as a &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; (any instance of the &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and its sub-types).</source>
          <target state="translated">これらのマクロは&lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;構造体のメンバーにアクセスし、ndarraytypes.hで定義されてい &lt;code&gt;ndarraytypes.h&lt;/code&gt; 。入力引数&lt;em&gt;arr&lt;/em&gt;は、&lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;とそのサブタイプの任意のインスタンス）として直接解釈可能な任意の&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; にする&lt;/a&gt;ことができます。</target>
        </trans-unit>
        <trans-unit id="a58240a1702d16b3630637ee0890f803946e53fd" translate="yes" xml:space="preserve">
          <source>These macros access the &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure members and are defined in &lt;code&gt;ndarraytypes.h&lt;/code&gt;. The input argument, &lt;em&gt;arr&lt;/em&gt;, can be any &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that is directly interpretable as a &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; (any instance of the &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and itssub-types).</source>
          <target state="translated">これらのマクロは&lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;構造体のメンバーにアクセスし、ndarraytypes.hで定義されてい &lt;code&gt;ndarraytypes.h&lt;/code&gt; 。入力引数&lt;em&gt;arr&lt;/em&gt;は、&lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;およびそのサブタイプの任意のインスタンス）として直接解釈可能な任意の&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; にする&lt;/a&gt;ことができます。</target>
        </trans-unit>
        <trans-unit id="13b269cced89ab6392bc06c8030f96e4b737c057" translate="yes" xml:space="preserve">
          <source>These macros all access the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure members. The input argument, arr, can be any &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that is directly interpretable as a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; (any instance of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and its sub-types).</source>
          <target state="translated">これらのマクロはすべて&lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;構造体のメンバーにアクセスします。入力引数arr は、&lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;とそのサブタイプのインスタンス）として直接解釈可能な任意の&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; にする&lt;/a&gt;ことができます。</target>
        </trans-unit>
        <trans-unit id="11ea008c03805b7a8b457a794a3fc2be74133b50" translate="yes" xml:space="preserve">
          <source>These macros are only meaningful if &lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt;&lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; evaluates True during compilation of the extension module. Otherwise, these macros are equivalent to whitespace. Python uses a single Global Interpreter Lock (GIL) for each Python process so that only a single thread may execute at a time (even on multi-cpu machines). When calling out to a compiled function that may take time to compute (and does not have side-effects for other threads like updated global variables), the GIL should be released so that other Python threads can run while the time-consuming calculations are performed. This can be accomplished using two groups of macros. Typically, if one macro in a group is used in a code block, all of them must be used in the same code block. Currently, &lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt;&lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; is defined to the python-defined &lt;a href=&quot;#c.WITH_THREADS&quot;&gt;&lt;code&gt;WITH_THREADS&lt;/code&gt;&lt;/a&gt; constant unless the environment variable &lt;code&gt;NPY_NOSMP&lt;/code&gt; is set in which case &lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt;&lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; is defined to be 0.</source>
          <target state="translated">これらのマクロは、拡張モジュールのコンパイル中に&lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt; &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; が&lt;/a&gt;Trueと評価した場合にのみ意味があります。それ以外の場合、これらのマクロは空白と同等です。 Pythonは、Pythonプロセスごとに単一のグローバルインタープリターロック（GIL）を使用するため、一度に1つのスレッドのみを実行できます（マルチCPUマシンでも）。計算に時間がかかる可能性がある（更新されたグローバル変数などの他のスレッドに副作用がない）コンパイル済み関数を呼び出す場合は、GILを解放して、時間のかかる計算の実行中に他のPythonスレッドを実行できるようにする必要があります。 。これは、2つのグループのマクロを使用して実行できます。通常、グループ内の1つのマクロをコードブロックで使用する場合は、それらすべてを同じコードブロックで使用する必要があります。現在、&lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt; &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; &lt;/a&gt;環境変数 &lt;code&gt;NPY_NOSMP&lt;/code&gt; が設定されていない限り、Pythonで定義された&lt;a href=&quot;#c.WITH_THREADS&quot;&gt; &lt;code&gt;WITH_THREADS&lt;/code&gt; &lt;/a&gt;定数に定義されます。設定されている場合、&lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt; &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; &lt;/a&gt;は0に定義されます。</target>
        </trans-unit>
        <trans-unit id="0b21dcbffd2b61b3d3ee30959d3bc33fc08a9c74" translate="yes" xml:space="preserve">
          <source>These macros are only meaningful if &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; evaluates True during compilation of the extension module. Otherwise, these macros are equivalent to whitespace. Python uses a single Global Interpreter Lock (GIL) for each Python process so that only a single thread may execute at a time (even on multi-cpu machines). When calling out to a compiled function that may take time to compute (and does not have side-effects for other threads like updated global variables), the GIL should be released so that other Python threads can run while the time-consuming calculations are performed. This can be accomplished using two groups of macros. Typically, if one macro in a group is used in a code block, all of them must be used in the same code block. Currently, &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; is defined to the python-defined &lt;code&gt;WITH_THREADS&lt;/code&gt; constant unless the environment variable &lt;code&gt;NPY_NOSMP&lt;/code&gt; is set in which case &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; is defined to be 0.</source>
          <target state="translated">これらのマクロは、拡張モジュールのコンパイル中に &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; が Trueを評価する場合にのみ意味があります。それ以外の場合、これらのマクロは空白と同等です。 Pythonは、Pythonプロセスごとに単一のグローバルインタープリターロック（GIL）を使用するため、一度に実行できるスレッドは1つだけです（マルチCPUマシンでも）。計算に時間がかかる可能性がある（更新されたグローバル変数などの他のスレッドに副作用がない）コンパイル済み関数を呼び出す場合、GILを解放して、時間のかかる計算が実行されている間に他のPythonスレッドを実行できるようにする必要があります。 。これは、マクロの2つのグループを使用して実行できます。通常、グループ内の1つのマクロがコードブロックで使用されている場合、それらすべてを同じコードブロックで使用する必要があります。現在、 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 環境変数 &lt;code&gt;NPY_NOSMP&lt;/code&gt; が設定されていない限り、python定義の &lt;code&gt;WITH_THREADS&lt;/code&gt; 定数に定義されます。この場合、 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; は0と定義されます。</target>
        </trans-unit>
        <trans-unit id="729c9787f60d8418994cdb90a7bff93ed76bf569" translate="yes" xml:space="preserve">
          <source>These macros use different memory allocators, depending on the constant &lt;a href=&quot;#c.NPY_USE_PYMEM&quot;&gt;&lt;code&gt;NPY_USE_PYMEM&lt;/code&gt;&lt;/a&gt;. The system malloc is used when &lt;a href=&quot;#c.NPY_USE_PYMEM&quot;&gt;&lt;code&gt;NPY_USE_PYMEM&lt;/code&gt;&lt;/a&gt; is 0, if &lt;a href=&quot;#c.NPY_USE_PYMEM&quot;&gt;&lt;code&gt;NPY_USE_PYMEM&lt;/code&gt;&lt;/a&gt; is 1, then the Python memory allocator is used.</source>
          <target state="translated">これらのマクロは、定数&lt;a href=&quot;#c.NPY_USE_PYMEM&quot;&gt; &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; に&lt;/a&gt;応じて、異なるメモリアロケータを使用します。システムmallocは、&lt;a href=&quot;#c.NPY_USE_PYMEM&quot;&gt; &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; &lt;/a&gt;が0の場合に使用され、NPY_USE_PYMEMが1の場合は、Python&lt;a href=&quot;#c.NPY_USE_PYMEM&quot;&gt; &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; &lt;/a&gt;ロケーターが使用されます。</target>
        </trans-unit>
        <trans-unit id="da2fff533a172874c502697494e5cdbf3a7c39b3" translate="yes" xml:space="preserve">
          <source>These macros use different memory allocators, depending on the constant &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt;. The system malloc is used when &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; is 0, if &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; is 1, then the Python memory allocator is used.</source>
          <target state="translated">これらのマクロは、定数 &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; に応じて、異なるメモリアロケータを使用します。 &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; が0の場合、システムmallocが使用されます &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; が1の場合、Python メモリアロケーターが使用されます。</target>
        </trans-unit>
        <trans-unit id="512de4565bde2a4a800d6eb7f4ecd21ece637307" translate="yes" xml:space="preserve">
          <source>These members are both pointers to functions to copy data from &lt;em&gt;src&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;swap&lt;/em&gt; if indicated. The value of arr is only used for flexible ( &lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ) arrays (and is obtained from &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; ). The second function copies a single value, while the first loops over n values with the provided strides. These functions can deal with misbehaved &lt;em&gt;src&lt;/em&gt; data. If &lt;em&gt;src&lt;/em&gt; is NULL then no copy is performed. If &lt;em&gt;swap&lt;/em&gt; is 0, then no byteswapping occurs. It is assumed that &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;src&lt;/em&gt; do not overlap. If they overlap, then use &lt;code&gt;memmove&lt;/code&gt; (&amp;hellip;) first followed by &lt;code&gt;copyswap(n)&lt;/code&gt; with NULL valued &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">これらのメンバーは、関数へのポインタの両方からデータをコピーしている&lt;em&gt;SRC&lt;/em&gt;に&lt;em&gt;はdest&lt;/em&gt;と&lt;em&gt;スワップ&lt;/em&gt;示された場合。 arrの値は、フレキシブル（&lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt; &lt;code&gt;NPY_STRING&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt; &lt;code&gt;NPY_UNICODE&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt; &lt;code&gt;NPY_VOID&lt;/code&gt; &lt;/a&gt;）配列にのみ使用されます（そして &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; から取得されます）。 2番目の関数は単一の値をコピーし、最初の関数は提供されたストライドでn個の値をループします。これらの関数は、正しく動作しない&lt;em&gt;src&lt;/em&gt;データを処理できます。場合&lt;em&gt;srcが&lt;/em&gt; NULLであるその後、コピーは実行されません。&lt;em&gt;swap&lt;/em&gt;が0の場合、バイト&lt;em&gt;スワップ&lt;/em&gt;は発生しません。これは想定されている&lt;em&gt;DEST&lt;/em&gt;および&lt;em&gt;SRC&lt;/em&gt;重複しないでください。それらがオーバーラップする場合は、最初に &lt;code&gt;memmove&lt;/code&gt; （&amp;hellip;）を使用し、その後にNULL値の &lt;code&gt;src&lt;/code&gt; を &lt;code&gt;copyswap(n)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="6a72dfa72e903b9f6c19523d338aa7b21c3b5f83" translate="yes" xml:space="preserve">
          <source>These members are both pointers to functions to copy data from &lt;em&gt;src&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;swap&lt;/em&gt; if indicated. The value of arr is only used for flexible ( &lt;a href=&quot;dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ) arrays (and is obtained from &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; ). The second function copies a single value, while the first loops over n values with the provided strides. These functions can deal with misbehaved &lt;em&gt;src&lt;/em&gt; data. If &lt;em&gt;src&lt;/em&gt; is NULL then no copy is performed. If &lt;em&gt;swap&lt;/em&gt; is 0, then no byteswapping occurs. It is assumed that &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;src&lt;/em&gt; do not overlap. If they overlap, then use &lt;code&gt;memmove&lt;/code&gt; (&amp;hellip;) first followed by &lt;code&gt;copyswap(n)&lt;/code&gt; with NULL valued &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">これらのメンバーは、関数へのポインタの両方からデータをコピーしている&lt;em&gt;SRC&lt;/em&gt;に&lt;em&gt;はdest&lt;/em&gt;と&lt;em&gt;スワップ&lt;/em&gt;示された場合。 arrの値は、柔軟な（&lt;a href=&quot;dtype#c.NPY_STRING&quot;&gt; &lt;code&gt;NPY_STRING&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;dtype#c.NPY_UNICODE&quot;&gt; &lt;code&gt;NPY_UNICODE&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;dtype#c.NPY_VOID&quot;&gt; &lt;code&gt;NPY_VOID&lt;/code&gt; &lt;/a&gt;）配列にのみ使用されます（ &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; から取得されます）。 2番目の関数は単一の値をコピーし、最初の関数は指定されたストライドでn個の値をループします。これらの関数は、誤動作した&lt;em&gt;src&lt;/em&gt;データを処理できます。場合&lt;em&gt;srcが&lt;/em&gt;NULLであるその後、コピーは実行されません。&lt;em&gt;スワップ&lt;/em&gt;が0の場合、バイト&lt;em&gt;スワップ&lt;/em&gt;は発生しません。これは想定されている&lt;em&gt;DEST&lt;/em&gt;および&lt;em&gt;SRC&lt;/em&gt;重ならないでください。それらが重複している場合は、最初に &lt;code&gt;memmove&lt;/code&gt; （&amp;hellip;）を使用し、次にnull値の &lt;code&gt;src&lt;/code&gt; を &lt;code&gt;copyswap(n)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="d6721252244f80ca68ee960086197a2ea6f31616" translate="yes" xml:space="preserve">
          <source>These numbers in the previous line represent (0, 0) to machine precision</source>
          <target state="translated">前の行のこれらの数字は、機械精度に対して(0,0)を表しています。</target>
        </trans-unit>
        <trans-unit id="dc06d74801540c694b86fd1603123c1d29a31d44" translate="yes" xml:space="preserve">
          <source>These options determine the way floating point numbers, arrays and other NumPy objects are displayed.</source>
          <target state="translated">これらのオプションは、浮動小数点数や配列、その他のNumPyオブジェクトの表示方法を決定します。</target>
        </trans-unit>
        <trans-unit id="c7caafe15667a4da0d6093971259ebc7a46a9f78" translate="yes" xml:space="preserve">
          <source>These pages describe a general &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; and &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; workflow.</source>
          <target state="translated">これらのページでは、一般的な&lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt;および&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;ワークフローについて説明しています。</target>
        </trans-unit>
        <trans-unit id="df150acba8d3f0417e81ddcccc29e42e2e807db8" translate="yes" xml:space="preserve">
          <source>These paths both use the same machinery. We make the distinction here, because they result in different input to your methods. Specifically, &lt;a href=&quot;#view-casting&quot;&gt;View casting&lt;/a&gt; means you have created a new instance of your array type from any potential subclass of ndarray. &lt;a href=&quot;#new-from-template&quot;&gt;Creating new from template&lt;/a&gt; means you have created a new instance of your class from a pre-existing instance, allowing you - for example - to copy across attributes that are particular to your subclass.</source>
          <target state="translated">これらのパスは両方とも同じ機械を使用します。ここでは、メソッドへの入力が異なるため、区別します。具体的には、&lt;a href=&quot;#view-casting&quot;&gt;ビューキャストと&lt;/a&gt;は、ndarrayの潜在的なサブクラスから配列型の新しいインスタンスを作成したことを意味します。&lt;a href=&quot;#new-from-template&quot;&gt;テンプレートから新規&lt;/a&gt;作成とは、既存のインスタンスからクラスの新しいインスタンスを作成したことを意味します。これにより、たとえば、サブクラスに固有の属性間でコピーできます。</target>
        </trans-unit>
        <trans-unit id="dcba0fcabfaea90dcbb4dedc9f83dbe704fc9440" translate="yes" xml:space="preserve">
          <source>These pointers are different from the pointers accepted by &lt;code&gt;NpyIter_ResetBasePointers&lt;/code&gt;, because the direction along some axes may have been reversed.</source>
          <target state="translated">これらのポインターは、一部の軸に沿った方向が逆になっている可能性があるため、 &lt;code&gt;NpyIter_ResetBasePointers&lt;/code&gt; が受け入れるポインターとは異なります。</target>
        </trans-unit>
        <trans-unit id="2936192ef68f1082cb1baded7a4cc1332510cdca" translate="yes" xml:space="preserve">
          <source>These properties together mean that we can safely mix together the usual user-provided seed with simple incrementing counters to get &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; states that are (to very high probability) independent of each other. We can wrap this together into an API that is easy to use and difficult to misuse.</source>
          <target state="translated">これらのプロパティを組み合わせると、通常のユーザー提供のシードと単純なインクリメントカウンターを安全に組み合わせて、（非常に高い確率で）互いに独立した&lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; &lt;/a&gt;状態を取得できます。これを、使いやすく誤用しにくいAPIにまとめることができます。</target>
        </trans-unit>
        <trans-unit id="43a8a14f212cc60aa00fe9447268d1975d32ef40" translate="yes" xml:space="preserve">
          <source>These properties together mean that we can safely mix together the usual user-provided seed with simple incrementing counters to get &lt;code&gt;BitGenerator&lt;/code&gt; states that are (to very high probability) independent of each other. We can wrap this together into an API that is easy to use and difficult to misuse.</source>
          <target state="translated">これらのプロパティを組み合わせることで、通常のユーザー指定のシードと単純な増分カウンターを安全に組み合わせて、（非常に高い確率で）互いに独立した &lt;code&gt;BitGenerator&lt;/code&gt; 状態を取得できます。これを、使いやすく、誤用しにくいAPIにまとめることができます。</target>
        </trans-unit>
        <trans-unit id="a6a12c973c6b3912e3652bb2e3ed402ca4234700" translate="yes" xml:space="preserve">
          <source>These tools have been found useful by others using Python and so are included here. They are discussed separately because they are either older ways to do things now handled by f2py, Cython, or ctypes (SWIG, PyFort) or because I don&amp;rsquo;t know much about them (SIP, Boost). I have not added links to these methods because my experience is that you can find the most relevant link faster using Google or some other search engine, and any links provided here would be quickly dated. Do not assume that just because it is included in this list, I don&amp;rsquo;t think the package deserves your attention. I&amp;rsquo;m including information about these packages because many people have found them useful and I&amp;rsquo;d like to give you as many options as possible for tackling the problem of easily integrating your code.</source>
          <target state="translated">これらのツールは、Pythonを使用している他の人によって有用であることがわかっているため、ここに含まれています。これらは、f2py、Cython、またはctypes（SWIG、PyFort）によって処理されるようになった古い方法であるか、私がそれらについてあまり知らないため（SIP、Boost）、別々に説明されています。私の経験では、Googleやその他の検索エンジンを使用すると、最も関連性の高いリンクをすばやく見つけることができ、ここで提供されるリンクはすぐに古くなるため、これらのメソッドへのリンクは追加していません。このリストに含まれているからといって、そのパッケージが注目に値するとは思わないでください。多くの人がこれらのパッケージが便利だと思っているので、これらのパッケージに関する情報を含めています。コードを簡単に統合するという問題に取り組むために、できるだけ多くのオプションを提供したいと思います。</target>
        </trans-unit>
        <trans-unit id="f0fbc806872e828602fd0c760ad7240ac769262d" translate="yes" xml:space="preserve">
          <source>These two macros are similar and obtain the pointer to the data-buffer for the array. The first macro can (and should be) assigned to a particular pointer where the second is for generic processing. If you have not guaranteed a contiguous and/or aligned array then be sure you understand how to access the data in the array to avoid memory and/or alignment problems.</source>
          <target state="translated">これら2つのマクロは類似しており、配列のデータバッファへのポインタを取得します。最初のマクロは特定のポインタに代入することができます(そして代入すべきです)が、2番目のマクロは一般的な処理のためのものです。配列の連続性やアラインメントが保証されていない場合は,メモリやアラインメントの問題を避けるために,配列内のデータにアクセスする方法を理解しておく必要があります.</target>
        </trans-unit>
        <trans-unit id="e28f8dd7e1d385fa1bfc87cb75abfbb7c4a8ade7" translate="yes" xml:space="preserve">
          <source>These type names are part of the C-API and can therefore be created in extension C-code. There is also a &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; and a &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; that are simple substitutes for one of the integer types that can hold a pointer on the platform. The structure of these scalar objects is not exposed to C-code. The function &lt;a href=&quot;array#c.PyArray_ScalarAsCtype&quot;&gt;&lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt;&lt;/a&gt; (..) can be used to extract the C-type value from the array scalar and the function &lt;a href=&quot;array#c.PyArray_Scalar&quot;&gt;&lt;code&gt;PyArray_Scalar&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to construct an array scalar from a C-value.</source>
          <target state="translated">これらのタイプ名はC-APIの一部であるため、拡張Cコードで作成できます。あり &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; と &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; プラットフォーム上のポインタを保持できる整数型のいずれかのための簡単な代替です。これらのスカラーオブジェクトの構造は、Cコードに公開されていません。関数&lt;a href=&quot;array#c.PyArray_ScalarAsCtype&quot;&gt; &lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt; &lt;/a&gt;（..）を使用して配列スカラーからCタイプ値を抽出でき、関数&lt;a href=&quot;array#c.PyArray_Scalar&quot;&gt; &lt;code&gt;PyArray_Scalar&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）を使用してC値から配列スカラーを作成できます。</target>
        </trans-unit>
        <trans-unit id="be4a900566749a67d476933d0258a41ade60543e" translate="yes" xml:space="preserve">
          <source>These type names are part of the C-API and can therefore be created in extension C-code. There is also a &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; and a &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; that are simple substitutes for one of the integer types that can hold a pointer on the platform. The structure of these scalar objects is not exposed to C-code. The function &lt;a href=&quot;c-api.array#c.PyArray_ScalarAsCtype&quot;&gt;&lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt;&lt;/a&gt; (..) can be used to extract the C-type value from the array scalar and the function &lt;a href=&quot;c-api.array#c.PyArray_Scalar&quot;&gt;&lt;code&gt;PyArray_Scalar&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to construct an array scalar from a C-value.</source>
          <target state="translated">これらのタイプ名はC-APIの一部であるため、拡張Cコードで作成できます。あり &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; と &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; プラットフォーム上のポインタを保持できる整数型のいずれかのための簡単な代替です。これらのスカラーオブジェクトの構造は、Cコードに公開されていません。関数&lt;a href=&quot;c-api.array#c.PyArray_ScalarAsCtype&quot;&gt; &lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt; &lt;/a&gt;（..）を使用して配列スカラーからCタイプの値を抽出し、関数&lt;a href=&quot;c-api.array#c.PyArray_Scalar&quot;&gt; &lt;code&gt;PyArray_Scalar&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）を使用してC値から配列スカラーを構築できます。</target>
        </trans-unit>
        <trans-unit id="39c33e43ad465d1114668c2913272d120aead183" translate="yes" xml:space="preserve">
          <source>These typemaps now check to make sure that the &lt;code&gt;INPLACE_ARRAY&lt;/code&gt; arguments use native byte ordering. If not, an exception is raised.</source>
          <target state="translated">これらのタイプマップは、 &lt;code&gt;INPLACE_ARRAY&lt;/code&gt; 引数がネイティブのバイト順序を使用していることを確認するようになりました。そうでない場合は、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="afffd3e5751f118e6c4a8e5fa416a0de7397d2ff" translate="yes" xml:space="preserve">
          <source>These values are appended to a copy of &lt;code&gt;a&lt;/code&gt;. It must be of the correct shape (the same shape as &lt;code&gt;a&lt;/code&gt;, excluding &lt;code&gt;axis&lt;/code&gt;). If &lt;code&gt;axis&lt;/code&gt; is not specified, &lt;code&gt;b&lt;/code&gt; can be any shape and will be flattened before use.</source>
          <target state="translated">これらの値は、のコピーに追加されます。これは、正しい形状（同じ形状である必要があり、除く &lt;code&gt;axis&lt;/code&gt; ）。 &lt;code&gt;axis&lt;/code&gt; が指定されていない場合、 &lt;code&gt;b&lt;/code&gt; は任意の形状にすることができ、使用前に平坦化されます。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="612fafedc61071a5e61db03c65c0f553ab91df63" translate="yes" xml:space="preserve">
          <source>These values are appended to a copy of &lt;code&gt;arr&lt;/code&gt;. It must be of the correct shape (the same shape as &lt;code&gt;arr&lt;/code&gt;, excluding &lt;code&gt;axis&lt;/code&gt;). If &lt;code&gt;axis&lt;/code&gt; is not specified, &lt;code&gt;values&lt;/code&gt; can be any shape and will be flattened before use.</source>
          <target state="translated">これらの値は &lt;code&gt;arr&lt;/code&gt; のコピーに追加されます。正しい形状（ &lt;code&gt;axis&lt;/code&gt; を除いて &lt;code&gt;arr&lt;/code&gt; と同じ形状）でなければなりません。 &lt;code&gt;axis&lt;/code&gt; が指定されていない場合、 &lt;code&gt;values&lt;/code&gt; は任意の形状にすることができ、使用前に平坦化されます。</target>
        </trans-unit>
        <trans-unit id="d11f3f9e08bc59771682cf52bbe126f37d2ff215" translate="yes" xml:space="preserve">
          <source>These values are only returned if &lt;a href=&quot;numpy.full#numpy.full&quot;&gt;&lt;code&gt;full&lt;/code&gt;&lt;/a&gt; = True</source>
          <target state="translated">これらの値は、&lt;a href=&quot;numpy.full#numpy.full&quot;&gt; &lt;code&gt;full&lt;/code&gt; &lt;/a&gt; = Trueの場合にのみ返されます</target>
        </trans-unit>
        <trans-unit id="c265d10397c2203b05e143772f5cfb33ffa2cf8c" translate="yes" xml:space="preserve">
          <source>These values are only returned if &lt;code&gt;full&lt;/code&gt; = True</source>
          <target state="translated">これらの値は、 &lt;code&gt;full&lt;/code&gt; = Trueの場合にのみ返されます</target>
        </trans-unit>
        <trans-unit id="94c85fa0224cf9a04b1b6ccf08fcebfe46c06507" translate="yes" xml:space="preserve">
          <source>These values will be element-wise interpolated into the string.</source>
          <target state="translated">これらの値は、文字列に要素ごとに補間されます。</target>
        </trans-unit>
        <trans-unit id="dd5e6abec4e1ccbc6948e611e796f2af804c4524" translate="yes" xml:space="preserve">
          <source>They are the standard vector/matrix/tensor type of NumPy. Many NumPy functions return arrays, not matrices.</source>
          <target state="translated">NumPyの標準的なベクトル/行列/テンソル型です。多くのNumPy関数は行列ではなく配列を返します。</target>
        </trans-unit>
        <trans-unit id="8f43e0b4384b8a2ab0accbd750c1e3d8364a7037" translate="yes" xml:space="preserve">
          <source>They are the standard vector/matrix/tensor type of numpy. Many numpy functions return arrays, not matrices.</source>
          <target state="translated">これらはnumpyの標準的なベクトル/行列/テンソル型です。多くの numpy 関数は,行列ではなく配列を返します.</target>
        </trans-unit>
        <trans-unit id="509dc829f5043c117345f356b056cfc2f0e4fe76" translate="yes" xml:space="preserve">
          <source>They support multidimensional array algebra that is supported in MATLAB</source>
          <target state="translated">MATLABでサポートされている多次元配列の代数をサポートしています。</target>
        </trans-unit>
        <trans-unit id="d528fd04772fea95a1dd88b443f26490baf33962" translate="yes" xml:space="preserve">
          <source>Things are a little bit more tricky when combining reduction and allocated operands. Before iteration is started, any reduction operand must be initialized to its starting values. Here&amp;rsquo;s how we can do this, taking sums along the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">リダクションオペランドと割り当てられたオペランドを組み合わせる場合は、少し注意が必要です。反復を開始する前に、縮小オペランドをその開始値に初期化する必要があります。ここでは、最後の軸に沿って合計を取って、これを行うことができます方法です。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d8c3ebfdc398f463f36600d7ef80c9d888a357d" translate="yes" xml:space="preserve">
          <source>Things become more complex when multidimensional arrays are indexed, particularly with multidimensional index arrays. These tend to be more unusual uses, but they are permitted, and they are useful for some problems. We&amp;rsquo;ll start with the simplest multidimensional case (using the array y from the previous examples):</source>
          <target state="translated">多次元配列にインデックスを付けると、特に多次元インデックス配列を使用すると、事態はさらに複雑になります。これらはより珍しい使用法である傾向がありますが、許可されており、いくつかの問題に役立ちます。最も単純な多次元の場合から始めます（前の例の配列yを使用）。</target>
        </trans-unit>
        <trans-unit id="998943208ea6deef89245cfe0875a67c35f9b773" translate="yes" xml:space="preserve">
          <source>Think of &lt;a href=&quot;#numpy.linalg.multi_dot&quot;&gt;&lt;code&gt;multi_dot&lt;/code&gt;&lt;/a&gt; as:</source>
          <target state="translated">&lt;a href=&quot;#numpy.linalg.multi_dot&quot;&gt; &lt;code&gt;multi_dot&lt;/code&gt; &lt;/a&gt;は次のように考えてください。</target>
        </trans-unit>
        <trans-unit id="80d13b605601d6c6ca920c19b73c5be17b635404" translate="yes" xml:space="preserve">
          <source>This 2-d averaging filter runs quickly because the loop is in C and the pointer computations are done only as needed. If the code above is compiled as a module &lt;code&gt;image&lt;/code&gt;, then a 2-d image, &lt;code&gt;img&lt;/code&gt;, can be filtered using this code very quickly using:</source>
          <target state="translated">この2次元平均化フィルターは、ループがCであり、ポインターの計算が必要な場合にのみ実行されるため、迅速に実行されます。上記のコードがモジュール &lt;code&gt;image&lt;/code&gt; としてコンパイルされている場合、2次元イメージ &lt;code&gt;img&lt;/code&gt; は、次のコードを使用してこのコードを使用して非常にすばやくフィルタリングできます。</target>
        </trans-unit>
        <trans-unit id="1e4e675f0444c2be3f07e89468e7d677b6986ce7" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;.wav&lt;/code&gt; example is for illustration; to read a &lt;code&gt;.wav&lt;/code&gt; file in real life, use Python&amp;rsquo;s built-in module &lt;a href=&quot;https://docs.python.org/dev/library/wave.html#module-wave&quot;&gt;&lt;code&gt;wave&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この &lt;code&gt;.wav&lt;/code&gt; の例は説明用です。実際に &lt;code&gt;.wav&lt;/code&gt; ファイルを読み取るには、Pythonの組み込みモジュール&lt;a href=&quot;https://docs.python.org/dev/library/wave.html#module-wave&quot;&gt; &lt;code&gt;wave&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="269959a51cb8489ddd62f29ffab3f7d5a6b40d53" translate="yes" xml:space="preserve">
          <source>This Chapter attempts to explain the logic behind some of the new pieces of code. The purpose behind these explanations is to enable somebody to be able to understand the ideas behind the implementation somewhat more easily than just staring at the code. Perhaps in this way, the algorithms can be improved on, borrowed from, and/or optimized by more people.</source>
          <target state="translated">この章では、いくつかの新しいコードの背後にあるロジックを説明しようとしています。これらの説明の背後にある目的は、コードを見ているだけではなく、実装の背後にある考え方を誰かがより簡単に理解できるようにすることです。おそらくこのようにして、より多くの人がアルゴリズムを改良したり、借りたり、最適化したりすることができるようになるでしょう。</target>
        </trans-unit>
        <trans-unit id="d6d4a7a2f523794d0b16e4b9b049698c812e64fd" translate="yes" xml:space="preserve">
          <source>This Subcommittee shall NOT make decisions about the direction, scope or technical direction of the Project.</source>
          <target state="translated">本分科会は、プロジェクトの方向性、範囲、技術的な方向性について決定してはならない。</target>
        </trans-unit>
        <trans-unit id="e344df267f24877e3c878787dee0c7157b282950" translate="yes" xml:space="preserve">
          <source>This Subcommittee will have 5 members, 4 of whom will be current Council Members and 1 of whom will be external to the Steering Council. No more than 2 Subcommittee Members can report to one person through employment or contracting work (including the reportee, i.e. the reportee + 1 is the max). This avoids effective majorities resting on one person.</source>
          <target state="translated">本分科会の委員は5名とし、そのうち4名は現職のカウンシルメンバー、1名は運営協議会の外部委員とする。分科委員会の委員は、雇用や業務委託により1人の人間に報告することができるのは2人以下とする(報告者を含めて、報告者+1が最大)。これにより、有効な多数決が一人に依存することを避けることができる。</target>
        </trans-unit>
        <trans-unit id="d8eb7804ceb212518c04178ca9353c5652cddc34" translate="yes" xml:space="preserve">
          <source>This address may be cached before the iteration loop, calling &lt;code&gt;iternext&lt;/code&gt; will not change it. The value itself may change during iteration, in particular if buffering is enabled. This function may be safely called without holding the Python GIL.</source>
          <target state="translated">このアドレスは反復ループの前にキャッシュされる可能性があり、 &lt;code&gt;iternext&lt;/code&gt; を呼び出しても変更されません。特にバッファリングが有効になっている場合、値自体は反復中に変更される可能性があります。この関数は、Python GILを保持せずに安全に呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="6a02ab6384a4ff5cc117cc0360cf322a65257b07" translate="yes" xml:space="preserve">
          <source>This advanced indexing occurs when obj is an array object of Boolean type, such as may be returned from comparison operators. A single boolean index array is practically identical to &lt;code&gt;x[obj.nonzero()]&lt;/code&gt; where, as described above, &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;obj.nonzero()&lt;/code&gt;&lt;/a&gt; returns a tuple (of length &lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt;&lt;code&gt;obj.ndim&lt;/code&gt;&lt;/a&gt;) of integer index arrays showing the &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; elements of &lt;em&gt;obj&lt;/em&gt;. However, it is faster when &lt;code&gt;obj.shape == x.shape&lt;/code&gt;.</source>
          <target state="translated">この高度なインデックス付けは、objがブール型の配列オブジェクトである場合に発生します。たとえば、比較演算子から返される場合があります。単一のブールインデックス配列は、 &lt;code&gt;x[obj.nonzero()]&lt;/code&gt; と実質的に同じです。ここで、上記のように、&lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt; &lt;code&gt;obj.nonzero()&lt;/code&gt; &lt;/a&gt;は、&lt;em&gt;objの&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt;要素を示す整数インデックス配列のタプル（長さ&lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt; &lt;code&gt;obj.ndim&lt;/code&gt; &lt;/a&gt;）を返します。ただし、 &lt;code&gt;obj.shape == x.shape&lt;/code&gt; 場合は高速です。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dacb6ef0aabe4e0449ac2f7d6e826edb424af8c" translate="yes" xml:space="preserve">
          <source>This advanced indexing occurs when obj is an array object of Boolean type, such as may be returned from comparison operators. A single boolean index array is practically identical to &lt;code&gt;x[obj.nonzero()]&lt;/code&gt; where, as described above, &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;obj.nonzero()&lt;/code&gt;&lt;/a&gt; returns a tuple (of length &lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt;&lt;code&gt;obj.ndim&lt;/code&gt;&lt;/a&gt;) of integer index arrays showing the &lt;code&gt;True&lt;/code&gt; elements of &lt;em&gt;obj&lt;/em&gt;. However, it is faster when &lt;code&gt;obj.shape == x.shape&lt;/code&gt;.</source>
          <target state="translated">この高度なインデックス作成は、objが比較演算子から返されるようなブール型の配列オブジェクトである場合に発生します。単一のブールインデックス配列は、 &lt;code&gt;x[obj.nonzero()]&lt;/code&gt; と実質的に同じです。上記のように、&lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt; &lt;code&gt;obj.nonzero()&lt;/code&gt; &lt;/a&gt;は、&lt;em&gt;objの&lt;/em&gt; &lt;code&gt;True&lt;/code&gt; 要素を示す整数インデックス配列の（長さ&lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt; &lt;code&gt;obj.ndim&lt;/code&gt; の&lt;/a&gt;）タプルを返します。ただし、 &lt;code&gt;obj.shape == x.shape&lt;/code&gt; 場合は高速です。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="710121ccc37af7c57d603d19a46f2cadc801d4ee" translate="yes" xml:space="preserve">
          <source>This allows multithreading to fill large arrays in chunks using suitable BitGenerators in parallel.</source>
          <target state="translated">これにより、適切なBitGeneratorを使用して並列に大きな配列をチャンクで埋めるマルチスレッドが可能になります。</target>
        </trans-unit>
        <trans-unit id="af03503ddeac7c1214ea6c40abe67021cd6a3a66" translate="yes" xml:space="preserve">
          <source>This allows you to import the in-place built NumPy &lt;em&gt;from the repo base directory only&lt;/em&gt;. If you want the in-place build to be visible outside that base dir, you need to point your &lt;code&gt;PYTHONPATH&lt;/code&gt; environment variable to this directory. Some IDEs (&lt;a href=&quot;https://www.spyder-ide.org/&quot;&gt;Spyder&lt;/a&gt; for example) have utilities to manage &lt;code&gt;PYTHONPATH&lt;/code&gt;. On Linux and OSX, you can run the command:</source>
          <target state="translated">これにより、インプレースでビルドされたNumPy&lt;em&gt;をリポジトリベースディレクトリからのみ&lt;/em&gt;インポートできます。インプレースビルドをそのベースディレクトリの外部に表示する場合は、 &lt;code&gt;PYTHONPATH&lt;/code&gt; 環境変数がこのディレクトリを指すようにする必要があります。一部のIDE（&lt;a href=&quot;https://www.spyder-ide.org/&quot;&gt;Spyder&lt;/a&gt;など）には、 &lt;code&gt;PYTHONPATH&lt;/code&gt; を管理するためのユーティリティがあります。LinuxおよびOSXでは、次のコマンドを実行できます。</target>
        </trans-unit>
        <trans-unit id="8a10be423c319c36683d60f03c4235ea58ef43ca" translate="yes" xml:space="preserve">
          <source>This also works for functions and other objects that &lt;strong&gt;you&lt;/strong&gt; create. Just remember to include a docstring with your function using a string literal (&lt;code&gt;&quot;&quot;&quot; &quot;&quot;&quot;&lt;/code&gt; or &lt;code&gt;''' '''&lt;/code&gt; around your documentation).</source>
          <target state="translated">これ&lt;strong&gt;は、&lt;/strong&gt;作成する関数やその他のオブジェクトでも機能します。文字列リテラル（ドキュメント &lt;code&gt;''' '''&lt;/code&gt; 前後に &lt;code&gt;&quot;&quot;&quot; &quot;&quot;&quot;&lt;/code&gt; または'' '' ''）を使用して、関数にdocstringを含めることを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="43700c3e2d90a58545492f544e16be4440930810" translate="yes" xml:space="preserve">
          <source>This also works in more dimensions, e.g.</source>
          <target state="translated">これは、例えば、より多くの次元でも機能します。</target>
        </trans-unit>
        <trans-unit id="d1c39c0afd071dc6e571fc8d1273c278aad6faa3" translate="yes" xml:space="preserve">
          <source>This also works with 2D arrays! If you start with this array:</source>
          <target state="translated">これは2次元配列でも動作します! この配列から始めると</target>
        </trans-unit>
        <trans-unit id="d160c6be16a498bbc805a56a17ad9724ae3c358b" translate="yes" xml:space="preserve">
          <source>This applies type promotion to all the inputs, using the NumPy rules for combining scalars and arrays, to determine the output type of a set of operands. This is the same result type that ufuncs produce. The specific algorithm used is as follows.</source>
          <target state="translated">これは、スカラと配列を結合するためのNumPyのルールを使用して、すべての入力に型昇格を適用し、オペランドのセットの出力型を決定します。これは、ufuncsが生成するのと同じ結果型です。使用される具体的なアルゴリズムは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="2e8bc0cbcc5f069a41dc6497b9c0a909fd514a44" translate="yes" xml:space="preserve">
          <source>This approach to the array interface allows for faster access to an array using only one attribute lookup and a well-defined C-structure.</source>
          <target state="translated">この配列インターフェースへのアプローチにより、1つの属性ルックアップとよく定義されたC構造だけを使用して、より高速に配列にアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="b2cfa3868ca6d5d3eec71f613d2a281e952e696d" translate="yes" xml:space="preserve">
          <source>This approach to the interface consists of the object having an &lt;a href=&quot;#__array_interface__&quot;&gt;&lt;code&gt;__array_interface__&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">インターフェイスへのこのアプローチは、&lt;a href=&quot;#__array_interface__&quot;&gt; &lt;code&gt;__array_interface__&lt;/code&gt; &lt;/a&gt;属性を持つオブジェクトで構成されます。</target>
        </trans-unit>
        <trans-unit id="3505c6babbf93b992cced9994459f797fa18ee9a" translate="yes" xml:space="preserve">
          <source>This approach to the interface consists of the object having an &lt;a href=&quot;#object.__array_interface__&quot;&gt;&lt;code&gt;__array_interface__&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">インターフェイスへのこのアプローチは、&lt;a href=&quot;#object.__array_interface__&quot;&gt; &lt;code&gt;__array_interface__&lt;/code&gt; &lt;/a&gt;属性を持つオブジェクトで構成されます。</target>
        </trans-unit>
        <trans-unit id="e27c7321ec2c09e2c1e41b0fb7ac933d7973957f" translate="yes" xml:space="preserve">
          <source>This arrangement allow for very flexible use of arrays. One thing that it allows is simple changes of the metadata to change the interpretation of the array buffer. Changing the byteorder of the array is a simple change involving no rearrangement of the data. The shape of the array can be changed very easily without changing anything in the data buffer or any data copying at all</source>
          <target state="translated">この配置は、配列を非常に柔軟に使用することを可能にします。一つは、配列バッファの解釈を変更するためにメタデータを簡単に変更することです。配列のバイト順を変更することは、データの再配置を伴わない簡単な変更です。配列の形状は、データバッファ内の何も変更することなく、またデータのコピーも全く行わずに、非常に簡単に変更することができます。</target>
        </trans-unit>
        <trans-unit id="13b0f80cc0af4acb749cdb54d3ae94021e334ad5" translate="yes" xml:space="preserve">
          <source>This array creation routine allows for the convenient creation of a new array matching an existing array&amp;rsquo;s shapes and memory layout, possibly changing the layout and/or data type.</source>
          <target state="translated">この配列作成ルーチンを使用すると、既存の配列の形状とメモリレイアウトに一致する新しい配列を簡単に作成でき、場合によってはレイアウトやデータタイプを変更できます。</target>
        </trans-unit>
        <trans-unit id="b6ad81be881df54f2faa5255b14c490a53a2cd92" translate="yes" xml:space="preserve">
          <source>This array is a copy of some other array. The C-API function PyArray_ResolveWritebackIfCopy must be called before deallocating to the base array will be updated with the contents of this array.</source>
          <target state="translated">この配列は他の配列のコピーです。C-API関数PyArray_ResolveWritebackIfCopyを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="9975deeda2df7b42c75df625b9b5fc69426c2203" translate="yes" xml:space="preserve">
          <source>This array is stored in memory as 40 bytes, one after the other (known as a contiguous block of memory). The strides of an array tell us how many bytes we have to skip in memory to move to the next position along a certain axis. For example, we have to skip 4 bytes (1 value) to move to the next column, but 20 bytes (5 values) to get to the same position in the next row. As such, the strides for the array &lt;code&gt;x&lt;/code&gt; will be &lt;code&gt;(20, 4)&lt;/code&gt;.</source>
          <target state="translated">この配列は、40バイトとしてメモリに連続して格納されます（メモリの連続ブロックと呼ばれます）。配列のストライドは、特定の軸に沿って次の位置に移動するためにメモリでスキップする必要があるバイト数を示します。たとえば、次の列に移動するには4バイト（1つの値）をスキップする必要がありますが、次の行の同じ位置に移動するには20バイト（5つの値）をスキップする必要があります。このように、アレイのためのストライド &lt;code&gt;x&lt;/code&gt; があろう &lt;code&gt;(20, 4)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38cb8241a835a683d594eee86aed4e56e6c6635d" translate="yes" xml:space="preserve">
          <source>This array is the mask for all &lt;a href=&quot;../generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;writemasked&lt;/code&gt;&lt;/a&gt; operands. Code uses the &lt;code&gt;writemasked&lt;/code&gt; flag which indicates that only elements where the chosen ARRAYMASK operand is True will be written to. In general, the iterator does not enforce this, it is up to the code doing the iteration to follow that promise.</source>
          <target state="translated">この配列は、すべての&lt;a href=&quot;../generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;writemasked&lt;/code&gt; &lt;/a&gt;マスクされたオペランドのマスクです。コードは、選択されたARRAYMASKオペランドがTrueである要素のみが書き込まれることを示す &lt;code&gt;writemasked&lt;/code&gt; フラグを使用します。一般に、イテレータはこれを強制しません。その約束に従うために反復を行うのはコード次第です。</target>
        </trans-unit>
        <trans-unit id="6ed5fe179d122dc6d0ff4af8af1bf207796107b0" translate="yes" xml:space="preserve">
          <source>This array is the mask for all &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;writemasked&lt;/code&gt;&lt;/a&gt; operands. Code uses the &lt;code&gt;writemasked&lt;/code&gt; flag which indicates that only elements where the chosen ARRAYMASK operand is True will be written to. In general, the iterator does not enforce this, it is up to the code doing the iteration to follow that promise.</source>
          <target state="translated">この配列は、すべての&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;writemasked&lt;/code&gt; &lt;/a&gt;マスクされたオペランドのマスクです。コードは、選択されたARRAYMASKオペランドがTrueである要素のみに書き込まれることを示す &lt;code&gt;writemasked&lt;/code&gt; フラグを使用します。一般に、イテレーターはこれを強制しません。その約束に従って反復を行うのはコード次第です。</target>
        </trans-unit>
        <trans-unit id="da76cf9484436ae5f595cbe33ce62d99eee348ae" translate="yes" xml:space="preserve">
          <source>This array is used in computing an N-d index from a 1-d index. It contains needed products of the dimensions.</source>
          <target state="translated">この配列は,1次元のインデックスからN次元のインデックスを計算する際に使用されます.次元の必要積が格納されています.</target>
        </trans-unit>
        <trans-unit id="2950d768bc15bd8305b22a36aa90ddcbd53411a1" translate="yes" xml:space="preserve">
          <source>This array method can be conveniently chained:</source>
          <target state="translated">この配列メソッドは、便利に連鎖させることができます。</target>
        </trans-unit>
        <trans-unit id="cd59928fafb5b8b3afd2257d5348ff12e61a3751" translate="yes" xml:space="preserve">
          <source>This array must contain integers in &lt;code&gt;[0, n-1]&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of choices, unless &lt;code&gt;mode=wrap&lt;/code&gt; or &lt;code&gt;mode=clip&lt;/code&gt;, in which cases any integers are permissible.</source>
          <target state="translated">この配列は &lt;code&gt;[0, n-1]&lt;/code&gt; 整数を含む必要があります。ここで &lt;code&gt;n&lt;/code&gt; は選択肢の数です。ただし、 &lt;code&gt;mode=wrap&lt;/code&gt; または &lt;code&gt;mode=clip&lt;/code&gt; の場合を除きます。この場合、任意の整数が許可されます。</target>
        </trans-unit>
        <trans-unit id="2801e85aeaae18790917a73e502d7026a3a34d08" translate="yes" xml:space="preserve">
          <source>This array must contain integers in &lt;code&gt;[0, n-1]&lt;/code&gt;, where n is the number of choices.</source>
          <target state="translated">この配列は &lt;code&gt;[0, n-1]&lt;/code&gt; 整数を含む必要があります。ここで、nは選択肢の数です。</target>
        </trans-unit>
        <trans-unit id="7231182809746ea9e4a7a5bcc665f806413fd373" translate="yes" xml:space="preserve">
          <source>This assumes that you have forked &lt;a href=&quot;https://github.com/scipy/scipy.org&quot;&gt;https://github.com/scipy/scipy.org&lt;/a&gt;:</source>
          <target state="translated">これは、&lt;a href=&quot;https://github.com/scipy/scipy.org&quot;&gt;https&lt;/a&gt;：//github.com/scipy/scipy.orgをフォークしたことを前提としています。</target>
        </trans-unit>
        <trans-unit id="3397e055cb40235a1ae2818b229475b2582745a3" translate="yes" xml:space="preserve">
          <source>This attribute allows simple but flexible determination of which sub- type should be considered &amp;ldquo;primary&amp;rdquo; when an operation involving two or more sub-types arises. In operations where different sub-types are being used, the sub-type with the largest &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; attribute will determine the sub-type of the output(s). If two sub- types have the same &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; then the sub-type of the first argument determines the output. The default &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; attribute returns a value of 0.0 for the base ndarray type and 1.0 for a sub-type. This attribute can also be defined by objects that are not sub-types of the ndarray and can be used to determine which &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; method should be called for the return output.</source>
          <target state="translated">この属性により、2つ以上のサブタイプを含む操作が発生した場合に、どのサブタイプを「プライマリ」と見なすかを簡単かつ柔軟に決定できます。異なるサブタイプが使用されている操作では、最大の&lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;属性を持つサブタイプが出力のサブタイプを決定します。 2つのサブタイプの&lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;が同じである場合、最初の引数のサブタイプが出力を決定します。デフォルトの&lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;属性は、基本ndarrayタイプの場合は0.0、サブタイプの場合は1.0の値を返します。この属性は、ndarrayのサブタイプではないオブジェクトによって定義することもでき、戻り出力に対してどの&lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt;メソッドを呼び出す必要があるかを決定するために使用できます。</target>
        </trans-unit>
        <trans-unit id="a1937d99c6f34bca77e93395a42e2a63ca828dcf" translate="yes" xml:space="preserve">
          <source>This attribute can also be an object exposing the &lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#bufferobjects&quot;&gt;buffer interface&lt;/a&gt; which will be used to share the data. If this key is not present (or returns None), then memory sharing will be done through the buffer interface of the object itself. In this case, the offset key can be used to indicate the start of the buffer. A reference to the object exposing the array interface must be stored by the new object if the memory area is to be secured.</source>
          <target state="translated">この属性は、データの共有に使用される&lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#bufferobjects&quot;&gt;バッファーインターフェイス&lt;/a&gt;を公開するオブジェクトにすることもできます。このキーが存在しない場合（またはNoneを返す場合）、メモリ共有はオブジェクト自体のバッファインターフェイスを介して行われます。この場合、オフセットキーを使用してバッファの開始を示すことができます。メモリ領域を保護する場合は、配列インターフェイスを公開するオブジェクトへの参照を新しいオブジェクトによって保存する必要があります。</target>
        </trans-unit>
        <trans-unit id="19820dc6931f03b4ce34d1e382ce5208e82ba583" translate="yes" xml:space="preserve">
          <source>This attribute can also be an object exposing the &lt;a href=&quot;https://docs.python.org/dev/c-api/objbuffer.html#c.PyObject_AsCharBuffer&quot;&gt;&lt;code&gt;buffer interface&lt;/code&gt;&lt;/a&gt; which will be used to share the data. If this key is not present (or returns &lt;code&gt;None&lt;/code&gt;), then memory sharing will be done through the buffer interface of the object itself. In this case, the offset key can be used to indicate the start of the buffer. A reference to the object exposing the array interface must be stored by the new object if the memory area is to be secured.</source>
          <target state="translated">この属性は、データの共有に使用される&lt;a href=&quot;https://docs.python.org/dev/c-api/objbuffer.html#c.PyObject_AsCharBuffer&quot;&gt; &lt;code&gt;buffer interface&lt;/code&gt; &lt;/a&gt;を公開するオブジェクトにすることもできます。このキーが存在しない（または &lt;code&gt;None&lt;/code&gt; を返す）場合、メモリ共有はオブジェクト自体のバッファーインターフェイスを介して行われます。この場合、オフセットキーを使用して、バッファの開始を示すことができます。メモリ領域を確保する必要がある場合は、配列インターフェイスを公開するオブジェクトへの参照を新しいオブジェクトに格納する必要があります。</target>
        </trans-unit>
        <trans-unit id="357acc58797c34ec7ee3526baa5d4678b200c571" translate="yes" xml:space="preserve">
          <source>This attribute can also be an object exposing the &lt;code&gt;buffer interface&lt;/code&gt; which will be used to share the data. If this key is not present (or returns None), then memory sharing will be done through the buffer interface of the object itself. In this case, the offset key can be used to indicate the start of the buffer. A reference to the object exposing the array interface must be stored by the new object if the memory area is to be secured.</source>
          <target state="translated">この属性は、データの共有に使用される &lt;code&gt;buffer interface&lt;/code&gt; を公開するオブジェクトにすることもできます。このキーが存在しない（またはNoneを返す）場合、メモリ共有はオブジェクト自体のバッファインターフェイスを介して行われます。この場合、オフセットキーを使用してバッファの開始を示すことができます。メモリ領域を保護する場合は、配列インターフェイスを公開するオブジェクトへの参照を新しいオブジェクトによって保存する必要があります。</target>
        </trans-unit>
        <trans-unit id="99486092092808fe1a7a3c63950908fb38dd3c25" translate="yes" xml:space="preserve">
          <source>This attribute creates an object that makes it easier to use arrays when calling shared libraries with the ctypes module. The returned object has, among others, data, shape, and strides attributes (see Notes below) which themselves return ctypes objects that can be used as arguments to a shared library.</source>
          <target state="translated">この属性は、ctypesモジュールで共有ライブラリを呼び出す際に、配列をより簡単に使用できるようにするオブジェクトを作成します。返されるオブジェクトは、特に、data,shape,strides属性(以下の注意事項を参照)を持っており、これらの属性自体が共有ライブラリの引数として使用できるctypesオブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="94f279541eccc23ec8d58b2be974fecc119fa4c7" translate="yes" xml:space="preserve">
          <source>This basic behavior can be augmented by passing a 2-tuple in as the file argument. The first element of the tuple should specify the relative path (under the package install directory) where the remaining sequence of files should be installed to (it has nothing to do with the file-names in the source distribution). The second element of the tuple is the sequence of files that should be installed. The files in this sequence can be filenames, relative paths, or absolute paths. For absolute paths the file will be installed in the top-level package installation directory (regardless of the first argument). Filenames and relative path names will be installed in the package install directory under the path name given as the first element of the tuple.</source>
          <target state="translated">この基本的な動作は、ファイルの引数に 2 タプルを渡すことで拡張できます。タプルの最初の要素は、残りの一連のファイルがインストールされる相対パス (パッケージのインストールディレクトリの下)を指定します (ソース配布物のファイル名とは関係ありません)。タプルの 2 番目の要素は、インストールされるべきファイルのシーケンスです。このシーケンスに含まれるファイルは、ファイル名、相対パス、絶対パスのいずれかになります。絶対パスの場合、ファイルはトップレベルのパッケージインストールディレクトリにインストールされます (最初の引数に関係なく)。ファイル名と相対パス名は、タプルの最初の要素として与えられたパス名の下のパッケージインストールディレクトリにインストールされます。</target>
        </trans-unit>
        <trans-unit id="38d8b59be8238ec40cd52d11a1691c2db5ac9b19" translate="yes" xml:space="preserve">
          <source>This broadcasting can also be achieved using the function &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">このブロードキャストは、関数&lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt;を使用しても実現できます。</target>
        </trans-unit>
        <trans-unit id="040d755c45914cdad7e449ca2485bc004cd21eb5" translate="yes" xml:space="preserve">
          <source>This bug causes Python before 3.4 to not reliably show warnings again after they have been ignored once (even within catch_warnings). It means that no &amp;ldquo;ignore&amp;rdquo; filter can be used easily, since following tests might need to see the warning. Additionally it allows easier specificity for testing warnings and can be nested.</source>
          <target state="translated">このバグにより、3.4より前のPythonでは、警告が一度無視された後（catch_warnings内であっても）確実に再び警告が表示されなくなります。これは、次のテストで警告を確認する必要がある可能性があるため、「無視」フィルターを簡単に使用できないことを意味します。さらに、警告をテストするための特定を容易にし、ネストすることができます。</target>
        </trans-unit>
        <trans-unit id="b97776ec43283f6527b6b56ee297ecb07c0e7a5e" translate="yes" xml:space="preserve">
          <source>This builds NumPy first, so the first time it may take a few minutes. If you specify &lt;code&gt;-n&lt;/code&gt;, the tests are run against the version of NumPy (if any) found on current PYTHONPATH.</source>
          <target state="translated">これにより、最初にNumPyがビルドされるため、初回は数分かかる場合があります。 &lt;code&gt;-n&lt;/code&gt; を指定すると、現在のPYTHONPATHにあるバージョンのNumPy（存在する場合）に対してテストが実行されます。</target>
        </trans-unit>
        <trans-unit id="25f8c2b712d454554ccb3b1572df7e3d85a8d6a8" translate="yes" xml:space="preserve">
          <source>This can be done via &lt;em&gt;interactive rebasing&lt;/em&gt;.</source>
          <target state="translated">これは、&lt;em&gt;インタラクティブなリベース&lt;/em&gt;を介して行うことができます。</target>
        </trans-unit>
        <trans-unit id="3d1ccaf9367b320b45fde18f5d1b6d26c14c28d1" translate="yes" xml:space="preserve">
          <source>This can be used on multidimensional arrays too:</source>
          <target state="translated">これは多次元配列でも使用できます。</target>
        </trans-unit>
        <trans-unit id="4619f696b33e2f5aafe4335faf3807d265baaeed" translate="yes" xml:space="preserve">
          <source>This can have multiple paragraphs.</source>
          <target state="translated">これは複数の段落を持つことができます。</target>
        </trans-unit>
        <trans-unit id="7b0866e6d60c935d1c1a437309972ddf022e2bfb" translate="yes" xml:space="preserve">
          <source>This chapter will review many of the tools that are available for the purpose of accessing code written in other compiled languages. There are many resources available for learning to call other compiled libraries from Python and the purpose of this Chapter is not to make you an expert. The main goal is to make you aware of some of the possibilities so that you will know what to &amp;ldquo;Google&amp;rdquo; in order to learn more.</source>
          <target state="translated">この章では、他のコンパイル言語で記述されたコードにアクセスする目的で使用できるツールの多くを確認します。Pythonから他のコンパイル済みライブラリを呼び出すことを学ぶために利用できる多くのリソースがあり、この章の目的はあなたを専門家にすることではありません。主な目標は、いくつかの可能性を認識して、詳細を学ぶために「Google」に何をすべきかを理解できるようにすることです。</target>
        </trans-unit>
        <trans-unit id="f7b07ef80d0cc13652d9fe61895de6904fd8ef60" translate="yes" xml:space="preserve">
          <source>This class implements the special methods for almost all of Python&amp;rsquo;s builtin operators defined in the &lt;a href=&quot;https://docs.python.org/dev/library/operator.html#module-operator&quot;&gt;&lt;code&gt;operator&lt;/code&gt;&lt;/a&gt; module, including comparisons (&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, etc.) and arithmetic (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, etc.), by deferring to the &lt;code&gt;__array_ufunc__&lt;/code&gt; method, which subclasses must implement.</source>
          <target state="translated">このクラスの実装ほとんどすべてで定義されたPythonの組み込みオペレータのための特別な方法&lt;a href=&quot;https://docs.python.org/dev/library/operator.html#module-operator&quot;&gt; &lt;code&gt;operator&lt;/code&gt; &lt;/a&gt;比較を含むモジュール、（ &lt;code&gt;==&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、など）と演算（ &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;-&lt;/code&gt; に延期することによって、等）、 &lt;code&gt;__array_ufunc__&lt;/code&gt; 方法どのサブクラスが実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="4c89b01b7f4a0346b82c2ab3f988792b632fe09a" translate="yes" xml:space="preserve">
          <source>This class is provided for numarray backward-compatibility. New code (not concerned with numarray compatibility) should use arrays of type &lt;a href=&quot;../arrays.scalars#numpy.string_&quot;&gt;&lt;code&gt;string_&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../arrays.scalars#numpy.unicode_&quot;&gt;&lt;code&gt;unicode_&lt;/code&gt;&lt;/a&gt; and use the free functions in &lt;code&gt;numpy.char&lt;/code&gt; for fast vectorized string operations instead.</source>
          <target state="translated">このクラスは、numarrayの下位互換性のために提供されています。新しいコード（numarrayの互換性には関係ありません）は、&lt;a href=&quot;../arrays.scalars#numpy.string_&quot;&gt; &lt;code&gt;string_&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../arrays.scalars#numpy.unicode_&quot;&gt; &lt;code&gt;unicode_&lt;/code&gt; &lt;/a&gt;型の配列を使用し、代わりに &lt;code&gt;numpy.char&lt;/code&gt; の無料の関数を使用して高速のベクトル化された文字列操作を行う必要があります。</target>
        </trans-unit>
        <trans-unit id="cbc453ece1fc4bcfba8a214ebb68dae3ad49689e" translate="yes" xml:space="preserve">
          <source>This class is provided for numarray backward-compatibility. New code (not concerned with numarray compatibility) should use arrays of type &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt; and use the free functions in &lt;code&gt;numpy.char&lt;/code&gt; for fast vectorized string operations instead.</source>
          <target state="translated">このクラスは、numarrayの下位互換性のために提供されています。新しいコード（numarrayの互換性には関係ありません）は、 &lt;code&gt;string_&lt;/code&gt; または &lt;code&gt;unicode_&lt;/code&gt; タイプの配列を使用し、代わりに &lt;code&gt;numpy.char&lt;/code&gt; の無料の関数を使用して、高速ベクトル化された文字列操作を実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="817afa6aa8358446cc6150c81d202fd10664d253" translate="yes" xml:space="preserve">
          <source>This class isn&amp;rsquo;t very useful, because it has the same constructor as the bare ndarray object, including passing in buffers and shapes and so on. We would probably prefer the constructor to be able to take an already formed ndarray from the usual numpy calls to &lt;code&gt;np.array&lt;/code&gt; and return an object.</source>
          <target state="translated">このクラスは、バッファーやシェイプの受け渡しなど、裸のndarrayオブジェクトと同じコンストラクターを持っているため、あまり役に立ちません。コンストラクターは、np.arrayへの通常のnumpy呼び出しから既に形成されたndarrayを &lt;code&gt;np.array&lt;/code&gt; して、オブジェクトを返すことができるようにすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="547d58e17f08661cffe0028727466b3bfecb1f09" translate="yes" xml:space="preserve">
          <source>This class may at some point be turned into a factory function which returns a view into an mmap buffer.</source>
          <target state="translated">このクラスは、いつかはビューをmmapバッファに返すファクトリ関数に変わるかもしれません。</target>
        </trans-unit>
        <trans-unit id="9f0e2bd2c54e1831a429118c49099c40d4fc6a31" translate="yes" xml:space="preserve">
          <source>This code can be compiled and linked into an extension module named filter using:</source>
          <target state="translated">このコードをコンパイルして、filter という拡張モジュールにリンクするには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="051a76f1d3dcebdcceb5b6a498f248ede74e08da" translate="yes" xml:space="preserve">
          <source>This code has a significant amount of error handling. Note the &lt;code&gt;SWIG_fail&lt;/code&gt; is a macro for &lt;code&gt;goto fail&lt;/code&gt;, referring to the label at line 28. If the user provides the wrong number of arguments, this will be caught at line 10. If construction of the NumPy array fails or produces an array with the wrong number of dimensions, these errors are caught at line 17. And finally, if an error is detected, memory is still managed correctly at line 30.</source>
          <target state="translated">このコードには、大量のエラー処理があります。注意 &lt;code&gt;SWIG_fail&lt;/code&gt; がためのマクロです &lt;code&gt;goto fail&lt;/code&gt; numpyの配列の構築が間違ったの配列を失敗したか、生成された場合、ユーザーが間違った数の引数を提供している場合はライン28でラベルを参照し、これはライン10で捕捉されます次元数の場合、これらのエラーは17行目でキャッチされます。最後に、エラーが検出された場合でも、メモリは30行目で正しく管理されています。</target>
        </trans-unit>
        <trans-unit id="3999b914a2658c99b5fe639f3ab379867f2570ac" translate="yes" xml:space="preserve">
          <source>This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment and goals. Please try to follow this code in spirit as much as in letter, to create a friendly and productive environment that enriches the surrounding community.</source>
          <target state="translated">このコードは完全なものではありませんし、完全なものでもありません。これは、協調的で共有された環境と目標に関する私たちの共通の理解を深めるためのものです。周囲のコミュニティを豊かにする友好的で生産的な環境を作るために、文字と同じくらい精神的にこのコードに従うようにしてください。</target>
        </trans-unit>
        <trans-unit id="dc2f712a7c05e996ac3e38345d45b7f3d7e23038" translate="yes" xml:space="preserve">
          <source>This code loads the shared library named &lt;code&gt;code.{ext}&lt;/code&gt; located in the same path as this file. It then adds a return type of void to the functions contained in the library. It also adds argument checking to the functions in the library so that ndarrays can be passed as the first three arguments along with an integer (large enough to hold a pointer on the platform) as the fourth argument.</source>
          <target state="translated">このコードは、このファイルと同じパスにある &lt;code&gt;code.{ext}&lt;/code&gt; という名前の共有ライブラリをロードします。次に、ライブラリに含まれている関数に戻り値の型のvoidを追加します。また、ライブラリ内の関数に引数チェックを追加して、ndarraysを最初の3つの引数として渡し、4番目の引数として整数（プラットフォーム上でポインターを保持するのに十分な大きさ）を渡すことができるようにします。</target>
        </trans-unit>
        <trans-unit id="533c867c6a351c2be81a48161bc93203ea12c76d" translate="yes" xml:space="preserve">
          <source>This code of conduct applies to all spaces managed by the NumPy project, including all public and private mailing lists, issue trackers, wikis, blogs, Twitter, and any other communication channel used by our community. The NumPy project does not organise in-person events, however events related to our community should have a code of conduct similar in spirit to this one.</source>
          <target state="translated">この行動規範は、NumPyプロジェクトが管理する全てのスペースに適用され、全ての公開・非公開のメーリングリスト、課題追跡、Wiki、ブログ、Twitter、そしてコミュニティが使用するその他のコミュニケーション・チャンネルを含む。NumPyプロジェクトは対面でのイベントを開催しませんが、コミュニティに関連したイベントには、この行動規範と同様の精神で行動する必要があります。</target>
        </trans-unit>
        <trans-unit id="cff208b4a7eacc934c607e5c41003491618977d7" translate="yes" xml:space="preserve">
          <source>This code of conduct should be honored by everyone who participates in the NumPy community formally or informally, or claims any affiliation with the project, in any project-related activities and especially when representing the project, in any role.</source>
          <target state="translated">この行動規範は、正式または非公式にNumPyコミュニティに参加している人、プロジェクト関連の活動に参加している人、特にプロジェクトを代表している人は、どのような役割であっても尊重されるべきです。</target>
        </trans-unit>
        <trans-unit id="0f194434e38b3846c0fd28dc955d7908e8501694" translate="yes" xml:space="preserve">
          <source>This command builds (see &lt;code&gt;-c&lt;/code&gt; flag, execute &lt;code&gt;python -m numpy.f2py&lt;/code&gt; without arguments to see the explanation of command line options) an extension module &lt;code&gt;fib1.so&lt;/code&gt; (see &lt;code&gt;-m&lt;/code&gt; flag) to the current directory. Now, in Python the Fortran subroutine &lt;code&gt;FIB&lt;/code&gt; is accessible via &lt;code&gt;fib1.fib&lt;/code&gt;:</source>
          <target state="translated">このコマンドは、拡張モジュール &lt;code&gt;fib1.so&lt;/code&gt; （ &lt;code&gt;-m&lt;/code&gt; フラグを参照）を現在のディレクトリにビルドします（ &lt;code&gt;-c&lt;/code&gt; フラグを参照、引数なしで &lt;code&gt;python -m numpy.f2py&lt;/code&gt; を実行してコマンドラインオプションの説明を参照）。現在、Pythonでは、Fortranサブルーチン &lt;code&gt;FIB&lt;/code&gt; に &lt;code&gt;fib1.fib&lt;/code&gt; からアクセスできます。</target>
        </trans-unit>
        <trans-unit id="ac9bee6274aa8d66ef375e679babd25ee76812a2" translate="yes" xml:space="preserve">
          <source>This command leaves a file named add.{ext} in the current directory (where {ext} is the appropriate extension for a Python extension module on your platform &amp;mdash; so, pyd, &lt;em&gt;etc.&lt;/em&gt; ). This module may then be imported from Python. It will contain a method for each subroutine in add (zadd, cadd, dadd, sadd). The docstring of each method contains information about how the module method may be called:</source>
          <target state="translated">このコマンドは、現在のディレクトリにadd。{ext}という名前のファイルを残します（{ext}は、プラットフォーム上のPython拡張モジュールの適切な拡張子です。つまり、pyd&lt;em&gt;など&lt;/em&gt;）。このモジュールは、Pythonからインポートできます。add（zadd、cadd、dadd、sadd）の各サブルーチンのメソッドが含まれます。各メソッドのdocstringには、モジュールメソッドの呼び出し方法に関する情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="bbb1615a9d0e074d0b52d81da555b5659d5320b3" translate="yes" xml:space="preserve">
          <source>This command leaves a file named add.{ext} in the current directory (where {ext} is the appropriate extension for a python extension module on your platform &amp;mdash; so, pyd, &lt;em&gt;etc.&lt;/em&gt; ). This module may then be imported from Python. It will contain a method for each subroutine in add (zadd, cadd, dadd, sadd). The docstring of each method contains information about how the module method may be called:</source>
          <target state="translated">このコマンドは、現在のディレクトリにadd。{ext}という名前のファイルを残します（{ext}は、プラットフォーム上のpython拡張モジュールの適切な拡張子です。つまり、pyd&lt;em&gt;など&lt;/em&gt;）。このモジュールは、Pythonからインポートできます。 add（zadd、cadd、dadd、sadd）の各サブルーチンのメソッドが含まれます。各メソッドのdocstringには、モジュールメソッドの呼び出し方法に関する情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="b8208674ec726acd6f311802a0a4f9952791f4b6" translate="yes" xml:space="preserve">
          <source>This command leaves the file add.pyf in the current directory. The section of this file corresponding to zadd is:</source>
          <target state="translated">このコマンドは、add.pyfファイルをカレントディレクトリに残します。このファイルのzaddに対応する部分は</target>
        </trans-unit>
        <trans-unit id="4e0a485b84958d1031e7018c2536aa8e72a66489" translate="yes" xml:space="preserve">
          <source>This condition is broadcast over the input. At locations where the condition is True, the &lt;code&gt;out&lt;/code&gt; array will be set to the ufunc result. Elsewhere, the &lt;code&gt;out&lt;/code&gt; array will retain its original value. Note that if an uninitialized &lt;code&gt;out&lt;/code&gt; array is created via the default &lt;code&gt;out=None&lt;/code&gt;, locations within it where the condition is False will remain uninitialized.</source>
          <target state="translated">この状態は入力を介してブロードキャストされます。条件がTrueである場所では、 &lt;code&gt;out&lt;/code&gt; 配列はufuncの結果に設定されます。それ以外の場合、 &lt;code&gt;out&lt;/code&gt; 配列は元の値を保持します。初期化さ &lt;code&gt;out&lt;/code&gt; ていないout配列がデフォルトの &lt;code&gt;out=None&lt;/code&gt; で作成された場合、条件がFalseである配列内の場所は初期化されないままになることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ee4c6c49dffb551e0984368af8f98c122bd3ccfb" translate="yes" xml:space="preserve">
          <source>This constructor can be compared to &lt;code&gt;empty&lt;/code&gt;: it creates a new record array but does not fill it with data. To create a record array from data, use one of the following methods:</source>
          <target state="translated">このコンストラクタは &lt;code&gt;empty&lt;/code&gt; と比較できます。新しいレコード配列を作成しますが、データを入れません。データからレコード配列を作成するには、次のいずれかの方法を使用します。</target>
        </trans-unit>
        <trans-unit id="33c942d2092f2a81aa60d19a082d10077f5b892d" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='Fortran'&lt;/code&gt;, in which case &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="translated">このコンストラクタは、 &lt;code&gt;None&lt;/code&gt; でない場合は、 &lt;code&gt;buffer&lt;/code&gt; （ &lt;code&gt;offset&lt;/code&gt; と&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;）を使用して配列を作成します。場合 &lt;code&gt;buffer&lt;/code&gt; ありません &lt;code&gt;None&lt;/code&gt; 、その後で新しいアレイ構築&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;、両方のない限り、「C順序」に &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; 及び &lt;code&gt;order='Fortran'&lt;/code&gt; でケース、&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;「Fortranの順序」です。</target>
        </trans-unit>
        <trans-unit id="953bdd8047346bccedc501390c7ed7305dc6711a" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='F'&lt;/code&gt;, in which case &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="translated">このコンストラクターは、 &lt;code&gt;None&lt;/code&gt; でない場合、 &lt;code&gt;buffer&lt;/code&gt; （ &lt;code&gt;offset&lt;/code&gt; と&lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;）を使用して配列を作成します。場合 &lt;code&gt;buffer&lt;/code&gt; ありません &lt;code&gt;None&lt;/code&gt; 、その後で新しいアレイ構築&lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;、両方のない限り、「C順序」に &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; 及び &lt;code&gt;order='F'&lt;/code&gt; でケース、&lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;「Fortranの順序」です。</target>
        </trans-unit>
        <trans-unit id="244906121f35fcb6808baef572df1faf5ecac2b9" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='Fortran'&lt;/code&gt;, in which case &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="translated">このコンストラクタは、 &lt;code&gt;None&lt;/code&gt; でない場合は、 &lt;code&gt;buffer&lt;/code&gt; （ &lt;code&gt;offset&lt;/code&gt; と&lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;）を使用して配列を作成します。場合 &lt;code&gt;buffer&lt;/code&gt; ありません &lt;code&gt;None&lt;/code&gt; 、その後で新しいアレイ構築&lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;、両方のない限り、「C順序」に &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; 及び &lt;code&gt;order='Fortran'&lt;/code&gt; でケース、&lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;「Fortranの順序」です。</target>
        </trans-unit>
        <trans-unit id="472735a82ef7af1ec4165da8f5b7c128444159de" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='F'&lt;/code&gt;, in which case &lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="translated">このコンストラクターは、 &lt;code&gt;None&lt;/code&gt; でない場合、 &lt;code&gt;buffer&lt;/code&gt; （ &lt;code&gt;offset&lt;/code&gt; と&lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;）を使用して配列を作成します。場合 &lt;code&gt;buffer&lt;/code&gt; ありません &lt;code&gt;None&lt;/code&gt; 、その後で新しいアレイ構築&lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;、両方のない限り、「C順序」に &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; 及び &lt;code&gt;order='F'&lt;/code&gt; でケース、&lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;「Fortranの順序」です。</target>
        </trans-unit>
        <trans-unit id="25eee032d6ea1636789f057c08bed3526280036b" translate="yes" xml:space="preserve">
          <source>This could then be registered to convert doubles to floats using the code:</source>
          <target state="translated">これを登録して、コードを使用してダブルスをフロートに変換することができます。</target>
        </trans-unit>
        <trans-unit id="a5986918bf935c1ed16d4421ab17b1ade1eafe40" translate="yes" xml:space="preserve">
          <source>This declares that the corresponding argument depends on the values of variables in the list &lt;code&gt;&amp;lt;names&amp;gt;&lt;/code&gt;. For example, &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; may use the values of other arguments. Using information given by &lt;code&gt;depend(..)&lt;/code&gt; attributes, F2PY ensures that arguments are initialized in a proper order. If &lt;code&gt;depend(..)&lt;/code&gt; attribute is not used then F2PY determines dependence relations automatically. Use &lt;code&gt;depend()&lt;/code&gt; to disable dependence relations generated by F2PY.</source>
          <target state="translated">これは、対応する引数がリスト &lt;code&gt;&amp;lt;names&amp;gt;&lt;/code&gt; 内の変数の値に依存することを宣言します。たとえば、 &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; は他の引数の値を使用する場合があります。F2PYは、 &lt;code&gt;depend(..)&lt;/code&gt; 属性によって指定された情報を使用して、引数が適切な順序で初期化されるようにします。場合 &lt;code&gt;depend(..)&lt;/code&gt; 属性はF2PYが自動的に依存関係を決定し、その後使用されていません。F2PYによって生成された依存関係を無効にするには、 &lt;code&gt;depend()&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="c221f7f1dff9c4b5017181532f28da44b16fcb82" translate="yes" xml:space="preserve">
          <source>This decorator can be used to filter DeprecationWarning&amp;rsquo;s, to avoid printing them during the test suite run, while checking that the test actually raises a DeprecationWarning.</source>
          <target state="translated">このデコレータを使用してDeprecationWarningをフィルタリングし、テストが実際にDeprecationWarningを発生させていることを確認しながら、テストスイートの実行中にそれらを出力しないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="50d52a319d15baa1479e649a743cee7e5d09023b" translate="yes" xml:space="preserve">
          <source>This decorator can&amp;rsquo;t use the nose namespace, because it can be called from a non-test module. See also &lt;code&gt;istest&lt;/code&gt; and &lt;code&gt;nottest&lt;/code&gt; in &lt;code&gt;nose.tools&lt;/code&gt;.</source>
          <target state="translated">このデコレータは、非テストモジュールから呼び出すことができるため、nose名前空間を使用できません。参照してください &lt;code&gt;istest&lt;/code&gt; と &lt;code&gt;nottest&lt;/code&gt; で &lt;code&gt;nose.tools&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67fd7e1d7456c74a698475b7f144fadff01137fb" translate="yes" xml:space="preserve">
          <source>This default iterator selects a sub-array of dimension</source>
          <target state="translated">このデフォルトのイテレータは,次元の部分配列を選択します.</target>
        </trans-unit>
        <trans-unit id="cfb9c1da992a1d1aaddfb397e6c91ff1039b17da" translate="yes" xml:space="preserve">
          <source>This default threshold is designed to detect rank deficiency accounting for the numerical errors of the SVD computation. Imagine that there is a column in &lt;code&gt;M&lt;/code&gt; that is an exact (in floating point) linear combination of other columns in &lt;code&gt;M&lt;/code&gt;. Computing the SVD on &lt;code&gt;M&lt;/code&gt; will not produce a singular value exactly equal to 0 in general: any difference of the smallest SVD value from 0 will be caused by numerical imprecision in the calculation of the SVD. Our threshold for small SVD values takes this numerical imprecision into account, and the default threshold will detect such numerical rank deficiency. The threshold may declare a matrix &lt;code&gt;M&lt;/code&gt; rank deficient even if the linear combination of some columns of &lt;code&gt;M&lt;/code&gt; is not exactly equal to another column of &lt;code&gt;M&lt;/code&gt; but only numerically very close to another column of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">このデフォルトのしきい値は、SVD計算の数値エラーを説明するランクの不足を検出するように設計されています。列があることを想像する &lt;code&gt;M&lt;/code&gt; における他の列の（浮動小数点）で正確な線形組み合わせである &lt;code&gt;M&lt;/code&gt; は。 &lt;code&gt;M&lt;/code&gt; で SVDを計算しても、一般に正確に0に等しい特異値は生成されません。最小のSVD値と0との差は、SVDの計算における数値の不正確さが原因です。小さなSVD値のしきい値は、この数値の不正確さを考慮に入れており、デフォルトのしきい値は、このような数値ランクの不足を検出します。マトリックス宣言することができる閾値 &lt;code&gt;M&lt;/code&gt; のランクが不足場合でも、一部の列の線形結合 &lt;code&gt;M&lt;/code&gt; 丁度の別の列に等しくない &lt;code&gt;M&lt;/code&gt; 非常に近くの別の列にのみ数値が、 &lt;code&gt;M&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0285819f9fc91ea6c1e91e579241c01b00956ba" translate="yes" xml:space="preserve">
          <source>This design was retracted almost immediately after it was proposed, in &amp;lt;&lt;a href=&quot;https://mail.python.org/pipermail/numpy-discussion/2006-June/020995.html&quot;&gt;https://mail.python.org/pipermail/numpy-discussion/2006-June/020995.html&lt;/a&gt;&amp;gt;. Despite 14 years of documentation to the contrary, at no point was it valid to assume that &lt;code&gt;__array_interface__&lt;/code&gt; capsules held this tuple content.</source>
          <target state="translated">このデザインは、&amp;lt; &lt;a href=&quot;https://mail.python.org/pipermail/numpy-discussion/2006-June/020995.html&quot;&gt;https://mail.python.org/pipermail/numpy-discussion/2006-June/020995.html&lt;/a&gt; &amp;gt;で提案された直後に撤回されました。それとは反対に14年間の文書化にもかかわらず、 &lt;code&gt;__array_interface__&lt;/code&gt; カプセルがこのタプルコンテンツを保持していると仮定することはどの時点でも有効ではありませんでした。</target>
        </trans-unit>
        <trans-unit id="b6968499a16ad7614bdea90ae8f3aad570e0c60e" translate="yes" xml:space="preserve">
          <source>This document describes the syntax and best practices for docstrings used with the numpydoc extension for &lt;a href=&quot;http://sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt;.</source>
          <target state="translated">このドキュメントでは、&lt;a href=&quot;http://sphinx-doc.org/&quot;&gt;Sphinxの&lt;/a&gt;numpydoc拡張機能で使用されるdocstringの構文とベストプラクティスについて説明します。</target>
        </trans-unit>
        <trans-unit id="b45b65ecc52b644a63152b28ad1bde6a3a5e1f70" translate="yes" xml:space="preserve">
          <source>This document gives coding conventions for the C code comprising the C implementation of NumPy. Note, rules are there to be broken. Two good reasons to break a particular rule:</source>
          <target state="translated">このドキュメントでは、NumPyのC実装を構成するCコードのコーディング規約を示します。注意:ルールは破るためのものである。特定のルールを破るには2つの理由がある。</target>
        </trans-unit>
        <trans-unit id="8c3b557b3201940ffcbe7e57b7ac3945729bb630" translate="yes" xml:space="preserve">
          <source>This document itself was written in ReStructuredText. &lt;a href=&quot;#example&quot;&gt;An example&lt;/a&gt; of the format shown here is available.</source>
          <target state="translated">このドキュメント自体はReStructuredTextで書かれています。ここに示されているフォーマット&lt;a href=&quot;#example&quot;&gt;の例&lt;/a&gt;が利用可能です。</target>
        </trans-unit>
        <trans-unit id="2007e99c49141c98bee8b2f4b8b703b1ff66930c" translate="yes" xml:space="preserve">
          <source>This does not compute the usual correlation: if op2 is larger than op1, the arguments are swapped, and the conjugate is never taken for complex arrays. See PyArray_Correlate2 for the usual signal processing correlation.</source>
          <target state="translated">これは通常の相関を計算しません:op2 が op1 よりも大きい場合、引数はスワップされ、複素数配列の場合は共役が取られることはありません。通常の信号処理の相関については PyArray_Correlate2 を参照してください。</target>
        </trans-unit>
        <trans-unit id="2ac0e7432126a7d32cb5b22ed347524b29026575" translate="yes" xml:space="preserve">
          <source>This enables the iterator to reason about data dependency, possibly avoiding unnecessary copies.</source>
          <target state="translated">これにより、イテレータがデータの依存性を推論し、不要なコピーを回避することができます。</target>
        </trans-unit>
        <trans-unit id="fb73eae3981c0a0cbcb09d6d3ccfc761b4660a9a" translate="yes" xml:space="preserve">
          <source>This example makes use of Python 3 &lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt;&lt;code&gt;concurrent.futures&lt;/code&gt;&lt;/a&gt; to fill an array using multiple threads. Threads are long-lived so that repeated calls do not require any additional overheads from thread creation.</source>
          <target state="translated">この例では、Python 3の&lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt; &lt;code&gt;concurrent.futures&lt;/code&gt; &lt;/a&gt;を使用して、複数のスレッドを使用して配列を埋めます。スレッドは存続期間が長いため、呼び出しを繰り返すと、スレッドの作成による追加のオーバーヘッドは必要ありません。</target>
        </trans-unit>
        <trans-unit id="ff3d50ffaaf1fbc724fd92676a9a6bf2dd386440" translate="yes" xml:space="preserve">
          <source>This example makes use of Python 3 &lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt;&lt;code&gt;concurrent.futures&lt;/code&gt;&lt;/a&gt; to fill an array using multiple threads. Threads are long-lived so that repeated calls do not require any additional overheads from thread creation. The underlying BitGenerator is &lt;code&gt;PCG64&lt;/code&gt; which is fast, has a long period and supports using &lt;code&gt;PCG64.jumped&lt;/code&gt; to return a new generator while advancing the state. The random numbers generated are reproducible in the sense that the same seed will produce the same outputs.</source>
          <target state="translated">この例では、Python 3の&lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt; &lt;code&gt;concurrent.futures&lt;/code&gt; &lt;/a&gt;を使用して、複数のスレッドを使用して配列を埋めています。スレッドは存続期間が長いので、呼び出しを繰り返しても、スレッドの作成による追加のオーバーヘッドは必要ありません。基礎となるBitGeneratorは &lt;code&gt;PCG64&lt;/code&gt; であり、高速で、期間が長く、 &lt;code&gt;PCG64.jumped&lt;/code&gt; を使用して、状態を進めながら新しいジェネレーターを返すことができます。生成された乱数は、同じシードが同じ出力を生成するという意味で再現可能です。</target>
        </trans-unit>
        <trans-unit id="40004ca036e22114daf23d8e12216a484254a12b" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;converters&lt;/code&gt; can be used to convert a field with a trailing minus sign into a negative number.</source>
          <target state="translated">この例は、 &lt;code&gt;converters&lt;/code&gt; を使用して、末尾にマイナス記号が付いているフィールドを負の数に変換する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="b788d751d6a8b5a6ea3f2e12485a26037e6ed998" translate="yes" xml:space="preserve">
          <source>This example shows how numba can be used to produce Box-Muller normals using a pure Python implementation which is then compiled. The random numbers are provided by &lt;code&gt;ctypes.next_double&lt;/code&gt;.</source>
          <target state="translated">この例は、numbaを使用して、コンパイルされた純粋なPython実装を使用してBox-Muller法線を生成する方法を示しています。乱数は &lt;code&gt;ctypes.next_double&lt;/code&gt; によって提供されます。</target>
        </trans-unit>
        <trans-unit id="c43d650067bf3f7811ad3426eb67449ba8f8d778" translate="yes" xml:space="preserve">
          <source>This example shows how numba can be used to produce gaussian samples using a pure Python implementation which is then compiled. The random numbers are provided by &lt;code&gt;ctypes.next_double&lt;/code&gt;.</source>
          <target state="translated">この例は、numbaを使用して、純粋なPython実装を使用してガウスサンプルを生成し、それをコンパイルする方法を示しています。乱数は &lt;code&gt;ctypes.next_double&lt;/code&gt; によって提供されます。</target>
        </trans-unit>
        <trans-unit id="21f8a7f3cdbbf2fa9d3bdab5400251540901f919" translate="yes" xml:space="preserve">
          <source>This example shows how to create a ufunc for a structured array dtype. For the example we show a trivial ufunc for adding two arrays with dtype &amp;lsquo;u8,u8,u8&amp;rsquo;. The process is a bit different from the other examples since a call to &lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_FromFuncAndData&quot;&gt;&lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t fully register ufuncs for custom dtypes and structured array dtypes. We need to also call &lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_RegisterLoopForDescr&quot;&gt;&lt;code&gt;PyUFunc_RegisterLoopForDescr&lt;/code&gt;&lt;/a&gt; to finish setting up the ufunc.</source>
          <target state="translated">この例は、構造化配列dtypeのufuncを作成する方法を示しています。この例では、dtypeが「u8、u8、u8」の2つの配列を追加するための簡単なufuncを示しています。呼び出しのためのプロセスは、他の例と少し異なって&lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_FromFuncAndData&quot;&gt; &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; が&lt;/a&gt;完全にカスタムdtypesと構造アレイdtypesためufuncsを登録しません。&lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_RegisterLoopForDescr&quot;&gt; &lt;code&gt;PyUFunc_RegisterLoopForDescr&lt;/code&gt; &lt;/a&gt;設定を完了するには、PyUFunc_RegisterLoopF​​orDescrも呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="2f7280fcf983a91daf5dc16e89c6643dc47e38c1" translate="yes" xml:space="preserve">
          <source>This example shows that a negative value can be returned when the input is an array of signed integers.</source>
          <target state="translated">この例は、入力が符号付き整数の配列である場合に負の値を返すことができることを示しています。</target>
        </trans-unit>
        <trans-unit id="15659709a5e32bf1f77ae2078941bf91dc0f1586" translate="yes" xml:space="preserve">
          <source>This example uses a temporary file so that doctest doesn&amp;rsquo;t write files to your directory. You would use a &amp;lsquo;normal&amp;rsquo; filename.</source>
          <target state="translated">この例では、doctestがディレクトリにファイルを書き込まないように、一時ファイルを使用しています。「通常の」ファイル名を使用します。</target>
        </trans-unit>
        <trans-unit id="c6a6109259025b3790be906b9d5fd08b4a7ddd22" translate="yes" xml:space="preserve">
          <source>This explanation of &lt;code&gt;fmt&lt;/code&gt; is not complete, for an exhaustive specification see &lt;a href=&quot;#r672d4d5b6143-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;.</source>
          <target state="translated">この &lt;code&gt;fmt&lt;/code&gt; の説明は完全ではありません。詳細な仕様については、&lt;a href=&quot;#r672d4d5b6143-1&quot; id=&quot;id1&quot;&gt;[1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c6f060f066c80d886f242a9ad00dc6b69ec16949" translate="yes" xml:space="preserve">
          <source>This feature lets you make local decisions about when and how to split up streams without coordination between processes. You do not have to preallocate space to avoid overlapping or request streams from a common global service. This general &amp;ldquo;tree-hashing&amp;rdquo; scheme is &lt;a href=&quot;https://www.iro.umontreal.ca/~lecuyer/myftp/papers/parallel-rng-imacs.pdf&quot;&gt;not unique to numpy&lt;/a&gt; but not yet widespread. Python has increasingly-flexible mechanisms for parallelization available, and this scheme fits in very well with that kind of use.</source>
          <target state="translated">この機能を使用すると、プロセス間で調整することなく、いつ、どのようにストリームを分割するかをローカルで決定できます。重複を回避したり、共通のグローバルサービスからのストリームを要求したりするために、領域を事前に割り当てる必要はありません。この一般的な「ツリーハッシュ」スキームは&lt;a href=&quot;https://www.iro.umontreal.ca/~lecuyer/myftp/papers/parallel-rng-imacs.pdf&quot;&gt;、numpyに固有のもので&lt;/a&gt;はありませんが、まだ普及していません。Pythonは、利用可能な並列化のためのますます柔軟なメカニズムを備えており、このスキームはそのような使用法に非常によく適合します。</target>
        </trans-unit>
        <trans-unit id="1eaab0e05e888941195d61599512548e7a521f9d" translate="yes" xml:space="preserve">
          <source>This file contains a walkthrough of the NumPy 1.14.5 release on Linux, modified for building on azure and uploading to anaconda.org The commands can be copied into the command line, but be sure to replace 1.14.5 by the correct version.</source>
          <target state="translated">このファイルには、Linux での NumPy 1.14.5 リリースのウォークスルーが含まれており、azure でのビルドと anaconda.org へのアップロード用に修正されています。</target>
        </trans-unit>
        <trans-unit id="ce7f900d77aa58f2ad5d408dd151ca95c6ec2123" translate="yes" xml:space="preserve">
          <source>This file contains a walkthrough of the NumPy 1.19.0 release on Linux, modified for building on azure and uploading to anaconda.org The commands can be copied into the command line, but be sure to replace 1.19.0 by the correct version.</source>
          <target state="translated">このファイルには、Linux での NumPy 1.19.0 リリースのウォークスルーが含まれており、azure でのビルドと anaconda.org へのアップロードのために修正されています。</target>
        </trans-unit>
        <trans-unit id="bbd2bf0596d8530c916e2a9e88d889eff818ebc6" translate="yes" xml:space="preserve">
          <source>This file gives an overview of what is necessary to build binary releases for NumPy.</source>
          <target state="translated">このファイルでは、NumPy用のバイナリリリースをビルドするために必要なものの概要を説明します。</target>
        </trans-unit>
        <trans-unit id="482a4249cfca9480f9fad090626bdeb4f2b9945b" translate="yes" xml:space="preserve">
          <source>This file is installed to the package installation directory.</source>
          <target state="translated">このファイルは、パッケージのインストールディレクトリにインストールされます。</target>
        </trans-unit>
        <trans-unit id="53df6470e0b1cc077e937e47a1974181b9abe4c8" translate="yes" xml:space="preserve">
          <source>This flag can only be used with &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; when &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt; is enabled. This is because without buffering, the inner loop is always the size of the innermost iteration dimension, and allowing it to get cut up would require special handling, effectively making it more like the buffered version.</source>
          <target state="translated">このフラグはのみで使用することができます&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;とき&lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; が&lt;/a&gt;有効になっています。これは、バッファリングを行わない場合、内部ループは常に最も内側の反復次元のサイズであり、それを切り取ることを許可するには特別な処理が必要になるため、事実上バッファバージョンに似たものになるためです。</target>
        </trans-unit>
        <trans-unit id="b15ae805eec5e668ba73f9b0b01c1bc16e63444d" translate="yes" xml:space="preserve">
          <source>This flag has effect only if &lt;code&gt;NPY_ITER_COPY_IF_OVERLAP&lt;/code&gt; is enabled on the iterator.</source>
          <target state="translated">このフラグは、 &lt;code&gt;NPY_ITER_COPY_IF_OVERLAP&lt;/code&gt; がイテレーターで有効になっている場合にのみ有効です。</target>
        </trans-unit>
        <trans-unit id="9da2bfdfbda0e7663b5a969172c32a000741b205" translate="yes" xml:space="preserve">
          <source>This flag is incompatible with &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このフラグは、&lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; &lt;/a&gt;と互換性がありません。</target>
        </trans-unit>
        <trans-unit id="f18364f6e6e63625675c7a8e617237459cb62263" translate="yes" xml:space="preserve">
          <source>This flag is true if the underlying array is &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;. It is used to simplify calculations when possible.</source>
          <target state="translated">このフラグは、基になる配列が&lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; の&lt;/a&gt;場合に真になります。可能な場合は計算を簡略化するために使用されます。</target>
        </trans-unit>
        <trans-unit id="dded0adeb2bd9373f814af71190afe223e5d417b" translate="yes" xml:space="preserve">
          <source>This flag is true if the underlying array is &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;. It is used to simplify calculations when possible.</source>
          <target state="translated">基本となる配列が&lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; の&lt;/a&gt;場合、このフラグはtrueです。可能な場合は、計算を簡略化するために使用されます。</target>
        </trans-unit>
        <trans-unit id="8bd5458653c4b0d4b9801dcf72f3813b331fc2dd" translate="yes" xml:space="preserve">
          <source>This flag is useful for arrays that must be in C-contiguous order and aligned. These kinds of arrays are usually input arrays for some algorithm.</source>
          <target state="translated">このフラグは,C-連続した順序で整列されていなければならない配列に対して有用です.この種の配列は,通常,何らかのアルゴリズムの入力配列です.</target>
        </trans-unit>
        <trans-unit id="174700adc5b2ef69a266d85c159fde8b55bae281" translate="yes" xml:space="preserve">
          <source>This flag is useful to specify an array that is in C-contiguous order, is aligned, and can be written to as well. Such an array is usually returned as output (although normally such output arrays are created from scratch).</source>
          <target state="translated">このフラグは,C-連続した順序で配列され,整列されていて,書き込みも可能な配列を指定するのに便利です.このような配列は,通常は出力として返されます(通常,このような出力配列はスクラッチから作成されますが).</target>
        </trans-unit>
        <trans-unit id="5677601b0eb842974f94991fa89b82f29f0accae" translate="yes" xml:space="preserve">
          <source>This flag is useful to specify an array that will be used for both input and output. &lt;a href=&quot;../reference/c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; must be called before &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt;&lt;code&gt;Py_DECREF&lt;/code&gt;&lt;/a&gt; at the end of the interface routine to write back the temporary data into the original array passed in. Use of the &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags requires that the input object is already an array (because other objects cannot be automatically updated in this fashion). If an error occurs use &lt;a href=&quot;../reference/c-api/array#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt; (obj) on an array with these flags set. This will set the underlying base array writable without causing the contents to be copied back into the original array.</source>
          <target state="translated">このフラグは、入力と出力の両方に使用される配列を指定するのに役立ちます。&lt;a href=&quot;../reference/c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;れた元の配列に一時データを書き戻すには、インターフェイスルーチンの最後で&lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt; &lt;code&gt;Py_DECREF&lt;/code&gt; の&lt;/a&gt;前にPyArray_ResolveWritebackIfCopyを呼び出す必要があります&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;フラグを使用するには、入力オブジェクトがすでに配列である必要があります（他のオブジェクトは自動的に更新できないため）このように）。エラーが発生した場合は、これらのフラグが設定された配列で&lt;a href=&quot;../reference/c-api/array#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt;（obj）を使用してください。これにより、コンテンツが元の配列にコピーされて戻されることなく、基になる基本配列が書き込み可能に設定されます。</target>
        </trans-unit>
        <trans-unit id="e07be9168d02cb1629420a221f75d6ebada0e23c" translate="yes" xml:space="preserve">
          <source>This flag only affects writing from the buffer back to the array. This means that if the operand is also &lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt;&lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt;&lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt;&lt;/a&gt;, code doing iteration can write to this operand to control which elements will be untouched and which ones will be modified. This is useful when the mask should be a combination of input masks.</source>
          <target state="translated">このフラグは、バッファから配列への書き込みにのみ影響します。これは、オペランドも&lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt; &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt; &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; &lt;/a&gt;である場合、反復を実行するコードがこのオペランドに書き込み、変更されない要素と変更されない要素を制御できることを意味します。これは、マスクを定型入力の組み合わせにする必要がある場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="61e9f59feb262d0f073bfa393f7c68aa5599a46b" translate="yes" xml:space="preserve">
          <source>This form also makes it possible to specify struct dtypes with overlapping fields, functioning like the &amp;lsquo;union&amp;rsquo; type in C. This usage is discouraged, however, and the union mechanism is preferred.</source>
          <target state="translated">この形式では、Cの「union」タイプのように機能する、フィールドが重複するstruct dtypeを指定することもできます。ただし、この使用はお勧めできませんが、unionメカニズムが推奨されます。</target>
        </trans-unit>
        <trans-unit id="0d302c80ebc9e23237f250ea17213abaf97a46db" translate="yes" xml:space="preserve">
          <source>This form is discouraged because Python dictionaries do not preserve order in Python versions before Python 3.6, and the order of the fields in a structured dtype has meaning. &lt;a href=&quot;#titles&quot;&gt;Field Titles&lt;/a&gt; may be specified by using a 3-tuple, see below.</source>
          <target state="translated">PythonディクショナリはPython3.6より前のバージョンのPythonでは順序を保持せず、構造化dtypeのフィールドの順序には意味があるため、この形式は推奨されません。&lt;a href=&quot;#titles&quot;&gt;フィールドタイトル&lt;/a&gt;は、3タプルを使用して指定できます。以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="eee7324318b68cf58364fb2712f6b7aa7bb3937e" translate="yes" xml:space="preserve">
          <source>This forms part of the old polynomial API. Since version 1.4, the new polynomial API defined in &lt;a href=&quot;../routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt; is preferred. A summary of the differences can be found in the &lt;a href=&quot;../routines.polynomials&quot;&gt;transition guide&lt;/a&gt;.</source>
          <target state="translated">これは、古い多項式APIの一部を形成します。バージョン1.4以降、&lt;a href=&quot;../routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt;で定義された新しい多項式APIが優先されます。違いの概要は、&lt;a href=&quot;../routines.polynomials&quot;&gt;移行ガイドに&lt;/a&gt;記載されています。</target>
        </trans-unit>
        <trans-unit id="55ceb45713d06ac7d3696f87a18d50201d0b6641" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;steals a reference&lt;/strong&gt; to &lt;code&gt;obj&lt;/code&gt; and sets it as the base property of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">この関数は&lt;strong&gt;、&lt;/strong&gt; &lt;code&gt;obj&lt;/code&gt; へ&lt;strong&gt;の参照&lt;/strong&gt;を&lt;strong&gt;盗み、&lt;/strong&gt;それを &lt;code&gt;arr&lt;/code&gt; の基本プロパティとして設定します。</target>
        </trans-unit>
        <trans-unit id="d09c0732b811d51b99b90004b51ceb77de43b711" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;steals a reference&lt;/strong&gt; to &lt;code&gt;op&lt;/code&gt; and makes sure that &lt;code&gt;op&lt;/code&gt; is a base-class ndarray. It special cases array scalars, but otherwise calls &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;op&lt;/code&gt;, NULL, 0, 0, &lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt;&lt;/a&gt;, NULL).</source>
          <target state="translated">この関数は、&lt;strong&gt;参照盗み&lt;/strong&gt;に &lt;code&gt;op&lt;/code&gt; していることを確認します &lt;code&gt;op&lt;/code&gt; が基底クラスのndarrayです。配列スカラーは特別な場合ですが、それ以外の場合は&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;op&lt;/code&gt; 、NULL、0、0、&lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt; &lt;/a&gt;、NULL）を呼び出します。</target>
        </trans-unit>
        <trans-unit id="39a0c64e238756c013e69a01cf344f4e1849a8a1" translate="yes" xml:space="preserve">
          <source>This function accepts but discards arguments &lt;code&gt;bias&lt;/code&gt; and &lt;code&gt;ddof&lt;/code&gt;. This is for backwards compatibility with previous versions of this function. These arguments had no effect on the return values of the function and can be safely ignored in this and previous versions of numpy.</source>
          <target state="translated">この関数は、引数 &lt;code&gt;bias&lt;/code&gt; と &lt;code&gt;ddof&lt;/code&gt; を受け入れますが破棄します。これは、この関数の以前のバージョンとの下位互換性のためです。これらの引数は関数の戻り値に影響を与えなかったため、numpyのこのバージョンと以前のバージョンでは無視しても問題ありません。</target>
        </trans-unit>
        <trans-unit id="f2fa4598ed049a537ca6f0801826008a1fe6bde0" translate="yes" xml:space="preserve">
          <source>This function aims to be a fast reader for simply formatted files. The &lt;a href=&quot;numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; function provides more sophisticated handling of, e.g., lines with missing values.</source>
          <target state="translated">この関数は、単純にフォーマットされたファイルの高速リーダーを目指しています。&lt;a href=&quot;numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;機能は、より洗練されたの取り扱い、例えば、欠損値を持つ行を提供します。</target>
        </trans-unit>
        <trans-unit id="ff21c5d7fbe80ce59f5b300cd13fc6a4fc144e9d" translate="yes" xml:space="preserve">
          <source>This function allows one set of bins to be computed, and reused across multiple histograms:</source>
          <target state="translated">この関数は、1つのビンのセットを計算し、複数のヒストグラムに渡って再利用することができます。</target>
        </trans-unit>
        <trans-unit id="8a2a88415c2050cb4cd9564db4ec54b1d4908d16" translate="yes" xml:space="preserve">
          <source>This function allows the user to register a 1-d loop with an already- created ufunc to be used whenever the ufunc is called with any of its input arguments as the user-defined data-type. This is needed in order to make ufuncs work with built-in data-types. The data-type must have been previously registered with the numpy system. The loop is passed in as &lt;em&gt;function&lt;/em&gt;. This loop can take arbitrary data which should be passed in as &lt;em&gt;data&lt;/em&gt;. The data-types the loop requires are passed in as &lt;em&gt;arg_types&lt;/em&gt; which must be a pointer to memory at least as large as ufunc-&amp;gt;nargs.</source>
          <target state="translated">この関数を使用すると、ユーザーは、既に作成されたufuncを使用して1次元ループを登録し、ユーザー定義のデータ型として入力引数のいずれかを指定してufuncを呼び出すときに使用できます。これは、組み込みデータ型でufuncを機能させるために必要です。 data-typeは、numpyシステムに事前に登録されている必要があります。ループは&lt;em&gt;関数&lt;/em&gt;として渡され&lt;em&gt;ます&lt;/em&gt;。このループは、&lt;em&gt;data&lt;/em&gt;として渡される任意のデータを取ることができ&lt;em&gt;ます&lt;/em&gt;。ループが必要とするデータ型は、少なくともufunc-&amp;gt; nargsと同じ大きさのメモリへのポインタでなければならない&lt;em&gt;arg_types&lt;/em&gt;として渡されます。</target>
        </trans-unit>
        <trans-unit id="f1576babab462c2253d07a719792b0ff878bb525" translate="yes" xml:space="preserve">
          <source>This function allows you to alter the tp_str and tp_repr methods of the array object to any Python function. Thus you can alter what happens for all arrays when str(arr) or repr(arr) is called from Python. The function to be called is passed in as &lt;em&gt;op&lt;/em&gt;. If &lt;em&gt;repr&lt;/em&gt; is non-zero, then this function will be called in response to repr(arr), otherwise the function will be called in response to str(arr). No check on whether or not &lt;em&gt;op&lt;/em&gt; is callable is performed. The callable passed in to &lt;em&gt;op&lt;/em&gt; should expect an array argument and should return a string to be printed.</source>
          <target state="translated">この関数を使用すると、配列オブジェクトのtp_strメソッドとtp_reprメソッドを任意のPython関数に変更できます。したがって、Pythonからstr（arr）またはrepr（arr）が呼び出されたときに、すべての配列で何が起こるかを変更できます。呼び出される関数は&lt;em&gt;op&lt;/em&gt;として渡されます。場合&lt;em&gt;のreprが&lt;/em&gt;非ゼロであり、この関数は、そうでなければ関数はSTR（ARR）に応答して呼び出される、のrepr（ARR）に応答して呼び出されます。&lt;em&gt;op&lt;/em&gt;が呼び出し可能かどうかのチェックは行われません。&lt;em&gt;opに&lt;/em&gt;渡される呼び出し可能オブジェクトは、配列引数を予期し、出力される文字列を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="3bb2d31f5b88cf1b316b3ceb02135e04993b15e9" translate="yes" xml:space="preserve">
          <source>This function assigns from the old to the new array by name, so the value of a field in the output array is the value of the field with the same name in the source array. This has the effect of creating a new ndarray containing only the fields &amp;ldquo;required&amp;rdquo; by the required_dtype.</source>
          <target state="translated">この関数は、古い配列から新しい配列に名前で割り当てるため、出力配列のフィールドの値は、ソース配列の同じ名前のフィールドの値になります。これには、required_dtypeによって「required」されたフィールドのみを含む新しいndarrayを作成する効果があります。</target>
        </trans-unit>
        <trans-unit id="12c8f95658bf6b7edc09d3adda4d0c4816cea136" translate="yes" xml:space="preserve">
          <source>This function behaves like PyUFunc_RegisterLoopForType above, except that it allows the user to register a 1-d loop using PyArray_Descr objects instead of dtype type num values. This allows a 1-d loop to be registered for structured array data-dtypes and custom data-types instead of scalar data-types.</source>
          <target state="translated">この関数は上記の PyUFunc_RegisterLoopForType と同様の動作をしますが、dtype 型の num 値の代わりに PyArray_Descr オブジェクトを用いて 1-d ループを登録することができます。これにより、スカラーデータ型の代わりに構造化配列データ型やカスタムデータ型に対して1次元ループを登録することができます。</target>
        </trans-unit>
        <trans-unit id="e6245a8e454db1361715a92d11f03ae0bff098bc" translate="yes" xml:space="preserve">
          <source>This function can be exponentially slow for some inputs, unless &lt;code&gt;max_work&lt;/code&gt; is set to a finite number or &lt;code&gt;MAY_SHARE_BOUNDS&lt;/code&gt;. If in doubt, use &lt;a href=&quot;numpy.may_share_memory#numpy.may_share_memory&quot;&gt;&lt;code&gt;numpy.may_share_memory&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;max_work&lt;/code&gt; が有限数または &lt;code&gt;MAY_SHARE_BOUNDS&lt;/code&gt; に設定されていない限り、この関数は一部の入力で指数関数的に遅くなる可能性があります。疑わしい場合は、代わりに&lt;a href=&quot;numpy.may_share_memory#numpy.may_share_memory&quot;&gt; &lt;code&gt;numpy.may_share_memory&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="71ac25efd0c9fb7e70f813509afc2d6139c57b07" translate="yes" xml:space="preserve">
          <source>This function changes the fill value of the masked array &lt;code&gt;a&lt;/code&gt; in place. If &lt;code&gt;a&lt;/code&gt; is not a masked array, the function returns silently, without doing anything.</source>
          <target state="translated">この関数は、マスクされた配列 &lt;code&gt;a&lt;/code&gt; の塗りつぶし値を変更します。 &lt;code&gt;a&lt;/code&gt; がマスクされた配列でない場合、関数は何もせずにサイレントに戻ります。</target>
        </trans-unit>
        <trans-unit id="dc2a1bc44c01911d64ceae9284770c887ff15ab1" translate="yes" xml:space="preserve">
          <source>This function checks to see if &lt;em&gt;arr&lt;/em&gt; is a 0-dimensional array and, if so, returns the appropriate array scalar. It should be used whenever 0-dimensional arrays could be returned to Python.</source>
          <target state="translated">この関数は、&lt;em&gt;arr&lt;/em&gt;が0次元配列かどうかを確認し、0次元配列の場合は、適切な配列スカラーを返します。0次元配列がPythonに返される可能性がある場合は常に使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="6e0d86a376dbbcdcd20b9ab0ced8ac2eae8ffe8a" translate="yes" xml:space="preserve">
          <source>This function computes the &lt;em&gt;N&lt;/em&gt;-dimensional discrete Fourier Transform over any number of axes in an &lt;em&gt;M&lt;/em&gt;-dimensional array by means of the Fast Fourier Transform (FFT).</source>
          <target state="translated">この関数は、高速フーリエ変換（FFT）を使用して、&lt;em&gt;M&lt;/em&gt;次元配列の任意の数の軸で&lt;em&gt;N&lt;/em&gt;次元の離散フーリエ変換を計算します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f34d917f1e7128a56a07b81dc929875f904b8a8c" translate="yes" xml:space="preserve">
          <source>This function computes the &lt;em&gt;n&lt;/em&gt;-dimensional discrete Fourier Transform over any axes in an &lt;em&gt;M&lt;/em&gt;-dimensional array by means of the Fast Fourier Transform (FFT). By default, the transform is computed over the last two axes of the input array, i.e., a 2-dimensional FFT.</source>
          <target state="translated">この関数は、高速フーリエ変換（FFT）を使用して、&lt;em&gt;M&lt;/em&gt;次元配列の任意の軸で&lt;em&gt;n&lt;/em&gt;次元の離散フーリエ変換を計算します。デフォルトでは、変換は入力配列の最後の2つの軸、つまり2次元FFTで計算されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8915bccc6bfc2e5b959f002fb985788d011a64f" translate="yes" xml:space="preserve">
          <source>This function computes the N-dimensional discrete Fourier Transform over any number of axes in an M-dimensional real array by means of the Fast Fourier Transform (FFT). By default, all axes are transformed, with the real transform performed over the last axis, while the remaining transforms are complex.</source>
          <target state="translated">この関数は,高速フーリエ変換(FFT)を用いて,M次元実数配列内の任意の数の軸に対するN次元離散フーリエ変換を計算します.デフォルトでは,すべての軸が変換され,最後の軸に対して実数変換が実行され,残りの変換は複素数になります.</target>
        </trans-unit>
        <trans-unit id="b8c7b22438d176337766fd2e49c4b7cfc3e07bab" translate="yes" xml:space="preserve">
          <source>This function computes the correlation as generally defined in signal processing texts:</source>
          <target state="translated">この関数は,信号処理のテキストで一般的に定義されている相関を計算します.</target>
        </trans-unit>
        <trans-unit id="cd6ec7a4da9a308e6c6acab0d22d9735b9865d50" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the 2-dimensional discrete Fourier Transform over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT). In other words, &lt;code&gt;ifft2(fft2(a)) == a&lt;/code&gt; to within numerical accuracy. By default, the inverse transform is computed over the last two axes of the input array.</source>
          <target state="translated">この関数は、高速フーリエ変換（FFT）を使用して、M次元配列の任意の数の軸で2次元離散フーリエ変換の逆を計算します。言い換えると、 &lt;code&gt;ifft2(fft2(a)) == a&lt;/code&gt; は、数値精度の範囲内です。デフォルトでは、逆変換は入力配列の最後の2つの軸に対して計算されます。</target>
        </trans-unit>
        <trans-unit id="1a4ebaf525beaf877d17151690d3a34bb9c59baf" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the N-dimensional discrete Fourier Transform for real input over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT). In other words, &lt;code&gt;irfftn(rfftn(a), a.shape) == a&lt;/code&gt; to within numerical accuracy. (The &lt;code&gt;a.shape&lt;/code&gt; is necessary like &lt;code&gt;len(a)&lt;/code&gt; is for &lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt;, and for the same reason.)</source>
          <target state="translated">この関数は、高速フーリエ変換（FFT）を使用して、M次元配列の任意の数の軸に渡る実数入力のN次元離散フーリエ変換の逆を計算します。言い換えると、 &lt;code&gt;irfftn(rfftn(a), a.shape) == a&lt;/code&gt; は、数値の精度の範囲内です。（ &lt;code&gt;a.shape&lt;/code&gt; は &lt;code&gt;len(a)&lt;/code&gt; が&lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; の&lt;/a&gt;場合と同じように必要であり、同じ理由で必要です。）</target>
        </trans-unit>
        <trans-unit id="0c7a0cee522d4ce9c957b628834b82e1d28defa5" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the N-dimensional discrete Fourier Transform over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT). In other words, &lt;code&gt;ifftn(fftn(a)) == a&lt;/code&gt; to within numerical accuracy. For a description of the definitions and conventions used, see &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数は、高速フーリエ変換（FFT）を使用して、M次元配列の任意の数の軸に対するN次元の離散フーリエ変換の逆数を計算します。言い換えると、 &lt;code&gt;ifftn(fftn(a)) == a&lt;/code&gt; は数値精度の範囲内です。使用される定義と規則の説明については、&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b2f9d73633ea8b8eb82a0685fcd08ea3505d9a66" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier Transform of real input computed by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;. In other words, &lt;code&gt;irfft(rfft(a), len(a)) == a&lt;/code&gt; to within numerical accuracy. (See Notes below for why &lt;code&gt;len(a)&lt;/code&gt; is necessary here.)</source>
          <target state="translated">この関数は、&lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt;によって計算された実数入力の1次元&lt;em&gt;n&lt;/em&gt;ポイント離散フーリエ変換の逆を計算します。言い換えれば、 &lt;code&gt;irfft(rfft(a), len(a)) == a&lt;/code&gt; は、数値精度の範囲内です。（ここで &lt;code&gt;len(a)&lt;/code&gt; が必要な理由については、下記の注を参照してください。）</target>
        </trans-unit>
        <trans-unit id="82bfb7db090395ddadcdd09fad9b5160012346cf" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier transform computed by &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;. In other words, &lt;code&gt;ifft(fft(a)) == a&lt;/code&gt; to within numerical accuracy. For a general description of the algorithm and definitions, see &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数は、&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;によって計算された1次元の&lt;em&gt;n点&lt;/em&gt;離散フーリエ変換の逆関数を計算します。言い換えれば、 &lt;code&gt;ifft(fft(a)) == a&lt;/code&gt; から数値精度の範囲内です。アルゴリズムと定義の一般的な説明については、&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="35acba32b3eea01535885b216d423da5ad809ed9" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier transform computed by &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;. In other words, &lt;code&gt;ifft(fft(a)) == a&lt;/code&gt; to within numerical accuracy. For a general description of the algorithm and definitions, see &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数は、&lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;によって計算された1次元の&lt;em&gt;n点&lt;/em&gt;離散フーリエ変換の逆を計算します。言い換えると、 &lt;code&gt;ifft(fft(a)) == a&lt;/code&gt; は数値精度の範囲内です。アルゴリズムと定義の一般的な説明については、&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ad9d7d69d57ac9facd5b4f82ac6ba6f908913a31" translate="yes" xml:space="preserve">
          <source>This function computes the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier Transform (DFT) of a real-valued array by means of an efficient algorithm called the Fast Fourier Transform (FFT).</source>
          <target state="translated">この関数は、高速フーリエ変換（FFT）と呼ばれる効率的なアルゴリズムを使用して、実数値配列の1次元&lt;em&gt;n点&lt;/em&gt;離散フーリエ変換（DFT）を計算します。</target>
        </trans-unit>
        <trans-unit id="68ec181d19ee1190284573e044b4ba392f94f385" translate="yes" xml:space="preserve">
          <source>This function computes the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier Transform (DFT) with the efficient Fast Fourier Transform (FFT) algorithm [CT].</source>
          <target state="translated">この関数は、効率的な高速フーリエ変換（FFT）アルゴリズム[CT]を使用して、1次元の&lt;em&gt;n点&lt;/em&gt;離散フーリエ変換（DFT）を計算します。</target>
        </trans-unit>
        <trans-unit id="30a498de56241e50f5fd1a10939273e87357615d" translate="yes" xml:space="preserve">
          <source>This function continues to be supported for backward compatibility, but you should prefer &lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt;&lt;code&gt;moveaxis&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt;&lt;code&gt;moveaxis&lt;/code&gt;&lt;/a&gt; function was added in NumPy 1.11.</source>
          <target state="translated">この関数は、下位互換性のために引き続きサポートされていますが、&lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt; &lt;code&gt;moveaxis&lt;/code&gt; &lt;/a&gt;を使用することをお勧めします。&lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt; &lt;code&gt;moveaxis&lt;/code&gt; の&lt;/a&gt;機能はnumpyの1.11で追加されました。</target>
        </trans-unit>
        <trans-unit id="307209890a37b51bcd317c1d8679c25cf8cf32dc" translate="yes" xml:space="preserve">
          <source>This function creates a new neighborhood iterator from an existing iterator. The neighborhood will be computed relatively to the position currently pointed by &lt;em&gt;iter&lt;/em&gt;, the bounds define the shape of the neighborhood iterator, and the mode argument the boundaries handling mode.</source>
          <target state="translated">この関数は、既存のイテレーターから新しい近隣イテレーターを作成します。近傍は、&lt;em&gt;iterが&lt;/em&gt;現在指している位置に対して相対的に計算され、境界は近傍イテレーターの形状を定義し、モード引数は境界処理モードです。</target>
        </trans-unit>
        <trans-unit id="33522609896e19e2c62ce4cc185c0f8e169d65db" translate="yes" xml:space="preserve">
          <source>This function does &lt;em&gt;not&lt;/em&gt; initialize the returned array; to do that use &lt;a href=&quot;numpy.zeros_like#numpy.zeros_like&quot;&gt;&lt;code&gt;zeros_like&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.ones_like#numpy.ones_like&quot;&gt;&lt;code&gt;ones_like&lt;/code&gt;&lt;/a&gt; instead. It may be marginally faster than the functions that do set the array values.</source>
          <target state="translated">この関数は返された配列を初期化しませ&lt;em&gt;ん&lt;/em&gt;。そのためには、代わりに&lt;a href=&quot;numpy.zeros_like#numpy.zeros_like&quot;&gt; &lt;code&gt;zeros_like&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;numpy.ones_like#numpy.ones_like&quot;&gt; &lt;code&gt;ones_like&lt;/code&gt; &lt;/a&gt;を使用してください。配列の値を設定する関数よりわずかに速いかもしれません。</target>
        </trans-unit>
        <trans-unit id="0decc5010e2e82ceb19b7a45f9d7da5f4f237524" translate="yes" xml:space="preserve">
          <source>This function does &lt;em&gt;not&lt;/em&gt; initialize the returned array; to do that use &lt;code&gt;zeros_like&lt;/code&gt; or &lt;code&gt;ones_like&lt;/code&gt; instead. It may be marginally faster than the functions that do set the array values.</source>
          <target state="translated">この関数は返された配列を初期化しませ&lt;em&gt;ん&lt;/em&gt;。そのためには、代わりに &lt;code&gt;zeros_like&lt;/code&gt; または &lt;code&gt;ones_like&lt;/code&gt; を使用してください。配列の値を設定する関数よりわずかに速いかもしれません。</target>
        </trans-unit>
        <trans-unit id="960581e2e13399cd79a7bf3c883aeb7b8d2e979d" translate="yes" xml:space="preserve">
          <source>This function does not check the contents of the input, only that the type is MaskType. In particular, this function returns False if the mask has a flexible dtype.</source>
          <target state="translated">この関数は、入力内容のチェックは行わず、型がMaskTypeであることのみをチェックします。特に、マスクが柔軟なdtypeを持っている場合はFalseを返します。</target>
        </trans-unit>
        <trans-unit id="0a232150acd8a12e027d94aeed56f5ff4aae9f46" translate="yes" xml:space="preserve">
          <source>This function does not enforce that the blocks lie on a fixed grid. &lt;code&gt;np.block([[a, b], [c, d]])&lt;/code&gt; is not restricted to arrays of the form:</source>
          <target state="translated">この関数は、ブロックが固定グリッド上にあることを強制しません。 &lt;code&gt;np.block([[a, b], [c, d]])&lt;/code&gt; は、次の形式の配列に限定されません。</target>
        </trans-unit>
        <trans-unit id="6dc40074e04bdcad2b344dd285961cdc7ff85df9" translate="yes" xml:space="preserve">
          <source>This function does not losslessly round-trip in either direction.</source>
          <target state="translated">この関数は、どちらの方向にもロスなく往復しません。</target>
        </trans-unit>
        <trans-unit id="b71c712d42350c6a8a0c257c490e077558876dad" translate="yes" xml:space="preserve">
          <source>This function encapsulates the broadcasting rules. The &lt;em&gt;mit&lt;/em&gt; container should already contain iterators for all the arrays that need to be broadcast. On return, these iterators will be adjusted so that iteration over each simultaneously will accomplish the broadcasting. A negative number is returned if an error occurs.</source>
          <target state="translated">この関数は、ブロードキャストルールをカプセル化します。&lt;em&gt;MITの&lt;/em&gt;コンテナは、必要が放送されることをすべてのアレイのためのイテレータをすでに含まれている必要があります。戻ったとき、これらのイテレータは調整され、それぞれの反復が同時にブロードキャストを実行します。エラーが発生した場合は、負の数が返されます。</target>
        </trans-unit>
        <trans-unit id="9bf48997cebca64928a72fe75ea6eb1ebc70dbfb" translate="yes" xml:space="preserve">
          <source>This function handles NaN comparisons as if NaN was a &amp;ldquo;normal&amp;rdquo; number. That is, AssertionError is not raised if both objects have NaNs in the same positions. This is in contrast to the IEEE standard on NaNs, which says that NaN compared to anything must return False.</source>
          <target state="translated">この関数は、NaNが「正規」数であるかのようにNaN比較を処理します。つまり、両方のオブジェクトのNaNが同じ位置にある場合、AssertionErrorは発生しません。これは、NaNに関するIEEE標準とは対照的であり、NaNは他のものと比較してFalseを返す必要があるとされています。</target>
        </trans-unit>
        <trans-unit id="b02f77dc9fbab1956d3050387654fd71594ea916" translate="yes" xml:space="preserve">
          <source>This function handles NaN comparisons as if NaN was a &amp;ldquo;normal&amp;rdquo; number. That is, no assertion is raised if both objects have NaNs in the same positions. This is in contrast to the IEEE standard on NaNs, which says that NaN compared to anything must return False.</source>
          <target state="translated">この関数は、NaNが「通常の」数値であるかのようにNaN比較を処理します。つまり、両方のオブジェクトのNaNが同じ位置にある場合、アサーションは発生しません。これは、NaNのIEEE標準とは対照的です。これは、NaNは何と比較してもFalseを返す必要があることを示しています。</target>
        </trans-unit>
        <trans-unit id="d5f910d97d6aeb7075f641616a02d523dd4438a4" translate="yes" xml:space="preserve">
          <source>This function has been deprecated. Use randint instead.</source>
          <target state="translated">この関数は非推奨です。代わりに randint を使用してください。</target>
        </trans-unit>
        <trans-unit id="77fe5df00c0c7c8132af4661573c5a4cca000d13" translate="yes" xml:space="preserve">
          <source>This function has to be used with extreme care, see notes.</source>
          <target state="translated">この機能は細心の注意を払って使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="eade9f90c736ff6d6151ab5c5bf1151931416ec5" translate="yes" xml:space="preserve">
          <source>This function instead copies &amp;ldquo;by field name&amp;rdquo;, such that fields in the dst are assigned from the identically named field in the src. This applies recursively for nested structures. This is how structure assignment worked in numpy &amp;gt;= 1.6 to &amp;lt;= 1.13.</source>
          <target state="translated">この関数は、代わりに「フィールド名で」コピーし、dstのフィールドがsrcの同じ名前のフィールドから割り当てられるようにします。これは、ネストされた構造に再帰的に適用されます。これは、numpy&amp;gt; = 1.6から&amp;lt;= 1.13で構造体の割り当てがどのように機能したかを示しています。</target>
        </trans-unit>
        <trans-unit id="965a01bc9232ab2e9c3c470747ee3c2312761abb" translate="yes" xml:space="preserve">
          <source>This function is a compatibility alias for tobytes.</source>
          <target state="translated">この関数はトバイトの互換性のエイリアスです。</target>
        </trans-unit>
        <trans-unit id="a3014854fc3aff1db547e25e4accc358bdc45e8a" translate="yes" xml:space="preserve">
          <source>This function is a compatibility alias for tobytes. Despite its name it returns bytes not strings.</source>
          <target state="translated">この関数は tobytes の互換性のエイリアスです。その名前にもかかわらず、文字列ではなくバイトを返します。</target>
        </trans-unit>
        <trans-unit id="5bced6280c853e5763696660107e62b1e9050b26" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;mask_rowcols&lt;/code&gt; with &lt;code&gt;axis&lt;/code&gt; equal to 0.</source>
          <target state="translated">この機能はへのショートカットである &lt;code&gt;mask_rowcols&lt;/code&gt; と &lt;code&gt;axis&lt;/code&gt; 0に等しいです。</target>
        </trans-unit>
        <trans-unit id="892aad8c63a29b7082fcd31d81f9eafb9d342e8e" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;mask_rowcols&lt;/code&gt; with &lt;code&gt;axis&lt;/code&gt; equal to 1.</source>
          <target state="translated">この機能はへのショートカットである &lt;code&gt;mask_rowcols&lt;/code&gt; と &lt;code&gt;axis&lt;/code&gt; 1に等しいです。</target>
        </trans-unit>
        <trans-unit id="ebac1dd8653756fd79c832147de01fce0d7f87ae" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x != value).</source>
          <target state="translated">この機能はするショートカットです &lt;code&gt;masked_where&lt;/code&gt; で、 &lt;code&gt;condition&lt;/code&gt; =（X！=値）。</target>
        </trans-unit>
        <trans-unit id="ab411b054ab6959d52991c7253cba72df24e6757" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;gt; value).</source>
          <target state="translated">この機能はするためのショートカットである &lt;code&gt;masked_where&lt;/code&gt; と、 &lt;code&gt;condition&lt;/code&gt; =（X&amp;gt;値）。</target>
        </trans-unit>
        <trans-unit id="bf30dbf11727720fe8d30e29bf375cde077485f8" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;gt;= value).</source>
          <target state="translated">この機能はするためのショートカットである &lt;code&gt;masked_where&lt;/code&gt; と、 &lt;code&gt;condition&lt;/code&gt; =（X&amp;gt; =値）。</target>
        </trans-unit>
        <trans-unit id="af1053b8f0ec97d05015f270566c5b82959272a7" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;lt; value).</source>
          <target state="translated">この機能はするためのショートカットである &lt;code&gt;masked_where&lt;/code&gt; と、 &lt;code&gt;condition&lt;/code&gt; =（X &amp;lt;値）。</target>
        </trans-unit>
        <trans-unit id="f9189002c6a19182c690d1c6efc00b46a33f7232" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;lt;= value).</source>
          <target state="translated">この機能はするためのショートカットである &lt;code&gt;masked_where&lt;/code&gt; と、 &lt;code&gt;condition&lt;/code&gt; =（X &amp;lt;=値）。</target>
        </trans-unit>
        <trans-unit id="f46637928627180e5c802e1527edd637c13a58b6" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x == value). For floating point arrays, consider using &lt;code&gt;masked_values(x, value)&lt;/code&gt;.</source>
          <target state="translated">この機能はするためのショートカットである &lt;code&gt;masked_where&lt;/code&gt; と、 &lt;code&gt;condition&lt;/code&gt; =（x ==値）。浮動小数点配列の場合、 &lt;code&gt;masked_values(x, value)&lt;/code&gt; 使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="f4434dee55a64bbfebaafbec40077ada7cc2e4b4" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = ~(np.isfinite(a)). Any pre-existing mask is conserved. Only applies to arrays with a dtype where NaNs or infs make sense (i.e. floating point types), but accepts any array_like object.</source>
          <target state="translated">この機能はするショートカットです &lt;code&gt;masked_where&lt;/code&gt; で、 &lt;code&gt;condition&lt;/code&gt; =〜（np.isfinite（））。既存のマスクはすべて保存されます。NaNまたはinfsが意味のあるdtypeを持つ配列（つまり、浮動小数点型）にのみ適用されますが、array_likeオブジェクトはすべて受け入れます。</target>
        </trans-unit>
        <trans-unit id="f28b126f5c6b2ce96d11bc92753f383ad4cd6485" translate="yes" xml:space="preserve">
          <source>This function is able to return one of eight different matrix norms, or one of an infinite number of vector norms (described below), depending on the value of the &lt;code&gt;ord&lt;/code&gt; parameter.</source>
          <target state="translated">この関数は、 &lt;code&gt;ord&lt;/code&gt; パラメータの値に応じて、8つの異なる行列ノルムのいずれか、または無限数のベクトルノルム（以下で説明）の1つを返すことができます。</target>
        </trans-unit>
        <trans-unit id="c1758140bc8fa9fd28fc8bc131c3f6321c42d5db" translate="yes" xml:space="preserve">
          <source>This function is capable of returning the condition number using one of seven different norms, depending on the value of &lt;code&gt;p&lt;/code&gt; (see Parameters below).</source>
          <target state="translated">この関数は、 &lt;code&gt;p&lt;/code&gt; の値に応じて、7つの異なるノルムのいずれかを使用して条件番号を返すことができます（以下のパラメーターを参照）。</target>
        </trans-unit>
        <trans-unit id="7f257a627b846a11d8d82d4b0986234672c8d024" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;a href=&quot;#numpy.ma.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; except that masked values are treated as equal (default) or unequal, depending on the &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt;&lt;code&gt;masked_equal&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">この関数は&lt;a href=&quot;#numpy.ma.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; &lt;/a&gt;と同等ですが、マスクされた値は、&lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt; &lt;code&gt;masked_equal&lt;/code&gt; &lt;/a&gt;引数に応じて等しい（デフォルト）または等しくないとして扱われます。</target>
        </trans-unit>
        <trans-unit id="dd8713725fce28207d278a6136fdd184217d0bb8" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;a href=&quot;numpy.allclose#numpy.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; except that masked values are treated as equal (default) or unequal, depending on the &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt;&lt;code&gt;masked_equal&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">この関数は、&lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt; &lt;code&gt;masked_equal&lt;/code&gt; &lt;/a&gt;引数に応じて、マスクされた値が等しい（デフォルト）または等しくないものとして扱われることを除いて、&lt;a href=&quot;numpy.allclose#numpy.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; &lt;/a&gt;と同等です。</target>
        </trans-unit>
        <trans-unit id="a3debc8695bd72584953abb12e719fb90548f7dd" translate="yes" xml:space="preserve">
          <source>This function is equivalent to calling the &amp;ldquo;compressed&amp;rdquo; method of a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;numpy.ma.maskedarray.compressed#numpy.ma.MaskedArray.compressed&quot;&gt;&lt;code&gt;MaskedArray.compressed&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">この関数は、の「圧縮」メソッドを呼び出すのと同等です&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; を&lt;/a&gt;参照してください&lt;a href=&quot;numpy.ma.maskedarray.compressed#numpy.ma.MaskedArray.compressed&quot;&gt; &lt;code&gt;MaskedArray.compressed&lt;/code&gt; &lt;/a&gt;詳細については。</target>
        </trans-unit>
        <trans-unit id="b5a91f899ffc50b531674413c041bb92c6104a7d" translate="yes" xml:space="preserve">
          <source>This function is equivalent to calling the &amp;ldquo;compressed&amp;rdquo; method of a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;ma.MaskedArray&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;numpy.ma.maskedarray.compressed#numpy.ma.MaskedArray.compressed&quot;&gt;&lt;code&gt;ma.MaskedArray.compressed&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">この関数は、の「圧縮」メソッドを呼び出すのと同等です&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;ma.MaskedArray&lt;/code&gt; を&lt;/a&gt;参照してください&lt;a href=&quot;numpy.ma.maskedarray.compressed#numpy.ma.MaskedArray.compressed&quot;&gt; &lt;code&gt;ma.MaskedArray.compressed&lt;/code&gt; &lt;/a&gt;詳細については。</target>
        </trans-unit>
        <trans-unit id="614f9af44de8bf025b95f7feb6cfbfad93376ecb" translate="yes" xml:space="preserve">
          <source>This function is equivalent to tuple axis arguments to reorderable ufuncs with keepdims=True. Tuple axis arguments to ufuncs have been available since version 1.7.0.</source>
          <target state="translated">この関数は、keepdims=Trueで並べ替え可能なufuncsへのタプル軸引数と同等です。ufuncsへのタプル軸引数はバージョン1.7.0から利用可能です。</target>
        </trans-unit>
        <trans-unit id="3c5d87f95304bba4f22f4f3bc79a0366620caeda" translate="yes" xml:space="preserve">
          <source>This function is exactly equivalent to &lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;numpy.transpose&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数は、&lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt; &lt;code&gt;numpy.transpose&lt;/code&gt; &lt;/a&gt;とまったく同じです。</target>
        </trans-unit>
        <trans-unit id="0a042d76cb2129f19b61e5085381910d8b99bdbc" translate="yes" xml:space="preserve">
          <source>This function is intended to be used in EXTERNAL_LOOP mode only, and will produce some wrong answers when that mode is not enabled.</source>
          <target state="translated">この関数は、EXTERNAL_LOOPモードでのみ使用することを意図しており、そのモードが有効になっていない場合、いくつかの間違った答えを生成します。</target>
        </trans-unit>
        <trans-unit id="d3aeb8a347cc701a9fec8946ae6c740c1103bc20" translate="yes" xml:space="preserve">
          <source>This function is not defined for complex-valued arguments; for the so-called argument of complex values, use &lt;a href=&quot;numpy.angle#numpy.angle&quot;&gt;&lt;code&gt;angle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数は、複素数値の引数に対しては定義されていません。いわゆる複素数値の引数には、&lt;a href=&quot;numpy.angle#numpy.angle&quot;&gt; &lt;code&gt;angle&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="42c780622358a45155401477993b5d9d0b335549" translate="yes" xml:space="preserve">
          <source>This function is not designed to work with integers.</source>
          <target state="translated">この関数は整数では動作しないように設計されています。</target>
        </trans-unit>
        <trans-unit id="ea62cc16ec217ef39d7f7c8e5969148da37fd3a3" translate="yes" xml:space="preserve">
          <source>This function is not implemented yet.</source>
          <target state="translated">この機能はまだ実装されていません。</target>
        </trans-unit>
        <trans-unit id="b2f9356116ad7b6b9ba74a0d07b768457fca53e0" translate="yes" xml:space="preserve">
          <source>This function is obsolete and, because of changes due to relaxed stride checking, its return value for the same array may differ for versions of NumPy &amp;gt;= 1.10.0 and previous versions. If you only want to check if an array is Fortran contiguous use &lt;code&gt;a.flags.f_contiguous&lt;/code&gt; instead.</source>
          <target state="translated">この関数は廃止されており、ストライドチェックの緩和による変更のため、NumPy&amp;gt; = 1.10.0のバージョンと以前のバージョンでは、同じ配列の戻り値が異なる場合があります。配列がFortran連続であるかどうかのみを確認したい場合は、代わりに &lt;code&gt;a.flags.f_contiguous&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="258358cbdd467c9c344ce8e3f9c85d0cd7f428e4" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt;&lt;code&gt;masked_values&lt;/code&gt;&lt;/a&gt;, but only suitable for object arrays: for floating point, use &lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt;&lt;code&gt;masked_values&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">この関数は&lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt; &lt;code&gt;masked_values&lt;/code&gt; &lt;/a&gt;に似ていますが、オブジェクト配列にのみ適しています。浮動小数点の場合は、代わりに&lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt; &lt;code&gt;masked_values&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="42e4240c2bc84555a7f741757d674e8c82e565ad" translate="yes" xml:space="preserve">
          <source>This function is superceded by &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数は&lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt; &lt;code&gt;PyArray_MinScalarType&lt;/code&gt; &lt;/a&gt;やPyArray_ResultTypeに取って代わられ&lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f3e20de601f3ca24a5ff2472df08d779de8dd632" translate="yes" xml:space="preserve">
          <source>This function is superceded by &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数は&lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; に&lt;/a&gt;取って代わられました。</target>
        </trans-unit>
        <trans-unit id="223dd6fd50941f5cca2c485c95e8e5dc687d05fb" translate="yes" xml:space="preserve">
          <source>This function is superseded by &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数は、&lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt; &lt;code&gt;PyArray_MinScalarType&lt;/code&gt; &lt;/a&gt;および/または&lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; に置き換えられ&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="cc0b6a66579ee7b8e064413a2fb5429da45dba58" translate="yes" xml:space="preserve">
          <source>This function is superseded by &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数は、&lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; に&lt;/a&gt;置き換えられました。</target>
        </trans-unit>
        <trans-unit id="5b1ff7898f391050d07732317e1b4b4bc976ee58" translate="yes" xml:space="preserve">
          <source>This function is symmetric, but rarely associative.</source>
          <target state="translated">この関数は対称性がありますが、まれに連想性があります。</target>
        </trans-unit>
        <trans-unit id="fb34e601302a103a0946045a1719e9ad4309bf62" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;numpy.diag&lt;/code&gt;&lt;/a&gt; that takes masked values into account, see &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;numpy.diag&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">この関数は、マスクされた値を考慮する&lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;numpy.diag&lt;/code&gt; &lt;/a&gt;と同等です。詳細については、&lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;numpy.diag&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="762735a831cc238bcd6be4852c06ac0013225a54" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;numpy.dot#numpy.dot&quot;&gt;&lt;code&gt;numpy.dot&lt;/code&gt;&lt;/a&gt; that takes masked values into account. Note that &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; are in different position than in the method version. In order to maintain compatibility with the corresponding method, it is recommended that the optional arguments be treated as keyword only. At some point that may be mandatory.</source>
          <target state="translated">この関数は、マスクされた値を考慮に入れる&lt;a href=&quot;numpy.dot#numpy.dot&quot;&gt; &lt;code&gt;numpy.dot&lt;/code&gt; &lt;/a&gt;と同等です。 &lt;code&gt;strict&lt;/code&gt; と &lt;code&gt;out&lt;/code&gt; は、メソッドバージョンとは異なる位置にあることに注意してください。対応するメソッドとの互換性を維持するために、オプションの引数をキーワードとしてのみ扱うことをお勧めします。ある時点でそれは必須かもしれません。</target>
        </trans-unit>
        <trans-unit id="b3449fce446ccae1d5ae6c6d55107b82701f20fd" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt;&lt;code&gt;numpy.ediff1d&lt;/code&gt;&lt;/a&gt; that takes masked values into account, see &lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt;&lt;code&gt;numpy.ediff1d&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">この関数は、マスクされた値を考慮する&lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt; &lt;code&gt;numpy.ediff1d&lt;/code&gt; &lt;/a&gt;と同等です。詳細については、&lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt; &lt;code&gt;numpy.ediff1d&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="fc125d9cdb2114a10df5933b4e6f500d1c08539d" translate="yes" xml:space="preserve">
          <source>This function is used to simplify access to fields nested in other fields.</source>
          <target state="translated">この関数は、他のフィールドにネストされたフィールドへのアクセスを簡素化するために使用されます。</target>
        </trans-unit>
        <trans-unit id="48492051f92b9e0c98dfd72175da1464af62c22d" translate="yes" xml:space="preserve">
          <source>This function is useful for calculating a fill value suitable for taking the maximum of an array with a given dtype.</source>
          <target state="translated">この関数は,与えられたdtypeを持つ配列の最大値を取るのに適した塗りつぶし値を計算するのに便利です.</target>
        </trans-unit>
        <trans-unit id="eeb9d1e68f6032230d3ff5e76ccad6bac584a6b3" translate="yes" xml:space="preserve">
          <source>This function is useful for calculating a fill value suitable for taking the minimum of an array with a given dtype.</source>
          <target state="translated">この関数は,指定されたdtypeを持つ配列の最小値を取るのに適したフィル値を計算するのに便利です.</target>
        </trans-unit>
        <trans-unit id="514144ea48299b81c7b15dfcf631d31668bd3186" translate="yes" xml:space="preserve">
          <source>This function is useful for determining a common type that two or more arrays can be converted to. It only works for non-flexible array types as no itemsize information is passed. The &lt;em&gt;mintype&lt;/em&gt; argument represents the minimum type acceptable, and &lt;em&gt;op&lt;/em&gt; represents the object that will be converted to an array. The return value is the enumerated typenumber that represents the data-type that &lt;em&gt;op&lt;/em&gt; should have.</source>
          <target state="translated">この関数は、2つ以上の配列を変換できる共通の型を決定するのに役立ちます。itemsize情報が渡されないため、これは非柔軟な配列型に対してのみ機能します。&lt;em&gt;mintypeの&lt;/em&gt;引数は最小タイプが許容可能であり、&lt;em&gt;OPは&lt;/em&gt;、アレイに変換されるオブジェクトを表します。戻り値は、&lt;em&gt;op&lt;/em&gt;が持つ必要があるデータ型を表す列挙型番号です。</target>
        </trans-unit>
        <trans-unit id="66ea2fa9dfd3553ca39f3787970de46499229028" translate="yes" xml:space="preserve">
          <source>This function is useful to be sure that an array with the correct flags is returned for passing to compiled code (perhaps through ctypes).</source>
          <target state="translated">この関数は、コンパイルされたコードに渡すために正しいフラグを持つ配列が返されることを確認するのに便利です(おそらくctypesを通して)。</target>
        </trans-unit>
        <trans-unit id="8e9b1bcfe6f895f9426e7973caf7f080e53d5b02" translate="yes" xml:space="preserve">
          <source>This function is very similar to &lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; above, but has an extra &lt;em&gt;identity_value&lt;/em&gt; argument, to define an arbitrary identity for the ufunc when &lt;code&gt;identity&lt;/code&gt; is passed as &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt;.</source>
          <target state="translated">この関数は上記の &lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; に非常に似ていますが、 &lt;code&gt;identity&lt;/code&gt; が &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt; として渡されるときにufuncの任意のIDを定義するための追加の&lt;em&gt;identity_value&lt;/em&gt;引数があります。</target>
        </trans-unit>
        <trans-unit id="e6ae878f05630a69160b11c652744c88c73b83f7" translate="yes" xml:space="preserve">
          <source>This function is very similar to PyUFunc_FromFuncAndData above, but has an extra &lt;em&gt;signature&lt;/em&gt; argument, to define a &lt;a href=&quot;c-api.generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;generalized universal functions&lt;/a&gt;. Similarly to how ufuncs are built around an element-by-element operation, gufuncs are around subarray-by-subarray operations, the &lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;signature&lt;/a&gt; defining the subarrays to operate on.</source>
          <target state="translated">この関数は上記のPyUFunc_FromFuncAndDataと非常に似ていますが、&lt;a href=&quot;c-api.generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;一般化された汎用関数&lt;/a&gt;を定義するための追加の&lt;em&gt;署名&lt;/em&gt;引数があります。要素ごとの操作を中心にufuncが構築される方法と同様に、gufuncsは、操作するサブ配列を定義する&lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;シグネチャである&lt;/a&gt;、サブ配列ごとの操作を中心にしています。</target>
        </trans-unit>
        <trans-unit id="7d7c3c059d66b50ac25de48e14a9110e6ed62010" translate="yes" xml:space="preserve">
          <source>This function is very similar to PyUFunc_FromFuncAndData above, but has an extra &lt;em&gt;signature&lt;/em&gt; argument, to define a &lt;a href=&quot;generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;generalized universal functions&lt;/a&gt;. Similarly to how ufuncs are built around an element-by-element operation, gufuncs are around subarray-by-subarray operations, the &lt;a href=&quot;generalized-ufuncs#details-of-signature&quot;&gt;signature&lt;/a&gt; defining the subarrays to operate on.</source>
          <target state="translated">この関数は、上記のPyUFunc_FromFuncAndDataと非常に似ていますが、&lt;a href=&quot;generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;一般化されたユニバーサル関数&lt;/a&gt;を定義するための追加の&lt;em&gt;署名&lt;/em&gt;引数があります。同様ufuncsは、要素ごとの操作を中心に構築されている方法、gufuncsはサブアレイごとサブアレイ操作、周りにある&lt;a href=&quot;generalized-ufuncs#details-of-signature&quot;&gt;署名&lt;/a&gt;で動作するサブアレイを定義します。</target>
        </trans-unit>
        <trans-unit id="0dc77b4e140ac75bc9ac3e89d41f38fc73185d22" translate="yes" xml:space="preserve">
          <source>This function makes most sense for arrays with up to 3 dimensions. For instance, for pixel-data with a height (first axis), width (second axis), and r/g/b channels (third axis). The functions &lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.stack#numpy.stack&quot;&gt;&lt;code&gt;stack&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.block#numpy.block&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; provide more general stacking and concatenation operations.</source>
          <target state="translated">この関数は、3次元までの配列に対して最も意味があります。たとえば、高さ（1番目の軸）、幅（2番目の軸）、およびr / g / bチャネル（3番目の軸）を持つピクセルデータの場合。関数&lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;numpy.stack#numpy.stack&quot;&gt; &lt;code&gt;stack&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;numpy.block#numpy.block&quot;&gt; &lt;code&gt;block&lt;/code&gt; は&lt;/a&gt;、より一般的なスタックおよび連結操作を提供します。</target>
        </trans-unit>
        <trans-unit id="f7b019770de00d4d47b09eabe135d2ae721a995a" translate="yes" xml:space="preserve">
          <source>This function makes most sense for arrays with up to 3 dimensions. For instance, for pixel-data with a height (first axis), width (second axis), and r/g/b channels (third axis). The functions &lt;a href=&quot;numpy.ma.concatenate#numpy.ma.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.ma.stack#numpy.ma.stack&quot;&gt;&lt;code&gt;stack&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;block&lt;/code&gt; provide more general stacking and concatenation operations.</source>
          <target state="translated">この関数は、3次元までの配列に対して最も意味があります。たとえば、高さ（1番目の軸）、幅（2番目の軸）、およびr / g / bチャネル（3番目の軸）を持つピクセルデータの場合。関数&lt;a href=&quot;numpy.ma.concatenate#numpy.ma.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;numpy.ma.stack#numpy.ma.stack&quot;&gt; &lt;code&gt;stack&lt;/code&gt; &lt;/a&gt;、および &lt;code&gt;block&lt;/code&gt; は、より一般的なスタックおよび連結操作を提供します。</target>
        </trans-unit>
        <trans-unit id="f15e5fa1742619380116b3f34a00c85d55366c55" translate="yes" xml:space="preserve">
          <source>This function may also be used as a decorator.</source>
          <target state="translated">この関数は、デコレータとしても使用できます。</target>
        </trans-unit>
        <trans-unit id="d585b637d27940cc37d90ebf4940a9aa2e521b5d" translate="yes" xml:space="preserve">
          <source>This function may be safely called without holding the Python GIL.</source>
          <target state="translated">この関数は、PythonのGILを保持していなくても安全に呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="cd200e9dfe3f17be99d159e426b6fa9331db61ec" translate="yes" xml:space="preserve">
          <source>This function may only be called if the iterator is tracking a multi-index and if &lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt;&lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt;&lt;/a&gt; was used to prevent an axis from being iterated in reverse order.</source>
          <target state="translated">この関数は、イテレータがマルチインデックスを追跡していて、&lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt; &lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt; &lt;/a&gt;を使用して軸が逆順で繰り返されないようにする場合にのみ呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="6ca18036fbf762cae2043baf8ac3fa8494d28495" translate="yes" xml:space="preserve">
          <source>This function must be called in the initialization section of a module that will make use of the C-API. It imports the module where the function-pointer table is stored and points the correct variable to it.</source>
          <target state="translated">この関数は、C-API を使用するモジュールの初期化セクションで呼び出す必要があります。この関数は、関数ポインタテーブルが格納されているモジュールをインポートし、正しい変数を指し示します。</target>
        </trans-unit>
        <trans-unit id="cf5ee49acb54388d21032f90f2de16dca9ddb6c3" translate="yes" xml:space="preserve">
          <source>This function must take two arguments, &lt;code&gt;func(a, axis)&lt;/code&gt;.</source>
          <target state="translated">この関数は、2つの引数 &lt;code&gt;func(a, axis)&lt;/code&gt; 取る必要があります。</target>
        </trans-unit>
        <trans-unit id="dba1259c24481a4a54d81a8fdecff9fadce8f02f" translate="yes" xml:space="preserve">
          <source>This function only shuffles the array along the first axis of a multi-dimensional array. The order of sub-arrays is changed but their contents remains the same.</source>
          <target state="translated">この関数は、多次元配列の第1軸に沿って配列をシャッフルするだけです。サブ配列の順序は変更されますが,その内容は変わりません.</target>
        </trans-unit>
        <trans-unit id="68ca7042b267a7f2923f8a89cc886956d3a640a1" translate="yes" xml:space="preserve">
          <source>This function provides greater precision than &lt;code&gt;exp(x) - 1&lt;/code&gt; for small values of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">この関数は、 &lt;code&gt;x&lt;/code&gt; の小さな値に対して &lt;code&gt;exp(x) - 1&lt;/code&gt; よりも高い精度を提供します。</target>
        </trans-unit>
        <trans-unit id="40a3f0ad0a26c2dcd1667ccf5fd0beae55099939" translate="yes" xml:space="preserve">
          <source>This function reads from the system entropy pool and so samples are not reproducible. In particular, it does &lt;em&gt;NOT&lt;/em&gt; make use of a BitGenerator, and so &lt;code&gt;seed&lt;/code&gt; and setting &lt;code&gt;state&lt;/code&gt; have no effect.</source>
          <target state="translated">この関数はシステムエントロピープールから読み取るため、サンプルは再現できません。特に、BitGeneratorを使用し&lt;em&gt;ない&lt;/em&gt;ため、 &lt;code&gt;seed&lt;/code&gt; と設定 &lt;code&gt;state&lt;/code&gt; は効果がありません。</target>
        </trans-unit>
        <trans-unit id="2db0a89599aa1f9e0af20f69fdc08455be79db8b" translate="yes" xml:space="preserve">
          <source>This function returns True if &lt;code&gt;x&lt;/code&gt; is an instance of MaskedArray and returns False otherwise. Any object is accepted as input.</source>
          <target state="translated">この関数は、 &lt;code&gt;x&lt;/code&gt; がMaskedArrayのインスタンスである場合はTrueを返し、それ以外の場合はFalseを返します。すべてのオブジェクトが入力として受け入れられます。</target>
        </trans-unit>
        <trans-unit id="326a3290cbe737031cbcfe2c255c104d77bb6d98" translate="yes" xml:space="preserve">
          <source>This function returns a (C-style) contiguous and behaved function array from any nested sequence or array interface exporting object, &lt;em&gt;op&lt;/em&gt;, of (non-flexible) type given by the enumerated &lt;em&gt;typenum&lt;/em&gt;, of minimum depth &lt;em&gt;min_depth&lt;/em&gt;, and of maximum depth &lt;em&gt;max_depth&lt;/em&gt;. Equivalent to a call to &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; with requirements set to &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; and the type_num member of the type argument set to &lt;em&gt;typenum&lt;/em&gt;.</source>
          <target state="translated">この関数は、列挙型&lt;em&gt;typenum&lt;/em&gt;で指定された（非フレキシブル）型で、最小深度が&lt;em&gt;min_depth&lt;/em&gt;で、最大深度が&lt;em&gt;max_depthである&lt;/em&gt;、ネストされたシーケンスまたは配列インターフェースのエクスポートオブジェクト（&lt;em&gt;op&lt;/em&gt;）から、（Cスタイルの）連続して動作する関数配列を&lt;em&gt;返し&lt;/em&gt;ます。呼び出しに相当&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;に設定要件と&lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; &lt;/a&gt;とに設定型引数のtype_numメンバー&lt;em&gt;typenum&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd99a05c88fddf54e9c57ac9cd52857632e3d1f8" translate="yes" xml:space="preserve">
          <source>This function returns a boolean ndarray with all entries False, that can be used in common mask manipulations. If a complex dtype is specified, the type of each field is converted to a boolean type.</source>
          <target state="translated">この関数は、一般的なマスク操作で使用できるように、すべてのエントリがFalseであるブール値のndarrayを返します。複素数のdtypeが指定された場合、各フィールドの型はブール型に変換されます。</target>
        </trans-unit>
        <trans-unit id="02eca326759cd81f17376a545937c3d2382a2a50" translate="yes" xml:space="preserve">
          <source>This function returns a well-behaved C-style contiguous array from any nested sequence or array-interface exporting object. The minimum number of dimensions the array can have is given by &lt;code&gt;min_depth&lt;/code&gt; while the maximum is &lt;code&gt;max_depth&lt;/code&gt;. This is equivalent to call &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; with requirements &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数は、ネストされたシーケンスまたは配列インターフェイスのエクスポートオブジェクトから、正常に動作するCスタイルの連続配列を返します。配列が持つことができる次元の最小数は &lt;code&gt;min_depth&lt;/code&gt; で与えられ、最大は &lt;code&gt;max_depth&lt;/code&gt; です。これは、呼び出すことと等価である&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; を&lt;/a&gt;要件と&lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5e7626c8e43009c9d0e23e7f2d941b6cb967b32" translate="yes" xml:space="preserve">
          <source>This function returns the absolute values (positive magnitude) of the data in &lt;code&gt;x&lt;/code&gt;. Complex values are not handled, use &lt;a href=&quot;numpy.absolute#numpy.absolute&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; to find the absolute values of complex data.</source>
          <target state="translated">この関数は、 &lt;code&gt;x&lt;/code&gt; のデータの絶対値（正の大きさ）を返します。複合値を使用し、処理されない&lt;a href=&quot;numpy.absolute#numpy.absolute&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt;複合データの絶対値を見つけます。</target>
        </trans-unit>
        <trans-unit id="89fee3e999f1c558b74709781bf21911d5dc8fa4" translate="yes" xml:space="preserve">
          <source>This function returns the value</source>
          <target state="translated">この関数は</target>
        </trans-unit>
        <trans-unit id="1cc55e517c256ea42c557b8b54e3efb3b6cafcb6" translate="yes" xml:space="preserve">
          <source>This function returns the values:</source>
          <target state="translated">この関数は値を返します。</target>
        </trans-unit>
        <trans-unit id="a6d07b33b778389f427bd3ca9fc11f04feb25982" translate="yes" xml:space="preserve">
          <source>This function should accept 1-D arrays. It is applied to 1-D slices of &lt;code&gt;arr&lt;/code&gt; along the specified axis.</source>
          <target state="translated">この関数は1次元配列を受け入れます。これは、指定された軸に沿った &lt;code&gt;arr&lt;/code&gt; の 1次元スライスに適用されます。</target>
        </trans-unit>
        <trans-unit id="5cfabdc0232ab8cc8ac575fbc0d4dec6b2dd7bf7" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;arr&lt;/em&gt;.</source>
          <target state="translated">この関数は、&lt;em&gt;arr&lt;/em&gt;への参照を盗みます。</target>
        </trans-unit>
        <trans-unit id="3ceff3d1be740072d08fa441617d883813e56f19" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt; if it is not NULL.</source>
          <target state="translated">この関数は、それがNULLでない場合、&lt;em&gt;descr&lt;/em&gt;への参照を盗みます。</target>
        </trans-unit>
        <trans-unit id="37fa48e8e102e5c7fe97151e437a12d635c87f86" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt; if it is not NULL. This array creation routine allows for the convenient creation of a new array matching an existing array&amp;rsquo;s shapes and memory layout, possibly changing the layout and/or data type.</source>
          <target state="translated">この関数は、&lt;em&gt;descr&lt;/em&gt;への参照がNULLでない場合、それを盗みます。この配列作成ルーチンを使用すると、既存の配列の形状やメモリレイアウトに一致する新しい配列を簡単に作成でき、レイアウトやデータ型を変更できる可能性があります。</target>
        </trans-unit>
        <trans-unit id="8281b58eb98855581eef0364cfa182f403baf433" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt;.</source>
          <target state="translated">この関数は、&lt;em&gt;descr&lt;/em&gt;への参照を盗み&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="71bb778b3ae86d2314883f6bdb50a6590499183c" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt;. The easiest way to get one is using &lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数は、&lt;em&gt;descr&lt;/em&gt;への参照を盗み&lt;em&gt;ます&lt;/em&gt;。これを取得する最も簡単な方法は、&lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt; &lt;code&gt;PyArray_DescrFromType&lt;/code&gt; &lt;/a&gt;を使用することです。</target>
        </trans-unit>
        <trans-unit id="f6d42633714a13d2a78f3f69e93cf9d52e8a857e" translate="yes" xml:space="preserve">
          <source>This function supports both indexing conventions through the indexing keyword argument. Giving the string &amp;lsquo;ij&amp;rsquo; returns a meshgrid with matrix indexing, while &amp;lsquo;xy&amp;rsquo; returns a meshgrid with Cartesian indexing. In the 2-D case with inputs of length M and N, the outputs are of shape (N, M) for &amp;lsquo;xy&amp;rsquo; indexing and (M, N) for &amp;lsquo;ij&amp;rsquo; indexing. In the 3-D case with inputs of length M, N and P, outputs are of shape (N, M, P) for &amp;lsquo;xy&amp;rsquo; indexing and (M, N, P) for &amp;lsquo;ij&amp;rsquo; indexing. The difference is illustrated by the following code snippet:</source>
          <target state="translated">この関数は、indexingキーワード引数を通じて両方のインデックス付け規則をサポートします。文字列 'ij'を指定すると、行列のインデックスが付いたメッシュグリッドが返され、 'xy'はデカルトのインデックスが付いたメッシュグリッドが返されます。入力が長さMおよびNの2次元の場合、出力は「xy」インデックスの場合は（N、M）、「ij」インデックスの場合は（M、N）の形状になります。入力が長さM、N、およびPの3次元の場合、出力は「xy」インデックスの場合は（N、M、P）、「ij」インデックスの場合は（M、N、P）の形状になります。違いは、次のコードスニペットに示されています。</target>
        </trans-unit>
        <trans-unit id="e857d76db9c7bac209f1715cec1437cf523540d8" translate="yes" xml:space="preserve">
          <source>This function swaps half-spaces for all axes listed (defaults to all). Note that &lt;code&gt;y[0]&lt;/code&gt; is the Nyquist component only if &lt;code&gt;len(x)&lt;/code&gt; is even.</source>
          <target state="translated">この関数は、リストされているすべての軸の半空間を交換します（デフォルトはすべて）。 &lt;code&gt;len(x)&lt;/code&gt; が偶数の場合にのみ、 &lt;code&gt;y[0]&lt;/code&gt; がナイキストコンポーネントであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a7870153b27cca4d6c02a86ec8c830b616e4b3c3" translate="yes" xml:space="preserve">
          <source>This function takes N 1-D sequences and returns N outputs with N dimensions each, such that the shape is 1 in all but one dimension and the dimension with the non-unit shape value cycles through all N dimensions.</source>
          <target state="translated">この関数は,N個の1次元シーケンスを受け取り,1次元を除くすべての次元で形状が1であり,非単位形状値を持つ次元がすべてのN次元を循環するように,それぞれN個の次元を持つN個の出力を返します.</target>
        </trans-unit>
        <trans-unit id="b4e43f62f7a361a5fb222fc70fbd3c26bd5104e6" translate="yes" xml:space="preserve">
          <source>This function takes a multi-iterator object that has been previously &amp;ldquo;broadcasted,&amp;rdquo; finds the dimension with the smallest &amp;ldquo;sum of strides&amp;rdquo; in the broadcasted result and adapts all the iterators so as not to iterate over that dimension (by effectively making them of length-1 in that dimension). The corresponding dimension is returned unless &lt;em&gt;mit&lt;/em&gt; -&amp;gt;nd is 0, then -1 is returned. This function is useful for constructing ufunc-like routines that broadcast their inputs correctly and then call a strided 1-d version of the routine as the inner-loop. This 1-d version is usually optimized for speed and for this reason the loop should be performed over the axis that won&amp;rsquo;t require large stride jumps.</source>
          <target state="translated">この関数は、以前に「ブロードキャスト」されたマルチイテレーターオブジェクトを受け取り、ブロードキャスト結果の「ストライドの合計」が最も小さいディメンションを見つけ、そのディメンションを反復しないようにすべてのイテレーターを適応させます（効果的にその次元の長さ-1）。&lt;em&gt;mit-&lt;/em&gt; &amp;gt; ndが0でない限り、対応する次元が返され、次に-1が返されます。この関数は、入力を正しくブロードキャストし、ストライドされた1次元バージョンのルーチンを内部ループとして呼び出すufuncのようなルーチンを構築するのに役立ちます。この1-dバージョンは通常速度が最適化されているため、大きなストライドジャンプを必要としない軸上でループを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="102958a161ae2e87757cf73f96956c3988a66269" translate="yes" xml:space="preserve">
          <source>This function uses the same algorithm as the builtin python &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_left&quot;&gt;&lt;code&gt;bisect.bisect_left&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;side='left'&lt;/code&gt;) and &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_right&quot;&gt;&lt;code&gt;bisect.bisect_right&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;side='right'&lt;/code&gt;) functions, which is also vectorized in the &lt;code&gt;v&lt;/code&gt; argument.</source>
          <target state="translated">この関数は、組み込みのpython &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_left&quot;&gt; &lt;code&gt;bisect.bisect_left&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;side='left'&lt;/code&gt; ）および&lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_right&quot;&gt; &lt;code&gt;bisect.bisect_right&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;side='right'&lt;/code&gt; ）関数と同じアルゴリズムを使用します。これらの関数も &lt;code&gt;v&lt;/code&gt; 引数でベクトル化されます。</target>
        </trans-unit>
        <trans-unit id="f4a094c15ea96c9120e1bb02da934b3ab9299caa" translate="yes" xml:space="preserve">
          <source>This function will not demote complex to float or anything to boolean, but will demote a signed integer to an unsigned integer when the scalar value is positive.</source>
          <target state="translated">この関数は、複素数をfloatや何かをbooleanに降格させるのではなく、スカラ値が正の場合は符号付き整数を符号なし整数に降格させます。</target>
        </trans-unit>
        <trans-unit id="e431cb683c0bc7c35e7633e888e952e4559756e5" translate="yes" xml:space="preserve">
          <source>This function will not preserve masking of MaskedArray inputs.</source>
          <target state="translated">この関数は、MaskedArray入力のマスキングを保持しません。</target>
        </trans-unit>
        <trans-unit id="2a9b1f287c173d330577d2300449ee4dfd3daa91" translate="yes" xml:space="preserve">
          <source>This function works on subclasses of ndarray like &lt;a href=&quot;numpy.ma.array#numpy.ma.array&quot;&gt;&lt;code&gt;ma.array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数は、ma.arrayのような&lt;a href=&quot;numpy.ma.array#numpy.ma.array&quot;&gt; &lt;code&gt;ma.array&lt;/code&gt; &lt;/a&gt;サブクラスで機能します。</target>
        </trans-unit>
        <trans-unit id="b6a52abd835e7532e9891ffc574fd5f4220e58bc" translate="yes" xml:space="preserve">
          <source>This function works similarly to &lt;a href=&quot;#c.PyArray_ObjectType&quot;&gt;&lt;code&gt;PyArray_ObjectType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) except it handles flexible arrays. The &lt;em&gt;mintype&lt;/em&gt; argument can have an itemsize member and the &lt;em&gt;outtype&lt;/em&gt; argument will have an itemsize member at least as big but perhaps bigger depending on the object &lt;em&gt;op&lt;/em&gt;.</source>
          <target state="translated">この関数は、柔軟な配列を処理することを除いて、&lt;a href=&quot;#c.PyArray_ObjectType&quot;&gt; &lt;code&gt;PyArray_ObjectType&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）と同様に機能します。&lt;em&gt;mintypeの&lt;/em&gt;引数はitemsizeメンバーを持つことができ、&lt;em&gt;OUTTYPEの&lt;/em&gt;引数は、オブジェクトに応じて、大きなおそらく大きなとして少なくともitemsizeメンバーを持つことになります&lt;em&gt;オペアンプ&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="24bfcaf02c26210c6ce475ff904488dd4e86859f" translate="yes" xml:space="preserve">
          <source>This functionality can be obtained via &lt;a href=&quot;numpy.diag_indices#numpy.diag_indices&quot;&gt;&lt;code&gt;diag_indices&lt;/code&gt;&lt;/a&gt;, but internally this version uses a much faster implementation that never constructs the indices and uses simple slicing.</source>
          <target state="translated">この機能は&lt;a href=&quot;numpy.diag_indices#numpy.diag_indices&quot;&gt; &lt;code&gt;diag_indices&lt;/code&gt; &lt;/a&gt;を介して取得できますが、内部的にはこのバージョンは、インデックスを構築せず、単純なスライスを使用する、はるかに高速な実装を使用しています。</target>
        </trans-unit>
        <trans-unit id="8df0c373fc062bf47c7c593de18498c118dd2c34" translate="yes" xml:space="preserve">
          <source>This general purpose 1-d core function assumes that &lt;em&gt;func&lt;/em&gt; is a string representing a method of the input object that takes one argument. The first argument in &lt;em&gt;args&lt;/em&gt; is the method whose function is called, the second argument in &lt;em&gt;args&lt;/em&gt; is the argument passed to the function. The output of the function is stored in the third entry of &lt;em&gt;args&lt;/em&gt;.</source>
          <target state="translated">この汎用1-dコア関数は、&lt;em&gt;func&lt;/em&gt;が、1つの引数を取る入力オブジェクトのメソッドを表す文字列であることを前提としています。最初の引数&lt;em&gt;引数は、&lt;/em&gt;その機能が呼び出されるメソッドであり、第二の引数&lt;em&gt;引数が&lt;/em&gt;関数に渡される引数です。関数の出力は&lt;em&gt;argsの&lt;/em&gt; 3番目のエントリに格納されます。</target>
        </trans-unit>
        <trans-unit id="71fb70d934e71392e5b977e3d5908e6d14ba65f1" translate="yes" xml:space="preserve">
          <source>This general purpose 1-d core function assumes that &lt;em&gt;func&lt;/em&gt; is a string representing a method of the input object. For each iteration of the loop, the Python object is extracted from the array and its &lt;em&gt;func&lt;/em&gt; method is called returning the result to the output array.</source>
          <target state="translated">この汎用1-dコア関数は、&lt;em&gt;func&lt;/em&gt;が入力オブジェクトのメソッドを表す文字列であることを前提としています。ループの反復ごとに、Pythonオブジェクトが配列から抽出され、その&lt;em&gt;func&lt;/em&gt;メソッドが呼び出されて、結果を出力配列に返します。</target>
        </trans-unit>
        <trans-unit id="ebe1403d50c0fdb0002abff6822f498479faa88e" translate="yes" xml:space="preserve">
          <source>This geometrical property can be seen in two dimensions by plotting generated data-points:</source>
          <target state="translated">この幾何学的特性は、生成されたデータ点をプロットすることで、2次元で見ることができます。</target>
        </trans-unit>
        <trans-unit id="e1dc7a565ca8eeac49fa065474eb2fca785df357" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the &lt;code&gt;nop&lt;/code&gt; data pointers. If &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; was not specified, each data pointer points to the current data item of the iterator. If no inner iteration was specified, it points to the first data item of the inner loop.</source>
          <target state="translated">これにより、 &lt;code&gt;nop&lt;/code&gt; データポインターへのポインターが返されます。&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;が指定されなかった場合、各データポインターはイテレーターの現在のデータ項目を指します。内部反復が指定されていない場合は、内部ループの最初のデータ項目を指します。</target>
        </trans-unit>
        <trans-unit id="ad9e42c674af93de7c3d00b721f840bb2a3ba388" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the &lt;code&gt;nop&lt;/code&gt; data type Descrs for the objects being iterated. The result points into &lt;code&gt;iter&lt;/code&gt;, so the caller does not gain any references to the Descrs.</source>
          <target state="translated">これにより、反復されるオブジェクトの &lt;code&gt;nop&lt;/code&gt; データ型Descrs へのポインターが返されます。結果は &lt;code&gt;iter&lt;/code&gt; を指しているため、呼び出し元はDescrsへの参照を取得しません。</target>
        </trans-unit>
        <trans-unit id="04484c93294b17e48ec0072eb06cb15b6ce824d8" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the &lt;code&gt;nop&lt;/code&gt; operand PyObjects that are being iterated. The result points into &lt;code&gt;iter&lt;/code&gt;, so the caller does not gain any references to the PyObjects.</source>
          <target state="translated">これは、 &lt;code&gt;nop&lt;/code&gt; れているnopオペランドPyObjects へのポインターを返します。結果は &lt;code&gt;iter&lt;/code&gt; を指すので、呼び出し元はPyObjectsへの参照を取得しません。</target>
        </trans-unit>
        <trans-unit id="de4914e9685130ac5234ec503748e2bb51b5d569" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the index being tracked, or NULL if no index is being tracked. It is only useable if one of the flags &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt;&lt;/a&gt; were specified during construction.</source>
          <target state="translated">これは、追跡されているインデックスへのポインタを返します。追跡されているインデックスがない場合はNULLを返します。構築中にフラグ&lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt; の&lt;/a&gt;いずれかが指定された場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="76e1c3a277ebfaa2cffaf967d76cec0c7e8df194" translate="yes" xml:space="preserve">
          <source>This gives back a reference to a new ndarray view, which is a view into the i-th object in the array &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt;&lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt;&lt;/a&gt;, whose dimensions and strides match the internal optimized iteration pattern. A C-order iteration of this view is equivalent to the iterator&amp;rsquo;s iteration order.</source>
          <target state="translated">これにより、配列&lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt; &lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt; の&lt;/a&gt; i番目のオブジェクトへのビューである新しいndarrayビューへの参照が返されます。このビューの次元とストライドは、内部の最適化された反復パターンと一致します。このビューのCオーダーの反復は、イテレーターの反復順序と同等です。</target>
        </trans-unit>
        <trans-unit id="5203e44570d99c05fcfa2df4337f300e46c186be" translate="yes" xml:space="preserve">
          <source>This group is used to call code that may take some time but does not use any Python C-API calls. Thus, the GIL should be released during its calculation.</source>
          <target state="translated">このグループは、時間がかかるかもしれないコードを呼び出すために使用されますが、PythonのC-APIコールは一切使用しません。したがって、GILはその計算中に解放されるべきです。</target>
        </trans-unit>
        <trans-unit id="5bcd38e59fd6cf93688e83d10245c536ddb55a3a" translate="yes" xml:space="preserve">
          <source>This group is used to re-acquire the Python GIL after it has been released. For example, suppose the GIL has been released (using the previous calls), and then some path in the code (perhaps in a different subroutine) requires use of the Python C-API, then these macros are useful to acquire the GIL. These macros accomplish essentially a reverse of the previous three (acquire the LOCK saving what state it had) and then re-release it with the saved state.</source>
          <target state="translated">このグループはPythonのGILがリリースされた後に再取得するために使用されます。例えば、GILが(前の呼び出しを使って)リリースされ、コード内のいくつかのパス(おそらく別のサブルーチン内)でPython C-APIの使用を必要としたとします。これらのマクロは基本的に前の3つの逆のことを行います(LOCKが持っていた状態を保存して取得します)。</target>
        </trans-unit>
        <trans-unit id="4ba46b0017074bb74d18814c42399e783717828c" translate="yes" xml:space="preserve">
          <source>This guide is an overview and explains the important features; details are found in &lt;a href=&quot;../reference/index#reference&quot;&gt;NumPy Reference&lt;/a&gt;.</source>
          <target state="translated">このガイドは概要であり、重要な機能について説明しています。詳細は&lt;a href=&quot;../reference/index#reference&quot;&gt;NumPyリファレンスにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="7c9e84e903bf2e483b137abd67c279312344ab01" translate="yes" xml:space="preserve">
          <source>This guide will help you decide what to contribute and how to submit it to the official NumPy documentation.</source>
          <target state="translated">このガイドは、何をコントリビュートするか、そしてそれをNumPyの公式ドキュメントに提出する方法を決めるのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="22e8bed5de814991ce18d8f44ecb60dc6c28da78" translate="yes" xml:space="preserve">
          <source>This info dict can then be used as input to a &lt;a href=&quot;../distutils#numpy.distutils.misc_util.Configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; instance:</source>
          <target state="translated">この情報辞書は、&lt;a href=&quot;../distutils#numpy.distutils.misc_util.Configuration&quot;&gt; &lt;code&gt;Configuration&lt;/code&gt; &lt;/a&gt;インスタンスへの入力として使用できます。</target>
        </trans-unit>
        <trans-unit id="594238b01d9d524cb6fb409e28f8c563967eda11" translate="yes" xml:space="preserve">
          <source>This information will be collected in writing, and whenever possible the group&amp;rsquo;s deliberations will be recorded and retained (i.e. chat transcripts, email discussions, recorded conference calls, summaries of voice conversations, etc).</source>
          <target state="translated">この情報は書面で収集され、可能な場合はいつでも、グループの審議が記録および保持されます（つまり、チャットの記録、電子メールディスカッション、記録された電話会議、音声会話の要約など）。</target>
        </trans-unit>
        <trans-unit id="11fb823e6d137af2611381a853679838cd294872" translate="yes" xml:space="preserve">
          <source>This interface describes homogeneous arrays in the sense that each item of the array has the same &amp;ldquo;type&amp;rdquo;. This type can be very simple or it can be a quite arbitrary and complicated C-like structure.</source>
          <target state="translated">このインターフェースは、配列の各項目が同じ「タイプ」を持つという意味で同種配列を記述します。このタイプは非常に単純な場合もあれば、非常に恣意的で複雑なCのような構造の場合もあります。</target>
        </trans-unit>
        <trans-unit id="669065ebaf0e163f0816c64449775393f24910fd" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;numpy.flatiter#numpy.flatiter&quot;&gt;&lt;code&gt;numpy.flatiter&lt;/code&gt;&lt;/a&gt; instance, which acts similarly to, but is not a subclass of, Python&amp;rsquo;s built-in iterator object.</source>
          <target state="translated">これは&lt;a href=&quot;numpy.flatiter#numpy.flatiter&quot;&gt; &lt;code&gt;numpy.flatiter&lt;/code&gt; &lt;/a&gt;インスタンスであり、Pythonの組み込み反復子オブジェクトと同様に機能しますが、そのサブクラスではありません。</target>
        </trans-unit>
        <trans-unit id="c616752b11f5b5590e848100c7afe1eff6eb31fb" translate="yes" xml:space="preserve">
          <source>This is a convenience function for quick storage of array data. Information on endianness and precision is lost, so this method is not a good choice for files intended to archive data or transport data between machines with different endianness. Some of these problems can be overcome by outputting the data as text files, at the expense of speed and file size.</source>
          <target state="translated">配列データを素早く保存するための便利な機能です。エンディアンと精度に関する情報は失われるので,データをアーカイブすることを目的としたファイルや,エンディアンの異なるマシン間でデータを転送することを目的としたファイルには,この方法は適していません.これらの問題のいくつかは、速度とファイルサイズを犠牲にしても、データをテキストファイルとして出力することで克服することができます。</target>
        </trans-unit>
        <trans-unit id="e143678de16b85b14841ff12151066d84f46e8b0" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、Matlabからコードを移植するユーザーにとって便利な関数であり、&lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt; &lt;code&gt;random_sample&lt;/code&gt; &lt;/a&gt;をラップします。この関数は、出力のサイズを指定するためにタプルを取ります。これは、&lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; &lt;/a&gt;などの他のNumPy関数と一致しています。</target>
        </trans-unit>
        <trans-unit id="7a6640731207cc17f5b282e72b4960d28e172178" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;a href=&quot;numpy.random.randomstate.random_sample#numpy.random.RandomState.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、Matlabからコードを移植するユーザーにとって便利な関数であり、&lt;a href=&quot;numpy.random.randomstate.random_sample#numpy.random.RandomState.random_sample&quot;&gt; &lt;code&gt;random_sample&lt;/code&gt; &lt;/a&gt;をラップします。この関数は、出力のサイズを指定するためにタプルを取ります。これは、&lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; &lt;/a&gt;などの他のNumPy関数と一致しています。</target>
        </trans-unit>
        <trans-unit id="e91ed9ba3b995348d0b712c7cd0f68c854820dd9" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;a href=&quot;numpy.random.randomstate.standard_normal#numpy.random.RandomState.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、Matlabからコードを移植するユーザーにとって便利な関数であり、&lt;a href=&quot;numpy.random.randomstate.standard_normal#numpy.random.RandomState.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; &lt;/a&gt;をラップします。この関数は、出力のサイズを指定するためにタプルを取ります。これは、&lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; &lt;/a&gt;などの他のNumPy関数と一致しています。</target>
        </trans-unit>
        <trans-unit id="637f2f7f4587e6fab14f3bc29737254f8ece5452" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;a href=&quot;numpy.random.standard_normal#numpy.random.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、Matlabからコードを移植するユーザーにとって便利な関数であり、&lt;a href=&quot;numpy.random.standard_normal#numpy.random.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; &lt;/a&gt;をラップします。この関数は、出力のサイズを指定するためにタプルを取ります。これは、&lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; &lt;/a&gt;などの他のNumPy関数と一致しています。</target>
        </trans-unit>
        <trans-unit id="aebce3c953e4d7a8aa40a69097fcdae621194f4a" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;code&gt;numpy.random.random_sample&lt;/code&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、Matlabからコードを移植するユーザーにとって便利な関数であり、 &lt;code&gt;numpy.random.random_sample&lt;/code&gt; をラップします。この関数はタプルを使用して出力のサイズを指定します。これは、&lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; &lt;/a&gt;などの他のNumPy関数と一致しています。</target>
        </trans-unit>
        <trans-unit id="8a8395276aef2b1c09ac3507c06c6aeae1c56edd" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;code&gt;numpy.random.standard_normal&lt;/code&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、Matlabからコードを移植するユーザーにとって便利な関数であり、 &lt;code&gt;numpy.random.standard_normal&lt;/code&gt; をラップします。この関数はタプルを使用して出力のサイズを指定します。これは、&lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; &lt;/a&gt;などの他のNumPy関数と一致しています。</target>
        </trans-unit>
        <trans-unit id="14bed771c7ecf5fb5c7f3988c3e80ea720b90d56" translate="yes" xml:space="preserve">
          <source>This is a convenience, legacy function.</source>
          <target state="translated">これは便利なレガシー機能です。</target>
        </trans-unit>
        <trans-unit id="8386d98dd4fd3fd3372da264e738d2eec8c472de" translate="yes" xml:space="preserve">
          <source>This is a default converter for output arrays given to functions. If &lt;em&gt;obj&lt;/em&gt; is &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt;&lt;code&gt;Py_None&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;NULL&lt;/code&gt;, then &lt;em&gt;*address&lt;/em&gt; will be &lt;code&gt;NULL&lt;/code&gt; but the call will succeed. If &lt;a href=&quot;#c.PyArray_Check&quot;&gt;&lt;code&gt;PyArray_Check&lt;/code&gt;&lt;/a&gt; ( &lt;em&gt;obj&lt;/em&gt;) is TRUE then it is returned in &lt;em&gt;*address&lt;/em&gt; without incrementing its reference count.</source>
          <target state="translated">これは、関数に指定された出力配列のデフォルトのコンバーターです。場合&lt;em&gt;objが&lt;/em&gt;ある&lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt; &lt;code&gt;Py_None&lt;/code&gt; &lt;/a&gt;または &lt;code&gt;NULL&lt;/code&gt; 、その後、&lt;em&gt;*アドレスは&lt;/em&gt;なり &lt;code&gt;NULL&lt;/code&gt; が、呼び出しが成功します。場合&lt;a href=&quot;#c.PyArray_Check&quot;&gt; &lt;code&gt;PyArray_Check&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;objが&lt;/em&gt;）TRUEであるそれはで返される&lt;em&gt;*アドレス&lt;/em&gt;参照カウントをインクリメントせず。</target>
        </trans-unit>
        <trans-unit id="ebf6bd0b70f0575c64ee3df5fdd00ac441de460d" translate="yes" xml:space="preserve">
          <source>This is a function equivalent to C99 copysign: return x with the same sign as y. Works for any value, including inf and nan. Single and extended precisions are available with suffix f and l.</source>
          <target state="translated">これは,C99 の copysign と同等の関数です:y と同じ符号を持つ x を返します.接尾辞 f と l を指定することで,単一精度と拡張精度が利用できます.</target>
        </trans-unit>
        <trans-unit id="9c5d9b74232b5b43fdac1227d638313277afa572" translate="yes" xml:space="preserve">
          <source>This is a function equivalent to C99 nextafter: return next representable floating point value from x in the direction of y. Single and extended precisions are available with suffix f and l.</source>
          <target state="translated">これは,C99 nextafter と同等の関数です:x から y 方向に次の表現可能な浮動小数点値を返します.</target>
        </trans-unit>
        <trans-unit id="6cef9e65ee084ca1f09a67a21a4b3ef4b9523383" translate="yes" xml:space="preserve">
          <source>This is a function equivalent to Fortran intrinsic. Return distance between x and next representable floating point value from x, e.g. spacing(1) == eps. spacing of nan and +/- inf return nan. Single and extended precisions are available with suffix f and l.</source>
          <target state="translated">これはFortranの内部関数と同等の関数です。x と x からの次の表現可能な浮動小数点値の間の距離を返します。例えば spacing(1)==eps.nan の間隔と +/-inf は nan を返します。接尾辞fとlを指定することで,単一の精度と拡張された精度を得ることができます.</target>
        </trans-unit>
        <trans-unit id="f691a7cca2d5bab9d5322a451f5071b060431b18" translate="yes" xml:space="preserve">
          <source>This is a function pointer for getting the current iterator multi-index, returned by &lt;a href=&quot;#c.NpyIter_GetGetMultiIndex&quot;&gt;&lt;code&gt;NpyIter_GetGetMultiIndex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、&lt;a href=&quot;#c.NpyIter_GetGetMultiIndex&quot;&gt; &lt;code&gt;NpyIter_GetGetMultiIndex&lt;/code&gt; &lt;/a&gt;によって返される、現在のイテレータマルチインデックスを取得するための関数ポインタです。</target>
        </trans-unit>
        <trans-unit id="afe9f9d9e5612f0c43f0b6f2ab1ddbf98d2077ed" translate="yes" xml:space="preserve">
          <source>This is a function pointer for the iteration loop, returned by &lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt;&lt;code&gt;NpyIter_GetIterNext&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、&lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt; &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt; &lt;/a&gt;によって返される、反復ループの関数ポインターです。</target>
        </trans-unit>
        <trans-unit id="682e5efdefc09e15bb711f19c6e22c6512c8e3c9" translate="yes" xml:space="preserve">
          <source>This is a list of flags for each operand. At minimum, one of &lt;code&gt;readonly&lt;/code&gt;, &lt;code&gt;readwrite&lt;/code&gt;, or &lt;code&gt;writeonly&lt;/code&gt; must be specified.</source>
          <target state="translated">これは、各オペランドのフラグのリストです。少なくとも、 &lt;code&gt;readonly&lt;/code&gt; 、 &lt;code&gt;readwrite&lt;/code&gt; 、または &lt;code&gt;writeonly&lt;/code&gt; のいずれかを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="daee1c27087ebe5008ffab37bf86e6cef5520692" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 isfinite: works for single, double and extended precision, and return a non 0 value is x is neither a NaN nor an infinity.</source>
          <target state="translated">これはマクロで、C99のisfiniteと同等です。単精度、倍精度、拡張精度で動作し、xがNaNでも無限大でもない場合、0ではない値を返します。</target>
        </trans-unit>
        <trans-unit id="80381bd72606c65ade88008349bbceb47f771261" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 isinf: works for single, double and extended precision, and return a non 0 value is x is infinite (positive and negative).</source>
          <target state="translated">これはマクロで、C99 isinf:と同等です。単精度、倍精度、拡張精度で動作し、0でない値を返します。</target>
        </trans-unit>
        <trans-unit id="0a2766c5fc1ee9982025de76ae4aa9f68ecd22db" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 isnan: works for single, double and extended precision, and return a non 0 value is x is a NaN.</source>
          <target state="translated">これはマクロであり、C99 isnanと同等です:単精度、倍精度、拡張精度で動作し、0ではない値を返します。</target>
        </trans-unit>
        <trans-unit id="ba072edcddb8314e48393832fd145a168df5e278" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 signbit: works for single, double and extended precision, and return a non 0 value is x has the signbit set (that is the number is negative).</source>
          <target state="translated">これはマクロであり、C99 signbitと同等です:単精度、倍精度、拡張精度で動作し、0以外の値を返します。</target>
        </trans-unit>
        <trans-unit id="90bdfe8753787f61c5537ce6dde698f20d3651a1" translate="yes" xml:space="preserve">
          <source>This is a quick overview of algebra and arrays in NumPy. It demonstrates how n-dimensional (</source>
          <target state="translated">NumPyの代数と配列の概要を簡単に説明します。これは、どのようにしてn-dimensional (</target>
        </trans-unit>
        <trans-unit id="e912c91523a3cdb66f72696d355ab45d0a9a414f" translate="yes" xml:space="preserve">
          <source>This is a relatively robust method to compare two arrays whose amplitude is variable.</source>
          <target state="translated">これは、振幅が可変である2つの配列を比較するための比較的堅牢な方法です。</target>
        </trans-unit>
        <trans-unit id="f9e98f643e268bceb892d520470f87f06bd3ffa1" translate="yes" xml:space="preserve">
          <source>This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="daaf8424b18b172abdada56262484be0114cb050" translate="yes" xml:space="preserve">
          <source>This is a setup.py file for the above code. As before, the module can be build via calling python setup.py build at the command prompt, or installed to site-packages via python setup.py install.</source>
          <target state="translated">これは上記のコードのsetup.pyファイルです。先ほどと同様に、コマンドプロンプトから python setup.py build を呼び出してモジュールをビルドしたり、 python setup.py install を使ってサイトパッケージにインストールしたりすることができます。</target>
        </trans-unit>
        <trans-unit id="5b6ff4b3ee0d226dd43f100afc9a5e9fc743a95d" translate="yes" xml:space="preserve">
          <source>This is a simple way to build up arrays quickly. There are two use cases.</source>
          <target state="translated">配列を素早く構築するためのシンプルな方法です。2つのユースケースがあります。</target>
        </trans-unit>
        <trans-unit id="5bf246dfc26ef7aa2b64da9e4b03eace45db2857" translate="yes" xml:space="preserve">
          <source>This is a special flag that is set if this array represents a copy made because a user required certain flags in &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; and a copy had to be made of some other array (and the user asked for this flag to be set in such a situation). The base attribute then points to the &amp;ldquo;misbehaved&amp;rdquo; array (which is set read_only). :c:func`PyArray_ResolveWritebackIfCopy` will copy its contents back to the &amp;ldquo;misbehaved&amp;rdquo; array (casting if necessary) and will reset the &amp;ldquo;misbehaved&amp;rdquo; array to &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;. If the &amp;ldquo;misbehaved&amp;rdquo; array was not &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; to begin with then &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; would have returned an error because &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; would not have been possible.</source>
          <target state="translated">これは、ユーザーが&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; に&lt;/a&gt;特定のフラグを必要とし、コピーを他の配列で作成する必要があったために、この配列がコピーを表す場合に設定される特別なフラグです（このような状況では、ユーザーがこのフラグの設定を要求しました）。 。次に、base属性は「誤動作」配列（read_onlyに設定されている）を指します。 ：c：func`PyArray_ResolveWritebackIfCopy`は、その内容を「誤動作」配列にコピーし（必要に応じてキャスト）、「誤動作」配列を&lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; に&lt;/a&gt;リセットします。 「misbehaved」アレイなかった場合&lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;その後、そもそも&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; が&lt;/a&gt;あるため、エラーが返されていた&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; は&lt;/a&gt;不可能でした。</target>
        </trans-unit>
        <trans-unit id="d494bbd6ea4e55e23b6320030cf19b92084fb2cb" translate="yes" xml:space="preserve">
          <source>This is a very flexible function; &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.array_str#numpy.array_str&quot;&gt;&lt;code&gt;array_str&lt;/code&gt;&lt;/a&gt; are using &lt;a href=&quot;#numpy.array2string&quot;&gt;&lt;code&gt;array2string&lt;/code&gt;&lt;/a&gt; internally so keywords with the same name should work identically in all three functions.</source>
          <target state="translated">これは非常に柔軟な機能です。&lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;numpy.array_str#numpy.array_str&quot;&gt; &lt;code&gt;array_str&lt;/code&gt; &lt;/a&gt;使用している&lt;a href=&quot;#numpy.array2string&quot;&gt; &lt;code&gt;array2string&lt;/code&gt; &lt;/a&gt;ので、キーワードと同じ名前はすべての3つの機能で同じ動作するはずで、内部。</target>
        </trans-unit>
        <trans-unit id="4a20d6c5e13bf5949cf2f01fed00be4a85ee83c8" translate="yes" xml:space="preserve">
          <source>This is a wrapper around &lt;code&gt;cPickle.dump&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;cPickle.dump&lt;/code&gt; のラッパーです。</target>
        </trans-unit>
        <trans-unit id="72c0baacc027dca1b05db754f60ee813fa6dbfcf" translate="yes" xml:space="preserve">
          <source>This is a wrapper around &lt;code&gt;cPickle.dumps&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;cPickle.dumps&lt;/code&gt; のラッパーです。</target>
        </trans-unit>
        <trans-unit id="b6ae9c5b7de866ac0dd1b4b58c7a54bd18149043" translate="yes" xml:space="preserve">
          <source>This is almost the same as the result of PyArray_CanCastTypeTo(PyArray_MinScalarType(arr), totype, casting), but it also handles a special case arising because the set of uint values is not a subset of the int values for types with the same number of bits.</source>
          <target state="translated">これは PyArray_CanCastTypeTo(PyArray_MinScalarType(arr),totype,casting)の結果とほぼ同じですが、同じビット数の型に対して uint 値の集合が int 値のサブセットではないために発生する特殊なケースも処理しています。</target>
        </trans-unit>
        <trans-unit id="06d558ced35712eb9368208c693942a96aac9510" translate="yes" xml:space="preserve">
          <source>This is an alias of &lt;a href=&quot;generated/numpy.random.random_sample#numpy.random.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは&lt;a href=&quot;generated/numpy.random.random_sample#numpy.random.random_sample&quot;&gt; &lt;code&gt;random_sample&lt;/code&gt; の&lt;/a&gt;エイリアスです。</target>
        </trans-unit>
        <trans-unit id="6be9e8aa17773bdb0efb0eec1cc4294398d93d4d" translate="yes" xml:space="preserve">
          <source>This is an alias of &lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt; for the complete documentation.</source>
          <target state="translated">これは&lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt; &lt;code&gt;random_sample&lt;/code&gt; の&lt;/a&gt;エイリアスです。完全なドキュメントについては、&lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt; &lt;code&gt;random_sample&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="abef17cd5a41150617b797dd34026cad2a72bcf3" translate="yes" xml:space="preserve">
          <source>This is an example of a func specialized for addition of doubles returning doubles.</source>
          <target state="translated">これは、ダブルスを返すダブルスの加算に特化したFuncの例です。</target>
        </trans-unit>
        <trans-unit id="8d1fbd89490e7598a40d0ab430364ea01d0cff36" translate="yes" xml:space="preserve">
          <source>This is an interface to the LAPACK routines &lt;code&gt;dgeqrf&lt;/code&gt;, &lt;code&gt;zgeqrf&lt;/code&gt;, &lt;code&gt;dorgqr&lt;/code&gt;, and &lt;code&gt;zungqr&lt;/code&gt;.</source>
          <target state="translated">これは、LAPACKルーチン &lt;code&gt;dgeqrf&lt;/code&gt; 、 &lt;code&gt;zgeqrf&lt;/code&gt; 、 &lt;code&gt;dorgqr&lt;/code&gt; 、および &lt;code&gt;zungqr&lt;/code&gt; へのインターフェースです。</target>
        </trans-unit>
        <trans-unit id="944d000b70e8d3d375939368b9ee8662949fdd56" translate="yes" xml:space="preserve">
          <source>This is an iterator object that makes it easy to loop over an N-dimensional array. It is the object returned from the flat attribute of an ndarray. It is also used extensively throughout the implementation internals to loop over an N-dimensional array. The tp_as_mapping interface is implemented so that the iterator object can be indexed (using 1-d indexing), and a few methods are implemented through the tp_methods table. This object implements the next method and can be used anywhere an iterator can be used in Python.</source>
          <target state="translated">N次元配列を簡単にループさせるためのイテレータオブジェクトです。ndarrayのflat属性から返されるオブジェクトです。また,実装内部では,N次元配列をループさせるために広く利用されています.tp_as_mappingインターフェースは、イテレータオブジェクトにインデックスを付けられるように実装されており(1次元インデックスを使用)、いくつかのメソッドがtp_methodsテーブルを通して実装されています。このオブジェクトは次のメソッドを実装しており、Pythonでイテレータが使える場所ならどこでも使えます。</target>
        </trans-unit>
        <trans-unit id="39877197a88959914be74b4d252daeba988b0567" translate="yes" xml:space="preserve">
          <source>This is an iterator object that makes it easy to loop over an N-dimensional neighborhood.</source>
          <target state="translated">これは、N次元の近傍をループすることを容易にするイテレータオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="ed4488f4638f84c1e1e4b827cf0b8579c8c851e4" translate="yes" xml:space="preserve">
          <source>This is an opaque pointer type for the iterator. Access to its contents can only be done through the iterator API.</source>
          <target state="translated">これは、イテレータ用の不透明なポインタ型です。その内容へのアクセスは、イテレータ API を通してのみ可能です。</target>
        </trans-unit>
        <trans-unit id="b4c12ec7da04774c2971488c28da077dd954ab73" translate="yes" xml:space="preserve">
          <source>This is defined for &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;, &lt;strong&gt;SHORT&lt;/strong&gt;, &lt;strong&gt;INT&lt;/strong&gt;, &lt;strong&gt;LONG&lt;/strong&gt;, &lt;strong&gt;LONGLONG&lt;/strong&gt;, &lt;strong&gt;INTP&lt;/strong&gt;</source>
          <target state="translated">これは &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;、&lt;strong&gt;SHORT&lt;/strong&gt;、&lt;strong&gt;INT&lt;/strong&gt;、&lt;strong&gt;LONG&lt;/strong&gt;、&lt;strong&gt;LONGLONG&lt;/strong&gt;、&lt;strong&gt;INTP&lt;/strong&gt;に対して定義されてい&lt;strong&gt;ます&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1cb38ad4a8a5f0f7eaad9358f9b24fff730b48c2" translate="yes" xml:space="preserve">
          <source>This is defined for all defined for &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;, &lt;strong&gt;UBYTE&lt;/strong&gt;, &lt;strong&gt;SHORT&lt;/strong&gt;, &lt;strong&gt;USHORT&lt;/strong&gt;, &lt;strong&gt;INT&lt;/strong&gt;, &lt;strong&gt;UINT&lt;/strong&gt;, &lt;strong&gt;LONG&lt;/strong&gt;, &lt;strong&gt;ULONG&lt;/strong&gt;, &lt;strong&gt;LONGLONG&lt;/strong&gt;, &lt;strong&gt;ULONGLONG&lt;/strong&gt;, &lt;strong&gt;INTP&lt;/strong&gt;, &lt;strong&gt;UINTP&lt;/strong&gt;</source>
          <target state="translated">これは、 &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;、&lt;strong&gt;UBYTE&lt;/strong&gt;、&lt;strong&gt;SHORT&lt;/strong&gt;、&lt;strong&gt;USHORT&lt;/strong&gt;、&lt;strong&gt;INT&lt;/strong&gt;、&lt;strong&gt;UINT&lt;/strong&gt;、&lt;strong&gt;LONG&lt;/strong&gt;、&lt;strong&gt;ULONG&lt;/strong&gt;、&lt;strong&gt;LONGLONG&lt;/strong&gt;、&lt;strong&gt;ULONGLONG&lt;/strong&gt;、&lt;strong&gt;INTP&lt;/strong&gt;、&lt;strong&gt;UINTP&lt;/strong&gt;に対して定義されたすべてに対して定義されます&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e53b90b8b35ae60046587f59e89f7b60e6df85a" translate="yes" xml:space="preserve">
          <source>This is different from &lt;a href=&quot;numpy.load#numpy.load&quot;&gt;&lt;code&gt;numpy.load&lt;/code&gt;&lt;/a&gt;, which does not use cPickle but loads the NumPy binary .npy format.</source>
          <target state="translated">これは、&lt;a href=&quot;numpy.load#numpy.load&quot;&gt; &lt;code&gt;numpy.load&lt;/code&gt; &lt;/a&gt;使用せずにNumPyバイナリ.npy形式をロードするnumpy.loadとは異なります。</target>
        </trans-unit>
        <trans-unit id="ad4d2eb9b0ee11d28c4e5a349ba480c6768dfc79" translate="yes" xml:space="preserve">
          <source>This is equivalent to (but faster than) the following use of &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt; and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">これは、次の&lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; の&lt;/a&gt;使用と同等です（ただし高速です）。これにより、 &lt;code&gt;ii&lt;/code&gt; と &lt;code&gt;kk&lt;/code&gt; のそれぞれがインデックスのタプルに設定されます。</target>
        </trans-unit>
        <trans-unit id="f5170749efab413ba3776c33568562d9c4634a7d" translate="yes" xml:space="preserve">
          <source>This is equivalent to (but faster than) the following use of &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt;, &lt;code&gt;jj&lt;/code&gt;, and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">これは、次の&lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; の&lt;/a&gt;使用と同等です（ただし、それよりも高速です）。これにより、 &lt;code&gt;ii&lt;/code&gt; 、 &lt;code&gt;jj&lt;/code&gt; 、および &lt;code&gt;kk&lt;/code&gt; のそれぞれがインデックスのタプルに設定されます。</target>
        </trans-unit>
        <trans-unit id="f723a36a0fdceaf5add767f4dfa10dbdef0cf27e" translate="yes" xml:space="preserve">
          <source>This is equivalent to (but faster than) the following use of &lt;code&gt;ndindex&lt;/code&gt; and &lt;code&gt;s_&lt;/code&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt;, &lt;code&gt;jj&lt;/code&gt;, and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">これは、次の &lt;code&gt;ndindex&lt;/code&gt; および &lt;code&gt;s_&lt;/code&gt; の使用と同等です（ただし、それよりも高速です）。これにより、 &lt;code&gt;ii&lt;/code&gt; 、 &lt;code&gt;jj&lt;/code&gt; 、および &lt;code&gt;kk&lt;/code&gt; のそれぞれがインデックスのタプルに設定されます。</target>
        </trans-unit>
        <trans-unit id="9623032760a445ce084ed7cad1f49c8e81cbc730" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.compress(ravel(condition), ravel(arr))&lt;/code&gt;. If &lt;code&gt;condition&lt;/code&gt; is boolean &lt;code&gt;np.extract&lt;/code&gt; is equivalent to &lt;code&gt;arr[condition]&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;np.compress(ravel(condition), ravel(arr))&lt;/code&gt; と同等です。 &lt;code&gt;condition&lt;/code&gt; がブールの場合、 &lt;code&gt;np.extract&lt;/code&gt; は &lt;code&gt;arr[condition]&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="270d637e7c2130210ad3ee654e7e3067ac01221d" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.ma.compress_rowcols(a, 0)&lt;/code&gt;, see &lt;a href=&quot;numpy.ma.compress_rowcols#numpy.ma.compress_rowcols&quot;&gt;&lt;code&gt;compress_rowcols&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">これは &lt;code&gt;np.ma.compress_rowcols(a, 0)&lt;/code&gt; と同等です。詳細については、&lt;a href=&quot;numpy.ma.compress_rowcols#numpy.ma.compress_rowcols&quot;&gt; &lt;code&gt;compress_rowcols&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="512416aca8fa4fb317d305f7a3902a8f4f57268d" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.ma.compress_rowcols(a, 0)&lt;/code&gt;, see &lt;code&gt;extras.compress_rowcols&lt;/code&gt; for details.</source>
          <target state="translated">これは &lt;code&gt;np.ma.compress_rowcols(a, 0)&lt;/code&gt; と同等です。詳細は &lt;code&gt;extras.compress_rowcols&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="f6ffd133d65cdedb57e33b341f8909e0c883dd56" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.ma.compress_rowcols(a, 1)&lt;/code&gt;, see &lt;a href=&quot;numpy.ma.compress_rowcols#numpy.ma.compress_rowcols&quot;&gt;&lt;code&gt;compress_rowcols&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">これは &lt;code&gt;np.ma.compress_rowcols(a, 1)&lt;/code&gt; と同等です。詳細については、&lt;a href=&quot;numpy.ma.compress_rowcols#numpy.ma.compress_rowcols&quot;&gt; &lt;code&gt;compress_rowcols&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1aabefa5df0b67ecae64f8e5a2fb2a4d5dd2e5ee" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.ma.compress_rowcols(a, 1)&lt;/code&gt;, see &lt;code&gt;extras.compress_rowcols&lt;/code&gt; for details.</source>
          <target state="translated">これは &lt;code&gt;np.ma.compress_rowcols(a, 1)&lt;/code&gt; と同等です。詳細は &lt;code&gt;extras.compress_rowcols&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="2e12dd8fc795d33b8f8bcabb847c3e158c738c5e" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the first axis after 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N)&lt;/code&gt;. Rebuilds arrays divided by &lt;a href=&quot;numpy.vsplit#numpy.vsplit&quot;&gt;&lt;code&gt;vsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、形状 &lt;code&gt;(N,)&lt;/code&gt; 1次元配列が &lt;code&gt;(1,N)&lt;/code&gt; 再形成された後の最初の軸に沿った連結に相当します。&lt;a href=&quot;numpy.vsplit#numpy.vsplit&quot;&gt; &lt;code&gt;vsplit&lt;/code&gt; で&lt;/a&gt;分割された配列を再構築します。</target>
        </trans-unit>
        <trans-unit id="8a1612db7b39849ef3a6bd08b64bed8c3240f816" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the first axis after 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N)&lt;/code&gt;. Rebuilds arrays divided by &lt;code&gt;vsplit&lt;/code&gt;.</source>
          <target state="translated">これは、形状 &lt;code&gt;(N,)&lt;/code&gt; 1次元配列が &lt;code&gt;(1,N)&lt;/code&gt; 再形成された後の最初の軸に沿った連結に相当します。 &lt;code&gt;vsplit&lt;/code&gt; で分割された配列を再構築します。</target>
        </trans-unit>
        <trans-unit id="e9676c88264ef3cd76556860f143548d10e94eb6" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the second axis, except for 1-D arrays where it concatenates along the first axis. Rebuilds arrays divided by &lt;a href=&quot;numpy.hsplit#numpy.hsplit&quot;&gt;&lt;code&gt;hsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、最初の軸に沿って連結する1次元配列を除いて、2番目の軸に沿った連結と同等です。&lt;a href=&quot;numpy.hsplit#numpy.hsplit&quot;&gt; &lt;code&gt;hsplit&lt;/code&gt; で&lt;/a&gt;分割された配列を再構築します。</target>
        </trans-unit>
        <trans-unit id="e6a5b26fca5a2a732affc24a30a8305bc7f4ee4d" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the second axis, except for 1-D arrays where it concatenates along the first axis. Rebuilds arrays divided by &lt;a href=&quot;numpy.ma.hsplit#numpy.ma.hsplit&quot;&gt;&lt;code&gt;hsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、最初の軸に沿って連結する1次元配列を除いて、2番目の軸に沿った連結と同等です。&lt;a href=&quot;numpy.ma.hsplit#numpy.ma.hsplit&quot;&gt; &lt;code&gt;hsplit&lt;/code&gt; で&lt;/a&gt;分割された配列を再構築します。</target>
        </trans-unit>
        <trans-unit id="5f3f85e2c1a9f572b9f43cddeb78f8794cecabcf" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the third axis after 2-D arrays of shape &lt;code&gt;(M,N)&lt;/code&gt; have been reshaped to &lt;code&gt;(M,N,1)&lt;/code&gt; and 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N,1)&lt;/code&gt;. Rebuilds arrays divided by &lt;a href=&quot;numpy.dsplit#numpy.dsplit&quot;&gt;&lt;code&gt;dsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、形状の2次元配列した後第3の軸に沿って連結と等価である &lt;code&gt;(M,N)&lt;/code&gt; に整形されている &lt;code&gt;(M,N,1)&lt;/code&gt; 及び形状の1-Dアレイ &lt;code&gt;(N,)&lt;/code&gt; に整形されている &lt;code&gt;(1,N,1)&lt;/code&gt; 。&lt;a href=&quot;numpy.dsplit#numpy.dsplit&quot;&gt; &lt;code&gt;dsplit&lt;/code&gt; で&lt;/a&gt;分割された配列を再構築します。</target>
        </trans-unit>
        <trans-unit id="5c6f9c31ab715a660b4d23dc2f49389f45ea5bda" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the third axis after 2-D arrays of shape &lt;code&gt;(M,N)&lt;/code&gt; have been reshaped to &lt;code&gt;(M,N,1)&lt;/code&gt; and 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N,1)&lt;/code&gt;. Rebuilds arrays divided by &lt;code&gt;dsplit&lt;/code&gt;.</source>
          <target state="translated">これは、形状の2次元配列した後第3の軸に沿って連結と等価である &lt;code&gt;(M,N)&lt;/code&gt; に整形されている &lt;code&gt;(M,N,1)&lt;/code&gt; 及び形状の1-Dアレイ &lt;code&gt;(N,)&lt;/code&gt; に整形されている &lt;code&gt;(1,N,1)&lt;/code&gt; 。 &lt;code&gt;dsplit&lt;/code&gt; で分割された配列を再構築します。</target>
        </trans-unit>
        <trans-unit id="d218a0a3e8c4c5860255504a9ba19c22b6fab14a" translate="yes" xml:space="preserve">
          <source>This is equivalent to np.nonzero(np.ravel(a))[0].</source>
          <target state="translated">これは、np.nonzero(np.ravel(a))[0]と等価です。</target>
        </trans-unit>
        <trans-unit id="c1506fb5159fec603ce600935782977e9cc4a640" translate="yes" xml:space="preserve">
          <source>This is equivalent to the &lt;code&gt;density&lt;/code&gt; argument, but produces incorrect results for unequal bin widths. It should not be used.</source>
          <target state="translated">これは、 &lt;code&gt;density&lt;/code&gt; 引数と同等ですが、ビンの幅が等しくない場合、誤った結果が生成されます。使用しないでください。</target>
        </trans-unit>
        <trans-unit id="59cfbae4022883700bb27212977a0aea4a1ca893" translate="yes" xml:space="preserve">
          <source>This is equivalent to the buffer object structure in Python up to the ptr member. On 32-bit platforms (&lt;em&gt;i.e.&lt;/em&gt; if &lt;a href=&quot;c-api.config#c.NPY_SIZEOF_INT&quot;&gt;&lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt;&lt;/a&gt; == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt;), the len member also matches an equivalent member of the buffer object. It is useful to represent a generic single-segment chunk of memory.</source>
          <target state="translated">これは、ptrメンバーまでのPythonのバッファーオブジェクト構造に相当します。32ビットプラットフォームでは（&lt;em&gt;つまり&lt;/em&gt;、&lt;a href=&quot;c-api.config#c.NPY_SIZEOF_INT&quot;&gt; &lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt; &lt;/a&gt; == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt; の場合）、lenメンバーは、バッファーオブジェクトの同等のメンバーとも一致します。一般的な単一セグメントのメモリチャンクを表すと便利です。</target>
        </trans-unit>
        <trans-unit id="4854fe34aab22a7dfbbaf3a63f41795215d42fdd" translate="yes" xml:space="preserve">
          <source>This is equivalent to the buffer object structure in Python up to the ptr member. On 32-bit platforms (&lt;em&gt;i.e.&lt;/em&gt; if &lt;a href=&quot;config#c.NPY_SIZEOF_INT&quot;&gt;&lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt;&lt;/a&gt; == &lt;a href=&quot;config#c.NPY_SIZEOF_INTP&quot;&gt;&lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt;&lt;/a&gt;), the len member also matches an equivalent member of the buffer object. It is useful to represent a generic single-segment chunk of memory.</source>
          <target state="translated">これは、ptrメンバーまでのPythonのバッファオブジェクト構造に相当します。32ビットプラットフォームでは（&lt;em&gt;つまり&lt;/em&gt;、&lt;a href=&quot;config#c.NPY_SIZEOF_INT&quot;&gt; &lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt; &lt;/a&gt; == &lt;a href=&quot;config#c.NPY_SIZEOF_INTP&quot;&gt; &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt; の&lt;/a&gt;場合）、lenメンバーはバッファオブジェクトの同等のメンバーとも一致します。一般的な単一セグメントのメモリチャンクを表すと便利です。</target>
        </trans-unit>
        <trans-unit id="0f80c76f4b696fc66848fb5ef4ea2fb36f89e0f9" translate="yes" xml:space="preserve">
          <source>This is equivalent to the buffer object structure in Python up to the ptr member. On 32-bit platforms (&lt;em&gt;i.e.&lt;/em&gt; if &lt;a href=&quot;config#c.NPY_SIZEOF_INT&quot;&gt;&lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt;&lt;/a&gt; == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt;), the len member also matches an equivalent member of the buffer object. It is useful to represent a generic single-segment chunk of memory.</source>
          <target state="translated">これは、ptrメンバーまでのPythonのバッファオブジェクト構造に相当します。32ビットプラットフォーム（&lt;em&gt;つまり&lt;/em&gt;、&lt;a href=&quot;config#c.NPY_SIZEOF_INT&quot;&gt; &lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt; &lt;/a&gt; == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt; の場合）では、lenメンバーはバッファオブジェクトの同等のメンバーとも一致します。一般的な単一セグメントのメモリチャンクを表すと便利です。</target>
        </trans-unit>
        <trans-unit id="0c4a19f41f357e975c7ecf272280bda06a0a7837" translate="yes" xml:space="preserve">
          <source>This is equivalent to:</source>
          <target state="translated">に相当します。</target>
        </trans-unit>
        <trans-unit id="71a0da6263af85d6d95df709a66cce1cab814a13" translate="yes" xml:space="preserve">
          <source>This is for output arrays, and requires that the flag &lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt;&lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt;&lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt;&lt;/a&gt; be set. If &lt;code&gt;op[i]&lt;/code&gt; is NULL, creates a new array with the final broadcast dimensions, and a layout matching the iteration order of the iterator.</source>
          <target state="translated">これは出力配列用であり、フラグ&lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt; &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt; &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; &lt;/a&gt;を設定する必要があります。 &lt;code&gt;op[i]&lt;/code&gt; がNULLの場合、最終的なブロードキャストの次元と、反復子の反復順序に一致するレイアウトで新しい配列を作成します。</target>
        </trans-unit>
        <trans-unit id="e43476e1c5b08d4915c75da838fbd060f4d5522a" translate="yes" xml:space="preserve">
          <source>This is how subclasses of the ndarray class are able to return views that preserve the class type. When taking a view, the standard ndarray machinery creates the new ndarray object with something like:</source>
          <target state="translated">このようにして、ndarray クラスのサブクラスはクラス型を保持したビューを返すことができます。ビューを取得するとき、標準的なndarrayの機械は次のようにして新しいndarrayオブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="271064c73ce5e7dc4de339611f7b4db1a780a7f2" translate="yes" xml:space="preserve">
          <source>This is implemented using the &lt;code&gt;_geev&lt;/code&gt; LAPACK routines which compute the eigenvalues and eigenvectors of general square arrays.</source>
          <target state="translated">これは、一般的な正方配列の固有値と固有ベクトルを計算する &lt;code&gt;_geev&lt;/code&gt; LAPACKルーチンを使用して実装されます。</target>
        </trans-unit>
        <trans-unit id="caec4ff4a054237a51c7a499531b302398f70bf8" translate="yes" xml:space="preserve">
          <source>This is indicated in the documentation via input parameter specifications such as &lt;code&gt;a : (..., M, M) array_like&lt;/code&gt;. This means that if for instance given an input array &lt;code&gt;a.shape == (N, M, M)&lt;/code&gt;, it is interpreted as a &amp;ldquo;stack&amp;rdquo; of N matrices, each of size M-by-M. Similar specification applies to return values, for instance the determinant has &lt;code&gt;det : (...)&lt;/code&gt; and will in this case return an array of shape &lt;code&gt;det(a).shape == (N,)&lt;/code&gt;. This generalizes to linear algebra operations on higher-dimensional arrays: the last 1 or 2 dimensions of a multidimensional array are interpreted as vectors or matrices, as appropriate for each operation.</source>
          <target state="translated">これは &lt;code&gt;a : (..., M, M) array_like&lt;/code&gt; などの入力パラメーター仕様を介してドキュメントに示されています。これは、たとえば入力配列 &lt;code&gt;a.shape == (N, M, M)&lt;/code&gt; が指定された場合、それぞれがM行M列のサイズのN個の行列の「スタック」として解釈されることを意味します。同様の仕様が戻り値に適用されます。たとえば、行列式には &lt;code&gt;det : (...)&lt;/code&gt; あり、この場合は形状 &lt;code&gt;det(a).shape == (N,)&lt;/code&gt; 配列を返します。これは、高次元配列の線形代数演算に一般化されます。多次元配列の最後の1または2次元は、各演算に応じて、ベクトルまたは行列として解釈されます。</target>
        </trans-unit>
        <trans-unit id="142401db7b88684f56ec37cbd8f1ca65b6bf6771" translate="yes" xml:space="preserve">
          <source>This is intended for working with source directories that are in an SVN repository.</source>
          <target state="translated">これは、SVN リポジトリ内にあるソースディレクトリを操作するためのものです。</target>
        </trans-unit>
        <trans-unit id="2fa46c7f117cac1c645f428d7403c2f212b4011c" translate="yes" xml:space="preserve">
          <source>This is like the builtin &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#issubclass&quot;&gt;&lt;code&gt;issubclass&lt;/code&gt;&lt;/a&gt;, but for &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">これは組み込みの&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#issubclass&quot;&gt; &lt;code&gt;issubclass&lt;/code&gt; &lt;/a&gt;に似ていますが、&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;用です。</target>
        </trans-unit>
        <trans-unit id="f497c1d2afa9510500c0e5d52cafff444023b2a6" translate="yes" xml:space="preserve">
          <source>This is needed by all Python objects. It consists of (at least) a reference count member ( &lt;code&gt;ob_refcnt&lt;/code&gt; ) and a pointer to the typeobject ( &lt;code&gt;ob_type&lt;/code&gt; ). (Other elements may also be present if Python was compiled with special options see Include/object.h in the Python source tree for more information). The ob_type member points to a Python type object.</source>
          <target state="translated">これはすべてのPythonオブジェクトで必要です。（少なくとも）参照カウントメンバー（ &lt;code&gt;ob_refcnt&lt;/code&gt; ）とtypeobjectへのポインター（ &lt;code&gt;ob_type&lt;/code&gt; ）で構成されます。（Pythonが特別なオプションでコンパイルされた場合、他の要素も存在する可能性があります。詳細については、PythonソースツリーのInclude / object.hを参照してください）。ob_typeメンバーは、Python型オブジェクトを指します。</target>
        </trans-unit>
        <trans-unit id="1833467ed646c8f15235c25f8dda305acdfb6a3c" translate="yes" xml:space="preserve">
          <source>This is not a comprehensive &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; reference. It&amp;rsquo;s tailored to the &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; hosting service. You may well find better or quicker ways of getting stuff done with &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt;, but these should get you started.</source>
          <target state="translated">これは包括的な&lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt;リファレンスではありません。&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;ホスティングサービスに合わせて調整されています。&lt;a href=&quot;https://git-scm.com/&quot;&gt;gitを&lt;/a&gt;使って物事を成し遂げるより良い、またはより速い方法を見つけるかもしれませんが、これらはあなたが始めるのに役立つはずです。</target>
        </trans-unit>
        <trans-unit id="d2a35d83e287759b7b772b39fa92c000861d127f" translate="yes" xml:space="preserve">
          <source>This is often used when a function returns multiple values:</source>
          <target state="translated">これは、関数が複数の値を返す場合によく使われます。</target>
        </trans-unit>
        <trans-unit id="daec8aebc5133f38a1a0c690c98645fa0bf3cd6e" translate="yes" xml:space="preserve">
          <source>This is particularly useful for evaluating functions of multiple dimensions on a regular grid.</source>
          <target state="translated">特に、正規のグリッド上で多次元の関数を評価するのに便利です。</target>
        </trans-unit>
        <trans-unit id="26d53d8ee495c7f638b914dab0d30642c949b736" translate="yes" xml:space="preserve">
          <source>This is presumably the most common case of large array creation. The details, of course, depend greatly on the format of data on disk and so this section can only give general pointers on how to handle various formats.</source>
          <target state="translated">これは、おそらく大規模なアレイを作成する際の最も一般的なケースです。もちろん、詳細はディスク上のデータのフォーマットに大きく依存しますので、このセクションでは様々なフォーマットをどのように扱うかについての一般的なポインタを与えることができます。</target>
        </trans-unit>
        <trans-unit id="dd8997d00c105166c9b4b9f773f5d0cdd6fa01f2" translate="yes" xml:space="preserve">
          <source>This is raised when an binary operation is passed Poly objects with different domains.</source>
          <target state="translated">これは、異なるドメインを持つポリオブジェクトにバイナリ演算が渡された場合に発生します。</target>
        </trans-unit>
        <trans-unit id="e57f721854d8f362e4016c48c315f6301f247f80" translate="yes" xml:space="preserve">
          <source>This is really &lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt;&lt;code&gt;irfftn&lt;/code&gt;&lt;/a&gt; with different defaults. For more details see &lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt;&lt;code&gt;irfftn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、実際にはさまざまなデフォルト設定に&lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt; &lt;code&gt;irfftn&lt;/code&gt; &lt;/a&gt;します。詳細については、&lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt; &lt;code&gt;irfftn&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ed9f359368f007790ca5657cc8ec4082492a200b" translate="yes" xml:space="preserve">
          <source>This is really just &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt; with different default behavior. For more details see &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは実際には、デフォルトの動作が異なる&lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt;です。詳細については、&lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="77938c782ff5f0e5fde7cba046a7d880a01771f8" translate="yes" xml:space="preserve">
          <source>This is reasonable enough, but watch out if you want to use Python&amp;rsquo;s &lt;code&gt;+=&lt;/code&gt; construct, as it may not do what you expect:</source>
          <target state="translated">これは十分に合理的ですが、Pythonの &lt;code&gt;+=&lt;/code&gt; 構造を使用する場合は、期待どおりに機能しない可能性があるので注意してください。</target>
        </trans-unit>
        <trans-unit id="5ef26806f6ea74b6485ab483c2778eff715e4572" translate="yes" xml:space="preserve">
          <source>This is short-hand for &lt;code&gt;np.r_['-1,2,0', index expression]&lt;/code&gt;, which is useful because of its common occurrence. In particular, arrays will be stacked along their last axis after being upgraded to at least 2-D with 1&amp;rsquo;s post-pended to the shape (column vectors made out of 1-D arrays).</source>
          <target state="translated">これは &lt;code&gt;np.r_['-1,2,0', index expression]&lt;/code&gt; であり、よく発生するため便利です。特に、配列は、少なくとも2次元にアップグレードされた後、最後の軸に沿ってスタックされ、1が形状に後置されます（1次元配列から作られた列ベクトル）。</target>
        </trans-unit>
        <trans-unit id="1c88394abdc65a1b05a8dd5d8683693375531a89" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) except you specify the data-type descriptor with &lt;em&gt;type_num&lt;/em&gt; and &lt;em&gt;itemsize&lt;/em&gt;, where &lt;em&gt;type_num&lt;/em&gt; corresponds to a builtin (or user-defined) type. If the type always has the same number of bytes, then itemsize is ignored. Otherwise, itemsize specifies the particular size of this array.</source>
          <target state="translated">これは&lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt; &lt;code&gt;PyArray_NewFromDescr&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）に似ていますが、&lt;em&gt;type_num&lt;/em&gt;と&lt;em&gt;itemsize&lt;/em&gt;でデータ型記述子を指定します&lt;em&gt;。type_num&lt;/em&gt;は組み込み（またはユーザー定義）型に対応します。タイプのバイト数が常に同じである場合、itemsizeは無視されます。それ以外の場合、itemsizeはこの配列の特定のサイズを指定します。</target>
        </trans-unit>
        <trans-unit id="ed43500d52b0e3a9d4bae70ddb5bfbe100ff1dd8" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;numpy.logspace#numpy.logspace&quot;&gt;&lt;code&gt;logspace&lt;/code&gt;&lt;/a&gt;, but with endpoints specified directly. Each output sample is a constant multiple of the previous.</source>
          <target state="translated">これは&lt;a href=&quot;numpy.logspace#numpy.logspace&quot;&gt; &lt;code&gt;logspace&lt;/code&gt; &lt;/a&gt;に似ていますが、エンドポイントが直接指定されています。各出力サンプルは、前のサンプルの定数倍です。</target>
        </trans-unit>
        <trans-unit id="c5fcd33629df929b0bdb1a57cfbe776ef13fe120" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;apply_along_axis&lt;/code&gt;, but treats the fields of a structured array as an extra axis. The fields are all first cast to a common type following the type-promotion rules from &lt;a href=&quot;../reference/generated/numpy.result_type#numpy.result_type&quot;&gt;&lt;code&gt;numpy.result_type&lt;/code&gt;&lt;/a&gt; applied to the field&amp;rsquo;s dtypes.</source>
          <target state="translated">これは &lt;code&gt;apply_along_axis&lt;/code&gt; に似ていますが、構造化配列のフィールドを追加の軸として扱います。フィールドはすべて、フィールドのdtypeに適用される&lt;a href=&quot;../reference/generated/numpy.result_type#numpy.result_type&quot;&gt; &lt;code&gt;numpy.result_type&lt;/code&gt; &lt;/a&gt;からのタイププロモーションルールに従って、最初に共通のタイプにキャストされます。</target>
        </trans-unit>
        <trans-unit id="852b3e753a1b8cdcb6346c93877a110d2d715f72" translate="yes" xml:space="preserve">
          <source>This is similar to choose or select, except that functions are evaluated on elements of &lt;code&gt;x&lt;/code&gt; that satisfy the corresponding condition from &lt;code&gt;condlist&lt;/code&gt;.</source>
          <target state="translated">これは、関数が &lt;code&gt;condlist&lt;/code&gt; からの対応する条件を満たす &lt;code&gt;x&lt;/code&gt; の要素で評価されることを除いて、chooseまたはselectに似ています。</target>
        </trans-unit>
        <trans-unit id="2c3a50a4a39023a7aa06d7ec91f3ecdac2409160" translate="yes" xml:space="preserve">
          <source>This is the &amp;ldquo;average&amp;rdquo; periodically compounded rate of return that gives a net present value of 0.0; for a more complete explanation, see Notes below.</source>
          <target state="translated">これは、正味現在価値が0.0になる「平均」の定期的に複合した収益率です。より完全な説明については、以下の注を参照してください。</target>
        </trans-unit>
        <trans-unit id="0dbc891d865ae88284f9bfa0a0edbf0c765484c8" translate="yes" xml:space="preserve">
          <source>This is the 1-d core function used by the dynamic ufuncs created by umath.frompyfunc(function, nin, nout). In this case &lt;em&gt;func&lt;/em&gt; is a pointer to a &lt;a href=&quot;#c.PyUFunc_PyFuncData&quot;&gt;&lt;code&gt;PyUFunc_PyFuncData&lt;/code&gt;&lt;/a&gt; structure which has definition</source>
          <target state="translated">これは、umath.frompyfunc（function、nin、nout）によって作成された動的ufuncによって使用される1-dコア関数です。この場合、&lt;em&gt;func&lt;/em&gt;は定義を持つ&lt;a href=&quot;#c.PyUFunc_PyFuncData&quot;&gt; &lt;code&gt;PyUFunc_PyFuncData&lt;/code&gt; &lt;/a&gt;構造体へのポインターです</target>
        </trans-unit>
        <trans-unit id="692a8cf195747eb5dfe92c87d684aef132c27f68" translate="yes" xml:space="preserve">
          <source>This is the NumPy implementation of the C library function fmod, the remainder has the same sign as the dividend &lt;code&gt;x1&lt;/code&gt;. It is equivalent to the Matlab(TM) &lt;code&gt;rem&lt;/code&gt; function and should not be confused with the Python modulus operator &lt;code&gt;x1 % x2&lt;/code&gt;.</source>
          <target state="translated">これはCライブラリ関数fmodのNumPy実装です。残りは被除数 &lt;code&gt;x1&lt;/code&gt; と同じ符号を持ちます。これはMatlab（TM）の &lt;code&gt;rem&lt;/code&gt; 関数と同等であり、Pythonのモジュラス演算子 &lt;code&gt;x1 % x2&lt;/code&gt; と混同しないでください。</target>
        </trans-unit>
        <trans-unit id="9f70c1d8b15029e4bba377d8eb228f8ad3621041" translate="yes" xml:space="preserve">
          <source>This is the code that handles the situation whenever the input and/or output arrays are either misaligned or of the wrong data-type (including being byte-swapped) from what the underlying 1-D loop expects. The arrays are also assumed to be non-contiguous. The code works very much like the strided-loop except for the inner 1-D loop is modified so that pre-processing is performed on the inputs and post- processing is performed on the outputs in bufsize chunks (where bufsize is a user-settable parameter). The underlying 1-D computational loop is called on data that is copied over (if it needs to be). The setup code and the loop code is considerably more complicated in this case because it has to handle:</source>
          <target state="translated">これは,入力配列や出力配列のアラインメントが間違っていたり,(バイトスワップされている場合も含めて)基礎となる1次元ループが期待するものと異なるデータ型であったりする場合に,その状況を処理するコードです.また,配列は連続していないと仮定されます.このコードはstrided-loopと非常によく似た動作をしますが,内部の1-Dループが変更されており,入力に対して前処理が実行され,出力に対して後処理がbufsizeのチャンク(bufsizeはユーザが設定可能なパラメータ)で実行されるようになっています.基礎となる1次元計算ループは、(必要に応じて)コピーされたデータ上で呼び出されます。この場合、セットアップコードとループコードは、処理しなければならないため、かなり複雑になります。</target>
        </trans-unit>
        <trans-unit id="97fdbbb09a00c84ec3c672ccc77676c7df568ed7" translate="yes" xml:space="preserve">
          <source>This is the docstring for the example.py module. Modules names should have short, all-lowercase names. The module name may have underscores if this improves readability.</source>
          <target state="translated">これは example.py モジュールの docstring です。モジュール名は短く、すべて小文字でなければなりません。可読性を向上させるために、モジュール名にはアンダースコアを付けることができます。</target>
        </trans-unit>
        <trans-unit id="938b03b0272fe214e0bd4545d8c331ea33459bae" translate="yes" xml:space="preserve">
          <source>This is the exact same method signature for &lt;code&gt;np.sum&lt;/code&gt;, so now if a user calls &lt;code&gt;np.sum&lt;/code&gt; on this object, numpy will call the object&amp;rsquo;s own &lt;code&gt;sum&lt;/code&gt; method and pass in these arguments enumerated above in the signature, and no errors will be raised because the signatures are completely compatible with each other.</source>
          <target state="translated">これは &lt;code&gt;np.sum&lt;/code&gt; のメソッドシグネチャとまったく同じであるため、ユーザーがこのオブジェクトで &lt;code&gt;np.sum&lt;/code&gt; を呼び出すと、numpyはオブジェクト自体の &lt;code&gt;sum&lt;/code&gt; メソッドを呼び出し、シグネチャで上記に列挙したこれらの引数を渡します。エラーは発生しません。署名は互いに完全に互換性があるためです。</target>
        </trans-unit>
        <trans-unit id="754ab86dfdc616fd9f3289ae80c9fb161f6f47b6" translate="yes" xml:space="preserve">
          <source>This is the main array creation function. Most new arrays are created with this flexible function.</source>
          <target state="translated">これがメインの配列作成関数です。ほとんどの新しい配列はこの柔軟な関数で作成されます。</target>
        </trans-unit>
        <trans-unit id="ae96a364309b5dfa1ba1a5f179699cc1e3ea0752" translate="yes" xml:space="preserve">
          <source>This is the main function used to obtain an array from any nested sequence, or object that exposes the array interface, &lt;em&gt;op&lt;/em&gt;. The parameters allow specification of the required &lt;em&gt;dtype&lt;/em&gt;, the minimum (&lt;em&gt;min_depth&lt;/em&gt;) and maximum (&lt;em&gt;max_depth&lt;/em&gt;) number of dimensions acceptable, and other &lt;em&gt;requirements&lt;/em&gt; for the array. This function &lt;strong&gt;steals a reference&lt;/strong&gt; to the dtype argument, which needs to be a &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure indicating the desired data-type (including required byteorder). The &lt;em&gt;dtype&lt;/em&gt; argument may be &lt;code&gt;NULL&lt;/code&gt;, indicating that any data-type (and byteorder) is acceptable. Unless &lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt;&lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt;&lt;/a&gt; is present in &lt;code&gt;flags&lt;/code&gt;, this call will generate an error if the data type cannot be safely obtained from the object. If you want to use &lt;code&gt;NULL&lt;/code&gt; for the &lt;em&gt;dtype&lt;/em&gt; and ensure the array is notswapped then use &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt;&lt;code&gt;PyArray_CheckFromAny&lt;/code&gt;&lt;/a&gt;. A value of 0 for either of the depth parameters causes the parameter to be ignored. Any of the following array flags can be added (&lt;em&gt;e.g.&lt;/em&gt; using |) to get the &lt;em&gt;requirements&lt;/em&gt; argument. If your code can handle general (&lt;em&gt;e.g.&lt;/em&gt; strided, byte-swapped, or unaligned arrays) then &lt;em&gt;requirements&lt;/em&gt; may be 0. Also, if &lt;em&gt;op&lt;/em&gt; is not already an array (or does not expose the array interface), then a new array will be created (and filled from &lt;em&gt;op&lt;/em&gt; using the sequence protocol). The new array will have &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; as its flags member. The &lt;em&gt;context&lt;/em&gt; argument is passed to the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method of &lt;em&gt;op&lt;/em&gt; and is only used if the array is constructed that way. Almost always this parameter is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">これは、入れ子になったシーケンスから配列を取得するために使用される主な関数、または配列インターフェイス&lt;em&gt;op&lt;/em&gt;を公​​開するオブジェクトです。パラメータを使用すると、必要な&lt;em&gt;dtype&lt;/em&gt;、許容される最小（&lt;em&gt;min_depth&lt;/em&gt;）および最大（&lt;em&gt;max_depth&lt;/em&gt;）の次元数、および配列の他の&lt;em&gt;要件&lt;/em&gt;を指定できます。この関数は、必要なデータ型（必要な&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;を含む）を示すPyArray_Descr構造体である必要があるdtype引数への&lt;strong&gt;参照&lt;/strong&gt;を&lt;strong&gt;盗み&lt;/strong&gt;ます。&lt;em&gt;DTYPEの&lt;/em&gt;引数があってもよい &lt;code&gt;NULL&lt;/code&gt; 任意のデータ型（およびBYTEORDER）が許容可能であることを示します。ない限り&lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt; &lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt; &lt;/a&gt;&lt;em&gt;&lt;/em&gt; &lt;code&gt;flags&lt;/code&gt; に存在する場合、オブジェクトからデータ型を安全に取得できない場合、この呼び出しはエラーを生成します。&lt;em&gt;dtypeに&lt;/em&gt; &lt;code&gt;NULL&lt;/code&gt; を使用し、配列がスワップされないようにする場合は、PyArray_CheckFromAnyを使用して&lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt; &lt;code&gt;PyArray_CheckFromAny&lt;/code&gt; &lt;/a&gt;。深さパラメーターのいずれかの値が0の場合、パラメーターは無視されます。次の配列フラグのいずれかを追加して（&lt;em&gt;たとえば&lt;/em&gt;、|を使用）、&lt;em&gt;要件&lt;/em&gt;引数を取得できます。あなたのコードは、一般的な処理できる場合（&lt;em&gt;例えば&lt;/em&gt;ストライド、バイトスワップ、または非整列配列）は、その後&lt;em&gt;の要件が&lt;/em&gt;あれば、また0であってもよい&lt;em&gt;オペアンプ&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;はまだ配列ではない（または配列インターフェイスを公開していない）場合、新しい配列が作成されます（シーケンスプロトコルを使用して&lt;em&gt;op&lt;/em&gt;から入力されます）。新しい配列には、フラグメンバーとして&lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; が&lt;/a&gt;あります。&lt;em&gt;コンテキスト&lt;/em&gt;引数が渡される&lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;の方法&lt;em&gt;OP&lt;/em&gt;とアレイがそのように構成されている場合にのみ使用されます。ほとんどの場合、このパラメータは &lt;code&gt;NULL&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="4ef891de4e312961f5d43ee05c17aa291119de54" translate="yes" xml:space="preserve">
          <source>This is the main function used to obtain an array from any nested sequence, or object that exposes the array interface, &lt;em&gt;op&lt;/em&gt;. The parameters allow specification of the required &lt;em&gt;dtype&lt;/em&gt;, the minimum (&lt;em&gt;min_depth&lt;/em&gt;) and maximum (&lt;em&gt;max_depth&lt;/em&gt;) number of dimensions acceptable, and other &lt;em&gt;requirements&lt;/em&gt; for the array. This function &lt;strong&gt;steals a reference&lt;/strong&gt; to the dtype argument, which needs to be a &lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure indicating the desired data-type (including required byteorder). The &lt;em&gt;dtype&lt;/em&gt; argument may be &lt;code&gt;NULL&lt;/code&gt;, indicating that any data-type (and byteorder) is acceptable. Unless &lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt;&lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt;&lt;/a&gt; is present in &lt;code&gt;flags&lt;/code&gt;, this call will generate an error if the data type cannot be safely obtained from the object. If you want to use &lt;code&gt;NULL&lt;/code&gt; for the &lt;em&gt;dtype&lt;/em&gt; and ensure the array is notswapped then use &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt;&lt;code&gt;PyArray_CheckFromAny&lt;/code&gt;&lt;/a&gt;. A value of 0 for either of the depth parameters causes the parameter to be ignored. Any of the following array flags can be added (&lt;em&gt;e.g.&lt;/em&gt; using |) to get the &lt;em&gt;requirements&lt;/em&gt; argument. If your code can handle general (&lt;em&gt;e.g.&lt;/em&gt; strided, byte-swapped, or unaligned arrays) then &lt;em&gt;requirements&lt;/em&gt; may be 0. Also, if &lt;em&gt;op&lt;/em&gt; is not already an array (or does not expose the array interface), then a new array will be created (and filled from &lt;em&gt;op&lt;/em&gt; using the sequence protocol). The new array will have &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; as its flags member. The &lt;em&gt;context&lt;/em&gt; argument is unused.</source>
          <target state="translated">これは、ネストされたシーケンス、または配列インターフェイス&lt;em&gt;op&lt;/em&gt;を公​​開するオブジェクトから配列を取得するために使用される主な関数です。パラメータを使用すると、必要な&lt;em&gt;dtype&lt;/em&gt;、許容可能な次元の最小（&lt;em&gt;min_depth&lt;/em&gt;）および最大（&lt;em&gt;max_depth&lt;/em&gt;）数、および配列の他の&lt;em&gt;要件&lt;/em&gt;を指定できます。この関数は、dtype引数への&lt;strong&gt;参照&lt;/strong&gt;を&lt;strong&gt;盗み&lt;/strong&gt;ます。これは、目的のデータ型（必要な&lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;を含む）を示すPyArray_Descr構造体である必要があります。&lt;em&gt;DTYPEの&lt;/em&gt;引数があってもよい &lt;code&gt;NULL&lt;/code&gt; 任意のデータ型（およびBYTEORDER）が許容可能であることを示します。&lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt; &lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt; で&lt;/a&gt;ない限りが &lt;code&gt;flags&lt;/code&gt; に存在する場合、データ型をオブジェクトから安全に取得できない場合、この呼び出しはエラーを生成します。あなたが使用したい場合は &lt;code&gt;NULL&lt;/code&gt; をため&lt;em&gt;DTYPE&lt;/em&gt;し、配列を確保その後、使用notswappedさ&lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt; &lt;code&gt;PyArray_CheckFromAny&lt;/code&gt; を&lt;/a&gt;。いずれかの深度パラメータの値が0の場合、パラメータは無視されます。次の配列フラグのいずれかを追加して（&lt;em&gt;たとえば&lt;/em&gt;|を使用して）、&lt;em&gt;要件&lt;/em&gt;引数を取得できます。あなたのコードは、一般的な処理できる場合（&lt;em&gt;例えば&lt;/em&gt;ストライド、バイトスワップ、または非整列配列）は、その後&lt;em&gt;の要件が&lt;/em&gt;あれば、また0であってもよい&lt;em&gt;オペアンプ&lt;/em&gt;がまだ配列ではない（または配列インターフェイスを公開していない）場合、新しい配列が作成されます（そして、シーケンスプロトコルを使用して&lt;em&gt;op&lt;/em&gt;から入力されます）。新しい配列には、フラグメンバーとして&lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; &lt;/a&gt;が含まれます。&lt;em&gt;コンテキスト&lt;/em&gt;引数が未使用です。</target>
        </trans-unit>
        <trans-unit id="0edcab26afcb3f2afd03c8c948c52b8fae9f82e5" translate="yes" xml:space="preserve">
          <source>This is the manual followed by NumPy&amp;rsquo;s Code of Conduct Committee. It&amp;rsquo;s used when we respond to an issue to make sure we&amp;rsquo;re consistent and fair.</source>
          <target state="translated">これは、NumPyの行動規範委員会が従うマニュアルです。これは、問題に対応するときに、一貫性と公平性を確保するために使用されます。</target>
        </trans-unit>
        <trans-unit id="5ec8c6b5a6fa5ea604ca73fde0faa7f48e61f60d" translate="yes" xml:space="preserve">
          <source>This is the masked array version of &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt;. For details see &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは&lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; の&lt;/a&gt;マスクされた配列バージョンです。詳細については、&lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c5b5fdafede3bb67234ee18c22a5b997e8095961" translate="yes" xml:space="preserve">
          <source>This is the masked array version of &lt;code&gt;lib.index_tricks.RClass&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;lib.index_tricks.RClass&lt;/code&gt; のマスクされた配列バージョンです。</target>
        </trans-unit>
        <trans-unit id="bf3cf3ae9cebee8b7306a5e44915e23de00facf1" translate="yes" xml:space="preserve">
          <source>This is the masked equivalent of the &lt;a href=&quot;numpy.resize#numpy.resize&quot;&gt;&lt;code&gt;numpy.resize&lt;/code&gt;&lt;/a&gt; function. The new array is filled with repeated copies of &lt;code&gt;x&lt;/code&gt; (in the order that the data are stored in memory). If &lt;code&gt;x&lt;/code&gt; is masked, the new array will be masked, and the new mask will be a repetition of the old one.</source>
          <target state="translated">これは、&lt;a href=&quot;numpy.resize#numpy.resize&quot;&gt; &lt;code&gt;numpy.resize&lt;/code&gt; &lt;/a&gt;関数のマスクされた同等物です。新しい配列は、 &lt;code&gt;x&lt;/code&gt; の繰り返しコピーで埋められます（データがメモリに格納される順序で）。場合は &lt;code&gt;x&lt;/code&gt; がマスクされて、新しい配列はマスクされ、新しいマスクは、古いものの繰り返しとなります。</target>
        </trans-unit>
        <trans-unit id="0cb42e32affa717b335b3825c72824c3d8e04997" translate="yes" xml:space="preserve">
          <source>This is the most flexible form of specification since it allows control over the byte-offsets of the fields and the itemsize of the structure.</source>
          <target state="translated">これは、フィールドのバイトオフセットと構造体のアイテムサイズを制御できるので、最も柔軟性の高い仕様形態です。</target>
        </trans-unit>
        <trans-unit id="e638e46153cb5bd9d2b2cfadb202d5a4f7f60071" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;ndarray.all&lt;/code&gt;&lt;/a&gt;, but it returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">これは&lt;a href=&quot;numpy.ndarray.all#numpy.ndarray.all&quot;&gt; &lt;code&gt;ndarray.all&lt;/code&gt; &lt;/a&gt;と同じですが、&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;オブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="b28c44c91a00424416f03ba6b4985acf74627eb2" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt; would return an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、同じである&lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt; &lt;code&gt;ndarray.argmax&lt;/code&gt; &lt;/a&gt;が、戻り&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;オブジェクト&lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt; &lt;code&gt;ndarray.argmax&lt;/code&gt; を&lt;/a&gt;返す&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22b8e33a3b4d40024b90c85a13a94be90c9158a1" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt; would return an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、同じである&lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt; &lt;code&gt;ndarray.argmin&lt;/code&gt; &lt;/a&gt;が、戻り&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;オブジェクト&lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt; &lt;code&gt;ndarray.argmin&lt;/code&gt; を&lt;/a&gt;返す&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1090f814c7b352e9c36a05ce2322d963cddbde3" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt; would return an ndarray.</source>
          <target state="translated">これは&lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt; &lt;code&gt;ndarray.max&lt;/code&gt; &lt;/a&gt;と同じですが、&lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt; &lt;code&gt;ndarray.max&lt;/code&gt; &lt;/a&gt;がndarrayを返す&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;オブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="74e44d918d1f15516605ec010845ff539cc17530" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt; would return an ndarray.</source>
          <target state="translated">これは&lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt; &lt;code&gt;ndarray.min&lt;/code&gt; &lt;/a&gt;と同じですが、&lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt; &lt;code&gt;ndarray.min&lt;/code&gt; &lt;/a&gt;がndarrayを返す&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;オブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="124e720446d4f3612122d427a64991837042df14" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.std#numpy.ndarray.std&quot;&gt;&lt;code&gt;ndarray.std&lt;/code&gt;&lt;/a&gt;, except that where an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; would be returned, a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object is returned instead.</source>
          <target state="translated">これは&lt;a href=&quot;numpy.ndarray.std#numpy.ndarray.std&quot;&gt; &lt;code&gt;ndarray.std&lt;/code&gt; &lt;/a&gt;と同じですが、&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;が返される場合は、代わりに&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;オブジェクトが返されます。</target>
        </trans-unit>
        <trans-unit id="a0acdb03a11a0405720f9b33ec10bd3e67d6e4fa" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt;&lt;code&gt;ndarray.sum&lt;/code&gt;&lt;/a&gt;, except that where an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; would be returned, a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object is returned instead.</source>
          <target state="translated">これは&lt;a href=&quot;numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt; &lt;code&gt;ndarray.sum&lt;/code&gt; &lt;/a&gt;と同じですが、&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;が返される場合は、代わりに&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;オブジェクトが返されます。</target>
        </trans-unit>
        <trans-unit id="1b894bff66f53b91713c65daaeb95b50cb72fdfc" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.var#numpy.ndarray.var&quot;&gt;&lt;code&gt;ndarray.var&lt;/code&gt;&lt;/a&gt;, except that where an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; would be returned, a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object is returned instead.</source>
          <target state="translated">これは&lt;a href=&quot;numpy.ndarray.var#numpy.ndarray.var&quot;&gt; &lt;code&gt;ndarray.var&lt;/code&gt; &lt;/a&gt;と同じですが、&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;が返される場合は、代わりに&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;オブジェクトが返されます。</target>
        </trans-unit>
        <trans-unit id="d6c0a4b3ef29201f690f9b9b88a69b8608d63748" translate="yes" xml:space="preserve">
          <source>This is the same for half-precision float as npy_nextafter and npy_nextafterf described in the low-level floating point section.</source>
          <target state="translated">これは、低レベル浮動小数点の項で説明したnpy_nextafterやnpy_nextafterfと同様に、半精度浮動小数点の場合も同じです。</target>
        </trans-unit>
        <trans-unit id="5a28a11e64cd4476f1fd45344cb04aff7bece602" translate="yes" xml:space="preserve">
          <source>This is the same for half-precision float as npy_spacing and npy_spacingf described in the low-level floating point section.</source>
          <target state="translated">これは、低レベル浮動小数点の項で説明したnpy_spacingやnpy_spacingfと同様に、半精度floatでも同じです。</target>
        </trans-unit>
        <trans-unit id="69592e67862b42a94f582425221058b3b2e662f2" translate="yes" xml:space="preserve">
          <source>This is the same polynomial as obtained by:</source>
          <target state="translated">で得られる多項式と同じです。</target>
        </trans-unit>
        <trans-unit id="8f841f69094513c4d7f4558bcdd113fb62e5f1f7" translate="yes" xml:space="preserve">
          <source>This is the simplest case of all. The ufunc is executed by calling the underlying 1-D loop exactly once. This is possible only when we have aligned data of the correct type (including byte-order) for both input and output and all arrays have uniform strides (either contiguous, 0-D, or 1-D). In this case, the 1-D computational loop is called once to compute the calculation for the entire array. Note that the hardware error flags are only checked after the entire calculation is complete.</source>
          <target state="translated">これが最も単純なケースです。ufuncは,基礎となる1次元ループを1回だけ呼び出すことで実行されます.これは,入力と出力の両方に対して正しい型(バイトオーダーを含む)のデータが整列されていて,すべての配列が一様なストライド(連続,0-D,1-Dのいずれか)を持っている場合にのみ可能です.この場合,配列全体の計算を計算するために1次元計算ループが1回呼び出されます.ハードウェアエラーフラグは,計算全体が完了した後にのみチェックされることに注意してください.</target>
        </trans-unit>
        <trans-unit id="963cd66868f04208a7a1c2183e363716e0ef0cf2" translate="yes" xml:space="preserve">
          <source>This is the type which exposes the iterator to Python. Currently, no API is exposed which provides access to the values of a Python-created iterator. If an iterator is created in Python, it must be used in Python and vice versa. Such an API will likely be created in a future version.</source>
          <target state="translated">これはイテレータをPythonに公開する型です。現在のところ、Pythonで作成されたイテレータの値へのアクセスを提供するAPIは公開されていません。Pythonでイテレータが作成された場合、それはPythonで使用されなければなりませんし、その逆もまた然りです。このようなAPIは将来のバージョンで作成される可能性が高いでしょう。</target>
        </trans-unit>
        <trans-unit id="4b42439256132aabca2f53b261c973f7c679d369" translate="yes" xml:space="preserve">
          <source>This is useful for setting up an accumulation loop, for example. The iterator can first be created with all the dimensions, including the accumulation axis, so that the output gets created correctly. Then, the accumulation axis can be removed, and the calculation done in a nested fashion.</source>
          <target state="translated">これは、例えば、蓄積ループを設定するのに便利です。出力が正しく作成されるように、蓄積軸を含むすべての次元でイテレータを最初に作成することができます。その後、蓄積軸を削除して、入れ子になった方法で計算を行うことができます。</target>
        </trans-unit>
        <trans-unit id="5300cb088270de52a08527e24f73ff59ea30c2bb" translate="yes" xml:space="preserve">
          <source>This is useful in a setup.py script for adding sub-packages to a package.</source>
          <target state="translated">これはsetup.pyスクリプトでサブパッケージをパッケージに追加する際に便利です。</target>
        </trans-unit>
        <trans-unit id="6e4aa46e2220dff2f0d0703b94a0af6befef5473" translate="yes" xml:space="preserve">
          <source>This is wonderful because the function writer doesn&amp;rsquo;t have to manually propagate infs or nans.</source>
          <target state="translated">関数ライターがinfsやnansを手動で伝播する必要がないため、これは素晴らしいことです。</target>
        </trans-unit>
        <trans-unit id="82959a96175cd052449eddf58c5c4610e0b21bd3" translate="yes" xml:space="preserve">
          <source>This iterates over matching 1d slices oriented along the specified axis in the index and data arrays, and uses the former to look up values in the latter. These slices can be different lengths.</source>
          <target state="translated">これは,インデックス配列とデータ配列の指定された軸に沿って配置されたマッチする1次元スライスを繰り返し処理し,前者を使用して後者の値を検索します.これらのスライスは,異なる長さにすることができます.</target>
        </trans-unit>
        <trans-unit id="5c175a7e11a936be20457fa33dc8778b062c8741" translate="yes" xml:space="preserve">
          <source>This iterates over matching 1d slices oriented along the specified axis in the index and data arrays, and uses the former to place values into the latter. These slices can be different lengths.</source>
          <target state="translated">これは,インデックス配列とデータ配列の指定された軸に沿って配置されたマッチする1次元スライスを繰り返し処理し,前者を使用して後者に値を配置します.これらのスライスは,異なる長さにすることができます.</target>
        </trans-unit>
        <trans-unit id="1d9086a3e8f6e523e455adb859a4bc6cbea3019a" translate="yes" xml:space="preserve">
          <source>This iterator returns elements of the array to be iterated over in &lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt;&lt;code&gt;Arrayterator&lt;/code&gt;&lt;/a&gt; one by one. It is similar to &lt;code&gt;flatiter&lt;/code&gt;.</source>
          <target state="translated">この反復子は、&lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt; &lt;code&gt;Arrayterator&lt;/code&gt; で&lt;/a&gt; 1つずつ反復される配列の要素を返します。それは &lt;code&gt;flatiter&lt;/code&gt; に似ています。</target>
        </trans-unit>
        <trans-unit id="f3aa62850b827d280ac62636d6a8e3df18a980ad" translate="yes" xml:space="preserve">
          <source>This just returns the value &lt;a href=&quot;#c.NPY_FEATURE_VERSION&quot;&gt;&lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#c.NPY_FEATURE_VERSION&quot;&gt;&lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt;&lt;/a&gt; changes whenever the API changes (e.g. a function is added). A changed value does not always require a recompile.</source>
          <target state="translated">これは、値&lt;a href=&quot;#c.NPY_FEATURE_VERSION&quot;&gt; &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; を&lt;/a&gt;返すだけです。&lt;a href=&quot;#c.NPY_FEATURE_VERSION&quot;&gt; &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; &lt;/a&gt;は、APIが変更される（関数が追加されるなど）たびに変更されます。変更された値は、必ずしも再コンパイルを必要としません。</target>
        </trans-unit>
        <trans-unit id="9621dd1cff206294072ec88c5bdff12776a1ac23" translate="yes" xml:space="preserve">
          <source>This just returns the value &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt; changes whenever a backward incompatible change at the ABI level. Because it is in the C-API, however, comparing the output of this function from the value defined in the current header gives a way to test if the C-API has changed thus requiring a re-compilation of extension modules that use the C-API. This is automatically checked in the function &lt;a href=&quot;#c.import_array&quot;&gt;&lt;code&gt;import_array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは単に値&lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; を&lt;/a&gt;返します。&lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt;は、ABIレベルで下位互換性のない変更が行われるたびに変更されます。ただし、C-APIにあるため、この関数の出力を現在のヘッダーで定義された値と比較すると、C-APIが変更されたかどうかをテストでき、Cを使用する拡張モジュールの再コンパイルが必要になります。 -API。これは、関数&lt;a href=&quot;#c.import_array&quot;&gt; &lt;code&gt;import_array&lt;/code&gt; &lt;/a&gt;で自動的にチェックされます。</target>
        </trans-unit>
        <trans-unit id="75e16e673218df8f16a0a1029a429a437c420b9d" translate="yes" xml:space="preserve">
          <source>This just returns the value &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt;. &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; changes whenever the API changes (e.g. a function is added). A changed value does not always require a recompile.</source>
          <target state="translated">これは単に値 &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; を返します。 &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; は、APIが変更される（関数が追加されるなど）たびに変更されます。変更された値は、常に再コンパイルする必要はありません。</target>
        </trans-unit>
        <trans-unit id="57131d2cbf8754e0c0045e65c405a8ff98703b38" translate="yes" xml:space="preserve">
          <source>This macro is defined to +inf.</source>
          <target state="translated">このマクロは+infに定義されています。</target>
        </trans-unit>
        <trans-unit id="8ca63ad5bc4e1dded64f0ca2a056ab5d5c7f090f" translate="yes" xml:space="preserve">
          <source>This macro is defined to -1.0.</source>
          <target state="translated">このマクロは-1.0に定義されています。</target>
        </trans-unit>
        <trans-unit id="b30ee77ae33429489972a6d1172613ede0e766a9" translate="yes" xml:space="preserve">
          <source>This macro is defined to -inf.</source>
          <target state="translated">このマクロは、-infに定義されています。</target>
        </trans-unit>
        <trans-unit id="b8842c8583817136af82824b8e5fdbb3f9c76f6e" translate="yes" xml:space="preserve">
          <source>This macro is defined to 1.0.</source>
          <target state="translated">このマクロは1.0に定義されています。</target>
        </trans-unit>
        <trans-unit id="bd01732ce89574cb085cbbd769f60ac683ce37ab" translate="yes" xml:space="preserve">
          <source>This macro is defined to a NaN (Not a Number), and is guaranteed to have the signbit unset (&amp;lsquo;positive&amp;rsquo; NaN). The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">このマクロはNaN（非数）に対して定義されており、符号ビットが設定されていない（「正の」NaN）ことが保証されています。対応する単精度および拡張精度マクロは、接尾辞FおよびLで利用できます。</target>
        </trans-unit>
        <trans-unit id="305a7f44534276994ed187e38461a42eaeb6b275" translate="yes" xml:space="preserve">
          <source>This macro is defined to a NaN value, guaranteed to have its sign bit unset.</source>
          <target state="translated">このマクロは NaN 値に対して定義され、その符号ビットがアンセットされることが保証されています。</target>
        </trans-unit>
        <trans-unit id="15a2136199da842d310792facc84af7246036426" translate="yes" xml:space="preserve">
          <source>This macro is defined to a positive inf. The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">このマクロは正の inf に定義されています。対応する単精度マクロと拡張精度マクロは、接尾辞FとLで利用できます。</target>
        </trans-unit>
        <trans-unit id="c5ea17d1f0932fffe7fa9472293549c952ff5b71" translate="yes" xml:space="preserve">
          <source>This macro is defined to negative zero (that is with the sign bit set). The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">こ のマ ク ロ は負のゼロに定義 さ れます (符号ビ ッ ト が設定 さ れています)。対応する単精度マクロと拡張精度マクロは、接尾辞 F と L で利用できます。</target>
        </trans-unit>
        <trans-unit id="28ffbdfd1fb5a238c0e6b132bd7b25e886a8862b" translate="yes" xml:space="preserve">
          <source>This macro is defined to negative zero.</source>
          <target state="translated">このマクロは負のゼロに定義されています。</target>
        </trans-unit>
        <trans-unit id="6499719d1e23e1af1e93848438b61bc7bf9fb167" translate="yes" xml:space="preserve">
          <source>This macro is defined to positive zero.</source>
          <target state="translated">このマクロは正のゼロに定義されています。</target>
        </trans-unit>
        <trans-unit id="c804fcf19685f98f19d42c1dc7c110945817d41e" translate="yes" xml:space="preserve">
          <source>This macro is defined to positive zero. The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">このマクロは正のゼロに定義されています。対応する単精度マクロと拡張精度マクロは、接尾辞FとLで利用できます。</target>
        </trans-unit>
        <trans-unit id="4c35e4d492b4b66e88cf91e279bf815b9c6ef74c" translate="yes" xml:space="preserve">
          <source>This manual contains many examples of use, usually prefixed with the Python prompt &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; (which is not a part of the example code). The examples assume that you have first entered:</source>
          <target state="translated">このマニュアルには多くの使用例が含まれており、通常はPythonプロンプト &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; のプレフィックスが付いています（これはサンプルコードの一部ではありません）。例では、最初に次のように入力したことを前提としています。</target>
        </trans-unit>
        <trans-unit id="fc87f3907c86c15e0fab69c802c5a342d7203e00" translate="yes" xml:space="preserve">
          <source>This may be clearer with an example.</source>
          <target state="translated">例を挙げれば、より明確になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="bc3434d0927f2e6cdc4fb04c1ef64578863b34f8" translate="yes" xml:space="preserve">
          <source>This may be used to read an existing file or create a new one.</source>
          <target state="translated">これは、既存のファイルを読み込んだり、新しいファイルを作成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="bb4ec39a1dbea334a71074f67fa1cd07017f1cdf" translate="yes" xml:space="preserve">
          <source>This may be used when you want to match up operand axes in some fashion, then remove them with &lt;a href=&quot;#c.NpyIter_RemoveAxis&quot;&gt;&lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt;&lt;/a&gt; to handle their processing manually. By calling this function before removing the axes, you can get the strides for the manual processing.</source>
          <target state="translated">これは、何らかの方法でオペランド軸を一致させてから、&lt;a href=&quot;#c.NpyIter_RemoveAxis&quot;&gt; &lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; &lt;/a&gt;を使用してそれらを削除し、手動で処理を処理する場合に使用できます。軸を削除する前にこの関数を呼び出すことにより、手動処理の歩幅を取得できます。</target>
        </trans-unit>
        <trans-unit id="c451240677ff61c1a609e49bd0f07f461a99c611" translate="yes" xml:space="preserve">
          <source>This may be used when you want to match up operand axes in some fashion, then remove them with &lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; to handle their processing manually. By calling this function before removing the axes, you can get the strides for the manual processing.</source>
          <target state="translated">これは、オペランド軸を何らかの方法で一致させ、 &lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; を使用してそれらを削除して、それらの処理を手動で処理する場合に使用できます。座標軸を削除する前にこの関数を呼び出すことにより、手動処理のストライドを取得できます。</target>
        </trans-unit>
        <trans-unit id="272240144b37c5af402b352038a269eb5d08f543" translate="yes" xml:space="preserve">
          <source>This may mainly help you if you are not running the python and/or NumPy version you are expecting to run.</source>
          <target state="translated">これは主に、あなたが期待しているpythonやNumPyのバージョンを実行していない場合に役立つかもしれません。</target>
        </trans-unit>
        <trans-unit id="c92d427e914a0dd599016040f8fd75a2d48dc062" translate="yes" xml:space="preserve">
          <source>This means that (i) we want to edit the commit message for &lt;code&gt;13d7934&lt;/code&gt;, and (ii) collapse the last three commits into one. Now we save and quit the editor.</source>
          <target state="translated">これは、（i） &lt;code&gt;13d7934&lt;/code&gt; のコミットメッセージを編集し、（ii）最後の3つのコミットを1つにまとめたいことを意味します。ここで、エディターを保存して終了します。</target>
        </trans-unit>
        <trans-unit id="c9eb6e1f385480cd888cdacc62c2f757c4de3926" translate="yes" xml:space="preserve">
          <source>This mechanism should support all compilers and it doesn&amp;rsquo;t require any compiler-specific extension, but at the same time it is adds a few steps to normal compilation that are explained as follows:</source>
          <target state="translated">このメカニズムはすべてのコンパイラをサポートする必要があり、コンパイラ固有の拡張機能は必要ありませんが、同時に、次のように説明される通常のコンパイルにいくつかの手順が追加されます。</target>
        </trans-unit>
        <trans-unit id="85b5c517a58e8aeec834229928a8cecac10d6dff" translate="yes" xml:space="preserve">
          <source>This member allows array objects to have weak references (using the weakref module).</source>
          <target state="translated">このメンバは、配列オブジェクトが弱い参照を持つことを可能にします (weakref モジュールを使用します)。</target>
        </trans-unit>
        <trans-unit id="ed18bc4ba4db4fad433f89f2b494c6f4723892b5" translate="yes" xml:space="preserve">
          <source>This member is used to hold a pointer to another Python object that is related to this array. There are two use cases:</source>
          <target state="translated">このメンバは、この配列に関連する別の Python オブジェクトへのポインタを保持するために使用されます。2つのユースケースがあります。</target>
        </trans-unit>
        <trans-unit id="9d7f481ab5f8b1d226ed9ed47a9904d6a830df77" translate="yes" xml:space="preserve">
          <source>This member points to an element in the ndarray indicated by the index.</source>
          <target state="translated">このメンバは、インデックスで示される ndarray の要素を指す。</target>
        </trans-unit>
        <trans-unit id="74643da87d06b0da62bc7a9a046a5adf218ab99e" translate="yes" xml:space="preserve">
          <source>This method directly exposes the the raw underlying pseudo-random number generator. All values are returned as unsigned 64-bit values irrespective of the number of bits produced by the PRNG.</source>
          <target state="translated">このメソッドは、基礎となる生の擬似乱数発生器を直接公開します。すべての値は、PRNG によって生成されたビット数に関係なく、符号なしの 64 ビット値として返されます。</target>
        </trans-unit>
        <trans-unit id="d818e6497cca20e6d8e8f1bc817ba9a89c8a342e" translate="yes" xml:space="preserve">
          <source>This method does nothing, except raise a ValueError exception. A masked array does not own its data and therefore cannot safely be resized in place. Use the &lt;a href=&quot;numpy.ma.resize#numpy.ma.resize&quot;&gt;&lt;code&gt;numpy.ma.resize&lt;/code&gt;&lt;/a&gt; function instead.</source>
          <target state="translated">このメソッドは、ValueError例外を発生させる以外は何もしません。マスクされた配列はそのデータを所有していないため、安全に適切なサイズに変更できません。代わりに&lt;a href=&quot;numpy.ma.resize#numpy.ma.resize&quot;&gt; &lt;code&gt;numpy.ma.resize&lt;/code&gt; &lt;/a&gt;関数を使用してください。</target>
        </trans-unit>
        <trans-unit id="9518a02e6b8dc4cd7e3170e82e29518e38adcb79" translate="yes" xml:space="preserve">
          <source>This method does the heavy lifting for the &lt;a href=&quot;numpy.testing.tester.test#numpy.testing.Tester.test&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt; method. It takes all the same arguments, for details see &lt;a href=&quot;numpy.testing.tester.test#numpy.testing.Tester.test&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このメソッドは、&lt;a href=&quot;numpy.testing.tester.test#numpy.testing.Tester.test&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt;メソッドの手間のかかる作業を行います。詳細については、&lt;a href=&quot;numpy.testing.tester.test#numpy.testing.Tester.test&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f55c9dffed1c2a6b5a2a9bf81f22b788e98f67b4" translate="yes" xml:space="preserve">
          <source>This method is called whenever the system internally allocates a new array from &lt;em&gt;obj&lt;/em&gt;, where &lt;em&gt;obj&lt;/em&gt; is a subclass (subtype) of the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. It can be used to change attributes of &lt;em&gt;self&lt;/em&gt; after construction (so as to ensure a 2-d matrix for example), or to update meta-information from the &amp;ldquo;parent.&amp;rdquo; Subclasses inherit a default implementation of this method that does nothing.</source>
          <target state="translated">システムが内部から新しいアレイ割り当てるたびに、このメソッドが呼び出され&lt;em&gt;OBJ&lt;/em&gt;、&lt;em&gt;objが&lt;/em&gt;のサブクラス（サブタイプ）である&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; を&lt;/a&gt;。これは、（たとえば、2次元のマトリックスを確実にするために）構築後に&lt;em&gt;自己の&lt;/em&gt;属性を変更するため、または「親」からメタ情報を更新するために使用できます。サブクラスは、何もしないこのメソッドのデフォルト実装を継承します。</target>
        </trans-unit>
        <trans-unit id="5957d72b0ca4a0dc20466e5e727abd34e77443e1" translate="yes" xml:space="preserve">
          <source>This method is difficult to implement safely and may be deprecated in future releases of NumPy.</source>
          <target state="translated">この方法は安全に実装することが難しく、NumPyの将来のリリースでは非推奨となる可能性があります。</target>
        </trans-unit>
        <trans-unit id="7aaa9616f6dcdd0184bee8a152bd13d1e550b310" translate="yes" xml:space="preserve">
          <source>This method is for backward compatibility only: do not use.</source>
          <target state="translated">このメソッドは下位互換性のためだけのものです。</target>
        </trans-unit>
        <trans-unit id="0ecb5e08ef8d16754216c422058e3a81999abee2" translate="yes" xml:space="preserve">
          <source>This method removes any overlaps and reorders the fields in memory so they have increasing byte offsets, and adds or removes padding bytes depending on the &lt;code&gt;align&lt;/code&gt; option, which behaves like the &lt;code&gt;align&lt;/code&gt; option to &lt;code&gt;np.dtype&lt;/code&gt;.</source>
          <target state="translated">このメソッドは、オーバーラップを削除し、メモリ内のフィールドを並べ替えてバイトオフセットを増やし、 &lt;code&gt;np.dtype&lt;/code&gt; の &lt;code&gt;align&lt;/code&gt; オプションのように動作する &lt;code&gt;align&lt;/code&gt; オプションに応じてパディングバイトを追加または削除します。</target>
        </trans-unit>
        <trans-unit id="83e657ddca83d2881d8a63d1d77710e25b3d7e94" translate="yes" xml:space="preserve">
          <source>This method scans files named __version__.py, &amp;lt;packagename&amp;gt;_version.py, version.py, and __svn_version__.py for string variables version, __version__, and &amp;lt;packagename&amp;gt;_version, until a version number is found.</source>
          <target state="translated">このメソッドは、バージョン番号が見つかるまで、__ version __。py、&amp;lt;packagename&amp;gt; _version.py、version.py、および__svn_version__.pyという名前のファイルをスキャンして、文字列変数version、__ version__、および&amp;lt;packagename&amp;gt; _versionを探します。</target>
        </trans-unit>
        <trans-unit id="f89805770623a7cfcc87bb87063713e7dd822816" translate="yes" xml:space="preserve">
          <source>This module contains all functions in the &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; namespace, with the following replacement functions that return &lt;a href=&quot;generated/numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrices&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このモジュールには&lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; &lt;/a&gt;名前空間のすべての関数が含まれており、&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; の&lt;/a&gt;代わりに&lt;a href=&quot;generated/numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrices&lt;/code&gt; &lt;/a&gt;を返す次の置換関数が含まれています。</target>
        </trans-unit>
        <trans-unit id="265d65d83193df044b48a623f0d3f0dda63b008d" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Chebyshev series, including a &lt;a href=&quot;generated/numpy.polynomial.chebyshev.chebyshev#numpy.polynomial.chebyshev.Chebyshev&quot;&gt;&lt;code&gt;Chebyshev&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">このモジュールは、通常の算術演算をカプセル化する&lt;a href=&quot;generated/numpy.polynomial.chebyshev.chebyshev#numpy.polynomial.chebyshev.Chebyshev&quot;&gt; &lt;code&gt;Chebyshev&lt;/code&gt; &lt;/a&gt;クラスを含む、チェビシェフシリーズの処理に役立つ多数のオブジェクト（主に関数）を提供します。（このモジュールがこのような多項式をどのように表し、処理するかに関する一般的な情報は、その「親」サブパッケージ&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt;のdocstringにあります）。</target>
        </trans-unit>
        <trans-unit id="e0c12fd4ebad36a4626d24020b78132a2c170962" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Hermite series, including a &lt;a href=&quot;generated/numpy.polynomial.hermite.hermite#numpy.polynomial.hermite.Hermite&quot;&gt;&lt;code&gt;Hermite&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">このモジュールは、通常の算術演算をカプセル化する&lt;a href=&quot;generated/numpy.polynomial.hermite.hermite#numpy.polynomial.hermite.Hermite&quot;&gt; &lt;code&gt;Hermite&lt;/code&gt; &lt;/a&gt;クラスを含む、Hermiteシリーズを処理するのに役立つ多くのオブジェクト（主に関数）を提供します。 （このモジュールがこのような多項式をどのように表し、処理するかに関する一般的な情報は、その「親」サブパッケージ&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt;のdocstringにあります）。</target>
        </trans-unit>
        <trans-unit id="009a1c885b932c48bc61dd45e0e34c3c31b1f286" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with HermiteE series, including a &lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt;&lt;code&gt;HermiteE&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">このモジュールは、通常の算術演算をカプセル化する&lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt; &lt;code&gt;HermiteE&lt;/code&gt; &lt;/a&gt;クラスを含む、HermiteEシリーズの処理に役立つ多くのオブジェクト（主に関数）を提供します。（このモジュールがこのような多項式をどのように表し、処理するかに関する一般的な情報は、その「親」サブパッケージ&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt;のdocstringにあります）。</target>
        </trans-unit>
        <trans-unit id="68d5327723a8c86e153df7ff9955c4a06be0ce20" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Hermite_e series, including a &lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt;&lt;code&gt;HermiteE&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">このモジュールは、通常の算術演算をカプセル化する&lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt; &lt;code&gt;HermiteE&lt;/code&gt; &lt;/a&gt;クラスを含む、Hermite_eシリーズの処理に役立つ多数のオブジェクト（主に関数）を提供します。（このモジュールがそのような多項式をどのように表し、どのように機能するかに関する一般的な情報は、その「親」サブパッケージ&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt;のdocstringにあります）。</target>
        </trans-unit>
        <trans-unit id="0d0299f154387dc04b7a01cfe822909405b30805" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Laguerre series, including a &lt;a href=&quot;generated/numpy.polynomial.laguerre.laguerre#numpy.polynomial.laguerre.Laguerre&quot;&gt;&lt;code&gt;Laguerre&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">このモジュールは、通常の算術演算をカプセル化する&lt;a href=&quot;generated/numpy.polynomial.laguerre.laguerre#numpy.polynomial.laguerre.Laguerre&quot;&gt; &lt;code&gt;Laguerre&lt;/code&gt; &lt;/a&gt;クラスを含む、Laguerreシリーズの処理に役立つ多数のオブジェクト（主に関数）を提供します。（このモジュールがこのような多項式をどのように表し、処理するかに関する一般的な情報は、その「親」サブパッケージ&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt;のdocstringにあります）。</target>
        </trans-unit>
        <trans-unit id="97167a7dd7012c05d960d350608d944b8fc4844a" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Legendre series, including a &lt;a href=&quot;generated/numpy.polynomial.legendre.legendre#numpy.polynomial.legendre.Legendre&quot;&gt;&lt;code&gt;Legendre&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">このモジュールは、通常の算術演算をカプセル化する&lt;a href=&quot;generated/numpy.polynomial.legendre.legendre#numpy.polynomial.legendre.Legendre&quot;&gt; &lt;code&gt;Legendre&lt;/code&gt; &lt;/a&gt;クラスを含む、Legendreシリーズの処理に役立つ多数のオブジェクト（主に関数）を提供します。（このモジュールがこのような多項式をどのように表し、処理するかに関する一般的な情報は、その「親」サブパッケージ&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt;のdocstringにあります）。</target>
        </trans-unit>
        <trans-unit id="27218660297bbc1672326aa7fc0091aba0aa4b36" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Polynomial series, including a &lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt;&lt;code&gt;Polynomial&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">このモジュールは、通常の算術演算をカプセル化する&lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt; &lt;code&gt;Polynomial&lt;/code&gt; &lt;/a&gt;クラスを含む、Polynomialシリーズの処理に役立つ多数のオブジェクト（主に関数）を提供します。（このモジュールがこのような多項式をどのように表し、処理するかに関する一般的な情報は、その「親」サブパッケージ&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt;のdocstringにあります）。</target>
        </trans-unit>
        <trans-unit id="1ab4c28fb83b693800bce3d9c0cb03cd8615a6cd" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with polynomials, including a &lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt;&lt;code&gt;Polynomial&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with polynomial objects is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">このモジュールは、通常の算術演算をカプセル化する&lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt; &lt;code&gt;Polynomial&lt;/code&gt; &lt;/a&gt;クラスを含む、多項式の処理に役立つ多数のオブジェクト（主に関数）を提供します。（このモジュールが多項式オブジェクトをどのように表現し、操作するかに関する一般的な情報は、その「親」サブパッケージ&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt;のdocstringにあります）。</target>
        </trans-unit>
        <trans-unit id="6505e2a54b4c90d04c624c70346ad867092f98b2" translate="yes" xml:space="preserve">
          <source>This module provides: error and warning objects; a polynomial base class; and some routines used in both the &lt;code&gt;polynomial&lt;/code&gt; and &lt;code&gt;chebyshev&lt;/code&gt; modules.</source>
          <target state="translated">このモジュールは以下を提供します：エラーおよび警告オブジェクト。多項式基本クラス; また、 &lt;code&gt;polynomial&lt;/code&gt; モジュールと &lt;code&gt;chebyshev&lt;/code&gt; モジュールの両方で使用されるいくつかのルーチン。</target>
        </trans-unit>
        <trans-unit id="a2e1ca0b050299a02c26006ffc538095c291c293" translate="yes" xml:space="preserve">
          <source>This module shows use of the &lt;code&gt;cimport&lt;/code&gt; statement to load the definitions from the &lt;code&gt;numpy.pxd&lt;/code&gt; header that ships with Cython. It looks like NumPy is imported twice; &lt;code&gt;cimport&lt;/code&gt; only makes the NumPy C-API available, while the regular &lt;code&gt;import&lt;/code&gt; causes a Python-style import at runtime and makes it possible to call into the familiar NumPy Python API.</source>
          <target state="translated">このモジュールは、 &lt;code&gt;cimport&lt;/code&gt; ステートメントを使用して、Cythonに &lt;code&gt;numpy.pxd&lt;/code&gt; ヘッダーから定義をロードする方法を示しています。NumPyは2回インポートされているようです。 &lt;code&gt;cimport&lt;/code&gt; は、定期的な間だけ、numpyのC-APIを使用できるようになり &lt;code&gt;import&lt;/code&gt; 実行時にPythonのスタイルのインポートを引き起こし、おなじみのnumpyのPythonのAPIを呼び出すことを可能にします。</target>
        </trans-unit>
        <trans-unit id="6f02b8e116f7a7bed4ba561da0ffe80943392202" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Chebyshev series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">このモジュールの &lt;code&gt;off + scl*x&lt;/code&gt; チェビシェフシリーズの表現。</target>
        </trans-unit>
        <trans-unit id="a628eacd0f4bb9dd57ff71e63c578eed78e261b5" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Hermite series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">このモジュールの &lt;code&gt;off + scl*x&lt;/code&gt; Hermiteシリーズの表現。</target>
        </trans-unit>
        <trans-unit id="9ab2b6eda8208cc86132d50e5e53a2cf2e15859d" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Laguerre series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">このモジュールの、 &lt;code&gt;off + scl*x&lt;/code&gt; ラゲールシリーズの表現。</target>
        </trans-unit>
        <trans-unit id="23eb81bc9bb7a5f0cbd08a18f3b739c712c791cf" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Legendre series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">このモジュールの &lt;code&gt;off + scl*x&lt;/code&gt; Legendreシリーズの表現。</target>
        </trans-unit>
        <trans-unit id="d92e37a5c688f24c68244c7cd58f9c4410908a50" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the linear polynomial &lt;code&gt;off +
scl*x&lt;/code&gt;.</source>
          <target state="translated">このモジュールの線形多項式 &lt;code&gt;off + scl*x&lt;/code&gt; の表現。</target>
        </trans-unit>
        <trans-unit id="cce1c3ab116538df151878b9366f2e0db3802d6b" translate="yes" xml:space="preserve">
          <source>This needs to be done after all installers are downloaded, but before the pavement file is updated for continued development:</source>
          <target state="translated">これは、すべてのインストーラがダウンロードされた後、開発を継続するために舗装ファイルが更新される前に行う必要があります。</target>
        </trans-unit>
        <trans-unit id="a5151a066bb85cc108b39c4156d9c6c1e5f15d97" translate="yes" xml:space="preserve">
          <source>This obeys the structured array assignment rules described above. For example, this means that one can swap the values of two fields using appropriate multi-field indexes:</source>
          <target state="translated">これは、上で説明した構造化配列の代入ルールに従います。例えば、これは、適切なマルチフィールドインデックスを使用して2つのフィールドの値を入れ替えることができることを意味します。</target>
        </trans-unit>
        <trans-unit id="1c93b1abaa0ee7234b376edaae74a000aa2ccbab" translate="yes" xml:space="preserve">
          <source>This object is no longer compatible with &lt;code&gt;np.sum&lt;/code&gt; because if you call &lt;code&gt;np.sum&lt;/code&gt;, it will pass in unexpected arguments &lt;code&gt;out&lt;/code&gt; and &lt;code&gt;keepdims&lt;/code&gt;, causing a TypeError to be raised.</source>
          <target state="translated">このオブジェクトは、もはやと互換性がありません &lt;code&gt;np.sum&lt;/code&gt; お電話の場合はので &lt;code&gt;np.sum&lt;/code&gt; を、それは予想外の引数に渡します &lt;code&gt;out&lt;/code&gt; と &lt;code&gt;keepdims&lt;/code&gt; TypeError例外が発生することが原因。</target>
        </trans-unit>
        <trans-unit id="b628f2a020e67ee402c9861512476edcb4af1ebf" translate="yes" xml:space="preserve">
          <source>This object is now compatible with &lt;code&gt;np.sum&lt;/code&gt; again because any extraneous arguments (i.e. keywords that are not &lt;code&gt;axis&lt;/code&gt; or &lt;code&gt;dtype&lt;/code&gt;) will be hidden away in the &lt;code&gt;**unused_kwargs&lt;/code&gt; parameter.</source>
          <target state="translated">無関係な引数（つまり、 &lt;code&gt;axis&lt;/code&gt; または &lt;code&gt;dtype&lt;/code&gt; ではないキーワード）が &lt;code&gt;**unused_kwargs&lt;/code&gt; パラメーターで非表示になるため、このオブジェクトは &lt;code&gt;np.sum&lt;/code&gt; と再び互換性があります。</target>
        </trans-unit>
        <trans-unit id="75a22002edc0d8d423cb72bfe9efb4e65f38427c" translate="yes" xml:space="preserve">
          <source>This only affects the iterator when &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is specified for the order parameter. By default with &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, the iterator reverses axes which have negative strides, so that memory is traversed in a forward direction. This disables this step. Use this flag if you want to use the underlying memory-ordering of the axes, but don&amp;rsquo;t want an axis reversed. This is the behavior of &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt;, for instance.</source>
          <target state="translated">これは、orderパラメーターに&lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt;が指定されている場合にのみイテレーターに影響します。デフォルトでは、&lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; を使用する&lt;/a&gt;と、イテレータは負のストライドを持つ軸を反転するため、メモリは順方向にトラバースされます。これにより、このステップが無効になります。軸の基礎となるメモリオーダリングを使用したいが、軸を逆にしたくない場合は、このフラグを使用します。これは、 &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt; の動作です。</target>
        </trans-unit>
        <trans-unit id="eaa2fd8c1567b66e551b17269b1ebbbc61f96243" translate="yes" xml:space="preserve">
          <source>This only affects the iterator when &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is specified for the order parameter. By default with &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, the iterator reverses axes which have negative strides, so that memory is traversed in a forward direction. This disables this step. Use this flag if you want to use the underlying memory-ordering of the axes, but don&amp;rsquo;t want an axis reversed. This is the behavior of &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt;, for instance.</source>
          <target state="translated">これは、orderパラメーターに&lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt;が指定されている場合にのみイテレーターに影響します。&lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; の&lt;/a&gt;デフォルトでは、反復子は負のストライドを持つ軸を反転するため、メモリは順方向にトラバースされます。これにより、このステップが無効になります。軸の基本的なメモリ順序を使用したいが、軸を逆にしたくない場合は、このフラグを使用します。これは、 &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt; の動作です。</target>
        </trans-unit>
        <trans-unit id="dfc0d7340cbb0038d2b37c47d460673f198c8e36" translate="yes" xml:space="preserve">
          <source>This operation, dividing an array by a scalar, works because of NumPy&amp;rsquo;s &lt;a href=&quot;theory.broadcasting#array-broadcasting-in-numpy&quot;&gt;broadcasting rules&lt;/a&gt;). (Note that in real-world applications, it would be better to use, for example, the &lt;a href=&quot;https://scikit-image.org/docs/stable/api/skimage.html#skimage.img_as_float&quot;&gt;&lt;code&gt;img_as_float&lt;/code&gt;&lt;/a&gt; utility function from &lt;code&gt;scikit-image&lt;/code&gt;).</source>
          <target state="translated">配列をスカラーで除算するこの操作は、NumPyの&lt;a href=&quot;theory.broadcasting#array-broadcasting-in-numpy&quot;&gt;ブロードキャストルール&lt;/a&gt;のために機能します）。（実際のアプリケーションでは、たとえば、 &lt;code&gt;scikit-image&lt;/code&gt; の&lt;a href=&quot;https://scikit-image.org/docs/stable/api/skimage.html#skimage.img_as_float&quot;&gt; &lt;code&gt;img_as_float&lt;/code&gt; &lt;/a&gt;ユーティリティ関数を使用する方がよいことに注意してください）。</target>
        </trans-unit>
        <trans-unit id="c162c5fa5c56025420698950fd9023cbce377364" translate="yes" xml:space="preserve">
          <source>This option is deprecated. Use &lt;code&gt;usercode&lt;/code&gt; statement to specify C code snippets directly in signature files.</source>
          <target state="translated">このオプションは非推奨です。 &lt;code&gt;usercode&lt;/code&gt; ステートメントを使用して、署名ファイルで直接Cコードスニペットを指定します。</target>
        </trans-unit>
        <trans-unit id="ae6b1796953475091b5cdaeb39e4d7e996e315e6" translate="yes" xml:space="preserve">
          <source>This optional parameter specifies the interpolation method to use when the desired percentile lies between two data points &lt;code&gt;i &amp;lt; j&lt;/code&gt;:</source>
          <target state="translated">このオプションのパラメーターは、目的のパーセンタイルが2つのデータポイント &lt;code&gt;i &amp;lt; j&lt;/code&gt; 間にある場合に使用する補間方法を指定します。</target>
        </trans-unit>
        <trans-unit id="002fb17667dbbd628eca51b6e4ff99f2217649e0" translate="yes" xml:space="preserve">
          <source>This optional parameter specifies the interpolation method to use when the desired quantile lies between two data points &lt;code&gt;i &amp;lt; j&lt;/code&gt;:</source>
          <target state="translated">このオプションのパラメーターは、目的の変位値が2つのデータポイント &lt;code&gt;i &amp;lt; j&lt;/code&gt; 間にある場合に使用する補間方法を指定します。</target>
        </trans-unit>
        <trans-unit id="c342edf9966c2e18280c4d355db707b32be4bff5" translate="yes" xml:space="preserve">
          <source>This package was developed independently of NumPy and was integrated in version 1.17.0. The original repo is at &lt;a href=&quot;https://github.com/bashtage/randomgen&quot;&gt;https://github.com/bashtage/randomgen&lt;/a&gt;.</source>
          <target state="translated">このパッケージはNumPyから独立して開発され、バージョン1.17.0に統合されました。元のリポジトリは&lt;a href=&quot;https://github.com/bashtage/randomgen&quot;&gt;https://github.com/bashtage/randomgenにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c427139240278bee81f47cf48768438afbe39755" translate="yes" xml:space="preserve">
          <source>This page describes the numpy-specific API for accessing the contents of a numpy array from other C extensions. &lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; &amp;ndash; &lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#c.PyObject_GetBuffer&quot;&gt;&lt;code&gt;The Revised Buffer Protocol&lt;/code&gt;&lt;/a&gt; introduces similar, standardized API to Python 2.6 and 3.0 for any extension module to use. &lt;a href=&quot;http://cython.org/&quot;&gt;Cython&lt;/a&gt;&amp;rsquo;s buffer array support uses the &lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; API; see the &lt;a href=&quot;https://github.com/cython/cython/wiki/tutorials-numpy&quot;&gt;Cython numpy tutorial&lt;/a&gt;. Cython provides a way to write code that supports the buffer protocol with Python versions older than 2.6 because it has a backward-compatible implementation utilizing the array interface described here.</source>
          <target state="translated">このページでは、他のC拡張からnumpy配列のコンテンツにアクセスするためのnumpy固有のAPIについて説明します。&lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; &amp;ndash; &lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#c.PyObject_GetBuffer&quot;&gt; &lt;code&gt;The Revised Buffer Protocol&lt;/code&gt; &lt;/a&gt;は、Python 2.6および3.0と同様の標準化されたAPIを導入して、拡張モジュールを使用できるようにします。&lt;a href=&quot;http://cython.org/&quot;&gt;Cython&lt;/a&gt;のバッファアレイサポートは&lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; APIを使用します。&lt;a href=&quot;https://github.com/cython/cython/wiki/tutorials-numpy&quot;&gt;Cython numpyチュートリアルを&lt;/a&gt;ご覧ください。Cythonには、2.6より前のバージョンのPythonでバッファープロトコルをサポートするコードを作成する方法が用意されています。これは、ここで説明する配列インターフェースを利用した下位互換性のある実装だからです。</target>
        </trans-unit>
        <trans-unit id="4df30a5dfa3e83d5a58c4b3babfef2e8f4555a00" translate="yes" xml:space="preserve">
          <source>This page documents the API for the iterator. The iterator is named &lt;code&gt;NpyIter&lt;/code&gt; and functions are named &lt;code&gt;NpyIter_*&lt;/code&gt;.</source>
          <target state="translated">このページには、イテレータのAPIが記載されています。イテレータの名前は &lt;code&gt;NpyIter&lt;/code&gt; で、関数の名前は &lt;code&gt;NpyIter_*&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f3ed57ed2270d94087c1c0c02f79e8407d0327af" translate="yes" xml:space="preserve">
          <source>This page tackles common applications; for the full collection of I/O routines, see &lt;a href=&quot;../reference/routines.io#routines-io&quot;&gt;Input and output&lt;/a&gt;.</source>
          <target state="translated">このページでは、一般的なアプリケーションについて説明します。I / Oルーチンの完全なコレクションについては、「&lt;a href=&quot;../reference/routines.io#routines-io&quot;&gt;入力と出力&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="2ef493fa5f7ddfcfa2e56b59880c2ca13b04b480" translate="yes" xml:space="preserve">
          <source>This plot is not so readable since the lines seem to be over each other, so let&amp;rsquo;s summarize in a more elaborate plot. We&amp;rsquo;ll plot the real data when available, and show the cubic fit for unavailable data, using this fit to compute an estimate to the observed number of cases on January 28th 2020, 7 days after the beginning of the records:</source>
          <target state="translated">このプロットは、線が互いに重なっているように見えるため、あまり読みにくいので、より複雑なプロットに要約しましょう。利用可能な場合は実際のデータをプロットし、利用できないデータの3次近似を示します。この近似を使用して、レコードの開始から7日後の2020年1月28日に観測されたケース数の推定値を計算します。</target>
        </trans-unit>
        <trans-unit id="b79e823ebc32815d2b3460b90e34d0a2f9bed7dc" translate="yes" xml:space="preserve">
          <source>This pointer may be cached before the iteration loop, calling &lt;code&gt;iternext&lt;/code&gt; will not change it.</source>
          <target state="translated">このポインタは反復ループの前にキャッシュされる可能性があり、 &lt;code&gt;iternext&lt;/code&gt; を呼び出しても変更されません。</target>
        </trans-unit>
        <trans-unit id="484a465c1e928c7fbd45d4d74c7fee12a21c59d4" translate="yes" xml:space="preserve">
          <source>This pointer may be cached before the iteration loop, calling &lt;code&gt;iternext&lt;/code&gt; will not change it. This function may be safely called without holding the Python GIL.</source>
          <target state="translated">このポインタは反復ループの前にキャッシュされる可能性があり、 &lt;code&gt;iternext&lt;/code&gt; を呼び出しても変更されません。この関数は、Python GILを保持せずに安全に呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="bb65fa9e55962767929fe75ece2f7703e6ac5b10" translate="yes" xml:space="preserve">
          <source>This produces the correct answer, but if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; each contain millions of numbers, we will pay the price for the inefficiencies of looping in Python. We could accomplish the same task much more quickly in C by writing (for clarity we neglect variable declarations and initializations, memory allocation, etc.)</source>
          <target state="translated">これにより正しい答えが得られますが、 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; にそれぞれ数百万の数値が含まれている場合、 Pythonでのループの非効率性の代償を払います。Cでは、次のように記述することで、同じタスクをはるかに迅速に実行できます（わかりやすくするために、変数の宣言と初期化、メモリ割り当てなどは無視します）。</target>
        </trans-unit>
        <trans-unit id="fc50269460cb12e12865cbec85480d4b3e10a0a9" translate="yes" xml:space="preserve">
          <source>This property can be very useful in assignments:</source>
          <target state="translated">このプロパティは、課題に非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="af7b379b2fcb530df7b5c66e85d1051773a408df" translate="yes" xml:space="preserve">
          <source>This property is a view on the imaginary part of this &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このプロパティは、この&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; の&lt;/a&gt;虚数部のビューです。</target>
        </trans-unit>
        <trans-unit id="00b60d7136524e649c297d22303044023139f2d1" translate="yes" xml:space="preserve">
          <source>This property is a view on the imaginary part of this &lt;code&gt;MaskedArray&lt;/code&gt;.</source>
          <target state="translated">このプロパティは、この &lt;code&gt;MaskedArray&lt;/code&gt; の虚数部のビューです。</target>
        </trans-unit>
        <trans-unit id="9c2a714f693725c88c94ac2607ed6abee0322d99" translate="yes" xml:space="preserve">
          <source>This property is a view on the real part of this &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このプロパティは、この&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; の&lt;/a&gt;実際の部分のビューです。</target>
        </trans-unit>
        <trans-unit id="a4989179ebd897375fad9fc4e97f158afedfb6f9" translate="yes" xml:space="preserve">
          <source>This property is a view on the real part of this &lt;code&gt;MaskedArray&lt;/code&gt;.</source>
          <target state="translated">このプロパティは、この &lt;code&gt;MaskedArray&lt;/code&gt; の実数部のビューです。</target>
        </trans-unit>
        <trans-unit id="56ae11e0e5ca2982f115765c5eb4aa5c0c2cf88d" translate="yes" xml:space="preserve">
          <source>This reallocates space for the data area if necessary.</source>
          <target state="translated">これにより、必要に応じてデータ領域のスペースが再確保されます。</target>
        </trans-unit>
        <trans-unit id="3875a2efa104b3c26f06d6992550d8f8f4acd93f" translate="yes" xml:space="preserve">
          <source>This reference manual details functions, modules, and objects included in NumPy, describing what they are and what they do. For learning how to use NumPy, see also &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/index.html#user&quot;&gt;NumPy User Guide&lt;/a&gt;.</source>
          <target state="translated">このリファレンスマニュアルでは、NumPyに含まれる関数、モジュール、オブジェクトについて詳しく説明し、それらの機能と機能について説明します。NumPyの使用方法については、&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/index.html#user&quot;&gt;NumPyユーザーガイド&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="6b66394de331bbd119ed305c44c97cddcc296f65" translate="yes" xml:space="preserve">
          <source>This reference manual details functions, modules, and objects included in NumPy, describing what they are and what they do. For learning how to use NumPy, see the &lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;complete documentation&lt;/a&gt;.</source>
          <target state="translated">このリファレンスマニュアルでは、NumPyに含まれる関数、モジュール、およびオブジェクトについて詳しく説明し、それらの機能と機能について説明します。NumPyの使用方法については、&lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;完全なドキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="49d7d34fc7b59b4f57a8fc699678974df3138f8f" translate="yes" xml:space="preserve">
          <source>This returns a tuple of indices that can be used to access the main diagonal of an array &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; dimensions and shape (n, n, &amp;hellip;, n). For &lt;code&gt;a.ndim = 2&lt;/code&gt; this is the usual diagonal, for &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; this is the set of indices to access &lt;code&gt;a[i, i, ..., i]&lt;/code&gt; for &lt;code&gt;i = [0..n-1]&lt;/code&gt;.</source>
          <target state="translated">この戻りアクセスするアレイの主対角線に使用することができる指標のタプル &lt;code&gt;a&lt;/code&gt; 用いて &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; の寸法及び形状（N、N、...、N）。ため &lt;code&gt;a.ndim = 2&lt;/code&gt; これがため、通常の対角線である &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; これはアクセスするインデックスの集合である &lt;code&gt;a[i, i, ..., i]&lt;/code&gt; のために &lt;code&gt;i = [0..n-1]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="445408c5f27be1f1d331536d4e933a74a8f78cb0" translate="yes" xml:space="preserve">
          <source>This returns the base object of the array. In most cases, this means the object which owns the memory the array is pointing at.</source>
          <target state="translated">これは、配列の基底オブジェクトを返します。ほとんどの場合、これは配列が指し示しているメモリを所有するオブジェクトを意味します。</target>
        </trans-unit>
        <trans-unit id="86f639de88fe17b751b6b11b662442ef7819d4d2" translate="yes" xml:space="preserve">
          <source>This routine simply adds the elements in two contiguous arrays and places the result in a third. The memory for all three arrays must be provided by the calling routine. A very basic interface to this routine can be automatically generated by f2py:</source>
          <target state="translated">このルーチンは、単純に連続する 2 つの配列の要素を追加し、その結果を 3 つ目の配列に配置します。3つの配列すべてのメモリは、呼び出したルーチンによって提供されなければなりません。このルーチンの非常に基本的なインターフェースは、f2pyによって自動的に生成されます。</target>
        </trans-unit>
        <trans-unit id="a52ed8eb1e1cedf938d67a58ab208207008af6c7" translate="yes" xml:space="preserve">
          <source>This routine succeeds where ordinary &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt; does not:</source>
          <target state="translated">このルーチンは、通常の&lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt;が成功しない場合に成功します。</target>
        </trans-unit>
        <trans-unit id="9bca535321764a180aeb878b90cecb0b41abe3ad" translate="yes" xml:space="preserve">
          <source>This rule helps you anticipate how a vector will be printed, and conversely how to find the index of any of the printed elements. For instance, in the example, the last two values of 8&amp;rsquo;s index must be 0 and 2. Since 8 appears in the second of the two 2x3&amp;rsquo;s, the first index must be 1:</source>
          <target state="translated">このルールは、ベクトルがどのように印刷されるかを予測するのに役立ち、逆に、印刷された要素のインデックスを見つける方法を予測するのに役立ちます。たとえば、この例では、8のインデックスの最後の2つの値は0と2である必要があります。2つの2x3の2番目に8が表示されるため、最初のインデックスは1である必要があります。</target>
        </trans-unit>
        <trans-unit id="bb5cd927267b8c85989f3387ce0a0d2359a4663d" translate="yes" xml:space="preserve">
          <source>This saves all the overhead involved in interpreting the Python code and manipulating Python objects, but at the expense of the benefits gained from coding in Python. Furthermore, the coding work required increases with the dimensionality of our data. In the case of a 2-D array, for example, the C code (abridged as before) expands to</source>
          <target state="translated">これにより、Pythonコードの解釈やPythonオブジェクトの操作に関わるすべてのオーバーヘッドを節約することができますが、Pythonでコーディングすることで得られる利点を犠牲にしています。さらに、必要なコーディング作業は、データの次元が高くなるにつれて増加します。例えば、2次元配列の場合、C言語のコードは(以前のように簡略化されていますが)次のように拡張されます。</target>
        </trans-unit>
        <trans-unit id="eb7064b0e5d0b37eaed95ef4ac40f47e88476c2d" translate="yes" xml:space="preserve">
          <source>This scheme does require that you avoid reusing stream IDs. This may require coordination between the parallel processes.</source>
          <target state="translated">この方式では、ストリーム ID の再利用を避ける必要があります。これは、並列プロセス間の調整が必要になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="1aa4791ff179e31578c8776ff4ea075ff10d4756" translate="yes" xml:space="preserve">
          <source>This section and the next describe in detail how to set up git for working with the NumPy source code. If you have git already set up, skip to &lt;a href=&quot;../development_workflow#development-workflow&quot;&gt;Development workflow&lt;/a&gt;.</source>
          <target state="translated">このセクションと次のセクションでは、NumPyソースコードを操作するためにgitを設定する方法について詳しく説明します。gitをすでに設定している場合は、&lt;a href=&quot;../development_workflow#development-workflow&quot;&gt;開発ワークフロー&lt;/a&gt;にスキップしてください。</target>
        </trans-unit>
        <trans-unit id="e071a3347f38c194bd96c7f6d94e6b8f7990250d" translate="yes" xml:space="preserve">
          <source>This section describes how the basic universal function computation loop is setup and executed for each of the three different kinds of execution. If &lt;a href=&quot;c-api/array#c.NPY_ALLOW_THREADS&quot;&gt;&lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; is defined during compilation, then as long as no object arrays are involved, the Python Global Interpreter Lock (GIL) is released prior to calling the loops. It is re-acquired if necessary to handle error conditions. The hardware error flags are checked only after the 1-D loop is completed.</source>
          <target state="translated">このセクションでは、3種類の実行のそれぞれについて、基本的なユニバーサル関数計算ループを設定して実行する方法について説明します。コンパイル中に&lt;a href=&quot;c-api/array#c.NPY_ALLOW_THREADS&quot;&gt; &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; &lt;/a&gt;が定義されている場合、オブジェクト配列が含まれていない限り、ループを呼び出す前にPythonグローバルインタープリターロック（GIL）が解放されます。エラー状態を処理するために、必要に応じて再取得されます。ハードウェアエラーフラグは、1-Dループが完了した後にのみチェックされます。</target>
        </trans-unit>
        <trans-unit id="d2295424cf2146c8c588e01472068b4499bd8664" translate="yes" xml:space="preserve">
          <source>This section describes how the basic universal function computation loop is setup and executed for each of the three different kinds of execution. If &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; is defined during compilation, then as long as no object arrays are involved, the Python Global Interpreter Lock (GIL) is released prior to calling the loops. It is re-acquired if necessary to handle error conditions. The hardware error flags are checked only after the 1-D loop is completed.</source>
          <target state="translated">このセクションでは、3つの異なる種類の実行それぞれに対して、基本的なユニバーサル関数計算ループがどのようにセットアップおよび実行されるかについて説明します。コンパイル中に &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; が定義されている場合、オブジェクト配列が関係しない限り、ループを呼び出す前にPythonグローバルインタープリターロック（GIL）が解放されます。エラー状態を処理する必要がある場合は、再取得されます。ハードウェアエラーフラグは、1-Dループが完了した後にのみチェックされます。</target>
        </trans-unit>
        <trans-unit id="36d38a5b23b654b48926d888ff2f70f4fd6663ca" translate="yes" xml:space="preserve">
          <source>This section describes the governance and leadership model of The Project.</source>
          <target state="translated">ここでは、The Projectのガバナンスとリーダーシップモデルについて説明します。</target>
        </trans-unit>
        <trans-unit id="387c13e7d204cf584e66117f50223922b47b0d67" translate="yes" xml:space="preserve">
          <source>This section should be used judiciously, i.e., only for errors that are non-obvious or have a large chance of getting raised.</source>
          <target state="translated">この部分は、自明ではない誤りや、上がる確率が大きい誤りに限って判断して使用するべきです。</target>
        </trans-unit>
        <trans-unit id="cf292081ef6e3f6d3a2a86d3bb95335c9be71e92" translate="yes" xml:space="preserve">
          <source>This section should use the &lt;code&gt;deprecated&lt;/code&gt; Sphinx directive instead of an underlined section header.</source>
          <target state="translated">このセクションでは、下線付きのセクションヘッダーではなく、 &lt;code&gt;deprecated&lt;/code&gt; Sphinxディレクティブを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="0a9b94d3eaea207d20a5173591fa4612902baa5c" translate="yes" xml:space="preserve">
          <source>This section will not cover means of replicating, joining, or otherwise expanding or mutating existing arrays. Nor will it cover creating object arrays or structured arrays. Both of those are covered in their own sections.</source>
          <target state="translated">このセクションでは、既存の配列を複製したり、結合したり、その他の方法で拡張したり、突然変異させたりする方法は扱いません。また、オブジェクト配列や構造化された配列を作成する方法も扱いません。これらについては、それぞれのセクションで説明します。</target>
        </trans-unit>
        <trans-unit id="9a18449ed2fc82d845556e8871f21b5f905f1f97" translate="yes" xml:space="preserve">
          <source>This should be read together with the general directions in &lt;code&gt;releasing&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;releasing&lt;/code&gt; 一般的な指示と一緒に読む必要があります。</target>
        </trans-unit>
        <trans-unit id="af85e32a0a54092009ceae627c9327451013292e" translate="yes" xml:space="preserve">
          <source>This should not be confused with:</source>
          <target state="translated">と混同してはいけません。</target>
        </trans-unit>
        <trans-unit id="281bd1fc18f2200e68ef811b640b0f24111b0170" translate="yes" xml:space="preserve">
          <source>This simply has the effect of switching the definitions of &lt;code&gt;arg1&lt;/code&gt; and &lt;code&gt;arg2&lt;/code&gt; in lines 3 and 4 of the generated code above, and their assignments in lines 19 and 20.</source>
          <target state="translated">これは単に、上記の生成されたコードの3行目と4行目の &lt;code&gt;arg1&lt;/code&gt; と &lt;code&gt;arg2&lt;/code&gt; の定義と、19行目と20行目の割り当てを切り替える効果があります。</target>
        </trans-unit>
        <trans-unit id="54a1fbc955c54345f701059c4adac18f9144af8f" translate="yes" xml:space="preserve">
          <source>This single module should provide all the common functionality for numpy tests in a single location, so that &lt;a href=&quot;../dev/development_environment#development-environment&quot;&gt;test scripts&lt;/a&gt; can just import it and work right away. For background, see the &lt;a href=&quot;testing#testing-guidelines&quot;&gt;Testing Guidelines&lt;/a&gt;</source>
          <target state="translated">この単一のモジュールは、&lt;a href=&quot;../dev/development_environment#development-environment&quot;&gt;テストスクリプト&lt;/a&gt;がそれをインポートしてすぐに機能できるように、単一の場所でnumpyテストのすべての一般的な機能を提供する必要があります。背景については、&lt;a href=&quot;testing#testing-guidelines&quot;&gt;テストガイドラインを&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="d5f0ce6428ed7ce9a3f007ac820d6ad83fbe35d9" translate="yes" xml:space="preserve">
          <source>This single module should provide all the common functionality for numpy tests in a single location, so that &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/dev/development_environment.html#development-environment&quot;&gt;test scripts&lt;/a&gt; can just import it and work right away. For background, see the &lt;a href=&quot;testing#testing-guidelines&quot;&gt;Testing Guidelines&lt;/a&gt;</source>
          <target state="translated">この単一のモジュールは、numpyテストのすべての一般的な機能を単一の場所で提供する必要があります。これにより、&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/dev/development_environment.html#development-environment&quot;&gt;テストスクリプト&lt;/a&gt;は、それをインポートしてすぐに機能します。背景については、&lt;a href=&quot;testing#testing-guidelines&quot;&gt;テストガイドラインを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e97f89b724acb7f31f3f94df4fb5ca630be7277b" translate="yes" xml:space="preserve">
          <source>This sort of mutation is not allowed by the types. Users who want to write statically typed code should insted use the &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;numpy.ndarray.view&lt;/code&gt;&lt;/a&gt; method to create a view of the array with a different dtype.</source>
          <target state="translated">この種の突然変異は、タイプによって許可されていません。静的に型指定されたコードを記述したいユーザーは、&lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt; &lt;code&gt;numpy.ndarray.view&lt;/code&gt; &lt;/a&gt;メソッドを使用して、異なるdtypeで配列のビューを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="feb22e5bb35e33b30ed01dab66654627fe20956a" translate="yes" xml:space="preserve">
          <source>This specifies the &amp;ldquo;intention&amp;rdquo; of the corresponding argument. &lt;code&gt;&amp;lt;intentspec&amp;gt;&lt;/code&gt; is a comma separated list of the following keys:</source>
          <target state="translated">これは、対応する引数の「意図」を指定します。 &lt;code&gt;&amp;lt;intentspec&amp;gt;&lt;/code&gt; は、次のキーのコンマ区切りのリストです。</target>
        </trans-unit>
        <trans-unit id="5e999bfd9ee7986bb74545207acc796f3e46abd8" translate="yes" xml:space="preserve">
          <source>This specifies which warnings to configure as &amp;lsquo;raise&amp;rsquo; instead of being shown once during the test execution. Valid strings are:</source>
          <target state="translated">これは、テストの実行中に1回表示されるのではなく、「発生」として構成する警告を指定します。有効な文字列は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="355c08a8b685b52031d6593cc7642f8973231125" translate="yes" xml:space="preserve">
          <source>This step is only needed for final releases and can be skipped for pre-releases. &lt;code&gt;make merge-doc&lt;/code&gt; clones the &lt;code&gt;numpy/doc&lt;/code&gt; repo into &lt;code&gt;doc/build/merge&lt;/code&gt; and updates it with the new documentation:</source>
          <target state="translated">この手順は最終リリースでのみ必要であり、プレリリースではスキップできます。 &lt;code&gt;make merge-doc&lt;/code&gt; は、 &lt;code&gt;numpy/doc&lt;/code&gt; リポジトリを &lt;code&gt;doc/build/merge&lt;/code&gt; に複製し、新しいドキュメントで更新します。</target>
        </trans-unit>
        <trans-unit id="f04c1b598b018608346e9a082214a1abd34ac499" translate="yes" xml:space="preserve">
          <source>This string will be used as the marker for missing data for all the columns</source>
          <target state="translated">この文字列は、すべての列の欠落データのマーカーとして使用されます。</target>
        </trans-unit>
        <trans-unit id="d96875a0b29939a3e2bb067cb066089a92949861" translate="yes" xml:space="preserve">
          <source>This structure is very useful when shape and/or strides information is supposed to be interpreted. The structure is:</source>
          <target state="translated">この構造は、形状および/またはストライド情報が解釈されることになっている場合に非常に有用である。この構造体は</target>
        </trans-unit>
        <trans-unit id="f5377b9ec1ee34b1b46afca48f12d70eda083569" translate="yes" xml:space="preserve">
          <source>This style allows passing in the &lt;a href=&quot;generated/numpy.dtype.fields#numpy.dtype.fields&quot;&gt;&lt;code&gt;fields&lt;/code&gt;&lt;/a&gt; attribute of a data-type object.</source>
          <target state="translated">このスタイルでは、データ型オブジェクトの&lt;a href=&quot;generated/numpy.dtype.fields#numpy.dtype.fields&quot;&gt; &lt;code&gt;fields&lt;/code&gt; &lt;/a&gt;属性を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="8baa5c3fa91f9d82d5f372676363ca92358b6704" translate="yes" xml:space="preserve">
          <source>This style does not accept &lt;em&gt;align&lt;/em&gt; in the &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; constructor as it is assumed that all of the memory is accounted for by the array interface description.</source>
          <target state="translated">このスタイルは、すべてのメモリが配列インターフェイスの記述によって占められていると想定されている&lt;em&gt;ため&lt;/em&gt;、&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;コンストラクターでは&lt;em&gt;align&lt;/em&gt;を受け入れません。</target>
        </trans-unit>
        <trans-unit id="63b067d6a5e8e9587ae90576ba34210d81e53f6b" translate="yes" xml:space="preserve">
          <source>This style has two required and three optional keys. The &lt;em&gt;names&lt;/em&gt; and &lt;em&gt;formats&lt;/em&gt; keys are required. Their respective values are equal-length lists with the field names and the field formats. The field names must be strings and the field formats can be any object accepted by &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">このスタイルには、2つの必須キーと3つのオプションキーがあります。&lt;em&gt;名前&lt;/em&gt;と&lt;em&gt;形式&lt;/em&gt;のキーが必要とされています。それぞれの値は、フィールド名とフィールド形式を含む長さの等しいリストです。フィールド名は文字列である必要があり、フィールド形式は&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;コンストラクターが受け入れる任意のオブジェクトにすることができます。</target>
        </trans-unit>
        <trans-unit id="9fd39c592746d75bfe12bf10bab5bf15e715d323" translate="yes" xml:space="preserve">
          <source>This subclass of ndarray has some unpleasant interactions with some operations, because it doesn&amp;rsquo;t quite fit properly as a subclass. An alternative to using this subclass is to create the &lt;code&gt;mmap&lt;/code&gt; object yourself, then create an ndarray with ndarray.__new__ directly, passing the object created in its &amp;lsquo;buffer=&amp;rsquo; parameter.</source>
          <target state="translated">このndarrayのサブクラスは、サブクラスとして適切に適合しないため、いくつかの操作との不愉快な相互作用があります。このサブクラスを使用する代わりに、 &lt;code&gt;mmap&lt;/code&gt; オブジェクトを自分で作成し、ndarray .__ new__を使用してndarrayを直接作成し、作成したオブジェクトを 'buffer ='パラメーターで渡します。</target>
        </trans-unit>
        <trans-unit id="8a52b4cb6a8af65abce36bb79c9c41aa8777063c" translate="yes" xml:space="preserve">
          <source>This tells you that you are currently on the &lt;code&gt;master&lt;/code&gt; branch, and that you also have a &lt;code&gt;remote&lt;/code&gt; connection to &lt;code&gt;origin/master&lt;/code&gt;. What remote repository is &lt;code&gt;remote/origin&lt;/code&gt;? Try &lt;code&gt;git remote -v&lt;/code&gt; to see the URLs for the remote. They will point to your &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; fork.</source>
          <target state="translated">これは、現在 &lt;code&gt;master&lt;/code&gt; ブランチにいること、および &lt;code&gt;origin/master&lt;/code&gt; への &lt;code&gt;remote&lt;/code&gt; 接続もあることを示しています。 &lt;code&gt;remote/origin&lt;/code&gt; はどのリモートリポジトリですか？ &lt;code&gt;git remote -v&lt;/code&gt; を試して、リモートのURLを確認してください。彼らはあなたの&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;フォークを指します。</target>
        </trans-unit>
        <trans-unit id="49e089f7d3412f57a533b95b4289e1725ee616b3" translate="yes" xml:space="preserve">
          <source>This template converter will replicate all &lt;strong&gt;function&lt;/strong&gt; and &lt;strong&gt;subroutine&lt;/strong&gt; blocks in the file with names that contain &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo; according to the rules in &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo;. The number of comma-separated words in &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo; determines the number of times the block is repeated. What these words are indicates what that repeat rule, &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo;, should be replaced with in each block. All of the repeat rules in a block must contain the same number of comma-separated words indicating the number of times that block should be repeated. If the word in the repeat rule needs a comma, leftarrow, or rightarrow, then prepend it with a backslash &amp;lsquo; &amp;lsquo;. If a word in the repeat rule matches &amp;lsquo; \&amp;lt;index&amp;gt;&amp;rsquo; then it will be replaced with the &amp;lt;index&amp;gt;-th word in the same repeat specification. There are two forms for the repeat rule: named and short.</source>
          <target state="translated">このテンプレートコンバーターは、すべての&lt;strong&gt;関数&lt;/strong&gt;と&lt;strong&gt;サブルーチン&lt;/strong&gt;を複製し&lt;strong&gt;ます&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;「&amp;lt;&amp;hellip;&amp;gt;」の規則に従って、「&amp;lt;&amp;hellip;&amp;gt;」を含む名前のファイル内のブロック。 '&amp;lt;&amp;hellip;&amp;gt;'内のコンマ区切りの単語の数により、ブロックが繰り返される回数が決まります。これらの単語が何であるかは、その繰り返しルール「&amp;lt;&amp;hellip;&amp;gt;」を各ブロックで置き換える必要があるものを示しています。ブロック内のすべての繰り返しルールには、ブロックを繰り返す必要がある回数を示す、同じ数のコンマ区切りの単語が含まれている必要があります。繰り返しルールの単語にコンマ、左矢印、または右矢印が必要な場合は、その前にバックスラッシュ「」を付けます。繰り返しルールの単語が「\ &amp;lt;インデックス&amp;gt;」に一致する場合、同じ繰り返し指定の&amp;lt;インデックス&amp;gt;番目の単語に置き換えられます。繰り返しルールには、名前付きと短縮の2つの形式があります。</target>
        </trans-unit>
        <trans-unit id="7b0c224585cc04560ef8f7427d408f831662e6b0" translate="yes" xml:space="preserve">
          <source>This tutorial is for people who have a basic understanding of NumPy and want to understand how masked arrays and the &lt;a href=&quot;../reference/maskedarray.generic#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module can be used in practice.</source>
          <target state="translated">このチュートリアルは、NumPyの基本を理解していて、マスクされた配列と&lt;a href=&quot;../reference/maskedarray.generic#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt;モジュールを実際に使用する方法を理解したい人を対象としています。</target>
        </trans-unit>
        <trans-unit id="e17f08578fff4f4b7f45b2cc421b1a2466a7ddfd" translate="yes" xml:space="preserve">
          <source>This tutorial is for people who have a basic understanding of linear algebra and arrays in NumPy and want to understand how n-dimensional (</source>
          <target state="translated">このチュートリアルは,NumPyの線形代数と配列の基本的な理解があり,n次元(</target>
        </trans-unit>
        <trans-unit id="1f4e248732bbeee435a6603f84a77d8416a7d7b4" translate="yes" xml:space="preserve">
          <source>This tutorial is intended as a quick overview of algebra and arrays in NumPy and want to understand how n-dimensional (</source>
          <target state="translated">このチュートリアルは、NumPyの代数と配列の概要を簡単に説明し、n次元(</target>
        </trans-unit>
        <trans-unit id="f3fb6c8e0c4b1a20c93f451ff612ab566979e83c" translate="yes" xml:space="preserve">
          <source>This type provides an iterator that encapsulates the concept of broadcasting. It allows</source>
          <target state="translated">この型は,ブロードキャストの概念をカプセル化したイテレータを提供します.これにより</target>
        </trans-unit>
        <trans-unit id="1cc43cfc53c5139a19951c354fea30226e0f77c2" translate="yes" xml:space="preserve">
          <source>This updates your feature branch with changes from the upstream &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;NumPy github&lt;/a&gt; repo. If you do not absolutely need to do this, try to avoid doing it, except perhaps when you are finished. The first step will be to update the remote repository with new commits from upstream:</source>
          <target state="translated">これにより、アップストリームの&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;NumPygithub&lt;/a&gt;リポジトリからの変更で機能ブランチが更新されます。絶対にこれを行う必要がない場合は、おそらく終了したときを除いて、それを行わないようにしてください。最初のステップは、アップストリームからの新しいコミットでリモートリポジトリを更新することです。</target>
        </trans-unit>
        <trans-unit id="fedc2274acc4b818673988228fa9cde0f7271aad" translate="yes" xml:space="preserve">
          <source>This usage is discouraged, because it is ambiguous with the other dict-based construction method. If you have a field called &amp;lsquo;names&amp;rsquo; and a field called &amp;lsquo;formats&amp;rsquo; there will be a conflict.</source>
          <target state="translated">他のdictベースの構築方法とはあいまいなので、この使用はお勧めできません。「名前」というフィールドと「フォーマット」というフィールドがある場合、競合が発生します。</target>
        </trans-unit>
        <trans-unit id="57872c5abdb149b7d4963cf4f155c74d4913dff4" translate="yes" xml:space="preserve">
          <source>This version replaces the ASCII string (which in practice was latin1) with a utf8-encoded string, so supports structured types with any unicode field names.</source>
          <target state="translated">このバージョンでは、ASCII 文字列 (実際には latin1)を utf8 エンコードされた文字列に置き換えているので、任意の unicode フィールド名を持つ構造化型をサポートしています。</target>
        </trans-unit>
        <trans-unit id="edc2f7bd6317d38177dd997f322c5b71aa234a4f" translate="yes" xml:space="preserve">
          <source>This view has the same dtype and itemsize as the indexed field, so it is typically a non-structured array, except in the case of nested structures.</source>
          <target state="translated">このビューは、インデックス化されたフィールドと同じdtypeとitemizeを持つので、入れ子構造の場合を除いて、通常は非構造化配列です。</target>
        </trans-unit>
        <trans-unit id="f66a767f0f656eca452c102d2e2bcfa75e3b2eec" translate="yes" xml:space="preserve">
          <source>This way of working helps to keep work well organized and the history as clear as possible.</source>
          <target state="translated">このような働き方をすることで、仕事の整理整頓や歴史をできるだけ明確にすることができます。</target>
        </trans-unit>
        <trans-unit id="bd10a8b1d06600ccbaab74bb218a771768eae1ee" translate="yes" xml:space="preserve">
          <source>This will ask for your key PGP passphrase, in order to sign the built source packages.</source>
          <target state="translated">これは、ビルドされたソースパッケージに署名するために、あなたの鍵となる PGP パスフレーズを要求します。</target>
        </trans-unit>
        <trans-unit id="3b6efd49b695f694142bfb54798d0f3fc1890e14" translate="yes" xml:space="preserve">
          <source>This will be a new view object if possible; otherwise, it will be a copy. Note there is no guarantee of the &lt;em&gt;memory layout&lt;/em&gt; (C- or Fortran- contiguous) of the returned array.</source>
          <target state="translated">可能であれば、これは新しいビューオブジェクトになります。それ以外の場合は、コピーになります。返される配列の&lt;em&gt;メモリレイアウト&lt;/em&gt;（CまたはFortran隣接）の保証はありません。</target>
        </trans-unit>
        <trans-unit id="8a5efb1ea8118b8207bdfa5a6ca70f84b9755cf3" translate="yes" xml:space="preserve">
          <source>This will be the default for all columns</source>
          <target state="translated">これがすべてのカラムのデフォルトとなります。</target>
        </trans-unit>
        <trans-unit id="6ee2bb240a6f906f9c6caaca502a22c771c78509" translate="yes" xml:space="preserve">
          <source>This will compile numpy on 4 CPUs and install it into the specified prefix. to perform a parallel in-place build, run:</source>
          <target state="translated">これにより、4つのCPUでnumpyがコンパイルされ、指定されたプレフィックスにインストールされます。</target>
        </trans-unit>
        <trans-unit id="82de4d27fe00c2e50e0f9b4ff494406f1e8a2a9f" translate="yes" xml:space="preserve">
          <source>This will create a report in &lt;code&gt;build/coverage&lt;/code&gt;, which can be viewed with:</source>
          <target state="translated">これにより、 &lt;code&gt;build/coverage&lt;/code&gt; でレポートが作成され、次のコマンドで表示できます。</target>
        </trans-unit>
        <trans-unit id="8933167843c02b6efd0369f05c57b0cadbffbc22" translate="yes" xml:space="preserve">
          <source>This will install the file foo.ini into the directory package_dir/lib, and the foo.ini file will be generated from foo.ini.in, where each &lt;code&gt;@version@&lt;/code&gt; will be replaced by &lt;code&gt;subst_dict['version']&lt;/code&gt;. The dictionary has an additional prefix substitution rule automatically added, which contains the install prefix (since this is not easy to get from setup.py). npy-pkg-config files can also be installed at the same location as used for numpy, using the path returned from &lt;code&gt;get_npy_pkg_dir&lt;/code&gt; function.</source>
          <target state="translated">これにより、ファイルfoo.iniがディレクトリpackage_dir / libにインストールされ、foo.iniファイルはfoo.ini.inから生成されます。各 &lt;code&gt;@version@&lt;/code&gt; は &lt;code&gt;subst_dict['version']&lt;/code&gt; 置き換えられます。辞書には追加のプレフィックス置換ルールが自動的に追加されており、インストールプレフィックスが含まれています（これはsetup.pyから取得するのは簡単ではないためです）。npy-pkg-configファイルは、 &lt;code&gt;get_npy_pkg_dir&lt;/code&gt; 関数から返されたパスを使用して、numpyと同じ場所にインストールすることもできます。</target>
        </trans-unit>
        <trans-unit id="520884ce9a07e1b7b3267f965a90c87f51ddd2d6" translate="yes" xml:space="preserve">
          <source>This will open an editor with the following text in it:</source>
          <target state="translated">これで、以下のようなテキストが入ったエディタが開きます。</target>
        </trans-unit>
        <trans-unit id="939c7c1369b63ae063d5f436c52d25c44b07c327" translate="yes" xml:space="preserve">
          <source>This will produce an extension module named filter.so in the current directory with a method named dfilter2d that returns a filtered version of the input.</source>
          <target state="translated">これにより、現在のディレクトリにfilter.soという名前の拡張モジュールが生成され、dfilter2dという名前のメソッドが入力のフィルタリングされたバージョンを返します。</target>
        </trans-unit>
        <trans-unit id="da4b4079ec57ef48d099df7ab2d17f04629ceaf5" translate="yes" xml:space="preserve">
          <source>This will work with MSVC, which otherwise chokes on very long strings.</source>
          <target state="translated">これはMSVCと連携して動作しますが、そうでなければ非常に長い弦で窒息してしまいます。</target>
        </trans-unit>
        <trans-unit id="09f5f63667326a5abebdc8b9ee9a7240e62a05f5" translate="yes" xml:space="preserve">
          <source>This will write the settings into your git configuration file, which should now contain a user section with your name and email:</source>
          <target state="translated">これで設定が git の設定ファイルに書き込まれ、ユーザーセクションにはあなたの名前とメールアドレスが含まれるようになりました。</target>
        </trans-unit>
        <trans-unit id="00582fa3dde2e164fba27e484b480804eaaba584" translate="yes" xml:space="preserve">
          <source>This works for both standard installs and in-place builds, i.e. the &lt;code&gt;@prefix@&lt;/code&gt; refer to the source directory for in-place builds.</source>
          <target state="translated">これは、標準インストールとインプレースビルドの両方で機能します。つまり、 &lt;code&gt;@prefix@&lt;/code&gt; は、インプレースビルドのソースディレクトリを指します。</target>
        </trans-unit>
        <trans-unit id="8dbc0909265236a8e2f517b68e39944b2e4da272" translate="yes" xml:space="preserve">
          <source>Those can be useful for precise floating point comparison.</source>
          <target state="translated">これらは、正確な浮動小数点比較を行うのに便利です。</target>
        </trans-unit>
        <trans-unit id="ae29a3649bad434c98c44c18fb3c7ec696b132a3" translate="yes" xml:space="preserve">
          <source>Those who want really good performance out of their low level operations should strongly consider directly using the iteration API provided in C, but for those who are not comfortable with C or C++, Cython is a good middle ground with reasonable performance tradeoffs. For the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object, this means letting the iterator take care of broadcasting, dtype conversion, and buffering, while giving the inner loop to Cython.</source>
          <target state="translated">低レベルの操作から本当に良いパフォーマンスを望んでいる人は、Cで提供されている反復APIを直接使用することを強く検討する必要があります。用&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; の&lt;/a&gt;オブジェクト、Cythonに内側のループを与えながら、放送、DTYPE変換、バッファリングのイテレータの世話をさせるこの手段。</target>
        </trans-unit>
        <trans-unit id="69a5e45c8dfd90560d7c862ef6ebab38e4725ee6" translate="yes" xml:space="preserve">
          <source>Though the demonstrated way of wrapping Fortran routines to Python is very straightforward, it has several drawbacks (see the comments above). These drawbacks are due to the fact that there is no way that F2PY can determine what is the actual intention of one or the other argument, is it input or output argument, or both, or something else. So, F2PY conservatively assumes that all arguments are input arguments by default.</source>
          <target state="translated">FortranルーチンをPythonにラップする方法は非常に簡単ですが、いくつかの欠点があります(上のコメントを参照)。これらの欠点は、F2PYが一方の引数が入力引数なのか出力引数なのか、あるいは両方なのか、あるいは他方の引数が何を意図しているのかを判断することができないという事実に起因します。そのため、F2PYは保守的に、デフォルトではすべての引数が入力引数であると仮定しています。</target>
        </trans-unit>
        <trans-unit id="4ea9f95f9e9b92d3d1f748e1eafd1b88bb106fab" translate="yes" xml:space="preserve">
          <source>Though we welcome people fluent in all languages, NumPy development is conducted in English.</source>
          <target state="translated">全ての言語に堪能な方を歓迎しますが、NumPyの開発は英語で行っています。</target>
        </trans-unit>
        <trans-unit id="98cd6421fe23fe93d73ba2b3eea2e1d452707c95" translate="yes" xml:space="preserve">
          <source>Thread safe f2py callback functions</source>
          <target state="translated">スレッドセーフなf2pyのコールバック関数</target>
        </trans-unit>
        <trans-unit id="35e557dff981ec6af1be9c041d1715ad421f55bd" translate="yes" xml:space="preserve">
          <source>Threading support</source>
          <target state="translated">スレッディングサポート</target>
        </trans-unit>
        <trans-unit id="2d3ac6352887bde0f838813d8ea2d7bd7a567c2f" translate="yes" xml:space="preserve">
          <source>Three common use cases are:</source>
          <target state="translated">3つの一般的なユースケースがあります。</target>
        </trans-unit>
        <trans-unit id="cfe35da7de09a2e27452780257d1fa8fced9ae75" translate="yes" xml:space="preserve">
          <source>Three ways to wrap - getting started</source>
          <target state="translated">3つの包み方~始めよう</target>
        </trans-unit>
        <trans-unit id="987f8885750fc51202cc3964c96525b26400aa8c" translate="yes" xml:space="preserve">
          <source>Three-by-two array of random numbers from [-5, 0):</source>
          <target state="translated">5,0)からの乱数の3×2配列。</target>
        </trans-unit>
        <trans-unit id="648f2b8e04236f9ba0d33739777255491d46f3b0" translate="yes" xml:space="preserve">
          <source>Threshold below which SVD values are considered zero. If &lt;code&gt;tol&lt;/code&gt; is None, and &lt;code&gt;S&lt;/code&gt; is an array with singular values for &lt;code&gt;M&lt;/code&gt;, and &lt;code&gt;eps&lt;/code&gt; is the epsilon value for datatype of &lt;code&gt;S&lt;/code&gt;, then &lt;code&gt;tol&lt;/code&gt; is set to &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt;.</source>
          <target state="translated">SVD値がゼロと見なされるしきい値。場合 &lt;code&gt;tol&lt;/code&gt; Noneです、そして &lt;code&gt;S&lt;/code&gt; は特異の値を持つ配列であり、 &lt;code&gt;M&lt;/code&gt; 、及び &lt;code&gt;eps&lt;/code&gt; のデータ型のイプシロン値であり、 &lt;code&gt;S&lt;/code&gt; は、 &lt;code&gt;tol&lt;/code&gt; に設定されている &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a18ce980b9b6a0af6ba5335aa5043a3f61a2139" translate="yes" xml:space="preserve">
          <source>Throw a dice 20 times:</source>
          <target state="translated">サイコロを20回投げる。</target>
        </trans-unit>
        <trans-unit id="e8597c496d58a52fd023424932f79f11d89743f4" translate="yes" xml:space="preserve">
          <source>Thus, tuples might be thought of as the native Python equivalent to numpy&amp;rsquo;s structured types, much like native python integers are the equivalent to numpy&amp;rsquo;s integer types. Structured scalars may be converted to a tuple by calling &lt;a href=&quot;../reference/generated/numpy.ndarray.item#numpy.ndarray.item&quot;&gt;&lt;code&gt;numpy.ndarray.item&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">したがって、タプルは、ネイティブPython整数がnumpyの整数型と同等であるのと同様に、numpyの構造化型と同等のネイティブPythonと見なすことができます。構造化スカラーは、&lt;a href=&quot;../reference/generated/numpy.ndarray.item#numpy.ndarray.item&quot;&gt; &lt;code&gt;numpy.ndarray.item&lt;/code&gt; &lt;/a&gt;を呼び出すことでタプルに変換できます。</target>
        </trans-unit>
        <trans-unit id="c6c62c18ed666f3768ae228e6da435d58941de5d" translate="yes" xml:space="preserve">
          <source>Thus, tuples might be thought of as the native Python equivalent to numpy&amp;rsquo;s structured types, much like native python integers are the equivalent to numpy&amp;rsquo;s integer types. Structured scalars may be converted to a tuple by calling &lt;code&gt;ndarray.item&lt;/code&gt;:</source>
          <target state="translated">したがって、タプルは、ネイティブPython整数がnumpyの整数型と同等であるのと同様に、numpyの構造化型と同等のネイティブPythonと考えることができます。構造化スカラーは、 &lt;code&gt;ndarray.item&lt;/code&gt; を呼び出すことでタプルに変換できます。</target>
        </trans-unit>
        <trans-unit id="699ce8b0c5a25495e7df7b31eb754f06f5937265" translate="yes" xml:space="preserve">
          <source>Tile an array.</source>
          <target state="translated">配列をタイル状にします。</target>
        </trans-unit>
        <trans-unit id="9478b387e78ee7ed878f28def0d9d737a40db3cf" translate="yes" xml:space="preserve">
          <source>Tiling arrays</source>
          <target state="translated">タイリング配列</target>
        </trans-unit>
        <trans-unit id="ae9e32a7bf76d858a6643fb3d615f4e6b741df45" translate="yes" xml:space="preserve">
          <source>Time span (absolute)</source>
          <target state="translated">タイムスパン(絶対値)</target>
        </trans-unit>
        <trans-unit id="83a0b67f984af7843f2cd5f9c4c4a4937a96b824" translate="yes" xml:space="preserve">
          <source>Time span (relative)</source>
          <target state="translated">タイムスパン(相対</target>
        </trans-unit>
        <trans-unit id="f427901653e2f16331f232b03616db8d30b0bf3e" translate="yes" xml:space="preserve">
          <source>Timedelta</source>
          <target state="translated">Timedelta</target>
        </trans-unit>
        <trans-unit id="4c953c5dc449ee95c79ccb8a9c6463f3dce00860" translate="yes" xml:space="preserve">
          <source>Timedelta64</source>
          <target state="translated">Timedelta64</target>
        </trans-unit>
        <trans-unit id="a836f04893b4c22a5902f8a189928c3d93f72795" translate="yes" xml:space="preserve">
          <source>Timezone information to use when displaying the datetime. If &amp;lsquo;UTC&amp;rsquo;, end with a Z to indicate UTC time. If &amp;lsquo;local&amp;rsquo;, convert to the local timezone first, and suffix with a +-#### timezone offset. If a tzinfo object, then do as with &amp;lsquo;local&amp;rsquo;, but use the specified timezone.</source>
          <target state="translated">日時を表示するときに使用するタイムゾーン情報。「UTC」の場合、UTC時間を示すZで終了します。「ローカル」の場合、最初にローカルタイムゾーンに変換し、接尾辞に+-####タイムゾーンオフセットを付けます。tzinfoオブジェクトの場合は、 'local'と同じようにしますが、指定されたタイムゾーンを使用します。</target>
        </trans-unit>
        <trans-unit id="73a38ab3a76b2ed7df0194513c7633ac39221da4" translate="yes" xml:space="preserve">
          <source>Timing of individual tests with &lt;code&gt;nose-timer&lt;/code&gt; (which needs to be installed). If True, time tests and report on all of them. If an integer (say &lt;code&gt;N&lt;/code&gt;), report timing results for &lt;code&gt;N&lt;/code&gt; slowest tests.</source>
          <target state="translated">&lt;code&gt;nose-timer&lt;/code&gt; （インストールする必要があります）を使用した個々のテストのタイミング。Trueの場合、時間テストを行い、それらすべてについて報告します。整数（たとえば &lt;code&gt;N&lt;/code&gt; ）の場合、最も遅い &lt;code&gt;N&lt;/code&gt; 個のテストのタイミング結果を報告します。</target>
        </trans-unit>
        <trans-unit id="661d4063b8ec8980f63428513015c42d7d7a39d4" translate="yes" xml:space="preserve">
          <source>Timings</source>
          <target state="translated">Timings</target>
        </trans-unit>
        <trans-unit id="535904f7958066905a2c6d516287e9eeaaa0c6e1" translate="yes" xml:space="preserve">
          <source>Timsort and radix sort have replaced mergesort for stable sorting</source>
          <target state="translated">Timsort と radix sort は、安定したソートのために mergesort に置き換わりました。</target>
        </trans-unit>
        <trans-unit id="18696f01e06a1b84af54b40680c306637cf01d64" translate="yes" xml:space="preserve">
          <source>Timsort is added for better performance on already or nearly sorted data. On random data timsort is almost identical to mergesort. It is now used for stable sort while quicksort is still the default sort if none is chosen. For details of timsort, refer to &lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPython listsort.txt&lt;/a&gt;. &amp;lsquo;mergesort&amp;rsquo; and &amp;lsquo;stable&amp;rsquo; are mapped to radix sort for integer data types. Radix sort is an O(n) sort instead of O(n log n).</source>
          <target state="translated">Timsortが追加され、すでにまたはほぼソートされたデータのパフォーマンスが向上します。ランダムデータでは、timsortはmergesortとほとんど同じです。何も選択されていない場合はクイックソートがデフォルトのソートのままですが、安定したソートに使用されます。timsortの詳細については、&lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPython listsort.txtを&lt;/a&gt;参照してください。'mergesort'および 'stable'は、整数データ型の基数ソートにマップされます。基数ソートは、O（n log n）ではなくO（n）ソートです。</target>
        </trans-unit>
        <trans-unit id="4c9ab7d1647422ac2345aafe56b9ec321ff2ddfd" translate="yes" xml:space="preserve">
          <source>Timsort is added for better performance on already or nearly sorted data. On random data timsort is almost identical to mergesort. It is now used for stable sort while quicksort is still the default sort if none is chosen. For timsort details, refer to &lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPython listsort.txt&lt;/a&gt;. &amp;lsquo;mergesort&amp;rsquo; and &amp;lsquo;stable&amp;rsquo; are mapped to radix sort for integer data types. Radix sort is an O(n) sort instead of O(n log n).</source>
          <target state="translated">すでにまたはほぼソートされたデータのパフォーマンスを向上させるために、Timsortが追加されました。ランダムデータでは、timsortはmergesortとほとんど同じです。何も選択されていない場合でもクイックソートがデフォルトのソートである間、安定ソートに使用されるようになりました。timsortの詳細については、を参照してください&lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPythonのがlistsort.txt&lt;/a&gt;。'mergesort'および 'stable'は、整数データ型の基数ソートにマップされます。基数ソートは、O（n log n）ではなくO（n）ソートです。</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="e4a5f9b37a824ec47658f0ce1a5ad5ba55b84339" translate="yes" xml:space="preserve">
          <source>Tip: &lt;code&gt;entry&lt;/code&gt; statement can be used to describe the signature of an arbitrary routine allowing F2PY to generate a number of wrappers from only one routine block signature. There are few restrictions while doing this: &lt;code&gt;fortranname&lt;/code&gt; cannot be used, &lt;code&gt;callstatement&lt;/code&gt; and &lt;code&gt;callprotoargument&lt;/code&gt; can be used only if they are valid for all entry routines, etc.</source>
          <target state="translated">ヒント： &lt;code&gt;entry&lt;/code&gt; ステートメントを使用して、任意のルーチンの署名を記述し、F2PYが1つのルーチンブロック署名のみから多数のラッパーを生成できるようにすることができます。これを行う際の制限はほとんどありません &lt;code&gt;fortranname&lt;/code&gt; は使用できません &lt;code&gt;callstatement&lt;/code&gt; と &lt;code&gt;callprotoargument&lt;/code&gt; は、すべてのエントリルーチンで有効な場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="e96f3984eaaf637764ee32773288dabcc604bf6b" translate="yes" xml:space="preserve">
          <source>Tips &amp;amp; Tricks</source>
          <target state="translated">ヒントとコツ</target>
        </trans-unit>
        <trans-unit id="caa39d36bfce368de59fb6b06774c2bd179f06cf" translate="yes" xml:space="preserve">
          <source>Title case words start with uppercase characters, all remaining cased characters are lowercase.</source>
          <target state="translated">タイトルの大文字の単語は大文字から始まり、残りの大文字はすべて小文字になります。</target>
        </trans-unit>
        <trans-unit id="45c41172aa1c58d7ba017f081fcd4e2ace4e86f0" translate="yes" xml:space="preserve">
          <source>Title that is printed in the string representation of &lt;a href=&quot;#numpy.MachAr&quot;&gt;&lt;code&gt;MachAr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.MachAr&quot;&gt; &lt;code&gt;MachAr&lt;/code&gt; &lt;/a&gt;の文字列表現で出力されるタイトル。</target>
        </trans-unit>
        <trans-unit id="20fb23c1b6aaaab924d80202c9bd41b9e867e2de" translate="yes" xml:space="preserve">
          <source>To Cython-ize this function, we replace the inner loop (y[&amp;hellip;] += x*x) with Cython code that&amp;rsquo;s specialized for the float64 dtype. With the &amp;lsquo;external_loop&amp;rsquo; flag enabled, the arrays provided to the inner loop will always be one-dimensional, so very little checking needs to be done.</source>
          <target state="translated">この関数をCython化するために、内部ループ（y [&amp;hellip;] + = x * x）を、float64 dtypeに特化したCythonコードに置き換えます。'external_loop'フラグを有効にすると、内部ループに提供される配列は常に1次元になるため、実行する必要のあるチェックはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="36e086a6bd3eb648c4aebbd467026f4cd1c91bb0" translate="yes" xml:space="preserve">
          <source>To achieve a behaviour similar to the basic slicing above, broadcasting can be used. The function &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; can help with this broadcasting. This is best understood with an example.</source>
          <target state="translated">上記の基本的なスライスと同様の動作を実現するには、ブロードキャストを使用できます。関数&lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt;は、このブロードキャストに役立ちます。これは例で最もよく理解されます。</target>
        </trans-unit>
        <trans-unit id="157492b79c5123115a363aac40a6322c3b4d23a2" translate="yes" xml:space="preserve">
          <source>To achieve what we want, we will make the following changes to it:</source>
          <target state="translated">やりたいことを実現するために、次のように変更していきます。</target>
        </trans-unit>
        <trans-unit id="d82eff9778b88421c109607c96725b336dc7bcf8" translate="yes" xml:space="preserve">
          <source>To actually build the binaries after everything is set up correctly, the release.sh script can be used. For details of the build process itself, it is best to read the pavement.py script.</source>
          <target state="translated">すべてが正しく設定された後に実際にバイナリをビルドするには、release.shスクリプトを使用することができます。ビルドプロセス自体の詳細については、pavement.py スクリプトを読むのがベストです。</target>
        </trans-unit>
        <trans-unit id="c76b68b96c698129b0e21483e667a083f4f8f28a" translate="yes" xml:space="preserve">
          <source>To add the rows or the columns in a 2D array, you would specify the axis.</source>
          <target state="translated">2次元配列の行や列を追加するには、軸を指定します。</target>
        </trans-unit>
        <trans-unit id="3f0b09a56b5f5cb6866275af7bae4ae9b88cd546" translate="yes" xml:space="preserve">
          <source>To add titles when using the list-of-tuples form of dtype specification, the field name may be specified as a tuple of two strings instead of a single string, which will be the field&amp;rsquo;s title and field name respectively. For example:</source>
          <target state="translated">dtype指定のタプルリスト形式を使用するときにタイトルを追加するには、フィールド名を、それぞれフィールドのタイトルとフィールド名になる単一の文字列ではなく、2つの文字列のタプルとして指定できます。例えば：</target>
        </trans-unit>
        <trans-unit id="03c09cbfb1aed4718ffc26452a3968e86a1cd3bc" translate="yes" xml:space="preserve">
          <source>To allow the datetime to be used in contexts where only certain days of the week are valid, NumPy includes a set of &amp;ldquo;busday&amp;rdquo; (business day) functions.</source>
          <target state="translated">特定の曜日のみが有効なコンテキストで日時を使用できるようにするために、NumPyには一連の「busday」（営業日）関数が含まれています。</target>
        </trans-unit>
        <trans-unit id="846af85fcfe300adce4c3f84895144d6dc4a75b5" translate="yes" xml:space="preserve">
          <source>To be completed.</source>
          <target state="translated">完成させるために。</target>
        </trans-unit>
        <trans-unit id="f6ad91f78d6c9353549254a135a4c203ecca9427" translate="yes" xml:space="preserve">
          <source>To be consistent with surrounding code that also breaks it (maybe for historic reasons) &amp;ndash; although this is also an opportunity to clean up someone else&amp;rsquo;s mess.</source>
          <target state="translated">（おそらく歴史的な理由で）それを壊す周囲のコードと一貫性を保つために&amp;ndash;これは、他の誰かの混乱を一掃する機会でもあります。</target>
        </trans-unit>
        <trans-unit id="172099588df066f08374020a56522cb6cad0b84f" translate="yes" xml:space="preserve">
          <source>To become eligible to join the Steering Council, an individual must be a Project Contributor who has produced contributions that are substantial in quality and quantity, and sustained over at least one year. Potential Council Members are nominated by existing Council members, and become members following consensus of the existing Council members, and confirmation that the potential Member is interested and willing to serve in that capacity. The Council will be initially formed from the set of existing Core Developers who, as of late 2015, have been significantly active over the last year.</source>
          <target state="translated">運営協議会への参加資格を得るためには、質・量ともに充実した貢献をし、少なくとも1年以上継続しているプロジェクトコントリビューターでなければなりません。運営協議会のメンバー候補者は、既存の運営協議会メンバーによって指名され、既存の運営協議会メンバーのコンセンサスを得て、そのメンバー候補者が興味を持ち、その役割を果たす意思があることを確認した上で、メンバーとなります。協議会は、2015年末現在、過去1年間に顕著な活動を行っている既存のコア開発者の集合から当初は結成される。</target>
        </trans-unit>
        <trans-unit id="85134bce24b996ec39a48245eda44b01d4da42e0" translate="yes" xml:space="preserve">
          <source>To begin to make use of the new data-type, you need to first define a new Python type to hold the scalars of your new data-type. It should be acceptable to inherit from one of the array scalars if your new type has a binary compatible layout. This will allow your new data type to have the methods and attributes of array scalars. New data- types must have a fixed memory size (if you want to define a data-type that needs a flexible representation, like a variable-precision number, then use a pointer to the object as the data-type). The memory layout of the object structure for the new Python type must be PyObject_HEAD followed by the fixed-size memory needed for the data- type. For example, a suitable structure for the new Python type is:</source>
          <target state="translated">新しいデータ型を利用するためには、まず新しいデータ型のスカラーを保持する Python の新しい型を定義する必要があります。新しいデータ型がバイナリ互換性のあるレイアウトであれば、配列スカラの一つを継承しても構いません。これにより、新しいデータ型は配列スカラのメソッドと属性を持つことができます。新しいデータ型は固定のメモリサイズを持たなければなりません(可変精度の数値のように柔軟な表現が必要なデータ型を定義したい場合は、データ型としてオブジェクトへのポインタを使用します)。新しいPython型のためのオブジェクト構造体のメモリレイアウトは、PyObject_HEADの後にデータ型に必要な固定サイズのメモリを続けなければなりません。例えば、新しいPython型のための適切な構造体は次のようになります。</target>
        </trans-unit>
        <trans-unit id="8c381239eecf186cabc8bbf33e7f7340c36dd415" translate="yes" xml:space="preserve">
          <source>To build an extension module, use</source>
          <target state="translated">拡張モジュールを構築するには</target>
        </trans-unit>
        <trans-unit id="262ab678dba163772e713fb5aa569cad52138f55" translate="yes" xml:space="preserve">
          <source>To build any extension modules for Python, you&amp;rsquo;ll need a C compiler. Various NumPy modules use FORTRAN 77 libraries, so you&amp;rsquo;ll also need a FORTRAN 77 compiler installed.</source>
          <target state="translated">Pythonの拡張モジュールをビルドするには、Cコンパイラが必要です。さまざまなNumPyモジュールがFORTRAN77ライブラリを使用するため、FORTRAN77コンパイラもインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="e7e5cfb4630032e513b61c1b673be491694cda68" translate="yes" xml:space="preserve">
          <source>To build docs, run &lt;code&gt;make&lt;/code&gt; from the &lt;code&gt;doc&lt;/code&gt; directory. &lt;code&gt;make help&lt;/code&gt; lists all targets. For example, to build the HTML documentation, you can run:</source>
          <target state="translated">ドキュメントを作成 &lt;code&gt;make&lt;/code&gt; は、 &lt;code&gt;doc&lt;/code&gt; ディレクトリからmakeを実行します。 &lt;code&gt;make help&lt;/code&gt; にすべてのターゲットが一覧表示されます。たとえば、HTMLドキュメントを作成するには、次のコマンドを実行できます。</target>
        </trans-unit>
        <trans-unit id="0116b47532b1c9e3e3765cf9819856a98d018b60" translate="yes" xml:space="preserve">
          <source>To build the PDF documentation, do instead:</source>
          <target state="translated">PDF ドキュメントを作成するには、代わりに以下のようにします。</target>
        </trans-unit>
        <trans-unit id="06915cfab63303daaadd53bd88f46eb60701ce38" translate="yes" xml:space="preserve">
          <source>To build the development version of NumPy and run tests, spawn interactive shells with the Python import paths properly set up etc., do one of:</source>
          <target state="translated">NumPyの開発版をビルドしてテストを実行したり、Pythonのインポートパスを適切に設定してインタラクティブなシェルをスポーンしたりするには、以下のいずれかを実行します。</target>
        </trans-unit>
        <trans-unit id="62e6dd105e1e44140e34cc1b1405df856709feb0" translate="yes" xml:space="preserve">
          <source>To build the final approximation matrix, we must understand how multiplication across different axes works.</source>
          <target state="translated">最終的な近似行列を構築するためには、異なる軸間の乗算がどのように機能するかを理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="9057f4f734687a0b8a5f3961b0c067a8d6921992" translate="yes" xml:space="preserve">
          <source>To change the dimensions of an array, you can omit one of the sizes which will then be deduced automatically:</source>
          <target state="translated">配列の寸法を変更するには、サイズのいずれかを省略することができます。</target>
        </trans-unit>
        <trans-unit id="59e2711afc65081105d063104c0dfaff7b844b23" translate="yes" xml:space="preserve">
          <source>To commit the staged files into the local copy of your repo, do &lt;code&gt;git
commit&lt;/code&gt;. At this point, a text editor will open up to allow you to write a commit message. Read the &lt;a href=&quot;#writing-the-commit-message&quot;&gt;commit message section&lt;/a&gt; to be sure that you are writing a properly formatted and sufficiently detailed commit message. After saving your message and closing the editor, your commit will be saved. For trivial commits, a short commit message can be passed in through the command line using the &lt;code&gt;-m&lt;/code&gt; flag. For example, &lt;code&gt;git commit -am &quot;ENH: Some message&quot;&lt;/code&gt;.</source>
          <target state="translated">ステージングされたファイルをリポジトリのローカルコピーに &lt;code&gt;git commit&lt;/code&gt; には、gitcommitを実行します。この時点で、テキストエディタが開き、コミットメッセージを書き込むことができます。&lt;a href=&quot;#writing-the-commit-message&quot;&gt;コミットメッセージのセクション&lt;/a&gt;を読んで、適切にフォーマットされ、十分に詳細なコミットメッセージを記述していることを確認してください。メッセージを保存してエディターを閉じると、コミットが保存されます。些細なコミットの場合、 &lt;code&gt;-m&lt;/code&gt; フラグを使用して、コマンドラインから短いコミットメッセージを渡すことができます。たとえば、 &lt;code&gt;git commit -am &quot;ENH: Some message&quot;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e713f5c0c4fc2dee368727d5468ec1ab8e8b8170" translate="yes" xml:space="preserve">
          <source>To construct an extension module, use</source>
          <target state="translated">拡張モジュールを構築するには</target>
        </trans-unit>
        <trans-unit id="4163e693f0e52983099e011b7813c35728efe745" translate="yes" xml:space="preserve">
          <source>To contribute code or documentation, you first need</source>
          <target state="translated">コードやドキュメントに貢献するためには、まず</target>
        </trans-unit>
        <trans-unit id="1d3a9fa41ffe14d77bbc445c74fe6fd7a66d7a2d" translate="yes" xml:space="preserve">
          <source>To convert the type of an array, use the .astype() method (preferred) or the type itself as a function. For example:</source>
          <target state="translated">配列の型を変換するには、.astype()メソッド(推奨)を使用するか、関数として型そのものを使用します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="982c13e7b2d67cdbdf6848604f9d8f779a4cdca3" translate="yes" xml:space="preserve">
          <source>To create a NumPy array, you can use the function &lt;code&gt;np.array()&lt;/code&gt;.</source>
          <target state="translated">NumPy配列を作成するには、関数 &lt;code&gt;np.array()&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="8941cedf9a3b3622178e2a604f85c6f9966d6beb" translate="yes" xml:space="preserve">
          <source>To create a masked array where all values close to 1.e20 are invalid, we would do:</source>
          <target state="translated">1.e20に近い値がすべて無効なマスク付き配列を作成するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="e67f8cba1a223a6d273b67fa4a3d036f127fda38" translate="yes" xml:space="preserve">
          <source>To create a sub-type, a similar procedure must be followed except only behaviors that are different require new entries in the type- object structure. All other entries can be NULL and will be filled in by &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt;&lt;code&gt;PyType_Ready&lt;/code&gt;&lt;/a&gt; with appropriate functions from the parent type(s). In particular, to create a sub-type in C follow these steps:</source>
          <target state="translated">サブタイプを作成するには、異なる動作のみがタイプオブジェクト構造に新しいエントリを必要とすることを除いて、同様の手順に従う必要があります。他のすべてのエントリはNULLにすることができ、&lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt; &lt;code&gt;PyType_Ready&lt;/code&gt; &lt;/a&gt;によって親タイプの適切な関数が入力されます。特に、Cでサブタイプを作成するには、次の手順に従います。</target>
        </trans-unit>
        <trans-unit id="fdf86d74a7427ac0a22c6f0a9b96d12080099d0c" translate="yes" xml:space="preserve">
          <source>To create an array with the second element invalid, we would do:</source>
          <target state="translated">2 番目の要素が無効な配列を作成するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="27de4fde4d9713bb683ffd50eb85f9b3570fc745" translate="yes" xml:space="preserve">
          <source>To create sequences of numbers, NumPy provides the &lt;code&gt;arange&lt;/code&gt; function which is analogous to the Python built-in &lt;code&gt;range&lt;/code&gt;, but returns an array.</source>
          <target state="translated">数字の配列を作成するために、numpyのは提供 &lt;code&gt;arange&lt;/code&gt; の組み込みのPythonに類似して機能 &lt;code&gt;range&lt;/code&gt; が、配列を返します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
