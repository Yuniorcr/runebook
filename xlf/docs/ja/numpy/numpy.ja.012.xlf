<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="5f26098ec8a9cbafe4e4d839766540a822d41056" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;a&lt;/code&gt; is not the same size as the second-to-last dimension of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">最後の次元場合の最後から2番目の寸法と同じ大きさではない &lt;code&gt;b&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2fd0d252831ab8d15d091d4ef1abf6e28cded875" translate="yes" xml:space="preserve">
          <source>If the masked array has named fields, accessing a single entry returns a &lt;code&gt;numpy.void&lt;/code&gt; object if none of the fields are masked, or a 0d masked array with the same dtype as the initial array if at least one of the fields is masked.</source>
          <target state="translated">マスクされた配列に名前付きフィールドがある場合、単一のエントリにアクセスすると、 &lt;code&gt;numpy.void&lt;/code&gt; フィールドもマスクされていない場合はnumpy.voidオブジェクトが返され、少なくとも1つのフィールドがマスクされている場合は、初期配列と同じdtypeの0dマスクされた配列が返されます。</target>
        </trans-unit>
        <trans-unit id="8ec6f09c123aa3a76dc4dc9103d999ab337134eb" translate="yes" xml:space="preserve">
          <source>If the mode is constant filling (&lt;code&gt;NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING&lt;/code&gt;), fill_value should point to an array object which holds the filling value (the first item will be the filling value if the array contains more than one item). For other cases, fill_value may be NULL.</source>
          <target state="translated">モードが一定の充填（ &lt;code&gt;NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING&lt;/code&gt; ）の場合、fill_valueは、充填値を保持する配列オブジェクトを指す必要があります（配列に複数の項目が含まれている場合、最初の項目が充填値になります）。その他の場合、fill_valueはNULLになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="510c4eb8a3d20ab4214058c75f9744c994e75f43" translate="yes" xml:space="preserve">
          <source>If the mode is constant filling (NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING), fill_value should point to an array object which holds the filling value (the first item will be the filling value if the array contains more than one item). For other cases, fill_value may be NULL.</source>
          <target state="translated">モードが定数充填(NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING)の場合、fill_valueは充填値を保持する配列オブジェクトを指すべきです(配列に複数の項目が含まれている場合、最初の項目が充填値となります)。それ以外の場合は、fill_value は NULL である可能性があります。</target>
        </trans-unit>
        <trans-unit id="be7395567c47ed030147671e19ef0b8f24978bfe" translate="yes" xml:space="preserve">
          <source>If the name is suffixed with the &amp;ldquo;?&amp;rdquo; modifier, the dimension is a core dimension only if it exists on all inputs and outputs that share it; otherwise it is ignored (and replaced by a dimension of size 1 for the elementary function).</source>
          <target state="translated">名前の末尾に「？」が付いている場合 修飾子、ディメンションは、それを共有するすべての入力と出力に存在する場合のみ、コアディメンションです。それ以外の場合は無視されます（および基本関数のサイズ1の次元に置き換えられます）。</target>
        </trans-unit>
        <trans-unit id="c3d1c518bb585ba44b9ba4aaf335820db98fa4f5" translate="yes" xml:space="preserve">
          <source>If the new array is larger than the original array, then the new array is filled with repeated copies of &lt;code&gt;a&lt;/code&gt;. Note that this behavior is different from a.resize(new_shape) which fills with zeros instead of repeated copies of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">新しい配列は元の配列よりも大きい場合、新しい配列が繰り返しコピーが充填されています。この動作は、 &lt;code&gt;a&lt;/code&gt; を繰り返しコピーする代わりにゼロで埋めるa.resize（new_shape）とは異なることに注意してください。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b5041b424abd93910d43bf1d34adce8cb0f61f85" translate="yes" xml:space="preserve">
          <source>If the number of objects in the selection tuple is less than &lt;em&gt;N&lt;/em&gt; , then &lt;code&gt;:&lt;/code&gt; is assumed for any subsequent dimensions.</source>
          <target state="translated">選択タプル内のオブジェクトの数が&lt;em&gt;N&lt;/em&gt;未満の場合、後続の次元には &lt;code&gt;:&lt;/code&gt; が想定されます。</target>
        </trans-unit>
        <trans-unit id="4f2a8e76e80cc97243c0461015d68ab374ad3374" translate="yes" xml:space="preserve">
          <source>If the number of objects in the selection tuple is less than &lt;em&gt;N&lt;/em&gt;, then &lt;code&gt;:&lt;/code&gt; is assumed for any subsequent dimensions.</source>
          <target state="translated">選択タプル内のオブジェクトの数が&lt;em&gt;N&lt;/em&gt;未満の場合、後続の次元では &lt;code&gt;:&lt;/code&gt; が想定されます。</target>
        </trans-unit>
        <trans-unit id="2928aac7d9000dc7b0628e4b095667d7efc04498" translate="yes" xml:space="preserve">
          <source>If the object in question is compiled in a language other than Python, using &lt;code&gt;??&lt;/code&gt; will return the same information as &lt;code&gt;?&lt;/code&gt;. You&amp;rsquo;ll find this with a lot of built-in objects and types, for example:</source>
          <target state="translated">問題のオブジェクトがPython以外の言語でコンパイルされている場合は、 &lt;code&gt;??&lt;/code&gt; &lt;code&gt;?&lt;/code&gt; と同じ情報を返します 。これは、多くの組み込みオブジェクトとタイプで見つかります。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="c5a6c4456ec6f4292b9cf18dc4d579bb22a84db3" translate="yes" xml:space="preserve">
          <source>If the object provided is an array, this function traverses the chain of &lt;code&gt;base&lt;/code&gt; pointers so that each array points to the owner of the memory directly. Once the base is set, it may not be changed to another value.</source>
          <target state="translated">提供されたオブジェクトが配列の場合、この関数は &lt;code&gt;base&lt;/code&gt; ポインターのチェーンを走査して、各配列がメモリの所有者を直接指すようにします。ベースが設定されると、別の値に変更できなくなります。</target>
        </trans-unit>
        <trans-unit id="89a89c71a1b9f2da8de85eabab619e5820532ff8" translate="yes" xml:space="preserve">
          <source>If the offsets of the fields and itemsize of a structured array satisfy the alignment conditions, the array will have the &lt;code&gt;ALIGNED&lt;/code&gt;&lt;a href=&quot;../reference/generated/numpy.ndarray.flags#numpy.ndarray.flags&quot;&gt;&lt;code&gt;flag&lt;/code&gt;&lt;/a&gt; set.</source>
          <target state="translated">構造化配列のフィールドとitemsizeのオフセットが整列条件を満たす場合、配列には &lt;code&gt;ALIGNED&lt;/code&gt; &lt;a href=&quot;../reference/generated/numpy.ndarray.flags#numpy.ndarray.flags&quot;&gt; &lt;code&gt;flag&lt;/code&gt; &lt;/a&gt;設定されます。</target>
        </trans-unit>
        <trans-unit id="657e1806ea99b60e1959c9ce313bdaa2fd70aa64" translate="yes" xml:space="preserve">
          <source>If the operand is flagged as write-only and a copy is needed, an uninitialized temporary array will be created and then copied to back to &lt;code&gt;op[i]&lt;/code&gt; on calling &lt;code&gt;NpyIter_Deallocate&lt;/code&gt;, instead of doing the unnecessary copy operation.</source>
          <target state="translated">オペランドに書き込み専用のフラグが付けられ、コピーが必要な場合、初期化されていない一時配列が作成され、不要なコピー操作を実行する代わりに、 &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; の呼び出し時に &lt;code&gt;op[i]&lt;/code&gt; にコピーされます。</target>
        </trans-unit>
        <trans-unit id="17f4400245338f1e4a33ed23afc91ef7ab8c40c6" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; is given, only the first &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; occurrences are replaced.</source>
          <target state="translated">オプションの引数&lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;が指定されている場合、最初の&lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; 個の&lt;/a&gt;出現のみが置き換えられます。</target>
        </trans-unit>
        <trans-unit id="650baf4400147a0e58c70982764ea43290cfecc2" translate="yes" xml:space="preserve">
          <source>If the package is not found.</source>
          <target state="translated">パッケージが見つからない場合</target>
        </trans-unit>
        <trans-unit id="2ad175da47137fbc79b21402b2a0b69af4d4bc0f" translate="yes" xml:space="preserve">
          <source>If the position of iter is changed, any subsequent call to PyArrayNeighborhoodIter_Next is undefined behavior, and PyArrayNeighborhoodIter_Reset must be called.</source>
          <target state="translated">iter の位置が変更された場合、それ以降の PyArrayNeighborhoodIter_Next の呼び出しは未定義の動作となり、PyArrayNeighborhoodIter_Reset が呼び出されなければなりません。</target>
        </trans-unit>
        <trans-unit id="16e630a04286a25caaca20cb641690b37ba91ed8" translate="yes" xml:space="preserve">
          <source>If the release series is a new one, you will need to add a new section to the &lt;code&gt;doc/build/merge/index.html&lt;/code&gt; front page just after the &amp;ldquo;insert here&amp;rdquo; comment:</source>
          <target state="translated">リリースシリーズが新しいものである場合は、「ここに挿入」コメントの直後に、 &lt;code&gt;doc/build/merge/index.html&lt;/code&gt; フロントページに新しいセクションを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="8c927b8ff30da3cc5f4b149881b61cbe3118f463" translate="yes" xml:space="preserve">
          <source>If the requested data type is in non-native byte order, the NBO flag overrides it and the requested data type is converted to be in native byte order.</source>
          <target state="translated">要求されたデータ型が非ネイティブバイト順の場合、NBOフラグはそれを上書きし、要求されたデータ型はネイティブバイト順に変換されます。</target>
        </trans-unit>
        <trans-unit id="8a5c6764b6f67871837f5bb9b64736c18fe7a7ad" translate="yes" xml:space="preserve">
          <source>If the returned coefficients are &lt;code&gt;c&lt;/code&gt;, then</source>
          <target state="translated">返される係数が &lt;code&gt;c&lt;/code&gt; の場合、</target>
        </trans-unit>
        <trans-unit id="054023bbbbd71a4d456dd16da82bfb709a02f2cc" translate="yes" xml:space="preserve">
          <source>If the second argument is 1-D, it is promoted to a matrix by appending a 1 to its dimensions. After matrix multiplication the appended 1 is removed.</source>
          <target state="translated">第2引数が1-Dの場合、その次元に1を付加することで行列に昇格します。行列の乗算の後、付加された1は削除されます。</target>
        </trans-unit>
        <trans-unit id="b4b38312a537fa220f815af5dcf5f4139bad3681" translate="yes" xml:space="preserve">
          <source>If the selection tuple has all entries &lt;code&gt;:&lt;/code&gt; except the &lt;em&gt;p&lt;/em&gt;-th entry which is a slice object &lt;code&gt;i:j:k&lt;/code&gt;, then the returned array has dimension &lt;em&gt;N&lt;/em&gt; formed by concatenating the sub-arrays returned by integer indexing of elements &lt;em&gt;i&lt;/em&gt;, &lt;em&gt;i+k&lt;/em&gt;, &amp;hellip;, &lt;em&gt;i + (m - 1) k &amp;lt; j&lt;/em&gt;,</source>
          <target state="translated">選択タプルはすべてのエントリがある場合 &lt;code&gt;:&lt;/code&gt; 除く&lt;em&gt;P&lt;/em&gt;スライスオブジェクトで番目のエントリ &lt;code&gt;i:j:k&lt;/code&gt; 、次に返される配列を寸法している&lt;em&gt;Nは&lt;/em&gt;要素の整数インデクシングによって返さサブアレイ連結することによって形成された&lt;em&gt;I&lt;/em&gt;、&lt;em&gt;iは+ kは&lt;/em&gt;、&amp;hellip;、&lt;em&gt;i +（m-1）k &amp;lt;j&lt;/em&gt;、</target>
        </trans-unit>
        <trans-unit id="9a652cfa7a533eb64735eb374de6f3a4977f5b9c" translate="yes" xml:space="preserve">
          <source>If the spacing between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; for one or more elements is larger than &lt;code&gt;nulp&lt;/code&gt;.</source>
          <target state="translated">1つ以上の要素の &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の間隔が &lt;code&gt;nulp&lt;/code&gt; より大きい場合。</target>
        </trans-unit>
        <trans-unit id="3600ee510b36714644dcc89a19bb177b5b6c4ba7" translate="yes" xml:space="preserve">
          <source>If the string is not the correct size to satisfy the requested &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">文字列が、要求された&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;count&lt;/code&gt; を満たすのに適切なサイズでない場合。</target>
        </trans-unit>
        <trans-unit id="8431a3b44693b10770bc98218be6d44b926dbd16" translate="yes" xml:space="preserve">
          <source>If the transition to C++ goes through it is possible that this form will be relaxed so that short class methods meant to be inlined can have the return type on the same line as the function name. However, that is yet to be determined.</source>
          <target state="translated">C++への移行が進めば、この形式が緩和され、インライン化された短いクラスメソッドの戻り値の型が関数名と同じ行になるようになる可能性があります。しかし、それはまだ決定されていません。</target>
        </trans-unit>
        <trans-unit id="ebc3886c14d49cd40506d4084002663f28dbcdd3" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;x&lt;/code&gt; is unsigned, then the output type is the unsigned platform integer:</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; のタイプが符号なしの場合、出力タイプは符号なしプラットフォーム整数になります。</target>
        </trans-unit>
        <trans-unit id="183bc4d9ba8fd4894a95c0f09db6946e16642c92" translate="yes" xml:space="preserve">
          <source>If the type of the input is complex.</source>
          <target state="translated">入力の種類が複素数の場合。</target>
        </trans-unit>
        <trans-unit id="95366e62fbbbe64ba41cdcaa0c22be8d3f384cd4" translate="yes" xml:space="preserve">
          <source>If the type of the input is float or complex.</source>
          <target state="translated">入力の型が float または複素数の場合。</target>
        </trans-unit>
        <trans-unit id="25291949b6396c31462d4c34b8e8b5c2797cb90a" translate="yes" xml:space="preserve">
          <source>If the ufunc has 2 inputs and 1 output and the second input is an Object array then a special-case check is performed so that NotImplemented is returned if the second input is not an ndarray, has the __array_priority__ attribute, and has an __r{op}__ special method. In this way, Python is signaled to give the other object a chance to complete the operation instead of using generic object-array calculations. This allows (for example) sparse matrices to override the multiplication operator 1-D loop.</source>
          <target state="translated">ufuncが2つの入力と1つの出力を持ち、2番目の入力がオブジェクト配列である場合、2番目の入力がndarrayではなく、__array_priority__属性を持ち、__r{op}__特別なメソッドを持っている場合、NotImplementedが返されるように、特殊ケースチェックが行われます。このようにして、Pythonは、汎用的なオブジェクト配列計算を使用する代わりに、他のオブジェクトに処理を完了する機会を与えるようにシグナルを送ります。これにより、(例えば)疎な行列は乗算演算子の1-Dループをオーバーライドすることができます。</target>
        </trans-unit>
        <trans-unit id="a4dffd94a98e9a9ee0037afd472e661e6232061e" translate="yes" xml:space="preserve">
          <source>If the underlying data is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, it is returned as such.</source>
          <target state="translated">基本となるデータが&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; の&lt;/a&gt;サブクラスである場合は、そのように返されます。</target>
        </trans-unit>
        <trans-unit id="c8138c9410f7b3ce9c5c6bb9d0523e6e1ea7bd8e" translate="yes" xml:space="preserve">
          <source>If the underlying data is a subclass of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, it is returned as such.</source>
          <target state="translated">基になるデータが&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; の&lt;/a&gt;サブクラスである場合、そのように返されます。</target>
        </trans-unit>
        <trans-unit id="10f03c3143f8af1fee84b593563d21e127566799" translate="yes" xml:space="preserve">
          <source>If the user tries to use any numpy functions not included in &lt;code&gt;HANDLED_FUNCTIONS&lt;/code&gt;, a &lt;code&gt;TypeError&lt;/code&gt; will be raised by numpy, indicating that this operation is not supported. For example, concatenating two &lt;code&gt;DiagonalArrays&lt;/code&gt; does not produce another diagonal array, so it is not supported.</source>
          <target state="translated">ユーザーが &lt;code&gt;HANDLED_FUNCTIONS&lt;/code&gt; に含まれていないnumpy関数を使用しようとすると、 &lt;code&gt;TypeError&lt;/code&gt; がnumpyによって発生し、この操作がサポートされていないことを示します。たとえば、2つの &lt;code&gt;DiagonalArrays&lt;/code&gt; 連結しても、別の対角配列は生成されないため、サポートされていません。</target>
        </trans-unit>
        <trans-unit id="23122d3c8d35684d3c1d392886f730d15f172384" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">値がデフォルト以外の場合、 &lt;code&gt;keepdims&lt;/code&gt; はndarrayのサブクラスの&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt;メソッドに&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;ます。サブクラスのメソッドが &lt;code&gt;keepdims&lt;/code&gt; を実装しない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="2abfa832de7674bd2d08ad1f7e2b845f18a0059c" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">値がデフォルト以外の場合、 &lt;code&gt;keepdims&lt;/code&gt; はndarrayのサブクラスの&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#min&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt;メソッドに&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;ます。サブクラスのメソッドが &lt;code&gt;keepdims&lt;/code&gt; を実装しない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="fb8acc52d13221f0fba6edb05a42e80cbebd0a2e" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; methods of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">値がデフォルト以外の場合、 &lt;code&gt;keepdims&lt;/code&gt; はndarrayのサブクラスの&lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt;メソッドに&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;ます。サブクラスのメソッドが &lt;code&gt;keepdims&lt;/code&gt; を実装しない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="33c6901ff2ee0db95c77f2b313983f44526bb314" translate="yes" xml:space="preserve">
          <source>If there are only scalars or the maximum category of the scalars is higher than the maximum category of the arrays, the data types are combined with &lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt;&lt;code&gt;PyArray_PromoteTypes&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">スカラーしかない場合、またはスカラーの最大カテゴリが配列の最大カテゴリよりも大きい場合は、データ型が&lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt; &lt;code&gt;PyArray_PromoteTypes&lt;/code&gt; &lt;/a&gt;と組み合わされて戻り値が生成されます。</target>
        </trans-unit>
        <trans-unit id="33fe4c771f7142c020971d30614039b35a541395" translate="yes" xml:space="preserve">
          <source>If there are only scalars or the maximum category of the scalars is higher than the maximum category of the arrays, the data types are combined with &lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">スカラーのみがある場合、またはスカラーの最大カテゴリーが配列の最大カテゴリーよりも大きい場合、データ型は、&lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt;と組み合わされて戻り値を生成します。</target>
        </trans-unit>
        <trans-unit id="713f3b36701faad5c729c8225f4c0508fcfe41f1" translate="yes" xml:space="preserve">
          <source>If there is no dictionary passed in or &lt;code&gt;vardict&lt;/code&gt; is None then returns NumPy arrays in the globals() dictionary (all NumPy arrays in the namespace).</source>
          <target state="translated">ディクショナリが渡されない場合、または &lt;code&gt;vardict&lt;/code&gt; がNoneの場合、globals（）ディクショナリ内のNumPy配列（名前空間内のすべてのNumPy配列）を返します。</target>
        </trans-unit>
        <trans-unit id="d0c11d30de5e96bdaa85cb78bb53dddd3ba03ebc" translate="yes" xml:space="preserve">
          <source>If there is no library with the expected extension, or the library is defective and cannot be loaded.</source>
          <target state="translated">期待される拡張子を持つライブラリがない場合、またはライブラリに欠陥があり、ロードできない場合。</target>
        </trans-unit>
        <trans-unit id="ef27bb26cd9e20ec5eb81bab137d2b6e00a224b0" translate="yes" xml:space="preserve">
          <source>If there is only one Boolean array and no integer indexing array present, this is straight forward. Care must only be taken to make sure that the boolean index has &lt;em&gt;exactly&lt;/em&gt; as many dimensions as it is supposed to work with.</source>
          <target state="translated">ブール配列が1つしかなく、整数インデックス配列が存在しない場合、これは簡単です。ブールインデックスが、使用するのと&lt;em&gt;まったく同じ&lt;/em&gt;数のディメンションを持っていることを確認するように注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="6e268d3c7b0192c893825d9fa07e4e49b28360ad" translate="yes" xml:space="preserve">
          <source>If these arrays are all collected in a structured array, then &lt;a href=&quot;#c.PyArray_Sort&quot;&gt;&lt;code&gt;PyArray_Sort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can also be used to sort the array directly.</source>
          <target state="translated">これらの配列がすべて構造化配列に収集されている場合、&lt;a href=&quot;#c.PyArray_Sort&quot;&gt; &lt;code&gt;PyArray_Sort&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）を使用して配列を直接ソートすることもできます。</target>
        </trans-unit>
        <trans-unit id="54dc9b5be81c958064f5d558fe01980eec4eadde" translate="yes" xml:space="preserve">
          <source>If these conditions are not met, a &lt;code&gt;ValueError: operands could not be broadcast together&lt;/code&gt; exception is thrown, indicating that the arrays have incompatible shapes. The size of the resulting array is the size that is not 1 along each axis of the inputs.</source>
          <target state="translated">これらの条件が満たされない場合、 &lt;code&gt;ValueError: operands could not be broadcast together&lt;/code&gt; 例外がスローされ、配列に互換性のない形状があることを示します。結果の配列のサイズは、入力の各軸に沿って1ではないサイズです。</target>
        </trans-unit>
        <trans-unit id="4b5797d27d90ecc738ae241c7f2d88131ab4d780" translate="yes" xml:space="preserve">
          <source>If these conditions hold, &lt;code&gt;__array_function__&lt;/code&gt; should return the result from calling its implementation for &lt;code&gt;func(*args, **kwargs)&lt;/code&gt;. Otherwise, it should return the sentinel value &lt;code&gt;NotImplemented&lt;/code&gt;, indicating that the function is not implemented by these types.</source>
          <target state="translated">これらの条件が満たされている場合、 &lt;code&gt;__array_function__&lt;/code&gt; は &lt;code&gt;func(*args, **kwargs)&lt;/code&gt; 実装を呼び出した結果を返す必要があります。それ以外の場合は、センチネル値 &lt;code&gt;NotImplemented&lt;/code&gt; を返し、関数がこれらのタイプによって実装されていないことを示します。</target>
        </trans-unit>
        <trans-unit id="c80ca8262eeedd9bef78dbd28fb2dc07a4582c48" translate="yes" xml:space="preserve">
          <source>If this array does not own its own memory, then base points to the Python object that owns it (perhaps another array object)</source>
          <target state="translated">この配列が自分のメモリを所有していない場合、base はそれを所有する Python オブジェクト (おそらく別の配列オブジェクト)を指します。</target>
        </trans-unit>
        <trans-unit id="f79009d9f8b9e9859082a3efe68d074e3e908ff8" translate="yes" xml:space="preserve">
          <source>If this array has the (deprecated) &lt;a href=&quot;array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag set, then this array is a working copy of a &amp;ldquo;misbehaved&amp;rdquo; array.</source>
          <target state="translated">この配列に（非推奨の）&lt;a href=&quot;array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;フラグが設定されている場合、この配列は「誤動作」配列の作業コピーです。</target>
        </trans-unit>
        <trans-unit id="f63b91f81d86b6356e230f230ee7da044adca895" translate="yes" xml:space="preserve">
          <source>If this array has the (deprecated) &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag set, then this array is a working copy of a &amp;ldquo;misbehaved&amp;rdquo; array.</source>
          <target state="translated">この配列に（非推奨の）&lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;フラグが設定されている場合、この配列は「正しく動作しない」配列の作業用コピーです。</target>
        </trans-unit>
        <trans-unit id="2e1498e4add4060095cafec2d44c32b17e6ac395" translate="yes" xml:space="preserve">
          <source>If this condition is not met, a &lt;code&gt;ValueError('frames are not aligned')&lt;/code&gt; exception is thrown indicating that the arrays have incompatible shapes. The size of the result array created by broadcast operations is the maximum size along each dimension from the input arrays. Note that the rule does not say anything about the two arrays needing to have the same number of dimensions. So, for example, if you have a 256 x 256 x 3 array of RGB values, and you want to scale each color in the image by a different value, you can multiply the image by a one-dimensional array with 3 values. Lining up the sizes of the trailing axes of these arrays according to the broadcast rule shows that they are compatible</source>
          <target state="translated">この条件が満たされない場合、 &lt;code&gt;ValueError('frames are not aligned')&lt;/code&gt; 例外がスローされ、配列に互換性のない形状があることを示します。ブロードキャスト操作によって作成された結果配列のサイズは、入力配列からの各次元に沿った最大サイズです。ルールは、同じ数の次元を持つ必要がある2つの配列については何も述べていないことに注意してください。したがって、たとえば、RGB値の256 x 256 x 3配列があり、画像の各色を異なる値でスケーリングする場合は、画像に3つの値を持つ1次元配列を掛けることができます。ブロードキャストルールに従ってこれらの配列の後軸のサイズを並べると、互換性があることがわかります</target>
        </trans-unit>
        <trans-unit id="b54640e63d198f32f1e8358a28ce29bc6179e6f7" translate="yes" xml:space="preserve">
          <source>If this function returns true, the caller should also check the inner loop stride of the operand, because if that stride is 0, then only the first element of the innermost external loop is being visited for the first time.</source>
          <target state="translated">この関数が真を返す場合、呼び出し元はオペランドの内部ループのストライドもチェックする必要があります。</target>
        </trans-unit>
        <trans-unit id="24a22c06faef1b4b61f295517b88ec97d1fc0a84" translate="yes" xml:space="preserve">
          <source>If this is &lt;code&gt;None&lt;/code&gt;, a reduction is performed over all the axes. If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">これが &lt;code&gt;None&lt;/code&gt; の場合、すべての軸で削減が実行されます。これが整数のタプルである場合、削減は以前のように単一の軸またはすべての軸ではなく、複数の軸で実行されます。</target>
        </trans-unit>
        <trans-unit id="33f579e70b917db4493a3111bc7067b3dc4d2ff2" translate="yes" xml:space="preserve">
          <source>If this is None, a reduction is performed over all the axes. If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">これが None の場合、縮小はすべての軸で実行されます。これがintのタプルである場合、以前のように1つの軸またはすべての軸ではなく、複数の軸で縮小が行われます。</target>
        </trans-unit>
        <trans-unit id="e4599c6e53b844db2376ed9e56ed7b49e63c6ec3" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a mean is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">これがintのタプルである場合、以前のように1つの軸またはすべての軸ではなく、複数の軸に渡って平均が実行されます。</target>
        </trans-unit>
        <trans-unit id="04767d2c5f5bbd4aab7323a751a31f226739a396" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">これがイントのタプルである場合、従来のように1つの軸またはすべての軸ではなく、複数の軸で縮小が行われます。</target>
        </trans-unit>
        <trans-unit id="e11ec2c8b461dd6b1390de16d518719c4d72ce55" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a standard deviation is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">これがイントのタプルであれば、従来のように1軸または全軸ではなく、複数の軸に渡って標準偏差が行われます。</target>
        </trans-unit>
        <trans-unit id="cdec667610de13f7517139e9ece6f88d2d290194" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a variance is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">これがイントのタプルである場合、分散は、以前のように1つの軸またはすべての軸ではなく、複数の軸に渡って実行されます。</target>
        </trans-unit>
        <trans-unit id="d50012ee6c384ff0215bab7085fcf98c562bc452" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the count is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">これがイントのタプルである場合、以前のように1つの軸またはすべての軸ではなく、複数の軸でカウントが実行されます。</target>
        </trans-unit>
        <trans-unit id="c674e367c6b1c23d3abf3ddc4c5a7a14ff593b5a" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the maximum is selected over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">これがイントのタプルである場合、以前のように1つの軸またはすべての軸ではなく、複数の軸で最大値が選択されます。</target>
        </trans-unit>
        <trans-unit id="a0756a48081a9a9cb1bfbc79e9843f0007e55c1d" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the minimum is selected over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">これがイントのタプルである場合、最小値は、以前のように1つの軸またはすべての軸ではなく、複数の軸にわたって選択されます。</target>
        </trans-unit>
        <trans-unit id="7573da3ff564f7261e16d53ba17d4d7c25b6abc9" translate="yes" xml:space="preserve">
          <source>If this is anything but the default value it will be passed through (in the special case of an empty array) to the &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; function of the underlying array. If the array is a sub-class and &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; does not have the kwarg &lt;code&gt;keepdims&lt;/code&gt; this will raise a RuntimeError.</source>
          <target state="translated">これがデフォルト値以外の場合は、（空の配列の特殊なケースでは）基になる配列の&lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt;関数に渡されます。配列がサブクラスで&lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt;にkwarg &lt;code&gt;keepdims&lt;/code&gt; がない場合、これはRuntimeErrorを発生させます。</target>
        </trans-unit>
        <trans-unit id="9eef22bd67c15e89cde5d92734a40aa76d92e691" translate="yes" xml:space="preserve">
          <source>If this is non- &lt;code&gt;NULL&lt;/code&gt;, then this data-type descriptor is a C-style contiguous array of another data-type descriptor. In other-words, each element that this descriptor describes is actually an array of some other base descriptor. This is most useful as the data-type descriptor for a field in another data-type descriptor. The fields member should be &lt;code&gt;NULL&lt;/code&gt; if this is non- &lt;code&gt;NULL&lt;/code&gt; (the fields member of the base descriptor can be non- &lt;code&gt;NULL&lt;/code&gt; however). The &lt;code&gt;PyArray_ArrayDescr&lt;/code&gt; structure is defined using</source>
          <target state="translated">これが &lt;code&gt;NULL&lt;/code&gt; 以外の場合、このデータ型記述子は、別のデータ型記述子のCスタイルの連続した配列です。言い換えると、この記述子が記述する各要素は、実際には他のいくつかの基本記述子の配列です。これは、別のデータ型記述子のフィールドのデータ型記述子として最も役立ちます。フィールド部材であるべき &lt;code&gt;NULL&lt;/code&gt; これは非ある場合 &lt;code&gt;NULL&lt;/code&gt; （ベース記述子のフィールド部材は、非することができる &lt;code&gt;NULL&lt;/code&gt; が）。 &lt;code&gt;PyArray_ArrayDescr&lt;/code&gt; の構造を使用して定義されます</target>
        </trans-unit>
        <trans-unit id="2824d770011e81edcc48aaca00be40fe5064246e" translate="yes" xml:space="preserve">
          <source>If this is non-NULL, then this data-type-descriptor has fields described by a Python dictionary whose keys are names (and also titles if given) and whose values are tuples that describe the fields. Recall that a data-type-descriptor always describes a fixed-length set of bytes. A field is a named sub-region of that total, fixed-length collection. A field is described by a tuple composed of another data- type-descriptor and a byte offset. Optionally, the tuple may contain a title which is normally a Python string. These tuples are placed in this dictionary keyed by name (and also title if given).</source>
          <target state="translated">これがNULLでない場合、このデータ型記述子はPython辞書によって記述されたフィールドを持ち、そのキーは名前(与えられた場合はタイトルも)であり、その値はフィールドを記述するタプルです。データ型記述子は常に固定長のバイトの集合を記述していることを思い出してください。フィールドはその固定長のコレクションの名前付きのサブ領域です。フィールドは、別のデータ型記述子とバイトオフセットからなるタプルによって記述されます。オプションで、タプルは通常Python文字列であるタイトルを含むことができます。これらのタプルは、名前(与えられた場合にはタイトルも)でキーが設定されたこの辞書に配置されます。</target>
        </trans-unit>
        <trans-unit id="0d86cba4ba7294ed9f7338e68f7b4f37b35c1557" translate="yes" xml:space="preserve">
          <source>If this is not desirable, then the array should be cast to a larger integer type first:</source>
          <target state="translated">これが望ましくない場合は、まず配列をより大きな整数型にキャストする必要があります。</target>
        </trans-unit>
        <trans-unit id="1ae38fd1d446748062bddf73d4866a0b315e1322" translate="yes" xml:space="preserve">
          <source>If this is set to &lt;code&gt;True&lt;/code&gt;, axes which are reduced over will be left in the result as a dimension with size one, so that the result will broadcast correctly against the inputs. This option can only be used for generalized ufuncs that operate on inputs that all have the same number of core dimensions and with outputs that have no core dimensions , i.e., with signatures like &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; or &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt;. If used, the location of the dimensions in the output can be controlled with &lt;code&gt;axes&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">これが &lt;code&gt;True&lt;/code&gt; に設定されている場合、縮小された軸はサイズ1の次元として結果に残り、結果は入力に対して正しくブロードキャストされます。このオプションは、コア次元の数がすべて同じで、コア次元のない出力、つまり &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; または &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt; 。使用する場合、出力の次元の位置は、 &lt;code&gt;axes&lt;/code&gt; および &lt;code&gt;axis&lt;/code&gt; で制御できます。</target>
        </trans-unit>
        <trans-unit id="a675290349084bcd281fdfbd331891015b07aca9" translate="yes" xml:space="preserve">
          <source>If this is set to &lt;code&gt;True&lt;/code&gt;, axes which are reduced over will be left in the result as a dimension with size one, so that the result will broadcast correctly against the inputs. This option can only be used for generalized ufuncs that operate on inputs that all have the same number of core dimensions and with outputs that have no core dimensions, i.e., with signatures like &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; or &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt;. If used, the location of the dimensions in the output can be controlled with &lt;code&gt;axes&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">これを &lt;code&gt;True&lt;/code&gt; に設定すると、縮小された軸がサイズ1のディメンションとして結果に残されるため、結果は入力に対して正しくブロードキャストされます。このオプションは、すべて同じ数のコア次元を持つ入力と、コア次元を持たない出力、つまり &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; 、 &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt; ）などのシグネチャで動作する一般化されたufuncにのみ使用できます。、m）-&amp;gt;（）。使用する場合、出力内の寸法の位置は、 &lt;code&gt;axes&lt;/code&gt; と &lt;code&gt;axis&lt;/code&gt; 制御できます。</target>
        </trans-unit>
        <trans-unit id="86e30e948710dc5b2db29b7dc82437914fd08740" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes that are counted are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</source>
          <target state="translated">これが True に設定されている場合、カウントされる軸は、サイズ 1 の寸法として結果に残されます。このオプションを指定すると、結果は入力配列に対して正しくブロードキャストされます。</target>
        </trans-unit>
        <trans-unit id="74585a8bd339c6874f448a64d5fe0ba3642c10c6" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are normed over are left in the result as dimensions with size one. With this option the result will broadcast correctly against the original &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">これがTrueに設定されている場合、正規化された軸は、サイズ1の次元として結果に残ります。このオプションを使用すると、結果は元の &lt;code&gt;x&lt;/code&gt; に対して正しくブロードキャストされます。</target>
        </trans-unit>
        <trans-unit id="526b620d34688cc0c68a7ee67814781d453388f5" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the array.</source>
          <target state="translated">これがTrueに設定されている場合、縮小された軸はサイズ1の寸法として結果に残されます。このオプションを指定すると、結果は配列に対して正しくブロードキャストされます。</target>
        </trans-unit>
        <trans-unit id="015e500928e7c3f86f2c9b5121c746246fcd7a9f" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</source>
          <target state="translated">これが True に設定されている場合、縮小された軸はサイズ 1 の寸法として結果に残されます。このオプションを指定すると、結果は入力配列に対して正しくブロードキャストされます。</target>
        </trans-unit>
        <trans-unit id="caf30df07a09579107c0faa5c9aaad9ad8721644" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">これがTrueに設定されている場合、縮小された軸はサイズ1の次元として結果に残ります。このオプションを使用すると、結果は元の &lt;code&gt;a&lt;/code&gt; に対して正しくブロードキャストされます。</target>
        </trans-unit>
        <trans-unit id="668624d9e02d10dc8924733d51742fcc1923286c" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">これがTrueに設定されている場合、縮小された軸はサイズ1の次元として結果に残ります。このオプションを使用すると、結果は元の &lt;code&gt;arr&lt;/code&gt; に対して正しくブロードキャストされます。</target>
        </trans-unit>
        <trans-unit id="813c59426f99f6e2035686f0669f18c79ec2fc97" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">これがTrueに設定されている場合、縮小された軸はサイズ1の次元として結果に残ります。このオプションを使用すると、結果は元の配列 &lt;code&gt;a&lt;/code&gt; に対して正しくブロードキャストされます。</target>
        </trans-unit>
        <trans-unit id="28e1fe971ad9fdc32699e38250e14da5caf0bb91" translate="yes" xml:space="preserve">
          <source>If this value is anything but the default it is passed through as-is to the relevant functions of the sub-classes. If these functions do not have a &lt;code&gt;keepdims&lt;/code&gt; kwarg, a RuntimeError will be raised.</source>
          <target state="translated">この値がデフォルト以外の場合は、そのままサブクラスの関連する関数に渡されます。これらの関数に &lt;code&gt;keepdims&lt;/code&gt; kwarg がない場合、RuntimeErrorが発生します。</target>
        </trans-unit>
        <trans-unit id="dd4ec2a983c899a1017fcabb86ae5785ce4793ab" translate="yes" xml:space="preserve">
          <source>If true (default), then the object is copied. Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, etc.).</source>
          <target state="translated">true（デフォルト）の場合、オブジェクトがコピーされます。それ以外の場合、コピーは、__ array__がコピーを返す場合、objがネストされたシーケンスである場合、または他の要件（&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;order&lt;/code&gt; など）を満たすためにコピーが必要な場合にのみ作成されます。</target>
        </trans-unit>
        <trans-unit id="a6f5f638d5dadad294989835332dc69ea08c7e48" translate="yes" xml:space="preserve">
          <source>If true (default), then the object is copied. Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (&lt;code&gt;itemsize&lt;/code&gt;, unicode, &lt;code&gt;order&lt;/code&gt;, etc.).</source>
          <target state="translated">true（デフォルト）の場合、オブジェクトがコピーされます。それ以外の場合、__ array__がコピーを返す場合、objがネストされたシーケンスである場合、または他の要件（ &lt;code&gt;itemsize&lt;/code&gt; 、unicode、 &lt;code&gt;order&lt;/code&gt; など）を満たすためにコピーが必要な場合にのみ、コピーが作成されます。</target>
        </trans-unit>
        <trans-unit id="7cfded7f1f4f8985525752f730c915f025bbc3bd" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;stop&lt;/code&gt; is the last sample. Otherwise, it is not included. Default is True.</source>
          <target state="translated">trueの場合、 &lt;code&gt;stop&lt;/code&gt; は最後のサンプルです。それ以外の場合は含まれません。デフォルトはTrueです。</target>
        </trans-unit>
        <trans-unit id="89363179f510b5ee9e2706f4cf949aff38e269d9" translate="yes" xml:space="preserve">
          <source>If true, sample from the interval [low, high] instead of the default [low, high) Defaults to False</source>
          <target state="translated">true の場合、デフォルトの [low,high]の代わりに [low,high]の間隔からサンプリングします。</target>
        </trans-unit>
        <trans-unit id="ade7c82d0d30db8fc4ef391480e9db75f4fe6678" translate="yes" xml:space="preserve">
          <source>If true, use an &amp;ldquo;aligned&amp;rdquo; memory layout, otherwise use a &amp;ldquo;packed&amp;rdquo; layout.</source>
          <target state="translated">trueの場合は「整列」メモリレイアウトを使用し、そうでない場合は「パック」レイアウトを使用します。</target>
        </trans-unit>
        <trans-unit id="3ef0d38b764385bc39d70e5ad26d095da7b5d3f0" translate="yes" xml:space="preserve">
          <source>If used with &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;, the inner loop for the caller may get larger chunks than would be possible without buffering, because of how the strides are laid out.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;と一緒に使用すると、ストライドがどのように配置されるかによって、呼び出し側の内部ループが、バッファリングなしで可能なチャンクよりも大きなチャンクを取得する場合があります。</target>
        </trans-unit>
        <trans-unit id="e6e87a78ddc8c45866e59f696a01a91d82f291c2" translate="yes" xml:space="preserve">
          <source>If values in &lt;code&gt;x&lt;/code&gt; are beyond the bounds of &lt;code&gt;bins&lt;/code&gt;, 0 or &lt;code&gt;len(bins)&lt;/code&gt; is returned as appropriate.</source>
          <target state="translated">値場合 &lt;code&gt;x&lt;/code&gt; の境界を超えている &lt;code&gt;bins&lt;/code&gt; 、0又は &lt;code&gt;len(bins)&lt;/code&gt; 適切に戻されます。</target>
        </trans-unit>
        <trans-unit id="adc126c0d80d4b8b968260ca8a9cd270dc0bc84e" translate="yes" xml:space="preserve">
          <source>If values in &lt;code&gt;x&lt;/code&gt; are such that they fall outside the bin range, attempting to index &lt;code&gt;bins&lt;/code&gt; with the indices that &lt;a href=&quot;#numpy.digitize&quot;&gt;&lt;code&gt;digitize&lt;/code&gt;&lt;/a&gt; returns will result in an IndexError.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の値がビンの範囲外になるような値である場合、&lt;a href=&quot;#numpy.digitize&quot;&gt; &lt;code&gt;digitize&lt;/code&gt; &lt;/a&gt;が返すインデックスで &lt;code&gt;bins&lt;/code&gt; にインデックスを付けようとすると、IndexErrorが発生します。</target>
        </trans-unit>
        <trans-unit id="b223152b4e60f22e3efa048a66b57e829307cf69" translate="yes" xml:space="preserve">
          <source>If we designed &lt;code&gt;rms&lt;/code&gt;, we probably made it a routine that takes an input-only array of length &lt;code&gt;n&lt;/code&gt; of &lt;code&gt;double&lt;/code&gt; values called &lt;code&gt;seq&lt;/code&gt; and returns the root mean square. The default behavior of &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;, however, will be to create a wrapper function that compiles, but is nearly impossible to use from the scripting language in the way the C routine was intended.</source>
          <target state="translated">&lt;code&gt;rms&lt;/code&gt; を設計した場合、おそらく &lt;code&gt;seq&lt;/code&gt; と呼ばれる長さ &lt;code&gt;n&lt;/code&gt; の &lt;code&gt;double&lt;/code&gt; 値の入力のみの配列を取り、二乗平均平方根を返すルーチンにした。ただし、&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;のデフォルトの動作は、コンパイルするラッパー関数を作成することですが、Cルーチンが意図した方法でスクリプト言語から使用することはほぼ不可能です。</target>
        </trans-unit>
        <trans-unit id="995e94e98f9bf00d5fa392b05fcaad89987b6cf9" translate="yes" xml:space="preserve">
          <source>If we operate on &lt;code&gt;arr&lt;/code&gt; with a numpy function, numpy will again use the &lt;code&gt;__array__&lt;/code&gt; interface to convert it to an array and then apply the function in the usual way.</source>
          <target state="translated">numpy関数を使用して &lt;code&gt;arr&lt;/code&gt; を操作する場合、numpyは再び &lt;code&gt;__array__&lt;/code&gt; インターフェイスを使用して配列に変換し、通常の方法で関数を適用します。</target>
        </trans-unit>
        <trans-unit id="f97977f7edcb7ebd515a426a761fd048280b35b8" translate="yes" xml:space="preserve">
          <source>If we subclass ndarray, we need to deal not only with explicit construction of our array type, but also &lt;a href=&quot;#view-casting&quot;&gt;View casting&lt;/a&gt; or &lt;a href=&quot;#new-from-template&quot;&gt;Creating new from template&lt;/a&gt;. NumPy has the machinery to do this, and this machinery that makes subclassing slightly non-standard.</source>
          <target state="translated">ndarrayをサブクラス化する場合は、配列型の明示的な構築だけでなく、&lt;a href=&quot;#view-casting&quot;&gt;ビューのキャスト&lt;/a&gt;や&lt;a href=&quot;#new-from-template&quot;&gt;テンプレートからの新規作成&lt;/a&gt;も処理する必要があります。NumPyにはこれを行うための機構があり、サブクラス化をわずかに非標準にするこの機構があります。</target>
        </trans-unit>
        <trans-unit id="be3492efc8039f75947121fd3b30a1fa61841ee0" translate="yes" xml:space="preserve">
          <source>If we want to get the max and min at the same time, we can stack the indices first</source>
          <target state="translated">最大値と最小値を同時に取得したい場合は、最初にインデックスをスタックすることができます。</target>
        </trans-unit>
        <trans-unit id="0b08db0a15b738091c43209c89bb138ad98fa1a5" translate="yes" xml:space="preserve">
          <source>If writing to the value in &amp;lsquo;op&amp;rsquo; is desired, set the boolean &amp;lsquo;writeable&amp;rsquo; to 1. This raises an error when &amp;lsquo;op&amp;rsquo; is a scalar, list of lists, or other non-writeable &amp;lsquo;op&amp;rsquo;. This differs from passing &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; to PyArray_FromAny, where the writeable array may be a copy of the input.</source>
          <target state="translated">「op」の値への書き込みが必要な場合は、ブール値「writeable」を1に設定します。これにより、「op」がスカラー、リストのリスト、またはその他の書き込み不可能な「op」の場合、エラーが発生します。これは、書き込み可能な配列が入力のコピーである場合がある&lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;をPyArray_FromAnyに渡すこととは異なります。</target>
        </trans-unit>
        <trans-unit id="d75e358b391e7be55d7e5cd127dec8c0712acdf8" translate="yes" xml:space="preserve">
          <source>If you already have Matplotlib installed, you can import it with:</source>
          <target state="translated">すでにMatplotlibがインストールされている場合は、それを使ってインポートすることができます。</target>
        </trans-unit>
        <trans-unit id="7cdef2e4118adffef01cdccc2d7928ddab94e772" translate="yes" xml:space="preserve">
          <source>If you already have Python, you can install NumPy with:</source>
          <target state="translated">すでにPythonをお持ちの方は、NumPyをインストールしておきましょう。</target>
        </trans-unit>
        <trans-unit id="541c45cda5d06a312d0d288fb58df06c65cc4253" translate="yes" xml:space="preserve">
          <source>If you are a first-time contributor:</source>
          <target state="translated">初めて投稿される方</target>
        </trans-unit>
        <trans-unit id="df553e5d4398ed0e4dcd8bdb41c75c9a32748a9c" translate="yes" xml:space="preserve">
          <source>If you are constructing an array using the C API, and specifying your own memory, you should use the function &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt;&lt;code&gt;PyArray_SetBaseObject&lt;/code&gt;&lt;/a&gt; to set the base to an object which owns the memory.</source>
          <target state="translated">C APIを使用して配列を作成し、独自のメモリを指定する場合は、関数&lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt; &lt;code&gt;PyArray_SetBaseObject&lt;/code&gt; &lt;/a&gt;を使用して、メモリを所有するオブジェクトにベースを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="348c2da24ae5fb5879e487ab21af4e5f5e066f22" translate="yes" xml:space="preserve">
          <source>If you are executing the commands above in the IPython shell, it might be necessary to use the command &lt;code&gt;plt.show()&lt;/code&gt; to show the image window.</source>
          <target state="translated">上記のコマンドをIPythonシェルで実行している場合は、コマンド &lt;code&gt;plt.show()&lt;/code&gt; を使用して画像ウィンドウを表示する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="39a6add3139de0ce389e24494d0e34b85d48e6cd" translate="yes" xml:space="preserve">
          <source>If you are not a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend your class define special methods like &lt;code&gt;__add__&lt;/code&gt; and &lt;code&gt;__lt__&lt;/code&gt; that delegate to ufuncs just like ndarray does. An easy way to do this is to subclass from &lt;a href=&quot;generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt;&lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; の&lt;/a&gt;サブクラスでない場合は、 &lt;code&gt;__add__&lt;/code&gt; と同じようにufuncにデリゲートする__add__ や &lt;code&gt;__lt__&lt;/code&gt; などの特別なメソッドをクラスで定義することをお勧めします。これを行う簡単な方法は、&lt;a href=&quot;generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt; &lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt; &lt;/a&gt;からサブクラス化することです。</target>
        </trans-unit>
        <trans-unit id="7c035b2fcdae27121ab8105788f03a3cf705ba84" translate="yes" xml:space="preserve">
          <source>If you are unfamiliar with git/GitHub or the process of submitting a pull request (PR), check our &lt;a href=&quot;index#devindex&quot;&gt;Contributor Guide&lt;/a&gt;.</source>
          <target state="translated">git / GitHubまたはプルリクエスト（PR）を送信するプロセスに慣れていない場合は、&lt;a href=&quot;index#devindex&quot;&gt;コントリビューターガイドを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="ad4921cf970b61f597c75ff9a8df48494b979251" translate="yes" xml:space="preserve">
          <source>If you are unsure whether your tutorial is useful to the community, consider submitting an issue on GitHub suggesting it, or asking on the mailing list or Stack Overflow.</source>
          <target state="translated">自分のチュートリアルがコミュニティにとって有用かどうかわからない場合は、GitHub で課題を提出して提案したり、メーリングリストや Stack Overflow で質問したりすることを検討してみてください。</target>
        </trans-unit>
        <trans-unit id="0e97815d05cf1a3f4e8ef4ccabd6db0958203378" translate="yes" xml:space="preserve">
          <source>If you are using a development setup, make sure to run &lt;code&gt;git clean -xdf&lt;/code&gt; to delete all files not under version control (be careful not to lose any modifications you made, e.g. &lt;code&gt;site.cfg&lt;/code&gt;). In many cases files from old builds may lead to incorrect builds.</source>
          <target state="translated">開発セットアップを使用している場合は、必ず &lt;code&gt;git clean -xdf&lt;/code&gt; を実行して、バージョン管理されていないすべてのファイルを削除してください（ &lt;code&gt;site.cfg&lt;/code&gt; などの変更を失わないように注意してください）。多くの場合、古いビルドのファイルは誤ったビルドにつながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="b1cb5159432a421c78854c686fcae1e006f9ca62" translate="yes" xml:space="preserve">
          <source>If you are using your own image, this command might take a while to run, depending on the size of your image and your hardware. Don&amp;rsquo;t worry, this is normal! The SVD can be a pretty intensive computation.</source>
          <target state="translated">独自のイメージを使用している場合、イメージのサイズとハードウェアによっては、このコマンドの実行に時間がかかる場合があります。心配しないでください、これは正常です！SVDはかなり集中的な計算になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="773329737315bec4048498e2cb47eae44fac50c7" translate="yes" xml:space="preserve">
          <source>If you are writing a tutorial or how-to, we encourage you to use real images and data (provided they are appropriately licensed and available). This makes the material more engaging for readers, and choosing the right data can add pedagogical value to your content.</source>
          <target state="translated">チュートリアルやハウツーを書く場合は、実際の画像やデータを使用することをお勧めします(適切なライセンスを取得し、利用可能な場合に限ります)。これにより、教材は読者をより魅力的なものにし、適切なデータを選択することで、コンテンツに教育的な価値を付加することができます。</target>
        </trans-unit>
        <trans-unit id="d4136f331004a4bb7cc67364f6afc023fd507b25" translate="yes" xml:space="preserve">
          <source>If you are writing an extension module that will include quite a bit of your own algorithmic code as well, then Cython is a good match. Among its features is the ability to easily and quickly work with multidimensional arrays.</source>
          <target state="translated">もしあなたが独自のアルゴリズムコードを含む拡張モジュールを書くのであれば、Cythonが適しています。Cythonの機能の中には、多次元配列を簡単かつ迅速に扱える機能があります。</target>
        </trans-unit>
        <trans-unit id="97bfbc5e92312fd81c84cc357b8b556f1c360029" translate="yes" xml:space="preserve">
          <source>If you are writing code that needs to support older versions of numpy, note that prior to 1.15, &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; was not a context manager and did not have a &lt;code&gt;close&lt;/code&gt; method. Instead it relied on the destructor to initiate the writeback of the buffer.</source>
          <target state="translated">古いバージョンのnumpyをサポートする必要のあるコードを記述している場合、1.15より前は、&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;はコンテキストマネージャーではなく、 &lt;code&gt;close&lt;/code&gt; メソッドがなかったことに注意してください。代わりに、バッファのライトバックを開始するためにデストラクタに依存していました。</target>
        </trans-unit>
        <trans-unit id="36ae6f737ad58a255ae0b7d304bf552b5362f8bf" translate="yes" xml:space="preserve">
          <source>If you are writing the algorithm, then I recommend that you use the stride information contained in the array to access the elements of the array (the &lt;a href=&quot;../reference/c-api/array#c.PyArray_GetPtr&quot;&gt;&lt;code&gt;PyArray_GetPtr&lt;/code&gt;&lt;/a&gt; macros make this painless). Then, you can relax your requirements so as not to force a single-segment array and the data-copying that might result.</source>
          <target state="translated">アルゴリズムを作成している場合は、配列に含まれているストライド情報を使用して配列の要素にアクセスすることをお勧めします（&lt;a href=&quot;../reference/c-api/array#c.PyArray_GetPtr&quot;&gt; &lt;code&gt;PyArray_GetPtr&lt;/code&gt; &lt;/a&gt;マクロを使用すると簡単にアクセスできます）。次に、要件を緩和して、単一セグメントの配列とその結果生じる可能性のあるデータコピーを強制しないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="b55dd90ddf002e60cb33ced8fd77f1baf2f3e711" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t already comfortable with reading tutorials that contain a lot of code, you might not know how to interpret a code block that looks like this:</source>
          <target state="translated">多くのコードを含むチュートリアルを読むことにまだ慣れていない場合は、次のようなコードブロックを解釈する方法がわからない可能性があります。</target>
        </trans-unit>
        <trans-unit id="0aadabdedda0a7396088f7e7156f2221bf29f201" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t familiar with this style, it&amp;rsquo;s very easy to understand. If you see &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, you&amp;rsquo;re looking at &lt;strong&gt;input&lt;/strong&gt;, or the code that you would enter. Everything that doesn&amp;rsquo;t have &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; in front of it is &lt;strong&gt;output&lt;/strong&gt;, or the results of running your code. This is the style you see when you run &lt;code&gt;python&lt;/code&gt; on the command line, but if you&amp;rsquo;re using IPython, you might see a different style.</source>
          <target state="translated">このスタイルに慣れていない場合は、非常に理解しやすいです。 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; が表示されている場合は、&lt;strong&gt;入力&lt;/strong&gt;または&lt;strong&gt;入力&lt;/strong&gt;するコードを確認しています。 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; が前にないものはすべて&lt;strong&gt;出力される&lt;/strong&gt;か、コードの実行結果です。これは、コマンドラインで &lt;code&gt;python&lt;/code&gt; を実行したときに表示されるスタイルですが、IPythonを使用している場合は、別のスタイルが表示される場合があります。</target>
        </trans-unit>
        <trans-unit id="bb14ac1edba829d3112a46c925f71b9aef58fe4d" translate="yes" xml:space="preserve">
          <source>If you begin with a 1D array like this one:</source>
          <target state="translated">このように1次元配列から始めると</target>
        </trans-unit>
        <trans-unit id="50d785ffa376c738acba9fd3062d7ce8c3507854" translate="yes" xml:space="preserve">
          <source>If you construct an array by passing in your own memory buffer as a parameter, you need to set the array&amp;rsquo;s &lt;code&gt;base&lt;/code&gt; property to ensure the lifetime of the memory buffer is appropriate.</source>
          <target state="translated">独自のメモリバッファをパラメータとして渡すことによって配列を構築する場合、メモリバッファの寿命が適切であることを保証するために、配列の &lt;code&gt;base&lt;/code&gt; プロパティを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="5a09672523495c2e56a3b155436551396bec1686" translate="yes" xml:space="preserve">
          <source>If you created this array &amp;ldquo;a&amp;rdquo;</source>
          <target state="translated">この配列「a」を作成した場合</target>
        </trans-unit>
        <trans-unit id="72ea524f17d30ae2b5b06f8b246da402ecc0aab1" translate="yes" xml:space="preserve">
          <source>If you define &lt;code&gt;__array_ufunc__&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;__array_ufunc__&lt;/code&gt; を定義する場合：</target>
        </trans-unit>
        <trans-unit id="ad02ce8758b2b7ef1353b5d6ceccf301d0d32341" translate="yes" xml:space="preserve">
          <source>If you depend on the current behavior, then we suggest copying the returned array explicitly, i.e., use &lt;code&gt;np.diagonal(a).copy()&lt;/code&gt; instead of just &lt;code&gt;np.diagonal(a)&lt;/code&gt;. This will work with both past and future versions of NumPy.</source>
          <target state="translated">現在の動作に依存している場合は、返された配列を明示的にコピーすることをお勧めします。つまり、単に &lt;code&gt;np.diagonal(a)&lt;/code&gt; ではなく &lt;code&gt;np.diagonal(a).copy()&lt;/code&gt; を使用します。これは、NumPyの過去のバージョンと将来のバージョンの両方で機能します。</target>
        </trans-unit>
        <trans-unit id="e04ecd6da4be5a785c0ba7636ed164c9197444de" translate="yes" xml:space="preserve">
          <source>If you didn&amp;rsquo;t actually mess up but there are merge conflicts, you need to resolve those. This can be one of the trickier things to get right. For a good description of how to do this, see &lt;a href=&quot;https://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging#Basic-Merge-Conflicts&quot;&gt;this article on merging conflicts&lt;/a&gt;.</source>
          <target state="translated">実際に混乱していなくても、マージの競合がある場合は、それらを解決する必要があります。これは、正しく行うのが難しいことの1つになる可能性があります。これを行う方法の適切な説明については、&lt;a href=&quot;https://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging#Basic-Merge-Conflicts&quot;&gt;競合のマージに関するこの記事を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e434a6791515ca1be095b9c944cc43b7244bf754" translate="yes" xml:space="preserve">
          <source>If you do this often, consider making CDN_URL and NPY_WHLS part of your default environment.</source>
          <target state="translated">このようなことを頻繁に行う場合は、CDN_URLとNPY_WHLSをデフォルト環境の一部にすることを検討してください。</target>
        </trans-unit>
        <trans-unit id="48d4a9d3c1a910573f5c99d8162fc661353211a4" translate="yes" xml:space="preserve">
          <source>If you do want to use Fortran ordering realize that there are two approaches to consider: 1) accept that the first index is just not the most rapidly changing in memory and have all your I/O routines reorder your data when going from memory to disk or visa versa, or use numpy&amp;rsquo;s mechanism for mapping the first index to the most rapidly varying data. We recommend the former if possible. The disadvantage of the latter is that many of numpy&amp;rsquo;s functions will yield arrays without Fortran ordering unless you are careful to use the &amp;lsquo;order&amp;rsquo; keyword. Doing this would be highly inconvenient.</source>
          <target state="translated">Fortranの順序付けを使用したい場合は、2つのアプローチを検討する必要があることを理解してください。1）最初のインデックスがメモリ内で最も急速に変化していないことを受け入れ、メモリからディスクに移動するときにすべてのI / Oルーチンでデータを並べ替えます。またはその逆、またはnumpyのメカニズムを使用して、最初のインデックスを最も急速に変化するデータにマッピングします。できれば前者をお勧めします。後者の欠点は、「order」キーワードを慎重に使用しない限り、numpyの関数の多くがFortran順序付けなしで配列を生成することです。これを行うのは非常に不便です。</target>
        </trans-unit>
        <trans-unit id="e095aad5306acb61c4cd71ef6f17e3d170477a48" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have Python yet, you might want to consider using &lt;a href=&quot;https://www.anaconda.com/&quot;&gt;Anaconda&lt;/a&gt;. It&amp;rsquo;s the easiest way to get started. The good thing about getting this distribution is the fact that you don&amp;rsquo;t need to worry too much about separately installing NumPy or any of the major packages that you&amp;rsquo;ll be using for your data analyses, like pandas, Scikit-Learn, etc.</source>
          <target state="translated">Pythonをまだお持ちでない場合は、&lt;a href=&quot;https://www.anaconda.com/&quot;&gt;Anacondaの&lt;/a&gt;使用を検討することをお勧めします。始めるのに最も簡単な方法です。このディストリビューションを入手することの良い点は、NumPyや、パンダ、Scikit-Learnなどのデータ分析に使用する主要なパッケージを個別にインストールすることについてあまり心配する必要がないという事実です。</target>
        </trans-unit>
        <trans-unit id="a32666f1e22aaef44f676905cda497776944f399" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have a &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; account, go to the &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; page, and make one.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;アカウントをお持ちでない場合は、&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;ページにアクセスして作成してください。</target>
        </trans-unit>
        <trans-unit id="00332ddab35edaceba6aacb138a662dde934bdb6" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t write to the array returned by this function, then you can just ignore all of the above.</source>
          <target state="translated">この関数によって返された配列に書き込まない場合は、上記のすべてを無視できます。</target>
        </trans-unit>
        <trans-unit id="ddf01261f92656913e0a2ec2a624205e1c2e4b27" translate="yes" xml:space="preserve">
          <source>If you forgot to make a backup branch:</source>
          <target state="translated">バックアップブランチを作るのを忘れていたら</target>
        </trans-unit>
        <trans-unit id="fe80a2730dc1732963891b3491f20ea69996dc7b" translate="yes" xml:space="preserve">
          <source>If you get a Python error that looks like the following:</source>
          <target state="translated">以下のようなPythonのエラーが出たら</target>
        </trans-unit>
        <trans-unit id="a53df4d5bfbd08adf0a5725999a9e0795dcb81f8" translate="yes" xml:space="preserve">
          <source>If you have a collection of tests that must be run multiple times with minor variations, it can be helpful to create a base class containing all the common tests, and then create a subclass for each variation. Several examples of this technique exist in NumPy; below are excerpts from one in &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py&quot;&gt;numpy/linalg/tests/test_linalg.py&lt;/a&gt;:</source>
          <target state="translated">マイナーバリエーションで複数回実行する必要があるテストのコレクションがある場合は、すべての一般的なテストを含む基本クラスを作成し、バリエーションごとにサブクラスを作成すると便利です。この手法のいくつかの例がNumPyに存在します。以下は、&lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py&quot;&gt;numpy / linalg / tests / test_linalg.pyの&lt;/a&gt; 1 つからの抜粋です。</target>
        </trans-unit>
        <trans-unit id="b76d68a8292694b360bf5a2e8b28bbbb6775f004" translate="yes" xml:space="preserve">
          <source>If you have already decided which type of document you want to write, you can check out the following specific guides:</source>
          <target state="translated">どのタイプの文書を書くかが決まっている場合は、以下のような具体的なガイドを参考にしてみてはいかがでしょうか。</target>
        </trans-unit>
        <trans-unit id="edd73a9e41446ceec5844edddba90601c9a86d6a" translate="yes" xml:space="preserve">
          <source>If you have an array of datetime64 day values, and you want a count of how many of them are valid dates, you can do this:</source>
          <target state="translated">datetime64日分の値の配列を持っていて、そのうちのいくつが有効な日付であるかを数えたい場合は、これを行うことができます。</target>
        </trans-unit>
        <trans-unit id="afdea327e298d690859d2830125b0506072aa9c8" translate="yes" xml:space="preserve">
          <source>If you have made changes to files that have changed also upstream, this may generate merge conflicts that you need to resolve. See &lt;a href=&quot;#recovering-from-mess-up&quot;&gt;below&lt;/a&gt; for help in this case.</source>
          <target state="translated">アップストリームでも変更されたファイルに変更を加えた場合、これにより、解決する必要のあるマージの競合が発生する可能性があります。この場合のヘルプについては、&lt;a href=&quot;#recovering-from-mess-up&quot;&gt;以下&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3940d12fada6e74d3a4f390741c7084734cc9f7c" translate="yes" xml:space="preserve">
          <source>If you have worked before with only one- or two-dimensional arrays in NumPy, you might use &lt;a href=&quot;../reference/generated/numpy.dot#numpy.dot&quot;&gt;&lt;code&gt;numpy.dot&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;numpy.matmul&lt;/code&gt;&lt;/a&gt; (or the &lt;code&gt;@&lt;/code&gt; operator) interchangeably. However, for n-dimensional arrays, they work in very different ways. For more details, check the documentation &lt;a href=&quot;../reference/generated/numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;numpy.matmul&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">以前にNumPyで1次元または2次元の配列のみを使用したことがある場合は、&lt;a href=&quot;../reference/generated/numpy.dot#numpy.dot&quot;&gt; &lt;code&gt;numpy.dot&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../reference/generated/numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;numpy.matmul&lt;/code&gt; &lt;/a&gt;（または &lt;code&gt;@&lt;/code&gt; 演算子）を同じ意味で使用できます。ただし、n次元配列の場合、それらは非常に異なる方法で機能します。詳細については、ドキュメント&lt;a href=&quot;../reference/generated/numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;numpy.matmul&lt;/code&gt; を&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="61245264d3565a00eccec23e4c121348aa40e38c" translate="yes" xml:space="preserve">
          <source>If you index &lt;code&gt;x&lt;/code&gt; at position 1 you get a structure:</source>
          <target state="translated">位置1で &lt;code&gt;x&lt;/code&gt; にインデックスを付けると、次の構造が得られます。</target>
        </trans-unit>
        <trans-unit id="19e171dd0ccd0c17916e231c961dda814be7cba5" translate="yes" xml:space="preserve">
          <source>If you just use Cython to compile a standard Python module, then you will get a C extension module that typically runs a bit faster than the equivalent Python module. Further speed increases can be gained by using the &lt;code&gt;cdef&lt;/code&gt; keyword to statically define C variables.</source>
          <target state="translated">Cythonを使用して標準のPythonモジュールをコンパイルするだけの場合、通常、同等のPythonモジュールよりも少し高速に実行されるC拡張モジュールを取得します。 &lt;code&gt;cdef&lt;/code&gt; キーワードを使用してC変数を静的に定義することにより、さらに速度を上げることができます。</target>
        </trans-unit>
        <trans-unit id="0c28db0c64cef3fce82c680e83d5a3bf5a7d6611" translate="yes" xml:space="preserve">
          <source>If you know you have boolean arguments, you can get away with using NumPy&amp;rsquo;s bitwise operators, but be careful with parentheses, like this: z = (x &amp;gt; 1) &amp;amp; (x &amp;lt; 2). The absence of NumPy operator forms of logical_and and logical_or is an unfortunate consequence of Python&amp;rsquo;s design.</source>
          <target state="translated">ブール引数があることがわかっている場合は、NumPyのビット演算子を使用する必要はありませんが、次のように括弧に注意してください：z =（x&amp;gt; 1）＆（x &amp;lt;2）。logic_andおよびlogical_orのNumPy演算子形式がないことは、Pythonの設計の残念な結果です。</target>
        </trans-unit>
        <trans-unit id="b50bdabfd893e921c2545949ea3927871fd9123c" translate="yes" xml:space="preserve">
          <source>If you mess up during a rebase:</source>
          <target state="translated">リベース中に失敗したら</target>
        </trans-unit>
        <trans-unit id="d5b391b72fd29e26b5330f8bc73fd6e0406a58fe" translate="yes" xml:space="preserve">
          <source>If you need a stricter way to identify a &lt;em&gt;numerical&lt;/em&gt; scalar, use &lt;code&gt;isinstance(x, numbers.Number)&lt;/code&gt;, as that returns &lt;code&gt;False&lt;/code&gt; for most non-numerical elements such as strings.</source>
          <target state="translated">&lt;em&gt;数値&lt;/em&gt;スカラーを識別するためのより厳密な方法が必要な場合は、 &lt;code&gt;isinstance(x, numbers.Number)&lt;/code&gt; ）を使用します。これは、文字列などのほとんどの非数値要素に対して &lt;code&gt;False&lt;/code&gt; を返すためです。</target>
        </trans-unit>
        <trans-unit id="6b620559920ae0493b1df8c4590d21b79ff5570f" translate="yes" xml:space="preserve">
          <source>If you need to generate a good seed &amp;ldquo;offline&amp;rdquo;, then &lt;code&gt;SeedSequence().entropy&lt;/code&gt; or using &lt;code&gt;secrets.randbits(128)&lt;/code&gt; from the standard library are both convenient ways.</source>
          <target state="translated">「オフライン」で適切なシードを生成する必要がある場合、 &lt;code&gt;SeedSequence().entropy&lt;/code&gt; または標準ライブラリからの &lt;code&gt;secrets.randbits(128)&lt;/code&gt; の使用はどちらも便利な方法です。</target>
        </trans-unit>
        <trans-unit id="9dadc35707bb7693c411ca705b6a79a8fd4bc6a1" translate="yes" xml:space="preserve">
          <source>If you need to generate a plot for your values, it&amp;rsquo;s very simple with &lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt;.</source>
          <target state="translated">値のプロットを生成する必要がある場合は、&lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlibを使用する&lt;/a&gt;と非常に簡単です。</target>
        </trans-unit>
        <trans-unit id="cd4f29a22f2d83f814cd7d3d9fed381be8da6e41" translate="yes" xml:space="preserve">
          <source>If you notice you messed up after the rebase:</source>
          <target state="translated">リベースしてから気がついたらめちゃくちゃになっていた。</target>
        </trans-unit>
        <trans-unit id="ee201455e7a9931a5a44547dd0593d53785f3676" translate="yes" xml:space="preserve">
          <source>If you obtained NumPy via git, get also the git submodules that contain additional parts required for building the documentation:</source>
          <target state="translated">NumPyをgit経由で取得した場合は、ドキュメントの構築に必要な追加パーツを含むgitサブモジュールも取得してください。</target>
        </trans-unit>
        <trans-unit id="fafc92af92f970e1f9bc871b99562e2a4dcbfd58" translate="yes" xml:space="preserve">
          <source>If you only had $150/month to pay towards the loan, how long would it take to pay-off a loan of $8,000 at 7% annual interest?</source>
          <target state="translated">月々150ドルしかローンの支払いができなかった場合、年利7%で8000ドルのローンを完済するにはどのくらいの期間がかかるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="f1851d09e17596b6fef1418fbf6cd4eb3f3c1218" translate="yes" xml:space="preserve">
          <source>If you only want to get the documentation, note that pre-built versions can be found at</source>
          <target state="translated">ドキュメントを手に入れたいだけなら、ビルド済みのバージョンは次の場所にあります。</target>
        </trans-unit>
        <trans-unit id="4ba77d4ac4c0346cf08567fdade124408903e3ad" translate="yes" xml:space="preserve">
          <source>If you prefer, you can use your own image as you work through this tutorial. In order to transform your image into a NumPy array that can be manipulated, you can use the &lt;code&gt;imread&lt;/code&gt; function from the &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.html#module-matplotlib.pyplot&quot;&gt;&lt;code&gt;matplotlib.pyplot&lt;/code&gt;&lt;/a&gt; submodule. Alternatively, you can use the &lt;a href=&quot;https://imageio.readthedocs.io/en/stable/userapi.html#imageio.imread&quot;&gt;&lt;code&gt;imageio.imread&lt;/code&gt;&lt;/a&gt; function from the &lt;code&gt;imageio&lt;/code&gt; library. Be aware that if you use your own image, you&amp;rsquo;ll likely need to adapt the steps below. For more information on how images are treated when converted to NumPy arrays, see &lt;a href=&quot;https://scikit-image.org/docs/stable/user_guide/numpy_images.html&quot;&gt;A crash course on NumPy for images&lt;/a&gt; from the &lt;code&gt;scikit-image&lt;/code&gt; documentation.</source>
          <target state="translated">必要に応じて、このチュートリアルで作業するときに独自の画像を使用できます。画像を操作可能なNumPy配列に変換するために、&lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.html#module-matplotlib.pyplot&quot;&gt; &lt;code&gt;matplotlib.pyplot&lt;/code&gt; &lt;/a&gt;サブモジュールの &lt;code&gt;imread&lt;/code&gt; 関数を使用できます。または、 &lt;code&gt;imageio&lt;/code&gt; ライブラリの&lt;a href=&quot;https://imageio.readthedocs.io/en/stable/userapi.html#imageio.imread&quot;&gt; &lt;code&gt;imageio.imread&lt;/code&gt; &lt;/a&gt;関数を使用することもできます。独自の画像を使用する場合は、以下の手順を調整する必要がある可能性があることに注意してください。NumPy配列に変換されたときの画像の処理方法の詳細については、 &lt;code&gt;scikit-image&lt;/code&gt; ドキュメントの&lt;a href=&quot;https://scikit-image.org/docs/stable/user_guide/numpy_images.html&quot;&gt;画像に関するNumPyのクラッシュコースを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="163df9c9003b7c4450bb235f2c67b2a07c0207a6" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;f2py&lt;/code&gt; with no arguments, and the line &lt;code&gt;numpy Version&lt;/code&gt; at the end matches the NumPy version printed from &lt;code&gt;python -m numpy.f2py&lt;/code&gt;, then you can use the shorter version. If not, or if you cannot run &lt;code&gt;f2py&lt;/code&gt;, you should replace all calls to &lt;code&gt;f2py&lt;/code&gt; here with the longer version.</source>
          <target state="translated">引数なしで &lt;code&gt;f2py&lt;/code&gt; を実行し、最後の行 &lt;code&gt;numpy Version&lt;/code&gt; が &lt;code&gt;python -m numpy.f2py&lt;/code&gt; から出力されたNumPyバージョンと一致する場合は、短いバージョンを使用できます。そうでない場合、または &lt;code&gt;f2py&lt;/code&gt; を実行できない場合は、ここで &lt;code&gt;f2py&lt;/code&gt; へのすべての呼び出しをより長いバージョンに置き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="c2f8a5ed085feb6d7cb818c6bb6a9239c65b61dd" translate="yes" xml:space="preserve">
          <source>If you run into a situation where a function or method is returning a pointer to an array, your best bet is to write your own version of the function to be wrapped, either with &lt;code&gt;%extend&lt;/code&gt; for the case of class methods or &lt;code&gt;%ignore&lt;/code&gt; and &lt;code&gt;%rename&lt;/code&gt; for the case of functions.</source>
          <target state="translated">関数またはメソッドが配列へのポインターを返す状況に遭遇した場合、最善の策は、ラップする関数の独自のバージョンを記述することです。クラスメソッドの場合は &lt;code&gt;%extend&lt;/code&gt; 、または &lt;code&gt;%ignore&lt;/code&gt; および &lt;code&gt;%rename&lt;/code&gt; 関数の場合は名前を変更します。</target>
        </trans-unit>
        <trans-unit id="2a7a60ee3a192da84e7197524a79fee3ab370312" translate="yes" xml:space="preserve">
          <source>If you see a good tutorial, how-to or explanation that is not included in the official documentation, you can suggest it to be added by &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;opening an issue on GitHub&lt;/a&gt;. Similarly, opening issues to suggest a tutorial, how-to or explanation that you can&amp;rsquo;t find anywhere is a great way to help the documentation team direct efforts towards what users are looking for. &lt;a href=&quot;https://github.com/numpy/numpy/issues/15760&quot;&gt;See this issue&lt;/a&gt; for an example of how to do this.</source>
          <target state="translated">公式ドキュメントに含まれていない優れたチュートリアル、ハウツー、または説明を見つけた場合は&lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;、GitHubで問題を開いて&lt;/a&gt;追加することを提案できます。同様に、どこにも見つからないチュートリアル、ハウツー、または説明を提案するために問題を開くことは、ドキュメントチームがユーザーが探しているものに向けて努力を向けるのに役立つ優れた方法です。&lt;a href=&quot;https://github.com/numpy/numpy/issues/15760&quot;&gt;これ&lt;/a&gt;を行う方法の例については、この問題を参照してください。</target>
        </trans-unit>
        <trans-unit id="c084a3f2a6106a54039205662cc0565194fa0738" translate="yes" xml:space="preserve">
          <source>If you specify an &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;a&lt;/code&gt; must be zero-padded or truncated, the extra/removed values will be added/removed at high frequencies. One can thus resample a series to &lt;code&gt;m&lt;/code&gt; points via Fourier interpolation by: &lt;code&gt;a_resamp = irfft(rfft(a), m)&lt;/code&gt;.</source>
          <target state="translated">あなたが指定した場合 &lt;code&gt;n&lt;/code&gt; ようなゼロパディングまたは切り捨てられている必要があり、余分な/削除値が高頻度で追加/削除されます。したがって、 &lt;code&gt;a_resamp = irfft(rfft(a), m)&lt;/code&gt; によってフーリエ補間を介してシリーズを &lt;code&gt;m&lt;/code&gt; ポイントにリサンプリングできます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dd256004a74583cc184f8439d5d048c30d412fb7" translate="yes" xml:space="preserve">
          <source>If you start with these arrays:</source>
          <target state="translated">これらの配列から始めると</target>
        </trans-unit>
        <trans-unit id="b2448ad4b64da661ec458b63dd3b9923ea02aca5" translate="yes" xml:space="preserve">
          <source>If you start with this array:</source>
          <target state="translated">この配列から始めた場合</target>
        </trans-unit>
        <trans-unit id="777d1be2db0dc4450d7b4eef96ddf2f8d5888d83" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend that you put all your override logic in &lt;code&gt;__array_ufunc__&lt;/code&gt; and not also override special methods. This ensures the class hierarchy is determined in only one place rather than separately by the ufunc machinery and by the binary operation rules (which gives preference to special methods of subclasses; the alternative way to enforce a one-place only hierarchy, of setting &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, would seem very unexpected and thus confusing, as then the subclass would not work at all with ufuncs).</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;をサブクラス化する場合、すべてのオーバーライドロジックを &lt;code&gt;__array_ufunc__&lt;/code&gt; に配置し、特別なメソッドもオーバーライドしないことをお勧めします。のみ階層ワン場所を強制する別の方法は、設定で、これは、クラス階層はサブクラスの特別な方法に優先を与える（ufunc機械によって、および二項演算規則によって唯一の場所ではなく、別々に決定されることを保証&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; を&lt;/a&gt;します&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;、サブクラスがufuncsでまったく機能しないため、非常に予期せず混乱を招くように見えます。</target>
        </trans-unit>
        <trans-unit id="2b988c177dc2b27c86ba6dc5904e8834a5cbf804" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend that you put all your override logic in &lt;code&gt;__array_ufunc__&lt;/code&gt; and not also override special methods. This ensures the class hierarchy is determined in only one place rather than separately by the ufunc machinery and by the binary operation rules (which gives preference to special methods of subclasses; the alternative way to enforce a one-place only hierarchy, of setting &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; to None, would seem very unexpected and thus confusing, as then the subclass would not work at all with ufuncs).</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;をサブクラス化する場合は、すべてのオーバーライドロジックを &lt;code&gt;__array_ufunc__&lt;/code&gt; に配置し、特別なメソッドもオーバーライドしないことをお勧めします。これにより、クラス階層は、ufunc機構と二項演算ルール（サブクラスの特別なメソッドを優先します。1か所のみの階層を適用する別の方法である&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;をどれも、非常に予想外で混乱しているように見えます。その場合、サブクラスはufuncsではまったく機能しません）。</target>
        </trans-unit>
        <trans-unit id="68630e24ebcf26648c6330182b68ffff11c7fe21" translate="yes" xml:space="preserve">
          <source>If you want to allow your new data-type to also be able to share in the scalar coercion rules, then you need to specify the scalarkind function in the data-type object&amp;rsquo;s &amp;ldquo;.f&amp;rdquo; member to return the kind of scalar the new data-type should be seen as (the value of the scalar is available to that function). Then, you can register data-types that can be cast to separately for each scalar kind that may be returned from your user-defined data-type. If you don&amp;rsquo;t register scalar coercion handling, then all of your user-defined data-types will be seen as &lt;a href=&quot;../reference/c-api/array#c.NPY_NOSCALAR&quot;&gt;&lt;code&gt;NPY_NOSCALAR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">新しいデータ型がスカラー強制ルールでも共有できるようにする場合は、データ型オブジェクトの「.f」メンバーでscalarkind関数を指定して、新しいデータのスカラーの種類を返す必要があります。 -typeは次のように見なされます（スカラーの値はその関数で使用できます）。次に、ユーザー定義のデータ型から返される可能性のあるスカラーの種類ごとに個別にキャストできるデータ型を登録できます。スカラー強制処理を登録しない場合、ユーザー定義のすべてのデータ型は&lt;a href=&quot;../reference/c-api/array#c.NPY_NOSCALAR&quot;&gt; &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; &lt;/a&gt;として表示されます。</target>
        </trans-unit>
        <trans-unit id="b381b011cdbc746e6a1a9147256650f6139d3056" translate="yes" xml:space="preserve">
          <source>If you want to be able to run the examples in this tutorial, you should also have &lt;a href=&quot;https://matplotlib.org/&quot;&gt;matplotlib&lt;/a&gt; and &lt;a href=&quot;https://scipy.org&quot;&gt;SciPy&lt;/a&gt; installed on your computer.</source>
          <target state="translated">このチュートリアルの例を実行できるようにする場合は、コンピューターに&lt;a href=&quot;https://matplotlib.org/&quot;&gt;matplotlib&lt;/a&gt;と&lt;a href=&quot;https://scipy.org&quot;&gt;SciPyも&lt;/a&gt;インストールしておく必要があります。</target>
        </trans-unit>
        <trans-unit id="2bd528b5e948a367e7029016eb9b4a7e59a0c3cc" translate="yes" xml:space="preserve">
          <source>If you want to check your array, you can run::</source>
          <target state="translated">配列をチェックしたい場合は、:.</target>
        </trans-unit>
        <trans-unit id="239d78c449f1143da9fe3cab0308bfd5b8c57120" translate="yes" xml:space="preserve">
          <source>If you want to distribute your f2py extension module, then you only need to include the .pyf file and the Fortran code. The distutils extensions in NumPy allow you to define an extension module entirely in terms of this interface file. A valid &lt;code&gt;setup.py&lt;/code&gt; file allowing distribution of the &lt;code&gt;add.f&lt;/code&gt; module (as part of the package &lt;code&gt;f2py_examples&lt;/code&gt; so that it would be loaded as &lt;code&gt;f2py_examples.add&lt;/code&gt;) is:</source>
          <target state="translated">f2py拡張モジュールを配布する場合は、.pyfファイルとFortranコードを含めるだけで済みます。NumPyのdistutils拡張機能を使用すると、このインターフェイスファイルに関して拡張モジュールを完全に定義できます。有効な &lt;code&gt;setup.py&lt;/code&gt; の配布可能ファイル &lt;code&gt;add.f&lt;/code&gt; のモジュールは、（パッケージの一部として &lt;code&gt;f2py_examples&lt;/code&gt; それはとしてロードされますように &lt;code&gt;f2py_examples.add&lt;/code&gt; ）です。</target>
        </trans-unit>
        <trans-unit id="205839ed0e5eb197529b1363e1bb132c099c8dee" translate="yes" xml:space="preserve">
          <source>If you want to edit an array with aligned &lt;code&gt;double&lt;/code&gt; code, but the order doesn&amp;rsquo;t matter, you would use this.</source>
          <target state="translated">配列された &lt;code&gt;double&lt;/code&gt; コードで配列を編集したいが、順序が重要でない場合は、これを使用します。</target>
        </trans-unit>
        <trans-unit id="354259176d8d4848edf2f2ea177ee9321090388c" translate="yes" xml:space="preserve">
          <source>If you want to generate a list of coordinates where the elements exist, you can zip the arrays, iterate over the list of coordinates, and print them. For example:</source>
          <target state="translated">要素が存在する座標のリストを生成したい場合は、配列をzipで圧縮し、座標のリストを反復処理して印刷することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="09988ae17a5580ba08c41432cf193fcdceccc334" translate="yes" xml:space="preserve">
          <source>If you want to get the unique rows or columns, make sure to pass the &lt;code&gt;axis&lt;/code&gt; argument. To find the unique rows, specify &lt;code&gt;axis=0&lt;/code&gt; and for columns, specify &lt;code&gt;axis=1&lt;/code&gt;.</source>
          <target state="translated">一意の行または列を取得する場合は、必ず &lt;code&gt;axis&lt;/code&gt; 引数を渡してください。一意の行を見つけるには、 &lt;code&gt;axis=0&lt;/code&gt; を指定し、列には &lt;code&gt;axis=1&lt;/code&gt; を指定します。</target>
        </trans-unit>
        <trans-unit id="a706c6c7d842fe3c84f0f98172224bf53de48486" translate="yes" xml:space="preserve">
          <source>If you want to learn more about C and Fortran order, you can &lt;a href=&quot;../reference/internals#numpy-internals&quot;&gt;read more about the internal organization of NumPy arrays here&lt;/a&gt;. Essentially, C and Fortran orders have to do with how indices correspond to the order the array is stored in memory. In Fortran, when moving through the elements of a two-dimensional array as it is stored in memory, the &lt;strong&gt;first&lt;/strong&gt; index is the most rapidly varying index. As the first index moves to the next row as it changes, the matrix is stored one column at a time. This is why Fortran is thought of as a &lt;strong&gt;Column-major language&lt;/strong&gt;. In C on the other hand, the &lt;strong&gt;last&lt;/strong&gt; index changes the most rapidly. The matrix is stored by rows, making it a &lt;strong&gt;Row-major language&lt;/strong&gt;. What you do for C or Fortran depends on whether it&amp;rsquo;s more important to preserve the indexing convention or not reorder the data.</source>
          <target state="translated">CおよびFortranの順序について詳しく知りたい場合&lt;a href=&quot;../reference/internals#numpy-internals&quot;&gt;は、NumPy配列の内部構成について詳しくはこちらをご覧ください&lt;/a&gt;。基本的に、CおよびFortranの順序は、配列がメモリに格納される順序にインデックスがどのように対応するかと関係があります。 Fortranでは、メモリに格納されている2次元配列の要素を移動するとき、&lt;strong&gt;最初の&lt;/strong&gt;インデックスが最も急速に変化するインデックスです。最初のインデックスが変化するにつれて次の行に移動すると、行列は一度に1列ずつ格納されます。これが、Fortranが&lt;strong&gt;列優先言語&lt;/strong&gt;と見なされている理由&lt;strong&gt;です&lt;/strong&gt;。一方、Cでは、&lt;strong&gt;最後の&lt;/strong&gt;インデックスが最も急速に変化します。行列は行ごとに格納されるため、&lt;strong&gt;行が主要な言語になります&lt;/strong&gt;。CまたはFortranで何をするかは、索引付け規則を維持することがより重要であるか、データを並べ替えないかによって異なります。</target>
        </trans-unit>
        <trans-unit id="90eb7317f80793824fd5ca68d969b076155c2b6b" translate="yes" xml:space="preserve">
          <source>If you want to make use of these extensions in third-party projects, they are available on &lt;a href=&quot;https://pypi.org/&quot;&gt;PyPi&lt;/a&gt; as the &lt;a href=&quot;https://python.org/pypi/numpydoc&quot;&gt;numpydoc&lt;/a&gt; package.</source>
          <target state="translated">あなたは、サードパーティのプロジェクトでこれらの拡張機能を利用したい場合は、上で利用可能な&lt;a href=&quot;https://pypi.org/&quot;&gt;は、PyPI&lt;/a&gt;として&lt;a href=&quot;https://python.org/pypi/numpydoc&quot;&gt;numpydocの&lt;/a&gt;パッケージ。</target>
        </trans-unit>
        <trans-unit id="ce326a8e1b86089803e6e52c507c14343be2d322" translate="yes" xml:space="preserve">
          <source>If you want to print your reversed array, you can run:</source>
          <target state="translated">逆さにした配列を印刷したい場合は、実行します。</target>
        </trans-unit>
        <trans-unit id="0c1156594a53dfa7f56ad636c35e9f1ff1d1bf58" translate="yes" xml:space="preserve">
          <source>If you want to reset both the &lt;code&gt;iterindex&lt;/code&gt; range and the base pointers at the same time, you can do the following to avoid extra buffer copying (be sure to add the return code error checks when you copy this code).</source>
          <target state="translated">&lt;code&gt;iterindex&lt;/code&gt; 範囲とベースポインターの両方を同時にリセットする場合は、次のようにして、余分なバッファーのコピーを回避できます（このコードをコピーするときに、必ずリターンコードエラーチェックを追加してください）。</target>
        </trans-unit>
        <trans-unit id="64b7d79c9f444db203d014596ebfe464ce993392" translate="yes" xml:space="preserve">
          <source>If you want to select values from your array that fulfill certain conditions, it&amp;rsquo;s straightforward with NumPy.</source>
          <target state="translated">特定の条件を満たす配列から値を選択する場合は、NumPyを使用すると簡単です。</target>
        </trans-unit>
        <trans-unit id="37f52b8408b71a5a1ecc2762c718ea9d22604602" translate="yes" xml:space="preserve">
          <source>If you want to store a single ndarray object, store it as a .npy file using &lt;code&gt;np.save&lt;/code&gt;. If you want to store more than one ndarray object in a single file, save it as a .npz file using &lt;code&gt;np.savez&lt;/code&gt;. You can also save several arrays into a single file in compressed npz format with &lt;a href=&quot;../reference/generated/numpy.savez_compressed#numpy.savez_compressed&quot;&gt;&lt;code&gt;savez_compressed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">単一のndarrayオブジェクトを保存する場合は、np.saveを使用して.npyファイルとして保存し &lt;code&gt;np.save&lt;/code&gt; 。あなたが単一のファイルに複数のndarrayオブジェクトを保存したい場合は、使用して.npzファイルとして保存 &lt;code&gt;np.savez&lt;/code&gt; を。あなたはまたして圧縮されたNPZ形式で単一のファイルに複数のアレイを保存することができ&lt;a href=&quot;../reference/generated/numpy.savez_compressed#numpy.savez_compressed&quot;&gt; &lt;code&gt;savez_compressed&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88094cb7e9cc7094508fd58f64e280384e2b183f" translate="yes" xml:space="preserve">
          <source>If you want to work on some stuff with other people, where you are all committing into the same repository, or even the same branch, then just share it via &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;.</source>
          <target state="translated">すべてが同じリポジトリ、または同じブランチにコミットしている他の人と何かに取り組みたい場合は、&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;を介して共有してください。</target>
        </trans-unit>
        <trans-unit id="3d8a79d78dafc5ad7f75ccfea604d3c282656ec2" translate="yes" xml:space="preserve">
          <source>If you wanted to split this array into three equally shaped arrays, you would run:</source>
          <target state="translated">この配列を3つの均等な形の配列に分割したい場合は、以下のように実行します。</target>
        </trans-unit>
        <trans-unit id="fe157cf65afca39aaf28e7392b7bcce12c2fa490" translate="yes" xml:space="preserve">
          <source>If you wanted to split your array after the third and fourth column, you&amp;rsquo;d run:</source>
          <target state="translated">3番目と4番目の列の後で配列を分割する場合は、次のコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="f154266a0558b92de5f9f6ffafaf54fec025441e" translate="yes" xml:space="preserve">
          <source>If you wish to build against OpenBLAS but you also have BLIS available one may predefine the order of searching via the environment variable &lt;code&gt;NPY_BLAS_ORDER&lt;/code&gt; which is a comma-separated list of the above names which is used to determine what to search for, for instance:</source>
          <target state="translated">OpenBLASに対してビルドしたいが、BLISも利用できる場合は、環境変数 &lt;code&gt;NPY_BLAS_ORDER&lt;/code&gt; を使用して検索の順序を事前に定義できます。これは、検索対象を決定するために使用される上記の名前のコンマ区切りリストです。</target>
        </trans-unit>
        <trans-unit id="591a2b4b56f13d91fd0f488df05b473dc7163812" translate="yes" xml:space="preserve">
          <source>If you wish to build against OpenBLAS but you also have MKL available one may predefine the order of searching via the environment variable &lt;code&gt;NPY_LAPACK_ORDER&lt;/code&gt; which is a comma-separated list of the above names, for instance:</source>
          <target state="translated">OpenBLASに対してビルドしたいが、MKLも使用できる場合は、上記の名前のコンマ区切りリストである環境変数 &lt;code&gt;NPY_LAPACK_ORDER&lt;/code&gt; を使用して、検索の順序を事前に定義できます。</target>
        </trans-unit>
        <trans-unit id="05bc8da7a227df06fa8b2e6100a971876a03d9e2" translate="yes" xml:space="preserve">
          <source>If you wish to maintain compatibility with numpy and its subsequent versions (which might add new keyword arguments) but do not want to surface all of numpy&amp;rsquo;s arguments, your function&amp;rsquo;s signature should accept &lt;code&gt;**kwargs&lt;/code&gt;. For example:</source>
          <target state="translated">numpy以降のバージョン（新しいキーワード引数が追加される可能性があります）との互換性を維持したいが、numpyのすべての引数を表示したくない場合は、関数のシグネチャが &lt;code&gt;**kwargs&lt;/code&gt; を受け入れる必要があります。例えば：</target>
        </trans-unit>
        <trans-unit id="97b99e9167303c0b41027781a2b137980415f644" translate="yes" xml:space="preserve">
          <source>If you wish to work the examples in this tutorial, you must also have some software installed on your computer. Please see &lt;a href=&quot;https://scipy.org/install.html&quot;&gt;https://scipy.org/install.html&lt;/a&gt; for instructions.</source>
          <target state="translated">このチュートリアルの例を実行する場合は、コンピューターにいくつかのソフトウェアもインストールする必要があります。手順については、&lt;a href=&quot;https://scipy.org/install.html&quot;&gt;https：//scipy.org/install.html&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7557e5e98e1d6b39d314fab8f9700d862099c3ca" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re interested in learning more about Pandas, take a look at the &lt;a href=&quot;https://pandas.pydata.org/index.html&quot;&gt;official Pandas documentation&lt;/a&gt;. Learn how to install Pandas with the &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/install.html&quot;&gt;official Pandas installation information&lt;/a&gt;.</source>
          <target state="translated">パンダについて詳しく知りたい場合は、&lt;a href=&quot;https://pandas.pydata.org/index.html&quot;&gt;パンダ&lt;/a&gt;の公式ドキュメントをご覧ください。&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/install.html&quot;&gt;公式のPandasインストール情報を使用&lt;/a&gt;してPandasをインストールする方法を学びます。</target>
        </trans-unit>
        <trans-unit id="2ed6aac4fbb9a95f912d9c4a1bba39294044ad2e" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re reading this page, you probably want to help. This guide is meant to help you decide which kind of content you&amp;rsquo;ll write, as well as give you some tips and instructions for submitting it to the official NumPy documentation (that is, the documentation that ships with NumPy and lives on the &lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;official project pages&lt;/a&gt;). Keep in mind that if you don&amp;rsquo;t want to do this, writing a tutorial on your own blog, creating a YouTube video or answering questions on social media or Stack Overflow are also great contributions!</source>
          <target state="translated">あなたがこのページを読んでいるなら、あなたはおそらく助けたいと思うでしょう。このガイドは、作成するコンテンツの種類を決定するのに役立つだけでなく、公式のNumPyドキュメント（つまり、NumPyに付属し、&lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;公式プロジェクトに存在&lt;/a&gt;するドキュメント）に送信するためのヒントと手順を提供することを目的としています。ページ）。これを行いたくない場合は、自分のブログでチュートリアルを書いたり、YouTubeビデオを作成したり、ソーシャルメディアやStackOverflowで質問に答えたりすることも大きな貢献です。</target>
        </trans-unit>
        <trans-unit id="fc7594579a51a68345b4192c0906de63f2aaa750" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using the command line, you can read your saved CSV any time with a command such as:</source>
          <target state="translated">コマンドラインを使用している場合は、次のようなコマンドを使用して、保存したCSVをいつでも読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="bb1dc4c88210c13fc91fb612afbe4d0471d01d47" translate="yes" xml:space="preserve">
          <source>If your change introduces a deprecation, make sure to discuss this first on GitHub or the mailing list first. If agreement on the deprecation is reached, follow &lt;a href=&quot;http://www.numpy.org/neps/nep-0023-backwards-compatibility.html&quot;&gt;NEP 23 deprecation policy&lt;/a&gt; to add the deprecation.</source>
          <target state="translated">変更によって非推奨が導入された場合は、GitHubまたはメーリングリストで最初にこれについて話し合うようにしてください。非推奨について合意に達した場合は、&lt;a href=&quot;http://www.numpy.org/neps/nep-0023-backwards-compatibility.html&quot;&gt;NEP23の非推奨ポリシー&lt;/a&gt;に従って非推奨を追加します。</target>
        </trans-unit>
        <trans-unit id="383746919525c98ba38f05552e38f10fc7e17a76" translate="yes" xml:space="preserve">
          <source>If your changes involve modifications to the API or addition/modification of a function, you should</source>
          <target state="translated">API の変更や関数の追加/変更を伴う変更の場合は、以下のようにしてください。</target>
        </trans-unit>
        <trans-unit id="d57214d0288965780d58c7b4b54223afc06a658d" translate="yes" xml:space="preserve">
          <source>If your commit introduces a new feature or changes functionality, post on the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-devel&quot;&gt;mailing list&lt;/a&gt; to explain your changes. For bug fixes, documentation updates, etc., this is generally not necessary, though if you do not get any reaction, do feel free to ask for review.</source>
          <target state="translated">コミットによって新機能が導入されたり、機能が変更されたりした場合は、&lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-devel&quot;&gt;メーリングリスト&lt;/a&gt;に投稿して変更について説明してください。バグ修正やドキュメントの更新などの場合、これは通常は必要ありませんが、何の反応も得られない場合は、遠慮なくレビューを依頼してください。</target>
        </trans-unit>
        <trans-unit id="ceebca4c980fce897cd94c7ea4093efdb4e34dd2" translate="yes" xml:space="preserve">
          <source>If your goal is to print such values with a fixed number of decimals, it is preferable to use numpy&amp;rsquo;s float printing routines to limit the number of printed decimals:</source>
          <target state="translated">このような値を固定の小数で印刷することが目標である場合は、numpyのfloat印刷ルーチンを使用して、印刷される小数の数を制限することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="5e8a3ab9024a9447fbb66b46a34249a781d9bca6" translate="yes" xml:space="preserve">
          <source>If your report involves any members of the committee, or if they feel they have a conflict of interest in handling it, then they will recuse themselves from considering your report. Alternatively, if for any reason you feel uncomfortable making a report to the committee, then you can also contact:</source>
          <target state="translated">あなたの報告書に委員会の委員が関与している場合、あるいは委員会の委員が報告書の処理に利害の対立があると感じた場合、委員会の委員はあなたの報告書を検討することを控えることになります。また、何らかの理由で委員会に報告書を提出することに抵抗を感じる場合は、以下の連絡先に連絡することもできます。</target>
        </trans-unit>
        <trans-unit id="3b1e83353521c6fb2d9909d1a47041f20fbc218d" translate="yes" xml:space="preserve">
          <source>If, however, you decide to deviate from this signature and do something like this:</source>
          <target state="translated">しかし、この署名から逸脱して、こんなことをすることになったら</target>
        </trans-unit>
        <trans-unit id="c323f3cd6a35ba341fff7e94a4d83cd135d073a2" translate="yes" xml:space="preserve">
          <source>Ignoring extreme values</source>
          <target state="translated">極端な価値観を無視して</target>
        </trans-unit>
        <trans-unit id="d887ce439b6be40447269f7cc275bae88c7965c1" translate="yes" xml:space="preserve">
          <source>Illustration image: &lt;a href=&quot;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&quot;&gt;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&lt;/a&gt;</source>
          <target state="translated">イラスト画像：&lt;a href=&quot;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&quot;&gt;https&lt;/a&gt; : //en.wikipedia.org/wiki/File : Composite_trapezoidal_rule_illustration.png</target>
        </trans-unit>
        <trans-unit id="8dc5a9232d67823e896b05855151653c2378fa30" translate="yes" xml:space="preserve">
          <source>Illustration, using the fact that the eigenvalues of a diagonal matrix are its diagonal elements, that multiplying a matrix on the left by an orthogonal matrix, &lt;code&gt;Q&lt;/code&gt;, and on the right by &lt;code&gt;Q.T&lt;/code&gt; (the transpose of &lt;code&gt;Q&lt;/code&gt;), preserves the eigenvalues of the &amp;ldquo;middle&amp;rdquo; matrix. In other words, if &lt;code&gt;Q&lt;/code&gt; is orthogonal, then &lt;code&gt;Q * A * Q.T&lt;/code&gt; has the same eigenvalues as &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">対角行列の固有値が対角要素であるという事実を使用して、左側の行列に直交行列 &lt;code&gt;Q&lt;/code&gt; を乗算し、右側に &lt;code&gt;Q.T&lt;/code&gt; （ &lt;code&gt;Q&lt;/code&gt; の転置）を乗算すると、図の固有値が保持されます。ミドル」マトリックス。つまり、 &lt;code&gt;Q&lt;/code&gt; が直交である場合、 &lt;code&gt;Q * A * Q.T&lt;/code&gt; は &lt;code&gt;A&lt;/code&gt; と同じ固有値を持ちます。</target>
        </trans-unit>
        <trans-unit id="aa91fcf02d0f861f5dcc65de755f413adabac4c5" translate="yes" xml:space="preserve">
          <source>Illustration:</source>
          <target state="translated">Illustration:</target>
        </trans-unit>
        <trans-unit id="50e19fda0d5b4b74a4a1a1d584e56578693a4ea4" translate="yes" xml:space="preserve">
          <source>Image</source>
          <target state="translated">Image</target>
        </trans-unit>
        <trans-unit id="536fc5481730660eaf684050e171a85c03ce521a" translate="yes" xml:space="preserve">
          <source>Image &lt;a href=&quot;#r7aa6c77779c0-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; illustrates trapezoidal rule &amp;ndash; y-axis locations of points will be taken from &lt;code&gt;y&lt;/code&gt; array, by default x-axis distances between points will be 1.0, alternatively they can be provided with &lt;code&gt;x&lt;/code&gt; array or with &lt;code&gt;dx&lt;/code&gt; scalar. Return value will be equal to combined area under the red lines.</source>
          <target state="translated">画像&lt;a href=&quot;#r7aa6c77779c0-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;は台形の規則を示しています。ポイントのy軸の位置は &lt;code&gt;y&lt;/code&gt; 配列から取得されます。デフォルトでは、ポイント間のx軸の距離は1.0ですが、 &lt;code&gt;x&lt;/code&gt; 配列または &lt;code&gt;dx&lt;/code&gt; スカラーで提供することもできます。戻り値は、赤い線の下の合計面積に等しくなります。</target>
        </trans-unit>
        <trans-unit id="a9fdbeb05caca869c7ab036893a4d3951315842f" translate="yes" xml:space="preserve">
          <source>Image filter in Cython</source>
          <target state="translated">Cython の画像フィルタ</target>
        </trans-unit>
        <trans-unit id="9e3e609852befab966299ce3a62b4f677877a107" translate="yes" xml:space="preserve">
          <source>Images are allowed, but should not be central to the explanation; users viewing the docstring as text must be able to comprehend its meaning without resorting to an image viewer. These additional illustrations are included using:</source>
          <target state="translated">画像は許可されていますが、説明の中心になるべきではありません。これらの追加のイラストは、以下のように使用して含まれています。</target>
        </trans-unit>
        <trans-unit id="4796b475dca83b62f81a07c968464a3ec0ce36b3" translate="yes" xml:space="preserve">
          <source>Imagine a series of commits A, B, C, D&amp;hellip; Imagine that there are two branches, &lt;em&gt;topic&lt;/em&gt; and &lt;em&gt;master&lt;/em&gt;. You branched &lt;em&gt;topic&lt;/em&gt; off &lt;em&gt;master&lt;/em&gt; when &lt;em&gt;master&lt;/em&gt; was at commit &amp;lsquo;E&amp;rsquo;. The graph of the commits looks like this:</source>
          <target state="translated">一連のコミットA、B、C、Dを想像してみてください&amp;hellip;&lt;em&gt;トピック&lt;/em&gt;と&lt;em&gt;マスターの&lt;/em&gt;2つのブランチがあると想像してください。&lt;em&gt;マスター&lt;/em&gt;がコミット 'E'にあったときに、&lt;em&gt;トピック&lt;/em&gt;を&lt;em&gt;マスター&lt;/em&gt;から分岐しました。コミットのグラフは次のようになります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d1a70afdce8219e6a6ff23faf95244260258e23" translate="yes" xml:space="preserve">
          <source>Imagine an array of 32-bit integers (each 4 bytes):</source>
          <target state="translated">32ビット整数の配列を想像してみてください(各4バイト)。</target>
        </trans-unit>
        <trans-unit id="56024d919b5d6ee0185b1f966812231e966a9f22" translate="yes" xml:space="preserve">
          <source>Immediately disconnect the originator from all NumPy communication channels.</source>
          <target state="translated">発信者をすべてのNumPy通信チャネルから直ちに切断します。</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">実施内容</target>
        </trans-unit>
        <trans-unit id="c12c46e2305d0716b258ac51f2e79f55da8c1069" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;__array_function__&lt;/code&gt; indicate that they can handle the operation by returning any value other than &lt;code&gt;NotImplemented&lt;/code&gt;.</source>
          <target state="translated">実装 &lt;code&gt;__array_function__&lt;/code&gt; は、彼らが以外の値を返すことによって操作を処理できることを示している &lt;code&gt;NotImplemented&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="45682c285dcaa4b3e31e357f40fa088a415ce505" translate="yes" xml:space="preserve">
          <source>Implementing this formula is simple and straightforward in NumPy:</source>
          <target state="translated">この式の実装は、NumPyではシンプルで簡単です。</target>
        </trans-unit>
        <trans-unit id="0e028e89dfea3c1cba7d9fc7a23453fc7abac732" translate="yes" xml:space="preserve">
          <source>Implements exec_command function that is (almost) equivalent to commands.getstatusoutput function but on NT, DOS systems the returned status is actually correct (though, the returned status values may be different by a factor). In addition, exec_command takes keyword arguments for (re-)defining environment variables.</source>
          <target state="translated">commands.getstatusoutput関数と(ほぼ)同等ですが、NT,DOSシステムでは、返されるステータスは実際には正しいものになります(ただし、返されるステータスの値はファクターによって異なる場合があります)。さらに、exec_commandは環境変数を(再)定義するためのキーワード引数を取ります。</target>
        </trans-unit>
        <trans-unit id="b794a9ed38f8d441574ce1ea158c0a341f3db730" translate="yes" xml:space="preserve">
          <source>Implements the complex comparisons between two complex numbers (structures with a real and imag member) using NumPy&amp;rsquo;s definition of the ordering which is lexicographic: comparing the real parts first and then the complex parts if the real parts are equal.</source>
          <target state="translated">辞書式の順序付けのNumPyの定義を使用して、2つの複素数（実数とimagのメンバーを持つ構造体）の間の複雑な比較を実装します。</target>
        </trans-unit>
        <trans-unit id="8c1ede9f9fcf093439f0e008232b895dda53883b" translate="yes" xml:space="preserve">
          <source>Implements the rules for scalar coercion. Scalars are only silently coerced from thistype to neededtype if this function returns nonzero. If scalar is &lt;a href=&quot;#c.NPY_NOSCALAR&quot;&gt;&lt;code&gt;NPY_NOSCALAR&lt;/code&gt;&lt;/a&gt;, then this function is equivalent to &lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt;&lt;code&gt;PyArray_CanCastSafely&lt;/code&gt;&lt;/a&gt;. The rule is that scalars of the same KIND can be coerced into arrays of the same KIND. This rule means that high-precision scalars will never cause low-precision arrays of the same KIND to be upcast.</source>
          <target state="translated">スカラー強制のルールを実装します。この関数がゼロ以外を返す場合にのみ、スカラーはこのタイプから必要なタイプにサイレントに強制変換されます。スカラーが&lt;a href=&quot;#c.NPY_NOSCALAR&quot;&gt; &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; の&lt;/a&gt;場合、この関数は&lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt; &lt;code&gt;PyArray_CanCastSafely&lt;/code&gt; &lt;/a&gt;と同等です。ルールは、同じKINDのスカラーを同じKINDの配列に強制変換できるというものです。このルールは、高精度のスカラーによって同じ種類の低精度の配列がアップキャストされることは決してないことを意味します。</target>
        </trans-unit>
        <trans-unit id="22af89867a4595ad888fcb4ec7aff9a5775524c5" translate="yes" xml:space="preserve">
          <source>Implements the rules for scalar coercion. Scalars are only silently coerced from thistype to neededtype if this function returns nonzero. If scalar is &lt;code&gt;NPY_NOSCALAR&lt;/code&gt;, then this function is equivalent to &lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt;&lt;code&gt;PyArray_CanCastSafely&lt;/code&gt;&lt;/a&gt;. The rule is that scalars of the same KIND can be coerced into arrays of the same KIND. This rule means that high-precision scalars will never cause low-precision arrays of the same KIND to be upcast.</source>
          <target state="translated">スカラー強制のルールを実装します。この関数がゼロ以外の値を返す場合、スカラーは暗黙的にthistypeからrequiredtypeに強制的に変換されます。スカラーが &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; の場合、この関数は&lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt; &lt;code&gt;PyArray_CanCastSafely&lt;/code&gt; &lt;/a&gt;と同等です。ルールは、同じ種類のスカラーを同じ種類の配列に強制変換できることです。このルールは、高精度のスカラーが同じKINDの低精度の配列をアップキャストすることは決してないことを意味します。</target>
        </trans-unit>
        <trans-unit id="cc6b2c01f5b15596a7e379b52c69cde1905611b5" translate="yes" xml:space="preserve">
          <source>Implications for subclassing</source>
          <target state="translated">サブクラス化への影響</target>
        </trans-unit>
        <trans-unit id="9b1ecf27a94cea1bc5736c0891a645368078e452" translate="yes" xml:space="preserve">
          <source>Implicit rules are used to determine the type specification of a variable (from the first-letter of its name) if the variable is not defined using &lt;code&gt;&amp;lt;variable type declaration&amp;gt;&lt;/code&gt;. Default implicit rule is given by</source>
          <target state="translated">変数が &lt;code&gt;&amp;lt;variable type declaration&amp;gt;&lt;/code&gt; を使用して定義されていない場合、暗黙のルールを使用して（名前の最初の文字から）変数の型指定を決定します。デフォルトの暗黙のルールはによって与えられます</target>
        </trans-unit>
        <trans-unit id="0951af8ad6c339672abaff4e57cd5d78b54b3d59" translate="yes" xml:space="preserve">
          <source>Import conventions</source>
          <target state="translated">インポート規約</target>
        </trans-unit>
        <trans-unit id="361838ee748707501d1086cda1d546a0bca541ea" translate="yes" xml:space="preserve">
          <source>ImportError</source>
          <target state="translated">ImportError</target>
        </trans-unit>
        <trans-unit id="2fdd9172a8740a8589e6db75bd8b770e98070548" translate="yes" xml:space="preserve">
          <source>Importing and exporting a CSV</source>
          <target state="translated">CSVのインポートとエクスポート</target>
        </trans-unit>
        <trans-unit id="a0b02515f5c051785b53791b2ce9293238d373b1" translate="yes" xml:space="preserve">
          <source>Importing data with &lt;code&gt;genfromtxt&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;genfromtxt&lt;/code&gt; を使用したデータのインポート</target>
        </trans-unit>
        <trans-unit id="5ce37d23b2e6f8bbdca3d0d3d416305b155ec2af" translate="yes" xml:space="preserve">
          <source>Importing data with genfromtxt</source>
          <target state="translated">genfromtxtでのデータのインポート</target>
        </trans-unit>
        <trans-unit id="c27d990de6ba5889ef7140c6c7a668ba89dfd7cb" translate="yes" xml:space="preserve">
          <source>Importing the API</source>
          <target state="translated">APIのインポート</target>
        </trans-unit>
        <trans-unit id="dd37ac12c1ad8599b8ebf308693dc3e055ea4be3" translate="yes" xml:space="preserve">
          <source>Improve detection of CPU features</source>
          <target state="translated">CPUの特徴の検出を改善</target>
        </trans-unit>
        <trans-unit id="3cf92b1447d3f56d21aa04032c4a2bb6319ee3e3" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;numpy.pad&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.pad&lt;/code&gt; のパフォーマンスを向上させる</target>
        </trans-unit>
        <trans-unit id="fc1f2a7f430fee41352adede4b4563f47e652af5" translate="yes" xml:space="preserve">
          <source>Improved automated bin estimators for &lt;code&gt;histogram&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;histogram&lt;/code&gt; 自動ビン推定量の改善</target>
        </trans-unit>
        <trans-unit id="c1f0700651c0f4723ea34b9b380874940d8f5904" translate="yes" xml:space="preserve">
          <source>Improved conversion from ctypes objects</source>
          <target state="translated">ctypesオブジェクトからの変換を改善</target>
        </trans-unit>
        <trans-unit id="518dff1009456384a218feffc1efa6923feaa474" translate="yes" xml:space="preserve">
          <source>Improved handling of zero-width string/unicode dtypes</source>
          <target state="translated">ゼロ幅文字列/unicodeのdtypesの取り扱いを改善</target>
        </trans-unit>
        <trans-unit id="58ab9853fb47f5464aeb249a62f870635c06737e" translate="yes" xml:space="preserve">
          <source>Improved precision of &lt;code&gt;ndarray.mean&lt;/code&gt; for float16 arrays</source>
          <target state="translated">float16配列の &lt;code&gt;ndarray.mean&lt;/code&gt; の精度が向上しました</target>
        </trans-unit>
        <trans-unit id="38934ca4956698ef07754fc3267371731cc1f9a9" translate="yes" xml:space="preserve">
          <source>Improved set operations</source>
          <target state="translated">セット操作の改善</target>
        </trans-unit>
        <trans-unit id="df66ef4f9fec541e48971fe99984a92ee3d241bf" translate="yes" xml:space="preserve">
          <source>Improvements</source>
          <target state="translated">Improvements</target>
        </trans-unit>
        <trans-unit id="75cb8c222cfbf4c46e4378aa465749528ac0f696" translate="yes" xml:space="preserve">
          <source>Improvements to build warnings</source>
          <target state="translated">ビルド警告の改善</target>
        </trans-unit>
        <trans-unit id="21535b2ca395b919fe7ab1e068c3e3d0e600eb23" translate="yes" xml:space="preserve">
          <source>Improving the basic interface</source>
          <target state="translated">基本インターフェースの改善</target>
        </trans-unit>
        <trans-unit id="651ad1981d9513aaa48106696e9dc28fdbdbb95a" translate="yes" xml:space="preserve">
          <source>In &amp;lsquo;clip&amp;rsquo; mode, a negative index which would normally wrap will clip to 0 instead.</source>
          <target state="translated">「クリップ」モードでは、通常折り返される負のインデックスは代わりに0にクリップします。</target>
        </trans-unit>
        <trans-unit id="0a5b493d076f809b633ada78947b9be3536bf476" translate="yes" xml:space="preserve">
          <source>In 1.16 a number of functions have been introduced in the &lt;a href=&quot;#module-numpy.lib.recfunctions&quot;&gt;&lt;code&gt;numpy.lib.recfunctions&lt;/code&gt;&lt;/a&gt; module to help users account for this change. These are &lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#numpy.lib.recfunctions.structured_to_unstructured&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.structured_to_unstructured&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.lib.recfunctions.unstructured_to_structured&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.unstructured_to_structured&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.lib.recfunctions.apply_along_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.apply_along_fields&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.lib.recfunctions.assign_fields_by_name&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.assign_fields_by_name&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#numpy.lib.recfunctions.require_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.require_fields&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1.16では、ユーザーがこの変更を説明できるように、&lt;a href=&quot;#module-numpy.lib.recfunctions&quot;&gt; &lt;code&gt;numpy.lib.recfunctions&lt;/code&gt; &lt;/a&gt;モジュールにいくつかの関数が導入されました。これらは&lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt; &lt;/a&gt;です。&lt;a href=&quot;#numpy.lib.recfunctions.structured_to_unstructured&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.structured_to_unstructured&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#numpy.lib.recfunctions.unstructured_to_structured&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.unstructured_to_structured&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#numpy.lib.recfunctions.apply_along_fields&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.apply_along_fields&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#numpy.lib.recfunctions.assign_fields_by_name&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.assign_fields_by_name&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#numpy.lib.recfunctions.require_fields&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.require_fields&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2fa6844c3d81a6fe2067c8e0e928cef4f2f272dc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;range(6)&lt;/code&gt;, information on what kind of rounding is done in addition, and on how underflow is handled.</source>
          <target state="translated">&lt;code&gt;range(6)&lt;/code&gt; 、丸め処理の種類に関する情報を加えて行われ、アンダーフローの処理方法にされます。</target>
        </trans-unit>
        <trans-unit id="50fbd12243b4769e24084faa8adf2287f6b3d6cd" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;explicit mode&lt;/em&gt; the output can be directly controlled by specifying output subscript labels. This requires the identifier &amp;lsquo;-&amp;gt;&amp;rsquo; as well as the list of output subscript labels. This feature increases the flexibility of the function since summing can be disabled or forced when required. The call &lt;code&gt;np.einsum('i-&amp;gt;', a)&lt;/code&gt; is like &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;np.sum(a, axis=-1)&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; is like &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;np.diag(a)&lt;/code&gt;&lt;/a&gt;. The difference is that &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; does not allow broadcasting by default. Additionally &lt;code&gt;np.einsum('ij,jh-&amp;gt;ih', a, b)&lt;/code&gt; directly specifies the order of the output subscript labels and therefore returns matrix multiplication, unlike the example above in implicit mode.</source>
          <target state="translated">で&lt;em&gt;明示モード&lt;/em&gt;出力は、直接出力添字ラベルを指定することによって制御することができます。これには、識別子「-&amp;gt;」と出力添え字ラベルのリストが必要です。必要に応じて加算を無効にしたり強制したりできるため、この機能により関数の柔軟性が向上します。呼び出し &lt;code&gt;np.einsum('i-&amp;gt;', a)&lt;/code&gt; は&lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;np.sum(a, axis=-1)&lt;/code&gt; &lt;/a&gt;ようなもので、 &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; は&lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;np.diag(a)&lt;/code&gt; の&lt;/a&gt;ようなものです。違いは、&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;がデフォルトでブロードキャストを許可しないことです。さらに、 &lt;code&gt;np.einsum('ij,jh-&amp;gt;ih', a, b)&lt;/code&gt; は、出力の添え字ラベルの順序を直接指定するため、暗黙的なモードでの上記の例とは異なり、行列の乗算を返します。</target>
        </trans-unit>
        <trans-unit id="c0145016518b0031bebdd7367da2ce7b6495c4d5" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;explicit&lt;/em&gt; mode, &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; provides further flexibility to compute other array operations that might not be considered classical Einstein summation operations, by disabling, or forcing summation over specified subscript labels.</source>
          <target state="translated">&lt;em&gt;明示&lt;/em&gt;モード、&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; は&lt;/a&gt;無効、または指定された添字ラベル上和を強制することによって、古典的なアインシュタイン総和演算考慮されない可能性のある他の配列演算を計算するためのさらなる柔軟性を提供します。</target>
        </trans-unit>
        <trans-unit id="4c8b68052719d1c1d5215bfd711f82950ca7a1df" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;implicit mode&lt;/em&gt;, the chosen subscripts are important since the axes of the output are reordered alphabetically. This means that &lt;code&gt;np.einsum('ij', a)&lt;/code&gt; doesn&amp;rsquo;t affect a 2D array, while &lt;code&gt;np.einsum('ji', a)&lt;/code&gt; takes its transpose. Additionally, &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; returns a matrix multiplication, while, &lt;code&gt;np.einsum('ij,jh', a, b)&lt;/code&gt; returns the transpose of the multiplication since subscript &amp;lsquo;h&amp;rsquo; precedes subscript &amp;lsquo;i&amp;rsquo;.</source>
          <target state="translated">では&lt;em&gt;暗黙のモード&lt;/em&gt;出力の軸がアルファベット順に並べ替えされているので、選ばれた添字が重要です。つまり、 &lt;code&gt;np.einsum('ij', a)&lt;/code&gt; は2D配列に影響を与えませんが、 &lt;code&gt;np.einsum('ji', a)&lt;/code&gt; は転置を行います。さらに、 &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; は行列の乗算を返し、 &lt;code&gt;np.einsum('ij,jh', a, b)&lt;/code&gt; は、添字 'h'が添え字の前にあるため、乗算の転置を返します。 '私'。</target>
        </trans-unit>
        <trans-unit id="065543ba7b7c467e5ff1cf1108109daa4f6f9b2e" translate="yes" xml:space="preserve">
          <source>In C, there is no equivalent to the deprecation warnings that Python supports. One way to do deprecations is to flag them in the documentation and release notes, then remove or change the deprecated features in a future major version (NumPy 2.0 and beyond). Minor versions of NumPy should not have major C-API changes, however, that prevent code that worked on a previous minor release. For example, we will do our best to ensure that code that compiled and worked on NumPy 1.4 should continue to work on NumPy 1.7 (but perhaps with compiler warnings).</source>
          <target state="translated">C言語では、PythonがサポートしているDeprecationの警告に相当するものはありません。Deprecationを行う1つの方法は、ドキュメントやリリースノートでDeprecationにフラグを立て、将来のメジャーバージョン(NumPy 2.0以降)でDeprecatedの機能を削除したり変更したりすることです。しかし、NumPyのマイナーバージョンでは、以前のマイナーリリースで動作していたコードが動作しなくなるようなC-APIの大きな変更があってはなりません。例えば、NumPy 1.4でコンパイルして動作していたコードがNumPy 1.7でも動作することを保証するために最善を尽くします。</target>
        </trans-unit>
        <trans-unit id="a9ca8be4f66144d7c2dcc488bdd409f6a21dcaf9" translate="yes" xml:space="preserve">
          <source>In IPython it is also possible to run individual examples simply by copy-pasting them in doctest mode:</source>
          <target state="translated">IPythonでは、doctestモードでコピーペーストするだけで個々のサンプルを実行することも可能です。</target>
        </trans-unit>
        <trans-unit id="494eed34e26fa744c79b6950c743fa3931771a94" translate="yes" xml:space="preserve">
          <source>In MATLAB&amp;reg; the main tool available to you for customizing the environment is to modify the search path with the locations of your favorite functions. You can put such customizations into a startup script that MATLAB will run on startup.</source>
          <target state="translated">MATLAB&amp;reg;では、環境をカスタマイズするために使用できる主なツールは、お気に入りの関数の場所で検索パスを変更することです。このようなカスタマイズを、MATLABが起動時に実行する起動スクリプトに組み込むことができます。</target>
        </trans-unit>
        <trans-unit id="05b064c6c8d4ad79dd43510f89eb8bbc99cffd4b" translate="yes" xml:space="preserve">
          <source>In MATLAB&amp;reg;, arrays have pass-by-value semantics, with a lazy copy-on-write scheme to prevent actually creating copies until they are actually needed. Slice operations copy parts of the array.</source>
          <target state="translated">MATLAB&amp;reg;では、配列には値渡しのセマンティクスがあり、実際に必要になるまで実際にコピーが作成されないようにするための遅延コピーオンライトスキームがあります。スライス操作は、配列の一部をコピーします。</target>
        </trans-unit>
        <trans-unit id="35c279433c70eb2d4b30f568fbc349c5cc15292b" translate="yes" xml:space="preserve">
          <source>In MATLAB&amp;reg;, the basic data type is a multidimensional array of double precision floating point numbers. Most expressions take such arrays and return such arrays. Operations on the 2-D instances of these arrays are designed to act more or less like matrix operations in linear algebra.</source>
          <target state="translated">MATLAB&amp;reg;では、基本的なデータ型は倍精度浮動小数点数の多次元配列です。ほとんどの式はそのような配列を取り、そのような配列を返します。これらの配列の2次元インスタンスに対する演算は、線形代数の行列演算のように機能するように設計されています。</target>
        </trans-unit>
        <trans-unit id="a7fc4e4e9aaf59319f61cb1b2c8333ad9f8d065b" translate="yes" xml:space="preserve">
          <source>In NumPy 1.16, you need to set the environment variable &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=1&lt;/code&gt; before importing NumPy to use NumPy function overrides.</source>
          <target state="translated">NumPy 1.16では、NumPyをインポートしてNumPy関数のオーバーライドを使用する前に、環境変数 &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=1&lt;/code&gt; を設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="2d05b90f328ed41700350ed32107071a1f6f3fbc" translate="yes" xml:space="preserve">
          <source>In NumPy 1.17, the protocol is enabled by default, but can be disabled with &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=0&lt;/code&gt;.</source>
          <target state="translated">NumPy 1.17では、プロトコルはデフォルトで有効になっていますが、 &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=0&lt;/code&gt; で無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="1b4938fa72e1c7213ec03de65817f46747825eb5" translate="yes" xml:space="preserve">
          <source>In NumPy 1.6.0, a type promotion API was created to encapsulate the mechanism for determining output types. See the functions &lt;a href=&quot;generated/numpy.result_type#numpy.result_type&quot;&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt;&lt;code&gt;min_scalar_type&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">NumPy 1.6.0では、タイププロモーションAPIが作成され、出力タイプを決定するメカニズムがカプセル化されました。詳細については、&lt;a href=&quot;generated/numpy.result_type#numpy.result_type&quot;&gt; &lt;code&gt;result_type&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;generated/numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;generated/numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt; &lt;code&gt;min_scalar_type&lt;/code&gt; &lt;/a&gt;関数を参照してください。</target>
        </trans-unit>
        <trans-unit id="6817ac22605fc4c2d0f573a2b14f3a89cb1e8f22" translate="yes" xml:space="preserve">
          <source>In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal, but depending on this fact is deprecated. Writing to the resulting array continues to work as it used to, but a FutureWarning is issued.</source>
          <target state="translated">NumPy 1.7と1.8では、対角線のコピーを返し続けますが、この事実によっては非推奨となります。結果の配列への書き込みは以前と同じように動作しますが、FutureWarningが発行されます。</target>
        </trans-unit>
        <trans-unit id="117fbe2ef07a30dba33092bb43c1ec1f63fe2b7a" translate="yes" xml:space="preserve">
          <source>In NumPy 1.7 and later, this form allows &lt;code&gt;base_dtype&lt;/code&gt; to be interpreted as a structured dtype. Arrays created with this dtype will have underlying dtype &lt;code&gt;base_dtype&lt;/code&gt; but will have fields and flags taken from &lt;code&gt;new_dtype&lt;/code&gt;. This is useful for creating custom structured dtypes, as done in &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record arrays&lt;/a&gt;.</source>
          <target state="translated">NumPy 1.7以降では、この形式により &lt;code&gt;base_dtype&lt;/code&gt; を構造化dtypeとして解釈できます。このdtypeで作成された配列には、基本となるdtype &lt;code&gt;base_dtype&lt;/code&gt; がありますが、フィールドとフラグは &lt;code&gt;new_dtype&lt;/code&gt; から取得されます。これは、&lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;レコード配列で&lt;/a&gt;行われるように、カスタム構造化dtypeを作成するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="11387d0f86941bf54bf7c514e7a5b1f0fd171696" translate="yes" xml:space="preserve">
          <source>In NumPy arrays have pass-by-reference semantics. Slice operations are views into an array.</source>
          <target state="translated">NumPyでは,配列は参照渡しのセマンティクスを持っています.スライス操作は配列へのビューです。</target>
        </trans-unit>
        <trans-unit id="0193a49a749beca871335b39ba584f160aa0e7bd" translate="yes" xml:space="preserve">
          <source>In NumPy the basic type is a multidimensional &lt;code&gt;array&lt;/code&gt;. Operations on these arrays in all dimensionalities including 2D are element-wise operations. One needs to use specific functions for linear algebra (though for matrix multiplication, one can use the &lt;code&gt;@&lt;/code&gt; operator in python 3.5 and above).</source>
          <target state="translated">NumPyでは、基本的なタイプは多次元 &lt;code&gt;array&lt;/code&gt; です。2Dを含むすべての次元でのこれらの配列の操作は、要素ごとの操作です。線形代数には特定の関数を使用する必要があります（ただし、行列の乗算には、Python 3.5以降では &lt;code&gt;@&lt;/code&gt; 演算子を使用できます）。</target>
        </trans-unit>
        <trans-unit id="3b53f7eb15b7831e508349b1a60777dcdbd79a0e" translate="yes" xml:space="preserve">
          <source>In NumPy versions &amp;lt;= 1.9.0 Nan is returned for slices that are all-NaN or empty. In later versions zero is returned.</source>
          <target state="translated">NumPyバージョン1.9.0以下では、すべてNaNまたは空のスライスに対してNanが返されます。新しいバージョンではゼロが返されます。</target>
        </trans-unit>
        <trans-unit id="36d3e5a6749595663c6dacbe6e7c386adcf1a912" translate="yes" xml:space="preserve">
          <source>In NumPy, dimensions are called &lt;strong&gt;axes&lt;/strong&gt;. This means that if you have a 2D array that looks like this:</source>
          <target state="translated">NumPyでは、寸法は&lt;strong&gt;軸&lt;/strong&gt;と呼ばれます。これは、次のような2D配列がある場合を意味します。</target>
        </trans-unit>
        <trans-unit id="ed78411a5f19815c75577c53c9647b97f455af34" translate="yes" xml:space="preserve">
          <source>In NumPy, there are 24 new fundamental Python types to describe different types of scalars. These type descriptors are mostly based on the types available in the C language that CPython is written in, with several additional types compatible with Python&amp;rsquo;s types.</source>
          <target state="translated">NumPyには、さまざまなタイプのスカラーを記述するための24の新しい基本的なPythonタイプがあります。これらの型記述子は、CPythonが記述されているC言語で使用可能な型に基づいており、Pythonの型と互換性のあるいくつかの型が追加されています。</target>
        </trans-unit>
        <trans-unit id="0c775f1e9d60e517f99b3f4fb5fbef2cd48f1233" translate="yes" xml:space="preserve">
          <source>In NumPy, universal functions are instances of the &lt;code&gt;numpy.ufunc&lt;/code&gt; class. Many of the built-in functions are implemented in compiled C code. The basic ufuncs operate on scalars, but there is also a generalized kind for which the basic elements are sub-arrays (vectors, matrices, etc.), and broadcasting is done over other dimensions. One can also produce custom &lt;code&gt;ufunc&lt;/code&gt; instances using the &lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt;&lt;code&gt;frompyfunc&lt;/code&gt;&lt;/a&gt; factory function.</source>
          <target state="translated">NumPyでは、ユニバーサル関数は &lt;code&gt;numpy.ufunc&lt;/code&gt; クラスのインスタンスです。組み込み関数の多くは、コンパイルされたCコードで実装されます。基本的なufuncはスカラーで動作しますが、基本的な要素がサブ配列（ベクトル、行列など）である一般化された種類もあり、ブロードキャストは他の次元で行われます。&lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt; &lt;code&gt;frompyfunc&lt;/code&gt; &lt;/a&gt;ファクトリー関数を使用してカスタム &lt;code&gt;ufunc&lt;/code&gt; インスタンスを生成することもできます。</target>
        </trans-unit>
        <trans-unit id="774635ebbde845fd67b0f22449de4d887322609c" translate="yes" xml:space="preserve">
          <source>In Numeric, the ancestor of Numpy, broadcasting was implemented in several lines of code buried deep in ufuncobject.c. In NumPy, the notion of broadcasting has been abstracted so that it can be performed in multiple places. Broadcasting is handled by the function &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt;. This function requires a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; (or something that is a binary equivalent) to be passed in. The &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the broadcast number of dimensions and size in each dimension along with the total size of the broadcast result. It also keeps track of the number of arrays being broadcast and a pointer to an iterator for each of the arrays being broadcast.</source>
          <target state="translated">Numpyの祖先であるNumericでは、ufuncobject.cの奥深くに埋め込まれた数行のコードでブロードキャストが実装されました。 NumPyでは、ブロードキャストの概念が抽象化され、複数の場所で実行できるようになりました。ブロードキャストは、関数&lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt;によって処理されます。この関数では、&lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt;（またはバイナリの同等物）を渡す必要があります&lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt;は、ブロードキャスト結果の合計サイズとともに、ブロードキャストの次元数と各次元のサイズを追跡します。また、ブロードキャストされるアレイの数と、ブロードキャストされる各アレイのイテレータへのポインタも追跡します。</target>
        </trans-unit>
        <trans-unit id="8922bb1c700cbaf5cb6e489ccc3a2d78c8e39611" translate="yes" xml:space="preserve">
          <source>In Numeric, the ancestor of Numpy, broadcasting was implemented in several lines of code buried deep in ufuncobject.c. In NumPy, the notion of broadcasting has been abstracted so that it can be performed in multiple places. Broadcasting is handled by the function &lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt;. This function requires a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; (or something that is a binary equivalent) to be passed in. The &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the broadcast number of dimensions and size in each dimension along with the total size of the broadcast result. It also keeps track of the number of arrays being broadcast and a pointer to an iterator for each of the arrays being broadcast.</source>
          <target state="translated">Numpyの祖先であるNumericでは、放送はufuncobject.cの奥深くに埋め込まれた数行のコードで実装されていました。 NumPyでは、ブロードキャストの概念が抽象化されているため、複数の場所で実行できます。ブロードキャストは、関数&lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt;によって処理されます。この関数では、&lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt;（またはバイナリに相当するもの）を渡す必要があります&lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt;は、ブロードキャスト結果の合計サイズとともに、各次元のディメンションのブロードキャスト数とサイズを追跡します。また、ブロードキャストされている配列の数と、ブロードキャストされている各配列のイテレーターへのポインターを追跡します。</target>
        </trans-unit>
        <trans-unit id="22b48541001b861013a36c818439e26a1074dfe7" translate="yes" xml:space="preserve">
          <source>In Numpy 1.15, indexing an array with a multi-field index returned a copy of the result above, but with fields packed together in memory as if passed through &lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Numpy 1.15では、マルチフィールドインデックスを使用して配列にインデックスを&lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt; &lt;/a&gt;と、上記の結果のコピーが返されましたが、フィールドはnumpy.lib.recfunctions.repack_fieldsを通過したかのようにメモリにパックされています。</target>
        </trans-unit>
        <trans-unit id="1b22fd0d42a99bd19673ecd40259cf68612486f3" translate="yes" xml:space="preserve">
          <source>In Python 3.0, &lt;code&gt;//&lt;/code&gt; is the floor division operator and &lt;code&gt;/&lt;/code&gt; the true division operator. The &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; function is equivalent to true division in Python.</source>
          <target state="translated">Python 3.0では、 &lt;code&gt;//&lt;/code&gt; はフロア除算演算子および &lt;code&gt;/&lt;/code&gt; は真の除算演算子です。 &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; 関数はPythonで、真の除算に相当します。</target>
        </trans-unit>
        <trans-unit id="62fa547333a8d1dc9c0d4f4c02b89f627c6e6bc6" translate="yes" xml:space="preserve">
          <source>In Python, &lt;code&gt;//&lt;/code&gt; is the floor division operator and &lt;code&gt;/&lt;/code&gt; the true division operator. The &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; function is equivalent to true division in Python.</source>
          <target state="translated">Pythonでは、 &lt;code&gt;//&lt;/code&gt; は床除算演算子であり、 &lt;code&gt;/&lt;/code&gt; は真の除算演算子です。 &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; 関数はPythonで、真の除算に相当します。</target>
        </trans-unit>
        <trans-unit id="c2ae9f01dfbac70b64c2f45fa3c211ed297fec42" translate="yes" xml:space="preserve">
          <source>In Python, &lt;code&gt;arr[i, j]&lt;/code&gt; is exactly the same as &lt;code&gt;arr[(i, j)]&lt;/code&gt;&amp;mdash;so we can put &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; in a &lt;code&gt;tuple&lt;/code&gt; and then do the indexing with that.</source>
          <target state="translated">Pythonでは、 &lt;code&gt;arr[i, j]&lt;/code&gt; は &lt;code&gt;arr[(i, j)]&lt;/code&gt; ]とまったく同じです。したがって、 &lt;code&gt;i&lt;/code&gt; と &lt;code&gt;j&lt;/code&gt; を &lt;code&gt;tuple&lt;/code&gt; 、それを使用してインデックスを作成できます。</target>
        </trans-unit>
        <trans-unit id="060ed7eb6876dfc9a447b37757dfa0a45bd6069c" translate="yes" xml:space="preserve">
          <source>In Python, &lt;code&gt;x[(exp1, exp2, ..., expN)]&lt;/code&gt; is equivalent to &lt;code&gt;x[exp1, exp2, ..., expN]&lt;/code&gt;; the latter is just syntactic sugar for the former.</source>
          <target state="translated">Pythonでは、 &lt;code&gt;x[(exp1, exp2, ..., expN)]&lt;/code&gt; は &lt;code&gt;x[exp1, exp2, ..., expN]&lt;/code&gt; 。後者は前者の単なる構文糖です。</target>
        </trans-unit>
        <trans-unit id="667b044648896477b62af8727dbe5136eaaff74b" translate="yes" xml:space="preserve">
          <source>In Python:</source>
          <target state="translated">Pythonで。</target>
        </trans-unit>
        <trans-unit id="269b609eb84c47b360c36d70b62b2cd1bb86a5a5" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, each sub-type is called a &lt;code&gt;field&lt;/code&gt;. The &lt;code&gt;field&lt;/code&gt; has a name (a string), a type (any valid dtype), and an optional &lt;code&gt;title&lt;/code&gt;. See &lt;a href=&quot;reference/arrays.dtypes#arrays-dtypes&quot;&gt;Data type objects (dtype)&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#term-structured-data-type&quot;&gt;構造化データタイプ&lt;/a&gt;、各サブタイプと呼ばれる &lt;code&gt;field&lt;/code&gt; 。この &lt;code&gt;field&lt;/code&gt; は、名前（文字列）、タイプ（任意の有効なdtype）、およびオプションの &lt;code&gt;title&lt;/code&gt; ます。&lt;a href=&quot;reference/arrays.dtypes#arrays-dtypes&quot;&gt;データ型オブジェクト（dtype）を&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="2721403cc827c0b84ea65a28ef2dffa50ceb53e2" translate="yes" xml:space="preserve">
          <source>In a nutshell, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; runs two main loops. The first loop converts each line of the file in a sequence of strings. The second loop converts each string to the appropriate data type. This mechanism is slower than a single loop, but gives more flexibility. In particular, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; is able to take missing data into account, when other faster and simpler functions like &lt;a href=&quot;../reference/generated/numpy.loadtxt#numpy.loadtxt&quot;&gt;&lt;code&gt;loadtxt&lt;/code&gt;&lt;/a&gt; cannot.</source>
          <target state="translated">一言で言えば、&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;は2つの主要なループを実行します。最初のループは、ファイルの各行を文字列のシーケンスに変換します。2番目のループは、各文字列を適切なデータ型に変換します。このメカニズムは単一のループよりも低速ですが、柔軟性が高くなります。特に、&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;は、loadtxtのような他のより高速で単純な関数では&lt;a href=&quot;../reference/generated/numpy.loadtxt#numpy.loadtxt&quot;&gt; &lt;code&gt;loadtxt&lt;/code&gt; &lt;/a&gt;な場合に、欠落しているデータを考慮に入れることができます。</target>
        </trans-unit>
        <trans-unit id="0643c04fa6f173d8a3f9cc4f3ce84f7f07625090" translate="yes" xml:space="preserve">
          <source>In a study, testing for a specific alternative to the null hypothesis requires use of the Noncentral F distribution. We need to calculate the area in the tail of the distribution that exceeds the value of the F distribution for the null hypothesis. We&amp;rsquo;ll plot the two probability distributions for comparison.</source>
          <target state="translated">ある研究では、帰無仮説の特定の代替案をテストするには、非中心F分布を使用する必要があります。帰無仮説のF分布の値を超える分布の裾の領域を計算する必要があります。比較のために2つの確率分布をプロットします。</target>
        </trans-unit>
        <trans-unit id="4a555d5f0fdb6581c9697563824e3d61c23e3de4" translate="yes" xml:space="preserve">
          <source>In a two&amp;rsquo;s-complement system negative numbers are represented by the two&amp;rsquo;s complement of the absolute value. This is the most common method of representing signed integers on computers &lt;a href=&quot;#r962252997619-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. A N-bit two&amp;rsquo;s-complement system can represent every integer in the range</source>
          <target state="translated">2の補数システムでは、負の数は絶対値の2の補数で表されます。これは、コンピューターで符号付き整数を表す最も一般的な方法です&lt;a href=&quot;#r962252997619-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。Nビットの2の補数システムは、範囲内のすべての整数を表すことができます</target>
        </trans-unit>
        <trans-unit id="6ec708a7d401df6aafb3a323298b5e8a10e70e10" translate="yes" xml:space="preserve">
          <source>In addition &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; may be scalars, in which case:</source>
          <target state="translated">さらに &lt;code&gt;a&lt;/code&gt; または &lt;code&gt;b&lt;/code&gt; はスカラーである場合があります。その場合、</target>
        </trans-unit>
        <trans-unit id="85652b9aa303fc72ea7ade73af4f0dda2d5084d0" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;numpy.lib.io&lt;/code&gt; module provides several convenience functions derived from &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt;. These functions work the same way as the original, but they have different default values.</source>
          <target state="translated">&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;に加えて、 &lt;code&gt;numpy.lib.io&lt;/code&gt; モジュールは&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;から派生したいくつかの便利な関数を提供します。これらの関数は元の関数と同じように機能しますが、デフォルト値が異なります。</target>
        </trans-unit>
        <trans-unit id="3b2e8925339289db83edc8e4d5703c4e6627acaa" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;__array_wrap__&lt;/code&gt;, which is called on the way out of the ufunc, there is also an &lt;code&gt;__array_prepare__&lt;/code&gt; method which is called on the way into the ufunc, after the output arrays are created but before any computation has been performed. The default implementation does nothing but pass through the array. &lt;code&gt;__array_prepare__&lt;/code&gt; should not attempt to access the array data or resize the array, it is intended for setting the output array type, updating attributes and metadata, and performing any checks based on the input that may be desired before computation begins. Like &lt;code&gt;__array_wrap__&lt;/code&gt;, &lt;code&gt;__array_prepare__&lt;/code&gt; must return an ndarray or subclass thereof or raise an error.</source>
          <target state="translated">&lt;code&gt;__array_wrap__&lt;/code&gt; からの途中で呼び出される__array_wrap__に加えて、出力配列が作成された後、計算が実行される前に、ufuncに入る途中で呼び出される &lt;code&gt;__array_prepare__&lt;/code&gt; メソッドもあります。デフォルトの実装は、配列を通過するだけです。 &lt;code&gt;__array_prepare__&lt;/code&gt; は、配列データへのアクセスや配列のサイズ変更を試みるべきではありません。これは、出力配列タイプの設定、属性とメタデータの更新、および計算を開始する前に必要な入力に基づくチェックの実行を目的としています。 &lt;code&gt;__array_wrap__&lt;/code&gt; と同様に、 &lt;code&gt;__array_prepare__&lt;/code&gt; はndarrayまたはそのサブクラスを返すか、エラーを発生させる必要があります。</target>
        </trans-unit>
        <trans-unit id="0202a847e7f1c55dfe19c04653df757ab3188d4f" translate="yes" xml:space="preserve">
          <source>In addition to attributes that can be specified via keyword arguments to &lt;code&gt;Configuration&lt;/code&gt; constructor, &lt;code&gt;Configuration&lt;/code&gt; instance (let us denote as &lt;code&gt;config&lt;/code&gt;) has the following attributes that can be useful in writing setup scripts:</source>
          <target state="translated">&lt;code&gt;Configuration&lt;/code&gt; コンストラクターのキーワード引数を介して指定できる属性に加えて、 &lt;code&gt;Configuration&lt;/code&gt; インスタンス（ &lt;code&gt;config&lt;/code&gt; と表記）には、セットアップスクリプトの作成に役立つ次の属性があります。</target>
        </trans-unit>
        <trans-unit id="9205eb129a4d89ef4a9eb5c8d77614ae87b40a33" translate="yes" xml:space="preserve">
          <source>In addition to field names, fields may also have an associated &lt;a href=&quot;../glossary#term-title&quot;&gt;title&lt;/a&gt;, an alternate name, which is sometimes used as an additional description or alias for the field. The title may be used to index an array, just like a field name.</source>
          <target state="translated">フィールド名に加えて、フィールドには、フィールドの追加の説明またはエイリアスとして使用されることもある代替名である&lt;a href=&quot;../glossary#term-title&quot;&gt;タイトル&lt;/a&gt;が関連付けられている場合もあります。タイトルは、フィールド名と同じように、配列にインデックスを付けるために使用できます。</target>
        </trans-unit>
        <trans-unit id="1ee5bd9d7a0e50bb5b466ac30e311415eba3cdbd" translate="yes" xml:space="preserve">
          <source>In addition to field names, structured array fields may have an associated &lt;a href=&quot;user/basics.rec#titles&quot;&gt;title&lt;/a&gt; which is an alias to the name and is commonly used for plotting.</source>
          <target state="translated">フィールド名に加えて、構造化配列フィールドには、名前のエイリアスであり、プロットに一般的に使用される&lt;a href=&quot;user/basics.rec#titles&quot;&gt;タイトル&lt;/a&gt;が関連付けられている場合があります。</target>
        </trans-unit>
        <trans-unit id="5d8a9cc27249ffd4d0b1366a65411d876d2aa7c5" translate="yes" xml:space="preserve">
          <source>In addition to sort, which returns a sorted copy of an array, you can use:</source>
          <target state="translated">配列のソートされたコピーを返す sort の他にも、以下のような方法があります。</target>
        </trans-unit>
        <trans-unit id="29ec49c4a4c9a814e9bec074f3eabcbf7dea786f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; class, the &lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module defines several constants.</source>
          <target state="translated">加え&lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; の&lt;/a&gt;クラス、&lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; の&lt;/a&gt;モジュールは、いくつかの定数を定義します。</target>
        </trans-unit>
        <trans-unit id="7b236bba71a2e6d9bbb7e9f54e04010c73fd209b" translate="yes" xml:space="preserve">
          <source>In addition to the Python C-API, there is a full and rich C-API for NumPy allowing sophisticated manipulations on a C-level. However, for most applications, only a few API calls will typically be used. For example, if you need to just extract a pointer to memory along with some shape information to pass to another calculation routine, then you will use very different calls than if you are trying to create a new array-like type or add a new data type for ndarrays. This chapter documents the API calls and macros that are most commonly used.</source>
          <target state="translated">PythonのC-APIに加えて、NumPyのための完全でリッチなC-APIがあり、Cレベルでの高度な操作を可能にしています。しかし、ほとんどのアプリケーションでは、通常はいくつかのAPIコールしか使用されません。例えば、形状情報と一緒にメモリへのポインタを抽出して別の計算ルーチンに渡す必要がある場合、新しい配列のような型を作成したり、ndarrays用の新しいデータ型を追加したりする場合とは全く異なる呼び出しを使用することになります。この章では、最も一般的に使用されるAPIコールとマクロについて説明します。</target>
        </trans-unit>
        <trans-unit id="4c1e50029232768a84bc4dc52748436e5f14647c" translate="yes" xml:space="preserve">
          <source>In addition, F2PY introduces the following statements:</source>
          <target state="translated">また、F2PYでは、以下のような記述を紹介しています。</target>
        </trans-unit>
        <trans-unit id="50f7370be70d6fe0e899df628f5a07f23f4c4044" translate="yes" xml:space="preserve">
          <source>In addition, building the documentation requires the Sphinx extension &lt;code&gt;plot_directive&lt;/code&gt;, which is shipped with &lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt;. This Sphinx extension can be installed by installing Matplotlib. You will also need Python&amp;gt;=3.6.</source>
          <target state="translated">さらに、ドキュメントを作成するには、&lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlibに&lt;/a&gt;付属しているSphinx拡張機能 &lt;code&gt;plot_directive&lt;/code&gt; が必要です。このSphinx拡張機能は、Matplotlibをインストールすることでインストールできます。Python&amp;gt; = 3.6も必要になります。</target>
        </trans-unit>
        <trans-unit id="55ae7a3680f09394c2ee157c2db0452e71e75c1c" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;em&gt;data&lt;/em&gt; is non-NULL, then &lt;em&gt;strides&lt;/em&gt; can also be provided. If &lt;em&gt;strides&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the array strides are computed as C-style contiguous (default) or Fortran-style contiguous (&lt;em&gt;flags&lt;/em&gt; is nonzero for &lt;em&gt;data&lt;/em&gt; = &lt;code&gt;NULL&lt;/code&gt; or &lt;em&gt;flags&lt;/em&gt; &amp;amp; &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; is nonzero non-NULL &lt;em&gt;data&lt;/em&gt;). Any provided &lt;em&gt;dims&lt;/em&gt; and &lt;em&gt;strides&lt;/em&gt; are copied into newly allocated dimension and strides arrays for the new array object.</source>
          <target state="translated">さらに、&lt;em&gt;データ&lt;/em&gt;が非NULLの場合、&lt;em&gt;ストライド&lt;/em&gt;も提供できます。&lt;em&gt;ストライド&lt;/em&gt;が &lt;code&gt;NULL&lt;/code&gt; の場合、配列ストライドはCスタイルの連続（デフォルト）またはFortranスタイルの連続（&lt;em&gt;フラグ&lt;/em&gt;は&lt;em&gt;data&lt;/em&gt; = &lt;code&gt;NULL&lt;/code&gt; または&lt;em&gt;flags&lt;/em&gt;＆&lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;はゼロ以外の非NULL &lt;em&gt;データ&lt;/em&gt;）として計算されます。指定された&lt;em&gt;dims&lt;/em&gt;と&lt;em&gt;strides&lt;/em&gt;は、新しく割り当てられた次元にコピーされ、新しい配列オブジェクトの配列をストライドします。</target>
        </trans-unit>
        <trans-unit id="176596f4a4076180f296c1297a5a4088a9dfbec9" translate="yes" xml:space="preserve">
          <source>In all the cases but the first one, the output will be a 1D array with a structured dtype. This dtype has as many fields as items in the sequence. The field names are defined with the &lt;code&gt;names&lt;/code&gt; keyword.</source>
          <target state="translated">最初のケースを除くすべてのケースで、出力は構造化されたdtypeを持つ1D配列になります。このdtypeには、シーケンス内のアイテムと同じ数のフィールドがあります。フィールド名は &lt;code&gt;names&lt;/code&gt; キーワードで定義されます。</target>
        </trans-unit>
        <trans-unit id="9d28ba92ccb218b4c16f2db7077723c632363102" translate="yes" xml:space="preserve">
          <source>In all the examples so far, the elements of &lt;code&gt;a&lt;/code&gt; are provided by the iterator one at a time, because all the looping logic is internal to the iterator. While this is simple and convenient, it is not very efficient. A better approach is to move the one-dimensional innermost loop into your code, external to the iterator. This way, NumPy&amp;rsquo;s vectorized operations can be used on larger chunks of the elements being visited.</source>
          <target state="translated">これまでのすべての例では、すべてのループロジックが反復子の内部にあるため、 &lt;code&gt;a&lt;/code&gt; の要素は、一度に1つずつ反復子によって提供されます。これはシンプルで便利ですが、あまり効率的ではありません。より良いアプローチは、1次元の最も内側のループをイテレータの外部のコードに移動することです。このように、NumPyのベクトル化された操作は、アクセスされる要素のより大きなチャンクで使用できます。</target>
        </trans-unit>
        <trans-unit id="8389ffaf8c2e94e518381d310c79dd3ec1608070" translate="yes" xml:space="preserve">
          <source>In almost all cases &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; should be used instead of this function, as that will also return true for 0d arrays. This is how numpy overloads functions in the style of the &lt;code&gt;dx&lt;/code&gt; arguments to &lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt;&lt;code&gt;gradient&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;bins&lt;/code&gt; argument to &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;. Some key differences:</source>
          <target state="translated">ほとんどすべての場合、この関数の代わりに &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; を使用する必要があります。0d配列に対してもtrueが返されるためです。これは、のスタイルでどのようにnumpyのオーバーロード機能である &lt;code&gt;dx&lt;/code&gt; の引数&lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt; &lt;code&gt;gradient&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;bins&lt;/code&gt; の引数&lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt;。主な違い：</target>
        </trans-unit>
        <trans-unit id="09406f1061497030999a27047c2ac1dba1e1fddd" translate="yes" xml:space="preserve">
          <source>In both cases, set the &lt;code&gt;BUILD_COMMIT&lt;/code&gt; variable to the current release tag - e.g. &lt;code&gt;v1.19.0&lt;/code&gt;:</source>
          <target state="translated">どちらの場合も、 &lt;code&gt;BUILD_COMMIT&lt;/code&gt; 変数を現在のリリースタグに設定します-例： &lt;code&gt;v1.19.0&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3e277da1826bb81328288e7b48e1bc36cb3d9f8b" translate="yes" xml:space="preserve">
          <source>In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence are returned.</source>
          <target state="translated">最大値が複数回発生した場合、最初に発生した値に対応するインデックスが返されます。</target>
        </trans-unit>
        <trans-unit id="27e7146cba1027fb05de967eb96a8d0d4f3188c0" translate="yes" xml:space="preserve">
          <source>In case of multiple occurrences of the minimum values, the indices corresponding to the first occurrence are returned.</source>
          <target state="translated">最小値が複数回発生した場合、最初に発生した値に対応するインデックスが返されます。</target>
        </trans-unit>
        <trans-unit id="e0a4f4799ebef164e20467e93383e4d4633f2709" translate="yes" xml:space="preserve">
          <source>In case of severe and obvious breaches, e.g. personal threat or violent, sexist or racist language, we will immediately disconnect the originator from NumPy communication channels; please see the manual for details.</source>
          <target state="translated">個人的な脅迫や暴力的、性差別的、人種差別的な言葉など、重度で明らかな違反があった場合は、直ちに発信者をNumPyの通信チャネルから切断します。</target>
        </trans-unit>
        <trans-unit id="ae3b7f089e082a13dedd4fd05f16654244713a03" translate="yes" xml:space="preserve">
          <source>In cases not involving clear severe and obvious breaches of this code of conduct, the process for acting on any received code of conduct violation report will be:</source>
          <target state="translated">この行動規範の明らかな重大かつ明白な違反が含まれていない場合、受け取った行動規範違反報告書に対応するためのプロセスは、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="b7695ef954df8bd205d22a810fa2781d2a8a8dfc" translate="yes" xml:space="preserve">
          <source>In certain cases a failed installation or setup issue can cause you to see the following error message:</source>
          <target state="translated">インストールやセットアップに失敗した場合、以下のようなエラーメッセージが表示されることがあります。</target>
        </trans-unit>
        <trans-unit id="77e954d7daee979232398ad08ec5cc70a6a273a6" translate="yes" xml:space="preserve">
          <source>In code, arrays are often conveniently expressed as nested lists:</source>
          <target state="translated">コードでは、配列はしばしば入れ子になったリストとして便利に表現されます。</target>
        </trans-unit>
        <trans-unit id="c38db33a30014f091c11009d703bc2b8cd0eeadd" translate="yes" xml:space="preserve">
          <source>In complex cases, &lt;a href=&quot;../reference/generated/numpy.r_#numpy.r_&quot;&gt;&lt;code&gt;r_&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.c_#numpy.c_&quot;&gt;&lt;code&gt;c_&lt;/code&gt;&lt;/a&gt; are useful for creating arrays by stacking numbers along one axis. They allow the use of range literals (&amp;ldquo;:&amp;rdquo;)</source>
          <target state="translated">複雑なケースでは、&lt;a href=&quot;../reference/generated/numpy.r_#numpy.r_&quot;&gt; &lt;code&gt;r_&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../reference/generated/numpy.c_#numpy.c_&quot;&gt; &lt;code&gt;c_&lt;/code&gt; &lt;/a&gt;は、1つの軸に沿って数値を積み重ねて配列を作成するのに役立ちます。範囲リテラル（「：」）の使用を許可します</target>
        </trans-unit>
        <trans-unit id="15906ca68f2a7d7e2f6c027ec51f5d69dd3bed29" translate="yes" xml:space="preserve">
          <source>In copying mode, &amp;lsquo;copy&amp;rsquo; is specified as a per-operand flag. This is done to provide control in a per-operand fashion. Buffering mode is specified as an iterator flag.</source>
          <target state="translated">コピーモードでは、「copy」がオペランドごとのフラグとして指定されます。これは、オペランドごとに制御を提供するために行われます。バッファリングモードは、イテレータフラグとして指定されます。</target>
        </trans-unit>
        <trans-unit id="d217a2b2edd5733cc1a08fd36e52adeffd147a5f" translate="yes" xml:space="preserve">
          <source>In ctypes, the return-value of a function is set to be &amp;lsquo;int&amp;rsquo; by default. This behavior can be changed by setting the restype attribute of the function. Use None for the restype if the function has no return value (&amp;lsquo;void&amp;rsquo;):</source>
          <target state="translated">ctypesでは、関数の戻り値はデフォルトで「int」に設定されています。この動作は、関数のrestype属性を設定することで変更できます。関数に戻り値がない場合（「void」）、restypeにNoneを使用します。</target>
        </trans-unit>
        <trans-unit id="20601c7341dfe87ba7a45fcff8c92729cd267fbb" translate="yes" xml:space="preserve">
          <source>In depth explanation of concepts, best practices and techniques</source>
          <target state="translated">概念、ベストプラクティス、テクニックを徹底解説</target>
        </trans-unit>
        <trans-unit id="2913833b48b2894352d88e1660f11e59aa09d3c6" translate="yes" xml:space="preserve">
          <source>In detail</source>
          <target state="translated">詳細はこちら</target>
        </trans-unit>
        <trans-unit id="18557e967a450637ab72e77508fbfb08c6b092fc" translate="yes" xml:space="preserve">
          <source>In effect, the slice and index array operation are independent. The slice operation extracts columns with index 1 and 2, (i.e. the 2nd and 3rd columns), followed by the index array operation which extracts rows with index 0, 2 and 4 (i.e the first, third and fifth rows).</source>
          <target state="translated">実質的に、スライス操作とインデックス配列操作は独立しています。スライス操作はインデックス 1 と 2 の列(つまり 2 番目と 3 番目の列)を抽出し、続いてインデックス配列操作はインデックス 0,2,4 の行(つまり 1 番目、3 番目、5 番目の行)を抽出します。</target>
        </trans-unit>
        <trans-unit id="0401f70e9e9ccb692db031dd68efec8a8e548588" translate="yes" xml:space="preserve">
          <source>In every case, the &amp;lsquo;descr&amp;rsquo; key is optional, but of course provides more information which may be important for various applications:</source>
          <target state="translated">いずれの場合も、「descr」キーはオプションですが、もちろん、さまざまなアプリケーションにとって重要となる可能性がある詳細情報を提供します。</target>
        </trans-unit>
        <trans-unit id="ed0824a3a5c26008c8df28fe72abd00f4b7f2a94" translate="yes" xml:space="preserve">
          <source>In every case, the moderator should make a reasonable effort to contact the originator, and tell them specifically how their language or actions qualify as a &amp;ldquo;clear and severe breach&amp;rdquo;. The moderator should also say that, if the originator believes this is unfair or they want to be reconnected to NumPy, they have the right to ask for a review, as below, by the Code of Conduct Committee. The moderator should copy this explanation to the Code of Conduct Committee.</source>
          <target state="translated">いずれの場合も、モデレーターは発信者に連絡するために合理的な努力を払い、彼らの言葉や行動が「明確で重大な違反」としてどのように適格であるかを具体的に伝える必要があります。モデレーターはまた、オリジネーターがこれが不公平であると信じている場合、またはNumPyに再接続したい場合は、以下のように行動規範委員会によるレビューを求める権利があると言う必要があります。モデレーターは、この説明を行動規範委員会にコピーする必要があります。</target>
        </trans-unit>
        <trans-unit id="7eac15d5d1d96d05ac021a41eb29548e9ee61a69" translate="yes" xml:space="preserve">
          <source>In fact, why don&amp;rsquo;t we try that?</source>
          <target state="translated">実は、やってみませんか？</target>
        </trans-unit>
        <trans-unit id="a50f2ab9bd768752351c518eb56b5f190e77022a" translate="yes" xml:space="preserve">
          <source>In general how to set and check your environment variables depends on your system. If you can open a correct python shell, you can also run the following in python:</source>
          <target state="translated">一般的に環境変数をどのように設定し、チェックするかはシステムに依存します。正しいpythonシェルを開くことができれば、pythonで以下のように実行することもできます。</target>
        </trans-unit>
        <trans-unit id="51a2782158f2135b3873b2bc91584160c3224ec1" translate="yes" xml:space="preserve">
          <source>In general if an index includes a Boolean array, the result will be identical to inserting &lt;code&gt;obj.nonzero()&lt;/code&gt; into the same position and using the integer array indexing mechanism described above. &lt;code&gt;x[ind_1, boolean_array, ind_2]&lt;/code&gt; is equivalent to &lt;code&gt;x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]&lt;/code&gt;.</source>
          <target state="translated">一般に、インデックスにブール配列が含まれている場合、結果は &lt;code&gt;obj.nonzero()&lt;/code&gt; を同じ位置に挿入し、上記の整数配列インデックスメカニズムを使用した場合と同じになります。 &lt;code&gt;x[ind_1, boolean_array, ind_2]&lt;/code&gt; は &lt;code&gt;x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a0426d4d5e9174343610861881dfacd8c07a4e5a" translate="yes" xml:space="preserve">
          <source>In general, a scalar argument of a F2PY generated wrapper function can be an ordinary Python scalar (integer, float, complex number) as well as an arbitrary sequence object (list, tuple, array, string) of scalars. In the latter case, the first element of the sequence object is passed to Fortran routine as a scalar argument.</source>
          <target state="translated">一般的に、F2PYで生成されたラッパー関数のスカラー引数は、通常のPythonスカラー(整数、浮動小数点、複素数)だけでなく、スカラーの任意のシーケンスオブジェクト(リスト、タプル、配列、文字列)を指定することができます。後者の場合、シーケンスオブジェクトの最初の要素はスカラー引数としてFortranルーチンに渡されます。</target>
        </trans-unit>
        <trans-unit id="41b09ab4340a010ae2242f6c23854be608350193" translate="yes" xml:space="preserve">
          <source>In general, array arguments of F2PY generated wrapper functions accept arbitrary sequences that can be transformed to NumPy array objects. An exception is &lt;code&gt;intent(inout)&lt;/code&gt; array arguments that always must be proper-contiguous and have proper type, otherwise an exception is raised. Another exception is &lt;code&gt;intent(inplace)&lt;/code&gt; array arguments that attributes will be changed &lt;em&gt;in situ&lt;/em&gt; if the argument has different type than expected (see &lt;code&gt;intent(inplace)&lt;/code&gt; attribute for more information).</source>
          <target state="translated">一般に、F2PYで生成されたラッパー関数の配列引数は、NumPy配列オブジェクトに変換できる任意のシーケンスを受け入れます。例外は &lt;code&gt;intent(inout)&lt;/code&gt; 配列引数であり、常に適切に連続し、適切な型である必要があります。そうでない場合、例外が発生します。もう1つの例外は、 &lt;code&gt;intent(inplace)&lt;/code&gt; 配列引数です。引数の型が予想と異なる場合、属性は&lt;em&gt;その場&lt;/em&gt;で変更さ&lt;em&gt;れ&lt;/em&gt;ます（詳細については、 &lt;code&gt;intent(inplace)&lt;/code&gt; 属性を参照してください）。</target>
        </trans-unit>
        <trans-unit id="ce9f087f4c4d9805ec9d46a8db9fd36d60eeb431" translate="yes" xml:space="preserve">
          <source>In general, for &lt;code&gt;values&lt;/code&gt;</source>
          <target state="translated">一般的に、 &lt;code&gt;values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4732749a65786e199f581dd65439c32d67356e7" translate="yes" xml:space="preserve">
          <source>In general, for arrays with more than two dimensions, &lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt; stacks along their second axes, &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt; stacks along their first axes, and &lt;a href=&quot;../reference/generated/numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt; allows for an optional arguments giving the number of the axis along which the concatenation should happen.</source>
          <target state="translated">一般に、3次元以上の配列の場合、&lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt;は2番目の軸に沿ってスタックし、&lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt; &lt;code&gt;vstack&lt;/code&gt; &lt;/a&gt;は最初の軸に沿ってスタックし、&lt;a href=&quot;../reference/generated/numpy.concatenate#numpy.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt;により、連結が発生する軸の番号を指定するオプションの引数を使用できます。</target>
        </trans-unit>
        <trans-unit id="31150963fe6ef250ba4e833d06b222cca1c2cb70" translate="yes" xml:space="preserve">
          <source>In general, if a NumPy array is proper-contiguous and has a proper type then it is directly passed to wrapped Fortran/C function. Otherwise, an element-wise copy of an input array is made and the copy, being proper-contiguous and with proper type, is used as an array argument.</source>
          <target state="translated">一般的に,NumPyの配列が適切な連続性を持ち,適切な型を持つ場合は,ラップされたFortran/C関数に直接渡されます.そうでなければ,入力配列の要素ごとのコピーが作成され,そのコピーは,適切な連続性を持ち,適切な型を持つものであれば,配列の引数として利用されます.</target>
        </trans-unit>
        <trans-unit id="13ea723c2a24ed6ef1771c5f258ea31816238b49" translate="yes" xml:space="preserve">
          <source>In general, if the array owns its own memory, as for &lt;code&gt;arr&lt;/code&gt; in this case, then &lt;code&gt;arr.base&lt;/code&gt; will be None - there are some exceptions to this - see the numpy book for more details.</source>
          <target state="translated">一般に、配列が独自のメモリを所有している場合、この場合の &lt;code&gt;arr&lt;/code&gt; の場合、 &lt;code&gt;arr.base&lt;/code&gt; はNoneになります（これにはいくつかの例外があります）。詳細については、numpyブックを参照してください。</target>
        </trans-unit>
        <trans-unit id="5abc873332e6b6be31064612f2de6812b8a80d3b" translate="yes" xml:space="preserve">
          <source>In general, it is not necessary to list class methods. Those that are not part of the public API have names that start with an underscore. In some cases, however, a class may have a great many methods, of which only a few are relevant (e.g., subclasses of ndarray). Then, it becomes useful to have an additional &lt;strong&gt;Methods&lt;/strong&gt; section:</source>
          <target state="translated">一般に、クラスメソッドをリストする必要はありません。パブリックAPIの一部ではないものには、アンダースコアで始まる名前が付いています。ただし、場合によっては、クラスに非常に多くのメソッドがあり、そのうちのいくつかだけが関連します（たとえば、ndarrayのサブクラス）。次に、追加の&lt;strong&gt;メソッド&lt;/strong&gt;セクションがあると便利になります。</target>
        </trans-unit>
        <trans-unit id="fcbe439e71ce76a6bc1cdecd65ffad854f695844" translate="yes" xml:space="preserve">
          <source>In general, numerical data arranged in an array-like structure in Python can be converted to arrays through the use of the array() function. The most obvious examples are lists and tuples. See the documentation for array() for details for its use. Some objects may support the array-protocol and allow conversion to arrays this way. A simple way to find out if the object can be converted to a numpy array using array() is simply to try it interactively and see if it works! (The Python Way).</source>
          <target state="translated">一般的に、Pythonで配列のような構造になっている数値データは、array()関数を使うことで配列に変換することができます。最もわかりやすい例はリストとタプルです。使い方の詳細は array()のドキュメントを参照してください。いくつかのオブジェクトは配列プロトコルをサポートしており、この方法で配列への変換を許可しているかもしれません。オブジェクトが array()を使って numpy 配列に変換できるかどうかを調べる簡単な方法は、単純に対話的に試してみて動作するかどうかを確認することです! (The Python Way)。</target>
        </trans-unit>
        <trans-unit id="2636b2d2555459756347b2bec78d067967d80c45" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one C-series by another results in quotient and remainder terms that are not in the Chebyshev polynomial basis set. Thus, to express these results as C-series, it is typically necessary to &amp;ldquo;reproject&amp;rdquo; the results onto said basis set, which typically produces &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">一般に、C系列を（多項式で）除算すると、Chebyshev多項式基底関数セットにはない商項と剰余項が生成されます。したがって、これらの結果をCシリーズとして表現するには、通常、結果を前記基底セットに「再投影」する必要があります。これにより、通常、「直感的でない」（ただし正しい）結果が生成されます。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="e3455fcce926f7a356d4db4cbb1cca4337cab9da" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Hermite series by another results in quotient and remainder terms that are not in the Hermite polynomial basis set. Thus, to express these results as a Hermite series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Hermite basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">一般に、あるエルミート級数を別のエルミート級数で（多項式）除算すると、エルミート多項式基底セットにない商項と剰余項が生成されます。したがって、これらの結果をHermiteシリーズとして表現するには、結果をHermite基底関数セットに「再投影」する必要があります。これにより、「直感的でない」（しかし正しい）結果が生成される可能性があります。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="efbd236c04665a122a8e3491beed41d349724880" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Laguerre series by another results in quotient and remainder terms that are not in the Laguerre polynomial basis set. Thus, to express these results as a Laguerre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Laguerre basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">一般に、あるラゲール級数を別のラゲール級数で除算すると、ラゲール多項式基底関数セットにはない商項と剰余項が生成されます。したがって、これらの結果をラゲールシリーズとして表すには、結果をラゲール基底関数セットに「再投影」する必要があります。これにより、「直感的でない」（しかし正しい）結果が生成される場合があります。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="3e8f9ae8eb5287a2e2ca75de1027864d1ea7dce3" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Legendre series by another results in quotient and remainder terms that are not in the Legendre polynomial basis set. Thus, to express these results as a Legendre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Legendre basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">一般に、あるルジャンドル級数を別のルジャンドル級数で（多項式）除算すると、ルジャンドル多項式基底関数セットにない商項と剰余項が生成されます。したがって、これらの結果をルジャンドル級数として表現するには、結果をルジャンドル基底関数に「再投影」する必要があります。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="747e8b05b6e447bd7c26bc6951f1c707ad59f09d" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Chebyshev polynomial basis set. Thus, to express the product as a C-series, it is typically necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which typically produces &amp;ldquo;unintuitive live&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">一般に、2つのC系列の（多項式）積は、チェビシェフ多項式基底関数セットにない条件で結果として生成されます。したがって、製品をCシリーズとして表現するには、通常、製品を上記の基底セットに「再投影」する必要があります。これにより、通常、「直感的でない」ライブ（ただし正しい）結果が生成されます。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="140624c01263c11121eb8733a7573189c8b35148" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Hermite polynomial basis set. Thus, to express the product as a Hermite series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">一般に、2つのCシリーズの（多項式）積は、エルミート多項式基底関数セットにない項で結果として生成されます。したがって、製品をHermiteシリーズとして表現するには、製品を前述の基底関数セットに「再投影」する必要があります。これにより、「直感的でない」（しかし正しい）結果が生成される可能性があります。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="4be0c1b381e26e882c60023195f1e89d336414ac" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Laguerre polynomial basis set. Thus, to express the product as a Laguerre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">一般的に、2つのCシリーズの（多項式）積は、ラゲール多項式基底関数セットにない項で結果を出します。したがって、製品をラゲールシリーズとして表現するには、製品を上記のベーシスセットに「再投影」する必要があります。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="54659a570a760a1d9fe356eba1a0141427eabe1f" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Legendre polynomial basis set. Thus, to express the product as a Legendre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">一般に、2つのCシリーズの（多項式）積は、ルジャンドル多項式基底関数セットにない条件で結果として生成されます。したがって、製品をルジャンドルシリーズとして表現するには、製品を上記のベーシスセットに「再投影」する必要があります。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="afe18211391947a00635543978b5840ef054bbac" translate="yes" xml:space="preserve">
          <source>In general, the contents of signature files is case-sensitive. When scanning Fortran codes and writing a signature file, F2PY lowers all cases automatically except in multiline blocks or when &lt;code&gt;--no-lower&lt;/code&gt; option is used.</source>
          <target state="translated">一般に、署名ファイルの内容では大文字と小文字が区別されます。Fortranコードをスキャンして署名ファイルを書き込む場合、F2PYは、複数行ブロックの場合、または &lt;code&gt;--no-lower&lt;/code&gt; オプションが使用されている場合を除いて、すべてのケースを自動的に下げます。</target>
        </trans-unit>
        <trans-unit id="de938489906c2e0d2c954a8201ef415c1aa719ca" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a C-series needs to be &amp;ldquo;reprojected&amp;rdquo; onto the C-series basis set. Thus, typically, the result of this function is &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">一般に、Cシリーズを区別した結果は、Cシリーズの基底セットに「再投影」する必要があります。したがって、通常、この関数の結果は正しいとはいえ、「直感的ではありません」。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="dc47191395ffa64cfa2441fe3b165eeaca46d090" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Hermite series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">一般に、エルミートシリーズを微分した結果は、べき級数での同じ演算に似ていません。したがって、この関数の結果は、正しいとはいえ、「直感的でない」ことがあります。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="c6b49ce2210116245bad6e5bb6d187bba65b38de" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Laguerre series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">一般に、ラゲール級数を微分した結果は、べき級数での同じ演算に似ていません。したがって、この関数の結果は、正しいとはいえ、「直感的でない」ことがあります。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="68d490300c846fea9862fc337043383e53cf549a" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Legendre series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">一般に、ルジャンドル系列を微分した結果は、べき級数での同じ演算に似ていません。したがって、この関数の結果は、正しいとはいえ、「直感的でない」ことがあります。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="ebd1b8db4b2a00ae669c478fea3d4050ecbe0184" translate="yes" xml:space="preserve">
          <source>In general, the shape of the resultant array will be the concatenation of the shape of the index array (or the shape that all the index arrays were broadcast to) with the shape of any unused dimensions (those not indexed) in the array being indexed.</source>
          <target state="translated">一般的に,結果として得られる配列の形状は,インデックス配列の形状(または,すべてのインデックス配列がブロードキャストされた形状)と,インデックス化される配列内の未使用の次元(インデックス化されていない次元)の形状を連結したものになります.</target>
        </trans-unit>
        <trans-unit id="f5de4ef25adb6cfc3610a2fc23a9d5023b6dda95" translate="yes" xml:space="preserve">
          <source>In general, when the boolean array has fewer dimensions than the array being indexed, this is equivalent to y[b, &amp;hellip;], which means y is indexed by b followed by as many : as are needed to fill out the rank of y. Thus the shape of the result is one dimension containing the number of True elements of the boolean array, followed by the remaining dimensions of the array being indexed.</source>
          <target state="translated">一般に、ブール配列の次元がインデックス付けされる配列よりも少ない場合、これはy [b、&amp;hellip;]と同等です。つまり、yはbの後に、yのランクを入力するために必要な数の：が続くインデックスになります。したがって、結果の形状は、ブール配列のTrue要素の数を含む1つの次元であり、その後にインデックスが付けられる配列の残りの次元が続きます。</target>
        </trans-unit>
        <trans-unit id="a094c205647147c910d02f3a8f4ccd59ee07b5bd" translate="yes" xml:space="preserve">
          <source>In general, you should target these typemap signatures specifically where you want them, and then clear them after you are done.</source>
          <target state="translated">一般的には、これらのタイプマップ署名は必要な場所にターゲットを絞って、それが終わったらクリアしてください。</target>
        </trans-unit>
        <trans-unit id="dd3e08bc1a57887f18c581f1dbde91b2bd716911" translate="yes" xml:space="preserve">
          <source>In higher dimensions, FFTs are used, e.g., for image analysis and filtering. The computational efficiency of the FFT means that it can also be a faster way to compute large convolutions, using the property that a convolution in the time domain is equivalent to a point-by-point multiplication in the frequency domain.</source>
          <target state="translated">高次元では,画像解析やフィルタリングなどにFFTが使用されます.FFTの計算効率は、時間領域での畳み込みが周波数領域でのポイントバイポイントの乗算と等価であるという特性を利用して、大規模な畳み込みを高速に計算できることを意味します。</target>
        </trans-unit>
        <trans-unit id="b07ddb1ceb7095c96bdb1f519b0d36703eda5462" translate="yes" xml:space="preserve">
          <source>In interactions between &lt;code&gt;ArrayLike&lt;/code&gt; objects and numbers or numpy arrays, the result is always another &lt;code&gt;ArrayLike&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ArrayLike&lt;/code&gt; オブジェクトと数値またはnumpy配列の間の相互作用では、結果は常に別の &lt;code&gt;ArrayLike&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="859968bca8846c38eabf846201d96ee61f1cb6f0" translate="yes" xml:space="preserve">
          <source>In linear space, the sequence starts at &lt;code&gt;base ** start&lt;/code&gt; (&lt;code&gt;base&lt;/code&gt; to the power of &lt;code&gt;start&lt;/code&gt;) and ends with &lt;code&gt;base ** stop&lt;/code&gt; (see &lt;code&gt;endpoint&lt;/code&gt; below).</source>
          <target state="translated">線形空間において、該シーケンスが開始 &lt;code&gt;base ** start&lt;/code&gt; （ &lt;code&gt;base&lt;/code&gt; のパワーに &lt;code&gt;start&lt;/code&gt; ）で終わる &lt;code&gt;base ** stop&lt;/code&gt; （参照 &lt;code&gt;endpoint&lt;/code&gt; 以下）を。</target>
        </trans-unit>
        <trans-unit id="e8987c188d2dc12518e96e9c96bc6fb94bc0c364" translate="yes" xml:space="preserve">
          <source>In many circumstances, datasets can be incomplete or tainted by the presence of invalid data. For example, a sensor may have failed to record a data, or recorded an invalid value. The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module provides a convenient way to address this issue, by introducing masked arrays.</source>
          <target state="translated">多くの状況で、無効なデータの存在によってデータセットが不完全になったり汚染されたりする可能性があります。たとえば、センサーがデータの記録に失敗したか、無効な値を記録した可能性があります。&lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; の&lt;/a&gt;モジュールは、マスクされた配列を導入することで、この問題に対処するための便利な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="af19adb5953933b119cf6e38053a7bd63ddf0076" translate="yes" xml:space="preserve">
          <source>In memory overlap checks, assume that operands with &lt;code&gt;NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE&lt;/code&gt; enabled are accessed only in the iterator order.</source>
          <target state="translated">メモリのオーバーラップチェックでは、 &lt;code&gt;NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE&lt;/code&gt; が有効になっているオペランドは、イテレータの順序でのみアクセスされると想定しています。</target>
        </trans-unit>
        <trans-unit id="bd53b438575f194778c1656e57b318d6b487ca6a" translate="yes" xml:space="preserve">
          <source>In more detail</source>
          <target state="translated">より詳細には</target>
        </trans-unit>
        <trans-unit id="f9e0501d6a0c7c31ee0e8c5ea3ca4747d4c70398" translate="yes" xml:space="preserve">
          <source>In most cases &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; should be used instead of this function, as that will also return true for 0d arrays. This is how numpy overloads functions in the style of the &lt;code&gt;dx&lt;/code&gt; arguments to &lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt;&lt;code&gt;gradient&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;bins&lt;/code&gt; argument to &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;. Some key differences:</source>
          <target state="translated">ほとんどの場合、この関数の代わりに &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; を使用する必要があります。これは、0d配列に対してもtrueを返すためです。これは、のスタイルでどのようにnumpyのオーバーロード機能である &lt;code&gt;dx&lt;/code&gt; の引数&lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt; &lt;code&gt;gradient&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;bins&lt;/code&gt; の引数&lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt;。いくつかの重要な違い：</target>
        </trans-unit>
        <trans-unit id="a5c743fe265d56156ca24d5e10903518aede0334" translate="yes" xml:space="preserve">
          <source>In most use cases the best way to install NumPy on your system is by using a pre-built package for your operating system. Please see &lt;a href=&quot;https://scipy.org/install.html&quot;&gt;https://scipy.org/install.html&lt;/a&gt; for links to available options.</source>
          <target state="translated">ほとんどのユースケースでは、システムにNumPyをインストールする最良の方法は、オペレーティングシステム用にビルド済みのパッケージを使用することです。利用可能なオプションへのリンクについては、&lt;a href=&quot;https://scipy.org/install.html&quot;&gt;https：//scipy.org/install.html&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="763b6e76c1532989efe227d788422ad02bd06f94" translate="yes" xml:space="preserve">
          <source>In normal buffering, the size of each inner loop is equal to the buffer size, or possibly larger if &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt; is specified. If &lt;a href=&quot;#c.NPY_ITER_REDUCE_OK&quot;&gt;&lt;code&gt;NPY_ITER_REDUCE_OK&lt;/code&gt;&lt;/a&gt; is enabled and a reduction occurs, the inner loops may become smaller depending on the structure of the reduction.</source>
          <target state="translated">通常のバッファリングでは、各内部ループのサイズはバッファサイズと同じか、&lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt;が指定されている場合はさらに大きくなります。場合&lt;a href=&quot;#c.NPY_ITER_REDUCE_OK&quot;&gt; &lt;code&gt;NPY_ITER_REDUCE_OK&lt;/code&gt; が&lt;/a&gt;有効になっており、還元が生じ、内部ループは還元の構造に応じて小さくなることがあります。</target>
        </trans-unit>
        <trans-unit id="2c60bcd4aa111fe243ec4d9e38a39cdb9410fc32" translate="yes" xml:space="preserve">
          <source>In numpy versions &amp;gt;= 1.7.0 the &lt;code&gt;basis&lt;/code&gt; and &lt;code&gt;cast&lt;/code&gt; class methods are also available. The cast method works like the convert method while the basis method returns the basis polynomial of given degree:</source>
          <target state="translated">numpyバージョン&amp;gt; = 1.7.0では、 &lt;code&gt;basis&lt;/code&gt; および &lt;code&gt;cast&lt;/code&gt; クラスメソッドも使用できます。castメソッドはconvertメソッドのように機能しますが、basisメソッドは指定された次数の基底多項式を返します。</target>
        </trans-unit>
        <trans-unit id="9a36a11020261b9ce301df38d29f32b272d351ef" translate="yes" xml:space="preserve">
          <source>In order to add a Python package to SciPy, its build script (&lt;code&gt;setup.py&lt;/code&gt;) must meet certain requirements. The most important requirement is that the package define a &lt;code&gt;configuration(parent_package='',top_path=None)&lt;/code&gt; function which returns a dictionary suitable for passing to &lt;code&gt;numpy.distutils.core.setup(..)&lt;/code&gt;. To simplify the construction of this dictionary, &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; provides the &lt;code&gt;Configuration&lt;/code&gt; class, described below.</source>
          <target state="translated">PythonパッケージをSciPyに追加するには、そのビルドスクリプト（ &lt;code&gt;setup.py&lt;/code&gt; ）が特定の要件を満たしている必要があります。最も重要な要件は、パッケージが &lt;code&gt;numpy.distutils.core.setup(..)&lt;/code&gt; に渡すのに適した辞書を返す &lt;code&gt;configuration(parent_package='',top_path=None)&lt;/code&gt; 関数を定義することです。このディクショナリの構築を簡略化するために、 &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; には、以下に説明する &lt;code&gt;Configuration&lt;/code&gt; クラスが用意されています。</target>
        </trans-unit>
        <trans-unit id="9195216b823d914ae553da6509b9641a3f8c45ff" translate="yes" xml:space="preserve">
          <source>In order to extract information from a given matrix, we can use the SVD to obtain 3 arrays which can be multiplied to obtain the original matrix. From the theory of linear algebra, given a matrix</source>
          <target state="translated">与えられた行列から情報を抽出するために、SVDを用いて、乗算して元の行列を得ることができる3つの配列を得ることができる。線形代数の理論から,与えられた行列</target>
        </trans-unit>
        <trans-unit id="60fc69a196f8bf024afb0ed60ca3a78c46194201" translate="yes" xml:space="preserve">
          <source>In order to improve the interface, directives should be provided. This is accomplished by constructing an interface definition file. It is usually best to start from the interface file that f2py can produce (where it gets its default behavior from). To get f2py to generate the interface file use the -h option:</source>
          <target state="translated">インターフェースを改善するために、ディレクティブを提供する必要があります。これは、インターフェース定義ファイルを構築することで達成されます。通常、f2pyが生成できるインターフェースファイル(デフォルトの動作を取得する場所)から始めるのがベストです。f2pyがインターフェースファイルを生成するためには、-hオプションを使用します。</target>
        </trans-unit>
        <trans-unit id="d5eaeb15f58484d8774fc878d68cb55c966f0844" translate="yes" xml:space="preserve">
          <source>In order to make use of the C-API from another extension module, the &lt;a href=&quot;#c.import_array&quot;&gt;&lt;code&gt;import_array&lt;/code&gt;&lt;/a&gt; function must be called. If the extension module is self-contained in a single .c file, then that is all that needs to be done. If, however, the extension module involves multiple files where the C-API is needed then some additional steps must be taken.</source>
          <target state="translated">別の拡張モジュールからC-APIを利用するには、&lt;a href=&quot;#c.import_array&quot;&gt; &lt;code&gt;import_array&lt;/code&gt; &lt;/a&gt;関数を呼び出す必要があります。拡張モジュールが単一の.cファイルに自己完結している場合、実行する必要があるのはそれだけです。ただし、拡張モジュールにC-APIが必要な複数のファイルが含まれている場合は、いくつかの追加手順を実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="c34adc34291107e6d105c5cd2a716fc5c0f9914c" translate="yes" xml:space="preserve">
          <source>In order to pay-off (i.e., have a future-value of 0) the $200,000 obtained today, a monthly payment of $1,854.02 would be required. Note that this example illustrates usage of &lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt;&lt;code&gt;fv&lt;/code&gt;&lt;/a&gt; having a default value of 0.</source>
          <target state="translated">今日得られた200,000ドルを支払う（つまり、future値が0である）には、月額1,854.02ドルの支払いが必要になります。この例では、デフォルト値が0の&lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt; &lt;code&gt;fv&lt;/code&gt; の&lt;/a&gt;使用法を示しています。</target>
        </trans-unit>
        <trans-unit id="5f37a6feac047af18be703227c7a9f994a3a9fcc" translate="yes" xml:space="preserve">
          <source>In order to prevent clobbering object pointers in fields of &lt;code&gt;numpy.object&lt;/code&gt; type, numpy currently does not allow views of structured arrays containing objects.</source>
          <target state="translated">&lt;code&gt;numpy.object&lt;/code&gt; タイプのフィールドでオブジェクトポインタが壊れるのを防ぐために、numpyは現在、オブジェクトを含む構造化配列のビューを許可していません。</target>
        </trans-unit>
        <trans-unit id="1b7199a5c1d305f9cc30b6b7f154cecb0f39e6d3" translate="yes" xml:space="preserve">
          <source>In order to remove elements from an array, it&amp;rsquo;s simple to use indexing to select the elements that you want to keep.</source>
          <target state="translated">配列から要素を削除するには、インデックスを使用して、保持する要素を選択するのが簡単です。</target>
        </trans-unit>
        <trans-unit id="b465797b5de029b2baabd94edf6595fe5ee0db1d" translate="yes" xml:space="preserve">
          <source>In order to start using NumPy and all of the functions available in NumPy, you&amp;rsquo;ll need to import it. This can be easily done with this import statement:</source>
          <target state="translated">NumPyとNumPyで利用可能なすべての機能の使用を開始するには、それをインポートする必要があります。これは、次のインポートステートメントで簡単に実行できます。</target>
        </trans-unit>
        <trans-unit id="cdf699c411308f89c9b3b067e51b1e307dfb7a9f" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;flags = divide + 2*over + 4*under + 8*invalid&lt;/code&gt;.</source>
          <target state="translated">つまり、 &lt;code&gt;flags = divide + 2*over + 4*under + 8*invalid&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f91eee16dbc3f050fa038e2c5209d53822e69e47" translate="yes" xml:space="preserve">
          <source>In other words, each entry &lt;code&gt;out[i,j,...,:]&lt;/code&gt; is an N-dimensional value drawn from the distribution.</source>
          <target state="translated">つまり、各エントリ &lt;code&gt;out[i,j,...,:]&lt;/code&gt; は、分布から抽出されたN次元の値です。</target>
        </trans-unit>
        <trans-unit id="b7dcdc5e279e7f5cb5fcdbe1eac1b3a0742ee26b" translate="yes" xml:space="preserve">
          <source>In other words, the usage of info is exactly the same as when using blas_info and co.</source>
          <target state="translated">つまり、infoの使い方はblas_infoやco.infoを使うときと全く同じです。</target>
        </trans-unit>
        <trans-unit id="84851d19bec7dda86a1de5ddcd1548f32366d2fa" translate="yes" xml:space="preserve">
          <source>In our case,</source>
          <target state="translated">私たちの場合は</target>
        </trans-unit>
        <trans-unit id="d08ff7590113d034602ad8a932c13f96f4f84856" translate="yes" xml:space="preserve">
          <source>In our case, we are approximating the grayscale portion of the image, so we will use the colormap &lt;code&gt;gray&lt;/code&gt;:</source>
          <target state="translated">この例では、画像のグレースケール部分を概算しているため、カラーマップ &lt;code&gt;gray&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="41f0de1dccddf6867cedf88d3dd90186911881e1" translate="yes" xml:space="preserve">
          <source>In our examples, we will treat the input array with a complex data type, so that we can take square roots of negative numbers. Without enabling copies or buffering mode, the iterator will raise an exception if the data type doesn&amp;rsquo;t match precisely.</source>
          <target state="translated">この例では、入力配列を複雑なデータ型で処理するため、負の数値の平方根を取得できます。コピーまたはバッファリングモードを有効にしないと、データ型が正確に一致しない場合、イテレータは例外を発生させます。</target>
        </trans-unit>
        <trans-unit id="f3aea51c3c320aa437734a573490879eb2569913" translate="yes" xml:space="preserve">
          <source>In place fancy indexing for ufuncs</source>
          <target state="translated">ufuncsのための場所のファンシーなインデックス化</target>
        </trans-unit>
        <trans-unit id="f02a14688f33a1cd645cff2ad5ad3ea73913fd03" translate="yes" xml:space="preserve">
          <source>In place operations will perform the calculation using the precision decided by the data type of the two operands, but will silently downcast the result (if necessary) so it can fit back into the array. Therefore, for mixed precision calculations, &lt;code&gt;A {op}=
B&lt;/code&gt; can be different than &lt;code&gt;A = A {op} B&lt;/code&gt;. For example, suppose &lt;code&gt;a = ones((3,3))&lt;/code&gt;. Then, &lt;code&gt;a += 3j&lt;/code&gt; is different than &lt;code&gt;a = a +
3j&lt;/code&gt;: while they both perform the same computation, &lt;code&gt;a += 3&lt;/code&gt; casts the result to fit back in &lt;code&gt;a&lt;/code&gt;, whereas &lt;code&gt;a = a + 3j&lt;/code&gt; re-binds the name &lt;code&gt;a&lt;/code&gt; to the result.</source>
          <target state="translated">インプレース演算は、2つのオペランドのデータ型によって決定される精度を使用して計算を実行しますが、結果に（必要に応じて）暗黙的にダウンキャストして、配列に適合できるようにします。したがって、混合精度計算では、 &lt;code&gt;A {op}= B&lt;/code&gt; は &lt;code&gt;A = A {op} B&lt;/code&gt; とは異なる場合があります。たとえば、 &lt;code&gt;a = ones((3,3))&lt;/code&gt; と仮定します。次いで、 &lt;code&gt;a += 3j&lt;/code&gt; は異なる &lt;code&gt;a = a + 3j&lt;/code&gt; ：彼らの両方が同じ計算、実行しながら &lt;code&gt;a += 3&lt;/code&gt; キャストバックに収まるように結果に対し、 &lt;code&gt;a = a + 3j&lt;/code&gt; 再バインド名 &lt;code&gt;a&lt;/code&gt; への結果。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ffbc219d4925b162d68445ad04161e81b80a2ae" translate="yes" xml:space="preserve">
          <source>In practice, we anticipate that for most Steering Council decisions (e.g., voting in new members) a more informal process will suffice.</source>
          <target state="translated">実際には、ほとんどの運営協議会の決定(新会員の投票など)は、より非公式なプロセスで十分であると考えています。</target>
        </trans-unit>
        <trans-unit id="211d3795b0d3cedf14ae00bfdd7e3e38d86df021" translate="yes" xml:space="preserve">
          <source>In prior versions of NumPy, the datetime64 type always stored times in UTC. By default, creating a datetime64 object from a string or printing it would convert from or to local time:</source>
          <target state="translated">NumPyの以前のバージョンでは、datetime64型は常にUTCで時刻を格納していました。デフォルトでは、文字列からdatetime64オブジェクトを作成したり、それを印刷したりすると、現地時間に変換されます。</target>
        </trans-unit>
        <trans-unit id="bb94af890255a1752661e16a2eacce9c1ad12713" translate="yes" xml:space="preserve">
          <source>In row-major, C-style order, in two dimensions, the row index varies the slowest, and the column index the quickest. This can be generalized to multiple dimensions, where row-major order implies that the index along the first axis varies slowest, and the index along the last quickest. The opposite holds for column-major, Fortran-style index ordering.</source>
          <target state="translated">行-長、C スタイルの順序では、2 つの次元では、行のインデックスが最も遅く、列のインデックスが最も速く変化します。これは多次元に一般化することができ、行-メジャー順序は、最初の軸に沿ったインデックスが最も遅く変化し、最後の軸に沿ったインデックスが最も速く変化することを意味します。これとは逆のことが、Fortranスタイルの列-メジャーインデックス順序にも当てはまります。</target>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="translated">要するに</target>
        </trans-unit>
        <trans-unit id="507aaff0e5cc21d7011bc819d2bd20f0b309484f" translate="yes" xml:space="preserve">
          <source>In single precision, &lt;a href=&quot;#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; can be inaccurate:</source>
          <target state="translated">単精度では、&lt;a href=&quot;#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt;は不正確になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="9b1dbcac5dd55e1c7b0ed7b38aff1c0737c2f620" translate="yes" xml:space="preserve">
          <source>In single precision, std() can be inaccurate:</source>
          <target state="translated">単精度では、std()は不正確な場合があります。</target>
        </trans-unit>
        <trans-unit id="ca04a495cdff9e1119115547af374f5b2a4d64ac" translate="yes" xml:space="preserve">
          <source>In single precision, var() can be inaccurate:</source>
          <target state="translated">単精度では、var()は不正確な場合があります。</target>
        </trans-unit>
        <trans-unit id="568553829625c2078673593fe2ee401327874ad7" translate="yes" xml:space="preserve">
          <source>In some cases, an appropriate use of the roll and the offset is necessary to get a desired answer.</source>
          <target state="translated">場合によっては、ロールとオフセットを適切に使い分けることで、希望する答えが得られることもあります。</target>
        </trans-unit>
        <trans-unit id="bac6ec658cf559e360b3f959f986ce1e7d727c27" translate="yes" xml:space="preserve">
          <source>In some cases, broadcasting stretches both arrays to form an output array larger than either of the initial arrays.*</source>
          <target state="translated">場合によっては,ブロードキャストは両方の配列を伸張して,どちらかの初期配列よりも大きな出力配列を形成します.</target>
        </trans-unit>
        <trans-unit id="ac0960cf0185d8fe7d74b182c3299905c5bc5818" translate="yes" xml:space="preserve">
          <source>In some cases, such as structured arrays and the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; interface, a data type needs to be used to make sense of the object. When this is needed, provide a Descr for &amp;lsquo;requested_dtype&amp;rsquo;, otherwise provide NULL. This reference is not stolen. Also, if the requested dtype doesn&amp;rsquo;t modify the interpretation of the input, out_dtype will still get the &amp;ldquo;innate&amp;rdquo; dtype of the object, not the dtype passed in &amp;lsquo;requested_dtype&amp;rsquo;.</source>
          <target state="translated">構造化配列や&lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;インターフェースなど、場合によっては、オブジェクトを理解するためにデータ型を使用する必要があります。これが必要な場合は、「requested_dtype」にDescrを提供し、そうでない場合はNULLを提供します。この参照は盗まれません。また、要求されたdtypeが入力の解釈を変更しない場合でも、out_dtypeは、「requested_dtype」で渡されたdtypeではなく、オブジェクトの「固有の」dtypeを取得します。</target>
        </trans-unit>
        <trans-unit id="facb6bd6062bf723ed24036374202b109145e308" translate="yes" xml:space="preserve">
          <source>In some cases, we are not interested in all the columns of the data but only a few of them. We can select which columns to import with the &lt;code&gt;usecols&lt;/code&gt; argument. This argument accepts a single integer or a sequence of integers corresponding to the indices of the columns to import. Remember that by convention, the first column has an index of 0. Negative integers behave the same as regular Python negative indexes.</source>
          <target state="translated">場合によっては、データのすべての列に関心があるわけではなく、そのうちのいくつかだけに関心があります。 &lt;code&gt;usecols&lt;/code&gt; 引数を使用して、インポートする列を選択できます。この引数は、インポートする列のインデックスに対応する単一の整数または整数のシーケンスを受け入れます。慣例により、最初の列のインデックスは0であることに注意してください。負の整数は、通常のPythonの負のインデックスと同じように動作します。</target>
        </trans-unit>
        <trans-unit id="ef2ea8dc139c52f2365b3742b195c7e8c88faf3c" translate="yes" xml:space="preserve">
          <source>In some cases, you will see this form of the commit command: &lt;code&gt;git commit
-a&lt;/code&gt;. The extra &lt;code&gt;-a&lt;/code&gt; flag automatically commits all modified files and removes all deleted files. This can save you some typing of numerous &lt;code&gt;git
add&lt;/code&gt; commands; however, it can add unwanted changes to a commit if you&amp;rsquo;re not careful. For more information, see &lt;a href=&quot;http://www.gitready.com/beginner/2009/01/18/the-staging-area.html&quot;&gt;why the -a flag?&lt;/a&gt; - and the helpful use-case description in the &lt;a href=&quot;https://tomayko.com/writings/the-thing-about-git&quot;&gt;tangled working copy problem&lt;/a&gt;.</source>
          <target state="translated">場合によっては、次の形式のcommitコマンドが表示されます： &lt;code&gt;git commit -a&lt;/code&gt; 。追加の &lt;code&gt;-a&lt;/code&gt; フラグは、変更されたすべてのファイルを自動的にコミットし、削除されたすべてのファイルを削除します。これにより、多数の &lt;code&gt;git add&lt;/code&gt; コマンドを入力する手間を省くことができます。ただし、注意しないと、コミットに不要な変更が追加される可能性があります。詳細&lt;a href=&quot;http://www.gitready.com/beginner/2009/01/18/the-staging-area.html&quot;&gt;については、-aフラグ&lt;/a&gt;を使用する理由を参照してください。 -そして、&lt;a href=&quot;https://tomayko.com/writings/the-thing-about-git&quot;&gt;絡み合った作業コピーの問題&lt;/a&gt;における有用なユースケースの説明。</target>
        </trans-unit>
        <trans-unit id="341cdd9b0329316960c0e4cc444da230117b1062" translate="yes" xml:space="preserve">
          <source>In some future release, it will return a read/write view and writing to the returned array will alter your original array. The returned array will have the same type as the input array.</source>
          <target state="translated">将来のリリースでは、読み込み/書き込みビューを返すようになり、返された配列に書き込むと元の配列が変更されます。返される配列は入力配列と同じ型になります。</target>
        </trans-unit>
        <trans-unit id="f5ee90b2a39e9fa80b16d394e14dd0a33a028120" translate="yes" xml:space="preserve">
          <source>In some situations, it is possible that you could use the &lt;code&gt;%numpy_typemaps&lt;/code&gt; macro to implement typemaps for your own types. See the &lt;a href=&quot;#other-common-types-bool&quot;&gt;Other Common Types: bool&lt;/a&gt; or &lt;a href=&quot;#other-common-types-complex&quot;&gt;Other Common Types: complex&lt;/a&gt; sections for examples. Another situation is if your dimensions are of a type other than &lt;code&gt;int&lt;/code&gt; (say &lt;code&gt;long&lt;/code&gt; for example):</source>
          <target state="translated">状況によっては、 &lt;code&gt;%numpy_typemaps&lt;/code&gt; マクロを使用して独自のタイプのタイプマップを実装できる場合があります。例については、&lt;a href=&quot;#other-common-types-bool&quot;&gt;その他の一般的なタイプ：bool&lt;/a&gt;または&lt;a href=&quot;#other-common-types-complex&quot;&gt;その他の一般的なタイプ：複雑な&lt;/a&gt;セクションを参照してください。もう1つの状況は、ディメンションが &lt;code&gt;int&lt;/code&gt; 以外のタイプ（たとえば、 &lt;code&gt;long&lt;/code&gt; など）の場合です。</target>
        </trans-unit>
        <trans-unit id="ef54aceba82e6cd0b5d227cf1545504de22cdfa8" translate="yes" xml:space="preserve">
          <source>In that case, each item is associated to a column, in order.</source>
          <target state="translated">その場合、各項目は順番に列に関連付けられています。</target>
        </trans-unit>
        <trans-unit id="4128e61e6436506814002ae295957c7fd56f0e0e" translate="yes" xml:space="preserve">
          <source>In that repository edit the files:</source>
          <target state="translated">そのリポジトリでファイルを編集します。</target>
        </trans-unit>
        <trans-unit id="3d0c88a0902d8f4e29b2260087b409a1f0c6bbf0" translate="yes" xml:space="preserve">
          <source>In the 1-D and 0-D case, the indexing and sparse keywords have no effect.</source>
          <target state="translated">1次元と0次元の場合は、インデックス化と疎なキーワードは効果がない。</target>
        </trans-unit>
        <trans-unit id="82b4d34298ee4da5c6486a950c439f010b328116" translate="yes" xml:space="preserve">
          <source>In the above example F2PY was able to guess accurately the signature of a call-back function. However, sometimes F2PY cannot establish the signature as one would wish and then the signature of a call-back function must be modified in the signature file manually. Namely, signature files may contain special modules (the names of such modules contain a substring &lt;code&gt;__user__&lt;/code&gt;) that collect various signatures of call-back functions. Callback arguments in routine signatures have attribute &lt;code&gt;external&lt;/code&gt; (see also &lt;code&gt;intent(callback)&lt;/code&gt; attribute). To relate a callback argument and its signature in &lt;code&gt;__user__&lt;/code&gt; module block, use &lt;code&gt;use&lt;/code&gt; statement as illustrated below. The same signature of a callback argument can be referred in different routine signatures.</source>
          <target state="translated">上記の例では、F2PYはコールバック関数のシグネチャを正確に推測することができました。ただし、F2PYが希望どおりに署名を確立できない場合があり、コールバック関数の署名を署名ファイルで手動で変更する必要があります。つまり、署名ファイルには、コールバック関数のさまざまな署名を収集する特別なモジュール（そのようなモジュールの名前には部分文字列 &lt;code&gt;__user__&lt;/code&gt; が含まれます）が含まれる場合があります。ルーチンシグニチャのコールバック引数には、 &lt;code&gt;external&lt;/code&gt; 属性があります（ &lt;code&gt;intent(callback)&lt;/code&gt; 属性も参照）。 &lt;code&gt;__user__&lt;/code&gt; モジュールブロックでコールバック引数とその署名を関連付けるには、 &lt;code&gt;use&lt;/code&gt; 以下に示すようなステートメント。コールバック引数の同じシグニチャは、異なるルーチンシグニチャで参照できます。</target>
        </trans-unit>
        <trans-unit id="e263de7df2b576cf438fac441850586c983ab809" translate="yes" xml:space="preserve">
          <source>In the case of double precision tests, this will return the python function &lt;code&gt;Vector.doubleLength&lt;/code&gt;.</source>
          <target state="translated">倍精度テストの場合、これはPython関数 &lt;code&gt;Vector.doubleLength&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="a0240da2483005a9c53b4aad1de6618f577c43aa" translate="yes" xml:space="preserve">
          <source>In the common 2-D case (N=1), the block structure can be visualized:</source>
          <target state="translated">一般的な2次元の場合(N=1)では、ブロック構造を可視化することができます。</target>
        </trans-unit>
        <trans-unit id="e138055380190b3c93b794e532e7d0c34dce613a" translate="yes" xml:space="preserve">
          <source>In the end, which you do for Fortran or C depends on which is more important, not reordering data or preserving the indexing convention. For large images, reordering data is potentially expensive, and often the indexing convention is inverted to avoid that.</source>
          <target state="translated">結局、FortranとCのどちらを使うかは、データの並び替えをしないことと、インデキシング規約を維持することのどちらがより重要かにかかっています。大きな画像の場合、データの並び替えにはコストがかかる可能性があり、それを避けるためにインデックス規則を反転させることがよくあります。</target>
        </trans-unit>
        <trans-unit id="8930375040ab76aae34fb47c1b34d1c268b41dae" translate="yes" xml:space="preserve">
          <source>In the event of any conflict of interest, a committee member must immediately notify the other members, and recuse themselves if necessary.</source>
          <target state="translated">委員は、利益相反が生じた場合、直ちに他の委員に通知し、必要に応じて退席しなければならない。</target>
        </trans-unit>
        <trans-unit id="b1d5a2c6f7d9d2516af28db041f10097409dc991" translate="yes" xml:space="preserve">
          <source>In the example above, we used the fact that by default, &lt;code&gt;dtype=float&lt;/code&gt;. By giving a sequence of names, we are forcing the output to a structured dtype.</source>
          <target state="translated">上記の例では、デフォルトで &lt;code&gt;dtype=float&lt;/code&gt; という事実を使用しました。名前のシーケンスを指定することにより、出力を構造化されたdtypeに強制します。</target>
        </trans-unit>
        <trans-unit id="6eb66ccf87f3461ec66b2cc1735ef182a062917a" translate="yes" xml:space="preserve">
          <source>In the file, array data starts at this offset. Since &lt;code&gt;offset&lt;/code&gt; is measured in bytes, it should normally be a multiple of the byte-size of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;. When &lt;code&gt;mode != 'r'&lt;/code&gt;, even positive offsets beyond end of file are valid; The file will be extended to accommodate the additional data. By default, &lt;code&gt;memmap&lt;/code&gt; will start at the beginning of the file, even if &lt;code&gt;filename&lt;/code&gt; is a file pointer &lt;code&gt;fp&lt;/code&gt; and &lt;code&gt;fp.tell() != 0&lt;/code&gt;.</source>
          <target state="translated">ファイルでは、配列データはこのオフセットから始まります。以来、 &lt;code&gt;offset&lt;/code&gt; バイト単位で測定され、それは、通常のバイトサイズの倍数でなければならない&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;。とき &lt;code&gt;mode != 'r'&lt;/code&gt; 、ファイルの終わりを越えても、正のオフセットが有効です。ファイルは、追加データを収容するために拡張されます。デフォルトでは、 &lt;code&gt;filename&lt;/code&gt; がファイルポインター &lt;code&gt;fp&lt;/code&gt; および &lt;code&gt;fp.tell() != 0&lt;/code&gt; であっても、 &lt;code&gt;memmap&lt;/code&gt; はファイルの先頭から開始されます。</target>
        </trans-unit>
        <trans-unit id="6d51d7e744b66162bcb271fa8e86dbafebc0e214" translate="yes" xml:space="preserve">
          <source>In the first case the lower bound of the integration is set to -1 and the integration constant is 0. In the second the constant of integration is set to 1 as well. Differentiation is simpler since the only option is the number of times the polynomial is differentiated:</source>
          <target state="translated">最初のケースでは、積分の下限を -1 とし、積分定数を 0 とします。 2 番目のケースでは、積分定数も 1 とします。微分は多項式を微分する回数を決めるだけなので,微分の方が簡単です.</target>
        </trans-unit>
        <trans-unit id="39042dbdcabf0496e03a08644bb7e129fe61d278" translate="yes" xml:space="preserve">
          <source>In the first case, the dimensions resulting from the advanced indexing operation come first in the result array, and the subspace dimensions after that. In the second case, the dimensions from the advanced indexing operations are inserted into the result array at the same spot as they were in the initial array (the latter logic is what makes simple advanced indexing behave just like slicing).</source>
          <target state="translated">最初のケースでは、高度なインデキシング操作の結果として得られた次元が結果配列の最初に来て、その後に部分空間次元が来ます。2 番目のケースでは、高度なインデキシング操作から得られた次元は、最初の配列にあったのと同じ場所で結果配列に挿入されます(後者のロジックにより、単純な高度なインデキシングがスライスと同じように動作するようになります)。</target>
        </trans-unit>
        <trans-unit id="fee9951c9cac899e8dc4b73ca21eaf580eee1e11" translate="yes" xml:space="preserve">
          <source>In the following descriptions, we reference a generic &lt;code&gt;DATA_TYPE&lt;/code&gt;, which could be any of the C data types listed above, and &lt;code&gt;DIM_TYPE&lt;/code&gt; which should be one of the many types of integers.</source>
          <target state="translated">以下の説明では、汎用の &lt;code&gt;DATA_TYPE&lt;/code&gt; を参照します。これは上記のCデータ型のいずれかであり、 &lt;code&gt;DIM_TYPE&lt;/code&gt; は多くの整数型の1つである必要があります。</target>
        </trans-unit>
        <trans-unit id="0a77a218f61bf2d19822ca93ebcee58f5aa1e669" translate="yes" xml:space="preserve">
          <source>In the following example, both the &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; arrays have axes with length one that are expanded to a larger size during the broadcast operation:</source>
          <target state="translated">次の例では、 &lt;code&gt;A&lt;/code&gt; 配列と &lt;code&gt;B&lt;/code&gt; 配列の両方に、ブロードキャスト操作中に大きなサイズに拡張される長さ1の軸があります。</target>
        </trans-unit>
        <trans-unit id="56c7aa7e2fe12577360a1a373c78ed632827aefd" translate="yes" xml:space="preserve">
          <source>In the following example, both the &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; arrays have axes with length one that are expanded to a larger size in a broadcast operation.</source>
          <target state="translated">次の例では、 &lt;code&gt;A&lt;/code&gt; 配列と &lt;code&gt;B&lt;/code&gt; 配列の両方に、ブロードキャスト操作でより大きなサイズに拡張される長さ1の軸があります。</target>
        </trans-unit>
        <trans-unit id="7b0aabec281905f99f49d1bbd6f2c64a2c3c69d5" translate="yes" xml:space="preserve">
          <source>In the following example, the second column is converted from as string representing a percentage to a float between 0 and 1:</source>
          <target state="translated">以下の例では、2 番目の列がパーセンテージを表す文字列から 0 から 1 の間の float に変換されます。</target>
        </trans-unit>
        <trans-unit id="4b029336d8b412b884840fa6a1fbeb3e45d0f30b" translate="yes" xml:space="preserve">
          <source>In the following example, we suppose that the missing values are flagged with &lt;code&gt;&quot;N/A&quot;&lt;/code&gt; in the first column and by &lt;code&gt;&quot;???&quot;&lt;/code&gt; in the third column. We wish to transform these missing values to 0 if they occur in the first and second column, and to -999 if they occur in the last column:</source>
          <target state="translated">次の例では、欠落している値に最初の列に &lt;code&gt;&quot;N/A&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;???&quot;&lt;/code&gt; フラグが付けられていると想定しています。3番目の列にあります。これらの欠落値が最初と2番目の列にある場合は0に変換し、最後の列にある場合は-999に変換します。</target>
        </trans-unit>
        <trans-unit id="fceed6223bcf512a691c7903c36d65343ab22b97" translate="yes" xml:space="preserve">
          <source>In the graph, we can see that although we have 768 singular values in &lt;code&gt;s&lt;/code&gt;, most of those (after the 150th entry or so) are pretty small. So it might make sense to use only the information related to the first (say, 50) &lt;em&gt;singular values&lt;/em&gt; to build a more economical approximation to our image.</source>
          <target state="translated">グラフでは、 &lt;code&gt;s&lt;/code&gt; に768の特異値がありますが、それらのほとんど（150番目のエントリ以降）はかなり小さいことがわかります。したがって、最初の（たとえば、50）&lt;em&gt;特異値&lt;/em&gt;に関連する情報のみを使用して、画像のより経済的な近似を構築することが理にかなっている場合があります。</target>
        </trans-unit>
        <trans-unit id="66d2fff5a851e4221aa19362249b2b84c5964134" translate="yes" xml:space="preserve">
          <source>In the next several sections we give example code that can be easily modified to create your own ufuncs. The examples are successively more complete or complicated versions of the logit function, a common function in statistical modeling. Logit is also interesting because, due to the magic of IEEE standards (specifically IEEE 754), all of the logit functions created below automatically have the following behavior.</source>
          <target state="translated">次のいくつかのセクションでは、独自のufuncsを作成するために簡単に修正できるコード例を示します。これらの例は、統計モデリングで一般的な関数であるロジット関数の、より完全な、あるいは複雑なバージョンのものです。Logitはまた、IEEE標準(特にIEEE 754)の魔法により、以下に作成されたlogit関数のすべてが自動的に以下のような動作をするという点で興味深いものです。</target>
        </trans-unit>
        <trans-unit id="1dc319444395eeb97927a05649519246dd32d72d" translate="yes" xml:space="preserve">
          <source>In the past most implementations used the &amp;ldquo;desc&amp;rdquo; member of the &lt;code&gt;PyCObject&lt;/code&gt; itself (do not confuse this with the &amp;ldquo;descr&amp;rdquo; member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure above &amp;mdash; they are two separate things) to hold the pointer to the object exposing the interface. This is now an explicit part of the interface. Be sure to own a reference to the object when the &lt;code&gt;PyCObject&lt;/code&gt; is created using &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt;.</source>
          <target state="translated">過去のほとんどの実装では、 &lt;code&gt;PyCObject&lt;/code&gt; 自体の「desc」メンバーを使用して（これを上記の&lt;a href=&quot;c-api.types-and-structures#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;構造体の「descr」メンバーと混同しないでください。これらは2つの別個のものです）、インターフェースを公開するオブジェクトへのポインターを保持します。これは、インターフェースの明示的な部分です。 &lt;code&gt;PyCObject&lt;/code&gt; _FromVoidPtrAndDescを使用してPyCObjectを作成するときは、必ずオブジェクトへの参照を所有して &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cb71d475f8be6120fc976bd353b076b792b7f77" translate="yes" xml:space="preserve">
          <source>In the past most implementations used the &amp;ldquo;desc&amp;rdquo; member of the &lt;code&gt;PyCObject&lt;/code&gt; itself (do not confuse this with the &amp;ldquo;descr&amp;rdquo; member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure above &amp;mdash; they are two separate things) to hold the pointer to the object exposing the interface. This is now an explicit part of the interface. Be sure to own a reference to the object when the &lt;code&gt;PyCObject&lt;/code&gt; is created using &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt;.</source>
          <target state="translated">これまで、ほとんどの実装では、 &lt;code&gt;PyCObject&lt;/code&gt; 自体の「desc」メンバーを使用して（これを上記の&lt;a href=&quot;c-api/types-and-structures#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;構造体の「descr」メンバーと混同しないでください。これらは2つの別個のものです）、インターフェイスを公開するオブジェクトへのポインターを保持します。これは、インターフェイスの明示的な部分になりました。 &lt;code&gt;PyCObject&lt;/code&gt; _FromVoidPtrAndDescを使用してPyCObjectを作成するときは、必ずオブジェクトへの参照を所有して &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cfcf82ced52f76044f84d6258de886b7808506ff" translate="yes" xml:space="preserve">
          <source>In the range -1 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 1 they are nice, equiripple functions lying between +/- 1. The same plots over the range -2 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 2 look very different:</source>
          <target state="translated">範囲-1 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 1では、それらは+/- 1の間にある等リップル関数であり、範囲が同じである-2 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 2のプロットは非常に異なって見えます。</target>
        </trans-unit>
        <trans-unit id="8d2fb588d0d5207847c4495ec3e5ed9b60e1f12d" translate="yes" xml:space="preserve">
          <source>In the same way, if we don&amp;rsquo;t give enough names to match the length of the dtype, the missing names will be defined with this default template:</source>
          <target state="translated">同様に、dtypeの長さに一致する十分な名前を指定しない場合、欠落している名前は次のデフォルトテンプレートで定義されます。</target>
        </trans-unit>
        <trans-unit id="9664dec4c702af778eb236a77580a7bb3b836b54" translate="yes" xml:space="preserve">
          <source>In the simplest case, there is only a &lt;em&gt;single&lt;/em&gt; advanced index. A single advanced index can for example replace a slice and the result array will be the same, however, it is a copy and may have a different memory layout. A slice is preferable when it is possible.</source>
          <target state="translated">最も単純なケースでは、高度なインデックスは&lt;em&gt;1つ&lt;/em&gt;だけです。たとえば、単一の高度なインデックスでスライスを置き換えることができ、結果の配列は同じになりますが、これはコピーであり、メモリレイアウトが異なる場合があります。可能であればスライスが望ましい。</target>
        </trans-unit>
        <trans-unit id="eaceaaeb778efa3a74e32f0e07667ae3c3a1ce24" translate="yes" xml:space="preserve">
          <source>In the source code, be sure to preface any issue or PR reference with &lt;code&gt;gh-xxxx&lt;/code&gt;.</source>
          <target state="translated">ソースコードでは、問題やPRリファレンスの前に必ず &lt;code&gt;gh-xxxx&lt;/code&gt; を付けてください。</target>
        </trans-unit>
        <trans-unit id="c94924098b3009fa708b6c1aec49764e87be7477" translate="yes" xml:space="preserve">
          <source>In the table below, it is assumed that you have executed the following commands in Python:</source>
          <target state="translated">下の表では、Pythonで以下のコマンドを実行したと仮定しています。</target>
        </trans-unit>
        <trans-unit id="d8a45b3135fa0c84b41da4d210f43fe96826517e" translate="yes" xml:space="preserve">
          <source>In the tables below, &lt;code&gt;platform?&lt;/code&gt; means that the type may not be available on all platforms. Compatibility with different C or Python types is indicated: two types are compatible if their data is of the same size and interpreted in the same way.</source>
          <target state="translated">下の表で、 &lt;code&gt;platform?&lt;/code&gt; タイプはすべてのプラットフォームで利用できるわけではないことを意味します。異なるCまたはPython型との互換性が示されています。2つの型は、データのサイズが同じで、同じ方法で解釈される場合に互換性があります。</target>
        </trans-unit>
        <trans-unit id="97b2743d166cdad8253bc15ad591949789d4af86" translate="yes" xml:space="preserve">
          <source>In the worst case, if a Contributor is genuinely misusing their veto in an obstructive fashion to the detriment of the project, then they can be ejected from the project by consensus of the Steering Council &amp;ndash; see below.</source>
          <target state="translated">最悪の場合、コントリビューターがプロジェクトに悪影響を与えるために拒否権を妨害的に悪用している場合は、運営評議会のコンセンサスによってプロジェクトから除外される可能性があります。以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="3a7fe7582d8015e2df7c05da1f3a915ff663edd3" translate="yes" xml:space="preserve">
          <source>In this calculation, we can ignore the amount of numbers drawn from each stream. Each of the PRNGs we provide has some extra protection built in that avoids overlaps if the &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; pools differ in the slightest bit. &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; has</source>
          <target state="translated">この計算では、各ストリームから引き出された数値の量を無視できます。私たちが提供する各PRNGには、&lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;プールがわずかに異なる場合に重複を回避する、いくつかの追加の保護が組み込まれています。&lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; に&lt;/a&gt;は</target>
        </trans-unit>
        <trans-unit id="65a0a52b3e0dac0b940f22ccbd59e595b0b91828" translate="yes" xml:space="preserve">
          <source>In this calculation, we can ignore the amount of numbers drawn from each stream. Each of the PRNGs we provide has some extra protection built in that avoids overlaps if the &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; pools differ in the slightest bit. &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; has</source>
          <target state="translated">この計算では、各ストリームから取得される数値の量を無視できます。私たちが提供する各PRNGにはいくつかの追加の保護機能が組み込まれており、&lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;プールが少しでも異なる場合に重複を回避します。&lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; に&lt;/a&gt;は</target>
        </trans-unit>
        <trans-unit id="fcdf80c260003d781b3489e23716b20d73cd0927" translate="yes" xml:space="preserve">
          <source>In this case, if the index arrays have a matching shape, and there is an index array for each dimension of the array being indexed, the resultant array has the same shape as the index arrays, and the values correspond to the index set for each position in the index arrays. In this example, the first index value is 0 for both index arrays, and thus the first value of the resultant array is y[0,0]. The next value is y[2,1], and the last is y[4,2].</source>
          <target state="translated">この場合、インデックス配列が一致した形状を有しており、インデックスされる配列の各次元についてインデックス配列が存在する場合、結果配列はインデックス配列と同じ形状を有しており、その値はインデックス配列の各位置について設定されたインデックスに対応する。この例では、両方のインデックス配列の最初のインデックス値は0であり、したがって、結果配列の最初の値はy[0,0]である。次の値は y[2,1]であり,最後の値は y[4,2]です.</target>
        </trans-unit>
        <trans-unit id="89c8dba17ad2bf90a54597788476417de6721a53" translate="yes" xml:space="preserve">
          <source>In this case, we wanted to test solving a linear algebra problem using matrices of several data types, using &lt;code&gt;linalg.solve&lt;/code&gt; and &lt;code&gt;linalg.inv&lt;/code&gt;. The common test cases (for single-precision, double-precision, etc. matrices) are collected in &lt;code&gt;LinalgTestCase&lt;/code&gt;.</source>
          <target state="translated">この場合、 &lt;code&gt;linalg.solve&lt;/code&gt; と &lt;code&gt;linalg.inv&lt;/code&gt; を使用して、いくつかのデータ型の行列を使用して線形代数問題の解をテストしたいと考えました。一般的なテストケース（単精度、倍精度などの行列）は &lt;code&gt;LinalgTestCase&lt;/code&gt; に収集されます。</target>
        </trans-unit>
        <trans-unit id="a876e5a0c738a8e265b4a962587a67aa3cabc3ca" translate="yes" xml:space="preserve">
          <source>In this chapter routine docstrings are presented, grouped by functionality. Many docstrings contain example code, which demonstrates basic usage of the routine. The examples assume that NumPy is imported with:</source>
          <target state="translated">この章では、機能別にグループ化されたルーチン・ドクストリングが示されています。多くの docstring には、ルーチンの基本的な使用法を示すサンプル・コードが含まれています。例は、NumPy がインポートされていることを前提としています。</target>
        </trans-unit>
        <trans-unit id="4030b7d01040d7db2670bc21cd8e6f75987d1ae6" translate="yes" xml:space="preserve">
          <source>In this context, consensus does &lt;em&gt;not&lt;/em&gt; require:</source>
          <target state="translated">このコンテキストでは、コンセンサスは以下&lt;em&gt;を&lt;/em&gt;必要としませ&lt;em&gt;ん&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="fb82fb6aef1a39fd7c11a037068f12eca825f3ae" translate="yes" xml:space="preserve">
          <source>In this example if &lt;code&gt;a&lt;/code&gt; is an ndarray, &amp;ldquo;fancy&amp;rdquo; indexing can be used.</source>
          <target state="translated">この例 &lt;code&gt;a&lt;/code&gt; は、aがndarrayの場合、「ファンシー」なインデックスを使用できます。</target>
        </trans-unit>
        <trans-unit id="8f824e9ad2dd27432acf7adb45ed2442b89417d6" translate="yes" xml:space="preserve">
          <source>In this example the spacing is also specified: uniform for axis=0 and non uniform for axis=1</source>
          <target state="translated">こ の例では、 軸=0 の場合は一様で、 軸=1 の場合は一様でない間隔も指定されています。</target>
        </trans-unit>
        <trans-unit id="328c265783b83eb29747b7db6d81add31503c3ba" translate="yes" xml:space="preserve">
          <source>In this example, I will show how the addition function and the filter function implemented previously using the other approaches can be implemented using ctypes. First, the C code which implements the algorithms contains the functions &lt;code&gt;zadd&lt;/code&gt;, &lt;code&gt;dadd&lt;/code&gt;, &lt;code&gt;sadd&lt;/code&gt;, &lt;code&gt;cadd&lt;/code&gt;, and &lt;code&gt;dfilter2d&lt;/code&gt;. The &lt;code&gt;zadd&lt;/code&gt; function is:</source>
          <target state="translated">この例では、他のアプローチを使用して以前に実装された加算関数とフィルター関数をctypesを使用して実装する方法を示します。まず、アルゴリズムを実装するCコードは、機能が含ま &lt;code&gt;zadd&lt;/code&gt; 、 &lt;code&gt;dadd&lt;/code&gt; 、 &lt;code&gt;sadd&lt;/code&gt; 、 &lt;code&gt;cadd&lt;/code&gt; 、及び &lt;code&gt;dfilter2d&lt;/code&gt; 。 &lt;code&gt;zadd&lt;/code&gt; 関数は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="97c094638bd844d3fa04f0e228195eec44c93a4f" translate="yes" xml:space="preserve">
          <source>In this example, a tuple of arrays was returned: one for each dimension. The first array represents the row indices where these values are found, and the second array represents the column indices where the values are found.</source>
          <target state="translated">この例では、各ディメンジョンに対して 1 つの配列のタプルが返されました。最初の配列は、これらの値が検出された行のインデックスを表し、2 番目の配列は、値が検出された列のインデックスを表します。</target>
        </trans-unit>
        <trans-unit id="2729241cb81ad5eb6d0653ad987658266f4094e0" translate="yes" xml:space="preserve">
          <source>In this example, both the predictions and labels vectors contain three values, meaning &lt;code&gt;n&lt;/code&gt; has a value of three. After we carry out subtractions the values in the vector are squared. Then NumPy sums the values, and your result is the error value for that prediction and a score for the quality of the model.</source>
          <target state="translated">この例では、予測ベクトルとラベルベクトルの両方に3つの値が含まれています。つまり、 &lt;code&gt;n&lt;/code&gt; の値は3です。減算を実行した後、ベクトルの値は2乗されます。次に、NumPyが値を合計すると、結果はその予測のエラー値とモデルの品質のスコアになります。</target>
        </trans-unit>
        <trans-unit id="e415859b6bc51789a95cf9e8d4d1433827763e1d" translate="yes" xml:space="preserve">
          <source>In this example, real input has an FFT which is Hermitian, i.e., symmetric in the real part and anti-symmetric in the imaginary part, as described in the &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; documentation:</source>
          <target state="translated">この例では、&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; の&lt;/a&gt;ドキュメントで説明されているように、実数入力はエルミートであるFFTを持っています。つまり、実数部では対称であり、虚数部では反対称です。</target>
        </trans-unit>
        <trans-unit id="ceae5efa8d3a6692e49c8c2886b52adb07addf1c" translate="yes" xml:space="preserve">
          <source>In this example, weight has more impact on the distance calculation than height because of the larger values. In practice, it is important to normalize the height and weight, often by their standard deviation across the data set, so that both have equal influence on the distance calculation.</source>
          <target state="translated">この例では、値が大きいため、高さよりも重量の方が距離計算に大きな影響を与えます。実際には、高さと重さを正規化することが重要であり、多くの場合、データセット全体の標準偏差で正規化することで、両者が距離計算に等しく影響するようにします。</target>
        </trans-unit>
        <trans-unit id="2c3e40fb7708f540adaa0b760c857b87aaa0e15a" translate="yes" xml:space="preserve">
          <source>In this shorthand notation any of the &lt;a href=&quot;../reference/arrays.dtypes#arrays-dtypes-constructing&quot;&gt;string dtype specifications&lt;/a&gt; may be used in a string and separated by commas. The itemsize and byte offsets of the fields are determined automatically, and the field names are given the default names &lt;code&gt;f0&lt;/code&gt;, &lt;code&gt;f1&lt;/code&gt;, etc.</source>
          <target state="translated">この省略表記では、&lt;a href=&quot;../reference/arrays.dtypes#arrays-dtypes-constructing&quot;&gt;文字列dtype仕様の&lt;/a&gt;いずれかを文字列で使用し、コンマで区切ることができます。フィールドのアイテムサイズとバイトオフセットは自動的に決定され、フィールド名にはデフォルト名 &lt;code&gt;f0&lt;/code&gt; 、 &lt;code&gt;f1&lt;/code&gt; などが付けられます。</target>
        </trans-unit>
        <trans-unit id="03bc9d15047b673ea201dcf5663747af818d9b11" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will use a &lt;a href=&quot;https://en.wikipedia.org/wiki/Matrix_decomposition&quot;&gt;matrix decomposition&lt;/a&gt; from linear algebra, the Singular Value Decomposition, to generate a compressed approximation of an image. We&amp;rsquo;ll use the &lt;code&gt;face&lt;/code&gt; image from the &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/misc.html#module-scipy.misc&quot;&gt;&lt;code&gt;scipy.misc&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">このチュートリアルでは、線形代数からの&lt;a href=&quot;https://en.wikipedia.org/wiki/Matrix_decomposition&quot;&gt;行列分解&lt;/a&gt;である特異値分解を使用して、画像の圧縮近似を生成します。&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/misc.html#module-scipy.misc&quot;&gt; &lt;code&gt;scipy.misc&lt;/code&gt; &lt;/a&gt;モジュールの &lt;code&gt;face&lt;/code&gt; 画像を使用します。</target>
        </trans-unit>
        <trans-unit id="7b71631798c22c7379ee16411ed600d40ef635fc" translate="yes" xml:space="preserve">
          <source>In two dimensions, the DFT is defined as</source>
          <target state="translated">2次元では、DFTは次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="e78643ae03c902815fce8ed7873dad947453bab7" translate="yes" xml:space="preserve">
          <source>In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_ macro namespace in them. That form of the constant names is deprecated in 1.7.</source>
          <target state="translated">NumPyのバージョン1.6およびそれ以前のバージョンでは、以下のフラグには_ARRAY_マクロの名前空間がありませんでした。この形式の定数名は1.7では非推奨となりました。</target>
        </trans-unit>
        <trans-unit id="2eb3748bd4c40ee385c34a340546b34ff09c6d0f" translate="yes" xml:space="preserve">
          <source>In versions of NumPy prior to 1.7, this function always returned a new, independent array containing a copy of the values in the diagonal.</source>
          <target state="translated">1.7以前のバージョンのNumPyでは,この関数は常に対角線上の値のコピーを含む独立した新しい配列を返していました.</target>
        </trans-unit>
        <trans-unit id="0dd37ad2fb32e65c87fa0dbb4334407e5e86a994" translate="yes" xml:space="preserve">
          <source>In what NumPy version the object was deprecated, and when it will be removed.</source>
          <target state="translated">どのNumPyバージョンでそのオブジェクトが非推奨になったのか、いつ削除されるのか。</target>
        </trans-unit>
        <trans-unit id="7e3012fb521e71655f173862b6d8385b1b505394" translate="yes" xml:space="preserve">
          <source>In-Place Arrays</source>
          <target state="translated">インプレース配列</target>
        </trans-unit>
        <trans-unit id="4515cac8ae9188e7e6a2adf0d7162014d11595d3" translate="yes" xml:space="preserve">
          <source>In-place arrays are defined as arrays that are modified in-place. The input values may or may not be used, but the values at the time the function returns are significant. The provided Python argument must therefore be a NumPy array of the required type. The in-place signatures are</source>
          <target state="translated">インプレース配列は、インプレースで変更される配列として定義されています。入力された値が使われても使われなくても構いませんが、関数が戻ってきた時点での値は重要です。そのため、提供されるPythonの引数は、必要な型のNumPy配列でなければなりません。インプレースのシグネチャは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="e156e5cac1a2d58a18cbdda52494e20ca1917186" translate="yes" xml:space="preserve">
          <source>In-place sort.</source>
          <target state="translated">場内ソート。</target>
        </trans-unit>
        <trans-unit id="79b98df32c7e9b7cb0e464788719f6ba70f3ff64" translate="yes" xml:space="preserve">
          <source>Incident reporting resolution &amp;amp; Code of Conduct enforcement</source>
          <target state="translated">インシデント報告の解決と行動規範の施行</target>
        </trans-unit>
        <trans-unit id="0c1195d8c8b6b9e2d6ec4d935a14c881a29bcc75" translate="yes" xml:space="preserve">
          <source>Incorrect &lt;code&gt;threshold&lt;/code&gt; in &lt;code&gt;np.set_printoptions&lt;/code&gt; raises &lt;code&gt;TypeError&lt;/code&gt; or &lt;code&gt;ValueError&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;np.set_printoptions&lt;/code&gt; の &lt;code&gt;threshold&lt;/code&gt; が正しくないと、 &lt;code&gt;TypeError&lt;/code&gt; または &lt;code&gt;ValueError&lt;/code&gt; が発生します</target>
        </trans-unit>
        <trans-unit id="2070997d3a1215cd23a07fdeb2caa1389920935f" translate="yes" xml:space="preserve">
          <source>Increased performance in &lt;code&gt;random.permutation&lt;/code&gt; for multidimensional arrays</source>
          <target state="translated">多次元配列の &lt;code&gt;random.permutation&lt;/code&gt; のパフォーマンスの向上</target>
        </trans-unit>
        <trans-unit id="e7086e912a42ead51516c8a8180bf48b02a02ed8" translate="yes" xml:space="preserve">
          <source>Incremement the index and the dataptr members of the &lt;em&gt;iterator&lt;/em&gt; to point to the next element of the array. If the array is not (C-style) contiguous, also increment the N-dimensional coordinates array.</source>
          <target state="translated">配列の次の要素を指すように&lt;em&gt;イテレータ&lt;/em&gt;のインデックスとdataptrメンバーをインクリメントします。配列が（Cスタイルの）連続していない場合は、N次元の座標配列も増分します。</target>
        </trans-unit>
        <trans-unit id="7a7d2f744a7296cdaea426008f157d69008c6d52" translate="yes" xml:space="preserve">
          <source>Increment items 0 and 1, and increment item 2 twice:</source>
          <target state="translated">項目0と1をインクリメントし、項目2を2回インクリメントします。</target>
        </trans-unit>
        <trans-unit id="aa0f6e205ff77646c8e4c26a5cd802d06b0ed1ab" translate="yes" xml:space="preserve">
          <source>Increment the multi-dimensional index by one.</source>
          <target state="translated">多次元インデックスを1つインクリメントします。</target>
        </trans-unit>
        <trans-unit id="1431536c5cec1e86a2b496f9aea15a2431b6da9a" translate="yes" xml:space="preserve">
          <source>Increment the release number in setup.py. Release candidates should have &amp;ldquo;rc1&amp;rdquo; (or &amp;ldquo;rc2&amp;rdquo;, &amp;ldquo;rcN&amp;rdquo;) appended to the X.Y.Z format.</source>
          <target state="translated">setup.pyのリリース番号をインクリメントします。リリース候補には、XYZ形式に「rc1」（または「rc2」、「rcN」）を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="47bbbc7bbd392dc811939b0ca8df290ae66b6625" translate="yes" xml:space="preserve">
          <source>Indeed, the fact is that Python indexing on lists and other sequences naturally leads to an outside-to inside ordering (the first index gets the largest grouping, the next the next largest, and the last gets the smallest element). Since image data are normally stored by rows, this corresponds to position within rows being the last item indexed.</source>
          <target state="translated">実際、リストやその他のシーケンスに対するPythonのインデックス付けは、自然にアウトサイドからインサイドへの順序付けになります(最初のインデックスは最大のグループ化、次のインデックスはその次の最大のグループ化、最後のインデックスは最小の要素を取得します)。画像データは通常行ごとに格納されるので、これは行内の位置が最後の項目のインデックスに対応します。</target>
        </trans-unit>
        <trans-unit id="a955748860a9401904eff7aeb318142866860450" translate="yes" xml:space="preserve">
          <source>Independent Streams</source>
          <target state="translated">独立したストリーム</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="9362b6e75e3f28d4a83666c8ba00890a4d410bc7" translate="yes" xml:space="preserve">
          <source>Index arrays</source>
          <target state="translated">インデックス配列</target>
        </trans-unit>
        <trans-unit id="8b7ef6cce7547dfa6d1e0bda509869536452ee0c" translate="yes" xml:space="preserve">
          <source>Index arrays may be combined with slices. For example:</source>
          <target state="translated">インデックス配列はスライスと組み合わせることができます。例えば</target>
        </trans-unit>
        <trans-unit id="c44a201623d0e3d087173369dce55b524d144281" translate="yes" xml:space="preserve">
          <source>Index arrays must be of integer type. Each value in the array indicates which value in the array to use in place of the index. To illustrate:</source>
          <target state="translated">インデックス配列は整数型でなければなりません。配列内の各値は、配列内のどの値をインデックスの代わりに使用するかを示します。説明のために、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="1a35691c6c1bb32304626e5515963a9a6c7ec2da" translate="yes" xml:space="preserve">
          <source>Index of the diagonal: 0 (the default) refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal.</source>
          <target state="translated">対角線のインデックス:0(デフォルト)は主対角線、正の値は上対角線、負の値は下対角線を指します。</target>
        </trans-unit>
        <trans-unit id="119920061dcb691e0fcbed0a1783c9e871f11ec5" translate="yes" xml:space="preserve">
          <source>Index of the diagonal: 0 refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal.</source>
          <target state="translated">対角線のインデックス:0は主対角線、正の値は上対角線、負の値は下対角線を示す。</target>
        </trans-unit>
        <trans-unit id="57f71bf775773f532dceb2dabadcde07069670df" translate="yes" xml:space="preserve">
          <source>Indexes of the maximal elements of a N-dimensional array:</source>
          <target state="translated">N次元配列の最大要素のインデックス.</target>
        </trans-unit>
        <trans-unit id="c30b085b29907fc8dd1fcc4ba9d8f5fab779ff0b" translate="yes" xml:space="preserve">
          <source>Indexes of the maximum values along an axis.</source>
          <target state="translated">軸に沿った最大値のインデックス。</target>
        </trans-unit>
        <trans-unit id="f9b599db4bf0df8d9bbcf7c5db6a037f6e6e69aa" translate="yes" xml:space="preserve">
          <source>Indexes of the minimum values along an axis.</source>
          <target state="translated">軸に沿った最小値のインデックス。</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="ca22a585bfdf222b22aaead59f3666212fc40ce0" translate="yes" xml:space="preserve">
          <source>Indexing &lt;code&gt;x['field-name']&lt;/code&gt; returns a new &lt;a href=&quot;../glossary#term-view&quot;&gt;view&lt;/a&gt; to the array, which is of the same shape as &lt;em&gt;x&lt;/em&gt; (except when the field is a sub-array) but of data type &lt;code&gt;x.dtype['field-name']&lt;/code&gt; and contains only the part of the data in the specified field. Also &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record array&lt;/a&gt; scalars can be &amp;ldquo;indexed&amp;rdquo; this way.</source>
          <target state="translated">&lt;code&gt;x['field-name']&lt;/code&gt; インデックスを付けると、配列に新しい&lt;a href=&quot;../glossary#term-view&quot;&gt;ビュー&lt;/a&gt;が返されます。これは、&lt;em&gt;x&lt;/em&gt;と同じ形状ですが（フィールドがサブ配列の場合を除く）、データ型は &lt;code&gt;x.dtype['field-name']&lt;/code&gt; 指定されたフィールドのデータの一部のみが含まれます。また、&lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;レコード配列&lt;/a&gt;スカラーは、この方法で「インデックス付け」できます。</target>
        </trans-unit>
        <trans-unit id="b59c12801d6fa741bd0be2abcd90167bf71d161c" translate="yes" xml:space="preserve">
          <source>Indexing &lt;code&gt;x['field-name']&lt;/code&gt; returns a new &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;view&lt;/a&gt; to the array, which is of the same shape as &lt;em&gt;x&lt;/em&gt; (except when the field is a sub-array) but of data type &lt;code&gt;x.dtype['field-name']&lt;/code&gt; and contains only the part of the data in the specified field. Also &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record array&lt;/a&gt; scalars can be &amp;ldquo;indexed&amp;rdquo; this way.</source>
          <target state="translated">&lt;code&gt;x['field-name']&lt;/code&gt; インデックスを付けると、配列に新しい&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;ビュー&lt;/a&gt;が返されます。これは、&lt;em&gt;x&lt;/em&gt;と同じ形状（フィールドがサブ配列の場合を除く）ですが、データ型は &lt;code&gt;x.dtype['field-name']&lt;/code&gt; 指定されたフィールドのデータの一部のみが含まれます。また、この方法で&lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;レコード配列&lt;/a&gt;スカラーに「インデックスを付ける」ことができます。</target>
        </trans-unit>
        <trans-unit id="9542b665971d159d6c17d4f34752698e601626e8" translate="yes" xml:space="preserve">
          <source>Indexing MaskedArrays/Constants with &lt;code&gt;...&lt;/code&gt; (ellipsis) now returns MaskedArray</source>
          <target state="translated">MaskedArrays / Constantsに &lt;code&gt;...&lt;/code&gt; （省略記号）でインデックスを付けると、MaskedArrayが返されるようになりました。</target>
        </trans-unit>
        <trans-unit id="a956de2c65434dac2e3f2395af98a63c09e0e921" translate="yes" xml:space="preserve">
          <source>Indexing Multi-dimensional arrays</source>
          <target state="translated">多次元配列のインデックス作成</target>
        </trans-unit>
        <trans-unit id="d29f8c2cdcd3c7159d7617a4b4b26d63a3389924" translate="yes" xml:space="preserve">
          <source>Indexing Structured Arrays</source>
          <target state="translated">構造化配列のインデックス作成</target>
        </trans-unit>
        <trans-unit id="370bbc588e0d38b8f416d5dcc2dcf3fc93d26630" translate="yes" xml:space="preserve">
          <source>Indexing a single element of a structured array (with an integer index) returns a structured scalar:</source>
          <target state="translated">構造化された配列の単一の要素(整数のインデックスを持つ)をインデックス化すると、構造化されたスカラが返されます。</target>
        </trans-unit>
        <trans-unit id="1544ebdc7ceef1dd43c207ab5e502bb881e63b2a" translate="yes" xml:space="preserve">
          <source>Indexing and Assignment to Structured arrays</source>
          <target state="translated">構造化配列へのインデックス付けと代入</target>
        </trans-unit>
        <trans-unit id="3b75e279fb5c7684c193076341ad2da99a787445" translate="yes" xml:space="preserve">
          <source>Indexing and slicing</source>
          <target state="translated">インデックス作成とスライス</target>
        </trans-unit>
        <trans-unit id="c620de8536d4e92665cc1da6338b0e3c9ccd772a" translate="yes" xml:space="preserve">
          <source>Indexing and slicing operations are useful when you&amp;rsquo;re manipulating matrices:</source>
          <target state="translated">インデックス作成とスライス操作は、行列を操作するときに役立ちます。</target>
        </trans-unit>
        <trans-unit id="9f16e8a5deb5dca320283bcd174b16dd9a73b2c2" translate="yes" xml:space="preserve">
          <source>Indexing arrays</source>
          <target state="translated">配列のインデックス作成</target>
        </trans-unit>
        <trans-unit id="32cfd79e57bf8a3877f833f091f428533e7b10d7" translate="yes" xml:space="preserve">
          <source>Indexing basics</source>
          <target state="translated">インデックス作成の基本</target>
        </trans-unit>
        <trans-unit id="43bc37d1483f275b849fa10b51ee75dd7340e249" translate="yes" xml:space="preserve">
          <source>Indexing into a structured array can also be done with a list of field names, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt;. As of NumPy 1.16 this returns a view containing only those fields. In older versions of numpy it returned a copy. See the user guide section on &lt;a href=&quot;../user/basics.rec#structured-arrays&quot;&gt;Structured arrays&lt;/a&gt; for more information on multifield indexing.</source>
          <target state="translated">構造化配列へのインデックス付けは、フィールド名のリストを使用して行うこともできます（&lt;em&gt;例：&lt;/em&gt; &lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt; 。NumPy 1.16以降、これはそれらのフィールドのみを含むビューを返します。numpyの古いバージョンでは、コピーが返されました。マルチフィールドインデックスの詳細については、&lt;a href=&quot;../user/basics.rec#structured-arrays&quot;&gt;構造化配列の&lt;/a&gt;ユーザーガイドセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="287cc46fe81b17127e826e2dc4d460f956256411" translate="yes" xml:space="preserve">
          <source>Indexing into a structured array can also be done with a list of field names, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt;. As of NumPy 1.16 this returns a view containing only those fields. In older versions of numpy it returned a copy. See the user guide section on &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#structured-arrays&quot;&gt;Structured arrays&lt;/a&gt; for more information on multifield indexing.</source>
          <target state="translated">構造化配列にインデックスは、フィールド名のリストでもを行うことができます&lt;em&gt;例えば&lt;/em&gt; &lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt; 。NumPy 1.16以降、これはそれらのフィールドのみを含むビューを返します。古いバージョンのnumpyでは、コピーを返しました。マルチフィールドインデックスの詳細については、&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#structured-arrays&quot;&gt;構造化配列の&lt;/a&gt;ユーザーガイドセクションをご覧ください。</target>
        </trans-unit>
        <trans-unit id="f9931083a6e7f53e9bc486a3df5e5e7c8488e9d6" translate="yes" xml:space="preserve">
          <source>Indexing routines</source>
          <target state="translated">インデックス作成ルーチン</target>
        </trans-unit>
        <trans-unit id="6e79a0e3c54ea0ceb91b9669283adab9f2147f0b" translate="yes" xml:space="preserve">
          <source>Indexing with Arrays of Indices</source>
          <target state="translated">インデックスの配列を使ったインデックス作成</target>
        </trans-unit>
        <trans-unit id="a5b7926d0e1062fbea55528bbcec6310b0c56043" translate="yes" xml:space="preserve">
          <source>Indexing with Boolean Arrays</source>
          <target state="translated">ブール型配列を使ったインデックス作成</target>
        </trans-unit>
        <trans-unit id="3484dfe82dee2e7bac292b6534b5cbe2647cd408" translate="yes" xml:space="preserve">
          <source>Indexing with an Integer to get a Structured Scalar</source>
          <target state="translated">整数でインデックスを作成して構造化スカラーを取得する</target>
        </trans-unit>
        <trans-unit id="090d4c4fc948bc8eed34fc6e8ddf8e7bd5be023c" translate="yes" xml:space="preserve">
          <source>Indexing with strings</source>
          <target state="translated">文字列によるインデックス作成</target>
        </trans-unit>
        <trans-unit id="2794b9b37dd0d88704ab33758cd5ea559027c74f" translate="yes" xml:space="preserve">
          <source>Indexing, Slicing and Iterating</source>
          <target state="translated">インデックス化、スライス、反復処理</target>
        </trans-unit>
        <trans-unit id="a0b6ddf08f9938b1aef1c27a89f039c34d4ed175" translate="yes" xml:space="preserve">
          <source>Indexing-like operations</source>
          <target state="translated">インデックスのような操作</target>
        </trans-unit>
        <trans-unit id="0454b105259e523f13a84d0a1ff2499fbf44bf18" translate="yes" xml:space="preserve">
          <source>Indicate how the user of the iterator will read or write to &lt;code&gt;op[i]&lt;/code&gt;. Exactly one of these flags must be specified per operand. Using &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; or &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; for a user-provided operand may trigger &lt;code&gt;WRITEBACKIFCOPY`&lt;/code&gt; semantics. The data will be written back to the original array when &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; is called.</source>
          <target state="translated">イテレータのユーザーが &lt;code&gt;op[i]&lt;/code&gt; をどのように読み書きするかを示します。これらのフラグの1つだけをオペランドごとに指定する必要があります。ユーザー指定のオペランドに &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; または &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; を使用すると、 &lt;code&gt;WRITEBACKIFCOPY`&lt;/code&gt; セマンティクスがトリガーされる場合があります。 &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; が呼び出されると、データは元の配列に書き戻されます。</target>
        </trans-unit>
        <trans-unit id="ba89764e8d83fcb18f052ec54405d196f55000ee" translate="yes" xml:space="preserve">
          <source>Indicate indices of sub-arrays to remove along the specified axis.</source>
          <target state="translated">指定された軸に沿って削除するサブ配列のインデックスを示します。</target>
        </trans-unit>
        <trans-unit id="ff289ba1c19ab34e00eb1d52160a46b6efb2713b" translate="yes" xml:space="preserve">
          <source>Indicates arrays of this data-type must be converted to a list before pickling.</source>
          <target state="translated">このデータ型の配列がピックリングの前にリストに変換されなければならないことを示します。</target>
        </trans-unit>
        <trans-unit id="327748da6a9d945d96e091b8e7383b60afba1da7" translate="yes" xml:space="preserve">
          <source>Indicates memory for this data-type must be initialized (set to 0) on creation.</source>
          <target state="translated">このデータ型のメモリが作成時に初期化(0に設定)されている必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="4bc4530525549adc3e6afe819ca6b79c82a0ab71" translate="yes" xml:space="preserve">
          <source>Indicates that arrays with a size of zero should be permitted. Since the typical iteration loop does not naturally work with zero-sized arrays, you must check that the IterSize is larger than zero before entering the iteration loop. Currently only the operands are checked, not a forced shape.</source>
          <target state="translated">サイズがゼロの配列を許可すべきであることを示します。典型的な反復ループは、当然ながらゼロサイズの配列では動作しないので、反復ループに入る前にIterSizeがゼロより大きいかどうかをチェックする必要があります。現在はオペランドのみがチェックされ、強制的な形ではありません。</target>
        </trans-unit>
        <trans-unit id="3f20ca03a166ca2b12eed667d0c9d43d498dcabe" translate="yes" xml:space="preserve">
          <source>Indicates that arrays with reference types (object arrays or structured arrays containing an object type) may be accepted and used in the iterator. If this flag is enabled, the caller must be sure to check whether &lt;code&gt;NpyIter_IterationNeedsAPI(iter)&lt;/code&gt; is true, in which case it may not release the GIL during iteration.</source>
          <target state="translated">参照型（オブジェクト配列またはオブジェクト型を含む構造化配列）を持つ配列を受け入れ、イテレーターで使用できることを示します。このフラグが有効になっている場合、呼び出し元は &lt;code&gt;NpyIter_IterationNeedsAPI(iter)&lt;/code&gt; がtrueであるかどうかを確認する必要があります。この場合、反復中にGILを解放しない可能性があります。</target>
        </trans-unit>
        <trans-unit id="e809396a40c3ec96fdae3328ed0a31c66576c7c0" translate="yes" xml:space="preserve">
          <source>Indicates that items of this data-type must be reference counted (using &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt;&lt;code&gt;Py_DECREF&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">このデータ型の項目は参照カウントされる必要があることを示します（&lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt; &lt;code&gt;Py_INCREF&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt; &lt;code&gt;Py_DECREF&lt;/code&gt; &lt;/a&gt;を使用）。</target>
        </trans-unit>
        <trans-unit id="03ad2756a493f01508378680f8d907e50dad0e86" translate="yes" xml:space="preserve">
          <source>Indicates that this operand is the mask to use for selecting elements when writing to operands which have the &lt;a href=&quot;#c.NPY_ITER_WRITEMASKED&quot;&gt;&lt;code&gt;NPY_ITER_WRITEMASKED&lt;/code&gt;&lt;/a&gt; flag applied to them. Only one operand may have &lt;a href=&quot;#c.NPY_ITER_ARRAYMASK&quot;&gt;&lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt;&lt;/a&gt; flag applied to it.</source>
          <target state="translated">このオペランドが、&lt;a href=&quot;#c.NPY_ITER_WRITEMASKED&quot;&gt; &lt;code&gt;NPY_ITER_WRITEMASKED&lt;/code&gt; &lt;/a&gt;フラグが適用されているオペランドに書き込むときに要素を選択するために使用するマスクであることを示します。1つのオペランドだけに&lt;a href=&quot;#c.NPY_ITER_ARRAYMASK&quot;&gt; &lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt; &lt;/a&gt;フラグを適用できます。</target>
        </trans-unit>
        <trans-unit id="613ac9b34fa48eda3d48ba0a932ba15f0204a86f" translate="yes" xml:space="preserve">
          <source>Indicates the item is a pointer to some other data-type</source>
          <target state="translated">項目が他のデータ型へのポインタであることを示す</target>
        </trans-unit>
        <trans-unit id="6f07bb702873a42eecec00d6bf9d09bfd0c31b06" translate="yes" xml:space="preserve">
          <source>Indicates this data-type requires the Python C-API during access (so don&amp;rsquo;t give up the GIL if array access is going to be needed).</source>
          <target state="translated">このデータ型がアクセス中にPython C-APIを必要とすることを示します（配列へのアクセスが必要になる場合はGILをあきらめないでください）。</target>
        </trans-unit>
        <trans-unit id="d5ca13d01e4aee97ba5ebf7dbc18794ab7e82eae" translate="yes" xml:space="preserve">
          <source>Indicating whether the intervals include the right or the left bin edge. Default behavior is (right==False) indicating that the interval does not include the right edge. The left bin end is open in this case, i.e., bins[i-1] &amp;lt;= x &amp;lt; bins[i] is the default behavior for monotonically increasing bins.</source>
          <target state="translated">間隔にビンの右端または左端が含まれるかどうかを示します。デフォルトの動作は（right == False）で、間隔に右端が含まれないことを示します。この場合、ビンの左端は開いています。つまり、bins [i-1] &amp;lt;= x &amp;lt;bins [i]は、単調増加するビンのデフォルトの動作です。</target>
        </trans-unit>
        <trans-unit id="ca9cfe4e704c12c6c1fa5c4b576973839a44850c" translate="yes" xml:space="preserve">
          <source>Indices can also be grouped by element.</source>
          <target state="translated">インデックスは、要素ごとにグループ化することもできます。</target>
        </trans-unit>
        <trans-unit id="14ad131012032e9e04ca04f6d1ddd8fbcaa3e2c0" translate="yes" xml:space="preserve">
          <source>Indices for the upper-triangle of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; の上三角のインデックス。</target>
        </trans-unit>
        <trans-unit id="05056f495c02c0b518e0436ff12d0703c782c034" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero.</source>
          <target state="translated">0以外の要素のインデックス。</target>
        </trans-unit>
        <trans-unit id="91841f1f82f1c15d4b5be121831bfdfa7d539a5a" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero. Indices are grouped by element.</source>
          <target state="translated">0以外の要素のインデックス。インデックスは要素ごとにグループ化されています。</target>
        </trans-unit>
        <trans-unit id="7756fd7ee8f7161ab914664d39dc9bedefea080d" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero. Indices are grouped by element. This array will have shape &lt;code&gt;(N, a.ndim)&lt;/code&gt; where &lt;code&gt;N&lt;/code&gt; is the number of non-zero items.</source>
          <target state="translated">ゼロ以外の要素のインデックス。インデックスは要素ごとにグループ化されています。この配列は形状 &lt;code&gt;(N, a.ndim)&lt;/code&gt; になります。ここで、 &lt;code&gt;N&lt;/code&gt; はゼロ以外のアイテムの数です。</target>
        </trans-unit>
        <trans-unit id="b94c56d6a6bfbdfee7bbd9db799f4cac5be86fa1" translate="yes" xml:space="preserve">
          <source>Indices of the minimum elements of a N-dimensional array:</source>
          <target state="translated">N次元配列の最小要素のインデックス.</target>
        </trans-unit>
        <trans-unit id="764406c1c2d21f5c9a93e6d3d66afbc9de92b722" translate="yes" xml:space="preserve">
          <source>Indices of the sorted elements of a N-dimensional array:</source>
          <target state="translated">N次元配列のソートされた要素のインデックス.</target>
        </trans-unit>
        <trans-unit id="d010fa85fcc511735fc1ba118d8c9fa77c46fb33" translate="yes" xml:space="preserve">
          <source>Indices to change along each 1d slice of &lt;code&gt;arr&lt;/code&gt;. This must match the dimension of arr, but dimensions in Ni and Nj may be 1 to broadcast against &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; の各1dスライスに沿って変化するインデックス。これはARRの寸法と一致しなければならないが、Niとニュージャージー州寸法は反対ブロードキャストに1であってもよい &lt;code&gt;arr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd4ed66b25e3e81f7c09020b3e15317e8ebab751" translate="yes" xml:space="preserve">
          <source>Indices to take along each 1d slice of &lt;code&gt;arr&lt;/code&gt;. This must match the dimension of arr, but dimensions Ni and Nj only need to broadcast against &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; の各1dスライスに沿ったインデックス。これはarrの次元と一致する必要がありますが、次元NiとNjは &lt;code&gt;arr&lt;/code&gt; に対してブロードキャストする必要があるだけです。</target>
        </trans-unit>
        <trans-unit id="7dfac1d76acfef8a43ec3bb5c63e278bd2c2aa5a" translate="yes" xml:space="preserve">
          <source>Indirect partial sort.</source>
          <target state="translated">間接的な部分ソート。</target>
        </trans-unit>
        <trans-unit id="67b91131b038b258475621be16da6d4bad633d9d" translate="yes" xml:space="preserve">
          <source>Indirect partition.</source>
          <target state="translated">間接的なパーティション。</target>
        </trans-unit>
        <trans-unit id="ceed8c74919b3d66cbcd799fe2d4bb252d0af6a7" translate="yes" xml:space="preserve">
          <source>Indirect sort.</source>
          <target state="translated">間接的なソート。</target>
        </trans-unit>
        <trans-unit id="7a7f09efc9fe3734b3bf1afc86adc2e542a21680" translate="yes" xml:space="preserve">
          <source>Indirect stable sort on multiple keys.</source>
          <target state="translated">複数のキーでの間接的な安定したソート</target>
        </trans-unit>
        <trans-unit id="80cc0e6eec2203fc2c38742d008a3fb864036a7b" translate="yes" xml:space="preserve">
          <source>Indirect stable sort with multiple keys.</source>
          <target state="translated">複数のキーを用いた間接的な安定ソート。</target>
        </trans-unit>
        <trans-unit id="f2d326af87bc022a272e7d1fdc4716803c23e396" translate="yes" xml:space="preserve">
          <source>Individual fields of a structured array may be accessed and modified by indexing the array with the field name.</source>
          <target state="translated">構造化された配列の個々のフィールドは、フィールド名で配列をインデックス化することで、アクセスしたり変更したりすることができます。</target>
        </trans-unit>
        <trans-unit id="8e9e048443c76eaece9af376ed6551264b94a4e9" translate="yes" xml:space="preserve">
          <source>Individual values are not stripped of spaces by default. When using a custom converter, make sure the function does remove spaces.</source>
          <target state="translated">個々の値は、デフォルトではスペースが取り除かれません。カスタムコンバータを使用する場合は、関数がスペースを削除することを確認してください。</target>
        </trans-unit>
        <trans-unit id="5888912f1820a7f863f2cf1064c7ab5b1a9a9baa" translate="yes" xml:space="preserve">
          <source>Individuals come from different cultural backgrounds and native languages. Try to identify any honest misunderstandings caused by a non-native speaker and help them understand the issue and what they can change to avoid causing offence. Complex discussion in a foreign language can be very intimidating, and we want to grow our diversity also across nationalities and cultures.</source>
          <target state="translated">人はそれぞれ異なる文化的背景や母国語を持っています。母国語を話さない人が引き起こした率直な誤解を見極め、問題を理解し、不快な思いをさせないために何を変えればよいのかを理解してもらうようにします。外国語での複雑な議論は、非常に威圧的なものですが、私たちは国籍や文化を超えて多様性を高めていきたいと考えています。</target>
        </trans-unit>
        <trans-unit id="a28ed132c608e3b4681e944b25690757eebfc33f" translate="yes" xml:space="preserve">
          <source>Inf (in module numpy)</source>
          <target state="translated">Inf (モジュールnumpy内)</target>
        </trans-unit>
        <trans-unit id="5b675f1c2537bc4e7587a11173af58141e3f3972" translate="yes" xml:space="preserve">
          <source>Infinity (in module numpy)</source>
          <target state="translated">無限大</target>
        </trans-unit>
        <trans-unit id="fbf064be21246c8a34df5396396140e055f24f53" translate="yes" xml:space="preserve">
          <source>Info are easily retrieved from the &lt;a href=&quot;distutils/misc_util#numpy.distutils.misc_util.get_info&quot;&gt;&lt;code&gt;get_info&lt;/code&gt;&lt;/a&gt; function in &lt;a href=&quot;distutils/misc_util#module-numpy.distutils.misc_util&quot;&gt;&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">情報を簡単に取得され&lt;a href=&quot;distutils/misc_util#numpy.distutils.misc_util.get_info&quot;&gt; &lt;code&gt;get_info&lt;/code&gt; &lt;/a&gt;関数&lt;a href=&quot;distutils/misc_util#module-numpy.distutils.misc_util&quot;&gt; &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="ecae1f8d30472c9a7f54d4130dc7c3b85605f125" translate="yes" xml:space="preserve">
          <source>Info are easily retrieved from the &lt;code&gt;get_info&lt;/code&gt; function in &lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt;&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">情報を簡単に取得され &lt;code&gt;get_info&lt;/code&gt; 関数&lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt; &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="ce47f6aad749dde8c374d70dfb4bb3378d690b1b" translate="yes" xml:space="preserve">
          <source>Information (via the dtype object) about the interpretation of the basic data element. The basic data element may be as simple as a int or a float, or it may be a compound object (e.g., struct-like), a fixed character field, or Python object pointers.</source>
          <target state="translated">基本データ要素の解釈に関する情報(dtypeオブジェクトを介して)。基本データ要素は int や float のような単純なものであってもよいし、複合オブジェクト (例えば struct ライクなもの)や固定文字フィールド、Python オブジェクトポインタのようなものであってもよいでしょう。</target>
        </trans-unit>
        <trans-unit id="bfbba3e12af5ea2c7741d834d66f7c560456f725" translate="yes" xml:space="preserve">
          <source>Information about sub-data-types in a &lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;構造化データ型の&lt;/a&gt;サブデータ型に関する情報：</target>
        </trans-unit>
        <trans-unit id="87749b5a0427424240dbd899baaf24bccac8d963" translate="yes" xml:space="preserve">
          <source>Information about sub-data-types in a &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;構造化データ&lt;/a&gt;タイプのサブデータタイプに関する情報：</target>
        </trans-unit>
        <trans-unit id="feb91fe9e3a82284bbc774141950eade27079231" translate="yes" xml:space="preserve">
          <source>Information about the memory layout of the array.</source>
          <target state="translated">アレイのメモリレイアウトに関する情報。</target>
        </trans-unit>
        <trans-unit id="6c6da40785b1a9277377a0ac6b35aa661e1efec5" translate="yes" xml:space="preserve">
          <source>Information may include:</source>
          <target state="translated">情報が含まれている可能性があります。</target>
        </trans-unit>
        <trans-unit id="b590718892221849c4b4d49b1a5feaa2b8ce90e3" translate="yes" xml:space="preserve">
          <source>Initialize all function pointers and members to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">すべての関数ポインターとメンバーを &lt;code&gt;NULL&lt;/code&gt; に初期化します。</target>
        </trans-unit>
        <trans-unit id="32bc5b2fd4039aefa8f94877a70e63431f9d15f4" translate="yes" xml:space="preserve">
          <source>Inner product</source>
          <target state="translated">内部製品</target>
        </trans-unit>
        <trans-unit id="1dba54e0b565dd813bcf7f4dd26137c8252036b6" translate="yes" xml:space="preserve">
          <source>Inner product of two arrays.</source>
          <target state="translated">2つの配列の内積.</target>
        </trans-unit>
        <trans-unit id="064057f93ed4cdc0c2704e960d9c6d25cbbcac22" translate="yes" xml:space="preserve">
          <source>Inplace partition.</source>
          <target state="translated">パーティションを入れ替えます。</target>
        </trans-unit>
        <trans-unit id="5afc0baf08aba247f1b2f3cdc0980c0ea2b6e83d" translate="yes" xml:space="preserve">
          <source>Inplace sort.</source>
          <target state="translated">インプレイスアウトします。</target>
        </trans-unit>
        <trans-unit id="d72a097ccb9c0003ebff6189ebb422b954b438f2" translate="yes" xml:space="preserve">
          <source>Input 1-D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">入力1次元&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80930bf11175241ae29fe59d0d272e2dd3fda246" translate="yes" xml:space="preserve">
          <source>Input &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; for which the mask is required.</source>
          <target state="translated">マスクが必要な入力&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="abfa0de453f55ea46910c5cb072561c46c566eda" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;MaskedArray&lt;/code&gt;, alternatively a ndarray or a subclass thereof.</source>
          <target state="translated">&lt;code&gt;MaskedArray&lt;/code&gt; 、またはndarrayまたはそのサブクラスを入力します。</target>
        </trans-unit>
        <trans-unit id="ef6caaf1ffac65c55e3879237f23b9e4cd5b35fe" translate="yes" xml:space="preserve">
          <source>Input Arrays</source>
          <target state="translated">入力配列</target>
        </trans-unit>
        <trans-unit id="c77783bb0c7d4d2f9b2b8bd6478b069981c0866f" translate="yes" xml:space="preserve">
          <source>Input and output</source>
          <target state="translated">入力と出力</target>
        </trans-unit>
        <trans-unit id="43fab0b785a955e5195e8f3f11f33f3ad7b432bc" translate="yes" xml:space="preserve">
          <source>Input argument, can be of any type and shape.</source>
          <target state="translated">入力引数は、任意のタイプと形状にすることができます。</target>
        </trans-unit>
        <trans-unit id="df78d5709935001a8bf74fe47ed30fca9beafae5" translate="yes" xml:space="preserve">
          <source>Input array</source>
          <target state="translated">入力配列</target>
        </trans-unit>
        <trans-unit id="d573fb86d82f5065edfc4ca49f5112f03928d672" translate="yes" xml:space="preserve">
          <source>Input array in degrees.</source>
          <target state="translated">度単位の入力配列。</target>
        </trans-unit>
        <trans-unit id="c7b020a842b9509ee12f3acbb189d43b5a5c8e2b" translate="yes" xml:space="preserve">
          <source>Input array in radians.</source>
          <target state="translated">入力配列をラジアン単位で表示します。</target>
        </trans-unit>
        <trans-unit id="f139b5d61b47039d6645fe901089b8d7348e059e" translate="yes" xml:space="preserve">
          <source>Input array of size 1.</source>
          <target state="translated">サイズ1の入力配列。</target>
        </trans-unit>
        <trans-unit id="4fabb62ebf0299b3a11dc8870c6ebb3a76ef6ff9" translate="yes" xml:space="preserve">
          <source>Input array of strings to capitalize.</source>
          <target state="translated">大文字にする文字列の入力配列。</target>
        </trans-unit>
        <trans-unit id="8088eb90e795502e434844cfa6cdf9e95d4c9437" translate="yes" xml:space="preserve">
          <source>Input array of the same size as &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; と同じサイズの入力配列。</target>
        </trans-unit>
        <trans-unit id="f46407fd3e6fc3c69904fb1af7940d31883ac983" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array, containing nan values to be ignored</source>
          <target state="translated">無視されるナノ値を含む、配列に変換可能な入力配列またはオブジェクト</target>
        </trans-unit>
        <trans-unit id="49d0fb63038b2721f65a3fb79be1b2a9aa62e9d2" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array, containing nan values to be ignored.</source>
          <target state="translated">無視されるナノ値を含む、配列に変換可能な入力配列またはオブジェクト。</target>
        </trans-unit>
        <trans-unit id="1e12f84194e4961e84959b469b0f8a65e2620351" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array.</source>
          <target state="translated">配列に変換できる入力配列またはオブジェクト。</target>
        </trans-unit>
        <trans-unit id="a14df91a899a43d15ec0d5b0ebc8a2a56f832cef" translate="yes" xml:space="preserve">
          <source>Input array to be binned. Prior to NumPy 1.10.0, this array had to be 1-dimensional, but can now have any shape.</source>
          <target state="translated">ビニングされる入力配列。NumPy 1.10.0以前では、この配列は1次元でなければなりませんでしたが、任意の形状を持つことができるようになりました。</target>
        </trans-unit>
        <trans-unit id="bf15a8f66c7dacebdd89b7241fd4d11919829ad3" translate="yes" xml:space="preserve">
          <source>Input array to compute determinants for.</source>
          <target state="translated">の行列式を計算するための入力配列.</target>
        </trans-unit>
        <trans-unit id="9eff9d201dcac2141e1679ca23a312d5c7800681" translate="yes" xml:space="preserve">
          <source>Input array to extend.</source>
          <target state="translated">拡張する入力配列。</target>
        </trans-unit>
        <trans-unit id="7e287445198fc945368949e1412f5d8cb686139f" translate="yes" xml:space="preserve">
          <source>Input array to integrate.</source>
          <target state="translated">統合するための入力配列。</target>
        </trans-unit>
        <trans-unit id="85b9cb3f5f032dd1e9e0718bbfaa4576f72e78eb" translate="yes" xml:space="preserve">
          <source>Input array whose fields must be modified.</source>
          <target state="translated">フィールドを変更しなければならない入力配列。</target>
        </trans-unit>
        <trans-unit id="42226304be73817a4e285cb433d2b7bb659c59a4" translate="yes" xml:space="preserve">
          <source>Input array with datetime or timedelta data type.</source>
          <target state="translated">datetimeまたはtimedeltaデータ型の入力配列。</target>
        </trans-unit>
        <trans-unit id="7c1847566b14607f43160463914cca58e1d1e0d6" translate="yes" xml:space="preserve">
          <source>Input array, a (subclass of) ndarray.</source>
          <target state="translated">ndarrayの(サブクラスの)入力配列。</target>
        </trans-unit>
        <trans-unit id="a4f57e9a75e6d26f7e8f35eb55623a7c6ae8a1b9" translate="yes" xml:space="preserve">
          <source>Input array, can be complex</source>
          <target state="translated">入力配列、複雑な場合があります。</target>
        </trans-unit>
        <trans-unit id="1b7a137c8182cfa54895f3372cda87fe7e3932e7" translate="yes" xml:space="preserve">
          <source>Input array, can be complex.</source>
          <target state="translated">入力配列、複雑になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="6d76cf24117a4b5288f54769d468e637657f37e2" translate="yes" xml:space="preserve">
          <source>Input array, from which the diagonals are taken.</source>
          <target state="translated">対角線が取られる入力配列.</target>
        </trans-unit>
        <trans-unit id="2204886fc1fe79484a18e95229b508e3a16d8a88" translate="yes" xml:space="preserve">
          <source>Input array, has to be a square 2-D array.</source>
          <target state="translated">入力配列は,正方形の2次元配列でなければならない.</target>
        </trans-unit>
        <trans-unit id="4e7ee35a9b27cc189fd5faf36b937d455a1aa919" translate="yes" xml:space="preserve">
          <source>Input array, must be at least 2-D.</source>
          <target state="translated">入力配列は、少なくとも2次元でなければなりません。</target>
        </trans-unit>
        <trans-unit id="b7ba46399772c3a420055c71f8f5dda1e65da7f0" translate="yes" xml:space="preserve">
          <source>Input array, taken to be real.</source>
          <target state="translated">実数であるとみなされる入力配列.</target>
        </trans-unit>
        <trans-unit id="16ca749420dd58126c1f3f4ccf95ce2fc49387c9" translate="yes" xml:space="preserve">
          <source>Input array.</source>
          <target state="translated">入力配列。</target>
        </trans-unit>
        <trans-unit id="05370e4965d51e56f1347351509792a8c2d8443c" translate="yes" xml:space="preserve">
          <source>Input array. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;x&lt;/code&gt; must be 1-D or 2-D, unless &lt;code&gt;ord&lt;/code&gt; is None. If both &lt;code&gt;axis&lt;/code&gt; and &lt;code&gt;ord&lt;/code&gt; are None, the 2-norm of &lt;code&gt;x.ravel&lt;/code&gt; will be returned.</source>
          <target state="translated">入力配列。 &lt;code&gt;axis&lt;/code&gt; がNoneの場合、 &lt;code&gt;ord&lt;/code&gt; がNoneでない限り、 &lt;code&gt;x&lt;/code&gt; は1-Dまたは2-Dである必要があります。 &lt;code&gt;axis&lt;/code&gt; と &lt;code&gt;ord&lt;/code&gt; の両方がNoneの場合、 &lt;code&gt;x.ravel&lt;/code&gt; の2ノルムが返されます。</target>
        </trans-unit>
        <trans-unit id="e22a13f0e68b42a409027fe2f016234b4ec5feb3" translate="yes" xml:space="preserve">
          <source>Input array. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;x&lt;/code&gt; must be 1-D or 2-D.</source>
          <target state="translated">入力配列。 &lt;code&gt;axis&lt;/code&gt; がNoneの場合、 &lt;code&gt;x&lt;/code&gt; は1次元または2次元でなければなりません。</target>
        </trans-unit>
        <trans-unit id="a823c846105b9c9719fbae89a64d485cac5a4b66" translate="yes" xml:space="preserve">
          <source>Input array. If &lt;code&gt;sorter&lt;/code&gt; is None, then it must be sorted in ascending order, otherwise &lt;code&gt;sorter&lt;/code&gt; must be an array of indices that sort it.</source>
          <target state="translated">入力配列。 &lt;code&gt;sorter&lt;/code&gt; がNoneの場合、昇順でソートする必要があります。それ以外の場合、 &lt;code&gt;sorter&lt;/code&gt; はそれをソートするインデックスの配列である必要があります。</target>
        </trans-unit>
        <trans-unit id="9358104d5c139fb6025e6e3c499456297f4494b9" translate="yes" xml:space="preserve">
          <source>Input array. It must conform to the Python-side of the array interface.</source>
          <target state="translated">配列を入力します。配列インターフェースのPython側に準拠している必要があります。</target>
        </trans-unit>
        <trans-unit id="6eef0d989b2fd6fdf464d508f694dc4a0a6a6caa" translate="yes" xml:space="preserve">
          <source>Input array. The elements in &lt;code&gt;a&lt;/code&gt; are read in the order specified by &lt;code&gt;order&lt;/code&gt;, and packed as a 1-D array.</source>
          <target state="translated">入力配列。 &lt;code&gt;a&lt;/code&gt; の要素は、orderで指定された &lt;code&gt;order&lt;/code&gt; で読み取られ、1次元配列としてパックされます。</target>
        </trans-unit>
        <trans-unit id="88c5aa449f45fc85917596c4004dffe23e0b86ac" translate="yes" xml:space="preserve">
          <source>Input array. Unless &lt;code&gt;axis&lt;/code&gt; is specified, this will be flattened if it is not already 1-D.</source>
          <target state="translated">入力配列。ない限り、 &lt;code&gt;axis&lt;/code&gt; 指定されている、それはすでに1-Dでない場合は、これを平坦化されます。</target>
        </trans-unit>
        <trans-unit id="c937c57a4f225878ef9dec01334ff4466710291e" translate="yes" xml:space="preserve">
          <source>Input arrays</source>
          <target state="translated">入力配列</target>
        </trans-unit>
        <trans-unit id="d4ab162cfec9e7e5f511b1323f2a38dced9855a6" translate="yes" xml:space="preserve">
          <source>Input arrays are defined as arrays of data that are passed into a routine but are not altered in-place or returned to the user. The Python input array is therefore allowed to be almost any Python sequence (such as a list) that can be converted to the requested type of array. The input array signatures are</source>
          <target state="translated">入力配列は、ルーチンに渡されたデータの配列として定義されていますが、その場で変更されたり、ユーザに返されたりすることはありません。したがって、Pythonの入力配列は、要求された型の配列に変換できるほぼすべてのPython配列(リストなど)であることが許されています。入力配列のシグネチャは</target>
        </trans-unit>
        <trans-unit id="098168471a46df6606b6ff9c9cd3ead3422de613" translate="yes" xml:space="preserve">
          <source>Input arrays of the same shape.</source>
          <target state="translated">同じ形状の配列を入力します。</target>
        </trans-unit>
        <trans-unit id="27f64d53a246ed11a85c01a61d0a931b1d50a817" translate="yes" xml:space="preserve">
          <source>Input arrays to be compared.</source>
          <target state="translated">比較対象の入力配列。</target>
        </trans-unit>
        <trans-unit id="6fed91f1bcdfc2569325e9089bbd325328b5c5e9" translate="yes" xml:space="preserve">
          <source>Input arrays to be multiplied. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">乗算する入力配列。 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状にブロードキャスト可能でなければなりません（これが出力の形状になります）。</target>
        </trans-unit>
        <trans-unit id="4a8e2cbe86fa87773992dad5fc91ec0f376d5ef6" translate="yes" xml:space="preserve">
          <source>Input arrays to compare.</source>
          <target state="translated">比較する配列を入力します。</target>
        </trans-unit>
        <trans-unit id="66d649cf79701276da2a390f23e474c6ab2aff7f" translate="yes" xml:space="preserve">
          <source>Input arrays, scalars not allowed.</source>
          <target state="translated">入力配列、スカラーは使用できません。</target>
        </trans-unit>
        <trans-unit id="556a7ea15ff0974e693ba20b38993284bf2034ec" translate="yes" xml:space="preserve">
          <source>Input arrays.</source>
          <target state="translated">入力配列。</target>
        </trans-unit>
        <trans-unit id="ad9b94d855384626461316d89dd8037bff8db7bd" translate="yes" xml:space="preserve">
          <source>Input arrays. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">入力配列。 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状にブロードキャスト可能でなければなりません（これが出力の形状になります）。</target>
        </trans-unit>
        <trans-unit id="d784452f6247a01f2c79aa8a172590665da159e0" translate="yes" xml:space="preserve">
          <source>Input arrays. They are flattened if they are not already 1D.</source>
          <target state="translated">入力配列.これらの配列は,1次元でない場合は平坦化されます.</target>
        </trans-unit>
        <trans-unit id="e48eae13547040a1f74bd1dc543d4762a4b7970d" translate="yes" xml:space="preserve">
          <source>Input arrays. Will be flattened if not already 1D.</source>
          <target state="translated">入力配列。1次元でない場合は平坦化されます。</target>
        </trans-unit>
        <trans-unit id="670ce16c58ae415abf92889322038709e2fa68ca" translate="yes" xml:space="preserve">
          <source>Input cash flows per time period. By convention, net &amp;ldquo;deposits&amp;rdquo; are negative and net &amp;ldquo;withdrawals&amp;rdquo; are positive. Thus, for example, at least the first element of &lt;code&gt;values&lt;/code&gt;, which represents the initial investment, will typically be negative.</source>
          <target state="translated">期間ごとの入力キャッシュフロー。慣例により、正味の「預金」はマイナス、正味の「引き出し」はプラスです。したがって、たとえば、初期投資を表す &lt;code&gt;values&lt;/code&gt; 少なくとも最初の要素は、通常は負になります。</target>
        </trans-unit>
        <trans-unit id="00f0d4d4fb6b101c2c16fbc5749470d99cd4de8c" translate="yes" xml:space="preserve">
          <source>Input class. If a tuple of classes, True is returned if &lt;code&gt;arg1&lt;/code&gt; is a subclass of any of the tuple elements.</source>
          <target state="translated">入力クラス。クラスのタプルの場合、 &lt;code&gt;arg1&lt;/code&gt; がタプル要素のいずれかのサブクラスであればTrueが返されます。</target>
        </trans-unit>
        <trans-unit id="2bad44bea0aeffb47c89150e3263bb8f1abd9181" translate="yes" xml:space="preserve">
          <source>Input class. True is returned if &lt;code&gt;arg1&lt;/code&gt; is a subclass of &lt;code&gt;arg2&lt;/code&gt;.</source>
          <target state="translated">入力クラス。 &lt;code&gt;arg1&lt;/code&gt; が &lt;code&gt;arg2&lt;/code&gt; のサブクラスの場合、Trueが返されます。</target>
        </trans-unit>
        <trans-unit id="56f0cc662add4c7f0901841588673883d4d29d17" translate="yes" xml:space="preserve">
          <source>Input comparison array.</source>
          <target state="translated">比較配列を入力します。</target>
        </trans-unit>
        <trans-unit id="64be30841013bc47e9c3850c4b6a7fded4a86ac4" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to a masked array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists, ndarrays and masked arrays.</source>
          <target state="translated">入力データは、マスクされた配列に変換できる任意の形式のものです。これには、リスト、タプルのリスト、タプルのリスト、タプルのリスト、リストのタプル、ndarrays、マスクされた配列が含まれます。</target>
        </trans-unit>
        <trans-unit id="81eacae9b22a55fbd594cc3dd8bc53a24b4e16f7" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array.</source>
          <target state="translated">配列に変換できる任意の形式の入力データ。</target>
        </trans-unit>
        <trans-unit id="2ed4e1316aa603c005ccf7b9b354de1cad7aa423" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists and ndarrays.</source>
          <target state="translated">配列に変換できる任意の形式の入力データ。これには、リスト、タプルのリスト、タプルのリスト、タプルのリスト、リストのタプル、NDARRAYが含まれます。</target>
        </trans-unit>
        <trans-unit id="c935f3a4d2949a1b2d5a11eb7de8a0fed4bd8dc0" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists and ndarrays. Success requires no NaNs or Infs.</source>
          <target state="translated">配列に変換できる任意の形式の入力データ。これには、リスト、タプルのリスト、タプルのリスト、タプルのリスト、リストのタプル、NDARRAYが含まれます。成功するには、NaNやInfが必要ありません。</target>
        </trans-unit>
        <trans-unit id="ebe3314c250fe9acc710492a54a53defc42ce5bf" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes scalars, lists, lists of tuples, tuples, tuples of tuples, tuples of lists, and ndarrays.</source>
          <target state="translated">配列に変換できる任意の形式の入力データ。これには、スカラー、リスト、タプルのリスト、タプルのリスト、タプルのリスト、リストのタプル、およびndarraysが含まれます。</target>
        </trans-unit>
        <trans-unit id="d430a3ba769bee8e9797da35defb2f32aa2749a3" translate="yes" xml:space="preserve">
          <source>Input data, which is flattened and set as the &lt;code&gt;k&lt;/code&gt;-th diagonal of the output.</source>
          <target state="translated">入力データ。平坦化され、出力の &lt;code&gt;k&lt;/code&gt; 番目の対角として設定されます。</target>
        </trans-unit>
        <trans-unit id="260753716624ad2077f13f38ada17a33c0f48cba" translate="yes" xml:space="preserve">
          <source>Input data.</source>
          <target state="translated">データを入力します。</target>
        </trans-unit>
        <trans-unit id="110e3a721161e503e06852d0b67d62808bcf14b0" translate="yes" xml:space="preserve">
          <source>Input data. If a string, variables in the current scope may be referenced by name.</source>
          <target state="translated">データを入力します。文字列の場合、現在のスコープ内の変数を名前で参照することができます。</target>
        </trans-unit>
        <trans-unit id="50ef3fe01b042bdbfb18f290684475887aff6e69" translate="yes" xml:space="preserve">
          <source>Input data. The histogram is computed over the flattened array.</source>
          <target state="translated">入力データ.ヒストグラムは,平坦化された配列の上で計算されます.</target>
        </trans-unit>
        <trans-unit id="479157011c9bc4b0c174d6c627dd634e47f423a6" translate="yes" xml:space="preserve">
          <source>Input datatype</source>
          <target state="translated">入力データ型</target>
        </trans-unit>
        <trans-unit id="c3661c49bb4714e36d1ea68c6778013ac4b2c966" translate="yes" xml:space="preserve">
          <source>Input masks.</source>
          <target state="translated">入力マスク。</target>
        </trans-unit>
        <trans-unit id="49c6112477838697a8b42892713d1ff818dab05e" translate="yes" xml:space="preserve">
          <source>Input must be an ndarray (or have similar attributes) for it to be considered a valid mask.</source>
          <target state="translated">有効なマスクとみなされるためには、入力は ndarray (または類似の属性)でなければなりません。</target>
        </trans-unit>
        <trans-unit id="cdda590be17222720d3dca31ac32ec20a4bd2027" translate="yes" xml:space="preserve">
          <source>Input object or name to get information about. If &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; is a numpy object, its docstring is given. If it is a string, available modules are searched for matching objects. If None, information about &lt;a href=&quot;#numpy.info&quot;&gt;&lt;code&gt;info&lt;/code&gt;&lt;/a&gt; itself is returned.</source>
          <target state="translated">情報を取得するオブジェクトまたは名前を入力します。場合は&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; numpyのオブジェクトで、そのドキュメント文字列が与えられています。文字列の場合、使用可能なモジュールで一致するオブジェクトが検索されます。Noneの場合、情報自体に関する&lt;a href=&quot;#numpy.info&quot;&gt; &lt;code&gt;info&lt;/code&gt; &lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="884c8a0c5d0944c72ee0463c3eae0abb376b5e70" translate="yes" xml:space="preserve">
          <source>Input object. This can be any object (function, class, module, &amp;hellip;).</source>
          <target state="translated">入力オブジェクト。これは任意のオブジェクト（関数、クラス、モジュールなど）にすることができます。</target>
        </trans-unit>
        <trans-unit id="5bf2f1c9ba1965ca26f274218714e854f9f8439e" translate="yes" xml:space="preserve">
          <source>Input parameters.</source>
          <target state="translated">パラメータを入力します。</target>
        </trans-unit>
        <trans-unit id="f281e3f644ef1c6e22e0e862f4156eee5c382d75" translate="yes" xml:space="preserve">
          <source>Input polynomials.</source>
          <target state="translated">多項式を入力します。</target>
        </trans-unit>
        <trans-unit id="d68cab221829e2198b605b4996fba557e5ff14b8" translate="yes" xml:space="preserve">
          <source>Input sequences.</source>
          <target state="translated">入力シーケンス。</target>
        </trans-unit>
        <trans-unit id="103b73f8b8612de7f92ed544d130aab2ccb3dead" translate="yes" xml:space="preserve">
          <source>Input value.</source>
          <target state="translated">入力値。</target>
        </trans-unit>
        <trans-unit id="cf14e71217c8a7f10324a53bd5825d3d1b8701ee" translate="yes" xml:space="preserve">
          <source>Input values</source>
          <target state="translated">入力値</target>
        </trans-unit>
        <trans-unit id="4191049318f63b6c3a85211b91a5c1cecb649bdb" translate="yes" xml:space="preserve">
          <source>Input values.</source>
          <target state="translated">入力値。</target>
        </trans-unit>
        <trans-unit id="07feb5a3916677b58c8f1860e3f940ccc64ab2f3" translate="yes" xml:space="preserve">
          <source>Input values. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">入力値。 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状にブロードキャスト可能でなければなりません（これが出力の形状になります）。</target>
        </trans-unit>
        <trans-unit id="75826edc2e28e338fe2b7ee2851bc98b65454f08" translate="yes" xml:space="preserve">
          <source>Input vector or stack of matrices.</source>
          <target state="translated">入力ベクトル,または行列のスタック.</target>
        </trans-unit>
        <trans-unit id="31df6d6470f1b56cda7e136be4be3e1c6dd63188" translate="yes" xml:space="preserve">
          <source>Input-only, in-place, argout, argoutview, and memory managed argoutview behavior.</source>
          <target state="translated">入力専用、インプレース、argout、argoutview、メモリ管理されたargoutviewの動作。</target>
        </trans-unit>
        <trans-unit id="f0c077a272f1db74eb4547826e2fa78b80131915" translate="yes" xml:space="preserve">
          <source>Inputs array.</source>
          <target state="translated">入力配列です。</target>
        </trans-unit>
        <trans-unit id="35b236db313f77f4ec031a91db5c8c986efb6cc5" translate="yes" xml:space="preserve">
          <source>Inputs arrays.</source>
          <target state="translated">入力配列です。</target>
        </trans-unit>
        <trans-unit id="b698f1874b3f648c9ca7483478e5a5187dbc4214" translate="yes" xml:space="preserve">
          <source>Insert a new axis that will appear at the &lt;code&gt;axis&lt;/code&gt; position in the expanded array shape.</source>
          <target state="translated">展開された配列図形の &lt;code&gt;axis&lt;/code&gt; 位置に表示される新しい軸を挿入します。</target>
        </trans-unit>
        <trans-unit id="af781fb10a00be46a34d9311756bc61e0afddfa8" translate="yes" xml:space="preserve">
          <source>Insert elements into an array.</source>
          <target state="translated">配列に要素を挿入します。</target>
        </trans-unit>
        <trans-unit id="62cc157d912a7ebc384c4d505230255340ab3ae0" translate="yes" xml:space="preserve">
          <source>Insert scalar into an array (scalar is cast to array&amp;rsquo;s dtype, if possible)</source>
          <target state="translated">配列にスカラーを挿入します（可能な場合、スカラーは配列のdtypeにキャストされます）</target>
        </trans-unit>
        <trans-unit id="6f263a0b1fde8fabbe156179a3331b4bc254ecbf" translate="yes" xml:space="preserve">
          <source>Insert values along the given axis before the given indices.</source>
          <target state="translated">指定されたインデックスの前に、指定された軸に沿って値を挿入します。</target>
        </trans-unit>
        <trans-unit id="6c05692f04b1e8c9bcb190b107c8a7b51796744b" translate="yes" xml:space="preserve">
          <source>Insert, remove, and combine dimensions, and resize existing ones</source>
          <target state="translated">寸法の挿入、削除、結合、既存の寸法の変更</target>
        </trans-unit>
        <trans-unit id="5ca6174fce3b04b3d69345d6264017af5ed2d820" translate="yes" xml:space="preserve">
          <source>Inserted between elements.</source>
          <target state="translated">要素間に挿入されています。</target>
        </trans-unit>
        <trans-unit id="e6afa88e6a63d5a7ba7fb743473b463e1d9a17d0" translate="yes" xml:space="preserve">
          <source>Inserting data into arrays</source>
          <target state="translated">配列へのデータの挿入</target>
        </trans-unit>
        <trans-unit id="0f2b8c85b4203c61d3146e95e582c267d771f003" translate="yes" xml:space="preserve">
          <source>Inserting directives in Fortran source</source>
          <target state="translated">Fortranソースにディレクティブを挿入する</target>
        </trans-unit>
        <trans-unit id="d078b8bceaffb54addedcd30ef388e1bc3bf477b" translate="yes" xml:space="preserve">
          <source>Inserts newlines if text is longer than &lt;code&gt;max_line_width&lt;/code&gt;. Defaults to &lt;code&gt;numpy.get_printoptions()['linewidth']&lt;/code&gt;.</source>
          <target state="translated">テキストが &lt;code&gt;max_line_width&lt;/code&gt; より長い場合、改行を挿入します。デフォルトは &lt;code&gt;numpy.get_printoptions()['linewidth']&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1e503f860ac4f65121fead950747f4fcea390ed6" translate="yes" xml:space="preserve">
          <source>Inspecting the array</source>
          <target state="translated">配列の検査</target>
        </trans-unit>
        <trans-unit id="60da80156a5d0a6bae59ac9116ec4cab69c6184c" translate="yes" xml:space="preserve">
          <source>Install git</source>
          <target state="translated">git のインストール</target>
        </trans-unit>
        <trans-unit id="b8e853cc56e81f34b9860e59d86983f00754c7d4" translate="yes" xml:space="preserve">
          <source>Installation of the new package is easy using:</source>
          <target state="translated">新しいパッケージのインストールは、これを使えば簡単にできます。</target>
        </trans-unit>
        <trans-unit id="2b894e265fdd7f5a67dff5c1fc33dcfbd31481f9" translate="yes" xml:space="preserve">
          <source>Installing NumPy</source>
          <target state="translated">NumPyのインストール</target>
        </trans-unit>
        <trans-unit id="aee4fe0a13da73153ed829e66d85c46397091399" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; subclasses are passed through as-is:</source>
          <target state="translated">&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;サブクラスのインスタンスはそのまま渡されます：</target>
        </trans-unit>
        <trans-unit id="449be076c28f2ad0824dc5cabdcb20c6b823dcf2" translate="yes" xml:space="preserve">
          <source>Instances of classes that are part of the NumPy API (for example &lt;code&gt;np.r_&lt;/code&gt;&lt;code&gt;np,c_&lt;/code&gt;, &lt;code&gt;np.index_exp&lt;/code&gt;, etc.) may require some care. To give these instances a useful docstring, we do the following:</source>
          <target state="translated">NumPy APIの一部であるクラスのインスタンス（たとえば、 &lt;code&gt;np.r_&lt;/code&gt; &lt;code&gt;np,c_&lt;/code&gt; 、 &lt;code&gt;np.index_exp&lt;/code&gt; など）には、注意が必要な場合があります。これらのインスタンスに有用なdocstringを与えるために、次のようにします。</target>
        </trans-unit>
        <trans-unit id="e39a6352ce81aec018b2a3acbf6b2a0e689c1611" translate="yes" xml:space="preserve">
          <source>Instead of plain &lt;code&gt;gdb&lt;/code&gt; you can of course use your favourite alternative debugger; run it on the python binary with arguments &lt;code&gt;runtests.py -g --python mytest.py&lt;/code&gt;.</source>
          <target state="translated">もちろん、プレーンな &lt;code&gt;gdb&lt;/code&gt; の代わりに、お気に入りの代替デバッガーを使用できます。引数 &lt;code&gt;runtests.py -g --python mytest.py&lt;/code&gt; してPythonバイナリで実行します。</target>
        </trans-unit>
        <trans-unit id="eb90e39d52c4ed3cde5408270177895a426f7a11" translate="yes" xml:space="preserve">
          <source>Instead of special method names which define behavior for Python classes, there are &amp;ldquo;function tables&amp;rdquo; which point to functions that implement the desired results. Since Python 2.2, the PyTypeObject itself has become dynamic which allows C types that can be &amp;ldquo;sub-typed &amp;ldquo;from other C-types in C, and sub-classed in Python. The children types inherit the attributes and methods from their parent(s).</source>
          <target state="translated">Pythonクラスの動作を定義する特別なメソッド名の代わりに、目的の結果を実装する関数を指す「関数テーブル」があります。Python 2.2以降、PyTypeObject自体が動的になり、Cの他のCタイプから「サブタイプ化」したり、Pythonでサブクラス化したりできるCタイプが可能になりました。子タイプは、親から属性とメソッドを継承します。</target>
        </trans-unit>
        <trans-unit id="1a76aa17748f84d4f0a3ce05629dc02de8fc5860" translate="yes" xml:space="preserve">
          <source>Instead of specifying the full covariance matrix, popular approximations include:</source>
          <target state="translated">完全な共分散行列を指定する代わりに、一般的な近似法には次のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="569af2f9677e0019350ea2c63399c035e782231b" translate="yes" xml:space="preserve">
          <source>Instead of the Python traditional &amp;lsquo;floor division&amp;rsquo;, this returns a true division. True division adjusts the output type to present the best answer, regardless of input types.</source>
          <target state="translated">Pythonの従来の「フロアディビジョン」の代わりに、これは真のディビジョンを返します。真の除算は、入力タイプに関係なく、出力タイプを調整して最良の回答を提示します。</target>
        </trans-unit>
        <trans-unit id="2a07db57033cceb88c4be20433a8c922b8ebe578" translate="yes" xml:space="preserve">
          <source>Instead of the above, you can also do:</source>
          <target state="translated">上記のようなことをするのではなくても構いません。</target>
        </trans-unit>
        <trans-unit id="50b73dbdc0cbb3f8f1706a51e59d5b72389beaee" translate="yes" xml:space="preserve">
          <source>Instead of this function &lt;code&gt;PyObject_Call(ufunc, args, kwds)&lt;/code&gt; should be used. The above function differs from this because it ignores support for non-array, or array subclasses as inputs. To ensure identical behaviour, it may be necessary to convert all inputs using &lt;code&gt;PyArray_FromAny(obj, NULL, 0, 0, NPY_ARRAY_ENSUREARRAY, NULL)&lt;/code&gt;.</source>
          <target state="translated">この関数の代わりに、 &lt;code&gt;PyObject_Call(ufunc, args, kwds)&lt;/code&gt; を使用する必要があります。上記の関数は、非配列または配列サブクラスの入力としてのサポートを無視するため、これとは異なります。同一の動作を保証するために、 &lt;code&gt;PyArray_FromAny(obj, NULL, 0, 0, NPY_ARRAY_ENSUREARRAY, NULL)&lt;/code&gt; を使用してすべての入力を変換する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="93d352d3764b7602f9edf496f491993157b0351d" translate="yes" xml:space="preserve">
          <source>Institutional Neutrality</source>
          <target state="translated">制度的中立性</target>
        </trans-unit>
        <trans-unit id="6e8f68e1ce3b53a860ea6246ace5d16aba4fb2d5" translate="yes" xml:space="preserve">
          <source>Institutional Partner benefits are:</source>
          <target state="translated">機関投資家パートナーの特典は</target>
        </trans-unit>
        <trans-unit id="36318fd5786e4e1f35ed034e1d3f5b6a4d87922c" translate="yes" xml:space="preserve">
          <source>Institutional Partners</source>
          <target state="translated">機関投資家の皆様</target>
        </trans-unit>
        <trans-unit id="228367a5efa47fc0ca88237f73f231005624c438" translate="yes" xml:space="preserve">
          <source>Institutional Partners and Funding</source>
          <target state="translated">制度上のパートナーと資金調達</target>
        </trans-unit>
        <trans-unit id="415e24116e418ab9260b5d4870a4577bbf2a9dc5" translate="yes" xml:space="preserve">
          <source>Institutions become eligible to become an Institutional Partner by employing individuals who actively contribute to The Project as part of their official duties. To state this another way, the only way for a Partner to influence the project is by actively contributing to the open development of the project, in equal terms to any other member of the community of Contributors and Council Members. Merely using Project Software in institutional context does not allow an entity to become an Institutional Partner. Financial gifts do not enable an entity to become an Institutional Partner. Once an institution becomes eligible for Institutional Partnership, the Steering Council must nominate and approve the Partnership.</source>
          <target state="translated">機関は、公務の一環として本プロジェクトに積極的に貢献する個人を雇用することで、機関パートナーになる資格を得ることができます。別の言い方をすれば、パートナーがプロジェクトに影響を与える唯一の方法は、プロジェクトのオープンな開発に積極的に貢献することであり、コントリビューターやカウンシルメンバーのコミュニティの他のメンバーと対等な条件である。プロジェクトソフトウェアを機関内で使用しているだけでは、機関パートナーになることはできない。金銭的な贈与は、機関投資家が機関投資家パートナーになることを可能にしない。機関投資家が機関投資家パートナーシップの資格を得た後は、運営協議会がパートナーシップを推薦し承認しなければなりません。</target>
        </trans-unit>
        <trans-unit id="ed58f29743f8e14b9c8e13d41e070a1cc1d1c9f5" translate="yes" xml:space="preserve">
          <source>Instructions</source>
          <target state="translated">Instructions</target>
        </trans-unit>
        <trans-unit id="987d64b35cc2b94395724f62d16f3a187b63fb14" translate="yes" xml:space="preserve">
          <source>Insufficient bit width parameter to &lt;code&gt;binary_repr&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;binary_repr&lt;/code&gt; へのビット幅パラメーターが不十分です</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="5796f99d3f819f045b29a1c73196d8c40b12d9d3" translate="yes" xml:space="preserve">
          <source>Integer (-2147483648 to 2147483647)</source>
          <target state="translated">整数(-2147483648~2147483647)</target>
        </trans-unit>
        <trans-unit id="4710e6c81ea3d854c2dc7806935816c50a107107" translate="yes" xml:space="preserve">
          <source>Integer (-32768 to 32767)</source>
          <target state="translated">整数(-32768~32767)</target>
        </trans-unit>
        <trans-unit id="d944b6a3d689ab2dee3e16b0c8d8d941fd887e9b" translate="yes" xml:space="preserve">
          <source>Integer (-9223372036854775808 to 9223372036854775807)</source>
          <target state="translated">整数(-9223372036854775808~9223372036854775807)。</target>
        </trans-unit>
        <trans-unit id="e8fe5938766ae937144b5f55575793bff2ec8f88" translate="yes" xml:space="preserve">
          <source>Integer and Void scalars are now unaffected by &lt;code&gt;np.set_string_function&lt;/code&gt;</source>
          <target state="translated">整数およびボイドスカラーは、 &lt;code&gt;np.set_string_function&lt;/code&gt; の影響を受けなくなりました。</target>
        </trans-unit>
        <trans-unit id="a61c09200238e7c60e4949f4f742cd3529f52bfd" translate="yes" xml:space="preserve">
          <source>Integer array indexing</source>
          <target state="translated">整数配列のインデキシング</target>
        </trans-unit>
        <trans-unit id="a764d9440def338d1a721af2c9bc3cf9203fd57a" translate="yes" xml:space="preserve">
          <source>Integer array indexing allows selection of arbitrary items in the array based on their &lt;em&gt;N&lt;/em&gt;-dimensional index. Each integer array represents a number of indexes into that dimension.</source>
          <target state="translated">整数配列のインデックス付けにより、&lt;em&gt;N&lt;/em&gt;次元のインデックスに基づいて配列内の任意の項目を選択できます。各整数配列は、その次元へのインデックスの数を表します。</target>
        </trans-unit>
        <trans-unit id="a46c6037b6ed3e2034603c23c6f4211c22a945c1" translate="yes" xml:space="preserve">
          <source>Integer exponents of 2. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">2の整数指数 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="a3173b86433d0db1fb5b647328822672be728221" translate="yes" xml:space="preserve">
          <source>Integer indicating how this dtype relates to the built-in dtypes.</source>
          <target state="translated">このdtypeが組み込みのdtypeとどのように関係しているかを示す整数。</target>
        </trans-unit>
        <trans-unit id="201042a920a1327277fe1dda0e55cd37046acf9f" translate="yes" xml:space="preserve">
          <source>Integer large enough to hold a pointer</source>
          <target state="translated">ポインタを保持するのに十分な大きさの整数</target>
        </trans-unit>
        <trans-unit id="c0ad68cb65f108515f3a5b364ab814f280978530" translate="yes" xml:space="preserve">
          <source>Integer performance has a similar ordering.</source>
          <target state="translated">整数の性能にも似たような順序があります。</target>
        </trans-unit>
        <trans-unit id="006c632da5c7b1582b36540c57330b631facab3d" translate="yes" xml:space="preserve">
          <source>Integer that can hold a pointer</source>
          <target state="translated">ポインタを保持できる整数</target>
        </trans-unit>
        <trans-unit id="b13be07f7abad8e811e3c73cea1a525a627e0bc2" translate="yes" xml:space="preserve">
          <source>Integer ufuncs vectorized with AVX2</source>
          <target state="translated">AVX2 でベクトル化された整数 ufuncs</target>
        </trans-unit>
        <trans-unit id="a334f0e07c1be58e6996ea133d59f4da9faac7a9" translate="yes" xml:space="preserve">
          <source>Integer used for indexing, typically the same as &lt;code&gt;ssize_t&lt;/code&gt;</source>
          <target state="translated">インデックス作成に使用される整数。通常は &lt;code&gt;ssize_t&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="654f37af768fdf3bb70ca69e758a2fe80f1abf09" translate="yes" xml:space="preserve">
          <source>Integers:</source>
          <target state="translated">Integers:</target>
        </trans-unit>
        <trans-unit id="84cede945b07b48bcb97421b3eb8bd4f5bd269e0" translate="yes" xml:space="preserve">
          <source>Integral part of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の整数部分。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="1ea3c0d26d1c5d1b53eb099b2c1cf7972b99ebe8" translate="yes" xml:space="preserve">
          <source>Integrate &lt;code&gt;y&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) along given axis.</source>
          <target state="translated">指定された軸に沿って &lt;code&gt;y&lt;/code&gt; （ &lt;code&gt;x&lt;/code&gt; ）を積分します。</target>
        </trans-unit>
        <trans-unit id="cc54f713576053888447a5aa6f2b6660db759e79" translate="yes" xml:space="preserve">
          <source>Integrate a Chebyshev series.</source>
          <target state="translated">チェビシェフ級数を統合します。</target>
        </trans-unit>
        <trans-unit id="f7e0820ca3cf5b80cf75499d63a15279548b4395" translate="yes" xml:space="preserve">
          <source>Integrate a Hermite series.</source>
          <target state="translated">ハーミットシリーズを統合します。</target>
        </trans-unit>
        <trans-unit id="09cdc33ab9232f32b3ffa23eec0555fd0aad884d" translate="yes" xml:space="preserve">
          <source>Integrate a Hermite_e series.</source>
          <target state="translated">Hermite_eシリーズを統合します。</target>
        </trans-unit>
        <trans-unit id="28e01e90e39bcd5c5a200d36b330a9fb8a0cc2c8" translate="yes" xml:space="preserve">
          <source>Integrate a Laguerre series.</source>
          <target state="translated">ラゲールシリーズに統合。</target>
        </trans-unit>
        <trans-unit id="e45d1046a79d8f27551599eaeb79cbfa5c322286" translate="yes" xml:space="preserve">
          <source>Integrate a Legendre series.</source>
          <target state="translated">レジェンドレシリーズに統合する。</target>
        </trans-unit>
        <trans-unit id="51617b9fadb594aa47fc197fa4afb1a0d12a97e3" translate="yes" xml:space="preserve">
          <source>Integrate a polynomial.</source>
          <target state="translated">多項式を積分します。</target>
        </trans-unit>
        <trans-unit id="1b28e42d25bb1781655bdbd732badc274759c37c" translate="yes" xml:space="preserve">
          <source>Integrate along the given axis using the composite trapezoidal rule.</source>
          <target state="translated">複合台形ルールを使って、与えられた軸に沿って積分します。</target>
        </trans-unit>
        <trans-unit id="f6bc7be2c5b5072601573fb92ccbc047dff88160" translate="yes" xml:space="preserve">
          <source>Integrate.</source>
          <target state="translated">Integrate.</target>
        </trans-unit>
        <trans-unit id="a77970f26b3a19856dc6d676e2149a78243716b5" translate="yes" xml:space="preserve">
          <source>Integrated squared error (ISE) estimator added to &lt;code&gt;histogram&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;histogram&lt;/code&gt; 追加された統合二乗誤差（ISE）推定量</target>
        </trans-unit>
        <trans-unit id="24640b86177ce52879242a4e3855fb7330a6f367" translate="yes" xml:space="preserve">
          <source>Integration constant(s). The value of the first integral at &lt;code&gt;lbnd&lt;/code&gt; is the first value in the list, the value of the second integral at &lt;code&gt;lbnd&lt;/code&gt; is the second value, etc. If &lt;code&gt;k == []&lt;/code&gt; (the default), all constants are set to zero. If &lt;code&gt;m == 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">積分定数。 &lt;code&gt;lbnd&lt;/code&gt; での最初の積分の値はリストの最初の値で、 &lt;code&gt;lbnd&lt;/code&gt; での2番目の積分の値は2番目の値です &lt;code&gt;k == []&lt;/code&gt; （デフォルト）の場合、すべての定数はゼロに設定されます。 &lt;code&gt;m == 1&lt;/code&gt; 場合、リストの代わりに単一のスカラーを指定できます。</target>
        </trans-unit>
        <trans-unit id="faa7aa2d13f47c8dc8e8d870349e9f9bbf12fee6" translate="yes" xml:space="preserve">
          <source>Integration constant(s). The value of the first integral at zero is the first value in the list, the value of the second integral at zero is the second value, etc. If &lt;code&gt;k == []&lt;/code&gt; (the default), all constants are set to zero. If &lt;code&gt;m == 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">積分定数。ゼロでの最初の積分の値はリストの最初の値、ゼロでの2番目の積分の値は2番目の値などです &lt;code&gt;k == []&lt;/code&gt; （デフォルト）の場合、すべての定数はゼロに設定されます。 &lt;code&gt;m == 1&lt;/code&gt; 場合、リストの代わりに単一のスカラーを指定できます。</target>
        </trans-unit>
        <trans-unit id="79199da79d91b1fb5aeec3ae95134c32578dd203" translate="yes" xml:space="preserve">
          <source>Integration constants. The first constant is applied to the first integration, the second to the second, and so on. The list of values must less than or equal to &lt;code&gt;m&lt;/code&gt; in length and any missing values are set to zero.</source>
          <target state="translated">積分定数。最初の定数は最初の積分に適用され、2番目の定数は2番目の積分に適用されます。値のリストの長さは &lt;code&gt;m&lt;/code&gt; 以下でなければならず、欠落している値はすべてゼロに設定されます。</target>
        </trans-unit>
        <trans-unit id="99a973b23f26b788591e237471230a61bc42bfca" translate="yes" xml:space="preserve">
          <source>Integration constants. They are given in the order of integration: those corresponding to highest-order terms come first.</source>
          <target state="translated">積分定数.これらは積分の順に与えられます:最高次の項に対応するものが最初に来ます。</target>
        </trans-unit>
        <trans-unit id="f1b63b1b837d115daafc12c34b184fde445bf116" translate="yes" xml:space="preserve">
          <source>Integration of array values using the composite trapezoidal rule.</source>
          <target state="translated">複合台形ルールを用いた配列値の統合</target>
        </trans-unit>
        <trans-unit id="272bd8e11d9a2557b005814cbc8295b6bce05913" translate="yes" xml:space="preserve">
          <source>Interaction with &lt;code&gt;scipy.sparse&lt;/code&gt; is a bit cleaner.</source>
          <target state="translated">&lt;code&gt;scipy.sparse&lt;/code&gt; との相互作用は少しクリーンです。</target>
        </trans-unit>
        <trans-unit id="cf5308846512dd05b3fe349862b884d3dad34184" translate="yes" xml:space="preserve">
          <source>Interchange two axes of an array.</source>
          <target state="translated">配列の2軸を交換します。</target>
        </trans-unit>
        <trans-unit id="487fafdb343a2fa07aa1e904de9985413e377451" translate="yes" xml:space="preserve">
          <source>Interest paid against the loan changes during the life or the loan. The &lt;code&gt;per&lt;/code&gt; is the payment period to calculate the interest amount.</source>
          <target state="translated">ローンに対して支払われる利子は、生涯またはローンの間に変化します。 &lt;code&gt;per&lt;/code&gt; 利息額を計算するための支払期間です。</target>
        </trans-unit>
        <trans-unit id="94a1603aa26be2dbffaf8cf5c3954f0266df1988" translate="yes" xml:space="preserve">
          <source>Interest portion of payment. If all input is scalar, returns a scalar float. If any input is array_like, returns interest payment for each input element. If multiple inputs are array_like, they all must have the same shape.</source>
          <target state="translated">支払いの利息部分。すべての入力がスカラの場合、スカラのfloatを返します。いずれかの入力がarray_likeの場合は、各入力要素の支払利息を返します。複数の入力が array_like の場合、それらはすべて同じ形をしていなければなりません。</target>
        </trans-unit>
        <trans-unit id="fae2c1a639317094eef5fc0747acae252e47559d" translate="yes" xml:space="preserve">
          <source>Interest rate paid on the cash flows</source>
          <target state="translated">キャッシュ・フロー計算書の利息の支払額</target>
        </trans-unit>
        <trans-unit id="bac9f8f12cdd23938b9506adf721b640d1387b0f" translate="yes" xml:space="preserve">
          <source>Interest rate received on the cash flows upon reinvestment</source>
          <target state="translated">キャッシュ・フローの再投資に伴う受取利子率</target>
        </trans-unit>
        <trans-unit id="acbc7801b292b22fd84bb969c2c0f9ee879becf9" translate="yes" xml:space="preserve">
          <source>Interfacing to C</source>
          <target state="translated">Cとのインターフェース</target>
        </trans-unit>
        <trans-unit id="5669f1ef998cb57e98a6c7c64ced935f3a20e1ba" translate="yes" xml:space="preserve">
          <source>Interfacing to C++:</source>
          <target state="translated">C++とのインターフェイス。</target>
        </trans-unit>
        <trans-unit id="0ef0659c2c669af8efd19f667b98f55614307e8e" translate="yes" xml:space="preserve">
          <source>Interfacing to Fortran:</source>
          <target state="translated">Fortranとのインターフェイス。</target>
        </trans-unit>
        <trans-unit id="5a1eb29a8757da9ba26cf2dfef44ad676331c673" translate="yes" xml:space="preserve">
          <source>Internal Flexibility</source>
          <target state="translated">内部の柔軟性</target>
        </trans-unit>
        <trans-unit id="ac2251ff80e959c9a76b1d8e25426050ad978681" translate="yes" xml:space="preserve">
          <source>Internal Rate of Return for periodic input values.</source>
          <target state="translated">周期的な入力値の内部収益率。</target>
        </trans-unit>
        <trans-unit id="70e52d12f616579455cc3db6303a1fc61cf8ea38" translate="yes" xml:space="preserve">
          <source>Internal changes</source>
          <target state="translated">内部変更</target>
        </trans-unit>
        <trans-unit id="811920182b71e4d6c39f62829f0533afa24b5bfb" translate="yes" xml:space="preserve">
          <source>Internal functions</source>
          <target state="translated">内部機能</target>
        </trans-unit>
        <trans-unit id="ecdbace78f65adf7ab79aea820093f0235b38c83" translate="yes" xml:space="preserve">
          <source>Internal memory layout of an ndarray</source>
          <target state="translated">ndarrayの内部メモリレイアウト</target>
        </trans-unit>
        <trans-unit id="4c771d77fd8a74b74dbd14733dbe89a221191139" translate="yes" xml:space="preserve">
          <source>Internal organization of numpy arrays</source>
          <target state="translated">numpy配列の内部構成</target>
        </trans-unit>
        <trans-unit id="8693ac81d62075b90be2f5012ceac7d5e0960c71" translate="yes" xml:space="preserve">
          <source>Internally used structures</source>
          <target state="translated">内部使用構造</target>
        </trans-unit>
        <trans-unit id="353f9272117a257bd48156e257afe86724ce335c" translate="yes" xml:space="preserve">
          <source>Internally, buffers are used for misaligned data, swapped data, and data that has to be converted from one data type to another. The size of internal buffers is settable on a per-thread basis. There can be up to</source>
          <target state="translated">内部的には、バッファは、位置ずれしたデータ、スワップされたデータ、あるデータタイプから別のデータタイプに変換する必要があるデータのために使用されます。内部バッファのサイズはスレッドごとに設定可能です。最大で</target>
        </trans-unit>
        <trans-unit id="0b9562a5febab6388bcaad8af8913734a30e5c69" translate="yes" xml:space="preserve">
          <source>Internally, the code uses some additional Python objects primarily for memory management. These types are not accessible directly from Python, and are not exposed to the C-API. They are included here only for completeness and assistance in understanding the code.</source>
          <target state="translated">内部的には、コードは主にメモリ管理のためにいくつかの追加の Python オブジェクトを使用しています。これらの型は Python から直接アクセスできず、C-API にも公開されていません。これらのオブジェクトは、コードの完全性と理解を助けるためだけにここに含まれています。</target>
        </trans-unit>
        <trans-unit id="88c585f236f03e4d85467407665675347bdfa2c1" translate="yes" xml:space="preserve">
          <source>Internally, these #defines work as follows:</source>
          <target state="translated">内部的には、これらの#defineは以下のように動作します。</target>
        </trans-unit>
        <trans-unit id="2e02d69fdcfa7dd47d4e20a9c3718e372f145dcc" translate="yes" xml:space="preserve">
          <source>Interoperability-Related Options</source>
          <target state="translated">相互運用性関連オプション</target>
        </trans-unit>
        <trans-unit id="b400cd2b32800b89445114d966c1ee1e1e2f5b22" translate="yes" xml:space="preserve">
          <source>Interpolate a function at the Chebyshev points of the first kind.</source>
          <target state="translated">第1種のチェビシェフ点で関数を補間します。</target>
        </trans-unit>
        <trans-unit id="b0124a6fa4961521e8ff39aa6c372018194a4ebf" translate="yes" xml:space="preserve">
          <source>Interpolating Chebyshev instance.</source>
          <target state="translated">チェビシェフのインスタンスを補間する。</target>
        </trans-unit>
        <trans-unit id="1427e61ed742cbf9aa91a5c0cf7909917aab75eb" translate="yes" xml:space="preserve">
          <source>Interpolation with periodic x-coordinates:</source>
          <target state="translated">周期的なX座標を用いた補間。</target>
        </trans-unit>
        <trans-unit id="437831e765e33b0f2fa769dfde52d2c581b5cfbf" translate="yes" xml:space="preserve">
          <source>Interpret a buffer as a 1-dimensional array.</source>
          <target state="translated">バッファを1次元の配列として解釈します。</target>
        </trans-unit>
        <trans-unit id="9feed02e3d661ed814b67ed529ab9195e31b0cb4" translate="yes" xml:space="preserve">
          <source>Interpret the input as a matrix.</source>
          <target state="translated">入力を行列として解釈します。</target>
        </trans-unit>
        <trans-unit id="a0422cc647bba954b177a29fbf1305b2895860e3" translate="yes" xml:space="preserve">
          <source>Interrupt Handling</source>
          <target state="translated">割り込み処理</target>
        </trans-unit>
        <trans-unit id="e5f5d0f73f8dc2d6363a75fe32ba76d7d8dff9cc" translate="yes" xml:space="preserve">
          <source>Intrinsic NumPy Array Creation</source>
          <target state="translated">本質的なNumPy配列の作成</target>
        </trans-unit>
        <trans-unit id="7e2ea7ccd882296e2e16cdecb01f04008d30cfc7" translate="yes" xml:space="preserve">
          <source>Intrinsic numpy array creation objects (e.g., arange, ones, zeros, etc.)</source>
          <target state="translated">本質的なnumpy配列作成オブジェクト(アレンジ、1、ゼロなど)。</target>
        </trans-unit>
        <trans-unit id="dcd3fd94e72c882e4eaa006cb5da780542c07011" translate="yes" xml:space="preserve">
          <source>Introduce yourself to Git:</source>
          <target state="translated">Gitの自己紹介をします。</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="b6ab6d57043280ab296716031275867d148d3ca7" translate="yes" xml:space="preserve">
          <source>Introduction to byte ordering and ndarrays</source>
          <target state="translated">バイトオーダーとNDARRAYの紹介</target>
        </trans-unit>
        <trans-unit id="24583ffa86b443c7a55325e4b25e34083f63ac92" translate="yes" xml:space="preserve">
          <source>Invalid arguments for array ordering</source>
          <target state="translated">配列の順序付けのための無効な引数</target>
        </trans-unit>
        <trans-unit id="46dbc8721ef190eab06879ef282ac69a2d11056b" translate="yes" xml:space="preserve">
          <source>Invalid data means values of &lt;code&gt;nan&lt;/code&gt;, &lt;code&gt;inf&lt;/code&gt;, etc.</source>
          <target state="translated">無効なデータは、 &lt;code&gt;nan&lt;/code&gt; 、 &lt;code&gt;inf&lt;/code&gt; などの値を意味します。</target>
        </trans-unit>
        <trans-unit id="b66a9668314f5851a31b3926b89142340d67c1e0" translate="yes" xml:space="preserve">
          <source>Invalid fill value exceptions</source>
          <target state="translated">無効な塗りつぶし値の例外</target>
        </trans-unit>
        <trans-unit id="6dd811ad3cf2203333b0468d5361ce3f92b716aa" translate="yes" xml:space="preserve">
          <source>Invalid operation: result is not an expressible number, typically indicates that a NaN was produced.</source>
          <target state="translated">無効な操作:結果が表現可能な数値ではなく、通常は NaN が生成されたことを示します。</target>
        </trans-unit>
        <trans-unit id="dfed6b5bd73798f6efbc4f77cde7ac568bd5cdfb" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic cosine, element-wise.</source>
          <target state="translated">逆双曲余弦、要素法。</target>
        </trans-unit>
        <trans-unit id="21de990f2f734fbb43aa31870f6cebb10139a34e" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic sine element-wise.</source>
          <target state="translated">逆双曲線正弦波を要素ごとに</target>
        </trans-unit>
        <trans-unit id="ae6bb16d1805cc3ebef5cfaf633f1f868061a8dc" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic tangent element-wise.</source>
          <target state="translated">要素間逆双曲正接。</target>
        </trans-unit>
        <trans-unit id="2c6d3ed37e9c36a516eafee4d6cf6bce8fa583e5" translate="yes" xml:space="preserve">
          <source>Inverse sine, element-wise.</source>
          <target state="translated">逆サイン、要素ごとに</target>
        </trans-unit>
        <trans-unit id="9b049bc33b3f3b47e868bbdc217dc4db5fb5be2d" translate="yes" xml:space="preserve">
          <source>Inverses of several matrices can be computed at once:</source>
          <target state="translated">複数の行列の逆数を一度に計算することができます。</target>
        </trans-unit>
        <trans-unit id="bafff722f42fe9db3b595ab6ea0bb84953a6e8ad" translate="yes" xml:space="preserve">
          <source>Investigate. Change directory to your new repo: &lt;code&gt;cd numpy&lt;/code&gt;. Then &lt;code&gt;git branch -a&lt;/code&gt; to show you all branches. You&amp;rsquo;ll get something like:</source>
          <target state="translated">調査します。ディレクトリを新しいリポジトリに変更します： &lt;code&gt;cd numpy&lt;/code&gt; 。次に、 &lt;code&gt;git branch -a&lt;/code&gt; を実行して、すべてのブランチを表示します。次のようなものが表示されます。</target>
        </trans-unit>
        <trans-unit id="525b73c1bc26402f8fe2106a7fc0623195c4b729" translate="yes" xml:space="preserve">
          <source>Is equivalent to &lt;code&gt;np.delete(arr, [0,2,4], axis=0)&lt;/code&gt;, but allows further use of &lt;code&gt;mask&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;np.delete(arr, [0,2,4], axis=0)&lt;/code&gt; と同等ですが、さらに &lt;code&gt;mask&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="24c5caf7c1723177101292b0ec91f3f69f7573df" translate="yes" xml:space="preserve">
          <source>Is straightforward to reverse engineer. Datasets often live longer than the programs that created them. A competent developer should be able to create a solution in their preferred programming language to read most &lt;code&gt;.npy&lt;/code&gt; files that he has been given without much documentation.</source>
          <target state="translated">リバースエンジニアリングは簡単です。データセットは多くの場合、それを作成したプログラムよりも長く存続します。有能な開発者は、多くのドキュメントなしで与えられたほとんどの &lt;code&gt;.npy&lt;/code&gt; ファイルを読み取るために、好みのプログラミング言語でソリューションを作成できるはずです。</target>
        </trans-unit>
        <trans-unit id="1a81d4101d801108adb8aad8206475022e2e35b0" translate="yes" xml:space="preserve">
          <source>Is the given function something that we know how to overload?</source>
          <target state="translated">与えられた関数は、私たちがオーバーロードする方法を知っているものなのでしょうか?</target>
        </trans-unit>
        <trans-unit id="b10180fbee8cac98fb1ea7940ed518f48a70dee3" translate="yes" xml:space="preserve">
          <source>Issued by &lt;a href=&quot;generated/numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt; when the Vandermonde matrix is rank deficient.</source>
          <target state="translated">Vandermonde行列がランク不足のときに&lt;a href=&quot;generated/numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; &lt;/a&gt;によって発行されます。</target>
        </trans-unit>
        <trans-unit id="2c7da8ef717a7e944f5132cdc9e7ea084630c1b8" translate="yes" xml:space="preserve">
          <source>Issued by &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt; when the Vandermonde matrix is rank deficient.</source>
          <target state="translated">Vandermonde行列がランク不足のときに&lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; &lt;/a&gt;によって発行されます。</target>
        </trans-unit>
        <trans-unit id="62ecce1ee2f04057e107579d5bef99ec7e6758b0" translate="yes" xml:space="preserve">
          <source>Issued by chebfit when the design matrix is rank deficient.</source>
          <target state="translated">デザインマトリクスのランクが不足している場合に chebfit によって発行されます。</target>
        </trans-unit>
        <trans-unit id="ed3a53b09f923a24c6dd04195732883fc05144f5" translate="yes" xml:space="preserve">
          <source>Issued by the generic Poly class when two domains don&amp;rsquo;t match.</source>
          <target state="translated">2つのドメインが一致しない場合に、汎用のPolyクラスによって発行されます。</target>
        </trans-unit>
        <trans-unit id="f00ecef77fb41ae5e26098e89f064e811f1d6ae9" translate="yes" xml:space="preserve">
          <source>Issues Fixed</source>
          <target state="translated">修正された問題</target>
        </trans-unit>
        <trans-unit id="b19e94cfda274542200371fca470c64546558300" translate="yes" xml:space="preserve">
          <source>Issues a DeprecationWarning, adds warning to &lt;code&gt;old_name&lt;/code&gt;&amp;rsquo;s docstring, rebinds &lt;code&gt;old_name.__name__&lt;/code&gt; and returns the new function object.</source>
          <target state="translated">DeprecationWarningを発行し、 &lt;code&gt;old_name&lt;/code&gt; のdocstringに警告を追加し、 &lt;code&gt;old_name.__name__&lt;/code&gt; して、新しい関数オブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="9ddf288870dda342df98b4b9313d3dcfea4defcb" translate="yes" xml:space="preserve">
          <source>Issues fixed</source>
          <target state="translated">問題の修正</target>
        </trans-unit>
        <trans-unit id="dee1de34f5e6dfdd4c0e68ce69b1f31528f724f6" translate="yes" xml:space="preserve">
          <source>It can also be used in places of &lt;a href=&quot;numpy.atleast_1d#numpy.atleast_1d&quot;&gt;&lt;code&gt;atleast_1d&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.atleast_2d#numpy.atleast_2d&quot;&gt;&lt;code&gt;atleast_2d&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;numpy.atleast_1d#numpy.atleast_1d&quot;&gt; &lt;code&gt;atleast_1d&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;numpy.atleast_2d#numpy.atleast_2d&quot;&gt; &lt;code&gt;atleast_2d&lt;/code&gt; の&lt;/a&gt;場所でも使用できます</target>
        </trans-unit>
        <trans-unit id="378d5136b02c66ae2366b0871c9dc87a59e458eb" translate="yes" xml:space="preserve">
          <source>It can be considered as a generalization of EPS: &lt;code&gt;spacing(np.float64(1)) == np.finfo(np.float64).eps&lt;/code&gt;, and there should not be any representable number between &lt;code&gt;x + spacing(x)&lt;/code&gt; and x for any finite x.</source>
          <target state="translated">これはEPSの一般化と見なすことができます： &lt;code&gt;spacing(np.float64(1)) == np.finfo(np.float64).eps&lt;/code&gt; であり、 &lt;code&gt;x + spacing(x)&lt;/code&gt; とxの間に表現可能な数があってはなりません任意の有限x。</target>
        </trans-unit>
        <trans-unit id="1ef0650f598bd8c46d6488dc9e1ecf7f36a57c12" translate="yes" xml:space="preserve">
          <source>It can be shown that a convolution</source>
          <target state="translated">畳み込みが</target>
        </trans-unit>
        <trans-unit id="3a39f7205319edd1c303f4671f99c8c35d8b49e6" translate="yes" xml:space="preserve">
          <source>It can be shown that if</source>
          <target state="translated">の場合は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="6680413ecf8178af7a6bc1c7bc275bc8809885e1" translate="yes" xml:space="preserve">
          <source>It differs from the forward transform by the sign of the exponential argument and the default normalization by</source>
          <target state="translated">指数引数の符号と、デフォルトの正規化である</target>
        </trans-unit>
        <trans-unit id="d2a43fea3528f404f8930330d870fe7079aa62c4" translate="yes" xml:space="preserve">
          <source>It does &lt;em&gt;not&lt;/em&gt; generally hold that &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; for C-style contiguous arrays or &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; for Fortran-style contiguous arrays is true.</source>
          <target state="translated">一般に、Cスタイルの連続配列の &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; 、またはFortranスタイルの連続配列の &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; がtrueであるとは見なされませ&lt;em&gt;ん&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="47be37fff5f8f22af765f82be2c6bfbaf9c3032a" translate="yes" xml:space="preserve">
          <source>It has the following structure:</source>
          <target state="translated">以下のような構造になっています。</target>
        </trans-unit>
        <trans-unit id="9d66b7021aa904bae4cfae41aeb4ea6450db47e9" translate="yes" xml:space="preserve">
          <source>It has the probability density function</source>
          <target state="translated">確率密度関数を持っています。</target>
        </trans-unit>
        <trans-unit id="8df067c80d1dbac7caebbaa192d51d71072198f4" translate="yes" xml:space="preserve">
          <source>It helps to understand a bit about how numpy arrays are handled under the covers to help understand numpy better. This section will not go into great detail. Those wishing to understand the full details are referred to Travis Oliphant&amp;rsquo;s book &amp;ldquo;Guide to NumPy&amp;rdquo;.</source>
          <target state="translated">numpyをより深く理解するために、numpy配列が内部でどのように処理されるかについて少し理解するのに役立ちます。このセクションでは、詳細については説明しません。完全な詳細を理解したい人は、Travis Oliphantの本「Guide to NumPy」を参照してください。</target>
        </trans-unit>
        <trans-unit id="2fbb89405ce29cc8160fa307e221950fa152cd3e" translate="yes" xml:space="preserve">
          <source>It is also possible to select more than one item at a time, using &lt;em&gt;slicing&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;スライス&lt;/em&gt;を使用して、一度に複数のアイテムを選択することもできます。</target>
        </trans-unit>
        <trans-unit id="c6785902c796379d2b6f1ca680d1350c037d297a" translate="yes" xml:space="preserve">
          <source>It is an error to have index values out of bounds:</source>
          <target state="translated">インデックス値が範囲外になるのはエラーです。</target>
        </trans-unit>
        <trans-unit id="9bd3e350ace36c053f4770c254bc8bbc0ed59492" translate="yes" xml:space="preserve">
          <source>It is assumed that all indices of &lt;code&gt;x&lt;/code&gt; are summed over in the product, together with the rightmost indices of &lt;code&gt;a&lt;/code&gt;, as is done in, for example, &lt;code&gt;tensordot(a, x, axes=b.ndim)&lt;/code&gt;.</source>
          <target state="translated">すべてのインデックスと仮定する &lt;code&gt;x&lt;/code&gt; は一緒の右端のインデックスと、製品に上加算されるように行われ、例えば、 &lt;code&gt;tensordot(a, x, axes=b.ndim)&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58008c74c97fe4d3ae3f9ae78ab47043dddec099" translate="yes" xml:space="preserve">
          <source>It is available from:</source>
          <target state="translated">から入手できます。</target>
        </trans-unit>
        <trans-unit id="ca7dcbab26b74b24d5b23e3d1dfbaa7bb550a61f" translate="yes" xml:space="preserve">
          <source>It is convenient to use &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; objects for dealing with polynomials:</source>
          <target state="translated">多項式を処理するには、&lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt; &lt;code&gt;poly1d&lt;/code&gt; &lt;/a&gt;オブジェクトを使用すると便利です。</target>
        </trans-unit>
        <trans-unit id="ee3d89b7c311757a10611a623afead7359a99d73" translate="yes" xml:space="preserve">
          <source>It is convenient to use &lt;code&gt;poly1d&lt;/code&gt; objects for dealing with polynomials:</source>
          <target state="translated">多項式を処理するには、 &lt;code&gt;poly1d&lt;/code&gt; オブジェクトを使用すると便利です。</target>
        </trans-unit>
        <trans-unit id="f0b5d505c1b6aa0449adcda591bae28c54d28b79" translate="yes" xml:space="preserve">
          <source>It is difficult to distribute an extension module made using ctypes because of a lack of support for building shared libraries in distutils (but I suspect this will change in time).</source>
          <target state="translated">distutilsでは共有ライブラリの構築がサポートされていないため、ctypesを使って作られた拡張モジュールを配布するのは難しいです(しかし、これはそのうち変わるのではないかと推測しています)。</target>
        </trans-unit>
        <trans-unit id="f6233db9ea353c629e411da73701b45f43b34d4b" translate="yes" xml:space="preserve">
          <source>It is easy to lose a clean separation between Python and C which makes re-using your C-code for other non-Python-related projects more difficult.</source>
          <target state="translated">PythonとCの間のきれいな分離を失うことは容易で、Cコードを他の非Python関連のプロジェクトで再利用することはより困難になります。</target>
        </trans-unit>
        <trans-unit id="09772c45572066c0ab1839c5da61b341c459c08d" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;reshape(-1, order=order)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;reshape(-1, order=order)&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="8649182deb90f9e5b82c97ccd124c9f5e91bbefa" translate="yes" xml:space="preserve">
          <source>It is expected that function &lt;code&gt;func&lt;/code&gt; has been defined externally. In order to use a Python function as &lt;code&gt;func&lt;/code&gt;, it must have an attribute &lt;code&gt;intent(callback)&lt;/code&gt; (it must be specified before the &lt;code&gt;external&lt;/code&gt; statement).</source>
          <target state="translated">関数 &lt;code&gt;func&lt;/code&gt; は外部で定義されていることが期待されます。Python関数を &lt;code&gt;func&lt;/code&gt; として使用するには、属性 &lt;code&gt;intent(callback)&lt;/code&gt; が必要です（ &lt;code&gt;external&lt;/code&gt; ステートメントの前に指定する必要があります）。</target>
        </trans-unit>
        <trans-unit id="41074d06eaa1aca6cfcc81add0a6d4a0de1496e0" translate="yes" xml:space="preserve">
          <source>It is expected that the Council Members will be employed at a wide range of companies, universities and non-profit organizations. Because of this, it is possible that Members will have conflict of interests. Such conflict of interests include, but are not limited to:</source>
          <target state="translated">評議員は、様々な企業、大学、非営利団体に就職することが想定されています。そのため、委員が利害関係を持つ可能性があります。このような利益相反には、以下のようなものがありますが、これらに限定されません。</target>
        </trans-unit>
        <trans-unit id="e897ba8d8d1e35fdbcdafccfd6dd8ffccaf71314" translate="yes" xml:space="preserve">
          <source>It is good practice to tell &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; who you are, for labeling any changes you make to the code. The simplest way to do this is from the command line:</source>
          <target state="translated">コードに加えた変更にラベルを付けるために、自分が誰であるかを&lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt;に伝えることをお勧めします。これを行う最も簡単な方法は、コマンドラインからです。</target>
        </trans-unit>
        <trans-unit id="9c72b281ec77874c2a8219572de87ebec10916f2" translate="yes" xml:space="preserve">
          <source>It is important to keep in mind that you get a &lt;em&gt;borrowed&lt;/em&gt; reference to the object when using the &amp;ldquo;O&amp;rdquo; format string. However, the converter functions usually require some form of memory handling. In this example, if the conversion is successful, &lt;em&gt;dtype&lt;/em&gt; will hold a new reference to a &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; object, while &lt;em&gt;input&lt;/em&gt; will hold a borrowed reference. Therefore, if this conversion were mixed with another conversion (say to an integer) and the data-type conversion was successful but the integer conversion failed, then you would need to release the reference count to the data-type object before returning. A typical way to do this is to set &lt;em&gt;dtype&lt;/em&gt; to &lt;code&gt;NULL&lt;/code&gt; before calling &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; and then use &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_XDECREF&quot;&gt;&lt;code&gt;Py_XDECREF&lt;/code&gt;&lt;/a&gt; on &lt;em&gt;dtype&lt;/em&gt; before returning.</source>
          <target state="translated">「O」形式の文字列を使用する場合は、オブジェクトへの&lt;em&gt;借用&lt;/em&gt;参照を取得することに注意することが重要です。ただし、コンバーター関数は通常、何らかの形式のメモリー処理を必要とします。この例では、変換が成功すると、&lt;em&gt;dtype&lt;/em&gt;は&lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr *&lt;/code&gt; &lt;/a&gt;オブジェクトへの新しい参照を保持し、&lt;em&gt;input&lt;/em&gt;は借用した参照を保持します。したがって、この変換が別の変換（たとえば整数）と混合され、データ型変換は成功したが整数変換が失敗した場合は、戻る前にデータ型オブジェクトへの参照カウントを解放する必要があります。これを行う一般的な方法は、呼び出す前に&lt;em&gt;dtype&lt;/em&gt;を &lt;code&gt;NULL&lt;/code&gt; に設定することです。&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt;を実行し、&lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_XDECREF&quot;&gt; &lt;code&gt;Py_XDECREF&lt;/code&gt; &lt;/a&gt;で&lt;em&gt;Py_XDECREFを&lt;/em&gt;使用してから戻ります。</target>
        </trans-unit>
        <trans-unit id="68e5e295697e350544ce52515eda2757f41a1612" translate="yes" xml:space="preserve">
          <source>It is important to keep the flags updated (using &lt;a href=&quot;#c.PyArray_UpdateFlags&quot;&gt;&lt;code&gt;PyArray_UpdateFlags&lt;/code&gt;&lt;/a&gt; can help) whenever a manipulation with an array is performed that might cause them to change. Later calculations in NumPy that rely on the state of these flags do not repeat the calculation to update them.</source>
          <target state="translated">配列を操作してフラグを変更する可能性がある場合は常に、フラグを更新したままにすることが重要です（&lt;a href=&quot;#c.PyArray_UpdateFlags&quot;&gt; &lt;code&gt;PyArray_UpdateFlags&lt;/code&gt; &lt;/a&gt;を使用すると役立ちます）。これらのフラグの状態に依存するNumPyの後の計算は、それらを更新するために計算を繰り返しません。</target>
        </trans-unit>
        <trans-unit id="6dd28e38486b7b23cc628bcffec168f7a3e2908d" translate="yes" xml:space="preserve">
          <source>It is important to note that once the iterator is exited, dangling references (like &lt;code&gt;x&lt;/code&gt; in the example) may or may not share data with the original data &lt;code&gt;a&lt;/code&gt;. If writeback semantics were active, i.e. if &lt;code&gt;x.base.flags.writebackifcopy&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then exiting the iterator will sever the connection between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, writing to &lt;code&gt;x&lt;/code&gt; will no longer write to &lt;code&gt;a&lt;/code&gt;. If writeback semantics are not active, then &lt;code&gt;x.data&lt;/code&gt; will still point at some part of &lt;code&gt;a.data&lt;/code&gt;, and writing to one will affect the other.</source>
          <target state="translated">イテレータが終了すると、ぶら下がっている参照（例の &lt;code&gt;x&lt;/code&gt; のような）が元のデータ &lt;code&gt;a&lt;/code&gt; とデータを共有する場合としない場合があることに注意してください。ライトバックのセマンティクスは、アクティブであった場合、すなわち場合 &lt;code&gt;x.base.flags.writebackifcopy&lt;/code&gt; がある &lt;code&gt;True&lt;/code&gt; 、その後、イテレータを終了することとの間の接続切断されます &lt;code&gt;x&lt;/code&gt; と、への書き込み &lt;code&gt;x&lt;/code&gt; になり、もはや書き込み。ライトバックセマンティクスがアクティブでない場合、 &lt;code&gt;x.data&lt;/code&gt; は引き続き &lt;code&gt;a.data&lt;/code&gt; の一部を指し、一方への書き込みは他方に影響します。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63bda28ddda57fde741844f509673a49e4004752" translate="yes" xml:space="preserve">
          <source>It is important to retain an archive of all activities of this committee to ensure consistency in behavior and provide institutional memory for the project. To assist in this, the default channel of discussion for this committee will be a private mailing list accessible to current and future members of the committee as well as members of the Steering Council upon justified request. If the Committee finds the need to use off-list communications (e.g. phone calls for early/rapid response), it should in all cases summarize these back to the list so there&amp;rsquo;s a good record of the process.</source>
          <target state="translated">行動の一貫性を確保し、プロジェクトに制度上の記憶を提供するために、この委員会のすべての活動のアーカイブを保持することが重要です。これを支援するために、この委員会のデフォルトの議論チャネルは、委員会の現在および将来のメンバー、および正当な要求に応じて運営評議会のメンバーがアクセスできるプライベートメーリングリストになります。委員会がリスト外のコミュニケーションを使用する必要があると判断した場合（たとえば、早期/迅速な対応のための電話）、すべての場合において、プロセスの良好な記録があるように、これらをリストに要約する必要があります。</target>
        </trans-unit>
        <trans-unit id="a263f6ef91dbde8a42fa624ef445c812e662a622" translate="yes" xml:space="preserve">
          <source>It is intended that all polynomial instances are immutable, therefore augmented operations (&lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, etc.) and any other functionality that would violate the immutablity of a polynomial instance are intentionally unimplemented.</source>
          <target state="translated">すべての多項式インスタンスは不変であることを意図しているため、拡張演算（ &lt;code&gt;+=&lt;/code&gt; 、 &lt;code&gt;-=&lt;/code&gt; など）および多項式インスタンスの不変性に違反するその他の機能は、意図的に実装されていません。</target>
        </trans-unit>
        <trans-unit id="8b8f2e17893170efcb86b57f32479a3f40a7b944" translate="yes" xml:space="preserve">
          <source>It is named for the American linguist George Kingsley Zipf, who noted that the frequency of any word in a sample of a language is inversely proportional to its rank in the frequency table.</source>
          <target state="translated">これは、アメリカの言語学者ジョージ・キングスレー・ジップフにちなんで名付けられたもので、彼は、言語のサンプル中の単語の頻度は、頻度表のランクに反比例することを指摘しました。</target>
        </trans-unit>
        <trans-unit id="21e4b23be2d40c69036b3d2e468ea13e53868304" translate="yes" xml:space="preserve">
          <source>It is no longer recommended to use this class, even for linear</source>
          <target state="translated">もはや、このクラスを使うことは推奨されていません。</target>
        </trans-unit>
        <trans-unit id="c8350ce47be17c20baa97fc4d0754bec81b2f208" translate="yes" xml:space="preserve">
          <source>It is no longer recommended to use this class, even for linear algebra. Instead use regular arrays. The class may be removed in the future.</source>
          <target state="translated">線形代数でもこのクラスを使うことはもはや推奨されていません。代わりに正規配列を使用してください.このクラスは将来的に削除される可能性があります.</target>
        </trans-unit>
        <trans-unit id="8c5239a5bff654c37cc55078706d5d6b20118c0c" translate="yes" xml:space="preserve">
          <source>It is not always possible to change the shape of an array without copying the data. If you want an error to be raised when the data is copied, you should assign the new shape to the shape attribute of the array:</source>
          <target state="translated">データをコピーせずに配列の形状を変更できるとは限りません。データがコピーされたときにエラーを発生させたい場合は、新しい形状を配列の shape 属性に代入する必要があります。</target>
        </trans-unit>
        <trans-unit id="656bf2f4ae8187e5defb4f5552faf2fbd1f5fad1" translate="yes" xml:space="preserve">
          <source>It is not difficult to create your own ufunc. All that is required is a 1-d loop for each data-type you want to support. Each 1-d loop must have a specific signature, and only ufuncs for fixed-size data-types can be used. The function call used to create a new ufunc to work on built-in data-types is given below. A different mechanism is used to register ufuncs for user-defined data-types.</source>
          <target state="translated">ufuncを自作することは難しくありません。必要なのは、サポートしたいデータ型ごとの1-dループだけです。各1-dループは特定のシグネチャを持たなければならず、固定サイズのデータ型のためのufuncのみを使用することができます。組み込みのデータ型で動作するための新しい ufunc を作成するために使用される関数呼び出しを以下に示します。ユーザ定義データ型用のufuncを登録するためには、別のメカニズムが使用されます。</target>
        </trans-unit>
        <trans-unit id="d8b548648b06bad09d9ab843a8e5797d1798c5b5" translate="yes" xml:space="preserve">
          <source>It is not necessary to use the doctest markup &lt;code&gt;&amp;lt;BLANKLINE&amp;gt;&lt;/code&gt; to indicate empty lines in the output. Note that the option to run the examples through &lt;code&gt;numpy.test&lt;/code&gt; is provided for checking if the examples work, not for making the examples part of the testing framework.</source>
          <target state="translated">doctestマークアップ &lt;code&gt;&amp;lt;BLANKLINE&amp;gt;&lt;/code&gt; を使用して、出力の空の行を示す必要はありません。 &lt;code&gt;numpy.test&lt;/code&gt; を介してサンプルを実行するオプションは、サンプルをテストフレームワークの一部にするためではなく、サンプルが機能するかどうかを確認するために提供されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b37f77a2246e7fcb1e0b4774efe6b903d4205875" translate="yes" xml:space="preserve">
          <source>It is often seen in Bayesian inference and order statistics.</source>
          <target state="translated">ベイズ推論や順序統計でよく見られます。</target>
        </trans-unit>
        <trans-unit id="7bef780e922069dd57c2e5a08856175d82409e4f" translate="yes" xml:space="preserve">
          <source>It is one of a class of extreme value distributions, the Generalized Extreme Value (GEV) distributions, which also includes the Weibull and Frechet.</source>
          <target state="translated">これは、極値分布のクラスである一般化極値(GEV)分布の1つで、ワイブルやフレッシェも含まれます。</target>
        </trans-unit>
        <trans-unit id="5071b59a11ab8c54d2368dbe31b14e825424a9ec" translate="yes" xml:space="preserve">
          <source>It is possible to index arrays with other arrays for the purposes of selecting lists of values out of arrays into new arrays. There are two different ways of accomplishing this. One uses one or more arrays of index values. The other involves giving a boolean array of the proper shape to indicate the values to be selected. Index arrays are a very powerful tool that allow one to avoid looping over individual elements in arrays and thus greatly improve performance.</source>
          <target state="translated">配列から値のリストを新しい配列に選択する目的で、他の配列と配列をインデックス化することが可能です。これを実現するには2つの異なる方法があります。1つはインデックス値の1つ以上の配列を使用します。もう一つは、選択する値を示すために適切な形状のブール値配列を与えます。インデックス配列は非常に強力なツールであり、配列内の個々の要素のループを避けることができるため、パフォーマンスを大幅に向上させることができます。</target>
        </trans-unit>
        <trans-unit id="36000cdc40cdbba3e0e5f28ba7dcb30e267b4506" translate="yes" xml:space="preserve">
          <source>It is possible to load a library using &amp;gt;&amp;gt;&amp;gt; lib = ctypes.cdll[&amp;lt;full_path_name&amp;gt;] # doctest: +SKIP</source>
          <target state="translated">&amp;gt;&amp;gt;&amp;gt; lib = ctypes.cdll [&amp;lt;full_path_name&amp;gt;]を使用してライブラリをロードすることが可能です＃doctest：+ SKIP</target>
        </trans-unit>
        <trans-unit id="38fbbd2c67dc08fbfcb5c5de50ecf788043a91ae" translate="yes" xml:space="preserve">
          <source>It is possible to slice and stride arrays to extract arrays of the same number of dimensions, but of different sizes than the original. The slicing and striding works exactly the same way it does for lists and tuples except that they can be applied to multiple dimensions as well. A few examples illustrates best:</source>
          <target state="translated">配列をスライスしたり,配列をストライドしたりして,同じ次元数の配列を,元の配列とは異なるサイズで抽出することができます.リストやタプルの場合と全く同じ方法でスライスやストライドを行うことができますが,複数の次元にも適用することができます.いくつかの例を挙げてみましょう.</target>
        </trans-unit>
        <trans-unit id="0a211923eef6c9018ec875b45f1ee8aa7feb24f0" translate="yes" xml:space="preserve">
          <source>It is possible to specify config_fc options in setup.py scripts. For example, using</source>
          <target state="translated">setup.py スクリプトで config_fc オプションを指定することができます。例えば</target>
        </trans-unit>
        <trans-unit id="3af7692eade07c544a49c1e0a3fa2b4f67d86e02" translate="yes" xml:space="preserve">
          <source>It is possible to specify how boundaries are treated using &lt;code&gt;edge_order&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;edge_order&lt;/code&gt; を使用して境界の処理方法を指定できます</target>
        </trans-unit>
        <trans-unit id="425695dd90c5cd68dc182714b9d0871e6107582e" translate="yes" xml:space="preserve">
          <source>It is possible to use methods from linear algebra to approximate an existing set of data. Here, we will use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Singular_value_decomposition&quot;&gt;SVD (Singular Value Decomposition)&lt;/a&gt; to try to rebuild an image that uses less singular value information than the original one, while still retaining some of its features.</source>
          <target state="translated">線形代数の方法を使用して、既存のデータセットを近似することができます。ここでは、&lt;a href=&quot;https://en.wikipedia.org/wiki/Singular_value_decomposition&quot;&gt;SVD（Singular Value Decomposition）&lt;/a&gt;を使用して、元の情報よりも少ない特異値情報を使用するイメージを再構築しようとしますが、その機能の一部は保持します。</target>
        </trans-unit>
        <trans-unit id="9279d7909405dcb9e4e547b0701fbd4a212eac71" translate="yes" xml:space="preserve">
          <source>It is possible to use special features to effectively increase the number of dimensions in an array through indexing so the resulting array acquires the shape needed for use in an expression or with a specific function.</source>
          <target state="translated">特殊な機能を利用して、配列の次元数を効果的に増加させることができ、結果として得られる配列は、式や特定の関数で使用するために必要な形状を取得します。</target>
        </trans-unit>
        <trans-unit id="006848dc30e65d20b3919e74b2fa41c8170663f6" translate="yes" xml:space="preserve">
          <source>It is recommended to use one of &lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt;&lt;code&gt;assert_allclose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.testing.assert_array_almost_equal_nulp#numpy.testing.assert_array_almost_equal_nulp&quot;&gt;&lt;code&gt;assert_array_almost_equal_nulp&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.testing.assert_array_max_ulp#numpy.testing.assert_array_max_ulp&quot;&gt;&lt;code&gt;assert_array_max_ulp&lt;/code&gt;&lt;/a&gt; instead of this function for more consistent floating point comparisons.</source>
          <target state="translated">より一貫した浮動小数点比較を&lt;a href=&quot;numpy.testing.assert_array_max_ulp#numpy.testing.assert_array_max_ulp&quot;&gt; &lt;code&gt;assert_array_max_ulp&lt;/code&gt; &lt;/a&gt;には、この関数の代わりに&lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt; &lt;code&gt;assert_allclose&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;numpy.testing.assert_array_almost_equal_nulp#numpy.testing.assert_array_almost_equal_nulp&quot;&gt; &lt;code&gt;assert_array_almost_equal_nulp&lt;/code&gt; &lt;/a&gt;またはassert_array_max_ulpのいずれかを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="e411ddee11ac634d5c4281835040dc7466b061ac" translate="yes" xml:space="preserve">
          <source>It is strongly advised &lt;em&gt;not&lt;/em&gt; to use the matrix subclass. As described below, it makes writing functions that deal consistently with matrices and regular arrays very difficult. Currently, they are mainly used for interacting with &lt;code&gt;scipy.sparse&lt;/code&gt;. We hope to provide an alternative for this use, however, and eventually remove the &lt;code&gt;matrix&lt;/code&gt; subclass.</source>
          <target state="translated">マトリックスサブクラスを使用し&lt;em&gt;ない&lt;/em&gt;ことを強くお勧めします。以下で説明するように、これは、行列と通常の配列を一貫して扱う関数の記述を非常に困難にします。現在、これらは主に &lt;code&gt;scipy.sparse&lt;/code&gt; とのやり取りに使用されています。ただし、この使用法の代替手段を提供し、最終的に &lt;code&gt;matrix&lt;/code&gt; サブクラスを削除したいと考えています。</target>
        </trans-unit>
        <trans-unit id="7669de0e65d605729606ade6c00d09dc551353c4" translate="yes" xml:space="preserve">
          <source>It is used, for example, in modeling the over-reporting of insurance claims.</source>
          <target state="translated">例えば、保険金の過大申告のモデル化などに使用されます。</target>
        </trans-unit>
        <trans-unit id="ca0ecc89a435e5703a52f043959e28e66dbb2433" translate="yes" xml:space="preserve">
          <source>It is useful for writing classes that do not inherit from &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, but that should support arithmetic and numpy universal functions like arrays as described in &lt;a href=&quot;../../neps/nep-0013-ufunc-overrides&quot;&gt;A Mechanism for Overriding Ufuncs&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; を&lt;/a&gt;継承しないクラスを作成する場合に便利ですが、&lt;a href=&quot;../../neps/nep-0013-ufunc-overrides&quot;&gt;Ufuncsをオーバーライドするメカニズムで&lt;/a&gt;説明されているように、配列のような算術関数とnumpyユニバーサル関数をサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="e32c0ef1527073446df56f2f6fdb74c9774fe25a" translate="yes" xml:space="preserve">
          <source>It is useful for writing classes that do not inherit from &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, but that should support arithmetic and numpy universal functions like arrays as described in &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/neps/nep-0013-ufunc-overrides.html&quot;&gt;A Mechanism for Overriding Ufuncs&lt;/a&gt;.</source>
          <target state="translated">これは、&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt;から継承しないクラスを作成する場合に役立ちますが、&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/neps/nep-0013-ufunc-overrides.html&quot;&gt;「Ufuncsをオーバーライドするメカニズム」で&lt;/a&gt;説明されているように、配列などの算術およびnumpyユニバーサル関数をサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="d3b8ad76686cc18b830ba552fba24082c4f933e5" translate="yes" xml:space="preserve">
          <source>It is worth noting that if</source>
          <target state="translated">注目すべきは、もし</target>
        </trans-unit>
        <trans-unit id="29b82dd1d6f270f96b8bc45104bc41a8e589f966" translate="yes" xml:space="preserve">
          <source>It isn&amp;rsquo;t always convenient to explicitly use Polynomial instances, so tuples, lists, arrays, and scalars are automatically cast in the arithmetic operations:</source>
          <target state="translated">多項式インスタンスを明示的に使用することが常に便利であるとは限らないため、タプル、リスト、配列、スカラーが算術演算で自動的にキャストされます。</target>
        </trans-unit>
        <trans-unit id="cf495221779c2163a5e7a39d1bf1b540324c978b" translate="yes" xml:space="preserve">
          <source>It landed 4 times on 1, once on 2, etc.</source>
          <target state="translated">1に4回、2に1回など、着地しました。</target>
        </trans-unit>
        <trans-unit id="d1653963d10a9096aa75746f96dbe0fd1387381e" translate="yes" xml:space="preserve">
          <source>It may also be convenient to define a custom decorators (&lt;code&gt;implements&lt;/code&gt; below) for registering &lt;code&gt;__array_function__&lt;/code&gt; implementations.</source>
          <target state="translated">&lt;code&gt;__array_function__&lt;/code&gt; 実装を登録するためのカスタムデコレータ（以下の &lt;code&gt;implements&lt;/code&gt; ）を定義すると便利な場合もあります。</target>
        </trans-unit>
        <trans-unit id="3598c5e5543d6be85e81adfe21a8be7084de89d0" translate="yes" xml:space="preserve">
          <source>It may be preferable to split the projected cashflow into an initial investment and expected future cashflows. In this case, the value of the initial cashflow is zero and the initial investment is later added to the future cashflows net present value:</source>
          <target state="translated">予測キャッシュフローを初期投資と期待される将来キャッシュフローに分割することが好ましい場合があります。この場合、初期キャッシュフローの価値はゼロであり、初期投資は後に将来キャッシュフローの純現在価値に加算されます。</target>
        </trans-unit>
        <trans-unit id="0c144448b26d1bb5e1e573955f886137b35b8bc6" translate="yes" xml:space="preserve">
          <source>It may be the case that while you were working on your edits, new commits have been added to &lt;code&gt;upstream&lt;/code&gt; that affect your work. In this case, follow the &lt;a href=&quot;#rebasing-on-master&quot;&gt;Rebasing on master&lt;/a&gt; section of this document to apply those changes to your branch.</source>
          <target state="translated">編集作業中に、作業に影響を与える新しいコミットが &lt;code&gt;upstream&lt;/code&gt; 追加された場合があります。この場合、このドキュメントの「&lt;a href=&quot;#rebasing-on-master&quot;&gt;マスター&lt;/a&gt;のリベース」セクションに従って、これらの変更をブランチに適用してください。</target>
        </trans-unit>
        <trans-unit id="61a2cf7173d1c99310b82e23b09fc16ccfa711fb" translate="yes" xml:space="preserve">
          <source>It often happens that the memory that you want to view with an array is not of the same byte ordering as the computer on which you are running Python.</source>
          <target state="translated">配列で見たいメモリが、Pythonを実行しているコンピュータと同じバイト順ではないことがよくあります。</target>
        </trans-unit>
        <trans-unit id="eaadd007be7687e8c25f3eb461c4399e71de7888" translate="yes" xml:space="preserve">
          <source>It should be clear that any structured type could be described using this interface.</source>
          <target state="translated">どんな構造化された型でも、このインタフェースを使って記述できることは明らかです。</target>
        </trans-unit>
        <trans-unit id="40b700e9c3136bc2579dd22e6d2f087fce1952e9" translate="yes" xml:space="preserve">
          <source>It should be emphasized at this point that you may not need the array iterator if your array is already contiguous (using an array iterator will work but will be slower than the fastest code you could write). The major purpose of array iterators is to encapsulate iteration over N-dimensional arrays with arbitrary strides. They are used in many, many places in the NumPy source code itself. If you already know your array is contiguous (Fortran or C), then simply adding the element- size to a running pointer variable will step you through the array very efficiently. In other words, code like this will probably be faster for you in the contiguous case (assuming doubles).</source>
          <target state="translated">ここで強調しておきたいのは,配列が既に連続している場合には,配列イテレータは必要ないかもしれないということです(配列イテレータを使うとうまくいきますが,最速のコードを書くよりも遅くなります).配列イテレータの主な目的は、任意のストライドでN次元配列の反復処理をカプセル化することです。配列イテレータは,NumPyのソースコードの多くの場所で使われています.配列が連続していることがすでにわかっている場合(FortranやC言語),実行中のポインタ変数に要素サイズを追加するだけで,非常に効率的に配列を処理することができます.言い換えれば,このようなコードは,連続配列の場合(ダブルスを想定している場合)には,おそらく速くなるでしょう.</target>
        </trans-unit>
        <trans-unit id="026d73ab6dffc63b48ab1902fa6d889c8def5bcb" translate="yes" xml:space="preserve">
          <source>It uses a &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; rather than the more modern &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">最新の&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;ではなく、&lt;a href=&quot;#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="18504c66aebcc566a9cf5db146c843b0920c0fed" translate="yes" xml:space="preserve">
          <source>It uses global state, which means results will change as the code changes</source>
          <target state="translated">グローバルステートを使用しているので、コードの変更に応じて結果が変化します。</target>
        </trans-unit>
        <trans-unit id="f377563feb8e5b75d15a1cc4f00304a3153cefc3" translate="yes" xml:space="preserve">
          <source>It works in 2-D as well:</source>
          <target state="translated">2Dでも動作します。</target>
        </trans-unit>
        <trans-unit id="e168152d8a6d565c340c6f98aabefe43987e5068" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common to need to transpose your matrices. NumPy arrays have the property &lt;code&gt;T&lt;/code&gt; that allows you to transpose a matrix.</source>
          <target state="translated">行列を転置する必要があるのはよくあることです。NumPy配列には、行列を転置できるプロパティ &lt;code&gt;T&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="2a604443bcd6724527af1c5d434ed815a21fd057" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to save and load and array with &lt;code&gt;np.save()&lt;/code&gt;. Just make sure to specify the array you want to save and a file name. For example, if you create this array:</source>
          <target state="translated">&lt;code&gt;np.save()&lt;/code&gt; を使用すると、保存、読み込み、配列を簡単に行うことができます。保存する配列とファイル名を必ず指定してください。たとえば、この配列を作成する場合：</target>
        </trans-unit>
        <trans-unit id="bb5dacd50e546c91bb0023917cb217930a8f4581" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to assign to copy-on-write array, but values are only written into the memory copy of the array, and not written to disk:</source>
          <target state="translated">コピーオンライト配列に割り当てることは可能ですが、値は配列のメモリコピーにのみ書き込まれ、ディスクには書き込まれません。</target>
        </trans-unit>
        <trans-unit id="2a0ce98ff31bde352ed1c0c91f62805b6675f308" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to do a parallel build with &lt;code&gt;numpy.distutils&lt;/code&gt; with the &lt;code&gt;-j&lt;/code&gt; option; see &lt;a href=&quot;../user/building#parallel-builds&quot;&gt;Parallel builds&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;-j&lt;/code&gt; オプションを &lt;code&gt;numpy.distutils&lt;/code&gt; してnumpy.distutilsを使用して並列ビルドを実行することは可能です。詳細については、&lt;a href=&quot;../user/building#parallel-builds&quot;&gt;並列ビルド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4121d3718e690b8fea8d720656c256ae8ee8cf80" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to do a parallel build with:</source>
          <target state="translated">以下を使用して並列ビルドを実行することができます。</target>
        </trans-unit>
        <trans-unit id="2a92fc5de8c1d7511c762594edc421f16b236424" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s recommended to specify only those config_fc options in such a way that are compiler independent.</source>
          <target state="translated">コンパイラーに依存しない方法でそれらのconfig_fcオプションのみを指定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="0753c18f0b1243f25af624a4511a2035947276c3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s simple to read in a CSV that contains existing information. The best and easiest way to do this is to use &lt;a href=&quot;https://pandas.pydata.org/getpandas.html&quot;&gt;Pandas&lt;/a&gt;.</source>
          <target state="translated">既存の情報を含むCSVで読み取るのは簡単です。これを行うための最良かつ最も簡単な方法は、&lt;a href=&quot;https://pandas.pydata.org/getpandas.html&quot;&gt;パンダ&lt;/a&gt;を使用することです。</target>
        </trans-unit>
        <trans-unit id="14495a2289a19a1e28ed57bed5a4a3a49edf0b4e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s simple to use Pandas in order to export your array as well. If you are new to NumPy, you may want to create a Pandas dataframe from the values in your array and then write the data frame to a CSV file with Pandas.</source>
          <target state="translated">アレイをエクスポートするためにパンダを使用するのも簡単です。NumPyを初めて使用する場合は、配列の値からPandasデータフレームを作成してから、Pandasを使用してデータフレームをCSVファイルに書き込むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="060cec9479c0c03cb8146120d17fc1e1fd50e074" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s usually a good idea to use the &lt;code&gt;-n&lt;/code&gt; flag to &lt;code&gt;git push&lt;/code&gt; to check first that you&amp;rsquo;re about to push the changes you want to the place you want.</source>
          <target state="translated">通常は、 &lt;code&gt;-n&lt;/code&gt; フラグを使用して &lt;code&gt;git push&lt;/code&gt; を使用し、必要な変更を目的の場所にプッシュしようとしていることを最初に確認することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="85be1e8acbcf441a36b9c0c869cff5476c693c32" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s very common to want to aggregate along a row or column. By default, every NumPy aggregation function will return the aggregate of the entire array. To find the sum or the minimum of the elements in your array, run:</source>
          <target state="translated">行または列に沿って集計することは非常に一般的です。デフォルトでは、すべてのNumPy集計関数は配列全体の集計を返します。配列内の要素の合計または最小値を見つけるには、次のコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="c3a9e71b0cabb8c3a03cd16e13045b08078788b6" translate="yes" xml:space="preserve">
          <source>Item selection and manipulation</source>
          <target state="translated">アイテムの選択と操作</target>
        </trans-unit>
        <trans-unit id="867490709f6ff3383fa1fcfac4368fffd68d75ba" translate="yes" xml:space="preserve">
          <source>Items of an array of this data type are wrapped in an &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;array scalar&lt;/a&gt; type that also has two fields:</source>
          <target state="translated">このデータ型の配列の項目は、2つのフィールドを持つ&lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;配列スカラー&lt;/a&gt;型にラップされます。</target>
        </trans-unit>
        <trans-unit id="7b5cbf04c6d27c2ce2fa2026bd76b8e62a482e6d" translate="yes" xml:space="preserve">
          <source>Iterating Over Arrays</source>
          <target state="translated">配列の反復処理</target>
        </trans-unit>
        <trans-unit id="61c7e36ee871033d37342fea4c9a477a22a3ad15" translate="yes" xml:space="preserve">
          <source>Iterating as a Specific Data Type</source>
          <target state="translated">特定のデータ型として反復処理</target>
        </trans-unit>
        <trans-unit id="d0332abd31d07a7d02dd3e33350dc402dcd2926d" translate="yes" xml:space="preserve">
          <source>Iterating over all but one axis</source>
          <target state="translated">1軸以外のすべての軸を反復処理</target>
        </trans-unit>
        <trans-unit id="1844648c4af60a1a170cdaf38688443ce7ba666d" translate="yes" xml:space="preserve">
          <source>Iterating over arrays</source>
          <target state="translated">配列の反復処理</target>
        </trans-unit>
        <trans-unit id="b05284699d8fb62b19954c2a16145ceb83ef59a3" translate="yes" xml:space="preserve">
          <source>Iterating over elements in the array</source>
          <target state="translated">配列の要素を繰り返し処理する</target>
        </trans-unit>
        <trans-unit id="ab8467929e39862040c3a1bba747525fbb89952c" translate="yes" xml:space="preserve">
          <source>Iterating over multiple arrays</source>
          <target state="translated">複数の配列の反復処理</target>
        </trans-unit>
        <trans-unit id="3c8101d6360b4040707379e2577c7a16fa0bf84e" translate="yes" xml:space="preserve">
          <source>Iteration is done in row-major, C-style order (the last index varying the fastest). The iterator can also be indexed using basic slicing or advanced indexing.</source>
          <target state="translated">イテレーションは、行-長、C スタイルの順序で行われます(最後のインデックスが最も速く変化します)。イテレータは、基本的なスライシングまたは高度なインデックスを使用してインデックスを作成することもできます。</target>
        </trans-unit>
        <trans-unit id="acbcdc45d250ba7dd26edab06186cf3962745972" translate="yes" xml:space="preserve">
          <source>Iterator Data Types</source>
          <target state="translated">イテレータのデータ型</target>
        </trans-unit>
        <trans-unit id="21aa412ed70b91ee6a2ff89a4abea36c2af42360" translate="yes" xml:space="preserve">
          <source>Iterator flag &lt;a href=&quot;#c.NPY_ITER_COMMON_DTYPE&quot;&gt;&lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">イテレータフラグ&lt;a href=&quot;#c.NPY_ITER_COMMON_DTYPE&quot;&gt; &lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1116d7dda5125208b276ad5471ddd5d08e64ba8" translate="yes" xml:space="preserve">
          <source>Iterator flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">イテレータフラグ&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b6f69b38ac0228e9245d67b9b1d09ee42bc5dcb" translate="yes" xml:space="preserve">
          <source>Iterator for broadcasting</source>
          <target state="translated">放送用イテレータ</target>
        </trans-unit>
        <trans-unit id="6425854ab104811d699d59fa557478463a96d42e" translate="yes" xml:space="preserve">
          <source>Iterator-Allocated Output Arrays</source>
          <target state="translated">イテレータで割り当てられた出力配列</target>
        </trans-unit>
        <trans-unit id="3ea20b9878659e33fbac6ee844497cef84a926f4" translate="yes" xml:space="preserve">
          <source>Iterators are a powerful concept for array processing. Essentially, iterators implement a generalized for-loop. If &lt;em&gt;myiter&lt;/em&gt; is an iterator object, then the Python code:</source>
          <target state="translated">イテレータは、配列処理の強力な概念です。基本的に、イテレータは一般化されたforループを実装します。場合&lt;em&gt;myiterは、&lt;/em&gt;イテレータオブジェクトは、Pythonのコードは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="796f6321f3f35af9085ef4cf35c1d4e6f0e4b4dc" translate="yes" xml:space="preserve">
          <source>Its disadvantages include</source>
          <target state="translated">その欠点には以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="57d54f82f4390510a92d95c53ba668fb5b8d3f93" translate="yes" xml:space="preserve">
          <source>Its probability density function is</source>
          <target state="translated">その確率密度関数は</target>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="a2cbec366193e4ee99c0016c5fe79f216b41e583" translate="yes" xml:space="preserve">
          <source>J. F. Kaiser, &amp;ldquo;Digital Filters&amp;rdquo; - Ch 7 in &amp;ldquo;Systems analysis by digital computer&amp;rdquo;, Editors: F.F. Kuo and J.F. Kaiser, p 218-285. John Wiley and Sons, New York, (1966).</source>
          <target state="translated">JF Kaiser、「デジタルフィルター」-「デジタルコンピューターによるシステム分析」の7章、編集者：FF KuoおよびJF Kaiser、p 218-285。John Wiley and Sons、ニューヨーク、1966年。</target>
        </trans-unit>
        <trans-unit id="f458212a67f9dc847550889da59b7be8169fde2a" translate="yes" xml:space="preserve">
          <source>Jaime Fern&amp;aacute;ndez del R&amp;iacute;o</source>
          <target state="translated">ハイメフェルナンデスデルリオ</target>
        </trans-unit>
        <trans-unit id="d85b6dd0eee475b31af984e7ef5b76c826173395" translate="yes" xml:space="preserve">
          <source>John K. Salmon, Mark A. Moraes, Ron O. Dror, and David E. Shaw, &amp;ldquo;Parallel Random Numbers: As Easy as 1, 2, 3,&amp;rdquo; Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis (SC11), New York, NY: ACM, 2011.</source>
          <target state="translated">John K. Salmon、Mark A. Moraes、Ron O. Dror、David E. Shaw、「Parallel Random Numbers：As Easy as 1、2、3」、Proceedings for the International Conference for High Performance Computing、Networking、Storage and分析（SC11）、ニューヨーク、ニューヨーク：ACM、2011年。</target>
        </trans-unit>
        <trans-unit id="5955c7d39672a39a399f419793e9d4b2998a0ae1" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays along a new axis.</source>
          <target state="translated">新しい軸に沿って配列を結合します。</target>
        </trans-unit>
        <trans-unit id="4ea1c9ee9a15b3dcbf6e5bf8c6f47b37d396752b" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays along an existing axis.</source>
          <target state="translated">既存の軸に沿って配列の列を結合します。</target>
        </trans-unit>
        <trans-unit id="c169b65bb5e75fcaa26f3cb74e710ac8d05e200a" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays together.</source>
          <target state="translated">一連の配列を一緒に結合します。</target>
        </trans-unit>
        <trans-unit id="a0cbf31ae389d3a2da5d14e49f527c1cd6c82518" translate="yes" xml:space="preserve">
          <source>Join arrays &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; on key &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">配列参加 &lt;code&gt;r1&lt;/code&gt; と &lt;code&gt;r2&lt;/code&gt; キーに &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23191121c5e72da7ca4394cebd036d5824a4bf84" translate="yes" xml:space="preserve">
          <source>Join arrays &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; on keys. Alternative to join_by, that always returns a np.recarray.</source>
          <target state="translated">キーの配列 &lt;code&gt;r1&lt;/code&gt; と &lt;code&gt;r2&lt;/code&gt; を結合します。join_byの代わりに、常にnp.recarrayを返します。</target>
        </trans-unit>
        <trans-unit id="ace77e0ad40f2680b6aa7f69f4dfbec0108a72b3" translate="yes" xml:space="preserve">
          <source>Join the sequence of objects in &lt;em&gt;obj&lt;/em&gt; together along &lt;em&gt;axis&lt;/em&gt; into a single array. If the dimensions or types are not compatible an error is raised.</source>
          <target state="translated">&lt;em&gt;obj&lt;/em&gt;のオブジェクトのシーケンスを&lt;em&gt;軸&lt;/em&gt;に沿って1つの配列に結合します。ディメンションまたはタイプに互換性がない場合、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="0b145a058f4f708ddeea141e56d4c1c7cea2454f" translate="yes" xml:space="preserve">
          <source>Join two or more pathname components + - convert a /-separated pathname to one using the OS&amp;rsquo;s path separator. - resolve  and  from path.</source>
          <target state="translated">2つ以上のパス名コンポーネントを結合します+-OSのパス区切り文字を使用して/で区切られたパス名を1つに変換します。-解決し、パスから。</target>
        </trans-unit>
        <trans-unit id="930021877100c692fce1a3c6407a5fca82ef8115" translate="yes" xml:space="preserve">
          <source>Joining arrays</source>
          <target state="translated">配列の結合</target>
        </trans-unit>
        <trans-unit id="853683e5afe4c33d14d4fe25be2e7a31fcdb24ae" translate="yes" xml:space="preserve">
          <source>Julian Taylor</source>
          <target state="translated">ジュリアン・テイラー</target>
        </trans-unit>
        <trans-unit id="1ad4711cdf3c76bf58efbbfffae229363be1de78" translate="yes" xml:space="preserve">
          <source>July 26, 2019</source>
          <target state="translated">2019年7月26日</target>
        </trans-unit>
        <trans-unit id="0ea4fce60f72408c555e74c1176fd49b9f6f546a" translate="yes" xml:space="preserve">
          <source>Jump Size</source>
          <target state="translated">ジャンプサイズ</target>
        </trans-unit>
        <trans-unit id="2f4eece64596ae5728be928b098daa67afdcbd49" translate="yes" xml:space="preserve">
          <source>Jumping the BitGenerator state</source>
          <target state="translated">BitGeneratorの状態をジャンプする</target>
        </trans-unit>
        <trans-unit id="edaececa3ce78905da5d0c8d3e5c155d40b3049c" translate="yes" xml:space="preserve">
          <source>Jumping to the next level of complexity, it is possible to only partially index an array with index arrays. It takes a bit of thought to understand what happens in such cases. For example if we just use one index array with y:</source>
          <target state="translated">次の複雑さのレベルにジャンプすると、配列を部分的にインデックス配列でしかインデックスを付けられないことがあります。このような場合に何が起こるのかを理解するには、少し考えが必要です。例えば、yを使って1つのインデックス配列を使うだけの場合。</target>
        </trans-unit>
        <trans-unit id="d3780087bf4b8552cfaeefd4ae432b76ab3d8ec4" translate="yes" xml:space="preserve">
          <source>Jumps the state as-if jumps * 210306068529402873165736369884012333109 random numbers have been generated.</source>
          <target state="translated">状態をジャンプしますので、ジャンプします*2103060685294028731657369884012333109乱数が生成されています。</target>
        </trans-unit>
        <trans-unit id="e66b5685b9897c71dad3170faecd2518dfadece3" translate="yes" xml:space="preserve">
          <source>June 29, 2020</source>
          <target state="translated">2020年6月29日</target>
        </trans-unit>
        <trans-unit id="f9d305a937478453054f4a6c27158c776273985e" translate="yes" xml:space="preserve">
          <source>Just for your own satisfaction, show yourself that you now have a new &amp;lsquo;remote&amp;rsquo;, with &lt;code&gt;git remote -v show&lt;/code&gt;, giving you something like:</source>
          <target state="translated">自分の満足のために、 &lt;code&gt;git remote -v show&lt;/code&gt; を使用して、新しい「リモート」があることを示してください。</target>
        </trans-unit>
        <trans-unit id="f8882074cfd8e824bd17a6e53a5a926e124e1b9b" translate="yes" xml:space="preserve">
          <source>Just like in other Python container objects, the contents of an array can be accessed and modified by indexing or slicing the array. Unlike the typical container objects, different arrays can share the same data, so changes made on one array might be visible in another.</source>
          <target state="translated">他の Python コンテナオブジェクトと同様に、配列の内容は配列をインデックス化したりスライスしたりすることでアクセスしたり変更したりすることができます。典型的なコンテナオブジェクトとは異なり、異なる配列は同じデータを共有することができるので、ある配列で行われた変更は別の配列でも見ることができるかもしれません。</target>
        </trans-unit>
        <trans-unit id="c5a2ccc2c43427a5df3aae2525cebca91213ce58" translate="yes" xml:space="preserve">
          <source>Just like the case for builtin special methods like &lt;code&gt;__add__&lt;/code&gt;, properly written &lt;code&gt;__array_function__&lt;/code&gt; methods should always return &lt;code&gt;NotImplemented&lt;/code&gt; when an unknown type is encountered. Otherwise, it will be impossible to correctly override NumPy functions from another object if the operation also includes one of your objects.</source>
          <target state="translated">&lt;code&gt;__add__&lt;/code&gt; などの組み込みの特殊メソッドの場合と同様に、適切に記述された &lt;code&gt;__array_function__&lt;/code&gt; メソッドは、不明なタイプが &lt;code&gt;NotImplemented&lt;/code&gt; 場合、常にNotImplementedを返す必要があります。そうでない場合、操作にオブジェクトの1つが含まれている場合、別のオブジェクトからNumPy関数を正しくオーバーライドすることはできません。</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="fea9c97b23d277bbc25a4ecec464e976ad73c9d8" translate="yes" xml:space="preserve">
          <source>Key to use in the Philox state. Unlike &lt;code&gt;seed&lt;/code&gt;, the value in key is directly set. Can be either a Python int in [0, 2**128) or a 2-element uint64 array. &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;seed&lt;/code&gt; cannot both be used.</source>
          <target state="translated">フィロックス州で使用するための鍵。 &lt;code&gt;seed&lt;/code&gt; とは異なり、キーの値は直接設定されます。[0、2 ** 128）のPythonintまたは2要素のuint64配列のいずれかです。 &lt;code&gt;key&lt;/code&gt; と &lt;code&gt;seed&lt;/code&gt; 両方を使用することはできません。</target>
        </trans-unit>
        <trans-unit id="04e171a322d7a93c71ab2aebd91bfaf316577346" translate="yes" xml:space="preserve">
          <source>Key to use in the Philox state. Unlike seed, the value in key is directly set. Can be either a Python int in [0, 2**128) or a 2-element uint64 array. &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;seed&lt;/code&gt; cannot both be used.</source>
          <target state="translated">Philox州で使用するキー。シードとは異なり、キーの値は直接設定されます。[0、2 ** 128）のPython intまたは2要素のuint64配列のいずれかです。 &lt;code&gt;key&lt;/code&gt; と &lt;code&gt;seed&lt;/code&gt; 両方を使用することはできません。</target>
        </trans-unit>
        <trans-unit id="a4f25f4e01bab825ac7968a35cf2573aecf46441" translate="yes" xml:space="preserve">
          <source>Keyword arguments passed to &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; に渡されるキーワード引数。</target>
        </trans-unit>
        <trans-unit id="936d17141932bddd8cdbe3cf3d8e6417d18816b5" translate="yes" xml:space="preserve">
          <source>Keyword arguments used in calling &lt;a href=&quot;#numpy.piecewise&quot;&gt;&lt;code&gt;piecewise&lt;/code&gt;&lt;/a&gt; are passed to the functions upon execution, i.e., if called &lt;code&gt;piecewise(..., ..., alpha=1)&lt;/code&gt;, then each function is called as &lt;code&gt;f(x, alpha=1)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.piecewise&quot;&gt; &lt;code&gt;piecewise&lt;/code&gt; の&lt;/a&gt;呼び出しで使用されるキーワード引数は、実行時に関数に渡されます。つまり、 &lt;code&gt;piecewise(..., ..., alpha=1)&lt;/code&gt; と呼ばれる場合、各関数は &lt;code&gt;f(x, alpha=1)&lt;/code&gt; として呼び出されます。</target>
        </trans-unit>
        <trans-unit id="94796302f2d6010802da8fc83c102abd3d91e59b" translate="yes" xml:space="preserve">
          <source>Keyword arguments with the value &lt;code&gt;None&lt;/code&gt; are not checked. Specifying a keyword enforces checking of that aspect of the ndarray on conversion to a ctypes-compatible object. The dtype keyword can be any object understood as a data-type object. The ndim keyword should be an integer, and the shape keyword should be an integer or a sequence of integers. The flags keyword specifies the minimal flags that are required on any array passed in. This can be specified as a string of comma separated requirements, an integer indicating the requirement bits OR&amp;rsquo;d together, or a flags object returned from the flags attribute of an array with the necessary requirements.</source>
          <target state="translated">値が &lt;code&gt;None&lt;/code&gt; のキーワード引数はチェックされません。キーワードを指定すると、ctypes互換オブジェクトへの変換時にndarrayのその側面のチェックが強制されます。dtypeキーワードは、データ型オブジェクトとして理解される任意のオブジェクトにすることができます。ndimキーワードは整数である必要があり、shapeキーワードは整数または整数のシーケンスである必要があります。flagsキーワードは、渡される配列に必要な最小限のフラグを指定します。これは、コンマ区切りの要件の文字列、要件ビットのORを示す整数、またはフラグ属性から返されるフラグオブジェクトとして指定できます。必要な要件を備えたアレイ。</target>
        </trans-unit>
        <trans-unit id="7b38351b3da46b01757fe5df0b763a6ba88d3175" translate="yes" xml:space="preserve">
          <source>Keyword arguments. The valid keywords are the possible floating-point exceptions. Each keyword should have a string value that defines the treatment for the particular error. Possible values are {&amp;lsquo;ignore&amp;rsquo;, &amp;lsquo;warn&amp;rsquo;, &amp;lsquo;raise&amp;rsquo;, &amp;lsquo;call&amp;rsquo;, &amp;lsquo;print&amp;rsquo;, &amp;lsquo;log&amp;rsquo;}.</source>
          <target state="translated">キーワード引数。有効なキーワードは、考えられる浮動小数点例外です。各キーワードには、特定のエラーの処理を定義する文字列値が必要です。可能な値は、{'ignore'、 'warn'、 'raise'、 'call'、 'print'、 'log'}です。</target>
        </trans-unit>
        <trans-unit id="cca3dd937ca64fcc731c3b76e10a3a59e197b380" translate="yes" xml:space="preserve">
          <source>Keywords other than &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are passed to &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;以外のキーワードがfunctionに渡され &lt;code&gt;function&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd51c0cf5320b73d3ff55b2176ad245d2d7397b1" translate="yes" xml:space="preserve">
          <source>Keywords other than &lt;code&gt;dtype&lt;/code&gt; are passed to &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dtype&lt;/code&gt; 以外のキーワードがfunctionに渡され &lt;code&gt;function&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c23ce94abbcda9863c972bac23c6a2a76bdd7d1" translate="yes" xml:space="preserve">
          <source>Kind of floating point data-type about which to get information.</source>
          <target state="translated">情報を取得するための浮動小数点データ型の一種。</target>
        </trans-unit>
        <trans-unit id="31be8fd23c00b4b851fa5f224f6fd4dac29e08c9" translate="yes" xml:space="preserve">
          <source>Known bugs:</source>
          <target state="translated">既知のバグ。</target>
        </trans-unit>
        <trans-unit id="26db35f7eb95d8b793f4df612e64a0ce6b5afd47" translate="yes" xml:space="preserve">
          <source>Known failures &amp;amp; skipping tests</source>
          <target state="translated">既知のエラーとテストのスキップ</target>
        </trans-unit>
        <trans-unit id="d54ed0ae4c90f25216ec62895c50ba0c59603696" translate="yes" xml:space="preserve">
          <source>Kotz, Samuel, et. al. &amp;ldquo;The Laplace Distribution and Generalizations, &amp;rdquo; Birkhauser, 2001.</source>
          <target state="translated">コッツ、サミュエル、他 al。「ラプラスの分布と一般化」、Birkhauser、2001年。</target>
        </trans-unit>
        <trans-unit id="9b54aa8ed101113f4ff654653787cb490d5956f9" translate="yes" xml:space="preserve">
          <source>Kronecker product of two arrays.</source>
          <target state="translated">2つの配列のクロネッカー積。</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="0c5ca7c9489e795d6e344494ca6012e6c5e6c94a" translate="yes" xml:space="preserve">
          <source>L. J. Gitman, &amp;ldquo;Principles of Managerial Finance, Brief,&amp;rdquo; 3rd ed., Addison-Wesley, 2003, pg. 346.</source>
          <target state="translated">LJ Gitman、「Principles of Managerial Finance、Brief」、第3版、Addison-Wesley、2003、pg。346。</target>
        </trans-unit>
        <trans-unit id="dad744be14f4bac6567fee2e00e8179f1cafc777" translate="yes" xml:space="preserve">
          <source>L. J. Gitman, &amp;ldquo;Principles of Managerial Finance, Brief,&amp;rdquo; 3rd ed., Addison-Wesley, 2003, pg. 348.</source>
          <target state="translated">LJ Gitman、「Principles of Managerial Finance、Brief」、第3版、Addison-Wesley、2003、pg。348。</target>
        </trans-unit>
        <trans-unit id="c9abe91342431b93d138f7615d16985673f94ddb" translate="yes" xml:space="preserve">
          <source>L2 norm of vector &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">ベクトル &lt;code&gt;v&lt;/code&gt; のL2ノルム</target>
        </trans-unit>
        <trans-unit id="cf9e7dcbce935737e3132c8567095e62b32e357d" translate="yes" xml:space="preserve">
          <source>LAPACK</source>
          <target state="translated">LAPACK</target>
        </trans-unit>
        <trans-unit id="a3fb459b8d25a6646ccd3006470636c4394d2fa7" translate="yes" xml:space="preserve">
          <source>LAPACK (NetLIB)</source>
          <target state="translated">ラパック (NetLIB)</target>
        </trans-unit>
        <trans-unit id="21d5b247623a47d3ffff1da535ef4461b811d560" translate="yes" xml:space="preserve">
          <source>LSB integer 1</source>
          <target state="translated">LSB 整数 1</target>
        </trans-unit>
        <trans-unit id="17bcd0c5595da0e7eb910f67673f577b1f83f0f7" translate="yes" xml:space="preserve">
          <source>LSB integer 2</source>
          <target state="translated">LSB 整数 2</target>
        </trans-unit>
        <trans-unit id="eec57c77bc60eb78065b6605060bb41430b8e7ce" translate="yes" xml:space="preserve">
          <source>LU decomposition (note: P(Matlab) == transpose(P(numpy)) )</source>
          <target state="translated">LU 分解(注意:P(Matlab)==transpose(P(numpy))</target>
        </trans-unit>
        <trans-unit id="f50beb264ce7d144bf1ce0f2f4d3f272a300b7de" translate="yes" xml:space="preserve">
          <source>Label a test as &amp;lsquo;slow&amp;rsquo;.</source>
          <target state="translated">テストに「遅い」というラベルを付けます。</target>
        </trans-unit>
        <trans-unit id="369c34c1729b62dec5c01c92266ffbd20a59873d" translate="yes" xml:space="preserve">
          <source>Labeling tests</source>
          <target state="translated">ラベリングテスト</target>
        </trans-unit>
        <trans-unit id="4bebfc5e6e36da81205979cf627ca2083b60eab7" translate="yes" xml:space="preserve">
          <source>Laguerre</source>
          <target state="translated">Laguerre</target>
        </trans-unit>
        <trans-unit id="e97fc7286288e61e2979e3135f28bb8c533a9b55" translate="yes" xml:space="preserve">
          <source>Laguerre (class in numpy.polynomial.laguerre)</source>
          <target state="translated">ラグエール</target>
        </trans-unit>
        <trans-unit id="5e57606aead53cf91effb25cd081645a48be4c71" translate="yes" xml:space="preserve">
          <source>Laguerre Class</source>
          <target state="translated">ラゲールクラス</target>
        </trans-unit>
        <trans-unit id="ba379f482d893a166d54a2acffc47cc917ce664e" translate="yes" xml:space="preserve">
          <source>Laguerre Module (&lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt;)</source>
          <target state="translated">ラゲールモジュール（ &lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="1fa1d2e4107d4f18290f33c4164e9ffd20858112" translate="yes" xml:space="preserve">
          <source>Laguerre Module (numpy.polynomial.laguerre)</source>
          <target state="translated">Laguerre モジュール (numpy.polynomial.laguerre)</target>
        </trans-unit>
        <trans-unit id="2a936707907aefc2336791e67e0a362c7a6f2893" translate="yes" xml:space="preserve">
          <source>Laguerre Series (&lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt;)</source>
          <target state="translated">ラゲールシリーズ（ &lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="df257db6a3d424bc3a9e921bbaaa3ba0ba50dac3" translate="yes" xml:space="preserve">
          <source>Laguerre Series (numpy.polynomial.laguerre)</source>
          <target state="translated">ラグエール級数</target>
        </trans-unit>
        <trans-unit id="99466c13dff878e880a6ce449247757d575c46d1" translate="yes" xml:space="preserve">
          <source>Laguerre coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*L_0(x) + 2*L_1(X) + 3*L_2(x)&lt;/code&gt;.</source>
          <target state="translated">次数の昇順のラゲール係数、つまり &lt;code&gt;(1, 2, 3)&lt;/code&gt; は &lt;code&gt;1*L_0(x) + 2*L_1(X) + 3*L_2(x)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="96781eb22440929e4bf56e8413b2c4b2ee004cfa" translate="yes" xml:space="preserve">
          <source>Laguerre coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">ラゲール係数は、低いものから高いものへと並べられています。場合 &lt;code&gt;y&lt;/code&gt; が 2-Dであった、の列kにおけるデータの係数 &lt;code&gt;y&lt;/code&gt; は、列にある &lt;code&gt;k&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="203d5e91f105ffb95930f626e1d302a193aeaa68" translate="yes" xml:space="preserve">
          <source>Laguerre series</source>
          <target state="translated">ラゲールシリーズ</target>
        </trans-unit>
        <trans-unit id="a347ea54d317cc577991ec7bf8e660f33b29ea5f" translate="yes" xml:space="preserve">
          <source>Laguerre series coefficients of the integral.</source>
          <target state="translated">積分のラグエール級数係数。</target>
        </trans-unit>
        <trans-unit id="d470a6ac507868056b6fb97be3c38f8e66fd3f73" translate="yes" xml:space="preserve">
          <source>Laguerre series of power.</source>
          <target state="translated">力のラゲールシリーズ。</target>
        </trans-unit>
        <trans-unit id="077697f66c66782d4ef98066ee75e7065a9fd35e" translate="yes" xml:space="preserve">
          <source>Laguerre series of the derivative.</source>
          <target state="translated">微分のラグエール級数。</target>
        </trans-unit>
        <trans-unit id="9a5deb2e7228ec3244f92981a2f639bd0074c61e" translate="yes" xml:space="preserve">
          <source>Laguerre series whose graph is a straight line.</source>
          <target state="translated">グラフが直線であるラグエール級数。</target>
        </trans-unit>
        <trans-unit id="40be499dbcfef954b53f79728a280796ea6c4f1b" translate="yes" xml:space="preserve">
          <source>Laguerre weight function.</source>
          <target state="translated">ラゲールの重み関数。</target>
        </trans-unit>
        <trans-unit id="19b66881a109c4450aeadcaedc080b0375d2ecf9" translate="yes" xml:space="preserve">
          <source>Laguerre.__call__()</source>
          <target state="translated">Laguerre.__call__()</target>
        </trans-unit>
        <trans-unit id="b79eed7b566471b5b98d5403131d5fcccb9ccdd6" translate="yes" xml:space="preserve">
          <source>Laguerre.basis()</source>
          <target state="translated">Laguerre.basis()</target>
        </trans-unit>
        <trans-unit id="8450b9cd56cfc84841f9b6a7b3ce8b6553391224" translate="yes" xml:space="preserve">
          <source>Laguerre.cast()</source>
          <target state="translated">Laguerre.cast()</target>
        </trans-unit>
        <trans-unit id="27a50de57a0c19215d0a40ab26d7fc3244818104" translate="yes" xml:space="preserve">
          <source>Laguerre.convert()</source>
          <target state="translated">Laguerre.convert()</target>
        </trans-unit>
        <trans-unit id="ba2566270efed850de8b718e7293f07a260b676d" translate="yes" xml:space="preserve">
          <source>Laguerre.copy()</source>
          <target state="translated">Laguerre.copy()</target>
        </trans-unit>
        <trans-unit id="3b52ca7dceafcdacc78576d128623ad1866249fc" translate="yes" xml:space="preserve">
          <source>Laguerre.cutdeg()</source>
          <target state="translated">Laguerre.cutdeg()</target>
        </trans-unit>
        <trans-unit id="d2b6b76b4b9ee361106b2c94187d00faaf8bec52" translate="yes" xml:space="preserve">
          <source>Laguerre.degree()</source>
          <target state="translated">Laguerre.degree()</target>
        </trans-unit>
        <trans-unit id="00ba5991cdfe21416f272ddb4e2fd2ee48ba1e73" translate="yes" xml:space="preserve">
          <source>Laguerre.deriv()</source>
          <target state="translated">Laguerre.deriv()</target>
        </trans-unit>
        <trans-unit id="3774c67b9a36d28184dc80e1b4d2486ea1e1f36a" translate="yes" xml:space="preserve">
          <source>Laguerre.domain</source>
          <target state="translated">Laguerre.domain</target>
        </trans-unit>
        <trans-unit id="b85b503244ce55e050a887342980da72b2e9ad78" translate="yes" xml:space="preserve">
          <source>Laguerre.fit()</source>
          <target state="translated">Laguerre.fit()</target>
        </trans-unit>
        <trans-unit id="23af0332e2c429442e5afb68340fa4aeef4545dc" translate="yes" xml:space="preserve">
          <source>Laguerre.fromroots()</source>
          <target state="translated">Laguerre.fromroots()</target>
        </trans-unit>
        <trans-unit id="a2a6581abb5a91aaeac7e93a2a256734282432d3" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samecoef()</source>
          <target state="translated">Laguerre.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="7dd4d8134966100274e963f0060bfab576b5fddf" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samedomain()</source>
          <target state="translated">Laguerre.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="e5e59e81443c19ac8f19e8c2fdccb120a1c9224f" translate="yes" xml:space="preserve">
          <source>Laguerre.has_sametype()</source>
          <target state="translated">Laguerre.has_sametype()</target>
        </trans-unit>
        <trans-unit id="3d138070a5021011806b89098bbe766378b10e7e" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samewindow()</source>
          <target state="translated">Laguerre.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="6f69d4698823efec4ccf07af22829cc894b0b98c" translate="yes" xml:space="preserve">
          <source>Laguerre.identity()</source>
          <target state="translated">Laguerre.identity()</target>
        </trans-unit>
        <trans-unit id="f1f6d872a178e7692b45f4ccbfd34fbbf6ed5f91" translate="yes" xml:space="preserve">
          <source>Laguerre.integ()</source>
          <target state="translated">Laguerre.integ()</target>
        </trans-unit>
        <trans-unit id="068cb46402017cfb3dd18164c9b41f89c700f799" translate="yes" xml:space="preserve">
          <source>Laguerre.linspace()</source>
          <target state="translated">Laguerre.linspace()</target>
        </trans-unit>
        <trans-unit id="100d51943018ffa8eadce404d26cfaa31b915872" translate="yes" xml:space="preserve">
          <source>Laguerre.mapparms()</source>
          <target state="translated">Laguerre.mapparms()</target>
        </trans-unit>
        <trans-unit id="de9dd46ebdab9f670b65d8cedb81c132ac30c276" translate="yes" xml:space="preserve">
          <source>Laguerre.roots()</source>
          <target state="translated">Laguerre.roots()</target>
        </trans-unit>
        <trans-unit id="9779fb4f29c73da5d6cee5ec234239b97271c1ae" translate="yes" xml:space="preserve">
          <source>Laguerre.trim()</source>
          <target state="translated">Laguerre.trim()</target>
        </trans-unit>
        <trans-unit id="76a59bb3d54a6db3b464f00c41f8b5a8b4767c11" translate="yes" xml:space="preserve">
          <source>Laguerre.truncate()</source>
          <target state="translated">Laguerre.truncate()</target>
        </trans-unit>
        <trans-unit id="36198a8897031e87556aee045b29805731052142" translate="yes" xml:space="preserve">
          <source>Laplaces</source>
          <target state="translated">Laplaces</target>
        </trans-unit>
        <trans-unit id="82f5e1511892c7fb01c75144ac000d62f83d5a77" translate="yes" xml:space="preserve">
          <source>Large allocations marked as suitable for transparent hugepages</source>
          <target state="translated">透過的な巨大ページに適しているとマークされた大規模な割り当て</target>
        </trans-unit>
        <trans-unit id="da46491a1118285dbcf5975a2a3f36f864e4e6eb" translate="yes" xml:space="preserve">
          <source>Large parts of this manual originate from Travis E. Oliphant&amp;rsquo;s book &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;Guide to NumPy&lt;/a&gt; (which generously entered Public Domain in August 2008). The reference documentation for many of the functions are written by numerous contributors and developers of NumPy.</source>
          <target state="translated">このマニュアルの大部分は、Travis E. Oliphantの著書&lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;Guide to NumPy&lt;/a&gt;（2008年8月にパブリックドメインに入った）に基づいています。多くの関数のリファレンスドキュメントは、NumPyの多数の寄稿者および開発者によって作成されています。</target>
        </trans-unit>
        <trans-unit id="eab5c44c0f0e22a5c5510649d34e17cb192d1603" translate="yes" xml:space="preserve">
          <source>Large parts of this manual originate from Travis E. Oliphant's book &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;&quot;Guide to NumPy&quot;&lt;/a&gt; (which generously entered Public Domain in August 2008). The reference documentation for many of the functions are written by numerous contributors and developers of NumPy.</source>
          <target state="translated">このマニュアルの大部分は、Travis E.Oliphantの著書&lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;「GuidetoNumPy」&lt;/a&gt;（2008年8月にパブリックドメインに入った）に由来しています。多くの関数のリファレンスドキュメントは、NumPyの多数の寄稿者と開発者によって書かれています。</target>
        </trans-unit>
        <trans-unit id="2fdae5c61df170eabed81dff27bfb3678199f99b" translate="yes" xml:space="preserve">
          <source>Largest size allowed for the user-settable buffers.</source>
          <target state="translated">ユーザー設定可能なバッファの最大サイズ。</target>
        </trans-unit>
        <trans-unit id="8da87d373f111f7e103693ae24e8a07ffa7a91e2" translate="yes" xml:space="preserve">
          <source>Last processed field name (used internally during recursion).</source>
          <target state="translated">最後に処理されたフィールド名(再帰時に内部的に使用されます)。</target>
        </trans-unit>
        <trans-unit id="688c183c0553e7f8897c3da631ac608e3281e20b" translate="yes" xml:space="preserve">
          <source>Learn about concepts and submodules</source>
          <target state="translated">概念とサブモジュールについて学ぶ</target>
        </trans-unit>
        <trans-unit id="7e1c2c8a281b93c2a756aa5c5b0dde7c93d58559" translate="yes" xml:space="preserve">
          <source>Learn about what NumPy is and how to install it</source>
          <target state="translated">NumPyとは何か、どのようにインストールするのかを学ぶ</target>
        </trans-unit>
        <trans-unit id="1893b40e2e74ded8d87e7668bb8ea0e85b265882" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;../reference/routines.io#routines-io&quot;&gt;input and output routines here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../reference/routines.io#routines-io&quot;&gt;入出力ルーチンの&lt;/a&gt;詳細については、こちらをご覧ください。</target>
        </trans-unit>
        <trans-unit id="42d6db2ec75c1bd30bb52b2e73819209cb308cc1" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;quickstart#quickstart-indexing-slicing-and-iterating&quot;&gt;indexing and slicing here&lt;/a&gt; and &lt;a href=&quot;basics.indexing#basics-indexing&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;quickstart#quickstart-indexing-slicing-and-iterating&quot;&gt;ここ&lt;/a&gt;と&lt;a href=&quot;basics.indexing#basics-indexing&quot;&gt;ここで&lt;/a&gt;インデックス作成とスライスの詳細をご覧ください。</target>
        </trans-unit>
        <trans-unit id="2a595050bddab4e4c46cb1e0dc7dff5874ac8e5f" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;whatisnumpy#whatisnumpy&quot;&gt;NumPy here&lt;/a&gt;!</source>
          <target state="translated">&lt;a href=&quot;whatisnumpy#whatisnumpy&quot;&gt;NumPyの&lt;/a&gt;詳細については、こちらをご覧ください。</target>
        </trans-unit>
        <trans-unit id="eccf892e3b309e4f27b805fda73ba6310c691f1f" translate="yes" xml:space="preserve">
          <source>Learn more about creating arrays here</source>
          <target state="translated">配列の作成についてはこちらをご覧ください。</target>
        </trans-unit>
        <trans-unit id="e9f285095a214517cc70148a152aa9ce3bfb1555" translate="yes" xml:space="preserve">
          <source>Least squares fit of Chebyshev series to data.</source>
          <target state="translated">チェビシェフ級数のデータへの最小二乗適合。</target>
        </trans-unit>
        <trans-unit id="5eede6c92597c6ad1ec14f2a50e868bfa8dbcef5" translate="yes" xml:space="preserve">
          <source>Least squares fit of Hermite series to data.</source>
          <target state="translated">ハーミット級数のデータへの最小二乗適合。</target>
        </trans-unit>
        <trans-unit id="f9834397596bb1c91a60ebd7bed6c56b93f210b5" translate="yes" xml:space="preserve">
          <source>Least squares fit of Laguerre series to data.</source>
          <target state="translated">ラゲール級数のデータへの最小二乗適合。</target>
        </trans-unit>
        <trans-unit id="60abe6780ea6293285c10210c3c968485e58937b" translate="yes" xml:space="preserve">
          <source>Least squares fit of Legendre series to data.</source>
          <target state="translated">レジェンドレ級数のデータへの最小二乗適合。</target>
        </trans-unit>
        <trans-unit id="f70b890f268681837dd642a40e85f47d99c8ef5c" translate="yes" xml:space="preserve">
          <source>Least squares fit to data.</source>
          <target state="translated">データへの最小二乗適合。</target>
        </trans-unit>
        <trans-unit id="82d4ad107d684ab9ad44770f05b7a2542d27bae6" translate="yes" xml:space="preserve">
          <source>Least squares polynomial fit.</source>
          <target state="translated">最小二乗多項式フィット。</target>
        </trans-unit>
        <trans-unit id="66b99a01120f0770d01e2e70f30aa7b3e6d8760b" translate="yes" xml:space="preserve">
          <source>Least-squares fit of a polynomial to data.</source>
          <target state="translated">データへの多項式の最小二乗適合。</target>
        </trans-unit>
        <trans-unit id="004f7153cd5215d911c25b804b9cb64fc053135e" translate="yes" xml:space="preserve">
          <source>Least-squares solution. If &lt;code&gt;b&lt;/code&gt; is two-dimensional, the solutions are in the &lt;code&gt;K&lt;/code&gt; columns of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">最小二乗解。場合 &lt;code&gt;b&lt;/code&gt; 2次元である、ソリューションはにある &lt;code&gt;K&lt;/code&gt; 個の列 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e3bf79d3ac96cdf89ed0ca352f8850960c3aecf" translate="yes" xml:space="preserve">
          <source>Leg of the triangle(s). If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">三角形の脚。 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状にブロードキャスト可能でなければなりません（これが出力の形状になります）。</target>
        </trans-unit>
        <trans-unit id="a3da3f26242bb8617087ec4d4fb9fafcb77635dc" translate="yes" xml:space="preserve">
          <source>Legacy Generator (RandomState)</source>
          <target state="translated">レガシージェネレータ(RandomState)</target>
        </trans-unit>
        <trans-unit id="7a03f0fe89c9579b9b2b236650c98185edc2fe62" translate="yes" xml:space="preserve">
          <source>Legacy Random Generation</source>
          <target state="translated">レガシーランダム世代</target>
        </trans-unit>
        <trans-unit id="47a5d89b5a8a2f363ca5b4a1476eb173fc07ab11" translate="yes" xml:space="preserve">
          <source>Legendre</source>
          <target state="translated">Legendre</target>
        </trans-unit>
        <trans-unit id="358ed7a487a2a55bfa9556bbf8f4fe1f6f4c1094" translate="yes" xml:space="preserve">
          <source>Legendre (class in numpy.polynomial.legendre)</source>
          <target state="translated">レジェンドレ</target>
        </trans-unit>
        <trans-unit id="4120cea9b471c879abda7b1336aba3d61c52e3bc" translate="yes" xml:space="preserve">
          <source>Legendre Class</source>
          <target state="translated">レジェンドレクラス</target>
        </trans-unit>
        <trans-unit id="b4a47072941f51eec5be92fa7536302b1cd27189" translate="yes" xml:space="preserve">
          <source>Legendre Module (&lt;code&gt;numpy.polynomial.legendre&lt;/code&gt;)</source>
          <target state="translated">ルジャンドルモジュール（ &lt;code&gt;numpy.polynomial.legendre&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="a6b7c39b7f03fb5bf1916b89cb05334bb7660fc8" translate="yes" xml:space="preserve">
          <source>Legendre Module (numpy.polynomial.legendre)</source>
          <target state="translated">凡例モジュール (numpy.polynomial.legendre)</target>
        </trans-unit>
        <trans-unit id="5cf0b728017026cd3633f8023ba22356ac49e8e9" translate="yes" xml:space="preserve">
          <source>Legendre Series (&lt;code&gt;numpy.polynomial.legendre&lt;/code&gt;)</source>
          <target state="translated">ルジャンドルシリーズ（ &lt;code&gt;numpy.polynomial.legendre&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="3fc1f7294028d411cdbd64652dfec514ea719176" translate="yes" xml:space="preserve">
          <source>Legendre Series (numpy.polynomial.legendre)</source>
          <target state="translated">レジェンドレ級数</target>
        </trans-unit>
        <trans-unit id="72a4b81826e99e6fe744c1d98416a1d24f591803" translate="yes" xml:space="preserve">
          <source>Legendre coefficients in order of increasing degree, i.e., &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*P_0(x) + 2*P_1(x) + 3*P_2(x)&lt;/code&gt;.</source>
          <target state="translated">ルジャンドル係数の次数の昇順、つまり &lt;code&gt;(1, 2, 3)&lt;/code&gt; は &lt;code&gt;1*P_0(x) + 2*P_1(x) + 3*P_2(x)&lt;/code&gt; 与えます。</target>
        </trans-unit>
        <trans-unit id="dd1aecb7d54479faf64417ed750dd54dbc48134e" translate="yes" xml:space="preserve">
          <source>Legendre coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;. If &lt;code&gt;deg&lt;/code&gt; is specified as a list, coefficients for terms not included in the fit are set equal to zero in the returned &lt;code&gt;coef&lt;/code&gt;.</source>
          <target state="translated">ルジャンドル係数は、低いものから高いものへと並べられています。場合 &lt;code&gt;y&lt;/code&gt; が 2-Dであった、の列kにおけるデータの係数 &lt;code&gt;y&lt;/code&gt; は、列にある &lt;code&gt;k&lt;/code&gt; 。 &lt;code&gt;deg&lt;/code&gt; がリストとして指定されている場合、近似に含まれない項の係数は、返される &lt;code&gt;coef&lt;/code&gt; でゼロに等しく設定されます。</target>
        </trans-unit>
        <trans-unit id="36661c8b6df50f0810e8abcd38c911e37700210a" translate="yes" xml:space="preserve">
          <source>Legendre series</source>
          <target state="translated">レジェンドレシリーズ</target>
        </trans-unit>
        <trans-unit id="cff0f8c14f012c4d84feceb1b721e76e38f2b7e7" translate="yes" xml:space="preserve">
          <source>Legendre series coefficient array of the integral.</source>
          <target state="translated">積分のレジェンドレ級数係数配列。</target>
        </trans-unit>
        <trans-unit id="e423b1233d9fcd2c8894e66b68b4670d1797fcf6" translate="yes" xml:space="preserve">
          <source>Legendre series of power.</source>
          <target state="translated">レジェンドレシリーズのパワー。</target>
        </trans-unit>
        <trans-unit id="cbfaa0f2130ef078276a68c292602bd146355698" translate="yes" xml:space="preserve">
          <source>Legendre series of the derivative.</source>
          <target state="translated">導関数のレジェンドレ級数。</target>
        </trans-unit>
        <trans-unit id="0c94fd4bbecdfa33cfa2085e96aaf27eb258cb91" translate="yes" xml:space="preserve">
          <source>Legendre series whose graph is a straight line.</source>
          <target state="translated">グラフが直線であるレジェンドレ級数。</target>
        </trans-unit>
        <trans-unit id="9c6dd8780cca130b14ebf98dc6a58e0b8fde7f4f" translate="yes" xml:space="preserve">
          <source>Legendre weight function (= 1).</source>
          <target state="translated">レジェンドレの重み関数(=1)。</target>
        </trans-unit>
        <trans-unit id="11838d713a7ca74c36db28fb9741ab01b38fc2f4" translate="yes" xml:space="preserve">
          <source>Legendre, Laguerre, Hermite, HermiteE polynomials in &lt;code&gt;numpy.polynomial&lt;/code&gt;</source>
          <target state="translated">でルジャンドル、ラゲール、エルミート、HermiteE多項式 &lt;code&gt;numpy.polynomial&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4086e8682b0af8e09d2dfa82cd2fdc76b5bc8f8d" translate="yes" xml:space="preserve">
          <source>Legendre.__call__()</source>
          <target state="translated">Legendre.__call__()</target>
        </trans-unit>
        <trans-unit id="38dffd4eba846de64c001288fae359b48ca7be06" translate="yes" xml:space="preserve">
          <source>Legendre.basis()</source>
          <target state="translated">Legendre.basis()</target>
        </trans-unit>
        <trans-unit id="03d79bdd0c244e4a8685e0cc2ed8f9bba14f2e75" translate="yes" xml:space="preserve">
          <source>Legendre.cast()</source>
          <target state="translated">Legendre.cast()</target>
        </trans-unit>
        <trans-unit id="c3757be303c19145dd4cdc1f1fdbe7778af7a9b8" translate="yes" xml:space="preserve">
          <source>Legendre.convert()</source>
          <target state="translated">Legendre.convert()</target>
        </trans-unit>
        <trans-unit id="30694a9a60e1750eef89dd48cd213d03dc835778" translate="yes" xml:space="preserve">
          <source>Legendre.copy()</source>
          <target state="translated">Legendre.copy()</target>
        </trans-unit>
        <trans-unit id="67fd9bca2a23484298ecfc5a44e6dbe767f8deee" translate="yes" xml:space="preserve">
          <source>Legendre.cutdeg()</source>
          <target state="translated">Legendre.cutdeg()</target>
        </trans-unit>
        <trans-unit id="de6280bafa05de1ba0dc2f4ee315b2f1c3f376c2" translate="yes" xml:space="preserve">
          <source>Legendre.degree()</source>
          <target state="translated">Legendre.degree()</target>
        </trans-unit>
        <trans-unit id="065d87c76a899767772e29e52989a91f8e7a3c94" translate="yes" xml:space="preserve">
          <source>Legendre.deriv()</source>
          <target state="translated">Legendre.deriv()</target>
        </trans-unit>
        <trans-unit id="dc4f96a4666e84f37c719b2fad25d196a612cc45" translate="yes" xml:space="preserve">
          <source>Legendre.domain</source>
          <target state="translated">Legendre.domain</target>
        </trans-unit>
        <trans-unit id="11c2423446ff507ce6eb98675dde94c735489c69" translate="yes" xml:space="preserve">
          <source>Legendre.fit()</source>
          <target state="translated">Legendre.fit()</target>
        </trans-unit>
        <trans-unit id="e21bd7963e9b515a9f4b47a6bcd09e263e8089ee" translate="yes" xml:space="preserve">
          <source>Legendre.fromroots()</source>
          <target state="translated">Legendre.fromroots()</target>
        </trans-unit>
        <trans-unit id="d5d912a486cc7b8f50ccecabe4f025c8e6390336" translate="yes" xml:space="preserve">
          <source>Legendre.has_samecoef()</source>
          <target state="translated">Legendre.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="6666d87ba29b4b8ae40e97a1bf2868d699324607" translate="yes" xml:space="preserve">
          <source>Legendre.has_samedomain()</source>
          <target state="translated">Legendre.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="3760f41cb73e83c63c3b041fb1850faaf75fa051" translate="yes" xml:space="preserve">
          <source>Legendre.has_sametype()</source>
          <target state="translated">Legendre.has_sametype()</target>
        </trans-unit>
        <trans-unit id="776a3387bba3bfaabfedc34f80f56441350be257" translate="yes" xml:space="preserve">
          <source>Legendre.has_samewindow()</source>
          <target state="translated">Legendre.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="d270c39a15f9cf84d450407eca8d04e34120a21a" translate="yes" xml:space="preserve">
          <source>Legendre.identity()</source>
          <target state="translated">Legendre.identity()</target>
        </trans-unit>
        <trans-unit id="a025b9af1289248a2a7d813cd3249b6c59a1b90e" translate="yes" xml:space="preserve">
          <source>Legendre.integ()</source>
          <target state="translated">Legendre.integ()</target>
        </trans-unit>
        <trans-unit id="b1309f9dd6fba8397cba7645c87fd874d753067f" translate="yes" xml:space="preserve">
          <source>Legendre.linspace()</source>
          <target state="translated">Legendre.linspace()</target>
        </trans-unit>
        <trans-unit id="3b41ed00816bbf0ea94cb8ce7b846f9374dce867" translate="yes" xml:space="preserve">
          <source>Legendre.mapparms()</source>
          <target state="translated">Legendre.mapparms()</target>
        </trans-unit>
        <trans-unit id="498206cc30a61e0936daddec7420065e1fb22906" translate="yes" xml:space="preserve">
          <source>Legendre.roots()</source>
          <target state="translated">Legendre.roots()</target>
        </trans-unit>
        <trans-unit id="c917ded9bfb105e1d1214678489c4d2d643e0789" translate="yes" xml:space="preserve">
          <source>Legendre.trim()</source>
          <target state="translated">Legendre.trim()</target>
        </trans-unit>
        <trans-unit id="4b818047b63ac1fb3abbf9ee09b84ccf39af0370" translate="yes" xml:space="preserve">
          <source>Legendre.truncate()</source>
          <target state="translated">Legendre.truncate()</target>
        </trans-unit>
        <trans-unit id="d96ebfedf4c36cbda183cd7a457b02a6edaca923" translate="yes" xml:space="preserve">
          <source>Length &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; array of &lt;code&gt;char&lt;/code&gt; encoding the &lt;a href=&quot;../generated/numpy.dtype.num#numpy.dtype.num&quot;&gt;&lt;code&gt;numpy.dtype.num&lt;/code&gt;&lt;/a&gt; (built-in only) that the corresponding function in the &lt;code&gt;func&lt;/code&gt; array accepts. For instance, for a comparison ufunc with three &lt;code&gt;ntypes&lt;/code&gt;, two &lt;code&gt;nin&lt;/code&gt; and one &lt;code&gt;nout&lt;/code&gt;, where the first function accepts &lt;code&gt;numpy.int32&lt;/code&gt; and the the second &lt;code&gt;numpy.int64&lt;/code&gt;, with both returning &lt;code&gt;numpy.bool_&lt;/code&gt;, &lt;code&gt;types&lt;/code&gt; would be &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; since &lt;code&gt;NPY_INT32&lt;/code&gt; is 5, &lt;code&gt;NPY_INT64&lt;/code&gt; is 7, and &lt;code&gt;NPY_BOOL&lt;/code&gt; is 0.</source>
          <target state="translated">長さ &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; の配列 &lt;code&gt;char&lt;/code&gt; コード&lt;a href=&quot;../generated/numpy.dtype.num#numpy.dtype.num&quot;&gt; &lt;code&gt;numpy.dtype.num&lt;/code&gt; &lt;/a&gt;に対応する機能は、（内蔵のみ） &lt;code&gt;func&lt;/code&gt; アレイが受け入れるを。例えば、3とufunc比較のため &lt;code&gt;ntypes&lt;/code&gt; 二 &lt;code&gt;nin&lt;/code&gt; 一 &lt;code&gt;nout&lt;/code&gt; 第関数が受け付け、 &lt;code&gt;numpy.int32&lt;/code&gt; 及び第二 &lt;code&gt;numpy.int64&lt;/code&gt; を両方戻すと、 &lt;code&gt;numpy.bool_&lt;/code&gt; 、 &lt;code&gt;types&lt;/code&gt; あろう &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; ため &lt;code&gt;NPY_INT32&lt;/code&gt; が5である、 &lt;code&gt;NPY_INT64&lt;/code&gt; は7であり、そして &lt;code&gt;NPY_BOOL&lt;/code&gt; は0です。</target>
        </trans-unit>
        <trans-unit id="a0ba05a259a8b34022dc6e1b217b0390cf104e0b" translate="yes" xml:space="preserve">
          <source>Length &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; array of &lt;code&gt;char&lt;/code&gt; encoding the &lt;a href=&quot;generated/numpy.dtype.num#numpy.dtype.num&quot;&gt;&lt;code&gt;numpy.dtype.num&lt;/code&gt;&lt;/a&gt; (built-in only) that the corresponding function in the &lt;code&gt;func&lt;/code&gt; array accepts. For instance, for a comparison ufunc with three &lt;code&gt;ntypes&lt;/code&gt;, two &lt;code&gt;nin&lt;/code&gt; and one &lt;code&gt;nout&lt;/code&gt;, where the first function accepts &lt;code&gt;numpy.int32&lt;/code&gt; and the the second &lt;code&gt;numpy.int64&lt;/code&gt;, with both returning &lt;code&gt;numpy.bool_&lt;/code&gt;, &lt;code&gt;types&lt;/code&gt; would be &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; since &lt;code&gt;NPY_INT32&lt;/code&gt; is 5, &lt;code&gt;NPY_INT64&lt;/code&gt; is 7, and &lt;code&gt;NPY_BOOL&lt;/code&gt; is 0.</source>
          <target state="translated">長さ &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; の配列 &lt;code&gt;char&lt;/code&gt; コード&lt;a href=&quot;generated/numpy.dtype.num#numpy.dtype.num&quot;&gt; &lt;code&gt;numpy.dtype.num&lt;/code&gt; &lt;/a&gt;に対応する機能は、（内蔵のみ） &lt;code&gt;func&lt;/code&gt; アレイが受け入れるを。例えば、3とufunc比較のため &lt;code&gt;ntypes&lt;/code&gt; 二 &lt;code&gt;nin&lt;/code&gt; 一 &lt;code&gt;nout&lt;/code&gt; 第関数が受け付け、 &lt;code&gt;numpy.int32&lt;/code&gt; 及び第二 &lt;code&gt;numpy.int64&lt;/code&gt; を両方戻すと、 &lt;code&gt;numpy.bool_&lt;/code&gt; 、 &lt;code&gt;types&lt;/code&gt; あろう &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; ため &lt;code&gt;NPY_INT32&lt;/code&gt; が 5である、 &lt;code&gt;NPY_INT64&lt;/code&gt; は 7であり、そして &lt;code&gt;NPY_BOOL&lt;/code&gt; は 0です。</target>
        </trans-unit>
        <trans-unit id="e599dfd0500969f55b8c9d010461f8e1fcc41925" translate="yes" xml:space="preserve">
          <source>Length of each array element, in number of characters. Default is 1.</source>
          <target state="translated">各配列要素の長さを文字数で表します。デフォルトは1です。</target>
        </trans-unit>
        <trans-unit id="6dbef5ea0e7b53958b8a2d75b0863dd2996ea77a" translate="yes" xml:space="preserve">
          <source>Length of one array element in bytes.</source>
          <target state="translated">1つの配列要素の長さをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="ebd0316d087a92fa193507d4dfe490f6483edcaf" translate="yes" xml:space="preserve">
          <source>Length of the inverse FFT, the number of points along transformation axis in the input to use. If &lt;code&gt;n&lt;/code&gt; is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt; is used.</source>
          <target state="translated">逆FFTの長さ、使用する入力の変換軸に沿ったポイントの数。 &lt;code&gt;n&lt;/code&gt; が入力の長さより小さい場合、入力は切り取られます。大きい場合、入力はゼロで埋められます。 &lt;code&gt;n&lt;/code&gt; が指定されていない場合、axisで指定された &lt;code&gt;axis&lt;/code&gt; 沿った入力の長さが使用されます。</target>
        </trans-unit>
        <trans-unit id="c0386e146b5b66f11c90240baf5f54bbd4a84b7b" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. For &lt;code&gt;n&lt;/code&gt; output points, &lt;code&gt;n//2 + 1&lt;/code&gt; input points are necessary. If the input is longer than this, it is cropped. If it is shorter than this, it is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, it is determined from the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">出力の変換された軸の長さ。ための &lt;code&gt;n&lt;/code&gt; 出力点、 &lt;code&gt;n//2 + 1&lt;/code&gt; の入力ポイントが必要です。入力がこれより長い場合、切り取られます。これより短い場合は、ゼロが埋め込まれます。 &lt;code&gt;n&lt;/code&gt; が指定されていない場合は、axisで指定された &lt;code&gt;axis&lt;/code&gt; 沿った入力の長さから決定されます。</target>
        </trans-unit>
        <trans-unit id="4f13f9612cce3a275a1186d10417cbf86f8f9b46" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. For &lt;code&gt;n&lt;/code&gt; output points, &lt;code&gt;n//2 + 1&lt;/code&gt; input points are necessary. If the input is longer than this, it is cropped. If it is shorter than this, it is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, it is taken to be &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">出力の変換された軸の長さ。ための &lt;code&gt;n&lt;/code&gt; 出力点、 &lt;code&gt;n//2 + 1&lt;/code&gt; の入力ポイントが必要です。入力がこれより長い場合は、トリミングされます。これより短い場合は、ゼロが埋め込まれます。 &lt;code&gt;n&lt;/code&gt; が指定されていない場合、 &lt;code&gt;2*(m-1)&lt;/code&gt; と見なされます。ここで、 &lt;code&gt;m&lt;/code&gt; は、axisで指定された &lt;code&gt;axis&lt;/code&gt; 沿った入力の長さです。</target>
        </trans-unit>
        <trans-unit id="ef669ab3a842002f9a1fb7bac5550ccceaa27247" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. For &lt;code&gt;n&lt;/code&gt; output points, &lt;code&gt;n//2+1&lt;/code&gt; input points are necessary. If the input is longer than this, it is cropped. If it is shorter than this, it is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, it is determined from the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">出力の変換された軸の長さ。ための &lt;code&gt;n&lt;/code&gt; 出力点、 &lt;code&gt;n//2+1&lt;/code&gt; の入力ポイントが必要です。入力がこれより長い場合、切り取られます。これより短い場合は、ゼロが埋め込まれます。 &lt;code&gt;n&lt;/code&gt; が指定されていない場合は、axisで指定された &lt;code&gt;axis&lt;/code&gt; 沿った入力の長さから決定されます。</target>
        </trans-unit>
        <trans-unit id="1393d388a3302d35f0092d404b2ba089179672a7" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. For &lt;code&gt;n&lt;/code&gt; output points, &lt;code&gt;n//2+1&lt;/code&gt; input points are necessary. If the input is longer than this, it is cropped. If it is shorter than this, it is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, it is taken to be &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">出力の変換された軸の長さ。ための &lt;code&gt;n&lt;/code&gt; 出力点、 &lt;code&gt;n//2+1&lt;/code&gt; の入力ポイントが必要です。入力がこれより長い場合は、トリミングされます。これより短い場合は、ゼロが埋め込まれます。 &lt;code&gt;n&lt;/code&gt; が指定されていない場合、 &lt;code&gt;2*(m-1)&lt;/code&gt; と見なされます。ここで、 &lt;code&gt;m&lt;/code&gt; は、axisで指定された &lt;code&gt;axis&lt;/code&gt; 沿った入力の長さです。</target>
        </trans-unit>
        <trans-unit id="9649fc48731a6d9a87c71452f8efbcb7f76b78d4" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. If &lt;code&gt;n&lt;/code&gt; is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt; is used.</source>
          <target state="translated">出力の変換された軸の長さ。 &lt;code&gt;n&lt;/code&gt; が入力の長さより小さい場合、入力は切り取られます。大きい場合、入力はゼロで埋められます。 &lt;code&gt;n&lt;/code&gt; が指定されていない場合、axisで指定された &lt;code&gt;axis&lt;/code&gt; 沿った入力の長さが使用されます。</target>
        </trans-unit>
        <trans-unit id="838e5e82eb9b3c833687dc387dbd43309bd32602" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. If &lt;code&gt;n&lt;/code&gt; is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt; is used. See notes about padding issues.</source>
          <target state="translated">出力の変換された軸の長さ。 &lt;code&gt;n&lt;/code&gt; が入力の長さより小さい場合、入力は切り取られます。大きい場合、入力はゼロで埋められます。 &lt;code&gt;n&lt;/code&gt; が指定されていない場合、axisで指定された &lt;code&gt;axis&lt;/code&gt; 沿った入力の長さが使用されます。パディングの問題に関するメモを参照してください。</target>
        </trans-unit>
        <trans-unit id="20b7b6096b899f364abc1b0ab113ac1d88c95817" translate="yes" xml:space="preserve">
          <source>Lentner, Marvin, &amp;ldquo;Elementary Applied Statistics&amp;rdquo;, Bogden and Quigley, 1972.</source>
          <target state="translated">レントナー、マーヴィン、「エレメンタリーアプライド統計」、ボグデンアンドクィグリー、1972年。</target>
        </trans-unit>
        <trans-unit id="ad48dd4be642df433d10c28592cb939dc42a109f" translate="yes" xml:space="preserve">
          <source>Less Basic</source>
          <target state="translated">基本的なものが少ない</target>
        </trans-unit>
        <trans-unit id="e99e5b627f7ed42d45bd8cf2acdec386f4c6174c" translate="yes" xml:space="preserve">
          <source>Less robust estimator that that takes into account data variability and data size.</source>
          <target state="translated">データのばらつきやデータサイズを考慮したロバスト性の低い推定器。</target>
        </trans-unit>
        <trans-unit id="ef5fe1edf37940bd463fee8eda068dc8d66b0f8a" translate="yes" xml:space="preserve">
          <source>Let</source>
          <target state="translated">Let</target>
        </trans-unit>
        <trans-unit id="a718bc5ba689b0611826e8a00c42db91a4cc33c1" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;M = A.ndim&lt;/code&gt;, &lt;code&gt;N = B.ndim&lt;/code&gt;. Then the result, &lt;code&gt;C&lt;/code&gt;, of &lt;code&gt;op.outer(A, B)&lt;/code&gt; is an array of dimension M + N such that:</source>
          <target state="translated">レッツ &lt;code&gt;M = A.ndim&lt;/code&gt; 、 &lt;code&gt;N = B.ndim&lt;/code&gt; 。次に、 &lt;code&gt;op.outer(A, B)&lt;/code&gt; の結果 &lt;code&gt;C&lt;/code&gt; は、次のような次元M + Nの配列になります。</target>
        </trans-unit>
        <trans-unit id="c21492f5c1039f68826ed62d8fddcbe2ecf43d60" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;x.shape&lt;/code&gt; be (10,20,30,40,50) and suppose &lt;code&gt;ind_1&lt;/code&gt; and &lt;code&gt;ind_2&lt;/code&gt; can be broadcast to the shape (2,3,4). Then &lt;code&gt;x[:,ind_1,ind_2]&lt;/code&gt; has shape (10,2,3,4,40,50) because the (20,30)-shaped subspace from X has been replaced with the (2,3,4) subspace from the indices. However, &lt;code&gt;x[:,ind_1,:,ind_2]&lt;/code&gt; has shape (2,3,4,10,30,50) because there is no unambiguous place to drop in the indexing subspace, thus it is tacked-on to the beginning. It is always possible to use &lt;a href=&quot;generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt;&lt;code&gt;.transpose()&lt;/code&gt;&lt;/a&gt; to move the subspace anywhere desired. Note that this example cannot be replicated using &lt;a href=&quot;generated/numpy.take#numpy.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">してみましょう &lt;code&gt;x.shape&lt;/code&gt; が可能（10,20,30,40,50）と仮定 &lt;code&gt;ind_1&lt;/code&gt; と &lt;code&gt;ind_2&lt;/code&gt; は形状（2,3,4）に放送することができます。次に、 &lt;code&gt;x[:,ind_1,ind_2]&lt;/code&gt; 形状は（10,2,3,4,40,50）になります。これは、Xの（20,30）形状の部分空間が、（2,3,4）の部分空間に置き換えられたためです。インデックス。ただし、 &lt;code&gt;x[:,ind_1,:,ind_2]&lt;/code&gt; 形状は（2,3,4,10,30,50）です。これは、インデックスサブスペースにドロップするための明確な場所がないため、最初に追加されます。&lt;a href=&quot;generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt; &lt;code&gt;.transpose()&lt;/code&gt; &lt;/a&gt;を使用してサブスペースを必要な場所に移動することは常に可能です。この例は、&lt;a href=&quot;generated/numpy.take#numpy.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;を使用して複製することはできません。</target>
        </trans-unit>
        <trans-unit id="c5de9d97cc2b507966a716e78a84203d66bead94" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s apply the steps of wrapping Fortran functions to Python one by one.</source>
          <target state="translated">Fortran関数をPythonに1つずつラップする手順を適用してみましょう。</target>
        </trans-unit>
        <trans-unit id="91c6bd95be9fba42070138c60bc544f63be79cf2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s check that this is what we expected:</source>
          <target state="translated">これが私たちが期待したものであることを確認しましょう：</target>
        </trans-unit>
        <trans-unit id="d53ca7c39e959075c64a326e51c71e27bb307d6d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider a list of elements, &lt;code&gt;x&lt;/code&gt;, where values of -9999. represent missing data. We wish to compute the average value of the data and the vector of anomalies (deviations from the average):</source>
          <target state="translated">要素のリスト &lt;code&gt;x&lt;/code&gt; について考えてみましょう。値は-9999です。欠損データを表します。データの平均値と異常のベクトル（平均からの偏差）を計算します。</target>
        </trans-unit>
        <trans-unit id="2913bcf139d6f47d02c0ac2f1be4a80f4a447c13" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider an array &lt;code&gt;d&lt;/code&gt; of floats between 0 and 1. We wish to compute the average of the values of &lt;code&gt;d&lt;/code&gt; while ignoring any data outside the range &lt;code&gt;[0.2, 0.9]&lt;/code&gt;:</source>
          <target state="translated">のが配列考える &lt;code&gt;d&lt;/code&gt; 我々は、の値の平均値を計算したい0と1の間のフロートのを &lt;code&gt;d&lt;/code&gt; は範囲外のデータを無視して &lt;code&gt;[0.2, 0.9]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab1ea5de1d1447221ec240c0905b303173635736" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider an array &lt;code&gt;d&lt;/code&gt; of random floats between 0 and 1. We wish to compute the average of the values of &lt;code&gt;d&lt;/code&gt; while ignoring any data outside the range &lt;code&gt;[0.1, 0.9]&lt;/code&gt;:</source>
          <target state="translated">のが配列考える &lt;code&gt;d&lt;/code&gt; 我々は、の値の平均値を計算したい0と1の間のランダムな浮動小数点のを &lt;code&gt;d&lt;/code&gt; は範囲外のデータを無視して &lt;code&gt;[0.1, 0.9]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39281dff86138ded282e6212c34eb9cda8834f15" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do 20,000 trials of the model, and count the number that generate zero positive results.</source>
          <target state="translated">モデルを20,000回試行して、肯定的な結果がゼロになる数を数えます。</target>
        </trans-unit>
        <trans-unit id="1b9b5278ac2afa5e3136c310885e0f8fd06a8be2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s explore a more advanced concept in numpy called broadcasting. The term broadcasting describes how numpy treats arrays with different shapes during arithmetic operations. Subject to certain constraints, the smaller array is &amp;ldquo;broadcast&amp;rdquo; across the larger array so that they have compatible shapes. Broadcasting provides a means of vectorizing array operations so that looping occurs in C instead of Python. It does this without making needless copies of data and usually leads to efficient algorithm implementations. There are also cases where broadcasting is a bad idea because it leads to inefficient use of memory that slows computation. This article provides a gentle introduction to broadcasting with numerous examples ranging from simple to involved. It also provides hints on when and when not to use broadcasting.</source>
          <target state="translated">ブロードキャストと呼ばれるnumpyのより高度な概念を調べてみましょう。ブロードキャストという用語は、numpyが算術演算中にさまざまな形状の配列を処理する方法を説明しています。特定の制約に従い、小さい方のアレイは大きい方のアレイ全体に「ブロードキャスト」されるため、互換性のある形状になります。ブロードキャストは、PythonではなくCでループが発生するように、配列操作をベクトル化する手段を提供します。これは、データの不必要なコピーを作成することなくこれを行い、通常、効率的なアルゴリズムの実装につながります。ブロードキャストは、メモリの非効率的な使用につながり、計算が遅くなるため、悪い考えである場合もあります。この記事では、単純なものから複雑なものまで、さまざまな例を使用して、放送を穏やかに紹介します。また、ブロードキャストを使用するタイミングと使用しない場合のヒントも提供します。</target>
        </trans-unit>
        <trans-unit id="f8b59fac8428f8c1733e5af773d6cbf876149f27" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at two examples we&amp;rsquo;ve seen before to see how they might be implemented using Cython. These examples were compiled into extension modules using Cython 0.21.1.</source>
          <target state="translated">Cythonを使用して実装する方法を確認するために、これまでに見た2つの例を見てみましょう。これらの例は、Cython0.21.1を使用して拡張モジュールにコンパイルされました。</target>
        </trans-unit>
        <trans-unit id="ddfef2ee46e1e4256e10013c995a2b4530178cef" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say the two integers were in fact 1 and 770. Because 770 = 256 * 3 + 2, the 4 bytes in memory would contain respectively: 0, 1, 3, 2. The bytes I have loaded from the file would have these contents:</source>
          <target state="translated">2つの整数が実際には1と770だったとしましょう。770= 256 * 3 + 2なので、メモリ内の4バイトにはそれぞれ0、1、3、2が含まれます。ファイルからロードしたバイトには次の内容が含まれます。 ：</target>
        </trans-unit>
        <trans-unit id="95938c655542a69cb7228f0ca9c4b635920085cc" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you create this array:</source>
          <target state="translated">この配列を作成するとします。</target>
        </trans-unit>
        <trans-unit id="6b85caabf5e3eeb59af1ba993281156e38d2a215" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have this array:</source>
          <target state="translated">この配列があるとしましょう：</target>
        </trans-unit>
        <trans-unit id="d641e5a95c4dff41b3615beef8a44670fd8d8071" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this goes for our array:</source>
          <target state="translated">これが配列にどのように影響するかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="663e98c256d28e922f69b08f25c6c3b896decad0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this works in practice with just one matrix first. Note that according to &lt;a href=&quot;https://en.wikipedia.org/wiki/Grayscale#Colorimetric_(perceptual_luminance-preserving)_conversion_to_grayscale&quot;&gt;colorimetry&lt;/a&gt;, it is possible to obtain a fairly reasonable grayscale version of our color image if we apply the formula</source>
          <target state="translated">最初に1つの行列だけでこれが実際にどのように機能するかを見てみましょう。&lt;a href=&quot;https://en.wikipedia.org/wiki/Grayscale#Colorimetric_(perceptual_luminance-preserving)_conversion_to_grayscale&quot;&gt;測色法&lt;/a&gt;によれば、式を適用すると、カラー画像のかなり妥当なグレースケールバージョンを取得できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ba48f83aec5246b87728fc21ac0f71842c7f7846" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with this array, called &amp;ldquo;a&amp;rdquo;</source>
          <target state="translated">「a」と呼ばれるこの配列から始めましょう</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="8be2fdf380d9d18148fd2ad94dc354c20768a219" translate="yes" xml:space="preserve">
          <source>License of NumPy</source>
          <target state="translated">NumPyのライセンス</target>
        </trans-unit>
        <trans-unit id="538c09161b8497f998404cafc34964ed3a445575" translate="yes" xml:space="preserve">
          <source>Licensed under the 3-clause BSD License.</source>
          <target state="translated">3句BSDライセンスの下でライセンスされています。</target>
        </trans-unit>
        <trans-unit id="b0484b837c9aac64b9b4f0cbb8a409c60f826cd6" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#c.PyArray_DescrConverter&quot;&gt;&lt;code&gt;PyArray_DescrConverter&lt;/code&gt;&lt;/a&gt; except it aligns C-struct-like objects on word-boundaries as the compiler would.</source>
          <target state="translated">同様&lt;a href=&quot;#c.PyArray_DescrConverter&quot;&gt; &lt;code&gt;PyArray_DescrConverter&lt;/code&gt; &lt;/a&gt;コンパイラと同じように、それはC-構造体のようなワード境界上のオブジェクトを整列除いて。</target>
        </trans-unit>
        <trans-unit id="2bf9a983b58a3025088acd0d34cc34c35bed8eba" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#c.PyArray_DescrConverter2&quot;&gt;&lt;code&gt;PyArray_DescrConverter2&lt;/code&gt;&lt;/a&gt; except it aligns C-struct-like objects on word-boundaries as the compiler would.</source>
          <target state="translated">同様&lt;a href=&quot;#c.PyArray_DescrConverter2&quot;&gt; &lt;code&gt;PyArray_DescrConverter2&lt;/code&gt; &lt;/a&gt;コンパイラと同じように、それはC-構造体のようなワード境界上のオブジェクトを整列除いて。</target>
        </trans-unit>
        <trans-unit id="98e8d5db12d0ec6df75e2b77dc6308321b737245" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;generated/numpy.char.find#numpy.char.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.char.find#numpy.char.find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt;と似ていますが、部分文字列が見つからない場合は &lt;code&gt;ValueError&lt;/code&gt; を送出します。</target>
        </trans-unit>
        <trans-unit id="8cac4055aba9315ef35a508ccbff6fd2fccbce50" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;generated/numpy.char.rfind#numpy.char.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.char.rfind#numpy.char.rfind&quot;&gt; &lt;code&gt;rfind&lt;/code&gt; &lt;/a&gt;と似ていますが、部分文字列 &lt;code&gt;sub&lt;/code&gt; が見つからない場合は &lt;code&gt;ValueError&lt;/code&gt; を送出します。</target>
        </trans-unit>
        <trans-unit id="bfb637364ad5b206ba50bed21f3142c132fe9341" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.find.html#numpy.chararray.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="translated">&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.find.html#numpy.chararray.find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt;と似ていますが、部分文字列が見つからない場合は &lt;code&gt;ValueError&lt;/code&gt; を送出します。</target>
        </trans-unit>
        <trans-unit id="6f8c624e10b2f68f4700be90af9ceef9f419abcf" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.rfind.html#numpy.chararray.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.rfind.html#numpy.chararray.rfind&quot;&gt; &lt;code&gt;rfind&lt;/code&gt; &lt;/a&gt;と似ていますが、部分文字列 &lt;code&gt;sub&lt;/code&gt; が見つからない場合は &lt;code&gt;ValueError&lt;/code&gt; を送出します。</target>
        </trans-unit>
        <trans-unit id="74d7df04563822c7d8ad24dbe267870b77fbb351" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.char.find#numpy.char.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="translated">&lt;a href=&quot;numpy.char.find#numpy.char.find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt;と似ていますが、部分文字列が見つからない場合は &lt;code&gt;ValueError&lt;/code&gt; を送出します。</target>
        </trans-unit>
        <trans-unit id="b35ea9f95fe9a083c883dcd6041e1ed2b46d8192" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.char.rfind#numpy.char.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">&lt;a href=&quot;numpy.char.rfind#numpy.char.rfind&quot;&gt; &lt;code&gt;rfind&lt;/code&gt; &lt;/a&gt;と似ていますが、部分文字列 &lt;code&gt;sub&lt;/code&gt; が見つからない場合は &lt;code&gt;ValueError&lt;/code&gt; を送出します。</target>
        </trans-unit>
        <trans-unit id="1381300ae7e04647799c4d29476d81d2674e1d00" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.chararray.find#numpy.chararray.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="translated">&lt;a href=&quot;numpy.chararray.find#numpy.chararray.find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt;と同様ですが、部分文字列が見つからない場合は &lt;code&gt;ValueError&lt;/code&gt; が発生します。</target>
        </trans-unit>
        <trans-unit id="b6baf9238888e49aa859d8fb862f39242936cfbf" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.chararray.rfind#numpy.chararray.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">&lt;a href=&quot;numpy.chararray.rfind#numpy.chararray.rfind&quot;&gt; &lt;code&gt;rfind&lt;/code&gt; &lt;/a&gt;と同様ですが、部分文字列 &lt;code&gt;sub&lt;/code&gt; が見つからない &lt;code&gt;ValueError&lt;/code&gt; が発生します。</target>
        </trans-unit>
        <trans-unit id="8f6786bbc0e6826ccf967ce3d26832cec08da525" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;catch_warnings&lt;/code&gt; this context manager is not threadsafe.</source>
          <target state="translated">&lt;code&gt;catch_warnings&lt;/code&gt; と同様に、このコンテキストマネージャーはスレッドセーフではありません。</target>
        </trans-unit>
        <trans-unit id="4988e06267fc3ad462b8b1372828e98aa6abe4ae" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;recfromtxt&lt;/code&gt;, but with a default &lt;code&gt;delimiter=&quot;,&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;recfromtxt&lt;/code&gt; と同様ですが、デフォルトの &lt;code&gt;delimiter=&quot;,&quot;&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="b0fa83334e9080fab8905202d2a0b49831c3f225" translate="yes" xml:space="preserve">
          <source>Like for other types, NumPy includes a typedef npy_half for the 16 bit float. Unlike for most of the other types, you cannot use this as a normal type in C, since it is a typedef for npy_uint16. For example, 1.0 looks like 0x3c00 to C, and if you do an equality comparison between the different signed zeros, you will get -0.0 != 0.0 (0x8000 != 0x0000), which is incorrect.</source>
          <target state="translated">他の型と同様に、NumPyには16ビットのfloat用の型定義子npy_halfが含まれています。他のほとんどの型とは異なり、これはnpy_uint16の型定義であるため、C言語では通常の型として使用することはできません。例えば、1.0はC言語では0x3c00のように見えますが、異なる符号付きゼロの間で等値比較を行うと、-0.0 !=0.0 (0x8000 !=0x0000)となり、これは正しくありません。</target>
        </trans-unit>
        <trans-unit id="e112999c2cd378720fa09f5bf6d3cb8761f7e014" translate="yes" xml:space="preserve">
          <source>Like with some other special methods in python, such as &lt;code&gt;__hash__&lt;/code&gt; and &lt;code&gt;__iter__&lt;/code&gt;, it is possible to indicate that your class does &lt;em&gt;not&lt;/em&gt; support ufuncs by setting &lt;code&gt;__array_ufunc__ = None&lt;/code&gt;. Ufuncs always raise &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; when called on an object that sets &lt;code&gt;__array_ufunc__ = None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__hash__&lt;/code&gt; や &lt;code&gt;__iter__&lt;/code&gt; など、Pythonの他のいくつかの特別なメソッドと同様に、 &lt;code&gt;__array_ufunc__ = None&lt;/code&gt; 設定することにより、クラスがufuncをサポートしてい&lt;em&gt;ない&lt;/em&gt;ことを示すことができます。Ufuncs は、 &lt;code&gt;__array_ufunc__ = None&lt;/code&gt; を設定するオブジェクトで呼び出されると、常に&lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; を発生&lt;/a&gt;させます。</target>
        </trans-unit>
        <trans-unit id="4aa7900482808a9df749231293505b57d3e3de9c" translate="yes" xml:space="preserve">
          <source>Likewise, ellipsis can be specified by code by using the Ellipsis object:</source>
          <target state="translated">同様に、Ellipsisオブジェクトを使用することで、コードでellipsisを指定することができます。</target>
        </trans-unit>
        <trans-unit id="3297842e50729fb77f4f0545de2f9ff7aa3909b6" translate="yes" xml:space="preserve">
          <source>Likewise, slicing can be combined with broadcasted boolean indices:</source>
          <target state="translated">同様に、スライスはブロードキャストされたブーリアンインデックスと組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="aed0f783a12a4ca0992442cfbd711f6845a91b7b" translate="yes" xml:space="preserve">
          <source>Limpert, E., Stahel, W. A., and Abbt, M., &amp;ldquo;Log-normal Distributions across the Sciences: Keys and Clues,&amp;rdquo; BioScience, Vol. 51, No. 5, May, 2001. &lt;a href=&quot;https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf&quot;&gt;https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf&lt;/a&gt;</source>
          <target state="translated">Limpert、E.、Stahel、WA、およびAbbt、M。、「サイエンス全体の対数正規分布：キーと手がかり」、BioScience、Vol。51、No。5、2001年5月&lt;a href=&quot;https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf&quot;&gt;。https：//stat.ethz.ch/~stahel/lognormal/bioscience.pdf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2c6327e28944d450d23eb12c3f0eb10b95ac744a" translate="yes" xml:space="preserve">
          <source>LinAlgError</source>
          <target state="translated">LinAlgError</target>
        </trans-unit>
        <trans-unit id="fbfdf4025591ea0589baa96d7f54fd5d7f0a5dbd" translate="yes" xml:space="preserve">
          <source>Line breaks are not included in the resulting list unless keepends is given and true.</source>
          <target state="translated">keependsが与えられていてtrueでない限り、改行は結果のリストには含まれません。</target>
        </trans-unit>
        <trans-unit id="fd8f1853d29d8157d704e36102bd70d85ec315bd" translate="yes" xml:space="preserve">
          <source>Line spacing and indentation are significant and should be carefully followed.</source>
          <target state="translated">行間やインデントは重要な意味を持ちますので、注意が必要です。</target>
        </trans-unit>
        <trans-unit id="fcb739908d0a50031f680d3b4fffc6749c4002d3" translate="yes" xml:space="preserve">
          <source>Linear Algebra</source>
          <target state="translated">線形代数</target>
        </trans-unit>
        <trans-unit id="4c2d7925777b262f78b0ed1ceeb1f07eef61acc7" translate="yes" xml:space="preserve">
          <source>Linear Algebra Equivalents</source>
          <target state="translated">線形代数の等価物</target>
        </trans-unit>
        <trans-unit id="c77bb2c05a2dcf0461045da9b6109d509594fc9a" translate="yes" xml:space="preserve">
          <source>Linear Algebra libraries</source>
          <target state="translated">線形代数ライブラリ</target>
        </trans-unit>
        <trans-unit id="06d74260ba46e8ed76ff22dda956f18a7b66203c" translate="yes" xml:space="preserve">
          <source>Linear algebra</source>
          <target state="translated">線形代数</target>
        </trans-unit>
        <trans-unit id="ef4be3efd16d5b211ab89b5efbf030ca1bafba61" translate="yes" xml:space="preserve">
          <source>Linear algebra (&lt;code&gt;numpy.linalg&lt;/code&gt;)</source>
          <target state="translated">線形代数（ &lt;code&gt;numpy.linalg&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="e2be6b18cf91c04a7b6c400bd00876f94a2389cb" translate="yes" xml:space="preserve">
          <source>Linear algebra (numpy.linalg)</source>
          <target state="translated">線形代数 (numpy.linalg)</target>
        </trans-unit>
        <trans-unit id="b624aab78757a9b353883b1449d6df824049976b" translate="yes" xml:space="preserve">
          <source>Linear algebra on several matrices at once</source>
          <target state="translated">一度に複数の行列の線形代数</target>
        </trans-unit>
        <trans-unit id="991cbbcb4b1ecb2172a95ff800353dc3c4b54edd" translate="yes" xml:space="preserve">
          <source>Linear map parameters between domains.</source>
          <target state="translated">ドメイン間の線形マップパラメータ。</target>
        </trans-unit>
        <trans-unit id="eb36eb210c8667bae908d8f0d19ef3098c4c1701" translate="yes" xml:space="preserve">
          <source>Link extension module with &amp;lt;resource&amp;gt; as defined by &lt;code&gt;numpy_distutils/system_info.py&lt;/code&gt;. E.g. to link with optimized LAPACK libraries (vecLib on MacOSX, ATLAS elsewhere), use &lt;code&gt;--link-lapack_opt&lt;/code&gt;. See also &lt;code&gt;--help-link&lt;/code&gt; switch.</source>
          <target state="translated">拡張モジュールを &lt;code&gt;numpy_distutils/system_info.py&lt;/code&gt; で定義されている&amp;lt;resource&amp;gt;にリンクします。たとえば、最適化されたLAPACKライ​​ブラリ（MacOSXではvecLib、その他ではATLAS）とリンクするには、 &lt;code&gt;--link-lapack_opt&lt;/code&gt; 使用します。 &lt;code&gt;--help-link&lt;/code&gt; switchも参照してください。</target>
        </trans-unit>
        <trans-unit id="26958b7c786c621d84d02830a0b14f77df5b2d9e" translate="yes" xml:space="preserve">
          <source>Linking against the core math library in an extension</source>
          <target state="translated">拡張機能でのコア数学ライブラリとのリンク</target>
        </trans-unit>
        <trans-unit id="f9ddb8c3deec44cd98e047bb68bdaf188f3b72f8" translate="yes" xml:space="preserve">
          <source>Linking your repository to the upstream repo</source>
          <target state="translated">リポジトリを上流のレポにリンクする</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="2d54756ca8573af092113bb3435c0903eeb35dd6" translate="yes" xml:space="preserve">
          <source>Links : If you need to include hyperlinks in your docstring, note that some docstring sections are not parsed as standard reST, and in these sections, numpydoc may become confused by hyperlink targets such as:</source>
          <target state="translated">リンク:docstringにハイパーリンクを含める必要がある場合、いくつかのdocstringセクションは標準のreSTとして解析されておらず、これらのセクションでは、numpydocはハイパーリンクターゲットのようなもので混乱する可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="518ed7ba947b32b000717c46a46d61dd856bd112" translate="yes" xml:space="preserve">
          <source>Linus Torvalds on &lt;a href=&quot;http://kerneltrap.org/Linux/Git_Management&quot;&gt;git management&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://kerneltrap.org/Linux/Git_Management&quot;&gt;git管理&lt;/a&gt;に関するLinusTorvalds</target>
        </trans-unit>
        <trans-unit id="965d93d3a9947030cc756b2db0fcacc76437a993" translate="yes" xml:space="preserve">
          <source>Linus Torvalds on &lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;linux git workflow&lt;/a&gt; . Summary; use the git tools to make the history of your edits as clean as possible; merge from upstream edits as little as possible in branches where you are doing active development.</source>
          <target state="translated">上のLinus Torvalds氏&lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;のLinux gitのワークフロー&lt;/a&gt;。概要; gitツールを使用して、編集の履歴をできるだけきれいにします。アクティブな開発を行っているブランチでは、アップストリーム編集からのマージをできるだけ少なくします。</target>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="d1400c37d080d60eab76dbcb84834f7292aae696" translate="yes" xml:space="preserve">
          <source>Linux timings used Ubuntu 18.04 and GCC 7.4. Windows timings were made on Windows 10 using Microsoft C/C++ Optimizing Compiler Version 19 (Visual Studio 2015). All timings were produced on a i5-3570 processor.</source>
          <target state="translated">LinuxのタイミングはUbuntu 18.04とGCC 7.4を使用しました。Windowsのタイミングは、Microsoft C/C++Optimizing Compiler Version 19 (Visual Studio 2015)を使用してWindows 10で作成しました。すべてのタイミングは、i5-3570プロセッサで作成されました。</target>
        </trans-unit>
        <trans-unit id="56d0cc5c207ff297b983e9b52ef59aa241b28b67" translate="yes" xml:space="preserve">
          <source>Linux timings used Ubuntu 18.04 and GCC 7.4. Windows timings were made on Windows 10 using Microsoft C/C++ Optimizing Compiler Version 19 (Visual Studio 2015). All timings were produced on an i5-3570 processor.</source>
          <target state="translated">LinuxのタイミングはUbuntu 18.04とGCC 7.4を使用しました。Windowsのタイミングは、Microsoft C/C++Optimizing Compiler Version 19 (Visual Studio 2015)を使用してWindows 10で作成しました。すべてのタイミングは、i5-3570プロセッサで作成されました。</target>
        </trans-unit>
        <trans-unit id="87860891be4cddda593f0fa03126f25fb568db9f" translate="yes" xml:space="preserve">
          <source>Linux: 32-bit and 64-bit Manylinux1 wheels built using travis-ci.</source>
          <target state="translated">Linux。32-bit と 64-bit の Manylinux1 ホイールは travis-ci を使ってビルドされています。</target>
        </trans-unit>
        <trans-unit id="97d9791ab8737c4211f3e78630cca56638f02eb1" translate="yes" xml:space="preserve">
          <source>List available Fortran compilers.</source>
          <target state="translated">利用可能なFortranコンパイラをリストアップします。</target>
        </trans-unit>
        <trans-unit id="eb5d7118db68e7b8996c3d0844e8e2d779102b13" translate="yes" xml:space="preserve">
          <source>List of array-like objects (such as lists, tuples, and ndarrays).</source>
          <target state="translated">配列のようなオブジェクト(リスト、タプル、ndarraysなど)のリスト。</target>
        </trans-unit>
        <trans-unit id="decb4e37dac06b0a04b2b5a1ce16d06dbaf9430d" translate="yes" xml:space="preserve">
          <source>List of maximum degrees of the form [x_deg, y_deg, z_deg].</source>
          <target state="translated">x_deg,y_deg,z_deg]という形式の最大次数のリスト。</target>
        </trans-unit>
        <trans-unit id="16b40ddc35115642a1ebd2b343c063499d9e736a" translate="yes" xml:space="preserve">
          <source>List of maximum degrees of the form [x_deg, y_deg].</source>
          <target state="translated">x_deg,y_deg]形式の最大次数のリスト。</target>
        </trans-unit>
        <trans-unit id="3946ce7ee00307be1e56a351d33b3682868445a4" translate="yes" xml:space="preserve">
          <source>List of roots.</source>
          <target state="translated">ルーツの一覧です。</target>
        </trans-unit>
        <trans-unit id="4e5a894ae66af5e5eb828b13d596e0e9298ff835" translate="yes" xml:space="preserve">
          <source>List of source file locations relative to the top directory of the package.</source>
          <target state="translated">パッケージのトップディレクトリからの相対的なソースファイルの場所のリスト。</target>
        </trans-unit>
        <trans-unit id="2c7afb1b33d8f0bf102c5fdc5f3bfa27a81be1cb" translate="yes" xml:space="preserve">
          <source>List of the library&amp;rsquo;s source files. See &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_library&quot;&gt;&lt;code&gt;add_library&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">ライブラリのソースファイルのリスト。詳細については、&lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_library&quot;&gt; &lt;code&gt;add_library&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5754e63d6ae44ac265c0defe49c460674a2539b7" translate="yes" xml:space="preserve">
          <source>List of the most important terms</source>
          <target state="translated">最重要用語一覧</target>
        </trans-unit>
        <trans-unit id="6519aa721c25f67c763afcfac03293aba9cab8a8" translate="yes" xml:space="preserve">
          <source>List of the sources. The list of sources may contain functions (called source generators) which must take an extension instance and a build directory as inputs and return a source file or list of source files or None. If None is returned then no sources are generated. If the Extension instance has no sources after processing all source generators, then no extension module is built.</source>
          <target state="translated">ソースのリスト。ソースのリストには、拡張子インスタンスとビルドディレクトリを入力として受け取り、ソースファイルまたはソースファイルのリストを返すか、または None を返す関数 (ソースジェネレータと呼ばれる)を含めることができます。None が返された場合、ソースは生成されません。すべてのソース・ジェネレータを処理した後で、Extension インスタンスにソースがない場合、Extension モジュールはビルドされません。</target>
        </trans-unit>
        <trans-unit id="2485a7cc99c4617bf66ce59e5b75a2d0c1ccfb4b" translate="yes" xml:space="preserve">
          <source>List system resources found by &lt;code&gt;numpy_distutils/system_info.py&lt;/code&gt;. For example, try &lt;code&gt;f2py --help-link lapack_opt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;numpy_distutils/system_info.py&lt;/code&gt; によって検出されたシステムリソースを一覧表示します。たとえば、 &lt;code&gt;f2py --help-link lapack_opt&lt;/code&gt; 試してください。</target>
        </trans-unit>
        <trans-unit id="50800b4f18e2a927baac61501f7e23170e957be0" translate="yes" xml:space="preserve">
          <source>List with any extra arguments to pass to nosetests.</source>
          <target state="translated">nosetestsに渡す引数を追加したリスト。</target>
        </trans-unit>
        <trans-unit id="70836ea6cfbd010e5c69675c6ed9768657e90763" translate="yes" xml:space="preserve">
          <source>Literal string representation.</source>
          <target state="translated">リテラル文字列表現。</target>
        </trans-unit>
        <trans-unit id="d75a54184aa53b5be4e832c635455d88f3cdc5e6" translate="yes" xml:space="preserve">
          <source>Load a pickle from the current string.</source>
          <target state="translated">現在の文字列からピクルスを読み込みます。</target>
        </trans-unit>
        <trans-unit id="3a504cdc1122f04029c4d408c355532536995f45" translate="yes" xml:space="preserve">
          <source>Load arrays or pickled objects from &lt;code&gt;.npy&lt;/code&gt;, &lt;code&gt;.npz&lt;/code&gt; or pickled files.</source>
          <target state="translated">&lt;code&gt;.npy&lt;/code&gt; 、 &lt;code&gt;.npz&lt;/code&gt; 、またはピクル化されたファイルから配列またはピクル化されたオブジェクトをロードします。</target>
        </trans-unit>
        <trans-unit id="9d2a30e3c587d0309a2b15e920e2381e52d3b73a" translate="yes" xml:space="preserve">
          <source>Load data from a text file, with missing values handled as specified.</source>
          <target state="translated">テキストファイルからデータをロードします。</target>
        </trans-unit>
        <trans-unit id="671e399a95a295b1b112f2ec88bde3aa682ce01d" translate="yes" xml:space="preserve">
          <source>Load data from a text file.</source>
          <target state="translated">テキストファイルからデータを読み込みます。</target>
        </trans-unit>
        <trans-unit id="ede7696890a000813048b7b45d0ec4e8eaa41ac3" translate="yes" xml:space="preserve">
          <source>Load data with missing values handled as specified.</source>
          <target state="translated">欠損値を指定通りに処理したデータを読み込みます。</target>
        </trans-unit>
        <trans-unit id="0fb4575d68b4fb0f498f6ef6cd58ad29dfef99ec" translate="yes" xml:space="preserve">
          <source>Load the files created by savez_compressed.</source>
          <target state="translated">savez_compressedで作成したファイルを読み込みます。</target>
        </trans-unit>
        <trans-unit id="00e2276e50083512489893c74a3667bfb2f8d261" translate="yes" xml:space="preserve">
          <source>Load the memmap and verify data was stored:</source>
          <target state="translated">memmapをロードして、データが保存されていることを確認します。</target>
        </trans-unit>
        <trans-unit id="f5bde0422e688546d3fcbda903a1675bdef859be" translate="yes" xml:space="preserve">
          <source>Load the shared library.</source>
          <target state="translated">共有ライブラリを読み込みます。</target>
        </trans-unit>
        <trans-unit id="4f1b35f9beeb82ff23b55bdd7e4bccbaa09655da" translate="yes" xml:space="preserve">
          <source>Loading files that contain object arrays uses the &lt;code&gt;pickle&lt;/code&gt; module, which is not secure against erroneous or maliciously constructed data. Consider passing &lt;code&gt;allow_pickle=False&lt;/code&gt; to load data that is known not to contain object arrays for the safer handling of untrusted sources.</source>
          <target state="translated">オブジェクト配列を含むファイルの読み込みには &lt;code&gt;pickle&lt;/code&gt; モジュールが使用されますが、これは誤ったデータや悪意を持って作成されたデータに対して安全ではありません。信頼できないソースをより安全に処理するために、オブジェクト配列を含まないことがわかっているデータをロードするには、 &lt;code&gt;allow_pickle=False&lt;/code&gt; を渡すことを検討してください。</target>
        </trans-unit>
        <trans-unit id="dc43ff557f7299b63c00a5f98241bc55534a0318" translate="yes" xml:space="preserve">
          <source>Loading the shared library</source>
          <target state="translated">共有ライブラリの読み込み</target>
        </trans-unit>
        <trans-unit id="dcd21227c7ed1f7628c4569c3c3b1f97f5e4a3e0" translate="yes" xml:space="preserve">
          <source>Local file path or URL to open.</source>
          <target state="translated">開くローカルファイルのパスまたはURL。</target>
        </trans-unit>
        <trans-unit id="399e1ff0ce348a172dad0b088afb4891c55b0357" translate="yes" xml:space="preserve">
          <source>Lock instance that is shared so that the same BitGenerator can be used in multiple Generators without corrupting the state. Code that generates values from a bit generator should hold the bit generator&amp;rsquo;s lock.</source>
          <target state="translated">共有されているインスタンスをロックして、同じBitGeneratorを複数のジェネレーターで状態を壊すことなく使用できるようにします。ビットジェネレーターから値を生成するコードは、ビットジェネレーターのロックを保持する必要があります。</target>
        </trans-unit>
        <trans-unit id="2d415fb960b72005c6491287e9aedba95abd331c" translate="yes" xml:space="preserve">
          <source>Lock instance that is shared so that the same bit git generator can be used in multiple Generators without corrupting the state. Code that generates values from a bit generator should hold the bit generator&amp;rsquo;s lock.</source>
          <target state="translated">共有されるインスタンスをロックして、同じビットのgitジェネレーターを複数のジェネレーターで状態を壊さずに使用できるようにします。ビットジェネレーターから値を生成するコードは、ビットジェネレーターのロックを保持する必要があります。</target>
        </trans-unit>
        <trans-unit id="107cbe58cd70b9b9564b7a980ec9a134ba83ff37" translate="yes" xml:space="preserve">
          <source>Log error message:</source>
          <target state="translated">ログのエラーメッセージを表示します。</target>
        </trans-unit>
        <trans-unit id="4eb269913863abecf02addc638fee893d2c7588f" translate="yes" xml:space="preserve">
          <source>Log into your &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; account.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;アカウントにログインします。</target>
        </trans-unit>
        <trans-unit id="5b18e27bd081f5e88f5467d9d05245be1522ecbd" translate="yes" xml:space="preserve">
          <source>Logarithm is a multivalued function: for each &lt;code&gt;x&lt;/code&gt; there is an infinite number of &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;10**z = x&lt;/code&gt;. The convention is to return the &lt;code&gt;z&lt;/code&gt; whose imaginary part lies in &lt;code&gt;[-pi, pi]&lt;/code&gt;.</source>
          <target state="translated">対数は多値関数です。各 &lt;code&gt;x&lt;/code&gt; に対して、 &lt;code&gt;10**z = x&lt;/code&gt; ような &lt;code&gt;z&lt;/code&gt; の無限数があります。規約は、虚数部が &lt;code&gt;[-pi, pi]&lt;/code&gt; ある &lt;code&gt;z&lt;/code&gt; を返すことです。</target>
        </trans-unit>
        <trans-unit id="5a52fe88f1d34f63b32537a63132c16ed59948f4" translate="yes" xml:space="preserve">
          <source>Logarithm is a multivalued function: for each &lt;code&gt;x&lt;/code&gt; there is an infinite number of &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;2**z = x&lt;/code&gt;. The convention is to return the &lt;code&gt;z&lt;/code&gt; whose imaginary part lies in &lt;code&gt;[-pi, pi]&lt;/code&gt;.</source>
          <target state="translated">対数は多値関数です。各 &lt;code&gt;x&lt;/code&gt; に対して、 &lt;code&gt;2**z = x&lt;/code&gt; ような &lt;code&gt;z&lt;/code&gt; の数は無限です。規約は、虚数部が &lt;code&gt;[-pi, pi]&lt;/code&gt; ある &lt;code&gt;z&lt;/code&gt; を返すことです。</target>
        </trans-unit>
        <trans-unit id="04517496328a3b4c1d39612790fc59d3b950de57" translate="yes" xml:space="preserve">
          <source>Logarithm is a multivalued function: for each &lt;code&gt;x&lt;/code&gt; there is an infinite number of &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;exp(z) = 1 + x&lt;/code&gt;. The convention is to return the &lt;code&gt;z&lt;/code&gt; whose imaginary part lies in &lt;code&gt;[-pi, pi]&lt;/code&gt;.</source>
          <target state="translated">対数は多値関数です。各 &lt;code&gt;x&lt;/code&gt; に対して、 &lt;code&gt;exp(z) = 1 + x&lt;/code&gt; ような &lt;code&gt;z&lt;/code&gt; の数は無限です。規約は、虚数部が &lt;code&gt;[-pi, pi]&lt;/code&gt; ある &lt;code&gt;z&lt;/code&gt; を返すことです。</target>
        </trans-unit>
        <trans-unit id="8f044358a356b12f8f04d65ec46fba2c711db9ca" translate="yes" xml:space="preserve">
          <source>Logarithm is a multivalued function: for each &lt;code&gt;x&lt;/code&gt; there is an infinite number of &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;exp(z) = x&lt;/code&gt;. The convention is to return the &lt;code&gt;z&lt;/code&gt; whose imaginary part lies in &lt;code&gt;[-pi, pi]&lt;/code&gt;.</source>
          <target state="translated">対数は多値関数です。各 &lt;code&gt;x&lt;/code&gt; に対して、 &lt;code&gt;exp(z) = x&lt;/code&gt; ような &lt;code&gt;z&lt;/code&gt; の数は無限にあります。規約は、虚数部が &lt;code&gt;[-pi, pi]&lt;/code&gt; ある &lt;code&gt;z&lt;/code&gt; を返すことです。</target>
        </trans-unit>
        <trans-unit id="166930005429709b3b373125970bc9f001b57f22" translate="yes" xml:space="preserve">
          <source>Logarithm of &lt;code&gt;exp(x1) + exp(x2)&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;exp(x1) + exp(x2)&lt;/code&gt; 対数。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="0df50307c119146d5dc714638f54a5eccd592099" translate="yes" xml:space="preserve">
          <source>Logarithm of the sum of exponentiations of inputs in base 2.</source>
          <target state="translated">ベース2の入力の指数の和の対数。</target>
        </trans-unit>
        <trans-unit id="3a29b9b1054fef950824734dd96565e57e322c96" translate="yes" xml:space="preserve">
          <source>Logarithm of the sum of exponentiations of the inputs in base-2.</source>
          <target state="translated">ベース2の入力の指数の和の対数。</target>
        </trans-unit>
        <trans-unit id="273c857a62012f5708232560c688d9c8f7c28ba5" translate="yes" xml:space="preserve">
          <source>Logarithm of the sum of exponentiations of the inputs.</source>
          <target state="translated">入力の指数の和の対数。</target>
        </trans-unit>
        <trans-unit id="e7b8fad3893b278189df782f86ba4d32084ced17" translate="yes" xml:space="preserve">
          <source>Logarithm to base 10 of the Euler constant (</source>
          <target state="translated">オイラー定数の基底10への対数 (</target>
        </trans-unit>
        <trans-unit id="80963c1ddcee26932e512e1ef164c3f919eb6773" translate="yes" xml:space="preserve">
          <source>Logarithm to base 2 of the Euler constant (</source>
          <target state="translated">オイラー定数の基底2への対数 (</target>
        </trans-unit>
        <trans-unit id="dca3308567585813d8c4516ae0b5df7d6382aa24" translate="yes" xml:space="preserve">
          <source>Logic functions</source>
          <target state="translated">ロジック機能</target>
        </trans-unit>
        <trans-unit id="acdcdb17721480a7efeeb33b0138faad218dbf31" translate="yes" xml:space="preserve">
          <source>Logical NOT is applied to the elements of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">論理NOTは &lt;code&gt;x&lt;/code&gt; の要素に適用されます。</target>
        </trans-unit>
        <trans-unit id="98ddc2178009c7731c8ae53ab405983c8f38c802" translate="yes" xml:space="preserve">
          <source>Logical OR is applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">論理ORは、 &lt;code&gt;x1&lt;/code&gt; および &lt;code&gt;x2&lt;/code&gt; の要素に適用されます。 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状にブロードキャスト可能でなければなりません（これが出力の形状になります）。</target>
        </trans-unit>
        <trans-unit id="f5bd72920a8d92e6480e74978ed9235cd1d3ad95" translate="yes" xml:space="preserve">
          <source>Logical XOR is applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">論理XORは、 &lt;code&gt;x1&lt;/code&gt; および &lt;code&gt;x2&lt;/code&gt; の要素に適用されます。 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状にブロードキャスト可能でなければなりません（これが出力の形状になります）。</target>
        </trans-unit>
        <trans-unit id="ab411408fbd29ad68b53700b2e7826c03e6703f0" translate="yes" xml:space="preserve">
          <source>Logical operations</source>
          <target state="translated">論理演算</target>
        </trans-unit>
        <trans-unit id="f9360627c5984485d4c34bec86c9dfebc0835bd0" translate="yes" xml:space="preserve">
          <source>Logspace is equivalent to the code</source>
          <target state="translated">ログスペースはコード</target>
        </trans-unit>
        <trans-unit id="05614c0010510d48dea6823d792acc33ba6daeb2" translate="yes" xml:space="preserve">
          <source>Long answer</source>
          <target state="translated">ロングアンサー</target>
        </trans-unit>
        <trans-unit id="cfff3eff895eee45ffb53c164dd9129e264c6241" translate="yes" xml:space="preserve">
          <source>Long arrays can be summarised:</source>
          <target state="translated">長い配列をまとめることができます。</target>
        </trans-unit>
        <trans-unit id="8677f57b867596167599f15cd53463b229e648c6" translate="yes" xml:space="preserve">
          <source>Lots of learning overhead:</source>
          <target state="translated">沢山の学習オーバーヘッド。</target>
        </trans-unit>
        <trans-unit id="dcabfd17cd19c7e1ebdad9125ee467aec3f27671" translate="yes" xml:space="preserve">
          <source>Low-level floating point manipulation</source>
          <target state="translated">低レベルの浮動小数点操作</target>
        </trans-unit>
        <trans-unit id="20bd4a379661919ac01507844a8735e9e7029b21" translate="yes" xml:space="preserve">
          <source>Low-level function which converts a 16-bit half-precision float into a 32-bit single-precision float, stored as a uint32.</source>
          <target state="translated">16ビットの半精度フロートを32ビットの単精度フロートに変換する低レベル関数で、uint32として格納されます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
