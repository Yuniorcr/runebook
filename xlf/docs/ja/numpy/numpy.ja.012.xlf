<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="67373bb92cd7ecbf243edb9d60ad6f00f86a6052" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">も参照してください。</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">参照</target>
        </trans-unit>
        <trans-unit id="1234129c54dee52191f9a009e54d14ba3cd7901d" translate="yes" xml:space="preserve">
          <source>See also the corresponding attribute of the derived class of interest.</source>
          <target state="translated">興味のある派生クラスの対応する属性も参照してください。</target>
        </trans-unit>
        <trans-unit id="83750efeee588beded293ee3f9269da81e7c7a09" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;generated/numpy.einsum#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; function for more details.</source>
          <target state="translated">詳細については、関数&lt;a href=&quot;generated/numpy.einsum#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b4f3fbbc86b01e081d4bf3029eeb047323af050f" translate="yes" xml:space="preserve">
          <source>See the class docstring for the number of bits returned.</source>
          <target state="translated">返されるビット数については、クラスの docstring を参照してください。</target>
        </trans-unit>
        <trans-unit id="c83ee6459f11d959cce47b344352f4193d454359" translate="yes" xml:space="preserve">
          <source>See the function &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt; for an alternative mechanism introduced in NumPy 1.6.0.</source>
          <target state="translated">NumPy 1.6.0で導入された代替メカニズムについては、関数&lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt; &lt;code&gt;PyArray_MinScalarType&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5b5e9065c0e163926104e92911bff64adedee471" translate="yes" xml:space="preserve">
          <source>See the function &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt; for details of NumPy type promotion, updated in NumPy 1.6.0.</source>
          <target state="translated">NumPy 1.6.0で更新されたNumPyタイプの昇格の詳細については、関数&lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="27b980b7065c19a238ed0ab9383f5a540a5d637c" translate="yes" xml:space="preserve">
          <source>See the more detailed documentation for &lt;code&gt;numpy.diagonal&lt;/code&gt; if you use this function to extract a diagonal and wish to write to the resulting array; whether it returns a copy or a view depends on what version of numpy you are using.</source>
          <target state="translated">この関数を使用して対角線を抽出し、結果の配列に書き込みたい場合は、 &lt;code&gt;numpy.diagonal&lt;/code&gt; の詳細なドキュメントを参照してください。コピーを返すかビューを返すかは、使用しているnumpyのバージョンによって異なります。</target>
        </trans-unit>
        <trans-unit id="a367dbe20937470e410dfbea9585fd8048f1569d" translate="yes" xml:space="preserve">
          <source>See the notes and examples for clarification.</source>
          <target state="translated">注釈と例を参照して明確にしてください。</target>
        </trans-unit>
        <trans-unit id="ed05825174e3134f290feabd650cdebd78790e5d" translate="yes" xml:space="preserve">
          <source>See the notes for an outline of the algorithm.</source>
          <target state="translated">アルゴリズムの概要については、注意事項を参照してください。</target>
        </trans-unit>
        <trans-unit id="2de41805fe60d43135ccbebaad2f5782594f2632" translate="yes" xml:space="preserve">
          <source>SeedSequence mixes sources of entropy in a reproducible way to set the initial state for independent and very probably non-overlapping BitGenerators.</source>
          <target state="translated">SeedSequenceは、再現性の高い方法でエントロピー源を混合し、独立した、おそらく重なりのないBitGeneratorの初期状態を設定します。</target>
        </trans-unit>
        <trans-unit id="c837283b736981a9d882e30832f45d2c3a206514" translate="yes" xml:space="preserve">
          <source>SeedSequence spawning</source>
          <target state="translated">シードシーケンス産卵</target>
        </trans-unit>
        <trans-unit id="28355ed4d1be051fdd750124cc876d1fa222f5c2" translate="yes" xml:space="preserve">
          <source>SeedSequence.entropy</source>
          <target state="translated">SeedSequence.entropy</target>
        </trans-unit>
        <trans-unit id="03d7f2826ccb833676fbe70c0022e77d2e2c9c55" translate="yes" xml:space="preserve">
          <source>SeedSequence.generate_state()</source>
          <target state="translated">SeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="c4d5a701757a2a9341845319c69171cb1c646cf5" translate="yes" xml:space="preserve">
          <source>SeedSequence.spawn()</source>
          <target state="translated">SeedSequence.spawn()</target>
        </trans-unit>
        <trans-unit id="9ba62987b34fe8fc63485d9dd7e815f3286c5601" translate="yes" xml:space="preserve">
          <source>SeedSequence.spawn_key</source>
          <target state="translated">SeedSequence.spawn_key</target>
        </trans-unit>
        <trans-unit id="8803a737a63e4b3f599d7264c369bdc58f640281" translate="yes" xml:space="preserve">
          <source>Seeding and Entropy</source>
          <target state="translated">種付けとエントロピー</target>
        </trans-unit>
        <trans-unit id="e478fbf4bf9d911f2c366f8992866e1d7b083794" translate="yes" xml:space="preserve">
          <source>Seeding and State</source>
          <target state="translated">種付けと状態</target>
        </trans-unit>
        <trans-unit id="37cd3865c006d959fb649d73b618699ccd761419" translate="yes" xml:space="preserve">
          <source>Seeds can be passed to any of the BitGenerators. The provided value is mixed via &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to spread a possible sequence of seeds across a wider range of initialization states for the BitGenerator. Here &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; is used and is wrapped with a &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">シードは任意のBitGeneratorに渡すことができます。提供された値は&lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;を介して混合され、可能なシードのシーケンスをBitGeneratorのより広い範囲の初期化状態に分散します。ここでは&lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;が使用され、&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;ラップされています。</target>
        </trans-unit>
        <trans-unit id="befc8fb6b3706476b647851ec8b54ce3f110f269" translate="yes" xml:space="preserve">
          <source>Selection algorithm. Default is &amp;lsquo;introselect&amp;rsquo;</source>
          <target state="translated">選択アルゴリズム。デフォルトは「introselect」です</target>
        </trans-unit>
        <trans-unit id="ad6f6961c3fd31b6fdfea3ebca7b48b26cade497" translate="yes" xml:space="preserve">
          <source>Selection algorithm. Default is &amp;lsquo;introselect&amp;rsquo;.</source>
          <target state="translated">選択アルゴリズム。デフォルトは「introselect」です。</target>
        </trans-unit>
        <trans-unit id="d113b695dceac1abca63d8057088ab91eda91dcc" translate="yes" xml:space="preserve">
          <source>Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</source>
          <target state="translated">シェイプ内の一次元エントリのサブセットを選択します。シェイプエントリが1より大きい軸が選択された場合、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="ce43c468d1865e00edb6873541f360679646ae28" translate="yes" xml:space="preserve">
          <source>Separator between array items for text output. If &amp;ldquo;&amp;rdquo; (empty), a binary file is written, equivalent to &lt;code&gt;file.write(a.tobytes())&lt;/code&gt;.</source>
          <target state="translated">テキスト出力用の配列項目間のセパレーター。「」（空）の場合、 &lt;code&gt;file.write(a.tobytes())&lt;/code&gt; と同等のバイナリファイルが書き込まれます。</target>
        </trans-unit>
        <trans-unit id="69c3854cf2f97e2b89f4f88e15dea295b287e18d" translate="yes" xml:space="preserve">
          <source>Separator between items if file is a text file. Empty (&amp;ldquo;&amp;rdquo;) separator means the file should be treated as binary. Spaces (&amp;rdquo; &amp;ldquo;) in the separator match zero or more whitespace characters. A separator consisting only of spaces must match at least one whitespace.</source>
          <target state="translated">ファイルがテキストファイルの場合、アイテム間の区切り文字。空（ &quot;&quot;）の区切り記号は、ファイルをバイナリとして扱う必要があることを意味します。区切り文字のスペース（ &quot;&quot;）は、ゼロ個以上の空白文字と一致します。スペースのみで構成されるセパレータは、少なくとも1つの空白と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="58b5ef82070109089258d37935f6f8dd60465e83" translate="yes" xml:space="preserve">
          <source>Separator to split each string element in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">セパレータは、各文字列要素を分割します。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fda4d938e57bdf80fd45be4a4b9ed3293812c803" translate="yes" xml:space="preserve">
          <source>Sequence containing the roots.</source>
          <target state="translated">根を含むシーケンス。</target>
        </trans-unit>
        <trans-unit id="577113b6ca2471336f20adea7da8449aa1b619c6" translate="yes" xml:space="preserve">
          <source>Sequence of Poly series coefficients. This routine fails for empty sequences.</source>
          <target state="translated">ポリ級数係数のシーケンス。このルーチンは、空のシーケンスでは失敗します。</target>
        </trans-unit>
        <trans-unit id="0cd7f24fb8c01924663f200685435e6585e0483c" translate="yes" xml:space="preserve">
          <source>Sequence of title strings. An empty list can be used to leave titles out.</source>
          <target state="translated">タイトル文字列のシーケンス。空のリストを使用してタイトルを除外することができます。</target>
        </trans-unit>
        <trans-unit id="e892733a57cfb8724fa5f063a8369bfa0e2ca384" translate="yes" xml:space="preserve">
          <source>Series basis polynomial of degree &lt;code&gt;deg&lt;/code&gt;.</source>
          <target state="translated">次数 &lt;code&gt;deg&lt;/code&gt; のシリーズ基底多項式。</target>
        </trans-unit>
        <trans-unit id="1337e50ba66491fb95c336fa496a5915ac327127" translate="yes" xml:space="preserve">
          <source>Series of representing the identity.</source>
          <target state="translated">アイデンティティを表すシリーズ。</target>
        </trans-unit>
        <trans-unit id="b63dd64982c7da79c8185bb27db51618398f47db" translate="yes" xml:space="preserve">
          <source>Series with the specified roots.</source>
          <target state="translated">指定された根を持つ直列。</target>
        </trans-unit>
        <trans-unit id="c58eeea00ccb981db5bb1976aef71852fd00d936" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;a.flat[n] = values[n]&lt;/code&gt; for all &lt;code&gt;n&lt;/code&gt; in indices.</source>
          <target state="translated">インデックス内のすべての &lt;code&gt;n&lt;/code&gt; に &lt;code&gt;a.flat[n] = values[n]&lt;/code&gt; を設定します。</target>
        </trans-unit>
        <trans-unit id="77a70ae836628667e278cbc0920a320844fc2438" translate="yes" xml:space="preserve">
          <source>Set a Python function to be used when pretty printing arrays.</source>
          <target state="translated">配列をきれいに印刷するときに使用するPython関数を設定します。</target>
        </trans-unit>
        <trans-unit id="2c5db0d0b74f7205ac29d00dc0f28315d34810c2" translate="yes" xml:space="preserve">
          <source>Set a callback function for the &amp;lsquo;call&amp;rsquo; mode.</source>
          <target state="translated">'call'モードのコールバック関数を設定します。</target>
        </trans-unit>
        <trans-unit id="b4dd0addc44a7c0a5f052f38a920a2396cfdd632" translate="yes" xml:space="preserve">
          <source>Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively.</source>
          <target state="translated">配列フラグ WRITEABLE,ALIGNED,(WRITEBACKIFCOPY,UPDATEIFCOPY)をそれぞれ設定します。</target>
        </trans-unit>
        <trans-unit id="fe4f54f983d0fc0329e51cb812fc504ecf7d9aeb" translate="yes" xml:space="preserve">
          <source>Set how floating-point errors are handled.</source>
          <target state="translated">浮動小数点エラーの処理方法を設定します。</target>
        </trans-unit>
        <trans-unit id="39887c043db9f2506d3506245ce2f8a4950e71c8" translate="yes" xml:space="preserve">
          <source>Set item described by index. If value is masked, masks those locations.</source>
          <target state="translated">インデックスで記述された項目を設定します。値がマスクされている場合は、その場所をマスクします。</target>
        </trans-unit>
        <trans-unit id="d43a840d83fb8f7ade894cbf5726d0d362e9206c" translate="yes" xml:space="preserve">
          <source>Set items 0 and 1 to their negative values:</source>
          <target state="translated">項目 0 と 1 を負の値に設定します。</target>
        </trans-unit>
        <trans-unit id="7e3313ed91d9ab09cbf1b02b801051fadfe61771" translate="yes" xml:space="preserve">
          <source>Set of strings or integers representing the positional or keyword arguments for which the function will not be vectorized. These will be passed directly to &lt;code&gt;pyfunc&lt;/code&gt; unmodified.</source>
          <target state="translated">関数がベクトル化されない位置引数またはキーワード引数を表す文字列または整数のセット。これらは変更されずに直接 &lt;code&gt;pyfunc&lt;/code&gt; に渡されます。</target>
        </trans-unit>
        <trans-unit id="dd426fb4dd6e4754c713da93e729d89067e4bb9f" translate="yes" xml:space="preserve">
          <source>Set print options for the scope of the &lt;code&gt;with&lt;/code&gt; block, and restore the old options at the end. See &lt;a href=&quot;numpy.set_printoptions#numpy.set_printoptions&quot;&gt;&lt;code&gt;set_printoptions&lt;/code&gt;&lt;/a&gt; for the full description of available options.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; ブロックのスコープに印刷オプションを設定し、最後に古いオプションを復元します。使用可能なオプションの詳細については、&lt;a href=&quot;numpy.set_printoptions#numpy.set_printoptions&quot;&gt; &lt;code&gt;set_printoptions&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="865d37322e223fb10d7a9b7ba6a65aa905f9c08b" translate="yes" xml:space="preserve">
          <source>Set printing options.</source>
          <target state="translated">印刷オプションを設定します。</target>
        </trans-unit>
        <trans-unit id="12d96b7d9d8a25110f724914dda75cc579f9b15b" translate="yes" xml:space="preserve">
          <source>Set routines</source>
          <target state="translated">ルーチンの設定</target>
        </trans-unit>
        <trans-unit id="90e5a4de82b432cd6a08040a41846a8b484aa8bd" translate="yes" xml:space="preserve">
          <source>Set self[key] to value.</source>
          <target state="translated">self[key]をvalueに設定します。</target>
        </trans-unit>
        <trans-unit id="03a01981fda3953041f5032c2c1e545ec21542ec" translate="yes" xml:space="preserve">
          <source>Set storage-indexed locations to corresponding values.</source>
          <target state="translated">ストレージインデックスのある場所を対応する値に設定します。</target>
        </trans-unit>
        <trans-unit id="b78901915d1c3e355e6e7781fdabdcf49646d0cb" translate="yes" xml:space="preserve">
          <source>Set the &lt;em&gt;iterator&lt;/em&gt; index and dataptr to the location in the array indicated by the integer &lt;em&gt;index&lt;/em&gt; which points to an element in the C-styled flattened array.</source>
          <target state="translated">&lt;em&gt;反復子&lt;/em&gt;インデックスとdataptrを、Cスタイルのフラット化された配列の要素を指す整数&lt;em&gt;インデックス&lt;/em&gt;で示される配列内の場所に設定し&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="4a1438d389936667e0dd90e958cbfcfc479a293a" translate="yes" xml:space="preserve">
          <source>Set the &lt;em&gt;iterator&lt;/em&gt; index, dataptr, and coordinates members to the location in the array indicated by the N-dimensional c-array, &lt;em&gt;destination&lt;/em&gt;, which must have size at least &lt;em&gt;iterator&lt;/em&gt; -&amp;gt;nd_m1+1.</source>
          <target state="translated">&lt;em&gt;イテレータ&lt;/em&gt;インデックス、dataptr、および座標メンバーを、少なくとも&lt;em&gt;イテレータ&lt;/em&gt; -&amp;gt; nd_m1 + 1のサイズでなければならないN次元のc配列、&lt;em&gt;destination&lt;/em&gt;で示される配列内の場所に設定し&lt;em&gt;ます&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9fda88468648975d476004e19b12d7764d8871eb" translate="yes" xml:space="preserve">
          <source>Set the divide by zero floating point exception</source>
          <target state="translated">ゼロによる除算の浮動小数点例外を設定します。</target>
        </trans-unit>
        <trans-unit id="052e8b4098d433df163dbe5f239a55cbd55acd03" translate="yes" xml:space="preserve">
          <source>Set the filling value of a masked array.</source>
          <target state="translated">マスクされた配列の充填値を設定します。</target>
        </trans-unit>
        <trans-unit id="9db96c8032d2ad506db915a48cc3b65dec28661e" translate="yes" xml:space="preserve">
          <source>Set the filling value of a, if a is a masked array.</source>
          <target state="translated">aがマスクされた配列の場合、aのフィリング値を設定します。</target>
        </trans-unit>
        <trans-unit id="8edcc5a32149cac92ce5f5d9a420660866edfc9a" translate="yes" xml:space="preserve">
          <source>Set the floating-point error callback function or log object.</source>
          <target state="translated">浮動小数点エラーコールバック関数またはログオブジェクトを設定します。</target>
        </trans-unit>
        <trans-unit id="f50931261f78ae53e6d835ee44ec72ac16267946" translate="yes" xml:space="preserve">
          <source>Set the internal state of the generator from a tuple.</source>
          <target state="translated">タプルからジェネレータの内部状態を設定します。</target>
        </trans-unit>
        <trans-unit id="b7c017b4e42e5916929d8c2729e2850e7861e4ad" translate="yes" xml:space="preserve">
          <source>Set the invalid floating point exception</source>
          <target state="translated">無効な浮動小数点の例外を設定します。</target>
        </trans-unit>
        <trans-unit id="5fc1b5b3104040e069bf3d79bfbecde1de4a9774" translate="yes" xml:space="preserve">
          <source>Set the mask.</source>
          <target state="translated">マスクを設定します。</target>
        </trans-unit>
        <trans-unit id="ddcd09abf8029d03a1fc8a1db4814b795eb053c2" translate="yes" xml:space="preserve">
          <source>Set the object that defines floating-point error handling.</source>
          <target state="translated">浮動小数点エラー処理を定義するオブジェクトを設定します。</target>
        </trans-unit>
        <trans-unit id="e125e8e413edbc9d7b60464db9303d04e73186dc" translate="yes" xml:space="preserve">
          <source>Set the overflow floating point exception</source>
          <target state="translated">オーバーフロー浮動小数点例外の設定</target>
        </trans-unit>
        <trans-unit id="32771428ee3d4ac8ada5bdd6145886e45b552f86" translate="yes" xml:space="preserve">
          <source>Set the size of the buffer used in ufuncs.</source>
          <target state="translated">ufuncsで使用するバッファのサイズを設定します。</target>
        </trans-unit>
        <trans-unit id="0594a866f8a04edf46179a77822269ada171c654" translate="yes" xml:space="preserve">
          <source>Set the underflow floating point exception</source>
          <target state="translated">アンダーフロー浮動小数点例外の設定</target>
        </trans-unit>
        <trans-unit id="74d19ff83e70ffb68238d34c2f7bcf87b543941d" translate="yes" xml:space="preserve">
          <source>Set treatment for all types of floating-point errors at once:</source>
          <target state="translated">すべての浮動小数点エラーの種類を一度に処理するように設定します。</target>
        </trans-unit>
        <trans-unit id="3643bcad64c7deb0821dc34ea3dcd8232b0cde58" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;a.flat[n] = values[n]&lt;/code&gt; for each n where &lt;code&gt;mask.flat[n]==True&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mask.flat[n]==True&lt;/code&gt; である各nに &lt;code&gt;a.flat[n] = values[n]&lt;/code&gt; を設定します。</target>
        </trans-unit>
        <trans-unit id="4b6bbd22699cc5a44aa30f4688fb3d6f05291031" translate="yes" xml:space="preserve">
          <source>Sets self._data.flat[n] = values[n] for each n in indices. If &lt;code&gt;values&lt;/code&gt; is shorter than &lt;a href=&quot;numpy.ma.indices#numpy.ma.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; then it will repeat. If &lt;code&gt;values&lt;/code&gt; has some masked values, the initial mask is updated in consequence, else the corresponding values are unmasked.</source>
          <target state="translated">インデックス内の各nにself._data.flat [n] = values [n]を設定します。 &lt;code&gt;values&lt;/code&gt; が&lt;a href=&quot;numpy.ma.indices#numpy.ma.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt;よりも短い場合は繰り返されます。 &lt;code&gt;values&lt;/code&gt; にマスクされた値がある場合、結果として初期マスクが更新されます。それ以外の場合、対応する値はマスクされません。</target>
        </trans-unit>
        <trans-unit id="6e37f27c4b449514c6ac39ca56b186f5e999b75a" translate="yes" xml:space="preserve">
          <source>Sets the flag represented by &lt;code&gt;f&lt;/code&gt; of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">フラグによって表される設定 &lt;code&gt;f&lt;/code&gt; の仮定すると、にキャストすることができる &lt;code&gt;PyArrayObject*&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="adf72c83614ca687d6f697b1bf172e89b7086997" translate="yes" xml:space="preserve">
          <source>Setting and getting error handling</source>
          <target state="translated">エラー処理の設定と取得</target>
        </trans-unit>
        <trans-unit id="a384be3e2e0c4f12be39cdfe96a41f79740f7b44" translate="yes" xml:space="preserve">
          <source>Setting the timezone to UTC shows the same information, but with a Z suffix</source>
          <target state="translated">タイムゾーンをUTCに設定すると、同じ情報が表示されますが、接尾辞がZになります。</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="c91695f6ab0af4734ea0166f05bdecf2943954de" translate="yes" xml:space="preserve">
          <source>Setup and teardown functions to functions and methods are known as &amp;ldquo;fixtures&amp;rdquo;, and their use is not encouraged.</source>
          <target state="translated">関数とメソッドへのセットアップおよびティアダウン関数は「フィクスチャ」と呼ばれ、それらの使用は推奨されません。</target>
        </trans-unit>
        <trans-unit id="badd1cce039672931750b6c398bce1ef82aaa01b" translate="yes" xml:space="preserve">
          <source>Several algorithms in NumPy work on arbitrarily strided arrays. However, some algorithms require single-segment arrays. When an irregularly strided array is passed in to such algorithms, a copy is automatically made.</source>
          <target state="translated">NumPyのいくつかのアルゴリズムは,任意のストライド配列で動作します.しかし,一部のアルゴリズムはシングルセグメント配列を必要とします.そのようなアルゴリズムに不規則にストライドされた配列が渡されると,自動的にコピーが作成されます.</target>
        </trans-unit>
        <trans-unit id="feb6d874b888999df457d285f3a6f7b3c564b09d" translate="yes" xml:space="preserve">
          <source>Several kinds of strings can be converted. Recognized strings can be prepended with &lt;code&gt;'&amp;gt;'&lt;/code&gt; (&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-big-endian&quot;&gt;big-endian&lt;/a&gt;), &lt;code&gt;'&amp;lt;'&lt;/code&gt; (&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-little-endian&quot;&gt;little-endian&lt;/a&gt;), or &lt;code&gt;'='&lt;/code&gt; (hardware-native, the default), to specify the byte order.</source>
          <target state="translated">いくつかの種類の文字列を変換できます。認識される文字列の前に &lt;code&gt;'&amp;gt;'&lt;/code&gt; （&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-big-endian&quot;&gt;ビッグエンディアン&lt;/a&gt;）、 &lt;code&gt;'&amp;lt;'&lt;/code&gt; （&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-little-endian&quot;&gt;リトルエンディアン&lt;/a&gt;）、または &lt;code&gt;'='&lt;/code&gt; （ハードウェアネイティブ、デフォルト）を付けて、バイトオーダーを指定できます。</target>
        </trans-unit>
        <trans-unit id="ea3e5d75b76acbd893a6d1a1cc411aeb6e8d344d" translate="yes" xml:space="preserve">
          <source>Several new types are defined in the C-code. Most of these are accessible from Python, but a few are not exposed due to their limited use. Every new Python type has an associated &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; with an internal structure that includes a pointer to a &amp;ldquo;method table&amp;rdquo; that defines how the new object behaves in Python. When you receive a Python object into C code, you always get a pointer to a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject&lt;/code&gt;&lt;/a&gt; structure. Because a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject&lt;/code&gt;&lt;/a&gt; structure is very generic and defines only &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_HEAD&quot;&gt;&lt;code&gt;PyObject_HEAD&lt;/code&gt;&lt;/a&gt;, by itself it is not very interesting. However, different objects contain more details after the &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_HEAD&quot;&gt;&lt;code&gt;PyObject_HEAD&lt;/code&gt;&lt;/a&gt; (but you have to cast to the correct type to access them &amp;mdash; or use accessor functions or macros).</source>
          <target state="translated">Cコードでは、いくつかの新しい型が定義されています。これらのほとんどはPythonからアクセスできますが、使用が制限されているために公開されていないものもあります。すべての新しいPythonタイプには、関連付けられた&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; &lt;/a&gt;があり、内部構造には、新しいオブジェクトがPythonでどのように動作するかを定義する「メソッドテーブル」へのポインターが含まれています。 PythonオブジェクトをCコードに受け取ると、常に&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject&lt;/code&gt; &lt;/a&gt;構造体へのポインターを取得します。ので&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject&lt;/code&gt; の&lt;/a&gt;構造は非常に一般的であり、唯一の定義&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_HEAD&quot;&gt; &lt;code&gt;PyObject_HEAD&lt;/code&gt; を&lt;/a&gt;、それ自体でそれは非常に興味深いものではありません。ただし、&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_HEAD&quot;&gt; &lt;code&gt;PyObject_HEAD&lt;/code&gt; の&lt;/a&gt;後には、オブジェクトごとに詳細が含まれています（ただし、オブジェクトにアクセスするには、正しいタイプにキャストする必要があります（または、アクセサー関数やマクロを使用します）。</target>
        </trans-unit>
        <trans-unit id="8baf8c262d837f958d6464df64e5309968744eec" translate="yes" xml:space="preserve">
          <source>Several of the linear algebra routines listed above are able to compute results for several matrices at once, if they are stacked into the same array.</source>
          <target state="translated">上に挙げたいくつかの線形代数ルーチンは,同じ配列にスタックされていれば,複数の行列の結果を一度に計算することができます.</target>
        </trans-unit>
        <trans-unit id="72b4a9a262fa7d17e9ac09d705cde6aa24c8773a" translate="yes" xml:space="preserve">
          <source>Several python types are equivalent to a corresponding array scalar when used to generate a &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; object:</source>
          <target state="translated">いくつかのpythonタイプは、&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;オブジェクトの生成に使用される場合、対応する配列スカラーに相当します。</target>
        </trans-unit>
        <trans-unit id="6c3e28ff5f28439895ee75d4f683fd40b7b5c1c1" translate="yes" xml:space="preserve">
          <source>Shape (length along each transformed axis) to use from the input. (&lt;code&gt;s[0]&lt;/code&gt; refers to axis 0, &lt;code&gt;s[1]&lt;/code&gt; to axis 1, etc.). The final element of &lt;code&gt;s&lt;/code&gt; corresponds to &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;rfft(x, n)&lt;/code&gt;, while for the remaining axes, it corresponds to &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;fft(x, n)&lt;/code&gt;. Along any axis, if the given shape is smaller than that of the input, the input is cropped. If it is larger, the input is padded with zeros. if &lt;code&gt;s&lt;/code&gt; is not given, the shape of the input along the axes specified by &lt;code&gt;axes&lt;/code&gt; is used.</source>
          <target state="translated">入力から使用する形状（変換された各軸に沿った長さ）。（ &lt;code&gt;s[0]&lt;/code&gt; は軸0、 &lt;code&gt;s[1]&lt;/code&gt; は軸1などを指します）。最終要素 &lt;code&gt;s&lt;/code&gt; に相当する &lt;code&gt;n&lt;/code&gt; ため &lt;code&gt;rfft(x, n)&lt;/code&gt; 残りの軸の間に、それに対応する &lt;code&gt;n&lt;/code&gt; 個のために &lt;code&gt;fft(x, n)&lt;/code&gt; 。任意の軸に沿って、与えられた形状が入力の形状より小さい場合、入力は切り取られます。大きい場合、入力はゼロで埋められます。 &lt;code&gt;s&lt;/code&gt; が指定されていない場合、axesで指定された &lt;code&gt;axes&lt;/code&gt; 沿った入力の形状が使用されます。</target>
        </trans-unit>
        <trans-unit id="25e97af4557ebd95034e25fa1946abe7364f73b7" translate="yes" xml:space="preserve">
          <source>Shape (length of each axis) of the output (&lt;code&gt;s[0]&lt;/code&gt; refers to axis 0, &lt;code&gt;s[1]&lt;/code&gt; to axis 1, etc.). This corresponds to &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;ifft(x, n)&lt;/code&gt;. Along each axis, if the given shape is smaller than that of the input, the input is cropped. If it is larger, the input is padded with zeros. if &lt;code&gt;s&lt;/code&gt; is not given, the shape of the input along the axes specified by &lt;code&gt;axes&lt;/code&gt; is used. See notes for issue on &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt; zero padding.</source>
          <target state="translated">出力の形状（各軸の長さ）（ &lt;code&gt;s[0]&lt;/code&gt; は軸0を、 &lt;code&gt;s[1]&lt;/code&gt; は軸1を、など）。これに該当する &lt;code&gt;n&lt;/code&gt; ため &lt;code&gt;ifft(x, n)&lt;/code&gt; 。各軸に沿って、与えられた形状が入力の形状より小さい場合、入力は切り取られます。大きい場合、入力はゼロで埋められます。 &lt;code&gt;s&lt;/code&gt; が指定されていない場合、axesで指定された &lt;code&gt;axes&lt;/code&gt; 沿った入力の形状が使用されます。&lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt;ゼロパディングに関する問題については、注記を参照してください。</target>
        </trans-unit>
        <trans-unit id="4f0274375e7f902c51299d209c86d1f430d2633d" translate="yes" xml:space="preserve">
          <source>Shape (length of each transformed axis) of the output (&lt;code&gt;s[0]&lt;/code&gt; refers to axis 0, &lt;code&gt;s[1]&lt;/code&gt; to axis 1, etc.). &lt;code&gt;s&lt;/code&gt; is also the number of input points used along this axis, except for the last axis, where &lt;code&gt;s[-1]//2+1&lt;/code&gt; points of the input are used. Along any axis, if the shape indicated by &lt;code&gt;s&lt;/code&gt; is smaller than that of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;s&lt;/code&gt; is not given, the shape of the input along the axes specified by &lt;code&gt;axes&lt;/code&gt; is used.</source>
          <target state="translated">（形状の出力（各変換軸の長さ） &lt;code&gt;s[0]&lt;/code&gt; 軸0を指し、 &lt;code&gt;s[1]&lt;/code&gt; 等軸1へ）。 &lt;code&gt;s&lt;/code&gt; は、最後の軸を除いて、この軸に沿って使用される入力ポイントの数でもあり、入力 &lt;code&gt;s[-1]//2+1&lt;/code&gt; ポイントが使用されます。任意の軸に沿って、 &lt;code&gt;s&lt;/code&gt; で示される形状が入力の形状よりも小さい場合、入力はトリミングされます。大きい場合、入力はゼロで埋められます。 &lt;code&gt;s&lt;/code&gt; が指定されていない場合、axesで指定された &lt;code&gt;axes&lt;/code&gt; 沿った入力の形状が使用されます。</target>
        </trans-unit>
        <trans-unit id="715197f23d8523982bbe5b136ca8694c043fdfe2" translate="yes" xml:space="preserve">
          <source>Shape (length of each transformed axis) of the output (&lt;code&gt;s[0]&lt;/code&gt; refers to axis 0, &lt;code&gt;s[1]&lt;/code&gt; to axis 1, etc.). This corresponds to &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;fft(x, n)&lt;/code&gt;. Along any axis, if the given shape is smaller than that of the input, the input is cropped. If it is larger, the input is padded with zeros. if &lt;code&gt;s&lt;/code&gt; is not given, the shape of the input along the axes specified by &lt;code&gt;axes&lt;/code&gt; is used.</source>
          <target state="translated">出力の形状（変換された各軸の長さ）（ &lt;code&gt;s[0]&lt;/code&gt; は軸0を、 &lt;code&gt;s[1]&lt;/code&gt; は軸1を、など）。これは、 &lt;code&gt;fft(x, n)&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; に対応します。任意の軸に沿って、与えられた形状が入力の形状より小さい場合、入力は切り取られます。大きい場合、入力はゼロで埋められます。 &lt;code&gt;s&lt;/code&gt; が指定されていない場合、axesで指定された &lt;code&gt;axes&lt;/code&gt; 沿った入力の形状が使用されます。</target>
        </trans-unit>
        <trans-unit id="911dd842dd5fbba1fec3b25f55cac11209b63564" translate="yes" xml:space="preserve">
          <source>Shape (length of each transformed axis) of the output (&lt;code&gt;s[0]&lt;/code&gt; refers to axis 0, &lt;code&gt;s[1]&lt;/code&gt; to axis 1, etc.). This corresponds to &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;fft(x, n)&lt;/code&gt;. Along each axis, if the given shape is smaller than that of the input, the input is cropped. If it is larger, the input is padded with zeros. if &lt;code&gt;s&lt;/code&gt; is not given, the shape of the input along the axes specified by &lt;code&gt;axes&lt;/code&gt; is used.</source>
          <target state="translated">出力の形状（変換された各軸の長さ）（ &lt;code&gt;s[0]&lt;/code&gt; は軸0を、 &lt;code&gt;s[1]&lt;/code&gt; は軸1を、など）。これは、 &lt;code&gt;fft(x, n)&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; に対応します。各軸に沿って、与えられた形状が入力の形状より小さい場合、入力は切り取られます。大きい場合、入力はゼロで埋められます。 &lt;code&gt;s&lt;/code&gt; が指定されていない場合、axesで指定された &lt;code&gt;axes&lt;/code&gt; 沿った入力の形状が使用されます。</target>
        </trans-unit>
        <trans-unit id="b17262b4844364ff0a648b69b2dd5889d0fd6ded" translate="yes" xml:space="preserve">
          <source>Shape (length of each transformed axis) of the output (&lt;code&gt;s[0]&lt;/code&gt; refers to axis 0, &lt;code&gt;s[1]&lt;/code&gt; to axis 1, etc.). This corresponds to &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;ifft(x, n)&lt;/code&gt;. Along any axis, if the given shape is smaller than that of the input, the input is cropped. If it is larger, the input is padded with zeros. if &lt;code&gt;s&lt;/code&gt; is not given, the shape of the input along the axes specified by &lt;code&gt;axes&lt;/code&gt; is used. See notes for issue on &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt; zero padding.</source>
          <target state="translated">出力の形状（変換された各軸の長さ）（ &lt;code&gt;s[0]&lt;/code&gt; は軸0を、 &lt;code&gt;s[1]&lt;/code&gt; は軸1を、など）。これは &lt;code&gt;ifft(x, n)&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; に対応します。任意の軸に沿って、与えられた形状が入力の形状より小さい場合、入力は切り取られます。大きい場合、入力はゼロで埋められます。 &lt;code&gt;s&lt;/code&gt; が指定されていない場合、axesで指定された &lt;code&gt;axes&lt;/code&gt; 沿った入力の形状が使用されます。&lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt;ゼロパディングに関する問題については、注記を参照してください。</target>
        </trans-unit>
        <trans-unit id="4ebeb877c0987d74b5cc7ea4944124e8bf55dfce" translate="yes" xml:space="preserve">
          <source>Shape Manipulation</source>
          <target state="translated">形状の操作</target>
        </trans-unit>
        <trans-unit id="c9f4b98b8edf5592548ab5955c6e16a228f358cb" translate="yes" xml:space="preserve">
          <source>Shape consistent means they are either the same shape, or one input array can be broadcasted to create the same shape as the other one.</source>
          <target state="translated">形状に一貫性があるということは,それらが同じ形状であるか,あるいは,一方の入力配列をブロードキャストして他方の入力配列と同じ形状にすることができることを意味します.</target>
        </trans-unit>
        <trans-unit id="5f1d9e046d241980c89d8b9124d4eafb15b1ca52" translate="yes" xml:space="preserve">
          <source>Shape manipulation</source>
          <target state="translated">形状操作</target>
        </trans-unit>
        <trans-unit id="3b6ca0ce8b60b462e3cf99cb12bf59179d6a929d" translate="yes" xml:space="preserve">
          <source>Shape of broadcasted result.</source>
          <target state="translated">放送結果の形状。</target>
        </trans-unit>
        <trans-unit id="bddad57d8d1388e963005420a02793b2da427fb5" translate="yes" xml:space="preserve">
          <source>Shape of created array.</source>
          <target state="translated">作成された配列の形状。</target>
        </trans-unit>
        <trans-unit id="6cd9e448195effa4bae30eb0f347906fc449b5d5" translate="yes" xml:space="preserve">
          <source>Shape of output array.</source>
          <target state="translated">出力配列の形状。</target>
        </trans-unit>
        <trans-unit id="46e7814f1b68d56a7fb197281826d8c0d7e2f4af" translate="yes" xml:space="preserve">
          <source>Shape of resized array.</source>
          <target state="translated">リサイズされた配列の形状。</target>
        </trans-unit>
        <trans-unit id="ee903849125469d0cd897ee6f3eb2ebe3bb658c4" translate="yes" xml:space="preserve">
          <source>Shape of the FFT.</source>
          <target state="translated">FFTの形状。</target>
        </trans-unit>
        <trans-unit id="93a4d2c249aa77d74ddbee4b73894079d88c4f5d" translate="yes" xml:space="preserve">
          <source>Shape of the array.</source>
          <target state="translated">配列の形状。</target>
        </trans-unit>
        <trans-unit id="02877fc62d2c6f24e10d1abc3b67c8004f59d738" translate="yes" xml:space="preserve">
          <source>Shape of the distribution. Must be positive.</source>
          <target state="translated">分布の形状。正でなければならない。</target>
        </trans-unit>
        <trans-unit id="f2d500bd962f41d17541e213ff6895cd13e0803e" translate="yes" xml:space="preserve">
          <source>Shape of the empty array, e.g., &lt;code&gt;(2, 3)&lt;/code&gt; or &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">空の配列の形状 &lt;code&gt;(2, 3)&lt;/code&gt; 例：（2、3）または &lt;code&gt;2&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="24ef6c437154658151fd05bcb5ba7d5668bdcc5d" translate="yes" xml:space="preserve">
          <source>Shape of the empty matrix.</source>
          <target state="translated">空の行列の形状。</target>
        </trans-unit>
        <trans-unit id="655648f0fa12f5cdf873e10745fb89b0bd95696d" translate="yes" xml:space="preserve">
          <source>Shape of the inverse FFT.</source>
          <target state="translated">逆FFTの形状。</target>
        </trans-unit>
        <trans-unit id="3199c5dcca84fd372c42321d02949f1a124a4434" translate="yes" xml:space="preserve">
          <source>Shape of the matrix</source>
          <target state="translated">マトリックスの形状</target>
        </trans-unit>
        <trans-unit id="c98d12cd91ff402d167f61e45930510176bc8db1" translate="yes" xml:space="preserve">
          <source>Shape of the new array, e.g., &lt;code&gt;(2, 3)&lt;/code&gt; or &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(2, 3)&lt;/code&gt; や &lt;code&gt;2&lt;/code&gt; など、新しい配列の形状。</target>
        </trans-unit>
        <trans-unit id="011eae76336380495ec0325c87bbf97467274627" translate="yes" xml:space="preserve">
          <source>Shape of the output array, which also determines the shape of the coordinate arrays passed to &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">出力配列の形状。これは、 &lt;code&gt;function&lt;/code&gt; に渡される座標配列の形状も決定します。</target>
        </trans-unit>
        <trans-unit id="c07147cdf3a1896289324d57eac09581fa428dd6" translate="yes" xml:space="preserve">
          <source>Shape of the output. If given as N integers, each integer specifies the size of one dimension. If given as a tuple, this tuple gives the complete shape.</source>
          <target state="translated">出力の形状。N個の整数として与えられた場合,各整数は1次元の大きさを指定します.タプルとして与えられた場合,このタプルは完全な形状を与えます.</target>
        </trans-unit>
        <trans-unit id="af9d8afd8fa749d8e52d9830aee69713b28d831e" translate="yes" xml:space="preserve">
          <source>Shape of the required MaskedArray.</source>
          <target state="translated">必要なMaskedArrayの形状。</target>
        </trans-unit>
        <trans-unit id="e290412db84643bfd2e4e9eaed5764c99448847e" translate="yes" xml:space="preserve">
          <source>Shape parameter for the distribution. Must be in the range (0, 1).</source>
          <target state="translated">分布の形状パラメータ。範囲(0,1)でなければなりません。</target>
        </trans-unit>
        <trans-unit id="83905d9bb159cfd69b777f36625de825a5e41d49" translate="yes" xml:space="preserve">
          <source>Shape parameter for window.</source>
          <target state="translated">ウィンドウの形状パラメータ。</target>
        </trans-unit>
        <trans-unit id="9b7a43cf04b72cc2f8a23566b289e4d0bd8ec177" translate="yes" xml:space="preserve">
          <source>Shape parameter of the distribution. Must be nonnegative.</source>
          <target state="translated">分布の形状パラメータ。非負でなければなりません。</target>
        </trans-unit>
        <trans-unit id="8e3c6edf56bb87890fd0d1cdb08c97f69b223d25" translate="yes" xml:space="preserve">
          <source>Shape tuple of the sub-array if this data type describes a sub-array, and &lt;code&gt;()&lt;/code&gt; otherwise.</source>
          <target state="translated">このデータ型がサブ配列を表す場合はサブ配列の形状タプル、そうでない場合は &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="446e2a7d2369f9d1a3b2488394691efa0754afe6" translate="yes" xml:space="preserve">
          <source>Shape tuple, the shape of the iterator.</source>
          <target state="translated">形状タプル、イテレータの形状。</target>
        </trans-unit>
        <trans-unit id="553abfec4e1a448d4b14d3d81794f14b5ad2fe5b" translate="yes" xml:space="preserve">
          <source>Share status of the mask (read-only).</source>
          <target state="translated">マスクの状態を共有します(読み取り専用)。</target>
        </trans-unit>
        <trans-unit id="7c87de531eb450c69f475f1cc68cfb4c95a8aa3e" translate="yes" xml:space="preserve">
          <source>Shift the bits of an integer to the left.</source>
          <target state="translated">整数のビットを左にシフトします。</target>
        </trans-unit>
        <trans-unit id="2f8deb45beae3abccb987abecafce17d01cca0db" translate="yes" xml:space="preserve">
          <source>Shift the bits of an integer to the right.</source>
          <target state="translated">整数のビットを右にシフトします。</target>
        </trans-unit>
        <trans-unit id="4b62e14d6acb41a9881dd5c7d1b632d11117bf42" translate="yes" xml:space="preserve">
          <source>Shift the zero-frequency component only along the second axis:</source>
          <target state="translated">第2軸に沿ってゼロ周波数成分のみをシフトさせます。</target>
        </trans-unit>
        <trans-unit id="dd4356118ce17af4ac61d8e18b734f9c851e6a93" translate="yes" xml:space="preserve">
          <source>Shift the zero-frequency component to the center of the spectrum.</source>
          <target state="translated">ゼロ周波数成分をスペクトルの中心にシフトさせます。</target>
        </trans-unit>
        <trans-unit id="5055dc1fca0e758173b975d01eb66d87f3cbb17c" translate="yes" xml:space="preserve">
          <source>Shift zero-frequency component to the center of the spectrum.</source>
          <target state="translated">ゼロ周波数成分をスペクトルの中心にシフトさせます。</target>
        </trans-unit>
        <trans-unit id="b180ab3848496fb12e866c104e23d82cd3b364fd" translate="yes" xml:space="preserve">
          <source>Shifts zero-frequency terms to centre of array</source>
          <target state="translated">ゼロ周波数の項をアレイの中心にシフト</target>
        </trans-unit>
        <trans-unit id="277215a3b406656029fa8041449bf3521c519abc" translate="yes" xml:space="preserve">
          <source>Shifts zero-frequency terms to the center of the array. For two-dimensional input, swaps first and third quadrants, and second and fourth quadrants.</source>
          <target state="translated">ゼロ周波数の項を配列の中心にシフトします。2次元入力の場合,第1象限と第3象限,第2象限と第4象限を入れ替えます.</target>
        </trans-unit>
        <trans-unit id="b762aac578ae466a940477f419de45f5524873a7" translate="yes" xml:space="preserve">
          <source>Short repeat rule</source>
          <target state="translated">ショートリピートルール</target>
        </trans-unit>
        <trans-unit id="82df73654f5b2a3f44b1124d8173803e26dbe857" translate="yes" xml:space="preserve">
          <source>Shortcut to &lt;code&gt;masked_where&lt;/code&gt;, where &lt;code&gt;condition&lt;/code&gt; is True for &lt;code&gt;x&lt;/code&gt; inside the interval [v1,v2] (v1 &amp;lt;= x &amp;lt;= v2). The boundaries &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt; can be given in either order.</source>
          <target state="translated">&lt;code&gt;masked_where&lt;/code&gt; へのショートカット。ここで、 &lt;code&gt;condition&lt;/code&gt; は区間[v1、v2]（v1 &amp;lt;= x &amp;lt;= v2）内の &lt;code&gt;x&lt;/code&gt; に対して Trueです。境界 &lt;code&gt;v1&lt;/code&gt; と &lt;code&gt;v2&lt;/code&gt; はどちらの順序でも指定できます。</target>
        </trans-unit>
        <trans-unit id="2b41646ab781bb52f3ec916c5f5214e0562ccf8b" translate="yes" xml:space="preserve">
          <source>Shortcut to &lt;code&gt;masked_where&lt;/code&gt;, where &lt;code&gt;condition&lt;/code&gt; is True for &lt;code&gt;x&lt;/code&gt; outside the interval [v1,v2] (x &amp;lt; v1)|(x &amp;gt; v2). The boundaries &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt; can be given in either order.</source>
          <target state="translated">&lt;code&gt;masked_where&lt;/code&gt; へのショートカット。ここで、 &lt;code&gt;condition&lt;/code&gt; は区間[v1、v2]外の &lt;code&gt;x&lt;/code&gt; に対して Trueです（x &amp;lt;v1）|（x&amp;gt; v2）。境界 &lt;code&gt;v1&lt;/code&gt; と &lt;code&gt;v2&lt;/code&gt; はどちらの順序でも指定できます。</target>
        </trans-unit>
        <trans-unit id="90a7ea5e6af4c7b7105e0bea7e0631a8b326d3c4" translate="yes" xml:space="preserve">
          <source>Show how an extreme value distribution can arise from a Gaussian process and compare to a Gaussian:</source>
          <target state="translated">極値分布がガウス過程からどのように発生するかを示し、ガウスと比較してください。</target>
        </trans-unit>
        <trans-unit id="19b965e86e175fb4e059f2686baef10d13deee7c" translate="yes" xml:space="preserve">
          <source>Show the coefficient of the k-th power in the polynomial (which is equivalent to &lt;code&gt;p.c[-(i+1)]&lt;/code&gt;):</source>
          <target state="translated">多項式でk乗の係数を表示します（これは &lt;code&gt;p.c[-(i+1)]&lt;/code&gt; と同等です）。</target>
        </trans-unit>
        <trans-unit id="2dc1d2c7e18782c1b84edd4a515e52ecaf16ffe6" translate="yes" xml:space="preserve">
          <source>Show the coefficients:</source>
          <target state="translated">係数を表示します。</target>
        </trans-unit>
        <trans-unit id="196a4e0eff8a41440049d47c5b180f7f45132ca2" translate="yes" xml:space="preserve">
          <source>Show which elements are NaN.</source>
          <target state="translated">どの要素がNaNであるかを示す。</target>
        </trans-unit>
        <trans-unit id="c42d9c8bf1bc36b5a64f8cd7d6ec47959c633d86" translate="yes" xml:space="preserve">
          <source>Show which elements are not NaN or +/-inf.</source>
          <target state="translated">どの要素がNaNまたは+/infでないかを示す。</target>
        </trans-unit>
        <trans-unit id="1722f8e8697cd3b5c7fd5053f2fe5fc8ffff0c94" translate="yes" xml:space="preserve">
          <source>Showing the shape equivalence:</source>
          <target state="translated">形状の等価性を示す。</target>
        </trans-unit>
        <trans-unit id="f7b90b8e09428e6e1e81258972869d09b4e3cfb5" translate="yes" xml:space="preserve">
          <source>Shows which elements are Not a Number (NaN).</source>
          <target state="translated">どの要素がNaN(Not a Number)であるかを表示します。</target>
        </trans-unit>
        <trans-unit id="fe897f37d53e4d88b6771d092e29d0cbef83871f" translate="yes" xml:space="preserve">
          <source>Shows which elements are finite (not NaN, not infinity)</source>
          <target state="translated">どの要素が有限であるかを示す(NaNではなく、無限ではない</target>
        </trans-unit>
        <trans-unit id="7baa9edf65ea714b6abdb42e0d551c9f633b7a31" translate="yes" xml:space="preserve">
          <source>Shows which elements are negative infinity.</source>
          <target state="translated">どの要素が負の無限大であるかを表示します。</target>
        </trans-unit>
        <trans-unit id="8a9af7136c0a378e79ffd9025ff0d52b52f3f5b3" translate="yes" xml:space="preserve">
          <source>Shows which elements are neither NaN nor infinity.</source>
          <target state="translated">どの要素がNaNでも無限大でもないかを表示します。</target>
        </trans-unit>
        <trans-unit id="b641e3652a21af65f93f39772715d39737df1101" translate="yes" xml:space="preserve">
          <source>Shows which elements are positive infinity.</source>
          <target state="translated">どの要素が正の無限大であるかを表示します。</target>
        </trans-unit>
        <trans-unit id="cae71eb0e9768c0464ac97199ab347f3e2d0b2fa" translate="yes" xml:space="preserve">
          <source>Shows which elements are positive or negative infinity.</source>
          <target state="translated">どの要素が正の無限大か負の無限大かを表示します。</target>
        </trans-unit>
        <trans-unit id="fb36ed0dc4329ccc9a4d63a4ab49050cba7729e3" translate="yes" xml:space="preserve">
          <source>Shrinking an array: array is flattened (in the order that the data are stored in memory), resized, and reshaped:</source>
          <target state="translated">配列の縮小:配列を平坦化(メモリにデータが格納されている順に)→リサイズ→リシェイプ。</target>
        </trans-unit>
        <trans-unit id="57d924a0266c81fc54add4584a1ccacbe3e83546" translate="yes" xml:space="preserve">
          <source>Signals to nose that this function is or is not a test.</source>
          <target state="translated">この機能がテストであること、またはテストでないことを鼻に知らせます。</target>
        </trans-unit>
        <trans-unit id="2f32be1dc74166373c988ec03b0bd86f0a576919" translate="yes" xml:space="preserve">
          <source>Signature</source>
          <target state="translated">Signature</target>
        </trans-unit>
        <trans-unit id="7931cda1fe427976dc0d85722ec095e3dd727c1d" translate="yes" xml:space="preserve">
          <source>Similar function which always returns ndarrays.</source>
          <target state="translated">常に ndarrays を返す類似の関数。</target>
        </trans-unit>
        <trans-unit id="3274df1aa677da58a67e936b08b6d01b18ae9bbb" translate="yes" xml:space="preserve">
          <source>Similar function which checks input for NaNs and Infs.</source>
          <target state="translated">NaNsやInfsの入力をチェックする類似の関数。</target>
        </trans-unit>
        <trans-unit id="5bfc139e101673a0040c4eaa29d6026a0cc4d777" translate="yes" xml:space="preserve">
          <source>Similar function which passes through subclasses.</source>
          <target state="translated">サブクラスを通過する似たような関数</target>
        </trans-unit>
        <trans-unit id="385cb8c7bac921aa96fc7c5b5e20aadf977c2b11" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#c.PyArray_FROM_O&quot;&gt;&lt;code&gt;PyArray_FROM_O&lt;/code&gt;&lt;/a&gt; except it can take an argument of &lt;em&gt;requirements&lt;/em&gt; indicating properties the resulting array must have. Available requirements that can be enforced are &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_NOTSWAPPED&quot;&gt;&lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_ENSURECOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSURECOPY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt;&lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt;&lt;/a&gt;. Standard combinations of flags can also be used:</source>
          <target state="translated">&lt;a href=&quot;#c.PyArray_FROM_O&quot;&gt; &lt;code&gt;PyArray_FROM_O&lt;/code&gt; に&lt;/a&gt;似ていますが、結果の配列に必要なプロパティを示す&lt;em&gt;要件の&lt;/em&gt;引数を取ることができます。強制することができる利用可能な要件がある&lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_NOTSWAPPED&quot;&gt; &lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_ENSURECOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSURECOPY&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt; &lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt; &lt;/a&gt;。フラグの標準的な組み合わせも使用できます。</target>
        </trans-unit>
        <trans-unit id="34e63b3cec603aed4fdc223ab142b8582483ea26" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#c.PyArray_FROM_O&quot;&gt;&lt;code&gt;PyArray_FROM_O&lt;/code&gt;&lt;/a&gt; except it can take an argument of &lt;em&gt;typenum&lt;/em&gt; specifying the type-number the returned array.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArray_FROM_O&quot;&gt; &lt;code&gt;PyArray_FROM_O&lt;/code&gt; &lt;/a&gt;と似ていますが、返される配列の型番号を指定する&lt;em&gt;typenumの&lt;/em&gt;引数を取ることができます。</target>
        </trans-unit>
        <trans-unit id="9ab72ded5542baece20f259b6e4f2d1ffd7e40a6" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; except the data-type is specified using a typenumber. &lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;typenum&lt;/em&gt;) is passed directly to &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt;. This macro also adds &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; to requirements if &lt;a href=&quot;#c.NPY_ARRAY_ENSURECOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSURECOPY&lt;/code&gt;&lt;/a&gt; is passed in as requirements.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; に&lt;/a&gt;似ていますが、データ型はtypenumberを使用して指定されます。&lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt; &lt;code&gt;PyArray_DescrFromType&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;typenum&lt;/em&gt;）は直接&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; に&lt;/a&gt;渡されます。このマクロはまた、追加&lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; を&lt;/a&gt;場合の要件に&lt;a href=&quot;#c.NPY_ARRAY_ENSURECOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSURECOPY&lt;/code&gt; が&lt;/a&gt;要件として渡されます。</target>
        </trans-unit>
        <trans-unit id="b7795b78351922539b7bd3388bd15513fe09ab10" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#numpy.linspace&quot;&gt;&lt;code&gt;linspace&lt;/code&gt;&lt;/a&gt;, but uses a step size (instead of the number of samples).</source>
          <target state="translated">&lt;a href=&quot;#numpy.linspace&quot;&gt; &lt;code&gt;linspace&lt;/code&gt; &lt;/a&gt;に似ていますが、（サンプル数ではなく）ステップサイズを使用します。</target>
        </trans-unit>
        <trans-unit id="61b73acdf7b4aeb554b76ddf529120fdd3244e4c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#numpy.linspace&quot;&gt;&lt;code&gt;linspace&lt;/code&gt;&lt;/a&gt;, but with numbers spaced evenly on a log scale (a geometric progression).</source>
          <target state="translated">&lt;a href=&quot;#numpy.linspace&quot;&gt; &lt;code&gt;linspace&lt;/code&gt; &lt;/a&gt;に似ていますが、対数スケールで等間隔に配置された数値（幾何学的プログレッション）。</target>
        </trans-unit>
        <trans-unit id="b7334b28a788c204f9b851a15f23e3dc83fbe028" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#numpy.ma.asanyarray&quot;&gt;&lt;code&gt;asanyarray&lt;/code&gt;&lt;/a&gt;, but does not conserve subclass.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.asanyarray&quot;&gt; &lt;code&gt;asanyarray&lt;/code&gt; &lt;/a&gt;に似ていますが、サブクラスを保存しません。</target>
        </trans-unit>
        <trans-unit id="e0639724205f7208e357391aa44785bd18f6e10a" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#numpy.ma.asarray&quot;&gt;&lt;code&gt;asarray&lt;/code&gt;&lt;/a&gt;, but conserves subclasses.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.asarray&quot;&gt; &lt;code&gt;asarray&lt;/code&gt; &lt;/a&gt;に似ていますが、サブクラスを保持します。</target>
        </trans-unit>
        <trans-unit id="087902d07ba8ed25e8e25e39b41104a23371fa18" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#numpy.random.mtrand.RandomState.random_integers&quot;&gt;&lt;code&gt;random_integers&lt;/code&gt;&lt;/a&gt;, only for the half-open interval [&lt;code&gt;low&lt;/code&gt;, &lt;code&gt;high&lt;/code&gt;), and 0 is the lowest value if &lt;code&gt;high&lt;/code&gt; is omitted.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.mtrand.RandomState.random_integers&quot;&gt; &lt;code&gt;random_integers&lt;/code&gt; &lt;/a&gt;と同様に、ハーフオープン間隔[ &lt;code&gt;low&lt;/code&gt; 、 &lt;code&gt;high&lt;/code&gt; ）の場合のみ、 &lt;code&gt;high&lt;/code&gt; を省略した場合は0が最小値になります。</target>
        </trans-unit>
        <trans-unit id="4f32836393c39ad349545e85caa88d4f0b0d4f21" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;numpy.geomspace#numpy.geomspace&quot;&gt;&lt;code&gt;geomspace&lt;/code&gt;&lt;/a&gt;, but with the end points specified as logarithms.</source>
          <target state="translated">&lt;a href=&quot;numpy.geomspace#numpy.geomspace&quot;&gt; &lt;code&gt;geomspace&lt;/code&gt; &lt;/a&gt;に似ていますが、終点が対数として指定されています。</target>
        </trans-unit>
        <trans-unit id="9f556182c8173073bc9575354a35bd7cdcf632ab" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;np.copyto(arr, vals, where=mask)&lt;/code&gt;, the difference is that &lt;a href=&quot;#numpy.place&quot;&gt;&lt;code&gt;place&lt;/code&gt;&lt;/a&gt; uses the first N elements of &lt;code&gt;vals&lt;/code&gt;, where N is the number of True values in &lt;code&gt;mask&lt;/code&gt;, while &lt;a href=&quot;numpy.copyto#numpy.copyto&quot;&gt;&lt;code&gt;copyto&lt;/code&gt;&lt;/a&gt; uses the elements where &lt;code&gt;mask&lt;/code&gt; is True.</source>
          <target state="translated">同様 &lt;code&gt;np.copyto(arr, vals, where=mask)&lt;/code&gt; 、違いはある&lt;a href=&quot;#numpy.place&quot;&gt; &lt;code&gt;place&lt;/code&gt; &lt;/a&gt;の最初のN個の要素を使用し &lt;code&gt;vals&lt;/code&gt; Nはで真の値の数であり、 &lt;code&gt;mask&lt;/code&gt; しながら&lt;a href=&quot;numpy.copyto#numpy.copyto&quot;&gt; &lt;code&gt;copyto&lt;/code&gt; &lt;/a&gt;元素使用 &lt;code&gt;mask&lt;/code&gt; Trueです。</target>
        </trans-unit>
        <trans-unit id="85182c2cf4636594ba4bb81df790d59ce12b4844" translate="yes" xml:space="preserve">
          <source>Similar to a Blackman</source>
          <target state="translated">ブラックマンに似ている</target>
        </trans-unit>
        <trans-unit id="fda0ddbefcd9b950d1be64cfa40b8b4d44338564" translate="yes" xml:space="preserve">
          <source>Similar to a Hamming</source>
          <target state="translated">ハミングに似ている</target>
        </trans-unit>
        <trans-unit id="e44711f2465ecfd9681ac18329e5511ea31ae57b" translate="yes" xml:space="preserve">
          <source>Similar to a Hanning</source>
          <target state="translated">ハニングに似ている</target>
        </trans-unit>
        <trans-unit id="234d445a03f1aebf3ed4d77e0d02e9c11e9233b2" translate="yes" xml:space="preserve">
          <source>Similar to add_library, but the specified library is installed.</source>
          <target state="translated">add_library と似ていますが、指定したライブラリがインストールされます。</target>
        </trans-unit>
        <trans-unit id="3dfdcd8111d1084fb95920b6488396d3e8d8a393" translate="yes" xml:space="preserve">
          <source>Similar to geomspace, but with arithmetic instead of geometric progression.</source>
          <target state="translated">ジオムスペースに似ていますが、幾何学的な進行の代わりに算術を用います。</target>
        </trans-unit>
        <trans-unit id="33e0805e34847491157755893623c681d0de564b" translate="yes" xml:space="preserve">
          <source>Similar to geomspace, but with endpoints specified using log and base.</source>
          <target state="translated">geomspaceに似ていますが、logとbaseを使ってエンドポイントを指定します。</target>
        </trans-unit>
        <trans-unit id="2e5b100f812a24f804b90138859e80b7ccf1d358" translate="yes" xml:space="preserve">
          <source>Similar to linspace, with the step size specified instead of the number of samples.</source>
          <target state="translated">linspaceに似ていますが,サンプル数の代わりにステップサイズが指定されます.</target>
        </trans-unit>
        <trans-unit id="17805c407a9f09edaa3bff91c61279fe000f669b" translate="yes" xml:space="preserve">
          <source>Similar to linspace, with the step size specified instead of the number of samples. Note that, when used with a float endpoint, the endpoint may or may not be included.</source>
          <target state="translated">linspaceと似ていますが、サンプル数の代わりにステップサイズを指定します。float 終点と一緒に使用する場合,終点が含まれている場合と含まれていない場合があることに注意してください.</target>
        </trans-unit>
        <trans-unit id="376b7895ca7454ae515537b5c988798aa23f4981" translate="yes" xml:space="preserve">
          <source>Similar to logspace, but with endpoints specified directly.</source>
          <target state="translated">logspaceに似ていますが、エンドポイントが直接指定されます。</target>
        </trans-unit>
        <trans-unit id="fb5e56ddf3f3d8bcd94b1df305f6991c2bdc0db5" translate="yes" xml:space="preserve">
          <source>Similar to logspace, but with the samples uniformly distributed in linear space, instead of log space.</source>
          <target state="translated">logspace に似ていますが、サンプルは対数空間ではなく線形空間に一様に分布しています。</target>
        </trans-unit>
        <trans-unit id="972ade8b6d212f3e2ece52621379958937336838" translate="yes" xml:space="preserve">
          <source>Similar, but takes a tuple as its argument.</source>
          <target state="translated">似ていますが、タプルを引数に取ります。</target>
        </trans-unit>
        <trans-unit id="d90324501e9d6e49bd014963ecc43250f1eed84e" translate="yes" xml:space="preserve">
          <source>Similarly for methods:</source>
          <target state="translated">メソッドについても同様です。</target>
        </trans-unit>
        <trans-unit id="8e9eeb8d7a147426a8015c3531ee3a6251c0e6fe" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;sqrt&lt;/code&gt;, other base logarithms, &lt;code&gt;power&lt;/code&gt; and trig functions are correctly handled. See their respective docstrings for specific examples.</source>
          <target state="translated">同様に、 &lt;code&gt;sqrt&lt;/code&gt; 、他の基本対数、 &lt;code&gt;power&lt;/code&gt; 、およびトリガー関数は正しく処理されます。特定の例については、それぞれのdocstringを参照してください。</target>
        </trans-unit>
        <trans-unit id="acf3895a0f3e8fb2433f49e7c933653b2955fa80" translate="yes" xml:space="preserve">
          <source>Simple Iteration Example</source>
          <target state="translated">単純な反復の例</target>
        </trans-unit>
        <trans-unit id="4512383893712587e1eb27a74805a2a877a79b85" translate="yes" xml:space="preserve">
          <source>Simple Multi-Iteration Example</source>
          <target state="translated">単純なマルチイテレーションの例</target>
        </trans-unit>
        <trans-unit id="50416fe10bcfba1d097d2f78636e350c2106eb91" translate="yes" xml:space="preserve">
          <source>Simple example showing support of broadcasting</source>
          <target state="translated">放送対応を示す簡単な例</target>
        </trans-unit>
        <trans-unit id="ae19d7f5a896d028209ec76ca00e6ca839a5fe6f" translate="yes" xml:space="preserve">
          <source>Simple financial functions</source>
          <target state="translated">シンプルな金融機能</target>
        </trans-unit>
        <trans-unit id="d369dea603addc198cac2b7cf54d9f2f5da3fe8f" translate="yes" xml:space="preserve">
          <source>Simple random data</source>
          <target state="translated">単純なランダムデータ</target>
        </trans-unit>
        <trans-unit id="1c8cdc6800aadf2bece7e4049099bee1ec8e07ce" translate="yes" xml:space="preserve">
          <source>Simulate from the complex normal distribution (&lt;code&gt;complex_normal&lt;/code&gt;)</source>
          <target state="translated">複素正規分布からシミュレート（ &lt;code&gt;complex_normal&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="6c7cbba342c72a06adf163e32df8899d2552eb30" translate="yes" xml:space="preserve">
          <source>Simultaneous floor division and remainder.</source>
          <target state="translated">フロア分割と残りを同時に行う。</target>
        </trans-unit>
        <trans-unit id="5bfc61180c73bf11bcf8e9a59d533a6dcbb10666" translate="yes" xml:space="preserve">
          <source>Since Numpy version 1.17.0 the Generator can be initialized with a number of different BitGenerators. It exposes many different probability distributions. See &lt;a href=&quot;https://www.numpy.org/neps/nep-0019-rng-policy.html&quot;&gt;NEP 19&lt;/a&gt; for context on the updated random Numpy number routines. The legacy &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; random number routines are still available, but limited to a single BitGenerator.</source>
          <target state="translated">Numpyバージョン1.17.0以降、ジェネレーターはいくつかの異なるBitGeneratorsで初期化できます。それは多くの異なる確率分布を公開します。更新されたランダムNumpy数値ルーチンのコンテキストについては、&lt;a href=&quot;https://www.numpy.org/neps/nep-0019-rng-policy.html&quot;&gt;NEP 19&lt;/a&gt;を参照してください。従来の&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;乱数ルーチンは引き続き使用できますが、単一のBitGeneratorに限定されます。</target>
        </trans-unit>
        <trans-unit id="0e5a09c913abb2d820fe3ca564fc0e41384dbaaf" translate="yes" xml:space="preserve">
          <source>Since all ufuncs can take output arguments, this will always be (at least) 1.</source>
          <target state="translated">すべてのufuncsは出力引数を取ることができるので、これは常に(少なくとも)1になります。</target>
        </trans-unit>
        <trans-unit id="2ed82f769a88b72358683adc7002539ca034c05e" translate="yes" xml:space="preserve">
          <source>Since concatenation happens along the last axis first, &lt;a href=&quot;#numpy.block&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; is _not_ capable of producing the following directly:</source>
          <target state="translated">連結は最初に最後の軸に沿って行われるため、&lt;a href=&quot;#numpy.block&quot;&gt; &lt;code&gt;block&lt;/code&gt; &lt;/a&gt;は次のものを直接生成することはできません。</target>
        </trans-unit>
        <trans-unit id="dbccad20cacee376129c1a8bbd5585811048a318" translate="yes" xml:space="preserve">
          <source>Single Array Iteration</source>
          <target state="translated">単一配列反復</target>
        </trans-unit>
        <trans-unit id="1923a37e061c3d312b736626f7d4070c8dcabda6" translate="yes" xml:space="preserve">
          <source>Singular Value Decomposition.</source>
          <target state="translated">特異値分解。</target>
        </trans-unit>
        <trans-unit id="be2751c62dbed56ddb419e417fca2d9511c5f595" translate="yes" xml:space="preserve">
          <source>Singular values of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">の特異値。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f7ca2b11c805ad773c63eebb03a2a048382c59e" translate="yes" xml:space="preserve">
          <source>Size of a pointer on this platform (sizeof(void *)) (A macro defines NPY_SIZEOF_INTP as well.)</source>
          <target state="translated">このプラットフォーム上のポインタのサイズ (sizeof(void *)(マクロでNPY_SIZEOF_INTPも定義しています)。</target>
        </trans-unit>
        <trans-unit id="f19f296d7676df236287d76dbc5f75e14729bdc6" translate="yes" xml:space="preserve">
          <source>Size of buffer.</source>
          <target state="translated">バッファのサイズ。</target>
        </trans-unit>
        <trans-unit id="94f57e9139c081fd224904e8757bd108f6615f74" translate="yes" xml:space="preserve">
          <source>Size of spacing between samples.</source>
          <target state="translated">サンプル間の間隔の大きさ。</target>
        </trans-unit>
        <trans-unit id="3de9e845a3b95a48f909e7b501dd8bf3a25f0227" translate="yes" xml:space="preserve">
          <source>Size of the data (how many bytes is in &lt;em&gt;e.g.&lt;/em&gt; the integer)</source>
          <target state="translated">データのサイズ（でどのように多くのバイトです&lt;em&gt;例えば&lt;/em&gt;整数）</target>
        </trans-unit>
        <trans-unit id="69356099c1bda1de5732916fcc4b059a9e5e1e9d" translate="yes" xml:space="preserve">
          <source>Size of the data is in turn described by:</source>
          <target state="translated">データのサイズは順番に記述されます。</target>
        </trans-unit>
        <trans-unit id="b7b677e8d293fb1fdabc56b0ddc443af48c5aeca" translate="yes" xml:space="preserve">
          <source>Size of the iterator.</source>
          <target state="translated">イテレータのサイズ。</target>
        </trans-unit>
        <trans-unit id="9f5f50339fb8609920b44a4a178129be24577d29" translate="yes" xml:space="preserve">
          <source>Size of the pooled entropy to store. Default is 4 to give a 128-bit entropy pool. 8 (for 256 bits) is another reasonable choice if working with larger PRNGs, but there is very little to be gained by selecting another value.</source>
          <target state="translated">プールされたエントロピーを格納するサイズ。デフォルトは4で、128ビットのエントロピーをプールします。8 (256ビットの場合)も、より大きなPRNGを扱う場合には妥当な選択ですが、他の値を選択しても得られるものはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="425427638096d8909ac722e80f2f8c0179bde19c" translate="yes" xml:space="preserve">
          <source>Size of the returned identity matrix.</source>
          <target state="translated">返された ID マトリックスのサイズ。</target>
        </trans-unit>
        <trans-unit id="c4824192ad4385f49198eaabf9b1f747f0e02ed6" translate="yes" xml:space="preserve">
          <source>Size of ufunc buffer in bytes.</source>
          <target state="translated">ufunc バッファのサイズをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="ad4bbd7cecbd939b77596b18a5178a89c143d6ba" translate="yes" xml:space="preserve">
          <source>Skip the first &lt;code&gt;skiprows&lt;/code&gt; lines, including comments; default: 0.</source>
          <target state="translated">コメントを含む最初の &lt;code&gt;skiprows&lt;/code&gt; 行をスキップします。デフォルト：0。</target>
        </trans-unit>
        <trans-unit id="ceefed34cafaf5b19edca282e41b54d0f46c4e35" translate="yes" xml:space="preserve">
          <source>Slicing creates a view, whose memory is shared with x:</source>
          <target state="translated">スライシングはビューを作成し、そのメモリは x と共有されます。</target>
        </trans-unit>
        <trans-unit id="68f51b4a2c9bfa7e4967d12fe3615173471a2867" translate="yes" xml:space="preserve">
          <source>Small results can be suppressed:</source>
          <target state="translated">小さな結果であれば、それを抑えることができます。</target>
        </trans-unit>
        <trans-unit id="55c8d4062bb648b3be6e31f36bb0441eeb936269" translate="yes" xml:space="preserve">
          <source>Smallest (most negative) power of &lt;code&gt;ibeta&lt;/code&gt; consistent with there being no leading zeros in the mantissa.</source>
          <target state="translated">仮数に先行ゼロがないことと一致する &lt;code&gt;ibeta&lt;/code&gt; の最小（最も負の）パワー。</target>
        </trans-unit>
        <trans-unit id="5723001a57f6b6652b2b21977d2b2710160cd8a8" translate="yes" xml:space="preserve">
          <source>Smallest (positive) power of &lt;code&gt;ibeta&lt;/code&gt; that causes overflow.</source>
          <target state="translated">オーバーフローを引き起こす &lt;code&gt;ibeta&lt;/code&gt; の最小（正の）パワー。</target>
        </trans-unit>
        <trans-unit id="77213ab3e24eed5431e4dc1329418d12eafeda49" translate="yes" xml:space="preserve">
          <source>Smallest size of user-settable internal buffers.</source>
          <target state="translated">ユーザー設定可能な内部バッファの最小サイズ。</target>
        </trans-unit>
        <trans-unit id="5987afde50b9e89e0e7eef5d3f74c5e410d18d69" translate="yes" xml:space="preserve">
          <source>So if this is true, why not choose the index order that matches what you most expect? In particular, why not define row-ordered images to use the image convention? (This is sometimes referred to as the Fortran convention vs the C convention, thus the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;FORTRAN&amp;rsquo; order options for array ordering in numpy.) The drawback of doing this is potential performance penalties. It&amp;rsquo;s common to access the data sequentially, either implicitly in array operations or explicitly by looping over rows of an image. When that is done, then the data will be accessed in non-optimal order. As the first index is incremented, what is actually happening is that elements spaced far apart in memory are being sequentially accessed, with usually poor memory access speeds. For example, for a two dimensional image &amp;lsquo;im&amp;rsquo; defined so that im[0, 10] represents the value at x=0, y=10. To be consistent with usual Python behavior then im[0] would represent a column at x=0. Yet that data would be spread over the whole array since the data are stored in row order. Despite the flexibility of numpy&amp;rsquo;s indexing, it can&amp;rsquo;t really paper over the fact basic operations are rendered inefficient because of data order or that getting contiguous subarrays is still awkward (e.g., im[:,0] for the first row, vs im[0]), thus one can&amp;rsquo;t use an idiom such as for row in im; for col in im does work, but doesn&amp;rsquo;t yield contiguous column data.</source>
          <target state="translated">それでこれが本当なら、あなたが最も期待するものと一致するインデックスの順序を選択してみませんか？特に、画像の規則を使用するように行順の画像を定義しないのはなぜですか？ （これは、Fortran規約とC規約と呼ばれることもあるので、numpyでの配列の順序付けのための「C」および「FORTRAN」の順序オプションです。）これを行うことの欠点は、潜在的なパフォーマンスの低下です。配列操作で暗黙的に、または画像の行をループして明示的にデータに順次アクセスするのが一般的です。それが行われると、データは最適でない順序でアクセスされます。最初のインデックスがインクリメントされると、実際に起こっていることは、メモリ内で遠く離れた要素がシーケンシャルにアクセスされており、通常はメモリアクセス速度が遅いということです。たとえば、im [0、10]がx = 0での値を表すように定義された2次元画像 'im'の場合、y = 10。通常のPythonの動作と一致させるために、im [0]はx = 0の列を表します。ただし、データは行順に格納されるため、そのデータはアレイ全体に分散されます。 numpyのインデックス付けの柔軟性にもかかわらず、データの順序や連続するサブ配列の取得が依然として厄介なため（たとえば、最初の行のim [：、0]とim [ 0]）、したがって、im in rowのようなイディオムは使用できません。 im in colは機能しますが、連続した列データは生成されません。データの順序が原因で基本的な操作が非効率的になる、または連続したサブ配列を取得するのが依然として厄介であること（たとえば、最初の行のim [：、0]とim [0]の比較）を実際に説明することはできません。 imの行のようなイディオムを使用しないでください。 im in colは機能しますが、連続した列データは生成されません。データの順序が原因で基本的な操作が非効率的になる、または連続したサブ配列を取得するのが依然として厄介であること（たとえば、最初の行のim [：、0]とim [0]の比較）を実際に説明することはできません。 imの行のようなイディオムを使用しないでください。 im in colは機能しますが、連続した列データは生成されません。</target>
        </trans-unit>
        <trans-unit id="75338853856b7644da267b729869a79f35465ac8" translate="yes" xml:space="preserve">
          <source>So the p-value is about 0.009, which says the null hypothesis has a probability of about 99% of being true.</source>
          <target state="translated">つまり、P値は0.009くらいで、帰無仮説が99%くらいの確率で真実であるということです。</target>
        </trans-unit>
        <trans-unit id="b22b13d407a40d9045527bdf90132a3a9fa96895" translate="yes" xml:space="preserve">
          <source>So there is about a 1% chance that the F statistic will exceed 7.62, the measured value is 36, so the null hypothesis is rejected at the 1% level.</source>
          <target state="translated">つまり、F統計が7.62を超える確率は1%程度で、測定値は36なので、帰無仮説は1%レベルで棄却されるということになります。</target>
        </trans-unit>
        <trans-unit id="a6530c806dc81f899a20b29f20f0a01aeaaaf38e" translate="yes" xml:space="preserve">
          <source>So, over 64 months would be required to pay off the loan.</source>
          <target state="translated">そのため、64ヶ月を超えると完済が必要になります。</target>
        </trans-unit>
        <trans-unit id="a5004dc1aab93010354b018bb188be79f920df9c" translate="yes" xml:space="preserve">
          <source>So, to end up with the same $15692.93 under the same $100 per month &amp;ldquo;savings plan,&amp;rdquo; for annual interest rates of 4% and 3%, one would need initial investments of $649.27 and $1273.79, respectively.</source>
          <target state="translated">したがって、同じ月額100ドルの「貯蓄プラン」で同じ$ 15692.93になるには、年利4％と3％の場合、それぞれ初期投資$ 649.27と$ 1273.79が必要になります。</target>
        </trans-unit>
        <trans-unit id="6ebdb3e9e8d6757481f655d319b1afadf8dc01e9" translate="yes" xml:space="preserve">
          <source>Solution to the system a x = b. Returned shape is identical to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">システムの解法ax = b。返される形状は &lt;code&gt;b&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="47cd45ea813008c51999b21afe4021732229d27d" translate="yes" xml:space="preserve">
          <source>Solve a linear matrix equation, or system of linear scalar equations.</source>
          <target state="translated">一次行列方程式、または一次スカラー方程式の系を解きなさい。</target>
        </trans-unit>
        <trans-unit id="f401130634f936a923b84a9e812b9c0958189ce8" translate="yes" xml:space="preserve">
          <source>Solve the system of equations &lt;code&gt;3 * x0 + x1 = 9&lt;/code&gt; and &lt;code&gt;x0 + 2 * x1 = 8&lt;/code&gt;:</source>
          <target state="translated">方程式系 &lt;code&gt;3 * x0 + x1 = 9&lt;/code&gt; および &lt;code&gt;x0 + 2 * x1 = 8&lt;/code&gt; 解く：</target>
        </trans-unit>
        <trans-unit id="4fa6a62025edb0c24849f443aeee1762c51d4292" translate="yes" xml:space="preserve">
          <source>Solve the tensor equation &lt;code&gt;a x = b&lt;/code&gt; for x.</source>
          <target state="translated">テンソル方程式 &lt;code&gt;a x = b&lt;/code&gt; をxについて解きます。</target>
        </trans-unit>
        <trans-unit id="2662dd226f62ccee1e8db7abb4ac87cf33caa66b" translate="yes" xml:space="preserve">
          <source>Solves the equation</source>
          <target state="translated">方程式を解く</target>
        </trans-unit>
        <trans-unit id="c7e1b491799507ad39ca1efa34833c4a45590d4c" translate="yes" xml:space="preserve">
          <source>Solving equations and inverting matrices</source>
          <target state="translated">方程式を解き、行列を反転させる</target>
        </trans-unit>
        <trans-unit id="43b0492eef0c0518822e4513393b1d39235d0d0e" translate="yes" xml:space="preserve">
          <source>Some cases where uint and true alignment are different ()</source>
          <target state="translated">uint と真のアラインメントが異なる場合があります()</target>
        </trans-unit>
        <trans-unit id="d1019de292a3b48b30fff1374e4676305929bebd" translate="yes" xml:space="preserve">
          <source>Some cases where uint and true alignment are different (default gcc linux):</source>
          <target state="translated">uint と真のアラインメントが異なる場合があります(デフォルトの gcc linux)。</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">いくつかの例を紹介します。</target>
        </trans-unit>
        <trans-unit id="8c00107ac79c20e1a081f03fb6cbaba3191f960b" translate="yes" xml:space="preserve">
          <source>Some of the scalar types are essentially equivalent to fundamental Python types and therefore inherit from them as well as from the generic array scalar type:</source>
          <target state="translated">いくつかのスカラー型は基本的にPythonの基本的な型と同等であるため、汎用配列スカラー型と同様にそれらを継承しています。</target>
        </trans-unit>
        <trans-unit id="c85e63aec45df025bea301bcb4bf6b89b178cf85" translate="yes" xml:space="preserve">
          <source>Some old Fortran codes need special compiler options in order to work correctly. In order to specify compiler options per source file, &lt;code&gt;numpy.distutils&lt;/code&gt; Fortran compiler looks for the following pattern:</source>
          <target state="translated">一部の古いFortranコードは、正しく機能するために特別なコンパイラオプションを必要とします。ソースファイルごとにコンパイラオプションを指定するために、 &lt;code&gt;numpy.distutils&lt;/code&gt; Fortranコンパイラは次のパターンを探します。</target>
        </trans-unit>
        <trans-unit id="b279d322696735803b77494e0d85658168ba5e97" translate="yes" xml:space="preserve">
          <source>Some spreadsheet programs calculate the &amp;ldquo;floor-towards-zero&amp;rdquo;, in other words &lt;code&gt;floor(-2.5) == -2&lt;/code&gt;. NumPy instead uses the definition of &lt;a href=&quot;#numpy.floor&quot;&gt;&lt;code&gt;floor&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;floor(-2.5) == -3&lt;/code&gt;.</source>
          <target state="translated">一部のスプレッドシートプログラムは、「floor-towards-zero」、つまり &lt;code&gt;floor(-2.5) == -2&lt;/code&gt; 計算します。numpyの代わりの定義使用&lt;a href=&quot;#numpy.floor&quot;&gt; &lt;code&gt;floor&lt;/code&gt; &lt;/a&gt; &lt;code&gt;floor(-2.5) == -3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e076ea295087ca8af80708dc44915c8314e4840f" translate="yes" xml:space="preserve">
          <source>Some useful aliases of the above types are</source>
          <target state="translated">上記のタイプのいくつかの有用なエイリアスは</target>
        </trans-unit>
        <trans-unit id="1671b95e5ffbf1238a81b8297939415d3fd1114c" translate="yes" xml:space="preserve">
          <source>Something like the following code can be used to support both &lt;code&gt;RandomState&lt;/code&gt; and &lt;code&gt;Generator&lt;/code&gt;, with the understanding that the interfaces are slightly different</source>
          <target state="translated">以下のコードのようなものは、両方サポートするために使用することができる &lt;code&gt;RandomState&lt;/code&gt; 及び &lt;code&gt;Generator&lt;/code&gt; インターフェイスが若干異なることを理解して、</target>
        </trans-unit>
        <trans-unit id="9467a0f0b915a6467304173ebaf28fafa38f3924" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to access a multidimensional array as a C-style multi-dimensional array so that algorithms can be implemented using C&amp;rsquo;s a[i][j][k] syntax. This routine returns a pointer, &lt;em&gt;ptr&lt;/em&gt;, that simulates this kind of C-style array, for 1-, 2-, and 3-d ndarrays.</source>
          <target state="translated">Cのa [i] [j] [k]構文を使用してアルゴリズムを実装できるように、Cスタイルの多次元配列として多次元配列にアクセスすると便利な場合があります。このルーチンは、1次元、2次元、および3次元のndarrayに対して、この種のCスタイルの配列をシミュレートするポインター&lt;em&gt;ptrを&lt;/em&gt;返します。</target>
        </trans-unit>
        <trans-unit id="ec72337ff3c83f7940812234b3ba998c6f082e9e" translate="yes" xml:space="preserve">
          <source>Sometimes it may be useful to get the N-dimensional index while iterating. The ndenumerate iterator can achieve this.</source>
          <target state="translated">時々、反復処理中にN次元のインデックスを取得するのが便利な場合があります。ndenumerateイテレータはこれを実現します。</target>
        </trans-unit>
        <trans-unit id="0744d9126505450547757e296c542c0b00376d4c" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to skip a test or mark it as a known failure, such as when the test suite is being written before the code it&amp;rsquo;s meant to test, or if a test only fails on a particular architecture.</source>
          <target state="translated">場合によっては、テストを意図したコードの前にテストスイートが書き込まれている場合や、特定のアーキテクチャでのみテストが失敗した場合など、テストをスキップするか、既知のエラーとしてマークする必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="c295e72861adbd23ef6b2dcbfed6577dacefe499" translate="yes" xml:space="preserve">
          <source>Sometimes, the best approach is to use the &lt;code&gt;%extend&lt;/code&gt; directive to define new methods for your classes (or overload existing ones) that take a &lt;code&gt;PyObject*&lt;/code&gt; (that either is or can be converted to a &lt;code&gt;PyArrayObject*&lt;/code&gt;) instead of a pointer to a buffer. In this case, the helper routines in &lt;code&gt;numpy.i&lt;/code&gt; can be very useful.</source>
          <target state="translated">場合によっては、 &lt;code&gt;%extend&lt;/code&gt; ディレクティブを使用して、バッファへのポインタの代わりに &lt;code&gt;PyObject*&lt;/code&gt; （または &lt;code&gt;PyArrayObject*&lt;/code&gt; 変換できる）を取るクラスの新しいメソッドを定義する（または既存のメソッドをオーバーロードする）のが最善の方法です。。この場合、 &lt;code&gt;numpy.i&lt;/code&gt; のヘルパールーチンが非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="013e7e93c49d182f82742c8920c97f56d061e7e4" translate="yes" xml:space="preserve">
          <source>Somewhat more sophisticated example</source>
          <target state="translated">やや洗練された例</target>
        </trans-unit>
        <trans-unit id="328b7438e36cdae2c28d64a3dd3bc7ddc0df1e77" translate="yes" xml:space="preserve">
          <source>Sort a complex array using the real part first, then the imaginary part.</source>
          <target state="translated">最初に実部を用いて複素配列をソートし,次に虚部を用いてソートします.</target>
        </trans-unit>
        <trans-unit id="7703cef2dff0050a3552375a078ec7f70589b4bd" translate="yes" xml:space="preserve">
          <source>Sort an array in-place.</source>
          <target state="translated">配列をインプレースでソートします。</target>
        </trans-unit>
        <trans-unit id="758912cadfdc3e6db6c081dc567a966e86a886f3" translate="yes" xml:space="preserve">
          <source>Sort an array in-place. Refer to &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;numpy.sort&lt;/code&gt;&lt;/a&gt; for full documentation.</source>
          <target state="translated">配列をインプレースでソートします。完全なドキュメントについては、&lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;numpy.sort&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e971cf5812926cfacabdee56dc64c56ffada0b99" translate="yes" xml:space="preserve">
          <source>Sort by age, then height if ages are equal:</source>
          <target state="translated">年齢が同じなら年齢順に並べ替え、年齢が同じなら身長順に並べ替えます。</target>
        </trans-unit>
        <trans-unit id="edf066d3ae816f3adbcc852b784794ee538b1cc5" translate="yes" xml:space="preserve">
          <source>Sort names: first by surname, then by name.</source>
          <target state="translated">名前のソート:最初に苗字で、次に名前でソートします。</target>
        </trans-unit>
        <trans-unit id="c29b838e8a5ddeb05ab8f84b06787846a1a439df" translate="yes" xml:space="preserve">
          <source>Sort the array, in-place</source>
          <target state="translated">配列をソートします。</target>
        </trans-unit>
        <trans-unit id="b84eb35a33eb1b763dfde94c1db6ce2176107aa8" translate="yes" xml:space="preserve">
          <source>Sort two columns of numbers:</source>
          <target state="translated">2列の数字を並べ替えます。</target>
        </trans-unit>
        <trans-unit id="880e5dacaffdb29c387c406a9aa16d00ec9b6165" translate="yes" xml:space="preserve">
          <source>Sorted 1D array of common and unique elements.</source>
          <target state="translated">共通要素とユニーク要素の1D配列をソートしました。</target>
        </trans-unit>
        <trans-unit id="2b58c607b5c87ff5c9488ade6840a7c97cabbe74" translate="yes" xml:space="preserve">
          <source>Sorted 1D array of unique values that are in only one of the input arrays.</source>
          <target state="translated">入力配列のうちの1つだけにある一意の値の1次元配列をソートします。</target>
        </trans-unit>
        <trans-unit id="378e9e163b7eecefadb4415cae533096e336c4ab" translate="yes" xml:space="preserve">
          <source>Sorting</source>
          <target state="translated">Sorting</target>
        </trans-unit>
        <trans-unit id="ba112ceba77d3fead905df9fb056b8ffb7481e25" translate="yes" xml:space="preserve">
          <source>Sorting algorithm. The default is &amp;lsquo;quicksort&amp;rsquo;. Note that both &amp;lsquo;stable&amp;rsquo; and &amp;lsquo;mergesort&amp;rsquo; use timsort or radix sort under the covers and, in general, the actual implementation will vary with data type. The &amp;lsquo;mergesort&amp;rsquo; option is retained for backwards compatibility.</source>
          <target state="translated">並べ替えアルゴリズム。デフォルトは 'quicksort'です。'stable'と 'mergesort'はどちらも内部でtimsortまたはradix sortを使用し、一般に実際の実装はデータ型によって異なることに注意してください。'mergesort'オプションは、下位互換性のために保持されています。</target>
        </trans-unit>
        <trans-unit id="0575bbf541bc6691bd2f441dd799bc35084ddbf2" translate="yes" xml:space="preserve">
          <source>Sorting algorithm. The default is &amp;lsquo;quicksort&amp;rsquo;. Note that both &amp;lsquo;stable&amp;rsquo; and &amp;lsquo;mergesort&amp;rsquo; use timsort under the covers and, in general, the actual implementation will vary with data type. The &amp;lsquo;mergesort&amp;rsquo; option is retained for backwards compatibility.</source>
          <target state="translated">並べ替えアルゴリズム。デフォルトは 'quicksort'です。'stable'と 'mergesort'はどちらも内部でティムソートを使用し、一般に実際の実装はデータ型によって異なることに注意してください。'mergesort'オプションは、下位互換性のために保持されています。</target>
        </trans-unit>
        <trans-unit id="2cdbbd83ff8697bca9c84ed001e2e5d899425b4f" translate="yes" xml:space="preserve">
          <source>Sorting algorithm. The default is &amp;lsquo;quicksort&amp;rsquo;. Note that both &amp;lsquo;stable&amp;rsquo; and &amp;lsquo;mergesort&amp;rsquo; use timsort under the covers and, in general, the actual implementation will vary with datatype. The &amp;lsquo;mergesort&amp;rsquo; option is retained for backwards compatibility.</source>
          <target state="translated">並べ替えアルゴリズム。デフォルトは 'quicksort'です。'stable'と 'mergesort'はどちらも内部でティムソートを使用し、一般に、実際の実装はデータ型によって異なることに注意してください。'mergesort'オプションは、下位互換性のために保持されています。</target>
        </trans-unit>
        <trans-unit id="bdc99b8f2211c27e95a7ae2ea3c4e510c89721f9" translate="yes" xml:space="preserve">
          <source>Sorting with keys:</source>
          <target state="translated">キーを使ってソートします。</target>
        </trans-unit>
        <trans-unit id="26d009fe61cd6c804332028c785b29bfb52d084f" translate="yes" xml:space="preserve">
          <source>Sorting, searching, and counting</source>
          <target state="translated">並び替え、検索、カウント</target>
        </trans-unit>
        <trans-unit id="6767832dfbb08054083a5a2806dbcbcc61e43981" translate="yes" xml:space="preserve">
          <source>Source array</source>
          <target state="translated">ソース配列</target>
        </trans-unit>
        <trans-unit id="f129cc36c0cc30f28b30e1834c4eba00a6a6b06e" translate="yes" xml:space="preserve">
          <source>Source of entropy. &amp;lsquo;system&amp;rsquo; uses system cryptographic pool. &amp;lsquo;fallback&amp;rsquo; uses a hash of the time and process id.</source>
          <target state="translated">エントロピーの源。'system'はシステム暗号プールを使用します。「フォールバック」は、時間とプロセスIDのハッシュを使用します。</target>
        </trans-unit>
        <trans-unit id="dc1737b3b1fae12e4ca81687b7ce0c8d06e3bfa1" translate="yes" xml:space="preserve">
          <source>Spacing between f values. Default unitary spacing for all dimensions. Spacing can be specified using:</source>
          <target state="translated">f値間の間隔。すべての寸法のデフォルトの単位間隔。間隔は、以下を使用して指定することができます。</target>
        </trans-unit>
        <trans-unit id="534a506bdd04ed14f369aaa8c5d2a5a1b475cf75" translate="yes" xml:space="preserve">
          <source>Spacing between values. For any output &lt;code&gt;out&lt;/code&gt;, this is the distance between two adjacent values, &lt;code&gt;out[i+1] - out[i]&lt;/code&gt;. The default step size is 1. If &lt;code&gt;step&lt;/code&gt; is specified as a position argument, &lt;code&gt;start&lt;/code&gt; must also be given.</source>
          <target state="translated">値間の間隔。出力 &lt;code&gt;out&lt;/code&gt; の場合、これは2つの隣接する値 &lt;code&gt;out[i+1] - out[i]&lt;/code&gt; 間の距離です。デフォルトのステップサイズは1です。 &lt;code&gt;step&lt;/code&gt; 位置引数として指定する場合は、 &lt;code&gt;start&lt;/code&gt; も指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="9b1c83ae389903de1c17429b8031bd633cfea38a" translate="yes" xml:space="preserve">
          <source>Spacing can be also specified with an array that represents the coordinates of the values F along the dimensions. For instance a uniform spacing:</source>
          <target state="translated">間隔は、次元に沿った値 F の座標を表す配列で指定することもできます。例えば、一様な間隔。</target>
        </trans-unit>
        <trans-unit id="3c1452a3b0205f538f941fa6e2df87a5606ff452" translate="yes" xml:space="preserve">
          <source>Spacing of +- inf and NaN is NaN.</source>
          <target state="translated">の間隔は+-infとNaNの間隔はNaNである。</target>
        </trans-unit>
        <trans-unit id="23afed8ee1674d2a0d0a6b27d54e26458214a09b" translate="yes" xml:space="preserve">
          <source>Spawn a number of child &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; s by extending the &lt;a href=&quot;numpy.random.seedsequence.spawn_key#numpy.random.SeedSequence.spawn_key&quot;&gt;&lt;code&gt;spawn_key&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;を拡張して、多数の子SeedSequenceを&lt;a href=&quot;numpy.random.seedsequence.spawn_key#numpy.random.SeedSequence.spawn_key&quot;&gt; &lt;code&gt;spawn_key&lt;/code&gt; &lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="91b21b0aabd8c374de6706b913967d168827f182" translate="yes" xml:space="preserve">
          <source>Spawn a number of child &lt;a href=&quot;numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; s by extending the &lt;a href=&quot;numpy.random.seedsequence.spawn_key#numpy.random.SeedSequence.spawn_key&quot;&gt;&lt;code&gt;spawn_key&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;を拡張して、多数の子SeedSequenceを&lt;a href=&quot;numpy.random.seedsequence.spawn_key#numpy.random.SeedSequence.spawn_key&quot;&gt; &lt;code&gt;spawn_key&lt;/code&gt; &lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="3011c57bc17adfb34d1d5b7d2a537f2f42b61ecd" translate="yes" xml:space="preserve">
          <source>Spawn a number of child &lt;code&gt;SeedSequence&lt;/code&gt; s by extending the &lt;code&gt;spawn_key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SeedSequence&lt;/code&gt; を拡張して、多数の子SeedSequenceを &lt;code&gt;spawn_key&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="5bdcbf562b3722f869ecc22fc6f007711257a292" translate="yes" xml:space="preserve">
          <source>Special attributes and methods</source>
          <target state="translated">特殊な属性とメソッド</target>
        </trans-unit>
        <trans-unit id="aed4a5ac93d537d2fee54607e067f0fcd734c2a7" translate="yes" xml:space="preserve">
          <source>Special case of &lt;a href=&quot;#c.PyArray_EquivTypes&quot;&gt;&lt;code&gt;PyArray_EquivTypes&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) that does not accept flexible data types but may be easier to call.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArray_EquivTypes&quot;&gt; &lt;code&gt;PyArray_EquivTypes&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）の特殊なケースで、柔軟なデータ型を受け入れませんが、呼び出しは簡単です。</target>
        </trans-unit>
        <trans-unit id="1fe419ca9a2135cb73cdfe673bb644f8c5d089ef" translate="yes" xml:space="preserve">
          <source>Special case of &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; for when &lt;em&gt;op&lt;/em&gt; is already an array but it needs to be of a specific &lt;em&gt;newtype&lt;/em&gt; (including byte-order) or has certain &lt;em&gt;requirements&lt;/em&gt;.</source>
          <target state="translated">特別な場合&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;場合の&lt;em&gt;OPが&lt;/em&gt;既に配列であるが、それは特定のであることが必要である&lt;em&gt;のnewtype&lt;/em&gt;（バイト順を含む）、または特定有する&lt;em&gt;要件を&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="60bf3781f7b69622f4280d80dab8f4e70529bfe8" translate="yes" xml:space="preserve">
          <source>Special functions for NPY_OBJECT</source>
          <target state="translated">NPY_OBJECTの特殊関数</target>
        </trans-unit>
        <trans-unit id="b3dfcf123c0344e2a770caf2c6d80f585312a2df" translate="yes" xml:space="preserve">
          <source>Special hook for ufuncs.</source>
          <target state="translated">ufuncs専用フック。</target>
        </trans-unit>
        <trans-unit id="93a7e480fca31e54d3a1bf415987f972c987379d" translate="yes" xml:space="preserve">
          <source>Special methods</source>
          <target state="translated">特殊な方法</target>
        </trans-unit>
        <trans-unit id="3002d8550adc7583b9e34c0e71be4f097501b6cb" translate="yes" xml:space="preserve">
          <source>Specific methods</source>
          <target state="translated">具体的な方法</target>
        </trans-unit>
        <trans-unit id="cf2f0aad66d259134ba110faea6639bae5dba0cf" translate="yes" xml:space="preserve">
          <source>Specifies how indices outside &lt;code&gt;[0, n-1]&lt;/code&gt; will be treated:</source>
          <target state="translated">&lt;code&gt;[0, n-1]&lt;/code&gt; 以外のインデックスの処理方法を指定します。</target>
        </trans-unit>
        <trans-unit id="a7fddec5bc5d09611a6a6411474f1557bfcece40" translate="yes" xml:space="preserve">
          <source>Specifies how out-of-bounds indices are handled. Can specify either one mode or a tuple of modes, one mode per index.</source>
          <target state="translated">境界外インデックスの処理方法を指定します。1つのモードまたはモードのタプルを指定することができ、インデックスごとに1つのモードを指定します。</target>
        </trans-unit>
        <trans-unit id="bd5a8d9eaa67a4089d4d8ea6c9d2499b271531d4" translate="yes" xml:space="preserve">
          <source>Specifies how out-of-bounds indices will behave.</source>
          <target state="translated">境界外指数がどのように振る舞うかを指定します。</target>
        </trans-unit>
        <trans-unit id="0c82c7d4c03f4e3d40af4885f34fa55cd32452a2" translate="yes" xml:space="preserve">
          <source>Specifies how out-of-bounds indices will behave. &amp;lsquo;raise&amp;rsquo; : raise an error. &amp;lsquo;wrap&amp;rsquo; : wrap around. &amp;lsquo;clip&amp;rsquo; : clip to the range.</source>
          <target state="translated">範囲外のインデックスの動作を指定します。'raise'：エラーを発生させます。'wrap'：ラップアラウンド。'clip'：範囲にクリップします。</target>
        </trans-unit>
        <trans-unit id="613844173fd200c8dfdc2aaedd515354fe3b2a25" translate="yes" xml:space="preserve">
          <source>Specifies how to handle encoding errors</source>
          <target state="translated">エンコーディングエラーの処理方法を指定します。</target>
        </trans-unit>
        <trans-unit id="9b982562ff1b137afe496fb00468655c2065dda1" translate="yes" xml:space="preserve">
          <source>Specifies the calculation iteration order/memory layout of the output array. Defaults to &amp;lsquo;K&amp;rsquo;. &amp;lsquo;C&amp;rsquo; means the output should be C-contiguous, &amp;lsquo;F&amp;rsquo; means F-contiguous, &amp;lsquo;A&amp;rsquo; means F-contiguous if the inputs are F-contiguous and not also not C-contiguous, C-contiguous otherwise, and &amp;lsquo;K&amp;rsquo; means to match the element ordering of the inputs as closely as possible.</source>
          <target state="translated">出力配列の計算反復順序/メモリレイアウトを指定します。デフォルトは「K」です。'C'は出力がC隣接でなければならないことを意味し、 'F'はF隣接であることを意味し、 'A'は入力がF隣接であり、C隣接ではない場合はF隣接であり、それ以外の場合はC隣接であり、 'K 'は、入力の要素の順序をできる限り一致させることを意味します。</target>
        </trans-unit>
        <trans-unit id="050a737d589d7084aca709c1606453929922c13e" translate="yes" xml:space="preserve">
          <source>Specifies the minimum number of dimensions that the resulting array should have. Ones will be pre-pended to the shape as needed to meet this requirement.</source>
          <target state="translated">結果として得られる配列が持つべき最小の寸法数を指定します。この要件を満たすために,必要に応じて形状に 1 がプリペンドされます.</target>
        </trans-unit>
        <trans-unit id="1931e4d3fdc0bcca4a66f0fb2135dc85de6a0cb0" translate="yes" xml:space="preserve">
          <source>Specifies the subscripts for summation as comma separated list of subscript labels. An implicit (classical Einstein summation) calculation is performed unless the explicit indicator &amp;lsquo;-&amp;gt;&amp;rsquo; is included as well as subscript labels of the precise output form.</source>
          <target state="translated">添え字ラベルのコンマ区切りリストとして、合計の添え字を指定します。明示的なインジケーター「-&amp;gt;」と正確な出力形式の添え字ラベルが含まれていない限り、暗黙の（古典的なEinstein総和）計算が実行されます。</target>
        </trans-unit>
        <trans-unit id="7ecc55fddab59538bed27df3a80b7134cf4b1452" translate="yes" xml:space="preserve">
          <source>Specifies the subscripts for summation.</source>
          <target state="translated">和算の添え字を指定します。</target>
        </trans-unit>
        <trans-unit id="dc782b605bddd3902febdfde45c4deaed380a257" translate="yes" xml:space="preserve">
          <source>Specifies whether the calculation is done with the lower triangular part of &lt;code&gt;a&lt;/code&gt; (&amp;lsquo;L&amp;rsquo;, default) or the upper triangular part (&amp;lsquo;U&amp;rsquo;). Irrespective of this value only the real parts of the diagonal will be considered in the computation to preserve the notion of a Hermitian matrix. It therefore follows that the imaginary part of the diagonal will always be treated as zero.</source>
          <target state="translated">計算を &lt;code&gt;a&lt;/code&gt; の下三角部分（ 'L'、デフォルト）または上三角部分（ 'U'）のどちらで行うかを指定します。この値に関係なく、エルミート行列の概念を保存するために、計算では対角の実部のみが考慮されます。したがって、対角の虚数部は常にゼロとして扱われます。</target>
        </trans-unit>
        <trans-unit id="84b53fe298f53e60bfe5c134c03be76d2e5954a6" translate="yes" xml:space="preserve">
          <source>Specify &lt;code&gt;count&lt;/code&gt; to improve performance. It allows &lt;code&gt;fromiter&lt;/code&gt; to pre-allocate the output array, instead of resizing it on demand.</source>
          <target state="translated">パフォーマンスを向上させるために &lt;code&gt;count&lt;/code&gt; を指定します。 &lt;code&gt;fromiter&lt;/code&gt; は、オンデマンドでサイズを変更する代わりに、出力配列を事前に割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="a2559f8e80c3826a37d110b99c7697f1e76b2b76" translate="yes" xml:space="preserve">
          <source>Specify the memory layout of the array. If object is not an array, the newly created array will be in C order (row major) unless &amp;lsquo;F&amp;rsquo; is specified, in which case it will be in Fortran order (column major). If object is an array the following holds.</source>
          <target state="translated">配列のメモリレイアウトを指定します。オブジェクトが配列でない場合、新しく作成された配列は 'F'が指定されていない限り、C順（行優先）になります。この場合、Fortran順（列優先）になります。オブジェクトが配列の場合、以下が成り立ちます。</target>
        </trans-unit>
        <trans-unit id="c44bd2c1faa32dfad2b525474c59d5dbcd2e61f5" translate="yes" xml:space="preserve">
          <source>Specify the order of the array. If order is &amp;lsquo;C&amp;rsquo; (default), then the array will be in C-contiguous order (last-index varies the fastest). If order is &amp;lsquo;F&amp;rsquo;, then the returned array will be in Fortran-contiguous order (first-index varies the fastest).</source>
          <target state="translated">配列の順序を指定します。順序が 'C'（デフォルト）の場合、配列はCの連続した順序になります（最後のインデックスが最も速く変化します）。順序が 'F'の場合、返される配列はFortranの連続した順序になります（最初のインデックスが最も速く変化します）。</target>
        </trans-unit>
        <trans-unit id="8f0736b76ded7485aa40ce78476b297a664e4a9e" translate="yes" xml:space="preserve">
          <source>Specify the order of the array. If order is &amp;lsquo;C&amp;rsquo; (default), then the array will be in C-contiguous order (last-index varies the fastest). If order is &amp;lsquo;F&amp;rsquo;, then the returned array will be in Fortran-contiguous order (first-index varies the fastest). If order is &amp;lsquo;A&amp;rsquo;, then the returned array may be in any order (either C-, Fortran-contiguous, or even discontiguous).</source>
          <target state="translated">配列の順序を指定します。順序が 'C'（デフォルト）の場合、配列はCの連続した順序になります（最後のインデックスが最も速く変化します）。順序が 'F'の場合、返される配列はFortranの連続した順序になります（最初のインデックスが最も速く変化します）。順序が 'A'の場合、返される配列は任意の順序（C-、Fortran-contiguous、または不連続）になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="21cff05ed82b999db4c7f573fea17c64f4478c68" translate="yes" xml:space="preserve">
          <source>Specify the order of the array. If order is &amp;lsquo;C&amp;rsquo;, then the array will be in C-contiguous order (last-index varies the fastest). If order is &amp;lsquo;F&amp;rsquo;, then the returned array will be in Fortran-contiguous order (first-index varies the fastest). If order is &amp;lsquo;A&amp;rsquo; (default), then the returned array may be in any order (either C-, Fortran-contiguous, or even discontiguous), unless a copy is required, in which case it will be C-contiguous.</source>
          <target state="translated">配列の順序を指定します。順序が「C」の場合、配列はCの連続した順序になります（最後のインデックスが最も速く変化します）。順序が 'F'の場合、返される配列はFortranの連続した順序になります（最初のインデックスが最も速く変化します）。順序が 'A'（デフォルト）の場合、コピーが必要でない限り、返される配列は任意の順序（C-、Fortran連続、または不連続）になります。この場合、コピーはC-連続になります。</target>
        </trans-unit>
        <trans-unit id="b4bff2e865a836b411173470fe4113bf016b57f0" translate="yes" xml:space="preserve">
          <source>Specify the order of the ndarray memory layout: &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style or &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-column-major&quot;&gt;column-major&lt;/a&gt;, Fortran-style. This only has an effect if the shape is greater than 1-D. The default order is &amp;lsquo;C&amp;rsquo;.</source>
          <target state="translated">ndarrayメモリレイアウトの順序を指定します：&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;行&lt;/a&gt;優先、Cスタイルまたは&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-column-major&quot;&gt;列&lt;/a&gt;優先、Fortranスタイル。これは、形状が1-Dより大きい場合にのみ効果があります。デフォルトの順序は「C」です。</target>
        </trans-unit>
        <trans-unit id="83ad629c93587e0e12f83328a8f66ad92721efa4" translate="yes" xml:space="preserve">
          <source>Specifying and constructing data types</source>
          <target state="translated">データ型の指定と構築</target>
        </trans-unit>
        <trans-unit id="00b91ffde426d9b0a3c3899a390a47a2d221ddad" translate="yes" xml:space="preserve">
          <source>Specifying config_fc options for libraries in setup.py script</source>
          <target state="translated">setup.pyスクリプトでライブラリのconfig_fcオプションを指定する</target>
        </trans-unit>
        <trans-unit id="497ce53e1d016b8475e5f51d0ed03829af1fe8b7" translate="yes" xml:space="preserve">
          <source>Specifying dtype and names</source>
          <target state="translated">dtypeと名前の指定</target>
        </trans-unit>
        <trans-unit id="99c8805177de6129ae475f67ee264572110d40f8" translate="yes" xml:space="preserve">
          <source>Specifying just the month, but forcing a &amp;lsquo;days&amp;rsquo; unit:</source>
          <target state="translated">月のみを指定し、「日」単位を強制する：</target>
        </trans-unit>
        <trans-unit id="b3dbb36c7df88f2134e58d3a13401955888547e5" translate="yes" xml:space="preserve">
          <source>Specifying the roots of a polynomial still leaves one degree of freedom, typically represented by an undetermined leading coefficient. &lt;a href=&quot;#r6c2ffae921d1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; In the case of this function, that coefficient - the first one in the returned array - is always taken as one. (If for some reason you have one other point, the only automatic way presently to leverage that information is to use &lt;code&gt;polyfit&lt;/code&gt;.)</source>
          <target state="translated">多項式の根を指定しても、1つの自由度が残ります。これは通常、未決定の先行係数で表されます。&lt;a href=&quot;#r6c2ffae921d1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;この関数の場合、その係数-返される配列の最初の係数-は常に1と見なされます。（何らかの理由で別のポイントがある場合、現在その情報を活用する唯一の自動方法は、 &lt;code&gt;polyfit&lt;/code&gt; を使用することです。）</target>
        </trans-unit>
        <trans-unit id="0b1f4aea2b38e05ca6cff4352833d4c2eead6bd1" translate="yes" xml:space="preserve">
          <source>Speeding up copy operations by using uint assignment in instead of memcpy</source>
          <target state="translated">memcpyの代わりにuint代入を使用してコピー操作を高速化する</target>
        </trans-unit>
        <trans-unit id="76bb3aba19733547ddb8d57ed987b6a041161ff6" translate="yes" xml:space="preserve">
          <source>Spherical covariance (&lt;code&gt;cov&lt;/code&gt; is a multiple of the identity matrix)</source>
          <target state="translated">球面共分散（ &lt;code&gt;cov&lt;/code&gt; は単位行列の倍数です）</target>
        </trans-unit>
        <trans-unit id="088d71f3f52d7346fd614d711bd267b4c39c4007" translate="yes" xml:space="preserve">
          <source>Split an array into multiple sub-arrays horizontally (column-wise).</source>
          <target state="translated">配列を水平方向に複数のサブ配列に分割します。</target>
        </trans-unit>
        <trans-unit id="b5754126c144e79af24aefbc17318a87cc5f7fd2" translate="yes" xml:space="preserve">
          <source>Split an array into multiple sub-arrays of equal or near-equal size.</source>
          <target state="translated">配列を同じサイズまたはそれに近いサイズの複数のサブ配列に分割します。</target>
        </trans-unit>
        <trans-unit id="0cf080dcab286083ff1cc66a435eccc8025f3bbc" translate="yes" xml:space="preserve">
          <source>Split an array into multiple sub-arrays of equal or near-equal size. Does not raise an exception if an equal division cannot be made.</source>
          <target state="translated">配列を,等しく,あるいはほぼ等しくなるようなサイズの複数のサブ配列に分割します.等しく分割できない場合は例外を発生させません。</target>
        </trans-unit>
        <trans-unit id="c6395892c45b206d6b99821cc909fe1d65570f05" translate="yes" xml:space="preserve">
          <source>Split an array into multiple sub-arrays of equal size.</source>
          <target state="translated">配列を同じ大きさの複数のサブ配列に分割します。</target>
        </trans-unit>
        <trans-unit id="505aae82481059a2edd349c99b982eb22991f3d7" translate="yes" xml:space="preserve">
          <source>Split an array into multiple sub-arrays vertically (row-wise).</source>
          <target state="translated">配列を縦に複数のサブ配列に分割します(行単位)。</target>
        </trans-unit>
        <trans-unit id="0976bf6e914482518c948616b2a64bfe1f530549" translate="yes" xml:space="preserve">
          <source>Split an array into multiple sub-arrays.</source>
          <target state="translated">配列を複数のサブ配列に分割します。</target>
        </trans-unit>
        <trans-unit id="ffd00244dfa808ccdb1e357f445723b1de446321" translate="yes" xml:space="preserve">
          <source>Split array along second axis.</source>
          <target state="translated">2 番目の軸に沿って配列を分割します。</target>
        </trans-unit>
        <trans-unit id="19f8340eb834a92f93fbe1b260b02dab12c9b437" translate="yes" xml:space="preserve">
          <source>Split array along third axis.</source>
          <target state="translated">第3軸に沿って配列を分割します。</target>
        </trans-unit>
        <trans-unit id="abb8acff6e092f71fe2d7d85b72048053b4e0289" translate="yes" xml:space="preserve">
          <source>Split array into a list of multiple sub-arrays of equal size.</source>
          <target state="translated">配列を同じサイズの複数のサブ配列のリストに分割します。</target>
        </trans-unit>
        <trans-unit id="eeb46fbf791ef3d6b7513aae13670bfd1d286c5f" translate="yes" xml:space="preserve">
          <source>Split array into a list of multiple sub-arrays vertically.</source>
          <target state="translated">配列を複数のサブ配列のリストに縦に分割します。</target>
        </trans-unit>
        <trans-unit id="08031d3c1e963e5e593f6077f8007bde4094d65a" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays along the 3rd axis (depth).</source>
          <target state="translated">配列を第3軸(深さ)に沿って複数のサブ配列に分割します。</target>
        </trans-unit>
        <trans-unit id="95260188435af534996db3e9c839aec2ec1973f1" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays horizontally (column wise)</source>
          <target state="translated">配列を水平方向に複数のサブ配列に分割(列単位</target>
        </trans-unit>
        <trans-unit id="4a58d1a7c17bf5b26ef79c3a68ad7dfd39dc14fd" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays horizontally (column-wise).</source>
          <target state="translated">配列を水平方向(列方向)に複数のサブ配列に分割します。</target>
        </trans-unit>
        <trans-unit id="aaa399416b95737d5812be5e3aafc40e1bde329d" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays of equal size.</source>
          <target state="translated">配列を同じ大きさの複数のサブ配列に分割します。</target>
        </trans-unit>
        <trans-unit id="32200fb547976d9cdce1bf0123e79ad3d01d45c6" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays vertically (row wise)</source>
          <target state="translated">配列を縦方向に複数のサブ配列に分割(行単位</target>
        </trans-unit>
        <trans-unit id="5e2072ff967b60fe048397bbdc922e037ef75e9d" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays vertically (row wise).</source>
          <target state="translated">配列を縦方向に複数のサブ配列に分割します(行単位)。</target>
        </trans-unit>
        <trans-unit id="d638a6c0e1614240bc1fdb2bb9a33a3845eee28f" translate="yes" xml:space="preserve">
          <source>Splitting arrays</source>
          <target state="translated">配列の分割</target>
        </trans-unit>
        <trans-unit id="4d58ebaf799f88b14e5a55e0738d2ff6431f8e7d" translate="yes" xml:space="preserve">
          <source>Square identity matrix.</source>
          <target state="translated">正方形の同一性行列。</target>
        </trans-unit>
        <trans-unit id="3613d80d3881f6e72e0182c8791baa68e9f04486" translate="yes" xml:space="preserve">
          <source>Square root (of data size) estimator, used by Excel and other programs for its speed and simplicity.</source>
          <target state="translated">エクセルなどで使用されている平方根(データサイズの)推定器で、その速さとシンプルさから人気があります。</target>
        </trans-unit>
        <trans-unit id="a20f5de17a778177c1d20a924357600fac4e355d" translate="yes" xml:space="preserve">
          <source>Stack 1-D arrays as columns into a 2-D array.</source>
          <target state="translated">1次元配列を列として積み上げて2次元配列にします.</target>
        </trans-unit>
        <trans-unit id="22aff824a88fb9e372dada7709040605bdecb795" translate="yes" xml:space="preserve">
          <source>Stack a sequence of arrays along a new axis.</source>
          <target state="translated">新しい軸に沿って配列を積み重ねます。</target>
        </trans-unit>
        <trans-unit id="b708f3f441cf8b7881ef5ae7003def9a89be1321" translate="yes" xml:space="preserve">
          <source>Stack along first axis.</source>
          <target state="translated">第一軸に沿って積み重ねる。</target>
        </trans-unit>
        <trans-unit id="4e6821d485f2c248408d2340ce48afc4638994d9" translate="yes" xml:space="preserve">
          <source>Stack along second axis.</source>
          <target state="translated">第2軸に沿って積み重ねる。</target>
        </trans-unit>
        <trans-unit id="654d38ec444eb1ee8c9c4cb4064b5c34d10ed04b" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence along a new dimension.</source>
          <target state="translated">配列を新しい次元に沿って順番に積み重ねます。</target>
        </trans-unit>
        <trans-unit id="8075374116f55fd4a715fc7ce7ce68e6a94d1c6b" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence depth wise (along third axis).</source>
          <target state="translated">配列を深さ方向(3番目の軸に沿って)に積み重ねる。</target>
        </trans-unit>
        <trans-unit id="49771b17dcab7c55c17889eac7ab065c2d3411f8" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence depth wise (along third dimension)</source>
          <target state="translated">配列を深さ方向に順に積み重ねる(3次元に沿って</target>
        </trans-unit>
        <trans-unit id="d03609f09d0072b17b53d7c9e81abc547dbe26af" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence depth wise (along third dimension).</source>
          <target state="translated">配列を深さ方向(3次元に沿って)に積み重ねる。</target>
        </trans-unit>
        <trans-unit id="9d4bdc812ef44d6a84449088558f278a7a04fd89" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence horizontally (column wise)</source>
          <target state="translated">配列を水平方向に順に積み重ねる(カラム単位</target>
        </trans-unit>
        <trans-unit id="ab9d3847a31919c576029d377c5a503add8ffa12" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence horizontally (column wise).</source>
          <target state="translated">配列を水平方向(列方向)に順に積み上げていきます。</target>
        </trans-unit>
        <trans-unit id="6895241ba9b7ce75e412efb0b37cc740ec4c6f5a" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence vertically (row wise)</source>
          <target state="translated">配列を縦に順に積み重ねる(行単位</target>
        </trans-unit>
        <trans-unit id="d3ccf82c78c83570433d65f4d8ae10b7fd8977b2" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence vertically (row wise).</source>
          <target state="translated">配列を縦に順に積み上げていきます(行単位)。</target>
        </trans-unit>
        <trans-unit id="8085e023a3bd83539ee52ab6920d2f5d11c78066" translate="yes" xml:space="preserve">
          <source>Stacks of matrices are broadcast together as if the matrices were elements, respecting the signature &lt;code&gt;(n,k),(k,m)-&amp;gt;(n,m)&lt;/code&gt;:</source>
          <target state="translated">マトリックスのスタックは、シグネチャ &lt;code&gt;(n,k),(k,m)-&amp;gt;(n,m)&lt;/code&gt; 考慮して、マトリックスが要素であるかのように一緒にブロードキャストされます。</target>
        </trans-unit>
        <trans-unit id="d04797e8ae7899c2001f6f6340094625d64a3d75" translate="yes" xml:space="preserve">
          <source>Stacks of object matrices are not currently supported.</source>
          <target state="translated">オブジェクト行列のスタックは現在サポートされていません。</target>
        </trans-unit>
        <trans-unit id="67bfee426b8f29b7c1b147b264c4ea92422abbce" translate="yes" xml:space="preserve">
          <source>Stadlober, Ernst, &amp;ldquo;The ratio of uniforms approach for generating discrete random variates&amp;rdquo;, Journal of Computational and Applied Mathematics, 31, pp. 181-189 (1990).</source>
          <target state="translated">Stadlober、Ernst、「離散ランダム変量を生成するためのユニフォームの比率のアプローチ」、Journal of Computational and Applied Mathematics、31、pp。181-189（1990）。</target>
        </trans-unit>
        <trans-unit id="6555192e9f6da8cd095b33f3c4f7b71a9783ffae" translate="yes" xml:space="preserve">
          <source>Standard Exponentials (&lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt;&lt;code&gt;standard_exponential&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">標準指数（&lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt; &lt;code&gt;standard_exponential&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="a76b8a339223d559651cacde3723ee6065b8680a" translate="yes" xml:space="preserve">
          <source>Standard FFTs</source>
          <target state="translated">標準FFT</target>
        </trans-unit>
        <trans-unit id="8a50b57204e2e599132c00b62a1be1df8baa7ef4" translate="yes" xml:space="preserve">
          <source>Standard Gammas (&lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt;&lt;code&gt;standard_gamma&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">標準ガンマ（&lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt; &lt;code&gt;standard_gamma&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="6acbc6354e507f6042f5f9e2e8ed73fc0f0df274" translate="yes" xml:space="preserve">
          <source>Standard array subclasses</source>
          <target state="translated">標準的な配列のサブクラス</target>
        </trans-unit>
        <trans-unit id="cc94a4125e37461a7eb45a58071de9b78020fdd7" translate="yes" xml:space="preserve">
          <source>Standard container class</source>
          <target state="translated">標準コンテナクラス</target>
        </trans-unit>
        <trans-unit id="d97a83beb388d3e9a736d669dd24314ad1c4c05d" translate="yes" xml:space="preserve">
          <source>Standard container-class for easy multiple-inheritance.</source>
          <target state="translated">複数継承を容易にするための標準的なコンテナクラス。</target>
        </trans-unit>
        <trans-unit id="fd746f492ad659d3f7460598edb734faace83b3c" translate="yes" xml:space="preserve">
          <source>Standard deviation</source>
          <target state="translated">標準偏差</target>
        </trans-unit>
        <trans-unit id="abfc13a248e3a8f054556e98e30f2c835c7640af" translate="yes" xml:space="preserve">
          <source>Standard deviation (spread or &amp;ldquo;width&amp;rdquo;) of the distribution. Must be non-negative.</source>
          <target state="translated">分布の標準偏差（スプレッドまたは「幅」）。負でない必要があります。</target>
        </trans-unit>
        <trans-unit id="353ecc8b9a821fe897c9828f33c52edee66e1903" translate="yes" xml:space="preserve">
          <source>Standard deviation of the underlying normal distribution. Must be non-negative. Default is 1.</source>
          <target state="translated">基礎となる正規分布の標準偏差。非負でなければなりません。デフォルトは1です。</target>
        </trans-unit>
        <trans-unit id="23af397f01a5349c3364864801bdaded9c9fd69b" translate="yes" xml:space="preserve">
          <source>Standard division.</source>
          <target state="translated">標準的な分割。</target>
        </trans-unit>
        <trans-unit id="41e65f8d183f4a9b208031a1e27c9fa561f1fc26" translate="yes" xml:space="preserve">
          <source>Standard iterator method, returns the index tuple and array value.</source>
          <target state="translated">標準的なイテレータメソッドで、インデックスタプルと配列の値を返します。</target>
        </trans-unit>
        <trans-unit id="5dc1c8c87cf79f5d6e41fc7b3d5b58a53840de0c" translate="yes" xml:space="preserve">
          <source>Standard iterator method, updates the index and returns the index tuple.</source>
          <target state="translated">標準的なイテレータメソッドで、インデックスを更新し、インデックスタプルを返します。</target>
        </trans-unit>
        <trans-unit id="df808e9a53d2f9ad1713cebd06d023de29058b1f" translate="yes" xml:space="preserve">
          <source>Start of interval. The interval includes this value. The default start value is 0.</source>
          <target state="translated">インターバルの開始。インターバルにはこの値が含まれます。デフォルトの開始値は 0 です。</target>
        </trans-unit>
        <trans-unit id="e3d56ccfa43387f906331b5afa2c49c8c391ba34" translate="yes" xml:space="preserve">
          <source>Start reading buffer (&lt;code&gt;buf&lt;/code&gt;) from this offset onwards.</source>
          <target state="translated">このオフセット以降、バッファー（ &lt;code&gt;buf&lt;/code&gt; ）の読み取りを開始します。</target>
        </trans-unit>
        <trans-unit id="8a8f60afc4e5d9508e376d3a267b217a51489d68" translate="yes" xml:space="preserve">
          <source>Start reading the buffer from this offset (in bytes); default: 0.</source>
          <target state="translated">このオフセットからバッファの読み込みを開始します(バイト数)。</target>
        </trans-unit>
        <trans-unit id="ddcac8bcdcee9d908ef620776b7aaacfebecb3f8" translate="yes" xml:space="preserve">
          <source>Start search at this level.</source>
          <target state="translated">このレベルで検索を開始します。</target>
        </trans-unit>
        <trans-unit id="1b68451d2955d61b15e001c6fdcdc0d7038975d3" translate="yes" xml:space="preserve">
          <source>Starting from numpy 1.3.0, we are working on separating the pure C, &amp;ldquo;computational&amp;rdquo; code from the python dependent code. The goal is twofolds: making the code cleaner, and enabling code reuse by other extensions outside numpy (scipy, etc&amp;hellip;).</source>
          <target state="translated">numpy 1.3.0以降、純粋なCの「計算」コードをpython依存コードから分離する作業を進めています。目標は2つあります。コードをよりクリーンにすることと、numpyの外部の他の拡張機能（scipyなど）によるコードの再利用を可能にすることです。</target>
        </trans-unit>
        <trans-unit id="190bfe8a8e41d4d3adc0d8967b2fb6cda62c785e" translate="yes" xml:space="preserve">
          <source>Starting guess for solving the rate of interest, default 0.1</source>
          <target state="translated">利率を解くための開始推測、デフォルト0.1</target>
        </trans-unit>
        <trans-unit id="1998183b3f42c5d604f45eee6e025b0b95e779c9" translate="yes" xml:space="preserve">
          <source>Starting in NumPy 1.7, there are core array data types which natively support datetime functionality. The data type is called &amp;ldquo;datetime64&amp;rdquo;, so named because &amp;ldquo;datetime&amp;rdquo; is already taken by the datetime library included in Python.</source>
          <target state="translated">NumPy 1.7以降、日時機能をネイティブにサポートするコア配列データ型があります。データ型は「datetime64」と呼ばれ、Pythonに含まれているdatetimeライブラリによって「datetime」が既に取得されているため、この名前が付けられています。</target>
        </trans-unit>
        <trans-unit id="e4430717cba93d1575e5d9028fa5b9735d7a5640" translate="yes" xml:space="preserve">
          <source>Starting in NumPy 1.9 it returns a read-only view on the original array. Attempting to write to the resulting array will produce an error.</source>
          <target state="translated">NumPy 1.9からは,元の配列の読み取り専用ビューを返します.結果の配列への書き込みを試みるとエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="03579e07c4a86e15aa2daa8e0ee5d8b2de28c77b" translate="yes" xml:space="preserve">
          <source>Starting in NumPy 1.9, promote_types function now returns a valid string length when given an integer or float dtype as one argument and a string dtype as another argument. Previously it always returned the input string dtype, even if it wasn&amp;rsquo;t long enough to store the max integer/float value converted to a string.</source>
          <target state="translated">NumPy 1.9以降、promote_types関数は、整数または浮動小数点のdtypeを1つの引数として、文字列のdtypeを別の引数として指定すると、有効な文字列の長さを返すようになりました。以前は、文字列に変換された最大の整数/浮動小数点値を格納するのに十分な長さでなくても、常に入力文字列dtypeを返していました。</target>
        </trans-unit>
        <trans-unit id="48acaf98f98fb538de8401c0548aec9b9591fd70" translate="yes" xml:space="preserve">
          <source>Starting value for the sum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">合計の開始値。詳細については、&lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="2086b21f8f49274138c38d476bee317a84a8aecc" translate="yes" xml:space="preserve">
          <source>Statistics</source>
          <target state="translated">Statistics</target>
        </trans-unit>
        <trans-unit id="55fdc4e46b10f8815926e76cd96fd99504aad94e" translate="yes" xml:space="preserve">
          <source>Store compressed data to disk, and load it again:</source>
          <target state="translated">圧縮されたデータをディスクに保存し、再度ロードします。</target>
        </trans-unit>
        <trans-unit id="c40b4ecf74fcdef0fac2e2b3e7ed1b00b25b3fa6" translate="yes" xml:space="preserve">
          <source>Store data to disk, and load it again:</source>
          <target state="translated">データをディスクに保存し、再度読み込みます。</target>
        </trans-unit>
        <trans-unit id="e1c52dc3262f206eabc8e2236b28e7c92720ec86" translate="yes" xml:space="preserve">
          <source>Stores all of the necessary information to reconstruct the array including shape and dtype on a machine of a different architecture. Both little-endian and big-endian arrays are supported, and a file with little-endian numbers will yield a little-endian array on any machine reading the file. The types are described in terms of their actual sizes. For example, if a machine with a 64-bit C &amp;ldquo;long int&amp;rdquo; writes out an array with &amp;ldquo;long ints&amp;rdquo;, a reading machine with 32-bit C &amp;ldquo;long ints&amp;rdquo; will yield an array with 64-bit integers.</source>
          <target state="translated">異なるアーキテクチャのマシンで形状やdtypeを含むアレイを再構築するために必要なすべての情報を保存します。リトルエンディアン配列とビッグエンディアン配列の両方がサポートされており、リトルエンディアン番号を持つファイルは、ファイルを読み取るすべてのマシンでリトルエンディアン配列を生成します。タイプは、実際のサイズの観点から説明されています。たとえば、64ビットC「long int」のマシンが「long int」の配列を書き込む場合、32ビットC「long int」の読み取りマシンは64ビット整数の配列を生成します。</target>
        </trans-unit>
        <trans-unit id="4be1432cfaeaa9150a93183cf4c2899fcef7c724" translate="yes" xml:space="preserve">
          <source>Stores object arrays, i.e. arrays containing elements that are arbitrary Python objects. Files with object arrays are not to be mmapable, but can be read and written to disk.</source>
          <target state="translated">オブジェクト配列、つまり任意の Python オブジェクトの要素を含む配列を格納します。オブジェクト配列を持つファイルはmmapableではありませんが、ディスクへの読み書きは可能です。</target>
        </trans-unit>
        <trans-unit id="f27167d2cff299e4b6bdced9e8ba574539ece3ec" translate="yes" xml:space="preserve">
          <source>Strided Loop</source>
          <target state="translated">ストライドループ</target>
        </trans-unit>
        <trans-unit id="0229721b8100825a2747d58dc18cba748992b615" translate="yes" xml:space="preserve">
          <source>Strided copy code: Here, &amp;ldquo;uint alignment&amp;rdquo; is used instead. If the itemsize of an array is equal to 1, 2, 4, 8 or 16 bytes and the array is uint aligned then instead numpy will do &lt;code&gt;*(uintN*)dst) = *(uintN*)src)&lt;/code&gt; for appropriate N. Otherwise numpy copies by doing &lt;code&gt;memcpy(dst, src, N)&lt;/code&gt;.</source>
          <target state="translated">ストライドコピーコード：ここでは、「uint配置」が代わりに使用されます。配列のitemsizeが1、2、4、8、または16バイトに等しく、配列がuintで整列されている場合、代わりにnumpyは適切なNに対して &lt;code&gt;*(uintN*)dst) = *(uintN*)src)&lt;/code&gt; を実行します。 numpyは &lt;code&gt;memcpy(dst, src, N)&lt;/code&gt; 実行してコピーします。</target>
        </trans-unit>
        <trans-unit id="416989873d1bb367de9329586677a513ca98acbb" translate="yes" xml:space="preserve">
          <source>Strides for the array (see &lt;a href=&quot;numpy.ndarray.strides#numpy.ndarray.strides&quot;&gt;&lt;code&gt;ndarray.strides&lt;/code&gt;&lt;/a&gt; for full description). Default is None.</source>
          <target state="translated">配列のストライド（完全な説明については、&lt;a href=&quot;numpy.ndarray.strides#numpy.ndarray.strides&quot;&gt; &lt;code&gt;ndarray.strides&lt;/code&gt; &lt;/a&gt;を参照してください）。デフォルトはなしです。</target>
        </trans-unit>
        <trans-unit id="abe83ed756895533bb0aacd0ff6c133f19d2f819" translate="yes" xml:space="preserve">
          <source>Strides for the array (see &lt;code&gt;ndarray.strides&lt;/code&gt; for full description). Default is None.</source>
          <target state="translated">配列のストライド（完全な説明については、 &lt;code&gt;ndarray.strides&lt;/code&gt; を参照してください）。デフォルトはなしです。</target>
        </trans-unit>
        <trans-unit id="715d0f58588cad2551c57b871fab2907378f7743" translate="yes" xml:space="preserve">
          <source>Strides of data in memory.</source>
          <target state="translated">メモリ内のデータのストライド。</target>
        </trans-unit>
        <trans-unit id="4afc193de85ea729f32e1a7419493e9d11ac22a1" translate="yes" xml:space="preserve">
          <source>String (fixed-length sequence of char)</source>
          <target state="translated">文字列(固定長の文字列</target>
        </trans-unit>
        <trans-unit id="f12af9aa3dd629be8a9ae33b8570944039c84f2e" translate="yes" xml:space="preserve">
          <source>String Parsing</source>
          <target state="translated">文字列の解析</target>
        </trans-unit>
        <trans-unit id="34123bf351844b619c4dbfc6727ace35b50b4db7" translate="yes" xml:space="preserve">
          <source>String containing words to look for.</source>
          <target state="translated">検索する単語を含む文字列。</target>
        </trans-unit>
        <trans-unit id="4df4e94946ef158e4c1e5b716aaee91f272b4a7e" translate="yes" xml:space="preserve">
          <source>String formatting</source>
          <target state="translated">文字列の書式設定</target>
        </trans-unit>
        <trans-unit id="92531b336e4e7bb6a1d7d30a01f8111947fec115" translate="yes" xml:space="preserve">
          <source>String information</source>
          <target state="translated">文字列情報</target>
        </trans-unit>
        <trans-unit id="c2b35fa4d37ee8a6b4bd38cea3798cc9fbf4cba7" translate="yes" xml:space="preserve">
          <source>String integers specify the axis to concatenate along or the minimum number of dimensions to force entries into.</source>
          <target state="translated">文字列の整数は、連結する軸、または強制的に入力する次元の最小数を指定します。</target>
        </trans-unit>
        <trans-unit id="f501c85c352da3ec100086db122d9f22d122b32e" translate="yes" xml:space="preserve">
          <source>String of length &lt;code&gt;length&lt;/code&gt;.</source>
          <target state="translated">長さ &lt;code&gt;length&lt;/code&gt; のストリング。</target>
        </trans-unit>
        <trans-unit id="766f45c1227c8c7d13e31b3c8218c7c441dc99b1" translate="yes" xml:space="preserve">
          <source>String operations</source>
          <target state="translated">文字列操作</target>
        </trans-unit>
        <trans-unit id="b92216b3243250ff57b76e23d2f013b608ec0972" translate="yes" xml:space="preserve">
          <source>String or character separating columns.</source>
          <target state="translated">列を区切る文字列または文字。</target>
        </trans-unit>
        <trans-unit id="791d1bdb2ea8c1e1e2ac650ffdc82b6e091407c9" translate="yes" xml:space="preserve">
          <source>String or character separating lines.</source>
          <target state="translated">行を区切る文字列または文字。</target>
        </trans-unit>
        <trans-unit id="070445e0a7bd458bdad35ce8dcb2d1d0173ff69e" translate="yes" xml:space="preserve">
          <source>String representation of &lt;code&gt;number&lt;/code&gt; in &lt;code&gt;base&lt;/code&gt; system.</source>
          <target state="translated">文字列表現 &lt;code&gt;number&lt;/code&gt; における &lt;code&gt;base&lt;/code&gt; システム。</target>
        </trans-unit>
        <trans-unit id="2e31e8b091806f3d1f281cc4ba782be9fda82868" translate="yes" xml:space="preserve">
          <source>String representation of floating point infinity (default inf).</source>
          <target state="translated">浮動小数点無限大の文字列表現(デフォルトのinf)。</target>
        </trans-unit>
        <trans-unit id="01373c57fb8fe982545c8617e4790c9bba32d3bd" translate="yes" xml:space="preserve">
          <source>String representation of floating point not-a-number (default nan).</source>
          <target state="translated">浮動小数点の非数(デフォルトは nan)を文字列で表現します。</target>
        </trans-unit>
        <trans-unit id="9f3842d201b21eb0e7888c9c3d9a2c881516b8c4" translate="yes" xml:space="preserve">
          <source>String representation of the array.</source>
          <target state="translated">配列の文字列表現.</target>
        </trans-unit>
        <trans-unit id="4db97d521f52ac6d93080543eb6b74577ba23cc3" translate="yes" xml:space="preserve">
          <source>String representations:</source>
          <target state="translated">文字列表現。</target>
        </trans-unit>
        <trans-unit id="e0d061a82ce8af858bef95987cfb2e899639d475" translate="yes" xml:space="preserve">
          <source>String that will be prepended to the &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;footer&lt;/code&gt; strings, to mark them as comments. Default: &amp;lsquo;# &amp;lsquo;, as expected by e.g. &lt;code&gt;numpy.loadtxt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;header&lt;/code&gt; 文字列と &lt;code&gt;footer&lt;/code&gt; 文字列の前に追加して、コメントとしてマークする文字列。デフォルト： &lt;code&gt;numpy.loadtxt&lt;/code&gt; などで期待される「＃」。</target>
        </trans-unit>
        <trans-unit id="29161ee7a7a15a1abaf0f1612beb0eae4baa01d7" translate="yes" xml:space="preserve">
          <source>String that will be written at the beginning of the file.</source>
          <target state="translated">ファイルの先頭に書き込まれる文字列。</target>
        </trans-unit>
        <trans-unit id="5c5d64e1c727d0403596e9c5ea3308951b6f9d69" translate="yes" xml:space="preserve">
          <source>String that will be written at the end of the file.</source>
          <target state="translated">ファイルの最後に書き込まれる文字列。</target>
        </trans-unit>
        <trans-unit id="65875ffed7d9c75f6fe284ddd93f194bd7eecd53" translate="yes" xml:space="preserve">
          <source>String used in lieu of missing data when a masked array is printed. By default, this string is &lt;code&gt;'--'&lt;/code&gt;.</source>
          <target state="translated">マスクされた配列が印刷されるときに欠落データの代わりに使用される文字列。デフォルトでは、この文字列は &lt;code&gt;'--'&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e619565781aeac87df5988755d8308bf2c9d2598" translate="yes" xml:space="preserve">
          <source>String with comma-separated fields</source>
          <target state="translated">カンマで区切られたフィールドを持つ文字列</target>
        </trans-unit>
        <trans-unit id="70f2192ce102bd881643cbec0959f90e05d94515" translate="yes" xml:space="preserve">
          <source>Strings are also a scalar type:</source>
          <target state="translated">文字列もスカラ型です。</target>
        </trans-unit>
        <trans-unit id="abee4933ed6df48a826b4ec24a053bf896cc2409" translate="yes" xml:space="preserve">
          <source>Structured arrays are sorted lexically by &lt;code&gt;argsort&lt;/code&gt;:</source>
          <target state="translated">構造化配列は、 &lt;code&gt;argsort&lt;/code&gt; によって字句的にソートされます。</target>
        </trans-unit>
        <trans-unit id="f15140621e0cd4e0f0fe72960c228d9f03950ae6" translate="yes" xml:space="preserve">
          <source>Structured data types are formed by creating a data type whose &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;field&lt;/a&gt; contain other data types. Each field has a name by which it can be &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;accessed&lt;/a&gt;. The parent data type should be of sufficient size to contain all its fields; the parent is nearly always based on the &lt;code&gt;void&lt;/code&gt; type which allows an arbitrary item size. Structured data types may also contain nested structured sub-array data types in their fields.</source>
          <target state="translated">構造化データ型は、&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;フィールド&lt;/a&gt;に他のデータ型が含まれるデータ型を作成することによって形成されます。各フィールドには、&lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;アクセス&lt;/a&gt;できる名前があります。親データ型は、そのすべてのフィールドを含めるのに十分なサイズでなければなりません。親はほぼ常に、任意のアイテムサイズを許可する &lt;code&gt;void&lt;/code&gt; タイプに基づいています。構造化データタイプのフィールドには、ネストされた構造化サブ配列データタイプが含まれる場合もあります。</target>
        </trans-unit>
        <trans-unit id="6624b07c38a844e59271b0a0c26ed454ac19dbe9" translate="yes" xml:space="preserve">
          <source>Structured type, one field name &amp;lsquo;f1&amp;rsquo;, containing int16:</source>
          <target state="translated">構造化タイプ、1つのフィールド名「f1」、int16を含む：</target>
        </trans-unit>
        <trans-unit id="d2e117ca328d87720528f1cfaf8d8960167ffb11" translate="yes" xml:space="preserve">
          <source>Structured type, one field named &amp;lsquo;f1&amp;rsquo;, in itself containing a structured type with one field:</source>
          <target state="translated">構造化タイプ、「f1」という名前の1つのフィールド、それ自体が1つのフィールドを持つ構造化タイプを含む：</target>
        </trans-unit>
        <trans-unit id="58f4a5191b04c275b13b1266e03ae0e69f92c2c1" translate="yes" xml:space="preserve">
          <source>Structured type, two fields: the first field contains an unsigned int, the second an int32:</source>
          <target state="translated">構造化型で、2 つのフィールド:最初のフィールドには unsigned int、2 番目のフィールドには int32 が含まれます。</target>
        </trans-unit>
        <trans-unit id="ca4456203ca66897ff0941bbafc31276906d7671" translate="yes" xml:space="preserve">
          <source>Structured view(s) of &lt;a href=&quot;numpy.nditer.operands#numpy.nditer.operands&quot;&gt;&lt;code&gt;operands&lt;/code&gt;&lt;/a&gt; in memory, matching the reordered and optimized iterator access pattern. Valid only before the iterator is closed.</source>
          <target state="translated">メモリ内の&lt;a href=&quot;numpy.nditer.operands#numpy.nditer.operands&quot;&gt; &lt;code&gt;operands&lt;/code&gt; &lt;/a&gt;の構造化ビュー。並べ替えられて最適化されたイテレータアクセスパターンと一致します。イテレータが閉じられる前にのみ有効です。</target>
        </trans-unit>
        <trans-unit id="803fd087e54001bfefdde2c389864825258535d4" translate="yes" xml:space="preserve">
          <source>Sub-arrays always have a C-contiguous memory layout.</source>
          <target state="translated">サブアレイは常にC-連続メモリレイアウトを持っています。</target>
        </trans-unit>
        <trans-unit id="b5f988ec613aba03f62b8fb5c8cfc27a7a1a6d0f" translate="yes" xml:space="preserve">
          <source>Sub-optimal &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; (due to repeated path calculation time): ~330ms</source>
          <target state="translated">準最適な&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;（繰り返されるパス計算時間のため）：〜330ms</target>
        </trans-unit>
        <trans-unit id="fa0a23c0a00071a5375730590cb136590b810c95" translate="yes" xml:space="preserve">
          <source>Subclasses of &lt;code&gt;ndarray&lt;/code&gt; are preserved except for the &amp;lsquo;raw&amp;rsquo; mode. So if &lt;code&gt;a&lt;/code&gt; is of type &lt;code&gt;matrix&lt;/code&gt;, all the return values will be matrices too.</source>
          <target state="translated">「raw」モードを除いて、 &lt;code&gt;ndarray&lt;/code&gt; のサブクラスは保持されます。したがって、 &lt;code&gt;a&lt;/code&gt; が &lt;code&gt;matrix&lt;/code&gt; 型の場合、すべての戻り値も行列になります。</target>
        </trans-unit>
        <trans-unit id="9d147ab8047bc6066411af552791a9504b59a189" translate="yes" xml:space="preserve">
          <source>Subclassing a &lt;code&gt;numpy.ndarray&lt;/code&gt; is possible but if your goal is to create an array with &lt;em&gt;modified&lt;/em&gt; behavior, as do dask arrays for distributed computation and cupy arrays for GPU-based computation, subclassing is discouraged. Instead, using numpy&amp;rsquo;s &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.dispatch.html#basics-dispatch&quot;&gt;dispatch mechanism&lt;/a&gt; is recommended.</source>
          <target state="translated">&lt;code&gt;numpy.ndarray&lt;/code&gt; のサブクラス化は可能ですが、分散計算用のdask配列やGPUベースの計算用のcupy配列の&lt;em&gt;ように、&lt;/em&gt;動作が&lt;em&gt;変更され&lt;/em&gt;た配列を作成することが目的の場合、サブクラス化は推奨されません。代わりに、numpyの&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.dispatch.html#basics-dispatch&quot;&gt;ディスパッチメカニズム&lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="33bc88cf96b41fa0646c461894f505af99f67ac1" translate="yes" xml:space="preserve">
          <source>Subclassing is preserved. This means that if, e.g., the data part of the masked array is a recarray, &lt;a href=&quot;numpy.ma.filled#numpy.ma.filled&quot;&gt;&lt;code&gt;filled&lt;/code&gt;&lt;/a&gt; returns a recarray:</source>
          <target state="translated">サブクラス化は保持されます。これは、たとえば、マスクされた配列のデータ部分がrecarrayである場合、&lt;a href=&quot;numpy.ma.filled#numpy.ma.filled&quot;&gt; &lt;code&gt;filled&lt;/code&gt; &lt;/a&gt;はrecarrayを返すことを意味します。</target>
        </trans-unit>
        <trans-unit id="dcd026d87f16ab5d865099378d38748e1049d4d8" translate="yes" xml:space="preserve">
          <source>Subclassing ndarray</source>
          <target state="translated">ndarrayのサブクラス</target>
        </trans-unit>
        <trans-unit id="d9952117e8cb53d0fd7ca6ba7d99ad537965d8c9" translate="yes" xml:space="preserve">
          <source>Subdivide &lt;code&gt;int16&lt;/code&gt; into 2 &lt;code&gt;int8&lt;/code&gt;&amp;rsquo;s, called x and y. 0 and 1 are the offsets in bytes:</source>
          <target state="translated">&lt;code&gt;int16&lt;/code&gt; をxとyと呼ばれる2つの &lt;code&gt;int8&lt;/code&gt; に分割します。0と1はバイト単位のオフセットです。</target>
        </trans-unit>
        <trans-unit id="7cd760711c541e202c788fb098af0b33b391721e" translate="yes" xml:space="preserve">
          <source>Subsequence with trailing zeros removed. If the resulting sequence would be empty, return the first element. The returned sequence may or may not be a view.</source>
          <target state="translated">末尾のゼロを除去した部分シーケンス。結果のシーケンスが空の場合は、最初の要素を返します。返されるシーケンスは、ビューであってもビューでなくても構いません。</target>
        </trans-unit>
        <trans-unit id="259ff26648e77d2b9a5ec16a4f186ec8e1c65753" translate="yes" xml:space="preserve">
          <source>Substitute a polynomial for x and expand the result. Here we substitute p in itself leading to a new polynomial of degree 4 after expansion. If the polynomials are regarded as functions this is composition of functions:</source>
          <target state="translated">x に多項式を代入し、結果を展開します。ここでは、展開後に次数4の新しい多項式につながるpをそれ自体に代入します。多項式が関数とみなされる場合、これは関数の合成です。</target>
        </trans-unit>
        <trans-unit id="8d18e7a773fc8ec030ec151dbf7cd596c836697a" translate="yes" xml:space="preserve">
          <source>Substitution:</source>
          <target state="translated">Substitution:</target>
        </trans-unit>
        <trans-unit id="976370d3324e5eaaec19ed99a261ec090486b0fa" translate="yes" xml:space="preserve">
          <source>Subtract arguments, element-wise.</source>
          <target state="translated">要素ごとに引数を減算します。</target>
        </trans-unit>
        <trans-unit id="8567fbb4d729f4cd5b7fbe5674c01c465635fa47" translate="yes" xml:space="preserve">
          <source>Subtract one Chebyshev series from another.</source>
          <target state="translated">チェビシェフ級数を別の級数から引き算します。</target>
        </trans-unit>
        <trans-unit id="a494f472ea255a2aaa4f1c8f52b90c62196690f5" translate="yes" xml:space="preserve">
          <source>Subtract one Hermite series from another.</source>
          <target state="translated">1つのハーミット系列から別のハーミット系列を引き算します。</target>
        </trans-unit>
        <trans-unit id="60b31c93b32c6d82ec367e99b58e2a7fd1690435" translate="yes" xml:space="preserve">
          <source>Subtract one Laguerre series from another.</source>
          <target state="translated">1つのラゲール級数から別のラゲール級数を引き算します。</target>
        </trans-unit>
        <trans-unit id="09477810015d786e3a1ce0d9827bfd9d00039de6" translate="yes" xml:space="preserve">
          <source>Subtract one Legendre series from another.</source>
          <target state="translated">レジェンドレシリーズを1つ減算します。</target>
        </trans-unit>
        <trans-unit id="a2407a57a6647eba13b915586134c7e1d7534217" translate="yes" xml:space="preserve">
          <source>Subtract one polynomial from another.</source>
          <target state="translated">1つの多項式を別の多項式から引き算します。</target>
        </trans-unit>
        <trans-unit id="5de67be97d964e12a293477e154e8fa146741938" translate="yes" xml:space="preserve">
          <source>Subtract other from self in-place.</source>
          <target state="translated">その場で自己から他を引き算します。</target>
        </trans-unit>
        <trans-unit id="b3957443ea74659d4523c7bc9e466d304ba155cf" translate="yes" xml:space="preserve">
          <source>Subtract other from self, and return a new masked array.</source>
          <target state="translated">selfからotherを引き、新しいマスクされた配列を返します。</target>
        </trans-unit>
        <trans-unit id="6cf676697a4c117ec3074a618da8a2b0fca9cd14" translate="yes" xml:space="preserve">
          <source>Subtract self from other, and return a new masked array.</source>
          <target state="translated">他の配列から自己を引き算し、新しいマスクされた配列を返します。</target>
        </trans-unit>
        <trans-unit id="d0b818b7784e48b243d98be89f763b62cb9fc7bd" translate="yes" xml:space="preserve">
          <source>Successfully tested on:</source>
          <target state="translated">テストに成功しました</target>
        </trans-unit>
        <trans-unit id="7f477dc5121884706ef8fed21e4d11c24e6db091" translate="yes" xml:space="preserve">
          <source>Sum across array propagating NaNs.</source>
          <target state="translated">アレイ伝搬するNaN全体の和。</target>
        </trans-unit>
        <trans-unit id="b2cc82eaee79a7562889de3502bb827b013693aa" translate="yes" xml:space="preserve">
          <source>Sum along diagonals.</source>
          <target state="translated">対角線に沿った和。</target>
        </trans-unit>
        <trans-unit id="b221abad8e52361732192c7acb9613f67b076ac3" translate="yes" xml:space="preserve">
          <source>Sum array elements.</source>
          <target state="translated">配列の要素を合計します。</target>
        </trans-unit>
        <trans-unit id="96c00e26cd369dd11b081a1035d4633225e7965d" translate="yes" xml:space="preserve">
          <source>Sum of array elements over a given axis.</source>
          <target state="translated">指定された軸上の配列要素の合計。</target>
        </trans-unit>
        <trans-unit id="6302a8aa98d30db8a3e7186cb73eb9e4337d618b" translate="yes" xml:space="preserve">
          <source>Sum over an axis (requires explicit form):</source>
          <target state="translated">軸上の和(明示的な形式が必要)。</target>
        </trans-unit>
        <trans-unit id="1c979daf2b6e4cef98bd537ad236de258dbc0d5a" translate="yes" xml:space="preserve">
          <source>Sum over axes 0 and 2. The result has same number of dimensions as the original array:</source>
          <target state="translated">軸 0 と軸 2 の和。結果は元の配列と同じ次元数になります。</target>
        </trans-unit>
        <trans-unit id="1103f1f7acbd2c5b9349bcbddbb45121fae537eb" translate="yes" xml:space="preserve">
          <source>Sum products over arbitrary axes.</source>
          <target state="translated">任意の軸上の積を合計します。</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="bf661fd6213ae079ce34c2c9dd00db526c359e2b" translate="yes" xml:space="preserve">
          <source>Sums of residuals; squared Euclidean 2-norm for each column in &lt;code&gt;b - a*x&lt;/code&gt;. If the rank of &lt;code&gt;a&lt;/code&gt; is &amp;lt; N or M &amp;lt;= N, this is an empty array. If &lt;code&gt;b&lt;/code&gt; is 1-dimensional, this is a (1,) shape array. Otherwise the shape is (K,).</source>
          <target state="translated">残差の合計; &lt;code&gt;b - a*x&lt;/code&gt; 各列の2乗ユークリッド2ノルム。ランク場合&amp;lt;N又はM &amp;lt;= Nであり、これは空の配列です。場合 &lt;code&gt;b&lt;/code&gt; 1次元であり、これは（1）形状のアレイです。それ以外の場合、形状は（K、）です。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6c71b95244ccde5ac8df906b9633b9278b04563" translate="yes" xml:space="preserve">
          <source>Sums, products, differences</source>
          <target state="translated">和・積・差</target>
        </trans-unit>
        <trans-unit id="56cedb0b6384ebe895f048d3113a97e19adce9ed" translate="yes" xml:space="preserve">
          <source>SunOS 5.9, Python 2.2, 2.3.2</source>
          <target state="translated">SunOS 5.9、Python 2.2、2.3.2</target>
        </trans-unit>
        <trans-unit id="5732c875d678ed7bc376f8bdb01c865cd0e57b5f" translate="yes" xml:space="preserve">
          <source>Support for multiple insertions when &lt;code&gt;obj&lt;/code&gt; is a single scalar or a sequence with one element (similar to calling insert multiple times).</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; が単一のスカラーまたは1つの要素を持つシーケンスである場合の複数の挿入のサポート（挿入を複数回呼び出すのと同様）。</target>
        </trans-unit>
        <trans-unit id="6d95257e0d6b5ee52701ed6e60955d7b5cf2355f" translate="yes" xml:space="preserve">
          <source>Supported BitGenerators</source>
          <target state="translated">サポートされているビットジェネレーター</target>
        </trans-unit>
        <trans-unit id="090678b79c24d0799aa7434df5ba4e013c0ea2ff" translate="yes" xml:space="preserve">
          <source>Supports Fortran-contiguous arrays directly.</source>
          <target state="translated">Fortranに連続した配列を直接サポートします.</target>
        </trans-unit>
        <trans-unit id="62c4a407a3644c899b58964ef70d8d5ea099dfdd" translate="yes" xml:space="preserve">
          <source>Supports full broadcasting of the inputs.</source>
          <target state="translated">入力のフル放送に対応しています。</target>
        </trans-unit>
        <trans-unit id="12f46de9102cae348756a951378fba972f726b07" translate="yes" xml:space="preserve">
          <source>Supports rolling over multiple dimensions simultaneously.</source>
          <target state="translated">複数の寸法を同時に転がすことに対応しています。</target>
        </trans-unit>
        <trans-unit id="d97b0cce7cf0a1a8ea78834b26b7eaa1e93207d9" translate="yes" xml:space="preserve">
          <source>Supports the method &lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt;&lt;code&gt;advance&lt;/code&gt;&lt;/a&gt; to advance the RNG an arbitrary number of steps. The state of the PCG-64 RNG is represented by 2 128-bit unsigned integers.</source>
          <target state="translated">メソッドサポート&lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt; &lt;code&gt;advance&lt;/code&gt; &lt;/a&gt; RNGに任意のステップを進めます。PCG-64 RNGの状態は、2つの128ビット符号なし整数で表されます。</target>
        </trans-unit>
        <trans-unit id="34c5f00d14223115d609ab63804b8bf6dbd38059" translate="yes" xml:space="preserve">
          <source>Suppose &lt;code&gt;x.shape&lt;/code&gt; is (10,20,30) and &lt;code&gt;ind&lt;/code&gt; is a (2,3,4)-shaped indexing &lt;code&gt;intp&lt;/code&gt; array, then &lt;code&gt;result = x[...,ind,:]&lt;/code&gt; has shape (10,2,3,4,30) because the (20,)-shaped subspace has been replaced with a (2,3,4)-shaped broadcasted indexing subspace. If we let &lt;em&gt;i, j, k&lt;/em&gt; loop over the (2,3,4)-shaped subspace then &lt;code&gt;result[...,i,j,k,:] = x[...,ind[i,j,k],:]&lt;/code&gt;. This example produces the same result as &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt;&lt;code&gt;x.take(ind, axis=-2)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">仮定 &lt;code&gt;x.shape&lt;/code&gt; がある（10,20,30）及び &lt;code&gt;ind&lt;/code&gt; （2,3,4）形状のインデキシングされ &lt;code&gt;intp&lt;/code&gt; アレイ、その後 &lt;code&gt;result = x[...,ind,:]&lt;/code&gt; 形状（10,2,3を有します、4,30）（20、）形のサブスペースが（2,3,4）形のブロードキャストインデックスサブスペースに置き換えられたため。&lt;em&gt;i、j、kを&lt;/em&gt;（2,3,4）形の部分空間でループさせると、 &lt;code&gt;result[...,i,j,k,:] = x[...,ind[i,j,k],:]&lt;/code&gt; 。この例は、&lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt; &lt;code&gt;x.take(ind, axis=-2)&lt;/code&gt; &lt;/a&gt;と同じ結果を生成します。</target>
        </trans-unit>
        <trans-unit id="ab6e03b971eeb9906907892d695f98f70c00c465" translate="yes" xml:space="preserve">
          <source>Suppose I have two files coolmodule.c and coolhelper.c which need to be compiled and linked into a single extension module. Suppose coolmodule.c contains the required initcool module initialization function (with the import_array() function called). Then, coolmodule.c would have at the top:</source>
          <target state="translated">二つのファイル coolmodule.c と coolhelper.c をコンパイルして一つの拡張モジュールにリンクする必要があるとします。coolmodule.c に必要な initcool モジュールの初期化関数 (import_array()関数を呼び出したもの)が含まれているとします。そうすると、coolmodule.c の先頭には、以下のような記述があります。</target>
        </trans-unit>
        <trans-unit id="1a06be2cc716b778d6a1c32b124922e42d2cce52" translate="yes" xml:space="preserve">
          <source>Suppose now that we wish to print that same data, but with the missing values replaced by the average value.</source>
          <target state="translated">同じデータを、欠落した値を平均値に置き換えて印刷したいとします。</target>
        </trans-unit>
        <trans-unit id="5dca6dc181cc53601add013bc2ada72709458943" translate="yes" xml:space="preserve">
          <source>Suppose the first operand is one dimensional and the second operand is two dimensional. The iterator will have three dimensions, so &lt;code&gt;op_axes&lt;/code&gt; will have two 3-element lists. The first list picks out the one axis of the first operand, and is -1 for the rest of the iterator axes, with a final result of [0, -1, -1]. The second list picks out the two axes of the second operand, but shouldn&amp;rsquo;t overlap with the axes picked out in the first operand. Its list is [-1, 0, 1]. The output operand maps onto the iterator axes in the standard manner, so we can provide None instead of constructing another list.</source>
          <target state="translated">最初のオペランドが1次元で、2番目のオペランドが2次元であるとします。イテレータには3つの次元があるため、 &lt;code&gt;op_axes&lt;/code&gt; には2つの3要素リストがあります。最初のリストは、最初のオペランドの1つの軸を選択し、残りの反復子軸では-1であり、最終結果は[0、-1、-1]です。 2番目のリストは、2番目のオペランドの2つの軸を選択しますが、最初のオペランドで選択された軸と重複してはなりません。そのリストは[-1、0、1]です。出力オペランドは標準的な方法でイテレータ軸にマッピングされるため、別のリストを作成する代わりにNoneを提供できます。</target>
        </trans-unit>
        <trans-unit id="ffbff519fe81519b5859278de1db83d3776384bb" translate="yes" xml:space="preserve">
          <source>Suppose you have a SciPy module &lt;code&gt;scipy/xxx/yyy.py&lt;/code&gt; containing a function &lt;code&gt;zzz()&lt;/code&gt;. To test this function you would create a test module called &lt;code&gt;test_yyy.py&lt;/code&gt;. If you only need to test one aspect of &lt;code&gt;zzz&lt;/code&gt;, you can simply add a test function:</source>
          <target state="translated">関数 &lt;code&gt;zzz()&lt;/code&gt; を含むSciPyモジュール &lt;code&gt;scipy/xxx/yyy.py&lt;/code&gt; があるとします。この関数をテストするには、 &lt;code&gt;test_yyy.py&lt;/code&gt; というテストモジュールを作成します。 &lt;code&gt;zzz&lt;/code&gt; の 1つの側面のみをテストする必要がある場合は、テスト関数を追加するだけです。</target>
        </trans-unit>
        <trans-unit id="561e62ec5d03ac50c21e0a257548d3eb990ac028" translate="yes" xml:space="preserve">
          <source>Suppose you have an urn with 15 white and 15 black marbles. If you pull 15 marbles at random, how likely is it that 12 or more of them are one color?</source>
          <target state="translated">15個の白と15個の黒のビー玉が入った骨壷があるとします。15個のビー玉をランダムに引いた場合、12個以上のビー玉が1色である可能性はどのくらいでしょうか?</target>
        </trans-unit>
        <trans-unit id="7c7cd36a0c21d430e2827a371600cad0b35b80b7" translate="yes" xml:space="preserve">
          <source>Suppress the rows and/or columns of a 2-D array that contain masked values.</source>
          <target state="translated">マスクされた値を含む2次元配列の行や列を抑制します.</target>
        </trans-unit>
        <trans-unit id="00f54cf02ad98c4bd3014ede43830053636d4545" translate="yes" xml:space="preserve">
          <source>Suppress whole columns of a 2-D array that contain masked values.</source>
          <target state="translated">マスクされた値を含む2次元配列の列全体を抑制します.</target>
        </trans-unit>
        <trans-unit id="685b0c43425911b6f904fe6d170e96c0345d4cbf" translate="yes" xml:space="preserve">
          <source>Suppress whole rows of a 2-D array that contain masked values.</source>
          <target state="translated">マスクされた値を含む2次元配列の全行を抑制します.</target>
        </trans-unit>
        <trans-unit id="b11d9a95741366c39b17b9d4fd94445d808b15b4" translate="yes" xml:space="preserve">
          <source>Swap the bytes of the array elements</source>
          <target state="translated">配列要素のバイトを入れ替える</target>
        </trans-unit>
        <trans-unit id="bbdcf90ffec6f9d47a9ac51cf19b00a93a140fa9" translate="yes" xml:space="preserve">
          <source>Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned.</source>
          <target state="translated">戻り値の性質を決定するスイッチです。False(デフォルト)の場合は係数のみが返され、Trueの場合は特異値分解の診断情報も返されます。</target>
        </trans-unit>
        <trans-unit id="6b3384dea957229bd45073ab4c8cae823f791969" translate="yes" xml:space="preserve">
          <source>Switch determining the nature of the return value. When &lt;code&gt;False&lt;/code&gt; (the default) just the coefficients are returned; when &lt;code&gt;True&lt;/code&gt;, diagnostic information from the singular value decomposition (used to solve the fit&amp;rsquo;s matrix equation) is also returned.</source>
          <target state="translated">戻り値の性質を決定するスイッチ。とき &lt;code&gt;False&lt;/code&gt; （デフォルト）だけ係数が返されます。 &lt;code&gt;True&lt;/code&gt; の場合、特異値分解（当てはめの行列方程式を解くために使用される）からの診断情報も返されます。</target>
        </trans-unit>
        <trans-unit id="7af38070c59fd5383f5319f90871324cb011240a" translate="yes" xml:space="preserve">
          <source>System Entropy</source>
          <target state="translated">エントロピー系</target>
        </trans-unit>
        <trans-unit id="1b1430441b7b7dd5a90d83f42f914deacc5fd0e5" translate="yes" xml:space="preserve">
          <source>System configuration</source>
          <target state="translated">システム構成</target>
        </trans-unit>
        <trans-unit id="8e0d354392fe3fc9d2a5d83e7fd5a6f24a2b815a" translate="yes" xml:space="preserve">
          <source>TODO: Maybe it would be better to introduce a function &lt;code&gt;NpyIter_GetWrappedOutput&lt;/code&gt; and remove this flag?</source>
          <target state="translated">TODO：関数 &lt;code&gt;NpyIter_GetWrappedOutput&lt;/code&gt; を導入してこのフラグを削除する方がよいでしょうか？</target>
        </trans-unit>
        <trans-unit id="c398f641b79127cbb5368a052c9c18ee4b191edd" translate="yes" xml:space="preserve">
          <source>TODO: This feature can be easily extended for Fortran 90 codes as well. Let us know if you would need such a feature.</source>
          <target state="translated">TODO:この機能はFortran 90コードにも簡単に拡張できます。このような機能が必要な場合は、私たちに教えてください。</target>
        </trans-unit>
        <trans-unit id="d2bf59208074c19e062d597b69c91e24c1b3f65d" translate="yes" xml:space="preserve">
          <source>Take a sequence of 1-D arrays and stack them as columns to make a single 2-D array. 2-D arrays are stacked as-is, just like with &lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt;. 1-D arrays are turned into 2-D columns first.</source>
          <target state="translated">1次元配列のシーケンスを受け取り、それらを列としてスタックして、1つの2次元配列を作成します。2次元配列は、&lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt;と同様に、そのままスタックされます。1次元配列は、最初に2次元列に変換されます。</target>
        </trans-unit>
        <trans-unit id="a7063ff9c282b69776d4b6c1965ce5cc8d3d21f1" translate="yes" xml:space="preserve">
          <source>Take a sequence of 1-D arrays and stack them as columns to make a single 2-D array. 2-D arrays are stacked as-is, just like with &lt;a href=&quot;numpy.ma.hstack#numpy.ma.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt;. 1-D arrays are turned into 2-D columns first.</source>
          <target state="translated">1次元配列のシーケンスを受け取り、それらを列としてスタックして、1つの2次元配列を作成します。2次元配列は、&lt;a href=&quot;numpy.ma.hstack#numpy.ma.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt;と同様に、そのままスタックされます。1次元配列は、最初に2次元列に変換されます。</target>
        </trans-unit>
        <trans-unit id="948650b27c1b2b9784a79436cafe48d7d653c938" translate="yes" xml:space="preserve">
          <source>Take along an axis, using the same indices for every 1d slice</source>
          <target state="translated">1次元スライスごとに同じインデックスを使用して、軸に沿って取る</target>
        </trans-unit>
        <trans-unit id="750d821c9fa304621f4be0f3b88564bf9278e152" translate="yes" xml:space="preserve">
          <source>Take elements by matching the array and the index arrays</source>
          <target state="translated">配列とインデックス配列を一致させて要素を取る</target>
        </trans-unit>
        <trans-unit id="e11fd16230a195030272e04871b014d038eef9ab" translate="yes" xml:space="preserve">
          <source>Take elements from an array along an axis.</source>
          <target state="translated">配列から軸に沿って要素を取り出します。</target>
        </trans-unit>
        <trans-unit id="2bd0abec8d18fb4f628e5467a962eaf329bb6905" translate="yes" xml:space="preserve">
          <source>Take elements using a boolean mask</source>
          <target state="translated">ブール型マスクを使って要素を取る</target>
        </trans-unit>
        <trans-unit id="b8cd92f0049ea13b3db726f84fc3411287caeddf" translate="yes" xml:space="preserve">
          <source>Take the fields dictionary, &lt;em&gt;dict&lt;/em&gt;, such as the one attached to a data-type object and construct an ordered-list of field names such as is stored in the names field of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">データ型オブジェクトに接続されているようなフィールド辞書&lt;em&gt;dictを&lt;/em&gt;&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;、PyArray_Descrオブジェクトの名前フィールドに格納されているようなフィールド名の順序付きリストを作成します。</target>
        </trans-unit>
        <trans-unit id="673397230d0da22f7147b4eeece871fd1294c5ff" translate="yes" xml:space="preserve">
          <source>Take values from the input array by matching 1d index and data slices</source>
          <target state="translated">1次元インデックスとデータスライスをマッチングさせて入力配列から値を取得する</target>
        </trans-unit>
        <trans-unit id="7f4b8f1ca46302f3d1aba5fbdc3749dad60f0480" translate="yes" xml:space="preserve">
          <source>Take values from the input array by matching 1d index and data slices.</source>
          <target state="translated">1次元インデックスとデータスライスをマッチングさせて、入力配列から値を取得します。</target>
        </trans-unit>
        <trans-unit id="567aaaa85050a78f736c937e4e349477825e7c6c" translate="yes" xml:space="preserve">
          <source>Takes an arbitrary Python function and returns a NumPy ufunc.</source>
          <target state="translated">任意のPython関数を受け取り、NumPy ufuncを返します。</target>
        </trans-unit>
        <trans-unit id="ad884a5ab2796ce61beab25497caa48a0c350a18" translate="yes" xml:space="preserve">
          <source>Takes an arbitrary Python function and returns a ufunc</source>
          <target state="translated">任意の Python 関数を受け取り、ufunc を返します。</target>
        </trans-unit>
        <trans-unit id="4fe8421f7b4bac2910c2919a03e01d32f910e006" translate="yes" xml:space="preserve">
          <source>Taking an example cited in Wikipedia, this distribution can be used if one wanted to cut strings (each of initial length 1.0) into K pieces with different lengths, where each piece had, on average, a designated average length, but allowing some variation in the relative sizes of the pieces.</source>
          <target state="translated">ウィキペディアで引用されている例を例にすると、この分布は、(それぞれの初期長さ1.0の)弦を異なる長さのK個に切断したい場合に使用することができ、各個は平均的に指定された平均長さを持っていますが、相対的な大きさの変化を許容します。</target>
        </trans-unit>
        <trans-unit id="af1237aaefe517f485a7a53e6bb8a3bb8a86a6a4" translate="yes" xml:space="preserve">
          <source>Target array.</source>
          <target state="translated">ターゲットの配列。</target>
        </trans-unit>
        <trans-unit id="51038a1a794fec6114fafbb47a8bce902f23294f" translate="yes" xml:space="preserve">
          <source>Target indices, interpreted as integers.</source>
          <target state="translated">整数として解釈されるターゲットインデックス。</target>
        </trans-unit>
        <trans-unit id="695f8bb0287f4fc300e17fa93e5262f0b53e9bb1" translate="yes" xml:space="preserve">
          <source>Temporary directories are deleted when the DataSource is deleted.</source>
          <target state="translated">一時的なディレクトリは、DataSourceが削除されると削除されます。</target>
        </trans-unit>
        <trans-unit id="6701dda5ea2a62c52d8395d7a5c8f390a0ab64df" translate="yes" xml:space="preserve">
          <source>Tensor contraction:</source>
          <target state="translated">テンソルの収縮。</target>
        </trans-unit>
        <trans-unit id="7e786b6ecaa33c3bfa2a663250579b348bbb6678" translate="yes" xml:space="preserve">
          <source>Tensor contractions, &lt;a href=&quot;numpy.tensordot#numpy.tensordot&quot;&gt;&lt;code&gt;numpy.tensordot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">テンソル収縮、&lt;a href=&quot;numpy.tensordot#numpy.tensordot&quot;&gt; &lt;code&gt;numpy.tensordot&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8aa53899fcc2f4722e3aaa13b02a9f0c21a58b0c" translate="yes" xml:space="preserve">
          <source>Tensor to &amp;lsquo;invert&amp;rsquo;. Its shape must be &amp;lsquo;square&amp;rsquo;, i. e., &lt;code&gt;prod(a.shape[:ind]) == prod(a.shape[ind:])&lt;/code&gt;.</source>
          <target state="translated">「反転」するテンソル。その形状は「正方形」でなければなりません。つまり、 &lt;code&gt;prod(a.shape[:ind]) == prod(a.shape[ind:])&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="5a7912060e7ae8d981d410c16692b658bc5a8653" translate="yes" xml:space="preserve">
          <source>Tensors to &amp;ldquo;dot&amp;rdquo;.</source>
          <target state="translated">「ドット」へのテンソル。</target>
        </trans-unit>
        <trans-unit id="71218d40834bc4913fe2fbb95e52de19a584b43a" translate="yes" xml:space="preserve">
          <source>Test Running</source>
          <target state="translated">テストの実行</target>
        </trans-unit>
        <trans-unit id="2ec99dbb44d0090912e3c4ddf71222f3cee61914" translate="yes" xml:space="preserve">
          <source>Test Support (&lt;code&gt;numpy.testing&lt;/code&gt;)</source>
          <target state="translated">テストサポート（ &lt;code&gt;numpy.testing&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c35554b04739c6c6869f7c83d9841e0dda4c5073" translate="yes" xml:space="preserve">
          <source>Test Support (numpy.testing)</source>
          <target state="translated">テストサポート (numpy.testing)</target>
        </trans-unit>
        <trans-unit id="59afddee1692b59da457c30d92a5b65f5e31115a" translate="yes" xml:space="preserve">
          <source>Test element-wise for NaN and return result as a boolean array.</source>
          <target state="translated">NaNを要素ごとにテストし、結果をブール値の配列として返します。</target>
        </trans-unit>
        <trans-unit id="ed391a308f11ca7f40c17a765e9b20cc4e1035a2" translate="yes" xml:space="preserve">
          <source>Test element-wise for NaT (not a time) and return result as a boolean array.</source>
          <target state="translated">NaTを要素ごとにテストし(時間ではなく)、結果をブール値の配列として返します。</target>
        </trans-unit>
        <trans-unit id="9f34997c659f4457d18a667e13e9b54ff7ea7b5d" translate="yes" xml:space="preserve">
          <source>Test element-wise for finiteness (not infinity or not Not a Number).</source>
          <target state="translated">有限性(無限大ではないか、数ではないか)を要素ごとにテストします。</target>
        </trans-unit>
        <trans-unit id="b73482f0dd7c13ea3e95362c875b37244def5b6c" translate="yes" xml:space="preserve">
          <source>Test element-wise for negative infinity, return result as bool array.</source>
          <target state="translated">負の無限大を要素ごとにテストし、結果をbool配列で返します。</target>
        </trans-unit>
        <trans-unit id="f441420173d81baeaa59a4fb443d5293972df75a" translate="yes" xml:space="preserve">
          <source>Test element-wise for positive infinity, return result as bool array.</source>
          <target state="translated">正の無限大を要素ごとにテストし、結果をbool配列で返します。</target>
        </trans-unit>
        <trans-unit id="f76286ad13fcd1d6939365b38ad9443c5711054b" translate="yes" xml:space="preserve">
          <source>Test element-wise for positive or negative infinity.</source>
          <target state="translated">正の無限大か負の無限大かを要素ごとにテストします。</target>
        </trans-unit>
        <trans-unit id="a54ae1b5fd87138bbeb065cc5056362be6e773bd" translate="yes" xml:space="preserve">
          <source>Test if &lt;code&gt;path&lt;/code&gt; exists as (and in this order):</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; が次のように（この順序で）存在するかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="6db21c53daecd81068cb27c5716c17cf9ec8f853" translate="yes" xml:space="preserve">
          <source>Test if path exists.</source>
          <target state="translated">パスが存在するかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="ab9c97d91f47360ac72bf2e9386f7b26c75db7d2" translate="yes" xml:space="preserve">
          <source>Test if two strings are equal.</source>
          <target state="translated">2つの文字列が等しいかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="90c99592ef3a4e369f5b8438543a142bc4a6d8c8" translate="yes" xml:space="preserve">
          <source>Test support</source>
          <target state="translated">テストサポート</target>
        </trans-unit>
        <trans-unit id="fe6e53750db930a15ff2a9eb0786f6b4b0dd49e8" translate="yes" xml:space="preserve">
          <source>Test whether &lt;code&gt;ary&lt;/code&gt; is contiguous. If so, return 1. Otherwise, set a Python error and return 0.</source>
          <target state="translated">&lt;code&gt;ary&lt;/code&gt; が隣接しているかどうかをテストします。その場合は1を返します。それ以外の場合は、Pythonエラーを設定して0を返します。</target>
        </trans-unit>
        <trans-unit id="e52099e2b541a96f27cc77aa438f266ac05e538f" translate="yes" xml:space="preserve">
          <source>Test whether all array elements along a given axis evaluate to True.</source>
          <target state="translated">指定された軸に沿ったすべての配列要素がTrueに評価されるかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="7d4c1c04414d7af36c37c81837979d62019dac75" translate="yes" xml:space="preserve">
          <source>Test whether all elements along a given axis evaluate to True.</source>
          <target state="translated">指定された軸に沿ったすべての要素がTrueに評価されるかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="8dcb7ed405671230192b179ae33bab118c7f5996" translate="yes" xml:space="preserve">
          <source>Test whether all matrix elements along a given axis evaluate to True.</source>
          <target state="translated">指定された軸に沿ったすべての行列要素がTrueに評価されるかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="a8cd365e47952360dc676cadf55d3bc2ecae44b5" translate="yes" xml:space="preserve">
          <source>Test whether any array element along a given axis evaluates to True.</source>
          <target state="translated">指定された軸に沿った配列要素がTrueと評価されるかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="e54011a9e26f7c9e97e1ca23a771785990f7e7d4" translate="yes" xml:space="preserve">
          <source>Test whether any element along a given axis evaluates to True.</source>
          <target state="translated">指定された軸に沿った要素がTrueに評価されるかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="3c5d24b0586eac0954dbcb6d49897a1641c89d36" translate="yes" xml:space="preserve">
          <source>Test whether each element of a 1-D array is also present in a second array.</source>
          <target state="translated">1次元配列の各要素が2番目の配列にも存在するかどうかをテストします.</target>
        </trans-unit>
        <trans-unit id="025a700084bfede250ccd79227b915c047f7f35d" translate="yes" xml:space="preserve">
          <source>Test whether input is an instance of MaskedArray.</source>
          <target state="translated">入力がMaskedArrayのインスタンスであるかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="43d2fa7f4fbc625f4df01f08ea6653e49f950cbd" translate="yes" xml:space="preserve">
          <source>Testing Guidelines</source>
          <target state="translated">テストガイドライン</target>
        </trans-unit>
        <trans-unit id="ef9606fae34bdb52d82ad257949ec42aea0b9b12" translate="yes" xml:space="preserve">
          <source>Testing Header Files</source>
          <target state="translated">ヘッダーファイルのテスト</target>
        </trans-unit>
        <trans-unit id="d322a0e8fe52f19dbe7d5bd52156ee63071b90d8" translate="yes" xml:space="preserve">
          <source>Testing Organization</source>
          <target state="translated">試験機関</target>
        </trans-unit>
        <trans-unit id="e3148b0ff766bdb8347a198898838253aab4da96" translate="yes" xml:space="preserve">
          <source>Testing Python Scripts</source>
          <target state="translated">Python スクリプトのテスト</target>
        </trans-unit>
        <trans-unit id="8c3a61a48bb499744371cb7fc30761102d86f229" translate="yes" xml:space="preserve">
          <source>Testing SWIG Interface Files</source>
          <target state="translated">SWIGインターフェースファイルのテスト</target>
        </trans-unit>
        <trans-unit id="34d08d85bddb11f11da76ad84dab43a94d74c7ed" translate="yes" xml:space="preserve">
          <source>Testing Source Files</source>
          <target state="translated">ソースファイルのテスト</target>
        </trans-unit>
        <trans-unit id="7704b172077f920ddd46d5adbcffe86730e58a19" translate="yes" xml:space="preserve">
          <source>Testing looks for module-level or class-level setup and teardown functions by name; thus:</source>
          <target state="translated">テストでは、モジュールレベルまたはクラスレベルのセットアップとティアダウン関数を名前で探します。</target>
        </trans-unit>
        <trans-unit id="45ece46e91d1fe305feeee99aed2fad182be7b30" translate="yes" xml:space="preserve">
          <source>Testing the numpy.i Typemaps</source>
          <target state="translated">numpy.i型マップのテスト</target>
        </trans-unit>
        <trans-unit id="417d130b240483956f423e540d6cb689832b6f9e" translate="yes" xml:space="preserve">
          <source>Tests on random data</source>
          <target state="translated">ランダムデータのテスト</target>
        </trans-unit>
        <trans-unit id="f3d72180c504c070f745ad049bd21c11042867d1" translate="yes" xml:space="preserve">
          <source>Tests on random data are good, but since test failures are meant to expose new bugs or regressions, a test that passes most of the time but fails occasionally with no code changes is not helpful. Make the random data deterministic by setting the random number seed before generating it. Use either Python&amp;rsquo;s &lt;code&gt;random.seed(some_number)&lt;/code&gt; or NumPy&amp;rsquo;s &lt;code&gt;numpy.random.seed(some_number)&lt;/code&gt;, depending on the source of random numbers.</source>
          <target state="translated">ランダムデータでのテストは適切ですが、テストの失敗は新しいバグやリグレッションを明らかにすることを目的としているため、ほとんどの場合合格しますが、コードを変更せずに失敗するテストは役に立ちません。乱数シードを生成する前に設定して、ランダムデータを確定的にします。乱数のソースに応じて、Pythonの &lt;code&gt;random.seed(some_number)&lt;/code&gt; またはNumPyの &lt;code&gt;numpy.random.seed(some_number)&lt;/code&gt; のいずれかを使用します。</target>
        </trans-unit>
        <trans-unit id="927f696caa5bf0529c4f0991bbe8b99afb2fa55b" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float has a value equal to zero. This may be slightly faster than calling npy_half_eq(h, NPY_ZERO).</source>
          <target state="translated">半精度フロートの値が0に等しいかどうかを調べます。これは、npy_half_eq(h,NPY_ZERO)を呼び出すよりも若干速いかもしれません。</target>
        </trans-unit>
        <trans-unit id="b3be553d33f0513a6775eaa86f3391147a1aac09" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is a NaN.</source>
          <target state="translated">半精度フロートがNaNであるかどうかを判定します。</target>
        </trans-unit>
        <trans-unit id="6424a62751d70065c8ad2d16d22d5e29e4d2e45c" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is finite (not NaN or Inf).</source>
          <target state="translated">半精度フロートが有限であるかどうかをテストします(NaNやInfではありません)。</target>
        </trans-unit>
        <trans-unit id="b796fd95ec3aee28c84902e310b3fcc5e87bd087" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is plus or minus Inf.</source>
          <target state="translated">半精度フロートがプラスかマイナスかを判定します。</target>
        </trans-unit>
        <trans-unit id="9cad929af9630184e2ec9f960cd674271afcf718" translate="yes" xml:space="preserve">
          <source>Tests, that send messages to stderr, fail when executed from MSYS prompt because the messages are lost at some point.</source>
          <target state="translated">stderr にメッセージを送信するテストは、MSYS プロンプトから実行するとメッセージが失われるため失敗します。</target>
        </trans-unit>
        <trans-unit id="0a988a505d4f9bd1f41a57f4c2458a2423baedc7" translate="yes" xml:space="preserve">
          <source>Text files</source>
          <target state="translated">テキストファイル</target>
        </trans-unit>
        <trans-unit id="4ba343aecd438b7c22876dbbd27f537f09be5607" translate="yes" xml:space="preserve">
          <source>Text formatting options</source>
          <target state="translated">テキストの書式設定オプション</target>
        </trans-unit>
        <trans-unit id="90e8faeace432448f3522160a796443560f628f2" translate="yes" xml:space="preserve">
          <source>That can be one of 12 different scalar types: &lt;code&gt;signed char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, &lt;code&gt;unsigned long long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;signed char&lt;/code&gt; 、 &lt;code&gt;unsigned char&lt;/code&gt; 、 &lt;code&gt;short&lt;/code&gt; 、 &lt;code&gt;unsigned short&lt;/code&gt; 、 &lt;code&gt;int&lt;/code&gt; 、 &lt;code&gt;unsigned int&lt;/code&gt; 、 &lt;code&gt;long&lt;/code&gt; 、 &lt;code&gt;unsigned long&lt;/code&gt; 、 &lt;code&gt;long long&lt;/code&gt; 、 &lt;code&gt;unsigned long long&lt;/code&gt; 、 &lt;code&gt;float&lt;/code&gt; および &lt;code&gt;double&lt;/code&gt; の12種類のスカラー型のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="be4b72468f984c83d93633e8f8bf75388e94a047" translate="yes" xml:space="preserve">
          <source>That is a looser test than originally documented, but agrees with what the actual implementation did up to rounding vagaries. An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">これは元々文書化されていたテストよりも緩いテストですが、実際の実装が丸めのばらつきまで行ったものと一致しています。形状の不一致や値が競合する場合に例外が発生します。numpy の標準的な使い方とは対照的に、NaN は数字と同じように比較され、両方のオブジェクトが同じ位置に NaN を持っていてもアサーションは発生しません。</target>
        </trans-unit>
        <trans-unit id="31ca174a88927a9e0e7f8f15283f8ce9b3459f51" translate="yes" xml:space="preserve">
          <source>That is a looser test than originally documented, but agrees with what the actual implementation in &lt;a href=&quot;numpy.testing.assert_array_almost_equal#numpy.testing.assert_array_almost_equal&quot;&gt;&lt;code&gt;assert_array_almost_equal&lt;/code&gt;&lt;/a&gt; did up to rounding vagaries. An exception is raised at conflicting values. For ndarrays this delegates to assert_array_almost_equal</source>
          <target state="translated">これは、最初に文書化されたものよりも緩いテストですが、&lt;a href=&quot;numpy.testing.assert_array_almost_equal#numpy.testing.assert_array_almost_equal&quot;&gt; &lt;code&gt;assert_array_almost_equal&lt;/code&gt; &lt;/a&gt;の実際の実装が丸めのばらつきまで何をしたかと一致します。値が競合すると例外が発生します。ndarraysの場合、これはassert_array_almost_equalに委任します</target>
        </trans-unit>
        <trans-unit id="b5240cf478eeccab2d778da09495ef32dd780cc8" translate="yes" xml:space="preserve">
          <source>That support 74 different argument signatures for each data type, including:</source>
          <target state="translated">を含む、各データ型の74の異なる引数シグネチャをサポートしています。</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="5c4c1c79691cc97764af36fe5679519dac98f423" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;busday&amp;rdquo; functions can additionally check a list of &amp;ldquo;holiday&amp;rdquo; dates, specific dates that are not valid days.</source>
          <target state="translated">「バスデー」機能はさらに、「休日」の日付のリスト、有効な日ではない特定の日付をチェックできます。</target>
        </trans-unit>
        <trans-unit id="701df984a45b35c07efc7a2ab11dc3b2d9004e29" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;four quadrant&amp;rdquo; arctan of the angle formed by (&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;) and the positive &lt;code&gt;x&lt;/code&gt;-axis.</source>
          <target state="translated">（ &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; ）と正の &lt;code&gt;x&lt;/code&gt; 軸によって形成される角度の「4象限」アークタン。</target>
        </trans-unit>
        <trans-unit id="2adc5d4e116d43dd248737cacbfac03ed3ef63f9" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;y-intercept&amp;rdquo; and &amp;ldquo;slope&amp;rdquo; of the line, respectively.</source>
          <target state="translated">ラインの「y切片」と「勾配」。</target>
        </trans-unit>
        <trans-unit id="e4a0235cef14b392c275cecc105837cde82d5723" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;a&amp;rsquo; variable is unstripped from c[1] because whitespace leading.</source>
          <target state="translated">空白文字が先行しているため、 'a'変数はc [1]から取り除かれます。</target>
        </trans-unit>
        <trans-unit id="bda37a7da4e6885245e567c4fedb24dc646e8a1c" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;out&amp;rsquo; keyword argument is expected to be a tuple with one entry per output (which can be &lt;code&gt;None&lt;/code&gt; for arrays to be allocated by the ufunc). For ufuncs with a single output, passing a single array (instead of a tuple holding a single array) is also valid.</source>
          <target state="translated">'out'キーワード引数は、出力ごとに1つのエントリを持つタプルであることが期待されます（ufuncによって割り当てられる配列の場合は &lt;code&gt;None&lt;/code&gt; にすることができます）。単一の出力を持つufuncの場合、（単一の配列を保持するタプルの代わりに）単一の配列を渡すことも有効です。</target>
        </trans-unit>
        <trans-unit id="34701f78458bf915d5b828bf9386058d6824fbe4" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;per&amp;rsquo; variable represents the periods of the loan. Remember that financial equations start the period count at 1!</source>
          <target state="translated">「per」変数はローンの期間を表します。財務方程式は期間カウントを1から開始することを忘れないでください！</target>
        </trans-unit>
        <trans-unit id="cb090179fdd970838b19c1b214a4530cfcd16ee3" translate="yes" xml:space="preserve">
          <source>The (non-conjugated) transpose of the matrix.</source>
          <target state="translated">行列の(非共役の)転置。</target>
        </trans-unit>
        <trans-unit id="2c0a3ac18c0e35ff547f3a4005419b0e018f9e8e" translate="yes" xml:space="preserve">
          <source>The 1.6 implementation of datetime does not convert between units correctly.:</source>
          <target state="translated">1.6 の datetime の実装では、単位間の変換が正しく行われませんでした。</target>
        </trans-unit>
        <trans-unit id="f72725eb7318a896f41cd0cf447d8c91f324fb0d" translate="yes" xml:space="preserve">
          <source>The 1.6 implementation of datetime only works correctly for a small subset of arithmetic operations. Here we show some simple cases.:</source>
          <target state="translated">datetimeの1.6の実装は、算術演算の小さなサブセットに対してのみ正しく動作します。ここでは、いくつかの簡単なケースを示します。</target>
        </trans-unit>
        <trans-unit id="887cfe3b8a793575511e5fe48982dbd8c7813d6e" translate="yes" xml:space="preserve">
          <source>The 2-D output array.</source>
          <target state="translated">2次元出力配列です。</target>
        </trans-unit>
        <trans-unit id="8d40d72287619706da0622aa60cf9b527faa81be" translate="yes" xml:space="preserve">
          <source>The 24 built-in &lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;array scalar type objects&lt;/a&gt; all convert to an associated data-type object. This is true for their sub-classes as well.</source>
          <target state="translated">24個の組み込み&lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;配列スカラー型オブジェクトは&lt;/a&gt;すべて、関連するデータ型オブジェクトに変換されます。これは、サブクラスにも当てはまります。</target>
        </trans-unit>
        <trans-unit id="44abfc0b778e06539587a775fdc8b33ee9085231" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; array flags can be &amp;ldquo;calculated&amp;rdquo; from the array object itself. This routine updates one or more of these flags of &lt;em&gt;arr&lt;/em&gt; as specified in &lt;em&gt;flagmask&lt;/em&gt; by performing the required calculation.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;、及び&lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;アレイフラグは配列オブジェクト自体から「計算」することができます。このルーチンは、必要な計算を実行することにより、&lt;em&gt;flagmaskで&lt;/em&gt;指定された&lt;em&gt;arr&lt;/em&gt;のこれらのフラグの1つ以上を更新します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="83e501c171dddeb86862ef16beddd704b5bc114a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; is the built-in type of the data-type-descriptor objects used to describe how the bytes comprising the array are to be interpreted. There are 21 statically-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects for the built-in data-types. While these participate in reference counting, their reference count should never reach zero. There is also a dynamic table of user-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects that is also maintained. Once a data-type-descriptor object is &amp;ldquo;registered&amp;rdquo; it should never be deallocated either. The function &lt;a href=&quot;c-api.array#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to retrieve a &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object from an enumerated type-number (either built-in or user- defined).</source>
          <target state="translated">&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; は、&lt;/a&gt;組み込みデータ型の記述子のタイプは、アレイを含むバイトが解釈される方法を記述するのに使用されるオブジェクトです。組み込みのデータ型には21の静的に定義された&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;オブジェクトがあります。これらは参照カウントに参加していますが、参照カウントがゼロになることはありません。また、維持されているユーザー定義の&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;オブジェクトの動的テーブルもあります。 data-type-descriptorオブジェクトが「登録」されると、割り当て解除することはできません。関数&lt;a href=&quot;c-api.array#c.PyArray_DescrFromType&quot;&gt; &lt;code&gt;PyArray_DescrFromType&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）を使用して、列挙されたtype-number（組み込みまたはユーザー定義のいずれか）から&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;オブジェクトを取得できます。</target>
        </trans-unit>
        <trans-unit id="3bd6fb4bf6c794847df919e4e53f9f40e8a12e37" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure is defined so that NumPy and other extension modules can use the rapid array interface protocol. The &lt;code&gt;__array_struct__&lt;/code&gt; method of an object that supports the rapid array interface protocol should return a &lt;code&gt;PyCObject&lt;/code&gt; that contains a pointer to a &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure with the relevant details of the array. After the new array is created, the attribute should be &lt;code&gt;DECREF&lt;/code&gt;&amp;rsquo;d which will free the &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure. Remember to &lt;code&gt;INCREF&lt;/code&gt; the object (whose &lt;code&gt;__array_struct__&lt;/code&gt; attribute was retrieved) and point the base member of the new &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; to this same object. In this way the memory for the array will be managed correctly.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; の&lt;/a&gt; numpyの及び他の拡張モジュールが急速配列インタフェースプロトコルを使用することができるように構造が定義されています。高速配列インターフェースプロトコルをサポートするオブジェクトの &lt;code&gt;__array_struct__&lt;/code&gt; メソッドは、配列の関連詳細を含む&lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;構造へのポインターを含む &lt;code&gt;PyCObject&lt;/code&gt; を返す必要があります。新しい配列が作成された後、&lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;構造を解放する属性を &lt;code&gt;DECREF&lt;/code&gt; する必要があります。覚え &lt;code&gt;INCREF&lt;/code&gt; （そのオブジェクト &lt;code&gt;__array_struct__&lt;/code&gt; 属性取得された）と新規のベース部材ポイント&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; を&lt;/a&gt;この同じオブジェクトに。このようにして、アレイのメモリは正しく管理されます。</target>
        </trans-unit>
        <trans-unit id="cd84e3bef1191839ce6ab3739e785dd2e1559188" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; C-structure contains all of the required information for an array. All instances of an ndarray (and its subclasses) will have this structure. For future compatibility, these structure members should normally be accessed using the provided macros. If you need a shorter name, then you can make use of &lt;code&gt;NPY_AO&lt;/code&gt; (deprecated) which is defined to be equivalent to &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; C-構造は、アレイに必要な情報のすべてを含みます。ndarray（およびそのサブクラス）のすべてのインスタンスは、この構造になります。将来の互換性のために、これらの構造体メンバーは通常、提供されたマクロを使用してアクセスする必要があります。あなたは短い名前が必要な場合は、利用することができ &lt;code&gt;NPY_AO&lt;/code&gt; と同等になるように定義されている（非推奨）&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d2c044849f6b8be8bb6f06a8ac4ced885f369cf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure lies at the heart of the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt;. While it is described here for completeness, it should be considered internal to NumPy and manipulated via &lt;code&gt;PyArrayDescr_*&lt;/code&gt; or &lt;code&gt;PyDataType*&lt;/code&gt; functions and macros. The size of this structure is subject to change across versions of NumPy. To ensure compatibility:</source>
          <target state="translated">&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; の&lt;/a&gt;構造はの中心に位置&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt;。完全を &lt;code&gt;PyArrayDescr_*&lt;/code&gt; ためにここで説明しますが、NumPyの内部と見なして、PyArrayDescr_ *または &lt;code&gt;PyDataType*&lt;/code&gt; 関数とマクロを介して操作する必要があります。この構造のサイズは、NumPyのバージョン間で変更される可能性があります。互換性を確保するには：</target>
        </trans-unit>
        <trans-unit id="2e3e60e01ee7ee0a4514d09bc8a1e601d0467625" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; typeobject implements many of the features of &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyTypeObject&quot;&gt;&lt;code&gt;Python objects&lt;/code&gt;&lt;/a&gt; including the &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_number&quot;&gt;&lt;code&gt;tp_as_number&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_sequence&quot;&gt;&lt;code&gt;tp_as_sequence&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_mapping&quot;&gt;&lt;code&gt;tp_as_mapping&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_buffer&quot;&gt;&lt;code&gt;tp_as_buffer&lt;/code&gt;&lt;/a&gt; interfaces. The &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.richcmpfunc&quot;&gt;&lt;code&gt;rich comparison&lt;/code&gt;&lt;/a&gt;) is also used along with new-style attribute lookup for member (&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_members&quot;&gt;&lt;code&gt;tp_members&lt;/code&gt;&lt;/a&gt;) and properties (&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_getset&quot;&gt;&lt;code&gt;tp_getset&lt;/code&gt;&lt;/a&gt;). The &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; can also be sub-typed.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; の&lt;/a&gt; typeobject器具の機能の多く&lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyTypeObject&quot;&gt; &lt;code&gt;Python objects&lt;/code&gt; &lt;/a&gt;を含む&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_number&quot;&gt; &lt;code&gt;tp_as_number&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_sequence&quot;&gt; &lt;code&gt;tp_as_sequence&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_mapping&quot;&gt; &lt;code&gt;tp_as_mapping&lt;/code&gt; &lt;/a&gt;、及び&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_buffer&quot;&gt; &lt;code&gt;tp_as_buffer&lt;/code&gt; の&lt;/a&gt;インターフェース。&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.richcmpfunc&quot;&gt; &lt;code&gt;rich comparison&lt;/code&gt; &lt;/a&gt;）また、新しいスタイルの属性メンバ（のルックアップと一緒に使用され&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_members&quot;&gt; &lt;code&gt;tp_members&lt;/code&gt; &lt;/a&gt;）とプロパティ（&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_getset&quot;&gt; &lt;code&gt;tp_getset&lt;/code&gt; &lt;/a&gt;）。&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; は&lt;/a&gt;、サブ入力することもできます。</target>
        </trans-unit>
        <trans-unit id="f2f36b5d156bf75520af226984583d62ec445b7c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module provides a set of vectorized string operations for arrays of type &lt;code&gt;numpy.string_&lt;/code&gt; or &lt;code&gt;numpy.unicode_&lt;/code&gt;. All of them are based on the string methods in the Python standard library.</source>
          <target state="translated">&lt;a href=&quot;#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; の&lt;/a&gt;モジュールは、型の配列のためのベクトル化文字列操作のセット提供 &lt;code&gt;numpy.string_&lt;/code&gt; 又は &lt;code&gt;numpy.unicode_&lt;/code&gt; を。これらはすべて、Python標準ライブラリの文字列メソッドに基づいています。</target>
        </trans-unit>
        <trans-unit id="2314014335c763a38d9f2613dc7158883ea47e7a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module can be used as an addition to &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; の&lt;/a&gt;モジュールへの追加として使用することができる&lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; の&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc31921d14e06fe1077c1cf00e508c39081a2db7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module comes with a specific implementation of most ufuncs. Unary and binary functions that have a validity domain (such as &lt;a href=&quot;generated/numpy.log#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.divide#numpy.divide&quot;&gt;&lt;code&gt;divide&lt;/code&gt;&lt;/a&gt;) return the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; constant whenever the input is masked or falls outside the validity domain:</source>
          <target state="translated">&lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; の&lt;/a&gt;モジュールは、ほとんどのufuncsの具体的な実装が付属しています。有効性ドメイン（&lt;a href=&quot;generated/numpy.log#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;generated/numpy.divide#numpy.divide&quot;&gt; &lt;code&gt;divide&lt;/code&gt; など&lt;/a&gt;）を持つ単項関数とバイナリ関数は、入力がマスクされるか、有効性ドメインの外にある場合は常に、&lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt;定数を返します。</target>
        </trans-unit>
        <trans-unit id="b2581729cb5a508c4225155bce5e9d0c211d34fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">&lt;a href=&quot;#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;クラスはNumarrayとの後方互換性のために存在し、それが新たな開発のために推奨されていません。numpy 1.4以降、文字列の配列が必要な場合は、&lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; 、 &lt;code&gt;string_&lt;/code&gt; または &lt;code&gt;unicode_&lt;/code&gt; の配列を使用し、&lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt;モジュールの無料の関数を使用して高速ベクトル化された文字列操作を行うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="bfd56b98bdff55bc0967f4255e8d608e0cada88c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.char.chararray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.char.chararray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;オブジェクトは、辞書のように（同様にアクセスすることができる &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ）、または（同様に小文字の属性名を使用して &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短いフラグ名は、辞書アクセスでのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="5b3e9186bfdffbf3c12bbb5a751b0411b0862a0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">&lt;a href=&quot;#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;クラスはNumarrayとの後方互換性のために存在し、それが新たな開発のために推奨されていません。numpy 1.4以降、文字列の配列が必要な場合は、&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; 、 &lt;code&gt;string_&lt;/code&gt; または &lt;code&gt;unicode_&lt;/code&gt; の配列を使用し、&lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt;モジュールの無料の関数を使用して高速ベクトル化された文字列操作を行うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="3c48c115471617c80e93a7432dc970b4f61e8b90" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.MaskedArray.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt;, as a regular &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt; of any shape or datatype (the data).</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.MaskedArray.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt;正規として、&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt;任意の形状またはデータ型（データ）。</target>
        </trans-unit>
        <trans-unit id="a0df6452154474f3f899180d65ac301d22c1fea9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.MaskedArray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.MaskedArray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;オブジェクトは、辞書のように（同様にアクセスすることができる &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ）、または（同様に小文字の属性名を使用して &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短いフラグ名は、辞書アクセスでのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="768878a0d288c4cac805d022d60e3e5c74cdd571" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; constant is a special case of &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, with a float datatype and a null shape. It is used to test whether a specific entry of a masked array is masked, or to mask one or several entries of a masked array:</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt;定数は、特殊なケースである&lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;フロートデータ型及びヌル形状を有します。これは、マスクされた配列の特定のエントリがマスクされているかどうかをテストするため、またはマスクされた配列の1つまたは複数のエントリをマスクするために使用されます。</target>
        </trans-unit>
        <trans-unit id="146a5b50c3ebb2fb745630d24192949df345a171" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.matrix.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.matrix.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;オブジェクトは、辞書のように（同様にアクセスすることができる &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ）、または（同様に小文字の属性名を使用して &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短いフラグ名は、辞書アクセスでのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="59336961ce31b9039ac38b42d5319606fa0f917b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ndarray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ndarray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;オブジェクトは、辞書のように（同様にアクセスすることができる &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ）、または（同様に小文字の属性名を使用して &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短いフラグ名は、辞書アクセスでのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="550894140eb6b413b0c8bb49cded0a5d50198b4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; provides access to a wide range of distributions, and served as a replacement for &lt;code&gt;RandomState&lt;/code&gt;. The main difference between the two is that &lt;code&gt;Generator&lt;/code&gt; relies on an additional BitGenerator to manage state and generate the random bits, which are then transformed into random values from useful distributions. The default BitGenerator used by &lt;code&gt;Generator&lt;/code&gt; is &lt;code&gt;PCG64&lt;/code&gt;. The BitGenerator can be changed by passing an instantized BitGenerator to &lt;code&gt;Generator&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;ディストリビューションの広い範囲へのアクセスを提供し、そしてのための代替を務め &lt;code&gt;RandomState&lt;/code&gt; 。 2つの主な違いは、 &lt;code&gt;Generator&lt;/code&gt; が追加のBitGeneratorに依存して状態を管理し、ランダムビットを生成することです。ランダムビットは、有用な分布からランダムな値に変換されます。 &lt;code&gt;Generator&lt;/code&gt; で使用されるデフォルトのBitGenerator は &lt;code&gt;PCG64&lt;/code&gt; です。 BitGeneratorは、インスタンス化されたBitGeneratorを &lt;code&gt;Generator&lt;/code&gt; に渡すことで変更できます。</target>
        </trans-unit>
        <trans-unit id="c4a823e24105a263472e6db5aa11ef1abc5d69b0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; provides access to legacy generators. This generator is considered frozen and will have no further improvements. It is guaranteed to produce the same values as the final point release of NumPy v1.16. These all depend on Box-Muller normals or inverse CDF exponentials or gammas. This class should only be used if it is essential to have randoms that are identical to what would have been produced by previous versions of NumPy.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; は、&lt;/a&gt;従来の発電機へのアクセスを提供します。このジェネレーターはフリーズされていると見なされ、これ以上の改善はありません。NumPy v1.16の最終ポイントリリースと同じ値が生成されることが保証されています。これらはすべて、Box-Muller法線または逆CDF指数またはガンマに依存します。このクラスは、以前のバージョンのNumPyによって生成されたものと同一の乱数を持つことが不可欠である場合にのみ使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="81979ac862ad90b476e52b55f8477208f98b95b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.recarray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.recarray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;オブジェクトは、辞書のように（同様にアクセスすることができる &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ）、または（同様に小文字の属性名を使用して &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短いフラグ名は、辞書アクセスでのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="84da36ced33272fa147152f5a355ea7313e10b52" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.sign&quot;&gt;&lt;code&gt;sign&lt;/code&gt;&lt;/a&gt; function returns &lt;code&gt;-1 if x &amp;lt; 0, 0 if x==0, 1 if x &amp;gt; 0&lt;/code&gt;. nan is returned for nan inputs.</source>
          <target state="translated">&lt;a href=&quot;#numpy.sign&quot;&gt; &lt;code&gt;sign&lt;/code&gt; &lt;/a&gt;関数戻り &lt;code&gt;-1 if x &amp;lt; 0, 0 if x==0, 1 if x &amp;gt; 0&lt;/code&gt; 。nanは、nan入力に対して返されます。</target>
        </trans-unit>
        <trans-unit id="c8f5bdf7e480a14edfbd94978da2fd35d2b6fd26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.testing.decorators.deprecated&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt; decorator itself.</source>
          <target state="translated">&lt;a href=&quot;#numpy.testing.decorators.deprecated&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt;デコレータ自体。</target>
        </trans-unit>
        <trans-unit id="f00c158e6b19c749648df9ba6c6e65d03c7d496b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.vectorize&quot;&gt;&lt;code&gt;vectorize&lt;/code&gt;&lt;/a&gt; function is provided primarily for convenience, not for performance. The implementation is essentially a for loop.</source>
          <target state="translated">&lt;a href=&quot;#numpy.vectorize&quot;&gt; &lt;code&gt;vectorize&lt;/code&gt; &lt;/a&gt;機能はありません、パフォーマンスのために、主に便宜のために提供されます。実装は基本的にforループです。</target>
        </trans-unit>
        <trans-unit id="5870961c86339efdff46c3532a51705af2f592f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;datetime unit&lt;/a&gt; on which this dtype is based.</source>
          <target state="translated">&lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;日時単位&lt;/a&gt;このDTYPEが基づいています。</target>
        </trans-unit>
        <trans-unit id="a98bd2e9d383259ba90aad2f3b46a4c0ddbbec99" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../routines.testing#module-numpy.testing&quot;&gt;&lt;code&gt;numpy.testing&lt;/code&gt;&lt;/a&gt; module includes &lt;code&gt;import decorators as dec&lt;/code&gt;. A test can be decorated as slow like this:</source>
          <target state="translated">&lt;a href=&quot;../routines.testing#module-numpy.testing&quot;&gt; &lt;code&gt;numpy.testing&lt;/code&gt; の&lt;/a&gt;モジュールは、 &lt;code&gt;import decorators as dec&lt;/code&gt; 。テストは次のように遅くなるように装飾できます：</target>
        </trans-unit>
        <trans-unit id="c4d94d478ef39d11efc586cafc38818b04af19cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt; function takes the iterators that have already been defined and uses them to determine the broadcast shape in each dimension (to create the iterators at the same time that broadcasting occurs then use the &lt;code&gt;PyMultiIter_New&lt;/code&gt; function). Then, the iterators are adjusted so that each iterator thinks it is iterating over an array with the broadcast size. This is done by adjusting the iterators number of dimensions, and the shape in each dimension. This works because the iterator strides are also adjusted. Broadcasting only adjusts (or adds) length-1 dimensions. For these dimensions, the strides variable is simply set to 0 so that the data-pointer for the iterator over that array doesn&amp;rsquo;t move as the broadcasting operation operates over the extended dimension.</source>
          <target state="translated">&lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; の&lt;/a&gt;機能は、既に定義されているイテレータを取り、（放送が次に使用発生と同時にイテレータを作成するために、各次元における放送形状を決定するためにそれらを使用 &lt;code&gt;PyMultiIter_New&lt;/code&gt; の機能）。次に、各イテレータがブロードキャストサイズの配列を反復していると各イテレータが考えるように、イテレータが調整されます。これは、反復子の次元数、および各次元の形状を調整することによって行われます。これは、反復子のストライドも調整されるため機能します。ブロードキャストでは、長さ1の寸法のみが調整（または追加）されます。これらの次元の場合、ストライド変数は単に0に設定されるため、その配列に対するイテレーターのデータポインターは、ブロードキャスト操作が拡張次元で動作するときに移動しません。</target>
        </trans-unit>
        <trans-unit id="d36f842f2997c8193b726b30df3debd673ecb729" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object can be used in all slicing operations to create an axis of length one. &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; is an alias for &amp;lsquo;None&amp;rsquo;, and &amp;lsquo;None&amp;rsquo; can be used in place of this with the same result.</source>
          <target state="translated">&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; の&lt;/a&gt;オブジェクトは、長さ1の軸線を作成するために、すべてのスライス操作で使用することができます。&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;は 'None'のエイリアスであり、これの代わりに 'None'を使用しても同じ結果になります。</target>
        </trans-unit>
        <trans-unit id="149f4058a1754093961b02f9ea6b9d5dd9c10925" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;クラスはNumarrayとの後方互換性のために存在し、それが新たな開発のために推奨されていません。numpy 1.4以降、文字列の配列が必要な場合は、&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; 、 &lt;code&gt;string_&lt;/code&gt; または &lt;code&gt;unicode_&lt;/code&gt; の配列を使用し、&lt;a href=&quot;routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt;モジュールの無料の関数を使用して高速ベクトル化された文字列操作を行うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f9537bf435fae2ec4edc2520b8aeb23abd0ca21e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; can be inherited from (in Python or in C) if desired. Therefore, it can form a foundation for many useful classes. Often whether to sub-class the array object or to simply use the core array component as an internal part of a new class is a difficult decision, and can be simply a matter of choice. NumPy has several tools for simplifying how your new object interacts with other array objects, and so the choice may not be significant in the end. One way to simplify the question is by asking yourself if the object you are interested in can be replaced as a single array or does it really require two or more arrays at its core.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; は、&lt;/a&gt;所望であれば、（PythonでまたはC）から継承することができます。したがって、多くの有用なクラスの基礎を形成できます。多くの場合、配列オブジェクトをサブクラス化するか、単にコア配列コンポーネントを新しいクラスの内部部分として使用するかは難しい決定であり、単に選択の問題にすぎません。 NumPyには、新しいオブジェクトが他の配列オブジェクトとどのように相互作用するかを簡略化するためのツールがいくつかあります。そのため、最終的には重要な選択ではない場合があります。質問を簡単にする1つの方法は、関心のあるオブジェクトを単一の配列として置き換えることができるか、それともコアに2つ以上の配列が本当に必要かどうかを自問することです。</target>
        </trans-unit>
        <trans-unit id="c0cd171dc2a149543f352698d4bc596e7f8afac8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; will try to provide chunks that are as large as possible to the inner loop. By forcing &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; order, we get different external loop sizes. This mode is enabled by specifying an iterator flag.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; は、&lt;/a&gt;内側のループにできるだけ大きい塊を提供しようとします。「C」と「F」の順序を強制することにより、異なる外部ループサイズが得られます。このモードは、反復子フラグを指定することで有効になります。</target>
        </trans-unit>
        <trans-unit id="f0287b2a9be936e86bf33e5d1e69557ad4042b14" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; is the user-facing object that is nearly identical to &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. The canonical method to initialize a generator passes a &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; bit generator as the sole argument.</source>
          <target state="translated">&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;とほぼ同じであるユーザー向けのオブジェクトである&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;。ジェネレーターを初期化する標準的な方法では、&lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;ビットジェネレーターを唯一の引数として渡します。</target>
        </trans-unit>
        <trans-unit id="a44536d85a990a438123d796af5725162190334f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;random generator&lt;/code&gt;&lt;/a&gt; takes the bit generator-provided stream and transforms them into more useful distributions, e.g., simulated normal random values. This structure allows alternative bit generators to be used with little code duplication.</source>
          <target state="translated">&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;random generator&lt;/code&gt; &lt;/a&gt;、通常のランダムな値をシミュレートし、例えば、ビットジェネレータが提供するストリームを取り、より有用ディストリビューションにそれらを変換します。この構造により、コードの重複がほとんどなく、代替ビットジェネレーターを使用できます。</target>
        </trans-unit>
        <trans-unit id="f7f755efceb36d8200d20dc31c04e76cd3c9faf2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; type checking and conversion system is a complicated combination of C macros, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; macros, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; typemaps and &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; fragments. Fragments are a way to conditionally insert code into your wrapper file if it is needed, and not insert it if not needed. If multiple typemaps require the same fragment, the fragment only gets inserted into your wrapper code once.</source>
          <target state="translated">&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIGの&lt;/a&gt;型チェックと変換システムは、Cマクロの複雑な組み合わせです&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIGの&lt;/a&gt;マクロ、&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIGの&lt;/a&gt;タイプマップと&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIGの&lt;/a&gt;断片。フラグメントは、必要に応じてラッパーファイルに条件付きでコードを挿入し、不要な場合は挿入しない方法です。複数のタイプマップが同じフラグメントを必要とする場合、フラグメントはラッパーコードに1回だけ挿入されます。</target>
        </trans-unit>
        <trans-unit id="1a20426fc7bb4d929b1ae303283b379020fbc254" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;numpy.polynomial.polynomial.polynomial.fit#numpy.polynomial.polynomial.Polynomial.fit&quot;&gt;&lt;code&gt;Polynomial.fit&lt;/code&gt;&lt;/a&gt; class method is recommended for new code as it is more stable numerically. See the documentation of the method for more information.</source>
          <target state="translated">&lt;a href=&quot;numpy.polynomial.polynomial.polynomial.fit#numpy.polynomial.polynomial.Polynomial.fit&quot;&gt; &lt;code&gt;Polynomial.fit&lt;/code&gt; の&lt;/a&gt;それはより安定した数値であるように、クラスメソッドは、新しいコードのために推奨されます。詳細については、メソッドのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="1ea1937064d555fd6f04fc2b57ae9e905ce9bf17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npy&lt;/code&gt; format is the standard binary file format in NumPy for persisting a &lt;em&gt;single&lt;/em&gt; arbitrary NumPy array on disk. The format stores all of the shape and dtype information necessary to reconstruct the array correctly even on another machine with a different architecture. The format is designed to be as simple as possible while achieving its limited goals.</source>
          <target state="translated">&lt;code&gt;.npy&lt;/code&gt; フォーマットが持続するためのnumpyのに標準的なバイナリファイル形式である&lt;em&gt;単一の&lt;/em&gt;ディスク上の任意のnumpyのアレイ。このフォーマットは、異なるアーキテクチャーを持つ別のマシンでもアレイを正しく再構築するために必要なすべての形状とdtype情報を保存します。フォーマットは、その限られた目標を達成しながら、できるだけシンプルになるように設計されています。</target>
        </trans-unit>
        <trans-unit id="d25fde9120bc920bdf839700f32d6b700adf8720" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npy&lt;/code&gt; format, including motivation for creating it and a comparison of alternatives, is described in the &lt;a href=&quot;https://www.numpy.org/neps/nep-0001-npy-format.html&quot;&gt;&amp;ldquo;npy-format&amp;rdquo; NEP&lt;/a&gt;, however details have evolved with time and this document is more current.</source>
          <target state="translated">&lt;code&gt;.npy&lt;/code&gt; それを作成するための動機および代替の比較を含むフォーマットは、に記載されている&lt;a href=&quot;https://www.numpy.org/neps/nep-0001-npy-format.html&quot;&gt;「NPYフォーマット」NEP&lt;/a&gt;詳細は時間とともに進化しており、この文書は、より多くの電流であるが、。</target>
        </trans-unit>
        <trans-unit id="22e53f126c53ee44cfae93fe323456796e3a7525" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; file format is a zipped archive of files named after the variables they contain. The archive is compressed with &lt;code&gt;zipfile.ZIP_DEFLATED&lt;/code&gt; and each file in the archive contains one variable in &lt;code&gt;.npy&lt;/code&gt; format. For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.npz&lt;/code&gt; ファイル形式は、そこに含まれる変数名にちなんで名付けられたファイルのzip形式のアーカイブです。アーカイブは &lt;code&gt;zipfile.ZIP_DEFLATED&lt;/code&gt; で圧縮されており、アーカイブ内の各ファイルには &lt;code&gt;.npy&lt;/code&gt; 形式の変数が1つ含まれています。説明については &lt;code&gt;.npy&lt;/code&gt; 形式、参照&lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b51e4d01309ff5a759f392af08bb39d1e99043e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; file format is a zipped archive of files named after the variables they contain. The archive is not compressed and each file in the archive contains one variable in &lt;code&gt;.npy&lt;/code&gt; format. For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.npz&lt;/code&gt; ファイル形式は、そこに含まれる変数名にちなんで名付けられたファイルのzip形式のアーカイブです。アーカイブは圧縮されておらず、アーカイブ内の各ファイルには &lt;code&gt;.npy&lt;/code&gt; 形式の変数が1つ含まれています。説明については &lt;code&gt;.npy&lt;/code&gt; 形式、参照&lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5c00dd2aa73f26e18024a200e3875179deacef9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; format is the standard format for persisting &lt;em&gt;multiple&lt;/em&gt; NumPy arrays on disk. A &lt;code&gt;.npz&lt;/code&gt; file is a zip file containing multiple &lt;code&gt;.npy&lt;/code&gt; files, one for each array.</source>
          <target state="translated">&lt;code&gt;.npz&lt;/code&gt; フォーマットは、持続するための標準フォーマットである&lt;em&gt;複数&lt;/em&gt;のディスク上のnumpyのアレイ。 &lt;code&gt;.npz&lt;/code&gt; ファイルが複数含むzipファイルである &lt;code&gt;.npy&lt;/code&gt; ファイル、各アレイの1を。</target>
        </trans-unit>
        <trans-unit id="19658579206ac4f8753c064c0302ad76f2f72a46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ALIGNED&lt;/code&gt; flag of an ndarray, computed in &lt;code&gt;IsAligned&lt;/code&gt; and checked by &lt;code&gt;PyArray_ISALIGNED&lt;/code&gt;. This is computed from &lt;code&gt;dtype.alignment&lt;/code&gt;. It is set to &lt;code&gt;True&lt;/code&gt; if every item in the array is at a memory location consistent with &lt;code&gt;dtype.alignment&lt;/code&gt;, which is the case if the data ptr and all strides of the array are multiples of that alignment.</source>
          <target state="translated">&lt;code&gt;ALIGNED&lt;/code&gt; ndarrayのフラグで計算 &lt;code&gt;IsAligned&lt;/code&gt; によって確認 &lt;code&gt;PyArray_ISALIGNED&lt;/code&gt; 。これは &lt;code&gt;dtype.alignment&lt;/code&gt; から計算されます。配列のすべての項目が &lt;code&gt;dtype.alignment&lt;/code&gt; と一致するメモリ位置にある場合は &lt;code&gt;True&lt;/code&gt; に設定されます。これは、データのptrと配列のすべてのストライドがその配置の倍数である場合です。</target>
        </trans-unit>
        <trans-unit id="85388f353d8827d53025cb4498ec7c4f7175db9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BitGenerator&lt;/code&gt; has a limited set of responsibilities. It manages state and provides functions to produce random doubles and random unsigned 32- and 64-bit values.</source>
          <target state="translated">&lt;code&gt;BitGenerator&lt;/code&gt; は、責任の限定セットを持っています。状態を管理し、ランダムなdoubleおよびランダムな符号なし32ビットおよび64ビット値を生成する関数を提供します。</target>
        </trans-unit>
        <trans-unit id="29642d4a46e1b1f330f5d899a27d8931b3675855" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Configuration&lt;/code&gt; constructor has a fourth optional argument, &lt;code&gt;package_path&lt;/code&gt;, that can be used when package files are located in a different location than the directory of the &lt;code&gt;setup.py&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;Configuration&lt;/code&gt; コンストラクタは、第四オプションの引数、持ってい &lt;code&gt;package_path&lt;/code&gt; パッケージファイルがあるディレクトリとは異なる場所に配置されているときに使用することができ、 &lt;code&gt;setup.py&lt;/code&gt; ファイルを。</target>
        </trans-unit>
        <trans-unit id="d942d62411c592ee85272583cee21a0d612eb9cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MT19937&lt;/code&gt; state vector consists of a 624-element array of 32-bit unsigned integers plus a single integer value between 0 and 624 that indexes the current position within the main array.</source>
          <target state="translated">&lt;code&gt;MT19937&lt;/code&gt; 状態ベクトルは、32ビット符号なし整数の624素子アレイプラス単一の整数値で構成され、0〜624に索引メインアレイ内の現在の位置。</target>
        </trans-unit>
        <trans-unit id="a95fd45cabac9b94aa97772f024779835dc306b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Makefile&lt;/code&gt; calls &lt;code&gt;swig&lt;/code&gt; to generate &lt;code&gt;Vector.py&lt;/code&gt; and &lt;code&gt;Vector_wrap.cxx&lt;/code&gt;, and also executes the &lt;code&gt;setup.py&lt;/code&gt; script that compiles &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; and links together the extension module &lt;code&gt;_Vector.so&lt;/code&gt; or &lt;code&gt;_Vector.dylib&lt;/code&gt;, depending on the platform. This extension module and the proxy file &lt;code&gt;Vector.py&lt;/code&gt; are both placed in a subdirectory under the &lt;code&gt;build&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;Makefile&lt;/code&gt; は呼び出し &lt;code&gt;swig&lt;/code&gt; 生成する &lt;code&gt;Vector.py&lt;/code&gt; と &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; を、また実行 &lt;code&gt;setup.py&lt;/code&gt; コンパイルスクリプト &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; 拡張モジュールとリンクを一緒に &lt;code&gt;_Vector.so&lt;/code&gt; または &lt;code&gt;_Vector.dylib&lt;/code&gt; をプラットフォームに応じて、。この拡張モジュールとプロキシファイル &lt;code&gt;Vector.py&lt;/code&gt; は、どちらも &lt;code&gt;build&lt;/code&gt; ディレクトリの下のサブディレクトリに配置されます。</target>
        </trans-unit>
        <trans-unit id="a509290375510505b589158f3b8f2b07b506f6b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MaskedArray&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;MaskedArray&lt;/code&gt; クラス</target>
        </trans-unit>
        <trans-unit id="b55e755e6d26d2135c464a8b79f8ff9c154dcada" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NPY_SIZEOF_{CTYPE}&lt;/code&gt; constants are defined so that sizeof information is available to the pre-processor.</source>
          <target state="translated">&lt;code&gt;NPY_SIZEOF_{CTYPE}&lt;/code&gt; 定数はsizeof情報をプリプロセッサに利用可能であるように定義されます。</target>
        </trans-unit>
        <trans-unit id="d918fc830e6f124f45ecb19bab96030d1a7583a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PCG64&lt;/code&gt; state vector consists of 2 unsigned 128-bit values, which are represented externally as Python ints. One is the state of the PRNG, which is advanced by a linear congruential generator (LCG). The second is a fixed odd increment used in the LCG.</source>
          <target state="translated">&lt;code&gt;PCG64&lt;/code&gt; の状態ベクトルは、Python int値として外部表される2符号なしの128ビット値、から成ります。1つはPRNGの状態で、線形合同法ジェネレーター（LCG）によって進められます。2番目は、LCGで使用される固定の奇数の増分です。</target>
        </trans-unit>
        <trans-unit id="c1a90ac63bb863a062bb153b73df1e64c4857aff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Philox&lt;/code&gt; state vector consists of a 256-bit value encoded as a 4-element uint64 array and a 128-bit value encoded as a 2-element uint64 array. The former is a counter which is incremented by 1 for every 4 64-bit randoms produced. The second is a key which determined the sequence produced. Using different keys produces independent sequences.</source>
          <target state="translated">&lt;code&gt;Philox&lt;/code&gt; の状態ベクトルは、4素子UINT64アレイと2要素UINT64アレイとして符号化された128ビット値として符号化された256ビット値から成ります。前者は、4つの64ビットランダムが生成されるたびに1ずつ増加するカウンターです。2番目は、生成されるシーケンスを決定するキーです。異なるキーを使用すると、独立したシーケンスが生成されます。</target>
        </trans-unit>
        <trans-unit id="4d1f94165781d8145f1fd80c467f6bd0f760f0b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SFC64&lt;/code&gt; state vector consists of 4 unsigned 64-bit values. The last is a 64-bit counter that increments by 1 each iteration.</source>
          <target state="translated">&lt;code&gt;SFC64&lt;/code&gt; の状態ベクトルは、4符号なしの64ビット値から成ります。最後は64ビットのカウンターで、反復ごとに1ずつ増加します。</target>
        </trans-unit>
        <trans-unit id="395b8858a352467f67b6a09c4a5fc424e26cfad2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__init__.py&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;__init__.py&lt;/code&gt; ファイル</target>
        </trans-unit>
        <trans-unit id="55e0b71eae2cfd6e566258a88d10c513a1a5a113" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; keyword of the dtype constructor, which only affects structured arrays. If the structure&amp;rsquo;s field offsets are not manually provided numpy determines offsets automatically. In that case, &lt;code&gt;align=True&lt;/code&gt; pads the structure so that each field is &amp;ldquo;true&amp;rdquo; aligned in memory and sets &lt;code&gt;dtype.alignment&lt;/code&gt; to be the largest of the field &amp;ldquo;true&amp;rdquo; alignments. This is like what C-structs usually do. Otherwise if offsets or itemsize were manually provided &lt;code&gt;align=True&lt;/code&gt; simply checks that all the fields are &amp;ldquo;true&amp;rdquo; aligned and that the total itemsize is a multiple of the largest field alignment. In either case &lt;code&gt;dtype.isalignedstruct&lt;/code&gt; is also set to True.</source>
          <target state="translated">dtypeコンストラクターの &lt;code&gt;align&lt;/code&gt; キーワード。構造化配列にのみ影響します。構造体のフィールドオフセットが手動で提供されない場合、numpyはオフセットを自動的に決定します。その場合、 &lt;code&gt;align=True&lt;/code&gt; は、各フィールドがメモリ内で「true」に整列されるように構造体を &lt;code&gt;dtype.alignment&lt;/code&gt; し、dtype.alignmentをフィールドの「true」整列の最大値に設定します。これはC構造体が通常行うことと似ています。それ以外の場合、オフセットまたはitemsizeが手動で提供 &lt;code&gt;align=True&lt;/code&gt; れた場合、align = Trueは、すべてのフィールドが「true」に配置されていること、および合計itemsizeが最大のフィールド配置の倍数であることを単にチェックします。どちらの場合も、 &lt;code&gt;dtype.isalignedstruct&lt;/code&gt; もTrueに設定されます。</target>
        </trans-unit>
        <trans-unit id="dd27c9fa716237737a1b850fd84a88e9e84db97b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt;-clause of the &lt;code&gt;with&lt;/code&gt;-statement gives the current print options:</source>
          <target state="translated">-clause &lt;code&gt;with&lt;/code&gt; -statementは、現在の印刷オプションを提供します： &lt;code&gt;as&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="caa858c948295450c18bcef4c572e68d7eda67a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;axis&lt;/code&gt; keyword can be used to specify a subset of axes of which the gradient is calculated</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; キーワードは、勾配が計算された軸のサブセットを指定するために使用することができます</target>
        </trans-unit>
        <trans-unit id="c68a2d64e2aeed4fdf4077c45259bb4b7c07822e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;axis&lt;/code&gt; parameter specifies the index of the new axis in the dimensions of the result. For example, if &lt;code&gt;axis=0&lt;/code&gt; it will be the first dimension and if &lt;code&gt;axis=-1&lt;/code&gt; it will be the last dimension.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; パラメータは、結果の次元で新しい軸のインデックスを指定します。たとえば、 &lt;code&gt;axis=0&lt;/code&gt; の場合は最初の次元になり、 &lt;code&gt;axis=-1&lt;/code&gt; の場合は最後の次元になります。</target>
        </trans-unit>
        <trans-unit id="7d4cb66724d02c13ff5f50a065c67d6d75a20a6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool_&lt;/code&gt; data type is very similar to the Python &lt;code&gt;BooleanType&lt;/code&gt; but does not inherit from it because Python&amp;rsquo;s &lt;code&gt;BooleanType&lt;/code&gt; does not allow itself to be inherited from, and on the C-level the size of the actual bool data is not the same as a Python Boolean scalar.</source>
          <target state="translated">&lt;code&gt;bool_&lt;/code&gt; のデータ型は、Pythonと非常に似て &lt;code&gt;BooleanType&lt;/code&gt; が、Pythonのため、それを継承しません &lt;code&gt;BooleanType&lt;/code&gt; は、それ自体から継承することはできません。また、C-レベルで実際のブールデータのサイズは、Pythonのブールと同じではありませんスカラー。</target>
        </trans-unit>
        <trans-unit id="1a9ec4df6ec3fb7357baf90864b29d969f59440a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool_&lt;/code&gt; type is not a subclass of the &lt;code&gt;int_&lt;/code&gt; type (the &lt;code&gt;bool_&lt;/code&gt; is not even a number type). This is different than Python&amp;rsquo;s default implementation of &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; as a sub-class of int.</source>
          <target state="translated">&lt;code&gt;bool_&lt;/code&gt; のタイプのサブクラスではない &lt;code&gt;int_&lt;/code&gt; タイプ（ &lt;code&gt;bool_&lt;/code&gt; は偶数タイプではありません）。これは、intのサブクラスとしての&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; の&lt;/a&gt; Pythonのデフォルト実装とは異なります。</target>
        </trans-unit>
        <trans-unit id="3f5c3b6d52d4becfb53cc5a7dd0ae6b04cdb9085" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a prefix or suffix; rather, all combinations of its values are stripped.</source>
          <target state="translated">&lt;code&gt;chars&lt;/code&gt; 引数には、削除する文字のセットを指定する文字列です。省略されるかNoneの場合、 &lt;code&gt;chars&lt;/code&gt; 引数はデフォルトで空白を削除します。 &lt;code&gt;chars&lt;/code&gt; 引数は、接頭辞や接尾辞ではありません。むしろ、その値のすべての組み合わせが取り除かれます。</target>
        </trans-unit>
        <trans-unit id="44ca716c299a61027880c154634feb6b89178fc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a prefix; rather, all combinations of its values are stripped.</source>
          <target state="translated">&lt;code&gt;chars&lt;/code&gt; 引数には、削除する文字のセットを指定する文字列です。省略されるかNoneの場合、 &lt;code&gt;chars&lt;/code&gt; 引数はデフォルトで空白を削除します。 &lt;code&gt;chars&lt;/code&gt; 引数は、接頭辞ではありません。むしろ、その値のすべての組み合わせが取り除かれます。</target>
        </trans-unit>
        <trans-unit id="3ab81d1fe754db2126af526470043294b9859fdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a suffix; rather, all combinations of its values are stripped.</source>
          <target state="translated">&lt;code&gt;chars&lt;/code&gt; 引数には、削除する文字のセットを指定する文字列です。省略されるかNoneの場合、 &lt;code&gt;chars&lt;/code&gt; 引数はデフォルトで空白を削除します。 &lt;code&gt;chars&lt;/code&gt; 引数が接尾辞ではありません。むしろ、その値のすべての組み合わせが取り除かれます。</target>
        </trans-unit>
        <trans-unit id="c5f33c0fec12debe8698b9f3d00999bb3fb759ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype.alignment&lt;/code&gt; attribute (&lt;code&gt;descr-&amp;gt;alignment&lt;/code&gt; in C). This is meant to reflect the &amp;ldquo;true alignment&amp;rdquo; of the type. It has arch-dependent default values for all datatypes, with the exception of structured types created with &lt;code&gt;align=True&lt;/code&gt; as described below.</source>
          <target state="translated">&lt;code&gt;dtype.alignment&lt;/code&gt; 属性（ &lt;code&gt;descr-&amp;gt;alignment&lt;/code&gt; Cで）。これは、タイプの「真の調整」を反映することを意味します。以下に説明するように &lt;code&gt;align=True&lt;/code&gt; で作成された構造化タイプを除いて、すべてのデータタイプにアーチ依存のデフォルト値があります。</target>
        </trans-unit>
        <trans-unit id="4e0428300bbf21ef1b533ffa3e86adb5ceddd8dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype&lt;/code&gt; parameter defines the underlying data type.</source>
          <target state="translated">&lt;code&gt;dtype&lt;/code&gt; パラメータは、基礎となるデータ・タイプを定義します。</target>
        </trans-unit>
        <trans-unit id="93f7d511e2846b265125fabe4d5030e15709832e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;excluded&lt;/code&gt; argument can be used to prevent vectorizing over certain arguments. This can be useful for array-like arguments of a fixed length such as the coefficients for a polynomial as in &lt;a href=&quot;numpy.polyval#numpy.polyval&quot;&gt;&lt;code&gt;polyval&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;excluded&lt;/code&gt; 引数は、特定の引数の上にベクトル化を防止するために使用することができます。これは、&lt;a href=&quot;numpy.polyval#numpy.polyval&quot;&gt; &lt;code&gt;polyval&lt;/code&gt; の&lt;/a&gt;ような多項式の係数など、固定長の配列のような引数に役立ちます。</target>
        </trans-unit>
        <trans-unit id="2beff53e54fda1bd096a7e81c4708f352287d275" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; attribute of the &lt;code&gt;PyArrayObject&lt;/code&gt; structure contains important information about the memory used by the array (pointed to by the data member) This flag information must be kept accurate or strange results and even segfaults may result.</source>
          <target state="translated">&lt;code&gt;PyArrayObject&lt;/code&gt; 構造体の &lt;code&gt;flags&lt;/code&gt; 属性には、配列で使用されるメモリに関する重要な情報が含まれます（データメンバーによってポイントされます）。このフラグ情報は、正確または奇妙な結果を維持する必要があり、segfaultsも発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8b08d522b6b1cfd800cd6bda4d86b04d644f1baf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int_&lt;/code&gt; type does &lt;strong&gt;not&lt;/strong&gt; inherit from the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; built-in under Python 3, because type &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; is no longer a fixed-width integer type.</source>
          <target state="translated">&lt;code&gt;int_&lt;/code&gt; タイプがない&lt;strong&gt;ではない&lt;/strong&gt;から継承していない&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;型ので、ビルトインのPython 3の下&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; は&lt;/a&gt;もはや固定幅の整数型です。</target>
        </trans-unit>
        <trans-unit id="5032550323e57bc7dec27d8af2d8f9df18642750" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;itershape&lt;/code&gt; parameter allows you to force the iterator to have a specific iteration shape. It is an array of length &lt;code&gt;oa_ndim&lt;/code&gt;. When an entry is negative, its value is determined from the operands. This parameter allows automatically allocated outputs to get additional dimensions which don&amp;rsquo;t match up with any dimension of an input.</source>
          <target state="translated">&lt;code&gt;itershape&lt;/code&gt; のパラメータを使用すると、特定の反復形状を有するようにイテレータを強制することができます。長さ &lt;code&gt;oa_ndim&lt;/code&gt; の配列です。エントリが負の場合、その値はオペランドから決定されます。このパラメーターを使用すると、出力が自動的に割り当てられ、入力のどの次元とも一致しない追加の次元を取得できます。</target>
        </trans-unit>
        <trans-unit id="d1b139e99319cf8723f8471165f727072e0de12d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;k&lt;/code&gt; different &amp;ldquo;columns&amp;rdquo; to be sorted. The last column (or row if &lt;code&gt;keys&lt;/code&gt; is a 2D array) is the primary sort key.</source>
          <target state="translated">&lt;code&gt;k&lt;/code&gt; ソートする別の「列」。最後の列（または &lt;code&gt;keys&lt;/code&gt; が2D配列の場合は行）がプライマリソートキーです。</target>
        </trans-unit>
        <trans-unit id="ab61433b884d13cbf28918d009f77e172c843e81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt; arrays of indices corresponding to the locations where &lt;code&gt;mask_func(np.ones((n, n)), k)&lt;/code&gt; is True.</source>
          <target state="translated">&lt;code&gt;mask_func(np.ones((n, n)), k)&lt;/code&gt; がTrueである場所に対応するインデックスの &lt;code&gt;n&lt;/code&gt; 個の配列。</target>
        </trans-unit>
        <trans-unit id="68dcfe0b1fdf3a267f300958e2039277e48ae02c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new_order&lt;/code&gt; code can be any from the following:</source>
          <target state="translated">&lt;code&gt;new_order&lt;/code&gt; のコードは、次のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="8693a0f592844bcf9978c5fbaa78f4621036206e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nonzero&lt;/code&gt; method of the condition array can also be called.</source>
          <target state="translated">条件配列の &lt;code&gt;nonzero&lt;/code&gt; メソッドも呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="d18c665ad6cff39ded6fc90bc8648963ab9ee138" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; file contains several macros and routines that it uses internally to build its typemaps. However, these functions may be useful elsewhere in your interface file. These macros and routines are implemented as fragments, which are described briefly in the previous section. If you try to use one or more of the following macros or functions, but your compiler complains that it does not recognize the symbol, then you need to force these fragments to appear in your code using:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; ファイルは、そのタイプマップを構築するために内部的に使用されるいくつかのマクロおよびルーチンが含まれています。ただし、これらの関数は、インターフェースファイルの他の場所で役立つ場合があります。これらのマクロとルーチンは、前のセクションで簡単に説明したフラグメントとして実装されます。以下のマクロまたは関数を1つ以上使用しようとしたが、コンパイラーがシンボルを認識しないと不平を言った場合、以下を使用してこれらのフラグメントを強制的にコードに表示する必要があります。</target>
        </trans-unit>
        <trans-unit id="9f4cb37fdc51e8b1f5c2b248e5fd15fdd94aa9b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; file is currently located in the &lt;code&gt;tools/swig&lt;/code&gt; sub-directory under the &lt;code&gt;numpy&lt;/code&gt; installation directory. Typically, you will want to copy it to the directory where you are developing your wrappers.</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; のファイルは、現在に位置している &lt;code&gt;tools/swig&lt;/code&gt; 下のサブディレクトリ &lt;code&gt;numpy&lt;/code&gt; のインストールディレクトリ。通常、ラッパーを開発しているディレクトリにコピーします。</target>
        </trans-unit>
        <trans-unit id="96831ff16133b13c87cfe870992604959917c570" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file also provides additional tools for wrapper developers, including:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; インターフェイスファイルも含めて、ラッパー開発者向けの追加ツールを提供しています。</target>
        </trans-unit>
        <trans-unit id="d04832f55eba99f2bc4cc0dceb3d718f68b6cac8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file does not support typemaps for output arrays, for several reasons. First, C/C++ return arguments are limited to a single value. This prevents obtaining dimension information in a general way. Second, arrays with hard-coded lengths are not permitted as return arguments. In other words:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; インターフェイスファイルは、いくつかの理由で、出力配列のためのタイプマップをサポートしていません。まず、C / C ++の戻り引数は単一の値に制限されます。これにより、一般的な方法で次元情報を取得できなくなります。次に、ハードコーディングされた長さの配列は、戻り引数として許可されていません。言い換えると：</target>
        </trans-unit>
        <trans-unit id="65e8b572ae6dc55c16aea9abc0f0766e897fe055" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file uses the &lt;code&gt;%numpy_typemaps&lt;/code&gt; macro to implement typemaps for the following C data types and &lt;code&gt;int&lt;/code&gt; dimension types:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; インターフェイスファイルが使用 &lt;code&gt;%numpy_typemaps&lt;/code&gt; 以下のCデータ型とするためのタイプマップを実装するマクロ &lt;code&gt;int&lt;/code&gt; 寸法タイプ：</target>
        </trans-unit>
        <trans-unit id="d99e0e96fa984690444350c5bb3087380beb5586" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.ma&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;numpy.ma&lt;/code&gt; のモジュール</target>
        </trans-unit>
        <trans-unit id="4c8ade543f0e1c46d97cf061c562c3116b9639d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;order&lt;/code&gt; keyword gives the index ordering both for &lt;em&gt;fetching&lt;/em&gt; the values from &lt;code&gt;a&lt;/code&gt;, and then &lt;em&gt;placing&lt;/em&gt; the values into the output array. For example, let&amp;rsquo;s say you have an array:</source>
          <target state="translated">&lt;code&gt;order&lt;/code&gt; キーワードはのために、両方のインデックスの順序与える&lt;em&gt;フェッチ&lt;/em&gt;からの値を、その後、&lt;em&gt;確定&lt;/em&gt;出力配列に値を。たとえば、次のような配列があるとします。 &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="022ed8cd0b6cf9d8c83ca5b8b482f20886ea6324" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;series&lt;/code&gt; is expected to be an instance of some polynomial series of one of the types supported by by the numpy.polynomial module, but could be some other class that supports the convert method.</source>
          <target state="translated">&lt;code&gt;series&lt;/code&gt; numpy.polynomialモジュールによってでサポートされているタイプのいずれかのいくつかの多項式一連のインスタンスであると予想されるが、変換メソッドをサポートするいくつかの他のクラスであってもよいです。</target>
        </trans-unit>
        <trans-unit id="f4910f2b9024b32efada1e65d4c1134f65374f1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setup.py&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;setup.py&lt;/code&gt; ファイル</target>
        </trans-unit>
        <trans-unit id="0948550106d7d72b97910c4e4918bcddbe3d6d6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;signature&lt;/code&gt; argument allows for vectorizing functions that act on non-scalar arrays of fixed length. For example, you can use it for a vectorized calculation of Pearson correlation coefficient and its p-value:</source>
          <target state="translated">&lt;code&gt;signature&lt;/code&gt; 引数は、固定長の非スカラー配列に作用する機能をベクトル化することを可能にします。たとえば、ピアソン相関係数とそのp値のベクトル化された計算に使用できます。</target>
        </trans-unit>
        <trans-unit id="19cc10b9b9bd6104c6aeb8b9be441a8dc8445028" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; argument must be a sequence that contains the following elements:</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; 引数には、次の要素を含むシーケンスである必要があります。</target>
        </trans-unit>
        <trans-unit id="28db18b99085783cc1cb19c430887ae4c1bd2dc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; tuple has the following items:</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; タプルは以下の項目があります。</target>
        </trans-unit>
        <trans-unit id="0e4c35736a2eec986972a33d172a5be16d326f7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tp_as_number&lt;/code&gt; methods use a generic approach to call whatever function has been registered for handling the operation. When the &lt;code&gt;_multiarray_umath module&lt;/code&gt; is imported, it sets the numeric operations for all arrays to the corresponding ufuncs. This choice can be changed with &lt;a href=&quot;c-api.ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt;&lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt;&lt;/a&gt; The &lt;code&gt;tp_str&lt;/code&gt; and &lt;code&gt;tp_repr&lt;/code&gt; methods can also be altered using &lt;a href=&quot;c-api.array#c.PyArray_SetStringFunction&quot;&gt;&lt;code&gt;PyArray_SetStringFunction&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;tp_as_number&lt;/code&gt; の方法は操作を処理するために登録されているものは何でも関数を呼び出すために、一般的なアプローチを使用します。場合 &lt;code&gt;_multiarray_umath module&lt;/code&gt; インポートされ、対応するufuncsにすべてのアレイのための数値演算を設定します。この選択はして変更することができ&lt;a href=&quot;c-api.ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt; &lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt; &lt;/a&gt; &lt;code&gt;tp_str&lt;/code&gt; と &lt;code&gt;tp_repr&lt;/code&gt; ハンドラのそれと方法も使用して変更することができます&lt;a href=&quot;c-api.array#c.PyArray_SetStringFunction&quot;&gt; &lt;code&gt;PyArray_SetStringFunction&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88a54cde186ec5ee99014b55275737fd8ded4abc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;bounds&lt;/em&gt; argument is expected to be a (2 * iter-&amp;gt;ao-&amp;gt;nd) arrays, such as the range bound[2*i]-&amp;gt;bounds[2*i+1] defines the range where to walk for dimension i (both bounds are included in the walked coordinates). The bounds should be ordered for each dimension (bounds[2*i] &amp;lt;= bounds[2*i+1]).</source>
          <target state="translated">&lt;em&gt;境界&lt;/em&gt; &amp;gt;境界[2 * I + 1]の次元iについて歩く範囲を定義-引数は、[2 * i]には、結合した範囲（2 * iter-&amp;gt; AO-&amp;gt; ND）アレイであると期待されます（両方の境界は、ウォークされた座標に含まれます）。境界は、次元ごとに順序付けする必要があります（bounds [2 * i] &amp;lt;= bounds [2 * i + 1]）。</target>
        </trans-unit>
        <trans-unit id="ea1fe523a0552e237800f38d8997bfcb72c8d0f5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;func&lt;/em&gt;, &lt;em&gt;data&lt;/em&gt;, &lt;em&gt;types&lt;/em&gt;, &lt;em&gt;name&lt;/em&gt;, and &lt;em&gt;doc&lt;/em&gt; arguments are not copied by &lt;a href=&quot;#c.PyUFunc_FromFuncAndData&quot;&gt;&lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt;&lt;/a&gt;. The caller must ensure that the memory used by these arrays is not freed as long as the ufunc object is alive.</source>
          <target state="translated">&lt;em&gt;FUNC&lt;/em&gt;、&lt;em&gt;データ&lt;/em&gt;、&lt;em&gt;種類&lt;/em&gt;、&lt;em&gt;名前&lt;/em&gt;、および&lt;em&gt;ドキュメントの&lt;/em&gt;引数はでコピーされません&lt;a href=&quot;#c.PyUFunc_FromFuncAndData&quot;&gt; &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; &lt;/a&gt;。呼び出し元は、これらの配列で使用されているメモリがufuncオブジェクトが有効である限り解放されないようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="20c9d63d4d93167ef641a021fb26c115a182b092" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;itemsize&lt;/em&gt; key allows the total size of the dtype to be set, and must be an integer large enough so all the fields are within the dtype. If the dtype being constructed is aligned, the &lt;em&gt;itemsize&lt;/em&gt; must also be divisible by the struct alignment. Total dtype &lt;em&gt;itemsize&lt;/em&gt; is limited to &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt;&lt;code&gt;ctypes.c_int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;itemsize&lt;/em&gt;キーはDTYPEの合計サイズを設定することができ、そしてすべてのフィールドがDTYPE内にあるように、整数十分な大きさでなければなりません。構築さDTYPEが整列されている場合、&lt;em&gt;itemsizeは&lt;/em&gt;また、構造体の配向で割り切れなければなりません。合計dtype &lt;em&gt;itemsize&lt;/em&gt;は&lt;em&gt;ctypes.c_int&lt;/em&gt;に制限されてい&lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt; &lt;code&gt;ctypes.c_int&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ed9f0881461d81b2f7af8ce5229589ca6d28abd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;-dimensional FFT of real input.</source>
          <target state="translated">実数入力の&lt;em&gt;n&lt;/em&gt;次元FFT。</target>
        </trans-unit>
        <trans-unit id="35066a9f7cb50260dfe6cd2d771163f62f1011ce" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">&lt;em&gt;N&lt;/em&gt;次元FFT。</target>
        </trans-unit>
        <trans-unit id="1f82e353fb8bee88c46f056efaf0e1b9b205e05a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;out&lt;/em&gt; argument to &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt; is not supported, &lt;code&gt;third&lt;/code&gt; has to be None.</source>
          <target state="translated">&lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt;への&lt;em&gt;out&lt;/em&gt;引数はサポートされていません。3 &lt;code&gt;third&lt;/code&gt; はNoneでなければなりません。</target>
        </trans-unit>
        <trans-unit id="17d0c90784f11b0394d45b1939c2a01c10fdf407" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;shape&lt;/em&gt; is the fixed shape of the sub-array described by this data type, and &lt;em&gt;item_dtype&lt;/em&gt; the data type of the array.</source>
          <target state="translated">&lt;em&gt;形状は、&lt;/em&gt;このデータ型によって記述サブアレイの固定された形状であり、&lt;em&gt;item_dtype&lt;/em&gt;アレイのデータ・タイプ。</target>
        </trans-unit>
        <trans-unit id="e35e90d2e4f0ba849a49c1795babe3ab2a9f08fe" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;side&lt;/em&gt; argument indicates whether the index returned should be that of the first suitable location (if &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt;) or of the last (if &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;側&lt;/em&gt;引数が返されるインデックスがなければならないかどうかを示す第一の適切な位置の（IF &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt; ）または最後の（場合 &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="099bc64f90d3db4f6c006d553b07493bf40349bd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sorter&lt;/em&gt; argument, if not &lt;code&gt;NULL&lt;/code&gt;, must be a 1D array of integer indices the same length as &lt;em&gt;self&lt;/em&gt;, that sorts it into ascending order. This is typically the result of a call to &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt;&lt;code&gt;PyArray_ArgSort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) Binary search is used to find the required insertion points.</source>
          <target state="translated">&lt;em&gt;ソータ&lt;/em&gt;ない場合引数は、 &lt;code&gt;NULL&lt;/code&gt; 、整数インデックスの1次元配列と同じ長さでなければならない&lt;em&gt;自己&lt;/em&gt;、昇順にソートしてあります。これは通常、&lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt; &lt;code&gt;PyArray_ArgSort&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）の呼び出しの結果です。必要な挿入ポイントを見つけるために、バイナリ検索が使用されます。</target>
        </trans-unit>
        <trans-unit id="7fad9b84d117a49a76f66aa7359451abb9299209" translate="yes" xml:space="preserve">
          <source>The API exposed by NumPy for third-party extensions has grown over years of releases, and has allowed programmers to directly access NumPy functionality from C. This API can be best described as &amp;ldquo;organic&amp;rdquo;. It has emerged from multiple competing desires and from multiple points of view over the years, strongly influenced by the desire to make it easy for users to move to NumPy from Numeric and Numarray. The core API originated with Numeric in 1995 and there are patterns such as the heavy use of macros written to mimic Python&amp;rsquo;s C-API as well as account for compiler technology of the late 90&amp;rsquo;s. There is also only a small group of volunteers who have had very little time to spend on improving this API.</source>
          <target state="translated">サードパーティの拡張機能のためにNumPyによって公開されたAPIは、長年にわたってリリースされており、プログラマーはCからNumPy機能に直接アクセスできるようになりました。このAPIは「オーガニック」として最もよく説明できます。これは、ユーザーがNumericおよびNumarrayからNumPyに簡単に移行できるようにしたいという強い影響を受けて、長年にわたる複数の競合する欲求および複数の視点から浮上しました。コアAPIは1995年にNumericで開発され、PythonのC-APIを模倣して90年代後半のコンパイラーテクノロジーを説明するために書かれたマクロの多用などのパターンがあります。また、このAPIの改善に費やす時間がほとんどないボランティアの小さなグループしかありません。</target>
        </trans-unit>
        <trans-unit id="00284168716cc312202174053f58f3f176efd9f0" translate="yes" xml:space="preserve">
          <source>The Array Interface</source>
          <target state="translated">配列インターフェース</target>
        </trans-unit>
        <trans-unit id="0126a67e2a45442b450ea70b10470e175bf968af" translate="yes" xml:space="preserve">
          <source>The Bartlett window is defined as</source>
          <target state="translated">バートレットウィンドウは次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="937ca2e1b9d54c371bf73ce20e57493839ccf829" translate="yes" xml:space="preserve">
          <source>The Bartlett window is very similar to a triangular window, except that the end points are at zero. It is often used in signal processing for tapering a signal, without generating too much ripple in the frequency domain.</source>
          <target state="translated">バートレット窓は三角窓に非常に似ていますが、終点がゼロであることを除いては、三角窓に似ています。バートレット窓は、周波数領域でのリップルをあまり発生させずに信号を先細りさせるために、信号処理でよく使用されます。</target>
        </trans-unit>
        <trans-unit id="9c87b609239622a7f33fd7054a79bbe3b69d99bf" translate="yes" xml:space="preserve">
          <source>The Beta distribution is a special case of the Dirichlet distribution, and is related to the Gamma distribution. It has the probability distribution function</source>
          <target state="translated">ベータ分布は、ディリクレ分布の特殊なケースであり、ガンマ分布に関連しています。これは確率分布関数</target>
        </trans-unit>
        <trans-unit id="b111fe41355b271c80f9d028d2e71b1df692e910" translate="yes" xml:space="preserve">
          <source>The BitGenerator can also be directly accessed using the members of the basic RNG structure.</source>
          <target state="translated">BitGeneratorは、基本的なRNG構造のメンバーを使用して直接アクセスすることもできます。</target>
        </trans-unit>
        <trans-unit id="fe9a0ff0e1aba5f3307dd340548f412e309bd12d" translate="yes" xml:space="preserve">
          <source>The BitGenerators have been designed to be extendable using standard tools for high-performance Python &amp;ndash; numba and Cython. The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; object can also be used with user-provided BitGenerators as long as these export a small set of required functions.</source>
          <target state="translated">BitGeneratorsは、高性能Pythonの標準ツールであるnumbaおよびCythonを使用して拡張できるように設計されています。&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;オブジェクトは、これらの輸出限りユーザ提供BitGeneratorsで必要な機能の小さなセットを使用することができます。</target>
        </trans-unit>
        <trans-unit id="d038e7d7a9d5b6013d6bf710bb0f42c26b9ffb86" translate="yes" xml:space="preserve">
          <source>The Blackman window is a taper formed by using the first three terms of a summation of cosines. It was designed to have close to the minimal leakage possible. It is close to optimal, only slightly worse than a Kaiser window.</source>
          <target state="translated">ブラックマン窓は、余弦の和の最初の3項を使用して形成されたテーパーです。これは、可能な限り漏れを最小限に抑えるように設計されています。最適に近く、カイザー窓よりもわずかに悪いだけです。</target>
        </trans-unit>
        <trans-unit id="df8aff554aa2b04bd579ded0666721d3f45ae21e" translate="yes" xml:space="preserve">
          <source>The Blackman window is defined as</source>
          <target state="translated">ブラックマンウィンドウは次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="201133c822c73c7e6eedbd7735bf455db76c868e" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using &lt;code&gt;Generator&lt;/code&gt; for the normal distribution or any other distribution that relies on the normal such as the &lt;code&gt;gamma&lt;/code&gt; or &lt;code&gt;standard_t&lt;/code&gt;. If you require bitwise backward compatible streams, use &lt;code&gt;RandomState&lt;/code&gt;.</source>
          <target state="translated">NumPyの法線を生成するために使用されるBox-Mullerメソッドは、&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;では使用できなくなりました。 &lt;code&gt;Generator&lt;/code&gt; を使用して正規分布や、 &lt;code&gt;gamma&lt;/code&gt; や &lt;code&gt;standard_t&lt;/code&gt; などの正規分布に依存する他の分布に対して正確なランダム値を再現することはできません。ビット単位の下位互換性のあるストリームが必要な場合は、 &lt;code&gt;RandomState&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="530afb1a91925fe435a9294f8360e96b319ffb64" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using Generator for the normal distribution or any other distribution that relies on the normal such as the &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.gamma#numpy.random.mtrand.RandomState.gamma&quot;&gt;&lt;code&gt;RandomState.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.standard_t#numpy.random.mtrand.RandomState.standard_t&quot;&gt;&lt;code&gt;RandomState.standard_t&lt;/code&gt;&lt;/a&gt;. If you require bitwise backward compatible streams, use &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NumPyの法線を生成するために使用されるBox-Mullerメソッドは、&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;では使用できなくなりました。&lt;a href=&quot;generated/numpy.random.mtrand.randomstate.gamma#numpy.random.mtrand.RandomState.gamma&quot;&gt; &lt;code&gt;RandomState.gamma&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;generated/numpy.random.mtrand.randomstate.standard_t#numpy.random.mtrand.RandomState.standard_t&quot;&gt; &lt;code&gt;RandomState.standard_t&lt;/code&gt; &lt;/a&gt;などの正規分布または正規分布に依存するその他の分布に対して、Generatorを使用して正確なランダム値を再現することはできません。ビット単位の下位互換性のあるストリームが必要な場合は、&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="08ca8f1d4aa8ba16007dde802489e6ef41f52bf0" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available.</source>
          <target state="translated">NumPyの法線を生成するために使用されるBox-Mullerメソッドは使用できなくなりました。</target>
        </trans-unit>
        <trans-unit id="12c85becd504bcc9e1840ed9b25393915f66f319" translate="yes" xml:space="preserve">
          <source>The C code to be wrapped for argoutview arrays are characterized by pointers: pointers to the dimensions and double pointers to the data, so that these values can be passed back to the user. The argoutview typemap signatures are therefore</source>
          <target state="translated">argoutview配列のためにラップされるCコードは,次元へのポインタとデータへのダブルポインタというポインタによって特徴づけられます.したがって、argoutviewのタイプマップのシグネチャは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="3b86dcfa016c911d4342c93c728710eb6da34647" translate="yes" xml:space="preserve">
          <source>The C-API is actually an array of function pointers. This array is created (and pointed to by a global variable) by import_ufunc. The global variable is either statically defined or allowed to be seen by other files depending on the state of &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt;&lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C-APIは、実際には関数ポインタの配列です。この配列は、import_ufuncによって作成（およびグローバル変数によってポイント）されます。グローバル変数は、&lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt; &lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt; の&lt;/a&gt;状態に応じて、静的に定義されるか、他のファイルからの参照を許可されます。</target>
        </trans-unit>
        <trans-unit id="27ac48dd933ed72b23987767613d8001cf662454" translate="yes" xml:space="preserve">
          <source>The C-structure corresponding to an object of &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; is used to keep track of a pointer into an N-dimensional array. It contains associated information used to quickly march through the array. The pointer can be adjusted in three basic ways: 1) advance to the &amp;ldquo;next&amp;rdquo; position in the array in a C-style contiguous fashion, 2) advance to an arbitrary N-dimensional coordinate in the array, and 3) advance to an arbitrary one-dimensional index into the array. The members of the &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; structure are used in these calculations. Iterator objects keep their own dimension and strides information about an array. This can be adjusted as needed for &amp;ldquo;broadcasting,&amp;rdquo; or to loop over only specific dimensions.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; の&lt;/a&gt;オブジェクトに対応するC構造体は&lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;です。&lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; は、&lt;/a&gt; N次元配列にポインタを追跡するために使用されます。これには、アレイ全体をすばやく移動するために使用される関連情報が含まれています。ポインターは、3つの基本的な方法で調整できます。1）Cスタイルの連続した方法で配列の「次の」位置に進む、2）配列の任意のN次元座標に進む、3）配列に進む配列への任意の1次元インデックス。&lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;のメンバーこれらの計算では構造が使用されます。イテレータオブジェクトは独自の次元を保持し、配列に関する情報をストライドします。これは、「ブロードキャスト」、または特定のディメンションのみをループするために、必要に応じて調整できます。</target>
        </trans-unit>
        <trans-unit id="5b65035b5e2ef1f9ddd680e8269d8b6e8cd78edf" translate="yes" xml:space="preserve">
          <source>The C-structure corresponding to an object of &lt;a href=&quot;#c.PyArrayNeighborhoodIter_Type&quot;&gt;&lt;code&gt;PyArrayNeighborhoodIter_Type&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;#c.PyArrayNeighborhoodIterObject&quot;&gt;&lt;code&gt;PyArrayNeighborhoodIterObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArrayNeighborhoodIter_Type&quot;&gt; &lt;code&gt;PyArrayNeighborhoodIter_Type&lt;/code&gt; の&lt;/a&gt;オブジェクトに対応するC構造体は&lt;a href=&quot;#c.PyArrayNeighborhoodIterObject&quot;&gt; &lt;code&gt;PyArrayNeighborhoodIterObject&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="b70a592ea3e52c944c4250fca143b3a7150ee3c2" translate="yes" xml:space="preserve">
          <source>The Cauchy distribution arises in the solution to the driven harmonic oscillator problem, and also describes spectral line broadening. It also describes the distribution of values at which a line tilted at a random angle will cut the x axis.</source>
          <target state="translated">Cauchy 分布は、従動高調波発振器問題の解で発生し、スペクトル線の広がりを記述します。また、ランダムな角度で傾いた線がx軸を切る値の分布も記述しています。</target>
        </trans-unit>
        <trans-unit id="7e16b7bac76fd95a18826e75104c29f03fcae229" translate="yes" xml:space="preserve">
          <source>The Chebyshev class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the methods listed below.</source>
          <target state="translated">Chebyshevクラスは、標準のPython数値メソッド「+」、「-」、「*」、「//」、「％」、「divmod」、「**」、および「（）」と、リストされたメソッドを提供します未満。</target>
        </trans-unit>
        <trans-unit id="993466511b9f370f4f72797c543b0fe46fcac4af" translate="yes" xml:space="preserve">
          <source>The Chebyshev series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">チェビシェフ級数の基底多項式は &lt;code&gt;x&lt;/code&gt; のべき乗ではないため、この関数の結果は直観的に見えない可能性があります。</target>
        </trans-unit>
        <trans-unit id="46d5d357969a2c2d8e943734dcd70f209f532e7d" translate="yes" xml:space="preserve">
          <source>The Cholesky decomposition is often used as a fast way of solving</source>
          <target state="translated">コレスキー分解は、次のような問題を解くための高速な方法としてよく使われます。</target>
        </trans-unit>
        <trans-unit id="7319ec02e3cbbaab7add308cd0a417516f369a3b" translate="yes" xml:space="preserve">
          <source>The DFT is defined, with the conventions used in this implementation, in the documentation for the &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">DFTは、この実装で使用される規則&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt;、numpy.fftモジュールのドキュメントで定義されています。</target>
        </trans-unit>
        <trans-unit id="c850428d828f95dc2c92af14d3b7a369fbb6f873" translate="yes" xml:space="preserve">
          <source>The DFT is in general defined for complex inputs and outputs, and a single-frequency component at linear frequency</source>
          <target state="translated">DFTは一般的に複雑な入力と出力に対して定義され、線形周波数での単一周波数成分</target>
        </trans-unit>
        <trans-unit id="e1f0dbe8081449397bad0aa2cc6ad0fe41215d23" translate="yes" xml:space="preserve">
          <source>The Datetime and Timedelta data types support a large number of time units, as well as generic units which can be coerced into any of the other units based on input data.</source>
          <target state="translated">Datetime と Timedelta データ型は、多数の時間単位と、入力データに基づいて他の単位に強制的に変換できる汎用単位をサポートしています。</target>
        </trans-unit>
        <trans-unit id="fcc8fbde1f068047c588e86f64b1d9bca100dc12" translate="yes" xml:space="preserve">
          <source>The Dirichlet distribution is a distribution over vectors</source>
          <target state="translated">ディリクレ分布はベクトルに対する分布である</target>
        </trans-unit>
        <trans-unit id="a4edf1637ded5c0257b8e49c407baa1302046498" translate="yes" xml:space="preserve">
          <source>The Einstein summation convention can be used to compute many multi-dimensional, linear algebraic array operations. &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; provides a succinct way of representing these.</source>
          <target state="translated">Einstein総和規則を使用して、多くの多次元線形代数配列演算を計算できます。&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;は、これらを表現する簡潔な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="28b073ac0a61d366802edc13aac74cfca673e0d2" translate="yes" xml:space="preserve">
          <source>The Euler constant</source>
          <target state="translated">オイラー定数</target>
        </trans-unit>
        <trans-unit id="e516b8e0c93fdf83378c5af74b4c3f11ab8b2eec" translate="yes" xml:space="preserve">
          <source>The F statistic is used to compare in-group variances to between-group variances. Calculating the distribution depends on the sampling, and so it is a function of the respective degrees of freedom in the problem. The variable &lt;code&gt;dfnum&lt;/code&gt; is the number of samples minus one, the between-groups degrees of freedom, while &lt;code&gt;dfden&lt;/code&gt; is the within-groups degrees of freedom, the sum of the number of samples in each group minus the number of groups.</source>
          <target state="translated">F統計は、グループ内の分散とグループ間の分散を比較するために使用されます。分布の計算はサンプリングに依存するため、問題のそれぞれの自由度の関数です。変数 &lt;code&gt;dfnum&lt;/code&gt; は、サンプル数から1を引いたもので、グループ間の自由度です。一方、 &lt;code&gt;dfden&lt;/code&gt; は、グループ内の自由度で、各グループのサンプル数の合計からグループ数を引いたものです。</target>
        </trans-unit>
        <trans-unit id="255611abe871551a6f0d10449c721d9ac320d3a5" translate="yes" xml:space="preserve">
          <source>The Frobenius norm is given by &lt;a href=&quot;#rac1c834adb66-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;:</source>
          <target state="translated">フロベニウスノルムは&lt;a href=&quot;#rac1c834adb66-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;によって与えられます。</target>
        </trans-unit>
        <trans-unit id="7783b7563d5c19477bd0cec8f560b128f37ead00" translate="yes" xml:space="preserve">
          <source>The Gamma distribution is often used to model the times to failure of electronic components, and arises naturally in processes for which the waiting times between Poisson distributed events are relevant.</source>
          <target state="translated">ガンマ分布は、電子部品の故障までの時間をモデル化するためによく使用され、ポアソン分布イベント間の待ち時間が関連するプロセスで自然に発生します。</target>
        </trans-unit>
        <trans-unit id="9c990e445bfb7966adc1e3b9adac640f1e0e9113" translate="yes" xml:space="preserve">
          <source>The Generator&amp;rsquo;s normal, exponential and gamma functions use 256-step Ziggurat methods which are 2-10 times faster than NumPy&amp;rsquo;s Box-Muller or inverse CDF implementations.</source>
          <target state="translated">ジェネレーターの通常の指数関数およびガンマ関数は、NumPyのBox-Mullerまたは逆CDF実装よりも2〜10倍速い256ステップのZigguratメソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="5fd129bc188ef44c6bd32a38b068d9f3ddc783f7" translate="yes" xml:space="preserve">
          <source>The Gumbel (named for German mathematician Emil Julius Gumbel) was used very early in the hydrology literature, for modeling the occurrence of flood events. It is also used for modeling maximum wind speed and rainfall rates. It is a &amp;ldquo;fat-tailed&amp;rdquo; distribution - the probability of an event in the tail of the distribution is larger than if one used a Gaussian, hence the surprisingly frequent occurrence of 100-year floods. Floods were initially modeled as a Gaussian process, which underestimated the frequency of extreme events.</source>
          <target state="translated">ガンベル（ドイツの数学者エミルジュリアスガンベルにちなんで名付けられました）は、洪水の発生をモデル化するために、水文学の非常に早い段階で使用されました。また、最大風速と降雨率のモデリングにも使用されます。これは「ファットテール」分布です。分布のテールでのイベントの確率は、ガウス分布を使用した場合よりも大きいため、驚くほど頻繁に100年の洪水が発生します。洪水は当初、ガウス過程としてモデル化され、極端なイベントの頻度を過小評価していました。</target>
        </trans-unit>
        <trans-unit id="aa1cbdb34f4d0d2f5ba482222c9284e53a83897b" translate="yes" xml:space="preserve">
          <source>The Gumbel (or Smallest Extreme Value (SEV) or the Smallest Extreme Value Type I) distribution is one of a class of Generalized Extreme Value (GEV) distributions used in modeling extreme value problems. The Gumbel is a special case of the Extreme Value Type I distribution for maximums from distributions with &amp;ldquo;exponential-like&amp;rdquo; tails.</source>
          <target state="translated">ガンベル（または最小極値（SEV）または最小極値タイプI）分布は、極値問題のモデリングで使用される一般化極値（GEV）分布のクラスの1つです。ガンベルは、「指数のような」裾をもつ分布からの最大値に対する極値タイプI分布の特殊なケースです。</target>
        </trans-unit>
        <trans-unit id="d38e3c533241c1cffef7a77e2fb316d839d0e953" translate="yes" xml:space="preserve">
          <source>The Hamming was named for R. W. Hamming, an associate of J. W. Tukey and is described in Blackman and Tukey. It was recommended for smoothing the truncated autocovariance function in the time domain. Most references to the Hamming window come from the signal processing literature, where it is used as one of many windowing functions for smoothing values. It is also known as an apodization (which means &amp;ldquo;removing the foot&amp;rdquo;, i.e. smoothing discontinuities at the beginning and end of the sampled signal) or tapering function.</source>
          <target state="translated">ハミングは、JWチューキーの仲間であるRWハミングにちなんで名付けられ、BlackmanとTukeyで説明されています。時間領域で打ち切られた自己共分散関数を平滑化するために推奨されました。ハミングウィンドウへのほとんどの参照は、値を平滑化するための多くのウィンドウ関数の1つとして使用される信号処理の文献から来ています。これは、アポダイゼーション（「足を取り除く」、つまり、サンプリングされた信号の最初と最後の不連続性を滑らかにすること）またはテーパー機能としても知られています。</target>
        </trans-unit>
        <trans-unit id="f6f99a10c7b1d0ed496e360cabc47ad0e8b4f95f" translate="yes" xml:space="preserve">
          <source>The Hamming window is a taper formed by using a weighted cosine.</source>
          <target state="translated">ハミング窓は、加重余弦を用いて形成されたテーパーである。</target>
        </trans-unit>
        <trans-unit id="c543c8775de7884a498fb8d25199a6da7865f313" translate="yes" xml:space="preserve">
          <source>The Hamming window is defined as</source>
          <target state="translated">ハミング窓は次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="c53c036c06b914f30dfda36ac484fab584082b10" translate="yes" xml:space="preserve">
          <source>The Hanning was named for Julius von Hann, an Austrian meteorologist. It is also known as the Cosine Bell. Some authors prefer that it be called a Hann window, to help avoid confusion with the very similar Hamming window.</source>
          <target state="translated">ハニングはオーストリアの気象学者ユリウス・フォン・ハンにちなんで名付けられた。コサインベルとしても知られています。ハミング窓との混同を避けるために、ハニング窓と呼ぶことを好む人もいます。</target>
        </trans-unit>
        <trans-unit id="ff9ff54dbcac5fb28018a438cebbfd23097afaae" translate="yes" xml:space="preserve">
          <source>The Hanning window is a taper formed by using a weighted cosine.</source>
          <target state="translated">ハニング窓は、重み付き余弦を用いて形成されたテーパである。</target>
        </trans-unit>
        <trans-unit id="7063e81cb7e74fa0cdbf05d1c6333c059e7c5e09" translate="yes" xml:space="preserve">
          <source>The Hanning window is defined as</source>
          <target state="translated">ハニングウィンドウは次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="48a86546760e1edd4295f33a270bba0337fe9c75" translate="yes" xml:space="preserve">
          <source>The Heaviside step function is defined as:</source>
          <target state="translated">ヘビサイドステップ関数は、次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="a4ab8a335073ed439b508ce34550cc0419ac6836" translate="yes" xml:space="preserve">
          <source>The Hermite class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Hermiteクラスは、標準のPython数値メソッド「+」、「-」、「*」、「//」、「％」、「divmod」、「**」、および「（）」、および属性と &lt;code&gt;ABCPolyBase&lt;/code&gt; のドキュメントにリストされているメソッド。</target>
        </trans-unit>
        <trans-unit id="18c51c2fe8d0823ca52707c91973d012f1770684" translate="yes" xml:space="preserve">
          <source>The Hermite series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">エルミート級数の基底多項式は &lt;code&gt;x&lt;/code&gt; のべき乗ではないため、この関数の結果は直観的に見えない可能性があります。</target>
        </trans-unit>
        <trans-unit id="29f886dede3063b00d8467b1f756a147bc393097" translate="yes" xml:space="preserve">
          <source>The HermiteE class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">HermiteEクラスは、標準のPython数値メソッド「+」、「-」、「*」、「//」、「％」、「divmod」、「**」、および「（）」、および属性と &lt;code&gt;ABCPolyBase&lt;/code&gt; のドキュメントにリストされているメソッド。</target>
        </trans-unit>
        <trans-unit id="8cc8b1724a44c8d63d2cfd0d81bc585f17fc260c" translate="yes" xml:space="preserve">
          <source>The HermiteE series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">HermiteEシリーズの基底多項式は &lt;code&gt;x&lt;/code&gt; のべき乗ではないため、この関数の結果は直観的に見えない可能性があります。</target>
        </trans-unit>
        <trans-unit id="d4c697a75ca6fe93876f5946baa1a9463872c64a" translate="yes" xml:space="preserve">
          <source>The IRR is perhaps best understood through an example (illustrated using np.irr in the Examples section below). Suppose one invests 100 units and then makes the following withdrawals at regular (fixed) intervals: 39, 59, 55, 20. Assuming the ending value is 0, one&amp;rsquo;s 100 unit investment yields 173 units; however, due to the combination of compounding and the periodic withdrawals, the &amp;ldquo;average&amp;rdquo; rate of return is neither simply 0.73/4 nor (1.73)^0.25-1. Rather, it is the solution (for</source>
          <target state="translated">IRRはおそらく、例（下記の例のセクションでnp.irrを使用して示されています）によって最もよく理解されます。100ユニットを投資し、定期的（固定）間隔で次の引き出しを行うとします。39、59、55、20。終了値が0であるとすると、100ユニットの投資は173ユニットになります。ただし、調合と定期的な引き出しの組み合わせにより、「平均」収益率は単に0.73 / 4でも（1.73）^ 0.25-1でもありません。むしろ、それはソリューションです（</target>
        </trans-unit>
        <trans-unit id="ddbfb62d79e442dbada344aa5b0b7d3f75bd62fd" translate="yes" xml:space="preserve">
          <source>The Kaiser can approximate many other windows by varying the beta parameter.</source>
          <target state="translated">カイザーはβパラメータを変化させることで、他の多くの窓を近似することができます。</target>
        </trans-unit>
        <trans-unit id="61a6a7b7c0a7a3c07a636b9187a5aa5c8ed22e80" translate="yes" xml:space="preserve">
          <source>The Kaiser was named for Jim Kaiser, who discovered a simple approximation to the DPSS window based on Bessel functions. The Kaiser window is a very good approximation to the Digital Prolate Spheroidal Sequence, or Slepian window, which is the transform which maximizes the energy in the main lobe of the window relative to total energy.</source>
          <target state="translated">カイザーは、ベッセル関数に基づいてDPSS窓への単純な近似を発見したジム・カイザーにちなんで命名されました。カイザー窓は、全エネルギーに対して窓の主ローブのエネルギーを最大化する変換であるデジタル・プロレート・スフェロイダル・シーケンス(Slepian window)の非常に優れた近似である。</target>
        </trans-unit>
        <trans-unit id="3c47d6f84b8a7a5230ef01c3b24f485faf045505" translate="yes" xml:space="preserve">
          <source>The Kaiser window is a taper formed by using a Bessel function.</source>
          <target state="translated">カイザー窓は、ベッセル関数を用いて形成されたテーパである。</target>
        </trans-unit>
        <trans-unit id="d40317952ac62ac63be6a7eb42d8bb031447a844" translate="yes" xml:space="preserve">
          <source>The Kaiser window is defined as</source>
          <target state="translated">カイザー窓は次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="de389ba4bc7accb91ca973f3199d4d09bb36d074" translate="yes" xml:space="preserve">
          <source>The Laguerre class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Laguerreクラスは、標準のPython数値メソッド「+」、「-」、「*」、「//」、「％」、「divmod」、「**」、および「（）」、および属性と &lt;code&gt;ABCPolyBase&lt;/code&gt; のドキュメントにリストされているメソッド。</target>
        </trans-unit>
        <trans-unit id="673da347447c32096475798f43cd3eae37f1e962" translate="yes" xml:space="preserve">
          <source>The Laguerre series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">ラゲール級数の基底多項式は &lt;code&gt;x&lt;/code&gt; のべき乗ではないため、この関数の結果は直感的に見えない可能性があります。</target>
        </trans-unit>
        <trans-unit id="beacaa427ac9dd11f90d057bc9c94b6f47608f00" translate="yes" xml:space="preserve">
          <source>The Laplace distribution is similar to the Gaussian/normal distribution, but is sharper at the peak and has fatter tails. It represents the difference between two independent, identically distributed exponential random variables.</source>
          <target state="translated">ラプラス分布は、ガウス分布/正規分布に似ていますが、ピークでシャープになり、尾が太くなります。これは、2つの独立した、同じように分布する指数関数的なランダム変数の間の差を表します。</target>
        </trans-unit>
        <trans-unit id="9f6965544802824fa340cc542a5a8e5ec41b1a8a" translate="yes" xml:space="preserve">
          <source>The Legendre class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Legendreクラスは、標準のPython数値メソッド「+」、「-」、「*」、「//」、「％」、「divmod」、「**」、および「（）」、および属性と &lt;code&gt;ABCPolyBase&lt;/code&gt; のドキュメントにリストされているメソッド。</target>
        </trans-unit>
        <trans-unit id="083c119f1df4d844bfc4b2160deea854a1daea76" translate="yes" xml:space="preserve">
          <source>The Legendre series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">ルジャンドル級数の基底多項式は &lt;code&gt;x&lt;/code&gt; のべき乗ではないため、この関数の結果は直観的に見えない可能性があります。</target>
        </trans-unit>
        <trans-unit id="191a6c01d66efbf4468b0c4b76d708edbb3efb30" translate="yes" xml:space="preserve">
          <source>The Logistic distribution is used in Extreme Value problems where it can act as a mixture of Gumbel distributions, in Epidemiology, and by the World Chess Federation (FIDE) where it is used in the Elo ranking system, assuming the performance of each player is a logistically distributed random variable.</source>
          <target state="translated">ロジスティック分布は、各プレーヤーのパフォーマンスがロジスティックに分布するランダム変数であると仮定して、それがEloランキングシステムで使用されている世界チェス連盟(FIDE)によって、疫学で、それがGumbel分布の混合物として機能することができる極端な値の問題で使用されます。</target>
        </trans-unit>
        <trans-unit id="7e46f1b490ad93ea0aa4b70cea1c8217c1eeec4d" translate="yes" xml:space="preserve">
          <source>The Lomax or Pareto II distribution is a shifted Pareto distribution. The classical Pareto distribution can be obtained from the Lomax distribution by adding 1 and multiplying by the scale parameter &lt;code&gt;m&lt;/code&gt; (see Notes). The smallest value of the Lomax distribution is zero while for the classical Pareto distribution it is &lt;code&gt;mu&lt;/code&gt;, where the standard Pareto distribution has location &lt;code&gt;mu = 1&lt;/code&gt;. Lomax can also be considered as a simplified version of the Generalized Pareto distribution (available in SciPy), with the scale set to one and the location set to zero.</source>
          <target state="translated">LomaxまたはパレートII分布は、シフトされたパレート分布です。古典的なパレート分布は、Lomax分布から1を加算し、スケールパラメーター &lt;code&gt;m&lt;/code&gt; を掛けることで取得できます（「注」を参照）。Lomax分布の最小値はゼロですが、従来のパレート分布の場合は &lt;code&gt;mu&lt;/code&gt; であり、標準のパレート分布の位置は &lt;code&gt;mu = 1&lt;/code&gt; です。Lomaxは、スケールが1に設定され、位置が0に設定された、一般化されたパレート分布（SciPyで利用可能）の簡易バージョンと見なすこともできます。</target>
        </trans-unit>
        <trans-unit id="913eec14ed443e489cdc77c2f2c24950a32724fd" translate="yes" xml:space="preserve">
          <source>The MATLAB &lt;code&gt;rem&lt;/code&gt; function and or the C &lt;code&gt;%&lt;/code&gt; operator which is the complement to &lt;code&gt;int(x1 / x2)&lt;/code&gt;.</source>
          <target state="translated">MATLABの &lt;code&gt;rem&lt;/code&gt; 関数、または &lt;code&gt;int(x1 / x2)&lt;/code&gt; 補数であるC &lt;code&gt;%&lt;/code&gt; 演算子。</target>
        </trans-unit>
        <trans-unit id="accc4f84d711af6e82c6efbbd034211d91d17fc7" translate="yes" xml:space="preserve">
          <source>The MaskedArray class</source>
          <target state="translated">MaskedArray クラス</target>
        </trans-unit>
        <trans-unit id="5110aa799914ad12dc0bd211beae0c5585bdbc96" translate="yes" xml:space="preserve">
          <source>The Matrix class</source>
          <target state="translated">マトリックスクラス</target>
        </trans-unit>
        <trans-unit id="aae8587a9f8f2d6d760d4e3f9211a40fc1df3fef" translate="yes" xml:space="preserve">
          <source>The N-dimensional array (&lt;code&gt;ndarray&lt;/code&gt;)</source>
          <target state="translated">N次元配列（ &lt;code&gt;ndarray&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ebbab7ca4ee7572bcfa080543866bf18ac7ca419" translate="yes" xml:space="preserve">
          <source>The N-dimensional array (ndarray)</source>
          <target state="translated">N次元配列(ndarray)</target>
        </trans-unit>
        <trans-unit id="9062ffe94800b2d5eac1ade12a3d3195e3fb90d9" translate="yes" xml:space="preserve">
          <source>The NPV of the input cash flow series &lt;code&gt;values&lt;/code&gt; at the discount &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">割引&lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt;での入力キャッシュフローシリーズ &lt;code&gt;values&lt;/code&gt; のNPV 。</target>
        </trans-unit>
        <trans-unit id="06341e3da348b45983c3d2e0a0cf15e91944f0fa" translate="yes" xml:space="preserve">
          <source>The NumPy 1.6 release includes a more primitive datetime data type than 1.7. This section documents many of the changes that have taken place.</source>
          <target state="translated">NumPy 1.6のリリースには、1.7よりも原始的なデータ型が含まれています。このセクションでは、これまでに行われた変更点の多くを文書化しています。</target>
        </trans-unit>
        <trans-unit id="22808a8257a77bd3771514110cd88913c8cbfe31" translate="yes" xml:space="preserve">
          <source>The NumPy linear algebra functions rely on BLAS and LAPACK to provide efficient low level implementations of standard linear algebra algorithms. Those libraries may be provided by NumPy itself using C versions of a subset of their reference implementations but, when possible, highly optimized libraries that take advantage of specialized processor functionality are preferred. Examples of such libraries are &lt;a href=&quot;https://www.openblas.net/&quot;&gt;OpenBLAS&lt;/a&gt;, MKL (TM), and ATLAS. Because those libraries are multithreaded and processor dependent, environmental variables and external packages such as &lt;a href=&quot;https://github.com/joblib/threadpoolctl&quot;&gt;threadpoolctl&lt;/a&gt; may be needed to control the number of threads or specify the processor architecture.</source>
          <target state="translated">NumPy線形代数関数は、BLASおよびLAPACKに依存して、標準線形代数アルゴリズムの効率的な低レベル実装を提供します。これらのライブラリは、リファレンス実装のサブセットのCバージョンを使用してNumPy自体によって提供される場合がありますが、可能であれば、専用のプロセッサ機能を利用する高度に最適化されたライブラリが推奨されます。そのようなライブラリーの例は、&lt;a href=&quot;https://www.openblas.net/&quot;&gt;OpenBLAS&lt;/a&gt;、MKL（TM）、およびATLASです。これらのライブラリはマルチスレッドでプロセッサに依存しているため、スレッド数の制御やプロセッサアーキテクチャの指定には、環境変数や&lt;a href=&quot;https://github.com/joblib/threadpoolctl&quot;&gt;threadpoolctl&lt;/a&gt;などの外部パッケージが必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="5abe575872513074969d9820a4d531c3d12a22f7" translate="yes" xml:space="preserve">
          <source>The Pareto distribution must be greater than zero, and is unbounded above. It is also known as the &amp;ldquo;80-20 rule&amp;rdquo;. In this distribution, 80 percent of the weights are in the lowest 20 percent of the range, while the other 20 percent fill the remaining 80 percent of the range.</source>
          <target state="translated">パレート分布はゼロより大きくなければならず、上に制限はありません。 「80-20ルール」としても知られています。この分布では、重みの80％が範囲の最低20％にあり、残りの20％が範囲の残りの80％を占めています。</target>
        </trans-unit>
        <trans-unit id="ed5b998678bc3c838f5d54a5f0beb5816b99470d" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#r8689274e67cd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="translated">イタリアの経済学者Vilfredo Paretoにちなんで名付けられたパレート分布は、多くの現実世界の問題で役立つべき法則確率分布です。経済学の分野以外では、一般にブラッドフォード分布と呼ばれます。パレートは、経済における富の分布を表すために分布を開発しました。また、保険、Webページのアクセス統計、油田のサイズ、およびSourceforgeのプロジェクトのダウンロード頻度など、他の多くの問題にも使用されています&lt;a href=&quot;#r8689274e67cd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。いわゆる「太った」分布の1つです。</target>
        </trans-unit>
        <trans-unit id="2867a07ee69e6406fe64c658305fdda7fb7b8075" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#rc338d9f74bfc-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="translated">イタリアの経済学者Vilfredo Paretoにちなんで名付けられたパレート分布は、多くの現実世界の問題で役立つべき法則確率分布です。経済学の分野以外では、一般にブラッドフォード分布と呼ばれます。パレートは、経済における富の分布を表すために分布を開発しました。また、保険、Webページのアクセス統計、油田のサイズ、およびSourceforgeのプロジェクトのダウンロード頻度など、他の多くの問題にも使用されています&lt;a href=&quot;#rc338d9f74bfc-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。いわゆる「太った」分布の1つです。</target>
        </trans-unit>
        <trans-unit id="8aa87161535a17c7b4517b9679a26277a14402b5" translate="yes" xml:space="preserve">
          <source>The Poisson distribution</source>
          <target state="translated">ポアソン分布</target>
        </trans-unit>
        <trans-unit id="0ebdde94b2528198e1aa6a1394f362ff4a94706c" translate="yes" xml:space="preserve">
          <source>The Poisson distribution is the limit of the binomial distribution for large N.</source>
          <target state="translated">ポアソン分布は、大きなNに対する二項分布の限界です。</target>
        </trans-unit>
        <trans-unit id="9280ad29766a65718d4060a0ccabd4c148a5c905" translate="yes" xml:space="preserve">
          <source>The Polynomial class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Polynomialクラスは、標準のPython数値メソッド「+」、「-」、「*」、「//」、「％」、「divmod」、「**」、および「（）」、および属性と &lt;code&gt;ABCPolyBase&lt;/code&gt; のドキュメントにリストされているメソッド。</target>
        </trans-unit>
        <trans-unit id="827ba55564ba45b324c36aacf3e17c27674e9dcd" translate="yes" xml:space="preserve">
          <source>The PyArrayInterface structure had no descr member at the end (and therefore no flag ARR_HAS_DESCR)</source>
          <target state="translated">PyArrayInterface 構造体の最後には descr メンバがありません (したがって ARR_HAS_DESCR フラグもありません)。</target>
        </trans-unit>
        <trans-unit id="41d158f9c0cb59631db3742cfa40b5047248d25c" translate="yes" xml:space="preserve">
          <source>The PyArrayInterface structure is defined in &lt;code&gt;numpy/ndarrayobject.h&lt;/code&gt; as:</source>
          <target state="translated">PyArrayInterface構造体は、 &lt;code&gt;numpy/ndarrayobject.h&lt;/code&gt; で次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="5f9e4e5af356a67d9cce5fec6bebfc002a3fe5b0" translate="yes" xml:space="preserve">
          <source>The Python exposure supplies two iteration interfaces, one which follows the Python iterator protocol, and another which mirrors the C-style do-while pattern. The native Python approach is better in most cases, but if you need the coordinates or index of an iterator, use the C-style pattern.</source>
          <target state="translated">1つはPythonのイテレータプロトコルに従うもので、もう1つはC-styleのdo-whileパターンをミラーするものです。ほとんどの場合、Pythonのネイティブなアプローチの方が良いでしょうが、イテレータの座標やインデックスが必要な場合はC-styleパターンを使用してください。</target>
        </trans-unit>
        <trans-unit id="52c071d4e6dd56561ca8fc870ab3c5e829454e91" translate="yes" xml:space="preserve">
          <source>The Python function &lt;code&gt;max()&lt;/code&gt; will find the maximum over a one-dimensional array, but it will do so using a slower sequence interface. The reduce method of the maximum ufunc is much faster. Also, the &lt;code&gt;max()&lt;/code&gt; method will not give answers you might expect for arrays with greater than one dimension. The reduce method of minimum also allows you to compute a total minimum over an array.</source>
          <target state="translated">Python関数 &lt;code&gt;max()&lt;/code&gt; は、1次元配列の最大値を検出しますが、より遅いシーケンスインターフェイスを使用して検出します。最大ufuncのreduceメソッドははるかに高速です。また、 &lt;code&gt;max()&lt;/code&gt; メソッドは、1次元を超える配列に対して期待する回答を提供しません。また、reduceメソッドのminimumを使用すると、配列全体の合計最小値を計算することもできます。</target>
        </trans-unit>
        <trans-unit id="faf8bfa039d6b92e8c05db35a7f948162088fe3f" translate="yes" xml:space="preserve">
          <source>The Python interactive interpreter unfortunately prints out the values of expressions inside the while loop during each iteration of the loop. We have modified the output in the examples using this looping construct in order to be more readable.</source>
          <target state="translated">Python の対話型インタプリタは、残念ながらループの各反復中に while ループ内の式の値を出力してしまいます。より読みやすくするために、このループ構造を使用した例の出力を修正しました。</target>
        </trans-unit>
        <trans-unit id="4b9b366242a59401489f5a3a46b627dbab76f505" translate="yes" xml:space="preserve">
          <source>The Python interface that we want is:</source>
          <target state="translated">欲しいのはPythonのインターフェースです。</target>
        </trans-unit>
        <trans-unit id="a4e789fdc99a292c8a541209ecbc17b1d6c5f8c7" translate="yes" xml:space="preserve">
          <source>The Python iterator protocol doesn&amp;rsquo;t have a natural way to query these additional values from the iterator, so we introduce an alternate syntax for iterating with an &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt;. This syntax explicitly works with the iterator object itself, so its properties are readily accessible during iteration. With this looping construct, the current value is accessible by indexing into the iterator, and the index being tracked is the property &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;multi_index&lt;/code&gt; depending on what was requested.</source>
          <target state="translated">Pythonイテレータプロトコルには、イテレータからこれらの追加の値をクエリする自然な方法がないため、&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;で反復するための代替構文を紹介します。この構文はイテレータオブジェクト自体と明示的に連携するため、反復中にそのプロパティに簡単にアクセスできます。このループ構成では、反復子に &lt;code&gt;index&lt;/code&gt; &lt;code&gt;multi_index&lt;/code&gt; ことで現在の値にアクセスでき、追跡されているインデックスは、要求されたものに応じてプロパティインデックスまたはmulti_indexになります。</target>
        </trans-unit>
        <trans-unit id="6867d7144d35416337495ca1b602061770d80f10" translate="yes" xml:space="preserve">
          <source>The Python list representation of the masked array.</source>
          <target state="translated">マスクされた配列のPythonリスト表現。</target>
        </trans-unit>
        <trans-unit id="10730a9ceb03252e7c33bf729de07821aa7c70e5" translate="yes" xml:space="preserve">
          <source>The Python object this chunk of memory comes from. Needed so that memory can be accounted for properly.</source>
          <target state="translated">このメモリのチャンクは Python オブジェクトから来ています。メモリを適切に説明できるようにするために必要です。</target>
        </trans-unit>
        <trans-unit id="8a0585dac865895f74c0e37d281119c6e2073a73" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &amp;ldquo;random&amp;rdquo; also contains a Mersenne Twister pseudo-random number generator with a number of methods that are similar to the ones available in &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="translated">Python stdlibモジュール「random」には、&lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; で&lt;/a&gt;使用可能なものと同様のいくつかのメソッドを備えたMersenne Twister疑似乱数ジェネレーターも含まれています。&lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; は&lt;/a&gt;、NumPy対応であることに加えて、選択できる確率分布の数がはるかに多いという利点があります。</target>
        </trans-unit>
        <trans-unit id="e2bba830daa553cb7faa782d38dcb55b1552bd1f" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &amp;ldquo;random&amp;rdquo; also contains a Mersenne Twister pseudo-random number generator.</source>
          <target state="translated">Python stdlibモジュール「ランダム」には、Mersenne Twister疑似乱数ジェネレータも含まれています。</target>
        </trans-unit>
        <trans-unit id="d16bb9351563ad26c9ac5328e3a25381d78f799b" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; contains pseudo-random number generator with a number of methods that are similar to the ones available in &lt;code&gt;Generator&lt;/code&gt;. It uses Mersenne Twister, and this bit generator can be accessed using &lt;code&gt;MT19937&lt;/code&gt;. &lt;code&gt;Generator&lt;/code&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="translated">Python stdlibモジュール&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; に&lt;/a&gt;は、 &lt;code&gt;Generator&lt;/code&gt; で利用可能なものと同様のいくつかのメソッドを持つ疑似乱数ジェネレータが含まれています。Mersenne Twisterを使用しており、このビットジェネレーターには &lt;code&gt;MT19937&lt;/code&gt; を使用してアクセスできます。 &lt;code&gt;Generator&lt;/code&gt; は、NumPy対応であることに加えて、選択できる確率分布の数がはるかに多いという利点があります。</target>
        </trans-unit>
        <trans-unit id="bbfe8c34ab4f057b17acc33f18a11bfdb2e17b46" translate="yes" xml:space="preserve">
          <source>The Python type of the ndarray is &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;. In C, every ndarray is a pointer to a &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure. The ob_type member of this structure contains a pointer to the &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; typeobject.</source>
          <target state="translated">ndarrayのPythonタイプは&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;です。Cでは、すべてのndarrayは&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;構造体へのポインターです。この構造体のob_typeメンバーには、&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; typeobject へのポインターが含まれています。</target>
        </trans-unit>
        <trans-unit id="92e614f1f8b5e40429cf0717c65db8d5a132db4d" translate="yes" xml:space="preserve">
          <source>The Rayleigh distribution would arise, for example, if the East and North components of the wind velocity had identical zero-mean Gaussian distributions. Then the wind speed would have a Rayleigh distribution.</source>
          <target state="translated">レイリー分布は、例えば、風速の東成分と北成分が同一のゼロ平均ガウス分布を持つ場合に発生します。そうすると、風速はレイリー分布を持つことになります。</target>
        </trans-unit>
        <trans-unit id="0175f443d47358199cf2723ff7e49526482ab828" translate="yes" xml:space="preserve">
          <source>The Simple Wrapper and Interface Generator (or &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;) is a powerful tool for generating wrapper code for interfacing to a wide variety of scripting languages. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; can parse header files, and using only the code prototypes, create an interface to the target language. But &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; is not omnipotent. For example, it cannot know from the prototype:</source>
          <target state="translated">Simple Wrapper and Interface Generator（または&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;）は、さまざまなスクリプト言語とインターフェースするためのラッパーコードを生成するための強力なツールです。&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;はヘッダーファイルを解析でき、コードプロトタイプのみを使用して、ターゲット言語へのインターフェイスを作成します。しかし、&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;は全能ではありません。たとえば、プロトタイプからはわかりません。</target>
        </trans-unit>
        <trans-unit id="3486112e5f71acaa9b7cc7fff52d1dbfa7f50dd3" translate="yes" xml:space="preserve">
          <source>The Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where the last index is the power of &lt;code&gt;x&lt;/code&gt;. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">ヴァンダーモンド行列。返される行列の形状は &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; で、最後のインデックスは &lt;code&gt;x&lt;/code&gt; のべき乗です。dtypeは、変換された &lt;code&gt;x&lt;/code&gt; と同じになります。</target>
        </trans-unit>
        <trans-unit id="39a7c567f58b9f21ca516451a55bb90e053dd395" translate="yes" xml:space="preserve">
          <source>The Weibull (or Type III asymptotic extreme value distribution for smallest values, SEV Type III, or Rosin-Rammler distribution) is one of a class of Generalized Extreme Value (GEV) distributions used in modeling extreme value problems. This class includes the Gumbel and Frechet distributions.</source>
          <target state="translated">ワイブル(または最小値のためのIII型漸近極限値分布、SEV III型、またはRosin-Rammler分布)は、極限値問題のモデル化に使用される一般化極限値(GEV)分布のクラスの1つです。このクラスには、ガンベル分布とフレッシェ分布が含まれます。</target>
        </trans-unit>
        <trans-unit id="201b34b560ffa9f638b13b95cb2b860322d162bb" translate="yes" xml:space="preserve">
          <source>The Zipf distribution (also known as the zeta distribution) is a continuous probability distribution that satisfies Zipf&amp;rsquo;s law: the frequency of an item is inversely proportional to its rank in a frequency table.</source>
          <target state="translated">Zipf分布（ゼータ分布とも呼ばれます）は、Zipfの法則を満たす連続確率分布です。アイテムの頻度は、頻度テーブルのランクに反比例します。</target>
        </trans-unit>
        <trans-unit id="cb048510e93bd94f0172757e215cb9cb29cef573" translate="yes" xml:space="preserve">
          <source>The ability to be used as a context manager is new in NumPy v1.11.0.</source>
          <target state="translated">コンテキストマネージャとして使用できる機能は、NumPy v1.11.0では新しくなりました。</target>
        </trans-unit>
        <trans-unit id="10ff963859461b5262a67238fd0cc7b697172b26" translate="yes" xml:space="preserve">
          <source>The above does not hold for in-place operators, for which &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; never returns &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt;. Hence, &lt;code&gt;arr += obj&lt;/code&gt; would always lead to a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. This is because for arrays in-place operations cannot generically be replaced by a simple reverse operation. (For instance, by default, &lt;code&gt;arr += obj&lt;/code&gt; would be translated to &lt;code&gt;arr =
arr + obj&lt;/code&gt;, i.e., &lt;code&gt;arr&lt;/code&gt; would be replaced, contrary to what is expected for in-place array operations.)</source>
          <target state="translated">上記は、&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;が&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt;を返さないインプレース演算子には当てはまりません。したがって、 &lt;code&gt;arr += obj&lt;/code&gt; は常に&lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; を&lt;/a&gt;引き起こします。これは、配列の場合、インプレース操作を単純な逆操作で一般的に置き換えることはできないためです。（たとえば、デフォルトでは、 &lt;code&gt;arr += obj&lt;/code&gt; は &lt;code&gt;arr = arr + obj&lt;/code&gt; に変換されます。つまり、インプレース配列演算に期待されるものとは逆に、 &lt;code&gt;arr&lt;/code&gt; は置き換えられます。）</target>
        </trans-unit>
        <trans-unit id="68e86910bcee8988f5fee730ecb24162fd22e6a7" translate="yes" xml:space="preserve">
          <source>The above equation is not symmetric in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, so that &lt;code&gt;allclose(a, b)&lt;/code&gt; might be different from &lt;code&gt;allclose(b, a)&lt;/code&gt; in some rare cases.</source>
          <target state="translated">上記の式は &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; で対称ではないため、 &lt;code&gt;allclose(a, b)&lt;/code&gt; が &lt;code&gt;allclose(b, a)&lt;/code&gt; a）と異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="6185045f653324c861d3553f34d55db24911888b" translate="yes" xml:space="preserve">
          <source>The above is &lt;strong&gt;not&lt;/strong&gt; true for advanced indexing.</source>
          <target state="translated">上記は、高度なインデックス作成に&lt;strong&gt;は&lt;/strong&gt;当てはまり&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="21db79b1f2f5936ea0ef3cfbbfc9697c308c56be" translate="yes" xml:space="preserve">
          <source>The above rules may be clearer in the following template source example:</source>
          <target state="translated">以下のテンプレートソースの例では、上記のルールがより明確になっているかもしれません。</target>
        </trans-unit>
        <trans-unit id="bbd30ffed27aefb02b7cc5cbecba164ede0884a8" translate="yes" xml:space="preserve">
          <source>The absolute tolerance parameter (see Notes).</source>
          <target state="translated">絶対許容範囲パラメータ(注記を参照)。</target>
        </trans-unit>
        <trans-unit id="b410151dc56a82d87375b78c87d1aad1438a967a" translate="yes" xml:space="preserve">
          <source>The absolute values of &lt;code&gt;x&lt;/code&gt;, the returned values are always floats. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の絶対値。戻り値は常に浮動小数点です。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="a714cd42c4750db7daf108e375247bf95502ae46" translate="yes" xml:space="preserve">
          <source>The accumulate function is very similar to the reduce function in that the output and the second input both point to the output. The difference is that the second input points to memory one stride behind the current output pointer. Thus, the operation performed is</source>
          <target state="translated">アキュムレート関数は、出力と2番目の入力の両方が出力を指すという点で、リデュース関数と非常に似ています。違いは、2番目の入力が現在の出力ポインタの1ストライド後ろのメモリを指していることです。したがって、実行される操作は</target>
        </trans-unit>
        <trans-unit id="09fde86411dc88385ee0c9001b20e47aa778341c" translate="yes" xml:space="preserve">
          <source>The accumulated values. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">累積値。 &lt;code&gt;out&lt;/code&gt; が指定されている場合、 &lt;code&gt;r&lt;/code&gt; は &lt;code&gt;out&lt;/code&gt; への参照です。</target>
        </trans-unit>
        <trans-unit id="ea47ba00873e187022bea737541efbc8a18ba099" translate="yes" xml:space="preserve">
          <source>The actual object to check.</source>
          <target state="translated">実際にチェックするオブジェクト。</target>
        </trans-unit>
        <trans-unit id="2c2156efeae8cdcc13e079cd68ed8ee62442ae55" translate="yes" xml:space="preserve">
          <source>The actual testing takes place with a Python script named:</source>
          <target state="translated">実際のテストは、Pythonスクリプトという名前で行われます。</target>
        </trans-unit>
        <trans-unit id="e611ef52ce3f87e2cae1cb595f38cf187d2711d5" translate="yes" xml:space="preserve">
          <source>The advanced indexes are all next to each other. For example &lt;code&gt;x[..., arr1, arr2, :]&lt;/code&gt; but &lt;em&gt;not&lt;/em&gt;&lt;code&gt;x[arr1, :, 1]&lt;/code&gt; since &lt;code&gt;1&lt;/code&gt; is an advanced index in this regard.</source>
          <target state="translated">高度なインデックスはすべて互いに隣接しています。たとえば、 &lt;code&gt;x[..., arr1, arr2, :]&lt;/code&gt; が&lt;em&gt;、&lt;/em&gt; &lt;code&gt;x[arr1, :, 1]&lt;/code&gt; はあり&lt;em&gt;ません&lt;/em&gt;。これは、 &lt;code&gt;1&lt;/code&gt; がこの点で高度なインデックスだからです。</target>
        </trans-unit>
        <trans-unit id="31c1e1991e0db334efbc077fcf4425ba78851bf7" translate="yes" xml:space="preserve">
          <source>The advanced indexes are separated by a slice, &lt;code&gt;Ellipsis&lt;/code&gt; or &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt;. For example &lt;code&gt;x[arr1, :, arr2]&lt;/code&gt;.</source>
          <target state="translated">高度なインデックスはスライス、で区切られて &lt;code&gt;Ellipsis&lt;/code&gt; や&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;。たとえば、 &lt;code&gt;x[arr1, :, arr2]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e14666a8704d081387416d669f25517240f5f545" translate="yes" xml:space="preserve">
          <source>The aim of this document is to describe how to add new tools to SciPy.</source>
          <target state="translated">このドキュメントの目的は SciPy に新しいツールを追加する方法を説明することです。</target>
        </trans-unit>
        <trans-unit id="ddbe83e4c507cabc5c6e4f89a6b5af846c612df5" translate="yes" xml:space="preserve">
          <source>The algorithm is carefully designed to eliminate a number of possible ways to collide. For example, if one only does one level of spawning, it is guaranteed that all states will be unique. But it&amp;rsquo;s easier to estimate the naive upper bound on a napkin and take comfort knowing that the probability is actually lower.</source>
          <target state="translated">アルゴリズムは、衝突する可能性のあるいくつかの方法を排除するように慎重に設計されています。たとえば、1レベルのスポーンしか行わない場合、すべての状態が一意になることが保証されます。しかし、ナプキンのナイーブな上限を見積もり、確率が実際には低いことを知って安心する方が簡単です。</target>
        </trans-unit>
        <trans-unit id="31b40688fb93dbcbc32e9b43e4ccf1abfa448a2d" translate="yes" xml:space="preserve">
          <source>The algorithm relies on computing the eigenvalues of the companion matrix &lt;a href=&quot;#r01a8f58ef25b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;.</source>
          <target state="translated">アルゴリズムは、コンパニオン行列&lt;a href=&quot;#r01a8f58ef25b-1&quot; id=&quot;id1&quot;&gt;[1]の&lt;/a&gt;固有値の計算に依存しています。</target>
        </trans-unit>
        <trans-unit id="ddd22305ce6ff69cc69c0e35a34dfdaaddbe6b6d" translate="yes" xml:space="preserve">
          <source>The algorithm works by first finding a &amp;ldquo;running dimension&amp;rdquo;, along which the blocks will be extracted. Given an array of dimensions &lt;code&gt;(d1, d2, ..., dn)&lt;/code&gt;, e.g. if &lt;code&gt;buf_size&lt;/code&gt; is smaller than &lt;code&gt;d1&lt;/code&gt;, the first dimension will be used. If, on the other hand, &lt;code&gt;d1 &amp;lt; buf_size &amp;lt; d1*d2&lt;/code&gt; the second dimension will be used, and so on. Blocks are extracted along this dimension, and when the last block is returned the process continues from the next dimension, until all elements have been read.</source>
          <target state="translated">このアルゴリズムは、最初に「実行中の次元」を見つけることで機能し、それに沿ってブロックが抽出されます。次元の配列 &lt;code&gt;(d1, d2, ..., dn)&lt;/code&gt; 与えられた場合、たとえば、 &lt;code&gt;buf_size&lt;/code&gt; が &lt;code&gt;d1&lt;/code&gt; より小さい場合、最初の次元が使用されます。一方、 &lt;code&gt;d1 &amp;lt; buf_size &amp;lt; d1*d2&lt;/code&gt; 、2番目の次元が使用されます。ブロックはこの次元に沿って抽出され、最後のブロックが返されると、すべての要素が読み取られるまで、プロセスは次の次元から続行されます。</target>
        </trans-unit>
        <trans-unit id="bddd09a9de7b4e7a6ce50c8c2ab936314f5f7ae0" translate="yes" xml:space="preserve">
          <source>The angle of the ray intersecting the unit circle at the given &lt;code&gt;x&lt;/code&gt;-coordinate in radians [0, pi]. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">ラジアン[0、pi]で指定された &lt;code&gt;x&lt;/code&gt; 座標で単位円と交差する光線の角度。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="a13da23a8343744c8c54019aa364c899333968f0" translate="yes" xml:space="preserve">
          <source>The anti-diagonal can be filled by reversing the order of elements using either &lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt;&lt;code&gt;numpy.flipud&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt;&lt;code&gt;numpy.fliplr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">対角線は、&lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt; &lt;code&gt;numpy.flipud&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt; &lt;code&gt;numpy.fliplr&lt;/code&gt; の&lt;/a&gt;いずれかを使用して要素の順序を逆にすることで埋めることができます。</target>
        </trans-unit>
        <trans-unit id="900a13fc7d937db8f345df515885761fbb0acd80" translate="yes" xml:space="preserve">
          <source>The anti-diagonal can be obtained by reversing the order of elements using either &lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt;&lt;code&gt;numpy.flipud&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt;&lt;code&gt;numpy.fliplr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">対角要素は、&lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt; &lt;code&gt;numpy.flipud&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt; &lt;code&gt;numpy.fliplr&lt;/code&gt; &lt;/a&gt;を使用して要素の順序を逆にすることで取得できます。</target>
        </trans-unit>
        <trans-unit id="bdd6673496c6fd17d43bfb63694d67b1a23e7074" translate="yes" xml:space="preserve">
          <source>The approximate decimal resolution of this type, i.e., &lt;code&gt;10**-precision&lt;/code&gt;.</source>
          <target state="translated">このタイプのおおよその10進分解能、つまり &lt;code&gt;10**-precision&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6b2d49779da2fb225e5136c9ad3c68e119d3fee" translate="yes" xml:space="preserve">
          <source>The approximate number of decimal digits to which this kind of float is precise.</source>
          <target state="translated">この種のフロートが正確な小数点以下の桁数の目安。</target>
        </trans-unit>
        <trans-unit id="0fe8c5bbb5b2bd70ddad0ccf0217bddc268f6835" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;ngood&lt;/code&gt; and &lt;code&gt;nbad&lt;/code&gt; each must be less than &lt;code&gt;10**9&lt;/code&gt;. For extremely large arguments, the algorithm that is used to compute the samples &lt;a href=&quot;#r688e4aa3bfc3-4&quot; id=&quot;id1&quot;&gt;[4]&lt;/a&gt; breaks down because of loss of precision in floating point calculations. For such large values, if &lt;code&gt;nsample&lt;/code&gt; is not also large, the distribution can be approximated with the binomial distribution, &lt;code&gt;binomial(n=nsample, p=ngood/(ngood + nbad))&lt;/code&gt;.</source>
          <target state="translated">引数 &lt;code&gt;ngood&lt;/code&gt; と &lt;code&gt;nbad&lt;/code&gt; はそれぞれ &lt;code&gt;10**9&lt;/code&gt; 未満でなければなりません。引数が非常に大きい場合、サンプルの計算に使用されるアルゴリズム&lt;a href=&quot;#r688e4aa3bfc3-4&quot; id=&quot;id1&quot;&gt;[4]&lt;/a&gt;は、浮動小数点計算の精度が失われるために機能しなくなります。このような大きな値の場合、 &lt;code&gt;nsample&lt;/code&gt; も大きくない場合、分布は二項分布 &lt;code&gt;binomial(n=nsample, p=ngood/(ngood + nbad))&lt;/code&gt; で近似できます。</target>
        </trans-unit>
        <trans-unit id="2d355dbffda7b60d25c8fd14c77261de1c537b59" translate="yes" xml:space="preserve">
          <source>The arguments of the &lt;code&gt;configuration&lt;/code&gt; function specify the name of parent SciPy package (&lt;code&gt;parent_package&lt;/code&gt;) and the directory location of the main &lt;code&gt;setup.py&lt;/code&gt; script (&lt;code&gt;top_path&lt;/code&gt;). These arguments, along with the name of the current package, should be passed to the &lt;code&gt;Configuration&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;configuration&lt;/code&gt; 関数の引数は、親SciPyパッケージの名前（ &lt;code&gt;parent_package&lt;/code&gt; ）とメインの &lt;code&gt;setup.py&lt;/code&gt; スクリプトのディレクトリの場所（ &lt;code&gt;top_path&lt;/code&gt; ）を指定します。これらの引数は、現在のパッケージの名前とともに、 &lt;code&gt;Configuration&lt;/code&gt; コンストラクターに渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="9b1212b40ba5f9b8205d7b64e2e9c20d35b415b3" translate="yes" xml:space="preserve">
          <source>The arithmetic mean is the sum of the elements along the axis divided by the number of elements.</source>
          <target state="translated">算術平均は、軸に沿った要素の総和を要素数で割ったものです。</target>
        </trans-unit>
        <trans-unit id="149dc5ada110e245afebc011f82badc7bfaf2c21" translate="yes" xml:space="preserve">
          <source>The arithmetic mean is the sum of the non-NaN elements along the axis divided by the number of non-NaN elements.</source>
          <target state="translated">算術平均は、軸に沿った非NaN要素の合計を非NaN要素の数で割ったものである。</target>
        </trans-unit>
        <trans-unit id="a686d6fd794f1b48b235aeae1a3e22a10c775aa4" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;v&lt;/code&gt; of eigenvectors may not be of maximum rank, that is, some of the columns may be linearly dependent, although round-off error may obscure that fact. If the eigenvalues are all different, then theoretically the eigenvectors are linearly independent. Likewise, the (complex-valued) matrix of eigenvectors &lt;code&gt;v&lt;/code&gt; is unitary if the matrix &lt;code&gt;a&lt;/code&gt; is normal, i.e., if &lt;code&gt;dot(a, a.H) = dot(a.H, a)&lt;/code&gt;, where &lt;code&gt;a.H&lt;/code&gt; denotes the conjugate transpose of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">固有ベクトルの配列 &lt;code&gt;v&lt;/code&gt; は最大ランクではない可能性があります。つまり、丸め誤差によりその事実が不明瞭になる可能性がありますが、一部の列は線形従属である可能性があります。固有値がすべて異なる場合、理論的には固有ベクトルは線形独立です。同様に、固有ベクトル &lt;code&gt;v&lt;/code&gt; の（複素数値）行列は、行列 &lt;code&gt;a&lt;/code&gt; が正規の場合、つまり &lt;code&gt;dot(a, a.H) = dot(a.H, a)&lt;/code&gt; 場合、ユニタリーです。ここで、 &lt;code&gt;a.H&lt;/code&gt; は &lt;code&gt;a&lt;/code&gt; の共役転置を示します。</target>
        </trans-unit>
        <trans-unit id="539630988d5b7ef9eff53456e4a77b468fdbbd35" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;x&lt;/code&gt; is prefilled with its filling value.</source>
          <target state="translated">配列 &lt;code&gt;x&lt;/code&gt; には、その充填値が事前に入力されています。</target>
        </trans-unit>
        <trans-unit id="048ae46227673b90cff5c0388062d4ed48f2b030" translate="yes" xml:space="preserve">
          <source>The array assembled from the given blocks.</source>
          <target state="translated">与えられたブロックから組み立てられた配列。</target>
        </trans-unit>
        <trans-unit id="f6532b7ade94739e158787e37c1d9655afff859b" translate="yes" xml:space="preserve">
          <source>The array can be indexed using Python container-like syntax:</source>
          <target state="translated">配列は、Pythonのコンテナのような構文を使ってインデックスを作成することができます。</target>
        </trans-unit>
        <trans-unit id="a7b308d78b11f2c07c75c1db0756393dc3ae53a1" translate="yes" xml:space="preserve">
          <source>The array data-type or scalar for which the default fill value is returned.</source>
          <target state="translated">デフォルトの塗りつぶし値が返される配列のデータ型またはスカラ。</target>
        </trans-unit>
        <trans-unit id="3821c84ea0df179e936beb82ec9c4a845023032b" translate="yes" xml:space="preserve">
          <source>The array element of the current iteration.</source>
          <target state="translated">現在の反復の配列要素。</target>
        </trans-unit>
        <trans-unit id="930ed301b34bfc297be655fe9a537d3e2971d137" translate="yes" xml:space="preserve">
          <source>The array flags cannot be set arbitrarily:</source>
          <target state="translated">配列フラグを任意に設定することはできません。</target>
        </trans-unit>
        <trans-unit id="67bdbd5d8bcbe5caab95cc4d4f8dabba43280775" translate="yes" xml:space="preserve">
          <source>The array for which the string representation of the pickle is returned.</source>
          <target state="translated">ピクルスの文字列表現が返される配列。</target>
        </trans-unit>
        <trans-unit id="2a33c6111cdd8f36d42a5e94437f624d1b58746f" translate="yes" xml:space="preserve">
          <source>The array for which to count non-zeros.</source>
          <target state="translated">ゼロ以外の値をカウントする配列。</target>
        </trans-unit>
        <trans-unit id="ceccbd318dae2746e4f8b98dac923588a6a52441" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays, will be at least 2-D.</source>
          <target state="translated">与えられた配列を積み重ねて形成される配列は、少なくとも2次元となる。</target>
        </trans-unit>
        <trans-unit id="2568bf2e437e715b60f945dc9695881ce8ef667f" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays, will be at least 3-D.</source>
          <target state="translated">与えられた配列を積み重ねて形成された配列は、少なくとも3次元となる。</target>
        </trans-unit>
        <trans-unit id="b2c061ec289a87d3c0d4e9e7c64e5126014d42ed" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays.</source>
          <target state="translated">与えられた配列を積み重ねて形成される配列。</target>
        </trans-unit>
        <trans-unit id="8e505b1ebbfcf9d9aa6a8f699f88f4ba40304f40" translate="yes" xml:space="preserve">
          <source>The array from which values are copied.</source>
          <target state="translated">値がコピーされる配列。</target>
        </trans-unit>
        <trans-unit id="7c8fb39bbbe950fa5ba32f6dec4764ff1752adf1" translate="yes" xml:space="preserve">
          <source>The array h contains the Householder reflectors that generate q along with r. The tau array contains scaling factors for the reflectors. In the deprecated &amp;lsquo;economic&amp;rsquo; mode only h is returned.</source>
          <target state="translated">配列hには、rとともにqを生成するハウスホルダーリフレクターが含まれています。タウ配列には、リフレクターのスケーリング係数が含まれています。非推奨の「経済的」モードでは、hのみが返されます。</target>
        </trans-unit>
        <trans-unit id="d2932d4203636051c0cde3cab914ac5caf308f90" translate="yes" xml:space="preserve">
          <source>The array interface (sometimes called array protocol) was created in 2005 as a means for array-like Python objects to re-use each other&amp;rsquo;s data buffers intelligently whenever possible. The homogeneous N-dimensional array interface is a default mechanism for objects to share N-dimensional array memory and information. The interface consists of a Python-side and a C-side using two attributes. Objects wishing to be considered an N-dimensional array in application code should support at least one of these attributes. Objects wishing to support an N-dimensional array in application code should look for at least one of these attributes and use the information provided appropriately.</source>
          <target state="translated">配列インターフェイス（配列プロトコルとも呼ばれる）は、配列のようなPythonオブジェクトが互いのデータバッファーを可能な限りインテリジェントに再利用するための手段として2005年に作成されました。同種のN次元配列インターフェースは、オブジェクトがN次元配列のメモリと情報を共有するためのデフォルトのメカニズムです。インターフェースは、2つの属性を使用するPython側とC側で構成されます。アプリケーションコードでN次元配列と見なされるオブジェクトは、これらの属性の少なくとも1つをサポートする必要があります。アプリケーションコードでN次元配列をサポートするオブジェクトは、これらの属性の少なくとも1つを探し、適切に提供された情報を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="3b7adbdac3eaf5c6305f1f61b91018f4287bec67" translate="yes" xml:space="preserve">
          <source>The array into which values are copied.</source>
          <target state="translated">値がコピーされる配列。</target>
        </trans-unit>
        <trans-unit id="8a281d694c98742955f6444ee26a08d74603ea7a" translate="yes" xml:space="preserve">
          <source>The array is filled with a fill value before the string conversion.</source>
          <target state="translated">配列は文字列変換前のフィル値で埋められています。</target>
        </trans-unit>
        <trans-unit id="fba8708c42061e69f757d72f0e5d1d004653f4bc" translate="yes" xml:space="preserve">
          <source>The array is rotated in the plane defined by the axes. Axes must be different.</source>
          <target state="translated">配列は軸で定義された平面内で回転します。軸は異なるものでなければなりません。</target>
        </trans-unit>
        <trans-unit id="9a1223a8243cbae9aaa7753c7ea500a550cf52c0" translate="yes" xml:space="preserve">
          <source>The array iterator encapsulates many of the key features in ufuncs, allowing user code to support features like output parameters, preservation of memory layouts, and buffering of data with the wrong alignment or type, without requiring difficult coding.</source>
          <target state="translated">配列イテレータは ufuncs の主要な機能の多くをカプセル化しており、ユーザーコードは難しいコーディングを必要とせずに、出力パラメータ、メモリレイアウトの保存、間違ったアライメントや型のデータのバッファリングなどの機能をサポートすることができます。</target>
        </trans-unit>
        <trans-unit id="c6e1241b8c7d132ea91621f870c2bd3aaf572b4c" translate="yes" xml:space="preserve">
          <source>The array may be recreated via &lt;code&gt;a = np.array(a.tolist())&lt;/code&gt;, although this may sometimes lose precision.</source>
          <target state="translated">配列は &lt;code&gt;a = np.array(a.tolist())&lt;/code&gt; して再作成できますが、精度が低下する場合があります。</target>
        </trans-unit>
        <trans-unit id="1eee9d9d69514705c81523ac5b902691363a28a0" translate="yes" xml:space="preserve">
          <source>The array of UTC timestamps to format.</source>
          <target state="translated">フォーマットする UTC タイムスタンプの配列。</target>
        </trans-unit>
        <trans-unit id="c75d57d539a00e02934380f0ab251d1c277b5e1c" translate="yes" xml:space="preserve">
          <source>The array of dates to process.</source>
          <target state="translated">処理する日付の配列。</target>
        </trans-unit>
        <trans-unit id="cc2f192e213603a4bcf402844b3339c10f79380e" translate="yes" xml:space="preserve">
          <source>The array of numbers for which the absolute values are required. If &lt;code&gt;x&lt;/code&gt; is a scalar, the result &lt;code&gt;y&lt;/code&gt; will also be a scalar.</source>
          <target state="translated">絶対値が必要な数値の配列。場合 &lt;code&gt;x&lt;/code&gt; はスカラーであり、結果 &lt;code&gt;y&lt;/code&gt; はまたスカラーであろう。</target>
        </trans-unit>
        <trans-unit id="f9c4960d6bbbc8f2591cc039cfe68db4d8e24d90" translate="yes" xml:space="preserve">
          <source>The array of offsets, which is broadcast with &lt;code&gt;dates&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dates&lt;/code&gt; とともにブロードキャストされるオフセットの配列。</target>
        </trans-unit>
        <trans-unit id="2d674fe1383c12f697c52fd3b5198eb57b81bcb7" translate="yes" xml:space="preserve">
          <source>The array of rounded numbers</source>
          <target state="translated">丸められた数字の配列</target>
        </trans-unit>
        <trans-unit id="202adb7679573040b63e561db69df0e93b9eb75e" translate="yes" xml:space="preserve">
          <source>The array of the end dates for counting, which are excluded from the count themselves.</source>
          <target state="translated">カウントの終了日の配列で、カウント自体から除外されます。</target>
        </trans-unit>
        <trans-unit id="f508cbbca81c78d6c3819b4c01ca29622bef56f6" translate="yes" xml:space="preserve">
          <source>The array of the first dates for counting.</source>
          <target state="translated">カウントする最初の日付の配列。</target>
        </trans-unit>
        <trans-unit id="a4e03a6eeebaef72c6a7e32f280b123bbf142ff2" translate="yes" xml:space="preserve">
          <source>The array or list to be shuffled.</source>
          <target state="translated">シャッフルされる配列またはリスト.</target>
        </trans-unit>
        <trans-unit id="1f6abc9406bedaa275a3843a6290b585462b97a3" translate="yes" xml:space="preserve">
          <source>The array or matrix to be repeated.</source>
          <target state="translated">繰り返し行われる配列または行列.</target>
        </trans-unit>
        <trans-unit id="53aead7fb32cb3de7311369b48d13d4953d0adc5" translate="yes" xml:space="preserve">
          <source>The array owns the memory it uses or borrows it from another object.</source>
          <target state="translated">配列は、使用するメモリを所有したり、別のオブジェクトから借りたりします。</target>
        </trans-unit>
        <trans-unit id="8abf01fdd64396d234195c26c60e850e4a12a8d7" translate="yes" xml:space="preserve">
          <source>The array scalar objects have an &lt;code&gt;array priority&lt;/code&gt; of &lt;a href=&quot;c-api.array#c.NPY_SCALAR_PRIORITY&quot;&gt;&lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt;&lt;/a&gt; (-1,000,000.0). They also do not (yet) have a &lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; attribute. Otherwise, they share the same attributes as arrays:</source>
          <target state="translated">配列スカラーオブジェクトの &lt;code&gt;array priority&lt;/code&gt; は&lt;a href=&quot;c-api.array#c.NPY_SCALAR_PRIORITY&quot;&gt; &lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt; &lt;/a&gt;（-1,000,000.0）です。また、（まだ）&lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt;属性も持っていません。それ以外の場合は、配列と同じ属性を共有します。</target>
        </trans-unit>
        <trans-unit id="8c0162c81e2783b3bcbb0dd799de5c3ba91aba6a" translate="yes" xml:space="preserve">
          <source>The array scalars also offer the same methods and attributes as arrays with the intent that the same code can be used to support arbitrary dimensions (including 0-dimensions). The array scalars are read-only (immutable) with the exception of the void scalar which can also be written to so that structured array field setting works more naturally (a[0][&amp;lsquo;f1&amp;rsquo;] = &lt;code&gt;value&lt;/code&gt; ).</source>
          <target state="translated">配列スカラーは、同じコードを使用して任意の次元（0次元を含む）をサポートできるという意図で、配列と同じメソッドと属性も提供します。配列スカラーは読み取り専用（不変）ですが、構造化配列フィールドの設定がより自然に機能するように書き込むことができるvoidスカラーは例外です（a [0] ['f1'] = &lt;code&gt;value&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d0afa5fdfdf427a8322c75c5712091eca91eabac" translate="yes" xml:space="preserve">
          <source>The array scalars offer a hierarchy of Python types that allow a one- to-one correspondence between the data-type stored in an array and the Python-type that is returned when an element is extracted from the array. An exception to this rule was made with object arrays. Object arrays are heterogeneous collections of arbitrary Python objects. When you select an item from an object array, you get back the original Python object (and not an object array scalar which does exist but is rarely used for practical purposes).</source>
          <target state="translated">配列スカラは、配列に格納されているデータ型と、配列から要素が抽出されたときに返されるPython型との間で1対1の対応を可能にするPython型の階層を提供します。このルールの例外がオブジェクト配列で作られました。オブジェクト配列は任意のPythonオブジェクトの異種コレクションです。オブジェクト配列からアイテムを選択すると、元のPythonオブジェクトが返されます(オブジェクト配列のスカラーではなく、オブジェクト配列のスカラーが存在しますが、実用的な目的ではほとんど使われません)。</target>
        </trans-unit>
        <trans-unit id="4e947f26c0ecf6d9ff639e9f27b5b5f852135d7e" translate="yes" xml:space="preserve">
          <source>The array to act on.</source>
          <target state="translated">操作する配列。</target>
        </trans-unit>
        <trans-unit id="7000ca786d20479930ea43aa17e050c42578abc2" translate="yes" xml:space="preserve">
          <source>The array to be pickled.</source>
          <target state="translated">漬け込む配列。</target>
        </trans-unit>
        <trans-unit id="25694c63a056a35911c5654e87ce1708648d0cd3" translate="yes" xml:space="preserve">
          <source>The array to broadcast.</source>
          <target state="translated">放送するための配列。</target>
        </trans-unit>
        <trans-unit id="61fa35e69f8b8bb03ffef7462ad7cef9c9cdddeb" translate="yes" xml:space="preserve">
          <source>The array to mask. If not a MaskedArray instance (or if no array elements are masked). The result is a MaskedArray with &lt;code&gt;mask&lt;/code&gt; set to &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; (False). Must be a 2D array.</source>
          <target state="translated">マスクする配列。MaskedArrayインスタンスでない場合（または配列要素がマスクされていない場合）。結果は、 &lt;code&gt;mask&lt;/code&gt; が&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;（False）に設定されたMaskedArrayです。2D配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="9a0afda668850edc1a593d4069db9a58418e2d74" translate="yes" xml:space="preserve">
          <source>The array to operate on. If not a MaskedArray instance (or if no array elements are masked), &lt;code&gt;x&lt;/code&gt; is interpreted as a MaskedArray with &lt;code&gt;mask&lt;/code&gt; set to &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;. Must be a 2D array.</source>
          <target state="translated">操作するアレイ。MaskedArrayインスタンスでない場合（または配列要素がマスクされていない場合）、 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;mask&lt;/code&gt; が&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; に&lt;/a&gt;設定されたMaskedArrayとして解釈されます。2D配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="da7df7a6420823a6b7e45bca218ba68631febc25" translate="yes" xml:space="preserve">
          <source>The array to pad.</source>
          <target state="translated">パッドにする配列。</target>
        </trans-unit>
        <trans-unit id="8966af5b1934b124717f0c80ec9988807e784cf9" translate="yes" xml:space="preserve">
          <source>The array to perform in place operation on.</source>
          <target state="translated">その場で操作を行う配列。</target>
        </trans-unit>
        <trans-unit id="1a2586a66b67a305c2797e7e06685302608f4ea4" translate="yes" xml:space="preserve">
          <source>The array whose axes should be reordered.</source>
          <target state="translated">軸の並び替えが必要な配列。</target>
        </trans-unit>
        <trans-unit id="81f5ca8ebafc1afb8a9d51589c5e138b4b807e19" translate="yes" xml:space="preserve">
          <source>The array(s) to be iterated over. Valid only before the iterator is closed.</source>
          <target state="translated">イテレータが終了する前にのみ有効です。イテレータが閉じられる前にのみ有効です。</target>
        </trans-unit>
        <trans-unit id="8c52ea12181e4277b350926a7c51f79608004cd5" translate="yes" xml:space="preserve">
          <source>The array(s) to iterate over.</source>
          <target state="translated">反復処理を行う配列.</target>
        </trans-unit>
        <trans-unit id="ae34a0f5008cfcf7a204a6ae1b41350a0a8ffea9" translate="yes" xml:space="preserve">
          <source>The array-protocol typestring of this data-type object.</source>
          <target state="translated">このデータ型オブジェクトの配列プロトコル型文字列。</target>
        </trans-unit>
        <trans-unit id="342be16484b97c95949f88958c455899735a9596" translate="yes" xml:space="preserve">
          <source>The arrays all have exactly the same shape.</source>
          <target state="translated">配列はすべて全く同じ形をしています。</target>
        </trans-unit>
        <trans-unit id="d48d7d91bb3512b8a648b512669295a09d607ddf" translate="yes" xml:space="preserve">
          <source>The arrays all have the same number of dimensions and the length of each dimensions is either a common length or 1.</source>
          <target state="translated">配列はすべて同じ数の次元を持ち、各次元の長さは共通の長さか1である。</target>
        </trans-unit>
        <trans-unit id="3b32b95e95ce590daa0a88406a7282f0b6f9ae1f" translate="yes" xml:space="preserve">
          <source>The arrays holding the elements to be compared. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">比較する要素を保持する配列。 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状にブロードキャスト可能でなければなりません（これが出力の形状になります）。</target>
        </trans-unit>
        <trans-unit id="b72974524c2659f265dc742386bd383e243bc4a6" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the first axis. 1-D arrays must have the same length.</source>
          <target state="translated">配列は,第1軸以外のすべての軸に沿って同じ形状でなければなりません.1次元配列は,同じ長さでなければなりません.</target>
        </trans-unit>
        <trans-unit id="9548b85aa3e636c88bbbc65cfcdf4e6b5fff4585" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the second axis, except 1-D arrays which can be any length.</source>
          <target state="translated">配列は,任意の長さの1次元配列を除いて,第2軸以外のすべての軸に沿って同じ形状でなければなりません.</target>
        </trans-unit>
        <trans-unit id="34736140b85990281116cda8321b303d602cfb2e" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the third axis. 1-D or 2-D arrays must have the same shape.</source>
          <target state="translated">配列は,3 番目の軸以外のすべての軸に沿って同じ形をしていなければなりません.1次元または2次元の配列は,同じ形状でなければなりません.</target>
        </trans-unit>
        <trans-unit id="250d7318b7910004f5ade9c6bf7fa2a62b2d0aa6" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape, except in the dimension corresponding to &lt;code&gt;axis&lt;/code&gt; (the first, by default).</source>
          <target state="translated">配列は、 &lt;code&gt;axis&lt;/code&gt; 対応する次元（デフォルトでは最初）を除いて、同じ形状でなければなりません。</target>
        </trans-unit>
        <trans-unit id="3650412314ab8d0d6cc595877979b22653a06cac" translate="yes" xml:space="preserve">
          <source>The arrays that have too few dimensions can have their shapes prepended with a dimension of length 1 to satisfy property 2.</source>
          <target state="translated">次元が少なすぎる配列は,特性2を満たすために,その形状の前に長さ1の次元を付加することができます.</target>
        </trans-unit>
        <trans-unit id="3c7fb6624c1c578e967064538473cd4324bc56b1" translate="yes" xml:space="preserve">
          <source>The arrays to be added. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">追加する配列。 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状にブロードキャスト可能でなければなりません（これが出力の形状になります）。</target>
        </trans-unit>
        <trans-unit id="61831d63f8eb03ec54ea81f37b4edf92245e6861" translate="yes" xml:space="preserve">
          <source>The arrays to be subtracted from each other. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">互いに減算される配列。 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状にブロードキャスト可能でなければなりません（これが出力の形状になります）。</target>
        </trans-unit>
        <trans-unit id="b989bf28be4c34813d52a00110756329cfab3199" translate="yes" xml:space="preserve">
          <source>The arrays to broadcast.</source>
          <target state="translated">放送する配列。</target>
        </trans-unit>
        <trans-unit id="4bc127992ac15b346e5ebc50b22b2084cc253474" translate="yes" xml:space="preserve">
          <source>The available functions are defined in &amp;lt;numpy/npy_math.h&amp;gt; - please refer to this header when in doubt.</source>
          <target state="translated">利用可能な関数は&amp;lt;numpy / npy_math.h&amp;gt;で定義されています-不明な場合はこのヘッダーを参照してください。</target>
        </trans-unit>
        <trans-unit id="4c1200844d5256d1bf5c45cf0a767eb7723d9e5e" translate="yes" xml:space="preserve">
          <source>The average along the specified axis. When returned is &lt;code&gt;True&lt;/code&gt;, return a tuple with the average as the first element and the sum of the weights as the second element. The return type is &lt;code&gt;np.float64&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is of integer type and floats smaller than &lt;code&gt;float64&lt;/code&gt;, or the input data-type, otherwise. If returned, &lt;code&gt;sum_of_weights&lt;/code&gt; is always &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">指定された軸に沿った平均。 &lt;code&gt;True&lt;/code&gt; の場合、最初の要素として平均を、2番目の要素として重みの合計を含むタプルを返します。 &lt;code&gt;a&lt;/code&gt; が整数型で &lt;code&gt;float64&lt;/code&gt; より小さい浮動小数点数の場合、戻り値の型は &lt;code&gt;np.float64&lt;/code&gt; です。それ以外の場合は、入力データ型です。返される場合、 &lt;code&gt;sum_of_weights&lt;/code&gt; は常に &lt;code&gt;float64&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="542875b084a7c351a7a1f8a6d2d600675ca4d2a7" translate="yes" xml:space="preserve">
          <source>The average squared deviation is normally calculated as &lt;code&gt;x.sum() / N&lt;/code&gt;, where &lt;code&gt;N = len(x)&lt;/code&gt;. If, however, &lt;code&gt;ddof&lt;/code&gt; is specified, the divisor &lt;code&gt;N - ddof&lt;/code&gt; is used instead. In standard statistical practice, &lt;code&gt;ddof=1&lt;/code&gt; provides an unbiased estimator of the variance of the infinite population. &lt;code&gt;ddof=0&lt;/code&gt; provides a maximum likelihood estimate of the variance for normally distributed variables. The standard deviation computed in this function is the square root of the estimated variance, so even with &lt;code&gt;ddof=1&lt;/code&gt;, it will not be an unbiased estimate of the standard deviation per se.</source>
          <target state="translated">通常、平均二乗偏差は &lt;code&gt;x.sum() / N&lt;/code&gt; として計算されます。ここで、 &lt;code&gt;N = len(x)&lt;/code&gt; です。ただし、 &lt;code&gt;ddof&lt;/code&gt; が指定されている場合は、除数 &lt;code&gt;N - ddof&lt;/code&gt; が代わりに使用されます。標準的な統計手法では、 &lt;code&gt;ddof=1&lt;/code&gt; は、無限母集団の分散の不偏推定量を提供します。 &lt;code&gt;ddof=0&lt;/code&gt; は、正規分布変数の分散の最尤推定を提供します。この関数で計算される標準偏差は、推定された分散の平方根であるため、 &lt;code&gt;ddof=1&lt;/code&gt; を使用しても、標準偏差自体の公平な推定にはなりません。</target>
        </trans-unit>
        <trans-unit id="21ebdcee890d352b954472165e15ea262b078aa8" translate="yes" xml:space="preserve">
          <source>The axes over which to compute the inverse fft. Default is the last two axes.</source>
          <target state="translated">逆ftを計算する軸。デフォルトは最後の2軸です。</target>
        </trans-unit>
        <trans-unit id="3f6da36d69c95a72b5592c0677dd407fdc9cfa2c" translate="yes" xml:space="preserve">
          <source>The axis along which &lt;code&gt;v&lt;/code&gt; are appended. If &lt;code&gt;axis&lt;/code&gt; is not given, both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are flattened before use.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; が追加される軸。場合は &lt;code&gt;axis&lt;/code&gt; 与えられていない、両方の &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; 使用前に平坦化されています。</target>
        </trans-unit>
        <trans-unit id="071585631d8d75cc42162ae0da0a1b91474572d1" translate="yes" xml:space="preserve">
          <source>The axis along which &lt;code&gt;values&lt;/code&gt; are appended. If &lt;code&gt;axis&lt;/code&gt; is not given, both &lt;code&gt;arr&lt;/code&gt; and &lt;code&gt;values&lt;/code&gt; are flattened before use.</source>
          <target state="translated">&lt;code&gt;values&lt;/code&gt; が追加される軸。 &lt;code&gt;axis&lt;/code&gt; が指定されていない場合、 &lt;code&gt;arr&lt;/code&gt; と &lt;code&gt;values&lt;/code&gt; 両方が使用前にフラット化されます。</target>
        </trans-unit>
        <trans-unit id="d25eb0541fd006d52dcbebc548c80309c583cc52" translate="yes" xml:space="preserve">
          <source>The axis along which the arrays will be joined. Default is 0.</source>
          <target state="translated">配列が結合される軸。デフォルトは0です。</target>
        </trans-unit>
        <trans-unit id="ab324f8b42b072f0ce80303066858390de817e59" translate="yes" xml:space="preserve">
          <source>The axis along which the arrays will be joined. If axis is None, arrays are flattened before use. Default is 0.</source>
          <target state="translated">配列を結合する軸。axis が None の場合、配列は使用前に平坦化されます。デフォルトは0です。</target>
        </trans-unit>
        <trans-unit id="b85856e591095eebb92c2f542dccaa68776b00c8" translate="yes" xml:space="preserve">
          <source>The axis along which the difference is taken, default is the last axis.</source>
          <target state="translated">デフォルトは最後の軸です。</target>
        </trans-unit>
        <trans-unit id="848f8430ea7a17384babb0b6d388a2e2e8bda711" translate="yes" xml:space="preserve">
          <source>The axis along which the selection is performed. The default, 0, selects by row.</source>
          <target state="translated">選択が実行される軸。デフォルトの 0 は、行単位で選択します。</target>
        </trans-unit>
        <trans-unit id="db9105950615faa8709d8dba888767b4f466811c" translate="yes" xml:space="preserve">
          <source>The axis along which to apply the accumulation; default is zero.</source>
          <target state="translated">累積を適用する軸。</target>
        </trans-unit>
        <trans-unit id="b45496da67ff059714d0b1ae6911029e831dd2fd" translate="yes" xml:space="preserve">
          <source>The axis along which to apply the reduceat.</source>
          <target state="translated">リダクションを適用する軸。</target>
        </trans-unit>
        <trans-unit id="ef9dbd3a8e7509325fd10ad7183022f46facda83" translate="yes" xml:space="preserve">
          <source>The axis along which to delete the subarray defined by &lt;code&gt;obj&lt;/code&gt;. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;obj&lt;/code&gt; is applied to the flattened array.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; で定義された部分配列を削除する軸。 &lt;code&gt;axis&lt;/code&gt; がNoneの場合、 &lt;code&gt;obj&lt;/code&gt; はフラット化された配列に適用されます。</target>
        </trans-unit>
        <trans-unit id="5932d4cf836b6b58485bd9f15e2f20474363c36f" translate="yes" xml:space="preserve">
          <source>The axis along which to integrate.</source>
          <target state="translated">積分する軸。</target>
        </trans-unit>
        <trans-unit id="0011917dec1b66b996673fed4476058c1c23ee6e" translate="yes" xml:space="preserve">
          <source>The axis along which to repeat values. By default, use the flattened input array, and return a flat output array.</source>
          <target state="translated">値を繰り返す軸。デフォルトでは、平坦化された入力配列を使用し、平坦な出力配列を返します。</target>
        </trans-unit>
        <trans-unit id="407371d3199afc3105f3e75619a63b4981063028" translate="yes" xml:space="preserve">
          <source>The axis along which to split, default is 0.</source>
          <target state="translated">分割する軸、デフォルトは0です。</target>
        </trans-unit>
        <trans-unit id="40f4cb16df8166b16f689cc3f6a27ceb034ca2a8" translate="yes" xml:space="preserve">
          <source>The axis currently being calculated.</source>
          <target state="translated">現在計算中の軸。</target>
        </trans-unit>
        <trans-unit id="779396c94c96c008627d39cce908fca96b699246" translate="yes" xml:space="preserve">
          <source>The axis in the result array along which the input arrays are stacked.</source>
          <target state="translated">入力配列がスタックされる結果配列の軸.</target>
        </trans-unit>
        <trans-unit id="f53c3f1c70993fc128dae4ee501fb80cbace06f6" translate="yes" xml:space="preserve">
          <source>The axis in the result to store the samples. Relevant only if start or stop are array-like. By default (0), the samples will be along a new axis inserted at the beginning. Use -1 to get an axis at the end.</source>
          <target state="translated">サンプルを格納する結果の軸。start または stop が配列のようになっている場合にのみ関係します。デフォルト(0)では、サンプルは最初に挿入された新しい軸に沿って配置されます。最後に軸を取得するには -1 を使用します。</target>
        </trans-unit>
        <trans-unit id="5d9b30084a3b37c792a839c94c54a5cdb7a8cfce" translate="yes" xml:space="preserve">
          <source>The axis is rolled until it lies before this position. The default, 0, results in a &amp;ldquo;complete&amp;rdquo; roll.</source>
          <target state="translated">軸は、この位置の前にくるまでロールされます。デフォルトの0は、「完全な」ロールになります。</target>
        </trans-unit>
        <trans-unit id="bb67daef266f9ea49c20107e1bf4911d74a22608" translate="yes" xml:space="preserve">
          <source>The axis over which to select values. By default, the flattened input array is used.</source>
          <target state="translated">値を選択する軸。デフォルトでは、平坦化された入力配列が使用されます。</target>
        </trans-unit>
        <trans-unit id="d0edfc48d57e03c356c790b28b9213c10fc98a8b" translate="yes" xml:space="preserve">
          <source>The axis to operate on. If None, &lt;code&gt;ar&lt;/code&gt; will be flattened. If an integer, the subarrays indexed by the given axis will be flattened and treated as the elements of a 1-D array with the dimension of the given axis, see the notes for more details. Object arrays or structured arrays that contain objects are not supported if the &lt;code&gt;axis&lt;/code&gt; kwarg is used. The default is None.</source>
          <target state="translated">操作する軸。Noneの場合、 &lt;code&gt;ar&lt;/code&gt; はフラット化されます。整数の場合、指定された軸によってインデックスが付けられたサブ配列は平坦化され、指定された軸の次元を持つ1次元配列の要素として扱われます。詳細については、注を参照してください。 &lt;code&gt;axis&lt;/code&gt; kwargが使用されている場合、オブジェクト配列またはオブジェクトを含む構造化配列はサポートされません。デフォルトは「なし」です。</target>
        </trans-unit>
        <trans-unit id="b9493a9f29cafe569828c852de6864aa7f5d0ff6" translate="yes" xml:space="preserve">
          <source>The axis to roll backwards. The positions of the other axes do not change relative to one another.</source>
          <target state="translated">逆転させる軸。他の軸の位置は互いに相対的に変化しない。</target>
        </trans-unit>
        <trans-unit id="340d3fc196833339a77972eea60efcdfd52ba73c" translate="yes" xml:space="preserve">
          <source>The axis to take 1d slices along. If axis is None, the destination array is treated as if a flattened 1d view had been created of it.</source>
          <target state="translated">1 次元のスライスを取る軸。axis が None の場合,出力配列は,平坦化された 1 次元ビューが作成されたかのように扱われます.</target>
        </trans-unit>
        <trans-unit id="a049beb1044c250e5951941014a3acba639cb49d" translate="yes" xml:space="preserve">
          <source>The axis to take 1d slices along. If axis is None, the input array is treated as if it had first been flattened to 1d, for consistency with &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1dスライスをとる軸。axisがNoneの場合、入力配列は、最初に1dにフラット化されたかのように扱われ、&lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt;との一貫性が保たれます。</target>
        </trans-unit>
        <trans-unit id="98787e1071b5327d0b2e07537c81bb27588db08e" translate="yes" xml:space="preserve">
          <source>The base case for this recursion is a 0D array:</source>
          <target state="translated">この再帰のベースケースは0次元配列です。</target>
        </trans-unit>
        <trans-unit id="88d21dfd4e25736b7184078ba7f33b64bea753e0" translate="yes" xml:space="preserve">
          <source>The base of an array that owns its memory is None:</source>
          <target state="translated">メモリを所有する配列の基底は None です。</target>
        </trans-unit>
        <trans-unit id="074b16b582d8ec2099beaee8dcbc987839646a35" translate="yes" xml:space="preserve">
          <source>The base of the log space. The step size between the elements in &lt;code&gt;ln(samples) / ln(base)&lt;/code&gt; (or &lt;code&gt;log_base(samples)&lt;/code&gt;) is uniform. Default is 10.0.</source>
          <target state="translated">ログスペースのベース。 &lt;code&gt;ln(samples) / ln(base)&lt;/code&gt; （または &lt;code&gt;log_base(samples)&lt;/code&gt; ）の要素間のステップサイズは均一です。デフォルトは10.0です。</target>
        </trans-unit>
        <trans-unit id="535897fba7f592c8b7dd04c68596d9a31edf2e11" translate="yes" xml:space="preserve">
          <source>The bases in &lt;code&gt;x1&lt;/code&gt; raised to the exponents in &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; の底は &lt;code&gt;x2&lt;/code&gt; の指数に累乗されます。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="707f28b031c35e2bf30d29bbd42946a1e8c7dc8c" translate="yes" xml:space="preserve">
          <source>The bases.</source>
          <target state="translated">基地です。</target>
        </trans-unit>
        <trans-unit id="5bc92f7e413935d311df16000ae397f9e815d85b" translate="yes" xml:space="preserve">
          <source>The basic data element&amp;rsquo;s size in bytes</source>
          <target state="translated">基本データ要素のサイズ（バイト単位）</target>
        </trans-unit>
        <trans-unit id="68fe9eda4da762f1f4d04299c59c07412dcd5a69" translate="yes" xml:space="preserve">
          <source>The basic slice syntax is &lt;code&gt;i:j:k&lt;/code&gt; where &lt;em&gt;i&lt;/em&gt; is the starting index, &lt;em&gt;j&lt;/em&gt; is the stopping index, and &lt;em&gt;k&lt;/em&gt; is the step (</source>
          <target state="translated">基本的なスライス構文は &lt;code&gt;i:j:k&lt;/code&gt; です。ここで、&lt;em&gt;i&lt;/em&gt;は開始インデックス、&lt;em&gt;j&lt;/em&gt;は停止インデックス、&lt;em&gt;k&lt;/em&gt;はステップ（</target>
        </trans-unit>
        <trans-unit id="aeeddb45e8f2002e147b881df220bd44abec802b" translate="yes" xml:space="preserve">
          <source>The basic type character codes are:</source>
          <target state="translated">基本的なタイプの文字コードは</target>
        </trans-unit>
        <trans-unit id="94f38793f86bdba698e5ca03402c847550f50738" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is a Chebyshev basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">基底多項式は、 &lt;code&gt;c&lt;/code&gt; がチェビシェフ基底多項式であるときにコンパニオン行列が対称になるようにスケーリングされます。これは、スケーリングされていない場合よりも優れた固有値推定を提供します。基底多項式の場合、&lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt;を使用してそれらを取得すると、固有値は実数であることが保証されます。</target>
        </trans-unit>
        <trans-unit id="fd443fcafad8cfc7235ab73b5edb8fa2361feb5f" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an Hermite basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">基底多項式は、 &lt;code&gt;c&lt;/code&gt; がエルミート基底多項式である場合にコンパニオン行列が対称になるようにスケーリングされます。これは、スケーリングされていない場合よりも優れた固有値推定を提供します。基底多項式の場合、&lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt;を使用してそれらを取得すると、固有値は実数であることが保証されます。</target>
        </trans-unit>
        <trans-unit id="e1520a86bfcd397936d59363e21a13733e7a71b7" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an HermiteE basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">基底多項式は、 &lt;code&gt;c&lt;/code&gt; がHermiteE基底多項式であるときにコンパニオン行列が対称になるようにスケーリングされます。これは、スケーリングされていない場合よりも優れた固有値推定を提供します。基底多項式の場合、&lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt;を使用してそれらを取得すると、固有値は実数であることが保証されます。</target>
        </trans-unit>
        <trans-unit id="31e8496a7482cd5cd28cb680bd285957a80df61e" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an Legendre basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">基底多項式は、 &lt;code&gt;c&lt;/code&gt; がルジャンドル基底多項式のときにコンパニオン行列が対称になるようにスケーリングされます。これは、スケーリングされていない場合よりも優れた固有値推定を提供します。基底多項式の場合、&lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt;を使用してそれらを取得すると、固有値は実数であることが保証されます。</target>
        </trans-unit>
        <trans-unit id="f437318ff72364f761b90a9b7cf38009e657db81" translate="yes" xml:space="preserve">
          <source>The behavior depends on the arguments in the following way.</source>
          <target state="translated">挙動は以下のように引数に依存します。</target>
        </trans-unit>
        <trans-unit id="e2bdcfca6c07efc9e236b5653fc2391d3452350a" translate="yes" xml:space="preserve">
          <source>The best practice is to &lt;strong&gt;not&lt;/strong&gt; reseed a BitGenerator, rather to recreate a new one. This method is here for legacy reasons. This example demonstrates best practice.</source>
          <target state="translated">ベストプラクティスは、BitGeneratorを再シードし&lt;strong&gt;ないで&lt;/strong&gt;、新しいものを再作成することです。この方法はレガシーの理由でここにあります。この例は、ベストプラクティスを示しています。</target>
        </trans-unit>
        <trans-unit id="b917d701e1031f727f4614d1e3412a655c750b99" translate="yes" xml:space="preserve">
          <source>The best way to become familiar with the iterator is to look at its usage within the NumPy codebase itself. For example, here is a slightly tweaked version of the code for &lt;a href=&quot;c-api.array#c.PyArray_CountNonzero&quot;&gt;&lt;code&gt;PyArray_CountNonzero&lt;/code&gt;&lt;/a&gt;, which counts the number of non-zero elements in an array.</source>
          <target state="translated">イテレーターに慣れるための最良の方法は、NumPyコードベース自体での使用法を確認することです。たとえば、これは&lt;a href=&quot;c-api.array#c.PyArray_CountNonzero&quot;&gt; &lt;code&gt;PyArray_CountNonzero&lt;/code&gt; &lt;/a&gt;のコードを少し調整したバージョンで、配列内のゼロ以外の要素の数をカウントします。</target>
        </trans-unit>
        <trans-unit id="de71d7b03048d0ddf7e9d872a2d91138dd227be5" translate="yes" xml:space="preserve">
          <source>The best way to encode the options required to link against the specified C libraries is to use a &amp;ldquo;libname.ini&amp;rdquo; file, and use &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.get_info&quot;&gt;&lt;code&gt;get_info&lt;/code&gt;&lt;/a&gt; to retrieve the required options (see &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt;&lt;code&gt;add_npy_pkg_config&lt;/code&gt;&lt;/a&gt; for more information).</source>
          <target state="translated">指定されたCライブラリへのリンクに必要なオプションをエンコードする最良の方法は、「libname.ini」ファイルを使用し、&lt;a href=&quot;#numpy.distutils.misc_util.Configuration.get_info&quot;&gt; &lt;code&gt;get_info&lt;/code&gt; &lt;/a&gt;を使用して必要なオプションを取得することです（詳細については、&lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt; &lt;code&gt;add_npy_pkg_config&lt;/code&gt; &lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="1969d49698b808b6d276d97e5d8d4c69483e3b58" translate="yes" xml:space="preserve">
          <source>The bi-dimensional histogram of samples &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Values in &lt;code&gt;x&lt;/code&gt; are histogrammed along the first dimension and values in &lt;code&gt;y&lt;/code&gt; are histogrammed along the second dimension.</source>
          <target state="translated">サンプル &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の2次元ヒストグラム。 &lt;code&gt;x&lt;/code&gt; の値は最初の次元に沿ってヒストグラムが作成され、 &lt;code&gt;y&lt;/code&gt; の値は2番目の次元に沿ってヒストグラムが作成されます。</target>
        </trans-unit>
        <trans-unit id="14050b2975e92118c403ebf94bd3985c0b813e9c" translate="yes" xml:space="preserve">
          <source>The bin edges along the first dimension.</source>
          <target state="translated">1次元に沿ったビンのエッジ。</target>
        </trans-unit>
        <trans-unit id="4350d5e237c7d985f1cac8ee28f6158f7c836a6a" translate="yes" xml:space="preserve">
          <source>The bin edges along the second dimension.</source>
          <target state="translated">ビンの端は第2の次元に沿っています。</target>
        </trans-unit>
        <trans-unit id="a2867162a2727e5c2d9c039d549ef3ce42449ec8" translate="yes" xml:space="preserve">
          <source>The bin specification:</source>
          <target state="translated">ビンの仕様です。</target>
        </trans-unit>
        <trans-unit id="60d93abeda71712ad2c6a79ef8adc26f40d2aa9b" translate="yes" xml:space="preserve">
          <source>The binwidth is proportional to the interquartile range (IQR) and inversely proportional to cube root of a.size. Can be too conservative for small datasets, but is quite good for large datasets. The IQR is very robust to outliers.</source>
          <target state="translated">bin幅は,四分位間範囲(IQR)に比例し,a.sizeの立方根に反比例する.小規模なデータセットでは保守的すぎることもありますが、大規模なデータセットでは非常に優れています。IQRは,外れ値に対して非常にロバストである.</target>
        </trans-unit>
        <trans-unit id="fcdd8e437719df337fcbc4c74083d021a1773472" translate="yes" xml:space="preserve">
          <source>The binwidth is proportional to the standard deviation of the data and inversely proportional to cube root of &lt;code&gt;x.size&lt;/code&gt;. Can be too conservative for small datasets, but is quite good for large datasets. The standard deviation is not very robust to outliers. Values are very similar to the Freedman-Diaconis estimator in the absence of outliers.</source>
          <target state="translated">ビン幅はデータの標準偏差に比例し、 &lt;code&gt;x.size&lt;/code&gt; の立方根に反比例します。小さなデータセットには控えめすぎる可能性がありますが、大きなデータセットには非常に適しています。標準偏差は外れ値に対して非常にロバストではありません。外れ値がない場合、値はFreedman-Diaconis推定量と非常に似ています。</target>
        </trans-unit>
        <trans-unit id="4bfe7be4cfb5e7ee31495fab431c2ade90ea37b4" translate="yes" xml:space="preserve">
          <source>The bit generator instance used by the generator</source>
          <target state="translated">が使用するビットジェネレーターのインスタンス</target>
        </trans-unit>
        <trans-unit id="c5d3462c76522066d7ff9beefce9a7effa7d1a7a" translate="yes" xml:space="preserve">
          <source>The bit generators can be used in downstream projects via &lt;a href=&quot;extending#randomgen-cython&quot;&gt;Cython&lt;/a&gt;.</source>
          <target state="translated">ビットジェネレーターは、&lt;a href=&quot;extending#randomgen-cython&quot;&gt;Cython&lt;/a&gt;を介してダウンストリームプロジェクトで使用できます。</target>
        </trans-unit>
        <trans-unit id="bb60b63a1d593f422d320c08f605d5c913dee609" translate="yes" xml:space="preserve">
          <source>The bit generators can be used in downstream projects via Cython.</source>
          <target state="translated">ビットジェネレーターは、Cythonを介して下流のプロジェクトで使用することができます。</target>
        </trans-unit>
        <trans-unit id="6e4e6fbd0cb3401b8c573dd3679e44e3f4f81dbf" translate="yes" xml:space="preserve">
          <source>The bit-width names can also be used (e.g. &lt;a href=&quot;c-api.dtype#c.NPY_INT32&quot;&gt;&lt;code&gt;NPY_INT32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_COMPLEX128&quot;&gt;&lt;code&gt;NPY_COMPLEX128&lt;/code&gt;&lt;/a&gt; ) if desired.</source>
          <target state="translated">必要に応じて、ビット幅の名前（&lt;a href=&quot;c-api.dtype#c.NPY_INT32&quot;&gt; &lt;code&gt;NPY_INT32&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;c-api.dtype#c.NPY_COMPLEX128&quot;&gt; &lt;code&gt;NPY_COMPLEX128&lt;/code&gt; など&lt;/a&gt;）も使用できます。</target>
        </trans-unit>
        <trans-unit id="81d10a070991358c5aabcf2c4a0f8549725777dd" translate="yes" xml:space="preserve">
          <source>The bit-wise operators &amp;amp; and | are the proper way to perform element-by-element array comparisons. Be sure you understand the operator precedence: &lt;code&gt;(a &amp;gt; 2) &amp;amp; (a &amp;lt; 5)&lt;/code&gt; is the proper syntax because &lt;code&gt;a &amp;gt; 2 &amp;amp; a &amp;lt; 5&lt;/code&gt; will result in an error due to the fact that &lt;code&gt;2 &amp;amp; a&lt;/code&gt; is evaluated first.</source>
          <target state="translated">ビットごとの演算子＆および| 要素ごとの配列比較を実行する適切な方法です。演算子の優先順位を必ず理解してください。 &lt;code&gt;(a &amp;gt; 2) &amp;amp; (a &amp;lt; 5)&lt;/code&gt; は適切な構文です。これは &lt;code&gt;a &amp;gt; 2 &amp;amp; a &amp;lt; 5&lt;/code&gt; 場合、 &lt;code&gt;2 &amp;amp; a&lt;/code&gt; が最初に評価されるため、エラーが発生するためです。</target>
        </trans-unit>
        <trans-unit id="023be86065ffa72daa5873059c9ec3d6c37210a4" translate="yes" xml:space="preserve">
          <source>The bits that are inherited for the parent data-type if these bits are set in any field of the data-type. Currently ( &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt;&lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt;&lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt;&lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt;&lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">これらのビットがデータ型のいずれかのフィールドに設定されている場合に親データ型に継承されるビット。現在（&lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt; &lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt; &lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt; &lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt; &lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4cdfeeb979f5beeacca8e8ed28ded2c7c6f59236" translate="yes" xml:space="preserve">
          <source>The buffer size. If &lt;code&gt;buf_size&lt;/code&gt; is supplied, the maximum amount of data that will be read into memory is &lt;code&gt;buf_size&lt;/code&gt; elements. Default is None, which will read as many element as possible into memory.</source>
          <target state="translated">バッファサイズ。 &lt;code&gt;buf_size&lt;/code&gt; が指定されている場合、メモリに読み込まれるデータの最大量は &lt;code&gt;buf_size&lt;/code&gt; 要素です。デフォルトはNoneで、可能な限り多くの要素をメモリに読み込みます。</target>
        </trans-unit>
        <trans-unit id="2e41256de81634e573afba6a93755e0b3e1dcc73" translate="yes" xml:space="preserve">
          <source>The built-in scalar types are shown below. Along with their (mostly) C-derived names, the integer, float, and complex data-types are also available using a bit-width convention so that an array of the right size can always be ensured (e.g. &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;). Two aliases (&lt;code&gt;intp&lt;/code&gt; and &lt;code&gt;uintp&lt;/code&gt;) pointing to the integer type that is sufficiently large to hold a C pointer are also provided. The C-like names are associated with character codes, which are shown in the table. Use of the character codes, however, is discouraged.</source>
          <target state="translated">組み込みスカラー型を以下に示します。それらの（ほとんど）Cから派生した名前に加えて、ビット幅の規則を使用して整数、浮動小数点、および複素数のデータ型も利用できるため、適切なサイズの配列を常に確保できます（たとえば、 &lt;code&gt;int8&lt;/code&gt; 、 &lt;code&gt;float64&lt;/code&gt; 、 &lt;code&gt;complex128&lt;/code&gt; ）。 。二つのエイリアス（ &lt;code&gt;intp&lt;/code&gt; と &lt;code&gt;uintp&lt;/code&gt; Cポインタを保持するのに十分な大きさである整数型を指す）も提供されます。Cのような名前は、表に示す文字コードに関連付けられています。ただし、文字コードの使用はお勧めしません。</target>
        </trans-unit>
        <trans-unit id="c0f5f929adb8df8a6adc766b8c78557ffdeb6dfb" translate="yes" xml:space="preserve">
          <source>The byte offset of element &lt;code&gt;(i[0], i[1], ..., i[n])&lt;/code&gt; in an array &lt;code&gt;a&lt;/code&gt; is:</source>
          <target state="translated">配列 &lt;code&gt;a&lt;/code&gt; の要素 &lt;code&gt;(i[0], i[1], ..., i[n])&lt;/code&gt; のバイトオフセットは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a157c5730d5626d8d468cb6666e1e8a306635908" translate="yes" xml:space="preserve">
          <source>The byte order of the data (which may not be the native byte order)</source>
          <target state="translated">データのバイト順(ネイティブのバイト順ではない場合もあります</target>
        </trans-unit>
        <trans-unit id="54750603ecbabb9e0fbfb396fe440127b1696b3c" translate="yes" xml:space="preserve">
          <source>The byteswapped array. If &lt;code&gt;inplace&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, this is a view to self.</source>
          <target state="translated">バイトスワップされた配列。 &lt;code&gt;inplace&lt;/code&gt; が &lt;code&gt;True&lt;/code&gt; の場合、これは自分へのビューです。</target>
        </trans-unit>
        <trans-unit id="50ca95011c00b72a055aafd7f7fd748d3ee5666f" translate="yes" xml:space="preserve">
          <source>The calculation based on the Einstein summation convention.</source>
          <target state="translated">アインシュタインの和算規約に基づいた計算。</target>
        </trans-unit>
        <trans-unit id="f28022cc3c759ea7fff9649dace591b586e47f2a" translate="yes" xml:space="preserve">
          <source>The call function takes two arguments. The first is a string describing the type of error (such as &amp;ldquo;divide by zero&amp;rdquo;, &amp;ldquo;overflow&amp;rdquo;, &amp;ldquo;underflow&amp;rdquo;, or &amp;ldquo;invalid value&amp;rdquo;), and the second is the status flag. The flag is a byte, whose four least-significant bits indicate the type of error, one of &amp;ldquo;divide&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, &amp;ldquo;invalid&amp;rdquo;:</source>
          <target state="translated">call関数は2つの引数を取ります。1つ目はエラーの種類を説明する文字列（「ゼロ除算」、「オーバーフロー」、「アンダーフロー」、「無効な値」など）で、2つ目はステータスフラグです。フラグはバイトであり、その最下位4ビットがエラーのタイプを示し、「除算」、「オーバー」、「アンダー」、「無効」のいずれかです。</target>
        </trans-unit>
        <trans-unit id="65bfb33c8f536eca2e334a181b45563504281f94" translate="yes" xml:space="preserve">
          <source>The callable to test.</source>
          <target state="translated">テストするための呼び出し可能なもの。</target>
        </trans-unit>
        <trans-unit id="431e9b7795bdf48241d6bec5990fb4a0130d071a" translate="yes" xml:space="preserve">
          <source>The ceil of the scalar &lt;code&gt;x&lt;/code&gt; is the smallest integer &lt;code&gt;i&lt;/code&gt;, such that &lt;code&gt;i &amp;gt;= x&lt;/code&gt;. It is often denoted as</source>
          <target state="translated">スカラー &lt;code&gt;x&lt;/code&gt; のceilは、 &lt;code&gt;i &amp;gt;= x&lt;/code&gt; ような最小の整数 &lt;code&gt;i&lt;/code&gt; です。多くの場合、</target>
        </trans-unit>
        <trans-unit id="e9d3cf326f9a7a53ec955615e43eb638c61eb8ef" translate="yes" xml:space="preserve">
          <source>The ceiling of each element in &lt;code&gt;x&lt;/code&gt;, with &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; dtype. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">各要素の天井 &lt;code&gt;x&lt;/code&gt; と、&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; DTYPE。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="39a8dcb488a9fc6fc34cf5a558688abf07d39d3f" translate="yes" xml:space="preserve">
          <source>The character representing the minimum-size type that was found.</source>
          <target state="translated">見つかった最小サイズのタイプを表す文字。</target>
        </trans-unit>
        <trans-unit id="97cbe8e263bc4b6b77075dcb6bab028e565a01e7" translate="yes" xml:space="preserve">
          <source>The character to use for padding</source>
          <target state="translated">パディングに使用する文字</target>
        </trans-unit>
        <trans-unit id="6c4bf24ea0f35b24c677f85fded0fd7b09f23149" translate="yes" xml:space="preserve">
          <source>The character used to indicate the start of a comment. All the characters occurring on a line after a comment are discarded</source>
          <target state="translated">コメントの開始を示すために使用される文字。コメントの後の行にある文字はすべて破棄されます。</target>
        </trans-unit>
        <trans-unit id="d85f382686a835461ae276491d1cc1f7d794fafc" translate="yes" xml:space="preserve">
          <source>The characteristic polynomial,</source>
          <target state="translated">特徴的な多項式。</target>
        </trans-unit>
        <trans-unit id="95fe0ca98cff261937758debf60dec87c78a570a" translate="yes" xml:space="preserve">
          <source>The characters or list of characters used to indicate the start of a comment. None implies no comments. For backwards compatibility, byte strings will be decoded as &amp;lsquo;latin1&amp;rsquo;. The default is &amp;lsquo;#&amp;rsquo;.</source>
          <target state="translated">コメントの開始を示すために使用される文字または文字のリスト。なしはコメントがないことを意味します。下位互換性のために、バイト文字列は「latin1」としてデコードされます。デフォルトは「＃」です。</target>
        </trans-unit>
        <trans-unit id="5b3f50108009441cc91c801c6a0d50e7f118400f" translate="yes" xml:space="preserve">
          <source>The class defining the warning that &lt;code&gt;func&lt;/code&gt; is expected to throw.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; がスローすると予想される警告を定義するクラス。</target>
        </trans-unit>
        <trans-unit id="3182c5f9b369539a27f1bc7716b92f10416add66" translate="yes" xml:space="preserve">
          <source>The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for these alternatives. For example, any of &amp;lsquo;&amp;gt;&amp;rsquo; or &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;brian&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">コードは、これらの代替案について &lt;code&gt;new_order&lt;/code&gt; の最初の文字で大文字と小文字を区別しないチェックを行います。たとえば、ビッグエンディアンを指定するには、「&amp;gt;」、「B」、「b」、「brian」のいずれも有効です。</target>
        </trans-unit>
        <trans-unit id="3d7fde77cc6d2864c99d7d852dc9654a8a2c232a" translate="yes" xml:space="preserve">
          <source>The coefficient array representing their sum.</source>
          <target state="translated">それらの和を表す係数配列.</target>
        </trans-unit>
        <trans-unit id="8877be945db0e0267ce25ed710aea10434e74470" translate="yes" xml:space="preserve">
          <source>The coefficient matrix of the coefficients &lt;code&gt;p&lt;/code&gt; is a Vandermonde matrix.</source>
          <target state="translated">係数 &lt;code&gt;p&lt;/code&gt; の係数行列は、ヴァンダーモンド行列です。</target>
        </trans-unit>
        <trans-unit id="1749ca10e1fd82b0f81734b8e3040c222ba10138" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is 1 for monic polynomials in this form.</source>
          <target state="translated">この形式の単項多項式では、最後の項の係数は1である。</target>
        </trans-unit>
        <trans-unit id="7f518b8b3d036f3e65aa1004d0ce4c9fe4f469f2" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Chebyshev form.</source>
          <target state="translated">最後の項の係数は、チェビシェフ形式の単項多項式では一般的に1ではない。</target>
        </trans-unit>
        <trans-unit id="c6e27aff7bd03298a7abe7cdd24c2851e78ffc19" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Hermite form.</source>
          <target state="translated">エルミート形式の単項多項式では、最後の項の係数は一概に1とは言えません。</target>
        </trans-unit>
        <trans-unit id="d8180193920e1d179284839e524518471959f55d" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in HermiteE form.</source>
          <target state="translated">HermiteE形式の単項多項式では、最後の項の係数は一般的に1ではありません。</target>
        </trans-unit>
        <trans-unit id="870417532aa77b335abb3ff61d44b3280649b54a" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Laguerre form.</source>
          <target state="translated">ラゲール形式の単項多項式では、最後の項の係数は一概に1とは言えません。</target>
        </trans-unit>
        <trans-unit id="d2eb9fcb4c7fc816e015e2f1263164865a84ea2c" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Legendre form.</source>
          <target state="translated">レジェンドレ形式の単項多項式では、最後の項の係数は一概に1とは言えません。</target>
        </trans-unit>
        <trans-unit id="c0eab4462e93f35863c8383ff656ddde3733b00b" translate="yes" xml:space="preserve">
          <source>The coefficients are determined by multiplying together linear factors of the form &lt;code&gt;(x - r_i)&lt;/code&gt;, i.e.</source>
          <target state="translated">係数は、一緒にフォームの線形係数乗算することによって決定される &lt;code&gt;(x - r_i)&lt;/code&gt; 、すなわち</target>
        </trans-unit>
        <trans-unit id="96b42532f49d3b3a4358a0737c1292c860f167f7" translate="yes" xml:space="preserve">
          <source>The column &lt;code&gt;v[:, i]&lt;/code&gt; is the normalized eigenvector corresponding to the eigenvalue &lt;code&gt;w[i]&lt;/code&gt;. Will return a matrix object if &lt;code&gt;a&lt;/code&gt; is a matrix object.</source>
          <target state="translated">列 &lt;code&gt;v[:, i]&lt;/code&gt; は、固有値 &lt;code&gt;w[i]&lt;/code&gt; 対応する正規化された固有ベクトルです。場合は行列オブジェクトを返しますマトリックスオブジェクトです。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="05afae6f6316038b8a077ed2d79753233c9700ab" translate="yes" xml:space="preserve">
          <source>The column dimension of the arrays for which the returned arrays will be valid. By default &lt;code&gt;m&lt;/code&gt; is taken equal to &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">返される配列が有効になる配列の列次元。デフォルト &lt;code&gt;m&lt;/code&gt; は、mは &lt;code&gt;n&lt;/code&gt; と等しくなります。</target>
        </trans-unit>
        <trans-unit id="049227627bd4dfed2d2a3d0a02023afddf2ece4d" translate="yes" xml:space="preserve">
          <source>The columns of the output matrix are powers of the input vector. The order of the powers is determined by the &lt;code&gt;increasing&lt;/code&gt; boolean argument. Specifically, when &lt;code&gt;increasing&lt;/code&gt; is False, the &lt;code&gt;i&lt;/code&gt;-th output column is the input vector raised element-wise to the power of &lt;code&gt;N - i - 1&lt;/code&gt;. Such a matrix with a geometric progression in each row is named for Alexandre- Theophile Vandermonde.</source>
          <target state="translated">出力行列の列は、入力ベクトルのべき乗です。累乗の順序は、 &lt;code&gt;increasing&lt;/code&gt; ブール引数によって決定されます。具体的には、 &lt;code&gt;increasing&lt;/code&gt; がFalseの場合、 &lt;code&gt;i&lt;/code&gt; 番目の出力列は、要素ごとに &lt;code&gt;N - i - 1&lt;/code&gt; 累乗された入力ベクトルです。各行に幾何学的な進行があるこのような行列は、Alexandre-Theophile Vandermondeにちなんで名付けられました。</target>
        </trans-unit>
        <trans-unit id="fd5ff7ed1e1b0436ec4f4722206a381ca973b853" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;make test&lt;/code&gt; will ensure that all of the test software is built and then run all three test scripts.</source>
          <target state="translated">&lt;code&gt;make test&lt;/code&gt; コマンドは、すべてのテストソフトウェアがビルドされていることを確認してから、3つのテストスクリプトをすべて実行します。</target>
        </trans-unit>
        <trans-unit id="24aa155f0fb452987333532fc0871b6b96e25258" translate="yes" xml:space="preserve">
          <source>The common data type, which is the maximum of &lt;code&gt;array_types&lt;/code&gt; ignoring &lt;code&gt;scalar_types&lt;/code&gt;, unless the maximum of &lt;code&gt;scalar_types&lt;/code&gt; is of a different kind (&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt;&lt;code&gt;dtype.kind&lt;/code&gt;&lt;/a&gt;). If the kind is not understood, then None is returned.</source>
          <target state="translated">最大値である共通データ型、 &lt;code&gt;array_types&lt;/code&gt; 無視 &lt;code&gt;scalar_types&lt;/code&gt; を最大ない限り、 &lt;code&gt;scalar_types&lt;/code&gt; が異なる種類（である&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt; &lt;code&gt;dtype.kind&lt;/code&gt; &lt;/a&gt;）。種類が理解できない場合は、Noneが返されます。</target>
        </trans-unit>
        <trans-unit id="6557c9bc2aa7a334ee156279cd2e6ed26882b290" translate="yes" xml:space="preserve">
          <source>The common fill value, or None.</source>
          <target state="translated">共通の塗りつぶし値、または None。</target>
        </trans-unit>
        <trans-unit id="c7c4929011c41aa057f46d2bc4e51aaccf9a85a1" translate="yes" xml:space="preserve">
          <source>The companion matrix for power series cannot be made symmetric by scaling the basis, so this function differs from those for the orthogonal polynomials.</source>
          <target state="translated">力系列のコンパニオン行列は基底をスケーリングして対称にすることができないので、直交多項式のコンパニオン行列とは異なります。</target>
        </trans-unit>
        <trans-unit id="50728cc7411772baf0d23ae9dab7a04fd085919c" translate="yes" xml:space="preserve">
          <source>The comparison of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; uses standard broadcasting, which means that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; need not have the same shape in order for &lt;code&gt;allclose(a, b)&lt;/code&gt; to evaluate to True. The same is true for &lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt;&lt;code&gt;equal&lt;/code&gt;&lt;/a&gt; but not &lt;a href=&quot;numpy.array_equal#numpy.array_equal&quot;&gt;&lt;code&gt;array_equal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">比較と &lt;code&gt;b&lt;/code&gt; があることを意味標準放送、使用および &lt;code&gt;b&lt;/code&gt; 必要性のためのために、同じ形状を有していない &lt;code&gt;allclose(a, b)&lt;/code&gt; Trueに評価することを。&lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt; &lt;code&gt;equal&lt;/code&gt; &lt;/a&gt;が&lt;a href=&quot;numpy.array_equal#numpy.array_equal&quot;&gt; &lt;code&gt;array_equal&lt;/code&gt; に&lt;/a&gt;は同じことが当てはまりません。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed9a376f5659e4753c56a46ffbea586e1c5b762b" translate="yes" xml:space="preserve">
          <source>The complex conjugate of &lt;code&gt;x&lt;/code&gt;, with same dtype as &lt;code&gt;y&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; と同じdtypeを持つ &lt;code&gt;x&lt;/code&gt; の複素共役。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="d1ca0ff74dd3394813701dd385de23f306fa9c69" translate="yes" xml:space="preserve">
          <source>The complex conjugate of a complex number is obtained by changing the sign of its imaginary part.</source>
          <target state="translated">複素数の複素共役は、その虚数部の符号を変えることで得られる。</target>
        </trans-unit>
        <trans-unit id="41eb6fa093181f73897902c7f0874292edf29e51" translate="yes" xml:space="preserve">
          <source>The compressed array.</source>
          <target state="translated">圧縮された配列です。</target>
        </trans-unit>
        <trans-unit id="5eb5823a400c379807aed8ab125dee97f320721d" translate="yes" xml:space="preserve">
          <source>The concatenated array with any masked entries preserved.</source>
          <target state="translated">マスクされたエントリが保存された連結配列。</target>
        </trans-unit>
        <trans-unit id="a37868502a5a0d6add95945d1a64803e757adeaa" translate="yes" xml:space="preserve">
          <source>The concatenated array.</source>
          <target state="translated">連結された配列。</target>
        </trans-unit>
        <trans-unit id="3af59c1bb124d9d3dff66fb6d58de527a5027e82" translate="yes" xml:space="preserve">
          <source>The concept of a behaved segment is used in the description of the function pointers. A behaved segment is one that is aligned and in native machine byte-order for the data-type. The &lt;code&gt;nonzero&lt;/code&gt;, &lt;code&gt;copyswap&lt;/code&gt;, &lt;code&gt;copyswapn&lt;/code&gt;, &lt;code&gt;getitem&lt;/code&gt;, and &lt;code&gt;setitem&lt;/code&gt; functions can (and must) deal with mis-behaved arrays. The other functions require behaved memory segments.</source>
          <target state="translated">動作セグメントの概念は、関数ポインターの説明で使用されます。動作するセグメントは、データ型に合わせて調整され、ネイティブマシンのバイト順であるセグメントです。 &lt;code&gt;nonzero&lt;/code&gt; 、 &lt;code&gt;copyswap&lt;/code&gt; 、 &lt;code&gt;copyswapn&lt;/code&gt; 、 &lt;code&gt;getitem&lt;/code&gt; 、および &lt;code&gt;setitem&lt;/code&gt; 機能することができる（及びなければならない）ミス行儀アレイとの契約。その他の機能には、動作するメモリセグメントが必要です。</target>
        </trans-unit>
        <trans-unit id="46e686c81ff0f33a7ee42cbdb148b2206e722231" translate="yes" xml:space="preserve">
          <source>The condition number of &lt;code&gt;x&lt;/code&gt; is defined as the norm of &lt;code&gt;x&lt;/code&gt; times the norm of the inverse of &lt;code&gt;x&lt;/code&gt;&lt;a href=&quot;#r611900c44d60-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;; the norm can be the usual L2-norm (root-of-sum-of-squares) or one of a number of other matrix norms.</source>
          <target state="translated">条件数 &lt;code&gt;x&lt;/code&gt; がのノルムとして定義され &lt;code&gt;x&lt;/code&gt; 時間の逆数のノルム &lt;code&gt;x&lt;/code&gt; &lt;a href=&quot;#r611900c44d60-1&quot; id=&quot;id1&quot;&gt;[1] &lt;/a&gt;。ノルムは、通常のL2ノルム（平方根の平方根）または他の多数の行列ノルムのいずれかです。</target>
        </trans-unit>
        <trans-unit id="7ed508e4defcab357510ceacda28d2924496cd06" translate="yes" xml:space="preserve">
          <source>The condition number of the matrix. May be infinite.</source>
          <target state="translated">行列の条件番号。無限になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="c901451fe41cf6f1482465c84b6a4c739cbccbff" translate="yes" xml:space="preserve">
          <source>The config file generated from &lt;code&gt;template&lt;/code&gt; is installed in the given install directory, using &lt;code&gt;subst_dict&lt;/code&gt; for variable substitution.</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; から生成された設定ファイルは、変数置換に &lt;code&gt;subst_dict&lt;/code&gt; を使用して、指定されたインストールディレクトリにインストールされます。</target>
        </trans-unit>
        <trans-unit id="2fe0070d6ccb31708b92b4e4ed2caabdfe3d249d" translate="yes" xml:space="preserve">
          <source>The constants &lt;strong&gt;NPY_INTP&lt;/strong&gt; and &lt;strong&gt;NPY_UINTP&lt;/strong&gt; refer to an enumerated integer type that is large enough to hold a pointer on the platform. Index arrays should always be converted to &lt;strong&gt;NPY_INTP&lt;/strong&gt; , because the dimension of the array is of type npy_intp.</source>
          <target state="translated">定数&lt;strong&gt;NPY_INTP&lt;/strong&gt;および&lt;strong&gt;NPY_UINTP&lt;/strong&gt;は、プラットフォーム上でポインターを保持するのに十分な大きさの列挙整数型を参照します。配列の次元は&lt;strong&gt;npy_intp型&lt;/strong&gt;であるため、インデックス配列は常に&lt;strong&gt;NPY_INTP&lt;/strong&gt;に変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="fd8a200b77c06e1513f552e8d61858be6438182d" translate="yes" xml:space="preserve">
          <source>The constructed array.</source>
          <target state="translated">構築された配列。</target>
        </trans-unit>
        <trans-unit id="6f12164e316c899cbeec8a520db14b994fa35a8e" translate="yes" xml:space="preserve">
          <source>The contiguous constraint applies only to the inner loop, successive inner loops may have arbitrary pointer changes.</source>
          <target state="translated">連続制約は内側ループにのみ適用され、連続する内側ループでは任意のポインタ変更が可能です。</target>
        </trans-unit>
        <trans-unit id="a28f32d0e2528be0855bfa01e7539cc0e939d215" translate="yes" xml:space="preserve">
          <source>The convenience classes provided by the polynomial package are:</source>
          <target state="translated">多項式パッケージで提供される便利なクラスは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="5a4e9570e8f8bcacc96f206106a01eefad39bd6f" translate="yes" xml:space="preserve">
          <source>The convert method can also convert domain and window:</source>
          <target state="translated">また、convertメソッドはドメインやウィンドウの変換も可能です。</target>
        </trans-unit>
        <trans-unit id="60131768e228b843852dbff6de95273c5e8b7bcb" translate="yes" xml:space="preserve">
          <source>The converted data-type.</source>
          <target state="translated">変換されたデータ型。</target>
        </trans-unit>
        <trans-unit id="1fc6b89fce1f12a34477c12a69d7cd751ad23c91" translate="yes" xml:space="preserve">
          <source>The convolution operator is often seen in signal processing, where it models the effect of a linear time-invariant system on a signal &lt;a href=&quot;#r95849f33d2b1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. In probability theory, the sum of two independent random variables is distributed according to the convolution of their individual distributions.</source>
          <target state="translated">たたみ込み演算子は信号処理でよく見られ、信号に対する線形時不変システムの影響をモデル化します&lt;a href=&quot;#r95849f33d2b1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。確率論では、2つの独立確率変数の合計は、個々の分布の畳み込みに従って分布します。</target>
        </trans-unit>
        <trans-unit id="1b7a113f553d13745aed52a84f8c20493ad427e3" translate="yes" xml:space="preserve">
          <source>The coordinates member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; structure maintains the current N-d counter unless the underlying array is C-contiguous in which case the coordinate counting is by-passed. The index member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the current flat index of the iterator. It is updated by the &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">&lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;構造体の座標メンバーは、基になる配列がC隣接していない限り、現在のNdカウンターを維持します。この場合、座標カウントはバイパスされます。&lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;のインデックスメンバーは、イテレータの現在のフラットインデックスを追跡します。&lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt;マクロによって更新されます。</target>
        </trans-unit>
        <trans-unit id="893c6dfe4a5a151e44d6687fac35fbd3b646a45a" translate="yes" xml:space="preserve">
          <source>The core dimensions are removed from all inputs and the remaining dimensions are broadcast together, defining the loop dimensions.</source>
          <target state="translated">コアディメンジョンはすべての入力から削除され、残りのディメンジョンは一緒にブロードキャストされ、ループディメンジョンが定義されます。</target>
        </trans-unit>
        <trans-unit id="72b350bebf37a78a10162e24af07cb3168e9e839" translate="yes" xml:space="preserve">
          <source>The core of the ufunc is the &lt;a href=&quot;#c.PyUFuncObject&quot;&gt;&lt;code&gt;PyUFuncObject&lt;/code&gt;&lt;/a&gt; which contains all the information needed to call the underlying C-code loops that perform the actual work. While it is described here for completeness, it should be considered internal to NumPy and manipulated via &lt;code&gt;PyUFunc_*&lt;/code&gt; functions. The size of this structure is subject to change across versions of NumPy. To ensure compatibility:</source>
          <target state="translated">ufuncの中核は&lt;a href=&quot;#c.PyUFuncObject&quot;&gt; &lt;code&gt;PyUFuncObject&lt;/code&gt; &lt;/a&gt;で、実際の作業を実行する基本的なCコードループを呼び出すために必要なすべての情報が含まれています。完全を &lt;code&gt;PyUFunc_*&lt;/code&gt; ためにここで説明しますが、NumPyの内部と見なして、PyUFunc_ *関数を介して操作する必要があります。この構造のサイズは、NumPyのバージョン間で変更される可能性があります。互換性を確保するには：</target>
        </trans-unit>
        <trans-unit id="76b4be14cc8fe5491309195ba608e3525321fc00" translate="yes" xml:space="preserve">
          <source>The correlation coefficient matrix of the variables.</source>
          <target state="translated">変数の相関係数行列。</target>
        </trans-unit>
        <trans-unit id="f4e710373f0588180cd5157b94f36ff64a509ad5" translate="yes" xml:space="preserve">
          <source>The corresponding angle in degrees. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">度単位の対応する角度。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="a2c63fcb50ab2a66bb9a9ad01ce9f4ff69c1d271" translate="yes" xml:space="preserve">
          <source>The corresponding angle in radians. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">ラジアンでの対応する角度。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="c2babda63010514076aef395fac45645683b9564" translate="yes" xml:space="preserve">
          <source>The corresponding array scalar type is &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="translated">対応する配列スカラー型は &lt;code&gt;int32&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="cd11fa4205dd5b33a3e2b183413534954599bad7" translate="yes" xml:space="preserve">
          <source>The corresponding cosine values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">対応するコサイン値。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="6d98f6605847a59a64fcad02a0b3d4fdfd44ca3d" translate="yes" xml:space="preserve">
          <source>The corresponding degree values; if &lt;code&gt;out&lt;/code&gt; was supplied this is a reference to it. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">対応する次数の値。 &lt;code&gt;out&lt;/code&gt; が指定された場合、これはそれへの参照です。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="2584010810109879710934f24451582df80fa088" translate="yes" xml:space="preserve">
          <source>The corresponding hyperbolic sine values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">対応する双曲線正弦値。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="2f46b05f80b785698faf42d321e3104fa7625e8a" translate="yes" xml:space="preserve">
          <source>The corresponding hyperbolic tangent values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">対応する双曲線正接値。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="d9ca95035c9f509708b9e99487c1ebe9e3ab11bd" translate="yes" xml:space="preserve">
          <source>The corresponding radian values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">対応するラジアン値。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="c1e4a7360c69977ad10edc5bee560d5ac06dcf90" translate="yes" xml:space="preserve">
          <source>The corresponding tangent values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">対応する接線の値。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="f1763b6e0e62ea8d29f68696fab1bd4ea96474d4" translate="yes" xml:space="preserve">
          <source>The cost for a matrix multiplication can be calculated with the following function:</source>
          <target state="translated">行列の乗算にかかるコストは、以下の関数で計算できます。</target>
        </trans-unit>
        <trans-unit id="6933bada15117031adec212786a3dbdf77a91aff" translate="yes" xml:space="preserve">
          <source>The costs for the two different parenthesizations are as follows:</source>
          <target state="translated">2つの異なる括弧を付けた場合の費用は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="71417050531966fa2bba7739241abcc4b67310e0" translate="yes" xml:space="preserve">
          <source>The counterclockwise angle from the positive real axis on the complex plane in the range &lt;code&gt;(-pi, pi]&lt;/code&gt;, with dtype as numpy.float64.</source>
          <target state="translated">範囲 &lt;code&gt;(-pi, pi]&lt;/code&gt; の複素平面上の正の実軸からの反時計回りの角度。dtypeはnumpy.float64です。</target>
        </trans-unit>
        <trans-unit id="703b92f1857fec3346f55e95a27ed079fdf918ac" translate="yes" xml:space="preserve">
          <source>The covariance matrix of the variables.</source>
          <target state="translated">変数の共分散行列。</target>
        </trans-unit>
        <trans-unit id="f56bfc3801b5981a49e90ddd94a5011933b03e11" translate="yes" xml:space="preserve">
          <source>The cross product of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in</source>
          <target state="translated">外積と &lt;code&gt;b&lt;/code&gt; で &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d70737d8a9b599cea578eef90e469f4ec5cade8d" translate="yes" xml:space="preserve">
          <source>The cumulative product for each column (i.e., over the rows) of &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">の各列（すなわち、行以上）の累積生成物： &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4974aaba8d216c55c50471b0bc56ddd6323d0ebc" translate="yes" xml:space="preserve">
          <source>The cumulative product for each row (i.e. over the columns) of &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; の各行（つまり列）の累積積：</target>
        </trans-unit>
        <trans-unit id="50631d91282d5f6763c8dcfd14a90d74339342d9" translate="yes" xml:space="preserve">
          <source>The current (1-d) index into the broadcasted result.</source>
          <target state="translated">放送された結果への現在の(1-d)インデックス。</target>
        </trans-unit>
        <trans-unit id="8c233acaa927b0b3ae6437f9077a3fae3621ed5f" translate="yes" xml:space="preserve">
          <source>The current 1-d index into the array.</source>
          <target state="translated">配列への現在の1-dインデックス.</target>
        </trans-unit>
        <trans-unit id="cbb3baf8a681bbb5337a5050d23b30de4d838c39" translate="yes" xml:space="preserve">
          <source>The current error handler. If no handler was set through &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">現在のエラーハンドラ。&lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt;でハンドラが設定されていない場合は、 &lt;code&gt;None&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="fcd1e82b97c62204928be3c1426e12c2f8f2093c" translate="yes" xml:space="preserve">
          <source>The current interface remains unchanged, and &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; can still be used to implement (specialized) ufuncs, consisting of scalar elementary functions.</source>
          <target state="translated">現在のインターフェースは変更されないままであり、 &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; は、スカラ基本関数で構成される（特殊化された）ufuncを実装するために引き続き使用できます。</target>
        </trans-unit>
        <trans-unit id="4809e84f7d3a9eb68e3d6e9384c7ac43b19e108c" translate="yes" xml:space="preserve">
          <source>The current version of the ndarray object (check to see if this variable is defined to guarantee the numpy/arrayobject.h header is being used).</source>
          <target state="translated">ndarrayオブジェクトの現在のバージョン(numpy/arrayobject.hヘッダが使用されていることを保証するためにこの変数が定義されているかどうかを確認してください)。</target>
        </trans-unit>
        <trans-unit id="d02692cc2b9183733a0e1ac33e907e722f2cb651" translate="yes" xml:space="preserve">
          <source>The data actually stored in object arrays (&lt;em&gt;i.e.&lt;/em&gt;, arrays having dtype &lt;code&gt;object_&lt;/code&gt;) are references to Python objects, not the objects themselves. Hence, object arrays behave more like usual Python &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt;&lt;code&gt;lists&lt;/code&gt;&lt;/a&gt;, in the sense that their contents need not be of the same Python type.</source>
          <target state="translated">オブジェクト配列（&lt;em&gt;つまり&lt;/em&gt;、dtype &lt;code&gt;object_&lt;/code&gt; を持つ配列）に実際に格納されているデータは、オブジェクト自体ではなく、Pythonオブジェクトへの参照です。したがって、オブジェクト配列&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt; &lt;code&gt;lists&lt;/code&gt; &lt;/a&gt;、その内容が同じPythonタイプである必要がないという意味で、通常のPython リストのように動作します。</target>
        </trans-unit>
        <trans-unit id="2b8f4fa1516918fd8297afcfb360ffa13708823d" translate="yes" xml:space="preserve">
          <source>The data and all elements are aligned appropriately for the hardware.</source>
          <target state="translated">データと全ての要素がハードウェアに合わせて適切に配置されています。</target>
        </trans-unit>
        <trans-unit id="3286aa81b485c3d7add58cb76776a5c44fcb4bf2" translate="yes" xml:space="preserve">
          <source>The data area and all array elements are aligned appropriately.</source>
          <target state="translated">データ領域とすべての配列要素が適切に整列されます。</target>
        </trans-unit>
        <trans-unit id="c1365a86184a90bddcccd2199d804c180d307014" translate="yes" xml:space="preserve">
          <source>The data area can be written to.</source>
          <target state="translated">データ領域に書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="539587e7a7889df8e80a73151cc3ac06f87c111c" translate="yes" xml:space="preserve">
          <source>The data area can be written to. Setting this to False locks the data, making it read-only. A view (slice, etc.) inherits WRITEABLE from its base array at creation time, but a view of a writeable array may be subsequently locked while the base array remains writeable. (The opposite is not true, in that a view of a locked array may not be made writeable. However, currently, locking a base object does not lock any views that already reference it, so under that circumstance it is possible to alter the contents of a locked array via a previously created writeable view onto it.) Attempting to change a non-writeable array raises a RuntimeError exception.</source>
          <target state="translated">データ領域に書き込むことができます。これを False に設定すると、データがロックされ、読み取り専用になります。ビュー(スライスなど)は、作成時にベース配列からWRITEABLEを継承しますが、書き込み可能な配列のビューは、その後ベース配列が書き込み可能なままロックされることがあります(逆は真ではありません)。(逆は真ではなく、ロックされた配列のビューを書き込み可能にすることはできません。しかし、現在のところ、ベースオブジェクトをロックしても、すでに参照しているビューはロックされないので、そのような状況下では、以前に作成された書き込み可能なビューを介して、ロックされた配列の内容を変更することが可能です)。書き込み不可能な配列を変更しようとすると、RuntimeError 例外が発生します。</target>
        </trans-unit>
        <trans-unit id="dfe7ced9a654feaf927f01f408558bf43f63134c" translate="yes" xml:space="preserve">
          <source>The data area is in C-style contiguous order (last index varies the fastest).</source>
          <target state="translated">データ領域はC形式で連続しています(最後のインデックスが最も早く変化します)。</target>
        </trans-unit>
        <trans-unit id="28271e4f2d83215b5c3293be14583eebd0638934" translate="yes" xml:space="preserve">
          <source>The data area is in Fortran-style contiguous order (first index varies the fastest).</source>
          <target state="translated">データ領域はFortran形式の連続した順序(最初のインデックスが最も速い順に変化します)です。</target>
        </trans-unit>
        <trans-unit id="a2e621a0b9254b737a1faf535f1456a6f33c01ae" translate="yes" xml:space="preserve">
          <source>The data area is owned by this array.</source>
          <target state="translated">データ領域はこの配列が所有しています。</target>
        </trans-unit>
        <trans-unit id="ca9e054ad351441ecdb18cea4952500858e11b12" translate="yes" xml:space="preserve">
          <source>The data area represents a (well-behaved) copy whose information should be transferred back to the original when &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">データ領域は（適切に動作する）コピーを表し、その情報は&lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;が呼び出されたときに元に戻されます。</target>
        </trans-unit>
        <trans-unit id="15eb3cf2a1c1abdf07a79e9fe9ea7b5a63c62afd" translate="yes" xml:space="preserve">
          <source>The data in the array is returned as a single string. This function is similar to &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt;, the difference being that &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt; also returns information on the kind of array and its data type.</source>
          <target state="translated">配列のデータは単一の文字列として返されます。この関数は&lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt;に似ていますが、&lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt;は配列の種類とそのデータ型に関する情報も返す点が異なります。</target>
        </trans-unit>
        <trans-unit id="4cbbe8ca710f692f60ad1bfe0fc2af00b27f6fa9" translate="yes" xml:space="preserve">
          <source>The data in the same field can be heterogeneous, they will be promoted to the highest data type. This method is intended for creating smaller record arrays. If used to create large array without formats defined</source>
          <target state="translated">同じフィールド内のデータは異種である可能性があり、それらは最も高いデータ型に昇格します。このメソッドは、より小さなレコード配列を作成するためのものです。フォーマットが定義されていない大きな配列を作成するために使用される場合</target>
        </trans-unit>
        <trans-unit id="f030fb38724d73d189a884d6cd4eaca4e1c69e90" translate="yes" xml:space="preserve">
          <source>The data is in a single, C-style contiguous segment.</source>
          <target state="translated">データは1つのCスタイルの連続したセグメントにあります。</target>
        </trans-unit>
        <trans-unit id="5f1d8da4b437441472e9916d9ae01c496d02e5d4" translate="yes" xml:space="preserve">
          <source>The data is in a single, Fortran-style contiguous segment.</source>
          <target state="translated">データはFortranスタイルの単一の連続セグメントにあります。</target>
        </trans-unit>
        <trans-unit id="56a1a480524e7bf67ab594cb10c3c6101b00713c" translate="yes" xml:space="preserve">
          <source>The data of the resulting array will not be byteswapped, but will be interpreted correctly.</source>
          <target state="translated">結果として得られる配列のデータはバイトスワップされず、正しく解釈されます。</target>
        </trans-unit>
        <trans-unit id="b88d2dbaff9987ad87362817ef4a120d93a6244e" translate="yes" xml:space="preserve">
          <source>The data to be histogrammed.</source>
          <target state="translated">ヒストグラム化するデータ。</target>
        </trans-unit>
        <trans-unit id="5386b778229b14d65914edc6d972b4efb28b5001" translate="yes" xml:space="preserve">
          <source>The data type object associated with the array can be found in the &lt;a href=&quot;generated/numpy.ndarray.dtype#numpy.ndarray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; attribute:</source>
          <target state="translated">配列に関連付けられたデータ型オブジェクトは、&lt;a href=&quot;generated/numpy.ndarray.dtype#numpy.ndarray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;属性にあります。</target>
        </trans-unit>
        <trans-unit id="1c7886ffa6332318e280aa7625497d4df1ee7f24" translate="yes" xml:space="preserve">
          <source>The data type of &lt;code&gt;rep&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rep&lt;/code&gt; のデータ型。</target>
        </trans-unit>
        <trans-unit id="4b822d3fbc39f811ebad48ba4194f76d214d3123" translate="yes" xml:space="preserve">
          <source>The data type of an operand with this flag should be either &lt;a href=&quot;c-api.dtype#c.NPY_BOOL&quot;&gt;&lt;code&gt;NPY_BOOL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_MASK&quot;&gt;&lt;code&gt;NPY_MASK&lt;/code&gt;&lt;/a&gt;, or a struct dtype whose fields are all valid mask dtypes. In the latter case, it must match up with a struct operand being WRITEMASKED, as it is specifying a mask for each field of that array.</source>
          <target state="translated">このフラグを持つオペランドのデータ型は、&lt;a href=&quot;c-api.dtype#c.NPY_BOOL&quot;&gt; &lt;code&gt;NPY_BOOL&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;c-api.dtype#c.NPY_MASK&quot;&gt; &lt;code&gt;NPY_MASK&lt;/code&gt; &lt;/a&gt;、またはフィールドがすべて有効なマスクdtypeであるstruct dtypeのいずれかである必要があります。後者の場合、その配列の各フィールドのマスクを指定しているため、構造体のオペランドがWRITEMASKEDであることと一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="11db59fda83e28216c250b45f855268127882d3e" translate="yes" xml:space="preserve">
          <source>The data type of the array; default: float. For binary input data, the data must be in exactly this format.</source>
          <target state="translated">配列のデータ型。デフォルトは float です。バイナリ入力データの場合、データは正確にこの形式でなければなりません。</target>
        </trans-unit>
        <trans-unit id="6121c8d9cd39c4f61e9ffef0d098e3b7d36639d6" translate="yes" xml:space="preserve">
          <source>The data type of the output of &lt;code&gt;vectorized&lt;/code&gt; is determined by calling the function with the first element of the input. This can be avoided by specifying the &lt;code&gt;otypes&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;vectorized&lt;/code&gt; された出力のデータ型は、入力の最初の要素で関数を呼び出すことによって決定されます。これは、 &lt;code&gt;otypes&lt;/code&gt; 引数を指定することで回避できます。</target>
        </trans-unit>
        <trans-unit id="bc2814a7f847db35d30b7458174ec64d03a7e7a5" translate="yes" xml:space="preserve">
          <source>The data type of the view. The dtype size of the view can not be larger than that of the array itself.</source>
          <target state="translated">ビューのデータ型。ビューのdtypeのサイズは、配列自体のサイズより大きくすることはできません。</target>
        </trans-unit>
        <trans-unit id="99643c3f7e25f9a00992f90ee5d0bdd7cb79f63e" translate="yes" xml:space="preserve">
          <source>The data types of the values provided in &lt;a href=&quot;numpy.nditer.value#numpy.nditer.value&quot;&gt;&lt;code&gt;value&lt;/code&gt;&lt;/a&gt;. This may be different from the operand data types if buffering is enabled. Valid only before the iterator is closed.</source>
          <target state="translated">valueで提供される&lt;a href=&quot;numpy.nditer.value#numpy.nditer.value&quot;&gt; &lt;code&gt;value&lt;/code&gt; &lt;/a&gt;のデータ型。これは、バッファリングが有効になっている場合、オペランドのデータ型と異なる場合があります。イテレータが閉じられる前にのみ有効です。</target>
        </trans-unit>
        <trans-unit id="9d016fef105a6db00651ac782a1c7e9c999e6600" translate="yes" xml:space="preserve">
          <source>The data-type is an important abstraction of the ndarray. Operations will look to the data-type to provide the key functionality that is needed to operate on the array. This functionality is provided in the list of function pointers pointed to by the &amp;lsquo;f&amp;rsquo; member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure. In this way, the number of data-types can be extended simply by providing a &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure with suitable function pointers in the &amp;lsquo;f&amp;rsquo; member. For built-in types there are some optimizations that by-pass this mechanism, but the point of the data- type abstraction is to allow new data-types to be added.</source>
          <target state="translated">データ型は、ndarrayの重要な抽象化です。操作では、データ型を参照して、アレイの操作に必要な主要な機能を提供します。この機能は、&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;構造体の'f'メンバーが指す関数ポインターのリストで提供されます。このように、&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;構造体に 'f'メンバーの適切な関数ポインターを提供するだけで、データ型の数を拡張できます。組み込み型の場合、このメカニズムを回避するいくつかの最適化がありますが、データ型の抽象化のポイントは、新しいデータ型を追加できるようにすることです。</target>
        </trans-unit>
        <trans-unit id="b58fbdafeaa8107e58c408c096a3cb8ca5d659d7" translate="yes" xml:space="preserve">
          <source>The data-type of the returned array.</source>
          <target state="translated">返された配列のデータ型。</target>
        </trans-unit>
        <trans-unit id="5c8d679fa5d2836b35d4e189ea3c3c42c4a9bfcc" translate="yes" xml:space="preserve">
          <source>The data-type used to interpret the file contents. Default is &lt;code&gt;uint8&lt;/code&gt;.</source>
          <target state="translated">ファイルの内容を解釈するために使用されるデータ型。デフォルトは &lt;code&gt;uint8&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e1e17b816f5aa8d3b539033dd4f8579bd040ce7c" translate="yes" xml:space="preserve">
          <source>The data-type used to represent the intermediate results. Defaults to the data-type of the output array if such is provided, or the the data-type of the input array if no output array is provided.</source>
          <target state="translated">中間結果の表現に用いられるデータ型.デフォルトは,出力配列が指定されている場合はそのデータ型,出力配列が指定されていない場合は入力配列のデータ型となります.</target>
        </trans-unit>
        <trans-unit id="932e882a29033e270334b0a0ca27c7a0b749d38c" translate="yes" xml:space="preserve">
          <source>The data-type-descriptor object of the base-type.</source>
          <target state="translated">ベースタイプのdata-type-descriptorオブジェクト。</target>
        </trans-unit>
        <trans-unit id="d6987a7425e0ff97a8320c32ec6abc8ee62f4f4d" translate="yes" xml:space="preserve">
          <source>The datatype determines which of &amp;lsquo;mergesort&amp;rsquo; or &amp;lsquo;timsort&amp;rsquo; is actually used, even if &amp;lsquo;mergesort&amp;rsquo; is specified. User selection at a finer scale is not currently available.</source>
          <target state="translated">データ型は、「mergesort」が指定されている場合でも、「mergesort」または「timsort」のどちらが実際に使用されるかを決定します。より細かいスケールでのユーザー選択は現在利用できません。</target>
        </trans-unit>
        <trans-unit id="f8494cadb009486b1d5ee5b6a13352cbf85e331c" translate="yes" xml:space="preserve">
          <source>The datetime API is &lt;em&gt;experimental&lt;/em&gt; in 1.7.0, and may undergo changes in future versions of NumPy.</source>
          <target state="translated">日時APIは1.7.0で&lt;em&gt;実験的&lt;/em&gt;であり、NumPyの将来のバージョンで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="5a29e38fde2fbef6d304ea68f9f28e90e826577d" translate="yes" xml:space="preserve">
          <source>The datetime object represents a single moment in time. If two datetimes have different units, they may still be representing the same moment of time, and converting from a bigger unit like months to a smaller unit like days is considered a &amp;lsquo;safe&amp;rsquo; cast because the moment of time is still being represented exactly.</source>
          <target state="translated">datetimeオブジェクトは、1つの瞬間を表します。2つの日時の単位が異なる場合でも、それらは同じ瞬間を表している可能性があり、月のような大きな単位から日のような小さな単位への変換は、瞬間がまだ正確に表されているため、「安全な」キャストと見なされます。</target>
        </trans-unit>
        <trans-unit id="96194d206533dca35ec887829a70fc8982e7d450" translate="yes" xml:space="preserve">
          <source>The datetime string parser in NumPy 1.6 is very liberal in what it accepts, and silently allows invalid input without raising errors. The parser in NumPy 1.7 is quite strict about only accepting ISO 8601 dates, with a few convenience extensions. 1.6 always creates microsecond (us) units by default, whereas 1.7 detects a unit based on the format of the string. Here is a comparison.:</source>
          <target state="translated">NumPy 1.6のdatetime文字列パーサは、受け入れるものに対して非常に自由で、エラーを発生させることなく、無効な入力を黙って許可します。NumPy 1.7のパーサは、ISO 8601の日付のみを受け入れるという非常に厳格なものですが、いくつかの便利な拡張機能があります。1.6ではデフォルトで常にマイクロ秒(us)単位を作成しますが、1.7では文字列のフォーマットに基づいて単位を検出します。以下に比較を示します。</target>
        </trans-unit>
        <trans-unit id="1369383d5a514fcfed8df04d6ed924de54d6f3b1" translate="yes" xml:space="preserve">
          <source>The datetime type works with many common NumPy functions, for example &lt;a href=&quot;generated/numpy.arange#numpy.arange&quot;&gt;&lt;code&gt;arange&lt;/code&gt;&lt;/a&gt; can be used to generate ranges of dates.</source>
          <target state="translated">日時型は、多くの一般的なNumPy関数で機能します。たとえば、&lt;a href=&quot;generated/numpy.arange#numpy.arange&quot;&gt; &lt;code&gt;arange&lt;/code&gt; &lt;/a&gt;を使用して日付の範囲を生成できます。</target>
        </trans-unit>
        <trans-unit id="60d7f83834880a987611358eebe758ac593dc7d2" translate="yes" xml:space="preserve">
          <source>The decomposition is performed using LAPACK routine &lt;code&gt;_gesdd&lt;/code&gt;.</source>
          <target state="translated">分解はLAPACKルーチン &lt;code&gt;_gesdd&lt;/code&gt; を使用して実行されます。</target>
        </trans-unit>
        <trans-unit id="e1516fc7b62e4a0344208958aa595053689db869" translate="yes" xml:space="preserve">
          <source>The decorated test &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">装飾されたテスト &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9657b7f30a96eb6a9709525e36cff8e84658cbb" translate="yes" xml:space="preserve">
          <source>The decorator itself is decorated with the &lt;code&gt;nose.tools.make_decorator&lt;/code&gt; function in order to transmit function name, and various other metadata.</source>
          <target state="translated">関数名やその他のさまざまなメタデータを送信するために、デコレータ自体が &lt;code&gt;nose.tools.make_decorator&lt;/code&gt; 関数で修飾されています。</target>
        </trans-unit>
        <trans-unit id="4a37da8a9aa52a4088272dd54ccf6dae2a209ad8" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;atol&lt;/code&gt; is not appropriate for comparing numbers that are much smaller than one (see Notes).</source>
          <target state="translated">デフォルトの &lt;code&gt;atol&lt;/code&gt; は、1より小さい数値の比較には適していません（「注意」を参照）。</target>
        </trans-unit>
        <trans-unit id="cb5293865f62263e0a19bbfa34c77f6486814f1d" translate="yes" xml:space="preserve">
          <source>The default __array_priority__ of matrix objects is 10.0, and therefore mixed operations with ndarrays always produce matrices.</source>
          <target state="translated">行列オブジェクトのデフォルトの __array_priority__は 10.0 であるため、ndarrays との混合操作は常に行列を生成します。</target>
        </trans-unit>
        <trans-unit id="cd69cae26ca025156d4d72a557a24e650bb3e040" translate="yes" xml:space="preserve">
          <source>The default character, this is returned if none of the characters in &lt;code&gt;typechars&lt;/code&gt; matches a character in &lt;code&gt;typeset&lt;/code&gt;.</source>
          <target state="translated">デフォルトの文字 &lt;code&gt;typechars&lt;/code&gt; の文字もtypesetの文字と一致しない場合に返され &lt;code&gt;typeset&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9f67bac25f1e9fa1addb151018aeaf9def3b945" translate="yes" xml:space="preserve">
          <source>The default data type in NumPy is &lt;code&gt;float_&lt;/code&gt;.</source>
          <target state="translated">NumPyのデフォルトのデータ型は &lt;code&gt;float_&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1cb916c2a199dec22e3c7d35ff5ca943ade2af02" translate="yes" xml:space="preserve">
          <source>The default data type: &lt;code&gt;float_&lt;/code&gt;.</source>
          <target state="translated">デフォルトのデータ型： &lt;code&gt;float_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="585140e706eb572d257d276596c7c62733d99ac8" translate="yes" xml:space="preserve">
          <source>The default fill value.</source>
          <target state="translated">デフォルトの塗りつぶし値。</target>
        </trans-unit>
        <trans-unit id="a6dbb84bde95674721b5026ade7be2a1d41460db" translate="yes" xml:space="preserve">
          <source>The default filling value depends on the datatype of the input array or the type of the input scalar:</source>
          <target state="translated">デフォルトの充填値は,入力配列のデータ型または入力スカラの型に依存します.</target>
        </trans-unit>
        <trans-unit id="d172f7f7da97c607ca46d821dc996e8763c04a60" translate="yes" xml:space="preserve">
          <source>The default for busday functions is that the only valid days are Monday through Friday (the usual business days). The implementation is based on a &amp;ldquo;weekmask&amp;rdquo; containing 7 Boolean flags to indicate valid days; custom weekmasks are possible that specify other sets of valid days.</source>
          <target state="translated">busday関数のデフォルトでは、有効な日は月曜日から金曜日（通常の営業日）のみです。実装は、有効な日を示す7つのブールフラグを含む「週マスク」に基づいています。有効な曜日の他のセットを指定するカスタム週マスクが可能です。</target>
        </trans-unit>
        <trans-unit id="b9e6f3b39a9841c2072fe28c903a4873d59b58cf" translate="yes" xml:space="preserve">
          <source>The default for most operations, raises an exception if an index is out of bounds.</source>
          <target state="translated">ほとんどの操作のデフォルトでは、インデックスが範囲外の場合に例外を発生させます。</target>
        </trans-unit>
        <trans-unit id="0b3aadfe669f7dc7282a8bf3bc7021b967d5f363" translate="yes" xml:space="preserve">
          <source>The default is not to change the current behavior.</source>
          <target state="translated">デフォルトでは、現在の動作を変更しないようになっています。</target>
        </trans-unit>
        <trans-unit id="13f5430198109332da2b945e817fa963554a0039" translate="yes" xml:space="preserve">
          <source>The default iterator of an ndarray object is the default Python iterator of a sequence type. Thus, when the array object itself is used as an iterator. The default behavior is equivalent to:</source>
          <target state="translated">ndarrayオブジェクトのデフォルトのイテレータは、配列型のPythonのデフォルトのイテレータです。このように、配列オブジェクト自体をイテレータとして使用する場合。デフォルトの動作と同等になります。</target>
        </trans-unit>
        <trans-unit id="d0a1e3c85492f9a28cfa2d6a52018d6303212281" translate="yes" xml:space="preserve">
          <source>The default normalization has the direct transforms unscaled and the inverse transforms are scaled by</source>
          <target state="translated">デフォルトの正規化では、直接変換はスケーリングされず、逆変換は</target>
        </trans-unit>
        <trans-unit id="d79f5666dde2a74098ca71f007435f35059e5b3e" translate="yes" xml:space="preserve">
          <source>The default threshold to detect rank deficiency is a test on the magnitude of the singular values of &lt;code&gt;M&lt;/code&gt;. By default, we identify singular values less than &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; as indicating rank deficiency (with the symbols defined above). This is the algorithm MATLAB uses [1]. It also appears in &lt;em&gt;Numerical recipes&lt;/em&gt; in the discussion of SVD solutions for linear least squares [2].</source>
          <target state="translated">ランクの不足を検出するための既定のしきい値は、 &lt;code&gt;M&lt;/code&gt; の特異値の大きさのテストです。デフォルトでは、 &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; 未満の特異値は、ランクの不足を示すものとして識別されます（上で定義されたシンボルを使用）。これは、MATLABが使用するアルゴリズムです[1]。また、線形最小二乗法のSVDソリューションの説明の&lt;em&gt;数値レシピ&lt;/em&gt;にも記載されています[2]。</target>
        </trans-unit>
        <trans-unit id="fabcee56c3086c9123fae22826809a0d986ec9e3" translate="yes" xml:space="preserve">
          <source>The default type to use when no dtype is explicitly specified, for example when calling np.zero(shape). This is equivalent to &lt;a href=&quot;#c.NPY_DOUBLE&quot;&gt;&lt;code&gt;NPY_DOUBLE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">np.zero（shape）を呼び出すときなど、dtypeが明示的に指定されていない場合に使用するデフォルトのタイプ。これは&lt;a href=&quot;#c.NPY_DOUBLE&quot;&gt; &lt;code&gt;NPY_DOUBLE&lt;/code&gt; &lt;/a&gt;と同等です。</target>
        </trans-unit>
        <trans-unit id="a62d7fdf404d547735e1b655e9c601557613abc2" translate="yes" xml:space="preserve">
          <source>The default valid days are Monday through Friday (&amp;ldquo;business days&amp;rdquo;). A busdaycalendar object can be specified with any set of weekly valid days, plus an optional &amp;ldquo;holiday&amp;rdquo; dates that always will be invalid.</source>
          <target state="translated">デフォルトの有効日は月曜日から金曜日（「営業日」）です。busdaycalendarオブジェクトは、週単位の有効な日と、常に無効になるオプションの「休日」の日付のセットで指定できます。</target>
        </trans-unit>
        <trans-unit id="203757e2bdf5bbe5e651d506c476783cf6e50edd" translate="yes" xml:space="preserve">
          <source>The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order. The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for the alternatives above. For example, any of &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;biggish&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">デフォルト値（ 'S'）の場合、現在のバイト順が入れ替わります。コードは、上記の代替案の &lt;code&gt;new_order&lt;/code&gt; の最初の文字で大文字と小文字を区別しないチェックを行います。たとえば、ビッグエンディアンを指定するには、「B」、「b」、「biggish」のいずれも有効です。</target>
        </trans-unit>
        <trans-unit id="19a5ab6c7c39a905e845eb64d8df075515c15636" translate="yes" xml:space="preserve">
          <source>The defining property of the antiderivative:</source>
          <target state="translated">反誘導体の定義的な性質。</target>
        </trans-unit>
        <trans-unit id="a1b5640a64fc73d8755c0223b335feaa121479d8" translate="yes" xml:space="preserve">
          <source>The definition of advanced indexing means that &lt;code&gt;x[(1,2,3),]&lt;/code&gt; is fundamentally different than &lt;code&gt;x[(1,2,3)]&lt;/code&gt;. The latter is equivalent to &lt;code&gt;x[1,2,3]&lt;/code&gt; which will trigger basic selection while the former will trigger advanced indexing. Be sure to understand why this occurs.</source>
          <target state="translated">高度割り出し手段の定義は、その &lt;code&gt;x[(1,2,3),]&lt;/code&gt; は基本的に異なる &lt;code&gt;x[(1,2,3)]&lt;/code&gt; 。後者は &lt;code&gt;x[1,2,3]&lt;/code&gt; と同等で、基本的な選択をトリガーしますが、前者は高度なインデックス作成をトリガーします。これが発生する理由を必ず理解してください。</target>
        </trans-unit>
        <trans-unit id="61496dee2f3816bd693a7ce0398282c8ea47a960" translate="yes" xml:space="preserve">
          <source>The definition of correlation above is not unique and sometimes correlation may be defined differently. Another common definition is:</source>
          <target state="translated">上記の相関関係の定義は一意ではなく、場合によっては異なる定義になることもあります。もう一つの一般的な定義は</target>
        </trans-unit>
        <trans-unit id="e5f33fe407bab51cea8bacccfd88b8a5036810dc" translate="yes" xml:space="preserve">
          <source>The degree of the series.</source>
          <target state="translated">シリーズの度合。</target>
        </trans-unit>
        <trans-unit id="155faa0de8c44a325761ca30fe7a5e7dbf74e6e4" translate="yes" xml:space="preserve">
          <source>The depends list contains paths to files or directories that the sources of the extension module depend on. If any path in the depends list is newer than the extension module, then the module will be rebuilt.</source>
          <target state="translated">依存リストには、拡張モジュールのソースが依存している ファイルやディレクトリへのパスが含まれています。もし depends リストのパスが拡張モジュールよりも新しいものであれば、 モジュールは再構築されます。</target>
        </trans-unit>
        <trans-unit id="63644093036e4f3b360649808afd2f026edeffe7" translate="yes" xml:space="preserve">
          <source>The derivation of the t-distribution was first published in 1908 by William Gosset while working for the Guinness Brewery in Dublin. Due to proprietary issues, he had to publish under a pseudonym, and so he used the name Student.</source>
          <target state="translated">t分布の派生は、ダブリンのギネス醸造所で働いていたウィリアム・ゴセットが1908年に初めて発表しました。プロプライエタリな問題のため、彼は偽名で出版しなければならなかったので、スチューデントという名前を使いました。</target>
        </trans-unit>
        <trans-unit id="7db2e5319fb072c88d575bc92b04bca324abdb47" translate="yes" xml:space="preserve">
          <source>The derivative of the polynomial</source>
          <target state="translated">多項式の微分</target>
        </trans-unit>
        <trans-unit id="e38da7322eec5dfeb19db7a40e7e799054f3e9fa" translate="yes" xml:space="preserve">
          <source>The desc member of the PyCObject returned from __array_struct__ was not specified. Usually, it was the object exposing the array (so that a reference to it could be kept and destroyed when the C-object was destroyed). Now it must be a tuple whose first element is a string with &amp;ldquo;PyArrayInterface Version #&amp;rdquo; and whose second element is the object exposing the array.</source>
          <target state="translated">__array_struct__から返されたPyCObjectのdescメンバーが指定されていません。通常、これは配列を公開するオブジェクトでした（Cオブジェクトが破棄されたときに、その参照を保持および破棄できるようにするため）。これは、最初の要素が「PyArrayInterface Version＃」の文字列で、2番目の要素が配列を公開するオブジェクトであるタプルである必要があります。</target>
        </trans-unit>
        <trans-unit id="d7dbcb2541cf001d7b26e25e4170575fd900c8ee" translate="yes" xml:space="preserve">
          <source>The description of the fourth element of the header therefore has become: &amp;ldquo;The next 4 bytes form a little-endian unsigned int: the length of the header data HEADER_LEN.&amp;rdquo;</source>
          <target state="translated">したがって、ヘッダーの4番目の要素の説明は次のようになっています。</target>
        </trans-unit>
        <trans-unit id="f4a52cabb32fca3b74ad0388e9c1cbe1cf8d25b1" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array, e.g., &lt;code&gt;numpy.int8&lt;/code&gt;. Default is &lt;code&gt;numpy.float64&lt;/code&gt;.</source>
          <target state="translated">配列に必要なデータ型（例： &lt;code&gt;numpy.int8&lt;/code&gt; )。デフォルトは &lt;code&gt;numpy.float64&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f7534f7cefc524ae1e988328a3c98ad10f344592" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array. If not given, then the type will be determined as the minimum type required to hold the objects in the sequence. This argument can only be used to &amp;lsquo;upcast&amp;rsquo; the array. For downcasting, use the .astype(t) method.</source>
          <target state="translated">配列に必要なデータ型。指定しない場合、タイプは、シーケンス内のオブジェクトを保持するために必要な最小タイプとして決定されます。この引数は、配列を「アップキャスト」するためにのみ使用できます。ダウンキャストには、.astype（t）メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="50dd3f94578e7376ef4b1fc5b09b342ebb1fed2e" translate="yes" xml:space="preserve">
          <source>The desired data-type for the matrix, default is float.</source>
          <target state="translated">デフォルトは float です.</target>
        </trans-unit>
        <trans-unit id="07d678da86d17478a0143d6947f08f3fa51a5f65" translate="yes" xml:space="preserve">
          <source>The desired data-type for the matrix, default is np.float64.</source>
          <target state="translated">デフォルトは np.float64 です.</target>
        </trans-unit>
        <trans-unit id="d07509f4b4964e751a91c8805000083d2ee4926c" translate="yes" xml:space="preserve">
          <source>The desired data-type. By default, the data-type is determined from &lt;code&gt;formats&lt;/code&gt;, &lt;code&gt;names&lt;/code&gt;, &lt;code&gt;titles&lt;/code&gt;, &lt;code&gt;aligned&lt;/code&gt; and &lt;code&gt;byteorder&lt;/code&gt;.</source>
          <target state="translated">目的のデータ型。デフォルトでは、データ型は、 &lt;code&gt;formats&lt;/code&gt; 、 &lt;code&gt;names&lt;/code&gt; 、 &lt;code&gt;titles&lt;/code&gt; 、 &lt;code&gt;byteorder&lt;/code&gt; &lt;code&gt;aligned&lt;/code&gt; 、バイトオーダーから決定されます。</target>
        </trans-unit>
        <trans-unit id="3c998f357ef80cf65beb1c4220aff1c69081dd53" translate="yes" xml:space="preserve">
          <source>The desired shape of the array. If &lt;code&gt;mode == 'r'&lt;/code&gt; and the number of remaining bytes after &lt;code&gt;offset&lt;/code&gt; is not a multiple of the byte-size of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, you must specify &lt;a href=&quot;numpy.memmap.shape#numpy.memmap.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. By default, the returned array will be 1-D with the number of elements determined by file size and data-type.</source>
          <target state="translated">アレイの目的の形状。場合 &lt;code&gt;mode == 'r'&lt;/code&gt; と後の残りのバイト数 &lt;code&gt;offset&lt;/code&gt; バイトサイズの倍数でない&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; は&lt;/a&gt;、次のように指定しなければならない&lt;a href=&quot;numpy.memmap.shape#numpy.memmap.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;。デフォルトでは、返される配列は1次元で、要素の数はファイルサイズとデータ型によって決まります。</target>
        </trans-unit>
        <trans-unit id="cdd86af715375b55e1d483d875bf1753af5d922f" translate="yes" xml:space="preserve">
          <source>The desired shape of the iterator. This allows &lt;code&gt;allocate&lt;/code&gt; operands with a dimension mapped by op_axes not corresponding to a dimension of a different operand to get a value not equal to 1 for that dimension.</source>
          <target state="translated">イテレータの目的の形状。これにより、異なるオペランドの次元に対応しないop_axesによってマップされた次元を持つオペランドを &lt;code&gt;allocate&lt;/code&gt; て、その次元に対して1以外の値を取得できます。</target>
        </trans-unit>
        <trans-unit id="84971317bba10bc74f9aaf650dccf1acca028d13" translate="yes" xml:space="preserve">
          <source>The desired, expected object.</source>
          <target state="translated">目的とする、期待されるオブジェクト。</target>
        </trans-unit>
        <trans-unit id="40c65673e654df212bffc77b7c4cf508b802ea94" translate="yes" xml:space="preserve">
          <source>The determinant is computed via LU factorization using the LAPACK routine &lt;code&gt;z/dgetrf&lt;/code&gt;.</source>
          <target state="translated">行列式は、LAPACKルーチン &lt;code&gt;z/dgetrf&lt;/code&gt; を使用したLU分解によって計算されます。</target>
        </trans-unit>
        <trans-unit id="94f9591a378d3f5d467509648f89e89bcee5af83" translate="yes" xml:space="preserve">
          <source>The determinant of a 2-D array &lt;code&gt;[[a, b], [c, d]]&lt;/code&gt; is &lt;code&gt;ad - bc&lt;/code&gt;:</source>
          <target state="translated">2次元配列 &lt;code&gt;[[a, b], [c, d]]&lt;/code&gt; の行列式は &lt;code&gt;ad - bc&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="67af8ebad34e1dbafff04ba3dd64dccd7934523b" translate="yes" xml:space="preserve">
          <source>The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:</source>
          <target state="translated">2次元配列[[a,b],[c,d]]の行列式はad-bcである.</target>
        </trans-unit>
        <trans-unit id="e56bde2e38a2da31d0e2d0f24b802753579a52ca" translate="yes" xml:space="preserve">
          <source>The determinant of a square Vandermonde matrix is the product of the differences between the values of the input vector:</source>
          <target state="translated">正方形のヴァンデルモンデ行列の行列式は、入力ベクトルの値の差の積である。</target>
        </trans-unit>
        <trans-unit id="34c13c034ad3086185d61530fb01b7940b4e4527" translate="yes" xml:space="preserve">
          <source>The dictionary contains three keys:</source>
          <target state="translated">辞書には3つのキーが含まれています。</target>
        </trans-unit>
        <trans-unit id="bd944e951e9799c3343f288ae6c347a06ac11e23" translate="yes" xml:space="preserve">
          <source>The dictionary is indexed by keys that are the names of the fields. Each entry in the dictionary is a tuple fully describing the field:</source>
          <target state="translated">辞書は、フィールドの名前であるキーによってインデックス化されます。辞書の各エントリは、フィールドを完全に記述したタプルです。</target>
        </trans-unit>
        <trans-unit id="162f606f6e0310c46fbb8198beb3cd00b92c6224" translate="yes" xml:space="preserve">
          <source>The difference of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">要素ごとの &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の違い。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="07942ea7f660d79ad7e6e73de1169306977fb28a" translate="yes" xml:space="preserve">
          <source>The differences between consecutive elements of an array.</source>
          <target state="translated">配列の連続した要素間の差。</target>
        </trans-unit>
        <trans-unit id="f62761da3d9dc37e999ceb43677343bc26056903" translate="yes" xml:space="preserve">
          <source>The differences. Loosely, this is &lt;code&gt;ary.flat[1:] - ary.flat[:-1]&lt;/code&gt;.</source>
          <target state="translated">違い。大まかに言うと、これは &lt;code&gt;ary.flat[1:] - ary.flat[:-1]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e2f3cc77955898f687e1a89336e253a34038e978" translate="yes" xml:space="preserve">
          <source>The different types of interpolation can be visualized graphically:</source>
          <target state="translated">補間の種類の違いをグラフィカルに可視化することができます。</target>
        </trans-unit>
        <trans-unit id="0f5b79f9447070c03232c2c0b7664e2645b9b9cd" translate="yes" xml:space="preserve">
          <source>The dimension over which bit-packing is done. &lt;code&gt;None&lt;/code&gt; implies packing the flattened array.</source>
          <target state="translated">ビットパッキングが行われる次元。 &lt;code&gt;None&lt;/code&gt; 、フラット化された配列をパックすることを意味しません。</target>
        </trans-unit>
        <trans-unit id="dfa565d5af13bd83cac275f338d5f2b3b4b7544c" translate="yes" xml:space="preserve">
          <source>The dimension over which bit-unpacking is done. &lt;code&gt;None&lt;/code&gt; implies unpacking the flattened array.</source>
          <target state="translated">ビットアンパッキングが行われる次元。 &lt;code&gt;None&lt;/code&gt; は、フラット化された配列をアンパックすることを意味します。</target>
        </trans-unit>
        <trans-unit id="db3013243a57c5e7a96cffb61f2f631ca09ac6ac" translate="yes" xml:space="preserve">
          <source>The dimensionality of each input/output of an elementary function is defined by its core dimensions (zero core dimensions correspond to a scalar input/output). The core dimensions are mapped to the last dimensions of the input/output arrays.</source>
          <target state="translated">初等関数の各入出力の次元性は,そのコア次元によって定義される(コア次元がゼロの場合はスカラー入出力に対応する).コア次元は,入出力配列の最後の次元にマップされます.</target>
        </trans-unit>
        <trans-unit id="bbd2ce0767215831bee7913f7b1f8113fac9632a" translate="yes" xml:space="preserve">
          <source>The dimensionality of the output is equal to the greatest of: * the dimensionality of all the inputs * the depth to which the input list is nested</source>
          <target state="translated">出力の次元は,以下のうち最大のものに等しい.*すべての入力の次元性*入力リストが入れ子にされる深さ</target>
        </trans-unit>
        <trans-unit id="169b189aee12891e66fa6116bc6ee28490426b80" translate="yes" xml:space="preserve">
          <source>The dimensions beyond the core dimensions are called &amp;ldquo;loop&amp;rdquo; dimensions. In the above example, this corresponds to &lt;code&gt;(3, 5)&lt;/code&gt;.</source>
          <target state="translated">コア寸法を超える寸法は、「ループ」寸法と呼ばれます。上記の例では、これは &lt;code&gt;(3, 5)&lt;/code&gt; 対応します。</target>
        </trans-unit>
        <trans-unit id="f513b3b85fff0b6f84da786029bafd05ba0e618b" translate="yes" xml:space="preserve">
          <source>The dimensions of the iterator.</source>
          <target state="translated">イテレータの寸法。</target>
        </trans-unit>
        <trans-unit id="5ecf20054a40c0975aa34c7a074c143c2ad5eb76" translate="yes" xml:space="preserve">
          <source>The dimensions of the returned array, must be non-negative. If no argument is given a single Python float is returned.</source>
          <target state="translated">返される配列の次元は、非負でなければなりません。引数が与えられなかった場合は、単一の Python float が返されます。</target>
        </trans-unit>
        <trans-unit id="1962b62fe3553b6c10eaad6d82d38bd0027b1eca" translate="yes" xml:space="preserve">
          <source>The direction where to look for the next representable value of &lt;code&gt;x1&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; の次の表現可能な値を探す方向。 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状にブロードキャスト可能でなければなりません（これが出力の形状になります）。</target>
        </trans-unit>
        <trans-unit id="712dcab95da2336dfeef7d45bac02b258dccf977" translate="yes" xml:space="preserve">
          <source>The discount rate.</source>
          <target state="translated">割引率です。</target>
        </trans-unit>
        <trans-unit id="0706686baa5fd5b913d978e6a5e5bd325098b037" translate="yes" xml:space="preserve">
          <source>The discrete convolution operation is defined as</source>
          <target state="translated">離散畳み込み演算は次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="12a1ae320e29367bfe14ad50414fe949007c38e7" translate="yes" xml:space="preserve">
          <source>The docstring for the function. If &lt;code&gt;None&lt;/code&gt;, the docstring will be the &lt;code&gt;pyfunc.__doc__&lt;/code&gt;.</source>
          <target state="translated">関数のドキュメント文字列。場合 &lt;code&gt;None&lt;/code&gt; 、ドキュメンテーション文字列になります &lt;code&gt;pyfunc.__doc__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72a23a7f9d3c84d9ccb7d9d4e76905cf07195965" translate="yes" xml:space="preserve">
          <source>The docstring is taken from the input function to &lt;a href=&quot;#numpy.vectorize&quot;&gt;&lt;code&gt;vectorize&lt;/code&gt;&lt;/a&gt; unless it is specified:</source>
          <target state="translated">docstringは、指定されていない限り、&lt;a href=&quot;#numpy.vectorize&quot;&gt; &lt;code&gt;vectorize&lt;/code&gt; &lt;/a&gt;するために入力関数から取得されます。</target>
        </trans-unit>
        <trans-unit id="82bd10e4e262158659ec5e27575297c3e33fb51b" translate="yes" xml:space="preserve">
          <source>The doctests are run as if they are in a fresh Python instance which has executed &lt;code&gt;import numpy as np&lt;/code&gt;. Tests that are part of a SciPy subpackage will have that subpackage already imported. E.g. for a test in &lt;code&gt;scipy/linalg/tests/&lt;/code&gt;, the namespace will be created such that &lt;code&gt;from scipy import linalg&lt;/code&gt; has already executed.</source>
          <target state="translated">doctestは、 &lt;code&gt;import numpy as np&lt;/code&gt; 実行した新しいPythonインスタンス内にあるかのように実行されます。SciPyサブパッケージの一部であるテストには、そのサブパッケージがすでにインポートされています。たとえば、 &lt;code&gt;scipy/linalg/tests/&lt;/code&gt; 場合、 &lt;code&gt;from scipy import linalg&lt;/code&gt; がすでに実行されるように名前空間が作成されます。</target>
        </trans-unit>
        <trans-unit id="4e34de0083248d68455464ce3b6cb6cff4a615e4" translate="yes" xml:space="preserve">
          <source>The doctests can be run by adding the &lt;code&gt;doctests&lt;/code&gt; argument to the &lt;code&gt;test()&lt;/code&gt; call; for example, to run all tests (including doctests) for numpy.lib:</source>
          <target state="translated">doctestは、 &lt;code&gt;test()&lt;/code&gt; 呼び出しに &lt;code&gt;doctests&lt;/code&gt; 引数を追加することで実行できます。たとえば、numpy.libのすべてのテスト（doctestを含む）を実行するには：</target>
        </trans-unit>
        <trans-unit id="914dd900bd888e0ac2a856c709956c6c77b685df" translate="yes" xml:space="preserve">
          <source>The doctests can be run by the user/developer by adding the &lt;code&gt;doctests&lt;/code&gt; argument to the &lt;code&gt;test()&lt;/code&gt; call. For example, to run all tests (including doctests) for &lt;code&gt;numpy.lib&lt;/code&gt;:</source>
          <target state="translated">doctestは、 &lt;code&gt;test()&lt;/code&gt; 呼び出しに &lt;code&gt;doctests&lt;/code&gt; 引数を追加することにより、ユーザー/開発者が実行できます。たとえば、 &lt;code&gt;numpy.lib&lt;/code&gt; のすべてのテスト（doctestを含む）を実行するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="b01857d163ce7be746891e6a1ddb4df8d280228b" translate="yes" xml:space="preserve">
          <source>The domain of the converted series. If the value is None, the default domain of &lt;code&gt;kind&lt;/code&gt; is used.</source>
          <target state="translated">変換されたシリーズのドメイン。値がNoneの場合、デフォルトの &lt;code&gt;kind&lt;/code&gt; ドメインが使用されます。</target>
        </trans-unit>
        <trans-unit id="3910d27792e65700eaf0cb459a12293f622c5605" translate="yes" xml:space="preserve">
          <source>The drawn samples, of shape (size, alpha.ndim).</source>
          <target state="translated">描画されたサンプルの形状(size,alpha.ndim)。</target>
        </trans-unit>
        <trans-unit id="caba47af25cacb65ea654dc8b3910b7df6c6afc4" translate="yes" xml:space="preserve">
          <source>The drawn samples, of shape &lt;em&gt;size&lt;/em&gt;, if that was provided. If not, the shape is &lt;code&gt;(N,)&lt;/code&gt;.</source>
          <target state="translated">提供されている場合、形状&lt;em&gt;サイズ&lt;/em&gt;の描画されたサンプル。そうでない場合、形状は &lt;code&gt;(N,)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="40b0e929b6fe8b38b46b38ce838182fe7c7332dc" translate="yes" xml:space="preserve">
          <source>The drawn samples.</source>
          <target state="translated">描かれたサンプル。</target>
        </trans-unit>
        <trans-unit id="aa44e17b8461776ae7df4f43d6abddd8f6a24f76" translate="yes" xml:space="preserve">
          <source>The dtype object, which must be a &lt;code&gt;datetime64&lt;/code&gt; or &lt;code&gt;timedelta64&lt;/code&gt; type.</source>
          <target state="translated">でなければならないDTYPEオブジェクト、 &lt;code&gt;datetime64&lt;/code&gt; 又は &lt;code&gt;timedelta64&lt;/code&gt; タイプ。</target>
        </trans-unit>
        <trans-unit id="8fb6faafe66ffccb238a2fd43e44c5a7f5fbd5ca" translate="yes" xml:space="preserve">
          <source>The dtype of the masked array matches the dtype of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">マスクされた配列のdtypeは、 &lt;code&gt;arr&lt;/code&gt; のdtypeと一致します。</target>
        </trans-unit>
        <trans-unit id="a55d71e165e1e48cb124a8472e43c4880e17aca7" translate="yes" xml:space="preserve">
          <source>The dtype to convert</source>
          <target state="translated">変換する dtype</target>
        </trans-unit>
        <trans-unit id="5ecd0c1cb739e638a2efc7fc65026ccc752fcf9a" translate="yes" xml:space="preserve">
          <source>The dtype to convert.</source>
          <target state="translated">変換するdtype。</target>
        </trans-unit>
        <trans-unit id="0624587fa2f7d6454c0f9d5829dab19d01e4bd1b" translate="yes" xml:space="preserve">
          <source>The easiest way to understand the situation may be to think in terms of the result shape. There are two parts to the indexing operation, the subspace defined by the basic indexing (excluding integers) and the subspace from the advanced indexing part. Two cases of index combination need to be distinguished:</source>
          <target state="translated">一番わかりやすいのは、結果の形で考えることかもしれません。インデックス操作には2つの部分があり、基本的なインデックス付け(整数を除く)で定義された部分空間と、高度なインデックス付けの部分からの部分空間です。インデックスの組み合わせについては、2つのケースを区別する必要があります。</target>
        </trans-unit>
        <trans-unit id="f92b730683a3cb47168faa379ee22ac3235eed0f" translate="yes" xml:space="preserve">
          <source>The easy way to do conversions between polynomial basis sets is to use the convert method of a class instance.</source>
          <target state="translated">多項式基底集合間の変換を簡単に行う方法は、クラスインスタンスのconvertメソッドを使用することです。</target>
        </trans-unit>
        <trans-unit id="2fc5d8b78173f52a2c49af3f59f052a25e59fb4f" translate="yes" xml:space="preserve">
          <source>The edges to pass into &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt;に渡すエッジ</target>
        </trans-unit>
        <trans-unit id="b6f1be0a37063a8a4026cc94c7cf86f62cf5bdd8" translate="yes" xml:space="preserve">
          <source>The effect of broadcasting.</source>
          <target state="translated">放送の効果。</target>
        </trans-unit>
        <trans-unit id="a34abd23a6e4bdf2596a3b4673affad53721777d" translate="yes" xml:space="preserve">
          <source>The eigenvalues are computed using LAPACK routines &lt;code&gt;_syevd&lt;/code&gt;, &lt;code&gt;_heevd&lt;/code&gt;.</source>
          <target state="translated">固有値はLAPACKルーチン &lt;code&gt;_syevd&lt;/code&gt; 、 &lt;code&gt;_heevd&lt;/code&gt; を使用して計算されます。</target>
        </trans-unit>
        <trans-unit id="7701e5ef9799c4995d19bac48ad9fa82db4dc5c5" translate="yes" xml:space="preserve">
          <source>The eigenvalues in ascending order, each repeated according to its multiplicity.</source>
          <target state="translated">固有値を昇順に並べ、それぞれの多重度に応じて繰り返します。</target>
        </trans-unit>
        <trans-unit id="af42e28434cbe95fe6890df4d996c2c99e9b2481" translate="yes" xml:space="preserve">
          <source>The eigenvalues of real symmetric or complex Hermitian matrices are always real. &lt;a href=&quot;#rc702e98a756a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; The array &lt;code&gt;v&lt;/code&gt; of (column) eigenvectors is unitary and &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; satisfy the equations &lt;code&gt;dot(a, v[:, i]) = w[i] * v[:, i]&lt;/code&gt;.</source>
          <target state="translated">実対称または複素エルミート行列の固有値は常に実数です。&lt;a href=&quot;#rc702e98a756a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;（列）固有ベクトルの配列 &lt;code&gt;v&lt;/code&gt; はユニタリであり &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;w&lt;/code&gt; 、および &lt;code&gt;v&lt;/code&gt; は等式 &lt;code&gt;dot(a, v[:, i]) = w[i] * v[:, i]&lt;/code&gt; 満たします。</target>
        </trans-unit>
        <trans-unit id="2ff4d23698273b360b1d6366e444e95ea540f28f" translate="yes" xml:space="preserve">
          <source>The eigenvalues, each repeated according to its multiplicity. The eigenvalues are not necessarily ordered. The resulting array will be of complex type, unless the imaginary part is zero in which case it will be cast to a real type. When &lt;code&gt;a&lt;/code&gt; is real the resulting eigenvalues will be real (0 imaginary part) or occur in conjugate pairs</source>
          <target state="translated">それぞれがその多重度に従って繰り返される固有値。固有値は必ずしも順序付けられていません。結果の配列は複素数型になります。ただし、虚数部がゼロの場合は、実数型にキャストされます。 &lt;code&gt;a&lt;/code&gt; が実数の場合、結果の固有値は実数（0の虚数部）または共役ペアで発生します</target>
        </trans-unit>
        <trans-unit id="9cfc7ae7c9df4df4270a01f781a7985d0061b823" translate="yes" xml:space="preserve">
          <source>The eigenvalues, each repeated according to its multiplicity. They are not necessarily ordered, nor are they necessarily real for real matrices.</source>
          <target state="translated">固有値は,それぞれがその倍数に応じて繰り返される.固有値は必ずしも順序付けされているわけではなく,実数行列の場合は必ずしも実数ではありません.</target>
        </trans-unit>
        <trans-unit id="fedbdf07c41c58b01420971d15b808683a8a1612" translate="yes" xml:space="preserve">
          <source>The eigenvalues/eigenvectors are computed using LAPACK routines &lt;code&gt;_syevd&lt;/code&gt;, &lt;code&gt;_heevd&lt;/code&gt;.</source>
          <target state="translated">固有値/固有ベクトルは、LAPACKルーチン &lt;code&gt;_syevd&lt;/code&gt; 、 &lt;code&gt;_heevd&lt;/code&gt; を使用して計算されます。</target>
        </trans-unit>
        <trans-unit id="672eac8f0267740479f9ff389b02d40f57b3ff35" translate="yes" xml:space="preserve">
          <source>The element inserted in &lt;code&gt;output&lt;/code&gt; when all conditions evaluate to False.</source>
          <target state="translated">すべての条件がFalseと評価されたときに &lt;code&gt;output&lt;/code&gt; に挿入される要素。</target>
        </trans-unit>
        <trans-unit id="c154db2e01512028a28319b3317262699278c799" translate="yes" xml:space="preserve">
          <source>The element size of this data-type object.</source>
          <target state="translated">このデータ型オブジェクトの要素サイズ。</target>
        </trans-unit>
        <trans-unit id="100849a009dc981ce005b4c12bbdd30342f43ac6" translate="yes" xml:space="preserve">
          <source>The element-wise remainder of the quotient &lt;code&gt;floor_divide(x1, x2)&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">商 &lt;code&gt;floor_divide(x1, x2)&lt;/code&gt; の要素ごとの剰余。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="55f57b3f397334c809b04b980612f0a5ab349a62" translate="yes" xml:space="preserve">
          <source>The elements are binary-valued (0 or 1).</source>
          <target state="translated">要素は2値(0または1)です。</target>
        </trans-unit>
        <trans-unit id="18d658a71c2e23e5ce04fb215c6cdc657f3c41d2" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;a&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;m&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; の要素は、このインデックスの順序を使用して読み取られます。 「C」は、Cのような順序で要素にインデックスを付けることを意味し、最後の軸のインデックスが最も速く変化し、最初の軸のインデックスが最も遅く変化します。 「F」は、最初のインデックスが最も速く変化し、最後のインデックスが最も遅く変化するFortranのようなインデックスの順序で要素にインデックスを付けることを意味します。 'C'および 'F'オプションは、基になる配列のメモリレイアウトを考慮せず、軸のインデックスの順序のみを参照することに注意してください。 'A'は、 &lt;code&gt;m&lt;/code&gt; がメモリ内でFortranに&lt;em&gt;隣接&lt;/em&gt;している場合はFortranに似たインデックス順で、それ以外はCに似た順序で要素を読み取ることを意味します。 'K'は、ストライドが負の場合にデータを反転することを除いて、メモリ内で発生した順に要素を読み取ることを意味します。デフォルトでは、「C」インデックス順が使用されます。</target>
        </trans-unit>
        <trans-unit id="27ccf6e9acce055e532ad81d9bdd8638f9a4a262" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;a&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in row-major, C-style order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in column-major, Fortran-style order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;a&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; の要素は、このインデックスの順序を使用して読み取られます。「C」は、要素を行優先、Cスタイルの順序でインデックス付けすることを意味し、最後の軸のインデックスが最も速く変化し、最初の軸のインデックスが最も遅く変化します。'F'は、最初のインデックスが最も速く変化し、最後のインデックスが最も遅く変化する、列優先のFortranスタイルの順序で要素にインデックスを付けることを意味します。'C'および 'F'オプションは、基になる配列のメモリレイアウトを考慮せず、軸のインデックスの順序のみを参照することに注意してください。「A」は、 &lt;code&gt;a&lt;/code&gt; が&lt;em&gt;連続した&lt;/em&gt; Fortranの場合、要素をFortranに似たインデックス順で読み取ることを意味します&lt;em&gt;&lt;/em&gt;メモリでは、それ以外はCのような順序です。'K'は、ストライドが負の場合にデータを反転することを除いて、メモリ内で発生した順に要素を読み取ることを意味します。デフォルトでは、「C」インデックス順が使用されます。</target>
        </trans-unit>
        <trans-unit id="8bfe90d8bb9b3a44603b03bac0e42210874e7808" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;m&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;m&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; の要素は、このインデックスの順序を使用して読み取られます。 「C」は、Cのような順序で要素にインデックスを付けることを意味し、最後の軸のインデックスが最も速く変化し、最初の軸のインデックスが最も遅く変化します。 「F」は、最初のインデックスが最も速く変化し、最後のインデックスが最も遅く変化するFortranのようなインデックスの順序で要素にインデックスを付けることを意味します。 'C'および 'F'オプションは、基になる配列のメモリレイアウトを考慮せず、軸のインデックスの順序のみを参照することに注意してください。 'A'は、 &lt;code&gt;m&lt;/code&gt; がメモリ内でFortranに&lt;em&gt;隣接&lt;/em&gt;している場合はFortranに似たインデックス順で、それ以外はCに似た順序で要素を読み取ることを意味します。 'K'は、ストライドが負の場合にデータを反転することを除いて、メモリ内で発生した順に要素を読み取ることを意味します。デフォルトでは、「C」インデックス順が使用されます。</target>
        </trans-unit>
        <trans-unit id="d8d7a05ea4e76ed025da3efb7e37c3722ae9fddb" translate="yes" xml:space="preserve">
          <source>The elements of both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;a.T&lt;/code&gt; get traversed in the same order, namely the order they are stored in memory, whereas the elements of &lt;code&gt;a.T.copy(order=&amp;rsquo;C&amp;rsquo;)&lt;/code&gt; get visited in a different order because they have been put into a different memory layout.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; と &lt;code&gt;a.T&lt;/code&gt; の両方の要素は同じ順序、つまりメモリに格納されている順序でトラバースされますが、 &lt;code&gt;a.T.copy(order=&amp;rsquo;C&amp;rsquo;)&lt;/code&gt; の要素は異なるメモリに配置されているため、異なる順序でアクセスされますレイアウト。</target>
        </trans-unit>
        <trans-unit id="7c09282fb5ba8925fe26507ed54970dbeacf3bc3" translate="yes" xml:space="preserve">
          <source>The elements of the shape tuple give the lengths of the corresponding array dimensions.</source>
          <target state="translated">形状タプルの要素は,対応する配列の次元の長さを与えます.</target>
        </trans-unit>
        <trans-unit id="d08dc6baf6d1de4ff7af87aa1f35d18925c1f47b" translate="yes" xml:space="preserve">
          <source>The elements of this structure are:</source>
          <target state="translated">この構造の要素は</target>
        </trans-unit>
        <trans-unit id="d0777cee700edf703f03cd8f123c44ac46b607f9" translate="yes" xml:space="preserve">
          <source>The end value of the sequence, unless &lt;code&gt;endpoint&lt;/code&gt; is set to False. In that case, the sequence consists of all but the last of &lt;code&gt;num + 1&lt;/code&gt; evenly spaced samples, so that &lt;code&gt;stop&lt;/code&gt; is excluded. Note that the step size changes when &lt;code&gt;endpoint&lt;/code&gt; is False.</source>
          <target state="translated">シーケンスの終了値（ &lt;code&gt;endpoint&lt;/code&gt; がFalseに設定されていない場合）。その場合、シーケンスは、 &lt;code&gt;num + 1&lt;/code&gt; 等間隔のサンプルの最後を除くすべてで構成されるため、その &lt;code&gt;stop&lt;/code&gt; は除外されます。 &lt;code&gt;endpoint&lt;/code&gt; がFalseの場合、ステップサイズが変化することに注意してください。</target>
        </trans-unit>
        <trans-unit id="61c8a67ac747d5eb7d80852565d6317e805901a1" translate="yes" xml:space="preserve">
          <source>The endpoint of the interval can optionally be excluded.</source>
          <target state="translated">区間の終点は、オプションで除外することができます。</target>
        </trans-unit>
        <trans-unit id="7c70e4957abd94f2cb0f87772d68554c90cbe5b2" translate="yes" xml:space="preserve">
          <source>The entropy for creating a &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;を作成するためのエントロピー。</target>
        </trans-unit>
        <trans-unit id="0807164c2e58b526f47d2a17d970242e2786a8ed" translate="yes" xml:space="preserve">
          <source>The enumeration value for ASCII strings of a selectable size. The strings have a fixed maximum size within a given array.</source>
          <target state="translated">選択可能なサイズのASCII文字列の列挙値。文字列は、指定された配列内で固定の最大サイズを持ちます。</target>
        </trans-unit>
        <trans-unit id="4486c486e9b2ccc0519632048cae0af33e6f2bea" translate="yes" xml:space="preserve">
          <source>The enumeration value for UCS4 strings of a selectable size. The strings have a fixed maximum size within a given array.</source>
          <target state="translated">選択可能なサイズのUCS4文字列の列挙値。文字列は、与えられた配列内で固定の最大サイズを持つ。</target>
        </trans-unit>
        <trans-unit id="ceb80d4c945347bb465d428088d951fae89cf7e9" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 128-bit/16-byte complex type made up of two NPY_DOUBLE values.</source>
          <target state="translated">2 つの NPY_DOUBLE 値からなる 128 ビット/16 バイト複素型の列挙値。</target>
        </trans-unit>
        <trans-unit id="022dd3242a4f7ab9f354ab53434df9783dde262d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte IEEE 754-2008 compatible floating point type.</source>
          <target state="translated">16ビット/2バイトのIEEE 754-2008互換浮動小数点型の列挙値。</target>
        </trans-unit>
        <trans-unit id="54200391c747968ffe444d868d0f00fe22c905a7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte signed integer.</source>
          <target state="translated">16ビット/2バイト符号付き整数の列挙値。</target>
        </trans-unit>
        <trans-unit id="24e698054b91536d27ff27c354d21704b0ff5fa7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte unsigned integer.</source>
          <target state="translated">16ビット/2バイトの符号なし整数の列挙値。</target>
        </trans-unit>
        <trans-unit id="48c93b25a09888099a2fa0e8cc423bbdd97aec51" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte IEEE 754 compatible floating point type.</source>
          <target state="translated">32ビット/4バイトのIEEE 754互換浮動小数点型の列挙値です。</target>
        </trans-unit>
        <trans-unit id="0767688f1013b974d66b67bec323cce162186c28" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte signed integer.</source>
          <target state="translated">32ビット/4バイト符号付き整数の列挙値。</target>
        </trans-unit>
        <trans-unit id="61e002f4aaa6d35ff73356572d5e52edd07749bc" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte unsigned integer.</source>
          <target state="translated">32ビット/4バイト符号なし整数の列挙値。</target>
        </trans-unit>
        <trans-unit id="13bb2de2cc37c2d6613c3c408dc1f6c1a04bcaf7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte IEEE 754 compatible floating point type.</source>
          <target state="translated">64ビット/8バイトのIEEE 754互換浮動小数点型の列挙値。</target>
        </trans-unit>
        <trans-unit id="712e85738302795b01166defaa51ce15d788398b" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte complex type made up of two NPY_FLOAT values.</source>
          <target state="translated">2つのNPY_FLOAT値からなる64ビット/8バイト複素型の列挙値。</target>
        </trans-unit>
        <trans-unit id="6fcce91d25d23bb25fdb72e7335d026c8e38fbfa" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte signed integer.</source>
          <target state="translated">64ビット/8バイト符号付き整数の列挙値。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
