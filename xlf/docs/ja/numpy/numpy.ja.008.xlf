<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="72188498e399312affe529bd4d440a03ee9c95e4" translate="yes" xml:space="preserve">
          <source>Arithmetic is modular when using integer types, and no error is raised on overflow. That means that, on a 32-bit platform:</source>
          <target state="translated">整数型を使用する場合、算術はモジュール化されており、オーバーフローでエラーが発生することはありません。つまり、32ビットプラットフォームでは</target>
        </trans-unit>
        <trans-unit id="339f6492877ce24a534c3f1e9110c317be457d3a" translate="yes" xml:space="preserve">
          <source>Arithmetic mean taken while not ignoring NaNs</source>
          <target state="translated">NaNを無視した算術平均値</target>
        </trans-unit>
        <trans-unit id="1fc0feb17ac2848b9f01591a445a367739c560da" translate="yes" xml:space="preserve">
          <source>Arithmetic operations</source>
          <target state="translated">算術演算</target>
        </trans-unit>
        <trans-unit id="7ee1fda772751523c2669ec2f48ddc06e8ec6d54" translate="yes" xml:space="preserve">
          <source>Arithmetic operators on arrays apply &lt;em&gt;elementwise&lt;/em&gt;. A new array is created and filled with the result.</source>
          <target state="translated">配列の算術演算子は&lt;em&gt;要素ごとに&lt;/em&gt;適用されます。新しい配列が作成され、結果が入力されます。</target>
        </trans-unit>
        <trans-unit id="16ba88bd7d8f2b893c09bcff737706246adcbc3b" translate="yes" xml:space="preserve">
          <source>Arithmetic, in-place:</source>
          <target state="translated">算数、その場で。</target>
        </trans-unit>
        <trans-unit id="ac2131c4955b2cce396141546558f75712964834" translate="yes" xml:space="preserve">
          <source>Arithmetic, matrix multiplication, and comparison operations</source>
          <target state="translated">算数、行列の掛け算、比較演算</target>
        </trans-unit>
        <trans-unit id="d534ca6745f09f171b20632796505d5bd60949d7" translate="yes" xml:space="preserve">
          <source>Arithmetic:</source>
          <target state="translated">Arithmetic:</target>
        </trans-unit>
        <trans-unit id="0771a753fa9fe721bf5720d2f9bacca79fff9e8e" translate="yes" xml:space="preserve">
          <source>Arithmetics</source>
          <target state="translated">Arithmetics</target>
        </trans-unit>
        <trans-unit id="dfc7a32fa9a79ec3a22472c368d871d5e78afd31" translate="yes" xml:space="preserve">
          <source>Array (possibly multi-dimensional) of values for which to to calculate &lt;code&gt;sinc(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sinc(x)&lt;/code&gt; を計算する値の配列（おそらく多次元）。</target>
        </trans-unit>
        <trans-unit id="0523df413b1fea0ba7975ab7c9175833f364830f" translate="yes" xml:space="preserve">
          <source>Array &lt;strong&gt;attributes&lt;/strong&gt; reflect information intrinsic to the array itself. If you need to get, or even set, properties of an array without creating a new array, you can often access an array through its attributes.</source>
          <target state="translated">配列&lt;strong&gt;属性&lt;/strong&gt;は、配列自体に固有の情報を反映します。新しい配列を作成せずに配列のプロパティを取得または設定する必要がある場合は、多くの場合、その属性を介して配列にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="6951f36c01ac0e1bf34c5ee5904784fafce57b89" translate="yes" xml:space="preserve">
          <source>Array API</source>
          <target state="translated">配列API</target>
        </trans-unit>
        <trans-unit id="5555a6fcea0c1d138c4fd9c9348c13792e83ec8b" translate="yes" xml:space="preserve">
          <source>Array Attributes</source>
          <target state="translated">配列属性</target>
        </trans-unit>
        <trans-unit id="3458034e7e106c04c09c4ec57632af02a473c676" translate="yes" xml:space="preserve">
          <source>Array Broadcasting in Numpy</source>
          <target state="translated">Numpyでの配列放送</target>
        </trans-unit>
        <trans-unit id="0c1a37c234fe9514069c7363784bf98af15b8355" translate="yes" xml:space="preserve">
          <source>Array Creation</source>
          <target state="translated">配列の作成</target>
        </trans-unit>
        <trans-unit id="daa02d3f49bf321fb5979b03ac56b6cd9657dfad" translate="yes" xml:space="preserve">
          <source>Array Functions</source>
          <target state="translated">配列関数</target>
        </trans-unit>
        <trans-unit id="12d693ff9b1c0d4047e2b7848ca27e4c2aad6719" translate="yes" xml:space="preserve">
          <source>Array Iterator</source>
          <target state="translated">配列イテレータ</target>
        </trans-unit>
        <trans-unit id="043a8c676a7d5d7051367cd8181a4b07707df511" translate="yes" xml:space="preserve">
          <source>Array Iterator API</source>
          <target state="translated">配列イテレータ API</target>
        </trans-unit>
        <trans-unit id="23211b01eb261a332c7929b935052183b79935ba" translate="yes" xml:space="preserve">
          <source>Array Iterators</source>
          <target state="translated">配列イテレータ</target>
        </trans-unit>
        <trans-unit id="17e44520a1762d19a9e642fb414c494c724cbf21" translate="yes" xml:space="preserve">
          <source>Array Scalars</source>
          <target state="translated">アレイスカラー</target>
        </trans-unit>
        <trans-unit id="d8dbcc76e586f64f22d24c3030096b5747dde0a4" translate="yes" xml:space="preserve">
          <source>Array arguments</source>
          <target state="translated">配列の引数</target>
        </trans-unit>
        <trans-unit id="2ec85771e631fd3b121a1ff64071bd20ad9c65bf" translate="yes" xml:space="preserve">
          <source>Array attributes</source>
          <target state="translated">配列属性</target>
        </trans-unit>
        <trans-unit id="447450427b5d5b0e87b960a4d40e39c7fb5454bf" translate="yes" xml:space="preserve">
          <source>Array attributes reflect information that is intrinsic to the array itself. Generally, accessing an array through its attributes allows you to get and sometimes set intrinsic properties of the array without creating a new array. The exposed attributes are the core parts of an array and only some of them can be reset meaningfully without creating a new array. Information on each attribute is given below.</source>
          <target state="translated">配列の属性は、配列自体に固有の情報を反映しています。一般的に、その属性から配列にアクセスすることで、新しい配列を作成しなくても配列の本質的なプロパティを取得したり設定したりすることができます。公開されている属性は配列の中心的な部分であり、新しい配列を作成しなくても意味のあるリセットができるのはそのうちのいくつかだけです。各属性に関する情報を以下に示します。</target>
        </trans-unit>
        <trans-unit id="43e339bdd3d217a5df3e10b8dade9046731deb5f" translate="yes" xml:space="preserve">
          <source>Array axis summations, &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;numpy.sum&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">配列軸の合計、&lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;numpy.sum&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="57c60efa53930ae07f9d8ba23de0e194c69cf7fe" translate="yes" xml:space="preserve">
          <source>Array comparison assertions include maximum differences</source>
          <target state="translated">配列比較アサーションには、最大差分が含まれています。</target>
        </trans-unit>
        <trans-unit id="347b135c7cac14f05d7b1660f5d4b4c54f55d66d" translate="yes" xml:space="preserve">
          <source>Array comparisons involving strings or structured dtypes</source>
          <target state="translated">文字列や構造化されたd型を含む配列比較</target>
        </trans-unit>
        <trans-unit id="d7a5d8de55dabc36dc25c0b90e8906cffcb6a61a" translate="yes" xml:space="preserve">
          <source>Array containing data to be averaged. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">平均化するデータを含む配列。 &lt;code&gt;a&lt;/code&gt; が配列でない場合、変換が試行されます。</target>
        </trans-unit>
        <trans-unit id="54d016905c8d5e8ccde24c37f9843bcd318cb81c" translate="yes" xml:space="preserve">
          <source>Array containing elements to clip.</source>
          <target state="translated">クリップする要素を含む配列。</target>
        </trans-unit>
        <trans-unit id="3961c6f8eadfe688bca31469d6a9f6d86adf81c6" translate="yes" xml:space="preserve">
          <source>Array containing number of representable floating point numbers between items in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; の項目間の表現可能な浮動小数点数を含む配列。</target>
        </trans-unit>
        <trans-unit id="3692161b3a773c7a966c7715be4b4e9968f11340" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose maximum is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">最大値が必要な数値を含む配列。 &lt;code&gt;a&lt;/code&gt; が配列でない場合、変換が試行されます。</target>
        </trans-unit>
        <trans-unit id="e6449394cdaf60dea5ac71fdd09a0ed9e9fcf7ee" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose mean is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">平均が必要な数値を含む配列。 &lt;code&gt;a&lt;/code&gt; が配列でない場合、変換が試行されます。</target>
        </trans-unit>
        <trans-unit id="535ad2f426544f7de05e5d9017d86d66f0dc26b1" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose minimum is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">最小値が必要な数値を含む配列。 &lt;code&gt;a&lt;/code&gt; が配列でない場合、変換が試行されます。</target>
        </trans-unit>
        <trans-unit id="64bc244f5b24dc5faeb077670f074a7e20727322" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose product is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">積が必要な数値を含む配列。 &lt;code&gt;a&lt;/code&gt; が配列でない場合、変換が試行されます。</target>
        </trans-unit>
        <trans-unit id="ee6ece6461a907cbfdfd61282756037912ce23f3" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose sum is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">合計が必要な数値を含む配列。 &lt;code&gt;a&lt;/code&gt; が配列でない場合、変換が試行されます。</target>
        </trans-unit>
        <trans-unit id="2effaddf77c674bd9a13dc031c59b1eb4d28fa23" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose variance is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">分散が必要な数値を含む配列。 &lt;code&gt;a&lt;/code&gt; が配列でない場合、変換が試行されます。</target>
        </trans-unit>
        <trans-unit id="f011f52156b6489c00057dbaf1f239251b746676" translate="yes" xml:space="preserve">
          <source>Array containing the roots of the series.</source>
          <target state="translated">系列のルートを含む配列。</target>
        </trans-unit>
        <trans-unit id="d1fb2d0b90ad27fe772216fd0efb4378564945a2" translate="yes" xml:space="preserve">
          <source>Array contents</source>
          <target state="translated">配列の内容</target>
        </trans-unit>
        <trans-unit id="2ea33ca743035321174ecf9d435d32b0b6324742" translate="yes" xml:space="preserve">
          <source>Array conversion</source>
          <target state="translated">配列変換</target>
        </trans-unit>
        <trans-unit id="fc6b3a513ef2597bc0f03a1e823241af5164729d" translate="yes" xml:space="preserve">
          <source>Array convolution. Same output as polymul, but has parameter for overlap mode.</source>
          <target state="translated">配列畳み込み。polymulと同じ出力ですが、オーバーラップモードのパラメータがあります。</target>
        </trans-unit>
        <trans-unit id="57c72a1a53b95fbe1af3976c75af0287d5c9a140" translate="yes" xml:space="preserve">
          <source>Array creation</source>
          <target state="translated">配列の作成</target>
        </trans-unit>
        <trans-unit id="b5a18bd4e3702b73f0e8bbba0d5f2e2fddff6728" translate="yes" xml:space="preserve">
          <source>Array creation routines</source>
          <target state="translated">配列作成ルーチン</target>
        </trans-unit>
        <trans-unit id="a51f0e8ac2e03ac06587c6b47fb57edec0450c93" translate="yes" xml:space="preserve">
          <source>Array data to be saved.</source>
          <target state="translated">保存する配列データ。</target>
        </trans-unit>
        <trans-unit id="4e68baef4a7d203aefd9d4a59b835fc6af2a5db3" translate="yes" xml:space="preserve">
          <source>Array data-type.</source>
          <target state="translated">配列データ型。</target>
        </trans-unit>
        <trans-unit id="52dbdba544f09b15fca774eb24a9caf2434bcfe6" translate="yes" xml:space="preserve">
          <source>Array desired.</source>
          <target state="translated">希望する配列。</target>
        </trans-unit>
        <trans-unit id="785376e3605a2b132b04a5af283162b0f7133160" translate="yes" xml:space="preserve">
          <source>Array flags</source>
          <target state="translated">配列フラグ</target>
        </trans-unit>
        <trans-unit id="746aa39a47d26f55bf62b76f045191bc2131b857" translate="yes" xml:space="preserve">
          <source>Array flags provide information about how the memory area used for the array is to be interpreted. There are 7 Boolean flags in use, only four of which can be changed by the user: WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.</source>
          <target state="translated">配列フラグは、配列に使用されるメモリ領域がどのように解釈されるかについての情報を提供します。使用中の7つのブール値フラグがありますが、そのうちユーザが変更できるのは4つだけです。WRITEBACKIFCOPY、UPDATEIFCOPY、WRITEABLE、ALIGNEDです。</target>
        </trans-unit>
        <trans-unit id="5f6e91f1df0558c7246187a2b89a1e305be167b2" translate="yes" xml:space="preserve">
          <source>Array flags; may be one or more of:</source>
          <target state="translated">配列フラグ。</target>
        </trans-unit>
        <trans-unit id="09f0fcdcc100e898aaa63b04e30eafb660bbc3ed" translate="yes" xml:space="preserve">
          <source>Array from which the diagonals are taken.</source>
          <target state="translated">対角線を取得する配列。</target>
        </trans-unit>
        <trans-unit id="3966916957967be244949812c17944d586ffd56d" translate="yes" xml:space="preserve">
          <source>Array from which to extract a part.</source>
          <target state="translated">パーツを抽出するための配列。</target>
        </trans-unit>
        <trans-unit id="e35c942121269158d9bce83e940f79fd38671bbd" translate="yes" xml:space="preserve">
          <source>Array indexing refers to any use of the square brackets ([]) to index array values. There are many options to indexing, which give numpy indexing great power, but with power comes some complexity and the potential for confusion. This section is just an overview of the various options and issues related to indexing. Aside from single element indexing, the details on most of these options are to be found in related sections.</source>
          <target state="translated">配列のインデキシングとは、配列の値をインデキシングするために角括弧([])を使用することを指します。インデックス作成には多くのオプションがあり、numpy のインデックス作成には大きな力がありますが、力があればあるほど複雑になり、混乱を招く可能性があります。この節では、インデキシングに関連する様々なオプションと問題点の概要を説明します。単一要素のインデキシングは別として、これらのオプションの詳細は関連するセクションにあります。</target>
        </trans-unit>
        <trans-unit id="4a877fe238b2290421c4de0ccb250aa8e3797a13" translate="yes" xml:space="preserve">
          <source>Array interface</source>
          <target state="translated">配列インターフェース</target>
        </trans-unit>
        <trans-unit id="533db24c36bf6bd74ce0240469f4033043848386" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">の配列の解釈。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1230519a64fd2e0f26f95201257e208e07092a99" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is an ndarray or a subclass of ndarray, it is returned as-is and no copy is performed.</source>
          <target state="translated">の配列の解釈。場合ndarrayまたはndarrayのサブクラスである、そのまま返され、コピーは実行されません。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a004555e4ca47c97c392427144fe0dcc6f68634" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;. No copy is performed if the input is already an ndarray with matching dtype and order. If &lt;code&gt;a&lt;/code&gt; is a subclass of ndarray, a base class ndarray is returned.</source>
          <target state="translated">の配列の解釈。入力がすでに一致するdtypeと順序を持つndarrayである場合、コピーは実行されません。 &lt;code&gt;a&lt;/code&gt; がndarrayのサブクラスの場合、基本クラスndarrayが返されます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a82a73ea4a83ace24f5a89b08b00620d66cb5bf" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;. No copy is performed if the input is already an ndarray. If &lt;code&gt;a&lt;/code&gt; is a subclass of ndarray, a base class ndarray is returned.</source>
          <target state="translated">の配列の解釈。入力がすでにndarrayである場合、コピーは実行されません。 &lt;code&gt;a&lt;/code&gt; がndarrayのサブクラスの場合、基本クラスndarrayが返されます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1af36487281180923aa6bea35e0e5228dcc2e12d" translate="yes" xml:space="preserve">
          <source>Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output.</source>
          <target state="translated">出力を配置する配列。その型は保持され、出力を保持するためには正しい形状でなければなりません。</target>
        </trans-unit>
        <trans-unit id="02f71c6bb3adeae64ae8bccd5d811288aeb1d5e1" translate="yes" xml:space="preserve">
          <source>Array into which the result can be placed. Its type is preserved and it must be of the right shape to hold the output.</source>
          <target state="translated">結果を配置できる配列。その型は保持され、出力を保持するためには適切な形状でなければなりません。</target>
        </trans-unit>
        <trans-unit id="1a57f1ce3b565cb3497401b660e08581c3aafec2" translate="yes" xml:space="preserve">
          <source>Array like index object or slice object for indexing into first operand. If first operand has multiple dimensions, indices can be a tuple of array like index objects or slice objects.</source>
          <target state="translated">最初のオペランドにインデックスを作成するためのインデックスオブジェクトやスライスオブジェクトのような配列です。最初のオペランドが多次元である場合、インデックスはインデックスオブジェクトやスライスオブジェクトのような配列のタプルになります。</target>
        </trans-unit>
        <trans-unit id="d40d802fdd7ba3f82f5c9dc44f415145a1e22c74" translate="yes" xml:space="preserve">
          <source>Array manipulation routines</source>
          <target state="translated">配列操作ルーチン</target>
        </trans-unit>
        <trans-unit id="069ff2b332e403300b9cde701bf5368c5831882c" translate="yes" xml:space="preserve">
          <source>Array method alternative API</source>
          <target state="translated">配列メソッド代替API</target>
        </trans-unit>
        <trans-unit id="5a716333b00a93ed3236b0b9385a0a127035480c" translate="yes" xml:space="preserve">
          <source>Array methods</source>
          <target state="translated">配列メソッド</target>
        </trans-unit>
        <trans-unit id="4e4004372e15259457b2d1e38548f61c9bc5e00d" translate="yes" xml:space="preserve">
          <source>Array mixins</source>
          <target state="translated">配列ミックスイン</target>
        </trans-unit>
        <trans-unit id="f161aeb75d90d23a000f60fbe55cf3eae07ee334" translate="yes" xml:space="preserve">
          <source>Array objects</source>
          <target state="translated">配列オブジェクト</target>
        </trans-unit>
        <trans-unit id="cf093406a8132eb8bfd9cf1020e69e3fe6518645" translate="yes" xml:space="preserve">
          <source>Array obtained.</source>
          <target state="translated">得られた配列。</target>
        </trans-unit>
        <trans-unit id="6b0a1f1e944aed373e67de14ba6a79b095a23306" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;fill_value&lt;/code&gt; with the given shape, dtype, and order.</source>
          <target state="translated">指定された形状、dtype、および順序を持つ &lt;code&gt;fill_value&lt;/code&gt; の配列。</target>
        </trans-unit>
        <trans-unit id="141b0992112c657405943baa4a593bdfd3d362b8" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;fill_value&lt;/code&gt; with the same shape and type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">アレイ &lt;code&gt;fill_value&lt;/code&gt; と同じ形状およびタイプ。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4591434d561c417ccddebc05c5c4eae4564de2b" translate="yes" xml:space="preserve">
          <source>Array of Chebyshev series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">チェビシェフ級数係数の配列.c が多次元の場合,異なる軸は,対応するインデックスによって与えられる各軸の次数を持つ異なる変数に対応します.</target>
        </trans-unit>
        <trans-unit id="4f8604db9d0154dd7eb0dded915686a2e44b5243" translate="yes" xml:space="preserve">
          <source>Array of Hermite series coefficients. If &lt;code&gt;c&lt;/code&gt; is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Hermiteシリーズ係数の配列。 &lt;code&gt;c&lt;/code&gt; が多次元の場合、異なる軸は異なる変数に対応し、各軸の次数は対応するインデックスによって与えられます。</target>
        </trans-unit>
        <trans-unit id="817eb4e4585a916e35d1ff46432ac14702692600" translate="yes" xml:space="preserve">
          <source>Array of Hermite series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">ハーミット級数の係数の配列.cが多次元の場合,異なる軸は,対応するインデックスによって与えられる各軸の次数を持つ異なる変数に対応します.</target>
        </trans-unit>
        <trans-unit id="6bb7459da4388ebdd50a78addd0898c1f80aabbe" translate="yes" xml:space="preserve">
          <source>Array of Hermite_e series coefficients. If &lt;code&gt;c&lt;/code&gt; is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Hermite_eシリーズ係数の配列。 &lt;code&gt;c&lt;/code&gt; が多次元の場合、異なる軸は異なる変数に対応し、各軸の次数は対応するインデックスによって与えられます。</target>
        </trans-unit>
        <trans-unit id="63e65a5158a929fafcbc4f8f156592488b9429ea" translate="yes" xml:space="preserve">
          <source>Array of Hermite_e series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Hermite_e級数の係数の配列。cが多次元の場合、異なる軸は、対応するインデックスによって与えられる各軸の次数を持つ異なる変数に対応します。</target>
        </trans-unit>
        <trans-unit id="1ea8d2a10d04a6eb03ee934ed9f9008e87ff51dc" translate="yes" xml:space="preserve">
          <source>Array of Laguerre series coefficients. If &lt;code&gt;c&lt;/code&gt; is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">ラゲール級数配列の配列。 &lt;code&gt;c&lt;/code&gt; が多次元の場合、異なる軸は異なる変数に対応し、各軸の次数は対応するインデックスによって与えられます。</target>
        </trans-unit>
        <trans-unit id="35c007605e6d77452f8dad5eb06d7938bab0902f" translate="yes" xml:space="preserve">
          <source>Array of Legendre series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">レジェンドレ級数係数の配列.c が多次元の場合,異なる軸は,対応するインデックスによって与えられる各軸の次数を持つ異なる変数に対応します.</target>
        </trans-unit>
        <trans-unit id="4261b4b77833f5ffb9b4ec031af96d60404d62e0" translate="yes" xml:space="preserve">
          <source>Array of angles in radians, in the range &lt;code&gt;[-pi, pi]&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;[-pi, pi]&lt;/code&gt; 範囲のラジアン単位の角度の配列。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="d00b51bfc114fceca7b5e804468ddaae71dd1f04" translate="yes" xml:space="preserve">
          <source>Array of bins. It has to be 1-dimensional and monotonic.</source>
          <target state="translated">ビンの配列。1次元で単調でなければならない。</target>
        </trans-unit>
        <trans-unit id="2431f4c023950cb461e657c537178d58e27e27dd" translate="yes" xml:space="preserve">
          <source>Array of booleans</source>
          <target state="translated">ブーリアンの配列</target>
        </trans-unit>
        <trans-unit id="536a897428fe0f47a3d34f49d6446e12ae81a0e0" translate="yes" xml:space="preserve">
          <source>Array of booleans identical in shape to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">と形状が同じブール値のアレイ。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a77bc6459d956649f3ae15d32c4f2c19eb8edf06" translate="yes" xml:space="preserve">
          <source>Array of booleans of same shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">同じ形状のブール値のアレイ。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a658696b6a89082b912ff090b4b6b37dee9b715c" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in &lt;code&gt;c[i,j]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than 2 the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="translated">多次数i、jの項の係数が &lt;code&gt;c[i,j]&lt;/code&gt; 含まれるように順序付けられた係数の配列。場合 &lt;code&gt;c&lt;/code&gt; は 2よりも大きい寸法を有し、残りのインデックスは、係数の複数のセットを列挙する。</target>
        </trans-unit>
        <trans-unit id="56c372955c6e7c782716979251e8af46e2f83f0a" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in &lt;code&gt;c[i,j]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="translated">多次数i、jの項の係数が &lt;code&gt;c[i,j]&lt;/code&gt; 含まれるように順序付けられた係数の配列。場合 &lt;code&gt;c&lt;/code&gt; は 2よりも大きい寸法を有し、残りのインデックスは、係数の複数のセットを列挙する。</target>
        </trans-unit>
        <trans-unit id="fa76e8a2aedbceba248a9fc307fb834762ffa569" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficient of the term of multi-degree i,j,k is contained in &lt;code&gt;c[i,j,k]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than 3 the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="translated">多次数i、j、kの項の係数が &lt;code&gt;c[i,j,k]&lt;/code&gt; 含まれるように順序付けられた係数の配列。場合 &lt;code&gt;c&lt;/code&gt; は 3よりも大きい寸法を有し、残りのインデックスは、係数の複数のセットを列挙する。</target>
        </trans-unit>
        <trans-unit id="2ca7ab8cb88305034f9c8ff4c4bec7fdbf7384a0" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in &lt;code&gt;c[i,j]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="translated">次数i、jの項の係数が &lt;code&gt;c[i,j]&lt;/code&gt; 含まれるように順序付けられた係数の配列。場合 &lt;code&gt;c&lt;/code&gt; は 2よりも大きい寸法を有し、残りのインデックスは、係数の複数のセットを列挙する。</target>
        </trans-unit>
        <trans-unit id="013054b355ed269971a257a22db8c61fecab58bc" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If &lt;code&gt;c&lt;/code&gt; is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">次数nの項の係数がc [n]に含まれるように順序付けられた係数の配列。 &lt;code&gt;c&lt;/code&gt; が多次元の場合、残りのインデックスは複数の多項式を列挙します。2次元の場合、係数は &lt;code&gt;c&lt;/code&gt; の列に格納されていると考えることができます。</target>
        </trans-unit>
        <trans-unit id="00bc78cb48de3651884eadaf718d38e560006d25" translate="yes" xml:space="preserve">
          <source>Array of evenly spaced values.</source>
          <target state="translated">等間隔の値の配列。</target>
        </trans-unit>
        <trans-unit id="2d1560c385ed8ca347f0a453a1d3ede23238d315" translate="yes" xml:space="preserve">
          <source>Array of indices into the array. It has the same shape as &lt;code&gt;a.shape&lt;/code&gt; with the dimension along &lt;code&gt;axis&lt;/code&gt; removed.</source>
          <target state="translated">配列へのインデックスの配列。 &lt;code&gt;axis&lt;/code&gt; 沿った寸法が削除された &lt;code&gt;a.shape&lt;/code&gt; と同じ形状です。</target>
        </trans-unit>
        <trans-unit id="a8ca40e5ac25fd9b6c7a437f8b20abf87b6dd448" translate="yes" xml:space="preserve">
          <source>Array of indices that partition &lt;code&gt;a&lt;/code&gt; along the specified axis. If &lt;code&gt;a&lt;/code&gt; is one-dimensional, &lt;code&gt;a[index_array]&lt;/code&gt; yields a partitioned &lt;code&gt;a&lt;/code&gt;. More generally, &lt;code&gt;np.take_along_axis(a, index_array, axis=a)&lt;/code&gt; always yields the partitioned &lt;code&gt;a&lt;/code&gt;, irrespective of dimensionality.</source>
          <target state="translated">指定された軸に沿ってを分割 &lt;code&gt;a&lt;/code&gt; インデックスの配列。場合は一次元である、 &lt;code&gt;a[index_array]&lt;/code&gt; 分割得。より一般的には、 &lt;code&gt;np.take_along_axis(a, index_array, axis=a)&lt;/code&gt; は、次元に関係なく、常にパーティション化され &lt;code&gt;a&lt;/code&gt; 生成します。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b6035bba7c71c43b0b9bba16cae62cbd47fc547" translate="yes" xml:space="preserve">
          <source>Array of indices that sort &lt;code&gt;a&lt;/code&gt; along the specified &lt;code&gt;axis&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is one-dimensional, &lt;code&gt;a[index_array]&lt;/code&gt; yields a sorted &lt;code&gt;a&lt;/code&gt;. More generally, &lt;code&gt;np.take_along_axis(a, index_array, axis=axis)&lt;/code&gt; always yields the sorted &lt;code&gt;a&lt;/code&gt;, irrespective of dimensionality.</source>
          <target state="translated">指定された &lt;code&gt;axis&lt;/code&gt; 沿ってをソート &lt;code&gt;a&lt;/code&gt; インデックスの配列。場合は一次元である、 &lt;code&gt;a[index_array]&lt;/code&gt; ソート生み出します。より一般的には、 &lt;code&gt;np.take_along_axis(a, index_array, axis=axis)&lt;/code&gt; は、次元に関係なく、常にソートされ &lt;code&gt;a&lt;/code&gt; 生成します。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0dc6273aecd116e71b925f830b8b852ca18868e" translate="yes" xml:space="preserve">
          <source>Array of indices that sort &lt;code&gt;a&lt;/code&gt; along the specified axis. In other words, &lt;code&gt;a[index_array]&lt;/code&gt; yields a sorted &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">指定された軸に沿ってをソート &lt;code&gt;a&lt;/code&gt; インデックスの配列。言い換えると、 &lt;code&gt;a[index_array]&lt;/code&gt; はソートされ &lt;code&gt;a&lt;/code&gt; 生成します。</target>
        </trans-unit>
        <trans-unit id="87cf8b4326e4bf74829f6ee998b605e627a3e05c" translate="yes" xml:space="preserve">
          <source>Array of indices that sort the keys along the specified axis.</source>
          <target state="translated">指定された軸に沿ってキーをソートするインデックスの配列。</target>
        </trans-unit>
        <trans-unit id="9ba877503fdc9b234f8b5bd4ff989ab5b66a993a" translate="yes" xml:space="preserve">
          <source>Array of insertion points with the same shape as &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; と同じ形状の挿入ポイントの配列。</target>
        </trans-unit>
        <trans-unit id="eda2f2ab5893d6c8f805112f168403bde8914bdc" translate="yes" xml:space="preserve">
          <source>Array of length &lt;code&gt;n//2 + 1&lt;/code&gt; containing the sample frequencies.</source>
          <target state="translated">サンプル周波数を含む長さ &lt;code&gt;n//2 + 1&lt;/code&gt; 配列。</target>
        </trans-unit>
        <trans-unit id="16403e1679edece0422b414ba8df64826286ea95" translate="yes" xml:space="preserve">
          <source>Array of length &lt;code&gt;n&lt;/code&gt; containing the sample frequencies.</source>
          <target state="translated">サンプル周波数を含む長さ &lt;code&gt;n&lt;/code&gt; の配列。</target>
        </trans-unit>
        <trans-unit id="3e56b710dd7f0b21c34a3b08ffd09a687bf4487b" translate="yes" xml:space="preserve">
          <source>Array of list objects</source>
          <target state="translated">リストオブジェクトの配列</target>
        </trans-unit>
        <trans-unit id="8a37d72f2b1b4102a1be6ef75c473c25a6af0723" translate="yes" xml:space="preserve">
          <source>Array of multipliers.</source>
          <target state="translated">乗算器の配列。</target>
        </trans-unit>
        <trans-unit id="206e9ffd7bd541d0301a39acc4ace879a4a8c4c0" translate="yes" xml:space="preserve">
          <source>Array of numbers to be decomposed.</source>
          <target state="translated">分解される数の配列。</target>
        </trans-unit>
        <trans-unit id="b8d93545bf76db1e421350de1ab5b27bda265c94" translate="yes" xml:space="preserve">
          <source>Array of ones with the given shape, dtype, and order.</source>
          <target state="translated">指定された形状、dtype、順序を持つものの配列。</target>
        </trans-unit>
        <trans-unit id="2a7562df8fd2349ba86c3e8c830bce9f44d2768c" translate="yes" xml:space="preserve">
          <source>Array of ones with the same shape and type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">と同じ形状とタイプを &lt;code&gt;a&lt;/code&gt; ものの配列。</target>
        </trans-unit>
        <trans-unit id="c57697e4962f7c2af124e859e719b69080933cff" translate="yes" xml:space="preserve">
          <source>Array of ones.</source>
          <target state="translated">1の配列。</target>
        </trans-unit>
        <trans-unit id="baa4adf58634fb06ef6ad2372bc5421740221f26" translate="yes" xml:space="preserve">
          <source>Array of points of the same shape as &lt;code&gt;x&lt;/code&gt;, after application of the linear map between the two domains.</source>
          <target state="translated">2つのドメイン間に線形マップを適用した後の、 &lt;code&gt;x&lt;/code&gt; と同じ形状の点の配列。</target>
        </trans-unit>
        <trans-unit id="e10ad4b8d9ac04992efd38f05d15c560adaf42ef" translate="yes" xml:space="preserve">
          <source>Array of points. The dtype is converted to float64 or complex128 depending on whether any of the elements are complex. If &lt;code&gt;x&lt;/code&gt; is scalar it is converted to a 1-D array.</source>
          <target state="translated">ポイントの配列。dtypeは、要素が複雑かどうかに応じて、float64またはcomplex128に変換されます。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、1次元配列に変換されます。</target>
        </trans-unit>
        <trans-unit id="2608e7cd905fe0c68e32ec9f1d08d5e186ac4133" translate="yes" xml:space="preserve">
          <source>Array of polynomial coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">多項式係数の配列.cが多次元の場合,異なる軸は,対応するインデックスによって与えられる各軸の次数を持つ異なる変数に対応します.</target>
        </trans-unit>
        <trans-unit id="df9f1c9c3e6efbfb4f90ed818292071092d8d4f0" translate="yes" xml:space="preserve">
          <source>Array of random floats of shape &lt;code&gt;size&lt;/code&gt; (unless &lt;code&gt;size=None&lt;/code&gt;, in which case a single float is returned).</source>
          <target state="translated">形状 &lt;code&gt;size&lt;/code&gt; のランダムなフロートの配列（ &lt;code&gt;size=None&lt;/code&gt; の場合を除く。この場合、単一のフロートが返されます）。</target>
        </trans-unit>
        <trans-unit id="8c27164f605bc6a37751898bf3ccca7ad65d8b8c" translate="yes" xml:space="preserve">
          <source>Array of roots. If &lt;code&gt;r&lt;/code&gt; is multidimensional the first index is the root index, while the remaining indices enumerate multiple polynomials. For instance, in the two dimensional case the roots of each polynomial may be thought of as stored in the columns of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">ルートの配列。 &lt;code&gt;r&lt;/code&gt; が多次元の場合、最初のインデックスはルートインデックスで、残りのインデックスは複数の多項式を列挙します。たとえば、2次元の場合、各多項式の根は &lt;code&gt;r&lt;/code&gt; の列に格納されていると考えることができます。</target>
        </trans-unit>
        <trans-unit id="f5e105f8faad33b4f50f2c4896fe5c70b476d2c2" translate="yes" xml:space="preserve">
          <source>Array of the roots of the polynomial. If all the roots are real, then &lt;code&gt;out&lt;/code&gt; is also real, otherwise it is complex.</source>
          <target state="translated">多項式の根の配列。すべてのルーツが実在する場合、 &lt;code&gt;out&lt;/code&gt; も実在します。それ以外の場合は複雑です。</target>
        </trans-unit>
        <trans-unit id="4d0d9a7ae0205565ce5ab6637ea0bc6fd758edf0" translate="yes" xml:space="preserve">
          <source>Array of the roots of the series. If all the roots are real, then &lt;code&gt;out&lt;/code&gt; is also real, otherwise it is complex.</source>
          <target state="translated">シリーズのルートの配列。すべてのルーツが実在する場合、 &lt;code&gt;out&lt;/code&gt; も実在します。それ以外の場合は複雑です。</target>
        </trans-unit>
        <trans-unit id="d523e60421af0d15597be465d458af223885d81e" translate="yes" xml:space="preserve">
          <source>Array of the same shape as &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と同じ形状の配列。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="8fb65c76565be83184293a727b86b612f6baa966" translate="yes" xml:space="preserve">
          <source>Array of the same type and shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">同じタイプ及び形状のアレイ。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cde597bca9a6bd0298c0f76843af628711adacdc" translate="yes" xml:space="preserve">
          <source>Array of two or more dimensions.</source>
          <target state="translated">2つ以上の次元の配列。</target>
        </trans-unit>
        <trans-unit id="9c36b99254e0fa9d0972f22709ef88f81c5217da" translate="yes" xml:space="preserve">
          <source>Array of twos exponents. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">2の指数の配列。 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状にブロードキャスト可能でなければなりません（これが出力の形状になります）。</target>
        </trans-unit>
        <trans-unit id="ef176723af239a8b84441eb4e1012c9997a74190" translate="yes" xml:space="preserve">
          <source>Array of type uint8 whose elements represent bits corresponding to the logical (0 or nonzero) value of the input elements. The shape of &lt;code&gt;packed&lt;/code&gt; has the same number of dimensions as the input (unless &lt;code&gt;axis&lt;/code&gt; is None, in which case the output is 1-D).</source>
          <target state="translated">入力要素の論理値（0またはゼロ以外）に対応するビットを要素が表すuint8型の配列。 &lt;code&gt;packed&lt;/code&gt; の形状は、入力と同じ次元数を持ちます（ &lt;code&gt;axis&lt;/code&gt; がNoneでない場合、その場合、出力は1-Dです）。</target>
        </trans-unit>
        <trans-unit id="d136dd4eb12fa67aaa6854e035f05c7d1d6e0269" translate="yes" xml:space="preserve">
          <source>Array of uninitialized (arbitrary) data of the given shape, dtype, and order. Object arrays will be initialized to None.</source>
          <target state="translated">指定された形状、dtype、順序の初期化されていない(任意の)データの配列。オブジェクトの配列は、Noneに初期化されます。</target>
        </trans-unit>
        <trans-unit id="84a6a10448bc129791439e6ef9301081b2eae3db" translate="yes" xml:space="preserve">
          <source>Array of uninitialized (arbitrary) data with the same shape and type as &lt;code&gt;prototype&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;prototype&lt;/code&gt; と同じ形状およびタイプの初期化されていない（任意の）データの配列。</target>
        </trans-unit>
        <trans-unit id="1b00e6648235fca7be6befd806901affb44faa6e" translate="yes" xml:space="preserve">
          <source>Array of variates drawn from the multivariate hypergeometric distribution.</source>
          <target state="translated">多変量ハイパージオメトリック分布から引き出された変量の配列.</target>
        </trans-unit>
        <trans-unit id="e791423834bca116a632635c62e713e7f9a7037b" translate="yes" xml:space="preserve">
          <source>Array of zeros with the given shape, dtype, and order.</source>
          <target state="translated">指定された形状、dtype、および次数のゼロの配列。</target>
        </trans-unit>
        <trans-unit id="5118cee064bbe572e4b1416e1f0671b0db1bf70d" translate="yes" xml:space="preserve">
          <source>Array of zeros with the same shape and type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">同じ形状およびタイプとゼロのアレイ。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16e772e7005bc124d579516af58c7fbb273b27a8" translate="yes" xml:space="preserve">
          <source>Array or &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; object of the difference polynomial&amp;rsquo;s coefficients.</source>
          <target state="translated">差分多項式の係数の配列または&lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt; &lt;code&gt;poly1d&lt;/code&gt; &lt;/a&gt;オブジェクト。</target>
        </trans-unit>
        <trans-unit id="dbb2927a7be8102e0b46249ee761be13ecebeed6" translate="yes" xml:space="preserve">
          <source>Array or sequence of arrays storing the fields to add to the base.</source>
          <target state="translated">ベースに追加するフィールドを格納する配列または配列のシーケンス。</target>
        </trans-unit>
        <trans-unit id="367e141a4fff1b31230cbf6695c1abe0275a3a68" translate="yes" xml:space="preserve">
          <source>Array priority.</source>
          <target state="translated">配列の優先度。</target>
        </trans-unit>
        <trans-unit id="8afc8a14b9ea339f994a4b92b64eeee0fec93781" translate="yes" xml:space="preserve">
          <source>Array property returning the array transposed.</source>
          <target state="translated">転置された配列を返す配列プロパティ。</target>
        </trans-unit>
        <trans-unit id="e80625fd7e8e2e9a68261ea8336b974ac71427ae" translate="yes" xml:space="preserve">
          <source>Array protocol: Python side</source>
          <target state="translated">配列プロトコル。Python側</target>
        </trans-unit>
        <trans-unit id="4090e62e110e0132c9a83e32a1060b0b2b11ae1b" translate="yes" xml:space="preserve">
          <source>Array protocol: struct</source>
          <target state="translated">配列プロトコル:構造体</target>
        </trans-unit>
        <trans-unit id="8bf3a8f5e4206285d07a06e43310e4a207d5bd53" translate="yes" xml:space="preserve">
          <source>Array representing the Chebyshev series of their sum.</source>
          <target state="translated">チェビシェフ級数の和を表す配列です。</target>
        </trans-unit>
        <trans-unit id="eb3f194c486d46ce1508a5889e8d0e228c628dfe" translate="yes" xml:space="preserve">
          <source>Array representing the Hermite series of their sum.</source>
          <target state="translated">その和のエルミート級数を表す配列。</target>
        </trans-unit>
        <trans-unit id="18e93cb56abb59b15e14ea61f7ed36817dbde4e6" translate="yes" xml:space="preserve">
          <source>Array representing the Laguerre series of their sum.</source>
          <target state="translated">それらの和のラゲール級数を表す配列.</target>
        </trans-unit>
        <trans-unit id="ec5ec69f7e2ff45ce04c960bdf2303ea70114cd3" translate="yes" xml:space="preserve">
          <source>Array representing the Legendre series of their sum.</source>
          <target state="translated">その和のレジェンドレ級数を表す配列。</target>
        </trans-unit>
        <trans-unit id="edc338d6dbe8df5cb4ad885aef823a83fa3236d0" translate="yes" xml:space="preserve">
          <source>Array representing the result of the multiplication.</source>
          <target state="translated">乗算の結果を表す配列。</target>
        </trans-unit>
        <trans-unit id="016974069d41d6a6d61d2549905026f66c136979" translate="yes" xml:space="preserve">
          <source>Array scalar checks the value, array does not</source>
          <target state="translated">配列のスカラは値をチェックしますが、配列はチェックしません。</target>
        </trans-unit>
        <trans-unit id="cc176eaf5a192bedc6a645855de021bd9ca0e1d1" translate="yes" xml:space="preserve">
          <source>Array scalar type</source>
          <target state="translated">配列スカラ型</target>
        </trans-unit>
        <trans-unit id="2ef4e544d40cf2979c0c92b90830370b3508c12a" translate="yes" xml:space="preserve">
          <source>Array scalars can be indexed like 0-dimensional arrays: if &lt;em&gt;x&lt;/em&gt; is an array scalar,</source>
          <target state="translated">配列スカラーは、0次元配列のようにインデックスを付けることができます&lt;em&gt;。x&lt;/em&gt;が配列スカラーの場合、</target>
        </trans-unit>
        <trans-unit id="e33eacc8d6c4dbb6e2b8986e0cc11de2dc224ecc" translate="yes" xml:space="preserve">
          <source>Array scalars have exactly the same methods as arrays. The default behavior of these methods is to internally convert the scalar to an equivalent 0-dimensional array and to call the corresponding array method. In addition, math operations on array scalars are defined so that the same hardware flags are set and used to interpret the results as for &lt;a href=&quot;ufuncs#ufuncs&quot;&gt;ufunc&lt;/a&gt;, so that the error state used for ufuncs also carries over to the math on array scalars.</source>
          <target state="translated">配列スカラーは配列とまったく同じメソッドを持っています。これらのメソッドのデフォルトの動作は、内部的にスカラーを同等の0次元配列に変換し、対応する配列メソッドを呼び出すことです。さらに、配列スカラーに対する数学演算は、&lt;a href=&quot;ufuncs#ufuncs&quot;&gt;ufunc&lt;/a&gt;と同じハードウェアフラグが設定され、結果を解釈するために定義されているため、ufuncsに使用されるエラー状態は、配列スカラーの数学にも引き継がれます。</target>
        </trans-unit>
        <trans-unit id="037bfe1a4a99bed13c2116a48ffe9e15e096321a" translate="yes" xml:space="preserve">
          <source>Array scalars have the same attributes and methods as &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; This allows one to treat items of an array partly on the same footing as arrays, smoothing out rough edges that result when mixing scalar and array operations.</source>
          <target state="translated">配列スカラーには、&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt;と同じ属性とメソッドがあります。&lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;これにより、配列のアイテムを部分的に配列と同じ足場で処理し、スカラー演算と配列演算を混合したときに生じる粗いエッジを平滑化できます。</target>
        </trans-unit>
        <trans-unit id="9e3e59079f5e7b1524c0f3bc70e22cf06a0ad4de" translate="yes" xml:space="preserve">
          <source>Array scalars have the same attributes and methods as &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; This allows one to treat items of an array partly on the same footing as arrays, smoothing out rough edges that result when mixing scalar and array operations.</source>
          <target state="translated">配列スカラーは&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt;と同じ属性とメソッドを持っています。&lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;これにより、配列のアイテムを部分的に配列と同じフーチングで処理し、スカラーと配列の操作を混合したときに生じる粗いエッジを滑らかにすることができます。</target>
        </trans-unit>
        <trans-unit id="9ed6ac908bf9aa1daed6dabda3ab37ae3cfe93cc" translate="yes" xml:space="preserve">
          <source>Array scalars live in a hierarchy (see the Figure below) of data types. They can be detected using the hierarchy: For example, &lt;code&gt;isinstance(val, np.generic)&lt;/code&gt; will return &lt;code&gt;True&lt;/code&gt; if &lt;em&gt;val&lt;/em&gt; is an array scalar object. Alternatively, what kind of array scalar is present can be determined using other members of the data type hierarchy. Thus, for example &lt;code&gt;isinstance(val, np.complexfloating)&lt;/code&gt; will return &lt;code&gt;True&lt;/code&gt; if &lt;em&gt;val&lt;/em&gt; is a complex valued type, while &lt;code&gt;isinstance(val, np.flexible)&lt;/code&gt; will return true if &lt;em&gt;val&lt;/em&gt; is one of the flexible itemsize array types (&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;unicode&lt;/code&gt;, &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">配列スカラーは、データ型の階層（下図を参照）にあります。これらは、階層を使用して検出できます。たとえば、&lt;em&gt;val&lt;/em&gt;が配列スカラーオブジェクトの場合、 &lt;code&gt;isinstance(val, np.generic)&lt;/code&gt; は &lt;code&gt;True&lt;/code&gt; を返します。あるいは、存在する配列スカラーの種類は、データ型階層の他のメンバーを使用して決定できます。したがって、たとえば、 &lt;code&gt;isinstance(val, np.complexfloating)&lt;/code&gt; は、&lt;em&gt;val&lt;/em&gt;が複素数値型の場合は &lt;code&gt;True&lt;/code&gt; を返し、 &lt;code&gt;isinstance(val, np.flexible)&lt;/code&gt; は、&lt;em&gt;val&lt;/em&gt;がフレキシブルアイテムサイズ配列型（ &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;unicode&lt;/code&gt; 、 &lt;code&gt;void&lt;/code&gt; ）。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="656531cc575d33e2858cc0fa46ccccf4a68a1757" translate="yes" xml:space="preserve">
          <source>Array shape.</source>
          <target state="translated">配列の形状。</target>
        </trans-unit>
        <trans-unit id="ef64ccc224961e26021d9bca9dc014037c55120d" translate="yes" xml:space="preserve">
          <source>Array structure and data access</source>
          <target state="translated">配列構造とデータアクセス</target>
        </trans-unit>
        <trans-unit id="342f29da2bf216f5bdf0ad7248aaa9e71a355727" translate="yes" xml:space="preserve">
          <source>Array that selects which entries to return. If len(condition) is less than the size of &lt;code&gt;a&lt;/code&gt; along the given axis, then output is truncated to the length of the condition array.</source>
          <target state="translated">返すエントリを選択する配列。len（condition）が指定された軸に沿った &lt;code&gt;a&lt;/code&gt; のサイズより小さい場合、出力は条件配列の長さに切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="592206156ca99ae21d8e7426eb607780c1bba521" translate="yes" xml:space="preserve">
          <source>Array that suppressed values indicated by a mask:</source>
          <target state="translated">マスクで示された値を抑制した配列。</target>
        </trans-unit>
        <trans-unit id="87d2918cacf26a2502b4f9340bca07e66e5e74fe" translate="yes" xml:space="preserve">
          <source>Array to be divided into sub-arrays.</source>
          <target state="translated">サブ配列に分割する配列。</target>
        </trans-unit>
        <trans-unit id="e4b60ba832fd5d14a8b64e94627ba0a71256396f" translate="yes" xml:space="preserve">
          <source>Array to be reshaped.</source>
          <target state="translated">リシェイプされる配列。</target>
        </trans-unit>
        <trans-unit id="873958f5c5efd8efa35f71b483ecb2b2925a1b71" translate="yes" xml:space="preserve">
          <source>Array to be resized.</source>
          <target state="translated">リサイズされる配列。</target>
        </trans-unit>
        <trans-unit id="b52f152b24d91c43ef9fb5209bce09865fb8369b" translate="yes" xml:space="preserve">
          <source>Array to be sorted.</source>
          <target state="translated">ソートされる配列。</target>
        </trans-unit>
        <trans-unit id="6b0f55aa6f40b643ba50d2b1a53516ef1346869f" translate="yes" xml:space="preserve">
          <source>Array to check for masked values.</source>
          <target state="translated">マスクされた値をチェックするための配列。</target>
        </trans-unit>
        <trans-unit id="20f86a6d67f17e927d1d04df5d4b886d82463103" translate="yes" xml:space="preserve">
          <source>Array to create a new.</source>
          <target state="translated">新しいものを作成するための配列です。</target>
        </trans-unit>
        <trans-unit id="a70bc91712a140c808e5cb79192527e68b6c9390" translate="yes" xml:space="preserve">
          <source>Array to mask</source>
          <target state="translated">マスクする配列</target>
        </trans-unit>
        <trans-unit id="d43e409e24f30f0a6d90180b76c2efb4ab130452" translate="yes" xml:space="preserve">
          <source>Array to mask.</source>
          <target state="translated">マスクする配列。</target>
        </trans-unit>
        <trans-unit id="83c52b56e1210abcac3501b49e1d67729c904dfd" translate="yes" xml:space="preserve">
          <source>Array to put data into.</source>
          <target state="translated">データを入れる配列。</target>
        </trans-unit>
        <trans-unit id="fd5b40620a3c780ffc94d7f339fd1c7607c14c60" translate="yes" xml:space="preserve">
          <source>Array to sort.</source>
          <target state="translated">ソートする配列。</target>
        </trans-unit>
        <trans-unit id="63fbdd1db19d27a9a5c7eab3d132c8bb3f503729" translate="yes" xml:space="preserve">
          <source>Array to test.</source>
          <target state="translated">テストする配列。</target>
        </trans-unit>
        <trans-unit id="55a565dc87ad0f5b9c2ac3f528dacc1158c373a0" translate="yes" xml:space="preserve">
          <source>Array type testing</source>
          <target state="translated">配列型のテスト</target>
        </trans-unit>
        <trans-unit id="585f95a404e839b1977230612e779c3487e0200e" translate="yes" xml:space="preserve">
          <source>Array types and conversions between types</source>
          <target state="translated">配列の型と型間の変換</target>
        </trans-unit>
        <trans-unit id="023792f2b2e17a7b6e86f7c45b577b4c007acb28" translate="yes" xml:space="preserve">
          <source>Array types can also be referred to by character codes, mostly to retain backward compatibility with older packages such as Numeric. Some documentation may still refer to these, for example:</source>
          <target state="translated">配列型は文字コードで参照することもできますが、これは主に Numeric のような古いパッケージとの下位互換性を維持するためです。ドキュメントの中には、例えば、今でもこれらを参照しているものがあります。</target>
        </trans-unit>
        <trans-unit id="e4bb8dd78a4c9a8f67c530c9ad1b7a619c52bea4" translate="yes" xml:space="preserve">
          <source>Array whose diagonal is to be filled, it gets modified in-place.</source>
          <target state="translated">対角線が塗りつぶされる配列は、その場で修正されます。</target>
        </trans-unit>
        <trans-unit id="82c627b6cd9b7d074082f31470ca27bba3557192" translate="yes" xml:space="preserve">
          <source>Array with its lower triangle filled with ones and zero elsewhere; in other words &lt;code&gt;T[i,j] == 1&lt;/code&gt; for &lt;code&gt;i &amp;lt;= j + k&lt;/code&gt;, 0 otherwise.</source>
          <target state="translated">下の三角形が1で埋められ、他の場所で0で埋められた配列。つまり、 &lt;code&gt;T[i,j] == 1&lt;/code&gt; for &lt;code&gt;i &amp;lt;= j + k&lt;/code&gt; 、それ以外の場合は0。</target>
        </trans-unit>
        <trans-unit id="b85c2934c5f2a59bc2e12dac7625860a488c925e" translate="yes" xml:space="preserve">
          <source>Array with its lower triangle filled with ones and zero elsewhere; in other words &lt;code&gt;T[i,j] == 1&lt;/code&gt; for &lt;code&gt;j &amp;lt;= i + k&lt;/code&gt;, 0 otherwise.</source>
          <target state="translated">下の三角形が1で埋められ、他の場所では0で埋められた配列。言い換えると、 &lt;code&gt;j &amp;lt;= i + k&lt;/code&gt; 場合は &lt;code&gt;T[i,j] == 1&lt;/code&gt; 、それ以外の場合は0です。</target>
        </trans-unit>
        <trans-unit id="41b54b4163faf0b1aa96452981f42d33d50824ef" translate="yes" xml:space="preserve">
          <source>Array with moved axes. This array is a view of the input array.</source>
          <target state="translated">軸を移動した配列です。この配列は入力配列のビューです。</target>
        </trans-unit>
        <trans-unit id="84addce66651c27032bab9126d05042eeca1af0e" translate="yes" xml:space="preserve">
          <source>Array with specified requirements and type if given.</source>
          <target state="translated">指定された要件と型を持つ配列。</target>
        </trans-unit>
        <trans-unit id="45f77fd17de7e78ac597a13bf5b178d24ee5d7aa" translate="yes" xml:space="preserve">
          <source>Array-checking restype/argtypes.</source>
          <target state="translated">restype/argtypesの配列チェックを行います。</target>
        </trans-unit>
        <trans-unit id="54d7e23aa660ea078adfa79ac4b2e54c5ef44772" translate="yes" xml:space="preserve">
          <source>Array-protocol type strings (see &lt;a href=&quot;arrays.interface#arrays-interface&quot;&gt;The Array Interface&lt;/a&gt;)</source>
          <target state="translated">配列プロトコルタイプの文字列（&lt;a href=&quot;arrays.interface#arrays-interface&quot;&gt;配列インターフェイスを&lt;/a&gt;参照）</target>
        </trans-unit>
        <trans-unit id="7bf6ce513964e0342411a0531bf1b89c426a52c9" translate="yes" xml:space="preserve">
          <source>Array-scalar types</source>
          <target state="translated">配列スカラ型</target>
        </trans-unit>
        <trans-unit id="a50913b40e0e8d9dc26876d10bb49f2fa38c66fb" translate="yes" xml:space="preserve">
          <source>Array_like means all those objects &amp;ndash; lists, nested lists, etc. &amp;ndash; that can be converted to an array. We can also refer to variables like &lt;code&gt;var1&lt;/code&gt;.</source>
          <target state="translated">Array_likeは、配列に変換できるすべてのオブジェクト（リスト、ネストされたリストなど）を意味します。 &lt;code&gt;var1&lt;/code&gt; のような変数を参照することもできます。</target>
        </trans-unit>
        <trans-unit id="31b1e39950526e77b6041b42fc1b62056a817d46" translate="yes" xml:space="preserve">
          <source>Arrays &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; must have the same shape.</source>
          <target state="translated">配列 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; は同じ形状でなければなりません。</target>
        </trans-unit>
        <trans-unit id="f2499f813f17514e2097a1073a6cd307b768602d" translate="yes" xml:space="preserve">
          <source>Arrays based off readonly buffers cannot be set &lt;code&gt;writeable&lt;/code&gt;</source>
          <target state="translated">読み取り専用バッファに基づく配列は &lt;code&gt;writeable&lt;/code&gt; に設定できません</target>
        </trans-unit>
        <trans-unit id="f1c67ac3218c1c87b31cea1d27a13f34756f157a" translate="yes" xml:space="preserve">
          <source>Arrays can be both C-style and Fortran-style contiguous simultaneously. This is clear for 1-dimensional arrays, but can also be true for higher dimensional arrays.</source>
          <target state="translated">配列はCスタイルとFortranスタイルの両方を同時に連続させることができます。これは1次元の配列では明らかですが,より高次元の配列でも同じことが言えます.</target>
        </trans-unit>
        <trans-unit id="9cba266ac8d90f704b5607af4e06eea419c285f7" translate="yes" xml:space="preserve">
          <source>Arrays can be indexed using an extended Python slicing syntax, &lt;code&gt;array[selection]&lt;/code&gt;. Similar syntax is also used for accessing fields in a &lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;.</source>
          <target state="translated">配列は、拡張Pythonスライシング構文 &lt;code&gt;array[selection]&lt;/code&gt; を使用してインデックスを付けることができます。同様の構文は、&lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;構造化データ型の&lt;/a&gt;フィールドにアクセスするためにも使用されます。</target>
        </trans-unit>
        <trans-unit id="aac913dee168d782f611f9dc70790bf862c5b21d" translate="yes" xml:space="preserve">
          <source>Arrays can be indexed using an extended Python slicing syntax, &lt;code&gt;array[selection]&lt;/code&gt;. Similar syntax is also used for accessing fields in a &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;.</source>
          <target state="translated">配列は、拡張されたPythonスライス構文 &lt;code&gt;array[selection]&lt;/code&gt; を使用してインデックスを付けることができます。同様の構文は、&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;構造化データタイプの&lt;/a&gt;フィールドへのアクセスにも使用されます。</target>
        </trans-unit>
        <trans-unit id="d674e5d59a78e41b46aaf270748b55f0fb8f59d0" translate="yes" xml:space="preserve">
          <source>Arrays do not need to have the same &lt;em&gt;number&lt;/em&gt; of dimensions. For example, if you have a &lt;code&gt;256x256x3&lt;/code&gt; array of RGB values, and you want to scale each color in the image by a different value, you can multiply the image by a one-dimensional array with 3 values. Lining up the sizes of the trailing axes of these arrays according to the broadcast rules, shows that they are compatible:</source>
          <target state="translated">配列は同じ&lt;em&gt;数&lt;/em&gt;の次元である必要はありません。たとえば、RGB値の &lt;code&gt;256x256x3&lt;/code&gt; 配列があり、画像の各色を異なる値でスケーリングする場合は、画像に3つの値を持つ1次元配列を掛けることができます。ブロードキャストルールに従ってこれらの配列の末尾の軸のサイズを並べると、互換性があることがわかります。</target>
        </trans-unit>
        <trans-unit id="00ec5e3a73cb29954290e60a6bc0ab13e3437ef3" translate="yes" xml:space="preserve">
          <source>Arrays may have a data-types containing fields, analogous to columns in a spread sheet. An example is &lt;code&gt;[(x, int), (y, float)]&lt;/code&gt;, where each entry in the array is a pair of &lt;code&gt;(int, float)&lt;/code&gt;. Normally, these attributes are accessed using dictionary lookups such as &lt;code&gt;arr['x']&lt;/code&gt; and &lt;code&gt;arr['y']&lt;/code&gt;. Record arrays allow the fields to be accessed as members of the array, using &lt;code&gt;arr.x&lt;/code&gt; and &lt;code&gt;arr.y&lt;/code&gt;.</source>
          <target state="translated">配列は、スプレッドシートの列に類似したフィールドを含むデータ型を持つことができます。例は &lt;code&gt;[(x, int), (y, float)]&lt;/code&gt; で、配列の各エントリは &lt;code&gt;(int, float)&lt;/code&gt; ペアです。通常、これらの属性には、 &lt;code&gt;arr['x']&lt;/code&gt; や &lt;code&gt;arr['y']&lt;/code&gt; などの辞書検索を使用してアクセスします。レコード配列では、 &lt;code&gt;arr.x&lt;/code&gt; と &lt;code&gt;arr.y&lt;/code&gt; を使用して、配列のメンバーとしてフィールドにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="b36ecf0a7f7bd039ed5c1c0704a51fefda73d80e" translate="yes" xml:space="preserve">
          <source>Arrays may have more than one dimension, each which can be sliced individually:</source>
          <target state="translated">配列は複数の次元を持つことができ、それぞれを個別にスライスすることができます。</target>
        </trans-unit>
        <trans-unit id="ef7c0cea98d6d20ecb3d174c3213bef74e8bc018" translate="yes" xml:space="preserve">
          <source>Arrays of byte-strings are not swapped</source>
          <target state="translated">バイト列の配列はスワップされない</target>
        </trans-unit>
        <trans-unit id="d404bf1fb512f78d1d6fefbd98ddbbf1ae665dd2" translate="yes" xml:space="preserve">
          <source>Arrays of evenly spaced numbers in N-dimensions.</source>
          <target state="translated">N次元の等間隔の数値の配列。</target>
        </trans-unit>
        <trans-unit id="b8de1bbbfd3c637354288fac451e8a7c60ba28fc" translate="yes" xml:space="preserve">
          <source>Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays.</source>
          <target state="translated">点座標の配列で、すべて同じ形をしています。dtypesは、要素のいずれかが複素数であるかどうかに応じて、float64またはcomplex128のいずれかに変換されます。スカラーは1次元配列に変換されます。</target>
        </trans-unit>
        <trans-unit id="52434d147f7a6b19ab25a12561971251796b7c3c" translate="yes" xml:space="preserve">
          <source>Arrays of strings are not swapped</source>
          <target state="translated">文字列の配列はスワップされない</target>
        </trans-unit>
        <trans-unit id="fc13f22057f28c646ca1b198ca565af87af49f1b" translate="yes" xml:space="preserve">
          <source>Arrays of values. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">値の配列。 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 場合、それらは共通の形状にブロードキャスト可能でなければなりません（これが出力の形状になります）。</target>
        </trans-unit>
        <trans-unit id="e6f0032138e45d68f74e2c44f2f735c8b5313272" translate="yes" xml:space="preserve">
          <source>Arrays should be constructed using &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;zeros&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.empty#numpy.empty&quot;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt; (refer to the See Also section below). The parameters given here refer to a low-level method (&lt;code&gt;ndarray(&amp;hellip;)&lt;/code&gt;) for instantiating an array.</source>
          <target state="translated">配列は、&lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;zeros&lt;/code&gt; 、&lt;/a&gt;または&lt;a href=&quot;numpy.empty#numpy.empty&quot;&gt; &lt;code&gt;empty&lt;/code&gt; &lt;/a&gt;を使用して構築する必要があります（以下の「関連項目」セクションを参照）。ここで指定するパラメーターは、配列をインスタンス化するための低レベルのメソッド（ &lt;code&gt;ndarray(&amp;hellip;)&lt;/code&gt; ）を参照します。</target>
        </trans-unit>
        <trans-unit id="bcfb0f71df3562232665c06d9cf63f39acceecc4" translate="yes" xml:space="preserve">
          <source>Arrays to be compared.</source>
          <target state="translated">比較対象の配列。</target>
        </trans-unit>
        <trans-unit id="c2fde1777833050ff202f7b922dc5d2847610f32" translate="yes" xml:space="preserve">
          <source>Arrays to save to the file. Arrays will be saved in the file with the keyword names.</source>
          <target state="translated">ファイルに保存する配列。配列はキーワード名でファイルに保存されます。</target>
        </trans-unit>
        <trans-unit id="4ba46cb118e6a4c1684691ff4c3a66ca5c9411f7" translate="yes" xml:space="preserve">
          <source>Arrays to save to the file. Since it is not possible for Python to know the names of the arrays outside &lt;a href=&quot;#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt;, the arrays will be saved with names &amp;ldquo;arr_0&amp;rdquo;, &amp;ldquo;arr_1&amp;rdquo;, and so on. These arguments can be any expression.</source>
          <target state="translated">ファイルに保存する配列。Pythonは&lt;a href=&quot;#numpy.savez&quot;&gt; &lt;code&gt;savez&lt;/code&gt; の&lt;/a&gt;外で配列の名前を知ることができないため、配列は「arr_0」、「arr_1」などの名前で保存されます。これらの引数は任意の式にすることができます。</target>
        </trans-unit>
        <trans-unit id="f51d18ef0f932163df8ae83aea003301ffa197e5" translate="yes" xml:space="preserve">
          <source>Arrays to save to the file. Since it is not possible for Python to know the names of the arrays outside &lt;a href=&quot;numpy.savez#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt;, the arrays will be saved with names &amp;ldquo;arr_0&amp;rdquo;, &amp;ldquo;arr_1&amp;rdquo;, and so on. These arguments can be any expression.</source>
          <target state="translated">ファイルに保存する配列。Pythonは&lt;a href=&quot;numpy.savez#numpy.savez&quot;&gt; &lt;code&gt;savez&lt;/code&gt; の&lt;/a&gt;外で配列の名前を知ることができないため、配列は「arr_0」、「arr_1」などの名前で保存されます。これらの引数は任意の式にすることができます。</target>
        </trans-unit>
        <trans-unit id="44d87a6dc57d91b7292b09dc95f59e76af66bd2d" translate="yes" xml:space="preserve">
          <source>Arrays to stack. All of them must have the same first dimension.</source>
          <target state="translated">スタックする配列。すべて同じ第一次元を持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="b99248188fbd19d8c22a40832b75d837dc4de460" translate="yes" xml:space="preserve">
          <source>Arrays with complex dtypes don&amp;rsquo;t return True.</source>
          <target state="translated">複雑なdtypeを持つ配列はTrueを返しません。</target>
        </trans-unit>
        <trans-unit id="a2bd40fc5b54aa90919de15beac751e23ad15489" translate="yes" xml:space="preserve">
          <source>Arrayterator (class in numpy.lib)</source>
          <target state="translated">Arrayterator (numpy.lib のクラス)</target>
        </trans-unit>
        <trans-unit id="816e3f055425505d10d82fdb50f19dc782762aaa" translate="yes" xml:space="preserve">
          <source>Arrayterator.flat</source>
          <target state="translated">Arrayterator.flat</target>
        </trans-unit>
        <trans-unit id="e63ac43cdcb5a4238c7b9262748f81e7cf3457ea" translate="yes" xml:space="preserve">
          <source>Arrayterator.shape</source>
          <target state="translated">Arrayterator.shape</target>
        </trans-unit>
        <trans-unit id="62735fb443777d7de2d1c29ccbb762ccfb2be570" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, a masked array also inherits all the attributes and properties of a &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; で&lt;/a&gt;のサブクラスである&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;、マスクされた配列はまた、すべての属性とプロパティを継承&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;インスタンス。</target>
        </trans-unit>
        <trans-unit id="bdc5d12d9a06d1a300c059aee30b6e3298b8cd56" translate="yes" xml:space="preserve">
          <source>As Numeric has matured and developed into NumPy, people have been able to write more code directly in NumPy. Often this code is fast-enough for production use, but there are still times that there is a need to access compiled code. Either to get that last bit of efficiency out of the algorithm or to make it easier to access widely-available codes written in C/C++ or Fortran.</source>
          <target state="translated">Numericが成熟し、NumPyに発展するにつれ、人々はより多くのコードをNumPyで直接書くことができるようになりました。多くの場合、このコードはプロダクションで使用するには十分な速さですが、コンパイルされたコードにアクセスする必要がある場合もあります。アルゴリズムから最後の一歩を効率化するため、あるいはC/C++やFortranで書かれた広く利用可能なコードへのアクセスを容易にするためです。</target>
        </trans-unit>
        <trans-unit id="266410aaeb848f2f7510db1bcf8e20c2778f75df" translate="yes" xml:space="preserve">
          <source>As a &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, it inherits its mechanisms for indexing and slicing.</source>
          <target state="translated">&lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; で&lt;/a&gt;のサブクラスで&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt;、それはインデックスとスライスのためにその機構を継承します。</target>
        </trans-unit>
        <trans-unit id="572a6b072b5d5bfb6b919bf3e8415158c50e5fd9" translate="yes" xml:space="preserve">
          <source>As a convenience for &lt;code&gt;__array_function__&lt;/code&gt; implementors, &lt;code&gt;types&lt;/code&gt; provides all argument types with an &lt;code&gt;'__array_function__'&lt;/code&gt; attribute. This allows implementors to quickly identify cases where they should defer to &lt;code&gt;__array_function__&lt;/code&gt; implementations on other arguments. Implementations should not rely on the iteration order of &lt;code&gt;types&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__array_function__&lt;/code&gt; インプリメンターの便宜上、 &lt;code&gt;types&lt;/code&gt; はすべての引数の型に &lt;code&gt;'__array_function__'&lt;/code&gt; 属性を提供します。これにより、実装者は他の引数の &lt;code&gt;__array_function__&lt;/code&gt; 実装を遅延させる必要があるケースをすばやく特定できます。実装では、 &lt;code&gt;types&lt;/code&gt; の反復順序に依存しないでください。</target>
        </trans-unit>
        <trans-unit id="943758d1e20ad4276263519968fa94f16b718bb2" translate="yes" xml:space="preserve">
          <source>As a corollary to this change, we no longer prohibit casting between datetimes with date units and datetimes with timeunits. With timezone naive datetimes, the rule for casting from dates to times is no longer ambiguous.</source>
          <target state="translated">この変更に付随して、日付単位のdatetimesと時間単位のdatetimesの間のキャストを禁止しなくなりました。timezoneのナイーブなdatetimesでは、日付から時刻へのキャストのルールが曖昧ではなくなりました。</target>
        </trans-unit>
        <trans-unit id="013d98a5ec5b7f58afd0279b5cb85ae341df8643" translate="yes" xml:space="preserve">
          <source>As a final note: if the &lt;code&gt;super&lt;/code&gt; route is suited to a given class, an advantage of using it is that it helps in constructing class hierarchies. E.g., suppose that our other class &lt;code&gt;B&lt;/code&gt; also used the &lt;code&gt;super&lt;/code&gt; in its &lt;code&gt;__array_ufunc__&lt;/code&gt; implementation, and we created a class &lt;code&gt;C&lt;/code&gt; that depended on both, i.e., &lt;code&gt;class C(A, B)&lt;/code&gt; (with, for simplicity, not another &lt;code&gt;__array_ufunc__&lt;/code&gt; override). Then any ufunc on an instance of &lt;code&gt;C&lt;/code&gt; would pass on to &lt;code&gt;A.__array_ufunc__&lt;/code&gt;, the &lt;code&gt;super&lt;/code&gt; call in &lt;code&gt;A&lt;/code&gt; would go to &lt;code&gt;B.__array_ufunc__&lt;/code&gt;, and the &lt;code&gt;super&lt;/code&gt; call in &lt;code&gt;B&lt;/code&gt; would go to &lt;code&gt;ndarray.__array_ufunc__&lt;/code&gt;, thus allowing &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; to collaborate.</source>
          <target state="translated">最後に、 &lt;code&gt;super&lt;/code&gt; ルートが特定のクラスに適している場合、それを使用する利点は、クラス階層の構築に役立つことです。たとえば、他のクラス &lt;code&gt;B&lt;/code&gt; も &lt;code&gt;__array_ufunc__&lt;/code&gt; 実装で &lt;code&gt;super&lt;/code&gt; を使用し、両方に依存するクラス &lt;code&gt;C&lt;/code&gt; 、つまり &lt;code&gt;class C(A, B)&lt;/code&gt; を作成したとします（簡単にするために、別の &lt;code&gt;__array_ufunc__&lt;/code&gt; オーバーライドは使用しません）。その後のインスタンスのufunc &lt;code&gt;C&lt;/code&gt; がに渡すでしょう &lt;code&gt;A.__array_ufunc__&lt;/code&gt; 、 &lt;code&gt;super&lt;/code&gt; でのコール &lt;code&gt;A&lt;/code&gt; はに行くと &lt;code&gt;B.__array_ufunc__&lt;/code&gt; 、および &lt;code&gt;super&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; を呼び出すと、 &lt;code&gt;ndarray.__array_ufunc__&lt;/code&gt; 、 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; が共同作業できるようになります。</target>
        </trans-unit>
        <trans-unit id="20a42179492180fa8aaa4dc644b08e20ca1aef18" translate="yes" xml:space="preserve">
          <source>As an alternative to &lt;code&gt;pytest.mark.&amp;lt;label&amp;gt;&lt;/code&gt;, there are a number of labels you can use.</source>
          <target state="translated">&lt;code&gt;pytest.mark.&amp;lt;label&amp;gt;&lt;/code&gt; 代わりに、使用できるラベルがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="3dab1c17c36782c312875481e08692d9b809435e" translate="yes" xml:space="preserve">
          <source>As an example, for &lt;code&gt;numpy.mean&lt;/code&gt; we would have:</source>
          <target state="translated">例として、 &lt;code&gt;numpy.mean&lt;/code&gt; の場合、次のようになります。</target>
        </trans-unit>
        <trans-unit id="fecff8f943e371686abc1110d1711ebbbb86c5fa" translate="yes" xml:space="preserve">
          <source>As an example, see the 1.14.3 REL commit: &lt;a href=&quot;https://github.com/numpy/numpy/commit/73299826729be58cec179b52c656adfcaefada93&quot;&gt;https://github.com/numpy/numpy/commit/73299826729be58cec179b52c656adfcaefada93&lt;/a&gt;.</source>
          <target state="translated">例として、1.14.3 RELコミットを参照して&lt;a href=&quot;https://github.com/numpy/numpy/commit/73299826729be58cec179b52c656adfcaefada93&quot;&gt;ください&lt;/a&gt;：https：//github.com/numpy/numpy/commit/73299826729be58cec179b52c656adfcaefada93。</target>
        </trans-unit>
        <trans-unit id="f7ec8e32822a5e0a0d90b5363a2541452778cbc3" translate="yes" xml:space="preserve">
          <source>As an example, we print out the result of broadcasting a one and a two dimensional array together.</source>
          <target state="translated">例として、1次元配列と2次元配列を一緒に放送した結果をプリントアウトします。</target>
        </trans-unit>
        <trans-unit id="8f262d8c602a1c1784a0611d8d573ccc9d004b7a" translate="yes" xml:space="preserve">
          <source>As an illustration, let&amp;rsquo;s consider the following dataset:</source>
          <target state="translated">例として、次のデータセットを考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="06bd4fa6779fdd07b3d52175c70a52bf6deacdac" translate="yes" xml:space="preserve">
          <source>As an optional convenience numpy provides an ndarray subclass, &lt;a href=&quot;../reference/generated/numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;numpy.recarray&lt;/code&gt;&lt;/a&gt;, and associated helper functions in the &lt;code&gt;numpy.rec&lt;/code&gt; submodule, that allows access to fields of structured arrays by attribute instead of only by index. Record arrays also use a special datatype, &lt;a href=&quot;../reference/generated/numpy.record#numpy.record&quot;&gt;&lt;code&gt;numpy.record&lt;/code&gt;&lt;/a&gt;, that allows field access by attribute on the structured scalars obtained from the array.</source>
          <target state="translated">オプションとして、numpyは、ndarrayサブクラス、&lt;a href=&quot;../reference/generated/numpy.recarray#numpy.recarray&quot;&gt; &lt;code&gt;numpy.recarray&lt;/code&gt; &lt;/a&gt;、および &lt;code&gt;numpy.rec&lt;/code&gt; サブモジュール内の関連するヘルパー関数を提供します。これにより、インデックスだけでなく属性ごとに構造化配列のフィールドにアクセスできます。レコード配列は、特別なデータ型&lt;a href=&quot;../reference/generated/numpy.record#numpy.record&quot;&gt; &lt;code&gt;numpy.record&lt;/code&gt; &lt;/a&gt;も使用します。これにより、配列から取得した構造化スカラーの属性によるフィールドアクセスが可能になります。</target>
        </trans-unit>
        <trans-unit id="ff6fd804dd39db5798ff08b4b25e0937a2c068e3" translate="yes" xml:space="preserve">
          <source>As an trivial example, consider this implementation of an &lt;code&gt;ArrayLike&lt;/code&gt; class that simply wraps a NumPy array and ensures that the result of any arithmetic operation is also an &lt;code&gt;ArrayLike&lt;/code&gt; object:</source>
          <target state="translated">簡単な例として、単純にNumPy配列をラップし、算術演算の結果も &lt;code&gt;ArrayLike&lt;/code&gt; オブジェクトになることを保証する &lt;code&gt;ArrayLike&lt;/code&gt; クラスのこの実装を検討してください。</target>
        </trans-unit>
        <trans-unit id="cede8d515f0ee49ac10c9ddedbb9f437527bae9a" translate="yes" xml:space="preserve">
          <source>As can be seen, the &amp;ldquo;good&amp;rdquo; parts have shrunk to insignificance. In using Chebyshev polynomials for fitting we want to use the region where &lt;code&gt;x&lt;/code&gt; is between -1 and 1 and that is what the &lt;code&gt;window&lt;/code&gt; specifies. However, it is unlikely that the data to be fit has all its data points in that interval, so we use &lt;code&gt;domain&lt;/code&gt; to specify the interval where the data points lie. When the fit is done, the domain is first mapped to the window by a linear transformation and the usual least squares fit is done using the mapped data points. The window and domain of the fit are part of the returned series and are automatically used when computing values, derivatives, and such. If they aren&amp;rsquo;t specified in the call the fitting routine will use the default window and the smallest domain that holds all the data points. This is illustrated below for a fit to a noisy sine curve.</source>
          <target state="translated">見て分かるように、「良い」部品は重要ではないほど縮小しています。チェビシェフ多項式をフィッティングに使用する場合、 &lt;code&gt;x&lt;/code&gt; が-1から1までの領域を使用し、 &lt;code&gt;window&lt;/code&gt; 指定します。ただし、当てはめるデータのすべてのデータポイントがその間隔内にあるとは考えにくいため、 &lt;code&gt;domain&lt;/code&gt; を使用します。データポイントの間隔を指定します。近似が完了すると、ドメインはまず線形変換によってウィンドウにマッピングされ、通常の最小二乗近似はマッピングされたデータポイントを使用して行われます。当てはめのウィンドウとドメインは返される系列の一部であり、値、導関数などを計算するときに自動的に使用されます。それらが呼び出しで指定されていない場合、フィッティングルーチンはデフォルトのウィンドウとすべてのデータポイントを保持する最小のドメインを使用します。これは、ノイズのある正弦曲線への当てはめのために以下に示されています。</target>
        </trans-unit>
        <trans-unit id="e0bc58a150fd519b1ef1b28d23e1c4528291bcac" translate="yes" xml:space="preserve">
          <source>As expected, this is a 768x1024 matrix:</source>
          <target state="translated">さすがに768×1024の行列です。</target>
        </trans-unit>
        <trans-unit id="c53fc1e45dbe406be17b6e30a5cfb9d43c0f2859" translate="yes" xml:space="preserve">
          <source>As explained previously, C-style contiguous arrays and Fortran-style contiguous arrays have particular striding patterns. Two array flags (&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;) indicate whether or not the striding pattern of a particular array matches the C-style contiguous or Fortran-style contiguous or neither. Whether or not the striding pattern matches a standard C or Fortran one can be tested Using &lt;a href=&quot;../reference/c-api/array#c.PyArray_IS_C_CONTIGUOUS&quot;&gt;&lt;code&gt;PyArray_IS_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (obj) and &lt;a href=&quot;../reference/c-api/array#c.PyArray_ISFORTRAN&quot;&gt;&lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt;&lt;/a&gt; (obj) respectively. Most third-party libraries expect contiguous arrays. But, often it is not difficult to support general-purpose striding. I encourage you to use the striding information in your own code whenever possible, and reserve single-segment requirements for wrapping third-party code. Using the striding information provided with the ndarray rather than requiring a contiguous striding reduces copying that otherwise must be made.</source>
          <target state="translated">前に説明したように、Cスタイルの連続配列とFortranスタイルの連続配列には特定のストライドパターンがあります。 2つの配列フラグ（&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;）は、特定の配列のストライドパターンがCスタイルの連続またはFortranスタイルの連続と一致するかどうかを示します。ストライドパターンが標準のCまたはFortranに一致するかどうかは、&lt;a href=&quot;../reference/c-api/array#c.PyArray_IS_C_CONTIGUOUS&quot;&gt; &lt;code&gt;PyArray_IS_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;（obj）および&lt;a href=&quot;../reference/c-api/array#c.PyArray_ISFORTRAN&quot;&gt; &lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt; &lt;/a&gt;を使用してテストできます。（obj）それぞれ。ほとんどのサードパーティライブラリは、連続した配列を想定しています。しかし、多くの場合、汎用ストライドをサポートすることは難しくありません。可能な限り、独自のコードでストライド情報を使用し、サードパーティのコードをラップするための単一セグメントの要件を予約することをお勧めします。連続したストライドを必要とするのではなく、ndarrayで提供されるストライド情報を使用すると、コピーを減らすことができます。</target>
        </trans-unit>
        <trans-unit id="6eb7f695a43a210c4ab19e5bc957617a28b1a107" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;ndarray.tobytes&lt;/code&gt;, information about the shape, dtype, etc., but also about &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt;, will be lost.</source>
          <target state="translated">&lt;code&gt;ndarray.tobytes&lt;/code&gt; 、形状、DTYPEなどについて、ほかの情報&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;、失われます。</target>
        </trans-unit>
        <trans-unit id="442dd71dc758bc00985af7b82e3b46e788353af0" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;ndarray.tobytes&lt;/code&gt;, information about the shape, dtype, etc., but also about &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt;, will be lost.</source>
          <target state="translated">&lt;code&gt;ndarray.tobytes&lt;/code&gt; 、形状、DTYPEなどについて、ほかの情報&lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;、失われます。</target>
        </trans-unit>
        <trans-unit id="b59d207ef2133a3867224936518ca5838dca25c9" translate="yes" xml:space="preserve">
          <source>As it turns out, numpy is smart enough when dealing with ufuncs to determine which index is the most rapidly varying one in memory and uses that for the innermost loop. Thus for ufuncs there is no large intrinsic advantage to either approach in most cases. On the other hand, use of .flat with an FORTRAN ordered array will lead to non-optimal memory access as adjacent elements in the flattened array (iterator, actually) are not contiguous in memory.</source>
          <target state="translated">結局のところ、numpyはufuncsを扱うときには、メモリ内のどのインデックスが最も急速に変化するインデックスであるかを判断し、それを最内ループに使用します。したがって、ufuncsの場合は、ほとんどの場合、どちらのアプローチにも大きな本質的な利点はありません。一方で、FORTRAN の順序付き配列で .flat を使用すると、平坦化された配列 (実際にはイテレータ)の隣接する要素がメモリ上で連続していないため、最適ではないメモリアクセスが発生します。</target>
        </trans-unit>
        <trans-unit id="bae171d630e66c8dccf252742ea919c5676002d9" translate="yes" xml:space="preserve">
          <source>As mentioned in the Notes section, &lt;a href=&quot;#numpy.testing.assert_array_equal&quot;&gt;&lt;code&gt;assert_array_equal&lt;/code&gt;&lt;/a&gt; has special handling for scalars. Here the test checks that each value in &lt;code&gt;x&lt;/code&gt; is 3:</source>
          <target state="translated">注のセクションで&lt;a href=&quot;#numpy.testing.assert_array_equal&quot;&gt; &lt;code&gt;assert_array_equal&lt;/code&gt; &lt;/a&gt;したように、assert_array_equalにはスカラーに対する特別な処理があります。ここで、テストは &lt;code&gt;x&lt;/code&gt; の各値が3であることを確認します。</target>
        </trans-unit>
        <trans-unit id="13dc2b7c8c10ac2fc73aefee2fde7f627c9b6aa2" translate="yes" xml:space="preserve">
          <source>As mentioned previously, the flat attribute of ndarray objects returns an iterator that will cycle over the entire array in C-style contiguous order.</source>
          <target state="translated">前述したように、ndarray オブジェクトの flat 属性は、配列全体を C スタイルの連続した順序で循環させるイテレータを返します。</target>
        </trans-unit>
        <trans-unit id="1eeb436878ddf7f47ab4d8c1fb337ec14f285994" translate="yes" xml:space="preserve">
          <source>As mentioned, one can select a subset of an array to assign to using a single index, slices, and index and mask arrays. The value being assigned to the indexed array must be shape consistent (the same shape or broadcastable to the shape the index produces). For example, it is permitted to assign a constant to a slice:</source>
          <target state="translated">前述のように、1つのインデックス、スライス、インデックスとマスクの配列を使用して、代入する配列のサブセットを選択することができます。インデックス付き配列に代入される値は、形状が一致していなければなりません(インデックスが生成する形状と同じ形状、またはブロードキャスト可能な形状)。例えば、スライスに定数を代入することは許されています。</target>
        </trans-unit>
        <trans-unit id="6bb256df55b0c84359db8c790668112e195bd64a" translate="yes" xml:space="preserve">
          <source>As noted above the inverse Gaussian distribution first arise from attempts to model Brownian motion. It is also a competitor to the Weibull for use in reliability modeling and modeling stock returns and interest rate processes.</source>
          <target state="translated">上で述べたように、逆ガウス分布は、ブラウン運動をモデル化する試みから最初に生まれました。また、信頼性モデリングや株式リターンや金利プロセスのモデリングで使用するために、ワイブルと競合するものでもあります。</target>
        </trans-unit>
        <trans-unit id="ec730138fa95973e97f6613bc68aa1a1f0c5aafb" translate="yes" xml:space="preserve">
          <source>As of 1.6, this function simply calls &lt;a href=&quot;#c.PyArray_CopyInto&quot;&gt;&lt;code&gt;PyArray_CopyInto&lt;/code&gt;&lt;/a&gt;, which handles the casting.</source>
          <target state="translated">1.6以降、この関数はキャストを処理する&lt;a href=&quot;#c.PyArray_CopyInto&quot;&gt; &lt;code&gt;PyArray_CopyInto&lt;/code&gt; を&lt;/a&gt;呼び出すだけです。</target>
        </trans-unit>
        <trans-unit id="3f3530b3b21291b3dd3b74336008cc7a706ed945" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.10, the returned array will have the same type as the input array. (for example, a masked array will be returned for a masked array input)</source>
          <target state="translated">NumPy 1.10では,返される配列は入力配列と同じ型になります(例えば,マスクされた配列の入力に対してはマスクされた配列が返されます).(例えば,マスクされた配列の入力に対しては,マスクされた配列が返されます)</target>
        </trans-unit>
        <trans-unit id="12042a22f9b6865da757e69e8d2ce21273a85e0c" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.4.0 &lt;a href=&quot;#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt; works with real/complex arrays containing nan values. The enhanced sort order is documented in &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NumPy 1.4.0 &lt;a href=&quot;#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt; nan値を含む実数/複素数配列で動作します。強化されたソート順は、&lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; に&lt;/a&gt;文書化されています。</target>
        </trans-unit>
        <trans-unit id="bba53cf9adf4ac58af71ddd4d6acfa9ee160b6ec" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.4.0 &lt;a href=&quot;#numpy.searchsorted&quot;&gt;&lt;code&gt;searchsorted&lt;/code&gt;&lt;/a&gt; works with real/complex arrays containing &lt;a href=&quot;../constants#numpy.nan&quot;&gt;&lt;code&gt;nan&lt;/code&gt;&lt;/a&gt; values. The enhanced sort order is documented in &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NumPy 1.4.0 &lt;a href=&quot;#numpy.searchsorted&quot;&gt; &lt;code&gt;searchsorted&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../constants#numpy.nan&quot;&gt; &lt;code&gt;nan&lt;/code&gt; &lt;/a&gt;値を含む実数/複素数配列で動作します。強化されたソート順は、&lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; に&lt;/a&gt;文書化されています。</target>
        </trans-unit>
        <trans-unit id="17597aa038b28f9f5c8df2774b1f9eab6ad3af4c" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.6.0, these array iterators are superceded by the new array iterator, &lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NumPy 1.6.0以降、これらの配列反復子は新しい配列反復子&lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt; &lt;code&gt;NpyIter&lt;/code&gt; に置き換えられました&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8364d1abaebc5d8b1444ea31949f7accfaa13ead" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.6.0, these array iterators are superseded by the new array iterator, &lt;a href=&quot;iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NumPy 1.6.0以降、これらの配列イテレーターは、新しい配列イテレーターである&lt;a href=&quot;iterator#c.NpyIter&quot;&gt; &lt;code&gt;NpyIter&lt;/code&gt; に&lt;/a&gt;置き換えられています。</target>
        </trans-unit>
        <trans-unit id="7f60464691ec1296f5eb92b23ac7c66b95bdc223" translate="yes" xml:space="preserve">
          <source>As previously discussed, you can also set the argtypes attribute of the function in order to have ctypes check the types of the input arguments when the function is called. Use the &lt;a href=&quot;#ndpointer&quot;&gt;&lt;code&gt;ndpointer&lt;/code&gt;&lt;/a&gt; factory function to generate a ready-made class for data-type, shape, and flags checking on your new function. The &lt;a href=&quot;#ndpointer&quot;&gt;&lt;code&gt;ndpointer&lt;/code&gt;&lt;/a&gt; function has the signature</source>
          <target state="translated">前に説明したように、関数が呼び出されたときにctypesに入力引数のタイプをチェックさせるために、関数のargtypes属性を設定することもできます。&lt;a href=&quot;#ndpointer&quot;&gt; &lt;code&gt;ndpointer&lt;/code&gt; &lt;/a&gt;ファクトリ関数を使用して、新しい関数でデータ型、形状、およびフラグをチェックするための既製のクラスを生成します。&lt;a href=&quot;#ndpointer&quot;&gt; &lt;code&gt;ndpointer&lt;/code&gt; の&lt;/a&gt;機能は、署名を有します</target>
        </trans-unit>
        <trans-unit id="7e6c9caa222f474d8200d79ae5b20b408a1c8172" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;#figure-2&quot;&gt;Figure 2&lt;/a&gt;, &lt;code&gt;b&lt;/code&gt; is added to each row of &lt;code&gt;a&lt;/code&gt;. When &lt;code&gt;b&lt;/code&gt; is longer than the rows of &lt;code&gt;a&lt;/code&gt;, as in &lt;a href=&quot;#figure-3&quot;&gt;Figure 3&lt;/a&gt;, an exception is raised because of the incompatible shapes.</source>
          <target state="translated">示すように&lt;a href=&quot;#figure-2&quot;&gt;、図2&lt;/a&gt;、 &lt;code&gt;b&lt;/code&gt; 各列に追加されます。場合 &lt;code&gt;b&lt;/code&gt; 列よりも長くなるように、&lt;a href=&quot;#figure-3&quot;&gt;図3&lt;/a&gt;は、例外があるため、互換性のない形状の隆起されます。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0eb75b8579bfe992aa268341a4c85c6d503920b9" translate="yes" xml:space="preserve">
          <source>As the scale approaches infinity, the distribution becomes more like a Gaussian. Some references claim that the Wald is an inverse Gaussian with mean equal to 1, but this is by no means universal.</source>
          <target state="translated">スケールが無限大に近づくにつれて、分布はよりガウス分布のようになります。いくつかの文献では、Waldは平均が1に等しい逆ガウス分布であると主張していますが、これは決して普遍的なものではありません。</target>
        </trans-unit>
        <trans-unit id="2f0e40b24d4f520710fd1ed228a57a1690ea8227" translate="yes" xml:space="preserve">
          <source>As well as the scalar array special case signaling that an integer array was interpreted as an integer index, which is important because an integer array index forces a copy but is ignored if a scalar is returned (full integer index). The prepared index is guaranteed to be valid with the exception of out of bound values and broadcasting errors for advanced indexing. This includes that an ellipsis is added for incomplete indices for example when a two dimensional array is indexed with a single integer.</source>
          <target state="translated">これは、整数配列のインデックスはコピーを強制しますが、スカラ(完全な整数インデックス)が返された場合は無視されるため、重要です。用意されたインデックスは、境界外の値や高度なインデックス作成のためのブロードキャストエラーを除いて有効であることが保証されます。これには,例えば2次元配列が単一の整数でインデックス付けされている場合など,不完全なインデックスに対して楕円が追加されることも含まれます.</target>
        </trans-unit>
        <trans-unit id="925814af80369e67056380832c2cbc226e28baa6" translate="yes" xml:space="preserve">
          <source>As with other container objects in Python, the contents of an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; can be accessed and modified by &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;indexing or slicing&lt;/a&gt; the array (using, for example, &lt;em&gt;N&lt;/em&gt; integers), and via the methods and attributes of the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Pythonの他のコンテナーオブジェクトと同様に、&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;のコンテンツは、配列の&lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;インデックス付けまたはスライス&lt;/a&gt;（たとえば、&lt;em&gt;N&lt;/em&gt;整数を使用）によって、および&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; の&lt;/a&gt;メソッドと属性を介してアクセスおよび変更できます。</target>
        </trans-unit>
        <trans-unit id="52fd93066bad29b67273e079568eccef85b00fa0" translate="yes" xml:space="preserve">
          <source>As you can imagine from the introduction, there are two ways you can affect the relationship between the byte ordering of the array and the underlying memory it is looking at:</source>
          <target state="translated">序章から想像できるように、配列のバイト順とそれが参照しているメモリとの関係に影響を与えるには2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="d2891acf8ae5fe1d5007874779732cde26b391a3" translate="yes" xml:space="preserve">
          <source>As you can see, the object can be initialized in the &lt;code&gt;__new__&lt;/code&gt; method or the &lt;code&gt;__init__&lt;/code&gt; method, or both, and in fact ndarray does not have an &lt;code&gt;__init__&lt;/code&gt; method, because all the initialization is done in the &lt;code&gt;__new__&lt;/code&gt; method.</source>
          <target state="translated">ご覧のとおり、オブジェクトは &lt;code&gt;__new__&lt;/code&gt; メソッドまたは &lt;code&gt;__init__&lt;/code&gt; メソッド、あるいはその両方で初期化できます。実際、すべての初期化は &lt;code&gt;__new__&lt;/code&gt; メソッドで行われるため、ndarrayには &lt;code&gt;__init__&lt;/code&gt; メソッドがありません。</target>
        </trans-unit>
        <trans-unit id="3b4f7dc7b3c4a70ce9ff533c44a9b7a4a1713152" translate="yes" xml:space="preserve">
          <source>Asking for your changes to be merged with the main repo</source>
          <target state="translated">あなたの変更をメインのレポにマージするようにお願いしています。</target>
        </trans-unit>
        <trans-unit id="b3cf9d2ab1eb546a2eba1efeb64eb1e97091b955" translate="yes" xml:space="preserve">
          <source>Assemble an nd-array from nested lists of blocks.</source>
          <target state="translated">ブロックのネストされたリストから nd-array をアセンブルします。</target>
        </trans-unit>
        <trans-unit id="74cbd6c218f89d00f752e7ba4b2b17d97a1a1ff7" translate="yes" xml:space="preserve">
          <source>Assemble arrays from blocks.</source>
          <target state="translated">ブロックから配列を組み立てる。</target>
        </trans-unit>
        <trans-unit id="de78d0a7b76ee6bba1ecaedfc383918b06ba62a9" translate="yes" xml:space="preserve">
          <source>Assert fails with numerical imprecision with floats:</source>
          <target state="translated">浮動小数点数の数値不正確さでアサートが失敗します。</target>
        </trans-unit>
        <trans-unit id="79536b913447cc8edd9ecd5192bb8530d9a9202a" translate="yes" xml:space="preserve">
          <source>Assert fails with numerical inprecision with floats:</source>
          <target state="translated">アサートは、浮動小数点数の数値精度が低い場合に失敗します。</target>
        </trans-unit>
        <trans-unit id="561c16749736b8dbda1124817a2b4447de5e4505" translate="yes" xml:space="preserve">
          <source>Asserts</source>
          <target state="translated">Asserts</target>
        </trans-unit>
        <trans-unit id="289e36002d46d5808069779b9fe9f985a8b15407" translate="yes" xml:space="preserve">
          <source>Assigning data to a Structured Array</source>
          <target state="translated">構造化配列へのデータの割り当て</target>
        </trans-unit>
        <trans-unit id="8a799af040a420920800093adb9e84b1752618c3" translate="yes" xml:space="preserve">
          <source>Assigning to slices/views of &lt;code&gt;MaskedArray&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;MaskedArray&lt;/code&gt; のスライス/ビューへの割り当て</target>
        </trans-unit>
        <trans-unit id="a63aa663ce3fd806853c6e1d56f0f1c1896855bd" translate="yes" xml:space="preserve">
          <source>Assigning values to indexed arrays</source>
          <target state="translated">インデックス付き配列への値の代入</target>
        </trans-unit>
        <trans-unit id="4d5174a57fec035b53144526667e457e11d00dd3" translate="yes" xml:space="preserve">
          <source>Assignment between two structured arrays occurs as if the source elements had been converted to tuples and then assigned to the destination elements. That is, the first field of the source array is assigned to the first field of the destination array, and the second field likewise, and so on, regardless of field names. Structured arrays with a different number of fields cannot be assigned to each other. Bytes of the destination structure which are not included in any of the fields are unaffected.</source>
          <target state="translated">2 つの構造化配列間の代入は,ソース要素がタプルに変換された後,デスティネーション要素に代入されたかのように行われます.つまり、フィールド名に関係なく、ソース配列の最初のフィールドがデスティネーション配列の最初のフィールドに代入され、2 番目のフィールドも同様に代入されます。フィールド数の異なる構造化配列は,互いに代入することができません.宛先構造体のどのフィールドにも含まれないバイトは影響を受けません。</target>
        </trans-unit>
        <trans-unit id="acccf5c6ee3457ada97687fe5c7f1318e0893486" translate="yes" xml:space="preserve">
          <source>Assignment from Python Native Types (Tuples)</source>
          <target state="translated">Pythonネイティブ型(タプル)からの割り当て</target>
        </trans-unit>
        <trans-unit id="9cc21533901f2115eb4a3c32d19650f93349565e" translate="yes" xml:space="preserve">
          <source>Assignment from Scalars</source>
          <target state="translated">スカラーズからの割り当て</target>
        </trans-unit>
        <trans-unit id="4c57993301d1b6548c0e4939d7c7c8d9a2d56b2c" translate="yes" xml:space="preserve">
          <source>Assignment from other Structured Arrays</source>
          <target state="translated">他の構造化配列からの代入</target>
        </trans-unit>
        <trans-unit id="fc5e2a82565507aaae14030e1c010088c6562688" translate="yes" xml:space="preserve">
          <source>Assignment involving subarrays</source>
          <target state="translated">サブアレイを含む割り当て</target>
        </trans-unit>
        <trans-unit id="dc3ede0861439daaed8c3de08958646d9211be1a" translate="yes" xml:space="preserve">
          <source>Assignment of ndarray object&amp;rsquo;s &lt;code&gt;data&lt;/code&gt; attribute</source>
          <target state="translated">ndarrayオブジェクトの &lt;code&gt;data&lt;/code&gt; 属性の割り当て</target>
        </trans-unit>
        <trans-unit id="2edeef440cbb6c2ba230df4bbf3e9bef68f36e23" translate="yes" xml:space="preserve">
          <source>Assignment to an array with a multi-field index modifies the original array:</source>
          <target state="translated">複数フィールドのインデックスを持つ配列に代入すると,元の配列が変更されます.</target>
        </trans-unit>
        <trans-unit id="af53b1c5013c72eb7aa598ce977b69cfb859c315" translate="yes" xml:space="preserve">
          <source>Assignment to the view modifies the original array. The view&amp;rsquo;s fields will be in the order they were indexed. Note that unlike for single-field indexing, the dtype of the view has the same itemsize as the original array, and has fields at the same offsets as in the original array, and unindexed fields are merely missing.</source>
          <target state="translated">ビューに割り当てると、元の配列が変更されます。ビューのフィールドは、インデックスが作成された順序になります。単一フィールドのインデックス付けとは異なり、ビューのdtypeは元の配列と同じitemsizeを持ち、元の配列と同じオフセットにフィールドがあり、インデックス付けされていないフィールドが欠落しているだけであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ed91fb02ba267588e9268d85784e62da51f799fd" translate="yes" xml:space="preserve">
          <source>Assignment vs referencing</source>
          <target state="translated">課題と参照</target>
        </trans-unit>
        <trans-unit id="d8a1879dbe4b9ce9021e415e931186b4b4a19157" translate="yes" xml:space="preserve">
          <source>Assigns values from one structured array to another by field name.</source>
          <target state="translated">ある構造化された配列からフィールド名で別の配列に値を代入します。</target>
        </trans-unit>
        <trans-unit id="ae9a24254ec6cd55a31a48c28461f44e73e53f66" translate="yes" xml:space="preserve">
          <source>Assume &lt;code&gt;mask_func&lt;/code&gt; is a function that, for a square array a of size &lt;code&gt;(n, n)&lt;/code&gt; with a possible offset argument &lt;code&gt;k&lt;/code&gt;, when called as &lt;code&gt;mask_func(a, k)&lt;/code&gt; returns a new array with zeros in certain locations (functions like &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt;&lt;code&gt;triu&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt;&lt;code&gt;tril&lt;/code&gt;&lt;/a&gt; do precisely this). Then this function returns the indices where the non-zero values would be located.</source>
          <target state="translated">仮定 &lt;code&gt;mask_func&lt;/code&gt; するサイズの正方形アレイAについて、その関数である &lt;code&gt;(n, n)&lt;/code&gt; の可能なオフセット引数と &lt;code&gt;k&lt;/code&gt; と呼ばれる、 &lt;code&gt;mask_func(a, k)&lt;/code&gt; 特定の位置にゼロを使用して新しい配列を返す（のような機能&lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt; &lt;code&gt;triu&lt;/code&gt; &lt;/a&gt;又は&lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt; &lt;code&gt;tril&lt;/code&gt; &lt;/a&gt;正確にこれを行います）。次に、この関数はゼロ以外の値が配置されるインデックスを返します。</target>
        </trans-unit>
        <trans-unit id="87a473db70c6a624c40e23afb12c39561d92a618" translate="yes" xml:space="preserve">
          <source>Assume &lt;em&gt;n&lt;/em&gt; is the number of elements in the dimension being sliced. Then, if &lt;em&gt;i&lt;/em&gt; is not given it defaults to 0 for &lt;em&gt;k &amp;gt; 0&lt;/em&gt; and &lt;em&gt;n - 1&lt;/em&gt; for &lt;em&gt;k &amp;lt; 0&lt;/em&gt; . If &lt;em&gt;j&lt;/em&gt; is not given it defaults to &lt;em&gt;n&lt;/em&gt; for &lt;em&gt;k &amp;gt; 0&lt;/em&gt; and &lt;em&gt;-n-1&lt;/em&gt; for &lt;em&gt;k &amp;lt; 0&lt;/em&gt; . If &lt;em&gt;k&lt;/em&gt; is not given it defaults to 1. Note that &lt;code&gt;::&lt;/code&gt; is the same as &lt;code&gt;:&lt;/code&gt; and means select all indices along this axis.</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt;は、スライスされる次元の要素数であると仮定します。次に、&lt;em&gt;i&lt;/em&gt;が指定されないと、&lt;em&gt;k&amp;gt; 0の&lt;/em&gt;場合はデフォルトで&lt;em&gt;0に&lt;/em&gt;なり、&lt;em&gt;k &amp;lt;0の&lt;/em&gt;&lt;em&gt;場合はn-1&lt;/em&gt;になり&lt;em&gt;ます&lt;/em&gt;。場合&lt;em&gt;jは&lt;/em&gt;にそれをデフォルト値を与えられていない&lt;em&gt;N&lt;/em&gt;ために&lt;em&gt;K&amp;gt; 0&lt;/em&gt;と&lt;em&gt;-n-1&lt;/em&gt;のための&lt;em&gt;K &amp;lt;0 &lt;/em&gt;。&lt;em&gt;k&lt;/em&gt;が指定されていない場合、デフォルトは1です。 &lt;code&gt;::&lt;/code&gt; は &lt;code&gt;:&lt;/code&gt; と同じであり、この軸に沿ってすべてのインデックスを選択することを意味します。</target>
        </trans-unit>
        <trans-unit id="b9dccb798e5c5e1b5508e3a8630765c07522b225" translate="yes" xml:space="preserve">
          <source>Assume that the observations are in the columns of the observation array &lt;code&gt;m&lt;/code&gt; and let &lt;code&gt;f = fweights&lt;/code&gt; and &lt;code&gt;a = aweights&lt;/code&gt; for brevity. The steps to compute the weighted covariance are as follows:</source>
          <target state="translated">観測は、観測アレイの列内にあると仮定し &lt;code&gt;m&lt;/code&gt; およびlet &lt;code&gt;f = fweights&lt;/code&gt; 及び &lt;code&gt;a = aweights&lt;/code&gt; 簡潔にするため。加重共分散を計算する手順は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="97728787c4c0fd66ac4cc28f08c4ba4e206f76e5" translate="yes" xml:space="preserve">
          <source>Assume we have three matrices</source>
          <target state="translated">3つの行列があるとします。</target>
        </trans-unit>
        <trans-unit id="68035e390827bfef5b6a722908902bf830e33068" translate="yes" xml:space="preserve">
          <source>Assuming that</source>
          <target state="translated">と仮定すると</target>
        </trans-unit>
        <trans-unit id="361dbf446d2fcbde7f8e5127964dd121d2c08adc" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;a&lt;/code&gt; is sorted:</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; がソートされていると仮定します。</target>
        </trans-unit>
        <trans-unit id="a66d954bab07db2d2ebde3811f3d1797fded0efb" translate="yes" xml:space="preserve">
          <source>Assuming the foo.ini.in file has the following content:</source>
          <target state="translated">foo.ini.inファイルの内容が以下のようになっているとします。</target>
        </trans-unit>
        <trans-unit id="3d748459a93c925f679363da9105b14fbf94ff7f" translate="yes" xml:space="preserve">
          <source>Assuming you have followed the instructions in these pages, git will create a default link to your &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; repo called &lt;code&gt;origin&lt;/code&gt;. In git &amp;gt;= 1.7 you can ensure that the link to origin is permanently set by using the &lt;code&gt;--set-upstream&lt;/code&gt; option:</source>
          <target state="translated">これらのページの指示に従っていると仮定すると、gitは &lt;code&gt;origin&lt;/code&gt; と呼ばれる&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;リポジトリへのデフォルトのリンクを作成します。git&amp;gt; = 1.7では、 &lt;code&gt;--set-upstream&lt;/code&gt; オプションを使用して、オリジンへのリンクが永続的に設定されていることを確認できます。</target>
        </trans-unit>
        <trans-unit id="0527fe789f4627f3a63d0bb5ba48121982fec81a" translate="yes" xml:space="preserve">
          <source>At each iteration of the loop, the &lt;em&gt;nin&lt;/em&gt; input objects are extracted from their object arrays and placed into an argument tuple, the Python &lt;em&gt;callable&lt;/em&gt; is called with the input arguments, and the nout outputs are placed into their object arrays.</source>
          <target state="translated">ループの各反復で、&lt;em&gt;ニン&lt;/em&gt;入力オブジェクトは、そのオブジェクトの配列から抽出され、引数のタプルに入れ、Pythonの&lt;em&gt;呼び出し可能は&lt;/em&gt;入力引数と呼ばれ、NOUT出力は、それらのオブジェクトの配列に配置されています。</target>
        </trans-unit>
        <trans-unit id="ca83daf60668ea69e76df727d7b2b16f815d0807" translate="yes" xml:space="preserve">
          <source>At the beginning of every &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, this method is called on the input object with the highest array priority, or the output object if one was specified. The output array is passed in and whatever is returned is passed to the ufunc. Subclasses inherit a default implementation of this method which simply returns the output array unmodified. Subclasses may opt to use this method to transform the output array into an instance of the subclass and update metadata before returning the array to the ufunc for computation.</source>
          <target state="translated">すべての&lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;の最初に、このメソッドは、配列の優先順位が最も高い入力オブジェクト、または指定されている場合は出力オブジェクトで呼び出されます。出力配列が渡され、返されるものはすべてufuncに渡されます。サブクラスは、このメソッドのデフォルトの実装を継承します。これは、変更されていない出力配列を返すだけです。サブクラスは、このメソッドを使用して出力配列をサブクラスのインスタンスに変換し、計算のために配列をufuncに返す前にメタデータを更新することを選択できます。</target>
        </trans-unit>
        <trans-unit id="12bc262a1577057e701d7713e64c78fa019c087b" translate="yes" xml:space="preserve">
          <source>At the core of every ufunc is a collection of type-specific functions that defines the basic functionality for each of the supported types. These functions must evaluate the underlying function</source>
          <target state="translated">すべての ufunc の中核には、サポートされている各型の基本的な機能を定義する型固有の関数のコレクションがあります。これらの関数は、基礎となる関数</target>
        </trans-unit>
        <trans-unit id="99499535512b6c181a0f3b43a50d805096cef5c2" translate="yes" xml:space="preserve">
          <source>At the core of every ufunc is a one-dimensional strided loop that implements the actual function for a specific type combination. When a ufunc is created, it is given a static list of inner loops and a corresponding list of type signatures over which the ufunc operates. The ufunc machinery uses this list to determine which inner loop to use for a particular case. You can inspect the &lt;a href=&quot;generated/numpy.ufunc.types#numpy.ufunc.types&quot;&gt;&lt;code&gt;.types&lt;/code&gt;&lt;/a&gt; attribute for a particular ufunc to see which type combinations have a defined inner loop and which output type they produce (&lt;a href=&quot;arrays.scalars#arrays-scalars-character-codes&quot;&gt;character codes&lt;/a&gt; are used in said output for brevity).</source>
          <target state="translated">すべてのufuncの中核は、特定の型の組み合わせの実際の関数を実装する1次元ストライドループです。 ufuncが作成されると、内部ループの静的リストと、ufuncが動作する型シグネチャの対応するリストが与えられます。 ufunc機構はこのリストを使用して、特定のケースで使用する内部ループを決定します。特定のufuncの&lt;a href=&quot;generated/numpy.ufunc.types#numpy.ufunc.types&quot;&gt; &lt;code&gt;.types&lt;/code&gt; &lt;/a&gt;属性を調べて、定義された内部ループを持つタイプの組み合わせと、それらが生成する出力タイプを確認できます（簡潔にするために、上記の出力では&lt;a href=&quot;arrays.scalars#arrays-scalars-character-codes&quot;&gt;文字コード&lt;/a&gt;を使用しています）。</target>
        </trans-unit>
        <trans-unit id="a696ebe70ac5ecb64adf92ab51868a20788e2014" translate="yes" xml:space="preserve">
          <source>At the core of the NumPy package, is the &lt;code&gt;ndarray&lt;/code&gt; object. This encapsulates &lt;em&gt;n&lt;/em&gt;-dimensional arrays of homogeneous data types, with many operations being performed in compiled code for performance. There are several important differences between NumPy arrays and the standard Python sequences:</source>
          <target state="translated">NumPyパッケージの中核には、 &lt;code&gt;ndarray&lt;/code&gt; オブジェクトがあります。これにより、同種のデータ型の&lt;em&gt;n&lt;/em&gt;次元配列がカプセル化され、パフォーマンスのためにコンパイルされたコードで多くの操作が実行されます。NumPy配列と標準のPythonシーケンスの間には、いくつかの重要な違いがあります。</target>
        </trans-unit>
        <trans-unit id="d886c7715daa7e13f2899ef3973389ec60967548" translate="yes" xml:space="preserve">
          <source>At the end of every &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, this method is called on the input object with the highest array priority, or the output object if one was specified. The ufunc-computed array is passed in and whatever is returned is passed to the user. Subclasses inherit a default implementation of this method, which transforms the array into a new instance of the object&amp;rsquo;s class. Subclasses may opt to use this method to transform the output array into an instance of the subclass and update metadata before returning the array to the user.</source>
          <target state="translated">すべての&lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;の最後に、このメソッドは、配列の優先順位が最も高い入力オブジェクト、または指定されている場合は出力オブジェクトで呼び出されます。ufuncで計算された配列が渡され、返されたものはすべてユーザーに渡されます。サブクラスは、このメソッドのデフォルト実装を継承します。これにより、配列がオブジェクトのクラスの新しいインスタンスに変換されます。サブクラスはこのメソッドを使用して、出力配列をサブクラスのインスタンスに変換し、メタデータを更新してから配列をユーザーに返すことができます。</target>
        </trans-unit>
        <trans-unit id="54f27a6635e66c8275db039314e451b39ca65192" translate="yes" xml:space="preserve">
          <source>At this point &lt;code&gt;arr + 3&lt;/code&gt; does not work.</source>
          <target state="translated">この時点で、 &lt;code&gt;arr + 3&lt;/code&gt; は機能しません。</target>
        </trans-unit>
        <trans-unit id="f7cf21779cc632f37ca6f9f1b905fd816410c5c5" translate="yes" xml:space="preserve">
          <source>Attribute statements:</source>
          <target state="translated">属性文。</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="cfe76174da05e50b979cc6188b003f45d1df8482" translate="yes" xml:space="preserve">
          <source>Attributes and properties of masked arrays</source>
          <target state="translated">マスクされた配列の属性とプロパティ</target>
        </trans-unit>
        <trans-unit id="75d3cd51a61f739cdedf79817eefc8974a835455" translate="yes" xml:space="preserve">
          <source>Attributes providing additional information:</source>
          <target state="translated">追加情報を提供する属性。</target>
        </trans-unit>
        <trans-unit id="1003414a3eb685608efbc345c0f83084c22559bd" translate="yes" xml:space="preserve">
          <source>Attributes that are properties and have their own docstrings can be simply listed by name:</source>
          <target state="translated">プロパティであり、それ自身のdocstringを持っている属性は、単に名前だけでリストアップすることができます。</target>
        </trans-unit>
        <trans-unit id="b8087185e5ee37cef4c337de5697d35d75d909fd" translate="yes" xml:space="preserve">
          <source>Attributes:</source>
          <target state="translated">Attributes:</target>
        </trans-unit>
        <trans-unit id="6854c23ffe094a9dcc2c7d18b7054597700c09d7" translate="yes" xml:space="preserve">
          <source>Author: Pearu Peterson &amp;lt;&lt;a href=&quot;mailto:pearu%40cens.ioc.ee&quot;&gt;pearu@cens.ioc.ee&lt;/a&gt;&amp;gt; Created: 11 January 2003</source>
          <target state="translated">著者：Pearu Peterson &amp;lt; &lt;a href=&quot;mailto:pearu%40cens.ioc.ee&quot;&gt;pearu@cens.ioc.ee&lt;/a&gt; &amp;gt;作成日：2003年1月11日</target>
        </trans-unit>
        <trans-unit id="d2a52548bd0852b99153ddd79a1f550f70674c7d" translate="yes" xml:space="preserve">
          <source>Authors</source>
          <target state="translated">Authors</target>
        </trans-unit>
        <trans-unit id="9a8e09e3b7e8024727baccc0a1e74a9673de3c0e" translate="yes" xml:space="preserve">
          <source>Automated Bin Selection Methods example, using 2 peak random data with 2000 points:</source>
          <target state="translated">2000点の2ピークランダムデータを用いた自動ビン選択方法の例。</target>
        </trans-unit>
        <trans-unit id="bfb122c45c152fbdf176456bb1bd4e6bc24c337e" translate="yes" xml:space="preserve">
          <source>Automatic Byte Offsets and Alignment</source>
          <target state="translated">自動バイトオフセットとアラインメント</target>
        </trans-unit>
        <trans-unit id="522d7710743316a9bb70282225a360f203660682" translate="yes" xml:space="preserve">
          <source>Automatic detection of forward incompatibilities</source>
          <target state="translated">順方向の非互換性を自動検出</target>
        </trans-unit>
        <trans-unit id="687034389bdc7cc4294c91418210f69e71c2ea75" translate="yes" xml:space="preserve">
          <source>Automatic extension module generation</source>
          <target state="translated">拡張モジュールの自動生成</target>
        </trans-unit>
        <trans-unit id="b2ebac8c965ff2e52dca0ea08eceaccc8803b780" translate="yes" xml:space="preserve">
          <source>Automatically generated reference documentation</source>
          <target state="translated">自動的に生成されるリファレンスドキュメント</target>
        </trans-unit>
        <trans-unit id="65efb82d6e37e5b9994108df57fecde86e561550" translate="yes" xml:space="preserve">
          <source>Auxiliary Data With Object Semantics</source>
          <target state="translated">オブジェクトセマンティクスによる補助データ</target>
        </trans-unit>
        <trans-unit id="b5d54069c98dcc2bb7ef53455746da49544d4c61" translate="yes" xml:space="preserve">
          <source>Available Typemaps</source>
          <target state="translated">利用可能なタイプマップ</target>
        </trans-unit>
        <trans-unit id="0eba0fa1e7377ce939b86cc49e664126d93a94fb" translate="yes" xml:space="preserve">
          <source>Available labels are:</source>
          <target state="translated">利用可能なラベルは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="b9ef456325fee29b959d2b71abeec2f41a07fee2" translate="yes" xml:space="preserve">
          <source>Available ufuncs</source>
          <target state="translated">利用可能なufuncs</target>
        </trans-unit>
        <trans-unit id="15f86c051ecf0b64e5f8cdc8c689552f42595942" translate="yes" xml:space="preserve">
          <source>Average</source>
          <target state="translated">Average</target>
        </trans-unit>
        <trans-unit id="00230b1d5c35405f7ca65ccbf60097d1ff75f793" translate="yes" xml:space="preserve">
          <source>Averages and variances</source>
          <target state="translated">平均と分散</target>
        </trans-unit>
        <trans-unit id="e7a6dacf63a1600c6901329b8727cfba6197e8fd" translate="yes" xml:space="preserve">
          <source>Axes are defined for arrays with more than one dimension. A 2-dimensional array has two corresponding axes: the first running vertically downwards across rows (axis 0), and the second running horizontally across columns (axis 1).</source>
          <target state="translated">軸は,2次元以上の配列に対して定義されます.2次元配列には,2つの対応する軸があります:1つ目は行を垂直に下向きに横切る軸(軸0),2つ目は列を水平に横切る軸(軸1)です.</target>
        </trans-unit>
        <trans-unit id="260a17f609be1b620f1eb6b59b7945c255c81429" translate="yes" xml:space="preserve">
          <source>Axes in &lt;code&gt;a&lt;/code&gt; to reorder to the right, before inversion. If None (default), no reordering is done.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; の軸は、反転する前に、右に並べ替えます。None（デフォルト）の場合、並べ替えは行われません。</target>
        </trans-unit>
        <trans-unit id="db233fcb37135c7f09c5ffb89b7ba1fec760ef66" translate="yes" xml:space="preserve">
          <source>Axes over which &lt;code&gt;func&lt;/code&gt; is applied; the elements must be integers.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; が適用される軸。要素は整数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="3c7544c1215157a53157a59a39707d4b0bcf94df" translate="yes" xml:space="preserve">
          <source>Axes over which to calculate. Defaults to None, which shifts all axes.</source>
          <target state="translated">計算する軸。デフォルトは None で、すべての軸をシフトします。</target>
        </trans-unit>
        <trans-unit id="01251d80564e6fc5615a7911ad0e73434e304c26" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT.</source>
          <target state="translated">FFTを計算する軸。</target>
        </trans-unit>
        <trans-unit id="eae74832fcf1fa3443d947416920310bd08270f6" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified.</source>
          <target state="translated">FFTを計算する軸。与えられていない場合は、最後の &lt;code&gt;len(s)&lt;/code&gt; 場合の軸が使用され、またはすべての軸されている &lt;code&gt;s&lt;/code&gt; も指定されていません。</target>
        </trans-unit>
        <trans-unit id="087a54cd73e6a93e216a09c22b970ec84185e189" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified. Repeated indices in &lt;code&gt;axes&lt;/code&gt; means that the transform over that axis is performed multiple times.</source>
          <target state="translated">FFTを計算する軸。与えられていない場合は、最後の &lt;code&gt;len(s)&lt;/code&gt; 場合の軸が使用され、またはすべての軸されている &lt;code&gt;s&lt;/code&gt; も指定されていません。 &lt;code&gt;axes&lt;/code&gt; インデックスが繰り返されるということは、その軸での変換が複数回実行されることを意味します。</target>
        </trans-unit>
        <trans-unit id="c012449cfef6487dddab190f30ddad2f2e0316c1" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT. If not given, the last two axes are used. A repeated index in &lt;code&gt;axes&lt;/code&gt; means the transform over that axis is performed multiple times. A one-element sequence means that a one-dimensional FFT is performed.</source>
          <target state="translated">FFTを計算する軸。指定しない場合、最後の2つの軸が使用されます。 &lt;code&gt;axes&lt;/code&gt; 繰り返されるインデックスは、その軸に対する変換が複数回実行されることを意味します。1要素シーケンスとは、1次元のFFTが実行されることを意味します。</target>
        </trans-unit>
        <trans-unit id="c1bbe9559f43f27cc8c677ee579702aea02533b0" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the IFFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified. Repeated indices in &lt;code&gt;axes&lt;/code&gt; means that the inverse transform over that axis is performed multiple times.</source>
          <target state="translated">IFFTを計算する軸。与えられていない場合は、最後の &lt;code&gt;len(s)&lt;/code&gt; 場合の軸が使用され、またはすべての軸されている &lt;code&gt;s&lt;/code&gt; も指定されていません。 &lt;code&gt;axes&lt;/code&gt; インデックスが繰り返されるということは、その軸に対する逆変換が複数回実行されることを意味します。</target>
        </trans-unit>
        <trans-unit id="b354616c4fe4a354f85531d5428c20c0b32f3c2f" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the inverse FFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified. Repeated indices in &lt;code&gt;axes&lt;/code&gt; means that the inverse transform over that axis is performed multiple times.</source>
          <target state="translated">逆FFTを計算する軸。与えられていない場合は、最後の &lt;code&gt;len(s)&lt;/code&gt; 場合の軸が使用され、またはすべての軸されている &lt;code&gt;s&lt;/code&gt; も指定されていません。 &lt;code&gt;axes&lt;/code&gt; インデックスが繰り返されるということは、その軸に対する逆変換が複数回実行されることを意味します。</target>
        </trans-unit>
        <trans-unit id="8a99b64a4a7a7c7ead7b23b02c696f0da53ae319" translate="yes" xml:space="preserve">
          <source>Axes over which to shift. Default is None, which shifts all axes.</source>
          <target state="translated">シフトする軸。デフォルトは None で、すべての軸をシフトします。</target>
        </trans-unit>
        <trans-unit id="0a52967d9e9b8df8a4f8c170f8ca693ae8a86fe3" translate="yes" xml:space="preserve">
          <source>Axes to be used as the first and second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults are the first two axes of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">対角線を取得する2次元サブ配列の1番目と2番目の軸として使用する軸。デフォルトの最初の2つの軸です。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f303f8b434501d0a0e88a06f71ae6bf60e07440a" translate="yes" xml:space="preserve">
          <source>Axis along which &lt;code&gt;arr&lt;/code&gt; is sliced.</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; がスライスされる軸。</target>
        </trans-unit>
        <trans-unit id="eb47b635b568e5dba0343ed2ed07af3eb1c5f691" translate="yes" xml:space="preserve">
          <source>Axis along which logical OR is performed</source>
          <target state="translated">論理和が実行される軸</target>
        </trans-unit>
        <trans-unit id="09cfc91cd9019ea0548a0bc697b5fe1ac4febf1f" translate="yes" xml:space="preserve">
          <source>Axis along which the cumulative product is computed. By default the input is flattened.</source>
          <target state="translated">累積積が計算される軸。デフォルトでは、入力は平坦化されます。</target>
        </trans-unit>
        <trans-unit id="57187cefb1f2a69dac281d57460affb45a365e61" translate="yes" xml:space="preserve">
          <source>Axis along which the cumulative sum is computed. The default (None) is to compute the cumsum over the flattened array.</source>
          <target state="translated">累積和が計算される軸。デフォルト(None)は、平坦化された配列の累積和を計算します。</target>
        </trans-unit>
        <trans-unit id="f37486b57129451282a7b678277fa8169fe0110e" translate="yes" xml:space="preserve">
          <source>Axis along which the elements are counted. By default, give the total number of elements.</source>
          <target state="translated">要素をカウントする軸。デフォルトでは、要素の総数を指定します。</target>
        </trans-unit>
        <trans-unit id="b08197a0ff41e61316a0f60a6919ee14fb5fe98b" translate="yes" xml:space="preserve">
          <source>Axis along which the medians are computed. The default (None) is to compute the median along a flattened version of the array.</source>
          <target state="translated">中央値を計算する軸。デフォルト(None)は、配列の平坦化されたバージョンに沿って中央値を計算します。</target>
        </trans-unit>
        <trans-unit id="bc92a5f411fa4b8657deb697c80aca8e1f76fb85" translate="yes" xml:space="preserve">
          <source>Axis along which the operation must be performed.</source>
          <target state="translated">操作を実行しなければならない軸。</target>
        </trans-unit>
        <trans-unit id="f2cd71dae3fa50b163de963d5f5e4581028e17b5" translate="yes" xml:space="preserve">
          <source>Axis along which to average &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;None&lt;/code&gt;, averaging is done over the flattened array.</source>
          <target state="translated">を平均 &lt;code&gt;a&lt;/code&gt; 軸。 &lt;code&gt;None&lt;/code&gt; の場合、平均化はフラット化された配列に対して行われます。</target>
        </trans-unit>
        <trans-unit id="17667e8c77ab258d88774c70f62a92c1b9869875" translate="yes" xml:space="preserve">
          <source>Axis along which to average &lt;code&gt;a&lt;/code&gt;. If None, averaging is done over the flattened array.</source>
          <target state="translated">平均化 &lt;code&gt;a&lt;/code&gt; 軸。Noneの場合、平均化はフラット化された配列に対して実行されます。</target>
        </trans-unit>
        <trans-unit id="6740a47c78c530ff5565f890ca7a6510d66b94b6" translate="yes" xml:space="preserve">
          <source>Axis along which to count. If None (default), a flattened version of the array is used.</source>
          <target state="translated">カウントする軸。None(デフォルト)の場合は、平坦化された配列が使用されます。</target>
        </trans-unit>
        <trans-unit id="87e6cb227cab73030094d0bab3690d5e44d50da1" translate="yes" xml:space="preserve">
          <source>Axis along which to find the peaks. By default, flatten the array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">ピークを見つけるための軸。デフォルトでは、アレイをフラット化します。 &lt;code&gt;axis&lt;/code&gt; は負の場合もあり、その場合、最後の軸から最初の軸までカウントされます。</target>
        </trans-unit>
        <trans-unit id="d012a76459484bfd8767b22b0537d0b22d4d11bb" translate="yes" xml:space="preserve">
          <source>Axis along which to find the peaks. If None (default) the flattened array is used.</source>
          <target state="translated">ピークを見つける軸。None(デフォルト)の場合、平坦化された配列が使用されます。</target>
        </trans-unit>
        <trans-unit id="c855b308fb59a9f63969a5e9a73073df7701d3a8" translate="yes" xml:space="preserve">
          <source>Axis along which to insert &lt;code&gt;values&lt;/code&gt;. If &lt;code&gt;axis&lt;/code&gt; is None then &lt;code&gt;arr&lt;/code&gt; is flattened first.</source>
          <target state="translated">&lt;code&gt;values&lt;/code&gt; を挿入する軸。 &lt;code&gt;axis&lt;/code&gt; がNoneの場合、 &lt;code&gt;arr&lt;/code&gt; が最初に平坦化されます。</target>
        </trans-unit>
        <trans-unit id="caa670fb62ad34335b9428afd9953d664aefbfc6" translate="yes" xml:space="preserve">
          <source>Axis along which to operate. By default flattened input is used.</source>
          <target state="translated">操作する軸。デフォルトではフラット入力が使用されます。</target>
        </trans-unit>
        <trans-unit id="1612a72f0d3b6ca5a9a80a269a8a766d4f4346ff" translate="yes" xml:space="preserve">
          <source>Axis along which to operate. By default, &lt;code&gt;axis&lt;/code&gt; is None and the flattened input is used.</source>
          <target state="translated">動作する軸。デフォルトでは、 &lt;code&gt;axis&lt;/code&gt; はなしであり、平坦化された入力が使用されます。</target>
        </trans-unit>
        <trans-unit id="dfc23123538404f83aba951929e9f61fafacf779" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. Default is None.</source>
          <target state="translated">操作を実行する軸。デフォルトは None です。</target>
        </trans-unit>
        <trans-unit id="f599b7c76d66ef3380a35805a50ac6efed5828ce" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. If None (default), applies to a flattened version of the array, and this is the same as &lt;a href=&quot;numpy.ma.flatnotmasked_contiguous#numpy.ma.flatnotmasked_contiguous&quot;&gt;&lt;code&gt;flatnotmasked_contiguous&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">操作を実行する軸。None（デフォルト）の場合、フラット化されたバージョンの配列に適用され、これは&lt;a href=&quot;numpy.ma.flatnotmasked_contiguous#numpy.ma.flatnotmasked_contiguous&quot;&gt; &lt;code&gt;flatnotmasked_contiguous&lt;/code&gt; &lt;/a&gt;と同じです。</target>
        </trans-unit>
        <trans-unit id="04c94dfe1278eba9030646d853545708152162d2" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. If None (default), applies to a flattened version of the array.</source>
          <target state="translated">操作を実行する軸。None (デフォルト)の場合、平坦化された配列に適用されます。</target>
        </trans-unit>
        <trans-unit id="504f2a8eb88761fe60f8368b4521f8ae3d7cee4e" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. If None, applies to a flattened version of the array.</source>
          <target state="translated">操作を実行する軸。Noneの場合、配列の平坦化バージョンに適用されます。</target>
        </trans-unit>
        <trans-unit id="152709e5051b3ce45dda1f386ffce54b5252f137" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. Default is -1, which means sort along the last axis.</source>
          <target state="translated">ソートする軸。デフォルトは -1 で、最後の軸に沿ってソートすることを意味します。</target>
        </trans-unit>
        <trans-unit id="2188a35fbb2aa8c603498f4b78d1698cebdd5a7d" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. If None, the array is flattened before sorting. The default is -1, which sorts along the last axis.</source>
          <target state="translated">ソートする軸。None の場合、配列はソートする前に平坦化されます。デフォルトは -1 で、最後の軸に沿ってソートします。</target>
        </trans-unit>
        <trans-unit id="740a6ece80316cdabae954a87f619b8a229d3521" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. If None, the default, the flattened array is used.</source>
          <target state="translated">ソートする軸。Noneの場合、デフォルトでは平坦化された配列が使用されます。</target>
        </trans-unit>
        <trans-unit id="d4ba2932956beb23c342eb9374fa565cb3b55723" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. The default is -1 (the last axis). If None, the flattened array is used.</source>
          <target state="translated">ソートする軸。デフォルトは -1 (最後の軸)です。None の場合は、平坦化された配列が使用されます。</target>
        </trans-unit>
        <trans-unit id="bf13afc2432793901330c8c7a32dd664b93fb6da" translate="yes" xml:space="preserve">
          <source>Axis along which to take slices. If None (default), work on the flattened array.</source>
          <target state="translated">スライスを取る軸。None(デフォルト)の場合、平坦化された配列で作業を行います。</target>
        </trans-unit>
        <trans-unit id="862dd8c4bcf2d6630f10d14b83366d28de07835e" translate="yes" xml:space="preserve">
          <source>Axis along which unwrap will operate, default is the last axis.</source>
          <target state="translated">アンラップが動作する軸に沿って、デフォルトは最後の軸です。</target>
        </trans-unit>
        <trans-unit id="2642370e7acd3a38fa3e5ae2e4852e710ae2493f" translate="yes" xml:space="preserve">
          <source>Axis of &lt;code&gt;a&lt;/code&gt; that defines the vector(s). By default, the last axis.</source>
          <target state="translated">軸ベクトル（複数可）を定義します。デフォルトでは、最後の軸。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac79a24e9b27340a01d757c607f815c179d09b07" translate="yes" xml:space="preserve">
          <source>Axis of &lt;code&gt;b&lt;/code&gt; that defines the vector(s). By default, the last axis.</source>
          <target state="translated">ベクトルを定義する &lt;code&gt;b&lt;/code&gt; の軸。デフォルトでは、最後の軸。</target>
        </trans-unit>
        <trans-unit id="f367b3271f5fcf8c75672a1e31a99c742130492f" translate="yes" xml:space="preserve">
          <source>Axis of &lt;code&gt;c&lt;/code&gt; containing the cross product vector(s). Ignored if both input vectors have dimension 2, as the return is scalar. By default, the last axis.</source>
          <target state="translated">外積ベクトルを含む &lt;code&gt;c&lt;/code&gt; の軸。戻り値がスカラーであるため、両方の入力ベクトルの次元が2の場合は無視されます。デフォルトでは、最後の軸。</target>
        </trans-unit>
        <trans-unit id="73455e870dee7c0562b8878e31766028fce2291e" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical AND reduction is performed. The default (&lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt;) is to perform a logical AND over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">論理AND削減が実行される軸。デフォルト（ &lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt; ）では、入力配列のすべての次元に対して論理ANDを実行します。 &lt;code&gt;axis&lt;/code&gt; は負の場合もあり、その場合、最後の軸から最初の軸までカウントされます。</target>
        </trans-unit>
        <trans-unit id="10ee68577b50399a741722b3f075be540558e59c" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical AND reduction is performed. The default (&lt;code&gt;axis=None&lt;/code&gt;) is to perform a logical AND over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">論理AND削減が実行される1つまたは複数の軸。デフォルト（ &lt;code&gt;axis=None&lt;/code&gt; ）は、入力配列のすべての次元に対して論理ANDを実行することです。 &lt;code&gt;axis&lt;/code&gt; は負の場合があり、その場合、最後の軸から最初の軸までカウントされます。</target>
        </trans-unit>
        <trans-unit id="f611b0275c8907be5ddfd942eef1d1cb490e3bfa" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical OR reduction is performed. The default (&lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt;) is to perform a logical OR over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">論理OR削減が実行される軸。デフォルト（ &lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt; ）では、入力配列のすべての次元に対して論理ORを実行します。 &lt;code&gt;axis&lt;/code&gt; は負の場合もあり、その場合、最後の軸から最初の軸までカウントされます。</target>
        </trans-unit>
        <trans-unit id="4b3cd50c25bcf6114d5dbf62c339109576c970bf" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical OR reduction is performed. The default (&lt;code&gt;axis=None&lt;/code&gt;) is to perform a logical OR over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">論理OR削減が実行される1つまたは複数の軸。デフォルト（ &lt;code&gt;axis=None&lt;/code&gt; ）は、入力配列のすべての次元に対して論理ORを実行することです。 &lt;code&gt;axis&lt;/code&gt; は負の場合があり、その場合、最後の軸から最初の軸までカウントされます。</target>
        </trans-unit>
        <trans-unit id="9fd47f9900eba5a8ae95abac9ad38d16026ca50d" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a product is performed. The default, axis=None, will calculate the product of all the elements in the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="translated">積が実行される軸または軸。デフォルトの axis=None は、入力配列内のすべての要素の積を計算します。axisが負の場合は、最後の軸から最初の軸までカウントされます。</target>
        </trans-unit>
        <trans-unit id="be576580b5bc0f979cac29a5b9d9045456b366f7" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a reduction is performed. The default (&lt;code&gt;axis&lt;/code&gt; = 0) is perform a reduction over the first dimension of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">削減が実行される軸。デフォルト（ &lt;code&gt;axis&lt;/code&gt; = 0）は、入力配列の最初の次元に対して縮小を実行します。 &lt;code&gt;axis&lt;/code&gt; は負の場合もあり、その場合、最後の軸から最初の軸までカウントされます。</target>
        </trans-unit>
        <trans-unit id="a9d8568517293b16cabcf73bd06fbc68a72003cd" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="translated">和が実行される軸または軸。デフォルトの axis=None は、入力配列のすべての要素を合計します。axis が負の場合は、最後の軸から最初の軸までカウントされます。</target>
        </trans-unit>
        <trans-unit id="7cc8bc628160032ea1ebe6f16101b997f0306e3e" translate="yes" xml:space="preserve">
          <source>Axis or axes along which elements are shifted. By default, the array is flattened before shifting, after which the original shape is restored.</source>
          <target state="translated">要素をシフトさせる軸または軸。デフォルトでは、配列はシフトする前に平坦化され、その後元の形状に復元されます。</target>
        </trans-unit>
        <trans-unit id="0e425003e67ef9bdd8af0004538626cffe9c1582" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the count is performed. The default (&lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt;) performs the count over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">カウントが実行される軸。デフォルト（ &lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt; ）は、入力配列のすべての次元でカウントを実行します。 &lt;code&gt;axis&lt;/code&gt; は負の場合もあり、その場合、最後の軸から最初の軸までカウントされます。</target>
        </trans-unit>
        <trans-unit id="dbd8b445b81cd5436ce710f441b84e722e566a56" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the count is performed. The default, None, performs the count over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">カウントが実行される1つまたは複数の軸。デフォルトのNoneは、入力配列のすべての次元でカウントを実行します。 &lt;code&gt;axis&lt;/code&gt; は負の場合があり、その場合、最後の軸から最初の軸までカウントされます。</target>
        </trans-unit>
        <trans-unit id="337ec9c050b4ae190316c405d645be292f57618f" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the maximum is computed. The default is to compute the maximum of the flattened array.</source>
          <target state="translated">最大値が計算される軸または軸。デフォルトでは,平坦化された配列の最大値を計算します.</target>
        </trans-unit>
        <trans-unit id="5bcbcdbcc90358e775edd4243e64cbf53abf5bcb" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the means are computed. The default is to compute the mean of the flattened array.</source>
          <target state="translated">平均が計算される軸または軸。デフォルトでは、平坦化された配列の平均を計算します。</target>
        </trans-unit>
        <trans-unit id="81e7f835d919d359ddd019861026589dd953700f" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the medians are computed. The default is to compute the median along a flattened version of the array. A sequence of axes is supported since version 1.9.0.</source>
          <target state="translated">中央値を計算する軸または軸。デフォルトは、配列の平坦化されたバージョンに沿ってメディアンを計算します。バージョン1.9.0以降、軸のシーケンスがサポートされています。</target>
        </trans-unit>
        <trans-unit id="86845400b54274fa2252847f24187b5fc174bc52" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the minimum is computed. The default is to compute the minimum of the flattened array.</source>
          <target state="translated">最小値が計算される軸または軸。デフォルトでは、平坦化された配列の最小値を計算します。</target>
        </trans-unit>
        <trans-unit id="afcadb3cc3e2b57bd1839f95d5290aac2075b609" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the percentiles are computed. The default is to compute the percentile(s) along a flattened version of the array.</source>
          <target state="translated">パーセンタイルが計算される軸または軸。デフォルトでは、平坦化された配列に沿ってパーセンタイルを計算します。</target>
        </trans-unit>
        <trans-unit id="1383f75934b288777f915d7bd0d8e7d4bc49532a" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the product is computed. The default is to compute the product of the flattened array.</source>
          <target state="translated">積が計算される軸または軸。デフォルトでは、平坦化された配列の積を計算します。</target>
        </trans-unit>
        <trans-unit id="dc86583a236f0e917d6fd47accfd6b2805fa40e8" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the quantiles are computed. The default is to compute the quantile(s) along a flattened version of the array.</source>
          <target state="translated">分位値が計算される軸または軸。デフォルトでは、配列の平坦化されたバージョンに沿って分位値を計算します。</target>
        </trans-unit>
        <trans-unit id="ff0198667d8f16fd97a42b385598004387813742" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the standard deviation is computed. The default is to compute the standard deviation of the flattened array.</source>
          <target state="translated">標準偏差が計算される軸または軸。デフォルトでは、平坦化された配列の標準偏差を計算します。</target>
        </trans-unit>
        <trans-unit id="561888a8d151a5f97b2ece2d51ce899a36bbfbdf" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the sum is computed. The default is to compute the sum of the flattened array.</source>
          <target state="translated">合計が計算される軸または軸。デフォルトでは、平坦化された配列の合計を計算します。</target>
        </trans-unit>
        <trans-unit id="949a7d6d27806e44a3241bd974384af685d26396" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the variance is computed. The default is to compute the variance of the flattened array.</source>
          <target state="translated">分散が計算される軸または軸。デフォルトでは、平坦化された配列の分散を計算します。</target>
        </trans-unit>
        <trans-unit id="daa1ea5e7ee9d15405e9d59d22ce1b86e2982a0b" translate="yes" xml:space="preserve">
          <source>Axis or axes along which to average &lt;code&gt;a&lt;/code&gt;. The default, axis=None, will average over all of the elements of the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="translated">を平均化 &lt;code&gt;a&lt;/code&gt; 1つまたは複数の軸。デフォルトのaxis = Noneは、入力配列のすべての要素の平均です。軸が負の場合、最後の軸から最初の軸までカウントされます。</target>
        </trans-unit>
        <trans-unit id="64370fd7391d23015a65d6e00207ab3ff57c0028" translate="yes" xml:space="preserve">
          <source>Axis or axes along which to flip over. The default, axis=None, will flip over all of the axes of the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="translated">反転させる軸または軸を指定します。デフォルトの axis=None は、入力配列のすべての軸を反転します。axis が負の場合、最後の軸から最初の軸までカウントされます。</target>
        </trans-unit>
        <trans-unit id="f2bf5799ae5ef9d1cdddea7d865553db9614fd21" translate="yes" xml:space="preserve">
          <source>Axis or axes along which to operate. By default, flattened input is used.</source>
          <target state="translated">操作する軸または軸。デフォルトでは、平坦化された入力が使用されます。</target>
        </trans-unit>
        <trans-unit id="f257ca43f52b8d212133752a1e0cef3f157fcc12" translate="yes" xml:space="preserve">
          <source>Axis or tuple of axes along which to count non-zeros. Default is None, meaning that non-zeros will be counted along a flattened version of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">非ゼロをカウントする軸または軸のタプル。デフォルトでは非ゼロの平坦化されたバージョンに沿ってカウントされることを意味し、Noneです。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1dfdd6be5ea8d2b943040ace17a9b289e52760e7" translate="yes" xml:space="preserve">
          <source>Axis over which the anomalies are taken. The default is to use the mean of the flattened array as reference.</source>
          <target state="translated">異常値を取る軸。デフォルトでは、平坦化された配列の平均を参照として使用します。</target>
        </trans-unit>
        <trans-unit id="5a28ddd98da60a547b5ae35ef6abe54e89e91508" translate="yes" xml:space="preserve">
          <source>Axis over which the derivative is taken. (Default: 0).</source>
          <target state="translated">微分が取られる軸。(デフォルト:0)。</target>
        </trans-unit>
        <trans-unit id="ca8db3e3878b22dd385e21680a7f2404ba4af59f" translate="yes" xml:space="preserve">
          <source>Axis over which the integral is taken. (Default: 0).</source>
          <target state="translated">積分が取られる軸。(デフォルト:0)。</target>
        </trans-unit>
        <trans-unit id="7238aa3702fcf05542c14de94bdcecf60c8463af" translate="yes" xml:space="preserve">
          <source>Axis over which to compute the FFT. If not given, the last axis is used.</source>
          <target state="translated">FFTを計算する軸。指定されていない場合は、最後の軸が使用されます。</target>
        </trans-unit>
        <trans-unit id="78aed7a81e841b649e307d86af83f2a27f772253" translate="yes" xml:space="preserve">
          <source>Axis over which to compute the inverse DFT. If not given, the last axis is used.</source>
          <target state="translated">逆DFTを計算する軸。指定されていない場合は、最後の軸が使用されます。</target>
        </trans-unit>
        <trans-unit id="1994028401ccc8c25a36ddcd64e63635d1053d3a" translate="yes" xml:space="preserve">
          <source>Axis over which to compute the inverse FFT. If not given, the last axis is used.</source>
          <target state="translated">逆FFTを計算する軸。指定されていない場合は、最後の軸が使用されます。</target>
        </trans-unit>
        <trans-unit id="7fc8d289aafc37f1ce906424ecc35f2c72d9a34f" translate="yes" xml:space="preserve">
          <source>Axis to be indirectly sorted. By default, sort over the last axis.</source>
          <target state="translated">間接的にソートする軸。デフォルトでは、最後の軸の上にソートされます。</target>
        </trans-unit>
        <trans-unit id="3e1ca61bed45345ef5098f13d05c389833be3df8" translate="yes" xml:space="preserve">
          <source>Axis to be used as the first axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to first axis (0).</source>
          <target state="translated">対角線を取るべき2次元サブアレイの最初の軸として使用される軸。デフォルトは最初の軸(0)。</target>
        </trans-unit>
        <trans-unit id="45f7ee7208a9fb7d4e4732ffbd5f973fe0a479d3" translate="yes" xml:space="preserve">
          <source>Axis to be used as the second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to second axis (1).</source>
          <target state="translated">対角線を取るべき2次元サブアレイの2番目の軸として使用される軸。デフォルトは2番目の軸(1)です。</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="c7781e5925cc1162bf57ca801ea173a8789aefd5" translate="yes" xml:space="preserve">
          <source>BEHAVED and C_CONTIGUOUS.</source>
          <target state="translated">BEHAVEDとC_CONTIGUOUS。</target>
        </trans-unit>
        <trans-unit id="eca3180a6c33b0a38f6f76fa644f63211aa1f14e" translate="yes" xml:space="preserve">
          <source>BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.</source>
          <target state="translated">BEHAVEDとF_CONTIGUOUSで、C_CONTIGUOUSではありません。</target>
        </trans-unit>
        <trans-unit id="c7243d04c977df0309eee7b50ccaddc2665154ee" translate="yes" xml:space="preserve">
          <source>BLAS</source>
          <target state="translated">BLAS</target>
        </trans-unit>
        <trans-unit id="bcd158bb5feaae9038808e3b55d2a031b8ba7709" translate="yes" xml:space="preserve">
          <source>BLAS (NetLIB)</source>
          <target state="translated">BLAS (NetLIB)</target>
        </trans-unit>
        <trans-unit id="dcf8c920edb3ad9eb9b92f8b67ba19eaaa1b8c86" translate="yes" xml:space="preserve">
          <source>BLIS</source>
          <target state="translated">BLIS</target>
        </trans-unit>
        <trans-unit id="cf867b1a06ac32f25a3a53b5cac69625adf84e3c" translate="yes" xml:space="preserve">
          <source>BLIS support in &lt;code&gt;numpy.distutils&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.distutils&lt;/code&gt; でのBLISサポート</target>
        </trans-unit>
        <trans-unit id="214e501b88ef4fd6dfd2e0ceb3d07f872f3aa657" translate="yes" xml:space="preserve">
          <source>BSD / Solaris</source>
          <target state="translated">BSD/Solaris</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="bd452a7ea759269a521e984eabecb645ce4b2ea6" translate="yes" xml:space="preserve">
          <source>Background information</source>
          <target state="translated">背景情報</target>
        </trans-unit>
        <trans-unit id="090a12d667902964e48f38714b38e1c7c7410ac2" translate="yes" xml:space="preserve">
          <source>Backport Pull Requests</source>
          <target state="translated">バックポートのプルリクエスト</target>
        </trans-unit>
        <trans-unit id="304c9bb8acb18cf698a66eac9714c36a88110784" translate="yes" xml:space="preserve">
          <source>Backporting</source>
          <target state="translated">Backporting</target>
        </trans-unit>
        <trans-unit id="850de91aa7213a4adf4d94aeab2caaf4d100f909" translate="yes" xml:space="preserve">
          <source>Backporting is the process of copying new feature/fixes committed in &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;numpy/master&lt;/a&gt; back to stable release branches. To do this you make a branch off the branch you are backporting to, cherry pick the commits you want from &lt;code&gt;numpy/master&lt;/code&gt;, and then submit a pull request for the branch containing the backport.</source>
          <target state="translated">バック&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;ポート&lt;/a&gt;は、numpy / masterでコミットされた新しい機能/修正を安定したリリースブランチにコピーして戻すプロセスです。これを行うには、バックポート先のブランチからブランチを作成し、 &lt;code&gt;numpy/master&lt;/code&gt; から必要なコミットをチェリーピックしてから、バックポートを含むブランチのプルリクエストを送信します。</target>
        </trans-unit>
        <trans-unit id="172132c5b69b62eb861ca29a9ea486edc3f7219f" translate="yes" xml:space="preserve">
          <source>Bare metal, wrap your own C-code manually.</source>
          <target state="translated">ベアメタル、自分のCコードを手動で包む。</target>
        </trans-unit>
        <trans-unit id="53740dccbfb785b89a2a2e2837295960b3f62362" translate="yes" xml:space="preserve">
          <source>Base Class for generic BitGenerators, which provide a stream of random bits based on different algorithms.</source>
          <target state="translated">さまざまなアルゴリズムに基づいたランダムビットのストリームを提供する汎用ビット生成器の基底クラス。</target>
        </trans-unit>
        <trans-unit id="2f03f2251cbc22f3d11027c3e6199900a02163b7" translate="yes" xml:space="preserve">
          <source>Base Class for generic BitGenerators, which provide a stream of random bits based on different algorithms. Must be overridden.</source>
          <target state="translated">様々なアルゴリズムに基づいたランダムビットのストリームを提供する汎用ビット生成器の基底クラス。オーバーライドする必要があります。</target>
        </trans-unit>
        <trans-unit id="18c896688f02b72b07f8b6644f275710e91f33b7" translate="yes" xml:space="preserve">
          <source>Base class</source>
          <target state="translated">基底クラス</target>
        </trans-unit>
        <trans-unit id="c559e4e184dd4d014a0b5060ba07110daeea6a9f" translate="yes" xml:space="preserve">
          <source>Base class for all polynomial types.</source>
          <target state="translated">すべての多項式型の基底クラス.</target>
        </trans-unit>
        <trans-unit id="6149d0f0d497f5c19a312e242e3099f49c4e1828" translate="yes" xml:space="preserve">
          <source>Base class for errors in this module.</source>
          <target state="translated">このモジュールのエラーの基底クラス。</target>
        </trans-unit>
        <trans-unit id="6c3e6ca54a7a88ced88fed404dda8485677d4e2e" translate="yes" xml:space="preserve">
          <source>Base class for numpy scalar types.</source>
          <target state="translated">numpyスカラ型の基底クラス.</target>
        </trans-unit>
        <trans-unit id="860a1492914588f337f184bd4823757e7c5382ef" translate="yes" xml:space="preserve">
          <source>Base object if memory is from some other object.</source>
          <target state="translated">メモリが他のオブジェクトからのものである場合は、ベースとなるオブジェクト。</target>
        </trans-unit>
        <trans-unit id="e272affdfa292522d2f5ac68c3e4ab276db10b62" translate="yes" xml:space="preserve">
          <source>Base of natural logarithm (</source>
          <target state="translated">自然対数の基底(</target>
        </trans-unit>
        <trans-unit id="65a08d51a2e698f7325209df48e279e52d580030" translate="yes" xml:space="preserve">
          <source>Base-2 logarithm of &lt;code&gt;2**x1 + 2**x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;2**x1 + 2**x2&lt;/code&gt; 2を底とする対数。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="dc8e13711f25f1ed77c835a90063cf7df6b684db" translate="yes" xml:space="preserve">
          <source>Base-2 logarithm of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の 2を底とする対数。</target>
        </trans-unit>
        <trans-unit id="99798b5608dba0e80521a63a27ddafba29b89b07" translate="yes" xml:space="preserve">
          <source>Base-2 logarithm of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の 2を底とする対数。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="38987414db4d1bf81908059ba9b136da28c33714" translate="yes" xml:space="preserve">
          <source>Base-n representations</source>
          <target state="translated">ベースnの表現</target>
        </trans-unit>
        <trans-unit id="0bff1548231bd093df6d8bc4bf7a28a9733d2f0e" translate="yes" xml:space="preserve">
          <source>Based on the above characterization, &amp;ldquo;high-priority&amp;rdquo; changes (i.e. fixing technical inaccuracies, broken links, etc.) can be proposed via pull requests directly as they are straightforward to review. Other changes should be raised as issues first so that the discussion can happen before you make major modifications, which in principle saves you from wasting your time on undesired changes.</source>
          <target state="translated">上記の特性に基づいて、「優先度の高い」変更（つまり、技術的な不正確さの修正、リンクの切断など）は、簡単に確認できるため、プルリクエストを介して直接提案できます。大きな変更を加える前に話し合いができるように、他の変更を最初に問題として提起する必要があります。これにより、原則として、不要な変更に時間を無駄にすることがなくなります。</target>
        </trans-unit>
        <trans-unit id="da94602e9563f3ceebc2fc5b569a77851b4c7e35" translate="yes" xml:space="preserve">
          <source>Basic &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt;: ~1520ms (benchmarked on 3.1GHz Intel i5.)</source>
          <target state="translated">基本的な&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;：〜1520ms（3.1GHz Intel i5でベンチマーク）</target>
        </trans-unit>
        <trans-unit id="e6e180bdb3abc214441692c8749fa0f6558a1809" translate="yes" xml:space="preserve">
          <source>Basic Array Flags</source>
          <target state="translated">基本的な配列フラグ</target>
        </trans-unit>
        <trans-unit id="e4e049299abaf782878f7f84544dfdb97d319e23" translate="yes" xml:space="preserve">
          <source>Basic Datetimes</source>
          <target state="translated">基本的な日付</target>
        </trans-unit>
        <trans-unit id="6081b68b227981c90bce83d2c2beb9f59d79503d" translate="yes" xml:space="preserve">
          <source>Basic Git setup</source>
          <target state="translated">基本的なGitの設定</target>
        </trans-unit>
        <trans-unit id="7a031fb4b54459f27072c9ee40c4b13ebd94a781" translate="yes" xml:space="preserve">
          <source>Basic Installation</source>
          <target state="translated">基本的なインストール</target>
        </trans-unit>
        <trans-unit id="e5074656d77a5a1b87923975067a88a41f1ac1c1" translate="yes" xml:space="preserve">
          <source>Basic Iteration</source>
          <target state="translated">基本的な反復処理</target>
        </trans-unit>
        <trans-unit id="57a6dc8bc52fe0e5017a1d4e4df961ab713b5b3a" translate="yes" xml:space="preserve">
          <source>Basic Linear Algebra</source>
          <target state="translated">基礎線形代数</target>
        </trans-unit>
        <trans-unit id="c7231dfbf12224ef4a3543250815ccb954fcb938" translate="yes" xml:space="preserve">
          <source>Basic Linear Algebra Subprograms</source>
          <target state="translated">基本的な線形代数サブプログラム</target>
        </trans-unit>
        <trans-unit id="9a85f6e8c6ded273cdb7e38718d85979a45dd77e" translate="yes" xml:space="preserve">
          <source>Basic Operations</source>
          <target state="translated">基本操作</target>
        </trans-unit>
        <trans-unit id="7169d2b21ccd399c4bc0e79bbfdd0bd5c61ee835" translate="yes" xml:space="preserve">
          <source>Basic Slicing and Indexing</source>
          <target state="translated">基本的なスライシングとインデックス作成</target>
        </trans-unit>
        <trans-unit id="60094894bbbb579bd2f4b96162f9928ec2ce169d" translate="yes" xml:space="preserve">
          <source>Basic Statistics</source>
          <target state="translated">基礎統計学</target>
        </trans-unit>
        <trans-unit id="b9b6d01ce3d08fc15e9971b8d7ad62d621a90733" translate="yes" xml:space="preserve">
          <source>Basic array operations</source>
          <target state="translated">基本的な配列操作</target>
        </trans-unit>
        <trans-unit id="bf23a24f7e23fb617c002847d87b0e8162ee99d1" translate="yes" xml:space="preserve">
          <source>Basic customization:</source>
          <target state="translated">基本的なカスタマイズ。</target>
        </trans-unit>
        <trans-unit id="4c8d5fdc5db9950cf7bea592d196bad4f803b3fb" translate="yes" xml:space="preserve">
          <source>Basic examples</source>
          <target state="translated">基本的な例</target>
        </trans-unit>
        <trans-unit id="beb8cd5e0f8e7a06f8d36dc83c4364f7f79078fa" translate="yes" xml:space="preserve">
          <source>Basic operations</source>
          <target state="translated">基本操作</target>
        </trans-unit>
        <trans-unit id="d6e8bb93c76a2ef8f7afd4a4fc3b007cbfd7ef2c" translate="yes" xml:space="preserve">
          <source>Basic operations are simple with NumPy. If you want to find the sum of the elements in an array, you&amp;rsquo;d use &lt;code&gt;sum()&lt;/code&gt;. This works for 1D arrays, 2D arrays, and arrays in higher dimensions.</source>
          <target state="translated">基本的な操作はNumPyで簡単です。配列内の要素の合計を検索する場合は、 &lt;code&gt;sum()&lt;/code&gt; を使用します。これは、1D配列、2D配列、および高次元の配列で機能します。</target>
        </trans-unit>
        <trans-unit id="b900db10ad3fb5583b98ef507ab36ddd8153f435" translate="yes" xml:space="preserve">
          <source>Basic slicing extends Python&amp;rsquo;s basic concept of slicing to N dimensions. Basic slicing occurs when &lt;em&gt;obj&lt;/em&gt; is a &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt;&lt;code&gt;slice&lt;/code&gt;&lt;/a&gt; object (constructed by &lt;code&gt;start:stop:step&lt;/code&gt; notation inside of brackets), an integer, or a tuple of slice objects and integers. &lt;code&gt;Ellipsis&lt;/code&gt; and &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; objects can be interspersed with these as well.</source>
          <target state="translated">基本的なスライスは、Pythonのスライスの基本的な概念をN次元に拡張します。基本的なスライスは、&lt;em&gt;obj&lt;/em&gt;が&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt; &lt;code&gt;slice&lt;/code&gt; &lt;/a&gt;オブジェクト（括弧内の &lt;code&gt;start:stop:step&lt;/code&gt; 表記で構成）、整数、またはスライスオブジェクトと整数のタプルである場合に発生します。 &lt;code&gt;Ellipsis&lt;/code&gt; と&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;オブジェクトは、これらが点在することができます。</target>
        </trans-unit>
        <trans-unit id="b34ccf1a566015b10946e74591046f4136452341" translate="yes" xml:space="preserve">
          <source>Basic slicing with more than one non-&lt;code&gt;:&lt;/code&gt; entry in the slicing tuple, acts like repeated application of slicing using a single non-&lt;code&gt;:&lt;/code&gt; entry, where the non-&lt;code&gt;:&lt;/code&gt; entries are successively taken (with all other non-&lt;code&gt;:&lt;/code&gt; entries replaced by &lt;code&gt;:&lt;/code&gt;). Thus, &lt;code&gt;x[ind1,...,ind2,:]&lt;/code&gt; acts like &lt;code&gt;x[ind1][...,ind2,:]&lt;/code&gt; under basic slicing.</source>
          <target state="translated">非つ以上の基本的なスライシング &lt;code&gt;:&lt;/code&gt; スライスの組内のエントリは、単一の非を使用して、スライスの反復適用のように動作 &lt;code&gt;:&lt;/code&gt; エントリ、ここで、非 &lt;code&gt;:&lt;/code&gt; エントリは、連続（すべての他の非で撮影された &lt;code&gt;:&lt;/code&gt; エントリはにより置換しました &lt;code&gt;:&lt;/code&gt; ） 。したがって、 &lt;code&gt;x[ind1,...,ind2,:]&lt;/code&gt; &lt;code&gt;x[ind1][...,ind2,:]&lt;/code&gt; 、基本的なスライスではx [ind1] [...、ind2 ,:]のように機能します。</target>
        </trans-unit>
        <trans-unit id="de17dd65e3190938ee92ddb98549d2245920a8ee" translate="yes" xml:space="preserve">
          <source>Basic usage is to call &lt;a href=&quot;../reference/c-api/array#c.PyArray_IterNew&quot;&gt;&lt;code&gt;PyArray_IterNew&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;array&lt;/code&gt; ) where array is an ndarray object (or one of its sub-classes). The returned object is an array-iterator object (the same object returned by the .flat attribute of the ndarray). This object is usually cast to PyArrayIterObject* so that its members can be accessed. The only members that are needed are &lt;code&gt;iter-&amp;gt;size&lt;/code&gt; which contains the total size of the array, &lt;code&gt;iter-&amp;gt;index&lt;/code&gt;, which contains the current 1-d index into the array, and &lt;code&gt;iter-&amp;gt;dataptr&lt;/code&gt; which is a pointer to the data for the current element of the array. Sometimes it is also useful to access &lt;code&gt;iter-&amp;gt;ao&lt;/code&gt; which is a pointer to the underlying ndarray object.</source>
          <target state="translated">基本的な使用法は、&lt;a href=&quot;../reference/c-api/array#c.PyArray_IterNew&quot;&gt; &lt;code&gt;PyArray_IterNew&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;array&lt;/code&gt; ）を呼び出すことです。ここで、arrayはndarrayオブジェクト（またはそのサブクラスの1つ）です。返されるオブジェクトは、配列イテレータオブジェクトです（ndarrayの.flat属性によって返されるのと同じオブジェクト）。このオブジェクトは通常、そのメンバーにアクセスできるようにPyArrayIterObject *にキャストされます。必要なメンバーは、配列の合計 &lt;code&gt;iter-&amp;gt;size&lt;/code&gt; を含むiter-&amp;gt; size、配列への現在の1-dインデックスを含む &lt;code&gt;iter-&amp;gt;index&lt;/code&gt; 、およびデータへのポインタである &lt;code&gt;iter-&amp;gt;dataptr&lt;/code&gt; だけです。配列の現在の要素。基礎となるndarrayオブジェクトへのポインタであるiter- &lt;code&gt;iter-&amp;gt;ao&lt;/code&gt; にアクセスすると便利な場合もあります。</target>
        </trans-unit>
        <trans-unit id="af837eca09697118dc16afab4a2dc5bfeccd2a15" translate="yes" xml:space="preserve">
          <source>Basic usage. Note how y is the &amp;ldquo;flattened&amp;rdquo; version of [a[:, 0, :], a[:, 1, 0], a[:, 2, :]] since we specified the first iter&amp;rsquo;s axes as [1]</source>
          <target state="translated">基本的な使い方。最初のイターの軸を[1]として指定したため、yは[a [:, 0、：]、a [:, 1、0]、a [:, 2、：]]の「フラット化」バージョンであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="189ceeabec801d69e58e27b3296832fd339cfd5c" translate="yes" xml:space="preserve">
          <source>Basic workflow</source>
          <target state="translated">基本的なワークフロー</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="4ce3c1a6b26e31f8d07ec92f4cb05d49b3eec33d" translate="yes" xml:space="preserve">
          <source>Be aware that when NumPy prints N-dimensional arrays, the last axis is looped over the fastest while the first axis is the slowest. For instance:</source>
          <target state="translated">NumPyがN次元配列を印刷するとき,最後の軸は最も速く,最初の軸は最も遅くループされることに注意してください.例えば</target>
        </trans-unit>
        <trans-unit id="11716f1e3c0926fa9c04fbb3c924f0811bf4b112" translate="yes" xml:space="preserve">
          <source>Be careful about round-off error!</source>
          <target state="translated">丸刈りエラーに注意!?</target>
        </trans-unit>
        <trans-unit id="3008b1888d55827508c13f2c0985bc725a03a91e" translate="yes" xml:space="preserve">
          <source>Be careful in the words that we choose. We are careful and respectful in our communication and we take responsibility for our own speech. Be kind to others. Do not insult or put down other participants. We will not accept harassment or other exclusionary behaviour, such as:</source>
          <target state="translated">選ぶ言葉には気をつけましょう。コミュニケーションを慎重に行い、自分の言葉に責任を持つ。他の参加者に親切にしましょう。他の参加者を侮辱したり、見下したりしないこと。ハラスメントなどの排除的な行為は認めません。</target>
        </trans-unit>
        <trans-unit id="a95dfdc69ac7b8c496606d6afad271cdcc3a6cdb" translate="yes" xml:space="preserve">
          <source>Be collaborative. Our work will be used by other people, and in turn we will depend on the work of others. When we make something for the benefit of the project, we are willing to explain to others how it works, so that they can build on the work to make it even better. Any decision we make will affect users and colleagues, and we take those consequences seriously when making decisions.</source>
          <target state="translated">協力的であること。私たちの作品は他の人に利用され、ひいては他の人の作品に依存することになります。プロジェクトの利益のために何かを作るとき、私たちはそれがどのように機能するのかを喜んで説明します。私たちが行うあらゆる決定は、ユーザーや同僚に影響を与えることになるので、私たちは決定を行う際にはそれらの結果を真剣に受け止めます。</target>
        </trans-unit>
        <trans-unit id="ff801bed133a99446534aede438fa2583bcd9e5a" translate="yes" xml:space="preserve">
          <source>Be empathetic, welcoming, friendly, and patient. We work together to resolve conflict, and assume good intentions. We may all experience some frustration from time to time, but we do not allow frustration to turn into a personal attack. A community where people feel uncomfortable or threatened is not a productive one.</source>
          <target state="translated">共感性を持ち、歓迎し、親しみやすく、忍耐強くあること。衝突を解決するために協力し、善意を前提とします。私たちは、誰もが時折フラストレーションを感じることがあるかもしれませんが、フラストレーションが個人的な攻撃に変わることを許しません。人々が不快に感じたり、脅かされたりするようなコミュニティは、生産的なものではありません。</target>
        </trans-unit>
        <trans-unit id="3eaab4694464d982dfc3e0a1afc07f0c4449c8cc" translate="yes" xml:space="preserve">
          <source>Be inquisitive. Nobody knows everything! Asking questions early avoids many problems later, so we encourage questions, although we may direct them to the appropriate forum. We will try hard to be responsive and helpful.</source>
          <target state="translated">探究心を持って 誰もすべてを知っているわけではありません。早めに質問をすることで、後で多くの問題を避けることができますので、適切なフォーラムに質問を誘導することもありますが、質問を奨励します。私たちは、対応し、役立つように努力します。</target>
        </trans-unit>
        <trans-unit id="6a20b0ffbe846eba275eb3ea56da6251c7cd9752" translate="yes" xml:space="preserve">
          <source>Be mindful of the needs of new members: provide them with explicit support and consideration, with the aim of increasing participation from underrepresented groups in particular.</source>
          <target state="translated">新会員のニーズに留意してください。新会員には明確な支援と配慮を提供し、特に無名のグループからの参加を増やすことを目的としています。</target>
        </trans-unit>
        <trans-unit id="1f37a97353eabf9fd15a91dbc5d9f5eb04cea0bf" translate="yes" xml:space="preserve">
          <source>Be mindful that large arrays created with &lt;code&gt;np.empty&lt;/code&gt; or &lt;code&gt;np.zeros&lt;/code&gt; might not be allocated in physical memory until the memory is accessed. If this is desired behaviour, make sure to comment it in your setup function. If you are benchmarking an algorithm, it is unlikely that a user will be executing said algorithm on a newly created empty/zero array. One can force pagefaults to occur in the setup phase either by calling &lt;code&gt;np.ones&lt;/code&gt; or &lt;code&gt;arr.fill(value)&lt;/code&gt; after creating the array,</source>
          <target state="translated">&lt;code&gt;np.empty&lt;/code&gt; または &lt;code&gt;np.zeros&lt;/code&gt; で作成された大きな配列は、メモリにアクセスするまで物理メモリに割り当てられない可能性があることに注意してください。これが望ましい動作である場合は、セットアップ関数で必ずコメントしてください。アルゴリズムのベンチマークを行っている場合、ユーザーが新しく作成された空/ゼロ配列でそのアルゴリズムを実行する可能性はほとんどありません。配列の作成後に &lt;code&gt;np.ones&lt;/code&gt; または &lt;code&gt;arr.fill(value)&lt;/code&gt; を呼び出すことにより、セットアップフェーズでページフォールトを強制的に発生させることができます。</target>
        </trans-unit>
        <trans-unit id="3730bbeeef610bbf04c76abf5ec330327e101406" translate="yes" xml:space="preserve">
          <source>Be open. We invite anyone to participate in our community. We prefer to use public methods of communication for project-related messages, unless discussing something sensitive. This applies to messages for help or project-related support, too; not only is a public support request much more likely to result in an answer to a question, it also ensures that any inadvertent mistakes in answering are more easily detected and corrected.</source>
          <target state="translated">オープンにしましょう。私たちは、誰でも私たちのコミュニティに参加するように招待しています。プロジェクト関連のメッセージについては、デリケートなことを話している場合を除き、公開された方法でコミュニケーションをとることを好みます。これはヘルプやプロジェクト関連のサポートを求めるメッセージにも当てはまります。</target>
        </trans-unit>
        <trans-unit id="ac10e1f58e2260e13e0683472d08e8f00358973a" translate="yes" xml:space="preserve">
          <source>Be sure to understand what steps you should take to manage the memory when using these conversion functions. These functions can require freeing memory, and/or altering the reference counts of specific objects based on your use.</source>
          <target state="translated">これらの変換関数を使用する際には、メモリを管理するためにどのような手順を踏むべきかを必ず理解しておいてください。これらの関数は、メモリを解放したり、用途に応じて特定のオブジェクトの参照カウントを変更したりする必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="6e72bb7e156cb39574b057b9674c2412ed422481" translate="yes" xml:space="preserve">
          <source>Be warned that even if &lt;code&gt;np.longdouble&lt;/code&gt; offers more precision than python &lt;code&gt;float&lt;/code&gt;, it is easy to lose that extra precision, since python often forces values to pass through &lt;code&gt;float&lt;/code&gt;. For example, the &lt;code&gt;%&lt;/code&gt; formatting operator requires its arguments to be converted to standard python types, and it is therefore impossible to preserve extended precision even if many decimal places are requested. It can be useful to test your code with the value &lt;code&gt;1 + np.finfo(np.longdouble).eps&lt;/code&gt;.</source>
          <target state="translated">場合でも、という警告が &lt;code&gt;np.longdouble&lt;/code&gt; のpythonより提供より精度 &lt;code&gt;float&lt;/code&gt; 、pythonのため、多くの場合、力の値が通過するように、その余分な精度を失うことは容易である &lt;code&gt;float&lt;/code&gt; 。たとえば、 &lt;code&gt;%&lt;/code&gt; フォーマット演算子では、引数を標準のPythonタイプに変換する必要があるため、小数点以下の桁数が多く要求されても、拡張精度を維持することはできません。値 &lt;code&gt;1 + np.finfo(np.longdouble).eps&lt;/code&gt; 使用してコードをテストすると便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="782223c5915f4980a539ed4710dad922b52bef1d" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; is a built-in type (written in C), the &lt;code&gt;__r{op}__&lt;/code&gt; special methods are not directly defined.</source>
          <target state="translated">なぜなら&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; が&lt;/a&gt;内蔵（Cで書かれた）タイプであり、 &lt;code&gt;__r{op}__&lt;/code&gt; 特別な方法は、直接定義されていません。</target>
        </trans-unit>
        <trans-unit id="d79cf7f45add11b370a63146a7703acf9ea33ca1" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;__array_finalize__&lt;/code&gt; is the only method that always sees new instances being created, it is the sensible place to fill in instance defaults for new object attributes, among other tasks.</source>
          <target state="translated">ので &lt;code&gt;__array_finalize__&lt;/code&gt; は常に作成される新しいインスタンスを見ている唯一の方法であり、それは他のタスクの中で、新たなオブジェクト属性、のインスタンスのデフォルト値で埋めるための賢明な場所です。</target>
        </trans-unit>
        <trans-unit id="cc46c55e2dfa187c2ac071bbb4bae1702d622519" translate="yes" xml:space="preserve">
          <source>Because Python strings are immutable, an &lt;code&gt;intent(inout)&lt;/code&gt; argument expects an array version of a string in order to have &lt;em&gt;in situ&lt;/em&gt; changes be effective.</source>
          <target state="translated">Python文字列は不変であるため、 &lt;code&gt;intent(inout)&lt;/code&gt; 引数は、&lt;em&gt;その場での&lt;/em&gt;変更を有効にするために、文字列の配列バージョンを想定しています。</target>
        </trans-unit>
        <trans-unit id="b4ea4687fdb37cf012f30310b86e8fc32c6c91ad" translate="yes" xml:space="preserve">
          <source>Because access to additional information is so useful, IPython uses the &lt;code&gt;?&lt;/code&gt; character as a shorthand for accessing this documentation along with other relevant information. IPython is a command shell for interactive computing in multiple languages. &lt;a href=&quot;https://ipython.org/&quot;&gt;You can find more information about IPython here&lt;/a&gt;.</source>
          <target state="translated">追加情報へのアクセスは非常に便利であるため、IPythonは &lt;code&gt;?&lt;/code&gt; を使用します。他の関連情報とともにこのドキュメントにアクセスするための省略形としての文字。IPythonは、複数の言語でのインタラクティブコンピューティングのためのコマンドシェルです。&lt;a href=&quot;https://ipython.org/&quot;&gt;IPythonの詳細については、こちらをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67d90e5f1ae663c377ee558cca369308548469d2" translate="yes" xml:space="preserve">
          <source>Because exact overlap detection has exponential runtime in the number of dimensions, the decision is made based on heuristics, which has false positives (needless copies in unusual cases) but has no false negatives.</source>
          <target state="translated">厳密なオーバーラップ検出は次元数で指数関数的なランタイムを持つため、ヒューリスティックに基づいて決定され、偽陽性(異常なケースでは不要なコピー)はあるが、偽陰性はない。</target>
        </trans-unit>
        <trans-unit id="b6f4af8bef1f35015b148a058f523cde0f4ccc9d" translate="yes" xml:space="preserve">
          <source>Because of how &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; handles sets, the following does not work as expected:</source>
          <target state="translated">&lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt;がセットを処理する方法のため、以下は期待どおりに機能しません。</target>
        </trans-unit>
        <trans-unit id="4a390a00169642b8c370c2fa0fa4fb8d3ba973c7" translate="yes" xml:space="preserve">
          <source>Because of the difficulty in distributing an extension module made using ctypes, f2py and Cython are still the easiest ways to extend Python for package creation. However, ctypes is in some cases a useful alternative. This should bring more features to ctypes that should eliminate the difficulty in extending Python and distributing the extension using ctypes.</source>
          <target state="translated">ctypesを使って作った拡張モジュールを配布するのは難しいので、パッケージ作成のためにPythonを拡張するには、f2pyやCythonがまだ一番簡単な方法です。しかし、ctypesは場合によっては有用な代替手段となります。これにより、pythonを拡張してctypesを使って拡張モジュールを配布することの難しさを解消するような機能がctypesにも追加されるはずです。</target>
        </trans-unit>
        <trans-unit id="c5a38fa639091b6298538af300d0ae57dcac2792" translate="yes" xml:space="preserve">
          <source>Because python extensions are not used in the same way as usual libraries on most platforms, some errors cannot be automatically detected at build time or even runtime. For example, if you build an extension using a function available only for numpy &amp;gt;= 1.3.0, and you import the extension later with numpy 1.2, you will not get an import error (but almost certainly a segmentation fault when calling the function). That&amp;rsquo;s why several functions are provided to check for numpy versions. The macros &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; corresponds to the numpy version used to build the extension, whereas the versions returned by the functions PyArray_GetNDArrayCVersion and PyArray_GetNDArrayCFeatureVersion corresponds to the runtime numpy&amp;rsquo;s version.</source>
          <target state="translated">ほとんどのプラットフォームでは、Python拡張機能が通常のライブラリと同じように使用されていないため、一部のエラーはビルド時または実行時にも自動的に検出できません。たとえば、numpy&amp;gt; = 1.3.0でのみ使用可能な関数を使用して拡張機能をビルドし、numpy 1.2で拡張機能を後でインポートした場合、インポートエラーは発生しません（ただし、関数を呼び出すときにセグメンテーション違反が発生することはほぼ確実です）。 。そのため、numpyバージョンをチェックするためにいくつかの関数が提供されています。マクロ&lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt;および &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; は、拡張機能のビルドに使用されるnumpyバージョンに対応しますが、関数PyArray_GetNDArrayCVersionおよびPyArray_GetNDArrayCFeatureVersionによって返されるバージョンは、ランタイムnumpyのバージョンに対応します。</target>
        </trans-unit>
        <trans-unit id="00d51d08a981e99f75ad16b5ac99f6d7fcbcfe04" translate="yes" xml:space="preserve">
          <source>Because the ctypes approach exposes a raw interface to the compiled code it is not always tolerant of user mistakes. Robust use of the ctypes module typically involves an additional layer of Python code in order to check the data types and array bounds of objects passed to the underlying subroutine. This additional layer of checking (not to mention the conversion from ctypes objects to C-data-types that ctypes itself performs), will make the interface slower than a hand-written extension-module interface. However, this overhead should be negligible if the C-routine being called is doing any significant amount of work. If you are a great Python programmer with weak C skills, ctypes is an easy way to write a useful interface to a (shared) library of compiled code.</source>
          <target state="translated">ctypesのアプローチはコンパイルされたコードに生のインターフェイスを公開しているため、ユーザのミスを常に許容するわけではありません。ctypesモジュールのロバストな使用は、通常、基礎となるサブルーチンに渡されるオブジェクトのデータ型と配列の境界をチェックするために、Pythonコードの追加レイヤーを必要とします。この追加のチェック層(ctypesオブジェクトからC-data-typesへの変換をctypes自身が行うことは言うまでもありません)は、手書きのextension-moduleインターフェースよりも遅くなります。しかし、呼び出されるC-routineがかなりの量の仕事をしている場合、このオーバーヘッドは無視できるほどのものでなければなりません。もしあなたがC言語のスキルが弱い偉大なPythonプログラマーであれば、ctypesはコンパイルされたコードの(共有された)ライブラリへの便利なインターフェースを簡単に書くことができます。</target>
        </trans-unit>
        <trans-unit id="29dd075a4977fb05332410d8621bf30c67da289c" translate="yes" xml:space="preserve">
          <source>Because the discrete Fourier transform separates its input into components that contribute at discrete frequencies, it has a great number of applications in digital signal processing, e.g., for filtering, and in this context the discretized input to the transform is customarily referred to as a &lt;em&gt;signal&lt;/em&gt;, which exists in the &lt;em&gt;time domain&lt;/em&gt;. The output is called a &lt;em&gt;spectrum&lt;/em&gt; or &lt;em&gt;transform&lt;/em&gt; and exists in the &lt;em&gt;frequency domain&lt;/em&gt;.</source>
          <target state="translated">離散フーリエ変換は、その入力を離散周波数で寄与するコンポーネントに分離するため、デジタル信号処理、たとえばフィルタリングに多くの用途があり、このコンテキストでは、変換への離散化入力は慣習的に&lt;em&gt;信号&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;、これは&lt;em&gt;時間領域に&lt;/em&gt;存在し&lt;em&gt;ます&lt;/em&gt;。出力は&lt;em&gt;スペクトル&lt;/em&gt;または&lt;em&gt;変換&lt;/em&gt;と呼ばれ、&lt;em&gt;周波数領域に&lt;/em&gt;存在し&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="9e9097d0b4adb9f9ce14f47bf1a8961a11b5917f" translate="yes" xml:space="preserve">
          <source>Because the output is limited to the range of the C int64 type, a ValueError is raised when &lt;code&gt;lam&lt;/code&gt; is within 10 sigma of the maximum representable value.</source>
          <target state="translated">出力はCのint64型の範囲に制限されているため、 &lt;code&gt;lam&lt;/code&gt; が表現可能な最大値の10シグマ以内にある場合、ValueErrorが発生します。</target>
        </trans-unit>
        <trans-unit id="fac8d49cb6d5e3c4d76e0475c48ac86177c281c5" translate="yes" xml:space="preserve">
          <source>Because the special treatment of tuples, they are not automatically converted to an array as a list would be. As an example:</source>
          <target state="translated">タプルの特殊な扱いのため、リストのように自動的に配列に変換されるわけではありません。例として</target>
        </trans-unit>
        <trans-unit id="b9411fa9bcced44864e82d01d766c1a2786cafda" translate="yes" xml:space="preserve">
          <source>Because you shouldn&amp;rsquo;t have done that.</source>
          <target state="translated">あなたはそれをするべきではなかったからです。</target>
        </trans-unit>
        <trans-unit id="e66686e9fe82b8c4d1e36e68b32d366de35a5f9f" translate="yes" xml:space="preserve">
          <source>Before beginning, ensure that &lt;em&gt;airspeed velocity&lt;/em&gt; is installed. By default, &lt;code&gt;asv&lt;/code&gt; ships with support for anaconda and virtualenv:</source>
          <target state="translated">開始する前に、&lt;em&gt;対気速度&lt;/em&gt;がインストールされていることを確認してください。デフォルトでは、 &lt;code&gt;asv&lt;/code&gt; アナコンダとvirtualenvのをサポートして発送します</target>
        </trans-unit>
        <trans-unit id="a4352ccd0a83ad23754cd59af6872e1e5131c575" translate="yes" xml:space="preserve">
          <source>Before reading this tutorial you should know a bit of Python. If you would like to refresh your memory, take a look at the &lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Python tutorial&lt;/a&gt;.</source>
          <target state="translated">このチュートリアルを読む前に、Pythonについて少し知っておく必要があります。メモリを更新したい場合は、&lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Pythonチュートリアルをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab8362b68d70c7caa9ac18442122ac15a5a21eab" translate="yes" xml:space="preserve">
          <source>Before reading this tutorial, you should know a bit of Python. If you would like to refresh your memory, take a look at the &lt;a href=&quot;https://docs.python.org/dev/tutorial/index.html&quot;&gt;Python tutorial&lt;/a&gt;.</source>
          <target state="translated">このチュートリアルを読む前に、Pythonについて少し知っておく必要があります。メモリを更新したい場合は、&lt;a href=&quot;https://docs.python.org/dev/tutorial/index.html&quot;&gt;Pythonチュートリアルをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6701eda483d7c3d519624fb81a0315cb15ec0008" translate="yes" xml:space="preserve">
          <source>Before reading this, it may help to familiarize yourself with the basics of C extensions for Python by reading/skimming the tutorials in Section 1 of &lt;a href=&quot;https://docs.python.org/extending/index.html&quot;&gt;Extending and Embedding the Python Interpreter&lt;/a&gt; and in &lt;a href=&quot;c-info.how-to-extend&quot;&gt;How to extend NumPy&lt;/a&gt;</source>
          <target state="translated">これを読む前に、それは1節でチュートリアルをスキミング/読み取ることによって、Python用のC拡張の基礎を理解するのを助けることができる&lt;a href=&quot;https://docs.python.org/extending/index.html&quot;&gt;Pythonインタプリタの拡張と埋め込み&lt;/a&gt;とで&lt;a href=&quot;c-info.how-to-extend&quot;&gt;numpyのを拡張する方法&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32836ad1d5d4d4bb58df8da3afbc677909c61049" translate="yes" xml:space="preserve">
          <source>Before the release branch is made, it should be checked that all deprecated code that should be removed is actually removed, and all new deprecations say in the docstring or deprecation warning at what version the code will be removed.</source>
          <target state="translated">リリースブランチを作成する前に、削除されるべき非推奨コードがすべて実際に削除されているかどうかを確認し、新しい非推奨コードはすべて、どのバージョンのコードが削除されるかを docstring や deprecation warning に記述しておくべきです。</target>
        </trans-unit>
        <trans-unit id="6843f140ae464de1cf1062218ac15fdc241e46ba" translate="yes" xml:space="preserve">
          <source>Before you can register a 1-d loop for a ufunc, the ufunc must be previously created. Then you call &lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_RegisterLoopForType&quot;&gt;&lt;code&gt;PyUFunc_RegisterLoopForType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) with the information needed for the loop. The return value of this function is &lt;code&gt;0&lt;/code&gt; if the process was successful and &lt;code&gt;-1&lt;/code&gt; with an error condition set if it was not successful.</source>
          <target state="translated">ufuncの1-dループを登録する前に、ufuncを事前に作成しておく必要があります。次に、ループに必要な情報を使用して&lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_RegisterLoopForType&quot;&gt; &lt;code&gt;PyUFunc_RegisterLoopForType&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）を呼び出します。この関数の戻り値は、プロセスが成功した場合は &lt;code&gt;0&lt;/code&gt; であり、成功しなかった場合はエラー条件が設定された &lt;code&gt;-1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="29cee176b513b19c85d7dfdf113b326997fd0f33" translate="yes" xml:space="preserve">
          <source>Behavior when the covariance matrix is not positive semidefinite.</source>
          <target state="translated">共分散行列が正半定値でない場合の挙動</target>
        </trans-unit>
        <trans-unit id="20b4ea80568cb9ce63d7c954c6894e4b50f0041f" translate="yes" xml:space="preserve">
          <source>Below I&amp;rsquo;ll describe three typical approaches of using F2PY. The following example Fortran 77 code will be used for illustration, save it as fib1.f:</source>
          <target state="translated">以下では、F2PYを使用する3つの典型的なアプローチについて説明します。次の例のFortran77コードを説明に使用し、fib1.fとして保存します。</target>
        </trans-unit>
        <trans-unit id="252e06d389a00c02f7e08aa374784958db4dd768" translate="yes" xml:space="preserve">
          <source>Below are the public attributes of this object which were documented in &amp;ldquo;Guide to NumPy&amp;rdquo; (we have omitted undocumented public attributes, as well as documented private attributes):</source>
          <target state="translated">「Guide to NumPy」でドキュメント化されたこのオブジェクトのパブリック属性を以下に示します（ドキュメント化されていないパブリック属性およびドキュメント化されたプライベート属性は省略しました）。</target>
        </trans-unit>
        <trans-unit id="94890db1b347a181e379f1b5ca0fad5bcd6b3fc7" translate="yes" xml:space="preserve">
          <source>Below is an example of a minimal &lt;code&gt;setup.py&lt;/code&gt; file for a pure SciPy package:</source>
          <target state="translated">以下は、純粋なSciPyパッケージの最小限の &lt;code&gt;setup.py&lt;/code&gt; ファイルの例です。</target>
        </trans-unit>
        <trans-unit id="525759fddd68e1f874367bb6bfc9a8ba5f573531" translate="yes" xml:space="preserve">
          <source>Below, are several code examples and graphical representations that help make the broadcast rule visually obvious. &lt;a href=&quot;#example-3&quot;&gt;Example 3&lt;/a&gt; adds a one-dimensional array to a two-dimensional array:</source>
          <target state="translated">以下は、ブロードキャストルールを視覚的に明確にするのに役立ついくつかのコード例とグラフィック表現です。&lt;a href=&quot;#example-3&quot;&gt;例3&lt;/a&gt;は、1次元配列を2次元配列に追加します。</target>
        </trans-unit>
        <trans-unit id="6f3b2ca2746598a5c0c336c60d7f1e5542f3b64a" translate="yes" xml:space="preserve">
          <source>Benchmarking</source>
          <target state="translated">Benchmarking</target>
        </trans-unit>
        <trans-unit id="817dcc8fca981b9f81e80ededa53ee4f0c2fe004" translate="yes" xml:space="preserve">
          <source>Benchmarking NumPy with Airspeed Velocity.</source>
          <target state="translated">NumPyを対気速度速度でベンチマークする。</target>
        </trans-unit>
        <trans-unit id="a532923696aa5c8f039ac98c01ebbdc352eb0162" translate="yes" xml:space="preserve">
          <source>Benchmarks are like tests, but have names starting with &amp;ldquo;bench&amp;rdquo; instead of &amp;ldquo;test&amp;rdquo;, and can be found under the &amp;ldquo;benchmarks&amp;rdquo; sub-directory of the module.</source>
          <target state="translated">ベンチマークはテストに似ていますが、名前は「test」ではなく「bench」で始まり、モジュールの「benchmarks」サブディレクトリにあります。</target>
        </trans-unit>
        <trans-unit id="9e0aad69f001fa26b773185a06a8bef93c3f6567" translate="yes" xml:space="preserve">
          <source>Bernoulli trials are experiments with one of two outcomes: success or failure (an example of such an experiment is flipping a coin). The geometric distribution models the number of trials that must be run in order to achieve success. It is therefore supported on the positive integers, &lt;code&gt;k = 1, 2, ...&lt;/code&gt;.</source>
          <target state="translated">ベルヌーイ試験は、成功または失敗の2つの結果のうちの1つを伴う実験です（そのような実験の例は、コインを弾くことです）。幾何分布は、成功を達成するために実行する必要がある試行の数をモデル化します。したがって、正の整数 &lt;code&gt;k = 1, 2, ...&lt;/code&gt; サポートされます。</target>
        </trans-unit>
        <trans-unit id="9fb2a7b505b1b75b34095ee2ffe16a241dd5bdfa" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;sys.stdout&lt;/code&gt;, a file-like object can also be used as it has both required methods:</source>
          <target state="translated">ほか &lt;code&gt;sys.stdout&lt;/code&gt; のそれは両方の必要なメソッドを有するように、ファイルのようなオブジェクトを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="4e5ba1e315701c442ad54ed60833fcd6227c3ccc" translate="yes" xml:space="preserve">
          <source>Besides creating an array from a sequence of elements, you can easily create an array filled with &lt;code&gt;0&lt;/code&gt;&amp;rsquo;s:</source>
          <target state="translated">要素のシーケンスから配列を作成する以外に、 &lt;code&gt;0&lt;/code&gt; で満たされた配列を簡単に作成できます。</target>
        </trans-unit>
        <trans-unit id="feb46c86681950d0f6eb887f4a6fb11b462f9f2e" translate="yes" xml:space="preserve">
          <source>Besides its obvious scientific uses, &lt;em&gt;NumPy&lt;/em&gt; can also be used as an efficient multi-dimensional container of generic data. Arbitrary data types can be defined. This allows &lt;em&gt;NumPy&lt;/em&gt; to seamlessly and speedily integrate with a wide variety of databases.</source>
          <target state="translated">明らかな科学的用途に加えて、&lt;em&gt;NumPy&lt;/em&gt;は一般的なデータの効率的な多次元コンテナとしても使用できます。任意のデータ型を定義できます。これにより、&lt;em&gt;NumPyは&lt;/em&gt;さまざまなデータベースとシームレスかつ迅速に統合できます。</target>
        </trans-unit>
        <trans-unit id="ab274f607cf51efd384bd87e6b3a93295c182bec" translate="yes" xml:space="preserve">
          <source>Besides the structural information contained in the strides and dimensions members of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;, the flags contain important information about how the data may be accessed. In particular, the &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set when the memory is on a suitable boundary according to the data-type array. Even if you have a contiguous chunk of memory, you cannot just assume it is safe to dereference a data- type-specific pointer to an element. Only if the &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set is this a safe operation (on some platforms it will work but on others, like Solaris, it will cause a bus error). The &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; should also be ensured if you plan on writing to the memory area of the array. It is also possible to obtain a pointer to an unwritable memory area. Sometimes, writing to the memory area when the &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; flag is not set will just be rude. Other times it can cause program crashes ( &lt;em&gt;e.g.&lt;/em&gt; a data-area that is a read-only memory-mapped file).</source>
          <target state="translated">&lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; の&lt;/a&gt;ストライドとディメンションのメンバーに含まれる構造情報に加えて、フラグにはデータへのアクセス方法に関する重要な情報が含まれています。特に、&lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;フラグは、メモリがデータ型配列に従って適切な境界にあるときに設定されます。連続したメモリのチャンクがある場合でも、要素へのデータ型固有のポインターを逆参照することが安全であると単純に想定することはできません。&lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;フラグが設定されている場合のみ、これは安全な操作です（一部のプラットフォームでは機能しますが、Solarisなどの他のプラットフォームでは、バスエラーが発生します）。&lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;また、アレイのメモリ領域に書き込む予定がある場合も確認する必要があります。書き込み不可能なメモリ領域へのポインタを取得することもできます。&lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;フラグが設定されていないときにメモリ領域に書き込むと、失礼になることがあります。また、プログラムがクラッシュする場合もあります（&lt;em&gt;たとえば&lt;/em&gt;、読み取り専用のメモリマップファイルであるデータ領域）。</target>
        </trans-unit>
        <trans-unit id="7552a827553f203cc1e2b5ca99b7201f49328d40" translate="yes" xml:space="preserve">
          <source>Besides the structural information contained in the strides and dimensions members of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;, the flags contain important information about how the data may be accessed. In particular, the &lt;a href=&quot;c-api/array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set when the memory is on a suitable boundary according to the data-type array. Even if you have a contiguous chunk of memory, you cannot just assume it is safe to dereference a data- type-specific pointer to an element. Only if the &lt;a href=&quot;c-api/array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set is this a safe operation (on some platforms it will work but on others, like Solaris, it will cause a bus error). The &lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; should also be ensured if you plan on writing to the memory area of the array. It is also possible to obtain a pointer to an unwritable memory area. Sometimes, writing to the memory area when the &lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; flag is not set will just be rude. Other times it can cause program crashes ( &lt;em&gt;e.g.&lt;/em&gt; a data-area that is a read-only memory-mapped file).</source>
          <target state="translated">&lt;a href=&quot;c-api/types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; の&lt;/a&gt;ストライドおよびディメンションメンバーに含まれる構造情報に加えて、フラグには、データへのアクセス方法に関する重要な情報が含まれています。特に、&lt;a href=&quot;c-api/array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;フラグは、メモリがデータ型配列に従って適切な境界上にある場合に設定されます。連続したメモリチャンクがある場合でも、データ型固有のポインタを要素に逆参照しても安全であるとは限りません。&lt;a href=&quot;c-api/array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;フラグが設定されている場合にのみ、これは安全な操作です（一部のプラットフォームでは機能しますが、Solarisなどの他のプラットフォームではバスエラーが発生します）。&lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;配列のメモリ領域への書き込みを計画している場合も確認する必要があります。書き込み不可能なメモリ領域へのポインタを取得することも可能です。&lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;フラグが設定されていないときにメモリ領域に書き込むのは、単に失礼な場合があります。また、プログラムがクラッシュする場合もあります（&lt;em&gt;たとえば&lt;/em&gt;、読み取り専用のメモリマップファイルであるデータ領域）。</target>
        </trans-unit>
        <trans-unit id="e1ba37be85f86a4053d7f866745343aa6628b3b0" translate="yes" xml:space="preserve">
          <source>Besides using &lt;code&gt;runtests.py&lt;/code&gt;, there are various ways to run the tests. Inside the interpreter, tests can be run like this:</source>
          <target state="translated">&lt;code&gt;runtests.py&lt;/code&gt; を使用する以外に、テストを実行するさまざまな方法があります。インタープリター内では、次のようにテストを実行できます。</target>
        </trans-unit>
        <trans-unit id="2bf0953ee914f2edfe24d253c99b5774c0b042b9" translate="yes" xml:space="preserve">
          <source>Best choice for unitary and other non-Hermitian normal matrices.</source>
          <target state="translated">ユニタリー行列やその他の非ヘルミティア正規行列に最適。</target>
        </trans-unit>
        <trans-unit id="22e034c69c8701c0ed22fdd3834451a1ee6eff5e" translate="yes" xml:space="preserve">
          <source>Best practice for achieving reproducible bit streams is to use the default &lt;code&gt;None&lt;/code&gt; for the initial entropy, and then use &lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt;&lt;code&gt;SeedSequence.entropy&lt;/code&gt;&lt;/a&gt; to log/pickle the &lt;a href=&quot;../../entropy#module-numpy.random.entropy&quot;&gt;&lt;code&gt;entropy&lt;/code&gt;&lt;/a&gt; for reproducibility:</source>
          <target state="translated">再現可能なビットストリームを実現するためのベストプラクティスは、初期エントロピーにデフォルトの &lt;code&gt;None&lt;/code&gt; を使用してから、&lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt; &lt;code&gt;SeedSequence.entropy&lt;/code&gt; &lt;/a&gt;を使用して、再現性のために&lt;a href=&quot;../../entropy#module-numpy.random.entropy&quot;&gt; &lt;code&gt;entropy&lt;/code&gt; &lt;/a&gt;をログ/ ピックします。</target>
        </trans-unit>
        <trans-unit id="7670ec2417d2f252a955be33c6c1b4f20bd90718" translate="yes" xml:space="preserve">
          <source>Best practice for achieving reproducible bit streams is to use the default &lt;code&gt;None&lt;/code&gt; for the initial entropy, and then use &lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt;&lt;code&gt;SeedSequence.entropy&lt;/code&gt;&lt;/a&gt; to log/pickle the &lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt;&lt;code&gt;entropy&lt;/code&gt;&lt;/a&gt; for reproducibility:</source>
          <target state="translated">再現可能なビットストリームを実現するためのベストプラクティスは、初期エントロピーにデフォルトの &lt;code&gt;None&lt;/code&gt; を使用してから、&lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt; &lt;code&gt;SeedSequence.entropy&lt;/code&gt; &lt;/a&gt;を使用して再現性のために&lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt; &lt;code&gt;entropy&lt;/code&gt; &lt;/a&gt;をログに記録/選択することです。</target>
        </trans-unit>
        <trans-unit id="ff113b93867eb5d4708dd06e48a11f6662278fd5" translate="yes" xml:space="preserve">
          <source>Beta, positive (&amp;gt;0).</source>
          <target state="translated">ベータ、ポジティブ（&amp;gt; 0）。</target>
        </trans-unit>
        <trans-unit id="df6d93c232f8ef730e08cac2f842b70dab985fb0" translate="yes" xml:space="preserve">
          <source>Beta: &amp;lsquo;1.8.0b1&amp;rsquo;, &amp;lsquo;1.8.0b2&amp;rsquo;, etc.</source>
          <target state="translated">ベータ：「1.8.0b1」、「1.8.0b2」など</target>
        </trans-unit>
        <trans-unit id="e5c69acc70fda034169d23116e19f5548d61c870" translate="yes" xml:space="preserve">
          <source>Better &lt;code&gt;repr&lt;/code&gt; of object arrays</source>
          <target state="translated">オブジェクト配列のより良い &lt;code&gt;repr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71ff91962e9990f86b3c3c6f7d7e56caab72ace4" translate="yes" xml:space="preserve">
          <source>Better behaviour of ufunc identities during reductions</source>
          <target state="translated">還元時のufuncアイデンティティのより良い振る舞い</target>
        </trans-unit>
        <trans-unit id="2e8b6f98e6b21c5c6afa9104a0769b9205288f70" translate="yes" xml:space="preserve">
          <source>Better default repr for &lt;code&gt;ndarray&lt;/code&gt; subclasses</source>
          <target state="translated">&lt;code&gt;ndarray&lt;/code&gt; サブクラスのデフォルトreprの改善</target>
        </trans-unit>
        <trans-unit id="9c34cb1b69a33b2d347cbab7a352fe546099b5b5" translate="yes" xml:space="preserve">
          <source>Better numerical stability for sum in some cases</source>
          <target state="translated">場合によっては、和の数値安定性が向上</target>
        </trans-unit>
        <trans-unit id="c1c0df1717608a8779754648098f8f6a8b834b75" translate="yes" xml:space="preserve">
          <source>Better support for &lt;code&gt;const&lt;/code&gt; dimensions in API functions</source>
          <target state="translated">API関数での &lt;code&gt;const&lt;/code&gt; ディメンションのサポートの向上</target>
        </trans-unit>
        <trans-unit id="9bf8b70bc38b460cf450f48cba644f58d2901785" translate="yes" xml:space="preserve">
          <source>Better support for empty structured and string types</source>
          <target state="translated">空の構造化型と文字列型のサポートが向上</target>
        </trans-unit>
        <trans-unit id="741240e1ef7d29df48749ede4195530d21b5583c" translate="yes" xml:space="preserve">
          <source>Beyond changes to a functions docstring and possible description in the general documentation, if your change introduces any user-facing modifications they may need to be mentioned in the release notes. To add your change to the release notes, you need to create a short file with a summary and place it in &lt;code&gt;doc/release/upcoming_changes&lt;/code&gt;. The file &lt;code&gt;doc/release/upcoming_changes/README.rst&lt;/code&gt; details the format and filename conventions.</source>
          <target state="translated">関数のdocstringの変更と一般的なドキュメントでの可能な説明に加えて、変更によってユーザー向けの変更が導入された場合は、リリースノートに記載する必要があります。リリースノートに変更を追加するには、概要を含む短いファイルを作成し、それを &lt;code&gt;doc/release/upcoming_changes&lt;/code&gt; に配置する必要があります。ファイル &lt;code&gt;doc/release/upcoming_changes/README.rst&lt;/code&gt; には、フォーマットとファイル名の規則が詳しく説明されています。</target>
        </trans-unit>
        <trans-unit id="1d7c1c795d86187e8f7208b51b9e4bbd86fa144c" translate="yes" xml:space="preserve">
          <source>Beyond the Basics</source>
          <target state="translated">基本を超えて</target>
        </trans-unit>
        <trans-unit id="26ffbba2ad335a399beb79e57cd9f0fee4d0bfe1" translate="yes" xml:space="preserve">
          <source>Beyond the Provided Typemaps</source>
          <target state="translated">提供されるタイプマップを超えて</target>
        </trans-unit>
        <trans-unit id="2381a720988421ed44a915283532f745ec598844" translate="yes" xml:space="preserve">
          <source>Binary Format Description</source>
          <target state="translated">バイナリ形式の説明</target>
        </trans-unit>
        <trans-unit id="b26f6c63a335a90adeeab8f4d5013e4f2efe2bec" translate="yes" xml:space="preserve">
          <source>Binary operations</source>
          <target state="translated">バイナリ演算</target>
        </trans-unit>
        <trans-unit id="e2606828726dd092395e99ae84af2fb16d4bba99" translate="yes" xml:space="preserve">
          <source>Binary operations with non-arrays as second argument</source>
          <target state="translated">第2引数に非配列を使用したバイナリ演算</target>
        </trans-unit>
        <trans-unit id="1cc036b4a48151bfca642ff2ead78a54a934983c" translate="yes" xml:space="preserve">
          <source>Binary representation of &lt;code&gt;num&lt;/code&gt; or two&amp;rsquo;s complement of &lt;code&gt;num&lt;/code&gt;.</source>
          <target state="translated">バイナリ表現 &lt;code&gt;num&lt;/code&gt; かの2の補数 &lt;code&gt;num&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cc1259e21c7e613999e790394c5c675e22538ae" translate="yes" xml:space="preserve">
          <source>Binary search is used to find the required insertion points.</source>
          <target state="translated">バイナリサーチは、必要な挿入点を見つけるために使用されます。</target>
        </trans-unit>
        <trans-unit id="d16d7bbb9c6ef7dc7a209b9f7f44b9f5da556503" translate="yes" xml:space="preserve">
          <source>Binary serialization</source>
          <target state="translated">バイナリ直列化</target>
        </trans-unit>
        <trans-unit id="c2fcfedbbaa7680e63fd8ec6b6d6fea722eb952d" translate="yes" xml:space="preserve">
          <source>Binomials</source>
          <target state="translated">Binomials</target>
        </trans-unit>
        <trans-unit id="d12186b0252e4232a8110ba893b738140b658fd0" translate="yes" xml:space="preserve">
          <source>Bit Generators</source>
          <target state="translated">ビットジェネレーター</target>
        </trans-unit>
        <trans-unit id="d9ea127fdd4796c75fc01357c967509bff02d70a" translate="yes" xml:space="preserve">
          <source>Bit field (following integer gives the number of bits in the bit field).</source>
          <target state="translated">ビットフィールド(以下の整数はビットフィールドのビット数を示す)。</target>
        </trans-unit>
        <trans-unit id="4239f8b7894d76bb52c94538f111a8da8d4fb0a0" translate="yes" xml:space="preserve">
          <source>Bit packing</source>
          <target state="translated">ビットパッキン</target>
        </trans-unit>
        <trans-unit id="b80dbb4a253c53f5aa98843beeecc669ef1da4eb" translate="yes" xml:space="preserve">
          <source>Bit-flags describing how this data type is to be interpreted.</source>
          <target state="translated">このデータ型がどのように解釈されるかを記述するビットフラグ。</target>
        </trans-unit>
        <trans-unit id="59a321c44dd261b336bb24b8f3a93b2ffcf9ad14" translate="yes" xml:space="preserve">
          <source>Bit-masks are in &lt;code&gt;numpy.core.multiarray&lt;/code&gt; as the constants &lt;code&gt;ITEM_HASOBJECT&lt;/code&gt;, &lt;code&gt;LIST_PICKLE&lt;/code&gt;, &lt;code&gt;ITEM_IS_POINTER&lt;/code&gt;, &lt;code&gt;NEEDS_INIT&lt;/code&gt;, &lt;code&gt;NEEDS_PYAPI&lt;/code&gt;, &lt;code&gt;USE_GETITEM&lt;/code&gt;, &lt;code&gt;USE_SETITEM&lt;/code&gt;. A full explanation of these flags is in C-API documentation; they are largely useful for user-defined data-types.</source>
          <target state="translated">ビットマスクはしている &lt;code&gt;numpy.core.multiarray&lt;/code&gt; 定数として &lt;code&gt;ITEM_HASOBJECT&lt;/code&gt; 、 &lt;code&gt;LIST_PICKLE&lt;/code&gt; 、 &lt;code&gt;ITEM_IS_POINTER&lt;/code&gt; 、 &lt;code&gt;NEEDS_INIT&lt;/code&gt; 、 &lt;code&gt;NEEDS_PYAPI&lt;/code&gt; 、 &lt;code&gt;USE_GETITEM&lt;/code&gt; 、 &lt;code&gt;USE_SETITEM&lt;/code&gt; 。これらのフラグの完全な説明は、C-APIドキュメントにあります。これらは、ユーザー定義のデータ型に大きく役立ちます。</target>
        </trans-unit>
        <trans-unit id="c6c2f273c5d1a8dcbceea602bbb87c029bbc0d32" translate="yes" xml:space="preserve">
          <source>Bit-twiddling functions</source>
          <target state="translated">ビットツイドル機能</target>
        </trans-unit>
        <trans-unit id="460d665e77f8686560c843f72478486336f12a1b" translate="yes" xml:space="preserve">
          <source>Bit-width names</source>
          <target state="translated">ビット幅名</target>
        </trans-unit>
        <trans-unit id="7176dd338904b0fc1d2cdf1063572e4e5cbd193a" translate="yes" xml:space="preserve">
          <source>Bit-width references to enumerated typenums</source>
          <target state="translated">列挙された型名へのビット幅参照</target>
        </trans-unit>
        <trans-unit id="143911730a6c4fbdf6bd766470cddffa24dd0b5c" translate="yes" xml:space="preserve">
          <source>BitGenerator</source>
          <target state="translated">BitGenerator</target>
        </trans-unit>
        <trans-unit id="e1d49785c1daa86c89ab6e63f74767502d9e2cd5" translate="yes" xml:space="preserve">
          <source>BitGenerator (class in numpy.random)</source>
          <target state="translated">BitGenerator (numpy.random のクラス)</target>
        </trans-unit>
        <trans-unit id="cc03ca2870189a580c7299116633756162b41a61" translate="yes" xml:space="preserve">
          <source>BitGenerator for Chris Doty-Humphrey&amp;rsquo;s Small Fast Chaotic PRNG.</source>
          <target state="translated">Chris Doty-HumphreyのSmall Fast Chaotic PRNGのBitGenerator。</target>
        </trans-unit>
        <trans-unit id="218df33e7359786597fc4c2a6c1726e5e91ef2e6" translate="yes" xml:space="preserve">
          <source>BitGenerator for the PCG-64 pseudo-random number generator.</source>
          <target state="translated">PCG-64擬似乱数発生器のBitGeneratorです。</target>
        </trans-unit>
        <trans-unit id="9b6bde107d0c3c8164f2b3ab1e4164dad1766298" translate="yes" xml:space="preserve">
          <source>BitGenerator to use as the core generator.</source>
          <target state="translated">コアジェネレーターとして使用するBitGenerator。</target>
        </trans-unit>
        <trans-unit id="dbbe08f6d74daba648b1cd173a6a41449071b1bf" translate="yes" xml:space="preserve">
          <source>BitGenerator.random_raw()</source>
          <target state="translated">BitGenerator.random_raw()</target>
        </trans-unit>
        <trans-unit id="ade67fe752c31c985cb01482e4ad03f16cfe18bb" translate="yes" xml:space="preserve">
          <source>BitGenerators: Objects that generate random numbers. These are typically unsigned integer words filled with sequences of either 32 or 64 random bits.</source>
          <target state="translated">BitGenerators (ビットジェネレータ)の略。乱数を生成するオブジェクト。これらは通常、32 または 64 のランダムビットのシーケンスで満たされた符号なし整数ワードです。</target>
        </trans-unit>
        <trans-unit id="a36a25a1cccb68c7c87fcd879bbb216973e2de75" translate="yes" xml:space="preserve">
          <source>Bits</source>
          <target state="translated">Bits</target>
        </trans-unit>
        <trans-unit id="02f4859e8970806328996752f2ca5818252436db" translate="yes" xml:space="preserve">
          <source>Bits are shifted to the left by appending &lt;code&gt;x2&lt;/code&gt; 0s at the right of &lt;code&gt;x1&lt;/code&gt;. Since the internal representation of numbers is in binary format, this operation is equivalent to multiplying &lt;code&gt;x1&lt;/code&gt; by &lt;code&gt;2**x2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; の右側に &lt;code&gt;x2&lt;/code&gt; 0を追加して、ビットを左にシフトします。数値の内部表現はバイナリ形式であるため、この演算は &lt;code&gt;x1&lt;/code&gt; に &lt;code&gt;2**x2&lt;/code&gt; を乗算することと同じです。</target>
        </trans-unit>
        <trans-unit id="9d9f79b7b35bc256a0d1b6d4ab01f312eace24eb" translate="yes" xml:space="preserve">
          <source>Bits are shifted to the right &lt;code&gt;x2&lt;/code&gt;. Because the internal representation of numbers is in binary format, this operation is equivalent to dividing &lt;code&gt;x1&lt;/code&gt; by &lt;code&gt;2**x2&lt;/code&gt;.</source>
          <target state="translated">ビットは右 &lt;code&gt;x2&lt;/code&gt; にシフトされます。数値の内部表現はバイナリ形式であるため、この演算は &lt;code&gt;x1&lt;/code&gt; を &lt;code&gt;2**x2&lt;/code&gt; 除算することと同じです。</target>
        </trans-unit>
        <trans-unit id="117a063b0a577c59c490f864292bca239247279f" translate="yes" xml:space="preserve">
          <source>Bits set for the object data-type: ( &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt;&lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_USE_GETITEM&quot;&gt;&lt;code&gt;NPY_USE_GETITEM&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_IS_POINTER&quot;&gt;&lt;code&gt;NPY_ITEM_IS_POINTER&lt;/code&gt;&lt;/a&gt; | &lt;code&gt;NPY_REFCOUNT&lt;/code&gt; | &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt;&lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt;&lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">オブジェクトデータタイプに設定されたビット：（&lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt; &lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_USE_GETITEM&quot;&gt; &lt;code&gt;NPY_USE_GETITEM&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_IS_POINTER&quot;&gt; &lt;code&gt;NPY_ITEM_IS_POINTER&lt;/code&gt; &lt;/a&gt; | &lt;code&gt;NPY_REFCOUNT&lt;/code&gt; | &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt; &lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt; &lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="13031923c83ade827195c6241750d4615a698b51" translate="yes" xml:space="preserve">
          <source>Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra, Dover Publications, New York.</source>
          <target state="translated">Blackman,R.B.and Tukey,J.W.(1958)The measurement of power spectra,Dover Publications,New York.</target>
        </trans-unit>
        <trans-unit id="348cdf7ff3c8eec7d1cd1aa8880558948fba2435" translate="yes" xml:space="preserve">
          <source>Blocks can be of any dimension, but will not be broadcasted using the normal rules. Instead, leading axes of size 1 are inserted, to make &lt;code&gt;block.ndim&lt;/code&gt; the same for all blocks. This is primarily useful for working with scalars, and means that code like &lt;code&gt;np.block([v, 1])&lt;/code&gt; is valid, where &lt;code&gt;v.ndim == 1&lt;/code&gt;.</source>
          <target state="translated">ブロックは任意の次元にすることができますが、通常のルールを使用してブロードキャストされません。代わりに、サイズ1の先行軸が挿入され、すべてのブロックで &lt;code&gt;block.ndim&lt;/code&gt; が同じになります。これは主にスカラーの操作に役立ち、 &lt;code&gt;v.ndim == 1&lt;/code&gt; であるnp.block &lt;code&gt;np.block([v, 1])&lt;/code&gt; ようなコードが有効であることを意味します。</target>
        </trans-unit>
        <trans-unit id="8994034796d9ec39a7933eb34371fad5f6ce9920" translate="yes" xml:space="preserve">
          <source>Blocks in the innermost lists are concatenated (see &lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;) along the last dimension (-1), then these are concatenated along the second-last dimension (-2), and so on until the outermost list is reached.</source>
          <target state="translated">最も内側のリストでブロックが（参照連結さ&lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt;最後の次元に沿って）（-1）、これらは最後から2番目の次元に沿って連結されている（-2）など最外リストに到達するまでに。</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="317be1616a174c84304de299b4ead5ef76ce4a76" translate="yes" xml:space="preserve">
          <source>Boolean (True or False) stored as a byte</source>
          <target state="translated">バイトとして格納されたブール値(TrueまたはFalse</target>
        </trans-unit>
        <trans-unit id="71383121b53c1c9facdaaabc47b0de18549c5c80" translate="yes" xml:space="preserve">
          <source>Boolean (integer type where all values are only True or False)</source>
          <target state="translated">ブール型(すべての値がTrueかFalseのみの整数型</target>
        </trans-unit>
        <trans-unit id="c7a0fd639a6581c56ba10f492adee6f212cd45b8" translate="yes" xml:space="preserve">
          <source>Boolean 1-d array selecting which entries to return. If len(condition) is less than the size of a along the axis, then output is truncated to length of condition array.</source>
          <target state="translated">どのエントリを返すかを選択する 1-d 配列のブール値。len(condition)が軸に沿った a のサイズよりも小さい場合、出力は条件配列の長さに切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="87962449a461c8ec49f5151d2bbb30e7a462a28e" translate="yes" xml:space="preserve">
          <source>Boolean array indexing</source>
          <target state="translated">ブール配列インデックス</target>
        </trans-unit>
        <trans-unit id="c1aefe73a2b6727a0e572007771ddec686a6bb1f" translate="yes" xml:space="preserve">
          <source>Boolean array of same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と同じ形状のブール配列。</target>
        </trans-unit>
        <trans-unit id="233d1fbe1852dc657d35dfe3cd279e3947a9a911" translate="yes" xml:space="preserve">
          <source>Boolean arrays used as indices are treated in a different manner entirely than index arrays. Boolean arrays must be of the same shape as the initial dimensions of the array being indexed. In the most straightforward case, the boolean array has the same shape:</source>
          <target state="translated">インデックスとして使用されるブール値配列は、インデックス配列とは全く異なる方法で扱われます。ブール型配列は、インデックス化される配列の初期寸法と同じ形状でなければなりません。最もわかりやすいケースでは、ブーリアン配列は同じ形状をしています。</target>
        </trans-unit>
        <trans-unit id="98073379b648edd4cbe725ce47f959a6d23058d4" translate="yes" xml:space="preserve">
          <source>Boolean indexing changes</source>
          <target state="translated">ブールインデキシングの変更</target>
        </trans-unit>
        <trans-unit id="639386fbce5315b91a1c655018a3b9643e9bcfef" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether the byte order of this dtype is native to the platform.</source>
          <target state="translated">このdtypeのバイト順がプラットフォームにネイティブであるかどうかを示すブール値。</target>
        </trans-unit>
        <trans-unit id="0c76417c3c3c65ffeed61396388e3db4b8c19de6" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether the dtype is a struct which maintains field alignment.</source>
          <target state="translated">dtypeがフィールドアライメントを維持する構造体であるかどうかを示すブール値。</target>
        </trans-unit>
        <trans-unit id="dad1680b2705f6d7f6eeec97cbb513a4e1699f09" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether the dtype is a struct which maintains field alignment. This flag is sticky, so when combining multiple structs together, it is preserved and produces new dtypes which are also aligned.</source>
          <target state="translated">dtypeがフィールド整列を維持する構造体であるかどうかを示すブール値。このフラグはスティッキーであるため、複数の構造体を結合する際には、このフラグが保持され、アラインメントされた新しいdtypesも生成されます。</target>
        </trans-unit>
        <trans-unit id="36f2224ace3c78a988e50bdc966ac649a4d3fc0b" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether this dtype contains any reference-counted objects in any fields or sub-dtypes.</source>
          <target state="translated">このdtypeが、任意のフィールドまたはサブタイプに参照カウントされたオブジェクトを含むかどうかを示すブール値。</target>
        </trans-unit>
        <trans-unit id="398d7e2271209225ea68a985a7b2fa72caeee3a6" translate="yes" xml:space="preserve">
          <source>Boolean mask array. It has to be the same shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">ブールマスク配列。と同じ形状で &lt;code&gt;a&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="59815579c0e1a982c330b63fe4d4075e4fd81815" translate="yes" xml:space="preserve">
          <source>Boolean mask array. Must have the same size as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">ブールマスク配列。同じサイズ持っている必要があります。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30d9ef559552bdd87313d89c8796d8136275e739" translate="yes" xml:space="preserve">
          <source>Boolean operations</source>
          <target state="translated">ブール演算</target>
        </trans-unit>
        <trans-unit id="0d747f327c87280779ba3eb08a42ad6dc25e090e" translate="yes" xml:space="preserve">
          <source>Boolean or &amp;ldquo;mask&amp;rdquo; index arrays</source>
          <target state="translated">ブールまたは「マスク」インデックス配列</target>
        </trans-unit>
        <trans-unit id="dd5ec2e25bdf5818c59dcd317ab96e5a1ea9111e" translate="yes" xml:space="preserve">
          <source>Boolean result of check whether &lt;code&gt;rep&lt;/code&gt; is a scalar dtype.</source>
          <target state="translated">&lt;code&gt;rep&lt;/code&gt; がスカラーdtypeであるかどうかのチェックのブール結果。</target>
        </trans-unit>
        <trans-unit id="e4ae3e1eb416ce7ddaa17364adbe02e871496027" translate="yes" xml:space="preserve">
          <source>Boolean result of the logical AND operation applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;; the shape is determined by broadcasting. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; および &lt;code&gt;x2&lt;/code&gt; の要素に適用された論理AND演算のブール結果。形は放送で決まります。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="80129c87ec19d7266b12fa62c898f1de8e697318" translate="yes" xml:space="preserve">
          <source>Boolean result of the logical OR operation applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;; the shape is determined by broadcasting. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; および &lt;code&gt;x2&lt;/code&gt; の要素に適用される論理OR演算のブール結果。形状は放送で決まります。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="efce76e1529f243bc75f6c85e1cb168b94a21ce6" translate="yes" xml:space="preserve">
          <source>Boolean result of the logical XOR operation applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;; the shape is determined by broadcasting. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の要素に適用された論理XOR演算のブール結果。形状は放送で決まります。 &lt;code&gt;x1&lt;/code&gt; と &lt;code&gt;x2&lt;/code&gt; の両方がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="e598e8b30eff8ac988c047694ee54841654f4531" translate="yes" xml:space="preserve">
          <source>Boolean result with the same shape as &lt;code&gt;x&lt;/code&gt; of the NOT operation on elements of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">同じ形状のブール結果 &lt;code&gt;x&lt;/code&gt; の要素に対するNOT演算の &lt;code&gt;x&lt;/code&gt; 。 &lt;code&gt;x&lt;/code&gt; がスカラーの場合、これはスカラーです。</target>
        </trans-unit>
        <trans-unit id="4cfb7a503c91815ccbf2f35210fcd3eadc71e7eb" translate="yes" xml:space="preserve">
          <source>Booleans are accepted as well:</source>
          <target state="translated">ブーリアンも受け付けています。</target>
        </trans-unit>
        <trans-unit id="fff8683eb97daf0f7f34cfbaabaadf811d8b8133" translate="yes" xml:space="preserve">
          <source>Booleans:</source>
          <target state="translated">Booleans:</target>
        </trans-unit>
        <trans-unit id="37cb1b945ecb9b619ea4147615565076f43e7b81" translate="yes" xml:space="preserve">
          <source>Boost Python</source>
          <target state="translated">ブーストパイソン</target>
        </trans-unit>
        <trans-unit id="80eb86696c9c70e3e908a024dfe4075dae3951c7" translate="yes" xml:space="preserve">
          <source>Boost is a repository of C++ libraries and Boost.Python is one of those libraries which provides a concise interface for binding C++ classes and functions to Python. The amazing part of the Boost.Python approach is that it works entirely in pure C++ without introducing a new syntax. Many users of C++ report that Boost.Python makes it possible to combine the best of both worlds in a seamless fashion. I have not used Boost.Python because I am not a big user of C++ and using Boost to wrap simple C-subroutines is usually over-kill. It&amp;rsquo;s primary purpose is to make C++ classes available in Python. So, if you have a set of C++ classes that need to be integrated cleanly into Python, consider learning about and using Boost.Python.</source>
          <target state="translated">BoostはC ++ライブラリのリポジトリであり、Boost.Pythonは、C ++クラスと関数をPythonにバインドするための簡潔なインターフェイスを提供するライブラリの1つです。 Boost.Pythonアプローチの驚くべき部分は、新しい構文を導入することなく、完全に純粋なC ++で機能することです。 C ++の多くのユーザーは、Boost.Pythonによって両方の長所をシームレスに組み合わせることができると報告しています。私はC ++の大口ユーザーではなく、Boostを使用して単純なCサブルーチンをラップするのは通常やり過ぎなので、Boost.Pythonを使用していません。主な目的は、C ++クラスをPythonで使用できるようにすることです。したがって、Pythonにクリーンに統合する必要があるC ++クラスのセットがある場合は、Boost.Pythonについて学習して使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="3d9f5c6c1605197a54538b1a42018d968a659108" translate="yes" xml:space="preserve">
          <source>Boost.Python</source>
          <target state="translated">Boost.Python</target>
        </trans-unit>
        <trans-unit id="35f319efb34e1e345510a06307dd059dbed15ac2" translate="yes" xml:space="preserve">
          <source>Boost.python</source>
          <target state="translated">Boost.python</target>
        </trans-unit>
        <trans-unit id="6a6c7de0b010d58cd0f9cb5716158db428b24bc0" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; must be 0-d or 1-d (ndim = 0 or 1), but &lt;code&gt;u.ndim&lt;/code&gt; need not equal &lt;code&gt;v.ndim&lt;/code&gt;. In other words, all four possible combinations - &lt;code&gt;u.ndim = v.ndim = 0&lt;/code&gt;, &lt;code&gt;u.ndim = v.ndim = 1&lt;/code&gt;, &lt;code&gt;u.ndim = 1, v.ndim = 0&lt;/code&gt;, and &lt;code&gt;u.ndim = 0, v.ndim = 1&lt;/code&gt; - work.</source>
          <target state="translated">両方の &lt;code&gt;u&lt;/code&gt; 及び &lt;code&gt;v&lt;/code&gt; 0-Dまたは1-D（ndim = 0又は1）が、でなければならない &lt;code&gt;u.ndim&lt;/code&gt; 必要等しくない &lt;code&gt;v.ndim&lt;/code&gt; 。つまり、4つの可能な組み合わせすべて、 &lt;code&gt;u.ndim = v.ndim = 0&lt;/code&gt; 、 &lt;code&gt;u.ndim = v.ndim = 1&lt;/code&gt; 、 &lt;code&gt;u.ndim = 1, v.ndim = 0&lt;/code&gt; 、 &lt;code&gt;u.ndim = 0, v.ndim = 1&lt;/code&gt; 仕事。</target>
        </trans-unit>
        <trans-unit id="88f65d9e2d112f1a7a284a45eccfdccc621dc60d" translate="yes" xml:space="preserve">
          <source>Both C-ordering (&amp;ldquo;last dimension fastest&amp;rdquo;) or Fortran-ordering (&amp;ldquo;first dimension fastest&amp;rdquo;) support for 2D, 3D and 4D arrays.</source>
          <target state="translated">C順序付け（「最後の次元が最も速い」）またはFortran順序付け（「最初の次元が最も速い」）は、2D、3D、4D配列をサポートしています。</target>
        </trans-unit>
        <trans-unit id="3720a76c9cc3b6258ee484172d090cd5b19b7e16" translate="yes" xml:space="preserve">
          <source>Both CTypes and CFFI allow the more complicated distributions to be used directly in Numba after compiling the file distributions.c into a &lt;code&gt;DLL&lt;/code&gt; or &lt;code&gt;so&lt;/code&gt;. An example showing the use of a more complicated distribution is in the &lt;code&gt;examples&lt;/code&gt; section below.</source>
          <target state="translated">CTypesとCFFIはどちらも、ファイルdistributions.cを &lt;code&gt;DLL&lt;/code&gt; などにコンパイルした後、より複雑なディストリビューションをNumbaで直接使用できる &lt;code&gt;so&lt;/code&gt; ます。より複雑なディストリビューションの使用を示す &lt;code&gt;examples&lt;/code&gt; は、以下の例のセクションにあります。</target>
        </trans-unit>
        <trans-unit id="6876b038e6598420047feff6385d214f7a9456e4" translate="yes" xml:space="preserve">
          <source>Both CTypes and CFFI allow the more complicated distributions to be used directly in Numba after compiling the file distributions.c into a DLL or so. An example showing the use of a more complicated distribution is in the examples folder.</source>
          <target state="translated">CTypes と CFFI の両方を使用すると、distribution.c ファイルを DLL などにコンパイルした後に、より複雑なディストリビューションを Numba で直接使用することができます。より複雑なディストリビューションの使用例は、examplesフォルダにあります。</target>
        </trans-unit>
        <trans-unit id="9b2e6b498660f219d33da75fb672071ec22d0de1" translate="yes" xml:space="preserve">
          <source>Both arguments must be convertible to data-type objects with the same total size.</source>
          <target state="translated">両方の引数は、同じ合計サイズのデータ型オブジェクトに変換可能でなければなりません。</target>
        </trans-unit>
        <trans-unit id="25024cfe43b48611add0d26f273e9fb8f30c82d0" translate="yes" xml:space="preserve">
          <source>Both for indexing:</source>
          <target state="translated">どちらもインデックス用。</target>
        </trans-unit>
        <trans-unit id="9c58adbe49cf294225a6b4d010fdfff04815b05a" translate="yes" xml:space="preserve">
          <source>Both of these routines multiply an &lt;em&gt;n&lt;/em&gt; -length array, &lt;em&gt;seq&lt;/em&gt;, of integers and return the result. No overflow checking is performed.</source>
          <target state="translated">これらのルーチンは両方とも、整数の&lt;em&gt;n&lt;/em&gt;長の配列&lt;em&gt;seqを&lt;/em&gt;乗算し、結果を返します。オーバーフローチェックは実行されません。</target>
        </trans-unit>
        <trans-unit id="e7d4dd33376799dad2f66b13833f7382c04f91d5" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;names&lt;/code&gt; and &lt;code&gt;fields&lt;/code&gt; attributes will equal &lt;code&gt;None&lt;/code&gt; for unstructured arrays. The recommended way to test if a dtype is structured is with &lt;code&gt;if dt.names is not None&lt;/code&gt; rather than &lt;code&gt;if dt.names&lt;/code&gt;, to account for dtypes with 0 fields.</source>
          <target state="translated">非構造化配列の場合、 &lt;code&gt;names&lt;/code&gt; 属性と &lt;code&gt;fields&lt;/code&gt; 属性の両方が &lt;code&gt;None&lt;/code&gt; に等しくなります。dtypeが構造化されているかどうかをテストするための推奨される方法は、フィールドが0のdtypeを説明するために、 &lt;code&gt;if dt.names&lt;/code&gt; ではなく &lt;code&gt;if dt.names is not None&lt;/code&gt; でない場合です。</target>
        </trans-unit>
        <trans-unit id="6a9d7b7663daf24925c25758270cb4610491dfdf" translate="yes" xml:space="preserve">
          <source>Both the C and Fortran orders are &lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-contiguous&quot;&gt;contiguous&lt;/a&gt;, &lt;em&gt;i.e.,&lt;/em&gt; single-segment, memory layouts, in which every part of the memory block can be accessed by some combination of the indices.</source>
          <target state="translated">CとFortranの両方の順序は&lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-contiguous&quot;&gt;連続しています&lt;/a&gt;。&lt;em&gt;つまり、&lt;/em&gt;単一セグメントのメモリレイアウトで、インデックスのいくつかの組み合わせでメモリブロックのすべての部分にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="d093ba37f9ce9c9f30f8fca73c109507dfcb0225" translate="yes" xml:space="preserve">
          <source>Both the Frobenius and nuclear norm orders are only defined for matrices and raise a ValueError when &lt;code&gt;x.ndim != 2&lt;/code&gt;.</source>
          <target state="translated">フロベニウスと核ノルムの両方の次数は行列に対してのみ定義され、 &lt;code&gt;x.ndim != 2&lt;/code&gt; 場合にValueErrorを発生させます。</target>
        </trans-unit>
        <trans-unit id="ffea5bc12b4c544392f03bcbcae76a932ec7e9d3" translate="yes" xml:space="preserve">
          <source>Both vectors with dimension 2.</source>
          <target state="translated">両方とも次元2のベクトルです。</target>
        </trans-unit>
        <trans-unit id="ee63b82109d9ff030ecbe37ab04ceac7db2412e8" translate="yes" xml:space="preserve">
          <source>Breaking long lines: if you can, break after commas in the outermost argument list. Always indent continuation lines appropriately, e.g.,</source>
          <target state="translated">長い行の改行:できれば、一番外側の引数リストのカンマの後で改行してください。継続行は常に適切にインデントしてください。</target>
        </trans-unit>
        <trans-unit id="bd6b304289af9581af2ffeee2445279337f31f30" translate="yes" xml:space="preserve">
          <source>Brighton Webs Ltd., &amp;ldquo;Rayleigh Distribution,&amp;rdquo; &lt;a href=&quot;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&quot;&gt;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&lt;/a&gt;</source>
          <target state="translated">Brighton Webs Ltd。、「Rayleigh Distribution」、&lt;a href=&quot;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&quot;&gt;https：//web.archive.org/web/20090514091424/http：//brighton-webs.co.uk：&lt;/a&gt; 80 / distributions / rayleigh.asp</target>
        </trans-unit>
        <trans-unit id="f95280aadb50a5d76ebefb36fbe813c4a9ec99eb" translate="yes" xml:space="preserve">
          <source>Brighton Webs Ltd., Wald Distribution, &lt;a href=&quot;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&quot;&gt;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&lt;/a&gt;</source>
          <target state="translated">Brighton Webs Ltd.、Wald Distribution、&lt;a href=&quot;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&quot;&gt;https：//web.archive.org/web/20090423014010/http：//www.brighton-webs.co.uk：&lt;/a&gt; 80 / distributions / wald.asp</target>
        </trans-unit>
        <trans-unit id="8d469ff5df319fd73b1f4431adc89a3cb7f9bc26" translate="yes" xml:space="preserve">
          <source>Broadcast an array to a new shape</source>
          <target state="translated">配列を新しい形状にブロードキャストする</target>
        </trans-unit>
        <trans-unit id="73facd5bb35116bed91fa4d11828ee34122a7818" translate="yes" xml:space="preserve">
          <source>Broadcast an array to a new shape.</source>
          <target state="translated">配列を新しい形状にブロードキャストします。</target>
        </trans-unit>
        <trans-unit id="335cb5d296e07dc61fd4677d50111abd1712ceae" translate="yes" xml:space="preserve">
          <source>Broadcast any number of arrays against each other.</source>
          <target state="translated">任意の数の配列を互いにブロードキャストします。</target>
        </trans-unit>
        <trans-unit id="98d4c99349e07c3606d8247f67b6a69bf991b037" translate="yes" xml:space="preserve">
          <source>Broadcast the input parameters against one another, and return an object that encapsulates the result. Amongst others, it has &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;nd&lt;/code&gt; properties, and may be used as an iterator.</source>
          <target state="translated">入力パラメータを相互にブロードキャストし、結果をカプセル化するオブジェクトを返します。とりわけ、それは &lt;code&gt;shape&lt;/code&gt; と &lt;code&gt;nd&lt;/code&gt; プロパティを持ち、反復子として使用できます。</target>
        </trans-unit>
        <trans-unit id="ba459229366746c447e3cdf752eb917433152cfe" translate="yes" xml:space="preserve">
          <source>Broadcasting</source>
          <target state="translated">Broadcasting</target>
        </trans-unit>
        <trans-unit id="2d4bd5e0675f1aedc285134fe7e6bea24d68a36e" translate="yes" xml:space="preserve">
          <source>Broadcasting (multi-iterators)</source>
          <target state="translated">放送(マルチイテレータ</target>
        </trans-unit>
        <trans-unit id="5e308728b0383411510cb3c77af8cc43a178e5fc" translate="yes" xml:space="preserve">
          <source>Broadcasting Array Iteration</source>
          <target state="translated">放送配列反復</target>
        </trans-unit>
        <trans-unit id="ffca602e6975476928a035e0bd899a364b765bab" translate="yes" xml:space="preserve">
          <source>Broadcasting allows universal functions to deal in a meaningful way with inputs that do not have exactly the same shape.</source>
          <target state="translated">放送では、全く同じ形をしていない入力に対して、普遍的な機能で有意義に対処することができます。</target>
        </trans-unit>
        <trans-unit id="3f1a8f806c9ec4c20408d10522361491e36b1938" translate="yes" xml:space="preserve">
          <source>Broadcasting and scalar multiplication:</source>
          <target state="translated">放送とスカラー乗算。</target>
        </trans-unit>
        <trans-unit id="9c4c6b372f00f9bbc9735f2491e20986adab213c" translate="yes" xml:space="preserve">
          <source>Broadcasting comes up quite often in real world problems. A typical example occurs in the vector quantization (VQ) algorithm used in information theory, classification, and other related areas. The basic operation in VQ [#f0] finds the closest point in a set of points, called codes in VQ jargon, to a given point, called the observation. In the very simple, two-dimensional case shown in &lt;a href=&quot;#figure-5&quot;&gt;Figure 5&lt;/a&gt;, the values in observation describe the weight and height of an athlete to be classified. The codes represent different classes of athletes. &lt;a href=&quot;#f1&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; Finding the closest point requires calculating the distance between observation and each of the codes. The shortest distance provides the best match. In this example, &lt;code&gt;codes[0]&lt;/code&gt; is the closest class indicating that the athlete is likely a basketball player.</source>
          <target state="translated">放送は、現実の問題で頻繁に発生します。典型的な例は、情報理論、分類、およびその他の関連分野で使用されるベクトル量子化（VQ）アルゴリズムで発生します。 VQ [＃f0]の基本的な操作では、VQ用語でコードと呼ばれる一連のポイントから、観測と呼ばれる特定のポイントに最も近いポイントを見つけます。&lt;a href=&quot;#figure-5&quot;&gt;図5&lt;/a&gt;に示す非常に単純な2次元の場合、観察値は、分類されるアスリートの体重と身長を表します。コードは、さまざまなクラスのアスリートを表しています。&lt;a href=&quot;#f1&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt;最も近い点を見つけるには、観測と各コードの間の距離を計算する必要があります。最短距離が最適です。この例では、 &lt;code&gt;codes[0]&lt;/code&gt; は、アスリートがバスケットボール選手である可能性が高いことを示す最も近いクラスです。</target>
        </trans-unit>
        <trans-unit id="3086582d38372be76fcd6867986780678b3bdbd6" translate="yes" xml:space="preserve">
          <source>Broadcasting is conventional for stacks of arrays</source>
          <target state="translated">アレイのスタックでは、従来から放送が行われています。</target>
        </trans-unit>
        <trans-unit id="60a524b775e11155b5c4df4747f272a28d6e6176" translate="yes" xml:space="preserve">
          <source>Broadcasting is the term used to describe the implicit element-by-element behavior of operations; generally speaking, in NumPy all operations, not just arithmetic operations, but logical, bit-wise, functional, etc., behave in this implicit element-by-element fashion, i.e., they broadcast. Moreover, in the example above, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; could be multidimensional arrays of the same shape, or a scalar and an array, or even two arrays of with different shapes, provided that the smaller array is &amp;ldquo;expandable&amp;rdquo; to the shape of the larger in such a way that the resulting broadcast is unambiguous. For detailed &amp;ldquo;rules&amp;rdquo; of broadcasting see &lt;a href=&quot;basics.broadcasting#module-numpy.doc.broadcasting&quot;&gt;&lt;code&gt;numpy.doc.broadcasting&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ブロードキャストは、操作の暗黙的な要素ごとの動作を説明するために使用される用語です。一般的に言えば、NumPyでは、算術演算だけでなく、論理演算、ビット演算、関数演算などのすべての演算が、この暗黙的な要素ごとの方法で動作します。つまり、ブロードキャストします。さらに、上記の例で &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; とbは同じ形状の多次元配列、スカラーと配列、または異なる形状の2つの配列である可能性があります。ただし、小さい方の配列が大きい方の形状に「拡張可能」である必要があります。結果として得られるブロードキャストが明確になるような方法で。ブロードキャストの詳細な「ルール」については、&lt;a href=&quot;basics.broadcasting#module-numpy.doc.broadcasting&quot;&gt; &lt;code&gt;numpy.doc.broadcasting&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c8a22fa6f76158c02a615ce1e41377e5e327d96b" translate="yes" xml:space="preserve">
          <source>Broadcasting is used throughout NumPy to decide how to handle disparately shaped arrays; for example, all arithmetic operations (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &amp;hellip;) between &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt; broadcast the arrays before operation.</source>
          <target state="translated">ブロードキャストはNumPy全体で使用され、異なる形状の配列の処理方法を決定します。たとえば、&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt;間のすべての算術演算（ &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;-&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、&amp;hellip;）は、演算の前に配列をブロードキャストします。</target>
        </trans-unit>
        <trans-unit id="c2ccb1ef65055f853bfad815cb4304fa00148706" translate="yes" xml:space="preserve">
          <source>Broadcasting over multiple arrays</source>
          <target state="translated">複数のアレイでの放送</target>
        </trans-unit>
        <trans-unit id="8643e22fd07e0fa1b2c6f3538e1689c01bced1a3" translate="yes" xml:space="preserve">
          <source>Broadcasting provides a convenient way of taking the outer product (or any other outer operation) of two arrays. The following example shows an outer addition operation of two 1-d arrays that produces the same result as &lt;a href=&quot;#example-3&quot;&gt;Example 3&lt;/a&gt;</source>
          <target state="translated">ブロードキャストは、2つの配列の外積（またはその他の外積）を取得する便利な方法を提供します。次の例は、&lt;a href=&quot;#example-3&quot;&gt;例3&lt;/a&gt;と同じ結果を生成する2つの1次元配列の外部加算操作を示しています。</target>
        </trans-unit>
        <trans-unit id="f086db6f9cde283cd15667e2a34db081fa8323d1" translate="yes" xml:space="preserve">
          <source>Broadcasting provides a convenient way of taking the outer product (or any other outer operation) of two arrays. The following example shows an outer addition operation of two 1-d arrays:</source>
          <target state="translated">放送は、2つの配列の外積(または他の任意の外積演算)を取る便利な方法を提供します。次の例は、2つの1次元配列の外部加算演算を示しています。</target>
        </trans-unit>
        <trans-unit id="916a860416eab96b40dda7fe2424a559b1d3ae5f" translate="yes" xml:space="preserve">
          <source>Broadcasting rules</source>
          <target state="translated">放送ルール</target>
        </trans-unit>
        <trans-unit id="d8a2b5b45365993f46ca0dedffba4cb7be1f878c" translate="yes" xml:space="preserve">
          <source>Broadcasting rules apply, see the &lt;a href=&quot;../routines.linalg#module-numpy.linalg&quot;&gt;&lt;code&gt;numpy.linalg&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">ブロードキャストルールが適用されます。詳しくは、&lt;a href=&quot;../routines.linalg#module-numpy.linalg&quot;&gt; &lt;code&gt;numpy.linalg&lt;/code&gt; の&lt;/a&gt;ドキュメントをご覧ください。</target>
        </trans-unit>
        <trans-unit id="d885a1b2d5577844b42f9c37b9817de5d134c079" translate="yes" xml:space="preserve">
          <source>Broadcasting was always implemented in Numeric using 0-valued strides for the extended dimensions. It is done in exactly the same way in NumPy. The big difference is that now the array of strides is kept track of in a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;, the iterators involved in a broadcast result are kept track of in a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt;, and the &lt;code&gt;PyArray_BroadCast&lt;/code&gt; call implements the broad-casting rules.</source>
          <target state="translated">放送は常に拡張ディメンションに0値のストライドを使用して数値で実装されました。NumPyでもまったく同じ方法で行われます。大きな違いは、中の今一歩の配列が保たれているトラックということです&lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; は&lt;/a&gt;、放送結果に関与イテレータは、中のトラックを保持している&lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt;、および &lt;code&gt;PyArray_BroadCast&lt;/code&gt; のコールを実装幅広いキャストルール。</target>
        </trans-unit>
        <trans-unit id="2a0a6879b6872d1f7b106e1d3c8e15aa2bd9c9f9" translate="yes" xml:space="preserve">
          <source>Broadcasting was always implemented in Numeric using 0-valued strides for the extended dimensions. It is done in exactly the same way in NumPy. The big difference is that now the array of strides is kept track of in a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;, the iterators involved in a broadcast result are kept track of in a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt;, and the &lt;code&gt;PyArray_BroadCast&lt;/code&gt; call implements the broad-casting rules.</source>
          <target state="translated">ブロードキャストは常に、拡張ディメンションに0値のストライドを使用して数値で実装されていました。これは、NumPyでもまったく同じ方法で行われます。大きな違いは、中の今一歩の配列が保たれているトラックということです&lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; は&lt;/a&gt;、放送結果に関与イテレータは、中のトラックを保持している&lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt;、および &lt;code&gt;PyArray_BroadCast&lt;/code&gt; のコールを実装幅広いキャストルール。</target>
        </trans-unit>
        <trans-unit id="6cc8d02b192349a4f1b4b7f860e5e3a1c421ecb8" translate="yes" xml:space="preserve">
          <source>Broadcasting, element-wise and scalar multiplication, &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;numpy.multiply&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ブロードキャスト、要素ごとのスカラー乗算、&lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt; &lt;code&gt;numpy.multiply&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90812c9e094ac5522eea3d57aa754d6964a1cdf2" translate="yes" xml:space="preserve">
          <source>Buffer (&lt;code&gt;buf&lt;/code&gt;) is interpreted according to these strides (strides define how many bytes each array element, row, column, etc. occupy in memory).</source>
          <target state="translated">バッファ（ &lt;code&gt;buf&lt;/code&gt; ）は、これらのストライドに従って解釈されます（ストライドは、各配列要素、行、列などがメモリで占有するバイト数を定義します）。</target>
        </trans-unit>
        <trans-unit id="3a3c6f456f2df72c3dcf8bdef2f2f225bc537cc1" translate="yes" xml:space="preserve">
          <source>Buffer of binary data</source>
          <target state="translated">バイナリデータのバッファ</target>
        </trans-unit>
        <trans-unit id="27cb2ff0185bcfdbaec6ac70d0f611c9c03b02a8" translate="yes" xml:space="preserve">
          <source>Buffered Loop</source>
          <target state="translated">バッファードループ</target>
        </trans-unit>
        <trans-unit id="3aa9875f6199e297bab60e3e7102191f0ce73af1" translate="yes" xml:space="preserve">
          <source>Buffered iterator for big arrays.</source>
          <target state="translated">大きな配列のためのバッファ付きイテレータ.</target>
        </trans-unit>
        <trans-unit id="6d37057306b02ade5a2d41571a0c0e632337fc5c" translate="yes" xml:space="preserve">
          <source>Buffering mode mitigates the memory usage issue and is more cache-friendly than making temporary copies. Except for special cases, where the whole array is needed at once outside the iterator, buffering is recommended over temporary copying. Within NumPy, buffering is used by the ufuncs and other functions to support flexible inputs with minimal memory overhead.</source>
          <target state="translated">バッファリングモードはメモリ使用量の問題を軽減し、一時的なコピーよりもキャッシュに優しいです。イテレータの外側で配列全体を一度に必要とするような特別な場合を除き,一時的なコピーよりもバッファリングが推奨されます.NumPyの中では,バッファリングはufuncsや他の関数によって使用され,最小限のメモリオーバーヘッドで柔軟な入力をサポートします.</target>
        </trans-unit>
        <trans-unit id="aff21481cc1c0abc2cbd1fe3d4ce255d0403752e" translate="yes" xml:space="preserve">
          <source>Buffering the Array Elements</source>
          <target state="translated">配列要素のバッファリング</target>
        </trans-unit>
        <trans-unit id="e0ea19fac7306381f9369bebfc56bf181ad2f644" translate="yes" xml:space="preserve">
          <source>Bugs Fixed</source>
          <target state="translated">修正されたバグ</target>
        </trans-unit>
        <trans-unit id="ac95995878b77d2a8ce4a1c4b232969f85fc5862" translate="yes" xml:space="preserve">
          <source>Build System Changes</source>
          <target state="translated">ビルドシステムの変更</target>
        </trans-unit>
        <trans-unit id="041e1aac6c7d1e7294bc5d8fa3967aabcde7a325" translate="yes" xml:space="preserve">
          <source>Build a matrix object from a string, nested sequence, or array.</source>
          <target state="translated">文字列,入れ子になったシーケンス,配列から行列オブジェクトを作成します.</target>
        </trans-unit>
        <trans-unit id="62d0591005ae8571425b97ff29068016515cd29b" translate="yes" xml:space="preserve">
          <source>Build and archive documentation</source>
          <target state="translated">ドキュメントの構築とアーカイブ</target>
        </trans-unit>
        <trans-unit id="7fcd3a3a0bc7c1a4ce328d262f632a0650b70528" translate="yes" xml:space="preserve">
          <source>Build extension module from a Fortran 77 source string with f2py.</source>
          <target state="translated">f2pyでFortran77のソース文字列から拡張モジュールをビルドします。</target>
        </trans-unit>
        <trans-unit id="1d349060ba731253879161224c46e4521b75c084" translate="yes" xml:space="preserve">
          <source>Build options can be discovered by running any of:</source>
          <target state="translated">ビルドオプションは、いずれかを実行することで発見することができます。</target>
        </trans-unit>
        <trans-unit id="7b1b626e82829b0dfeb4bfac3a16b7d5bcd6a8fc" translate="yes" xml:space="preserve">
          <source>Build source releases</source>
          <target state="translated">ビルドソースリリース</target>
        </trans-unit>
        <trans-unit id="6e79e48e57f84dbe7fa157bde2a3fead704bb75d" translate="yes" xml:space="preserve">
          <source>Build system</source>
          <target state="translated">ビルドシステム</target>
        </trans-unit>
        <trans-unit id="ea4c8827fa3eb397f1363449f23094e9e120bb77" translate="yes" xml:space="preserve">
          <source>Build the changelog and notes for upload with:</source>
          <target state="translated">でアップロードするための変更履歴とノートを作成します。</target>
        </trans-unit>
        <trans-unit id="133bc31192cbeea22da4122bb90ba0a93a894d67" translate="yes" xml:space="preserve">
          <source>Build wheels</source>
          <target state="translated">ビルドホイール</target>
        </trans-unit>
        <trans-unit id="d0fa723cff6db05fe0f943d3ba65530fea4a58d8" translate="yes" xml:space="preserve">
          <source>Building Installable C libraries</source>
          <target state="translated">インストール可能な C ライブラリの構築</target>
        </trans-unit>
        <trans-unit id="fc68ddc861d1de39d367519f523580fe22e0de8b" translate="yes" xml:space="preserve">
          <source>Building NumPy requires the following software installed:</source>
          <target state="translated">NumPyの構築には、以下のソフトウェアのインストールが必要です。</target>
        </trans-unit>
        <trans-unit id="f7247d0ef96399c8a6f6f94bdfcbbd262feaf108" translate="yes" xml:space="preserve">
          <source>Building NumPy with a Python built with debug support (on Linux distributions typically packaged as &lt;code&gt;python-dbg&lt;/code&gt;) is highly recommended.</source>
          <target state="translated">デバッグサポート付きでビルドされたPythonを使用してNumPyをビルドすることを強くお勧めします（Linuxディストリビューションでは通常 &lt;code&gt;python-dbg&lt;/code&gt; としてパッケージ化されています）。</target>
        </trans-unit>
        <trans-unit id="e3ab4efd8b4a10d38ed8959a1cb29fc9881db378" translate="yes" xml:space="preserve">
          <source>Building against OpenBLAS</source>
          <target state="translated">OpenBLASに対抗したビルド</target>
        </trans-unit>
        <trans-unit id="f1cd4f14fd9faeca78fccf35fd005e67e4d55852" translate="yes" xml:space="preserve">
          <source>Building and Extending the Documentation</source>
          <target state="translated">ドキュメントの構築と拡張</target>
        </trans-unit>
        <trans-unit id="ea6e2e9b251f8b11fe3d952437e66c0d7503db76" translate="yes" xml:space="preserve">
          <source>Building docs</source>
          <target state="translated">ドキュメントの構築</target>
        </trans-unit>
        <trans-unit id="8cd56ee99256f6026c82a35e18d75551094d8936" translate="yes" xml:space="preserve">
          <source>Building from source</source>
          <target state="translated">ソースからの構築</target>
        </trans-unit>
        <trans-unit id="797c000e127fd646fe95625f81ea1c57543896ff" translate="yes" xml:space="preserve">
          <source>Building in-place</source>
          <target state="translated">インプレイスの構築</target>
        </trans-unit>
        <trans-unit id="e1f8c7d7fa78c6eb31ad5ca785a393676894e731" translate="yes" xml:space="preserve">
          <source>Building matrices</source>
          <target state="translated">行列の構築</target>
        </trans-unit>
        <trans-unit id="d1d8b51984115777766e2f069b697c4bb754479c" translate="yes" xml:space="preserve">
          <source>Building source archives and wheels</source>
          <target state="translated">ソースアーカイブとホイールの構築</target>
        </trans-unit>
        <trans-unit id="1cc054390cfe90161261914ab7d65d3cfee4150a" translate="yes" xml:space="preserve">
          <source>Building the NumPy API and reference docs</source>
          <target state="translated">NumPy APIとリファレンスドキュメントの構築</target>
        </trans-unit>
        <trans-unit id="2b0584a2ddbe43766e4479e6f854126bbc0cb8a1" translate="yes" xml:space="preserve">
          <source>Building the documents requires a number of latex &lt;code&gt;.sty&lt;/code&gt; files. Install them all to avoid aggravation.</source>
          <target state="translated">ドキュメントを作成するには、多数のラテックス &lt;code&gt;.sty&lt;/code&gt; ファイルが必要です。悪化を避けるためにそれらをすべて取り付けてください。</target>
        </trans-unit>
        <trans-unit id="2afe730004d87377bea3908e9c6c7255bf4ce79e" translate="yes" xml:space="preserve">
          <source>Building the extension module can be now carried out in one command:</source>
          <target state="translated">拡張モジュールのビルドが1つのコマンドで行えるようになりました。</target>
        </trans-unit>
        <trans-unit id="fe2db8e7c7c6c32ba1fc4b4a6634f60ac081da44" translate="yes" xml:space="preserve">
          <source>Builds a set of strides which are the same as the strides of an output array created using the &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt;&lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt;&lt;/a&gt; flag, where NULL was passed for op_axes. This is for data packed contiguously, but not necessarily in C or Fortran order. This should be used together with &lt;a href=&quot;#c.NpyIter_GetShape&quot;&gt;&lt;code&gt;NpyIter_GetShape&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NpyIter_GetNDim&quot;&gt;&lt;code&gt;NpyIter_GetNDim&lt;/code&gt;&lt;/a&gt; with the flag &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt; passed into the constructor.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt; &lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt; &lt;/a&gt;にNULLが渡された、NPY_ITER_ALLOCATEフラグを使用して作成された出力配列のストライドと同じストライドのセットを作成します。これは、連続してパックされたデータ用ですが、必ずしもCまたはFortranの順序でパックされているわけではありません。これは、フラグ&lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; をコンストラクターに&lt;/a&gt;渡して、&lt;a href=&quot;#c.NpyIter_GetShape&quot;&gt; &lt;code&gt;NpyIter_GetShape&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#c.NpyIter_GetNDim&quot;&gt; &lt;code&gt;NpyIter_GetNDim&lt;/code&gt; &lt;/a&gt;と一緒に使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="8b40e55c8fd12c110479c1a8e453add933b9c6e8" translate="yes" xml:space="preserve">
          <source>Built-in Python types</source>
          <target state="translated">Python の組み込み型</target>
        </trans-unit>
        <trans-unit id="b858e075ef402953578da270159a51f6ad1575b6" translate="yes" xml:space="preserve">
          <source>Built-in scalar types</source>
          <target state="translated">組み込みのスカラ型</target>
        </trans-unit>
        <trans-unit id="4a2892e18069d1f5869c7225c38ebadc7aa96d21" translate="yes" xml:space="preserve">
          <source>Bundled version of LAPACK is now 3.2.2</source>
          <target state="translated">LAPACKのバンドル版が3.2.2になりました。</target>
        </trans-unit>
        <trans-unit id="f0300972b4a8f0b0074aec4f6903cf3e57d597c8" translate="yes" xml:space="preserve">
          <source>Business Day Functionality</source>
          <target state="translated">営業日機能</target>
        </trans-unit>
        <trans-unit id="3cbeeffaaa46e0b3d6b0ea56538a20f899791f42" translate="yes" xml:space="preserve">
          <source>Business Day Functions</source>
          <target state="translated">営業日の機能</target>
        </trans-unit>
        <trans-unit id="a4da80602eb90228591a52fa43450b5af3478d27" translate="yes" xml:space="preserve">
          <source>But different types can be used for substitution. In fact, this is how conversion of Polynomial classes among themselves is done for type, domain, and window casting:</source>
          <target state="translated">しかし、異なる型は置換のために使用することができます。実際には、多項式クラス同士の変換は、このようにして型、ドメイン、ウィンドウキャストのために行われます。</target>
        </trans-unit>
        <trans-unit id="bd8c2ef60d42745d2cdc473c152c1f9687c4dcc2" translate="yes" xml:space="preserve">
          <source>But if &lt;code&gt;rowsum&lt;/code&gt; would have two dimensions as well:</source>
          <target state="translated">ただし、 &lt;code&gt;rowsum&lt;/code&gt; にも2つの次元がある場合：</target>
        </trans-unit>
        <trans-unit id="b4df18df25d280603f202e60c13a7a8f66254798" translate="yes" xml:space="preserve">
          <source>But is also allowed to produce, for some &lt;code&gt;a, b, c, d&lt;/code&gt;:</source>
          <target state="translated">ただし、一部の &lt;code&gt;a, b, c, d&lt;/code&gt; についても生成できます。</target>
        </trans-unit>
        <trans-unit id="6646b6ecbc06bc26898d3bc8dfd20372b9b785ad" translate="yes" xml:space="preserve">
          <source>But that&amp;rsquo;s not the only way to look at it. Suppose one has large two-dimensional arrays (images or matrices) stored in data files. Suppose the data are stored by rows rather than by columns. If we are to preserve our index convention (whether matrix or image) that means that depending on the language we use, we may be forced to reorder the data if it is read into memory to preserve our indexing convention. For example if we read row-ordered data into memory without reordering, it will match the matrix indexing convention for C, but not for Fortran. Conversely, it will match the image indexing convention for Fortran, but not for C. For C, if one is using data stored in row order, and one wants to preserve the image index convention, the data must be reordered when reading into memory.</source>
          <target state="translated">しかし、それはそれを見る唯一の方法ではありません。大きな2次元配列（画像または行列）がデータファイルに格納されているとします。データが列ではなく行で格納されているとします。インデックスの規則（行列または画像）を保持する場合、使用する言語によっては、データをメモリに読み込んでインデックスの規則を保持すると、データの順序を変更しなければならない場合があります。たとえば、行順データを並べ替えずにメモリに読み込んだ場合、Cの行列のインデックス付け規則と一致しますが、Fortranとは一致しません。逆に、それはFortranのイメージインデックス規則と一致しますが、Cとは一致しません。Cの場合、行順に格納されたデータを使用していて、イメージインデックス規則を保持したい場合は、メモリに読み込むときにデータを並べ替える必要があります。</target>
        </trans-unit>
        <trans-unit id="6e0bd4df436692919faeb191ed09cf810cb22035" translate="yes" xml:space="preserve">
          <source>But there are cross-platform considerations, such as library file extensions, plus the fact Windows will just load the first library it finds with that name. NumPy supplies the load_library function as a convenience.</source>
          <target state="translated">しかし、ライブラリファイルの拡張子や、Windowsはその名前で最初に見つかったライブラリを読み込むだけという事実など、クロスプラットフォームでの配慮があります。NumPy は便利なように load_library 関数を提供しています。</target>
        </trans-unit>
        <trans-unit id="ec781290ccbee49bdd7da500afd06d4ca2f948bf" translate="yes" xml:space="preserve">
          <source>But this omits some subtleties. Here is a fully general summary:</source>
          <target state="translated">しかし、これはいくつかの微妙な点を省略しています。ここでは、完全に大まかな概要を説明します。</target>
        </trans-unit>
        <trans-unit id="9d33835f4b0ffd7a417785ade1f5f4a66909b7f6" translate="yes" xml:space="preserve">
          <source>But we can also specify the axis over which to multiply:</source>
          <target state="translated">しかし、乗算する軸を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="9f79d5f66a9deb8e0798847bf7ab428de8db1e5a" translate="yes" xml:space="preserve">
          <source>But when you use &lt;code&gt;ravel&lt;/code&gt;, the changes you make to the new array will affect the parent array.</source>
          <target state="translated">ただし、 &lt;code&gt;ravel&lt;/code&gt; を使用する場合、新しい配列に加えた変更は親配列に影響します。</target>
        </trans-unit>
        <trans-unit id="7460c60c1fec76b65a3c31a575c95674fb86e283" translate="yes" xml:space="preserve">
          <source>But, we could do anything we wanted:</source>
          <target state="translated">でも、やりたいことは何でもできました。</target>
        </trans-unit>
        <trans-unit id="e13f0fd9c0e50a5064cf51cb50663812feb86a8e" translate="yes" xml:space="preserve">
          <source>Buzas, Martin A.; Culver, Stephen J., Understanding regional species diversity through the log series distribution of occurrences: BIODIVERSITY RESEARCH Diversity &amp;amp; Distributions, Volume 5, Number 5, September 1999 , pp. 187-195(9).</source>
          <target state="translated">ブザス、マーティンA .; カルバー、スティーブンJ.、発生の対数系列分布による地域種の多様性の理解：生物多様性研究多様性と分布、第5巻、第5号、1999年9月、187-195頁（9）。</target>
        </trans-unit>
        <trans-unit id="66360bf7fbf8657df2c1591ab899dd54476a182c" translate="yes" xml:space="preserve">
          <source>By choosing an offset of 8 bytes we can select the complex part of the array for our view:</source>
          <target state="translated">8 バイトのオフセットを選択することで、配列の複雑な部分を選択して表示することができます。</target>
        </trans-unit>
        <trans-unit id="c96bbfd74d3086f0a931f577a61fdefbdd812bbe" translate="yes" xml:space="preserve">
          <source>By constructing a new ndarray of your desired shape and type using &lt;a href=&quot;../reference/c-api/array#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; or a simpler macro or function based on it.</source>
          <target state="translated">&lt;a href=&quot;../reference/c-api/array#c.PyArray_NewFromDescr&quot;&gt; &lt;code&gt;PyArray_NewFromDescr&lt;/code&gt; &lt;/a&gt;またはそれに基づくより単純なマクロまたは関数を使用して、目的の形状とタイプの新しいndarrayを作成します。</target>
        </trans-unit>
        <trans-unit id="6503cfb311994e99b18c321cb4370162b665063d" translate="yes" xml:space="preserve">
          <source>By convention, the negative sign represents cash flow out (i.e. money not available today). Thus, saving $100 a month at 5% annual interest leads to $15,692.93 available to spend in 10 years.</source>
          <target state="translated">慣例では、負の符号はキャッシュ・フロー・アウト(つまり今日使えないお金)を表しています。したがって、5%の年利で月100ドルを節約すると、10年後に使用可能な15,692.93ドルになります。</target>
        </trans-unit>
        <trans-unit id="7f5fbe94c54051531f7d898251f9826df16e5720" translate="yes" xml:space="preserve">
          <source>By convention, the negative sign represents cash flow out (i.e., money not available today). Thus, to end up with $15,692.93 in 10 years saving $100 a month at 5% annual interest, one&amp;rsquo;s initial deposit should also be $100.</source>
          <target state="translated">慣例により、負の符号はキャッシュフロー（つまり、現在利用できないお金）を表します。したがって、10年間で$ 15,692.93になり、年利5％で月額$ 100を節約するには、初回預金も$ 100にする必要があります。</target>
        </trans-unit>
        <trans-unit id="e8f9209679e0d480aec7fb981fefcc0f2b86d6ab" translate="yes" xml:space="preserve">
          <source>By converting it from some Python object using &lt;a href=&quot;../reference/c-api/array#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; or a macro built on it.</source>
          <target state="translated">&lt;a href=&quot;../reference/c-api/array#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;またはその上に構築されたマクロを使用してPythonオブジェクトから変換する。</target>
        </trans-unit>
        <trans-unit id="2387467eae05dde35d2654a3dbfc0d30bc85b00f" translate="yes" xml:space="preserve">
          <source>By default (&lt;code&gt;align=False&lt;/code&gt;), numpy will pack the fields together such that each field starts at the byte offset the previous field ended, and the fields are contiguous in memory.</source>
          <target state="translated">デフォルト（ &lt;code&gt;align=False&lt;/code&gt; ）では、numpyはフィールドをまとめてパックし、各フィールドは前のフィールドが終了したバイトオフセットで開始し、フィールドはメモリ内で連続します。</target>
        </trans-unit>
        <trans-unit id="52bf606add02bda44e68afd9558117218dd1b2cb" translate="yes" xml:space="preserve">
          <source>By default &lt;a href=&quot;#numpy.testing.rundocs&quot;&gt;&lt;code&gt;rundocs&lt;/code&gt;&lt;/a&gt; raises an AssertionError on failure.</source>
          <target state="translated">デフォルトでは、&lt;a href=&quot;#numpy.testing.rundocs&quot;&gt; &lt;code&gt;rundocs&lt;/code&gt; &lt;/a&gt;は失敗時にAssertionErrorを発生させます。</target>
        </trans-unit>
        <trans-unit id="0791e549c9e1c0c68c18f4046427ddfd65fee6cf" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; uses bits provided by &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; which has better statistical properties than the legacy mt19937 random number generator in &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">デフォルトでは、&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;によって提供されるビット使用&lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;におけるレガシーMT19937乱数発生器よりも良好な統計的性質を有する&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2eb2435c3e98faf455297cd059d456431f056aed" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;float16&lt;/code&gt; results are computed using &lt;code&gt;float32&lt;/code&gt; intermediates for extra precision.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;float16&lt;/code&gt; の結果は、精度を &lt;code&gt;float32&lt;/code&gt; ためにfloat32中間体を使用して計算されます。</target>
        </trans-unit>
        <trans-unit id="f255d5e8f1a7ce5480c00642bd965d8cbd147605" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;skip_header=0&lt;/code&gt; and &lt;code&gt;skip_footer=0&lt;/code&gt;, meaning that no lines are skipped.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;skip_header=0&lt;/code&gt; および &lt;code&gt;skip_footer=0&lt;/code&gt; です。これは、行がスキップされないことを意味します。</target>
        </trans-unit>
        <trans-unit id="509cc82d7b395ceb5fa528a542a3fa0619544044" translate="yes" xml:space="preserve">
          <source>By default, a new array is created of the given shape and data-type. If &lt;code&gt;buf&lt;/code&gt; is specified and is an object exposing the buffer interface, the array will use the memory from the existing buffer. In this case, the &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.recarray.strides#numpy.recarray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; keywords are available.</source>
          <target state="translated">デフォルトでは、指定された形状とデータ型の新しい配列が作成されます。場合 &lt;code&gt;buf&lt;/code&gt; 指定され、バッファインタフェースを露出するオブジェクトである、アレイは、既存のバッファからメモリを使用します。この場合、 &lt;code&gt;offset&lt;/code&gt; キーワードと&lt;a href=&quot;numpy.recarray.strides#numpy.recarray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;キーワードを使用できます。</target>
        </trans-unit>
        <trans-unit id="823f8fa3f73a578c65a2065fa5f02e69dcee70ef" translate="yes" xml:space="preserve">
          <source>By default, all user-defined data-types are not presumed to be safely castable to any builtin data-types. In addition builtin data-types are not presumed to be safely castable to user-defined data-types. This situation limits the ability of user-defined data-types to participate in the coercion system used by ufuncs and other times when automatic coercion takes place in NumPy. This can be changed by registering data-types as safely castable from a particular data-type object. The function &lt;a href=&quot;../reference/c-api/array#c.PyArray_RegisterCanCast&quot;&gt;&lt;code&gt;PyArray_RegisterCanCast&lt;/code&gt;&lt;/a&gt; (from_descr, totype_number, scalarkind) should be used to specify that the data-type object from_descr can be cast to the data-type with type number totype_number. If you are not trying to alter scalar coercion rules, then use &lt;a href=&quot;../reference/c-api/array#c.NPY_NOSCALAR&quot;&gt;&lt;code&gt;NPY_NOSCALAR&lt;/code&gt;&lt;/a&gt; for the scalarkind argument.</source>
          <target state="translated">デフォルトでは、すべてのユーザー定義データ型が組み込みデータ型に安全にキャストできるとは限りません。さらに、組み込みデータ型は、ユーザー定義のデータ型に安全にキャストできるとは想定されていません。この状況は、ufuncsやNumPyで自動強制が行われるその他の時間に使用される強制システムに参加するユーザー定義のデータ型の機能を制限します。これは、特定のデータ型オブジェクトから安全にキャストできるものとしてデータ型を登録することで変更できます。関数&lt;a href=&quot;../reference/c-api/array#c.PyArray_RegisterCanCast&quot;&gt; &lt;code&gt;PyArray_RegisterCanCast&lt;/code&gt; &lt;/a&gt;（from_descr、totype_number、scalarkind）を使用して、データ型オブジェクトfrom_descrを型番号totype_numberのデータ型にキャストできることを指定する必要があります。スカラー強制ルールを変更しようとしない場合は、scalarkind引数に&lt;a href=&quot;../reference/c-api/array#c.NPY_NOSCALAR&quot;&gt; &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; &lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="c3c9f5af6f6f20b9748f044265ea41cc53afdaad" translate="yes" xml:space="preserve">
          <source>By default, any empty string is marked as missing. We can also consider more complex strings, such as &lt;code&gt;&quot;N/A&quot;&lt;/code&gt; or &lt;code&gt;&quot;???&quot;&lt;/code&gt; to represent missing or invalid data. The &lt;code&gt;missing_values&lt;/code&gt; argument accepts three kind of values:</source>
          <target state="translated">デフォルトでは、空の文字列はすべて欠落としてマークされます。 &lt;code&gt;&quot;N/A&quot;&lt;/code&gt; や &lt;code&gt;&quot;???&quot;&lt;/code&gt; などのより複雑な文字列も検討できます。欠落または無効なデータを表すため。 &lt;code&gt;missing_values&lt;/code&gt; の引数は、値の3種類を受け付けます。</target>
        </trans-unit>
        <trans-unit id="5c0614e39713a118bc2e830f1f54b096ac814bb1" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="translated">デフォルトでは、astypeは常に新しく割り当てられた配列を返します。これがfalseに設定されており、&lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;order&lt;/code&gt; 、および &lt;code&gt;subok&lt;/code&gt; の要件が満たされている場合、コピーの代わりに入力配列が返されます。</target>
        </trans-unit>
        <trans-unit id="65020739d65de234914c6eca7148d91943920302" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="translated">デフォルトでは、astypeは常に新しく割り当てられた配列を返します。これがfalseに設定されており、&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;order&lt;/code&gt; 、および &lt;code&gt;subok&lt;/code&gt; の要件が満たされている場合、コピーの代わりに入力配列が返されます。</target>
        </trans-unit>
        <trans-unit id="67bd53a8510577a68e06f12cd6753f65341b7ba7" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="translated">デフォルトでは、astypeは常に新しく割り当てられた配列を返します。これがfalseに設定されていて、&lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;order&lt;/code&gt; 、および &lt;code&gt;subok&lt;/code&gt; の要件が満たされている場合、コピーではなく入力配列が返されます。</target>
        </trans-unit>
        <trans-unit id="33a91516197cac2d79884383700e7cb303d84acc" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="translated">デフォルトでは、astypeは常に新しく割り当てられた配列を返します。これがfalseに設定されており、&lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;order&lt;/code&gt; 、および &lt;code&gt;subok&lt;/code&gt; の要件が満たされている場合、コピーの代わりに入力配列が返されます。</target>
        </trans-unit>
        <trans-unit id="18abc4afb5a03b89f3bcee3c191658826915b7e7" translate="yes" xml:space="preserve">
          <source>By default, calculate the product of all elements:</source>
          <target state="translated">デフォルトでは、すべての要素の積を計算します。</target>
        </trans-unit>
        <trans-unit id="29592fecd779ff823d8494d78a32e4c6bef17a8b" translate="yes" xml:space="preserve">
          <source>By default, masked values are recognized as such. If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; have the same shape, a common mask is allocated: if &lt;code&gt;x[i,j]&lt;/code&gt; is masked, then &lt;code&gt;y[i,j]&lt;/code&gt; will also be masked. Setting &lt;code&gt;allow_masked&lt;/code&gt; to False will raise an exception if values are missing in either of the input arrays.</source>
          <target state="translated">デフォルトでは、マスクされた値はそのように認識されます。場合 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; 、同じ形状を有し、共通のマスクが割り当てられている次の場合 &lt;code&gt;x[i,j]&lt;/code&gt; マスクされ、次に &lt;code&gt;y[i,j]&lt;/code&gt; また、マスクされます。 &lt;code&gt;allow_masked&lt;/code&gt; をFalseに設定すると、いずれかの入力配列で値が欠落している場合に例外が発生します。</target>
        </trans-unit>
        <trans-unit id="72d47f0b8465ed8e3b2a5736c0d1dfec28a91237" translate="yes" xml:space="preserve">
          <source>By default, mode is &amp;lsquo;full&amp;rsquo;. This returns the convolution at each point of overlap, with an output shape of (N+M-1,). At the end-points of the convolution, the signals do not overlap completely, and boundary effects may be seen.</source>
          <target state="translated">デフォルトでは、モードは「フル」です。これは、オーバーラップの各ポイントでの畳み込みを（N + M-1）の出力形状で返します。たたみ込みの終点では、信号が完全にオーバーラップせず、境界効果が見られる場合があります。</target>
        </trans-unit>
        <trans-unit id="781e5458e78b28bbdf619e8539b2f911598af3c5" translate="yes" xml:space="preserve">
          <source>By default, returned multidimensional arrays are Fortran-contiguous. If &lt;code&gt;intent(c)&lt;/code&gt; is used, then returned multidimensional arrays are C-contiguous.</source>
          <target state="translated">デフォルトでは、返される多次元配列はFortranに隣接しています。場合 &lt;code&gt;intent(c)&lt;/code&gt; 使用され、返される多次元配列はC-連続しています。</target>
        </trans-unit>
        <trans-unit id="6971450c7aa549483b5389a69fedb16eaf066171" translate="yes" xml:space="preserve">
          <source>By default, reverse the dimensions, otherwise permute the axes according to the values given.</source>
          <target state="translated">デフォルトでは、寸法を反転させ、そうでなければ与えられた値に従って軸をパーミュートします。</target>
        </trans-unit>
        <trans-unit id="f55a7b395485c3988f5bccbb6f9eaebb26dfc947" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; treats the input operand as a read-only object. To be able to modify the array elements, you must specify either read-write or write-only mode using the &lt;code&gt;&amp;lsquo;readwrite&amp;rsquo;&lt;/code&gt; or &lt;code&gt;&amp;lsquo;writeonly&amp;rsquo;&lt;/code&gt; per-operand flags.</source>
          <target state="translated">デフォルトでは、&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;は入力オペランドを読み取り専用オブジェクトとして扱います。配列要素を変更できるようにするには、オペランドごとに &lt;code&gt;&amp;lsquo;readwrite&amp;rsquo;&lt;/code&gt; または &lt;code&gt;&amp;lsquo;writeonly&amp;rsquo;&lt;/code&gt; フラグを使用して、読み取り/書き込みモードまたは書き込み専用モードを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="174daf14dced474235661dc4a8a7f2c4b87b4b7c" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; uses the flags &amp;lsquo;allocate&amp;rsquo; and &amp;lsquo;writeonly&amp;rsquo; for operands that are passed in as None. This means we were able to provide just the two operands to the iterator, and it handled the rest.</source>
          <target state="translated">デフォルトでは、&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;はNoneとして渡されるオペランドにフラグ 'allocate'および 'writeonly'を使用します。これは、2つのオペランドのみをイテレータに提供でき、残りを処理したことを意味します。</target>
        </trans-unit>
        <trans-unit id="17e308c1f2a6481942287f2519e364f482dd5128" translate="yes" xml:space="preserve">
          <source>By default, the data-type is inferred from the input data.</source>
          <target state="translated">デフォルトでは、データタイプは入力データから推測されます。</target>
        </trans-unit>
        <trans-unit id="d105f45ad87599a046dab97b11d0171a9dd2c47e" translate="yes" xml:space="preserve">
          <source>By default, the index is into the flattened array, otherwise along the specified axis.</source>
          <target state="translated">デフォルトでは、インデックスは平坦化された配列の中にあり、そうでなければ指定された軸に沿っています。</target>
        </trans-unit>
        <trans-unit id="e68b2ebbdaa7d8bde52807398926b542381f9c7b" translate="yes" xml:space="preserve">
          <source>By default, the iterator produces pointers into the arrays provided, which may be aligned or unaligned, and with any byte order. If copying or buffering is not enabled and the operand data doesn&amp;rsquo;t satisfy the constraints, an error will be raised.</source>
          <target state="translated">デフォルトでは、イテレータは提供された配列へのポインタを生成します。これは、任意のバイト順で、整列または非整列の場合があります。コピーまたはバッファリングが有効になっておらず、オペランドデータが制約を満たさない場合、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="ab25c157edc4354c1f57c1df2646a0b82ab1dad1" translate="yes" xml:space="preserve">
          <source>By default, these operations apply to the array as though it were a list of numbers, regardless of its shape. However, by specifying the &lt;code&gt;axis&lt;/code&gt; parameter you can apply an operation along the specified axis of an array:</source>
          <target state="translated">デフォルトでは、これらの操作は、形状に関係なく、数値のリストであるかのように配列に適用されます。ただし、 &lt;code&gt;axis&lt;/code&gt; パラメータを指定することにより、配列の指定された軸に沿って操作を適用できます。</target>
        </trans-unit>
        <trans-unit id="8619d136820b4ea98c355d5e9bb29020512d7ef1" translate="yes" xml:space="preserve">
          <source>By default, when a line is decomposed into a series of strings, the individual entries are not stripped of leading nor trailing white spaces. This behavior can be overwritten by setting the optional argument &lt;code&gt;autostrip&lt;/code&gt; to a value of &lt;code&gt;True&lt;/code&gt;:</source>
          <target state="translated">デフォルトでは、行が一連の文字列に分解されるときに、個々のエントリの先頭または末尾の空白が削除されません。この動作は、オプションの引数 &lt;code&gt;autostrip&lt;/code&gt; を &lt;code&gt;True&lt;/code&gt; の値に設定することで上書きできます。</target>
        </trans-unit>
        <trans-unit id="a90e6d5076b3318d5438106f6aec8b51a30f2edc" translate="yes" xml:space="preserve">
          <source>By eliminating the inner loop in the description above, and using &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt; to build simple slice objects, &lt;a href=&quot;#numpy.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; can be expressed in terms of applying fancy indexing to each 1-d slice:</source>
          <target state="translated">上記の説明で内部ループを排除し、&lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; &lt;/a&gt;を使用して単純なスライスオブジェクトを作成&lt;a href=&quot;#numpy.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;ことにより、takeは、各1次元スライスにファンシーインデックスを適用することで表現できます。</target>
        </trans-unit>
        <trans-unit id="f5e127dadff417279256627201011a26eddd8177" translate="yes" xml:space="preserve">
          <source>By enabling buffering mode, the chunks provided by the iterator to the inner loop can be made larger, significantly reducing the overhead of the Python interpreter. In the example forcing Fortran iteration order, the inner loop gets to see all the elements in one go when buffering is enabled.</source>
          <target state="translated">バッファリングモードを有効にすることで、イテレータから内部ループに提供されるチャンクをより大きくすることができ、Pythonインタプリタのオーバーヘッドを大幅に削減することができます。Fortran の反復順序を強制する例では、バッファリングを有効にすると、内部ループは一度にすべての要素を見ることができます。</target>
        </trans-unit>
        <trans-unit id="842fa81b602f5ee9d6e48f92f8610cb23e1b4b1b" translate="yes" xml:space="preserve">
          <source>By examining the coefficients, we see that the line should have a gradient of roughly 1 and cut the y-axis at, more or less, -1.</source>
          <target state="translated">係数を調べると、線の勾配はおよそ1で、y軸は多かれ少なかれ-1で切れていることがわかります。</target>
        </trans-unit>
        <trans-unit id="4b0026b5caaf6e12c9b18e1ac7ccb5e7684a2b52" translate="yes" xml:space="preserve">
          <source>By far the most complex case is advanced indexing, which may or may not be combined with typical view based indexing. Here integer indices are interpreted as view based. Before trying to understand this, you may want to make yourself familiar with its subtleties. The advanced indexing code has three different branches and one special case:</source>
          <target state="translated">圧倒的に最も複雑なのは高度なインデックス作成で、これは典型的なビューベースのインデックス作成と組み合わせても、組み合わせなくても構いません。ここでは整数インデックスはビューベースと解釈されます。これを理解しようとする前に、その微妙な点を理解しておくとよいでしょう。高度なインデキシングのコードには、3つの異なるブランチと1つの特殊なケースがあります。</target>
        </trans-unit>
        <trans-unit id="46784614463c18819405731702cb3c998ad15a83" translate="yes" xml:space="preserve">
          <source>By placing intent directives and checking code, the interface can be cleaned up quite a bit until the Python module method is both easier to use and more robust.</source>
          <target state="translated">インテントディレクティブを配置したり、コードをチェックしたりすることで、Pythonモジュールメソッドが使いやすく、かつ堅牢になるまで、インターフェースをかなりきれいにすることができます。</target>
        </trans-unit>
        <trans-unit id="eb83a5c83addee3a887cb831a30aba85bb504443" translate="yes" xml:space="preserve">
          <source>By substituting</source>
          <target state="translated">を代入することで</target>
        </trans-unit>
        <trans-unit id="5cf0a6a61d5c04a9d920300ad8c8de64a060c650" translate="yes" xml:space="preserve">
          <source>By the above description, the casting rules are essentially implemented by the question of when a data type can be cast &amp;ldquo;safely&amp;rdquo; to another data type. The answer to this question can be determined in Python with a function call: &lt;a href=&quot;generated/numpy.can_cast#numpy.can_cast&quot;&gt;&lt;code&gt;can_cast(fromtype, totype)&lt;/code&gt;&lt;/a&gt;. The Figure below shows the results of this call for the 24 internally supported types on the author&amp;rsquo;s 64-bit system. You can generate this table for your system with the code given in the Figure.</source>
          <target state="translated">上記の説明により、キャストルールは、データ型を別のデータ型に「安全に」キャストできるタイミングの問題によって本質的に実装されます。この質問に対する答えは、Pythonで関数呼び出し&lt;a href=&quot;generated/numpy.can_cast#numpy.can_cast&quot;&gt; &lt;code&gt;can_cast(fromtype, totype)&lt;/code&gt; &lt;/a&gt;使用して決定できます。下の図は、作成者の64ビットシステムで内部的にサポートされている24の型に対するこの呼び出しの結果を示しています。図に示すコードを使用して、システムにこのテーブルを生成できます。</target>
        </trans-unit>
        <trans-unit id="0cffcf4de4e9b85ff13913ac390d2131986b166e" translate="yes" xml:space="preserve">
          <source>Byte (-128 to 127)</source>
          <target state="translated">バイト(-128~127</target>
        </trans-unit>
        <trans-unit id="c3b1bb21176956a777afbce91b2dc46b27bfdbd1" translate="yes" xml:space="preserve">
          <source>Byte order of the data (&lt;a href=&quot;../glossary#term-little-endian&quot;&gt;little-endian&lt;/a&gt; or &lt;a href=&quot;../glossary#term-big-endian&quot;&gt;big-endian&lt;/a&gt;)</source>
          <target state="translated">データのバイト順序（&lt;a href=&quot;../glossary#term-little-endian&quot;&gt;リトルエンディアン&lt;/a&gt;または&lt;a href=&quot;../glossary#term-big-endian&quot;&gt;ビッグエンディアン&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="c3ee543ea3c911ca70be24ca50be4966bfc9d11e" translate="yes" xml:space="preserve">
          <source>Byte order of the data (&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-little-endian&quot;&gt;little-endian&lt;/a&gt; or &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-big-endian&quot;&gt;big-endian&lt;/a&gt;)</source>
          <target state="translated">データのバイト順（&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-little-endian&quot;&gt;リトルエンディアン&lt;/a&gt;または&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-big-endian&quot;&gt;ビッグエンディアン&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="4fa7dfbdbb33fd63c061542164ead10c6ea66cdb" translate="yes" xml:space="preserve">
          <source>Byte order to force; a value from the byte order specifications above. The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order. The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for the alternatives above. For example, any of &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;biggish&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">強制するバイト順。上記のバイトオーダー仕様からの値。デフォルト値（ 'S'）の場合、現在のバイト順が入れ替わります。コードは、上記の代替案の &lt;code&gt;new_order&lt;/code&gt; の最初の文字で大文字と小文字を区別しないチェックを行います。たとえば、ビッグエンディアンを指定するには、「B」、「b」、「biggish」のいずれも有効です。</target>
        </trans-unit>
        <trans-unit id="d891a9572e92fd87112849b433aa9d82773e6323" translate="yes" xml:space="preserve">
          <source>Byte order to force; a value from the byte order specifications below. &lt;code&gt;new_order&lt;/code&gt; codes can be any of:</source>
          <target state="translated">強制するバイト順。以下のバイトオーダー仕様からの値。 &lt;code&gt;new_order&lt;/code&gt; コードは次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="925da9e3660113afb959c492e32c0df4c8fba9ab" translate="yes" xml:space="preserve">
          <source>Byte order to force; a value from the byte order specifications below. The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order. &lt;code&gt;new_order&lt;/code&gt; codes can be any of:</source>
          <target state="translated">強制するバイト順。以下のバイトオーダー仕様からの値。デフォルト値（ 'S'）の場合、現在のバイト順が入れ替わります。 &lt;code&gt;new_order&lt;/code&gt; コードは次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="208a9d70c2ceb4cad845268b3793f06f24736861" translate="yes" xml:space="preserve">
          <source>Byte-order for all fields.</source>
          <target state="translated">すべてのフィールドのバイト順。</target>
        </trans-unit>
        <trans-unit id="3d30b75f6bbab6dd2f33ea184465104adfe034dc" translate="yes" xml:space="preserve">
          <source>Byte-swapping</source>
          <target state="translated">Byte-swapping</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="c380132bd13732c2a4492b58e8089f6c672f3148" translate="yes" xml:space="preserve">
          <source>C API</source>
          <target state="translated">シーエーピーアイ</target>
        </trans-unit>
        <trans-unit id="90c2059501661b20579455b452bcdf7917e96a74" translate="yes" xml:space="preserve">
          <source>C API Deprecations</source>
          <target state="translated">C API の非推奨事項</target>
        </trans-unit>
        <trans-unit id="5eefd673571a664f98901cbfc9269cc56d66bdd2" translate="yes" xml:space="preserve">
          <source>C API changes</source>
          <target state="translated">C APIの変更</target>
        </trans-unit>
        <trans-unit id="991eaf0718be5436cf82b4e88422dbaeb580655b" translate="yes" xml:space="preserve">
          <source>C API for random</source>
          <target state="translated">ランダムのためのC言語API</target>
        </trans-unit>
        <trans-unit id="a09f5c39498227c23bac03c4d85a857f0c660b68" translate="yes" xml:space="preserve">
          <source>C dialect</source>
          <target state="translated">ハ方言</target>
        </trans-unit>
        <trans-unit id="baf0b9cf537d3452f0bedecd7885e6a6f5c95212" translate="yes" xml:space="preserve">
          <source>C expressions</source>
          <target state="translated">C式</target>
        </trans-unit>
        <trans-unit id="5053549bf41c7c644de43b7357e8b95981f3b14c" translate="yes" xml:space="preserve">
          <source>C expressions are used in the following parts of signature files:</source>
          <target state="translated">署名ファイルの以下の部分では、C言語の表現を使用しています。</target>
        </trans-unit>
        <trans-unit id="62988a5cc34cb2d480ad455963d13a5b50fea224" translate="yes" xml:space="preserve">
          <source>C order</source>
          <target state="translated">シーオーダー</target>
        </trans-unit>
        <trans-unit id="4d3779622c7ddb81083220abbfe17022ee213c7f" translate="yes" xml:space="preserve">
          <source>C order.</source>
          <target state="translated">C命令です。</target>
        </trans-unit>
        <trans-unit id="502ca6c945d9f8aee115c49e01f9edd12a50b0c8" translate="yes" xml:space="preserve">
          <source>C type</source>
          <target state="translated">C型</target>
        </trans-unit>
        <trans-unit id="1ef859ea3c4b4e94c8561ce88af6e45cd8c349e4" translate="yes" xml:space="preserve">
          <source>C++ support</source>
          <target state="translated">シープラスサポート</target>
        </trans-unit>
        <trans-unit id="e04e63e5d64190b9021eeae0aa43f4dd8f802b80" translate="yes" xml:space="preserve">
          <source>C-API</source>
          <target state="translated">C-API</target>
        </trans-unit>
        <trans-unit id="b42fb0a4e21a6c7c2ad779467660c5d634cd1f27" translate="yes" xml:space="preserve">
          <source>C-API Array Additions</source>
          <target state="translated">C-API 配列の追加</target>
        </trans-unit>
        <trans-unit id="20e7136fe60c57d32b3ba713a50d60dd983c3865" translate="yes" xml:space="preserve">
          <source>C-API Developer Improvements</source>
          <target state="translated">C-API 開発者の改善</target>
        </trans-unit>
        <trans-unit id="847c15716f4f18fd587862ab143e5d2f9581c235" translate="yes" xml:space="preserve">
          <source>C-API Ufunc Additions</source>
          <target state="translated">C-API Ufuncの追加</target>
        </trans-unit>
        <trans-unit id="c77824df8f5b9b7ad0f95af7e88364d494112e7e" translate="yes" xml:space="preserve">
          <source>C-API for implementing Elementary Functions</source>
          <target state="translated">初級関数を実装するためのC-API</target>
        </trans-unit>
        <trans-unit id="6bc42241dfe0e66ad03fd900ab60e09366468123" translate="yes" xml:space="preserve">
          <source>C-Level string to datetime casts changed</source>
          <target state="translated">Cレベルの文字列が変更された日付時刻をキャストします。</target>
        </trans-unit>
        <trans-unit id="39aa49db7f4958819165d85870c4e3056a314158" translate="yes" xml:space="preserve">
          <source>C-Types Foreign Function Interface (&lt;code&gt;numpy.ctypeslib&lt;/code&gt;)</source>
          <target state="translated">Cタイプの外部関数インターフェース（ &lt;code&gt;numpy.ctypeslib&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="1ee13877e6105fd56e4080481ca6046e3bea7c13" translate="yes" xml:space="preserve">
          <source>C-Types Foreign Function Interface (numpy.ctypeslib)</source>
          <target state="translated">C型外部関数インタフェース (numpy.ctypeslib)</target>
        </trans-unit>
        <trans-unit id="72c1b618d901fa2527c184612af8e5f097445876" translate="yes" xml:space="preserve">
          <source>C-contiguous or simply contiguous arrays when data is stored row-wise, i.e. indexing of data as stored in memory starts from the highest dimension.</source>
          <target state="translated">データが行単位で格納されている場合のC-連続または単純に連続した配列,つまりメモリに格納されているデータのインデックス付けは最高次元から始まります.</target>
        </trans-unit>
        <trans-unit id="bdb65d7a9aa6da6471ba4a02f9d435dd19d2ae5a" translate="yes" xml:space="preserve">
          <source>C-order</source>
          <target state="translated">C-order</target>
        </trans-unit>
        <trans-unit id="8bbf8c25cb421fee0bffcb1218c14c15435923a5" translate="yes" xml:space="preserve">
          <source>C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.</source>
          <target state="translated">C順の配列は、FORTRAN順の配列であってもFalseとして評価されます。</target>
        </trans-unit>
        <trans-unit id="18f7fb2659bfefae5fe403809093ff794847eddb" translate="yes" xml:space="preserve">
          <source>C-series coefficients of the integral.</source>
          <target state="translated">積分のC系列係数。</target>
        </trans-unit>
        <trans-unit id="aa3b96b2dd6cb469f06816ec7d846596063a8314" translate="yes" xml:space="preserve">
          <source>C-side of the array interface</source>
          <target state="translated">アレイインターフェースのC側</target>
        </trans-unit>
        <trans-unit id="6e0b67185c9289cda6113607f367a9d9edf7fee3" translate="yes" xml:space="preserve">
          <source>C-struct access</source>
          <target state="translated">C-構造体アクセス</target>
        </trans-unit>
        <trans-unit id="bd0b363c8100c3e0002d75837308df33fee89719" translate="yes" xml:space="preserve">
          <source>C-type names</source>
          <target state="translated">C型名</target>
        </trans-unit>
        <trans-unit id="af48e472b36161e129dd7edb2b2bd61998b64144" translate="yes" xml:space="preserve">
          <source>C. W. Clenshaw, &amp;ldquo;Chebyshev series for mathematical functions&amp;rdquo;, in &lt;em&gt;National Physical Laboratory Mathematical Tables&lt;/em&gt;, vol. 5, London: Her Majesty&amp;rsquo;s Stationery Office, 1962.</source>
          <target state="translated">CW Clenshaw、「&lt;em&gt;National Physical Laboratory Mathematical Tables&lt;/em&gt;、vol。」の「数学関数用のチェビシェフシリーズ」。5、ロンドン：彼女の陛下の文房具のオフィス、1962。</target>
        </trans-unit>
        <trans-unit id="43beb2dca45ea5b86cf6e2c78e1df08bb1062e1a" translate="yes" xml:space="preserve">
          <source>C99-like complex functions have been added. Those can be used if you wish to implement portable C extensions. Since we still support platforms without C99 complex type, you need to restrict to C90-compatible syntax, e.g.:</source>
          <target state="translated">C99のような複雑な関数が追加されました。移植性の高いC言語の拡張機能を実装したい場合に利用できます。私たちはまだ C99 の複素型を持たないプラットフォームをサポートしていますので、C90 と互換性のある構文に制限する必要があります。</target>
        </trans-unit>
        <trans-unit id="cf46ba2402ead2c46d226454dffcd7ce5ff43524" translate="yes" xml:space="preserve">
          <source>CFFI</source>
          <target state="translated">CFFI</target>
        </trans-unit>
        <trans-unit id="51aa24adb10c8f416d462fb3a5357dabf3e3fd38" translate="yes" xml:space="preserve">
          <source>CFFI + Numba</source>
          <target state="translated">CFFI+ヌンバ</target>
        </trans-unit>
        <trans-unit id="b9f44f432adf98c7d09c95f8b09f92c94663702d" translate="yes" xml:space="preserve">
          <source>CFFI can be used to directly access the functions in &lt;code&gt;include/numpy/random/distributions.h&lt;/code&gt;. Some &amp;ldquo;massaging&amp;rdquo; of the header file is required:</source>
          <target state="translated">CFFIを使用して、 &lt;code&gt;include/numpy/random/distributions.h&lt;/code&gt; /distributions.hの関数に直接アクセスできます。ヘッダーファイルの「マッサージ」が必要です。</target>
        </trans-unit>
        <trans-unit id="ebba6dc140f09bcbb9638f5bf4b3df884108c2f7" translate="yes" xml:space="preserve">
          <source>CFFI interface</source>
          <target state="translated">シーエフエフアイインタフェース</target>
        </trans-unit>
        <trans-unit id="a36da1e151b2b0823e662d5b8eaaa38259edebce" translate="yes" xml:space="preserve">
          <source>CI extended with additional services</source>
          <target state="translated">追加サービスで拡張されたCI</target>
        </trans-unit>
        <trans-unit id="6821c968895aca188636e67b589fcc004a8bbd12" translate="yes" xml:space="preserve">
          <source>CPU arch detection</source>
          <target state="translated">CPUアーチ検出</target>
        </trans-unit>
        <trans-unit id="1ade62840c85639fb7384a1d18b950f273e9fb48" translate="yes" xml:space="preserve">
          <source>CPU architecture of the platform; only one of the above is defined.</source>
          <target state="translated">プラットフォームのCPUアーキテクチャ;上記のうちの1つのみが定義されています。</target>
        </trans-unit>
        <trans-unit id="19b3426c923b3e7b1cdee4b651f488f72bf3c78b" translate="yes" xml:space="preserve">
          <source>CXX</source>
          <target state="translated">CXX</target>
        </trans-unit>
        <trans-unit id="c9cddb0fc26555bd7e44c82c30b8dd03f9efdf7e" translate="yes" xml:space="preserve">
          <source>C_CONTIGUOUS / C / CONTIGUOUS</source>
          <target state="translated">C_CONTIGUOUS/C/CONTIGUOUS</target>
        </trans-unit>
        <trans-unit id="0ce3a73aca867f2538f5c735d732291c3a6e377f" translate="yes" xml:space="preserve">
          <source>Caches in &lt;code&gt;np.fft&lt;/code&gt; are now bounded in total size and item count</source>
          <target state="translated">&lt;code&gt;np.fft&lt;/code&gt; のキャッシュは、合計サイズとアイテム数で制限されるようになりました</target>
        </trans-unit>
        <trans-unit id="f3d5846dd99b124383ff0d457d07594b45e6712e" translate="yes" xml:space="preserve">
          <source>Calculate &lt;code&gt;2**p&lt;/code&gt; for all &lt;code&gt;p&lt;/code&gt; in the input array.</source>
          <target state="translated">計算 &lt;code&gt;2**p&lt;/code&gt; のすべてのため &lt;code&gt;p&lt;/code&gt; 入力配列では。</target>
        </trans-unit>
        <trans-unit id="250bbdf8f96508ded0e2419aede1c85ce8e60f69" translate="yes" xml:space="preserve">
          <source>Calculate &lt;code&gt;2**x&lt;/code&gt; for all elements in the array.</source>
          <target state="translated">配列内のすべての要素について &lt;code&gt;2**x&lt;/code&gt; を計算します。</target>
        </trans-unit>
        <trans-unit id="80c054468bb32b1733a38bd9e500e3c7e2410c60" translate="yes" xml:space="preserve">
          <source>Calculate &lt;code&gt;exp(x) - 1&lt;/code&gt; for all elements in the array.</source>
          <target state="translated">配列内のすべての要素について &lt;code&gt;exp(x) - 1&lt;/code&gt; を計算します。</target>
        </trans-unit>
        <trans-unit id="897a0bcc51e675340eb8de452d794c61bbe86ad4" translate="yes" xml:space="preserve">
          <source>Calculate the absolute value element-wise.</source>
          <target state="translated">絶対値を要素ごとに計算します。</target>
        </trans-unit>
        <trans-unit id="52d855325ad8b8ba2e5f03ed06faa393dd2b3c5d" translate="yes" xml:space="preserve">
          <source>Calculate the exponential of all elements in the input array.</source>
          <target state="translated">入力配列の全要素の指数を計算します.</target>
        </trans-unit>
        <trans-unit id="a3dc7bdd6edd5fbaf2d2ff0fab2c5a4b13186ce0" translate="yes" xml:space="preserve">
          <source>Calculate the generalized inverse of a matrix using its singular-value decomposition (SVD) and including all &lt;em&gt;large&lt;/em&gt; singular values.</source>
          <target state="translated">特異値分解（SVD）を使用し、すべての&lt;em&gt;大きな&lt;/em&gt;特異値を含めて、行列の一般化された逆行列を計算します。</target>
        </trans-unit>
        <trans-unit id="4b25208e5ebec1248ee411c25859b5c2fd7bb09b" translate="yes" xml:space="preserve">
          <source>Calculate the n-th discrete difference along given axis.</source>
          <target state="translated">与えられた軸に沿ったn番目の離散差を計算します。</target>
        </trans-unit>
        <trans-unit id="42cb44e98b4304fa793f5c2a54298181fdecfa02" translate="yes" xml:space="preserve">
          <source>Calculate the n-th discrete difference along the given axis.</source>
          <target state="translated">与えられた軸に沿ったn番目の離散差を計算します。</target>
        </trans-unit>
        <trans-unit id="1c03f8fb0f5af1d1f5a42484860a4bc9ada64002" translate="yes" xml:space="preserve">
          <source>Calculate the standard deviation of the non-NaN values.</source>
          <target state="translated">非NaN値の標準偏差を計算します。</target>
        </trans-unit>
        <trans-unit id="f8c757cfbde7655c0c48030d0cc0f2a47e05c8b1" translate="yes" xml:space="preserve">
          <source>Calculate the standard deviation of these values.</source>
          <target state="translated">これらの値の標準偏差を計算します。</target>
        </trans-unit>
        <trans-unit id="7c1b58f3d94fc67cd514e1570aa6b12719e32b56" translate="yes" xml:space="preserve">
          <source>Calculate the t statistic, setting the ddof parameter to the unbiased value so the divisor in the standard deviation will be degrees of freedom, N-1.</source>
          <target state="translated">ddofパラメータを偏りのない値に設定してt統計量を計算し、標準偏差の除数が自由度N-1になるようにします。</target>
        </trans-unit>
        <trans-unit id="a8acd54a675004438176e793d314e80390eec770" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;1/x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;1/x&lt;/code&gt; を計算します。</target>
        </trans-unit>
        <trans-unit id="e5f90663e28e9982e7de271dda336040dea8f7aa" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;element in test_elements&lt;/code&gt;, broadcasting over &lt;code&gt;element&lt;/code&gt; only.</source>
          <target state="translated">&lt;code&gt;element in test_elements&lt;/code&gt; 計算し、 &lt;code&gt;element&lt;/code&gt; のみを介してブロードキャストします。</target>
        </trans-unit>
        <trans-unit id="c2efd3cd9b667cce814af0fcbaac60b64cdcdb35" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;element in test_elements&lt;/code&gt;, broadcasting over &lt;code&gt;element&lt;/code&gt; only. Returns a boolean array of the same shape as &lt;code&gt;element&lt;/code&gt; that is True where an element of &lt;code&gt;element&lt;/code&gt; is in &lt;code&gt;test_elements&lt;/code&gt; and False otherwise.</source>
          <target state="translated">&lt;code&gt;element in test_elements&lt;/code&gt; 計算し、 &lt;code&gt;element&lt;/code&gt; のみを介してブロードキャストします。戻り値と同じ形状のブール配列 &lt;code&gt;element&lt;/code&gt; の要素ここで真である &lt;code&gt;element&lt;/code&gt; である &lt;code&gt;test_elements&lt;/code&gt; さもなければとFalseを。</target>
        </trans-unit>
        <trans-unit id="74b05ed646884364ea61a52a0d97dd5553fc5db3" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;log(1 + x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;log(1 + x)&lt;/code&gt; 計算します。</target>
        </trans-unit>
        <trans-unit id="793634569b16ddadf09c84f21826d340c4bb186b" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;log(exp(x1) + exp(x2))&lt;/code&gt;. This function is useful in statistics where the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers. In such cases the logarithm of the calculated probability is stored. This function allows adding probabilities stored in such a fashion.</source>
          <target state="translated">&lt;code&gt;log(exp(x1) + exp(x2))&lt;/code&gt; 計算します。この関数は、イベントの計算された確率が通常の浮動小数点数の範囲を超えるほど小さい可能性がある統計で役立ちます。このような場合、計算された確率の対数が保存されます。この機能により、このような方法で格納された確率を追加できます。</target>
        </trans-unit>
        <trans-unit id="55306f441c10b288ef594152ca5bc10ba426774f" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;log2(2**x1 + 2**x2)&lt;/code&gt;. This function is useful in machine learning when the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers. In such cases the base-2 logarithm of the calculated probability can be used instead. This function allows adding probabilities stored in such a fashion.</source>
          <target state="translated">&lt;code&gt;log2(2**x1 + 2**x2)&lt;/code&gt; 計算します。この関数は、計算されたイベントの確率が非常に小さく、通常の浮動小数点数の範囲を超える可能性がある場合に、機械学習で役立ちます。そのような場合、代わりに、計算された確率の2を底とする対数を使用できます。この機能により、このような方法で格納された確率を追加できます。</target>
        </trans-unit>
        <trans-unit id="79b6b61d48a464831755d05e96c5b24edef1de03" translate="yes" xml:space="preserve">
          <source>Calculates which of the given dates are valid days, and which are not.</source>
          <target state="translated">指定された日付のうち、どれが有効な日でどれが無効なのかを計算します。</target>
        </trans-unit>
        <trans-unit id="dc6751bd6532a841494c31d2cb271a6c23434bcc" translate="yes" xml:space="preserve">
          <source>Calculation</source>
          <target state="translated">Calculation</target>
        </trans-unit>
        <trans-unit id="05d27dcc239bf9ea22989ad95d110b65fd4d9edb" translate="yes" xml:space="preserve">
          <source>Calculations</source>
          <target state="translated">Calculations</target>
        </trans-unit>
        <trans-unit id="c0b95ddbd1bbdb09cd17ce1c430a7adeedcc6050" translate="yes" xml:space="preserve">
          <source>Calculus</source>
          <target state="translated">Calculus</target>
        </trans-unit>
        <trans-unit id="dde8f3e3d46e069dd8c9fb51c5a6b6c4238ef493" translate="yes" xml:space="preserve">
          <source>Call &lt;a href=&quot;generator#numpy.random.default_rng&quot;&gt;&lt;code&gt;default_rng&lt;/code&gt;&lt;/a&gt; to get a new instance of a &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;, then call its methods to obtain samples from different distributions. By default, &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; uses bits provided by &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; which has better statistical properties than the legacy &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; used in &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;generator#numpy.random.default_rng&quot;&gt; &lt;code&gt;default_rng&lt;/code&gt; &lt;/a&gt;を呼び出して&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;新しいインスタンスを取得してから、そのメソッドを呼び出してさまざまなディストリビューションからサンプルを取得します。デフォルトでは、&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;によって提供されるビットを使用し&lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;。これは、&lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt;使用される従来のMT19937よりも優れた統計プロパティを備えています。</target>
        </trans-unit>
        <trans-unit id="f6b577a771e51546f11b433f88a97b7ef013570b" translate="yes" xml:space="preserve">
          <source>Call &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt;&lt;code&gt;PyType_Ready&lt;/code&gt;&lt;/a&gt; (&amp;lt;pointer_to_new_type&amp;gt;). If this function returns a negative number, a failure occurred and the type is not initialized. Otherwise, the type is ready to be used. It is generally important to place a reference to the new type into the module dictionary so it can be accessed from Python.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt; &lt;code&gt;PyType_Ready&lt;/code&gt; &lt;/a&gt;（&amp;lt;pointer_to_new_type&amp;gt;）を呼び出します。この関数が負の数を返す場合、障害が発生し、型は初期化されません。それ以外の場合は、タイプを使用する準備ができています。Pythonからアクセスできるように、新しいタイプへの参照をモジュールディクショナリに配置することが一般的に重要です。</target>
        </trans-unit>
        <trans-unit id="bdf175380f108b91b68b35d6cba860e239285fd3" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;str.istitle&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.istitle&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="d5bbdd4afe52a03da69e768bb6350617fd2c2fe8" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;str.isupper&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.isupper&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="204bec18a0c758d4b92300d3ccfda2d8f2d41215" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;str.lower&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.lower&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="eef266f410d282365eeaef6f6541415ad4d67585" translate="yes" xml:space="preserve">
          <source>Call self as a function.</source>
          <target state="translated">selfを関数として呼び出す。</target>
        </trans-unit>
        <trans-unit id="0ce1402d6ef90df67129aaaa626b1d87878afa44" translate="yes" xml:space="preserve">
          <source>Call the function from the library with the ctypes arguments.</source>
          <target state="translated">ライブラリからctypes引数を指定して関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="ef89b4e2063118e4442bf0889dbb070ab91c9c17" translate="yes" xml:space="preserve">
          <source>Call-back arguments</source>
          <target state="translated">コールバック引数</target>
        </trans-unit>
        <trans-unit id="8829f8e417cdbefc80e5f0018c56210ff40f16e6" translate="yes" xml:space="preserve">
          <source>Callback upon error:</source>
          <target state="translated">エラー時のコールバック。</target>
        </trans-unit>
        <trans-unit id="095dfbda4be2a7c23470a2f28679717480fb723d" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;add&lt;/code&gt; then yields:</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; を呼び出すと、次のようになります。</target>
        </trans-unit>
        <trans-unit id="11e32184ce81143ebb10c040c662152029bc28ed" translate="yes" xml:space="preserve">
          <source>Calling C-code from Python can result in Python crashes if you are not careful. None of the approaches in this chapter are immune. You have to know something about the way data is handled by both NumPy and by the third-party library being used.</source>
          <target state="translated">PythonからCコードを呼び出すと、注意しないとPythonがクラッシュする可能性があります。この章で紹介したアプローチは、どれも無傷ではありません。NumPyとサードパーティのライブラリの両方でデータがどのように扱われるかを知っておく必要があります。</target>
        </trans-unit>
        <trans-unit id="7a6041d361fd40eeecfd3b783ee25742eac73334" translate="yes" xml:space="preserve">
          <source>Calling f2py from Python</source>
          <target state="translated">Pythonからf2pyを呼び出す</target>
        </trans-unit>
        <trans-unit id="627187305b11d0b40ef311920110ebf177a808de" translate="yes" xml:space="preserve">
          <source>Calling other compiled libraries from Python</source>
          <target state="translated">Pythonから他のコンパイル済みライブラリを呼び出す</target>
        </trans-unit>
        <trans-unit id="45cc60363cb41b7ffde77fcffd01fb398e2212aa" translate="yes" xml:space="preserve">
          <source>Calling the function</source>
          <target state="translated">関数の呼び出し</target>
        </trans-unit>
        <trans-unit id="f76a0fdbe900eef0f77fc7210a232c0754707b8b" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.encode&quot;&gt;&lt;code&gt;str.encode&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">要素ごとに&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.encode&quot;&gt; &lt;code&gt;str.encode&lt;/code&gt; を&lt;/a&gt;呼び出します。</target>
        </trans-unit>
        <trans-unit id="5ddbcf21043a5f353f23ca4baba1595ba4a4c298" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.capitalize&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.capitalize&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="fac61b23fdecfba854b4b4efab7777fd152b2cd6" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.center&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.center&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="1314c79da136d136fb6bbb829ea41b9418ad141a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.count&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.count&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="4bdc60efe7fe548bd722d4044bc214b413e9d4dd" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.decode&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.decode&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="065d9a82f4f8e8be749e189a1fda4fbbe3abbe4a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.encode&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.encode&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="c1788f723cdc513a1b82d19f6d756a8fad670e36" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.endswith&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.endswith&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="1506c8828926db71b8ee1e63d0d49604826d93cb" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.expandtabs&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.expandtabs&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="3c7293ade2e69f10fa46947bf34f0b6e9553dda9" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.find&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.find&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="467102d858ecdef3b85b56bdb57ad38edb734308" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.index&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.index&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="9028b020672a2d11380a1f6acfdb2435aab492c0" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.isalnum&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.isalnum&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="fd4a785af6221c540650fb70b847d1cefb209fda" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.isalpha&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.isalpha&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="656252d18256f4f02da62d1b2291d93d00dda7e4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.isdigit&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.isdigit&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="2a85e1b04f3860c701786f2c9eabf6a753b661de" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.islower&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.islower&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="2bb68da644aa463ff4c1c36c7d9b40bf8b8f64bc" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.isspace&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.isspace&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="741c3bea47e11f849d26dfea4d3d3a40eab3c129" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.join&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.join&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="a819deb9a44d524ac6731b6be53354ba9f42a375" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.ljust&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.ljust&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="be80be96a9f5d678d3f84ce0ae913fd30691c166" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.lstrip&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.lstrip&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="3a06e70f258111f5ace799d0136012a728b9986f" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.partition&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.partition&lt;/code&gt; を要素ごとに呼び出します。</target>
        </trans-unit>
        <trans-unit id="887a34caef57804ead86c1cf188ead795251b5a4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.replace&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.replace&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="05d90debebac8c8e525b11c833af03b1809c3595" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rfind&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.rfind&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="89bfa6c81f923111ab3ece5d1065bb7a8b18172a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rindex&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.rindex&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="55188dcc2c20e117f83220adcd9445f8940213ba" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rjust&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.rjust&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="19291c82bbc252e358dcd5efe30bebd4ce3f47fc" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rpartition&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.rpartition&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="e30544ad22292a0898136208de2fa5fc236f97f4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rsplit&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.rsplit&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="bf3f027903bcb2fa17e73f1d36c8446f531dbe5a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rstrip&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.rstrip&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="739adfdb756eef5e48a6b103e3600e5bc999cb7a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.split&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.split&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="b5e51ab4b44c03ea14d792300213b602772f9ea6" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.splitlines&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.splitlines&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="6c953fe5d272055ef6fdc5b65d12465c629e73e4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.startswith&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.startswith&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="1827eeaf19d2fb7a578c669a1d5307476f133fcd" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.strip&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.strip&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="274bbb89ddefdfebcf8c0b98e05e899bc5eb9615" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.swapcase&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.swapcase&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="2bc28d6c4e67250d03ac5f9ac2fcd548d24d6297" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.title&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.title&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="91315156a48280f48729eabe9ec7862779adc8d2" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.translate&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.translate&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="2440d757fee8b2705315ead5568e7af63f8335a3" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.upper&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.upper&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="691e1fcbb97130e6abfe067256904d840bcc927b" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.zfill&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;str.zfill&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="9c60fe9461b9d2c89f3c3e872dadf8ad18517837" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;unicode.isdecimal&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;unicode.isdecimal&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="c6e0a82d42fca087f606e832d63a055b7b362137" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;unicode.isnumeric&lt;/code&gt; element-wise.</source>
          <target state="translated">要素ごとに &lt;code&gt;unicode.isnumeric&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="79ab673318d7c81b7f76879d7f7e6d0f3ff543f1" translate="yes" xml:space="preserve">
          <source>Can be a local file or a remote URL.</source>
          <target state="translated">ローカルファイルまたはリモートURLを指定できます。</target>
        </trans-unit>
        <trans-unit id="a90e6085e13ad6ee060ad3eac04d655f92454003" translate="yes" xml:space="preserve">
          <source>Can be read from a filelike stream object instead of an actual file.</source>
          <target state="translated">実際のファイルではなく、ファイルライクなストリームオブジェクトから読み込むことができます。</target>
        </trans-unit>
        <trans-unit id="22f6ea93b575f4da64882fc6b779b0f07dc62149" translate="yes" xml:space="preserve">
          <source>Can be scalar or non-scalar. If non-scalar, the resulting filled array should be broadcastable over input array. Default is None.</source>
          <target state="translated">スカラでもノンスカラでも構いません.スカラでない場合,結果として得られる埋められた配列は,入力配列に対してブロードキャスト可能でなければなりません.デフォルトは None です。</target>
        </trans-unit>
        <trans-unit id="07932047b9de074a44eece379f541bd670890cdd" translate="yes" xml:space="preserve">
          <source>Can be used, for example, to add broadcasting to a built-in Python function (see Examples section).</source>
          <target state="translated">例えば、組み込みの Python 関数にブロードキャストを追加するために使用することができます (例のセクションを参照してください)。</target>
        </trans-unit>
        <trans-unit id="7139132bf88ca6d9cbbfb32a613254727892bf7e" translate="yes" xml:space="preserve">
          <source>Can represent all NumPy arrays including nested record arrays and object arrays.</source>
          <target state="translated">入れ子になったレコード配列やオブジェクト配列を含むすべてのNumPy配列を表現することができます。</target>
        </trans-unit>
        <trans-unit id="f01b544f8ac201079e369764bc5d84163c794bad" translate="yes" xml:space="preserve">
          <source>Can write code in non-standard form which may become obsolete</source>
          <target state="translated">陳腐化する可能性のある非標準的な形式でコードを書くことができます。</target>
        </trans-unit>
        <trans-unit id="07c566972545483ecb8e809f4eb024c341423ec5" translate="yes" xml:space="preserve">
          <source>Can you reshape an array?</source>
          <target state="translated">配列の形を変えることはできますか?</target>
        </trans-unit>
        <trans-unit id="ca09c54bff74a82bae543ebe259f7452ee8c5293" translate="yes" xml:space="preserve">
          <source>Capabilities</source>
          <target state="translated">Capabilities</target>
        </trans-unit>
        <trans-unit id="a058457334819b9647916ad868c25fa88bc97117" translate="yes" xml:space="preserve">
          <source>Cartesian (&amp;lsquo;xy&amp;rsquo;, default) or matrix (&amp;lsquo;ij&amp;rsquo;) indexing of output. See Notes for more details.</source>
          <target state="translated">出力のデカルト（ 'xy'、デフォルト）または行列（ 'ij'）インデックス。詳細については、注を参照してください。</target>
        </trans-unit>
        <trans-unit id="b5599547be57585d8ed9f9e6e56fb372b94bf366" translate="yes" xml:space="preserve">
          <source>Cash flows (must contain at least one positive and one negative value) or nan is returned. The first value is considered a sunk cost at time zero.</source>
          <target state="translated">キャッシュフロー(正の値と負の値を少なくとも1つ含む必要があります)またはnanが返されます。最初の値は、時間ゼロの時点でのサンクコストとみなされます。</target>
        </trans-unit>
        <trans-unit id="4819b90bf3135701e4238f100f5eccaffb4cf77a" translate="yes" xml:space="preserve">
          <source>Cast &lt;code&gt;input&lt;/code&gt; to a &lt;code&gt;PyArrayObject*&lt;/code&gt; if legal, and ensure that it is of type &lt;code&gt;typecode&lt;/code&gt;. If &lt;code&gt;input&lt;/code&gt; cannot be cast, or the &lt;code&gt;typecode&lt;/code&gt; is wrong, set a Python error and return &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">正当であれば &lt;code&gt;input&lt;/code&gt; を &lt;code&gt;PyArrayObject*&lt;/code&gt; キャストし、それが &lt;code&gt;typecode&lt;/code&gt; タイプであることを確認してください。 &lt;code&gt;input&lt;/code&gt; をキャストできない場合、または &lt;code&gt;typecode&lt;/code&gt; が間違っている場合は、Pythonエラーを設定して &lt;code&gt;NULL&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="66c23409ad11975a171ee62798652be7275d78b9" translate="yes" xml:space="preserve">
          <source>Cast &lt;code&gt;n&lt;/code&gt; elements &lt;code&gt;from&lt;/code&gt; one type &lt;code&gt;to&lt;/code&gt; another. The data to cast from is in a contiguous, correctly-swapped and aligned chunk of memory pointed to by from. The buffer to cast to is also contiguous, correctly-swapped and aligned. The fromarr and toarr arguments should only be used for flexible-element-sized arrays (string, unicode, void).</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 個の要素 &lt;code&gt;from&lt;/code&gt; あるタイプ &lt;code&gt;to&lt;/code&gt; 別のタイプにキャストします。キャスト元のデータは、fromが指す連続した、正しくスワップされ、整列されたメモリのチャンクにあります。キャスト先のバッファも連続しており、正しくスワップされ、整列されています。fromarr引数とtoarr引数は、柔軟な要素サイズの配列（string、unicode、void）にのみ使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="5da405e72e65e85b0a6ff9fb710530d444100461" translate="yes" xml:space="preserve">
          <source>Cast code: This checks for &amp;ldquo;true&amp;rdquo; alignment, as it does &lt;code&gt;*dst = CASTFUNC(*src)&lt;/code&gt; if aligned. Otherwise, it does &lt;code&gt;memmove(srcval, src); dstval = CASTFUNC(srcval); memmove(dst, dstval)&lt;/code&gt; where dstval/srcval are aligned.</source>
          <target state="translated">キャストコード： &lt;code&gt;*dst = CASTFUNC(*src)&lt;/code&gt; が調整されている場合は、「真の」調整をチェックします。それ以外の場合は、 &lt;code&gt;memmove(srcval, src); dstval = CASTFUNC(srcval); memmove(dst, dstval)&lt;/code&gt; ここで、dstval / srcvalは整列されます。</target>
        </trans-unit>
        <trans-unit id="4dbf7f264927d9ee6c0c9230f88c1b227f370d7c" translate="yes" xml:space="preserve">
          <source>Cast the elements of the array &lt;em&gt;in&lt;/em&gt; into the array &lt;em&gt;out&lt;/em&gt;. The output array should be writeable, have an integer-multiple of the number of elements in the input array (more than one copy can be placed in out), and have a data type that is one of the builtin types. Returns 0 on success and -1 if an error occurs.</source>
          <target state="translated">配列&lt;em&gt;inの&lt;/em&gt;要素を配列&lt;em&gt;outに&lt;/em&gt;キャスト&lt;em&gt;し&lt;/em&gt;ます。出力配列は書き込み可能であり、入力配列の要素数の整数倍（複数のコピーを配置できます）を持ち、組み込み型の1つであるデータ型を持っている必要があります。成功した場合は0を返し、エラーが発生した場合は-1を返します。</target>
        </trans-unit>
        <trans-unit id="e6a8277578137a1b27ee47f6d99dc6ac5a6c8df7" translate="yes" xml:space="preserve">
          <source>Cast to the desired type, even if it can&amp;rsquo;t be done without losing information.</source>
          <target state="translated">情報を失わずに実行できない場合でも、目的のタイプにキャストします。</target>
        </trans-unit>
        <trans-unit id="a945bfddda4f16646c0e1e8cf16a394a39e915e6" translate="yes" xml:space="preserve">
          <source>Casting Rules</source>
          <target state="translated">鋳造規則</target>
        </trans-unit>
        <trans-unit id="0e43fbb5b95b8e028055445bd4f061de51dc4a06" translate="yes" xml:space="preserve">
          <source>Casting must be done on one or more of the inputs whenever the ufunc does not have a core loop implementation for the input types provided. If an implementation for the input types cannot be found, then the algorithm searches for an implementation with a type signature to which all of the inputs can be cast &amp;ldquo;safely.&amp;rdquo; The first one it finds in its internal list of loops is selected and performed, after all necessary type casting. Recall that internal copies during ufuncs (even for casting) are limited to the size of an internal buffer (which is user settable).</source>
          <target state="translated">提供された入力タイプのコアループ実装がufuncにない場合は常に、1つ以上の入力でキャストを実行する必要があります。入力タイプの実装が見つからない場合、アルゴリズムは、すべての入力を「安全に」キャストできる型シグネチャを持つ実装を検索します。ループの内部リストで最初に見つかったものが選択され、必要な型キャストがすべて実行された後に実行されます。ufuncs中の内部コピー（キャストの場合でも）は、内部バッファー（ユーザー設定可能）のサイズに制限されることを思い出してください。</target>
        </trans-unit>
        <trans-unit id="8748cec5513dc9c01c715b723dcb4b372a11fea9" translate="yes" xml:space="preserve">
          <source>Casting scalars</source>
          <target state="translated">スカラーの鋳造</target>
        </trans-unit>
        <trans-unit id="cbb26092630998f6b4ebb2584d7e63c1ad783481" translate="yes" xml:space="preserve">
          <source>Casting the set to a list gives the expected result:</source>
          <target state="translated">セットをリストにキャストすると、期待した結果が得られます。</target>
        </trans-unit>
        <trans-unit id="3b9cb47a9c04d9f04e8fb247efea4728b9f0825f" translate="yes" xml:space="preserve">
          <source>Casting to allow when changing between datetime units.</source>
          <target state="translated">日付時間の単位を変更する際に使用できるようにキャストしました。</target>
        </trans-unit>
        <trans-unit id="21d50099f4ef7f76fe962077ec52f3b66d36a662" translate="yes" xml:space="preserve">
          <source>Casts a structured array to a new dtype using assignment by field-name.</source>
          <target state="translated">フィールド名による代入を用いて、構造化配列を新しいdtypeにキャストします。</target>
        </trans-unit>
        <trans-unit id="1b7e02730ebfcc85f5732a8be223fd80563fe083" translate="yes" xml:space="preserve">
          <source>Categories are determined by first checking which of boolean, integer (int/uint), or floating point (float/complex) the maximum kind of all the arrays and the scalars are.</source>
          <target state="translated">カテゴリは,まず,すべての配列とスカラのうち,ブーリアン,整数(int/uint),浮動小数点(float/complex)のどれが最大の種類であるかを確認して決定されます.</target>
        </trans-unit>
        <trans-unit id="3325b57bdda8f0731fcea923488b3e46095663f1" translate="yes" xml:space="preserve">
          <source>Causes the iterator to convert all the operands to a common data type, calculated based on the ufunc type promotion rules. Copying or buffering must be enabled.</source>
          <target state="translated">すべてのオペランドを共通のデータ型に変換するために、イテレータを発生させます。コピーまたはバッファリングを有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="f6e47e97b987638e04e1741c9188448c0cda9575" translate="yes" xml:space="preserve">
          <source>Causes the iterator to provide data for &lt;code&gt;op[i]&lt;/code&gt; that is in native byte order, aligned according to the dtype requirements, contiguous, or any combination.</source>
          <target state="translated">イテレーターが、dtypeの要件、連続、または任意の組み合わせに従ってアラインされたネイティブのバイト順のデータを &lt;code&gt;op[i]&lt;/code&gt; に提供します。</target>
        </trans-unit>
        <trans-unit id="78cd28e519e06a8be731a725d2ee50a3144a0620" translate="yes" xml:space="preserve">
          <source>Causes the iterator to skip iteration of the innermost loop, requiring the user of the iterator to handle it.</source>
          <target state="translated">一番内側のループの反復をスキップさせ、イテレータのユーザがそれを処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="d748728383297b4bba46340904d34590fd3f0e6c" translate="yes" xml:space="preserve">
          <source>Causes the iterator to store buffering data, and use buffering to satisfy data type, alignment, and byte-order requirements. To buffer an operand, do not specify the &lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt;&lt;code&gt;NPY_ITER_COPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags, because they will override buffering. Buffering is especially useful for Python code using the iterator, allowing for larger chunks of data at once to amortize the Python interpreter overhead.</source>
          <target state="translated">イテレータにバッファリングデータを格納させ、バッファリングを使用してデータ型、配置、およびバイト順の要件を満たします。オペランドをバッファリングするには、&lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt; &lt;code&gt;NPY_ITER_COPY&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;フラグを指定しないでください。これらのフラグはバッファリングをオーバーライドするためです。バッファリングは、イテレータを使用するPythonコードで特に便利です。一度に大きなデータチャンクを使用して、Pythonインタープリタのオーバーヘッドを償却できます。</target>
        </trans-unit>
        <trans-unit id="cbe86966ee1567b8621995982683f047543e592a" translate="yes" xml:space="preserve">
          <source>Causes the iterator to track a multi-index. This prevents the iterator from coalescing axes to produce bigger inner loops. If the loop is also not buffered and no index is being tracked (&lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; can be called), then the iterator size can be &lt;code&gt;-1&lt;/code&gt; to indicate that the iterator is too large. This can happen due to complex broadcasting and will result in errors being created when the setting the iterator range, removing the multi index, or getting the next function. However, it is possible to remove axes again and use the iterator normally if the size is small enough after removal.</source>
          <target state="translated">イテレータにマルチインデックスを追跡させます。これにより、イテレータが軸を合体させてより大きな内部ループを生成するのを防ぎます。ループもバッファリングされておらず、インデックスが追跡されていない場合（ &lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; を呼び出すことができます）、イテレータのサイズを &lt;code&gt;-1&lt;/code&gt; にして、イテレータが大きすぎることを示すことができます。これは複雑なブロードキャストが原因で発生する可能性があり、イテレータ範囲の設定、マルチインデックスの削除、または次の関数の取得時にエラーが作成されます。ただし、削除後にサイズが十分に小さければ、軸を再度削除してイテレータを通常どおりに使用できます。</target>
        </trans-unit>
        <trans-unit id="a78370684072181888bd07868c0ae200011c6b51" translate="yes" xml:space="preserve">
          <source>Causes the iterator to track a raveled flat index matching C order. This option cannot be used with &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">イテレータに、Cの順序に一致する壊れたフラットインデックスを追跡させます。このオプションは&lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt; &lt;/a&gt;と一緒には使用できません。</target>
        </trans-unit>
        <trans-unit id="d09f5eb17dd94e9b8185491d29ffd82541173b9e" translate="yes" xml:space="preserve">
          <source>Causes the iterator to track a raveled flat index matching Fortran order. This option cannot be used with &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">イテレータに、Fortranの順序に一致する、解かれたフラットインデックスを追跡させます。このオプションは&lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt; &lt;/a&gt;と一緒には使用できません。</target>
        </trans-unit>
        <trans-unit id="c373af68347ef344e2a4047a6349667bfbe022fd" translate="yes" xml:space="preserve">
          <source>Chain exceptions to give better error messages for invalid PEP3118 format strings</source>
          <target state="translated">無効なPEP3118形式の文字列に対して、より良いエラーメッセージを提供するために例外を連鎖させる</target>
        </trans-unit>
        <trans-unit id="c0df50e511723d6385d81becfe6c98c0ca2c5dad" translate="yes" xml:space="preserve">
          <source>Chained array operations, in efficient calculation order, &lt;a href=&quot;numpy.einsum_path#numpy.einsum_path&quot;&gt;&lt;code&gt;numpy.einsum_path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">効率的な計算順序での連鎖配列演算&lt;a href=&quot;numpy.einsum_path#numpy.einsum_path&quot;&gt; &lt;code&gt;numpy.einsum_path&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d9f53c2498e2f3ad3fca9000468a403dc1def6c7" translate="yes" xml:space="preserve">
          <source>Chained array operations. For more complicated contractions, speed ups might be achieved by repeatedly computing a &amp;lsquo;greedy&amp;rsquo; path or pre-computing the &amp;lsquo;optimal&amp;rsquo; path and repeatedly applying it, using an &lt;a href=&quot;numpy.einsum_path#numpy.einsum_path&quot;&gt;&lt;code&gt;einsum_path&lt;/code&gt;&lt;/a&gt; insertion (since version 1.12.0). Performance improvements can be particularly significant with larger arrays:</source>
          <target state="translated">連鎖配列操作。より複雑な縮&lt;a href=&quot;numpy.einsum_path#numpy.einsum_path&quot;&gt; &lt;code&gt;einsum_path&lt;/code&gt; &lt;/a&gt;場合、「貪欲な」パスを繰り返し計算するか、「最適な」パスを事前計算し、einsum_path挿入を使用して繰り返し適用することで、スピードアップを実現できます（バージョン1.12.0以降）。より大きなアレイでは、パフォーマンスの向上が特に重要になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="4b14b1641c23a3ee01fb58fe8633eb893f1634ef" translate="yes" xml:space="preserve">
          <source>Change elements of an array based on conditional and input values.</source>
          <target state="translated">条件や入力値に基づいて配列の要素を変更します。</target>
        </trans-unit>
        <trans-unit id="01dcb981588ac5e81e8962905c01357fef0a774b" translate="yes" xml:space="preserve">
          <source>Change output of &lt;code&gt;round&lt;/code&gt; on scalars to be consistent with Python</source>
          <target state="translated">Pythonと一致するようにスカラーの &lt;code&gt;round&lt;/code&gt; 出力を変更します</target>
        </trans-unit>
        <trans-unit id="03e304dc68ffb07e8cb055b859df002401eafba4" translate="yes" xml:space="preserve">
          <source>Change shape and size of array in-place.</source>
          <target state="translated">配列の形状とサイズをその場で変更します。</target>
        </trans-unit>
        <trans-unit id="e18523f3dc9af0b0d781daa5529bbdd8c6b73861" translate="yes" xml:space="preserve">
          <source>Change the byte-ordering information in the array dtype so that it interprets the underlying data as being in a different byte order. This is the role of &lt;code&gt;arr.newbyteorder()&lt;/code&gt;</source>
          <target state="translated">配列dtypeのバイト順序情報を変更して、基になるデータが異なるバイト順序であると解釈するようにします。これは &lt;code&gt;arr.newbyteorder()&lt;/code&gt; の役割です</target>
        </trans-unit>
        <trans-unit id="51d2004fb81c8f1c875ffbaa2ebee0d486f11763" translate="yes" xml:space="preserve">
          <source>Change the byte-ordering of the underlying data, leaving the dtype interpretation as it was. This is what &lt;code&gt;arr.byteswap()&lt;/code&gt; does.</source>
          <target state="translated">dtypeの解釈をそのままにして、基になるデータのバイト順序を変更します。これは &lt;code&gt;arr.byteswap()&lt;/code&gt; が行うことです。</target>
        </trans-unit>
        <trans-unit id="7c78cf8387f58f6da3c59f8db55e089f69c5453e" translate="yes" xml:space="preserve">
          <source>Change the directory:</source>
          <target state="translated">ディレクトリを変更します。</target>
        </trans-unit>
        <trans-unit id="1baf38892b5a38369da2ab3d5066a1bc5faa26e9" translate="yes" xml:space="preserve">
          <source>Change the shape of an array without changing its data.</source>
          <target state="translated">配列のデータを変更せずに配列の形状を変更します。</target>
        </trans-unit>
        <trans-unit id="57cca933dc4ae8712cc751b049a24d49a1cbe977" translate="yes" xml:space="preserve">
          <source>Change the sign of x1 to that of x2, element-wise.</source>
          <target state="translated">x1の符号をx2の符号に変更します。</target>
        </trans-unit>
        <trans-unit id="f1fd8269d290cf6173d8944feb182f6867a500ae" translate="yes" xml:space="preserve">
          <source>Change the vector definition of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; using &lt;code&gt;axisa&lt;/code&gt; and &lt;code&gt;axisb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;axisa&lt;/code&gt; と &lt;code&gt;axisb&lt;/code&gt; を使用して、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; のベクトル定義を変更します。</target>
        </trans-unit>
        <trans-unit id="0e76bac75a93f40062500cfe4d6d4594aea2a414" translate="yes" xml:space="preserve">
          <source>Changed in version 1.10.0: Earlier NumPy versions required dfnum &amp;gt; 1.</source>
          <target state="translated">バージョン1.10.0で変更：以前のNumPyバージョンでは、dfnum&amp;gt; 1が必要でした。</target>
        </trans-unit>
        <trans-unit id="9e03441147d9c9bca84c6633efe853d678690f6f" translate="yes" xml:space="preserve">
          <source>Changed in version 1.11.0: When a single column has to be read it is possible to use an integer instead of a tuple. E.g &lt;code&gt;usecols = 3&lt;/code&gt; reads the fourth column the same way as &lt;code&gt;usecols = (3,)&lt;/code&gt; would.</source>
          <target state="translated">バージョン1.11.0で変更：単一の列を読み取る必要がある場合、タプルの代わりに整数を使用できます。たとえば、 &lt;code&gt;usecols = 3&lt;/code&gt; は、 &lt;code&gt;usecols = (3,)&lt;/code&gt; と同じ方法で4番目の列を読み取ります。</target>
        </trans-unit>
        <trans-unit id="4240cc617a1809505e609f22132a15e64d1b8364" translate="yes" xml:space="preserve">
          <source>Changed in version 1.13.0: Previously, the default was documented to be -1, but that was in error. At some future date, the default will change to -1, as originally intended. Until then, the axis should be given explicitly when &lt;code&gt;arr.ndim &amp;gt; 1&lt;/code&gt;, to avoid a FutureWarning.</source>
          <target state="translated">バージョン1.13.0で変更：以前は、デフォルトは-1と記載されていましたが、エラーでした。将来のある時点で、デフォルトは当初の意図どおり-1に変更されます。それまでは、 &lt;code&gt;arr.ndim &amp;gt; 1&lt;/code&gt; ときに明示的に軸を指定して、FutureWarningを回避する必要があります。</target>
        </trans-unit>
        <trans-unit id="7cf5dc6a75318b20c4a1e296708ff3954da61899" translate="yes" xml:space="preserve">
          <source>Changed in version 1.13.0: Tuples are allowed for keyword argument.</source>
          <target state="translated">バージョン1.13.0で変更。キーワード引数にタプルを使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="8369be3972dcfca939d8870350211ef461655917" translate="yes" xml:space="preserve">
          <source>Changed in version 1.14.0: Earlier NumPy versions required dfnum &amp;gt; 1.</source>
          <target state="translated">バージョン1.14.0で変更：以前のNumPyバージョンでは、dfnum&amp;gt; 1が必要でした。</target>
        </trans-unit>
        <trans-unit id="90df01afcc61c5a576cbe17f8aa7128ba6554b30" translate="yes" xml:space="preserve">
          <source>Changed in version 1.14.0: If not set, a FutureWarning is given. The previous default of &lt;code&gt;-1&lt;/code&gt; will use the machine precision as &lt;code&gt;rcond&lt;/code&gt; parameter, the new default will use the machine precision times &lt;code&gt;max(M, N)&lt;/code&gt;. To silence the warning and use the new default, use &lt;code&gt;rcond=None&lt;/code&gt;, to keep using the old behavior, use &lt;code&gt;rcond=-1&lt;/code&gt;.</source>
          <target state="translated">バージョン1.14.0で変更：設定されていない場合、FutureWarningが表示されます。以前のデフォルトの &lt;code&gt;-1&lt;/code&gt; では、マシン精度を &lt;code&gt;rcond&lt;/code&gt; パラメータとして使用し、新しいデフォルトでは、マシン精度と &lt;code&gt;max(M, N)&lt;/code&gt; 積を使用します。警告を &lt;code&gt;rcond=None&lt;/code&gt; て新しいデフォルトを使用するには、rcond = Noneを使用し、古い動作を引き続き使用するには、 &lt;code&gt;rcond=-1&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="1d2839d7d3bf87e0e23f5c67fc8d1ab0fe0551fd" translate="yes" xml:space="preserve">
          <source>Changed in version 1.14: Broadcasted against the stack of matrices</source>
          <target state="translated">バージョン1.14で変更されました:行列のスタックに対してブロードキャストされます。</target>
        </trans-unit>
        <trans-unit id="348ee8de383634f48f0728f5bfaf909f0982c324" translate="yes" xml:space="preserve">
          <source>Changed in version 1.14: Can now operate on stacks of matrices</source>
          <target state="translated">バージョン 1.14 で変更:行列のスタックを操作できるようになりました。</target>
        </trans-unit>
        <trans-unit id="05cf1c5d8f1269a7f5fa5c6cc3fc095bf8055509" translate="yes" xml:space="preserve">
          <source>Changed in version 1.15.0.: The &amp;lsquo;stable&amp;rsquo; option was added.</source>
          <target state="translated">バージョン1.15.0で変更： 'stable'オプションが追加されました。</target>
        </trans-unit>
        <trans-unit id="0e6fb4664107937e52dcdbc13917b49d6b44f05c" translate="yes" xml:space="preserve">
          <source>Changed in version 1.15.0: DeprecationWarnings are actually emitted.</source>
          <target state="translated">バージョン1.15.0で変更されました。DeprecationWarningsが実際に発せられるようになりました。</target>
        </trans-unit>
        <trans-unit id="5e3b221df91333bee6b9f5792109b32e7e70567b" translate="yes" xml:space="preserve">
          <source>Changed in version 1.15.0: None and tuples of axes are supported</source>
          <target state="translated">バージョン1.15.0で変更されました。軸のタプルはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="0a28aad38084ea97b7bc4890436cdfc6bcade503" translate="yes" xml:space="preserve">
          <source>Changed in version 1.16.0: A list of args may also be provided.</source>
          <target state="translated">バージョン 1.16.0 で変更されました。引数のリストも提供されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="cf547a772cebc0e7496a5c76e49a36dae75a2d98" translate="yes" xml:space="preserve">
          <source>Changed in version 1.16.0: Accept str as well as bytes</source>
          <target state="translated">バージョン1.16.0で変更。バイトだけでなく str も受け入れる</target>
        </trans-unit>
        <trans-unit id="83d75b7f177288265577e6765abc146d2cecb0e7" translate="yes" xml:space="preserve">
          <source>Changed in version 1.16.0: Non-scalar &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are now supported.</source>
          <target state="translated">バージョン1.16.0で変更：非スカラーの &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;stop&lt;/code&gt; がサポートされるようになりました。</target>
        </trans-unit>
        <trans-unit id="25985fe044545f9478af4af504ffd04c8801c6e6" translate="yes" xml:space="preserve">
          <source>Changed in version 1.16.0: Renamed from &lt;code&gt;dims&lt;/code&gt; to &lt;code&gt;shape&lt;/code&gt;.</source>
          <target state="translated">改名：バージョン1.16.0で変更 &lt;code&gt;dims&lt;/code&gt; に &lt;code&gt;shape&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eef53483993b5fb29b126ef19278ead520adb6f9" translate="yes" xml:space="preserve">
          <source>Changed in version 1.16.3: Made default False in response to CVE-2019-6446.</source>
          <target state="translated">バージョン1.16.3で変更:CVE-2019-6446に対応し、デフォルトをFalseにした。</target>
        </trans-unit>
        <trans-unit id="ff4dc328009aefab6de678232e1061e9bf30fb2d" translate="yes" xml:space="preserve">
          <source>Changed in version 1.17.0: &lt;a href=&quot;#numpy.errstate&quot;&gt;&lt;code&gt;errstate&lt;/code&gt;&lt;/a&gt; is also usable as a function decorator, saving a level of indentation if an entire function is wrapped. See &lt;a href=&quot;https://docs.python.org/dev/library/contextlib.html#contextlib.ContextDecorator&quot;&gt;&lt;code&gt;contextlib.ContextDecorator&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">バージョン1.17.0で変更：&lt;a href=&quot;#numpy.errstate&quot;&gt; &lt;code&gt;errstate&lt;/code&gt; &lt;/a&gt;は関数デコレーターとしても使用できるため、関数全体がラップされている場合、インデントのレベルを節約できます。詳細については、&lt;a href=&quot;https://docs.python.org/dev/library/contextlib.html#contextlib.ContextDecorator&quot;&gt; &lt;code&gt;contextlib.ContextDecorator&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="af2d1032fe2cc2a8c7b8fc21250999bf723a2b20" translate="yes" xml:space="preserve">
          <source>Changed in version 1.17.0: &lt;a href=&quot;https://docs.python.org/dev/library/pathlib.html#pathlib.Path&quot;&gt;&lt;code&gt;pathlib.Path&lt;/code&gt;&lt;/a&gt; objects are now accepted.</source>
          <target state="translated">バージョン1.17.0で変更：&lt;a href=&quot;https://docs.python.org/dev/library/pathlib.html#pathlib.Path&quot;&gt; &lt;code&gt;pathlib.Path&lt;/code&gt; &lt;/a&gt;オブジェクトが受け入れられるようになりました。</target>
        </trans-unit>
        <trans-unit id="61efb6f136dc51708e975673488296290e1e421b" translate="yes" xml:space="preserve">
          <source>Changed in version 1.17.0: Casting between a simple data type and a structured one is possible only for &amp;ldquo;unsafe&amp;rdquo; casting. Casting to multiple fields is allowed, but casting from multiple fields is not.</source>
          <target state="translated">バージョン1.17.0で変更：単純なデータ型と構造化データ型の間のキャストは、「安全でない」キャストでのみ可能です。複数のフィールドへのキャストは許可されていますが、複数のフィールドからのキャストは許可されていません。</target>
        </trans-unit>
        <trans-unit id="c5df5da3e381a86308cf0cc4eb048541e70b1ac9" translate="yes" xml:space="preserve">
          <source>Changed in version 1.18.</source>
          <target state="translated">バージョン1.18で変更。</target>
        </trans-unit>
        <trans-unit id="6b373f41a3cb0188f798a19ca6f87e39244e1215" translate="yes" xml:space="preserve">
          <source>Changed in version 1.18.0.</source>
          <target state="translated">バージョン1.18.0で変更。</target>
        </trans-unit>
        <trans-unit id="89bfac0c966e6918532c5056416ce8c139bac641" translate="yes" xml:space="preserve">
          <source>Changed in version 1.18.0: A mix of scalars and zero-dimensional arrays now produces a type capable of holding the scalar value. Previously priority was given to the dtype of the arrays.</source>
          <target state="translated">バージョン1.18.0での変更点:スカラと0次元配列の混合で、スカラ値を保持できる型が生成されるようになりました。以前は配列のdtypeが優先されていました。</target>
        </trans-unit>
        <trans-unit id="19b458380fddb4902dee94f09f396c9a282f453d" translate="yes" xml:space="preserve">
          <source>Changed in version 1.18.0: A tuple of axes is now supported. Out of range axes as described above are now forbidden and raise an &lt;code&gt;AxisError&lt;/code&gt;.</source>
          <target state="translated">バージョン1.18.0で変更：軸のタプルがサポートされるようになりました。上記の範囲外の軸は現在禁止されており、 &lt;code&gt;AxisError&lt;/code&gt; が発生します。</target>
        </trans-unit>
        <trans-unit id="dccd9958f73e96cdb6901cdbf8dca831295ef22c" translate="yes" xml:space="preserve">
          <source>Changed in version 1.19.0: Boolean indices are now treated as a mask of elements to remove, rather than being cast to the integers 0 and 1.</source>
          <target state="translated">バージョン 1.19.0 で変更:ブール値インデックスは、整数の 0 と 1 にキャストされるのではなく、削除する要素のマスクとして扱われるようになりました。</target>
        </trans-unit>
        <trans-unit id="7c9406124c2f89ed955f1ed4fdf79269cd807fab" translate="yes" xml:space="preserve">
          <source>Changed in version 1.8.0: Broadcasting rules apply, see the &lt;a href=&quot;../routines.linalg#module-numpy.linalg&quot;&gt;&lt;code&gt;numpy.linalg&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">バージョン1.8.0で変更：ブロードキャストルールが適用されます。詳細については、&lt;a href=&quot;../routines.linalg#module-numpy.linalg&quot;&gt; &lt;code&gt;numpy.linalg&lt;/code&gt; の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="442c1fd3d41745a2d4ec1e84a3657676ca62838e" translate="yes" xml:space="preserve">
          <source>Changed in version 1.9.0: A tuple of axes is supported</source>
          <target state="translated">バージョン 1.9.0 で変更:軸のタプルがサポートされました。</target>
        </trans-unit>
        <trans-unit id="73bab6415b0560ad9f839326ef0b98ed7906af98" translate="yes" xml:space="preserve">
          <source>Changed in version 1.9.0: Casting from numeric to string types in &amp;lsquo;safe&amp;rsquo; casting mode requires that the string dtype length is long enough to store the max integer/float value converted.</source>
          <target state="translated">バージョン1.9.0で変更：「セーフ」キャストモードで数値型から文字列型にキャストするには、文字列のdtypeの長さが、変換された最大の整数/浮動小数点値を格納するのに十分な長さである必要があります。</target>
        </trans-unit>
        <trans-unit id="8adc0d706675beb5229fbd846a1b85c2cfcca190" translate="yes" xml:space="preserve">
          <source>Changed in version 1.9.0: Casting from numeric to string types in &amp;lsquo;safe&amp;rsquo; casting mode requires that the string dtype length is long enough to store the maximum integer/float value converted.</source>
          <target state="translated">バージョン1.9.0で変更：「セーフ」キャストモードで数値型から文字列型にキャストするには、文字列のdtypeの長さが、変換された最大の整数/浮動小数点値を格納するのに十分な長さである必要があります。</target>
        </trans-unit>
        <trans-unit id="5a255433707dd5f70c7a4be8e1821141fe49e182" translate="yes" xml:space="preserve">
          <source>Changed in version 1.9: 1-D and 0-D cases are allowed.</source>
          <target state="translated">バージョン1.9で変更:1-Dと0-Dのケースを許可するようにしました。</target>
        </trans-unit>
        <trans-unit id="d65dbc46ba0aa85c5054bdc349b97636497c7d97" translate="yes" xml:space="preserve">
          <source>Changed in version NumPy: 1.19</source>
          <target state="translated">バージョンNumPyで変更しました。1.19</target>
        </trans-unit>
        <trans-unit id="090cd0a4c0bdb025d9d082643a59f937e13d144c" translate="yes" xml:space="preserve">
          <source>Changed random variate stream from &lt;code&gt;numpy.random.Generator.dirichlet&lt;/code&gt;</source>
          <target state="translated">ランダム変量ストリームを &lt;code&gt;numpy.random.Generator.dirichlet&lt;/code&gt; から変更しました</target>
        </trans-unit>
        <trans-unit id="6c789b1f25e20176df4d2eb365c2cf355c4a907a" translate="yes" xml:space="preserve">
          <source>Changed random variate stream from &lt;code&gt;numpy.random.Generator.integers&lt;/code&gt;</source>
          <target state="translated">ランダム変量ストリームを &lt;code&gt;numpy.random.Generator.integers&lt;/code&gt; から変更しました</target>
        </trans-unit>
        <trans-unit id="164b3d4809f98d0458414f1bf9cf3c9dcba16bb5" translate="yes" xml:space="preserve">
          <source>Changelog</source>
          <target state="translated">Changelog</target>
        </trans-unit>
        <trans-unit id="8aa57de6dce6ee1c35c6aba7426503281876b258" translate="yes" xml:space="preserve">
          <source>Changes</source>
          <target state="translated">Changes</target>
        </trans-unit>
        <trans-unit id="d447e3c0af8f91b0b6d56c2803ffc2d885c25ac6" translate="yes" xml:space="preserve">
          <source>Changes are also made in all fields and sub-arrays of the array data type.</source>
          <target state="translated">また、配列データ型のすべてのフィールドとサブ配列にも変更が加えられます。</target>
        </trans-unit>
        <trans-unit id="d5c8653ebb3c65244702565331c9f825090ef108" translate="yes" xml:space="preserve">
          <source>Changes are also made in all fields and sub-arrays of the data type.</source>
          <target state="translated">データ型のすべてのフィールドとサブアレイでも変更が行われます。</target>
        </trans-unit>
        <trans-unit id="988d6dcf1558a60cf9e3df8c88bfbf9aa6476a76" translate="yes" xml:space="preserve">
          <source>Changes elements of an array based on conditional and input values.</source>
          <target state="translated">条件や入力値に基づいて配列の要素を変更します。</target>
        </trans-unit>
        <trans-unit id="2285dbb1d294a01028b75412567462886684b25a" translate="yes" xml:space="preserve">
          <source>Changes that have been marked for this release must be backported to the maintenance/1.14.x branch.</source>
          <target state="translated">このリリースのためにマークされた変更は maintenance/1.14.x ブランチにバックポートしなければなりません。</target>
        </trans-unit>
        <trans-unit id="11f7d423e4a6c5aafe601b11f0668f2b9c2f00fa" translate="yes" xml:space="preserve">
          <source>Changes the variable used when printing &lt;code&gt;p&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt; to &lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt;&lt;code&gt;variable&lt;/code&gt;&lt;/a&gt; (see Examples).</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; を出力するときに使用される変数を &lt;code&gt;x&lt;/code&gt; から&lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt; &lt;code&gt;variable&lt;/code&gt; &lt;/a&gt;変更します（例を参照）。</target>
        </trans-unit>
        <trans-unit id="79ec3dbe3c422f3862e5d024b983cec2214e99ca" translate="yes" xml:space="preserve">
          <source>Changes to &lt;code&gt;PyArray_GetDTypeTransferFunction&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PyArray_GetDTypeTransferFunction&lt;/code&gt; への変更</target>
        </trans-unit>
        <trans-unit id="a6b7a5b4726b415eac4533ff4c785ffd43ff58e3" translate="yes" xml:space="preserve">
          <source>Changes with NumPy 1.11</source>
          <target state="translated">NumPy 1.11での変更点</target>
        </trans-unit>
        <trans-unit id="f88e590a9d42082459bee2897052e8478444520a" translate="yes" xml:space="preserve">
          <source>Changing array shape</source>
          <target state="translated">配列の形状を変更する</target>
        </trans-unit>
        <trans-unit id="d83babf52902d360c4710e39052681b9926c27c0" translate="yes" xml:space="preserve">
          <source>Changing byte ordering</source>
          <target state="translated">バイト順の変更</target>
        </trans-unit>
        <trans-unit id="bb5d57bb97464b7a41e90965a34fd558225f91df" translate="yes" xml:space="preserve">
          <source>Changing kind of array</source>
          <target state="translated">配列の種類の変更</target>
        </trans-unit>
        <trans-unit id="4dac00a1fdb9bc9e870465fcb8ac48e7a6f41092" translate="yes" xml:space="preserve">
          <source>Changing number of dimensions</source>
          <target state="translated">寸法数の変更</target>
        </trans-unit>
        <trans-unit id="26a89ebf1c1d895edaaec0f680290afde6188baf" translate="yes" xml:space="preserve">
          <source>Changing the number of dimensions</source>
          <target state="translated">寸法数の変更</target>
        </trans-unit>
        <trans-unit id="659708d4116763fca54f546304717111fc0dcdbc" translate="yes" xml:space="preserve">
          <source>Changing the shape</source>
          <target state="translated">形を変える</target>
        </trans-unit>
        <trans-unit id="7d5cb72a6a27b93f3d464005b1595158876ad637" translate="yes" xml:space="preserve">
          <source>Changing the shape of an array</source>
          <target state="translated">配列の形状を変更する</target>
        </trans-unit>
        <trans-unit id="472ea4d678f10230e80354665e55d5162f57e4eb" translate="yes" xml:space="preserve">
          <source>Character arrays (&lt;code&gt;numpy.char&lt;/code&gt;)</source>
          <target state="translated">文字配列（ &lt;code&gt;numpy.char&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c77510e827185d4da42fdcbd8730a318064afdff" translate="yes" xml:space="preserve">
          <source>Character arrays (numpy.char)</source>
          <target state="translated">文字配列 (numpy.char)</target>
        </trans-unit>
        <trans-unit id="92c1e393951a713a4c1c2df5523a5b76ef600358" translate="yes" xml:space="preserve">
          <source>Character code</source>
          <target state="translated">文字コード</target>
        </trans-unit>
        <trans-unit id="ba3973797ea212e06b4bd3f28ecf46f8274e1229" translate="yes" xml:space="preserve">
          <source>Character(s) used in replacement of white spaces in the variables names. By default, use a &amp;lsquo;_&amp;rsquo;.</source>
          <target state="translated">変数名の空白の置換に使用される文字。デフォルトでは、「_」を使用します。</target>
        </trans-unit>
        <trans-unit id="5c50aa40fe135ae872479f3d463481aa7c8705fa" translate="yes" xml:space="preserve">
          <source>Charles Harris</source>
          <target state="translated">チャールズ・ハリス</target>
        </trans-unit>
        <trans-unit id="faf08e2ed05138df0c2fc73c7cd9c35b89b1b4ee" translate="yes" xml:space="preserve">
          <source>Chebyshev</source>
          <target state="translated">Chebyshev</target>
        </trans-unit>
        <trans-unit id="ea61b1323fc64a9bb8d86a6aadc2fcb486ca4493" translate="yes" xml:space="preserve">
          <source>Chebyshev (class in numpy.polynomial.chebyshev)</source>
          <target state="translated">チェビシェフ</target>
        </trans-unit>
        <trans-unit id="b08808430b344bf934ff595f268dd7b3c9767d8c" translate="yes" xml:space="preserve">
          <source>Chebyshev Class</source>
          <target state="translated">チェビシェフクラス</target>
        </trans-unit>
        <trans-unit id="c805e26af7ca174190c79364ad41f4463c143779" translate="yes" xml:space="preserve">
          <source>Chebyshev Module (&lt;code&gt;numpy.polynomial.chebyshev&lt;/code&gt;)</source>
          <target state="translated">チェビシェフモジュール（ &lt;code&gt;numpy.polynomial.chebyshev&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="43b2dcb73cb4875580862bf8c8dd1ada4c4da4c6" translate="yes" xml:space="preserve">
          <source>Chebyshev Module (numpy.polynomial.chebyshev)</source>
          <target state="translated">チェビシェフモジュール (numpy.polynomial.chebyshev)</target>
        </trans-unit>
        <trans-unit id="2b074447d5337b1acd99539f1f78bf706c34ad9f" translate="yes" xml:space="preserve">
          <source>Chebyshev Series (&lt;code&gt;numpy.polynomial.chebyshev&lt;/code&gt;)</source>
          <target state="translated">チェビシェフシリーズ（ &lt;code&gt;numpy.polynomial.chebyshev&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="4a4e1fdfb1973afb318ee463fd302dbf6eb373c9" translate="yes" xml:space="preserve">
          <source>Chebyshev Series (numpy.polynomial.chebyshev)</source>
          <target state="translated">チェビシェフ級数</target>
        </trans-unit>
        <trans-unit id="0efbe54789bc84b8d4e58d69167610bd2675854f" translate="yes" xml:space="preserve">
          <source>Chebyshev coefficients in order of increasing degree, i.e., &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*T_0(x) + 2*T_1(x) + 3*T_2(x)&lt;/code&gt;.</source>
          <target state="translated">次数の昇順のチェビシェフ係数、つまり &lt;code&gt;(1, 2, 3)&lt;/code&gt; は &lt;code&gt;1*T_0(x) + 2*T_1(x) + 3*T_2(x)&lt;/code&gt; 与えます。</target>
        </trans-unit>
        <trans-unit id="cda36d3a5a7c1cf749fe8552f3ece2e37c1bde96" translate="yes" xml:space="preserve">
          <source>Chebyshev coefficients of the interpolating series ordered from low to high.</source>
          <target state="translated">補間級数のチェビシェフ係数を低い方から高い方に順に並べたものです。</target>
        </trans-unit>
        <trans-unit id="96032d11ffc294810d816c812b7d22b436c23b79" translate="yes" xml:space="preserve">
          <source>Chebyshev coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">チェビシェフ係数は低いものから高いものへと並べられています。場合 &lt;code&gt;y&lt;/code&gt; が 2-Dであった、の列kにおけるデータの係数 &lt;code&gt;y&lt;/code&gt; は、列にある &lt;code&gt;k&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78471d8e84581a3113228c58d00d8316306213cc" translate="yes" xml:space="preserve">
          <source>Chebyshev points of the first kind.</source>
          <target state="translated">チェビシェフは第一種のポイント。</target>
        </trans-unit>
        <trans-unit id="97b5ebecc93143ab3bacdf5e10cda1de1af56a39" translate="yes" xml:space="preserve">
          <source>Chebyshev points of the second kind.</source>
          <target state="translated">チェビシェフは第二種のポイント。</target>
        </trans-unit>
        <trans-unit id="1e63eba3c512c100441a580822bf3dee3fdc84ed" translate="yes" xml:space="preserve">
          <source>Chebyshev series</source>
          <target state="translated">チェビシェフシリーズ</target>
        </trans-unit>
        <trans-unit id="f8c02252eba6ff12458afafb159b20cecff7478a" translate="yes" xml:space="preserve">
          <source>Chebyshev series of power.</source>
          <target state="translated">チェビシェフシリーズのパワー。</target>
        </trans-unit>
        <trans-unit id="8a0ba9e6152e6c1500bb9491398112d62215acf4" translate="yes" xml:space="preserve">
          <source>Chebyshev series of the derivative.</source>
          <target state="translated">微分のチェビシェフ級数。</target>
        </trans-unit>
        <trans-unit id="4f2d57204da6b30aece47fb6efed1a7b8e11e6b0" translate="yes" xml:space="preserve">
          <source>Chebyshev series whose graph is a straight line.</source>
          <target state="translated">グラフが直線であるチェビシェフ級数。</target>
        </trans-unit>
        <trans-unit id="95aa0918943d1236cc6d32e54d1344d9d0be39c1" translate="yes" xml:space="preserve">
          <source>Chebyshev weight function.</source>
          <target state="translated">チェビシェフの重量関数。</target>
        </trans-unit>
        <trans-unit id="b18292f75bb94b7b116770748f5215372e100826" translate="yes" xml:space="preserve">
          <source>Chebyshev.__call__()</source>
          <target state="translated">Chebyshev.__call__()</target>
        </trans-unit>
        <trans-unit id="1bacc9adbf511d1e41a349b356ba0145d6ee7946" translate="yes" xml:space="preserve">
          <source>Chebyshev.basis()</source>
          <target state="translated">Chebyshev.basis()</target>
        </trans-unit>
        <trans-unit id="188210acd7ec982c8646fa316466c45a976f83f2" translate="yes" xml:space="preserve">
          <source>Chebyshev.cast()</source>
          <target state="translated">Chebyshev.cast()</target>
        </trans-unit>
        <trans-unit id="639e56acd1352c9b5b503ed1496fdb9a5d07c0c0" translate="yes" xml:space="preserve">
          <source>Chebyshev.convert()</source>
          <target state="translated">Chebyshev.convert()</target>
        </trans-unit>
        <trans-unit id="11392591347c8480770728aa505b563eccfa5f1d" translate="yes" xml:space="preserve">
          <source>Chebyshev.copy()</source>
          <target state="translated">Chebyshev.copy()</target>
        </trans-unit>
        <trans-unit id="41611d32208cae6870074acedaa6fe221b1b3446" translate="yes" xml:space="preserve">
          <source>Chebyshev.cutdeg()</source>
          <target state="translated">Chebyshev.cutdeg()</target>
        </trans-unit>
        <trans-unit id="8789ce0a4c5068fdfe534918cc2e90fdad042cd3" translate="yes" xml:space="preserve">
          <source>Chebyshev.degree()</source>
          <target state="translated">Chebyshev.degree()</target>
        </trans-unit>
        <trans-unit id="c6481905857e646a6d9c66a8532da7a6334a6377" translate="yes" xml:space="preserve">
          <source>Chebyshev.deriv()</source>
          <target state="translated">Chebyshev.deriv()</target>
        </trans-unit>
        <trans-unit id="6291088b6f8cbfecdb12bf2bdad126fa6f8f1e75" translate="yes" xml:space="preserve">
          <source>Chebyshev.domain</source>
          <target state="translated">Chebyshev.domain</target>
        </trans-unit>
        <trans-unit id="dd41304fdf8df9e37b5816500b41e22e66c61815" translate="yes" xml:space="preserve">
          <source>Chebyshev.fit()</source>
          <target state="translated">Chebyshev.fit()</target>
        </trans-unit>
        <trans-unit id="e4926f0eed8819f61f1604cce384a57795e1eabf" translate="yes" xml:space="preserve">
          <source>Chebyshev.fromroots()</source>
          <target state="translated">Chebyshev.fromroots()</target>
        </trans-unit>
        <trans-unit id="70d84e9f4f420d528a16ab4c0ba4755a5af5e65c" translate="yes" xml:space="preserve">
          <source>Chebyshev.has_samecoef()</source>
          <target state="translated">Chebyshev.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="119c3a01c7179401c8123c868c9643da34d59174" translate="yes" xml:space="preserve">
          <source>Chebyshev.has_samedomain()</source>
          <target state="translated">Chebyshev.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="1d9bea3b85c40da6ce150efb52fc340072577178" translate="yes" xml:space="preserve">
          <source>Chebyshev.has_sametype()</source>
          <target state="translated">Chebyshev.has_sametype()</target>
        </trans-unit>
        <trans-unit id="21b9443d56e25c8c9434c2048384c54825cbad75" translate="yes" xml:space="preserve">
          <source>Chebyshev.has_samewindow()</source>
          <target state="translated">Chebyshev.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="f72f56cc281db3fc06403b01e30cee59ef5f1b34" translate="yes" xml:space="preserve">
          <source>Chebyshev.identity()</source>
          <target state="translated">Chebyshev.identity()</target>
        </trans-unit>
        <trans-unit id="4320540c12f7d006eb6f49d8596f1304f5f9b17f" translate="yes" xml:space="preserve">
          <source>Chebyshev.integ()</source>
          <target state="translated">Chebyshev.integ()</target>
        </trans-unit>
        <trans-unit id="c6cc890aac4433ddc758056a7a1ec57ab680d9dd" translate="yes" xml:space="preserve">
          <source>Chebyshev.interpolate()</source>
          <target state="translated">Chebyshev.interpolate()</target>
        </trans-unit>
        <trans-unit id="7c5cc657b6a0749c5b79e78f062d99b7bfa79e2e" translate="yes" xml:space="preserve">
          <source>Chebyshev.linspace()</source>
          <target state="translated">Chebyshev.linspace()</target>
        </trans-unit>
        <trans-unit id="318403bb4b0c9579e1e22548291a889f9ceb1ac1" translate="yes" xml:space="preserve">
          <source>Chebyshev.mapparms()</source>
          <target state="translated">Chebyshev.mapparms()</target>
        </trans-unit>
        <trans-unit id="e3d230253c27dda3445e4aef41453767831a496b" translate="yes" xml:space="preserve">
          <source>Chebyshev.roots()</source>
          <target state="translated">Chebyshev.roots()</target>
        </trans-unit>
        <trans-unit id="a90771ff29f5d5fd6c72cd284a6221aaeee66dbc" translate="yes" xml:space="preserve">
          <source>Chebyshev.trim()</source>
          <target state="translated">Chebyshev.trim()</target>
        </trans-unit>
        <trans-unit id="5b40364d3cb3cca7f44236a76dfee86aa086098b" translate="yes" xml:space="preserve">
          <source>Chebyshev.truncate()</source>
          <target state="translated">Chebyshev.truncate()</target>
        </trans-unit>
        <trans-unit id="fa3b88952bbad94e7ad3a8b4bc8351fab6c23f70" translate="yes" xml:space="preserve">
          <source>Check Environment Variables</source>
          <target state="translated">環境変数のチェック</target>
        </trans-unit>
        <trans-unit id="0f1c2f66e836ebaf2af3cc3e88ba49176e5fc5ef" translate="yes" xml:space="preserve">
          <source>Check deprecations</source>
          <target state="translated">非推奨事項のチェック</target>
        </trans-unit>
        <trans-unit id="68b29a44de315b426add922aecd8f169abef4bb9" translate="yes" xml:space="preserve">
          <source>Check for a complex type or an array of complex numbers.</source>
          <target state="translated">複素数型や複素数の配列をチェックします。</target>
        </trans-unit>
        <trans-unit id="4bce08324cf028acd33defa95adda2d8f712ca10" translate="yes" xml:space="preserve">
          <source>Check for availability of Fortran 77 compiler.</source>
          <target state="translated">Fortran 77コンパイラの空き状況を確認します。</target>
        </trans-unit>
        <trans-unit id="8dfb4b491ef798ee13273ce6b905820e38be579c" translate="yes" xml:space="preserve">
          <source>Check for availability of Fortran 90 compiler.</source>
          <target state="translated">Fortran 90 コンパイラの空き状況を確認します。</target>
        </trans-unit>
        <trans-unit id="fc680846edbe0485cdd86c89e2d8ba596476a1dd" translate="yes" xml:space="preserve">
          <source>Check if coefficients match.</source>
          <target state="translated">係数が一致するかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="d9700aa50368965f26007e9ef6dc12172f836968" translate="yes" xml:space="preserve">
          <source>Check if domains match.</source>
          <target state="translated">ドメインが一致するかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="7cda7e0160467a48240d75643f9aa9dd2aa8c3ec" translate="yes" xml:space="preserve">
          <source>Check if the array is Fortran contiguous but &lt;em&gt;not&lt;/em&gt; C contiguous.</source>
          <target state="translated">配列がFortranに隣接しているが&lt;em&gt;、&lt;/em&gt; Cに隣接してい&lt;em&gt;ない&lt;/em&gt;かどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="e7a996762c75a9633231bd44ab99dd3f19880ea7" translate="yes" xml:space="preserve">
          <source>Check if types match.</source>
          <target state="translated">タイプが一致するかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="8d606aa3664f58aff3cd51e12c1f4292532053db" translate="yes" xml:space="preserve">
          <source>Check if windows match.</source>
          <target state="translated">窓が一致しているかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="2fb7aaaa0fefc98b63923082fcb9b881a92a1f09" translate="yes" xml:space="preserve">
          <source>Check that all items of arrays differ in at most N Units in the Last Place.</source>
          <target state="translated">配列のすべての項目が、最後の場所で最大N個の単位で異なることを確認してください。</target>
        </trans-unit>
        <trans-unit id="85d78e2e46b343ac5d95f102decec7f3757fea05" translate="yes" xml:space="preserve">
          <source>Check that the files in &lt;code&gt;release/installers&lt;/code&gt; have the correct versions, then push the tag upstream:</source>
          <target state="translated">&lt;code&gt;release/installers&lt;/code&gt; ファイルのバージョンが正しいことを確認してから、タグをアップストリームにプッシュします。</target>
        </trans-unit>
        <trans-unit id="3d69ccd1b6fed474517fc60eaa1e007186d233c6" translate="yes" xml:space="preserve">
          <source>Check that the release notes are up-to-date.</source>
          <target state="translated">リリースノートが最新のものであることを確認してください。</target>
        </trans-unit>
        <trans-unit id="7eaa6b9db4d409e9c0e745dc239854957e8b786b" translate="yes" xml:space="preserve">
          <source>Check that the solution is correct:</source>
          <target state="translated">解答が正しいことを確認してください。</target>
        </trans-unit>
        <trans-unit id="5caf476aaa67e250b5bea0e66db1d7432b8de4e4" translate="yes" xml:space="preserve">
          <source>Check that what you are going to push looks sensible:</source>
          <target state="translated">押そうとしているものが良識的に見えるかどうかをチェックしましょう。</target>
        </trans-unit>
        <trans-unit id="4b9add170f60f16261046081b4697b7c84e7d44a" translate="yes" xml:space="preserve">
          <source>Check the C API version number</source>
          <target state="translated">C APIのバージョン番号を確認する</target>
        </trans-unit>
        <trans-unit id="b474fcfc20997061eb0dbec47b248cfc5e13a11e" translate="yes" xml:space="preserve">
          <source>Check the pre-release button if this is a pre-releases.</source>
          <target state="translated">これがプレリリースの場合は、プレリリースボタンにチェックを入れておきましょう。</target>
        </trans-unit>
        <trans-unit id="13767ae2c1bd8cf1174421496546f179c6e6b424" translate="yes" xml:space="preserve">
          <source>Check the release notes</source>
          <target state="translated">リリースノートを確認する</target>
        </trans-unit>
        <trans-unit id="abd3adad63a405998bb8027f9dd962bdd792cf51" translate="yes" xml:space="preserve">
          <source>Check to see if &lt;code&gt;ary&lt;/code&gt; is Fortran contiguous. If so, return the input pointer and flag it as not a new object. If it is not Fortran contiguous, create a new &lt;code&gt;PyArrayObject*&lt;/code&gt; using the original data, flag it as a new object and return the pointer.</source>
          <target state="translated">&lt;code&gt;ary&lt;/code&gt; がFortranに隣接しているかどうかを確認します。その場合、入力ポインタを返し、新しいオブジェクトではないことを示すフラグを立てます。Fortranで隣接していない場合は、元のデータを使用して新しい &lt;code&gt;PyArrayObject*&lt;/code&gt; を作成し、それを新しいオブジェクトとしてフラグを立てて、ポインターを返します。</target>
        </trans-unit>
        <trans-unit id="6deabec9ba29d971d99676bd19f94bb36aab8ebd" translate="yes" xml:space="preserve">
          <source>Check to see if &lt;code&gt;ary&lt;/code&gt; is contiguous. If so, return the input pointer and flag it as not a new object. If it is not contiguous, create a new &lt;code&gt;PyArrayObject*&lt;/code&gt; using the original data, flag it as a new object and return the pointer.</source>
          <target state="translated">&lt;code&gt;ary&lt;/code&gt; が連続しているかどうかを確認します。その場合、入力ポインタを返し、新しいオブジェクトではないことを示すフラグを立てます。連続していない場合は、元のデータを使用して新しい &lt;code&gt;PyArrayObject*&lt;/code&gt; を作成し、新しいオブジェクトとしてフラグを立てて、ポインターを返します。</target>
        </trans-unit>
        <trans-unit id="7093331a27bd647ef152d8be9e2ae4a45e799c24" translate="yes" xml:space="preserve">
          <source>Check whether iterations are left, and perform a single internal iteration without returning the result.</source>
          <target state="translated">イテレーションが残っているかどうかを確認し、結果を返さずに内部で1回のイテレーションを実行します。</target>
        </trans-unit>
        <trans-unit id="4144c2e0e789ff4e5b95e42eba75f165eee47a48" translate="yes" xml:space="preserve">
          <source>Check whether iterations are left, and perform a single internal iteration without returning the result. Used in the C-style pattern do-while pattern. For an example, see &lt;a href=&quot;numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">反復が残っているかどうかを確認し、結果を返さずに単一の内部反復を実行します。Cスタイルのパターンのdo-whileパターンで使用されます。例については、&lt;a href=&quot;numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ed69b345e7c215832e51813de9d917baa4aa81d3" translate="yes" xml:space="preserve">
          <source>Check whether other does not equal self elementwise.</source>
          <target state="translated">その他が要素的に自己と等しくないかどうかを確認してください。</target>
        </trans-unit>
        <trans-unit id="a3d82cd61f57b9f18ee0eb4fb316060ba43247d8" translate="yes" xml:space="preserve">
          <source>Check whether other equals self elementwise.</source>
          <target state="translated">他が自己要素に等しいかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="434cdb1d625c09ab1050578e35a57522602ea24b" translate="yes" xml:space="preserve">
          <source>Checking the API Version</source>
          <target state="translated">APIのバージョンを確認する</target>
        </trans-unit>
        <trans-unit id="938faf2c9d435685fe655f2c37238cf2efba6e4c" translate="yes" xml:space="preserve">
          <source>Checking whether two arrays share memory is NP-complete, and runtime may increase exponentially in the number of dimensions. Hence, &lt;code&gt;max_work&lt;/code&gt; should generally be set to a finite number, as it is possible to construct examples that take extremely long to run:</source>
          <target state="translated">2つのアレイがメモリを共有するかどうかのチェックはNP完全であり、実行時間は次元数で指数関数的に増加する可能性があります。したがって、実行に非常に長い時間がかかる例を作成する可能性があるため、 &lt;code&gt;max_work&lt;/code&gt; は一般に有限数に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="3d5c81d84347f45939c3f87f353382248652d10c" translate="yes" xml:space="preserve">
          <source>Checkout master and forward port the documentation changes:</source>
          <target state="translated">マスターをチェックアウトし、ドキュメントの変更を転送します。</target>
        </trans-unit>
        <trans-unit id="2399d5909395b34e8a1bce7efc3302c9102efa33" translate="yes" xml:space="preserve">
          <source>Checkout the branch for the release, make sure it is up to date, and clean the repository:</source>
          <target state="translated">リリース用のブランチをチェックアウトして、それが最新のものであることを確認し、リポジトリをクリーンアップします。</target>
        </trans-unit>
        <trans-unit id="283049748626c9020e205907bb7476f70c9b37e7" translate="yes" xml:space="preserve">
          <source>Checks to see whether this is the first time the elements of the specified reduction operand which the iterator points at are being seen for the first time. The function returns a reasonable answer for reduction operands and when buffering is disabled. The answer may be incorrect for buffered non-reduction operands.</source>
          <target state="translated">イテレータが指す指定された縮小オペランドの要素が初めて見られるかどうかをチェックします。この関数は、リダクションオペランドの場合と、バッファリングが無効な場合には、妥当な答えを返します。バッファリングされていない縮小オペランドの場合は、正しくない場合があります。</target>
        </trans-unit>
        <trans-unit id="aa157d59451a76fbaaa96b55717e70ff4070a919" translate="yes" xml:space="preserve">
          <source>Chhikara, Raj S., and Folks, J. Leroy, &amp;ldquo;The Inverse Gaussian Distribution: Theory : Methodology, and Applications&amp;rdquo;, CRC Press, 1988.</source>
          <target state="translated">Chhikara、Raj S.、およびFolks、J。Leroy、「逆ガウス分布：理論：方法論、および応用」、CRC Press、1988。</target>
        </trans-unit>
        <trans-unit id="fdf0f4fddeb5edfe094f89b612af6bf23fbbf5d9" translate="yes" xml:space="preserve">
          <source>Child &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; objects can also spawn to make grandchildren, and so on. Each &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; has its position in the tree of spawned &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; objects mixed in with the user-provided seed to generate independent (with very high probability) streams.</source>
          <target state="translated">Child &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;オブジェクトは、孫を作成するためにスポーンすることもできます。各&lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;は、独立した（非常に高い確率で）ストリームを生成するために、ユーザーが指定したシードと混合された、生成された&lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;オブジェクトのツリー内での位置を持っています。</target>
        </trans-unit>
        <trans-unit id="3a10cdc107364498984b83536b7e81520a19b878" translate="yes" xml:space="preserve">
          <source>Choice arrays. &lt;code&gt;a&lt;/code&gt; and all of the choices must be broadcastable to the same shape. If &lt;code&gt;choices&lt;/code&gt; is itself an array (not recommended), then its outermost dimension (i.e., the one corresponding to &lt;code&gt;choices.shape[0]&lt;/code&gt;) is taken as defining the &amp;ldquo;sequence&amp;rdquo;.</source>
          <target state="translated">選択肢の配列。 &lt;code&gt;a&lt;/code&gt; とすべての選択肢は、同じ形で放送可能でなければなりません。 &lt;code&gt;choices&lt;/code&gt; 自体が配列である場合（非推奨）、その最も外側の次元（つまり、 &lt;code&gt;choices.shape[0]&lt;/code&gt; 対応する次元）が「シーケンス」を定義していると見なされます。</target>
        </trans-unit>
        <trans-unit id="5ad7147824c2ea94d6560122c459caa4f4c34051" translate="yes" xml:space="preserve">
          <source>Choice arrays. The index array and all of the choices should be broadcastable to the same shape.</source>
          <target state="translated">選択肢の配列。インデックス配列とすべての選択肢は、同じ形状にブロードキャスト可能なものでなければなりません。</target>
        </trans-unit>
        <trans-unit id="dd2f912583e24992ccf957c7cba350640486480d" translate="yes" xml:space="preserve">
          <source>Choices in brackets, default first when optional.</source>
          <target state="translated">括弧内の選択肢は、オプションの場合はデフォルトで最初に表示されます。</target>
        </trans-unit>
        <trans-unit id="2767cec7ad20032475822095cbe0813732009259" translate="yes" xml:space="preserve">
          <source>Cholesky decompose a banded Hermitian positive-definite matrix.</source>
          <target state="translated">コレスキーは帯状のエルミティア正定値行列を分解します。</target>
        </trans-unit>
        <trans-unit id="71912e57e25688eeffa7fea1751238fb822cd096" translate="yes" xml:space="preserve">
          <source>Cholesky decomposition of a matrix, to use in &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.cho_solve.html#scipy.linalg.cho_solve&quot;&gt;&lt;code&gt;scipy.linalg.cho_solve&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.cho_solve.html#scipy.linalg.cho_solve&quot;&gt; &lt;code&gt;scipy.linalg.cho_solve&lt;/code&gt; で&lt;/a&gt;使用する行列のコレスキー分解。</target>
        </trans-unit>
        <trans-unit id="3423d9c2caf056a50af1e5e388fbc351b162a74e" translate="yes" xml:space="preserve">
          <source>Cholesky decomposition.</source>
          <target state="translated">コレスキー分解。</target>
        </trans-unit>
        <trans-unit id="12973bc24b90d6422a6f6089fc22e3ce9dfde18a" translate="yes" xml:space="preserve">
          <source>Choose &lt;code&gt;nsample&lt;/code&gt; items at random without replacement from a collection with &lt;code&gt;N&lt;/code&gt; distinct types. &lt;code&gt;N&lt;/code&gt; is the length of &lt;code&gt;colors&lt;/code&gt;, and the values in &lt;code&gt;colors&lt;/code&gt; are the number of occurrences of that type in the collection. The total number of items in the collection is &lt;code&gt;sum(colors)&lt;/code&gt;. Each random variate generated by this function is a vector of length &lt;code&gt;N&lt;/code&gt; holding the counts of the different types that occurred in the &lt;code&gt;nsample&lt;/code&gt; items.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 個の異なるタイプのコレクションから、置換せずにランダムに &lt;code&gt;nsample&lt;/code&gt; アイテムを選択します。 &lt;code&gt;N&lt;/code&gt; はの長さである &lt;code&gt;colors&lt;/code&gt; 、およびの値 &lt;code&gt;colors&lt;/code&gt; コレクション内のそのタイプの出現回数です。コレクション内のアイテムの総数は &lt;code&gt;sum(colors)&lt;/code&gt; です。この関数によって生成される各確率変数は、 &lt;code&gt;nsample&lt;/code&gt; アイテムで発生したさまざまなタイプのカウントを保持する長さ &lt;code&gt;N&lt;/code&gt; のベクトルです。</target>
        </trans-unit>
        <trans-unit id="2ca2864418456f81d23c002bcfa240f2d8fca295" translate="yes" xml:space="preserve">
          <source>Choose five random numbers from the set of five evenly-spaced numbers between 0 and 2.5, inclusive (&lt;em&gt;i.e.&lt;/em&gt;, from the set</source>
          <target state="translated">0〜2.5の5つの等間隔の数字のセットから5つの乱数を選択します（&lt;em&gt;つまり&lt;/em&gt;、セットから）</target>
        </trans-unit>
        <trans-unit id="35c9a25e2ab923acd6164ad4d06282c1e090295d" translate="yes" xml:space="preserve">
          <source>Choose the type of path. If a tuple is provided, the second argument is assumed to be the maximum intermediate size created. If only a single argument is provided the largest input or output array size is used as a maximum intermediate size.</source>
          <target state="translated">パスの種類を選択します。タプルが提供された場合、第2引数は作成された最大の中間サイズと見なされます。単一の引数のみを指定した場合は、最大の入力配列または出力配列のサイズが最大の中間サイズとして使用されます。</target>
        </trans-unit>
        <trans-unit id="d477c0a201a1ecd6208acd5e9d6a705b45b36661" translate="yes" xml:space="preserve">
          <source>Choosing the data type</source>
          <target state="translated">データ型の選択</target>
        </trans-unit>
        <trans-unit id="fd3c5dfb5fbf5ecce869e29e990a70ecfaa87d5e" translate="yes" xml:space="preserve">
          <source>Choosing the fortran compiler</source>
          <target state="translated">fortranコンパイラの選択</target>
        </trans-unit>
        <trans-unit id="6410e1ff6dea4bdf660fd03e09261c2e8c92a4a7" translate="yes" xml:space="preserve">
          <source>Christian Kleiber, Samuel Kotz, &amp;ldquo;Statistical size distributions in economics and actuarial sciences&amp;rdquo;, Wiley, 2003.</source>
          <target state="translated">クリスチャンクライバー、サミュエルコッツ、「経済学と保険数理科学における統計的サイズ分布」、ワイリー、2003年。</target>
        </trans-unit>
        <trans-unit id="16460b81f71899d57eec8f9481e7178ad88e85b9" translate="yes" xml:space="preserve">
          <source>Chuck Harris</source>
          <target state="translated">チャックハリス</target>
        </trans-unit>
        <trans-unit id="699bc38ae6b089e1e0d8975a9f6a7f01d31c2f18" translate="yes" xml:space="preserve">
          <source>Circular padding. Outside bounds values will be as if the array was repeated. For example, for the array [1, 2, 3, 4], x[-2] will be 3, x[-2] will be 4, x[4] will be 1, x[5] will be 2, etc&amp;hellip;</source>
          <target state="translated">円形のパディング。範囲外の値は、配列が繰り返されたかのようになります。たとえば、配列[1、2、3、4]の場合、x [-2]は3になり、x [-2]は4になり、x [4]は1になり、x [5]は2になります。等&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="eedc46b2680ee864ce515307f6a3ce30df0bb9e4" translate="yes" xml:space="preserve">
          <source>Cite the relevant literature, e.g. &lt;a href=&quot;#ree6d1ec14498-1&quot; id=&quot;id4&quot;&gt;[1]&lt;/a&gt;. You may also cite these references in the notes section above.</source>
          <target state="translated">関連する文献を引用して&lt;a href=&quot;#ree6d1ec14498-1&quot; id=&quot;id4&quot;&gt;ください&lt;/a&gt;。例：[1]。上記の注記セクションでこれらの参照を引用することもできます。</target>
        </trans-unit>
        <trans-unit id="1e1a4f85c2ba4fe59c5c1669b393d40791072c87" translate="yes" xml:space="preserve">
          <source>Class docstring</source>
          <target state="translated">クラスのdocstring</target>
        </trans-unit>
        <trans-unit id="e799166bb71b4dde11ab28b58f6eff13ee75f067" translate="yes" xml:space="preserve">
          <source>Class for one-dimensional polynomials.</source>
          <target state="translated">一次元多項式のクラス。</target>
        </trans-unit>
        <trans-unit id="141f83ee32f213c3c3e30b940039c0256ca45642" translate="yes" xml:space="preserve">
          <source>Class from which most (all?) numpy scalar types are derived. For consistency, exposes the same API as &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, despite many consequent attributes being either &amp;ldquo;get-only,&amp;rdquo; or completely irrelevant. This is the class from which it is strongly suggested users should derive custom scalar types.</source>
          <target state="translated">ほとんどの（すべて？）numpyスカラー型の派生元のクラス。一貫性のために、多くの結果として生じる属性が「取得専用」または完全に無関係であるにもかかわらず、&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;と同じAPIを公開します。これは、ユーザーがカスタムスカラー型を派生することを強くお勧めするクラスです。</target>
        </trans-unit>
        <trans-unit id="f3a9c0c7155c7f2627130b00e8664e0c47570c98" translate="yes" xml:space="preserve">
          <source>Class generic exists solely to derive numpy scalars from, and possesses, albeit unimplemented, all the attributes of the ndarray class so as to provide a uniform API.</source>
          <target state="translated">genericクラスはnumpyスカラからnumpyスカラを導出するためだけに存在し、未実装ではありますが、統一されたAPIを提供するためにndarrayクラスのすべての属性を持っています。</target>
        </trans-unit>
        <trans-unit id="50af8b2f53e369e6ce37192f4f707fa498a94b5e" translate="yes" xml:space="preserve">
          <source>Class instance.</source>
          <target state="translated">クラスのインスタンス。</target>
        </trans-unit>
        <trans-unit id="2785358c74196dd17652dd76c2cb1f0e3a27dcf4" translate="yes" xml:space="preserve">
          <source>Class of the underlying data (read-only).</source>
          <target state="translated">基礎となるデータのクラス(読み取り専用)。</target>
        </trans-unit>
        <trans-unit id="631eda8579e2970ff77106029d682f1124ccd882" translate="yes" xml:space="preserve">
          <source>Class to convert formats, names, titles description to a dtype.</source>
          <target state="translated">フォーマット、名前、タイトルの説明をdtypeに変換するクラスです。</target>
        </trans-unit>
        <trans-unit id="70956031e8aba40d5608418084c786b47da059e0" translate="yes" xml:space="preserve">
          <source>Class whose methods to decorate.</source>
          <target state="translated">メソッドが装飾するクラス。</target>
        </trans-unit>
        <trans-unit id="ed1846afee3be21521286932b99e2aeae9e6414a" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">Classes</target>
        </trans-unit>
        <trans-unit id="94a0e1eeea610589ba223c0aebbf56c35a8d5343" translate="yes" xml:space="preserve">
          <source>Classes (including ndarray subclasses) can override how ufuncs act on them by defining certain special methods. For details, see &lt;a href=&quot;arrays.classes#arrays-classes&quot;&gt;Standard array subclasses&lt;/a&gt;.</source>
          <target state="translated">クラス（ndarrayサブクラスを含む）は、特定の特別なメソッドを定義することにより、それらに対するufuncの動作をオーバーライドできます。詳細については、&lt;a href=&quot;arrays.classes#arrays-classes&quot;&gt;標準配列サブクラスを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="39dc77f987229934cc60ecfa0809fc0d18f916fd" translate="yes" xml:space="preserve">
          <source>Classes specifying the information to be printed are defined in the &lt;code&gt;numpy.distutils.system_info&lt;/code&gt; module.</source>
          <target state="translated">印刷する情報を指定するクラスは、 &lt;code&gt;numpy.distutils.system_info&lt;/code&gt; モジュールで定義されています。</target>
        </trans-unit>
        <trans-unit id="70c66297b049e0748e33bac4e4aa71b028603811" translate="yes" xml:space="preserve">
          <source>Clear and severe breach actions</source>
          <target state="translated">明確で厳しい違反行為</target>
        </trans-unit>
        <trans-unit id="0716551020b700fbc40d6da11a6a973469d6550e" translate="yes" xml:space="preserve">
          <source>Clear the IEEE error flags.</source>
          <target state="translated">IEEEエラーフラグをクリアします。</target>
        </trans-unit>
        <trans-unit id="93188aa17cfb01f09e7b90afbdf16a0d09c57e22" translate="yes" xml:space="preserve">
          <source>Clearly, the signature of &lt;code&gt;fib2.fib&lt;/code&gt; now corresponds to the intention of Fortran subroutine &lt;code&gt;FIB&lt;/code&gt; more closely: given the number &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;fib2.fib&lt;/code&gt; returns the first &lt;code&gt;n&lt;/code&gt; Fibonacci numbers as a NumPy array. Also, the new Python signature &lt;code&gt;fib2.fib&lt;/code&gt; rules out any surprises that we experienced with &lt;code&gt;fib1.fib&lt;/code&gt;.</source>
          <target state="translated">明らかに、 &lt;code&gt;fib2.fib&lt;/code&gt; の署名は、Fortranサブルーチン &lt;code&gt;FIB&lt;/code&gt; の意図にさらに厳密に対応しています。数値 &lt;code&gt;n&lt;/code&gt; が与えられると、 &lt;code&gt;fib2.fib&lt;/code&gt; は最初の &lt;code&gt;n&lt;/code&gt; 個のフィボナッチ数をNumPy配列として返します。また、新しいPythonシグネチャ &lt;code&gt;fib2.fib&lt;/code&gt; は、 &lt;code&gt;fib1.fib&lt;/code&gt; で発生した驚きを排除します。</target>
        </trans-unit>
        <trans-unit id="d54d8ffb592fd7551eb0fff09b91b8b03d14a55e" translate="yes" xml:space="preserve">
          <source>Clearly, this is not an expected behaviour. The fact that the above example worked with &lt;code&gt;dtype=float&lt;/code&gt; is considered accidental.</source>
          <target state="translated">明らかに、これは予期された動作ではありません。上記の例が &lt;code&gt;dtype=float&lt;/code&gt; で機能したという事実は、偶然と見なされます。</target>
        </trans-unit>
        <trans-unit id="69cde09c8e5adab6b0a10f29c8e8089827660cd3" translate="yes" xml:space="preserve">
          <source>Clears the floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reodering this function call. Returns the previous status mask.</source>
          <target state="translated">浮動小数点の状態をクリアします。ローカル変数へのポインタが渡され、コンパイラの最適化がこの関数呼び出しを再編集するのを防ぐために、ローカル変数へのポインタが渡されます。前のステータス・マスクを返します。</target>
        </trans-unit>
        <trans-unit id="ed1f9109b874431402e7e242d58614b8508e6754" translate="yes" xml:space="preserve">
          <source>Clears the floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reordering this function call. Returns the previous status mask.</source>
          <target state="translated">浮動小数点の状態をクリアします。ローカル変数へのポインタが渡され、コンパイラの最適化がこの関数呼び出しの順序を変更しないようにします。前のステータス・マスクを返します。</target>
        </trans-unit>
        <trans-unit id="85631dab84756553305933ab9884fa05e7033c9b" translate="yes" xml:space="preserve">
          <source>Clears the floating point status. Returns the previous status mask.</source>
          <target state="translated">浮動小数点ステータスをクリアします。前のステータスマスクを返します。</target>
        </trans-unit>
        <trans-unit id="95fd8bb886c035e55cfc935aa6369ec4437d9dba" translate="yes" xml:space="preserve">
          <source>Clears the specified array flags. This function does no validation, and assumes that you know what you&amp;rsquo;re doing.</source>
          <target state="translated">指定された配列フラグをクリアします。この関数は検証を行わず、ユーザーが何をしているかを理解していることを前提としています。</target>
        </trans-unit>
        <trans-unit id="87a966bc3a0e8b49349f2e74d267c1202d21bb69" translate="yes" xml:space="preserve">
          <source>Click on the &amp;lsquo;Admin&amp;rsquo; button, and add anyone else to the repo as a collaborator:</source>
          <target state="translated">[管理者]ボタンをクリックして、他のユーザーを共同編集者としてリポジトリに追加します。</target>
        </trans-unit>
        <trans-unit id="b202685281d47a327156e53f1a2165efd9cbfc91" translate="yes" xml:space="preserve">
          <source>Click on the &lt;em&gt;fork&lt;/em&gt; button:</source>
          <target state="translated">&lt;em&gt;フォーク&lt;/em&gt;ボタンをクリックします。</target>
        </trans-unit>
        <trans-unit id="0259cd63a54e3479014d0b233265a7cb8a0c929d" translate="yes" xml:space="preserve">
          <source>Clip (limit) the values in an array.</source>
          <target state="translated">配列内の値をクリップ(制限)します。</target>
        </trans-unit>
        <trans-unit id="10b5f7285e869f556c319cd6389b16c1806e6590" translate="yes" xml:space="preserve">
          <source>Clipping and rounding</source>
          <target state="translated">切り抜きと丸め</target>
        </trans-unit>
        <trans-unit id="01110fe45ef307b0f0fc59a0a0494616ad2d9d3c" translate="yes" xml:space="preserve">
          <source>Clips an index to the valid range if it is out of bounds.</source>
          <target state="translated">圏外の場合は、インデックスを有効な範囲にクリップします。</target>
        </trans-unit>
        <trans-unit id="179755c100537d42883bc546a8caf3a46a35f567" translate="yes" xml:space="preserve">
          <source>Clone the project to your local computer:</source>
          <target state="translated">プロジェクトをローカルコンピュータにクローンします。</target>
        </trans-unit>
        <trans-unit id="5b64cfe6be1411cd7fe0a76e5fb94142fcfb5262" translate="yes" xml:space="preserve">
          <source>Clone your fork</source>
          <target state="translated">フォークのクローンを作る</target>
        </trans-unit>
        <trans-unit id="38bf2a1eaa30b34536c51de1b9b8ffd3a598c4f8" translate="yes" xml:space="preserve">
          <source>Clone your fork to the local computer with &lt;code&gt;git clone
https://github.com/your-user-name/numpy.git&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git clone https://github.com/your-user-name/numpy.git&lt;/code&gt; 使用してフォークをローカルコンピューターに複製します</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="62f18e281cfc29d9c7a7fc86dddda134af4ea798" translate="yes" xml:space="preserve">
          <source>Code lay-out</source>
          <target state="translated">コードレイアウト</target>
        </trans-unit>
        <trans-unit id="4cda7c9faa3b5335f012c53a4a45daebecabe9c2" translate="yes" xml:space="preserve">
          <source>Code maintenance and development</source>
          <target state="translated">コードのメンテナンスと開発</target>
        </trans-unit>
        <trans-unit id="4c6d56aa06140201b957d61e514a687a45637be2" translate="yes" xml:space="preserve">
          <source>Code segment showing the &amp;ldquo;can cast safely&amp;rdquo; table for a 32-bit system.</source>
          <target state="translated">32ビットシステムの「安全にキャストできる」テーブルを示すコードセグメント。</target>
        </trans-unit>
        <trans-unit id="6acd82038060af5c738afabbce906304f6a33338" translate="yes" xml:space="preserve">
          <source>Code segment showing the &amp;ldquo;can cast safely&amp;rdquo; table for a 64-bit system. Generally the output depends on the system; your system might result in a different table.</source>
          <target state="translated">64ビットシステムの「安全にキャストできる」テーブルを示すコードセグメント。通常、出力はシステムによって異なります。システムによって異なるテーブルが作成される場合があります。</target>
        </trans-unit>
        <trans-unit id="9f6f12146c68ac2d13434f01199bc89b65cb5d95" translate="yes" xml:space="preserve">
          <source>Code structure: one space between keywords like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; and the following left parenthesis; no spaces inside the parenthesis; braces around all &lt;code&gt;if&lt;/code&gt; branches and no statements on the same line as the &lt;code&gt;if&lt;/code&gt;. They should be formatted as shown:</source>
          <target state="translated">コード構造： &lt;code&gt;if&lt;/code&gt; 、 &lt;code&gt;for&lt;/code&gt; などのキーワードと次の左括弧の間に1つのスペース。括弧内にスペースはありません。すべての &lt;code&gt;if&lt;/code&gt; ブランチを中括弧で囲み、 &lt;code&gt;if&lt;/code&gt; と同じ行にステートメントを配置しません。次のようにフォーマットする必要があります。</target>
        </trans-unit>
        <trans-unit id="4880c50f2ea2d547641da09b4c0bf604cbaad4e6" translate="yes" xml:space="preserve">
          <source>Coefficient array of the integral.</source>
          <target state="translated">積分の係数配列。</target>
        </trans-unit>
        <trans-unit id="90095bbe595b4717b5f28520d7191bc7b67d082b" translate="yes" xml:space="preserve">
          <source>Coefficient matrix.</source>
          <target state="translated">係数行列。</target>
        </trans-unit>
        <trans-unit id="7ff4e0921ad16edc7282af8e661233be9efdef85" translate="yes" xml:space="preserve">
          <source>Coefficient tensor, of shape &lt;code&gt;b.shape + Q&lt;/code&gt;. &lt;code&gt;Q&lt;/code&gt;, a tuple, equals the shape of that sub-tensor of &lt;code&gt;a&lt;/code&gt; consisting of the appropriate number of its rightmost indices, and must be such that &lt;code&gt;prod(Q) == prod(b.shape)&lt;/code&gt; (in which sense &lt;code&gt;a&lt;/code&gt; is said to be &amp;lsquo;square&amp;rsquo;).</source>
          <target state="translated">形状 &lt;code&gt;b.shape + Q&lt;/code&gt; 係数テンソル。タプルである &lt;code&gt;Q&lt;/code&gt; は、その右端のインデックスの適切な数で構成される &lt;code&gt;a&lt;/code&gt; のそのサブテンソルの形状に等しく、 &lt;code&gt;prod(Q) == prod(b.shape)&lt;/code&gt; （ &lt;code&gt;a&lt;/code&gt; は、 「正方形」であること）。</target>
        </trans-unit>
        <trans-unit id="6f7d7eca3d654d7516012e0321be8d2b34b3af6d" translate="yes" xml:space="preserve">
          <source>Coefficients, including those equal to zero, of the quotient.</source>
          <target state="translated">商の係数(ゼロに等しいものを含む)。</target>
        </trans-unit>
        <trans-unit id="b57ec6a0b2d77f8f2ef4d5e927f014b094bd79db" translate="yes" xml:space="preserve">
          <source>Coefficients, including those equal to zero, of the remainder.</source>
          <target state="translated">ゼロに等しいものを含む、余剰の係数。</target>
        </trans-unit>
        <trans-unit id="3c2fcb20e68435f85b762cfd1d987d2533770ffc" translate="yes" xml:space="preserve">
          <source>Collapsed to a one-dimensional array. See &lt;a href=&quot;reference/generated/numpy.ndarray.flatten#numpy.ndarray.flatten&quot;&gt;&lt;code&gt;numpy.ndarray.flatten&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">1次元配列に折りたたまれています。詳細については、&lt;a href=&quot;reference/generated/numpy.ndarray.flatten#numpy.ndarray.flatten&quot;&gt; &lt;code&gt;numpy.ndarray.flatten&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="41175d152a9f45e2d3d903913dcac5478e50c120" translate="yes" xml:space="preserve">
          <source>Collection of utilities to manipulate structured arrays.</source>
          <target state="translated">構造化配列を操作するためのユーティリティのコレクション。</target>
        </trans-unit>
        <trans-unit id="99b2f68944ffe47fe2c86e737221636b3c8e81e8" translate="yes" xml:space="preserve">
          <source>Column-major order is also known as the Fortran order, as the Fortran programming language uses it.</source>
          <target state="translated">コラム・メジャーオーダーは、Fortranプログラミング言語が使用していることから、Fortranオーダーとも呼ばれています。</target>
        </trans-unit>
        <trans-unit id="3a433dc0365548604b9b44d97f7bfbf6e88d77aa" translate="yes" xml:space="preserve">
          <source>Combination of &lt;a href=&quot;#c.PyArray_FROM_OF&quot;&gt;&lt;code&gt;PyArray_FROM_OF&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.PyArray_FROM_OT&quot;&gt;&lt;code&gt;PyArray_FROM_OT&lt;/code&gt;&lt;/a&gt; allowing both a &lt;em&gt;typenum&lt;/em&gt; and a &lt;em&gt;flags&lt;/em&gt; argument to be provided.</source>
          <target state="translated">組み合わせ&lt;a href=&quot;#c.PyArray_FROM_OF&quot;&gt; &lt;code&gt;PyArray_FROM_OF&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#c.PyArray_FROM_OT&quot;&gt; &lt;code&gt;PyArray_FROM_OT&lt;/code&gt; が&lt;/a&gt;両方可能&lt;em&gt;typenum&lt;/em&gt;と&lt;em&gt;フラグ&lt;/em&gt;引数が提供されます。</target>
        </trans-unit>
        <trans-unit id="1825a72b8523c42869f6ed18e25b4d98c6db9809" translate="yes" xml:space="preserve">
          <source>Combinations of array flags</source>
          <target state="translated">配列フラグの組み合わせ</target>
        </trans-unit>
        <trans-unit id="003eeb3cc5852db3801153f1b44bcb67c74144f5" translate="yes" xml:space="preserve">
          <source>Combine the commits &lt;code&gt;2dec1ac&lt;/code&gt;, &lt;code&gt;a815645&lt;/code&gt;, &lt;code&gt;eadc391&lt;/code&gt; into a single one.</source>
          <target state="translated">コミット &lt;code&gt;2dec1ac&lt;/code&gt; 、 &lt;code&gt;a815645&lt;/code&gt; 、 &lt;code&gt;eadc391&lt;/code&gt; を1つに結合します。</target>
        </trans-unit>
        <trans-unit id="04f619e0125978268f6037fab0f4bee54fa7538a" translate="yes" xml:space="preserve">
          <source>Combine two masks with the &lt;code&gt;logical_or&lt;/code&gt; operator.</source>
          <target state="translated">2つのマスクを &lt;code&gt;logical_or&lt;/code&gt; 演算子で結合します。</target>
        </trans-unit>
        <trans-unit id="ac4e580a3225536b502c2bf6b739b38d8c6dc235" translate="yes" xml:space="preserve">
          <source>Combining advanced and basic indexing</source>
          <target state="translated">高度なインデックスと基本的なインデックスの組み合わせ</target>
        </trans-unit>
        <trans-unit id="127ce4975a7080b5ec675c2982d4f6e8310b7283" translate="yes" xml:space="preserve">
          <source>Combining index arrays with slices</source>
          <target state="translated">インデックス配列とスライスを組み合わせる</target>
        </trans-unit>
        <trans-unit id="6db9979c1fe0813b3eb2ee3a9a6ae24f7e5faea6" translate="yes" xml:space="preserve">
          <source>Combining multiple Boolean indexing arrays or a Boolean with an integer indexing array can best be understood with the &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;obj.nonzero()&lt;/code&gt;&lt;/a&gt; analogy. The function &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; also supports boolean arrays and will work without any surprises.</source>
          <target state="translated">複数のブールインデックス配列またはブールと整数インデックス配列を組み合わせることは、&lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt; &lt;code&gt;obj.nonzero()&lt;/code&gt; の&lt;/a&gt;アナロジーで最もよく理解できます。関数&lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt;はブール配列もサポートしており、驚くことなく動作します。</target>
        </trans-unit>
        <trans-unit id="48361d97c401e366adbd5368490fd7ba9e87a2ae" translate="yes" xml:space="preserve">
          <source>Comma Separated Value files (CSV) are widely used (and an export and import option for programs like Excel). There are a number of ways of reading these files in Python. There are CSV functions in Python and functions in pylab (part of matplotlib).</source>
          <target state="translated">カンマ区切り値ファイル(CSV)は広く使われています(Excelなどのプログラムのエクスポートやインポートのオプションもあります)。Pythonでこれらのファイルを読み込む方法はいくつかあります。PythonのCSV関数とpylab(matplotlibの一部)の関数があります。</target>
        </trans-unit>
        <trans-unit id="39a64d591310ffe84aa9b684771a7d278ba716a5" translate="yes" xml:space="preserve">
          <source>Comma delimited file with mixed dtype</source>
          <target state="translated">dtypeが混在するカンマ区切りファイル</target>
        </trans-unit>
        <trans-unit id="6a1f5ffc0ab313847c7fd16153c2c1f631a74c7f" translate="yes" xml:space="preserve">
          <source>Command &lt;code&gt;f2py&lt;/code&gt;</source>
          <target state="translated">コマンド &lt;code&gt;f2py&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a442ff47616055a09385f87492675eec3f89c3c" translate="yes" xml:space="preserve">
          <source>Comments go before the code they describe. Multi-line comments should be like so:</source>
          <target state="translated">コメントは記述するコードの前に行きます。複数行のコメントは次のようにします。</target>
        </trans-unit>
        <trans-unit id="84228a13dd8f0021fa36768dd176470923d0af72" translate="yes" xml:space="preserve">
          <source>Commit locally as you progress (&lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt;) Use a &lt;a href=&quot;development_workflow#writing-the-commit-message&quot;&gt;properly formatted&lt;/a&gt; commit message, write tests that fail before your change and pass afterward, run all the &lt;a href=&quot;development_environment#development-environment&quot;&gt;tests locally&lt;/a&gt;. Be sure to document any changed behavior in docstrings, keeping to the NumPy docstring &lt;a href=&quot;../docs/howto_document#howto-document&quot;&gt;standard&lt;/a&gt;.</source>
          <target state="translated">進行中にローカルでコミットします（ &lt;code&gt;git add&lt;/code&gt; および &lt;code&gt;git commit&lt;/code&gt; ）&lt;a href=&quot;development_workflow#writing-the-commit-message&quot;&gt;適切にフォーマットされた&lt;/a&gt;コミットメッセージを使用し、変更前に失敗して後で合格するテストを記述し、すべての&lt;a href=&quot;development_environment#development-environment&quot;&gt;テストをローカル&lt;/a&gt;で実行します。 NumPy docstring&lt;a href=&quot;../docs/howto_document#howto-document&quot;&gt;標準に準拠&lt;/a&gt;して、変更された動作をdocstringで文書化してください。</target>
        </trans-unit>
        <trans-unit id="0a32ce4cd17558c48ae2944590272943673a2335" translate="yes" xml:space="preserve">
          <source>Commit messages should be clear and follow a few basic rules. Example:</source>
          <target state="translated">コミットメッセージは明確で、いくつかの基本的なルールに従うべきです。例</target>
        </trans-unit>
        <trans-unit id="a8981cd8f439f881e61c62a6482ca86e9bb4de5a" translate="yes" xml:space="preserve">
          <source>Commit the result:</source>
          <target state="translated">結果をコミットします。</target>
        </trans-unit>
        <trans-unit id="47e4d165580c53bcc66b6184b36ff34e18c1fd45" translate="yes" xml:space="preserve">
          <source>Common ASCII Formats</source>
          <target state="translated">一般的なASCIIフォーマット</target>
        </trans-unit>
        <trans-unit id="f951af1137a01c272e20259ce69b92a33cbe2c01" translate="yes" xml:space="preserve">
          <source>Common block statements:</source>
          <target state="translated">一般的なブロック文。</target>
        </trans-unit>
        <trans-unit id="f108ad260d0dee041e2947d7bef1a1ab5f773f80" translate="yes" xml:space="preserve">
          <source>Common blocks</source>
          <target state="translated">共通ブロック</target>
        </trans-unit>
        <trans-unit id="67644de9822acbd842a9ed1592fafe3b76c5957a" translate="yes" xml:space="preserve">
          <source>Common reST concepts</source>
          <target state="translated">一般的なreSTの概念</target>
        </trans-unit>
        <trans-unit id="39a95105f6ae1d2c8ab5b77d2df7fa0bdc43b7b9" translate="yes" xml:space="preserve">
          <source>Common test support for all numpy test scripts.</source>
          <target state="translated">すべての numpy テストスクリプトで共通のテストをサポートします。</target>
        </trans-unit>
        <trans-unit id="ed80df7539525d1ebd0e5bb91694075d97aa07d4" translate="yes" xml:space="preserve">
          <source>Community coordination</source>
          <target state="translated">地域社会との連携</target>
        </trans-unit>
        <trans-unit id="c2a68a63dc41f356e6d15c8c535eea2cf026660b" translate="yes" xml:space="preserve">
          <source>Companion matrix of dimensions (deg, deg).</source>
          <target state="translated">次元(deg,deg)のコンパニオン行列。</target>
        </trans-unit>
        <trans-unit id="38428edac9ae2355adbd42053821bdf711ded835" translate="yes" xml:space="preserve">
          <source>Compare against built-in broadcasting:</source>
          <target state="translated">ビルトイン放送と比較してみてください。</target>
        </trans-unit>
        <trans-unit id="b2a60fa70e9171ad22b67932b73a6ceaa9b40830" translate="yes" xml:space="preserve">
          <source>Compare change in benchmark results to another version/commit/branch:</source>
          <target state="translated">ベンチマーク結果の変化を別のバージョン/コミット/ブランチと比較します。</target>
        </trans-unit>
        <trans-unit id="b5977dbb9726befd30db9317959bca3faeb91b26" translate="yes" xml:space="preserve">
          <source>Compare the power function distribution to the inverse of the Pareto.</source>
          <target state="translated">力関数分布をパレートの逆数と比較してみてください。</target>
        </trans-unit>
        <trans-unit id="abbe4b051440d5c3941fb5ca3a1c58883bee0b7d" translate="yes" xml:space="preserve">
          <source>Compare two array_like objects for equality with desired relative and/or absolute precision.</source>
          <target state="translated">2つのarray_likeオブジェクトを,希望する相対精度および/または絶対精度で比較します.</target>
        </trans-unit>
        <trans-unit id="6e9c538fcc856b4c5b41ccf954d897e3fba11150" translate="yes" xml:space="preserve">
          <source>Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated.</source>
          <target state="translated">2つの配列を比較し,要素ごとの最大値を含む新しい配列を返します.比較される要素の一方が NaN の場合,その要素が返されます.両方の要素がNaNであれば,最初の要素が返されます.後者の区別は,実部または虚部の少なくとも1つがNaNであると定義される複素数NaNにとって重要です.正味の効果は、NaNが伝播するということです。</target>
        </trans-unit>
        <trans-unit id="52e468afc192be1b2f72e0bc9d7f9f138350a871" translate="yes" xml:space="preserve">
          <source>Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then the non-nan element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are ignored when possible.</source>
          <target state="translated">2 つの配列を比較し,要素ごとの最大値を含む新しい配列を返します.比較される要素の一方が NaN の場合は,非 NaN の要素が返されます.両方の要素が NaN の場合は,最初の要素が返されます.後者の区別は,実部または虚部の少なくとも1つがNaNであると定義される複素数NaNにとって重要です.正味の効果は,可能な限りNaNを無視することです.</target>
        </trans-unit>
        <trans-unit id="ace9cb4b9063e509209a97ac371136964f6f7819" translate="yes" xml:space="preserve">
          <source>Compare two arrays and returns a new array containing the element-wise minima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated.</source>
          <target state="translated">2つの配列を比較し,要素ごとの最小値を含む新しい配列を返します.比較される要素の1つがNaNであれば,その要素が返されます.両方の要素がNaNであれば、最初の要素が返されます。後者の区別は,実部または虚部の少なくとも1つがNaNであると定義される複雑なNaNにとって重要です.正味の効果は、NaNが伝播するということです。</target>
        </trans-unit>
        <trans-unit id="89c593ddd4725e7eb3064d75c349a4174bbacd17" translate="yes" xml:space="preserve">
          <source>Compare two arrays and returns a new array containing the element-wise minima. If one of the elements being compared is a NaN, then the non-nan element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are ignored when possible.</source>
          <target state="translated">2つの配列を比較し,要素ごとの最小値を含む新しい配列を返します.比較される要素の片方が NaN の場合は,非 NaN の要素が返されます.両方の要素がNaNであれば,最初の要素が返されます.後者の区別は,実部または虚部の少なくとも1つがNaNであると定義される複素数NaNにとって重要です.正味の効果は,可能な限りNaNを無視することです.</target>
        </trans-unit>
        <trans-unit id="bc6a4145f838627dea20878218beb3ec59a9a475" translate="yes" xml:space="preserve">
          <source>Compare two arrays relatively to their spacing.</source>
          <target state="translated">2つの配列を相対的に比較します.</target>
        </trans-unit>
        <trans-unit id="3aa05ceaaca50383ae3aabbf2a41d83e5da1cd94" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.char.chararray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;code&gt;ndarray&lt;/code&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.char.chararray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.char.chararray.item#numpy.char.chararray.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="translated">インデックス構文と比較して、&lt;a href=&quot;#numpy.char.chararray.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt;は、これを行う必要がある場合に、スカラーを &lt;code&gt;ndarray&lt;/code&gt; の特定の場所に配置するための速度をいくらか向上させます。ただし、一般的にこれは推奨されません。他の問題の中でも、コードの外観が複雑になります。また、ループ内で&lt;a href=&quot;numpy.char.chararray.item#numpy.char.chararray.item&quot;&gt; &lt;code&gt;item&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#numpy.char.chararray.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt;（およびアイテム）を使用する場合は、ループの反復ごとに属性が検索されないように、必ずローカル変数にメソッドを割り当ててください。</target>
        </trans-unit>
        <trans-unit id="8520223908607ca37ab66be3e4ca795dd7020679" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.chararray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.chararray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.chararray.item#numpy.chararray.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="translated">インデックス構文と比較して、&lt;a href=&quot;#numpy.chararray.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt;は、これを行う必要がある場合に、スカラーを&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; の&lt;/a&gt;特定の場所に配置するための速度をいくらか向上させます。ただし、一般的にこれは推奨されません。他の問題の中でも、コードの外観が複雑になります。また、ループ内で&lt;a href=&quot;numpy.chararray.item#numpy.chararray.item&quot;&gt; &lt;code&gt;item&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#numpy.chararray.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt;（およびアイテム）を使用する場合は、ループの反復ごとに属性が検索されないように、必ずローカル変数にメソッドを割り当ててください。</target>
        </trans-unit>
        <trans-unit id="c0db5e8b47f9088d33c92f8b8df1d889c411c0de" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.ma.masked_array.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;code&gt;ndarray&lt;/code&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.ma.masked_array.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.ma.masked_array.item#numpy.ma.masked_array.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="translated">インデックス構文と比較して、&lt;a href=&quot;#numpy.ma.masked_array.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt;は、これを行う必要がある場合に、スカラーを &lt;code&gt;ndarray&lt;/code&gt; の特定の場所に配置するための速度をいくらか向上させます。ただし、一般的にこれは推奨されません。他の問題の中でも、コードの外観が複雑になります。また、ループ内で&lt;a href=&quot;numpy.ma.masked_array.item#numpy.ma.masked_array.item&quot;&gt; &lt;code&gt;item&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#numpy.ma.masked_array.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt;（およびアイテム）を使用する場合は、ループの反復ごとに属性が検索されないように、必ずローカル変数にメソッドを割り当ててください。</target>
        </trans-unit>
        <trans-unit id="38460977eefc5ad076607c73457ab20f90eef5d2" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.matrix.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.matrix.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.matrix.item#numpy.matrix.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="translated">索引付け構文と比較して、&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#numpy.matrix.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt;は、スカラーをndarrayの特定の場所に配置する必要がある場合に、これを高速化します。ただし、これは一般的にはお勧めできません。他の問題の中でも、コードの外観が複雑になります。また、ループ内で&lt;a href=&quot;#numpy.matrix.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt;（および&lt;a href=&quot;numpy.matrix.item#numpy.matrix.item&quot;&gt; &lt;code&gt;item&lt;/code&gt; &lt;/a&gt;）を使用する場合は、メソッドをローカル変数に割り当てて、ループの反復ごとに属性が検索されないようにしてください。</target>
        </trans-unit>
        <trans-unit id="ae8fffbb1016256e2544794348c439996df8510c" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.memmap.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.memmap.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.memmap.item#numpy.memmap.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="translated">インデックス構文と比較して、&lt;a href=&quot;#numpy.memmap.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt;は、これを行う必要がある場合に、スカラーを&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; の&lt;/a&gt;特定の場所に配置するための速度をいくらか向上させます。ただし、一般的にこれは推奨されません。他の問題の中でも、コードの外観が複雑になります。また、ループ内で&lt;a href=&quot;numpy.memmap.item#numpy.memmap.item&quot;&gt; &lt;code&gt;item&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#numpy.memmap.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt;（およびアイテム）を使用する場合は、ループの反復ごとに属性が検索されないように、必ずローカル変数にメソッドを割り当ててください。</target>
        </trans-unit>
        <trans-unit id="37a1ac805be872bfc7e003c20b71f2f1bbbc823c" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.ndarray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.ndarray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.ndarray.item#numpy.ndarray.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="translated">索引付け構文と比較して、&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#numpy.ndarray.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt;は、スカラーをndarrayの特定の場所に配置する必要がある場合に、これを高速化します。ただし、これは一般的にはお勧めできません。他の問題の中でも、コードの外観が複雑になります。また、ループ内で&lt;a href=&quot;#numpy.ndarray.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt;（および&lt;a href=&quot;numpy.ndarray.item#numpy.ndarray.item&quot;&gt; &lt;code&gt;item&lt;/code&gt; &lt;/a&gt;）を使用する場合は、メソッドをローカル変数に割り当てて、ループの反復ごとに属性が検索されないようにしてください。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
