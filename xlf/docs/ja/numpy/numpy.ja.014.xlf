<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="1f9c9c4e9b69dcd6586dbf80815cf3c44f18d220" translate="yes" xml:space="preserve">
          <source>Highlights</source>
          <target state="translated">Highlights</target>
        </trans-unit>
        <trans-unit id="00b07925679220cb801f1a4855d71039bbcccecc" translate="yes" xml:space="preserve">
          <source>Hiroshi Haramoto, Makoto Matsumoto, Takuji Nishimura, Fran&amp;ccedil;ois Panneton, Pierre L&amp;rsquo;Ecuyer, &amp;ldquo;Efficient Jump Ahead for F2-Linear Random Number Generators&amp;rdquo;, INFORMS JOURNAL ON COMPUTING, Vol. 20, No. 3, Summer 2008, pp. 385-390.</source>
          <target state="translated">原本博司、松本誠、西村拓司、フランソワ・パネトン、ピエール・レキュイエ、「F2線形乱数ジェネレータの効率的なジャンプ」、INFORMS JOURNAL ON COMPUTING、Vol。20、No。3、2008年夏、pp.385-390。</target>
        </trans-unit>
        <trans-unit id="5fb511a742639c34c53d07c644e43f8a516d0a8b" translate="yes" xml:space="preserve">
          <source>Hiroshi Haramoto, Makoto Matsumoto, and Pierre L&amp;rsquo;Ecuyer, &amp;ldquo;A Fast Jump Ahead Algorithm for Linear Recurrences in a Polynomial Space&amp;rdquo;, Sequences and Their Applications - SETA, 290&amp;ndash;298, 2008.</source>
          <target state="translated">原本博、松本眞、Pierre L'Ecuyer、「多項式空間における線形再発の高速ジャンプアヘッドアルゴリズム」、シーケンスとその応用-SETA、290&amp;ndash;298、2008年。</target>
        </trans-unit>
        <trans-unit id="f16459104f92ab6b38aa265adb4ecbfc3768e303" translate="yes" xml:space="preserve">
          <source>Histogram</source>
          <target state="translated">Histogram</target>
        </trans-unit>
        <trans-unit id="9f573dd516c5fae818d100652937d22c8be8a33c" translate="yes" xml:space="preserve">
          <source>Histograms</source>
          <target state="translated">Histograms</target>
        </trans-unit>
        <trans-unit id="4ae9938f95b0f1ddca2c84e6c590258bb6c7a2fc" translate="yes" xml:space="preserve">
          <source>Historically, NumPy has provided a special matrix type, &lt;code&gt;np.matrix&lt;/code&gt;, which is a subclass of ndarray which makes binary operations linear algebra operations. You may see it used in some existing code instead of &lt;code&gt;np.array&lt;/code&gt;. So, which one to use?</source>
          <target state="translated">歴史的に、NumPyは特別な行列型 &lt;code&gt;np.matrix&lt;/code&gt; を提供してきました。これは、二項演算を線形代数演算にするndarrayのサブクラスです。 &lt;code&gt;np.array&lt;/code&gt; の代わりにいくつかの既存のコードで使用されているのがわかるかもしれません。では、どちらを使用しますか？</target>
        </trans-unit>
        <trans-unit id="08c95aa82b69eff297d0839c133733de00ba649c" translate="yes" xml:space="preserve">
          <source>Hit the &lt;code&gt;{Publish,Update} release&lt;/code&gt; button at the bottom.</source>
          <target state="translated">下部にある &lt;code&gt;{Publish,Update} release&lt;/code&gt; ボタンを押します。</target>
        </trans-unit>
        <trans-unit id="34329cbed12573fba3127f8cc749498a60eadbb9" translate="yes" xml:space="preserve">
          <source>Hook in &lt;code&gt;numpy/__init__.py&lt;/code&gt; to run distribution-specific checks</source>
          <target state="translated">&lt;code&gt;numpy/__init__.py&lt;/code&gt; にフックして、ディストリビューション固有のチェックを実行します</target>
        </trans-unit>
        <trans-unit id="02f07bc7a75153468adfa0658b0fd2c34d3ff7ae" translate="yes" xml:space="preserve">
          <source>Horner&amp;rsquo;s scheme &lt;a href=&quot;#r138ee7027ddf-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is used to evaluate the polynomial. Even so, for polynomials of high degree the values may be inaccurate due to rounding errors. Use carefully.</source>
          <target state="translated">ホーナーのスキーム&lt;a href=&quot;#r138ee7027ddf-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;は、多項式の評価に使用されます。それでも、次数の高い多項式の場合、丸め誤差のために値が不正確になる可能性があります。慎重に使用してください。</target>
        </trans-unit>
        <trans-unit id="a0bb6d60bdafa1c8cd27af7d704ca6a159830aba" translate="yes" xml:space="preserve">
          <source>How Tos</source>
          <target state="translated">どのようにしてトス</target>
        </trans-unit>
        <trans-unit id="37544ef44c5ec43acf39ee75fa75aed3630c67b7" translate="yes" xml:space="preserve">
          <source>How can we pass our custom array type through this function? Numpy allows a class to indicate that it would like to handle computations in a custom-defined way through the interfaces &lt;code&gt;__array_ufunc__&lt;/code&gt; and &lt;code&gt;__array_function__&lt;/code&gt;. Let&amp;rsquo;s take one at a time, starting with &lt;code&gt;_array_ufunc__&lt;/code&gt;. This method covers &lt;a href=&quot;../reference/ufuncs#ufuncs&quot;&gt;Universal functions (ufunc)&lt;/a&gt;, a class of functions that includes, for example, &lt;a href=&quot;../reference/generated/numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;numpy.multiply&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.sin#numpy.sin&quot;&gt;&lt;code&gt;numpy.sin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数を介してカスタム配列型を渡すにはどうすればよいですか？ Numpyを使用すると、クラスは、インターフェイス &lt;code&gt;__array_ufunc__&lt;/code&gt; および &lt;code&gt;__array_function__&lt;/code&gt; を介してカスタム定義の方法で計算を処理することを示すことができます。 &lt;code&gt;_array_ufunc__&lt;/code&gt; から始めて、一度に1つずつ取り上げましょう。このメソッドは、&lt;a href=&quot;../reference/ufuncs#ufuncs&quot;&gt;ユニバーサル関数（ufunc）を&lt;/a&gt;カバーします。これは、たとえば&lt;a href=&quot;../reference/generated/numpy.multiply#numpy.multiply&quot;&gt; &lt;code&gt;numpy.multiply&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;../reference/generated/numpy.sin#numpy.sin&quot;&gt; &lt;code&gt;numpy.sin&lt;/code&gt; &lt;/a&gt;を含む関数のクラスです。</target>
        </trans-unit>
        <trans-unit id="6fb47cd6d16a30a926efe82eaad98fb5865139f5" translate="yes" xml:space="preserve">
          <source>How do we construct a 2D array from a list of equally-sized row vectors? In MATLAB this is quite easy: if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are two vectors of the same length you only need do &lt;code&gt;m=[x;y]&lt;/code&gt;. In NumPy this works via the functions &lt;code&gt;column_stack&lt;/code&gt;, &lt;code&gt;dstack&lt;/code&gt;, &lt;code&gt;hstack&lt;/code&gt; and &lt;code&gt;vstack&lt;/code&gt;, depending on the dimension in which the stacking is to be done. For example:</source>
          <target state="translated">同じサイズの行ベクトルのリストから2D配列を構築するにはどうすればよいですか？ MATLABでは、これは非常に簡単です &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; が同じ長さの2つのベクトルである場合は、 &lt;code&gt;m=[x;y]&lt;/code&gt; を実行するだけで済みます。 NumPyでは、これは、スタッキングが実行されるディメンションに応じて、関数 &lt;code&gt;column_stack&lt;/code&gt; 、 &lt;code&gt;dstack&lt;/code&gt; 、 &lt;code&gt;hstack&lt;/code&gt; 、および &lt;code&gt;vstack&lt;/code&gt; を介して機能します。例えば：</target>
        </trans-unit>
        <trans-unit id="0c6749c478409711ffa23534cffe66364ec264e6" translate="yes" xml:space="preserve">
          <source>How do we know when consensus has been achieved? In principle, this is rather difficult, since consensus is defined by the absence of vetos, which requires us to somehow prove a negative. In practice, we use a combination of our best judgement (e.g., a simple and uncontroversial bug fix posted on GitHub and reviewed by a core developer is probably fine) and best efforts (e.g., all substantive API changes must be posted to the mailing list in order to give the broader community a chance to catch any problems and suggest improvements; we assume that anyone who cares enough about NumPy to invoke their veto right should be on the mailing list). If no-one bothers to comment on the mailing list after a few days, then it&amp;rsquo;s probably fine. And worst case, if a change is more controversial than expected, or a crucial critique is delayed because someone was on vacation, then it&amp;rsquo;s no big deal: we apologize for misjudging the situation, &lt;a href=&quot;http://producingoss.com/en/producingoss.html#version-control-relaxation&quot;&gt;back up, and sort things out&lt;/a&gt;.</source>
          <target state="translated">コンセンサスが達成されたことをどのようにして知ることができますか？原則として、これはかなり困難です。なぜなら、コンセンサスは拒否権がないことによって定義され、何らかの形で否定的なことを証明する必要があるからです。実際には、最善の判断（GitHubに投稿され、コア開発者によるレビューが行われた、単純で議論の余地のないバグ修正など）と最善の努力（たとえば、すべての実質的なAPIの変更をメーリングリストに投稿する必要がある）を組み合わせて使用​​します。より広いコミュニティに問題を見つけて改善を提案する機会を与えるために、NumPyを十分に気にして拒否権を行使する人は誰でもメーリングリストに参加する必要があると想定しています）。数日経ってもメーリングリストにコメントする人がいない場合は、おそらく問題ありません。そして最悪の場合、変更が予想よりも物議を醸す場合、または、誰かが休暇中であったために重大な批判が遅れた場合、それは大したことではありません。状況を誤って判断したことをお詫びします。&lt;a href=&quot;http://producingoss.com/en/producingoss.html#version-control-relaxation&quot;&gt;バックアップして、物事を整理し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="d2fbb3731558c54237c322aa799a621ca3c7d2a1" translate="yes" xml:space="preserve">
          <source>How do you know the shape and size of an array?</source>
          <target state="translated">配列の形や大きさはどうやってわかるの?</target>
        </trans-unit>
        <trans-unit id="45e254592757b5e545a9eb104e6529f78a4c37d7" translate="yes" xml:space="preserve">
          <source>How many bytes needed to jump from the end of a dimension back to its beginning. Note that &lt;code&gt;backstrides[k] == strides[k] *
dims_m1[k]&lt;/code&gt;, but it is stored here as an optimization.</source>
          <target state="translated">次元の終わりから最初に戻るのに必要なバイト数。 &lt;code&gt;backstrides[k] == strides[k] * dims_m1[k]&lt;/code&gt; ですが、ここでは最適化として保存されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="50be7c0770c6ecdb4f48559d001a760ebacd49cf" translate="yes" xml:space="preserve">
          <source>How many trials succeeded after a single run?</source>
          <target state="translated">1回の走行で成功した試行回数は?</target>
        </trans-unit>
        <trans-unit id="b58aa8864964e56b91e5cf3a16abe6db4861d007" translate="yes" xml:space="preserve">
          <source>How numpy handles numerical exceptions</source>
          <target state="translated">numpyが数値的な例外を処理する方法</target>
        </trans-unit>
        <trans-unit id="769ef91e51259c0af4889f9e0ba44a7641bc888d" translate="yes" xml:space="preserve">
          <source>How the committee will respond to reports</source>
          <target state="translated">委員会の報告への対応方法</target>
        </trans-unit>
        <trans-unit id="8a9fac3d5f2ed22d26d8e65434409a64b568a19a" translate="yes" xml:space="preserve">
          <source>How to Prepare a Release</source>
          <target state="translated">リリースの準備方法</target>
        </trans-unit>
        <trans-unit id="f2421f501c3d9da50b64e18ac9aabab538f44d78" translate="yes" xml:space="preserve">
          <source>How to access the docstring for more information</source>
          <target state="translated">詳細については、docstringにアクセスする方法</target>
        </trans-unit>
        <trans-unit id="acdb5801edd59835ce1589b37b87df7e5921dc32" translate="yes" xml:space="preserve">
          <source>How to check the ABI of BLAS/LAPACK libraries</source>
          <target state="translated">BLAS/LAPACKライブラリのABIの確認方法</target>
        </trans-unit>
        <trans-unit id="7aec4c512fe995b8565d4654ce7ac7f7406a4e3f" translate="yes" xml:space="preserve">
          <source>How to contribute to the NumPy documentation</source>
          <target state="translated">NumPyドキュメントへの貢献方法</target>
        </trans-unit>
        <trans-unit id="f9221bbb4c993e17b159a09a015a8cfb26163b6a" translate="yes" xml:space="preserve">
          <source>How to contribute to this documentation (user and API)</source>
          <target state="translated">このドキュメントへの貢献方法 (ユーザとAPI)</target>
        </trans-unit>
        <trans-unit id="b16ba9588c01309cec829be39d4d7fa37da2d3d4" translate="yes" xml:space="preserve">
          <source>How to convert a 1D array into a 2D array (how to add a new axis to an array)</source>
          <target state="translated">1次元配列を2次元配列に変換する方法(配列に新しい軸を追加する方法</target>
        </trans-unit>
        <trans-unit id="767132203b56ed5a732938158524dc8930f4e863" translate="yes" xml:space="preserve">
          <source>How to create a basic array</source>
          <target state="translated">基本的な配列の作り方</target>
        </trans-unit>
        <trans-unit id="484181d716d9291c06f7d7ef08909d7d6fab3e0a" translate="yes" xml:space="preserve">
          <source>How to create an array from existing data</source>
          <target state="translated">既存のデータから配列を作成する方法</target>
        </trans-unit>
        <trans-unit id="9cc4cf70f5442751464e426079ad36aeb36f19be" translate="yes" xml:space="preserve">
          <source>How to do common tasks with NumPy</source>
          <target state="translated">NumPyで一般的なタスクを行う方法</target>
        </trans-unit>
        <trans-unit id="0cf433e8cb198db7bf7c955d6715ae5e9750b810" translate="yes" xml:space="preserve">
          <source>How to extend NumPy</source>
          <target state="translated">NumPyの拡張方法</target>
        </trans-unit>
        <trans-unit id="666793dffdb7a87d947a14c2cbc94401669fb6a1" translate="yes" xml:space="preserve">
          <source>How to get unique items and counts</source>
          <target state="translated">ユニークアイテムとカウント数の取得方法</target>
        </trans-unit>
        <trans-unit id="85f78c1b7c6c2daa9f22d71b7624a2bf3c525a6f" translate="yes" xml:space="preserve">
          <source>How to import NumPy</source>
          <target state="translated">NumPyのインポート方法</target>
        </trans-unit>
        <trans-unit id="5f492f4c3e2bb0aa4c599fef867f4b321aedf559" translate="yes" xml:space="preserve">
          <source>How to read and write data using NumPy</source>
          <target state="translated">NumPyを使ったデータの読み書き方法</target>
        </trans-unit>
        <trans-unit id="25e26bd806025536efd64003099ee09d64aa0000" translate="yes" xml:space="preserve">
          <source>How to reverse an array</source>
          <target state="translated">配列を反転させる方法</target>
        </trans-unit>
        <trans-unit id="9a0ae6b713025a426e1208163ee26bcb0e742b0a" translate="yes" xml:space="preserve">
          <source>How to save and load NumPy objects</source>
          <target state="translated">NumPyオブジェクトの保存と読み込み方法</target>
        </trans-unit>
        <trans-unit id="41cd522ba4633ce6d4277a1ec4fd27e9f6066b5f" translate="yes" xml:space="preserve">
          <source>How to treat dates that do not fall on a valid day. The default is &amp;lsquo;raise&amp;rsquo;.</source>
          <target state="translated">有効日に該当しない日付の扱い方。デフォルトは 'raise'です。</target>
        </trans-unit>
        <trans-unit id="32eab6d31082447f7e78feb7ff06453c5204497b" translate="yes" xml:space="preserve">
          <source>How to use an array iterator on a C-level is explained more fully in later sections. Typically, you do not need to concern yourself with the internal structure of the iterator object, and merely interact with it through the use of the macros &lt;a href=&quot;array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; (it), &lt;a href=&quot;array#c.PyArray_ITER_GOTO&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt;&lt;/a&gt; (it, dest), or &lt;a href=&quot;array#c.PyArray_ITER_GOTO1D&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt;&lt;/a&gt; (it, index). All of these macros require the argument &lt;em&gt;it&lt;/em&gt; to be a &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">経営幹部レベルで配列イテレータを使用する方法については、後のセクションで詳しく説明します。通常、イテレータオブジェクトの内部構造を気にする必要はなく、マクロ&lt;a href=&quot;array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt;（it）、&lt;a href=&quot;array#c.PyArray_ITER_GOTO&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt; &lt;/a&gt;（it、dest）、または&lt;a href=&quot;array#c.PyArray_ITER_GOTO1D&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt; &lt;/a&gt;（it、index）を使用して対話するだけです。これらのマクロのすべては、引数が必要です&lt;em&gt;、それは&lt;/em&gt;すべき&lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject *&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="031b673efec683dbe6f1648f1b6820d5445558f5" translate="yes" xml:space="preserve">
          <source>How to use an array iterator on a C-level is explained more fully in later sections. Typically, you do not need to concern yourself with the internal structure of the iterator object, and merely interact with it through the use of the macros &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; (it), &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt;&lt;/a&gt; (it, dest), or &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO1D&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt;&lt;/a&gt; (it, index). All of these macros require the argument &lt;em&gt;it&lt;/em&gt; to be a &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Cレベルで配列反復子を使用する方法については、後のセクションで詳しく説明します。通常、イテレータオブジェクトの内部構造を気にする必要はなく、マクロ&lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt;（it）、&lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt; &lt;/a&gt;（it、dest）、または&lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO1D&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt; &lt;/a&gt;（it、index）を使用してそれと対話するだけです。これらのマクロのすべては、引数が必要です&lt;em&gt;、それは&lt;/em&gt;すべき&lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject *&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4fbdd9c0dbdc8228af43d264039755fa6f4f95d7" translate="yes" xml:space="preserve">
          <source>How to write a NumPy how-to</source>
          <target state="translated">NumPyのハウツーを書くには</target>
        </trans-unit>
        <trans-unit id="9bcd1bde0a6ac509c8c0a0f1ece3cf8687c68de6" translate="yes" xml:space="preserve">
          <source>How to write docstrings in the numpydoc format</source>
          <target state="translated">numpydoc形式のdocstringの書き方</target>
        </trans-unit>
        <trans-unit id="a9ce4fa1ba9129e1c9bcea4c3de2267bc0616f3b" translate="yes" xml:space="preserve">
          <source>How-tos</source>
          <target state="translated">How-tos</target>
        </trans-unit>
        <trans-unit id="5a2138ee0afb6e0df456b908537065dae83cea13" translate="yes" xml:space="preserve">
          <source>How-tos bring people into the site and help them discover other information that&amp;rsquo;s here .</source>
          <target state="translated">ハウツーは人々をサイトに連れて行き、彼らがここにある他の情報を発見するのを助けます。</target>
        </trans-unit>
        <trans-unit id="ba325398237c63a9d5322f9272d833f53cda40ea" translate="yes" xml:space="preserve">
          <source>How-tos get straight to the point &amp;ndash; they</source>
          <target state="translated">ハウツーはポイントにまっすぐになります&amp;ndash;彼らは</target>
        </trans-unit>
        <trans-unit id="e6a6228c232d3f69fb7834193a60b8402989b6d1" translate="yes" xml:space="preserve">
          <source>How-tos make the site less forbidding to non-experts.</source>
          <target state="translated">ハウツーがあることで、専門家でなくても敷居の低いサイトになります。</target>
        </trans-unit>
        <trans-unit id="a2e4974ddfecbf0d517a464e620b926746339cbe" translate="yes" xml:space="preserve">
          <source>However, F2PY provides a hook to overcome this difficulty, namely, users can define their own &amp;lt;Fortran type&amp;gt; to &amp;lt;C type&amp;gt; maps. For example, if Fortran 90 code contains:</source>
          <target state="translated">ただし、F2PYは、この問題を克服するためのフックを提供します。つまり、ユーザーは独自の&amp;lt;Fortranタイプ&amp;gt;から&amp;lt;Cタイプ&amp;gt;へのマップを定義できます。たとえば、Fortran90コードに次のものが含まれている場合：</target>
        </trans-unit>
        <trans-unit id="1fba89386b8ecb89961d14d41f66fbec5ccd1d21" translate="yes" xml:space="preserve">
          <source>However, array scalars are immutable, so none of the array scalar attributes are settable.</source>
          <target state="translated">しかし、配列スカラは不変なので、配列スカラの属性はどれも設定できません。</target>
        </trans-unit>
        <trans-unit id="1e80ea7cc9443be2dc987f1f00e1482c24f952ab" translate="yes" xml:space="preserve">
          <source>However, for a 2D array, &lt;code&gt;tolist&lt;/code&gt; applies recursively:</source>
          <target state="translated">ただし、2D配列の場合、 &lt;code&gt;tolist&lt;/code&gt; は再帰的に適用されます。</target>
        </trans-unit>
        <trans-unit id="015eddccae9844f7be37e7464bfea1ad89cd5089" translate="yes" xml:space="preserve">
          <source>However, if editing Fortran codes is acceptable, then the generation of an intermediate signature file can be skipped in most cases. Namely, F2PY specific attributes can be inserted directly to Fortran source codes using the so-called F2PY directive. A F2PY directive defines special comment lines (starting with &lt;code&gt;Cf2py&lt;/code&gt;, for example) which are ignored by Fortran compilers but F2PY interprets them as normal lines.</source>
          <target state="translated">ただし、Fortranコードの編集が許容される場合は、ほとんどの場合、中間署名ファイルの生成をスキップできます。つまり、F2PY固有の属性は、いわゆるF2PYディレクティブを使用してFortranソースコードに直接挿入できます。F2PYディレクティブは、Fortranコンパイラーによって無視される特別なコメント行（たとえば、 &lt;code&gt;Cf2py&lt;/code&gt; で始まる）を定義しますが、F2PYはそれらを通常の行として解釈します。</target>
        </trans-unit>
        <trans-unit id="b575af53d48fbf01519f17fa75457eb6160cea6e" translate="yes" xml:space="preserve">
          <source>However, if one wants to perform an operation on each element in the array, one can use the &lt;code&gt;flat&lt;/code&gt; attribute which is an &lt;a href=&quot;https://docs.python.org/tutorial/classes.html#iterators&quot;&gt;iterator&lt;/a&gt; over all the elements of the array:</source>
          <target state="translated">ただし、配列内の各要素に対して操作を実行する場合は、配列のすべての要素に対する&lt;a href=&quot;https://docs.python.org/tutorial/classes.html#iterators&quot;&gt;イテレーター&lt;/a&gt;である &lt;code&gt;flat&lt;/code&gt; 属性を使用できます。</target>
        </trans-unit>
        <trans-unit id="538a59374ec076485a1ecbe77f4b8f8bcaeb6930" translate="yes" xml:space="preserve">
          <source>However, if the step length is a &lt;strong&gt;complex number&lt;/strong&gt; (e.g. 5j), then the integer part of its magnitude is interpreted as specifying the number of points to create between the start and stop values, where the stop value &lt;strong&gt;is inclusive&lt;/strong&gt;.</source>
          <target state="translated">ただし、ステップ長が&lt;strong&gt;複素数&lt;/strong&gt;（5jなど）の場合、その絶対値の整数部分は、開始値と終了値の間に作成するポイント数を指定するものとして解釈されます。ここで、終了値&lt;strong&gt;はを含み&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="c7b350918e2c3c187f55b17296e6170af94589d5" translate="yes" xml:space="preserve">
          <source>However, it also provides a filter mechanism to work around &lt;a href=&quot;https://bugs.python.org/issue4180&quot;&gt;https://bugs.python.org/issue4180&lt;/a&gt;.</source>
          <target state="translated">ただし、&lt;a href=&quot;https://bugs.python.org/issue4180&quot;&gt;https：//bugs.python.org/issue4180を&lt;/a&gt;回避するためのフィルターメカニズムも提供します。</target>
        </trans-unit>
        <trans-unit id="8a0d3e8aabdd09f6d1c5b5cc067196fd48077165" translate="yes" xml:space="preserve">
          <source>However, on Windows accessing an attribute of the &lt;code&gt;cdll&lt;/code&gt; method will load the first DLL by that name found in the current directory or on the PATH. Loading the absolute path name requires a little finesse for cross-platform work since the extension of shared libraries varies. There is a &lt;code&gt;ctypes.util.find_library&lt;/code&gt; utility available that can simplify the process of finding the library to load but it is not foolproof. Complicating matters, different platforms have different default extensions used by shared libraries (e.g. .dll &amp;ndash; Windows, .so &amp;ndash; Linux, .dylib &amp;ndash; Mac OS X). This must also be taken into account if you are using ctypes to wrap code that needs to work on several platforms.</source>
          <target state="translated">ただし、Windowsでは、 &lt;code&gt;cdll&lt;/code&gt; メソッドの属性にアクセスすると、現在のディレクトリまたはPATHにあるその名前で最初のDLLが読み込まれます。共有ライブラリの拡張機能はさまざまであるため、絶対パス名をロードするには、クロスプラットフォームの作業に少し手間がかかります。あり &lt;code&gt;ctypes.util.find_library&lt;/code&gt; 負荷にライブラリを見つけるプロセスを簡素化することができる利用可能なユーティリティは、それは誰にでもできるではありません。複雑なことに、プラットフォームが異なれば、共有ライブラリで使用されるデフォルトの拡張子も異なります（.dll &amp;ndash; Windows、.so &amp;ndash; Linux、.dylib &amp;ndash; Mac OS Xなど）。複数のプラットフォームで動作する必要があるコードをラップするためにctypesを使用している場合は、これも考慮に入れる必要があります。</target>
        </trans-unit>
        <trans-unit id="72730352a2b8f129f65e5ce4d2975cad73414281" translate="yes" xml:space="preserve">
          <source>However, since the indexing arrays above just repeat themselves, broadcasting can be used (compare operations such as &lt;code&gt;rows[:, np.newaxis] + columns&lt;/code&gt;) to simplify this:</source>
          <target state="translated">ただし、上記のインデックス配列はそれ自体を繰り返すだけなので、ブロードキャストを使用して（ &lt;code&gt;rows[:, np.newaxis] + columns&lt;/code&gt; ような操作を比較）、これを簡素化できます。</target>
        </trans-unit>
        <trans-unit id="5598df37564d4f9b7b446978966b782318a91f69" translate="yes" xml:space="preserve">
          <source>However, the Council&amp;rsquo;s primary responsibility is to facilitate the ordinary community-based decision making procedure described above. If we ever have to step in and formally override the community for the health of the Project, then we will do so, but we will consider reaching this point to indicate a failure in our leadership.</source>
          <target state="translated">ただし、評議会の主な責任は、上記の通常のコミュニティベースの意思決定手順を促進することです。プロジェクトの健全性のためにコミュニティに介入して正式にオーバーライドする必要がある場合は、そうしますが、この時点に到達して、リーダーシップの失敗を示すことを検討します。</target>
        </trans-unit>
        <trans-unit id="148e0e3942c54a4e1382c28056e669f5ec70ca70" translate="yes" xml:space="preserve">
          <source>However, the recommended way to get changes made by Fortran subroutine back to Python is to use &lt;code&gt;intent(out)&lt;/code&gt; attribute. It is more efficient and a cleaner solution.</source>
          <target state="translated">ただし、Fortranサブルーチンによって行われた変更をPythonに戻すための推奨される方法は、 &lt;code&gt;intent(out)&lt;/code&gt; 属性を使用することです。それはより効率的でよりクリーンなソリューションです。</target>
        </trans-unit>
        <trans-unit id="076196cf7f29cbacc06332dc3a19baa5b6deb43a" translate="yes" xml:space="preserve">
          <source>However, there are ways (see below) how to &amp;ldquo;teach&amp;rdquo; F2PY about the true intentions (among other things) of function arguments; and then F2PY is able to generate more Pythonic (more explicit, easier to use, and less error prone) wrappers to Fortran functions.</source>
          <target state="translated">ただし、関数の引数の（とりわけ）真の意図についてF2PYを「教える」方法（以下を参照）があります。そして、F2PYは、Fortran関数へのより多くのPythonic（より明示的で使いやすく、エラーが発生しにくい）ラッパーを生成できます。</target>
        </trans-unit>
        <trans-unit id="517b2fc5c448904cbaf5099f9fa2e17572271c41" translate="yes" xml:space="preserve">
          <source>However, this class is not run directly. Rather, it serves as a base class to several other python classes, each one specific to a particular data type. The &lt;code&gt;VectorTestCase&lt;/code&gt; class stores two strings for typing information:</source>
          <target state="translated">ただし、このクラスは直接実行されません。むしろ、それぞれが特定のデータ型に固有のいくつかの他のpythonクラスの基本クラスとして機能します。 &lt;code&gt;VectorTestCase&lt;/code&gt; のクラスが格納タイピング情報のための2つの文字列：</target>
        </trans-unit>
        <trans-unit id="2a6f4657816e90073e4efa70d32c1dabe823c21d" translate="yes" xml:space="preserve">
          <source>However, we can not do this by putting &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; into an array, because this array will be interpreted as indexing the first dimension of a.</source>
          <target state="translated">ただし、 &lt;code&gt;i&lt;/code&gt; と &lt;code&gt;j&lt;/code&gt; を配列に入れることによってこれを行うことはできません。これは、この配列がaの最初の次元にインデックスを付けるものとして解釈されるためです。</target>
        </trans-unit>
        <trans-unit id="d0b3b9f48e63d95c45789879b62e0b7dfb5a4009" translate="yes" xml:space="preserve">
          <source>However, when the list of indices contains repetitions, the assignment is done several times, leaving behind the last value:</source>
          <target state="translated">ただし、インデックスのリストに繰り返しが含まれている場合は、最後の値を残して何度か代入が行われます。</target>
        </trans-unit>
        <trans-unit id="521bc3c12a73492e24db294a1945beb730dec9cb" translate="yes" xml:space="preserve">
          <source>Human-readable</source>
          <target state="translated">Human-readable</target>
        </trans-unit>
        <trans-unit id="baf7f433a664b8146a9906ca7ff1abe3cab252ff" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine, element-wise.</source>
          <target state="translated">双曲余弦、要素法。</target>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="translated">双曲関数</target>
        </trans-unit>
        <trans-unit id="b87cce3c91c3e9d2649c00af3ce0c941c00a9a8f" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine, element-wise.</source>
          <target state="translated">双曲線的なサイン、要素的に。</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="32232530b1100268522739a98df9e054ce98ef4f" translate="yes" xml:space="preserve">
          <source>I() (numpy.matrix property)</source>
          <target state="translated">I()(numpy.matrixプロパティ)</target>
        </trans-unit>
        <trans-unit id="c586011e018241bf43412c51ec75d78e1897bbe7" translate="yes" xml:space="preserve">
          <source>I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng. trans. Ed.), &lt;em&gt;Handbook of Mathematics&lt;/em&gt;, New York, Van Nostrand Reinhold Co., 1985, pg. 720.</source>
          <target state="translated">IN Bronshtein、KA Semendyayev、およびKA Hirsch（英語翻訳版）、&lt;em&gt;数学ハンドブック、&lt;/em&gt;ニューヨーク、Van Nostrand Reinhold Co.、1985、pg。720。</target>
        </trans-unit>
        <trans-unit id="447fb9923a27f15d934b8afdf5c0a4f010eb6dd4" translate="yes" xml:space="preserve">
          <source>I/O with NumPy</source>
          <target state="translated">NumPyによるI/O</target>
        </trans-unit>
        <trans-unit id="58fa487987fc3870763b0f9db01323f264726e65" translate="yes" xml:space="preserve">
          <source>IBM/POWER big-endian - CPU feature names</source>
          <target state="translated">IBM/POWER ビッグエンディアン-CPUの機能名</target>
        </trans-unit>
        <trans-unit id="2ccc4b37b2ad4aa5276bee6f26efc4659da58371" translate="yes" xml:space="preserve">
          <source>IBM/POWER little-endian - CPU feature names</source>
          <target state="translated">IBM/POWER リトルエンディアン-CPUの機能名</target>
        </trans-unit>
        <trans-unit id="afc08020472b5f8bfb4430d0521200fb31b0b681" translate="yes" xml:space="preserve">
          <source>IEEE 754 Floating Point Special Values</source>
          <target state="translated">IEEE 754 浮動小数点特殊値</target>
        </trans-unit>
        <trans-unit id="0ee225f319b80c76b05dae881594a3894bf4661e" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of (positive) infinity.</source>
          <target state="translated">IEEE 754の(正の)無限大の浮動小数点表現。</target>
        </trans-unit>
        <trans-unit id="ff3e6480ff45af971d6b3762d77291c710637eb0" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of Not a Number (NaN).</source>
          <target state="translated">IEEE 754のNot a Number (NaN)の浮動小数点表現。</target>
        </trans-unit>
        <trans-unit id="824566ddb199752efcc7660bd7d421e1b2678da4" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of negative infinity.</source>
          <target state="translated">IEEE 754の負の無限大の浮動小数点表現。</target>
        </trans-unit>
        <trans-unit id="2e340e10314a130edadd8cad9f96f416538b858d" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of negative zero.</source>
          <target state="translated">IEEE 754 の負のゼロの浮動小数点表現。</target>
        </trans-unit>
        <trans-unit id="b287f77a659c8b69b20168ee840f1a54628cc862" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of positive zero.</source>
          <target state="translated">正のゼロのIEEE 754浮動小数点表現。</target>
        </trans-unit>
        <trans-unit id="8b686ac7097f2666dfedf8d88871747de97f1028" translate="yes" xml:space="preserve">
          <source>IEEE Standard for Floating-Point Arithmetic, IEEE Std 754-2008, pp.1-70, 2008, &lt;a href=&quot;https://www.doi.org/10.1109/IEEESTD.2008.4610935&quot;&gt;http://www.doi.org/10.1109/IEEESTD.2008.4610935&lt;/a&gt;</source>
          <target state="translated">浮動小数点演算のIEEE標準、IEEE Std 754-2008、pp.1-70、2008、&lt;a href=&quot;https://www.doi.org/10.1109/IEEESTD.2008.4610935&quot;&gt;http：//www.doi.org/10.1109/IEEESTD.2008.4610935&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="72cabc0c250f4a292eec84ba99be92816a937afe" translate="yes" xml:space="preserve">
          <source>INSTALL.rst.txt</source>
          <target state="translated">INSTALL.rst.txt</target>
        </trans-unit>
        <trans-unit id="ab585ec9c005c8ff11ee6135d8e5382d325fbd66" translate="yes" xml:space="preserve">
          <source>IO compatibility with large files</source>
          <target state="translated">大容量ファイルのIO互換性</target>
        </trans-unit>
        <trans-unit id="e274113d3320e2ddaa1955ecaa00f8ecd732ab0e" translate="yes" xml:space="preserve">
          <source>IO performance improvements</source>
          <target state="translated">IO パフォーマンスの改善</target>
        </trans-unit>
        <trans-unit id="a7aaaf8103e147f7508e66b5f7be824742d34faa" translate="yes" xml:space="preserve">
          <source>IOError</source>
          <target state="translated">IOError</target>
        </trans-unit>
        <trans-unit id="401e5d8be22ba7ec21a65d4ac42f63626cf30eac" translate="yes" xml:space="preserve">
          <source>ISO/IEC standard 9899:1999, &amp;ldquo;Programming language C.&amp;rdquo;</source>
          <target state="translated">ISO / IEC規格9899：1999、「プログラミング言語C」</target>
        </trans-unit>
        <trans-unit id="a192903ac36265b2268a1b63fb4343f1bc34ccf1" translate="yes" xml:space="preserve">
          <source>ISeedSequence.generate_state()</source>
          <target state="translated">ISeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="7817ae1e33233084a2765c4156676391d76c8dd8" translate="yes" xml:space="preserve">
          <source>ISpawnableSeedSequence.generate_state()</source>
          <target state="translated">ISpawnableSeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="266493f5f6f829a5601662541a1f5723f1a321cc" translate="yes" xml:space="preserve">
          <source>ISpawnableSeedSequence.spawn()</source>
          <target state="translated">ISpawnableSeedSequence.spawn()</target>
        </trans-unit>
        <trans-unit id="08673d1ddebe80d6502dff08e88d404531dbe20b" translate="yes" xml:space="preserve">
          <source>Identifies the benchmarks to run. This can be a string to pass to the nosetests executable with the &amp;lsquo;-A&amp;rsquo; option, or one of several special values. Special values are:</source>
          <target state="translated">実行するベンチマークを識別します。これは、「-A」オプションを指定して実行可能なnosetestsに渡す文字列、またはいくつかの特別な値の1つにすることができます。特別な値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="2938dea7757a31542d1346c3f1074719ce51ad4d" translate="yes" xml:space="preserve">
          <source>Identifies the tests to run. This can be a string to pass to the nosetests executable with the &amp;lsquo;-A&amp;rsquo; option, or one of several special values. Special values are:</source>
          <target state="translated">実行するテストを識別します。これは、「-A」オプションを指定して実行可能なnosetestsに渡す文字列、またはいくつかの特別な値の1つにすることができます。特別な値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="84791116b8cc2df6bbeaf0d85f3bf0937f9761c0" translate="yes" xml:space="preserve">
          <source>Identify the commit hash of the release, e.g. 1b2e1d63ff.</source>
          <target state="translated">リリースのコミットハッシュを識別します。</target>
        </trans-unit>
        <trans-unit id="fd1dd04c1dd17aedd6c4e7a39f0e9308f130b433" translate="yes" xml:space="preserve">
          <source>Identity for reduction, when &lt;a href=&quot;#c.PyUFuncObject.identity&quot;&gt;&lt;code&gt;PyUFuncObject.identity&lt;/code&gt;&lt;/a&gt; is equal to &lt;a href=&quot;ufunc#c.PyUFunc_IdentityValue&quot;&gt;&lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">削減のためのアイデンティティ、&lt;a href=&quot;#c.PyUFuncObject.identity&quot;&gt; &lt;code&gt;PyUFuncObject.identity&lt;/code&gt; が&lt;/a&gt;に等しい&lt;a href=&quot;ufunc#c.PyUFunc_IdentityValue&quot;&gt; &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="111e795804fa7bde03948ba63ec2cb3f6f402b39" translate="yes" xml:space="preserve">
          <source>Identity function.</source>
          <target state="translated">アイデンティティ機能。</target>
        </trans-unit>
        <trans-unit id="ef2cb61738111c3044b6a344dba03012a1f3066b" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;inner&amp;rsquo;, returns the elements common to both r1 and r2. If &amp;lsquo;outer&amp;rsquo;, returns the common elements as well as the elements of r1 not in r2 and the elements of not in r2. If &amp;lsquo;leftouter&amp;rsquo;, returns the common elements and the elements of r1 not in r2.</source>
          <target state="translated">'inner'の場合、r1とr2の両方に共通の要素を返します。'outer'の場合、共通の要素と、r2にないr1の要素、およびr2にないの要素を返します。'leftouter'の場合、r2にないr1の共通要素と要素を返します。</target>
        </trans-unit>
        <trans-unit id="c9a8c69d524e3737d8a52d7c063a710ab1820ab4" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;left&amp;rsquo;, the index of the first suitable location found is given. If &amp;lsquo;right&amp;rsquo;, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of &lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">「左」の場合、最初に見つかった適切な場所のインデックスが表示されます。「正しい」場合、最後のそのようなインデックスを返します。適切なインデックスがない場合は、0またはN（Nは &lt;code&gt;a&lt;/code&gt; の長さ）を返します。</target>
        </trans-unit>
        <trans-unit id="0b2ac55fdba7a6077870f65fb651eb209decd3f7" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;out&amp;rsquo; is None (the default), a uninitialized return array is created. The output array is then filled with the results of the ufunc in the places that the broadcast &amp;lsquo;where&amp;rsquo; is True. If &amp;lsquo;where&amp;rsquo; is the scalar True (the default), then this corresponds to the entire output being filled. Note that outputs not explicitly filled are left with their uninitialized values.</source>
          <target state="translated">'out'がNone（デフォルト）の場合、初期化されていない戻り配列が作成されます。次に、ブロードキャストの「where」がTrueである場所のufuncの結果が出力配列で埋められます。'where'がスカラーTrue（デフォルト）の場合、これは入力される出力全体に対応します。明示的に入力されていない出力には、初期化されていない値が残ることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b221bc8f0d9f3564598fa735c4c298856c0dd2e9" translate="yes" xml:space="preserve">
          <source>If -1/NULL values are passed to &lt;code&gt;oa_ndim&lt;/code&gt;, &lt;code&gt;op_axes&lt;/code&gt;, &lt;code&gt;itershape&lt;/code&gt;, and &lt;code&gt;buffersize&lt;/code&gt;, it is equivalent to &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">-1 / NULL値が &lt;code&gt;oa_ndim&lt;/code&gt; 、 &lt;code&gt;op_axes&lt;/code&gt; 、 &lt;code&gt;itershape&lt;/code&gt; 、および &lt;code&gt;buffersize&lt;/code&gt; に渡される場合、これは&lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt;と同等です。</target>
        </trans-unit>
        <trans-unit id="07ab4829841dadccaa2d85de36af5f3925367c25" translate="yes" xml:space="preserve">
          <source>If 64-bit integers are still too small the result may be cast to a floating point number. Floating point numbers offer a larger, but inexact, range of possible values.</source>
          <target state="translated">64ビット整数がまだ小さすぎる場合は、結果を浮動小数点数にキャストすることができます。浮動小数点数は、より大きな値を提供しますが、正確ではありません。</target>
        </trans-unit>
        <trans-unit id="79d46b4b066a6ba67bd08b99b0faa98132c0c54b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; is #defined, regardless of whether &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is, the C-API is declared to be &lt;code&gt;extern void**&lt;/code&gt;, so it is expected to be defined in another compilation unit.</source>
          <target state="translated">場合&lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; が&lt;/a&gt; #defineで定義され、関係なく、かどうかの&lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; が&lt;/a&gt;あり、C-APIがあることを宣言されている &lt;code&gt;extern void**&lt;/code&gt; 、別のコンパイル単位で定義されていることが予想されるので、。</target>
        </trans-unit>
        <trans-unit id="f636b5861ee4fae57e7d457d50fef770ecd7b810" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt;&lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt;&lt;/a&gt; was called, you may want to enable the flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;. This flag is not permitted together with &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt;, so this function is provided to enable the feature after &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt;&lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt;&lt;/a&gt; is called. This function also resets the iterator to its initial state.</source>
          <target state="translated">&lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt; &lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt; &lt;/a&gt;が呼び出された場合、フラグ&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;を有効にすることができます。このフラグは&lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; &lt;/a&gt;と一緒に使用できないため、この関数は&lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt; &lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt; &lt;/a&gt;が呼び出された後に機能を有効にするために提供されています。この関数は、イテレーターを初期状態にリセットします。</target>
        </trans-unit>
        <trans-unit id="1cac2a31adf2200c294f5c075bb6c153e55fa5a2" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is #defined, but &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; is not, the C-API is declared to be &lt;code&gt;void**&lt;/code&gt;, so that it will also be visible to other compilation units.</source>
          <target state="translated">場合&lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; が&lt;/a&gt; #defineで定義されていますが、&lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; は&lt;/a&gt;ないが、C-APIがあることを宣言されている &lt;code&gt;void**&lt;/code&gt; 、それはまた、他のコンパイル単位に表示されますように、。</target>
        </trans-unit>
        <trans-unit id="b3b296f263651378da8d936805870023810c7d29" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is not specified, but &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is specified (and is not an ndarray sub-class), the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; of the MaskedArray will be reset. If neither &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are specified (or if &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is an ndarray sub-class), then the fill value is preserved. Finally, if &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is specified, but &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not, the fill value is set to the specified value.</source>
          <target state="translated">場合&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; が&lt;/a&gt;指定されていないが、&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;指定されている（とndarrayサブクラスではない）、&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; MaskedArrayのはリセットされます。どちらの場合&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;も&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;指定されている（場合や&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;ndarrayサブクラスである）、そしてフィル値が保存されています。最後に、もし&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; が&lt;/a&gt;指定されているが、&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;、塗りつぶしの値が指定された値に設定されていません。</target>
        </trans-unit>
        <trans-unit id="f0fe9dfd78027e91a1bff4d801d8eb87a4610a71" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is not specified, but &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is specified (and is not an ndarray sub-class), the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; of the MaskedArray will be reset. If neither &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are specified (or if &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is an ndarray sub-class), then the fill value is preserved. Finally, if &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is specified, but &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not, the fill value is set to the specified value.</source>
          <target state="translated">場合&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; が&lt;/a&gt;指定されていないが、&lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;指定されている（とndarrayサブクラスではない）、&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; MaskedArrayのはリセットされます。どちらの場合&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;も&lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;指定されている（場合や&lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;ndarrayサブクラスである）、そしてフィル値が保存されています。最後に、もし&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; が&lt;/a&gt;指定されているが、&lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;、塗りつぶしの値が指定された値に設定されていません。</target>
        </trans-unit>
        <trans-unit id="bd7a3692bd40eb6528a52fa63a028a54110d3c3d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; is 1-D, the function &lt;code&gt;ufunc.accumulate(array)&lt;/code&gt; is the same as &lt;code&gt;ufunc.reduceat(array, indices)[::2]&lt;/code&gt; where &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;range(len(array) - 1)&lt;/code&gt; with a zero placed in every other element: &lt;code&gt;indices = zeros(2 * len(array) - 1)&lt;/code&gt;, &lt;code&gt;indices[1::2] = range(1, len(array))&lt;/code&gt;.</source>
          <target state="translated">場合&lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 1-Dであり、関数 &lt;code&gt;ufunc.accumulate(array)&lt;/code&gt; と同じである &lt;code&gt;ufunc.reduceat(array, indices)[::2]&lt;/code&gt; &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt;ある &lt;code&gt;range(len(array) - 1)&lt;/code&gt; 毎に配置されたゼロとその他の要素： &lt;code&gt;indices = zeros(2 * len(array) - 1)&lt;/code&gt; 、 &lt;code&gt;indices[1::2] = range(1, len(array))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc062e126b3bd61e02f7b3e167657fb84a747f47" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;, these arguments are passed to &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt;&lt;code&gt;numpy.format_parser&lt;/code&gt;&lt;/a&gt; to construct a dtype. See that function for detailed documentation</source>
          <target state="translated">&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;None&lt;/code&gt; の場合、これらの引数は&lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt; &lt;code&gt;numpy.format_parser&lt;/code&gt; &lt;/a&gt;に渡され、dtypeが作成されます。詳細なドキュメントについては、その関数を参照してください</target>
        </trans-unit>
        <trans-unit id="f05f58b7f416905ebe6f79d07e2a76e9b7837051" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;, these arguments are passed to &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt;&lt;code&gt;numpy.format_parser&lt;/code&gt;&lt;/a&gt; to construct a dtype. See that function for detailed documentation.</source>
          <target state="translated">&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;None&lt;/code&gt; の場合、これらの引数は&lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt; &lt;code&gt;numpy.format_parser&lt;/code&gt; &lt;/a&gt;に渡され、dtypeが作成されます。詳細なドキュメントについては、その関数を参照してください。</target>
        </trans-unit>
        <trans-unit id="b6b83b00b9ce96c4a5e91132daa4d55535f9e96d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is set, array is copied only if dtype does not match:</source>
          <target state="translated">場合&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;設定されている、配列はDTYPEが一致しない場合のみコピーされます。</target>
        </trans-unit>
        <trans-unit id="4fc8bcfc9864193d76a4195dd238fe6624ed9a71" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is not one dimensional, the output also has these dimensions.</source>
          <target state="translated">&lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt;が1次元でない場合、出力にもこれらの次元があります。</target>
        </trans-unit>
        <trans-unit id="6ede9f1a1e5701156394dbca76c84f8a340a9cea" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is not specified, but &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is specified (and is not an ndarray sub-class), the &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; of the MaskedArray will be reset. If neither &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are specified (or if &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is an ndarray sub-class), then the fill value is preserved. Finally, if &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is specified, but &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not, the fill value is set to the specified value.</source>
          <target state="translated">場合&lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; が&lt;/a&gt;指定されていないが、&lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;指定されている（とndarrayサブクラスではない）、&lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; MaskedArrayのはリセットされます。どちらの場合&lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;も&lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;指定されている（場合や&lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;ndarrayサブクラスである）、そしてフィル値が保存されています。最後に、もし&lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; が&lt;/a&gt;指定されているが、&lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;、塗りつぶしの値が指定された値に設定されていません。</target>
        </trans-unit>
        <trans-unit id="8d5ce8d43810f8659a3ffbe656fd3c96f0228399" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; is a string, it is interpreted as a matrix with commas or spaces separating columns, and semicolons separating rows.</source>
          <target state="translated">&lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt;が文字列の場合、列をコンマまたはスペースで区切り、行をセミコロンで区切った行列として解釈されます。</target>
        </trans-unit>
        <trans-unit id="006799ea3355b83be37fd21ad89f661aac343125" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; is already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, then this flag determines whether the data is copied (the default), or whether a view is constructed.</source>
          <target state="translated">場合&lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt;既にある&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;、このフラグは、データが（デフォルト）にコピーされているかどうか、またはビューが構築されているか否かを判定する。</target>
        </trans-unit>
        <trans-unit id="ad28cc6c8a4f0eed400b04898af33bdfb6744bee" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; has length one i.e. &lt;code&gt;(N,)&lt;/code&gt;, or is a scalar &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;out&lt;/code&gt; becomes a single row matrix of shape &lt;code&gt;(1,N)&lt;/code&gt;.</source>
          <target state="translated">場合&lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;長さ1、すなわちを有する &lt;code&gt;(N,)&lt;/code&gt; 、またはスカラーである &lt;code&gt;N&lt;/code&gt; 、 &lt;code&gt;out&lt;/code&gt; 形状の単一の行行列となる &lt;code&gt;(1,N)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f12c5c9464a76ef6881e238c0f45cc6cb56cab96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;filename.pyf&amp;gt;&lt;/code&gt; is specified as &lt;code&gt;stdout&lt;/code&gt; then signatures are send to standard output instead of a file.</source>
          <target state="translated">&lt;code&gt;&amp;lt;filename.pyf&amp;gt;&lt;/code&gt; が &lt;code&gt;stdout&lt;/code&gt; として指定されている場合、署名はファイルではなく標準出力に送信されます。</target>
        </trans-unit>
        <trans-unit id="22e7424cfa201c4ec783e98a6da198e97606627a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; contains a signature file, then a source for an extension module is constructed, all Fortran and C sources are compiled, and finally all object and library files are linked to the extension module &lt;code&gt;&amp;lt;modulename&amp;gt;.so&lt;/code&gt; which is saved into the current directory.</source>
          <target state="translated">場合は &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; 署名ファイルが含まれている、その後、拡張モジュールのソースが構築され、すべてのFortranとCのソースがコンパイルされ、そして最終的にはすべてのオブジェクトファイルとライブラリファイルは、拡張モジュールにリンクされている &lt;code&gt;&amp;lt;modulename&amp;gt;.so&lt;/code&gt; に保存されています現在のディレクトリ。</target>
        </trans-unit>
        <trans-unit id="207fbf09fcd7223478aec74725e5d0380117e758" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; does not contain a signature file, then an extension module is constructed by scanning all Fortran source codes for routine signatures.</source>
          <target state="translated">もし &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; その後、拡張モジュールは、ルーチンの署名のために、すべてのFortranソースコードをスキャンすることによって構築された署名ファイルを、含まれていません。</target>
        </trans-unit>
        <trans-unit id="3b197e7232928483bec23ab77c22b02eb5eeb910" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A.ndim &amp;gt; d&lt;/code&gt;, &lt;code&gt;reps&lt;/code&gt; is promoted to &lt;code&gt;A&lt;/code&gt;.ndim by pre-pending 1&amp;rsquo;s to it. Thus for an &lt;code&gt;A&lt;/code&gt; of shape (2, 3, 4, 5), a &lt;code&gt;reps&lt;/code&gt; of (2, 2) is treated as (1, 1, 2, 2).</source>
          <target state="translated">&lt;code&gt;A.ndim &amp;gt; d&lt;/code&gt; 場合は、先頭に &lt;code&gt;A&lt;/code&gt; 付加することにより、 &lt;code&gt;reps&lt;/code&gt; はA .ndimに昇格されます。したがって、形状（ &lt;code&gt;reps&lt;/code&gt; ）の &lt;code&gt;A&lt;/code&gt; の場合、（2、2）の担当者は（1、1、2、2）として扱われます。</target>
        </trans-unit>
        <trans-unit id="dbe88f61ce8f631b9b28c692a7753b41fb5fe9e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A.ndim &amp;lt; d&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is promoted to be d-dimensional by prepending new axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication, or shape (1, 1, 3) for 3-D replication. If this is not the desired behavior, promote &lt;code&gt;A&lt;/code&gt; to d-dimensions manually before calling this function.</source>
          <target state="translated">&lt;code&gt;A.ndim &amp;lt; d&lt;/code&gt; 場合、 &lt;code&gt;A&lt;/code&gt; は新しい軸を付加することによりd次元に昇格されます。したがって、形状（3、）配列は、2次元複製の場合は（1、3）に、3次元複製の場合は形状（1、1、3）に昇格されます。これが望ましい動作でない場合は、この関数を呼び出す前に、 &lt;code&gt;A&lt;/code&gt; をd次元に手動で昇格させます。</target>
        </trans-unit>
        <trans-unit id="7f85c71b217560bd561bde5602b4923ab34868ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, the result will contain the number of samples in each bin. If &lt;code&gt;True&lt;/code&gt;, the result is the value of the probability &lt;em&gt;density&lt;/em&gt; function at the bin, normalized such that the &lt;em&gt;integral&lt;/em&gt; over the range is 1. Note that the sum of the histogram values will not be equal to 1 unless bins of unity width are chosen; it is not a probability &lt;em&gt;mass&lt;/em&gt; function.</source>
          <target state="translated">場合 &lt;code&gt;False&lt;/code&gt; 、結果は各ビンのサンプル数が含まれています。場合 &lt;code&gt;True&lt;/code&gt; を、結果は、確率の値である&lt;em&gt;濃度&lt;/em&gt;こと正規ようなビンにおける関数、&lt;em&gt;積分&lt;/em&gt;範囲にわたって、ヒストグラム値の和が選択される幅団結のビンない限り、1に等しくならないことに留意されたいです。確率&lt;em&gt;質量&lt;/em&gt;関数ではありません。</target>
        </trans-unit>
        <trans-unit id="ca7cba1e4456723daee790d09bd9b4e007a0b7f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;None&lt;/code&gt; (default), all constants are assumed to be zero. If &lt;code&gt;m = 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; （デフォルト）の場合、すべての定数はゼロと見なされます。 &lt;code&gt;m = 1&lt;/code&gt; 場合、リストの代わりに単一のスカラーを指定できます。</target>
        </trans-unit>
        <trans-unit id="aec21489ec4d901f1aa321dc3743c87fb290d768" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, swap bytes in-place, default is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、バイトをインプレースでスワップします。デフォルトは &lt;code&gt;False&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f2e3fbb074311bdb46e2b67afbf7fb14e162de56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, the cutoff of &lt;code&gt;precision&lt;/code&gt; digits refers to the total number of digits after the decimal point, including leading zeros. If &lt;code&gt;False&lt;/code&gt;, &lt;code&gt;precision&lt;/code&gt; refers to the total number of significant digits, before or after the decimal point, ignoring leading zeros.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、 &lt;code&gt;precision&lt;/code&gt; 桁の切り捨てとは、先行ゼロを含む、小数点以下の合計桁数を指します。 &lt;code&gt;False&lt;/code&gt; の場合、 &lt;code&gt;precision&lt;/code&gt; は、先行ゼロを無視して、小数点の前後の有効桁数の合計を指します。</target>
        </trans-unit>
        <trans-unit id="a29f76a184d9fb35f364bb63d222c84be040ac5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, then cache the first function call that determines the number of outputs if &lt;code&gt;otypes&lt;/code&gt; is not provided.</source>
          <target state="translated">場合は &lt;code&gt;True&lt;/code&gt; 、そして場合の出力数を決定する第1の関数呼び出しキャッシュ &lt;code&gt;otypes&lt;/code&gt; が提供されていませんが。</target>
        </trans-unit>
        <trans-unit id="7faac3985b746b05ac26d42bd00cce4fcc2669d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use a digit-generation strategy which gives the shortest representation which uniquely identifies the floating-point number from other values of the same type, by judicious rounding. If &lt;code&gt;precision&lt;/code&gt; was omitted, print all necessary digits, otherwise digit generation is cut off after &lt;code&gt;precision&lt;/code&gt; digits and the remaining value is rounded. If &lt;code&gt;False&lt;/code&gt;, digits are generated as if printing an infinite-precision value and stopping after &lt;code&gt;precision&lt;/code&gt; digits, rounding the remaining value.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、適切な丸めによって、浮動小数点数を同じ型の他の値から一意に識別する最短の表現を提供する数字生成戦略を使用します。 &lt;code&gt;precision&lt;/code&gt; が省略された場合、必要なすべての桁を印刷します。それ以外の場合、桁の生成は桁の &lt;code&gt;precision&lt;/code&gt; 後で切り捨てられ、残りの値は丸められます。 &lt;code&gt;False&lt;/code&gt; の場合、桁は無限精度の値を出力するかのように生成され、 &lt;code&gt;precision&lt;/code&gt; 桁の後に停止し、残りの値を丸めます。</target>
        </trans-unit>
        <trans-unit id="d46a903cfc558730b35e63368d27aca2360607f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use a digit-generation strategy which gives the shortest representation which uniquely identifies the floating-point number from other values of the same type, by judicious rounding. If &lt;code&gt;precision&lt;/code&gt; was omitted, print out all necessary digits, otherwise digit generation is cut off after &lt;code&gt;precision&lt;/code&gt; digits and the remaining value is rounded. If &lt;code&gt;False&lt;/code&gt;, digits are generated as if printing an infinite-precision value and stopping after &lt;code&gt;precision&lt;/code&gt; digits, rounding the remaining value.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; の場合、適切な丸めによって、浮動小数点数を同じ型の他の値から一意に識別する最短の表現を提供する数字生成戦略を使用します。 &lt;code&gt;precision&lt;/code&gt; が省略された場合、必要なすべての桁を出力します。それ以外の場合、 &lt;code&gt;precision&lt;/code&gt; 桁の後で桁の生成が切り捨てられ、残りの値は丸められます。 &lt;code&gt;False&lt;/code&gt; の場合、桁は無限精度の値を出力するかのように生成され、 &lt;code&gt;precision&lt;/code&gt; 桁の後に停止し、残りの値を丸めます。</target>
        </trans-unit>
        <trans-unit id="e630a68b772e53281799a75b2daa484538be6573" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = chebvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">もし &lt;code&gt;V = chebvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; 、その後の列 &lt;code&gt;V&lt;/code&gt; の 2次元係数配列の要素に対応する &lt;code&gt;c&lt;/code&gt; 形状の（xdeg + 1、ydeg + 1）のために</target>
        </trans-unit>
        <trans-unit id="8cbfd70f5cc4a9c80c1b3f4ac628ba80decf75d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">もし &lt;code&gt;V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; 、その後の列 &lt;code&gt;V&lt;/code&gt; の 3次元係数配列の要素に対応する &lt;code&gt;c&lt;/code&gt; 形状の（xdeg + 1、ydeg + 1、のZdeg + 1）順序で</target>
        </trans-unit>
        <trans-unit id="00bfc10fc177e8c4f7b6b34693c411592fe272c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermevander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">もし &lt;code&gt;V = hermevander2d(x, y, [xdeg, ydeg])&lt;/code&gt; 、その後の列 &lt;code&gt;V&lt;/code&gt; の 2次元係数配列の要素に対応する &lt;code&gt;c&lt;/code&gt; の順序で形状の（xdeg + 1、ydeg + 1）</target>
        </trans-unit>
        <trans-unit id="a7c811e070f694575d65f49ba72909eaec417a6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">もし &lt;code&gt;V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; 、その後の列 &lt;code&gt;V&lt;/code&gt; の 3次元係数配列の要素に対応する &lt;code&gt;c&lt;/code&gt; 形状の（xdeg + 1、ydeg + 1、のZdeg + 1）順序で</target>
        </trans-unit>
        <trans-unit id="262fc8f05dc54d641c4705041f46d8b6c771c1fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">もし &lt;code&gt;V = hermvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; 、その後の列 &lt;code&gt;V&lt;/code&gt; の 2次元係数配列の要素に対応する &lt;code&gt;c&lt;/code&gt; の順序で形状の（xdeg + 1、ydeg + 1）</target>
        </trans-unit>
        <trans-unit id="066ad3b1f4c835bc91d8b4d1ca954772c0457a46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">もし &lt;code&gt;V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; 、その後の列 &lt;code&gt;V&lt;/code&gt; の 3次元係数配列の要素に対応する &lt;code&gt;c&lt;/code&gt; 形状の（xdeg + 1、ydeg + 1、のZdeg + 1）順序で</target>
        </trans-unit>
        <trans-unit id="6596fc02b05eb1b57c388bcee28f45c0fa647e79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = lagvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">もし &lt;code&gt;V = lagvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; 、その後の列 &lt;code&gt;V&lt;/code&gt; の 2次元係数配列の要素に対応する &lt;code&gt;c&lt;/code&gt; の順序で形状の（xdeg + 1、ydeg + 1）</target>
        </trans-unit>
        <trans-unit id="658f3ceb580a0341f1c8e14be933e5829c9b95b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">もし &lt;code&gt;V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; 、その後の列 &lt;code&gt;V&lt;/code&gt; の 3-D係数配列の要素に対応する &lt;code&gt;c&lt;/code&gt; 形状の（xdeg + 1、ydeg + 1、のZdeg + 1）順序で</target>
        </trans-unit>
        <trans-unit id="102bddd53317314797d80d0b03e0de44ee8eec62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = legvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">もし &lt;code&gt;V = legvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; 、その後の列 &lt;code&gt;V&lt;/code&gt; の 2次元係数配列の要素に対応する &lt;code&gt;c&lt;/code&gt; の順序で形状の（xdeg + 1、ydeg + 1）</target>
        </trans-unit>
        <trans-unit id="f9e4383801f2b61b08f9300b1b7fdf17e1c3f488" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">もし &lt;code&gt;V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; 、その後の列 &lt;code&gt;V&lt;/code&gt; の 3-D係数配列の要素に対応する &lt;code&gt;c&lt;/code&gt; 形状の（xdeg + 1、ydeg + 1、のZdeg + 1）順序で</target>
        </trans-unit>
        <trans-unit id="c691cf5dd3bcc26326919122a716b1456743d83e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = polyvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">もし &lt;code&gt;V = polyvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; 、その後の列 &lt;code&gt;V&lt;/code&gt; の 2次元係数配列の要素に対応する &lt;code&gt;c&lt;/code&gt; 形状の（xdeg + 1、ydeg + 1）のために</target>
        </trans-unit>
        <trans-unit id="3795a0fc387856e1a4fb9463ff23e8e2dc033c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">もし &lt;code&gt;V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; 、その後の列 &lt;code&gt;V&lt;/code&gt; の 3次元係数配列の要素に対応する &lt;code&gt;c&lt;/code&gt; 形状の（xdeg + 1、ydeg + 1、のZdeg + 1）順序で</target>
        </trans-unit>
        <trans-unit id="f8959bef2f1f180cd1904ca3003b3eeaecf0bbcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.fill_value == b.fill_value&lt;/code&gt;, return the fill value, otherwise return None.</source>
          <target state="translated">&lt;code&gt;a.fill_value == b.fill_value&lt;/code&gt; 場合は塗りつぶし値を返し、それ以外の場合はなしを返します。</target>
        </trans-unit>
        <trans-unit id="8f6e1a60280ed3603677c79dbcdebfa7ff398c42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt;, then the dimensions specified by &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; are removed, and a new axis inserted at the end corresponding to the diagonal.</source>
          <target state="translated">&lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; 場合、 &lt;code&gt;axis1&lt;/code&gt; および &lt;code&gt;axis2&lt;/code&gt; で指定された寸法が削除され、対角線に対応する端に新しい軸が挿入されます。</target>
        </trans-unit>
        <trans-unit id="64c4131bb0fe8a413fc2bc1ebe219f3e36ea1e9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.ndim&lt;/code&gt; is 0, then since the depth of the nested list is 0, it will not be a list at all, but a simple Python scalar.</source>
          <target state="translated">&lt;code&gt;a.ndim&lt;/code&gt; が0の場合、ネストされたリストの深さは0であるため、リストではなく、単純なPythonスカラーになります。</target>
        </trans-unit>
        <trans-unit id="355d7bac3059f5072f60fecea5ae0b7d9ef0b74d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.shape&lt;/code&gt; is (5,1), &lt;code&gt;b.shape&lt;/code&gt; is (1,6), &lt;code&gt;c.shape&lt;/code&gt; is (6,) and &lt;code&gt;d.shape&lt;/code&gt; is () so that &lt;em&gt;d&lt;/em&gt; is a scalar, then &lt;em&gt;a&lt;/em&gt;, &lt;em&gt;b&lt;/em&gt;, &lt;em&gt;c&lt;/em&gt;, and &lt;em&gt;d&lt;/em&gt; are all broadcastable to dimension (5,6); and</source>
          <target state="translated">場合 &lt;code&gt;a.shape&lt;/code&gt; が（5,1）である &lt;code&gt;b.shape&lt;/code&gt; （1,6）であり、 &lt;code&gt;c.shape&lt;/code&gt; は（6）であり、 &lt;code&gt;d.shape&lt;/code&gt; は（ある）ように、&lt;em&gt;Dは&lt;/em&gt;スカラー、その後で、&lt;em&gt;B&lt;/em&gt;、&lt;em&gt;C&lt;/em&gt;、および&lt;em&gt;d&lt;/em&gt;はすべて次元（5,6）にブロードキャスト可能です。そして&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="61914428b3107b079ee31cfc27e080d8a722c6a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are nonscalar, their last dimensions must match.</source>
          <target state="translated">場合と &lt;code&gt;b&lt;/code&gt; が非スカラーの、彼らの最後の寸法が一致している必要があります。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4f4e526a35a19438379df1f3dbff9a3882d194d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and each choice array are not all broadcastable to the same shape.</source>
          <target state="translated">場合は、各選択肢の配列は、すべて同じ形状にbroadcastableではありません。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6714bc3434562dda36e8035d926f1d408c7a5936" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; does not own its own data or references or views to it exist, and the data memory must be changed. PyPy only: will always raise if the data memory must be changed, since there is no reliable way to determine if references or views to it exist.</source>
          <target state="translated">が独自のデータまたはそれへの参照またはビューを所有し &lt;code&gt;a&lt;/code&gt; いない場合、データメモリを変更する必要があります。 PyPyのみ：データメモリへの参照またはビューが存在するかどうかを確認する信頼できる方法がないため、データメモリを変更する必要がある場合は常に発生します。</target>
        </trans-unit>
        <trans-unit id="d46ad13c1a8181bf81ec49d29f19d0a4e8222929" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then broadcasting rules apply, as explained in &lt;a href=&quot;../routines.linalg#routines-linalg-broadcasting&quot;&gt;Linear algebra on several matrices at once&lt;/a&gt;. This means that SVD is working in &amp;ldquo;stacked&amp;rdquo; mode: it iterates over all indices of the first &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensions and for each combination SVD is applied to the last two indices. The matrix &lt;code&gt;a&lt;/code&gt; can be reconstructed from the decomposition with either &lt;code&gt;(u * s[..., None, :]) @ vh&lt;/code&gt; or &lt;code&gt;u @ (s[..., None] * vh)&lt;/code&gt;. (The &lt;code&gt;@&lt;/code&gt; operator can be replaced by the function &lt;code&gt;np.matmul&lt;/code&gt; for python versions below 3.5.)</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; が3つ以上の次元を持っている場合、&lt;a href=&quot;../routines.linalg#routines-linalg-broadcasting&quot;&gt;一度に複数の行列の線形代数で&lt;/a&gt;説明されているように、ブロードキャストルールが適用されます。これは、SVDが「スタック」モードで動作していることを意味します。これは、最初の &lt;code&gt;a.ndim - 2&lt;/code&gt; 次元のすべてのインデックスを反復処理し、組み合わせごとにSVDが最後の2つのインデックスに適用されます。行列 &lt;code&gt;a&lt;/code&gt; は、 &lt;code&gt;(u * s[..., None, :]) @ vh&lt;/code&gt; または &lt;code&gt;u @ (s[..., None] * vh)&lt;/code&gt; いずれかを使用して分解から再構築できます。 （ &lt;code&gt;@&lt;/code&gt; 演算子は、3.5より前のバージョンのPythonでは関数 &lt;code&gt;np.matmul&lt;/code&gt; で置き換えることができます。）</target>
        </trans-unit>
        <trans-unit id="0f5e97c2878caebdac54716045091816869ce6d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then the axes specified by axis1 and axis2 are used to determine the 2-D sub-arrays whose traces are returned. The shape of the resulting array is the same as that of &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; removed.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; の次元が3つ以上の場合、 axis1およびaxis2で指定された軸を使用して、トレースが返される2次元サブ配列を決定します。得られたアレイの形状はと同じであると &lt;code&gt;axis1&lt;/code&gt; と &lt;code&gt;axis2&lt;/code&gt; 除去します。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b46ead587370435670ac4bc03b81d9c95e42b33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 1-D, the function &lt;code&gt;ufunc.accumulate(a)&lt;/code&gt; is the same as &lt;code&gt;ufunc.reduceat(a, indices)[::2]&lt;/code&gt; where &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;range(len(array) - 1)&lt;/code&gt; with a zero placed in every other element: &lt;code&gt;indices = zeros(2 * len(a) - 1)&lt;/code&gt;, &lt;code&gt;indices[1::2] = range(1, len(a))&lt;/code&gt;.</source>
          <target state="translated">場合1-Dであり、関数 &lt;code&gt;ufunc.accumulate(a)&lt;/code&gt; と同じである &lt;code&gt;ufunc.reduceat(a, indices)[::2]&lt;/code&gt; &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt;ある &lt;code&gt;range(len(array) - 1)&lt;/code&gt; 毎に配置されたゼロとその他の要素： &lt;code&gt;indices = zeros(2 * len(a) - 1)&lt;/code&gt; 、 &lt;code&gt;indices[1::2] = range(1, len(a))&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b8db921b8261a5150c028a4a52e2a78422e254b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, returns the diagonal of &lt;code&gt;a&lt;/code&gt; with the given offset, i.e., the collection of elements of the form &lt;code&gt;a[i, i+offset]&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then the axes specified by &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; are used to determine the 2-D sub-array whose diagonal is returned. The shape of the resulting array can be determined by removing &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; and appending an index to the right equal to the size of the resulting diagonals.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; が2次元の場合、指定されたオフセット、つまり &lt;code&gt;a[i, i+offset]&lt;/code&gt; 形式の要素のコレクションを持つ &lt;code&gt;a&lt;/code&gt; の対角線を返します。 &lt;code&gt;a&lt;/code&gt; の次元が3つ以上の場合、 &lt;code&gt;axis1&lt;/code&gt; および &lt;code&gt;axis2&lt;/code&gt; で指定された軸を使用して、対角線が返される2次元サブ配列を決定します。結果の配列の形状は、 &lt;code&gt;axis1&lt;/code&gt; と &lt;code&gt;axis2&lt;/code&gt; を削除し、結果の対角線のサイズに等しいインデックスを右側に追加することで決定できます。</target>
        </trans-unit>
        <trans-unit id="016f6a15e05ea7909f939f7c56abdd96bd940bcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, the sum along its diagonal with the given offset is returned, i.e., the sum of elements &lt;code&gt;a[i,i+offset]&lt;/code&gt; for all i.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; が2次元の場合、指定されたオフセットでの対角線に沿った合計、つまりすべてのi の要素 &lt;code&gt;a[i,i+offset]&lt;/code&gt; の合計が返されます。</target>
        </trans-unit>
        <trans-unit id="821330dbafd930ef241f18ef291a677b001e3d1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, the sum along the diagonal is returned. If &lt;code&gt;a&lt;/code&gt; has larger dimensions, then an array of sums along diagonals is returned.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; が2次元の場合、対角線に沿った合計が返されます。 &lt;code&gt;a&lt;/code&gt; の次元が大きい場合、対角線に沿った合計の配列が返されます。</target>
        </trans-unit>
        <trans-unit id="20e0991e165d15052f7414c1d9067709a6741ba8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, then a 1-D array containing the diagonal and of the same type as &lt;code&gt;a&lt;/code&gt; is returned unless &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, in which case a 1-D array rather than a (2-D) &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; is returned in order to maintain backward compatibility.</source>
          <target state="translated">場合、次に2-D、対角線とを含む1次元配列されるのと同じタイプのない限り、返されている&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 1次元配列ではなく、（2-D）、その場合、&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;返されます下位互換性を維持するため。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65772464bb82fc9b6e011b51f1c71a9673e3a5fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;matrix&lt;/code&gt; object (as opposed to an &lt;code&gt;ndarray&lt;/code&gt;), then so are all the return values.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; が（ &lt;code&gt;ndarray&lt;/code&gt; ではなく） &lt;code&gt;matrix&lt;/code&gt; オブジェクトである場合、すべての戻り値も同様です。</target>
        </trans-unit>
        <trans-unit id="cea4b92a7534a3149383f752281c310050f705b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a reference to &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;(a is b) == True&lt;/code&gt;. Therefore, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are different names for the same Python object.</source>
          <target state="translated">場合への参照である &lt;code&gt;b&lt;/code&gt; 、次いで &lt;code&gt;(a is b) == True&lt;/code&gt; 。したがって、 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; は同じPythonオブジェクトの異なる名前です。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f198160018800c5362e7b3890cbfcb18e618a7b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a subclass of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, its class is conserved. No copy is performed if the input is already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">場合のサブクラスである&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;、そのクラスが保存されています。入力がすでに&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; である&lt;/a&gt;場合、コピーは実行されません。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="edeed84f3c81e9ebf31ecd438474825302f801e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a subclass of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, its class is conserved. No copy is performed if the input is already an &lt;code&gt;ndarray&lt;/code&gt;.</source>
          <target state="translated">場合のサブクラスである&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;、そのクラスが保存されています。入力がすでに &lt;code&gt;ndarray&lt;/code&gt; である場合、コピーは実行されません。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="79b3d97ca6a58beeb5178bade7556181ec643eb5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an N-D array and &lt;code&gt;b&lt;/code&gt; is a 1-D array, it is a sum product over the last axis of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">場合NDアレイであり、 &lt;code&gt;b&lt;/code&gt; は 1次元配列であり、それは最後の軸上和生成物であると &lt;code&gt;b&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41bd115d2530c0df6f893d58055a4e7bbeb51a86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an N-D array and &lt;code&gt;b&lt;/code&gt; is an M-D array (where &lt;code&gt;M&amp;gt;=2&lt;/code&gt;), it is a sum product over the last axis of &lt;code&gt;a&lt;/code&gt; and the second-to-last axis of &lt;code&gt;b&lt;/code&gt;:</source>
          <target state="translated">場合NDアレイであり &lt;code&gt;b&lt;/code&gt; MD配列である（ここで、 &lt;code&gt;M&amp;gt;=2&lt;/code&gt; ）、それは最後の軸上和生成物であるとの最後から2番目の軸 &lt;code&gt;b&lt;/code&gt; ： &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2d3d6c358f256f08097a63c0a16dbce473bc638" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is complex the complex conjugate is taken before calculation of the dot product.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; が複素数の場合、ドット積の計算前に複素共役が取得されます。</target>
        </trans-unit>
        <trans-unit id="eccde6fba477d4d0328834eeb9139f4c209a7f8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is not a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;a&lt;/code&gt; itself is returned. If &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fill_value&lt;/code&gt; is None, &lt;code&gt;fill_value&lt;/code&gt; is set to &lt;code&gt;a.fill_value&lt;/code&gt;.</source>
          <target state="translated">場合ではない&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;、自身が返されます。場合で&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;fill_value&lt;/code&gt; は Noneです、 &lt;code&gt;fill_value&lt;/code&gt; がに設定されている &lt;code&gt;a.fill_value&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ac306a4eb2b5b20798f61a7b119dddd329017ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is not square or inversion fails.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; が正方でない場合、または反転が失敗した場合。</target>
        </trans-unit>
        <trans-unit id="dc36615c1be692990452f6adc2c02bec7979d9d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is real, the type of &lt;code&gt;a&lt;/code&gt; is used for the output. If &lt;code&gt;a&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; が実数の場合、出力には &lt;code&gt;a&lt;/code&gt; のタイプが使用されます。場合は、複雑な要素を持って、返された型はfloatです。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49742c1cee8e9efafb1c7fbbe431a8e95469bbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is singular or not &amp;lsquo;square&amp;rsquo; (in the above sense).</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; が特異であるか、「上記の意味で」「正方形」でない場合。</target>
        </trans-unit>
        <trans-unit id="2e9b74892f6f35d0326c1dc235300557d874f5a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is singular or not square.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; が特異または正方形でない場合。</target>
        </trans-unit>
        <trans-unit id="ceece9b2545779310cb6355ec10529e551268898" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align=False&lt;/code&gt;, this method produces a &amp;ldquo;packed&amp;rdquo; memory layout in which each field starts at the byte the previous field ended, and any padding bytes are removed.</source>
          <target state="translated">&lt;code&gt;align=False&lt;/code&gt; の場合、このメソッドは「パックされた」メモリレイアウトを生成します。このレイアウトでは、各フィールドは前のフィールドが終了したバイトから始まり、パディングバイトはすべて削除されます。</target>
        </trans-unit>
        <trans-unit id="460932656f30d1ee879c1ced09e2eca3e1ff623d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align=True&lt;/code&gt; is set, numpy will pad the structure in the same way many C compilers would pad a C-struct. Aligned structures can give a performance improvement in some cases, at the cost of increased datatype size. Padding bytes are inserted between fields such that each field&amp;rsquo;s byte offset will be a multiple of that field&amp;rsquo;s alignment, which is usually equal to the field&amp;rsquo;s size in bytes for simple datatypes, see &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr.alignment&quot;&gt;&lt;code&gt;PyArray_Descr.alignment&lt;/code&gt;&lt;/a&gt;. The structure will also have trailing padding added so that its itemsize is a multiple of the largest field&amp;rsquo;s alignment.</source>
          <target state="translated">&lt;code&gt;align=True&lt;/code&gt; が設定されている場合、numpyは、多くのCコンパイラがC構造体をパディングするのと同じ方法で構造体をパディングします。整列された構造は、データ型のサイズが大きくなる代わりに、場合によってはパフォーマンスを向上させることができます。パディングバイトは、各フィールドのバイトオフセットがそのフィールドの配置の倍数になるようにフィールド間に挿入されます。これは通常、単純なデータ型のフィールドのバイト単位のサイズに等しくなります&lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr.alignment&quot;&gt; &lt;code&gt;PyArray_Descr.alignment&lt;/code&gt; &lt;/a&gt;参照してください。構造には末尾のパディングも追加されるため、そのアイテムサイズは最大のフィールドの配置の倍数になります。</target>
        </trans-unit>
        <trans-unit id="3b8c190caa583967ef3d50f42e6abb370b98e8c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align=True&lt;/code&gt;, this methods produces an &amp;ldquo;aligned&amp;rdquo; memory layout in which each field&amp;rsquo;s offset is a multiple of its alignment, and the total itemsize is a multiple of the largest alignment, by adding padding bytes as needed.</source>
          <target state="translated">&lt;code&gt;align=True&lt;/code&gt; の場合、このメソッドは、必要に応じてパディングバイトを追加することにより、各フィールドのオフセットがその配置の倍数であり、アイテムサイズの合計が最大の配置の倍数である「配置された」メモリレイアウトを生成します。</target>
        </trans-unit>
        <trans-unit id="18f554f1ca3b0160e94e964322795aa916ef0365" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arr&lt;/code&gt; doesn&amp;rsquo;t have a shape attribute (i.e. not an ndarray)</source>
          <target state="translated">場合 &lt;code&gt;arr&lt;/code&gt; 形状属性を持たない（すなわちないndarray）</target>
        </trans-unit>
        <trans-unit id="6f94c014869b41cb6e3e090bab6cec3fc3652e46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axes&lt;/code&gt; is larger than the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;axes&lt;/code&gt; 最後の軸よりも大きくなっています。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb5967cac1f9c838f629289b9701f4f5d967c63e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is 0, only rows are masked.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; が0の場合、行のみがマスクされます。</target>
        </trans-unit>
        <trans-unit id="e77d1c339b65acf6a89a949d1d50328c8561be33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is 1 or -1, only columns are masked.</source>
          <target state="translated">場合は &lt;code&gt;axis&lt;/code&gt; 1または-1である、唯一の列がマスクされています。</target>
        </trans-unit>
        <trans-unit id="527dba2aee917b7e820a9015382f439872829fc2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is None, rows &lt;em&gt;and&lt;/em&gt; columns are masked.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; がNoneの場合、行&lt;em&gt;と&lt;/em&gt;列はマスクされます。</target>
        </trans-unit>
        <trans-unit id="1c5e761c4a44d3d8422fc68aeed03dd9853a0a7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is None, the result is a scalar. Otherwise, if &lt;code&gt;axis&lt;/code&gt; is given and the array is at least 2-D, the result is a masked array with dimension one smaller than the array on which &lt;a href=&quot;#numpy.ma.masked_array.mini&quot;&gt;&lt;code&gt;mini&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">場合は &lt;code&gt;axis&lt;/code&gt; Noneで、結果はスカラーです。それ以外の場合、 &lt;code&gt;axis&lt;/code&gt; が指定され、配列が少なくとも2次元である場合、結果は、&lt;a href=&quot;#numpy.ma.masked_array.mini&quot;&gt; &lt;code&gt;mini&lt;/code&gt; &lt;/a&gt;が呼び出される配列よりも1小さい次元のマスクされた配列になります。</target>
        </trans-unit>
        <trans-unit id="042bc001a4914cd7d0d232c6f0fb346989909740" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is an integer, it specifies the axis of &lt;code&gt;x&lt;/code&gt; along which to compute the vector norms. If &lt;code&gt;axis&lt;/code&gt; is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed. If &lt;code&gt;axis&lt;/code&gt; is None then either a vector norm (when &lt;code&gt;x&lt;/code&gt; is 1-D) or a matrix norm (when &lt;code&gt;x&lt;/code&gt; is 2-D) is returned.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; が整数の場合、ベクトルノルムを計算する &lt;code&gt;x&lt;/code&gt; の軸を指定します。 &lt;code&gt;axis&lt;/code&gt; が2タプルの場合、2次元行列を保持する軸を指定し、これらの行列の行列ノルムが計算されます。 &lt;code&gt;axis&lt;/code&gt; がNoneの場合、ベクトルノルム（ &lt;code&gt;x&lt;/code&gt; が1次元の場合）または行列ノルム（ &lt;code&gt;x&lt;/code&gt; が2次元の場合）が返されます。</target>
        </trans-unit>
        <trans-unit id="bfadfc7eb4a4188168e39022bbb71c1c25d02efa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is an integer, it specifies the axis of &lt;code&gt;x&lt;/code&gt; along which to compute the vector norms. If &lt;code&gt;axis&lt;/code&gt; is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed. If &lt;code&gt;axis&lt;/code&gt; is None then either a vector norm (when &lt;code&gt;x&lt;/code&gt; is 1-D) or a matrix norm (when &lt;code&gt;x&lt;/code&gt; is 2-D) is returned. The default is None.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; が整数の場合、ベクトルノルムを計算する &lt;code&gt;x&lt;/code&gt; の軸を指定します。 &lt;code&gt;axis&lt;/code&gt; が2タプルの場合、2次元行列を保持する軸を指定し、これらの行列の行列ノルムが計算されます。 &lt;code&gt;axis&lt;/code&gt; がNoneの場合、ベクトルノルム（ &lt;code&gt;x&lt;/code&gt; が1-Dの場合）または行列ノルム（ &lt;code&gt;x&lt;/code&gt; が2-Dの場合）のいずれかが返されます。デフォルトはNoneです。</target>
        </trans-unit>
        <trans-unit id="523d86ecb59b40a9d925f2a1e78fa6cb76926a2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is given, the number of varargs must equal the number of axes. Default: 1.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; が指定されている場合、可変引数の数は軸の数と等しくなければなりません。デフォルト：1。</target>
        </trans-unit>
        <trans-unit id="86e33ec8c24f94e2430b0659a5ab81a91a91d564" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is larger than the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;axis&lt;/code&gt; 最後の軸よりも大きくなっています。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b10999639108c4b4999de59d1e8da7d5676f431c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, and an axis being squeezed is not of length 1</source>
          <target state="translated">場合 &lt;code&gt;axis&lt;/code&gt; ません。 &lt;code&gt;None&lt;/code&gt; 、かつ軸は圧迫されている長さではない1</target>
        </trans-unit>
        <trans-unit id="048ac1275e643db0f79c87e34405c76349afe0b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is not None, and an axis being squeezed is not of length 1</source>
          <target state="translated">場合 &lt;code&gt;axis&lt;/code&gt; Noneでない、そして軸は圧迫されて長さではない1</target>
        </trans-unit>
        <trans-unit id="62e5f5a4f466db64bba565371ecaf3c0accbb2cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b = a[:100]&lt;/code&gt; is used instead, &lt;code&gt;a&lt;/code&gt; is referenced by &lt;code&gt;b&lt;/code&gt; and will persist in memory even if &lt;code&gt;del a&lt;/code&gt; is executed.</source>
          <target state="translated">場合 &lt;code&gt;b = a[:100]&lt;/code&gt; 代わりに使用される、によって参照される &lt;code&gt;b&lt;/code&gt; と場合でもメモリに持続する &lt;code&gt;del a&lt;/code&gt; 実行されます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1ba1d797cf86b71e14a5b8da31b21199908a909" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is a matrix, then all array results are returned as matrices.</source>
          <target state="translated">場合 &lt;code&gt;b&lt;/code&gt; 行列であり、すべてのアレイの結果は行列として返されます。</target>
        </trans-unit>
        <trans-unit id="ca0b482dcb07a6085a21a5bc1b0dde224b2f172c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is a string from the list below, &lt;a href=&quot;#numpy.histogram_bin_edges&quot;&gt;&lt;code&gt;histogram_bin_edges&lt;/code&gt;&lt;/a&gt; will use the method chosen to calculate the optimal bin width and consequently the number of bins (see &lt;code&gt;Notes&lt;/code&gt; for more detail on the estimators) from the data that falls within the requested range. While the bin width will be optimal for the actual data in the range, the number of bins will be computed to fill the entire range, including the empty portions. For visualisation, using the &amp;lsquo;auto&amp;rsquo; option is suggested. Weighted data is not supported for automated bin size selection.</source>
          <target state="translated">&lt;code&gt;bins&lt;/code&gt; が以下のリストの文字列である場合、&lt;a href=&quot;#numpy.histogram_bin_edges&quot;&gt; &lt;code&gt;histogram_bin_edges&lt;/code&gt; &lt;/a&gt;は、選択された方法を使用して、要求された範囲内にあるデータから最適なビンの幅を計算し、結果としてビンの数（推定量の詳細については「 &lt;code&gt;Notes&lt;/code&gt; を参照）を計算します。ビンの幅は範囲内の実際のデータに最適ですが、ビンの数は空の部分を含む範囲全体を満たすように計算されます。視覚化のために、「自動」オプションを使用することをお勧めします。重み付けされたデータは、自動ビンサイズ選択ではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="b70a91ff0eb4c89d18a81d985f393eb13ac7933f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is a string, it defines the method used to calculate the optimal bin width, as defined by &lt;a href=&quot;numpy.histogram_bin_edges#numpy.histogram_bin_edges&quot;&gt;&lt;code&gt;histogram_bin_edges&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;bins&lt;/code&gt; が文字列の場合は、&lt;a href=&quot;numpy.histogram_bin_edges#numpy.histogram_bin_edges&quot;&gt; &lt;code&gt;histogram_bin_edges&lt;/code&gt; で&lt;/a&gt;定義されているように、最適なビンの幅を計算するために使用されるメソッドを定義します。</target>
        </trans-unit>
        <trans-unit id="cbffbf31546ec9af5b6fd778dfc3e0a7e49fc75c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is an int, it defines the number of equal-width bins in the given range (10, by default). If &lt;code&gt;bins&lt;/code&gt; is a sequence, it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths.</source>
          <target state="translated">&lt;code&gt;bins&lt;/code&gt; がintの場合、指定された範囲（デフォルトでは10）内の等幅のビンの数を定義します。場合 &lt;code&gt;bins&lt;/code&gt; 配列され、それは不均一なビン幅を考慮して、最も右側のエッジを含むビンエッジの単調に増加する配列を定義します。</target>
        </trans-unit>
        <trans-unit id="b4024bb04b779936a7803a2173c03bd8c96f6ec1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is an int, it defines the number of equal-width bins in the given range (10, by default). If &lt;code&gt;bins&lt;/code&gt; is a sequence, it defines the bin edges, including the rightmost edge, allowing for non-uniform bin widths.</source>
          <target state="translated">&lt;code&gt;bins&lt;/code&gt; がintの場合、指定された範囲（デフォルトでは10）内の等幅のビンの数を定義します。 &lt;code&gt;bins&lt;/code&gt; がシーケンスの場合は、右端を含むビンエッジを定義し、不均一なビン幅を可能にします。</target>
        </trans-unit>
        <trans-unit id="f3d0d1457dc2c27ebf07eb8b8d37fdfe4b5b5f86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is not monotonic.</source>
          <target state="translated">&lt;code&gt;bins&lt;/code&gt; が単調でない場合。</target>
        </trans-unit>
        <trans-unit id="f1d57ef4cb7d5156a4314b6ea06d7045fe52a5fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is None, then only &lt;a href=&quot;numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;order&lt;/code&gt; are used.</source>
          <target state="translated">&lt;code&gt;buffer&lt;/code&gt; がNoneの場合、&lt;a href=&quot;numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;、および &lt;code&gt;order&lt;/code&gt; のみが使用されます。</target>
        </trans-unit>
        <trans-unit id="eb00c687c7393dfd8dae48855df788062a7f7eb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is None, then only &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;order&lt;/code&gt; are used.</source>
          <target state="translated">&lt;code&gt;buffer&lt;/code&gt; がNoneの場合、&lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;、および &lt;code&gt;order&lt;/code&gt; のみが使用されます。</target>
        </trans-unit>
        <trans-unit id="a3f34c748ade1a438e4af494b9939bb52d6b65ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is an object exposing the buffer interface, then all keywords are interpreted.</source>
          <target state="translated">&lt;code&gt;buffer&lt;/code&gt; がbufferインターフェースを公開するオブジェクトである場合、すべてのキーワードが解釈されます。</target>
        </trans-unit>
        <trans-unit id="f67df360e18cb83b99203eea7e5b2b66896eaba4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffersize&lt;/code&gt; is zero, a default buffer size is used, otherwise it specifies how big of a buffer to use. Buffers which are powers of 2 such as 4096 or 8192 are recommended.</source>
          <target state="translated">場合 &lt;code&gt;buffersize&lt;/code&gt; ゼロで、デフォルトのバッファサイズが使用され、それ以外の場合は、どのように大きな使用するバッファの指定します。4096や8192などの2の累乗のバッファーをお勧めします。</target>
        </trans-unit>
        <trans-unit id="beb58b828353ed80b8e0bbe892a75cbfcebae43d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than 3 dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; の次元数が3未満の場合、その次元に暗黙的に追加されて3次元になります。結果の形状は、c.shape [3：] + x.shapeになります。</target>
        </trans-unit>
        <trans-unit id="f7c13f789159cee3609188e9f6918f23db3edd6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than three dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape + y.shape + z.shape.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; の次元が3つ未満の場合、その次元に暗黙的に追加されて3次元になります。結果の形状は、c.shape [3：] + x.shape + y.shape + z.shapeになります。</target>
        </trans-unit>
        <trans-unit id="210c7187323274ff624491c071d18c59ba05eaa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than two dimensions, ones are implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape + y.shape.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; の次元が2つ未満の場合、その次元に暗黙的に1が追加されて2次元になります。結果の形状はc.shape [2：] + x.shape + y.shapeになります。</target>
        </trans-unit>
        <trans-unit id="4b9c82b7f7444c244d3d87499e2e6abb52d1e818" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than two dimensions, ones are implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; の次元が2つ未満の場合、その次元に暗黙的に1が追加されて2次元になります。結果の形状は、c.shape [2：] + x.shapeになります。</target>
        </trans-unit>
        <trans-unit id="b813783672e3b8b110dcc3caed6943e29c499cf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array a one is implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape.</source>
          <target state="translated">場合 &lt;code&gt;c&lt;/code&gt; は 1次元配列であるものは、暗黙的に2次元にする形状に追加されます。結果の形状は、c.shape [2：] + x.shapeになります。</target>
        </trans-unit>
        <trans-unit id="9b697950a550c5d2ac6bfd1a90d0ee0cf3873621" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = hermevander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;hermeval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of HermiteE series of the same degree and sample points.</source>
          <target state="translated">場合 &lt;code&gt;c&lt;/code&gt; は長さの係数の1次元配列である &lt;code&gt;n + 1&lt;/code&gt; 及び &lt;code&gt;V&lt;/code&gt; が配列である &lt;code&gt;V = hermevander(x, n)&lt;/code&gt; 、次いで &lt;code&gt;np.dot(V, c)&lt;/code&gt; 及び &lt;code&gt;hermeval(x, c)&lt;/code&gt; に同じ最大であります丸め。この同等性は、最小二乗フィッティングと、同じ次数とサンプルポイントの多数のHermiteEシリーズの評価の両方に役立ちます。</target>
        </trans-unit>
        <trans-unit id="8795163ae21f93104b677b1ca18c8738fd9a209a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = hermvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;hermval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Hermite series of the same degree and sample points.</source>
          <target state="translated">場合 &lt;code&gt;c&lt;/code&gt; は長さの係数の1次元配列である &lt;code&gt;n + 1&lt;/code&gt; 及び &lt;code&gt;V&lt;/code&gt; が配列である &lt;code&gt;V = hermvander(x, n)&lt;/code&gt; 、次いで &lt;code&gt;np.dot(V, c)&lt;/code&gt; 及び &lt;code&gt;hermval(x, c)&lt;/code&gt; に同じ最大であります丸め。この同等性は、最小二乗フィッティングと、同じ次数とサンプルポイントの多数のエルミートシリーズの評価の両方に役立ちます。</target>
        </trans-unit>
        <trans-unit id="41e4b417db13b3be059bf5b8693dedddbf2d39c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = lagvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;lagval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Laguerre series of the same degree and sample points.</source>
          <target state="translated">場合 &lt;code&gt;c&lt;/code&gt; は長さの係数の1次元配列である &lt;code&gt;n + 1&lt;/code&gt; 及び &lt;code&gt;V&lt;/code&gt; が配列である &lt;code&gt;V = lagvander(x, n)&lt;/code&gt; 、次いで &lt;code&gt;np.dot(V, c)&lt;/code&gt; 及び &lt;code&gt;lagval(x, c)&lt;/code&gt; に同じ最大であります丸め。この同等性は、最小二乗フィッティングと、同じ次数とサンプルポイントの多数のラゲール級数の評価の両方に役立ちます。</target>
        </trans-unit>
        <trans-unit id="a1b597f29a3697113f705d9c197e77e09839d912" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = legvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;legval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Legendre series of the same degree and sample points.</source>
          <target state="translated">場合 &lt;code&gt;c&lt;/code&gt; は長さの係数の1次元配列である &lt;code&gt;n + 1&lt;/code&gt; と &lt;code&gt;V&lt;/code&gt; が配列である &lt;code&gt;V = legvander(x, n)&lt;/code&gt; 、次いで &lt;code&gt;np.dot(V, c)&lt;/code&gt; 及び &lt;code&gt;legval(x, c)&lt;/code&gt; に同じ最大であります丸め。この同等性は、最小二乗フィッティングと、同じ次数とサンプルポイントの多数のルジャンドル系列の評価の両方に役立ちます。</target>
        </trans-unit>
        <trans-unit id="b7f0c7e082f8807f04eefbe2acbae592bdec65ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the matrix &lt;code&gt;V = chebvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;chebval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Chebyshev series of the same degree and sample points.</source>
          <target state="translated">場合 &lt;code&gt;c&lt;/code&gt; は長さの係数の1次元配列である &lt;code&gt;n + 1&lt;/code&gt; と &lt;code&gt;V&lt;/code&gt; は行列である &lt;code&gt;V = chebvander(x, n)&lt;/code&gt; 、次いで &lt;code&gt;np.dot(V, c)&lt;/code&gt; 及び &lt;code&gt;chebval(x, c)&lt;/code&gt; に同じ最大であります丸め。この同等性は、最小二乗フィッティングと、同じ次数とサンプルポイントの多数のチェビシェフシリーズの評価の両方に役立ちます。</target>
        </trans-unit>
        <trans-unit id="4e382928aa8d32a6b35f8adca3a6cffe61170326" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the matrix &lt;code&gt;V = polyvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;polyval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of polynomials of the same degree and sample points.</source>
          <target state="translated">場合 &lt;code&gt;c&lt;/code&gt; は長さの係数の1次元配列である &lt;code&gt;n + 1&lt;/code&gt; と &lt;code&gt;V&lt;/code&gt; は行列である &lt;code&gt;V = polyvander(x, n)&lt;/code&gt; 、次いで &lt;code&gt;np.dot(V, c)&lt;/code&gt; と &lt;code&gt;polyval(x, c)&lt;/code&gt; に同じ最大であります丸め。この同等性は、最小二乗フィッティングと、同じ次数とサンプルポイントの多数の多項式の評価の両方に役立ちます。</target>
        </trans-unit>
        <trans-unit id="8e80660168c2556d80131aae5098ce463a202c8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array, then &lt;code&gt;p(x)&lt;/code&gt; will have the same shape as &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; is multidimensional, then the shape of the result depends on the value of &lt;code&gt;tensor&lt;/code&gt;. If &lt;code&gt;tensor&lt;/code&gt; is true the shape will be c.shape[1:] + x.shape. If &lt;code&gt;tensor&lt;/code&gt; is false the shape will be c.shape[1:]. Note that scalars have shape (,).</source>
          <target state="translated">場合 &lt;code&gt;c&lt;/code&gt; は 1次元配列である場合、 &lt;code&gt;p(x)&lt;/code&gt; 同じ形状になります &lt;code&gt;x&lt;/code&gt; 。 &lt;code&gt;c&lt;/code&gt; が多次元の場合、結果の形状は &lt;code&gt;tensor&lt;/code&gt; の値に依存します。場合 &lt;code&gt;tensor&lt;/code&gt; + x.shape：本当である形状がc.shape [1]になります。 &lt;code&gt;tensor&lt;/code&gt; がfalseの場合、形状はc.shape [1：]になります。スカラーには形状（、）があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0a3728daa3b2e189e758d347ca0d72357650db3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is of length &lt;code&gt;n + 1&lt;/code&gt;, this function returns the value</source>
          <target state="translated">場合 &lt;code&gt;c&lt;/code&gt; は長さである &lt;code&gt;n + 1&lt;/code&gt; 、この関数は値を返します</target>
        </trans-unit>
        <trans-unit id="e3ad7dc6a355dfc8a1c8aa46843f5488897fd4ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is of length &lt;code&gt;n + 1&lt;/code&gt;, this function returns the value:</source>
          <target state="translated">場合 &lt;code&gt;c&lt;/code&gt; は長さである &lt;code&gt;n + 1&lt;/code&gt; 、この関数は値を返します。</target>
        </trans-unit>
        <trans-unit id="6a970efb45caa036763049ac1a92ee21b5440b3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;check(..)&lt;/code&gt; is not used then F2PY generates few standard checks (e.g. in a case of an array argument, check for the proper shape and size) automatically. Use &lt;code&gt;check()&lt;/code&gt; to disable checks generated by F2PY.</source>
          <target state="translated">場合 &lt;code&gt;check(..)&lt;/code&gt; 使用されていないが、その後F2PYは自動的に（適切な形状と大きさの配列引数、検査の場合などの）いくつかの標準チェックを生成します。使用 &lt;code&gt;check()&lt;/code&gt; F2PYによって生成された無効チェックに。</target>
        </trans-unit>
        <trans-unit id="ce30f3388eee45516fb0d109b2a57581be93d2fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cmp_op&lt;/code&gt; is not valid.</source>
          <target state="translated">場合 &lt;code&gt;cmp_op&lt;/code&gt; は有効ではありません。</target>
        </trans-unit>
        <trans-unit id="f3791f18c578dee37c08b1f05312986ce4a1234a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;condition&lt;/code&gt; is boolean:</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; がブールの場合：</target>
        </trans-unit>
        <trans-unit id="945ce76f24a4c673d6aa37d9ae7569a5f68abd37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is provided, it must stay alive for the life of the array. One way to manage this is through &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt;&lt;code&gt;PyArray_SetBaseObject&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; が提供される場合、そのデータはアレイの存続期間中存続している必要があります。これを管理する1つの方法は、&lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt; &lt;code&gt;PyArray_SetBaseObject&lt;/code&gt; &lt;/a&gt;を使用することです。</target>
        </trans-unit>
        <trans-unit id="58463c629975ec8a9511dbc013fc3e05064ff197" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;device&lt;/code&gt; does not have a &lt;code&gt;write()&lt;/code&gt; or &lt;code&gt;flush()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;device&lt;/code&gt; &lt;code&gt;write()&lt;/code&gt; または &lt;code&gt;flush()&lt;/code&gt; メソッドがない場合。</target>
        </trans-unit>
        <trans-unit id="799e69512e3ae47752ad1a4389491bce54790cbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, these arguments are passed to &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt;&lt;code&gt;numpy.format_parser&lt;/code&gt;&lt;/a&gt; to construct a dtype. See that function for detailed documentation</source>
          <target state="translated">&lt;code&gt;dtype&lt;/code&gt; が &lt;code&gt;None&lt;/code&gt; の場合、これらの引数は&lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt; &lt;code&gt;numpy.format_parser&lt;/code&gt; &lt;/a&gt;に渡され、dtypeが作成されます。詳細なドキュメントについては、その関数を参照してください</target>
        </trans-unit>
        <trans-unit id="eb15e22b2a7d43231c255a7fc2569fdb2ab36892" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, these arguments are passed to &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt;&lt;code&gt;numpy.format_parser&lt;/code&gt;&lt;/a&gt; to construct a dtype. See that function for detailed documentation.</source>
          <target state="translated">&lt;code&gt;dtype&lt;/code&gt; が &lt;code&gt;None&lt;/code&gt; の場合、これらの引数は&lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt; &lt;code&gt;numpy.format_parser&lt;/code&gt; &lt;/a&gt;に渡され、dtypeが作成されます。詳細なドキュメントについては、その関数を参照してください。</target>
        </trans-unit>
        <trans-unit id="68051abdc74ce34a8cd57f65aadeda23f8c9fb89" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; isn&amp;rsquo;t &lt;code&gt;NULL&lt;/code&gt;, then it requires that data type. If copying is allowed, it will make a temporary copy if the data is castable. If &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; is enabled, it will also copy the data back with another cast upon iterator destruction.</source>
          <target state="translated">&lt;code&gt;dtype&lt;/code&gt; が &lt;code&gt;NULL&lt;/code&gt; でない場合、そのデータ型が必要です。コピーが許可されている場合、データがキャスト可能であれば一時コピーが作成されます。&lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;が有効になっている場合、イテレータの破棄時に別のキャストでデータをコピーして戻します。</target>
        </trans-unit>
        <trans-unit id="760548f2e1b1246d013e160a44370e64f44dc286" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enddates&lt;/code&gt; specifies a date value that is earlier than the corresponding &lt;code&gt;begindates&lt;/code&gt; date value, the count will be negative.</source>
          <target state="translated">場合 &lt;code&gt;enddates&lt;/code&gt; が対応するよりも前の日付の値を指定 &lt;code&gt;begindates&lt;/code&gt; の日付値を、カウントがマイナスになります。</target>
        </trans-unit>
        <trans-unit id="417859000cee8d29cc7044346e37933b08a0f1c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fieldname&lt;/code&gt; is the empty string &lt;code&gt;''&lt;/code&gt;, the field will be given a default name of the form &lt;code&gt;f#&lt;/code&gt;, where &lt;code&gt;#&lt;/code&gt; is the integer index of the field, counting from 0 from the left:</source>
          <target state="translated">場合は &lt;code&gt;fieldname&lt;/code&gt; 空の文字列である &lt;code&gt;''&lt;/code&gt; 、フィールドはフォームのデフォルト名を指定します &lt;code&gt;f#&lt;/code&gt; 、 &lt;code&gt;#&lt;/code&gt; は左から0からのフィールド、集計の整数インデックスです。</target>
        </trans-unit>
        <trans-unit id="ea2d55579b57bf31daf1f1c848f07e4ba4a33873" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fortranname&lt;/code&gt; statement is used without &lt;code&gt;&amp;lt;actual Fortran/C routine name&amp;gt;&lt;/code&gt; then a dummy wrapper is generated.</source>
          <target state="translated">&lt;code&gt;fortranname&lt;/code&gt; ステートメントが &lt;code&gt;&amp;lt;actual Fortran/C routine name&amp;gt;&lt;/code&gt; なしで使用される場合、ダミーラッパーが生成されます。</target>
        </trans-unit>
        <trans-unit id="cb4a6b4dd2e4a7b67147341a42f6c8197722c973" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is a 1-D array of sorted integers, the entries indicate where along &lt;code&gt;axis&lt;/code&gt; the array is split. For example, &lt;code&gt;[2, 3]&lt;/code&gt; would, for &lt;code&gt;axis=0&lt;/code&gt;, result in</source>
          <target state="translated">場合 &lt;code&gt;indices_or_sections&lt;/code&gt; がソート整数の1次元配列であり、エントリがどこに沿って示す &lt;code&gt;axis&lt;/code&gt; アレイが分割されます。たとえば、 &lt;code&gt;[2, 3]&lt;/code&gt; は、 &lt;code&gt;axis=0&lt;/code&gt; の場合、結果は</target>
        </trans-unit>
        <trans-unit id="750e535a910db315f0680626cd7e38f07dd476ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is an integer, N, the array will be divided into N equal arrays along &lt;code&gt;axis&lt;/code&gt;. If such a split is not possible, an error is raised.</source>
          <target state="translated">場合 &lt;code&gt;indices_or_sections&lt;/code&gt; は整数、Nであり、アレイに沿ってN等しいアレイに分割される &lt;code&gt;axis&lt;/code&gt; 。このような分割が不可能な場合は、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="c2fbdd32f871ea7c6656b8280d919dff6251170e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is given as an integer, but a split does not result in equal division.</source>
          <target state="translated">もし &lt;code&gt;indices_or_sections&lt;/code&gt; 整数として与えられるが、分割は等分割では生じません。</target>
        </trans-unit>
        <trans-unit id="64c4e0e507acd8c3f4b71cfa7cf2cf1d38b76639" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;intent(c)&lt;/code&gt; is used as a statement but without an entity declaration list, then F2PY adds the &lt;code&gt;intent(c)&lt;/code&gt; attribute to all arguments.</source>
          <target state="translated">場合 &lt;code&gt;intent(c)&lt;/code&gt; 声明としてではなく、エンティティ宣言リストなしで使用され、その後、F2PYは追加 &lt;code&gt;intent(c)&lt;/code&gt; すべての引数に属性を。</target>
        </trans-unit>
        <trans-unit id="820239142587f3701cc156b154b6624dd5007ecf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;intent(copy)&lt;/code&gt; or &lt;code&gt;intent(overwrite)&lt;/code&gt; is used, then an additional optional argument is introduced with a name &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; and a default value 0 or 1, respectively.</source>
          <target state="translated">場合 &lt;code&gt;intent(copy)&lt;/code&gt; または &lt;code&gt;intent(overwrite)&lt;/code&gt; 使用され、その後、追加のオプション引数が名前で導入さ &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; と、それぞれデフォルト値0または1、。</target>
        </trans-unit>
        <trans-unit id="c296e3258dbc49519e8602388ede880a24772142" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k &amp;gt; l&lt;/code&gt;, then only &lt;code&gt;x_1, ..., x_l&lt;/code&gt; are set.</source>
          <target state="translated">&lt;code&gt;k &amp;gt; l&lt;/code&gt; 場合、 &lt;code&gt;x_1, ..., x_l&lt;/code&gt; のみが設定されます。</target>
        </trans-unit>
        <trans-unit id="271207c6144fe7ced9054709b41446a9de60c700" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k &amp;lt; l&lt;/code&gt;, then &lt;code&gt;y_{k + 1}, ..., y_l&lt;/code&gt; are ignored.</source>
          <target state="translated">場合 &lt;code&gt;k &amp;lt; l&lt;/code&gt; 、次いで、 &lt;code&gt;y_{k + 1}, ..., y_l&lt;/code&gt; 無視されます。</target>
        </trans-unit>
        <trans-unit id="e99e0454406f9add7ef291687419a1330612a513" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;legacy&lt;/code&gt; is False, or the BitGenerator is not MT19937, then state is returned as a dictionary.</source>
          <target state="translated">&lt;code&gt;legacy&lt;/code&gt; がFalseの場合、またはBitGeneratorがMT19937でない場合、状態はディクショナリとして返されます。</target>
        </trans-unit>
        <trans-unit id="ce1a7ad82e3cfecd360d23c388ed9b15e3542af6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;legacy&lt;/code&gt; is False, or the BitGenerator is not NT19937, then state is returned as a dictionary.</source>
          <target state="translated">&lt;code&gt;legacy&lt;/code&gt; がFalseの場合、またはBitGeneratorがNT19937ではない場合、状態は辞書として返されます。</target>
        </trans-unit>
        <trans-unit id="146abcde4c240659f226130b295dbaf50c55deac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m &amp;lt; 0&lt;/code&gt;, &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt;, &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt;, or &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;m &amp;lt; 0&lt;/code&gt; 場合、 &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt; 、 &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt; 、または &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2c2df004cd887df3e646568cfffdf17b3ac0ffbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m &amp;lt; 1&lt;/code&gt;, &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt;, &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt;, or &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;m &amp;lt; 1&lt;/code&gt; 場合、 &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt; 、 &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt; 、または &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e220ffcadc52e486b28727579ddc1e86ad96fbcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; have different flexible dtypes.</source>
          <target state="translated">&lt;code&gt;m1&lt;/code&gt; と &lt;code&gt;m2&lt;/code&gt; に異なる柔軟なdtypeがある場合。</target>
        </trans-unit>
        <trans-unit id="0cda2eb48aaf0ad93b34e30066de3169d0688cac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m&lt;/code&gt; has a single column then that column is returned as the single row of a matrix. Otherwise &lt;code&gt;m&lt;/code&gt; is returned. The returned matrix is always either &lt;code&gt;m&lt;/code&gt; itself or a view into &lt;code&gt;m&lt;/code&gt;. Supplying an axis keyword argument will not affect the returned matrix but it may cause an error to be raised.</source>
          <target state="translated">場合 &lt;code&gt;m&lt;/code&gt; が単一の列を有し、その列は、マトリクスの単一の行として返されます。それ以外の場合は、 &lt;code&gt;m&lt;/code&gt; が返されます。返される行列は、常に &lt;code&gt;m&lt;/code&gt; 自体または &lt;code&gt;m&lt;/code&gt; のビューです。axisキーワード引数を指定しても、返される行列には影響しませんが、エラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d089e6b20e99bc8aa35211116381511548d1fc6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxsplit&lt;/code&gt; is given, at most &lt;code&gt;maxsplit&lt;/code&gt; splits are done, the rightmost ones.</source>
          <target state="translated">場合 &lt;code&gt;maxsplit&lt;/code&gt; 個が与えられ、最大で &lt;code&gt;maxsplit&lt;/code&gt; 個の分割、右端のものをやっています。</target>
        </trans-unit>
        <trans-unit id="f3a2beabba4d5e799494083ff0f67c424eaf8432" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxsplit&lt;/code&gt; is given, at most &lt;code&gt;maxsplit&lt;/code&gt; splits are done.</source>
          <target state="translated">場合 &lt;code&gt;maxsplit&lt;/code&gt; 個が与えられ、最大で &lt;code&gt;maxsplit&lt;/code&gt; 個の分割行われます。</target>
        </trans-unit>
        <trans-unit id="6e310688fa6d65057ce51d85bd5439d15eeafd62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n + p &amp;lt;= m&lt;/code&gt; then &lt;code&gt;gun(a_1, ..., a_n, e_1, ..., e_p)&lt;/code&gt; is called.</source>
          <target state="translated">もし &lt;code&gt;n + p &amp;lt;= m&lt;/code&gt; 次いで &lt;code&gt;gun(a_1, ..., a_n, e_1, ..., e_p)&lt;/code&gt; 呼び出されます。</target>
        </trans-unit>
        <trans-unit id="75d4baac79ac0ec79605a8d87c557699bd33432f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n + p&lt;/code&gt; is less than the number of required arguments to &lt;code&gt;gun&lt;/code&gt; then an exception is raised.</source>
          <target state="translated">場合 &lt;code&gt;n + p&lt;/code&gt; 以下に必要な引数の数よりも &lt;code&gt;gun&lt;/code&gt; 後、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="a6773ebb7a73c0cf9641c3fc6c53898d5654dcdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is even, &lt;code&gt;A[-1]&lt;/code&gt; contains the term representing both positive and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely real. If &lt;code&gt;n&lt;/code&gt; is odd, there is no term at fs/2; &lt;code&gt;A[-1]&lt;/code&gt; contains the largest positive frequency (fs/2*(n-1)/n), and is complex in the general case.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; が偶数の場合、 &lt;code&gt;A[-1]&lt;/code&gt; には正と負の両方のナイキスト周波数（+ fs / 2および-fs / 2）を表す項が含まれ、純粋に実数でなければなりません。 &lt;code&gt;n&lt;/code&gt; が奇数の場合、fs / 2に項はありません。 &lt;code&gt;A[-1]&lt;/code&gt; は最大の正の周波数（fs / 2 *（n-1）/ n）を含み、一般的なケースでは複素数です。</target>
        </trans-unit>
        <trans-unit id="d002795222f44b6308a6ac63aedd1a3723557506" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;names&lt;/code&gt; is True, the field names are read from the first line after the first &lt;code&gt;skip_header&lt;/code&gt; lines. This line can optionally be proceeded by a comment delimiter. If &lt;code&gt;names&lt;/code&gt; is a sequence or a single-string of comma-separated names, the names will be used to define the field names in a structured dtype. If &lt;code&gt;names&lt;/code&gt; is None, the names of the dtype fields will be used, if any.</source>
          <target state="translated">場合 &lt;code&gt;names&lt;/code&gt; Trueで、フィールド名が最初の後の最初の行から読み込まれ &lt;code&gt;skip_header&lt;/code&gt; のライン。この行は、オプションでコメント区切り文字で開始できます。場合 &lt;code&gt;names&lt;/code&gt; シーケンスまたはカンマで区切られた名前の単一の文字列で、名前が構造化さDTYPEのフィールド名を定義するために使用されます。 &lt;code&gt;names&lt;/code&gt; がNoneの場合、dtypeフィールドがあれば、それが使用されます。</target>
        </trans-unit>
        <trans-unit id="07b76e3a08f68e2d41d08bcc90944dfb38bf1854" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;names=None&lt;/code&gt; but a structured dtype is expected, names are defined with the standard NumPy default of &lt;code&gt;&quot;f%i&quot;&lt;/code&gt;, yielding names like &lt;code&gt;f0&lt;/code&gt;, &lt;code&gt;f1&lt;/code&gt; and so forth:</source>
          <target state="translated">場合は &lt;code&gt;names=None&lt;/code&gt; が、構造化DTYPEが期待されていない、名前は標準のnumpyのデフォルトで定義されている &lt;code&gt;&quot;f%i&quot;&lt;/code&gt; のような名前生じ、 &lt;code&gt;f0&lt;/code&gt; 、 &lt;code&gt;f1&lt;/code&gt; などとの：</target>
        </trans-unit>
        <trans-unit id="9d8d4bbddf580197e193ef2ab5f3260ca263687d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.flags&lt;/code&gt; has &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, this function clears the flags, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; and makes it writeable, and sets &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; to NULL. In contrast to &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt; it makes no attempt to copy the data from &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; This undoes &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt;&lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt;&lt;/a&gt;. Usually this is called after an error when you are finished with &lt;code&gt;obj&lt;/code&gt;, just before &lt;code&gt;Py_DECREF(obj)&lt;/code&gt;. It may be called multiple times, or with &lt;code&gt;NULL&lt;/code&gt; input.</source>
          <target state="translated">場合 &lt;code&gt;obj.flags&lt;/code&gt; を有する&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;又は（廃止）&lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;、この関数はフラグ、クリア &lt;code&gt;DECREF&lt;/code&gt; S &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; 、それが書き込み可能になり、そしてセットは &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; NULLに。&lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt;とは対照的に、 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; からデータをコピーしようとはしません。これにより、&lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt; &lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt; が取り消され&lt;/a&gt;ます。通常、これは &lt;code&gt;obj&lt;/code&gt; を &lt;code&gt;Py_DECREF(obj)&lt;/code&gt; 終わったときのエラーの後、Py_DECREF（obj）の直前に呼び出されます。複数回、または &lt;code&gt;NULL&lt;/code&gt; 入力で呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="8f43e6f1e973bd0d462747acc6303f4251ae23b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.flags&lt;/code&gt; has &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, this function clears the flags, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; and makes it writeable, and sets &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; to NULL. It then copies &lt;code&gt;obj-&amp;gt;data&lt;/code&gt; to &lt;code&gt;obj-&amp;gt;base-&amp;gt;data&lt;/code&gt;, and returns the error state of the copy operation. This is the opposite of &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt;&lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt;&lt;/a&gt;. Usually this is called once you are finished with &lt;code&gt;obj&lt;/code&gt;, just before &lt;code&gt;Py_DECREF(obj)&lt;/code&gt;. It may be called multiple times, or with &lt;code&gt;NULL&lt;/code&gt; input. See also &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">場合 &lt;code&gt;obj.flags&lt;/code&gt; を有する&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;又は（廃止）&lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;、この関数はフラグ、クリア &lt;code&gt;DECREF&lt;/code&gt; S &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; 、それが書き込み可能になり、そしてセットは &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; NULLに。次に、 &lt;code&gt;obj-&amp;gt;data&lt;/code&gt; を &lt;code&gt;obj-&amp;gt;base-&amp;gt;data&lt;/code&gt; base-&amp;gt; dataにコピーし、コピー操作のエラー状態を返します。これは&lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt; &lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt; &lt;/a&gt;の逆です。通常、これは &lt;code&gt;obj&lt;/code&gt; を &lt;code&gt;Py_DECREF(obj)&lt;/code&gt; 終わったら、Py_DECREF（obj）の直前に呼び出されます。複数回、または &lt;code&gt;NULL&lt;/code&gt; 入力で呼び出すことができます。&lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt;もご覧ください。</target>
        </trans-unit>
        <trans-unit id="90c51090e68a386a4d8166c7cdb0f79785d7f6e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt;, &lt;code&gt;x[obj]&lt;/code&gt; returns a 1-dimensional array filled with the elements of &lt;em&gt;x&lt;/em&gt; corresponding to the &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; values of &lt;em&gt;obj&lt;/em&gt;. The search order will be &lt;a href=&quot;../glossary#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style. If &lt;em&gt;obj&lt;/em&gt; has &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; values at entries that are outside of the bounds of &lt;em&gt;x&lt;/em&gt;, then an index error will be raised. If &lt;em&gt;obj&lt;/em&gt; is smaller than &lt;em&gt;x&lt;/em&gt; it is identical to filling it with &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">もし &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt; 、 &lt;code&gt;x[obj]&lt;/code&gt; の要素で満たされた1次元配列戻り&lt;em&gt;X&lt;/em&gt;に対応する&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt;の値&lt;em&gt;OBJを&lt;/em&gt;。検索順序は、&lt;a href=&quot;../glossary#term-row-major&quot;&gt;行&lt;/a&gt;優先、Cスタイルになります。&lt;em&gt;x&lt;/em&gt;の範囲外のエントリで&lt;em&gt;obj&lt;/em&gt;に&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt;値がある場合、インデックスエラーが発生します。&lt;em&gt;obj&lt;/em&gt;が&lt;em&gt;x&lt;/em&gt;より小さい場合は、&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; で&lt;/a&gt;埋めるのと同じです。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="19e346c07517b41525b586a4ff8685ed9ba6dbe8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt;, &lt;code&gt;x[obj]&lt;/code&gt; returns a 1-dimensional array filled with the elements of &lt;em&gt;x&lt;/em&gt; corresponding to the &lt;code&gt;True&lt;/code&gt; values of &lt;em&gt;obj&lt;/em&gt;. The search order will be &lt;a href=&quot;../glossary#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style. If &lt;em&gt;obj&lt;/em&gt; has &lt;code&gt;True&lt;/code&gt; values at entries that are outside of the bounds of &lt;em&gt;x&lt;/em&gt;, then an index error will be raised. If &lt;em&gt;obj&lt;/em&gt; is smaller than &lt;em&gt;x&lt;/em&gt; it is identical to filling it with &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">もし &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt; 、 &lt;code&gt;x[obj]&lt;/code&gt; の要素で満たされた1次元配列戻り&lt;em&gt;X&lt;/em&gt;に対応する &lt;code&gt;True&lt;/code&gt; の値&lt;em&gt;OBJを&lt;/em&gt;。検索順序は、&lt;a href=&quot;../glossary#term-row-major&quot;&gt;行&lt;/a&gt;優先、Cスタイルになります。&lt;em&gt;x&lt;/em&gt;の範囲外のエントリで&lt;em&gt;obj&lt;/em&gt;に &lt;code&gt;True&lt;/code&gt; 値がある場合、インデックスエラーが発生します。&lt;em&gt;obj&lt;/em&gt;が&lt;em&gt;x&lt;/em&gt;より小さい場合は、 &lt;code&gt;False&lt;/code&gt; で埋めるのと同じです。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b9effe7f71bd1a595880c87c20422da0870723e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt;, &lt;code&gt;x[obj]&lt;/code&gt; returns a 1-dimensional array filled with the elements of &lt;em&gt;x&lt;/em&gt; corresponding to the &lt;code&gt;True&lt;/code&gt; values of &lt;em&gt;obj&lt;/em&gt;. The search order will be &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style. If &lt;em&gt;obj&lt;/em&gt; has &lt;code&gt;True&lt;/code&gt; values at entries that are outside of the bounds of &lt;em&gt;x&lt;/em&gt;, then an index error will be raised. If &lt;em&gt;obj&lt;/em&gt; is smaller than &lt;em&gt;x&lt;/em&gt; it is identical to filling it with &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">もし &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt; 、 &lt;code&gt;x[obj]&lt;/code&gt; の要素で満たされた1次元配列戻り&lt;em&gt;X&lt;/em&gt;に対応する &lt;code&gt;True&lt;/code&gt; の値&lt;em&gt;OBJを&lt;/em&gt;。検索順序は、&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;行&lt;/a&gt;優先、Cスタイルになります。&lt;em&gt;obj&lt;/em&gt;が&lt;em&gt;x&lt;/em&gt;の範囲外のエントリで &lt;code&gt;True&lt;/code&gt; 値を持っている場合、インデックスエラーが発生します。&lt;em&gt;obj&lt;/em&gt;が&lt;em&gt;x&lt;/em&gt;より小さい場合は、それを &lt;code&gt;False&lt;/code&gt; で埋めることと同じです。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c24698bfa7f55b1863fd1ee853e61b9963b6226" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then call the &lt;a href=&quot;numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;recarray&lt;/code&gt;&lt;/a&gt; constructor. If &lt;code&gt;obj&lt;/code&gt; is a string, then call the &lt;a href=&quot;numpy.fromstring#numpy.fromstring&quot;&gt;&lt;code&gt;fromstring&lt;/code&gt;&lt;/a&gt; constructor. If &lt;code&gt;obj&lt;/code&gt; is a list or a tuple, then if the first object is an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, call &lt;a href=&quot;numpy.core.records.fromarrays#numpy.core.records.fromarrays&quot;&gt;&lt;code&gt;fromarrays&lt;/code&gt;&lt;/a&gt;, otherwise call &lt;a href=&quot;numpy.core.records.fromrecords#numpy.core.records.fromrecords&quot;&gt;&lt;code&gt;fromrecords&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;obj&lt;/code&gt; is a &lt;a href=&quot;numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;recarray&lt;/code&gt;&lt;/a&gt;, then make a copy of the data in the recarray (if &lt;code&gt;copy=True&lt;/code&gt;) and use the new formats, names, and titles. If &lt;code&gt;obj&lt;/code&gt; is a file, then call &lt;a href=&quot;numpy.fromfile#numpy.fromfile&quot;&gt;&lt;code&gt;fromfile&lt;/code&gt;&lt;/a&gt;. Finally, if obj is an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, then return &lt;code&gt;obj.view(recarray)&lt;/code&gt;, making a copy of the data if &lt;code&gt;copy=True&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; が &lt;code&gt;None&lt;/code&gt; の場合、&lt;a href=&quot;numpy.recarray#numpy.recarray&quot;&gt; &lt;code&gt;recarray&lt;/code&gt; &lt;/a&gt;コンストラクターを呼び出します。 &lt;code&gt;obj&lt;/code&gt; が文字列の場合は、&lt;a href=&quot;numpy.fromstring#numpy.fromstring&quot;&gt; &lt;code&gt;fromstring&lt;/code&gt; &lt;/a&gt;コンストラクターを呼び出します。場合 &lt;code&gt;obj&lt;/code&gt; がリストまたはタプルである、最初のオブジェクトがある場合&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;、コール&lt;a href=&quot;numpy.core.records.fromarrays#numpy.core.records.fromarrays&quot;&gt; &lt;code&gt;fromarrays&lt;/code&gt; &lt;/a&gt;、さもなければコール&lt;a href=&quot;numpy.core.records.fromrecords#numpy.core.records.fromrecords&quot;&gt; &lt;code&gt;fromrecords&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;obj&lt;/code&gt; が&lt;a href=&quot;numpy.recarray#numpy.recarray&quot;&gt; &lt;code&gt;recarray&lt;/code&gt; の&lt;/a&gt;場合は、recarray内のデータのコピーを作成し（ &lt;code&gt;copy=True&lt;/code&gt; の場合）、新しい形式、名前、およびタイトルを使用します。 &lt;code&gt;obj&lt;/code&gt; がファイルの場合は、&lt;a href=&quot;numpy.fromfile#numpy.fromfile&quot;&gt; &lt;code&gt;fromfile&lt;/code&gt; &lt;/a&gt;を呼び出します。最後に、objが&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; の&lt;/a&gt;場合、 &lt;code&gt;obj.view(recarray)&lt;/code&gt; 、 &lt;code&gt;copy=True&lt;/code&gt; の場合にデータのコピーを作成します。</target>
        </trans-unit>
        <trans-unit id="0cb8b5f8682e528917b9dad63d5ce0f0a15864d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; isn&amp;rsquo;t a suitable numeric type.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; が適切な数値型でない場合。</target>
        </trans-unit>
        <trans-unit id="bd67812cd1998c40abb29425bc518b926e6b0841" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to &lt;a href=&quot;https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented&quot;&gt;&lt;code&gt;Py_NotImplemented&lt;/code&gt;&lt;/a&gt; and no error condition is set.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; が配列インターフェイスのいずれかの部分を実装している場合、 &lt;code&gt;out&lt;/code&gt; には、インターフェイスを使用して新しく作成されたndarrayへの新しい参照が含まれ &lt;code&gt;NULL&lt;/code&gt; 。変換中にエラーが発生した場合、 &lt;code&gt;out&lt;/code&gt; にはNULLが含まれます。それ以外の場合、outには&lt;a href=&quot;https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented&quot;&gt; &lt;code&gt;Py_NotImplemented&lt;/code&gt; &lt;/a&gt;への借用参照が含まれ、エラー条件は設定されません。</target>
        </trans-unit>
        <trans-unit id="12f75ca0900af5198142d436cbdd5e1ee389cfd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to Py_NotImplemented and no error condition is set. This version allows setting of the dtype in the part of the array interface that looks for the &lt;a href=&quot;../arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; attribute. &lt;code&gt;context&lt;/code&gt; is unused.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; が配列インターフェースのいずれかの部分を実装している場合、 &lt;code&gt;out&lt;/code&gt; にはインターフェースを使用して新しく作成されたndarrayへの新しい参照が含まれ、変換中にエラーが発生した場合は &lt;code&gt;out&lt;/code&gt; に &lt;code&gt;NULL&lt;/code&gt; が含まれます。それ以外の場合、outにはPy_NotImplementedへの借用参照が含まれ、エラー条件は設定されません。このバージョンでは、&lt;a href=&quot;../arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;属性を検索する配列インターフェイスの一部でdtypeを設定できます。 &lt;code&gt;context&lt;/code&gt; は使用されません。</target>
        </trans-unit>
        <trans-unit id="98dbfb53c5754a6749d968f5df5fe9eebecd4ff8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to Py_NotImplemented and no error condition is set. This version allows setting of the type and context in the part of the array interface that looks for the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; が配列インターフェイスのいずれかの部分を実装している場合、 &lt;code&gt;out&lt;/code&gt; には、インターフェイスを使用して新しく作成されたndarrayへの新しい参照が含まれ &lt;code&gt;NULL&lt;/code&gt; 。変換中にエラーが発生した場合、 &lt;code&gt;out&lt;/code&gt; にはNULLが含まれます。そうでない場合、outにはPy_NotImplementedへの借用参照が含まれ、エラー条件は設定されません。このバージョンでは、&lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;属性を検索する配列インターフェースの部分でタイプとコンテキストを設定できます。</target>
        </trans-unit>
        <trans-unit id="ed83570f54caf00535275cbf2433364d3dc43b7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; is already (C-style) contiguous and well-behaved then just return a reference, otherwise return a (contiguous and well-behaved) copy of the array. The parameter op must be a (sub-class of an) ndarray and no checking for that is done.</source>
          <target state="translated">場合 &lt;code&gt;op&lt;/code&gt; 既に（Cスタイル）であり、連続するだけの参照を返す次に行儀そうでなければ（連続と行儀）配列のコピーを返します。パラメータopはndarray（のサブクラス）である必要があり、そのチェックは行われません。</target>
        </trans-unit>
        <trans-unit id="3efc82f6eb8962f2bbdd61dd48e5d36f40ab01fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op_dtypes&lt;/code&gt; isn&amp;rsquo;t &lt;code&gt;NULL&lt;/code&gt;, it specifies a data type or &lt;code&gt;NULL&lt;/code&gt; for each &lt;code&gt;op[i]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;op_dtypes&lt;/code&gt; が &lt;code&gt;NULL&lt;/code&gt; でない場合は、各 &lt;code&gt;op[i]&lt;/code&gt; データ型または &lt;code&gt;NULL&lt;/code&gt; を指定します。</target>
        </trans-unit>
        <trans-unit id="49913a9d3761c3c5184d0fb1b55beebafb026c1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;otypes&lt;/code&gt; is not specified, then a call to the function with the first argument will be used to determine the number of outputs. The results of this call will be cached if &lt;code&gt;cache&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; to prevent calling the function twice. However, to implement the cache, the original function must be wrapped which will slow down subsequent calls, so only do this if your function is expensive.</source>
          <target state="translated">&lt;code&gt;otypes&lt;/code&gt; が指定されていない場合、最初の引数を使用した関数の呼び出しが、出力の数を決定するために使用されます。この呼び出しの結果は、関数が2回呼び出されないように &lt;code&gt;cache&lt;/code&gt; が &lt;code&gt;True&lt;/code&gt; の場合にキャッシュされます。ただし、キャッシュを実装するには、元の関数をラップする必要があります。これにより、後続の呼び出しが遅くなるため、関数が高価な場合にのみこれを実行してください。</target>
        </trans-unit>
        <trans-unit id="3aa37ff615f56f9b7e65eaa58699e643fd032326" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, a shuffled copy of &lt;code&gt;x&lt;/code&gt; is returned. Otherwise, the shuffled array is stored in &lt;code&gt;out&lt;/code&gt;, and &lt;code&gt;out&lt;/code&gt; is returned</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; がNoneの場合、 &lt;code&gt;x&lt;/code&gt; のシャッフルされたコピーが返されます。それ以外の場合、シャッフルされ &lt;code&gt;out&lt;/code&gt; 配列はoutに格納され、 &lt;code&gt;out&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="6567b2686e797d9822a7bbf895363486cc94afc9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the standard deviation, otherwise return a reference to the output array.</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; がNoneの場合、標準偏差を含む新しい配列を返します。それ以外の場合は、出力配列への参照を返します。</target>
        </trans-unit>
        <trans-unit id="089152cfcf81b924028fc82e4f2ab4321cd32c01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the standard deviation, otherwise return a reference to the output array. If ddof is &amp;gt;= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; がNoneの場合、標準偏差を含む新しい配列を返します。それ以外の場合は、出力配列への参照を返します。ddofがスライス内の非NaN要素の数以上の場合、またはスライスにNaNのみが含まれる場合、そのスライスの結果はNaNになります。</target>
        </trans-unit>
        <trans-unit id="a3cf56d56f9711ddb9fe165ac4a15d1c897a7d62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the variance, otherwise return a reference to the output array. If ddof is &amp;gt;= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; がNoneの場合、分散を含む新しい配列を返します。それ以外の場合は、出力配列への参照を返します。ddofがスライス内の非NaN要素の数以上の場合、またはスライスにNaNのみが含まれる場合、そのスライスの結果はNaNになります。</target>
        </trans-unit>
        <trans-unit id="bd3ed46fb1ad18e3f54a87922d109c78bc224796" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is provided, the function writes the result into it, and returns a reference to &lt;code&gt;out&lt;/code&gt;. (See Examples)</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; が指定されている場合、関数は結果を書き込み、 &lt;code&gt;out&lt;/code&gt; への参照を返します。（例を参照）</target>
        </trans-unit>
        <trans-unit id="d0b860961bc5b4a4c45189c0fd4de5c2d61f1ab4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the mean values, otherwise a reference to the output array is returned.</source>
          <target state="translated">&lt;code&gt;out=None&lt;/code&gt; の場合は、平均値を含む新しい配列を返します。それ以外の場合は、出力配列への参照を返します。</target>
        </trans-unit>
        <trans-unit id="d2bfee9ac0986058c6155b92fa93c7a62c8953a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the mean values, otherwise a reference to the output array is returned. Nan is returned for slices that contain only NaNs.</source>
          <target state="translated">&lt;code&gt;out=None&lt;/code&gt; の場合は、平均値を含む新しい配列を返します。それ以外の場合は、出力配列への参照を返します。NaNのみを含むスライスの場合、Nanが返されます。</target>
        </trans-unit>
        <trans-unit id="64277711f0130f08ef89a03256433633c6256165" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the variance; otherwise, a reference to the output array is returned.</source>
          <target state="translated">&lt;code&gt;out=None&lt;/code&gt; の場合、分散を含む新しい配列を返します。それ以外の場合は、出力配列への参照が返されます。</target>
        </trans-unit>
        <trans-unit id="9b1c9c61ff9f1ab4238c3c9129f3c3d7264b97ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;output&lt;/code&gt; not supplied then source code is printed to screen (sys.stdout). File object must be created with either write &amp;lsquo;w&amp;rsquo; or append &amp;lsquo;a&amp;rsquo; modes.</source>
          <target state="translated">&lt;code&gt;output&lt;/code&gt; が提供されない場合、ソースコードは画面に出力されます（sys.stdout）。ファイルオブジェクトは、書き込み 'w'または追加 'a'モードで作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="710d73ebab70d58eff0ea577b59d52767457dc24" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p &amp;gt; m&lt;/code&gt; then &lt;code&gt;gun(e_1, ..., e_m)&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;p &amp;gt; m&lt;/code&gt; 場合、 &lt;code&gt;gun(e_1, ..., e_m)&lt;/code&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="7ffd83286f9552326735c9e9997d8b928bd7d08a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p &amp;lt;= m &amp;lt; n + p&lt;/code&gt; then &lt;code&gt;gun(a_1, ..., a_q, e_1, ..., e_p)&lt;/code&gt; is called, here &lt;code&gt;q=m-p&lt;/code&gt;.</source>
          <target state="translated">もし &lt;code&gt;p &amp;lt;= m &amp;lt; n + p&lt;/code&gt; その後、 &lt;code&gt;gun(a_1, ..., a_q, e_1, ..., e_p)&lt;/code&gt; 、ここに呼ばれ &lt;code&gt;q=m-p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16e928ca77781f5fb31deca2051e51b1031bced3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p == 0&lt;/code&gt; then &lt;code&gt;gun(a_1, ..., a_q)&lt;/code&gt; is called, here &lt;code&gt;q = min(m, n)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p == 0&lt;/code&gt; 場合、 &lt;code&gt;gun(a_1, ..., a_q)&lt;/code&gt; が呼び出されます。ここでは、 &lt;code&gt;q = min(m, n)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="04c444cb5aa197d63b68cfea78d90d29188a9456" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is of length N, this function returns the value:</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; の長さがNの場合、この関数は値を返します。</target>
        </trans-unit>
        <trans-unit id="fe3f05df5768add8f656a94f10e13fc6943b0c1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is the returned series, then &lt;code&gt;p(x) == x&lt;/code&gt; for all values of x.</source>
          <target state="translated">場合 &lt;code&gt;p&lt;/code&gt; が返さシリーズでは、 &lt;code&gt;p(x) == x&lt;/code&gt; xの全ての値に対して。</target>
        </trans-unit>
        <trans-unit id="f5468a2ba10e85782ab3beca18220db469f1d944" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is an URL, it will be downloaded, stored in the &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; directory and opened from there.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; がURLの場合、ダウンロードされ、&lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt;ディレクトリに保存され、そこから開かれます。</target>
        </trans-unit>
        <trans-unit id="24260df7d2aad1e014a4c9af35e7ef7678f51548" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is an URL, then &lt;a href=&quot;#numpy.DataSource.abspath&quot;&gt;&lt;code&gt;abspath&lt;/code&gt;&lt;/a&gt; will return either the location the file exists locally or the location it would exist when opened using the &lt;a href=&quot;numpy.datasource.open#numpy.DataSource.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">場合は &lt;code&gt;path&lt;/code&gt; URLで、その後、&lt;a href=&quot;#numpy.DataSource.abspath&quot;&gt; &lt;code&gt;abspath&lt;/code&gt; &lt;/a&gt;返します。いずれかの場所は、ファイルがローカルに存在するか、使用して開いたときの場所は、それが存在することになる&lt;a href=&quot;numpy.datasource.open#numpy.DataSource.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;方法を。</target>
        </trans-unit>
        <trans-unit id="9e52fcae8c89336b9d76db6bc95e2d2ecd5abb9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single percentile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple percentiles are given, first axis of the result corresponds to the percentiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">場合 &lt;code&gt;q&lt;/code&gt; 単パーセンタイルとなる &lt;code&gt;axis=None&lt;/code&gt; 、その結果はスカラーではありません。複数のパーセンタイルが指定されている場合、結果の最初の軸はパーセンタイルに対応します。他の軸は、 &lt;code&gt;a&lt;/code&gt; の縮小後も残る軸です。入力に &lt;code&gt;float64&lt;/code&gt; より小さい整数または浮動小数点数が含まれている場合、出力データ型は &lt;code&gt;float64&lt;/code&gt; です。それ以外の場合、出力のデータ型は入力のデータ型と同じです。 &lt;code&gt;out&lt;/code&gt; が指定されている場合は、代わりにその配列が返されます。</target>
        </trans-unit>
        <trans-unit id="4219d6c9d1025bc747faeaba10649824d1b4aa46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single percentile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple quantiles are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">場合 &lt;code&gt;q&lt;/code&gt; 単パーセンタイルとなる &lt;code&gt;axis=None&lt;/code&gt; 、その結果はスカラーではありません。複数の変位値が指定されている場合、結果の最初の軸は変位値に対応します。他の軸は、 &lt;code&gt;a&lt;/code&gt; の縮小後も残る軸です。入力に &lt;code&gt;float64&lt;/code&gt; より小さい整数または浮動小数点数が含まれている場合、出力データ型は &lt;code&gt;float64&lt;/code&gt; です。それ以外の場合、出力のデータ型は入力のデータ型と同じです。 &lt;code&gt;out&lt;/code&gt; が指定されている場合は、代わりにその配列が返されます。</target>
        </trans-unit>
        <trans-unit id="adb7c2f1dd4ba6f271e782ab821bd6ce35c48378" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single quantile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple quantiles are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">場合 &lt;code&gt;q&lt;/code&gt; 単分位数となる &lt;code&gt;axis=None&lt;/code&gt; 、その結果はスカラーではありません。複数の変位値が指定されている場合、結果の最初の軸は変位値に対応します。他の軸は、 &lt;code&gt;a&lt;/code&gt; の縮小後も残る軸です。入力に &lt;code&gt;float64&lt;/code&gt; より小さい整数または浮動小数点数が含まれている場合、出力データ型は &lt;code&gt;float64&lt;/code&gt; です。それ以外の場合、出力のデータ型は入力のデータ型と同じです。 &lt;code&gt;out&lt;/code&gt; が指定されている場合は、代わりにその配列が返されます。</target>
        </trans-unit>
        <trans-unit id="9da6831f27b77e8b6677e8aad5c341d985befa99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is a 1-D array, then &lt;code&gt;p(x)&lt;/code&gt; will have the same shape as &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;r&lt;/code&gt; is multidimensional, then the shape of the result depends on the value of &lt;code&gt;tensor&lt;/code&gt;. If &lt;code&gt;tensor is ``True`&lt;/code&gt; the shape will be r.shape[1:] + x.shape; that is, each polynomial is evaluated at every value of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;tensor&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the shape will be r.shape[1:]; that is, each polynomial is evaluated only for the corresponding broadcast value of &lt;code&gt;x&lt;/code&gt;. Note that scalars have shape (,).</source>
          <target state="translated">場合 &lt;code&gt;r&lt;/code&gt; は 1次元配列であり、次いで、 &lt;code&gt;p(x)&lt;/code&gt; 同じ形状になります &lt;code&gt;x&lt;/code&gt; 。 &lt;code&gt;r&lt;/code&gt; が多次元の場合、結果の形状は &lt;code&gt;tensor&lt;/code&gt; の値に依存します。 &lt;code&gt;tensor is ``True`&lt;/code&gt; 場合、形状はr.shape [1：] + x.shape;になります。つまり、各多項式は &lt;code&gt;x&lt;/code&gt; のすべての値で評価されます。場合 &lt;code&gt;tensor&lt;/code&gt; ある &lt;code&gt;False&lt;/code&gt; を、形状がr.shape [1]であろう。つまり、各多項式は、対応する &lt;code&gt;x&lt;/code&gt; のブロードキャスト値についてのみ評価されます。スカラーには形状（、）があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="16d6bbf3ace149a532102c10ab8ede2738b896bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is of length &lt;code&gt;N&lt;/code&gt;, this function returns the value</source>
          <target state="translated">場合 &lt;code&gt;r&lt;/code&gt; は長さである &lt;code&gt;N&lt;/code&gt; 、この関数は値を返します</target>
        </trans-unit>
        <trans-unit id="6bc06c8f2ea0c3500f46f216948ca646bd403c39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep&lt;/code&gt; is an instance of a scalar dtype, True is returned. If not, False is returned.</source>
          <target state="translated">場合は &lt;code&gt;rep&lt;/code&gt; スカラーDTYPEのインスタンスである、Trueが返されます。そうでない場合は、Falseが返されます。</target>
        </trans-unit>
        <trans-unit id="caf6ef0eb6bbcb3c4e7a4a5b04998bc1341e6eb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reps&lt;/code&gt; has length &lt;code&gt;d&lt;/code&gt;, the result will have dimension of &lt;code&gt;max(d, A.ndim)&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;reps&lt;/code&gt; 長さがある &lt;code&gt;d&lt;/code&gt; は、結果がの次元があります &lt;code&gt;max(d, A.ndim)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15d930e73a09a54bb69273b247bbe9349e70a0c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rowvar&lt;/code&gt; is True (default), then each row represents a variable, with observations in the columns. Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations.</source>
          <target state="translated">場合 &lt;code&gt;rowvar&lt;/code&gt; が真（デフォルト）であり、各列は、列の観察と、変数を表します。それ以外の場合、関係は転置されます。各列は変数を表し、行には観測値が含まれます。</target>
        </trans-unit>
        <trans-unit id="0e485a675b3c010a2a7eedd59e29811b56d30eeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;axes&lt;/code&gt; have different length, or &lt;code&gt;axes&lt;/code&gt; not given and &lt;code&gt;len(s) != 2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; と &lt;code&gt;axes&lt;/code&gt; の長さが異なる場合、または &lt;code&gt;axes&lt;/code&gt; が指定されておらず、 &lt;code&gt;len(s) != 2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1a95f9d4c94712a6711035b0d38ca6007922134" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;axes&lt;/code&gt; have different length.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; と &lt;code&gt;axes&lt;/code&gt; 長さが異なる場合。</target>
        </trans-unit>
        <trans-unit id="7c3cc7c092c11cc91fc3de1425949e6b1c9585a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sctype&lt;/code&gt; is an object for which the type can not be inferred.</source>
          <target state="translated">&lt;code&gt;sctype&lt;/code&gt; が、型を推測できないオブジェクトの場合。</target>
        </trans-unit>
        <trans-unit id="9a8f382549c758d89f2c430b015281fc763e47f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;seed&lt;/code&gt; is not a &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;, a new &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; is instantiated. This function does not manage a default global instance.</source>
          <target state="translated">&lt;code&gt;seed&lt;/code&gt; が&lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;でない場合、新しい&lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; &lt;/a&gt;がインスタンス化されます。この関数は、デフォルトのグローバルインスタンスを管理しません。</target>
        </trans-unit>
        <trans-unit id="0aeaeba3f41f378516fdce780d9277e8a4ccfffb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.shape[k] == 1&lt;/code&gt; then for any legal index &lt;code&gt;index[k] == 0&lt;/code&gt;. This means that in the formula for the offset</source>
          <target state="translated">もし &lt;code&gt;self.shape[k] == 1&lt;/code&gt; 法的インデックス用次いで &lt;code&gt;index[k] == 0&lt;/code&gt; 。これは、オフセットの式で</target>
        </trans-unit>
        <trans-unit id="5df5fe3df9ec97e65980a43dfd1884e4e357c660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is non-singular, &lt;code&gt;ret&lt;/code&gt; is such that &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size))&lt;/code&gt; all return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;self&lt;/code&gt; 非特異で、 &lt;code&gt;ret&lt;/code&gt; 、そのようなことである &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size))&lt;/code&gt; すべての戻り &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e5eb20061bb0d5a1e031a6a1b5daa75d4a16cad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is non-singular, &lt;code&gt;ret&lt;/code&gt; is such that &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size)&lt;/code&gt; all return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; が特異でない場合、 &lt;code&gt;ret&lt;/code&gt; は &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size)&lt;/code&gt; すべて &lt;code&gt;True&lt;/code&gt; を返すようなものです。</target>
        </trans-unit>
        <trans-unit id="b27bb431dc045601d86e73a474de86c64d035384" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is singular.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; が特異な場合。</target>
        </trans-unit>
        <trans-unit id="a097af1908df1ac936bba64c59e9507a0eb901d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is not specified or &lt;code&gt;None&lt;/code&gt;, any whitespace string is a separator.</source>
          <target state="translated">場合は &lt;code&gt;sep&lt;/code&gt; 指定されていないか、されていない &lt;code&gt;None&lt;/code&gt; 、空白文字列が区切りです。</target>
        </trans-unit>
        <trans-unit id="6b286f3e58c7b02612a4551d6a9dcb5406b09f75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is not specified or None, any whitespace string is a separator.</source>
          <target state="translated">場合は &lt;code&gt;sep&lt;/code&gt; 指定されていないか、どれもされていない、空白文字列が区切りです。</target>
        </trans-unit>
        <trans-unit id="768a6e9085deaf336653d5c9857ddf9b254027d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; has length one i.e. &lt;code&gt;(N,)&lt;/code&gt;, or is a scalar &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;out&lt;/code&gt; becomes a single row matrix of shape &lt;code&gt;(1,N)&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;shape&lt;/code&gt; 長さ1、すなわちを有する &lt;code&gt;(N,)&lt;/code&gt; 、またはスカラーである &lt;code&gt;N&lt;/code&gt; 、 &lt;code&gt;out&lt;/code&gt; 形状の単一の行行列となる &lt;code&gt;(1,N)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="afe85dc9a909b4503b3e7da810ec90771fac4a7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sources&lt;/code&gt; does not contain a signature files, then F2PY is used to scan Fortran source files for routine signatures to construct the wrappers to Fortran codes.</source>
          <target state="translated">&lt;code&gt;sources&lt;/code&gt; 署名ファイルが含まれていない場合は、F2PYを使用してFortranソースファイルをスキャンし、ルーチンの署名を探して、Fortranコードのラッパーを作成します。</target>
        </trans-unit>
        <trans-unit id="5d3a0815985e487dc8833e6a9544cd8f4d19132e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tol&lt;/code&gt; &amp;lt; 0</source>
          <target state="translated">&lt;code&gt;tol&lt;/code&gt; &amp;lt;0の場合</target>
        </trans-unit>
        <trans-unit id="525464d43ab5c9d447229756137cbe7b0c9e5673" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;upstream&lt;/code&gt; isn&amp;rsquo;t there, it will be added after you access the NumPy repo with a command like &lt;code&gt;git fetch&lt;/code&gt; or &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;upstream&lt;/code&gt; ありませんあなたはコマンドでnumpyのレポにアクセスした後のように、それが追加されます &lt;code&gt;git fetch&lt;/code&gt; や &lt;code&gt;git pull&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cf15e83c2fdf72b1f29bfc75044966bd6bc1399" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is a 2-D array, return a copy of its &lt;code&gt;k&lt;/code&gt;-th diagonal. If &lt;code&gt;v&lt;/code&gt; is a 1-D array, return a 2-D array with &lt;code&gt;v&lt;/code&gt; on the &lt;code&gt;k&lt;/code&gt;-th diagonal.</source>
          <target state="translated">場合 &lt;code&gt;v&lt;/code&gt; は 2次元配列であり、それのコピーを返す &lt;code&gt;k&lt;/code&gt; 番目の対角。場合 &lt;code&gt;v&lt;/code&gt; は 1次元配列である、との2次元配列を返す &lt;code&gt;v&lt;/code&gt; 上 &lt;code&gt;k&lt;/code&gt; 番目の対角。</target>
        </trans-unit>
        <trans-unit id="8349a8e04c4275fccf8d4c40bdfe6166a838f29e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is longer than &lt;code&gt;a&lt;/code&gt;, the arrays are swapped before computation.</source>
          <target state="translated">場合 &lt;code&gt;v&lt;/code&gt; がより長い、配列は、計算の前にスワップされます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bfdbe84100978bde6f35b9bd48d4f5ad4bf72c8d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is not the same size as &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;mask&lt;/code&gt; then it will repeat. This gives behavior different from &lt;code&gt;a[mask] = values&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;values&lt;/code&gt; が &lt;code&gt;a&lt;/code&gt; や &lt;code&gt;mask&lt;/code&gt; と同じサイズでない場合は繰り返されます。これは、 &lt;code&gt;a[mask] = values&lt;/code&gt; とは異なる動作を提供します。</target>
        </trans-unit>
        <trans-unit id="54792a3abbf75ac3395cbad014c19ac2ff1595e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is smaller than &lt;code&gt;a&lt;/code&gt; it is repeated:</source>
          <target state="translated">&lt;code&gt;values&lt;/code&gt; が &lt;code&gt;a&lt;/code&gt; より小さい場合は繰り返されます。</target>
        </trans-unit>
        <trans-unit id="d3b50be1f74d03f550d5fd9dbbf8a888d565797b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x2&lt;/code&gt; is a scalar, its sign will be copied to all elements of &lt;code&gt;x1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x2&lt;/code&gt; がスカラーの場合、その符号は &lt;code&gt;x1&lt;/code&gt; のすべての要素にコピーされます。</target>
        </trans-unit>
        <trans-unit id="2e770d7b527b709ad5e13ef5b77aecccd75244de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; contains negative inputs, the answer is computed and returned in the complex domain.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; に負の入力が含まれている場合、回答が計算され、複素数ドメインに返されます。</target>
        </trans-unit>
        <trans-unit id="60fec046bd42368c53fb89df3120786c8d0bd4a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; contains negative values, the output is converted to the complex domain.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; に負の値が含まれている場合、出力は複素数ドメインに変換されます。</target>
        </trans-unit>
        <trans-unit id="b5f780e2f5cb497ee27a4b50260d939ccb5e1976" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, &lt;code&gt;x&lt;/code&gt; or its elements must support addition and multiplication with with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;x&lt;/code&gt; リストまたはタプルであり、それは、それ以外の場合はそのままとスカラーとして扱われ、ndarrayに変換されます。どちらの場合でも、 &lt;code&gt;x&lt;/code&gt; またはその要素は、それ自体と &lt;code&gt;c&lt;/code&gt; の要素との加算と乗算をサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="e9289f94a42ce2a055130aa0322c6aa21e4c7a12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, &lt;code&gt;x&lt;/code&gt; or its elements must support addition and multiplication with with themselves and with the elements of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;x&lt;/code&gt; リストまたはタプルであり、それは、それ以外の場合はそのままとスカラーとして扱われ、ndarrayに変換されます。どちらの場合でも、 &lt;code&gt;x&lt;/code&gt; またはその要素は、それ自体および &lt;code&gt;r&lt;/code&gt; の要素との加算および乗算をサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="0f3c93ccc6b110d8957f1eff605f32da46911a50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a multi-dimensional array, it is only shuffled along its first index.</source>
          <target state="translated">場合 &lt;code&gt;x&lt;/code&gt; 多次元配列であり、それが唯一の最初のインデックスに沿ってシャッフルされます。</target>
        </trans-unit>
        <trans-unit id="10902731cd32fb924a9fa6246d242dab230b11a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a poly1d instance, the result is the composition of the two polynomials, i.e., &lt;code&gt;x&lt;/code&gt; is &amp;ldquo;substituted&amp;rdquo; in &lt;code&gt;p&lt;/code&gt; and the simplified result is returned. In addition, the type of &lt;code&gt;x&lt;/code&gt; - array_like or poly1d - governs the type of the output: &lt;code&gt;x&lt;/code&gt; array_like =&amp;gt; &lt;code&gt;values&lt;/code&gt; array_like, &lt;code&gt;x&lt;/code&gt; a poly1d object =&amp;gt; &lt;code&gt;values&lt;/code&gt; is also.</source>
          <target state="translated">場合 &lt;code&gt;x&lt;/code&gt; は poly1dインスタンスであり、その結果、2つの多項式の組成物である、すなわち、 &lt;code&gt;x&lt;/code&gt; で「置換」されている &lt;code&gt;p&lt;/code&gt; 及び簡略化の結果が返されます。また、タイプ &lt;code&gt;x&lt;/code&gt; - array_like又はpoly1d -出力のタイプを支配： &lt;code&gt;x&lt;/code&gt; array_like =&amp;gt; &lt;code&gt;values&lt;/code&gt; array_likeは、 &lt;code&gt;x&lt;/code&gt; は poly1d物体=&amp;gt; &lt;code&gt;values&lt;/code&gt; もあります。</target>
        </trans-unit>
        <trans-unit id="d6a5280b73875b8ad0b036e2ed1535be94a86966" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a sequence, then &lt;code&gt;p(x)&lt;/code&gt; is returned for each element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is another polynomial then the composite polynomial &lt;code&gt;p(x(t))&lt;/code&gt; is returned.</source>
          <target state="translated">場合 &lt;code&gt;x&lt;/code&gt; が配列され、次いで、 &lt;code&gt;p(x)&lt;/code&gt; 、各要素のために返される &lt;code&gt;x&lt;/code&gt; 。場合 &lt;code&gt;x&lt;/code&gt; 、別の多項式複合多項式 &lt;code&gt;p(x(t))&lt;/code&gt; 返されます。</target>
        </trans-unit>
        <trans-unit id="e418b1b9672c946b1ca5e8afc3125fd05c313b38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a subtype of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; the return value will be of the same type.</source>
          <target state="translated">場合 &lt;code&gt;x&lt;/code&gt; のサブタイプである&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;戻り値は、同じタイプであろう。</target>
        </trans-unit>
        <trans-unit id="2f55968163fb644f21e767c8ca56c7265582f682" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an integer, randomly permute &lt;code&gt;np.arange(x)&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is an array, make a copy and shuffle the elements randomly.</source>
          <target state="translated">場合 &lt;code&gt;x&lt;/code&gt; 整数であり、ランダムに並び替える &lt;code&gt;np.arange(x)&lt;/code&gt; 。 &lt;code&gt;x&lt;/code&gt; が配列の場合、コピーを作成し、要素をランダムにシャッフルします。</target>
        </trans-unit>
        <trans-unit id="8675c9efb1c5ad5afa002d06cb6dcceef7c6f2a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is inexact, NaN is replaced by zero or by the user defined value in &lt;a href=&quot;../constants#numpy.nan&quot;&gt;&lt;code&gt;nan&lt;/code&gt;&lt;/a&gt; keyword, infinity is replaced by the largest finite floating point values representable by &lt;code&gt;x.dtype&lt;/code&gt; or by the user defined value in &lt;code&gt;posinf&lt;/code&gt; keyword and -infinity is replaced by the most negative finite floating point values representable by &lt;code&gt;x.dtype&lt;/code&gt; or by the user defined value in &lt;code&gt;neginf&lt;/code&gt; keyword.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; が不正確な場合、NaNはゼロまたは&lt;a href=&quot;../constants#numpy.nan&quot;&gt; &lt;code&gt;nan&lt;/code&gt; &lt;/a&gt;キーワードのユーザー定義値で置き換えられ、無限大は &lt;code&gt;x.dtype&lt;/code&gt; で表される最大の有限浮動小数点値または &lt;code&gt;posinf&lt;/code&gt; キーワードのユーザー定義値で置き換えられ、-infinityは &lt;code&gt;x.dtype&lt;/code&gt; または &lt;code&gt;neginf&lt;/code&gt; キーワードのユーザー定義値で表現できる最も負の有限浮動小数点値。</target>
        </trans-unit>
        <trans-unit id="a12bcfaac2b6a0d5eb775110eb5d113a7ffcf89b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not inexact, then no replacements are made.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; が不正確でない場合、置換は行われません。</target>
        </trans-unit>
        <trans-unit id="dab92b609c96bcdc43f19efa69fe1680ecbcb0cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is of a signed integer type, then the output type is the default platform integer:</source>
          <target state="translated">場合 &lt;code&gt;x&lt;/code&gt; 符号付き整数型であり、出力タイプは、デフォルトプラットフォームの整数です。</target>
        </trans-unit>
        <trans-unit id="9b8211170506c6269c7986617b768331c6cb9374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;xp&lt;/code&gt; and &lt;code&gt;fp&lt;/code&gt; have different length If &lt;code&gt;xp&lt;/code&gt; or &lt;code&gt;fp&lt;/code&gt; are not 1-D sequences If &lt;code&gt;period == 0&lt;/code&gt;</source>
          <target state="translated">場合 &lt;code&gt;xp&lt;/code&gt; 及び &lt;code&gt;fp&lt;/code&gt; は異なる長さを有する場合 &lt;code&gt;xp&lt;/code&gt; または &lt;code&gt;fp&lt;/code&gt; 1-D配列がされていない場合 &lt;code&gt;period == 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c2455250a9da7702638a12b7e54e59f4d21fc53" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;arr&lt;/em&gt; is an array, returns its data type descriptor, but if &lt;em&gt;arr&lt;/em&gt; is an array scalar (has 0 dimensions), it finds the data type of smallest size to which the value may be converted without overflow or truncation to an integer.</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt;が配列の場合、そのデータ型記述子を返しますが、&lt;em&gt;arr&lt;/em&gt;が配列スカラー（0次元）の場合、オーバーフローや整数への切り捨てなしに値を変換できる最小サイズのデータ​​型を見つけます。</target>
        </trans-unit>
        <trans-unit id="a70ed9437e4a5163189d25b472581eabce8d5ceb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;axis&lt;/em&gt; is &lt;em&gt;None&lt;/em&gt; (the default), the array is treated as a 1-D array and the operation is performed over the entire array. This behavior is also the default if self is a 0-dimensional array or array scalar. (An array scalar is an instance of the types/classes float32, float64, etc., whereas a 0-dimensional array is an ndarray instance containing precisely one array scalar.)</source>
          <target state="translated">場合&lt;em&gt;軸は&lt;/em&gt;ありません&lt;em&gt;なし&lt;/em&gt;（デフォルト）、アレイは、1次元アレイとして処理され、動作がアレイ全体にわたって行われます。この動作は、selfが0次元配列または配列スカラーの場合のデフォルトでもあります。（配列スカラーは、float32、float64などの型/クラスのインスタンスですが、0次元配列は、正確に1つの配列スカラーを含むndarrayインスタンスです。）</target>
        </trans-unit>
        <trans-unit id="9235232429102d093beb5f545c26b8fef229f79b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;axis&lt;/em&gt; is an integer, then the operation is done over the given axis (for each 1-D subarray that can be created along the given axis).</source>
          <target state="translated">&lt;em&gt;axis&lt;/em&gt;が整数の場合、操作は指定された軸上で行われます（指定された軸に沿って作成できる1-Dサブアレイごとに）。</target>
        </trans-unit>
        <trans-unit id="1b1a4ec186584bdfde20daf47a6283f1daa2a542" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then new unitinialized memory will be allocated and &lt;em&gt;flags&lt;/em&gt; can be non-zero to indicate a Fortran-style contiguous array. Use &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt;&lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt;&lt;/a&gt; to initialize the memory.</source>
          <target state="translated">場合は&lt;em&gt;、データが&lt;/em&gt;ある &lt;code&gt;NULL&lt;/code&gt; 、その後、新しいunitinializedメモリが割り当てられることになり、&lt;em&gt;フラグは&lt;/em&gt; Fortran形式の連続配列を示すために、非ゼロにすることができます。&lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt; &lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt; &lt;/a&gt;を使用してメモリを初期化します。</target>
        </trans-unit>
        <trans-unit id="b7bd71ee3411fe6c23b731a500527ae1ac46e705" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is not &lt;code&gt;NULL&lt;/code&gt;, then it is assumed to point to the memory to be used for the array and the &lt;em&gt;flags&lt;/em&gt; argument is used as the new flags for the array (except the state of &lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt;&lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags of the new array will be reset).</source>
          <target state="translated">&lt;em&gt;データ&lt;/em&gt;が &lt;code&gt;NULL&lt;/code&gt; でない場合は、配列に使用されるメモリを&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;、&lt;em&gt;flags&lt;/em&gt;引数が配列の新しいフラグとして使用されます（新しい配列の&lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt; &lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt; &lt;/a&gt;、NPY_ARRAY_WRITEBACKIFCOPY、およびNPY_ARRAY_UPDATEIFCOPYフラグの状態を除く）リセットされます）。</target>
        </trans-unit>
        <trans-unit id="6b3854bd1e23682951d79d6393e1c1b2b19835be" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is not &lt;code&gt;NULL&lt;/code&gt;, then it is assumed to point to the memory to be used for the array and the &lt;em&gt;flags&lt;/em&gt; argument is used as the new flags for the array (except the state of &lt;code&gt;NPY_OWNDATA&lt;/code&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags of the new array will be reset).</source>
          <target state="translated">&lt;em&gt;data&lt;/em&gt;が &lt;code&gt;NULL&lt;/code&gt; でない場合、配列に使用されるメモリを指すと見なされ、&lt;em&gt;flags&lt;/em&gt;引数が配列の新しいフラグとして使用されます（新しい配列の &lt;code&gt;NPY_OWNDATA&lt;/code&gt; 、&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;フラグの状態は除く）リセットされます）。</target>
        </trans-unit>
        <trans-unit id="9cebbbbcc1739892f8b12e053651c131570cd283" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;descr&lt;/em&gt; is NULL, the data type of &lt;em&gt;prototype&lt;/em&gt; is used.</source>
          <target state="translated">&lt;em&gt;descr&lt;/em&gt;がNULLの場合、&lt;em&gt;プロトタイプ&lt;/em&gt;のデータ型が使用されます。</target>
        </trans-unit>
        <trans-unit id="aec9506a456027cf0203832745240a439d9ff187" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;dtype&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the returned array will have the same data type as &lt;em&gt;self&lt;/em&gt;. The new data-type must be consistent with the size of &lt;em&gt;self&lt;/em&gt;. Either the itemsizes must be identical, or &lt;em&gt;self&lt;/em&gt; must be single-segment and the total number of bytes must be the same. In the latter case the dimensions of the returned array will be altered in the last (or first for Fortran-style contiguous arrays) dimension. The data area of the returned array and self is exactly the same.</source>
          <target state="translated">&lt;em&gt;dtype&lt;/em&gt;が &lt;code&gt;NULL&lt;/code&gt; の場合、返される配列は&lt;em&gt;self&lt;/em&gt;と同じデータ型になります。新しいデータ型は、&lt;em&gt;自分自身&lt;/em&gt;のサイズと一致している必要があります。 itemsizeは同一であるか、&lt;em&gt;self&lt;/em&gt;は単一セグメントで、バイトの総数は同じでなければなりません。後者の場合、返される配列の次元は、最後（またはFortranスタイルの連続配列の場合は最初）の次元で変更されます。返された配列と自己のデータ領域はまったく同じです。</target>
        </trans-unit>
        <trans-unit id="b00215400909f507a463937ff52555cace4d8945" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;op&lt;/em&gt; is already an array, but does not satisfy the requirements, then a copy is made (which will satisfy the requirements). If this flag is present and a copy (of an object that is already an array) must be made, then the corresponding &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag is set in the returned copy and &lt;em&gt;op&lt;/em&gt; is made to be read-only. You must be sure to call &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; to copy the contents back into &lt;em&gt;op&lt;/em&gt; and the &lt;em&gt;op&lt;/em&gt; array will be made writeable again. If &lt;em&gt;op&lt;/em&gt; is not writeable to begin with, or if it is not already an array, then an error is raised.</source>
          <target state="translated">場合&lt;em&gt;opが&lt;/em&gt;既に配列であるが、要件を満たしていない場合、コピーは（要件を満たすであろう）が行われます。このフラグが存在し、（すでに配列であるオブジェクトの）コピーを作成する必要がある場合、対応する&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;フラグが返されたコピーに設定され、&lt;em&gt;op&lt;/em&gt;は読み取り専用になります。必ず&lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;を呼び出して内容を&lt;em&gt;op&lt;/em&gt;にコピーし直すと、&lt;em&gt;op&lt;/em&gt;配列が再び書き込み可能になります。&lt;em&gt;op&lt;/em&gt;が最初から書き込み可能でない場合、または&lt;em&gt;op&lt;/em&gt;がまだ配列でない場合は、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="2b3d523872c6239b2b47533fe932fb9b935c7ec9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;permute&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, the shape of the result is</source>
          <target state="translated">&lt;em&gt;permute&lt;/em&gt;が &lt;code&gt;NULL&lt;/code&gt; の場合、結果の形状は</target>
        </trans-unit>
        <trans-unit id="864a2871c8455778be67517dc3e9f63ae59a60fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subok&lt;/em&gt; is 1, the newly created array will use the sub-type of &lt;em&gt;prototype&lt;/em&gt; to create the new array, otherwise it will create a base-class array.</source>
          <target state="translated">場合&lt;em&gt;subokは&lt;/em&gt; 1で、新しく作成された配列は、のサブタイプに使用する&lt;em&gt;プロトタイプを&lt;/em&gt;、それ以外の場合は、基本クラスの配列を作成します、新しい配列を作成します。</target>
        </trans-unit>
        <trans-unit id="d7c8774de40710ea170a99b3d842fc0b2a6f66b4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subtype&lt;/em&gt; is of an array subclass instead of the base &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;, then &lt;em&gt;obj&lt;/em&gt; is the object to pass to the &lt;a href=&quot;arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; method of the subclass.</source>
          <target state="translated">&lt;em&gt;サブタイプ&lt;/em&gt;が基本の&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt; &lt;/a&gt;ではなく配列サブクラスのものである場合、&lt;em&gt;obj&lt;/em&gt;はサブクラスの&lt;a href=&quot;arrays.classes#numpy.class.__array_finalize__&quot;&gt; &lt;code&gt;__array_finalize__&lt;/code&gt; &lt;/a&gt;メソッドに渡すオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="3703a88bcd847e1448a723a502192b0e8fa8fa65" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subtype&lt;/em&gt; is of an array subclass instead of the base &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;, then &lt;em&gt;obj&lt;/em&gt; is the object to pass to the &lt;a href=&quot;../arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; method of the subclass.</source>
          <target state="translated">&lt;em&gt;サブタイプ&lt;/em&gt;がベースの&lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt; &lt;/a&gt;ではなく配列サブクラスである場合、&lt;em&gt;obj&lt;/em&gt;はサブクラスの&lt;a href=&quot;../arrays.classes#numpy.class.__array_finalize__&quot;&gt; &lt;code&gt;__array_finalize__&lt;/code&gt; &lt;/a&gt;メソッドに渡すオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="c808aeb714f46484081440736a2f659eda1cb00f" translate="yes" xml:space="preserve">
          <source>If A = qr such that q is orthonormal (which is always possible via Gram-Schmidt), then &lt;code&gt;x = inv(r) * (q.T) * b&lt;/code&gt;. (In numpy practice, however, we simply use &lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt;&lt;code&gt;lstsq&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">A = qrで、qが正規直交である場合（これは常にGram-Schmidtを介して可能）、 &lt;code&gt;x = inv(r) * (q.T) * b&lt;/code&gt; です。（しかし、&lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt; &lt;code&gt;lstsq&lt;/code&gt; &lt;/a&gt;練習では、単にlstsqを使用します。）</target>
        </trans-unit>
        <trans-unit id="a5523a2784c429b6ba47e45d47c8a0bb942c669e" translate="yes" xml:space="preserve">
          <source>If False, a view into the original arrays are returned in order to conserve memory. Default is True. Please note that &lt;code&gt;sparse=False, copy=False&lt;/code&gt; will likely return non-contiguous arrays. Furthermore, more than one element of a broadcast array may refer to a single memory location. If you need to write to the arrays, make copies first.</source>
          <target state="translated">Falseの場合、メモリを節約するために元の配列のビューが返されます。デフォルトはTrueです。 &lt;code&gt;sparse=False, copy=False&lt;/code&gt; は不連続な配列を返す可能性が高いことに注意してください。さらに、ブロードキャストアレイの複数の要素が単一のメモリ位置を参照する場合があります。アレイに書き込む必要がある場合は、最初にコピーを作成してください。</target>
        </trans-unit>
        <trans-unit id="343caea52a4d2f3f220c6f641bc3ef525fc8ff10" translate="yes" xml:space="preserve">
          <source>If False, reference count will not be checked. Default is True.</source>
          <target state="translated">False の場合、参照カウントはチェックされません。デフォルトはTrueです。</target>
        </trans-unit>
        <trans-unit id="cc82a0ba7e27b536a6fe2ae6adeaa5a186566e3c" translate="yes" xml:space="preserve">
          <source>If False, the default, returns the number of samples in each bin. If True, returns the probability &lt;em&gt;density&lt;/em&gt; function at the bin, &lt;code&gt;bin_count / sample_count / bin_area&lt;/code&gt;.</source>
          <target state="translated">デフォルトのFalseの場合、各ビンのサンプル数を返します。Trueの場合、ビンの確率&lt;em&gt;密度&lt;/em&gt;関数 &lt;code&gt;bin_count / sample_count / bin_area&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="023ffe5319599a1faa2198b591752fc4467344db" translate="yes" xml:space="preserve">
          <source>If False, the default, returns the number of samples in each bin. If True, returns the probability &lt;em&gt;density&lt;/em&gt; function at the bin, &lt;code&gt;bin_count / sample_count / bin_volume&lt;/code&gt;.</source>
          <target state="translated">デフォルトのFalseの場合、各ビンのサンプル数を返します。Trueの場合、ビンでの確率&lt;em&gt;密度&lt;/em&gt;関数 &lt;code&gt;bin_count / sample_count / bin_volume&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="fff9762cd2d96487b93950bfb4f1067d252f526d" translate="yes" xml:space="preserve">
          <source>If GitHub indicates that the branch of your Pull Request can no longer be merged automatically, you have to incorporate changes that have been made since you started into your branch. Our recommended way to do this is to &lt;a href=&quot;development_workflow#rebasing-on-master&quot;&gt;rebase on master&lt;/a&gt;.</source>
          <target state="translated">プルリクエストのブランチを自動的にマージできなくなったことをGitHubが示している場合は、ブランチを開始してから行った変更を組み込む必要があります。これを行うための推奨される方法は&lt;a href=&quot;development_workflow#rebasing-on-master&quot;&gt;、マスター&lt;/a&gt;にリベースすることです。</target>
        </trans-unit>
        <trans-unit id="a65d3c4015ca8415c134fa3b89bccc8e92003c36" translate="yes" xml:space="preserve">
          <source>If K = min(M, N), then</source>
          <target state="translated">K=min(M,N)とすると</target>
        </trans-unit>
        <trans-unit id="c8fe35dc8be08c32dcc7a321c29a26e840a0b0cb" translate="yes" xml:space="preserve">
          <source>If None, the index is into the flattened array, otherwise along the specified axis</source>
          <target state="translated">None の場合,インデックスは平坦化された配列の中にあり,そうでない場合は指定された軸に沿っています.</target>
        </trans-unit>
        <trans-unit id="b2ed776381411dcc06237a74c5e85611ae70c52e" translate="yes" xml:space="preserve">
          <source>If None, then the path is assumed to be the local path plus the subpackage_name. If a setup.py file is not found in the subpackage_path, then a default configuration is used.</source>
          <target state="translated">None の場合は、パスはローカルパスにサブパッケージ名を加えたものとみなされます。subpackage_path に setup.py ファイルが見つからない場合は、デフォルトの設定が使用されます。</target>
        </trans-unit>
        <trans-unit id="7ed2128e955055b733a7b269ab15855f518690e5" translate="yes" xml:space="preserve">
          <source>If None, use a MaskType instance. Otherwise, use a new datatype with the same fields as &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, converted to boolean types.</source>
          <target state="translated">Noneの場合、MaskTypeインスタンスを使用します。それ以外の場合は、ブール型に変換された、&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;と同じフィールドを持つ新しいデータ型を使用します。</target>
        </trans-unit>
        <trans-unit id="7f68badbcb18a0e633a2cc1aee70bc74cc566792" translate="yes" xml:space="preserve">
          <source>If None, use a MaskType instance. Otherwise, use a new datatype with the same fields as &lt;code&gt;dtype&lt;/code&gt;, converted to boolean types.</source>
          <target state="translated">Noneの場合、MaskTypeインスタンスを使用します。それ以外の場合は、ブール型に変換された &lt;code&gt;dtype&lt;/code&gt; と同じフィールドを持つ新しいデータ型を使用します。</target>
        </trans-unit>
        <trans-unit id="858f084d421de6a09702f1940e95232bb37adf96" translate="yes" xml:space="preserve">
          <source>If Python &lt;code&gt;None&lt;/code&gt; object is used as a required argument, the argument is treated as optional. That is, in the case of array argument, the memory is allocated. And if &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; is given, the corresponding initialization is carried out.</source>
          <target state="translated">Python &lt;code&gt;None&lt;/code&gt; オブジェクトが必須の引数として使用されている場合、その引数はオプションとして扱われます。つまり、配列引数の場合、メモリが割り当てられます。また、 &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; を指定すると、対応する初期化が実行されます。</target>
        </trans-unit>
        <trans-unit id="b88b29f182ab4a1e89998e5d778c700419477eb5" translate="yes" xml:space="preserve">
          <source>If SVD computation does not converge.</source>
          <target state="translated">SVD計算が収束しない場合。</target>
        </trans-unit>
        <trans-unit id="1c8e91eba4c31b07d056c5e107cd3dbd66e73c1f" translate="yes" xml:space="preserve">
          <source>If True (default) make a copy of &lt;code&gt;a&lt;/code&gt; in the result. If False modify &lt;code&gt;a&lt;/code&gt; in place and return a view.</source>
          <target state="translated">TRUE（デフォルト）のコピーを作成した場合、結果に。Falseの場合 &lt;code&gt;a&lt;/code&gt; インプレースを変更してビューを返します。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f05298246a514cfbe30605192f5c3eec0c39e89" translate="yes" xml:space="preserve">
          <source>If True (default), &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;vh&lt;/code&gt; have the shapes &lt;code&gt;(..., M, M)&lt;/code&gt; and &lt;code&gt;(..., N, N)&lt;/code&gt;, respectively. Otherwise, the shapes are &lt;code&gt;(..., M, K)&lt;/code&gt; and &lt;code&gt;(..., K, N)&lt;/code&gt;, respectively, where &lt;code&gt;K = min(M, N)&lt;/code&gt;.</source>
          <target state="translated">True（デフォルト）の場合、 &lt;code&gt;u&lt;/code&gt; および &lt;code&gt;vh&lt;/code&gt; の形状はそれぞれ &lt;code&gt;(..., M, M)&lt;/code&gt; および &lt;code&gt;(..., N, N)&lt;/code&gt; です。それ以外の場合、形状はそれぞれ &lt;code&gt;(..., M, K)&lt;/code&gt; および &lt;code&gt;(..., K, N)&lt;/code&gt; です。ここで、 &lt;code&gt;K = min(M, N)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b7193bd03fb8a4044e82de41b9072ea59ef18024" translate="yes" xml:space="preserve">
          <source>If True (default), the function for pretty printing (&lt;code&gt;__repr__&lt;/code&gt;) is set, if False the function that returns the default string representation (&lt;code&gt;__str__&lt;/code&gt;) is set.</source>
          <target state="translated">True（デフォルト）の場合、プリティプリント用の関数（ &lt;code&gt;__repr__&lt;/code&gt; ）が設定され、Falseの場合、デフォルトの文字列表現（ &lt;code&gt;__str__&lt;/code&gt; ）を返す関数が設定されます。</target>
        </trans-unit>
        <trans-unit id="303e2928545dd79ae7d3ee948a353e0207edca4f" translate="yes" xml:space="preserve">
          <source>If True a sparse grid is returned in order to conserve memory. Default is False.</source>
          <target state="translated">True にすると、メモリを節約するために疎なグリッドを返します。デフォルトは False です。</target>
        </trans-unit>
        <trans-unit id="963fdb4eb1744c24416dda1302569ec977b1039b" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;M&lt;/code&gt; is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values. Defaults to False.</source>
          <target state="translated">Trueの場合、 &lt;code&gt;M&lt;/code&gt; はエルミート（実数値の場合は対称）と見なされ、特異値を見つけるためのより効率的な方法が可能になります。デフォルトはFalseです。</target>
        </trans-unit>
        <trans-unit id="7ff6382ed5c39a63563e9ed1fd085cab5037a2b5" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;a&lt;/code&gt; is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values. Defaults to False.</source>
          <target state="translated">Trueの場合、 &lt;code&gt;a&lt;/code&gt; はエルミート（実数値の場合は対称）であると見なされ、特異値を見つけるためのより効率的な方法が可能になります。デフォルトはFalseです。</target>
        </trans-unit>
        <trans-unit id="e36b410b04f66dbee1ad8585d5ab761e08ac7f58" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;c_or_r&lt;/code&gt; specifies the polynomial&amp;rsquo;s roots; the default is False.</source>
          <target state="translated">Trueの場合、 &lt;code&gt;c_or_r&lt;/code&gt; は多項式の根を指定します。デフォルトはFalseです。</target>
        </trans-unit>
        <trans-unit id="d928194afbe2c2b929bfedb481313d712d7c8b8b" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;stop&lt;/code&gt; is the last sample. Otherwise, it is not included. Default is True.</source>
          <target state="translated">Trueの場合、 &lt;code&gt;stop&lt;/code&gt; は最後のサンプルです。それ以外の場合は含まれません。デフォルトはTrueです。</target>
        </trans-unit>
        <trans-unit id="7b47be5e3a5ad40d6f18921eb27fcceb85292f89" translate="yes" xml:space="preserve">
          <source>If True, NaNs will compare equal.</source>
          <target state="translated">Trueの場合、NaNは等しく比較されます。</target>
        </trans-unit>
        <trans-unit id="cf238e83938a09d87961a742f48c2f2620eb27d1" translate="yes" xml:space="preserve">
          <source>If True, align the fields by padding as the C-compiler would. Default is False.</source>
          <target state="translated">Trueの場合、Cコンパイラが行うようにフィールドをパディングして整列させます。デフォルトは False です。</target>
        </trans-unit>
        <trans-unit id="9aac1833ab9bd35419c20a57ebf8fcbcb3fe9e5b" translate="yes" xml:space="preserve">
          <source>If True, also repack nested structures.</source>
          <target state="translated">True の場合は、ネストされた構造体も再パックします。</target>
        </trans-unit>
        <trans-unit id="fac02997269b77136285be7a5e579ac29dadfffd" translate="yes" xml:space="preserve">
          <source>If True, also return the indices of &lt;code&gt;ar&lt;/code&gt; (along the specified axis, if provided, or in the flattened array) that result in the unique array.</source>
          <target state="translated">Trueの場合、一意の配列となる &lt;code&gt;ar&lt;/code&gt; のインデックス（指定された軸がある場合は、指定された軸に沿って、またはフラット化された配列）も返します。</target>
        </trans-unit>
        <trans-unit id="5ba4a4047dcee50611d5129a3a15323121b0e960" translate="yes" xml:space="preserve">
          <source>If True, also return the indices of the unique array (for the specified axis, if provided) that can be used to reconstruct &lt;code&gt;ar&lt;/code&gt;.</source>
          <target state="translated">Trueの場合、 &lt;code&gt;ar&lt;/code&gt; を再構築するために使用できる（指定された軸がある場合は、指定された軸の）一意の配列のインデックスも返します。</target>
        </trans-unit>
        <trans-unit id="399ee9e74026589c23b2445da8094594d73ae5dd" translate="yes" xml:space="preserve">
          <source>If True, also return the number of times each unique item appears in &lt;code&gt;ar&lt;/code&gt;.</source>
          <target state="translated">Trueの場合、一意の各アイテムが &lt;code&gt;ar&lt;/code&gt; に表示される回数も返します。</target>
        </trans-unit>
        <trans-unit id="66852352128b1c7e34ad7789302cdfe6ede485bb" translate="yes" xml:space="preserve">
          <source>If True, always print floating point numbers using fixed point notation, in which case numbers equal to zero in the current precision will print as zero. If False, then scientific notation is used when absolute value of the smallest number is &amp;lt; 1e-4 or the ratio of the maximum absolute value to the minimum is &amp;gt; 1e3. The default is False.</source>
          <target state="translated">Trueの場合、常に固定小数点表記を使用して浮動小数点数を印刷します。この場合、現在の精度でゼロに等しい数値はゼロとして印刷されます。Falseの場合、最小数の絶対値が&amp;lt;1e-4であるか、最大絶対値と最小絶対値の比が&amp;gt; 1e3である場合、科学表記法が使用されます。デフォルトはFalseです。</target>
        </trans-unit>
        <trans-unit id="cbca430a42a0182aa9ea6441a3957e8ab3c8a25b" translate="yes" xml:space="preserve">
          <source>If True, always returns a tuple.</source>
          <target state="translated">True の場合、常にタプルを返します。</target>
        </trans-unit>
        <trans-unit id="7f126462d85653c6dda1dce20f661e9fd87395a7" translate="yes" xml:space="preserve">
          <source>If True, an exception is raised if an inconsistency is detected in the number of columns. If False, a warning is emitted and the offending lines are skipped.</source>
          <target state="translated">True の場合、カラム数の不一致が検出された場合に例外が発生します。False の場合、警告が表示され、問題のある行はスキップされます。</target>
        </trans-unit>
        <trans-unit id="00dd94f809ecdc81e9a20bf00165ace3a76e2409" translate="yes" xml:space="preserve">
          <source>If True, do not raise errors for invalid values.</source>
          <target state="translated">True の場合、無効な値に対してエラーを発生させません。</target>
        </trans-unit>
        <trans-unit id="75ba0a561e02b7ed5e7fa180639d41ec79419f2b" translate="yes" xml:space="preserve">
          <source>If True, field names are case sensitive. If False or &amp;lsquo;upper&amp;rsquo;, field names are converted to upper case. If &amp;lsquo;lower&amp;rsquo;, field names are converted to lower case.</source>
          <target state="translated">Trueの場合、フィールド名では大文字と小文字が区別されます。Falseまたは 'upper'の場合、フィールド名は大文字に変換されます。「小文字」の場合、フィールド名は小文字に変換されます。</target>
        </trans-unit>
        <trans-unit id="d130bfc0ef6421a7c1dc4437f4b7a0f3775ccf94" translate="yes" xml:space="preserve">
          <source>If True, fields in the dst for which there was no matching field in the src are filled with the value 0 (zero). This was the behavior of numpy &amp;lt;= 1.13. If False, those fields are not modified.</source>
          <target state="translated">Trueの場合、srcに一致するフィールドがなかったdstのフィールドには、値0（ゼロ）が入力されます。これは、numpy &amp;lt;= 1.13の動作でした。Falseの場合、これらのフィールドは変更されません。</target>
        </trans-unit>
        <trans-unit id="7d57971ed0ca8f21d400e58c76703f43cbfc417c" translate="yes" xml:space="preserve">
          <source>If True, masked values are propagated pair-wise: if a value is masked in &lt;code&gt;x&lt;/code&gt;, the corresponding value is masked in &lt;code&gt;y&lt;/code&gt;. If False, raises a &lt;code&gt;ValueError&lt;/code&gt; exception when some values are missing.</source>
          <target state="translated">Trueの場合、マスクされた値はペアごとに伝達されます。値が &lt;code&gt;x&lt;/code&gt; でマスクされている場合、対応する値は &lt;code&gt;y&lt;/code&gt; でマスクされます。Falseの場合、一部の値が欠落しているときに &lt;code&gt;ValueError&lt;/code&gt; 例外を発生させます。</target>
        </trans-unit>
        <trans-unit id="73add7a762002fef273e9b4ffea7ca56d1fceed2" translate="yes" xml:space="preserve">
          <source>If True, masked values are propagated pair-wise: if a value is masked in &lt;code&gt;x&lt;/code&gt;, the corresponding value is masked in &lt;code&gt;y&lt;/code&gt;. If False, raises an exception. Because &lt;code&gt;bias&lt;/code&gt; is deprecated, this argument needs to be treated as keyword only to avoid a warning.</source>
          <target state="translated">Trueの場合、マスクされた値はペアごとに伝達されます。値が &lt;code&gt;x&lt;/code&gt; でマスクされている場合、対応する値は &lt;code&gt;y&lt;/code&gt; でマスクされます。Falseの場合、例外が発生します。ので &lt;code&gt;bias&lt;/code&gt; 廃止されて、この引数は唯一の警告を回避するためのキーワードとして扱われる必要があります。</target>
        </trans-unit>
        <trans-unit id="3151423c1b8495757a74a9c40933465afccfc94a" translate="yes" xml:space="preserve">
          <source>If True, report coverage of NumPy code. Default is False. (This requires the &lt;a href=&quot;https://nedbatchelder.com/code/modules/coveragehtml&quot;&gt;coverage module&lt;/a&gt;).</source>
          <target state="translated">Trueの場合、NumPyコードのカバレッジを報告します。デフォルトはFalseです。（これには&lt;a href=&quot;https://nedbatchelder.com/code/modules/coveragehtml&quot;&gt;カバレッジモジュール&lt;/a&gt;が必要です）。</target>
        </trans-unit>
        <trans-unit id="3f2788b0d6fce7deb3124b031af49411eebfd85f" translate="yes" xml:space="preserve">
          <source>If True, return (&lt;code&gt;samples&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt;), where &lt;code&gt;step&lt;/code&gt; is the spacing between samples.</source>
          <target state="translated">確かに、リターン（もし &lt;code&gt;samples&lt;/code&gt; 、 &lt;code&gt;step&lt;/code&gt; ） &lt;code&gt;step&lt;/code&gt; サンプル間の間隔です。</target>
        </trans-unit>
        <trans-unit id="273f09f29e0c5b2094a6e70e74f740f3fc0e31da" translate="yes" xml:space="preserve">
          <source>If True, return a &lt;a href=&quot;https://docs.python.org/dev/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;subprocess.CompletedProcess&lt;/code&gt;&lt;/a&gt; containing the stdout and stderr of the compile process, instead of just the status code.</source>
          <target state="translated">Trueの場合、ステータスコードだけでなく、コンパイルプロセスのstdoutとstderrを含む&lt;a href=&quot;https://docs.python.org/dev/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;subprocess.CompletedProcess&lt;/code&gt; &lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="1ec0fbd07daef19f7914b14e4eca0f4fd562cd19" translate="yes" xml:space="preserve">
          <source>If True, return a masked array. If False, return a regular array.</source>
          <target state="translated">True の場合、マスクされた配列を返します。False の場合、正規の配列を返します。</target>
        </trans-unit>
        <trans-unit id="6adea9a68fb349bf8bb3df130607e9340ead5b74" translate="yes" xml:space="preserve">
          <source>If True, run doctests in module. Default is False.</source>
          <target state="translated">True の場合、モジュール内で doctests を実行します。デフォルトは False です。</target>
        </trans-unit>
        <trans-unit id="23ec8ba9608d7abff50b6dc8fd3f7629dafcce5d" translate="yes" xml:space="preserve">
          <source>If True, specifies that the decorated callable is a test. If False, specifies that the decorated callable is not a test. Default is True.</source>
          <target state="translated">真の場合、デコレーションされた呼び出し可能ファイルがテストであることを指定します。Falseの場合、デコレーションされた呼び出し可能ファイルがテストではないことを指定します。デフォルトはTrueです。</target>
        </trans-unit>
        <trans-unit id="528d6459701fb35380cbc7e9b626e72c7e5fe90f" translate="yes" xml:space="preserve">
          <source>If True, sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (default).</source>
          <target state="translated">Trueの場合、サブクラスはスルーされます。そうでない場合は、返される配列は強制的にベースクラスの配列になります(デフォルト)。</target>
        </trans-unit>
        <trans-unit id="392d55a0a9d04db7b0ca9f8c7072e4cdcc499491" translate="yes" xml:space="preserve">
          <source>If True, subclasses are preserved.</source>
          <target state="translated">True の場合、サブクラスが保存されます。</target>
        </trans-unit>
        <trans-unit id="8d750c3ba08e3d89b81f148fbacf7cfd56b0a5f8" translate="yes" xml:space="preserve">
          <source>If True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">Trueの場合、縮小された軸はサイズ1の次元として結果に残ります。このオプションを使用すると、結果は元の &lt;code&gt;arr&lt;/code&gt; に対して正しくブロードキャストされます。</target>
        </trans-unit>
        <trans-unit id="b2006dd9c76a3ff3a106ec273dd3c8e1e765c752" translate="yes" xml:space="preserve">
          <source>If True, the conflicting values are appended to the error message.</source>
          <target state="translated">True の場合、矛盾する値がエラーメッセージに追加されます。</target>
        </trans-unit>
        <trans-unit id="d8ba5d3712bb2ee2efcfc81e8a867c710618acda" translate="yes" xml:space="preserve">
          <source>If True, the indices which correspond to the intersection of the two arrays are returned. The first instance of a value is used if there are multiple. Default is False.</source>
          <target state="translated">True の場合、2 つの配列の交点に対応するインデックスが返されます。値が複数ある場合は、最初のインスタンスが使用されます。デフォルトは False です。</target>
        </trans-unit>
        <trans-unit id="796c55d79196f76e9a5e82ed451d32129c18b457" translate="yes" xml:space="preserve">
          <source>If True, the input arrays are both assumed to be unique, which can speed up the calculation. Default is False.</source>
          <target state="translated">True の場合,入力配列は両方とも一意であると仮定され,計算を高速化することができます.デフォルトは False です。</target>
        </trans-unit>
        <trans-unit id="262ad12226b8d86b75ded0db8c7b0c32d50e89e8" translate="yes" xml:space="preserve">
          <source>If True, the input arrays are both assumed to be unique, which can speed up the calculation. If True but &lt;code&gt;ar1&lt;/code&gt; or &lt;code&gt;ar2&lt;/code&gt; are not unique, incorrect results and out-of-bounds indices could result. Default is False.</source>
          <target state="translated">Trueの場合、入力配列は両方とも一意であると見なされ、計算を高速化できます。Trueであるが、 &lt;code&gt;ar1&lt;/code&gt; または &lt;code&gt;ar2&lt;/code&gt; が一意でない場合、誤った結果と範囲外のインデックスが発生する可能性があります。デフォルトはFalseです。</target>
        </trans-unit>
        <trans-unit id="4faadc5e6554004b31ce5928d5d80bd241c02388" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with either the &lt;code&gt;c_index&lt;/code&gt; or the &lt;code&gt;f_index&lt;/code&gt; flag, and the property &lt;a href=&quot;numpy.nditer.index#numpy.nditer.index&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; can be used to retrieve it.</source>
          <target state="translated">Trueの場合、イテレータは &lt;code&gt;c_index&lt;/code&gt; または &lt;code&gt;f_index&lt;/code&gt; フラグのいずれかで作成され、プロパティ&lt;a href=&quot;numpy.nditer.index#numpy.nditer.index&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt;を使用してそれを取得できます。</target>
        </trans-unit>
        <trans-unit id="78e99fe24c914b8497fc3d013aec906afbe03579" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with the &lt;code&gt;delay_bufalloc&lt;/code&gt; flag, and no reset() function was called on it yet.</source>
          <target state="translated">Trueの場合、イテレータは &lt;code&gt;delay_bufalloc&lt;/code&gt; フラグを使用して作成され、reset（）関数はまだ呼び出されていません。</target>
        </trans-unit>
        <trans-unit id="78a4539bda923dafd78fad0e5fb97c6b43556f2b" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with the &lt;code&gt;multi_index&lt;/code&gt; flag, and the property &lt;a href=&quot;numpy.nditer.multi_index#numpy.nditer.multi_index&quot;&gt;&lt;code&gt;multi_index&lt;/code&gt;&lt;/a&gt; can be used to retrieve it.</source>
          <target state="translated">Trueの場合、イテレータは &lt;code&gt;multi_index&lt;/code&gt; フラグを使用して作成され、プロパティ&lt;a href=&quot;numpy.nditer.multi_index#numpy.nditer.multi_index&quot;&gt; &lt;code&gt;multi_index&lt;/code&gt; &lt;/a&gt;を使用して取得できます。</target>
        </trans-unit>
        <trans-unit id="cd78b05e62a74691621672060edfaaaf7c932b8a" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = genfromtxt(...)&lt;/code&gt;. When used with a structured data-type, arrays are returned for each field. Default is False.</source>
          <target state="translated">Trueの場合、返される配列は転置されるため、 &lt;code&gt;x, y, z = genfromtxt(...)&lt;/code&gt; を使用して引数を解凍できます。構造化データ型で使用すると、フィールドごとに配列が返されます。デフォルトはFalseです。</target>
        </trans-unit>
        <trans-unit id="f4229174699f5726402f68c65f4921612f023a93" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;</source>
          <target state="translated">Trueの場合、返される配列は転置されるため、 &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt; を使用して引数をアンパックできます</target>
        </trans-unit>
        <trans-unit id="b9bf7edcd483311b9596b9cc1a4efa43974ee453" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;. When used with a structured data-type, arrays are returned for each field. Default is False.</source>
          <target state="translated">Trueの場合、返される配列は転置されるため、引数は &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt; を使用して解凍できます。構造化データタイプで使用すると、各フィールドの配列が返されます。デフォルトはFalseです。</target>
        </trans-unit>
        <trans-unit id="d43fcdb1c52440e31bff4cb2f390cb23f384392a" translate="yes" xml:space="preserve">
          <source>If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of &lt;code&gt;x&lt;/code&gt;. Scalars have dimension 0 for this action. The result is that every column of coefficients in &lt;code&gt;c&lt;/code&gt; is evaluated for every element of &lt;code&gt;x&lt;/code&gt;. If False, &lt;code&gt;x&lt;/code&gt; is broadcast over the columns of &lt;code&gt;c&lt;/code&gt; for the evaluation. This keyword is useful when &lt;code&gt;c&lt;/code&gt; is multidimensional. The default value is True.</source>
          <target state="translated">Trueの場合、係数配列の形状は、 &lt;code&gt;x&lt;/code&gt; の各次元に対して1つずつ、右側に拡張されます。このアクションでは、スカラーの次元は0です。その結果、 &lt;code&gt;c&lt;/code&gt; のすべての係数列が &lt;code&gt;x&lt;/code&gt; のすべての要素に対して評価されます。 Falseの場合、 &lt;code&gt;x&lt;/code&gt; は評価のために &lt;code&gt;c&lt;/code&gt; の列でブロードキャストされます。このキーワードは、 &lt;code&gt;c&lt;/code&gt; が多次元の場合に役立ちます。デフォルト値はTrueです。</target>
        </trans-unit>
        <trans-unit id="959391ebb6591b28733d37c72b179dc2ae1393e8" translate="yes" xml:space="preserve">
          <source>If True, the shape of the roots array is extended with ones on the right, one for each dimension of &lt;code&gt;x&lt;/code&gt;. Scalars have dimension 0 for this action. The result is that every column of coefficients in &lt;code&gt;r&lt;/code&gt; is evaluated for every element of &lt;code&gt;x&lt;/code&gt;. If False, &lt;code&gt;x&lt;/code&gt; is broadcast over the columns of &lt;code&gt;r&lt;/code&gt; for the evaluation. This keyword is useful when &lt;code&gt;r&lt;/code&gt; is multidimensional. The default value is True.</source>
          <target state="translated">Trueの場合、roots配列の形状は、 &lt;code&gt;x&lt;/code&gt; の各次元に1つずつ、右側に1つずつ拡張されます。このアクションでは、スカラーの次元は0です。結果は、 &lt;code&gt;r&lt;/code&gt; の係数のすべての列が &lt;code&gt;x&lt;/code&gt; のすべての要素に対して評価されるということです。Falseの場合、 &lt;code&gt;x&lt;/code&gt; は評価のために &lt;code&gt;r&lt;/code&gt; の列でブロードキャストされます。このキーワードは、 &lt;code&gt;r&lt;/code&gt; が多次元の場合に役立ちます。デフォルト値はTrueです。</target>
        </trans-unit>
        <trans-unit id="6f56bb6f69c7a79b2fcb0eba261866b1784e5a91" translate="yes" xml:space="preserve">
          <source>If True, the spaces at the end of Strings are removed before the comparison.</source>
          <target state="translated">Trueの場合、比較の前に文字列の末尾のスペースが削除されます。</target>
        </trans-unit>
        <trans-unit id="201e227337fd7a8180e5a7ed35ba4fd5fc02b88e" translate="yes" xml:space="preserve">
          <source>If True, the values in the returned array are inverted (that is, False where an element of &lt;code&gt;ar1&lt;/code&gt; is in &lt;code&gt;ar2&lt;/code&gt; and True otherwise). Default is False. &lt;code&gt;np.in1d(a, b, invert=True)&lt;/code&gt; is equivalent to (but is faster than) &lt;code&gt;np.invert(in1d(a, b))&lt;/code&gt;.</source>
          <target state="translated">Trueの場合、返される配列の値は反転されます（つまり、 &lt;code&gt;ar1&lt;/code&gt; の要素が &lt;code&gt;ar2&lt;/code&gt; にある場合はFalse、それ以外の場合はTrue）。デフォルトはFalseです。 &lt;code&gt;np.in1d(a, b, invert=True)&lt;/code&gt; は、np.invert（in1d（a、b））と同等です（ただし高速です &lt;code&gt;np.invert(in1d(a, b))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="259b3152dca6c438bfe50af972160ce0a4a1de26" translate="yes" xml:space="preserve">
          <source>If True, the values in the returned array are inverted, as if calculating &lt;code&gt;element not in test_elements&lt;/code&gt;. Default is False. &lt;code&gt;np.isin(a, b, invert=True)&lt;/code&gt; is equivalent to (but faster than) &lt;code&gt;np.invert(np.isin(a, b))&lt;/code&gt;.</source>
          <target state="translated">Trueの場合 &lt;code&gt;element not in test_elements&lt;/code&gt; 計算要素のように、返された配列の値が反転されます。デフォルトはFalseです。 &lt;code&gt;np.isin(a, b, invert=True)&lt;/code&gt; は、np.invert（np.isin（a、b））と同等です（ただし高速です &lt;code&gt;np.invert(np.isin(a, b))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="945e8f6a0cee215b87f641fdb7d3287ee26a3bd1" translate="yes" xml:space="preserve">
          <source>If True, then allow the input array &lt;code&gt;a&lt;/code&gt; to be modified by intermediate calculations, to save memory. In this case, the contents of the input &lt;code&gt;a&lt;/code&gt; after this function completes is undefined.</source>
          <target state="translated">Trueの場合、メモリを節約するために、入力配列 &lt;code&gt;a&lt;/code&gt; が中間計算によって変更されることを許可します。この場合、この関数が完了し &lt;code&gt;a&lt;/code&gt; 後の入力aの内容は未定義です。</target>
        </trans-unit>
        <trans-unit id="3dbfbe1abf097059eac31485586e156e13dcab2c" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array (a) for calculations. The input array will be modified by the call to median. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. Note that, if &lt;code&gt;overwrite_input&lt;/code&gt; is True, and the input is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">Trueの場合、計算に入力配列（a）のメモリの使用を許可します。入力配列は、medianの呼び出しによって変更されます。これにより、入力配列の内容を保持する必要がない場合にメモリを節約できます。入力を未定義として扱いますが、おそらく完全にまたは部分的にソートされます。デフォルトはFalseです。場合は、その注意 &lt;code&gt;overwrite_input&lt;/code&gt; がTrueで、かつ入力がまだない&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="efffbf4abfcfd3dab70b2b5adf8fd6ea45c7060a" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array (a) for calculations. The input array will be modified by the call to median. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. Note that, if &lt;code&gt;overwrite_input&lt;/code&gt; is True, and the input is not already an &lt;code&gt;ndarray&lt;/code&gt;, an error will be raised.</source>
          <target state="translated">Trueの場合、計算に入力配列（a）のメモリの使用を許可します。入力配列は、中央値の呼び出しによって変更されます。これにより、入力配列の内容を保持する必要がない場合にメモリを節約できます。入力を未定義として扱いますが、おそらく完全にまたは部分的にソートされます。デフォルトはFalseです。 &lt;code&gt;overwrite_input&lt;/code&gt; がTrueで、入力がまだ &lt;code&gt;ndarray&lt;/code&gt; でない場合、エラーが発生することに注意してください。</target>
        </trans-unit>
        <trans-unit id="453475060bdf9f6ca07ca2a9d367c0c72b7c7341" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array &lt;code&gt;a&lt;/code&gt; for calculations. The input array will be modified by the call to &lt;a href=&quot;#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If &lt;code&gt;overwrite_input&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">Trueの場合、計算 &lt;code&gt;a&lt;/code&gt; ために入力配列aのメモリの使用を許可します。入力配列は、&lt;a href=&quot;#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt;の呼び出しによって変更されます。これにより、入力配列の内容を保持する必要がない場合にメモリを節約できます。入力を未定義として扱いますが、おそらく完全にまたは部分的にソートされます。デフォルトはFalseです。場合 &lt;code&gt;overwrite_input&lt;/code&gt; がある &lt;code&gt;True&lt;/code&gt; となっていない&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;、エラーが発生します。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf48ed6030d0efc488f7b3086097c6ad325b803d" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array &lt;code&gt;a&lt;/code&gt; for calculations. The input array will be modified by the call to &lt;a href=&quot;numpy.median#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If &lt;code&gt;overwrite_input&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">Trueの場合、計算 &lt;code&gt;a&lt;/code&gt; ために入力配列aのメモリの使用を許可します。入力配列は、&lt;a href=&quot;numpy.median#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt;の呼び出しによって変更されます。これにより、入力配列の内容を保持する必要がない場合にメモリを節約できます。入力を未定義として扱いますが、おそらく完全にまたは部分的にソートされます。デフォルトはFalseです。場合 &lt;code&gt;overwrite_input&lt;/code&gt; がある &lt;code&gt;True&lt;/code&gt; となっていない&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;、エラーが発生します。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="727bb21e15aa63ae35b6dc8fc80a632c45207cf3" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array.</source>
          <target state="translated">True の場合は、サブクラスが渡されます (デフォルト)。そうでない場合は、返される配列は強制的にベースクラスの配列となります。</target>
        </trans-unit>
        <trans-unit id="4ceb06545ceed82d0fd2c4e74fddc1a8387d729b" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (default).</source>
          <target state="translated">True の場合はサブクラスが渡され、そうでなければ返される配列は強制的にベースクラスの配列になります (デフォルト)。</target>
        </trans-unit>
        <trans-unit id="7931866e33bf18d405c7c9da5047f41db3dc88c3" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (defaults to False).</source>
          <target state="translated">True の場合はサブクラスが渡され、そうでなければ返される配列は強制的にベースクラスの配列になります (デフォルトは False)。</target>
        </trans-unit>
        <trans-unit id="9752fe228ae3462d649576fdb0cd4757647ae348" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned arrays will be forced to be a base-class array (default).</source>
          <target state="translated">True の場合、サブクラスが渡されます。そうでない場合は、返される配列は強制的にベースクラスの配列になります (デフォルト)。</target>
        </trans-unit>
        <trans-unit id="066838f1ffe5aa12c7d71f9b1de32afdb88ee10e" translate="yes" xml:space="preserve">
          <source>If True, then the newly created array will use the sub-class type of &amp;lsquo;a&amp;rsquo;, otherwise it will be a base-class array. Defaults to True.</source>
          <target state="translated">Trueの場合、新しく作成された配列はサブクラスタイプの「a」を使用します。それ以外の場合は、基本クラスの配列になります。デフォルトはTrueです。</target>
        </trans-unit>
        <trans-unit id="637f994c43dad54f98722e59d623faad4b72d12f" translate="yes" xml:space="preserve">
          <source>If True, then the newly created array will use the sub-class type of &lt;code&gt;a&lt;/code&gt;, otherwise it will be a base-class array. Defaults to True.</source>
          <target state="translated">Trueの場合、新しく作成された配列は、のサブクラス型を使用します、それ以外の場合は、ベースクラスの配列になります。デフォルトはTrueです。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2dc991539e6e09a358dd637bc4a93159f28455ae" translate="yes" xml:space="preserve">
          <source>If True, then the newly created array will use the sub-class type of &lt;code&gt;prototype&lt;/code&gt;, otherwise it will be a base-class array. Defaults to True.</source>
          <target state="translated">Trueの場合、新しく作成された配列はサブクラスタイプの &lt;code&gt;prototype&lt;/code&gt; を使用します。それ以外の場合は、基本クラスの配列になります。デフォルトはTrueです。</target>
        </trans-unit>
        <trans-unit id="9ba9655ceab858d8e0fbfbe35222ace33db08fb2" translate="yes" xml:space="preserve">
          <source>If [array, array], the bin edges in each dimension (x_edges, y_edges = bins).</source>
          <target state="translated">array,array]の場合、各次元のbinエッジ(x_edges,y_edges=bins)。</target>
        </trans-unit>
        <trans-unit id="74d7f2b29106e8ca088ed3ddc192d60c869742ea" translate="yes" xml:space="preserve">
          <source>If [int, int], the number of bins in each dimension (nx, ny = bins).</source>
          <target state="translated">int,int]の場合、各次元のビン数(nx,ny=ビン数)。</target>
        </trans-unit>
        <trans-unit id="63952cde8568ab7ec41b2ac80ecf7fdc353a6855" translate="yes" xml:space="preserve">
          <source>If __svn_version__.py existed before, nothing is done.</source>
          <target state="translated">以前に __svn_version__.py が存在していた場合は何もしません。</target>
        </trans-unit>
        <trans-unit id="2973727add43998ece2695a952786574b37deff8" translate="yes" xml:space="preserve">
          <source>If a &amp;lt; 1.</source>
          <target state="translated">a &amp;lt;1の場合</target>
        </trans-unit>
        <trans-unit id="d6288450796b9bb41fb24a4a3b5f478c44715bdc" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;python module&lt;/code&gt; block contains two or more &lt;code&gt;common&lt;/code&gt; blocks with the same name, the variables from the additional declarations are appended. The types of variables in &lt;code&gt;&amp;lt;shortentitydecl&amp;gt;&lt;/code&gt; are defined using &lt;code&gt;&amp;lt;argument type declarations&amp;gt;&lt;/code&gt;. Note that the corresponding &lt;code&gt;&amp;lt;argument type declarations&amp;gt;&lt;/code&gt; may contain array specifications; then you don&amp;rsquo;t need to specify these in &lt;code&gt;&amp;lt;shortentitydecl&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;python module&lt;/code&gt; ブロックに同じ名前の2つ以上の &lt;code&gt;common&lt;/code&gt; ブロックが含まれている場合、追加の宣言の変数が追加されます。 &lt;code&gt;&amp;lt;shortentitydecl&amp;gt;&lt;/code&gt; の変数の型は、 &lt;code&gt;&amp;lt;argument type declarations&amp;gt;&lt;/code&gt; を使用して定義されます。対応する &lt;code&gt;&amp;lt;argument type declarations&amp;gt;&lt;/code&gt; は配列仕様が含まれる場合があることに注意してください。その場合、 &lt;code&gt;&amp;lt;shortentitydecl&amp;gt;&lt;/code&gt; でこれらを指定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="949f92ee120b49054523e5f48bcc0be73d87cf4a" translate="yes" xml:space="preserve">
          <source>If a Council member becomes inactive in the project for a period of one year, they will be considered for removal from the Council. Before removal, inactive Member will be approached to see if they plan on returning to active participation. If not they will be removed immediately upon a Council vote. If they plan on returning to active participation soon, they will be given a grace period of one year. If they don&amp;rsquo;t return to active participation within that time period they will be removed by vote of the Council without further grace period. All former Council members can be considered for membership again at any time in the future, like any other Project Contributor. Retired Council members will be listed on the project website, acknowledging the period during which they were active in the Council.</source>
          <target state="translated">カウンシルメンバーがプロジェクトで1年間非アクティブになった場合、カウンシルからの削除が検討されます。削除される前に、非アクティブなメンバーは、アクティブな参加に戻る予定があるかどうかを確認するためにアプローチされます。そうでない場合は、評議会の投票により直ちに削除されます。すぐに積極的な参加に戻る予定の場合は、1年間の猶予期間が与えられます。その期間内に積極的な参加に戻らなかった場合、それ以上の猶予期間なしに評議会の投票によって削除されます。元カウンシルメンバーはすべて、他のプロジェクトコントリビューターと同様に、将来いつでも再びメンバーになることを検討できます。退任した評議会のメンバーは、彼らが評議会で活動していた期間を認めて、プロジェクトのウェブサイトに掲載されます。</target>
        </trans-unit>
        <trans-unit id="0f5ac51d599581ab3e8a496c55fdc29ce07640e8" translate="yes" xml:space="preserve">
          <source>If a F2PY generated wrapper function expects the following call-back argument:</source>
          <target state="translated">F2PYで生成されたラッパー関数が以下のコールバック引数を期待している場合。</target>
        </trans-unit>
        <trans-unit id="736cfd31de35553aafebed98e2d227e880ff08c4" translate="yes" xml:space="preserve">
          <source>If a byteorder of &lt;a href=&quot;#c.NPY_IGNORE&quot;&gt;&lt;code&gt;NPY_IGNORE&lt;/code&gt;&lt;/a&gt; is encountered it is left alone. If newendian is &lt;a href=&quot;#c.NPY_SWAP&quot;&gt;&lt;code&gt;NPY_SWAP&lt;/code&gt;&lt;/a&gt;, then all byte-orders are swapped. Other valid newendian values are &lt;a href=&quot;#c.NPY_NATIVE&quot;&gt;&lt;code&gt;NPY_NATIVE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_LITTLE&quot;&gt;&lt;code&gt;NPY_LITTLE&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_BIG&quot;&gt;&lt;code&gt;NPY_BIG&lt;/code&gt;&lt;/a&gt; which all cause the returned data-typed descriptor (and all it&amp;rsquo;s referenced data-type descriptors) to have the corresponding byte- order.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_IGNORE&quot;&gt; &lt;code&gt;NPY_IGNORE&lt;/code&gt; のバイトオーダー&lt;/a&gt;が検出された場合、それはそのままになります。newendianが&lt;a href=&quot;#c.NPY_SWAP&quot;&gt; &lt;code&gt;NPY_SWAP&lt;/code&gt; の&lt;/a&gt;場合、すべてのバイト順序がスワップされます。その他の有効なニューエンディアン値は、&lt;a href=&quot;#c.NPY_NATIVE&quot;&gt; &lt;code&gt;NPY_NATIVE&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#c.NPY_LITTLE&quot;&gt; &lt;code&gt;NPY_LITTLE&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#c.NPY_BIG&quot;&gt; &lt;code&gt;NPY_BIG&lt;/code&gt; です。&lt;/a&gt;これらはすべて、返されるデータ型記述子（およびそれが参照するすべてのデータ型記述子）に対応するバイト順序を持たせます。</target>
        </trans-unit>
        <trans-unit id="ea1873bd2a58371aec0e3e9712cc84313c25ffe3" translate="yes" xml:space="preserve">
          <source>If a class (ndarray subclass or not) having the &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method is used as the output object of an &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, results will &lt;em&gt;not&lt;/em&gt; be written to the object returned by &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt;. This practice will return &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;メソッドを持つクラス（ndarrayサブクラスかどうか）がufuncの出力オブジェクトとして使用される&lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;場合&lt;/a&gt;、結果は&lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;によって返されるオブジェクトに書き込まれ&lt;em&gt;ません&lt;/em&gt;。この方法では、 &lt;code&gt;TypeError&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="c5279f6f16ca5cb6814a2ac00854340dc9cd2fbb" translate="yes" xml:space="preserve">
          <source>If a class (ndarray subclass or not) having the &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method is used as the output object of an &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, results will be written to the object returned by &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt;. Similar conversion is done on input arrays.</source>
          <target state="translated">&lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;メソッドを持つクラス（ndarrayサブクラスかどうか）がufuncの出力オブジェクトとして使用される&lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;場合&lt;/a&gt;、結果は&lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;によって返されたオブジェクトに書き込まれます。入力配列でも同様の変換が行われます。</target>
        </trans-unit>
        <trans-unit id="874568bcf37ebe0e2a8a8d54069b92c02f85f23a" translate="yes" xml:space="preserve">
          <source>If a class defines the &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, this disables the &lt;a href=&quot;#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; mechanism described below for ufuncs (which may eventually be deprecated).</source>
          <target state="translated">クラスが&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;メソッドを定義している場合、これは&lt;a href=&quot;#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;について以下で説明する__array_wrap &lt;a href=&quot;#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt;、__array_priority__メカニズムを無効にします（最終的には非推奨になる可能性があります）。</target>
        </trans-unit>
        <trans-unit id="0577aaede06ac434e631d772788e0f369a956f02" translate="yes" xml:space="preserve">
          <source>If a compile-time fixed buffer is being used (both flags &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;), the inner size may be used as a signal as well. The size is guaranteed to become zero when &lt;code&gt;iternext()&lt;/code&gt; returns false, enabling the following loop construct. Note that if you use this construct, you should not pass &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt; as a flag, because it will cause larger sizes under some circumstances.</source>
          <target state="translated">コンパイル時の固定バッファーが使用されている場合（フラグ&lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; の&lt;/a&gt;両方）、内部サイズも信号として使用できます。 &lt;code&gt;iternext()&lt;/code&gt; がfalseを返すとサイズがゼロになることが保証され、次のループ構造が有効になります。この構成を使用する場合、状況によってはサイズが大きくなるため、フラグとして&lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt;を渡さないでください。</target>
        </trans-unit>
        <trans-unit id="9d666b71ab2db0f6cb052dc4a309c02e840cf132" translate="yes" xml:space="preserve">
          <source>If a dimension is given as -1 in a reshaping operation, the other dimensions are automatically calculated:</source>
          <target state="translated">リシェーピング操作で寸法が-1として与えられると、他の寸法が自動的に計算されます。</target>
        </trans-unit>
        <trans-unit id="769025cc778c9102b36d6a70ef7aed0a8fe51c05" translate="yes" xml:space="preserve">
          <source>If a field name in the required_dtype does not exist in the input array, that field is created and set to 0 in the output array.</source>
          <target state="translated">required_dtypeのフィールド名が入力配列に存在しない場合、そのフィールドが作成され、出力配列に0が設定されます。</target>
        </trans-unit>
        <trans-unit id="4a3ce99d9611a27292277b44f279f72466bca938" translate="yes" xml:space="preserve">
          <source>If a field whose dtype object has this attribute is retrieved, then the extra dimensions implied by &lt;em&gt;shape&lt;/em&gt; are tacked on to the end of the retrieved array.</source>
          <target state="translated">dtypeオブジェクトがこの属性を持つフィールドが取得されると、取得された配列の最後に、&lt;em&gt;形状&lt;/em&gt;によって暗示される追加の次元が追加されます。</target>
        </trans-unit>
        <trans-unit id="aa639d13854427042e288c4d7a227d11cd8e9453" translate="yes" xml:space="preserve">
          <source>If a file &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; does not exist, the &lt;code&gt;include&lt;/code&gt; statement is ignored. Otherwise, the file &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; is included to a signature file. &lt;code&gt;include&lt;/code&gt; statements can be used in any part of a signature file, also outside the Fortran/C routine signature blocks.</source>
          <target state="translated">ファイル &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; が存在しない場合、 &lt;code&gt;include&lt;/code&gt; ステートメントは無視されます。それ以外の場合、ファイル &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; は署名ファイルに含まれます。 &lt;code&gt;include&lt;/code&gt; ステートメントは、Fortran / Cルーチンの署名ブロックの外部でも、署名ファイルの任意の部分で使用できます。</target>
        </trans-unit>
        <trans-unit id="24439780a6864c35956999c18798d43f08d60388" translate="yes" xml:space="preserve">
          <source>If a formatter is specified for a certain type, the &lt;code&gt;precision&lt;/code&gt; keyword is ignored for that type.</source>
          <target state="translated">特定のタイプにフォーマッターが指定されている場合、そのタイプの &lt;code&gt;precision&lt;/code&gt; キーワードは無視されます。</target>
        </trans-unit>
        <trans-unit id="687f359e5176c0f016578fb6a4154929ee305cd5" translate="yes" xml:space="preserve">
          <source>If a given array does not satisfy the specified restrictions.</source>
          <target state="translated">与えられた配列が指定された制限を満たさない場合。</target>
        </trans-unit>
        <trans-unit id="516fd825a9c72297363bd8dd8c84b3bb2fcfe3f7" translate="yes" xml:space="preserve">
          <source>If a how-to has many steps:</source>
          <target state="translated">ハウツーには多くのステップがあります。</target>
        </trans-unit>
        <trans-unit id="0f9748bf845ac9d150692dd01c4e3cac7093889e" translate="yes" xml:space="preserve">
          <source>If a is a matrix object, then the return value is a matrix as well:</source>
          <target state="translated">a が行列オブジェクトである場合、戻り値も同様に行列となります。</target>
        </trans-unit>
        <trans-unit id="8ca1d1baf4aebfbd38dd688686cce7228cb6bc88" translate="yes" xml:space="preserve">
          <source>If a is an int and less than zero, if a or p are not 1-dimensional, if a is an array-like of size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size</source>
          <target state="translated">a が int で 0 より小さい場合,a または p が 1 次元ではない場合,a がサイズ 0 の配列様である場合,p が確率のベクトルではない場合,a と p の長さが異なる場合,または replace=False でサンプルサイズが母集団のサイズより大きい場合</target>
        </trans-unit>
        <trans-unit id="45d749c722fde2f54ef7349c75a2d911b0caf469" translate="yes" xml:space="preserve">
          <source>If a is an int and less than zero, if p is not 1-dimensional, if a is array-like with a size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size.</source>
          <target state="translated">aがintで0より小さい場合,pが1次元ではない場合,aがサイズ0の配列状の場合,pが確率のベクトルではない場合,aとpの長さが異なる場合,replace=Falseでサンプルサイズが母集団サイズより大きい場合などです.</target>
        </trans-unit>
        <trans-unit id="6a821a28e324f16f0f4bf4708058f9a3d079d082" translate="yes" xml:space="preserve">
          <source>If a list of strings, each string should represent a dtype. If array_like, the character representation of the array dtype is used.</source>
          <target state="translated">文字列のリストの場合は、各文字列がdtypeを表す必要があります。array_likeの場合は、配列のdtypeの文字表現が使用されます。</target>
        </trans-unit>
        <trans-unit id="f0978a6e619ec2d43693907e27d2eb435814d97e" translate="yes" xml:space="preserve">
          <source>If a report doesn&amp;rsquo;t contain enough information, the committee will obtain all relevant data before acting. The committee is empowered to act on the Steering Council&amp;rsquo;s behalf in contacting any individuals involved to get a more complete account of events.</source>
          <target state="translated">レポートに十分な情報が含まれていない場合、委員会は行動する前にすべての関連データを取得します。委員会は、イベントのより完全な説明を得るために関係する個人に連絡する際に運営評議会に代わって行動する権限を与えられています。</target>
        </trans-unit>
        <trans-unit id="63795a6ab48fcba94623b51f8a7753fc963d4b8e" translate="yes" xml:space="preserve">
          <source>If a scalar dtype, the corresponding string character is returned. If an object, &lt;a href=&quot;#numpy.sctype2char&quot;&gt;&lt;code&gt;sctype2char&lt;/code&gt;&lt;/a&gt; tries to infer its scalar type and then return the corresponding string character.</source>
          <target state="translated">スカラーdtypeの場合、対応する文字列文字が返されます。オブジェクトの場合、&lt;a href=&quot;#numpy.sctype2char&quot;&gt; &lt;code&gt;sctype2char&lt;/code&gt; &lt;/a&gt;はそのスカラー型を推測し、対応する文字列文字を返します。</target>
        </trans-unit>
        <trans-unit id="98a2233adc7ab93848107f159b490659bfa27e57" translate="yes" xml:space="preserve">
          <source>If a scalar value is passed in.</source>
          <target state="translated">スカラー値が渡された場合</target>
        </trans-unit>
        <trans-unit id="15bc103dab402117d3913395fb8b40bbeeb0b897" translate="yes" xml:space="preserve">
          <source>If a second argument is supplied the result is stored there. If the type of that array is a numeric type the result is represented as zeros and ones, if the type is boolean then as False and True. The return value &lt;code&gt;out&lt;/code&gt; is then a reference to that array.</source>
          <target state="translated">2番目の引数が指定された場合、結果はそこに格納されます。その配列のタイプが数値タイプの場合、結果はゼロと1として表され、タイプがブールの場合、FalseおよびTrueとして表されます。次に、戻り値 &lt;code&gt;out&lt;/code&gt; はその配列への参照です。</target>
        </trans-unit>
        <trans-unit id="342304e655e812ee2a83e5789793e22172924b42" translate="yes" xml:space="preserve">
          <source>If a second argument is supplied the result is stored there. The return value &lt;code&gt;out&lt;/code&gt; is then a reference to that array.</source>
          <target state="translated">2番目の引数が指定された場合、結果はそこに格納されます。その場合、戻り値 &lt;code&gt;out&lt;/code&gt; はその配列への参照になります。</target>
        </trans-unit>
        <trans-unit id="ceb1ddfcab0f3cbec5d42431c301b1cc28fccf65" translate="yes" xml:space="preserve">
          <source>If a zero dimensional array is present in the index &lt;em&gt;and&lt;/em&gt; it is a full integer index the result will be a &lt;em&gt;scalar&lt;/em&gt; and not a zero dimensional array. (Advanced indexing is not triggered.)</source>
          <target state="translated">インデックスにゼロ次元配列が&lt;em&gt;あり、&lt;/em&gt;それが完全な整数インデックスである場合、結果は&lt;em&gt;スカラー&lt;/em&gt;であり、ゼロ次元配列ではありません。（高度なインデックス作成はトリガーされません。）</target>
        </trans-unit>
        <trans-unit id="64c5c963ea9794eafa3b89f1dd216c6a8ebfd684" translate="yes" xml:space="preserve">
          <source>If actual and desired are not equal up to specified precision.</source>
          <target state="translated">指定された精度までは、実際と希望が一致しない場合。</target>
        </trans-unit>
        <trans-unit id="39bbb6143ab84f37b65c3d7880c2778b652d186d" translate="yes" xml:space="preserve">
          <source>If actual and desired are not equal.</source>
          <target state="translated">実際と希望が一致しない場合</target>
        </trans-unit>
        <trans-unit id="fcebdf6acdb7662938a429c761fa5ad9e5471b67" translate="yes" xml:space="preserve">
          <source>If actual and desired objects are not equal.</source>
          <target state="translated">実物と希望する物が一致しない場合</target>
        </trans-unit>
        <trans-unit id="8aa394119b239dde7365c85e156833625438bfa9" translate="yes" xml:space="preserve">
          <source>If all &lt;code&gt;__array_function__&lt;/code&gt; methods return &lt;code&gt;NotImplemented&lt;/code&gt;, NumPy will raise &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">すべての &lt;code&gt;__array_function__&lt;/code&gt; メソッドがNotImplementedを返す &lt;code&gt;NotImplemented&lt;/code&gt; 、NumPyは &lt;code&gt;TypeError&lt;/code&gt; を発生させます。</target>
        </trans-unit>
        <trans-unit id="454ac4064cbf860208005757a60b81b3482b89cb" translate="yes" xml:space="preserve">
          <source>If all of the commits are related, create a merge commit:</source>
          <target state="translated">すべてのコミットが関連している場合は、マージコミットを作成します。</target>
        </trans-unit>
        <trans-unit id="85985aaa1b2d2d353f8a23ec019a6f4085543d14" translate="yes" xml:space="preserve">
          <source>If all proposals for resolving some issue are vetoed, then the status quo wins by default.</source>
          <target state="translated">何かの問題を解決するための提案がすべて拒否権を持っている場合は、ステータスクオがデフォルトで勝つことになります。</target>
        </trans-unit>
        <trans-unit id="eab8ea3dfbb5bbbb71e7908ef2deef22ffee42c7" translate="yes" xml:space="preserve">
          <source>If all the arrays are 1-D, &lt;a href=&quot;#numpy.where&quot;&gt;&lt;code&gt;where&lt;/code&gt;&lt;/a&gt; is equivalent to:</source>
          <target state="translated">すべての配列が1次元の場合&lt;a href=&quot;#numpy.where&quot;&gt; &lt;code&gt;where&lt;/code&gt; &lt;/a&gt;は次と同等です。</target>
        </trans-unit>
        <trans-unit id="4680fc5e031229cdb3ef2e322dccd91736ba09de" translate="yes" xml:space="preserve">
          <source>If all values are masked, return None. Otherwise, return a list of two tuples, corresponding to the indices of the first and last unmasked values respectively.</source>
          <target state="translated">すべての値がマスクされている場合は None を返します。そうでない場合は、マスクされていない最初と最後の値のインデックスにそれぞれ対応する2つのタプルのリストを返します。</target>
        </trans-unit>
        <trans-unit id="517ad1e00b3a93fbecfebfae5c6590d4c6fe64a9" translate="yes" xml:space="preserve">
          <source>If an argument has no &lt;code&gt;&amp;lt;argument type declaration&amp;gt;&lt;/code&gt;, its type is determined by applying &lt;code&gt;implicit&lt;/code&gt; rules to its name.</source>
          <target state="translated">引数に &lt;code&gt;&amp;lt;argument type declaration&amp;gt;&lt;/code&gt; がない場合、その型はその名前に &lt;code&gt;implicit&lt;/code&gt; ルールを適用することによって決定されます。</target>
        </trans-unit>
        <trans-unit id="2edcb18bec5f7aa2d4bb57f912992d616edce150" translate="yes" xml:space="preserve">
          <source>If an array does not own its memory, then its &lt;a href=&quot;reference/generated/numpy.ndarray.base&quot;&gt;base&lt;/a&gt; attribute returns the object whose memory the array is referencing. That object may be referencing the memory from still another object, so the owning object may be &lt;code&gt;a.base.base.base...&lt;/code&gt;. Some writers erroneously claim that testing &lt;code&gt;base&lt;/code&gt; determines if arrays are &lt;a href=&quot;#term-view&quot;&gt;view&lt;/a&gt;s. For the correct way, see &lt;a href=&quot;reference/generated/numpy.shares_memory#numpy.shares_memory&quot;&gt;&lt;code&gt;numpy.shares_memory&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">配列がそのメモリを所有していない場合、その&lt;a href=&quot;reference/generated/numpy.ndarray.base&quot;&gt;base&lt;/a&gt;属性は、配列が参照しているメモリを持つオブジェクトを返します。そのオブジェクトはさらに別のオブジェクトからメモリを参照している可能性があるため、所有しているオブジェクトは &lt;code&gt;a.base.base.base...&lt;/code&gt; 可能性があります。一部のライターは、テスト &lt;code&gt;base&lt;/code&gt; が配列が&lt;a href=&quot;#term-view&quot;&gt;ビューである&lt;/a&gt;かどうかを決定すると誤って主張しています。正しい方法については、&lt;a href=&quot;reference/generated/numpy.shares_memory#numpy.shares_memory&quot;&gt; &lt;code&gt;numpy.shares_memory&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6a0b2100814d2bab89059c0f2bc3adff904ee9a6" translate="yes" xml:space="preserve">
          <source>If an array has a very small or very large determinant, then a call to &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt; may overflow or underflow. This routine is more robust against such issues, because it computes the logarithm of the determinant rather than the determinant itself.</source>
          <target state="translated">配列の行列式が非常に小さいか非常に大きい場合、&lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; の&lt;/a&gt;呼び出しがオーバーフローまたはアンダーフローする可能性があります。このルーチンは、行列式自体ではなく行列式の対数を計算するため、このような問題に対してより堅牢です。</target>
        </trans-unit>
        <trans-unit id="089dc283ee6bf525b9e1357cb2890636154add48" translate="yes" xml:space="preserve">
          <source>If an array has no elements (&lt;code&gt;self.size == 0&lt;/code&gt;) there is no legal index and the strides are never used. Any array with no elements may be considered C-style and Fortran-style contiguous.</source>
          <target state="translated">配列に要素がない場合（ &lt;code&gt;self.size == 0&lt;/code&gt; ）、有効なインデックスはなく、ストライドは使用されません。要素のない配列は、CスタイルとFortranスタイルの連続と見なされます。</target>
        </trans-unit>
        <trans-unit id="c5c598efb3988281532c1be87569879df34d1935" translate="yes" xml:space="preserve">
          <source>If an array is created using a data-type describing a sub-array, the dimensions of the sub-array are appended to the shape of the array when the array is created. Sub-arrays in a field of a structured type behave differently, see &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;Field Access&lt;/a&gt;.</source>
          <target state="translated">配列がサブ配列を記述するデータ型を使用して作成される場合、配列が作成されるときに、サブ配列の次元が配列の形状に追加されます。構造化タイプのフィールドのサブ配列の動作は異なります。&lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;フィールドアクセスを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="bf36df6b09764d99c53b04e05c8fe53411949d03" translate="yes" xml:space="preserve">
          <source>If an array is created with this method, simply adding &amp;lsquo;itemsize&amp;rsquo; for each iteration will traverse the new array matching the iterator.</source>
          <target state="translated">このメソッドで配列が作成された場合、反復ごとに「itemsize」を追加するだけで、イテレーターに一致する新しい配列がトラバースされます。</target>
        </trans-unit>
        <trans-unit id="1497d51c68c81f921994ed240661dbb7879d05a8" translate="yes" xml:space="preserve">
          <source>If an array is too large to be printed, NumPy automatically skips the central part of the array and only prints the corners:</source>
          <target state="translated">配列が大きすぎて印刷できない場合、NumPyは自動的に配列の中心部をスキップして、コーナーのみを印刷します。</target>
        </trans-unit>
        <trans-unit id="5e8325ebccad64f5436323a863f272d5f091c76c" translate="yes" xml:space="preserve">
          <source>If an element of &lt;code&gt;axes&lt;/code&gt; is larger than than the number of axes of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;axes&lt;/code&gt; の要素が &lt;code&gt;a&lt;/code&gt; のAxesの数より大きい場合。</target>
        </trans-unit>
        <trans-unit id="bc51d7d23e7dc12f32f8e1785a950a943342d4c8" translate="yes" xml:space="preserve">
          <source>If an index exceeds the dimension of the array along &lt;code&gt;axis&lt;/code&gt;, an empty sub-array is returned correspondingly.</source>
          <target state="translated">インデックスが &lt;code&gt;axis&lt;/code&gt; に沿った配列の次元を超える場合、それに応じて空のサブ配列が返されます。</target>
        </trans-unit>
        <trans-unit id="d50315439445c5e53d7c5cb2eca5a37deb22722b" translate="yes" xml:space="preserve">
          <source>If an input has a dimension size of 1 in its shape, the first data entry in that dimension will be used for all calculations along that dimension. In other words, the stepping machinery of the &lt;a href=&quot;../glossary#term-ufunc&quot;&gt;ufunc&lt;/a&gt; will simply not step along that dimension (the &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;stride&lt;/a&gt; will be 0 for that dimension).</source>
          <target state="translated">入力の形状のディメンションサイズが1の場合、そのディメンションの最初のデータエントリが、そのディメンションに沿ったすべての計算に使用されます。言い換えると、&lt;a href=&quot;../glossary#term-ufunc&quot;&gt;ufuncの&lt;/a&gt;ステッピング機構は、単にその次元に沿ってステッピングしません（その次元の&lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;ストライド&lt;/a&gt;は0になります）。</target>
        </trans-unit>
        <trans-unit id="99fec5dbaf9a5723fb1db21784554641e2d086b8" translate="yes" xml:space="preserve">
          <source>If an input has a dimension size of 1 in its shape, the first data entry in that dimension will be used for all calculations along that dimension. In other words, the stepping machinery of the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; will simply not step along that dimension (the &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;stride&lt;/a&gt; will be 0 for that dimension).</source>
          <target state="translated">入力のディメンションサイズが1の場合、そのディメンションの最初のデータエントリが、そのディメンションに沿ったすべての計算に使用されます。言い換えれば、&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufuncの&lt;/a&gt;ステッピング機構は単にその次元に沿ってステップしない（その次元の&lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;ストライド&lt;/a&gt;は0になる）だけです。</target>
        </trans-unit>
        <trans-unit id="981216fcb80286728db3aa0467d4b1e8a655fef5" translate="yes" xml:space="preserve">
          <source>If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated as if a were np.arange(a)</source>
          <target state="translated">ndarrayの場合,その要素からランダムなサンプルが生成されます.int の場合は,a が np.arange(a)であるかのようにランダムサンプルが生成されます.</target>
        </trans-unit>
        <trans-unit id="6bcff738f855376346fed2a54471feef4ca0479d" translate="yes" xml:space="preserve">
          <source>If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated from np.arange(a).</source>
          <target state="translated">ndarray の場合は,その要素からランダムなサンプルが生成されます.intの場合は,np.arange(a)からランダムサンプルを生成します.</target>
        </trans-unit>
        <trans-unit id="b055403a11a75cdadf358d2e4b16e4aaac100a0a" translate="yes" xml:space="preserve">
          <source>If an object is provided, its write method should take one argument, a string.</source>
          <target state="translated">オブジェクトが提供されている場合、その書き込みメソッドは1つの引数である文字列を取らなければなりません。</target>
        </trans-unit>
        <trans-unit id="c6eb2fb826e8cbc6182574444dd579783c5b9225" translate="yes" xml:space="preserve">
          <source>If any input is array_like, &lt;code&gt;pv&lt;/code&gt; returns an array of equal shape. Let&amp;rsquo;s compare different interest rates in the example above:</source>
          <target state="translated">入力がarray_likeの場合、 &lt;code&gt;pv&lt;/code&gt; は同じ形状の配列を返します。上記の例で異なる金利を比較してみましょう：</target>
        </trans-unit>
        <trans-unit id="ffa8ae9c8e4ca204b853aaf38ee0943c2276d1c9" translate="yes" xml:space="preserve">
          <source>If any input is array_like, returns an array of equal shape. Let&amp;rsquo;s compare different interest rates from the example above.</source>
          <target state="translated">いずれかの入力がarray_likeの場合、等しい形状の配列を返します。上記の例とは異なる金利を比較してみましょう。</target>
        </trans-unit>
        <trans-unit id="dce7db3f12e1e92b36fcbe9af677f929557b423e" translate="yes" xml:space="preserve">
          <source>If any read/write overlap exists, this flag ensures the result of the operation is the same as if all operands were copied. In cases where copies would need to be made, &lt;strong&gt;the result of the computation may be undefined without this flag!&lt;/strong&gt;</source>
          <target state="translated">読み取り/書き込みのオーバーラップが存在する場合、このフラグにより​​、操作の結果がすべてのオペランドがコピーされた場合と同じになります。コピーを作成する必要がある場合、&lt;strong&gt;このフラグがないと、計算結果は未定義になる可能性があります。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e0c40f81e19502941982ef1a412a173673233b4" translate="yes" xml:space="preserve">
          <source>If any value in &lt;code&gt;alpha&lt;/code&gt; is less than or equal to zero</source>
          <target state="translated">&lt;code&gt;alpha&lt;/code&gt; いずれかの値がゼロ以下の場合</target>
        </trans-unit>
        <trans-unit id="5a8f0d595ba6a3701f0ba4d0bf45fa3cd44ca9ce" translate="yes" xml:space="preserve">
          <source>If any value in alpha is less than or equal to zero</source>
          <target state="translated">アルファ値のいずれかの値がゼロ以下の場合</target>
        </trans-unit>
        <trans-unit id="bc219d3a8300527c6efa92537ff8d0dcdb1108df" translate="yes" xml:space="preserve">
          <source>If any write operand has overlap with any read operand, eliminate all overlap by making temporary copies (enabling UPDATEIFCOPY for write operands, if necessary). A pair of operands has overlap if there is a memory address that contains data common to both arrays.</source>
          <target state="translated">オペランドのペアが重複している場合、オペランドを一時的にコピーすることで、すべての重複を排除します(必要に応じて、書き込みオペランドに対してUPDATEIFCOPYを有効にします)。オペランドのペアは、両方の配列に共通のデータを含むメモリ・アドレスがある場合、重複しています。</target>
        </trans-unit>
        <trans-unit id="2a45557faccf378e4b524258e3744f14e01d0549" translate="yes" xml:space="preserve">
          <source>If argument consists exclusively of int dtypes.</source>
          <target state="translated">引数がintのdtypesのみで構成されている場合。</target>
        </trans-unit>
        <trans-unit id="c785d849c18fc327cf9bee37bc11741d006f8fa7" translate="yes" xml:space="preserve">
          <source>If arguments are passed in with no keywords, the corresponding variable names, in the &lt;code&gt;.npz&lt;/code&gt; file, are &amp;lsquo;arr_0&amp;rsquo;, &amp;lsquo;arr_1&amp;rsquo;, etc. If keyword arguments are given, the corresponding variable names, in the &lt;code&gt;.npz&lt;/code&gt; file will match the keyword names.</source>
          <target state="translated">キーワードなしで引数が渡された場合、 &lt;code&gt;.npz&lt;/code&gt; ファイル内の対応する変数名は「arr_0」、「arr_1」などになります。キーワード引数が指定されている場合、 &lt;code&gt;.npz&lt;/code&gt; ファイル内の対応する変数名は、キーワード名。</target>
        </trans-unit>
        <trans-unit id="3d1c7a0f1e977aad5bcdfcdc2989a2f748b0274f" translate="yes" xml:space="preserve">
          <source>If array_like, the bin edges for the two dimensions (x_edges=y_edges=bins).</source>
          <target state="translated">array_like の場合は,2 次元の bin エッジ(x_edges=y_edges=bin)を指定します.</target>
        </trans-unit>
        <trans-unit id="8ad413f7fc8dfff3a6c2ee36c2613993e6279848" translate="yes" xml:space="preserve">
          <source>If at least one of &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is a non-string array</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; または &lt;code&gt;b&lt;/code&gt; の少なくとも1つが非文字列配列の場合</target>
        </trans-unit>
        <trans-unit id="b3c56f840baa3a689fec388e92d6ba86ff952aa7" translate="yes" xml:space="preserve">
          <source>If at some point an existing Institutional Partner stops having any contributing employees, then a one year grace period commences. If at the end of this one year period they continue not to have any contributing employees, then their Institutional Partnership will lapse, and resuming it will require going through the normal process for new Partnerships.</source>
          <target state="translated">ある時点で既存の機関投資家パートナーが貢献している従業員がいなくなった場合、1年間の猶予期間が開始される。この1年間の猶予期間が終了した時点でも貢献している従業員がいない場合は、その機関投資家パートナーシップは失効し、再開するには新たなパー トナーシップのための通常のプロセスを経る必要がある。</target>
        </trans-unit>
        <trans-unit id="8a90d0b3d22bdc0f93b285a7398aa4703fe73214" translate="yes" xml:space="preserve">
          <source>If axis is 0, only rows are suppressed.</source>
          <target state="translated">軸が0の場合、行のみが抑制されます。</target>
        </trans-unit>
        <trans-unit id="0782bc28993b5f00e72a0af1dcec69356d31839c" translate="yes" xml:space="preserve">
          <source>If axis is 1 or -1, only columns are suppressed.</source>
          <target state="translated">軸が 1 または -1 の場合、列のみが抑制されます。</target>
        </trans-unit>
        <trans-unit id="9506a7c18a807c059cd952ed93d5c51207a2a07d" translate="yes" xml:space="preserve">
          <source>If axis is None, both rows and columns are suppressed.</source>
          <target state="translated">軸が None の場合、行と列の両方が抑制されます。</target>
        </trans-unit>
        <trans-unit id="c5149a1f08013bd4c50d9514785f4f44208d1f0b" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, a product is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">axisがintのタプルである場合、積は、1つの軸または以前のようにすべての軸ではなく、タプルで指定されたすべての軸に対して実行されます。</target>
        </trans-unit>
        <trans-unit id="8de953aea1cde5c7cd7a932c7c1cd638dd5b48f8" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, a sum is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">axis が ints のタプルである場合、1 つの軸または以前のようにすべての軸ではなく、タプルで指定されたすべての軸に対して合計が実行されます。</target>
        </trans-unit>
        <trans-unit id="b7d9ad0b67d074ec073be5ef4e15eeecb68acdae" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, averaging is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">axisがintのタプルである場合、平均化は、1つの軸または以前のようにすべての軸ではなく、タプルで指定されたすべての軸で実行されます。</target>
        </trans-unit>
        <trans-unit id="288d1e6c0a612db41ca8d2410d35c52a79ba7795" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, flipping is performed on all of the axes specified in the tuple.</source>
          <target state="translated">axisがintのタプルの場合、タプルで指定されたすべての軸に対して反転が行われます。</target>
        </trans-unit>
        <trans-unit id="4a67a427d1a7cbcfc229fb55b05bdd5b239d1bd3" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 1-D arrays, it is inner product of vectors (without complex conjugation).</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; の両方が1次元配列の場合は、ベクトルの内積です（複素共役なし）。</target>
        </trans-unit>
        <trans-unit id="c28be53ff292bd7a51506b92f27ed7a94fd2ec15" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 2-D arrays, it is matrix multiplication, but using &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;matmul&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;a @ b&lt;/code&gt; is preferred.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; の両方が2次元配列の場合、それは行列の乗算ですが、&lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;matmul&lt;/code&gt; &lt;/a&gt;または &lt;code&gt;a @ b&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="76c96acc4a781ea364ff42aad287e5f7651eee5d" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;formats&lt;/code&gt; and &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are None, then this will auto-detect formats. Use list of tuples rather than list of lists for faster processing.</source>
          <target state="translated">両方の場合 &lt;code&gt;formats&lt;/code&gt; と&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;Noneです、この意志フォーマットを自動検出。処理を高速化するには、リストのリストではなくタプルのリストを使用します。</target>
        </trans-unit>
        <trans-unit id="194f3cee9e7df2b602bf5ba80d6118fb502e2eaf" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;formats&lt;/code&gt; and &lt;code&gt;dtype&lt;/code&gt; are None, then this will auto-detect formats. Use list of tuples rather than list of lists for faster processing.</source>
          <target state="translated">両方の場合 &lt;code&gt;formats&lt;/code&gt; と &lt;code&gt;dtype&lt;/code&gt; Noneです、この意志フォーマットを自動検出。処理を高速化するには、リストのリストではなくタプルのリストを使用します。</target>
        </trans-unit>
        <trans-unit id="368fd1e825cc7f1439018ab086e3ca74379697e1" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;code&gt;NULL&lt;/code&gt;, then return &lt;a href=&quot;#c.PyArray_Nonzero&quot;&gt;&lt;code&gt;PyArray_Nonzero&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;condition&lt;/em&gt;). Otherwise, both &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; must be given and the object returned is shaped like &lt;em&gt;condition&lt;/em&gt; and has elements of &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; where &lt;em&gt;condition&lt;/em&gt; is respectively True or False.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方が &lt;code&gt;NULL&lt;/code&gt; の場合、&lt;a href=&quot;#c.PyArray_Nonzero&quot;&gt; &lt;code&gt;PyArray_Nonzero&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;condition&lt;/em&gt;）を返します。それ以外の場合、&lt;em&gt;x&lt;/em&gt;と&lt;em&gt;yの&lt;/em&gt;両方を指定する必要があり、返されるオブジェクトは&lt;em&gt;条件の&lt;/em&gt;ような形をしており、&lt;em&gt;条件&lt;/em&gt;がそれぞれTrueまたはFalse である&lt;em&gt;x&lt;/em&gt;および&lt;em&gt;yの&lt;/em&gt;要素を持っています。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7d34c61041bcc07e55093729fc859031c36d6999" translate="yes" xml:space="preserve">
          <source>If both arguments are 2-D they are multiplied like conventional matrices.</source>
          <target state="translated">両方の引数が2次元の場合、従来の行列のように乗算されます。</target>
        </trans-unit>
        <trans-unit id="bf26496158ed7aff00fe3f64e66aa6a508289463" translate="yes" xml:space="preserve">
          <source>If both positive and negative infinity are present, the sum will be Not A Number (NaN).</source>
          <target state="translated">正の無限大と負の無限大の両方がある場合、合計はNot A Number(NaN)になります。</target>
        </trans-unit>
        <trans-unit id="c6be65ffe7d2b7c519b021c7a585a65d749c5cc8" translate="yes" xml:space="preserve">
          <source>If both the name and type are specified, the &lt;strong&gt;Returns&lt;/strong&gt; section takes the same form as the &lt;strong&gt;Parameters&lt;/strong&gt; section:</source>
          <target state="translated">名前とタイプの両方が指定されている場合、「&lt;strong&gt;返品」&lt;/strong&gt;セクションは「&lt;strong&gt;パラメーター」&lt;/strong&gt;セクションと同じ形式になり&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="10140359cb73a0890a92d9b94e958a4d9feb7bea" translate="yes" xml:space="preserve">
          <source>If both the name and type are specified, the &lt;strong&gt;Yields&lt;/strong&gt; section takes the same form as the &lt;strong&gt;Returns&lt;/strong&gt; section:</source>
          <target state="translated">名前とタイプの両方が指定されている場合、&lt;strong&gt;Yields&lt;/strong&gt;セクションは&lt;strong&gt;Returns&lt;/strong&gt;セクションと同じ形式になり&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="4d89fb74ad22e53fe87d261e5d40a2d4a0331e92" translate="yes" xml:space="preserve">
          <source>If called with all arguments other than the warning class omitted, may be used as a context manager:</source>
          <target state="translated">警告クラス以外のすべての引数を省略して呼ばれた場合、コンテキストマネージャーとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="e1f9fb2b578de1420ef1d4182da3c75ca58e3552" translate="yes" xml:space="preserve">
          <source>If complex input returns a real array if complex parts are close to zero.</source>
          <target state="translated">複素数入力の場合、複素数部分がゼロに近い場合は実数の配列を返します。</target>
        </trans-unit>
        <trans-unit id="4ec7acf826794e4e37207136e102eb50e7632b5f" translate="yes" xml:space="preserve">
          <source>If computation does not converge.</source>
          <target state="translated">計算が収束しない場合</target>
        </trans-unit>
        <trans-unit id="66501fc9abcadb23835ebb60ef928268453bb410" translate="yes" xml:space="preserve">
          <source>If condition is a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, missing values are considered as &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">conditionが&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; の&lt;/a&gt;場合、欠損値は &lt;code&gt;False&lt;/code&gt; と見なされます。</target>
        </trans-unit>
        <trans-unit id="9bd71f3d3293e73ba78bbdd8102f9b41323ceaaa" translate="yes" xml:space="preserve">
          <source>If copy is False and one of the inputs is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;, return a view of the other input mask. Defaults to False.</source>
          <target state="translated">copyがFalseで、入力の1つが&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; の&lt;/a&gt;場合、他の定型入力のビューを返します。デフォルトはFalseです。</target>
        </trans-unit>
        <trans-unit id="6d1cb15d43c2ba3971e5b54fc0a9bc261de3fb39" translate="yes" xml:space="preserve">
          <source>If data is passed to &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.PyArray_New&quot;&gt;&lt;code&gt;PyArray_New&lt;/code&gt;&lt;/a&gt;, this memory must not be deallocated until the new array is deleted. If this data came from another Python object, this can be accomplished using &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; on that object and setting the base member of the new array to point to that object. If strides are passed in they must be consistent with the dimensions, the itemsize, and the data of the array.</source>
          <target state="translated">データが&lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt; &lt;code&gt;PyArray_NewFromDescr&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#c.PyArray_New&quot;&gt; &lt;code&gt;PyArray_New&lt;/code&gt; に&lt;/a&gt;渡される場合、このメモリは、新しい配列が削除されるまで割り当て解除してはなりません。このデータが別のPythonオブジェクトからのものである場合は、そのオブジェクトで&lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt; &lt;code&gt;Py_INCREF&lt;/code&gt; &lt;/a&gt;を使用し、そのオブジェクトを指すように新しい配列のベースメンバーを設定することでこれを実現できます。ストライドが渡される場合、それらは、次元、itemsize、および配列のデータと一致している必要があります。</target>
        </trans-unit>
        <trans-unit id="8cd71bec9bf23486f57ed709deb2da7e823cdd37" translate="yes" xml:space="preserve">
          <source>If defined, the axis of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; that defines the vector(s) and cross product(s). Overrides &lt;code&gt;axisa&lt;/code&gt;, &lt;code&gt;axisb&lt;/code&gt; and &lt;code&gt;axisc&lt;/code&gt;.</source>
          <target state="translated">定義されている場合、軸、 &lt;code&gt;b&lt;/code&gt; 及び &lt;code&gt;c&lt;/code&gt; ベクトル（S）と外積（複数可）を定義します。 &lt;code&gt;axisa&lt;/code&gt; 、 &lt;code&gt;axisb&lt;/code&gt; および &lt;code&gt;axisc&lt;/code&gt; をオーバーライドします。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13711ea532b05dfaebf7f20551317865f1c997fe" translate="yes" xml:space="preserve">
          <source>If dtype is not supplied, this specifies the field names for the output dtype, in order. The field dtypes will be the same as the input array.</source>
          <target state="translated">dtypeが与えられていない場合は、出力されるdtypeのフィールド名を順に指定します。フィールドのdtypesは入力配列と同じになります。</target>
        </trans-unit>
        <trans-unit id="1d0ca2bca36fd3ca611fb59e9f429be6ca1dfcef" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is 0-D (scalar), it is equivalent to &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;multiply&lt;/code&gt;&lt;/a&gt; and using &lt;code&gt;numpy.multiply(a, b)&lt;/code&gt; or &lt;code&gt;a * b&lt;/code&gt; is preferred.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; または &lt;code&gt;b&lt;/code&gt; のいずれかが0-D（スカラー）の場​​合、&lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt; &lt;code&gt;multiply&lt;/code&gt; &lt;/a&gt;と同等であり、 &lt;code&gt;numpy.multiply(a, b)&lt;/code&gt; または &lt;code&gt;a * b&lt;/code&gt; が推奨されます。</target>
        </trans-unit>
        <trans-unit id="849e7230439a12b395b3d9d948e074f889418b25" translate="yes" xml:space="preserve">
          <source>If either argument is N-D, N &amp;gt; 2, it is treated as a stack of matrices residing in the last two indexes and broadcast accordingly.</source>
          <target state="translated">いずれかの引数がND、N&amp;gt; 2の場合、最後の2つのインデックスにある行列のスタックとして扱われ、それに応じてブロードキャストされます。</target>
        </trans-unit>
        <trans-unit id="cc8e18e241d0267fb4cce88d0332bc823b722b5a" translate="yes" xml:space="preserve">
          <source>If either array contains one or more NaNs, False is returned. Infs are treated as equal if they are in the same place and of the same sign in both arrays.</source>
          <target state="translated">どちらかの配列に1つ以上のNaNが含まれている場合,Falseが返されます.両方の配列の同じ場所に同じ符号のInfがある場合は,等しいものとして扱われます.</target>
        </trans-unit>
        <trans-unit id="281de8e5c6dae1e0aea9ae6d89d002bae88a2963" translate="yes" xml:space="preserve">
          <source>If element has complex type with zero complex part, the return value for that element is True.</source>
          <target state="translated">要素が複素数部がゼロの複素数型の場合、その要素の戻り値はTrueとなります。</target>
        </trans-unit>
        <trans-unit id="5d17dff94d5eaef97820ea5c6ea029508947d3b9" translate="yes" xml:space="preserve">
          <source>If factoring fails.</source>
          <target state="translated">ファクタリングが失敗したら</target>
        </trans-unit>
        <trans-unit id="d31081e35606566d9542bf752ae043c7bb856921" translate="yes" xml:space="preserve">
          <source>If file is a string or a path-like object then that file is opened, else it is assumed to be a file object. The file object must support random access (i.e. it must have tell and seek methods).</source>
          <target state="translated">ファイルが文字列かパスに似たオブジェクトであれば、そのファイルがオープンされ、そうでなければファイルオブジェクトとみなされます。ファイルオブジェクトはランダムアクセスをサポートしていなければなりません (つまり、 tell と seek メソッドを持っていなければなりません)。</target>
        </trans-unit>
        <trans-unit id="c92c0b980c98427841fd06fc2e90c17e3f8c8cf4" translate="yes" xml:space="preserve">
          <source>If filters are added and the &lt;code&gt;module&lt;/code&gt; keyword is given, the warning registry of this module will additionally be cleared when applying it, entering the context, or exiting it. This could cause warnings to appear a second time after leaving the context if they were configured to be printed once (default) and were already printed before the context was entered.</source>
          <target state="translated">フィルターが追加され、 &lt;code&gt;module&lt;/code&gt; キーワードが指定されている場合、このモジュールの警告レジストリーは、適用、コンテキストの入力、または終了時にさらに消去されます。これにより、一度印刷するように構成されていて（デフォルト）、コンテキストに入る前にすでに印刷されていた場合、コンテキストを離れた後に警告が再度表示される可能性があります。</target>
        </trans-unit>
        <trans-unit id="aa86a09a4bd6f04a9393e4d4dd4d45d0b7a047d8" translate="yes" xml:space="preserve">
          <source>If formats is None, then this will auto-detect formats. Use list of tuples rather than list of lists for faster processing.</source>
          <target state="translated">formats が None の場合は、フォーマットを自動検出します。処理を高速化するために、リストのリストではなくタプルのリストを使用してください。</target>
        </trans-unit>
        <trans-unit id="e7cf286f1082970c195a5ac9a9af060a6972f46c" translate="yes" xml:space="preserve">
          <source>If given and not &lt;code&gt;False&lt;/code&gt;, return not just the estimate but also its covariance matrix. By default, the covariance are scaled by chi2/dof, where dof = M - (deg + 1), i.e., the weights are presumed to be unreliable except in a relative sense and everything is scaled such that the reduced chi2 is unity. This scaling is omitted if &lt;code&gt;cov='unscaled'&lt;/code&gt;, as is relevant for the case that the weights are 1/sigma**2, with sigma known to be a reliable estimate of the uncertainty.</source>
          <target state="translated">&lt;code&gt;False&lt;/code&gt; でない場合は、推定値だけでなく、その共分散行列も返します。デフォルトでは、共分散はchi2 / dofによってスケーリングされます。ここで、dof = M-（deg + 1）です。つまり、相対的な意味を除いて重みは信頼できないと推定され、削減されたchi2が1になるようにすべてがスケーリングされます。重みが1 /シグマ** 2の場合に関連するように、 &lt;code&gt;cov='unscaled'&lt;/code&gt; の場合、このスケーリングは省略されます。シグマは不確実性の信頼できる推定値であることがわかっています。</target>
        </trans-unit>
        <trans-unit id="9c65522b5d0c56fc6284329915c9ff282e0a064e" translate="yes" xml:space="preserve">
          <source>If given and not &lt;code&gt;False&lt;/code&gt;, return not just the estimate but also its covariance matrix. By default, the covariance are scaled by chi2/sqrt(N-dof), i.e., the weights are presumed to be unreliable except in a relative sense and everything is scaled such that the reduced chi2 is unity. This scaling is omitted if &lt;code&gt;cov='unscaled'&lt;/code&gt;, as is relevant for the case that the weights are 1/sigma**2, with sigma known to be a reliable estimate of the uncertainty.</source>
          <target state="translated">&lt;code&gt;False&lt;/code&gt; でない場合は、推定値だけでなくその共分散行列も返します。デフォルトでは、共分散はchi2 / sqrt（N-dof）によってスケーリングされます。つまり、重みは相対的な意味を除いて信頼性が低いと推定され、縮小されたchi2が1になるようにすべてがスケーリングされます。 &lt;code&gt;cov='unscaled'&lt;/code&gt; の場合、このスケーリングは省略されます。これは、重みが1 / sigma ** 2の場合に関連しており、sigmaは不確実性の信頼できる推定値であることがわかっています。</target>
        </trans-unit>
        <trans-unit id="4a01bcc692f66d3a6d58bd9dd10d9c51e6240bfa" translate="yes" xml:space="preserve">
          <source>If given, any string of the form &lt;code&gt;@key@&lt;/code&gt; will be replaced by &lt;code&gt;subst_dict[key]&lt;/code&gt; in the template file when installed. The install prefix is always available through the variable &lt;code&gt;@prefix@&lt;/code&gt;, since the install prefix is not easy to get reliably from setup.py.</source>
          <target state="translated">指定すると、 &lt;code&gt;@key@&lt;/code&gt; 形式の文字列は、インストール時にテンプレートファイルで &lt;code&gt;subst_dict[key]&lt;/code&gt; に置き換えられます。インストールプレフィックスはsetup.pyから確実に取得することが容易ではないため、変数 &lt;code&gt;@prefix@&lt;/code&gt; を通じて常にインストールプレフィックスを利用できます。</target>
        </trans-unit>
        <trans-unit id="f229986316849fc58c19699184e093af0322102f" translate="yes" xml:space="preserve">
          <source>If given, should be a sequence of additional directories where to look for npy-pkg-config files. Those directories are searched prior to the NumPy directory.</source>
          <target state="translated">与えられた場合、npy-pkg-configファイルを探すための追加のディレクトリのシーケンスを指定する必要があります。これらのディレクトリは、NumPyディレクトリよりも前に検索されます。</target>
        </trans-unit>
        <trans-unit id="282b0a219b18c48a317e72503d2100cde36f84f8" translate="yes" xml:space="preserve">
          <source>If given, the array must be of the form &lt;code&gt;[beg, end]&lt;/code&gt;, where &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are the endpoints of the domain. If None is given then the class domain is used. The default is None.</source>
          <target state="translated">指定する場合、配列は &lt;code&gt;[beg, end]&lt;/code&gt; 形式でなければなりません。ここで、 &lt;code&gt;beg&lt;/code&gt; と &lt;code&gt;end&lt;/code&gt; はドメインのエンドポイントです。Noneを指定すると、クラスドメインが使用されます。デフォルトは「なし」です。</target>
        </trans-unit>
        <trans-unit id="0dd507ea0f76e3b5e94e32d9b92c028c04854d11" translate="yes" xml:space="preserve">
          <source>If given, the resulting array must be if the form &lt;code&gt;[beg, end]&lt;/code&gt;, where &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are the endpoints of the window. If None is given then the class window is used. The default is None.</source>
          <target state="translated">指定する場合、結果の配列は &lt;code&gt;[beg, end]&lt;/code&gt; 形式でなければなりません。ここで、 &lt;code&gt;beg&lt;/code&gt; と &lt;code&gt;end&lt;/code&gt; はウィンドウのエンドポイントです。Noneを指定すると、クラスウィンドウが使用されます。デフォルトは「なし」です。</target>
        </trans-unit>
        <trans-unit id="d16d5189bfa0fff58db67c1477d4b5ae0a2a03f6" translate="yes" xml:space="preserve">
          <source>If given, this is returned for objects whose types can not be determined. If not given, None is returned for those objects.</source>
          <target state="translated">指定された場合、型が特定できないオブジェクトに対して返されます。与えられなかった場合は、それらのオブジェクトに対して None が返されます。</target>
        </trans-unit>
        <trans-unit id="a5160dd116d677ef1f0e36c955a207aad3b93f5a" translate="yes" xml:space="preserve">
          <source>If given, this is the destinaton of the shuffled array. If &lt;code&gt;out&lt;/code&gt; is None, a shuffled copy of the array is returned.</source>
          <target state="translated">与えられた場合、これはシャッフルされた配列の宛先です。 &lt;code&gt;out&lt;/code&gt; がNoneの場合、配列のシャッフルされたコピーが返されます。</target>
        </trans-unit>
        <trans-unit id="4c9471fb7a9f3abaf682e7276b2ee9a3f16f1ed9" translate="yes" xml:space="preserve">
          <source>If input array &lt;code&gt;a&lt;/code&gt; is not 2D.</source>
          <target state="translated">入力配列 &lt;code&gt;a&lt;/code&gt; が2Dでない場合。</target>
        </trans-unit>
        <trans-unit id="03697161ee2c8ff90aa05356bdc85cfdd7ffe30e" translate="yes" xml:space="preserve">
          <source>If input is complex with all imaginary parts close to zero, return real parts.</source>
          <target state="translated">入力がすべての虚数部がゼロに近い複素数である場合、実数部を返します。</target>
        </trans-unit>
        <trans-unit id="f96f22e66784df0c0e7c7e7a77f909c0ac407de2" translate="yes" xml:space="preserve">
          <source>If input is the wrong shape (the input must be a 1-D or square 2-D array).</source>
          <target state="translated">入力が間違った形状の場合(入力は1次元または正方形の2次元配列でなければなりません)。</target>
        </trans-unit>
        <trans-unit id="c9a78f52b99ab1c1f8aad79c5f4b73ab06b85a94" translate="yes" xml:space="preserve">
          <source>If instead, we replace our &lt;code&gt;super&lt;/code&gt; call with &lt;code&gt;getattr(ufunc, method)&lt;/code&gt;, we effectively do &lt;code&gt;np.add(a.view(np.ndarray), b)&lt;/code&gt;. Again, &lt;code&gt;B.__array_ufunc__&lt;/code&gt; will be called, but now it sees an &lt;code&gt;ndarray&lt;/code&gt; as the other argument. Likely, it will know how to handle this, and return a new instance of the &lt;code&gt;B&lt;/code&gt; class to us. Our example class is not set up to handle this, but it might well be the best approach if, e.g., one were to re-implement &lt;code&gt;MaskedArray&lt;/code&gt; using &lt;code&gt;__array_ufunc__&lt;/code&gt;.</source>
          <target state="translated">代わりに、 &lt;code&gt;super&lt;/code&gt; 呼び出しを &lt;code&gt;getattr(ufunc, method)&lt;/code&gt; に置き換えると、効果的に &lt;code&gt;np.add(a.view(np.ndarray), b)&lt;/code&gt; ます。ここでも、 &lt;code&gt;B.__array_ufunc__&lt;/code&gt; が &lt;code&gt;ndarray&lt;/code&gt; れますが、他の引数としてndarrayが表示されます。おそらく、これを処理する方法を知っており、 &lt;code&gt;B&lt;/code&gt; クラスの新しいインスタンスを私たちに返します。このサンプルクラスはこれを処理するように設定されていませんが、たとえば &lt;code&gt;MaskedArray&lt;/code&gt; を使用して &lt;code&gt;__array_ufunc__&lt;/code&gt; を再実装する場合は、これが最善のアプローチである可能性があります。</target>
        </trans-unit>
        <trans-unit id="570a12b7ce63be7a2ce71fba3d8c9da77deb9d9d" translate="yes" xml:space="preserve">
          <source>If int, the number of bins for the two dimensions (nx=ny=bins).</source>
          <target state="translated">intの場合は,2次元のビン数(nx=ny=ビン).</target>
        </trans-unit>
        <trans-unit id="f4fb4d5bcb48df147e2cef0a0ea5928ac8067b9e" translate="yes" xml:space="preserve">
          <source>If it becomes necessary for the Steering Council to produce a formal decision, then they will use a form of the &lt;a href=&quot;https://www.apache.org/foundation/voting.html&quot;&gt;Apache Foundation voting process&lt;/a&gt;. This is a formalized version of consensus, in which +1 votes indicate agreement, -1 votes are vetoes (and must be accompanied with a rationale, as above), and one can also vote fractionally (e.g. -0.5, +0.5) if one wishes to express an opinion without registering a full veto. These numeric votes are also often used informally as a way of getting a general sense of people&amp;rsquo;s feelings on some issue, and should not normally be taken as formal votes. A formal vote only occurs if explicitly declared, and if this does occur then the vote should be held open for long enough to give all interested Council Members a chance to respond &amp;ndash; at least one week.</source>
          <target state="translated">運営評議会が正式な決定を下す必要が生じた場合、彼らは&lt;a href=&quot;https://www.apache.org/foundation/voting.html&quot;&gt;ApacheFoundationの投票プロセスの&lt;/a&gt;形式を使用します。これはコンセンサスの形式化されたバージョンであり、+ 1票は同意を示し、-1票は拒否権であり（上記のように論理的根拠を伴う必要があります）、1つであれば部分的に（たとえば-0.5、+ 0.5）投票することもできます。完全な拒否権を登録せずに意見を表明したい。これらの数値投票は、ある問題に対する人々の感情の一般的な感覚を得る方法として非公式に使用されることも多く、通常は正式な投票と見なされるべきではありません。正式な投票は、明示的に宣言された場合にのみ発生します。これが発生した場合は、関心のあるすべての評議会メンバーに応答する機会を与えるのに十分な期間、少なくとも1週間は投票を開いておく必要があります。</target>
        </trans-unit>
        <trans-unit id="46b4bbe660909db346ad59c7951f05bdd8332431" translate="yes" xml:space="preserve">
          <source>If it is necessary to explain a private method (use with care!), it can be referred to in the &lt;strong&gt;Extended Summary&lt;/strong&gt; or the &lt;strong&gt;Notes&lt;/strong&gt; section. Do not list private methods in the &lt;strong&gt;methods&lt;/strong&gt; section.</source>
          <target state="translated">プライベートメソッドを説明する必要がある場合（注意して使用してください！）、&lt;strong&gt;拡張サマリー&lt;/strong&gt;または&lt;strong&gt;メモ&lt;/strong&gt;セクションで参照できます。&lt;strong&gt;メソッド&lt;/strong&gt;セクションにプライベートメソッドをリストしないでください。</target>
        </trans-unit>
        <trans-unit id="c2941a8c3ef7e42aa1704dd826466efd7a289a13" translate="yes" xml:space="preserve">
          <source>If it is not necessary to specify a keyword argument, use &lt;code&gt;optional&lt;/code&gt;:</source>
          <target state="translated">キーワード引数を指定する必要がない場合は、 &lt;code&gt;optional&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="14206cf495608dab3bc0c9563f466018da9e1b11" translate="yes" xml:space="preserve">
          <source>If it went wrong, recovery is again possible as explained &lt;a href=&quot;#recovering-from-mess-up&quot;&gt;above&lt;/a&gt;.</source>
          <target state="translated">それがうまくいかなかった場合、&lt;a href=&quot;#recovering-from-mess-up&quot;&gt;上で&lt;/a&gt;説明したように回復が再び可能です。</target>
        </trans-unit>
        <trans-unit id="3a1bd74933e0b346982972b3334dd2af53c8b3cb" translate="yes" xml:space="preserve">
          <source>If keyword arguments are given, then filenames are taken from the keywords. If arguments are passed in with no keywords, then stored file names are arr_0, arr_1, etc.</source>
          <target state="translated">キーワード引数が与えられた場合は、そのキーワードからファイル名が取得されます。キーワードなしで引数が渡された場合は、格納されたファイル名は arr_0,arr_1 などとなります。</target>
        </trans-unit>
        <trans-unit id="a05e5457e182b0de28998599a17f81c2384bc52a" translate="yes" xml:space="preserve">
          <source>If keyword arguments are given, then filenames are taken from the keywords. If arguments are passed in with no keywords, then stored filenames are arr_0, arr_1, etc.</source>
          <target state="translated">キーワード引数が与えられた場合は、そのキーワードからファイル名が取り出されます。キーワードなしで引数が渡された場合は、格納されたファイル名は arr_0,arr_1 などになります。</target>
        </trans-unit>
        <trans-unit id="68f5690b1b20b80392957d2cc602580121727a3e" translate="yes" xml:space="preserve">
          <source>If list depths are mismatched - for instance, &lt;code&gt;[[a, b], c]&lt;/code&gt; is illegal, and should be spelt &lt;code&gt;[[a, b], [c]]&lt;/code&gt;</source>
          <target state="translated">リストの深さが一致しない場合-たとえば、 &lt;code&gt;[[a, b], c]&lt;/code&gt; は違法であり、 &lt;code&gt;[[a, b], [c]]&lt;/code&gt; と綴る必要があります</target>
        </trans-unit>
        <trans-unit id="f609da24233a507af66f8b7969941dc9c31d8838" translate="yes" xml:space="preserve">
          <source>If lists are empty - for instance, &lt;code&gt;[[a, b], []]&lt;/code&gt;</source>
          <target state="translated">リストが空の場合-たとえば、 &lt;code&gt;[[a, b], []]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0fa6317253cb5f3105874e72d36c2e7ed1eb2af" translate="yes" xml:space="preserve">
          <source>If multi-dimension input, returns a new ndarray of indices to the minimum values along the given axis. Otherwise, returns a scalar of index to the minimum values along the given axis.</source>
          <target state="translated">多次元入力の場合、与えられた軸に沿った最小値のインデックスの新しいndarrayを返します。それ以外の場合は、与えられた軸に沿った最小値へのインデックスのスカラを返します。</target>
        </trans-unit>
        <trans-unit id="3be2da634ae4e1a50b6a61b6e2a72b4b4858161d" translate="yes" xml:space="preserve">
          <source>If necessary, will be flattened before the differences are taken.</source>
          <target state="translated">必要に応じて、差分を取る前に平らになります。</target>
        </trans-unit>
        <trans-unit id="301925ec926932bb64f4f4002e984f88f86a2131" translate="yes" xml:space="preserve">
          <source>If needed create a new C-structure to handle each instance of your type. A typical C-structure would be:</source>
          <target state="translated">必要であれば、型の各インスタンスを処理するための新しい C-構造体を作成します。典型的な C-structure は次のようなものです。</target>
        </trans-unit>
        <trans-unit id="0a3c8652ca0e3dccf381651d80f187b5ac1a5a74" translate="yes" xml:space="preserve">
          <source>If neither is defined, the C-API is declared to be &lt;code&gt;static void**&lt;/code&gt;, so it is only visible within the compilation unit that #includes numpy/arrayobject.h.</source>
          <target state="translated">どちらも定義されていない場合、C-APIは &lt;code&gt;static void**&lt;/code&gt; として宣言されるため、＃includes numpy / arrayobject.hを含むコンパイル単位内でのみ表示されます。</target>
        </trans-unit>
        <trans-unit id="853b03d065feffbc6ac6731a7bbb396016c51c2b" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;__array_function__&lt;/code&gt; methods exists, NumPy will default to calling its own implementation, intended for use on NumPy arrays. This case arises, for example, when all array-like arguments are Python numbers or lists. (NumPy arrays do have a &lt;code&gt;__array_function__&lt;/code&gt; method, given below, but it always returns &lt;code&gt;NotImplemented&lt;/code&gt; if any argument other than a NumPy array subclass implements &lt;code&gt;__array_function__&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;__array_function__&lt;/code&gt; メソッドが存在しない場合、NumPyはデフォルトで、NumPy配列での使用を目的とした独自の実装を呼び出します。このケースは、たとえば、配列のようなすべての引数がPythonの数値またはリストである場合に発生します。（numpyのアレイを持っている &lt;code&gt;__array_function__&lt;/code&gt; 下記の方法を、それは常に返す &lt;code&gt;NotImplemented&lt;/code&gt; numpyのアレイサブクラス実装以外の引数があれば &lt;code&gt;__array_function__&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9e9935f1dd70f7a86b993ae6eeed6ce9464e1229" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;intent(in | inout | out | hide)&lt;/code&gt; is specified, &lt;code&gt;intent(in)&lt;/code&gt; is assumed.</source>
          <target state="translated">&lt;code&gt;intent(in | inout | out | hide)&lt;/code&gt; が指定されていない場合、 &lt;code&gt;intent(in)&lt;/code&gt; が想定されます。</target>
        </trans-unit>
        <trans-unit id="505142361ce7d844b31c251e5147e86fce3849fd" translate="yes" xml:space="preserve">
          <source>If none of the inputs overrides the ufunc, then all output arrays will be passed to the &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; methods of the input (besides &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;, and scalars) that defines it &lt;strong&gt;and&lt;/strong&gt; has the highest &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of any other input to the universal function. The default &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of the ndarray is 0.0, and the default &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of a subtype is 0.0. Matrices have &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; equal to 10.0.</source>
          <target state="translated">入力のいずれもufuncを上書きしない場合は、すべての出力アレイがに渡される&lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt;（以外の入力方法&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt;、およびスカラー）定義すること&lt;strong&gt;と&lt;/strong&gt;最高有する&lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;汎用関数に他の入力を。&lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;のデフォルトの__array_priority__は0.0 で、サブタイプのデフォルトの&lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;は0.0です。行列の&lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;は10.0です。</target>
        </trans-unit>
        <trans-unit id="96625db984c22cd52ed20b5b293895185469b2c4" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt; normalization is by &lt;code&gt;(N - ddof)&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the number of observations; this overrides the value implied by &lt;code&gt;bias&lt;/code&gt;. The default value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; でない場合、正規化は &lt;code&gt;(N - ddof)&lt;/code&gt; によって行われます &lt;code&gt;N&lt;/code&gt; は観測値の数です。これは、 &lt;code&gt;bias&lt;/code&gt; によって暗示される値をオーバーライドします。デフォルト値は &lt;code&gt;None&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e98fcdb4d2a9bfdfbe2eeae9c39d82ef88da39fa" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt; the default value implied by &lt;code&gt;bias&lt;/code&gt; is overridden. Note that &lt;code&gt;ddof=1&lt;/code&gt; will return the unbiased estimate, even if both &lt;code&gt;fweights&lt;/code&gt; and &lt;code&gt;aweights&lt;/code&gt; are specified, and &lt;code&gt;ddof=0&lt;/code&gt; will return the simple average. See the notes for the details. The default value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; でない場合、 &lt;code&gt;bias&lt;/code&gt; によって暗示されるデフォルト値は上書きされます。 &lt;code&gt;fweights&lt;/code&gt; と &lt;code&gt;aweights&lt;/code&gt; の両方が指定されている場合でも、 &lt;code&gt;ddof=1&lt;/code&gt; は不偏推定を返し、 &lt;code&gt;ddof=0&lt;/code&gt; は単純平均を返すことに注意してください。詳細については、注を参照してください。デフォルト値は &lt;code&gt;None&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="fcf87e157fa41fe29ae78434e407f9e7ee68fcea" translate="yes" xml:space="preserve">
          <source>If not None, the keys should indicate the type(s) that the respective formatting function applies to. Callables should return a string. Types that are not specified (by their corresponding keys) are handled by the default formatters. Individual types for which a formatter can be set are:</source>
          <target state="translated">Noneでない場合は、キーはそれぞれの書式設定関数が適用される型を示すべきです。呼び出し可能な関数は文字列を返す必要があります。(対応するキーによって)指定されていない型は、デフォルトのフォーマッタによって処理されます。フォーマッタを設定できる個々の型は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="bb477c8d5a32ba9dc9b4018fd2f3af6fa9009c49" translate="yes" xml:space="preserve">
          <source>If not None, the specified domain is used instead of that of the calling instance. It should be of the form &lt;code&gt;[beg,end]&lt;/code&gt;. The default is None which case the class domain is used.</source>
          <target state="translated">Noneでない場合は、呼び出し元インスタンスのドメインの代わりに、指定されたドメインが使用されます。 &lt;code&gt;[beg,end]&lt;/code&gt; 形式である必要があります。デフォルトはNoneで、この場合、クラスドメインが使用されます。</target>
        </trans-unit>
        <trans-unit id="9fd5a8f72ea35597060cfb26a58e00837b4119cd" translate="yes" xml:space="preserve">
          <source>If not None, then memory-map the file, using the given mode (see &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt;&lt;code&gt;numpy.memmap&lt;/code&gt;&lt;/a&gt; for a detailed description of the modes). A memory-mapped array is kept on disk. However, it can be accessed and sliced like any ndarray. Memory mapping is especially useful for accessing small fragments of large files without reading the entire file into memory.</source>
          <target state="translated">Noneでない場合は、指定されたモードを使用して、ファイルをメモリマップします（モードの詳細については、&lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt; &lt;code&gt;numpy.memmap&lt;/code&gt; &lt;/a&gt;を参照してください）。メモリマップドアレイはディスク上に保持されます。ただし、ndarrayのようにアクセスしてスライスできます。メモリマッピングは、ファイル全体をメモリに読み込まずに、大きなファイルの小さなフラグメントにアクセスする場合に特に便利です。</target>
        </trans-unit>
        <trans-unit id="1dde66b48fa13cf03c30ed219d07e5b09a8bd837" translate="yes" xml:space="preserve">
          <source>If obj is an ndarray (&lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt;), then the data-area of the ndarray is pointed to by the void* pointer &lt;a href=&quot;../reference/c-api/array#c.PyArray_DATA&quot;&gt;&lt;code&gt;PyArray_DATA&lt;/code&gt;&lt;/a&gt; (obj) or the char* pointer &lt;a href=&quot;../reference/c-api/array#c.PyArray_BYTES&quot;&gt;&lt;code&gt;PyArray_BYTES&lt;/code&gt;&lt;/a&gt; (obj). Remember that (in general) this data-area may not be aligned according to the data-type, it may represent byte-swapped data, and/or it may not be writeable. If the data area is aligned and in native byte-order, then how to get at a specific element of the array is determined only by the array of npy_intp variables, &lt;a href=&quot;../reference/c-api/array#c.PyArray_STRIDES&quot;&gt;&lt;code&gt;PyArray_STRIDES&lt;/code&gt;&lt;/a&gt; (obj). In particular, this c-array of integers shows how many &lt;strong&gt;bytes&lt;/strong&gt; must be added to the current element pointer to get to the next element in each dimension. For arrays less than 4-dimensions there are &lt;code&gt;PyArray_GETPTR{k}&lt;/code&gt; (obj, &amp;hellip;) macros where {k} is the integer 1, 2, 3, or 4 that make using the array strides easier. The arguments &amp;hellip;. represent {k} non- negative integer indices into the array. For example, suppose &lt;code&gt;E&lt;/code&gt; is a 3-dimensional ndarray. A (void*) pointer to the element &lt;code&gt;E[i,j,k]&lt;/code&gt; is obtained as &lt;a href=&quot;../reference/c-api/array#c.PyArray_GETPTR3&quot;&gt;&lt;code&gt;PyArray_GETPTR3&lt;/code&gt;&lt;/a&gt; (E, i, j, k).</source>
          <target state="translated">objがndarray（&lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt;）の場合、ndarrayのデータ領域は、void *ポインター&lt;a href=&quot;../reference/c-api/array#c.PyArray_DATA&quot;&gt; &lt;code&gt;PyArray_DATA&lt;/code&gt; &lt;/a&gt;（obj）またはchar *ポインター&lt;a href=&quot;../reference/c-api/array#c.PyArray_BYTES&quot;&gt; &lt;code&gt;PyArray_BYTES&lt;/code&gt; &lt;/a&gt;（obj）によってポイントされます。 （一般に）このデータ領域はデータ型に応じて整列されていない可能性があり、バイトスワップされたデータを表している可能性があり、および/または書き込み可能でない可能性があることに注意してください。データ領域が整列され、ネイティブのバイト順である場合、配列の特定の要素を取得する方法は、npy_intp変数の配列&lt;a href=&quot;../reference/c-api/array#c.PyArray_STRIDES&quot;&gt; &lt;code&gt;PyArray_STRIDES&lt;/code&gt; &lt;/a&gt;（obj）によってのみ決定されます。特に、この整数のc配列は、各次元の次の要素に到達するために、現在の要素ポインターに追加する必要がある&lt;strong&gt;バイト数を&lt;/strong&gt;示してい&lt;strong&gt;ます&lt;/strong&gt;。 4次元未満の配列の場合、 &lt;code&gt;PyArray_GETPTR{k}&lt;/code&gt; （obj、&amp;hellip;）マクロ。ここで、{k}は整数1、2、3、または4であり、配列のストライドの使用を容易にします。議論&amp;hellip;。配列への{k}非負の整数インデックスを表します。たとえば、 &lt;code&gt;E&lt;/code&gt; が3次元のndarrayであるとします。要素 &lt;code&gt;E[i,j,k]&lt;/code&gt; への（void *）ポインターは、&lt;a href=&quot;../reference/c-api/array#c.PyArray_GETPTR3&quot;&gt; &lt;code&gt;PyArray_GETPTR3&lt;/code&gt; &lt;/a&gt;（E、i、j、k）として取得されます。</target>
        </trans-unit>
        <trans-unit id="9280c1d0944bd8756c1f5111dc408efcc4ac592a" translate="yes" xml:space="preserve">
          <source>If offsets were specified using the optional &lt;code&gt;offsets&lt;/code&gt; key in the dictionary-based dtype specification, setting &lt;code&gt;align=True&lt;/code&gt; will check that each field&amp;rsquo;s offset is a multiple of its size and that the itemsize is a multiple of the largest field size, and raise an exception if not.</source>
          <target state="translated">オフセットは、オプションの使用して指定された場合は &lt;code&gt;offsets&lt;/code&gt; 設定、辞書ベースのDTYPE仕様のキーを &lt;code&gt;align=True&lt;/code&gt; 、各フィールドのオフセットは、そのサイズの倍数であるとitemsize最大フィールドサイズの倍数であり、例外を発生させることをことをチェックしますそうでない場合。</target>
        </trans-unit>
        <trans-unit id="7e8ee117c63f729e22bf227e3e07bb22de12fa90" translate="yes" xml:space="preserve">
          <source>If one argument: a scalar, only used in case &lt;code&gt;a&lt;/code&gt; is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</source>
          <target state="translated">1つの引数：スカラー、 &lt;code&gt;a&lt;/code&gt; のサイズが1の場合にのみ使用されます。2つの引数：最後の引数が設定する値であり、スカラーでなければならない場合、最初の引数は単一の配列要素の場所を指定します。intまたはtupleのいずれかです。</target>
        </trans-unit>
        <trans-unit id="57c6aeb84d68fcc852763a7a13de57615e4d20cf" translate="yes" xml:space="preserve">
          <source>If one does need to invoke a formal veto, then it should consist of:</source>
          <target state="translated">正式な拒否権を発動する必要があるならば、それは次のように構成されるべきです。</target>
        </trans-unit>
        <trans-unit id="071afc2f1bb001ecc847b5f0833d4155cd8fca5d" translate="yes" xml:space="preserve">
          <source>If one of the commands breaks in the middle, which is not uncommon, you may need to selectively upload the remaining files because PyPI does not allow the same file to be uploaded twice. The source file should be uploaded last to avoid synchronization problems if pip users access the files while this is in process. Note that PyPI only allows a single source distribution, here we have chosen the zip archive.</source>
          <target state="translated">珍しいことではありませんが、コマンドの一つが途中で途切れてしまった場合、PyPI は同じファイルを二度アップロードすることを許可していないので、残りのファイルを選択的にアップロードする必要があるかもしれません。この処理中に pip ユーザがファイルにアクセスした場合の同期問題を避けるために、ソースファイルは最後にアップロードする必要があります。PyPI は単一のソース配布しか許可していないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="6b366b75bdd6732eac035ef513f1831e74291371" translate="yes" xml:space="preserve">
          <source>If one of the commands breaks in the middle, you may need to selectively upload the remaining files because PyPI does not allow the same file to be uploaded twice. The source file should be uploaded last to avoid synchronization problems that might occur if pip users access the files while this is in process. Note that PyPI only allows a single source distribution, here we have chosen the zip archive.</source>
          <target state="translated">コマンドの1つが途中で中断した場合、PyPIは同じファイルを2回アップロードすることを許可していないため、残りのファイルを選択的にアップロードする必要があるかもしれません。ソースファイルは最後にアップロードすることで、処理中にピップユーザーがファイルにアクセスした場合に発生する可能性のある同期問題を回避することができます。PyPI は単一のソース配布しか認めていないことに注意してください。ここでは zip アーカイブを選択しました。</target>
        </trans-unit>
        <trans-unit id="6981fed895201194d2f8c788e92aaa4d462ed21a" translate="yes" xml:space="preserve">
          <source>If one of the input or output arguments has a &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, it is executed &lt;em&gt;instead&lt;/em&gt; of the ufunc. If more than one of the arguments implements &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;, they are tried in the order: subclasses before superclasses, inputs before outputs, otherwise left to right. The first routine returning something other than &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; determines the result. If all of the &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; operations return &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">入力引数または出力引数のいずれかに&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;メソッドがある場合、それはufuncの&lt;em&gt;代わり&lt;/em&gt;に実行されます。複数の引数が&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; を&lt;/a&gt;実装する場合、それらは次の順序で試行されます。スーパークラスの前のサブクラス、出力の前の入力、それ以外の場合は左から右。&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt;以外の何かを返す最初のルーチンが結果を決定します。すべての&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;操作がNotImplementedを返す&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;が発生します。</target>
        </trans-unit>
        <trans-unit id="078513303dc00f49a54bb48b4a05d01efff2507a" translate="yes" xml:space="preserve">
          <source>If one or more elements differ by more than &lt;code&gt;maxulp&lt;/code&gt;.</source>
          <target state="translated">1つ以上の要素が &lt;code&gt;maxulp&lt;/code&gt; よりも異なる場合。</target>
        </trans-unit>
        <trans-unit id="00b891e47fe38237c020d297bb43b5693729c6dd" translate="yes" xml:space="preserve">
          <source>If one throws a die repeatedly until the third time a &amp;ldquo;1&amp;rdquo; appears, then the probability distribution of the number of non-&amp;ldquo;1&amp;rdquo;s that appear before the third &amp;ldquo;1&amp;rdquo; is a negative binomial distribution.</source>
          <target state="translated">「1」が3回目に現れるまでサイコロを繰り返し投げると、3回目の「1」の前に現れる「1」以外の数の確率分布は負の二項分布になります。</target>
        </trans-unit>
        <trans-unit id="f25e55ccd77b879343ce3ca049a9d0e4b78987e8" translate="yes" xml:space="preserve">
          <source>If one uses the same dimension name in multiple locations, this enforces the same size of the corresponding dimensions.</source>
          <target state="translated">複数の場所で同じディメンジョン名を使用する場合、対応するディメンジョンの同じサイズが強制されます。</target>
        </trans-unit>
        <trans-unit id="341d0c5af878a988a0ac05e9410e510da00aae4c" translate="yes" xml:space="preserve">
          <source>If operand flags &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; are used the operands may be views into the original data with the &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag. In this case &lt;a href=&quot;#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; must be used as a context manager or the &lt;a href=&quot;numpy.nditer.close#numpy.nditer.close&quot;&gt;&lt;code&gt;nditer.close&lt;/code&gt;&lt;/a&gt; method must be called before using the result. The temporary data will be written back to the original data when the &lt;code&gt;__exit__&lt;/code&gt; function is called but not before:</source>
          <target state="translated">オペランドフラグ &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; または &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; が使用されている場合、オペランドは &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; フラグを使用して元のデータを表示できます。この場合に&lt;a href=&quot;#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;コンテキストマネージャとして使用しなければならないか、&lt;a href=&quot;numpy.nditer.close#numpy.nditer.close&quot;&gt; &lt;code&gt;nditer.close&lt;/code&gt; &lt;/a&gt;方法は結果を使用する前に呼び出されなければなりません。一時データは、 &lt;code&gt;__exit__&lt;/code&gt; 関数が呼び出されたときに元のデータに書き戻されますが、それ以前は書き戻されません。</target>
        </trans-unit>
        <trans-unit id="9d0e3c2e03d57620541ba508399723e46a30af16" translate="yes" xml:space="preserve">
          <source>If operand flags &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; are used the operands may be views into the original data with the &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag. In this case nditer must be used as a context manager or the nditer.close method must be called before using the result. The temporary data will be written back to the original data when the &lt;code&gt;__exit__&lt;/code&gt; function is called but not before:</source>
          <target state="translated">オペランドフラグ &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; または &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; が使用されている場合、オペランドは &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; フラグを使用して元のデータを表示する場合があります。この場合、結果を使用する前に、nditerをコンテキストマネージャーとして使用するか、nditer.closeメソッドを呼び出す必要があります。一時データは、 &lt;code&gt;__exit__&lt;/code&gt; 関数が呼び出されたときに元のデータに書き戻されますが、前には呼び出されません。</target>
        </trans-unit>
        <trans-unit id="6bcdbb4b2db72f15cd471674f6106b51d73bea1c" translate="yes" xml:space="preserve">
          <source>If our array has more than two dimensions, then the SVD can be applied to all axes at once. However, the linear algebra functions in NumPy expect to see an array of the form &lt;code&gt;(N, M, M)&lt;/code&gt;, where the first axis represents the number of matrices.</source>
          <target state="translated">配列に3つ以上の次元がある場合、SVDをすべての軸に一度に適用できます。ただし、NumPyの線形代数関数は、 &lt;code&gt;(N, M, M)&lt;/code&gt; 形式の配列を期待します。ここで、最初の軸は行列の数を表します。</target>
        </trans-unit>
        <trans-unit id="7979a86d632f406a43fda9a7bbc242f0b6aa48c1" translate="yes" xml:space="preserve">
          <source>If out is given and does not have a mask attribute, the mask of a is lost!</source>
          <target state="translated">outが与えられ、マスク属性を持たない場合、aのマスクは失われます!</target>
        </trans-unit>
        <trans-unit id="540ba134ebef3a60b12504ba1dddaea7cf0cec06" translate="yes" xml:space="preserve">
          <source>If passed a single ndarray or scalar (a nested list of depth 0), this is returned unmodified (and not copied).</source>
          <target state="translated">単一のndarrayまたはスカラ(深さ0の入れ子リスト)を渡した場合、これは変更されずに返されます(コピーされません)。</target>
        </trans-unit>
        <trans-unit id="2ca82b5f657729109e0a486900feb42978dd8189" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;#numpy.random.RandomState.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="translated">正のint_like引数が指定されている場合、&lt;a href=&quot;#numpy.random.RandomState.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt;は、平均0と分散1の単変量「正規」（ガウス）分布からサンプリングされたランダムフロートで満たされた形状 &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt; 配列を生成します。単一のフロート引数が指定されていない場合、分布からランダムにサンプリングされたものが返されます。</target>
        </trans-unit>
        <trans-unit id="96808216b5aaeeafcea0d1c6dd5a1e0894eaaeca" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;#numpy.random.mtrand.RandomState.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="translated">正のint_like引数が指定されている場合、&lt;a href=&quot;#numpy.random.mtrand.RandomState.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt;は形状 &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt; 配列を生成し、平均0と分散1の1変量の「正規」（ガウス）分布からサンプリングされたランダムなフロートで満たされます。引数を指定しない場合、分布からランダムにサンプリングされたものが返されます。</target>
        </trans-unit>
        <trans-unit id="6cd43f42d93868c2f881ad2d0e04b27cc3b3d230" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;#numpy.random.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="translated">正のint_like引数が指定されている場合、&lt;a href=&quot;#numpy.random.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt;は、平均0と分散1の単変量「正規」（ガウス）分布からサンプリングされたランダムフロートで満たされた形状 &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt; 配列を生成します。単一のフロート引数が指定されていない場合、分布からランダムにサンプリングされたものが返されます。</target>
        </trans-unit>
        <trans-unit id="bfcb0d73efeb90f5b4e3ce5ebdfcfa5192159dee" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;numpy.random.randn#numpy.random.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="translated">正のint_like引数が指定されている場合、&lt;a href=&quot;numpy.random.randn#numpy.random.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt;は、平均0と分散1の単変量「正規」（ガウス）分布からサンプリングされたランダムフロートで満たされた形状 &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt; 配列を生成します。単一のフロート引数が指定されていない場合、分布からランダムにサンプリングされたものが返されます。</target>
        </trans-unit>
        <trans-unit id="55be54163f14c3cf436fe9e5956719fe1ba33eba" translate="yes" xml:space="preserve">
          <source>If provided, forces the calculation to use the data type specified. Note that you may have to also give a more liberal &lt;code&gt;casting&lt;/code&gt; parameter to allow the conversions. Default is None.</source>
          <target state="translated">指定されている場合、指定されたデータ型を使用して計算を強制します。変換を可能にするために、よりリベラルな &lt;code&gt;casting&lt;/code&gt; パラメータも指定する必要がある場合があることに注意してください。デフォルトはなしです。</target>
        </trans-unit>
        <trans-unit id="e083348afe334fd6151280febab9e53c63ddbb1c" translate="yes" xml:space="preserve">
          <source>If provided, is a list of ints or None for each operands. The list of axes for an operand is a mapping from the dimensions of the iterator to the dimensions of the operand. A value of -1 can be placed for entries, causing that dimension to be treated as &lt;a href=&quot;../constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指定されている場合は、各オペランドのintまたはNoneのリストです。オペランドの軸のリストは、イテレーターの次元からオペランドの次元へのマッピングです。エントリに-1の値を設定すると、その次元が&lt;a href=&quot;../constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;として扱われます。</target>
        </trans-unit>
        <trans-unit id="b5d381c2d7955b7fd1c70c985e306d9e2f555e38" translate="yes" xml:space="preserve">
          <source>If provided, one above the largest (signed) integer to be drawn from the distribution (see above for behavior if &lt;code&gt;high=None&lt;/code&gt;). If array-like, must contain integer values</source>
          <target state="translated">提供されている場合、分布から抽出される最大の（符号付き）整数の1つ上（ &lt;code&gt;high=None&lt;/code&gt; の場合の動作については上記を参照）。配列のような場合、整数値を含める必要があります</target>
        </trans-unit>
        <trans-unit id="95838d6d878826fc55d5a3e35ced6032cc48a529" translate="yes" xml:space="preserve">
          <source>If provided, the calculation is done into this array.</source>
          <target state="translated">指定された場合は、この配列に計算が行われます。</target>
        </trans-unit>
        <trans-unit id="ea0c1f6bb199f46cbf91a8a029c842a1c97612d0" translate="yes" xml:space="preserve">
          <source>If provided, the destination array will have this dtype. Cannot be provided together with &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">指定した場合、宛先配列はこのdtypeになります。一緒に提供することはできません &lt;code&gt;out&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af1a016b36ff8a1ba521445122b451501db1dbf6" translate="yes" xml:space="preserve">
          <source>If provided, the destination to place the result. The shape must be correct, matching that of what concatenate would have returned if no out argument were specified.</source>
          <target state="translated">指定された場合は、結果を配置する先を指定します。out 引数が指定されていない場合に concatenate が返す形と一致する、正しい形でなければなりません。</target>
        </trans-unit>
        <trans-unit id="c1c663fe8abb225f988d791716021ba47f8cdb72" translate="yes" xml:space="preserve">
          <source>If provided, the destination to place the result. The shape must be correct, matching that of what stack would have returned if no out argument were specified.</source>
          <target state="translated">指定された場合は、結果を配置する先を指定します。out 引数が指定されていない場合にスタックが返す形と一致していなければなりません。</target>
        </trans-unit>
        <trans-unit id="f5316b9b72a00d5e03e3e99cc76713f526033f92" translate="yes" xml:space="preserve">
          <source>If provided, the largest (signed) integer to be drawn from the distribution (see above for behavior if &lt;code&gt;high=None&lt;/code&gt;).</source>
          <target state="translated">提供されている場合、分布から抽出される最大の（符号付き）整数（ &lt;code&gt;high=None&lt;/code&gt; の場合の動作については上記を参照）。</target>
        </trans-unit>
        <trans-unit id="9522e8e010639b210e9e797758ab5c3b994ee6ec" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指定されている場合、結果はこの配列に挿入されます。適切な形状と&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;である必要があります。</target>
        </trans-unit>
        <trans-unit id="95c405f27ca318550aa8a5e9d68fd036459e5597" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">指定した場合、結果はこの配列に挿入されます。適切な形状と &lt;code&gt;dtype&lt;/code&gt; である必要があります。</target>
        </trans-unit>
        <trans-unit id="5aa5842b82d356df663381019439d99b6de6d45f" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype.</source>
          <target state="translated">指定された場合、結果はこの配列に挿入されます。適切な形状と dtype でなければなりません。</target>
        </trans-unit>
        <trans-unit id="cb7c8c85e64a3a49b66549989ff45cf1e28fbfc9" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype. Note that &lt;code&gt;out&lt;/code&gt; is always buffered if &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt;; use other modes for better performance.</source>
          <target state="translated">指定した場合、結果はこの配列に挿入されます。適切な形状とdtypeである必要があります。 &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; 場合、 &lt;code&gt;out&lt;/code&gt; は常にバッファリングされることに注意してください。パフォーマンスを向上させるには、他のモードを使用してください。</target>
        </trans-unit>
        <trans-unit id="81a5da5dc747b4213d85b5feaae67db0441d8c96" translate="yes" xml:space="preserve">
          <source>If provided, the result will be placed in this array. It should be of the appropriate shape and dtype. Note that &lt;code&gt;out&lt;/code&gt; is always buffered if &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt;; use other modes for better performance.</source>
          <target state="translated">指定した場合、結果はこの配列に配置されます。適切な形状とdtypeである必要があります。 &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; 場合、 &lt;code&gt;out&lt;/code&gt; は常にバッファリングされることに注意してください。パフォーマンスを向上させるには、他のモードを使用してください。</target>
        </trans-unit>
        <trans-unit id="930ff5cfb0e50021c5f5a8e94b02d45dd7e7a78b" translate="yes" xml:space="preserve">
          <source>If provided, this array is filled with the result.</source>
          <target state="translated">指定された場合、この配列は結果で満たされます。</target>
        </trans-unit>
        <trans-unit id="11fa623532ff8e1a6968612e0395b44c20331e38" translate="yes" xml:space="preserve">
          <source>If set to False, the returned array will always be readonly. Otherwise it will be writable if the original array was. It is advisable to set this to False if possible (see Notes).</source>
          <target state="translated">False に設定されている場合、返される配列は常に読み取り専用となります。それ以外の場合は、元の配列がそうであれば書き込み可能になります。可能であれば、これを False に設定することをお勧めします (注意事項を参照してください)。</target>
        </trans-unit>
        <trans-unit id="2bff5e445257625fab4df9171fbb5cbef9e23081" translate="yes" xml:space="preserve">
          <source>If set to the string &lt;code&gt;&amp;lsquo;1.13&amp;rsquo;&lt;/code&gt; enables 1.13 legacy printing mode. This approximates numpy 1.13 print output by including a space in the sign position of floats and different behavior for 0d arrays. If set to &lt;code&gt;False&lt;/code&gt;, disables legacy mode. Unrecognized strings will be ignored with a warning for forward compatibility.</source>
          <target state="translated">文字列 &lt;code&gt;&amp;lsquo;1.13&amp;rsquo;&lt;/code&gt; 設定すると、1.13レガシー印刷モードが有効になります。これは、浮動小数点数の符号位置にスペースを含めることでnumpy 1.13の印刷出力を近似し、0d配列のさまざまな動作を示します。 &lt;code&gt;False&lt;/code&gt; に設定すると、レガシーモードが無効になります。認識されない文字列は無視され、上位互換性のための警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="fe72d8f764239876f5476ff64d033c4aa157117d" translate="yes" xml:space="preserve">
          <source>If slice notation is used, the syntax &lt;code&gt;start:stop:step&lt;/code&gt; is equivalent to &lt;code&gt;np.arange(start, stop, step)&lt;/code&gt; inside of the brackets. However, if &lt;code&gt;step&lt;/code&gt; is an imaginary number (i.e. 100j) then its integer portion is interpreted as a number-of-points desired and the start and stop are inclusive. In other words &lt;code&gt;start:stop:stepj&lt;/code&gt; is interpreted as &lt;code&gt;np.linspace(start, stop, step, endpoint=1)&lt;/code&gt; inside of the brackets. After expansion of slice notation, all comma separated sequences are concatenated together.</source>
          <target state="translated">スライス表記を使用する場合、構文 &lt;code&gt;start:stop:step&lt;/code&gt; は、括弧内の &lt;code&gt;np.arange(start, stop, step)&lt;/code&gt; と同等です。ただし、 &lt;code&gt;step&lt;/code&gt; が虚数（つまり100j）の場合、その整数部分は必要なポイント数として解釈され、開始と停止は包括的です。つまり、 &lt;code&gt;start:stop:stepj&lt;/code&gt; は、括弧内の &lt;code&gt;np.linspace(start, stop, step, endpoint=1)&lt;/code&gt; として解釈されます。スライス表記の拡張後、すべてのコンマ区切りのシーケンスが一緒に連結されます。</target>
        </trans-unit>
        <trans-unit id="d852188873e81a9c252d600a61b8e6669ecb8d51" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected (and &lt;a href=&quot;numpy.full#numpy.full&quot;&gt;&lt;code&gt;full&lt;/code&gt;&lt;/a&gt; == &lt;code&gt;False&lt;/code&gt;), a &lt;a href=&quot;numpy.rankwarning#numpy.RankWarning&quot;&gt;&lt;code&gt;RankWarning&lt;/code&gt;&lt;/a&gt; will be raised. This means that the coefficient values may be poorly determined. Fitting to a lower order polynomial will usually get rid of the warning (but may not be what you want, of course; if you have independent reason(s) for choosing the degree which isn&amp;rsquo;t working, you may have to: a) reconsider those reasons, and/or b) reconsider the quality of your data). The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; の特異値のいくつかが小さすぎて無視される（そして&lt;a href=&quot;numpy.full#numpy.full&quot;&gt; &lt;code&gt;full&lt;/code&gt; &lt;/a&gt;== &lt;code&gt;False&lt;/code&gt; ）場合、&lt;a href=&quot;numpy.rankwarning#numpy.RankWarning&quot;&gt; &lt;code&gt;RankWarning&lt;/code&gt; &lt;/a&gt;が発生します。これは、係数値が適切に決定されていない可能性があることを意味します。低次の多項式に適合させると、通常、警告が削除されます（ただし、もちろん、希望するものではない場合があります。機能していない次数を選択する独立した理由がある場合は、次のことを行う必要があります。a）これらの理由を再検討する、および/またはb）データの品質を再検討する）。 &lt;code&gt;rcond&lt;/code&gt; パラメータも、デフォルトよりも小さい値に設定することができますが、結果のフィットは、スプリアスことと丸め誤差から大きな貢献を持っていることがあります。</target>
        </trans-unit>
        <trans-unit id="81a87ade0c2eb6eb2f3e1b57567f9837157177e2" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected (and &lt;code&gt;full&lt;/code&gt; == &lt;code&gt;False&lt;/code&gt;), a &lt;code&gt;RankWarning&lt;/code&gt; will be raised. This means that the coefficient values may be poorly determined. Fitting to a lower order polynomial will usually get rid of the warning (but may not be what you want, of course; if you have independent reason(s) for choosing the degree which isn&amp;rsquo;t working, you may have to: a) reconsider those reasons, and/or b) reconsider the quality of your data). The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; の特異値の一部が無視されるほど小さい（および &lt;code&gt;full&lt;/code&gt; == &lt;code&gt;False&lt;/code&gt; ）場合、 &lt;code&gt;RankWarning&lt;/code&gt; が発生します。これは、係数値が十分に決定されていない可能性があることを意味します。低次の多項式に当てはめると、通常は警告が表示されなくなります（もちろん、期待どおりではない場合があります。機能していない次数を選択する独立した理由がある場合は、次のことを行う必要があります：a）それらの理由を再検討し、および/またはb）データの品質を再検討します。 &lt;code&gt;rcond&lt;/code&gt; パラメータも、デフォルトよりも小さい値に設定することができますが、結果のフィットは、スプリアスことと丸め誤差から大きな貢献を持っていることがあります。</target>
        </trans-unit>
        <trans-unit id="0219410592b277d18d42730ec323b9fe9d5cac7f" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected, then a &lt;a href=&quot;numpy.rankwarning#numpy.RankWarning&quot;&gt;&lt;code&gt;RankWarning&lt;/code&gt;&lt;/a&gt; will be issued. This means that the coefficient values may be poorly determined. Using a lower order fit will usually get rid of the warning. The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; の特異値の一部が&lt;a href=&quot;numpy.rankwarning#numpy.RankWarning&quot;&gt; &lt;code&gt;RankWarning&lt;/code&gt; &lt;/a&gt;て無視される場合、RankWarningが発行されます。これは、係数値が適切に決定されていない可能性があることを意味します。低次のフィットを使用すると、通常、警告が表示されなくなります。 &lt;code&gt;rcond&lt;/code&gt; パラメータも、デフォルトよりも小さい値に設定することができますが、結果のフィットは、スプリアスことと丸め誤差から大きな貢献を持っていることがあります。</target>
        </trans-unit>
        <trans-unit id="279580d9404d9230f24c863b3bff92a3996533c2" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected, then a &lt;code&gt;RankWarning&lt;/code&gt; will be issued. This means that the coefficient values may be poorly determined. Using a lower order fit will usually get rid of the warning. The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; の特異値の一部が無視されるほど小さい場合、 &lt;code&gt;RankWarning&lt;/code&gt; が発行されます。これは、係数値が十分に決定されていない可能性があることを意味します。低次の近似を使用すると、通常、警告が表示されなくなります。 &lt;code&gt;rcond&lt;/code&gt; パラメータも、デフォルトよりも小さい値に設定することができますが、結果のフィットは、スプリアスことと丸め誤差から大きな貢献を持っていることがあります。</target>
        </trans-unit>
        <trans-unit id="965baa6e6f17f07c36f67c069da20d4c8b056bfe" translate="yes" xml:space="preserve">
          <source>If sparse is False:</source>
          <target state="translated">sparseがFalseの場合。</target>
        </trans-unit>
        <trans-unit id="d3cfaef438df28358b3d4e747b777d350c839464" translate="yes" xml:space="preserve">
          <source>If sparse is True:</source>
          <target state="translated">sparseがTrueの場合。</target>
        </trans-unit>
        <trans-unit id="da499c4730990d0eca07f07d81ecedd5eee01e35" translate="yes" xml:space="preserve">
          <source>If sparse is set to true, the grid will be returned in a sparse representation.</source>
          <target state="translated">sparseがtrueに設定されている場合、グリッドは疎な表現で返されます。</target>
        </trans-unit>
        <trans-unit id="a0b2e0085e9bacd8c444b0a0e2e8508a5f8b81ab" translate="yes" xml:space="preserve">
          <source>If specified, all the fields will be changed to the provided byte-order. Otherwise, the default byte-order is used. For all available string specifiers, see &lt;a href=&quot;numpy.dtype.newbyteorder#numpy.dtype.newbyteorder&quot;&gt;&lt;code&gt;dtype.newbyteorder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指定した場合、すべてのフィールドが指定されたバイト順に変更されます。それ以外の場合は、デフォルトのバイト順が使用されます。使用可能なすべての文字列指定子については、&lt;a href=&quot;numpy.dtype.newbyteorder#numpy.dtype.newbyteorder&quot;&gt; &lt;code&gt;dtype.newbyteorder&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="524227865d52e8b4442de30061c3ce0262f46831" translate="yes" xml:space="preserve">
          <source>If specified, it must be a tuple or list which contains a permutation of [0,1,..,N-1] where N is the number of axes of a. The i&amp;rsquo;th axis of the returned array will correspond to the axis numbered &lt;code&gt;axes[i]&lt;/code&gt; of the input. If not specified, defaults to &lt;code&gt;range(a.ndim)[::-1]&lt;/code&gt;, which reverses the order of the axes.</source>
          <target state="translated">指定する場合は、[0,1、..、N-1]の順列を含むタプルまたはリストである必要があります。ここで、Nはaの軸の数です。返される配列のi番目の軸は、入力の軸番号付きの &lt;code&gt;axes[i]&lt;/code&gt; に対応します。指定しない場合、デフォルトは &lt;code&gt;range(a.ndim)[::-1]&lt;/code&gt; になり、軸の順序が逆になります。</target>
        </trans-unit>
        <trans-unit id="f824fc5934f1c56555b7168823af2d5da98b5dab" translate="yes" xml:space="preserve">
          <source>If state is a dictionary, it is directly set using the BitGenerators &lt;code&gt;state&lt;/code&gt; property.</source>
          <target state="translated">状態が辞書の場合、BitGenerators &lt;code&gt;state&lt;/code&gt; プロパティを使用して直接設定されます。</target>
        </trans-unit>
        <trans-unit id="8bed509b136f4d80f9b83488488a97c842996d12" translate="yes" xml:space="preserve">
          <source>If steps 1 and 2 are done correctly, compiling the release should not give a warning &amp;ldquo;API mismatch detect at the beginning of the build&amp;rdquo;.</source>
          <target state="translated">手順1と2が正しく行われていれば、リリースをコンパイルしても「ビルドの開始時にAPIの不一致が検出されました」という警告が表示されないはずです。</target>
        </trans-unit>
        <trans-unit id="ebc779ce22e3bc8704e258c3f6aa49989598231f" translate="yes" xml:space="preserve">
          <source>If the (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flags are set, it has a different meaning, namely base is the array into which the current array will be copied upon copy resolution. This overloading of the base property for two functions is likely to change in a future version of NumPy.</source>
          <target state="translated">（非推奨）&lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;フラグまたは&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;フラグが設定されている場合、フラグの意味は異なります。つまり、ベースは、コピーの解決時に現在の配列がコピーされる配列です。この2つの関数の基本プロパティのオーバーロードは、NumPyの将来のバージョンで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="cfe3d233f0d1b6d420d00f98b03a5ffbba4bbec2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; attribute is a CObject, then the pointer must be a pointer to a function with the signature:</source>
          <target state="translated">場合&lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_finalize__&quot;&gt; &lt;code&gt;__array_finalize__&lt;/code&gt; &lt;/a&gt;属性がCObjectのある、そしてポインタは、署名を持つ関数へのポインタでなければなりません。</target>
        </trans-unit>
        <trans-unit id="b7883df78258ee376bc6906db165b3539bd009bc" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; attribute is not None nor a CObject, then it must be a Python method that takes the parent array as an argument (which could be None if there is no parent), and returns nothing. Errors in this method will be caught and handled.</source>
          <target state="translated">&lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_finalize__&quot;&gt; &lt;code&gt;__array_finalize__&lt;/code&gt; &lt;/a&gt;属性がNoneでもCObjectでもない場合は、親配列を引数として取り（親がない場合はNoneになる可能性があります）、何も返さないPythonメソッドである必要があります。このメソッドのエラーはキャッチされ、処理されます。</target>
        </trans-unit>
        <trans-unit id="35bc1249e520730be2802640a0588a9755304660" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; object is a structured array the &lt;a href=&quot;../glossary#term-field&quot;&gt;fields&lt;/a&gt; of the array can be accessed by indexing the array with strings, dictionary-like.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;オブジェクトが構造化配列の場合、配列の&lt;a href=&quot;../glossary#term-field&quot;&gt;フィールド&lt;/a&gt;には、辞書のように文字列で配列にインデックスを付けることでアクセスできます。</target>
        </trans-unit>
        <trans-unit id="6f501c2023177671c00839603f74082e5dd3d055" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; object is a structured array the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;fields&lt;/a&gt; of the array can be accessed by indexing the array with strings, dictionary-like.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;オブジェクトが構造化配列である場合、配列の&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;フィールド&lt;/a&gt;には、辞書のように文字列で配列にインデックスを付けることでアクセスできます。</target>
        </trans-unit>
        <trans-unit id="0646be9a4620b324160297ec7386ae7d381a6d92" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;order&lt;/code&gt; keyword argument is specified. This behaviour is a bug in NumPy.</source>
          <target state="translated">場合は &lt;code&gt;order&lt;/code&gt; キーワード引数が指定されています。この動作はNumPyのバグです。</target>
        </trans-unit>
        <trans-unit id="95474ba24abf246463d023b7d37164eff549d001" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;width&lt;/code&gt; value is insufficient, it will be ignored, and &lt;code&gt;num&lt;/code&gt; will be returned in binary (&lt;code&gt;num&lt;/code&gt; &amp;gt; 0) or two&amp;rsquo;s complement (&lt;code&gt;num&lt;/code&gt; &amp;lt; 0) form with its width equal to the minimum number of bits needed to represent the number in the designated form. This behavior is deprecated and will later raise an error.</source>
          <target state="translated">&lt;code&gt;width&lt;/code&gt; 値が不十分な場合、その値は無視され、 &lt;code&gt;num&lt;/code&gt; はバイナリ（ &lt;code&gt;num&lt;/code&gt; &amp;gt; 0）または2の補数（ &lt;code&gt;num&lt;/code&gt; &amp;lt;0）形式で返されます。その幅は、数値を表すのに必要な最小ビット数と同じです。指定されたフォーム。この動作は非推奨であり、後でエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="e55f68c7edc654033798e55316d9b9691f5ca17e" translate="yes" xml:space="preserve">
          <source>If the API has changed, increment the C_API_VERSION in setup_common.py. The API is unchanged only if any code compiled against the current API will be backward compatible with the last released NumPy version. Any changes to C structures or additions to the public interface will make the new API not backward compatible.</source>
          <target state="translated">APIが変更されている場合は、setup_common.pyのC_API_VERSIONをインクリメントしてください。現在のAPIに対してコンパイルされたコードが、最後にリリースされたNumPyのバージョンと下位互換性がある場合にのみ、APIは変更されません。C構造の変更やパブリックインターフェースへの追加は、新しいAPIを下位互換性のないものにします。</target>
        </trans-unit>
        <trans-unit id="e8d9f657403ca89274645800f9ef39c0a2acef7a" translate="yes" xml:space="preserve">
          <source>If the CPU feature is not supported by the user platform or compiler, it will be skipped rather than raising a fatal error.</source>
          <target state="translated">CPUの機能がユーザープラットフォームやコンパイラでサポートされていない場合、致命的なエラーが発生するのではなく、スキップされます。</target>
        </trans-unit>
        <trans-unit id="846345b681ee07e5dd05c26de91938c5750e96ed" translate="yes" xml:space="preserve">
          <source>If the C_API_VERSION in the first step has changed, or if the hash of the API has changed, the cversions.txt file needs to be updated. To check the hash, run the script numpy/core/cversions.py and note the API hash that is printed. If that hash does not match the last hash in numpy/core/code_generators/cversions.txt the hash has changed. Using both the appropriate C_API_VERSION and hash, add a new entry to cversions.txt. If the API version was not changed, but the hash differs, you will need to comment out the previous entry for that API version. For instance, in NumPy 1.9 annotations were added, which changed the hash, but the API was the same as in 1.8. The hash serves as a check for API changes, but it is not definitive.</source>
          <target state="translated">最初のステップのC_API_VERSIONが変更されている場合や、APIのハッシュが変更されている場合は、cversions.txtファイルを更新する必要があります。ハッシュを確認するには、numpy/core/cversions.pyスクリプトを実行し、表示されるAPIハッシュをメモします。そのハッシュが numpy/core/code_generators/cversions.txt の最後のハッシュと一致しない場合は、ハッシュが変更されています。適切なC_API_VERSIONとハッシュの両方を使用して、cversions.txtに新しいエントリを追加します。APIのバージョンが変更されていないが、ハッシュが異なる場合は、そのAPIバージョンの前のエントリをコメントアウトする必要があります。例えば、NumPy 1.9ではアノテーションが追加され、ハッシュは変更されましたが、APIは1.8と同じでした。ハッシュはAPIの変更をチェックする役割を果たしますが、決定的なものではありません。</target>
        </trans-unit>
        <trans-unit id="307258bcc851f5976aadd2f56343dad80fcf2a38" translate="yes" xml:space="preserve">
          <source>If the PR relates to any issues, you can add the text &lt;code&gt;xref gh-xxxx&lt;/code&gt; where &lt;code&gt;xxxx&lt;/code&gt; is the number of the issue to github comments. Likewise, if the PR solves an issue, replace the &lt;code&gt;xref&lt;/code&gt; with &lt;code&gt;closes&lt;/code&gt;, &lt;code&gt;fixes&lt;/code&gt; or any of the other flavors &lt;a href=&quot;https://help.github.com/en/articles/closing-issues-using-keywords&quot;&gt;github accepts&lt;/a&gt;.</source>
          <target state="translated">PRが問題に関連している場合は、テキスト &lt;code&gt;xref gh-xxxx&lt;/code&gt; を追加できます。ここで、 &lt;code&gt;xxxx&lt;/code&gt; は問題の番号です。githubコメントに追加します。同様に、PRで問題が解決した場合は、 &lt;code&gt;xref&lt;/code&gt; を &lt;code&gt;closes&lt;/code&gt; 、 &lt;code&gt;fixes&lt;/code&gt; 、または&lt;a href=&quot;https://help.github.com/en/articles/closing-issues-using-keywords&quot;&gt;githubが受け入れる&lt;/a&gt;その他のフレーバーに置き換えます。</target>
        </trans-unit>
        <trans-unit id="049594537957d0705cc457b562940a40a3ed3347" translate="yes" xml:space="preserve">
          <source>If the SVD computation does not converge.</source>
          <target state="translated">SVD計算が収束しない場合。</target>
        </trans-unit>
        <trans-unit id="532b7abf588e485b512986621b48cdfb34aabd33" translate="yes" xml:space="preserve">
          <source>If the Sphinx build issues a warning of the form &lt;code&gt;WARNING: Unknown target name: &quot;example&quot;&lt;/code&gt;, then that is what is happening. To avoid this problem, use the inline hyperlink form:</source>
          <target state="translated">Sphinxビルドが &lt;code&gt;WARNING: Unknown target name: &quot;example&quot;&lt;/code&gt; 形式の警告を発行した場合、それが発生しています。この問題を回避するには、インラインハイパーリンクフォームを使用します。</target>
        </trans-unit>
        <trans-unit id="64f36babe99dcf796b7778a9ef584cf09c04cb03" translate="yes" xml:space="preserve">
          <source>If the accessed field is a sub-array, the dimensions of the sub-array are appended to the shape of the result.</source>
          <target state="translated">アクセスされたフィールドが部分配列の場合、その部分配列の寸法が結果の形状に追加されます。</target>
        </trans-unit>
        <trans-unit id="7e63ccdf53ce8ac8b2fb2a0fbc4aad1e23cbc4dc" translate="yes" xml:space="preserve">
          <source>If the accessed field is a subarray, the dimensions of the subarray are appended to the shape of the result:</source>
          <target state="translated">アクセスされたフィールドが部分配列の場合、その部分配列の寸法が結果の形状に追加されます。</target>
        </trans-unit>
        <trans-unit id="ba28bd784223a2a08bea18d126c6d98be59cd057" translate="yes" xml:space="preserve">
          <source>If the accumulator is too small, overflow occurs:</source>
          <target state="translated">アキュムレータが小さすぎるとオーバーフローが発生します。</target>
        </trans-unit>
        <trans-unit id="f2dce957332c62c691a49ddcc68e31de7ff97f8b" translate="yes" xml:space="preserve">
          <source>If the array has no mask, the address of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is returned. This address is typically not close to the data in memory:</source>
          <target state="translated">配列にマスクがない場合、&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;のアドレスが返されます。このアドレスは通常、メモリ内のデータに近くありません。</target>
        </trans-unit>
        <trans-unit id="d51f2eaee63f2842d7a7119019788b97cb6ca340" translate="yes" xml:space="preserve">
          <source>If the array has no mask, the address of &lt;code&gt;nomask&lt;/code&gt; is returned. This address is typically not close to the data in memory:</source>
          <target state="translated">配列にマスクがない場合は、 &lt;code&gt;nomask&lt;/code&gt; のアドレスが返されます。このアドレスは通常、メモリ内のデータに近くありません。</target>
        </trans-unit>
        <trans-unit id="0e4bd5d4fdacecd1895716db48cb1cac490ae19c" translate="yes" xml:space="preserve">
          <source>If the array is not compatible with the new shape according to NumPy&amp;rsquo;s broadcasting rules.</source>
          <target state="translated">NumPyのブロードキャストルールに従って、配列が新しい形状と互換性がない場合。</target>
        </trans-unit>
        <trans-unit id="1b3a1026c96ba9547fc879c6163e5467ed414876" translate="yes" xml:space="preserve">
          <source>If the axis argument isn&amp;rsquo;t passed, your 2D array will be flattened.</source>
          <target state="translated">axis引数が渡されない場合、2D配列はフラット化されます。</target>
        </trans-unit>
        <trans-unit id="9556db7609e9b52c8da71258e9ebc1e23d97b8b8" translate="yes" xml:space="preserve">
          <source>If the buffer has data that is not in machine byte-order, this should be specified as part of the data-type, e.g.:</source>
          <target state="translated">バッファにマシンバイト順ではないデータがある場合は、データタイプの一部として指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="707be1af574eabd0a2204881f5336941a1d0fb1f" translate="yes" xml:space="preserve">
          <source>If the columns have names, we can also select which columns to import by giving their name to the &lt;code&gt;usecols&lt;/code&gt; argument, either as a sequence of strings or a comma-separated string:</source>
          <target state="translated">列に名前がある場合は、文字列のシーケンスまたはコンマ区切りの文字列として &lt;code&gt;usecols&lt;/code&gt; 引数に名前を付けることで、インポートする列を選択することもできます。</target>
        </trans-unit>
        <trans-unit id="a9172eee727e3bc5966a060de8a7a54e3be2870d" translate="yes" xml:space="preserve">
          <source>If the common data type is known ahead of time, don&amp;rsquo;t use this flag. Instead, set the requested dtype for all the operands.</source>
          <target state="translated">一般的なデータタイプが事前にわかっている場合は、このフラグを使用しないでください。代わりに、要求されたdtypeをすべてのオペランドに設定します。</target>
        </trans-unit>
        <trans-unit id="c0b42d9b2195e628dbcfcb8e55fe0f75a169d8db" translate="yes" xml:space="preserve">
          <source>If the condition is a callable, it is used at runtime to dynamically make the decision. This is useful for tests that may require costly imports, to delay the cost until the test suite is actually executed.</source>
          <target state="translated">条件が呼び出し可能なものであれば、実行時に動的に決定を行うために使用されます。これは、テストスイートが実際に実行されるまでコストを遅らせるために、コストのかかるインポートを必要とする可能性のあるテストに便利です。</target>
        </trans-unit>
        <trans-unit id="da8929bf843323251f47496e7bd27572472297dd" translate="yes" xml:space="preserve">
          <source>If the conversion is not possible</source>
          <target state="translated">変換ができない場合</target>
        </trans-unit>
        <trans-unit id="bf41eeaf999250f9cdaa16bd479da6c16a96c8f5" translate="yes" xml:space="preserve">
          <source>If the ctypes module is not available, then the ctypes attribute of array objects still returns something useful, but ctypes objects are not returned and errors may be raised instead. In particular, the object will still have the &lt;code&gt;as_parameter&lt;/code&gt; attribute which will return an integer equal to the data attribute.</source>
          <target state="translated">ctypesモジュールが利用できない場合でも、配列オブジェクトのctypes属性は有用なものを返しますが、ctypesオブジェクトは返されず、代わりにエラーが発生する可能性があります。特に、オブジェクトには &lt;code&gt;as_parameter&lt;/code&gt; 属性があり、data属性と等しい整数を返します。</target>
        </trans-unit>
        <trans-unit id="882469c86c3e266d61a4e68ca724a4e1e6d70bb9" translate="yes" xml:space="preserve">
          <source>If the current domain is the interval &lt;code&gt;[l1, r1]&lt;/code&gt; and the window is &lt;code&gt;[l2, r2]&lt;/code&gt;, then the linear mapping function &lt;code&gt;L&lt;/code&gt; is defined by the equations:</source>
          <target state="translated">現在のドメインが区間 &lt;code&gt;[l1, r1]&lt;/code&gt; で、ウィンドウが &lt;code&gt;[l2, r2]&lt;/code&gt; 場合、線形マッピング関数 &lt;code&gt;L&lt;/code&gt; は次の方程式で定義されます。</target>
        </trans-unit>
        <trans-unit id="4ed8629dcca88646587124e3779205aed8a1ff8c" translate="yes" xml:space="preserve">
          <source>If the data or the mode is invalid.</source>
          <target state="translated">データやモードが無効な場合</target>
        </trans-unit>
        <trans-unit id="74cde2bcb160b06069d73cce52e519943212158c" translate="yes" xml:space="preserve">
          <source>If the data type is &lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, an aggregate of other data types, (&lt;em&gt;e.g.&lt;/em&gt;, describing an array item consisting of an integer and a float),</source>
          <target state="translated">データ型が&lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;構造化データ型&lt;/a&gt;である場合、他のデータ型の集合体（&lt;em&gt;たとえば&lt;/em&gt;、整数と浮動小数点数で構成される配列項目の記述）、</target>
        </trans-unit>
        <trans-unit id="b7e4177a6acaf9fb51b7f55a4c29b9a1f7f66006" translate="yes" xml:space="preserve">
          <source>If the data type is &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, an aggregate of other data types, (&lt;em&gt;e.g.&lt;/em&gt;, describing an array item consisting of an integer and a float),</source>
          <target state="translated">データ型が&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;構造化データ型&lt;/a&gt;である場合、他のデータ型の集約（&lt;em&gt;たとえば&lt;/em&gt;、整数と浮動小数点で構成される配列項目を記述する）、</target>
        </trans-unit>
        <trans-unit id="0cecddf950b77d1003b9474189d29ff0bfdb6282" translate="yes" xml:space="preserve">
          <source>If the data type is a sub-array, what is its shape and data type.</source>
          <target state="translated">データ型が部分配列の場合、その形状とデータ型は?</target>
        </trans-unit>
        <trans-unit id="5b7ff57105753a62bcfc1055c91f35344e435758" translate="yes" xml:space="preserve">
          <source>If the decomposition fails, for example, if &lt;code&gt;a&lt;/code&gt; is not positive-definite.</source>
          <target state="translated">分解が失敗した場合、たとえば、 &lt;code&gt;a&lt;/code&gt; が正定でない場合。</target>
        </trans-unit>
        <trans-unit id="ee52413e2abf8d484ea3208ee7d3358a43d8e634" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.all&quot;&gt;&lt;code&gt;all&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">デフォルト値が渡された場合、その後、 &lt;code&gt;keepdims&lt;/code&gt; はに渡されることはありません&lt;a href=&quot;#numpy.all&quot;&gt; &lt;code&gt;all&lt;/code&gt; &lt;/a&gt;のサブクラスの方法&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;、しかし、任意のデフォルト以外の値になります。サブクラスのメソッドが &lt;code&gt;keepdims&lt;/code&gt; を実装しない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="206ca5be0da6c825b1f0142de708ea22958f4d55" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.amax&quot;&gt;&lt;code&gt;amax&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">デフォルト値が渡された場合、その後、 &lt;code&gt;keepdims&lt;/code&gt; はに渡されることはありません&lt;a href=&quot;#numpy.amax&quot;&gt; &lt;code&gt;amax&lt;/code&gt; &lt;/a&gt;のサブクラスの方法&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;、しかし、任意のデフォルト以外の値になります。サブクラスのメソッドが &lt;code&gt;keepdims&lt;/code&gt; を実装しない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="f05780b3efb83cb7999e12324775e7fa0e8c55fe" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.amin&quot;&gt;&lt;code&gt;amin&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">デフォルト値が渡された場合、その後、 &lt;code&gt;keepdims&lt;/code&gt; はに渡されることはありません&lt;a href=&quot;#numpy.amin&quot;&gt; &lt;code&gt;amin&lt;/code&gt; &lt;/a&gt;のサブクラスの方法&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;、しかし、任意のデフォルト以外の値になります。サブクラスのメソッドが &lt;code&gt;keepdims&lt;/code&gt; を実装しない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="4bb758877f868372bd36b970799d233d6c9b6b2e" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">デフォルト値が渡された場合、その後、 &lt;code&gt;keepdims&lt;/code&gt; はに渡されることはありません&lt;a href=&quot;#numpy.any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt;のサブクラスの方法&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;、しかし、任意のデフォルト以外の値になります。サブクラスのメソッドが &lt;code&gt;keepdims&lt;/code&gt; を実装しない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="4f36bf742dff79ee7a2535335e60a655538367af" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.ma.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;code&gt;ndarray&lt;/code&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">デフォルト値が渡された場合、その後、 &lt;code&gt;keepdims&lt;/code&gt; はに渡されることはありません&lt;a href=&quot;#numpy.ma.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt;のサブクラスの方法 &lt;code&gt;ndarray&lt;/code&gt; 、しかし、任意のデフォルト以外の値になります。サブクラスのメソッドが &lt;code&gt;keepdims&lt;/code&gt; を実装しない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="e936312beb89ed94ea31f46b832a3128132ea8c3" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">デフォルト値が渡された場合、その後、 &lt;code&gt;keepdims&lt;/code&gt; はに渡されることはありません&lt;a href=&quot;#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt;のサブクラスの方法&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;、しかし、任意のデフォルト以外の値になります。サブクラスのメソッドが &lt;code&gt;keepdims&lt;/code&gt; を実装しない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="cccfcc112e296f9db67affb5426a407a1e1b1ab3" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">デフォルト値が渡された場合、その後、 &lt;code&gt;keepdims&lt;/code&gt; はに渡されることはありません&lt;a href=&quot;#numpy.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt;のサブクラスの方法&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;、しかし、任意のデフォルト以外の値になります。サブクラスのメソッドが &lt;code&gt;keepdims&lt;/code&gt; を実装しない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="f6aec8996590d19051796274c83c4f7439695ce8" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.ptp&quot;&gt;&lt;code&gt;ptp&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">デフォルト値が渡された場合、その後、 &lt;code&gt;keepdims&lt;/code&gt; はに渡されることはありません&lt;a href=&quot;#numpy.ptp&quot;&gt; &lt;code&gt;ptp&lt;/code&gt; &lt;/a&gt;のサブクラスの方法&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;、しかし、任意のデフォルト以外の値になります。サブクラスのメソッドが &lt;code&gt;keepdims&lt;/code&gt; を実装しない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="04b4fba4bb9497e64959763e9e88bb419b385930" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">デフォルト値が渡された場合、その後、 &lt;code&gt;keepdims&lt;/code&gt; はに渡されることはありません&lt;a href=&quot;#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt;のサブクラスの方法&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;、しかし、任意のデフォルト以外の値になります。サブクラスのメソッドが &lt;code&gt;keepdims&lt;/code&gt; を実装しない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="3ec6e98470abd2d3a8abe5e8029889dd09ba623f" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">デフォルト値が渡された場合、その後、 &lt;code&gt;keepdims&lt;/code&gt; はに渡されることはありません&lt;a href=&quot;#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt;のサブクラスの方法&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;、しかし、任意のデフォルト以外の値になります。サブクラスのメソッドが &lt;code&gt;keepdims&lt;/code&gt; を実装しない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="2d09798a597d9e0c839ab8917b5d5016554acbc8" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">デフォルト値が渡された場合、その後、 &lt;code&gt;keepdims&lt;/code&gt; はに渡されることはありません&lt;a href=&quot;#numpy.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt;のサブクラスの方法&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;、しかし、任意のデフォルト以外の値になります。サブクラスのメソッドが &lt;code&gt;keepdims&lt;/code&gt; を実装しない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="83795d27b8fbf6727fc73ba1d3ba1433b7f48097" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;numpy.ma.var#numpy.ma.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;code&gt;ndarray&lt;/code&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">デフォルト値が渡された場合、その後、 &lt;code&gt;keepdims&lt;/code&gt; はに渡されることはありません&lt;a href=&quot;numpy.ma.var#numpy.ma.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt;のサブクラスの方法 &lt;code&gt;ndarray&lt;/code&gt; 、しかし、任意のデフォルト以外の値になります。サブクラスのメソッドが &lt;code&gt;keepdims&lt;/code&gt; を実装しない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="3a3ccfe6612fdaf74f2303bcfe7218060615e3b7" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;numpy.var#numpy.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">デフォルト値が渡された場合、その後、 &lt;code&gt;keepdims&lt;/code&gt; はに渡されることはありません&lt;a href=&quot;numpy.var#numpy.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt;のサブクラスの方法&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;、しかし、任意のデフォルト以外の値になります。サブクラスのメソッドが &lt;code&gt;keepdims&lt;/code&gt; を実装していない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="f36f9bb6a297ac4fc949ef700d42398954026ba5" translate="yes" xml:space="preserve">
          <source>If the dimension of &lt;code&gt;a&lt;/code&gt; is less than 2.</source>
          <target state="translated">大きさならば2未満です。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a923921d01ae62bb1aaf773e7e11bc37201f68aa" translate="yes" xml:space="preserve">
          <source>If the discontinuity in &lt;code&gt;p&lt;/code&gt; is smaller than &lt;code&gt;pi&lt;/code&gt;, but larger than &lt;code&gt;discont&lt;/code&gt;, no unwrapping is done because taking the 2*pi complement would only make the discontinuity larger.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; の不連続性が &lt;code&gt;pi&lt;/code&gt; より小さく、 &lt;code&gt;discont&lt;/code&gt; よりも大きい場合、2 * pi補数をとると不連続性が大きくなるだけなので、アンラップは行われません。</target>
        </trans-unit>
        <trans-unit id="dd1746ba40294ba18df6698853992dfa2b70977c" translate="yes" xml:space="preserve">
          <source>If the dtypes of two void structured arrays are equal, testing the equality of the arrays will result in a boolean array with the dimensions of the original arrays, with elements set to &lt;code&gt;True&lt;/code&gt; where all fields of the corresponding structures are equal. Structured dtypes are equal if the field names, dtypes and titles are the same, ignoring endianness, and the fields are in the same order:</source>
          <target state="translated">2つのvoid構造化配列のdtypeが等しい場合、配列の同等性をテストすると、元の配列の次元を持つブール配列が生成され、対応する構造のすべてのフィールドが等しい要素が &lt;code&gt;True&lt;/code&gt; に設定されます。構造化されたdtypeは、フィールド名、dtype、およびタイトルが同じで、エンディアンを無視し、フィールドが同じ順序である場合に等しくなります。</target>
        </trans-unit>
        <trans-unit id="769e103ab2e97d0544e3e9203d0c4335be336adf" translate="yes" xml:space="preserve">
          <source>If the eigenvalue computation does not converge.</source>
          <target state="translated">固有値計算が収束しない場合。</target>
        </trans-unit>
        <trans-unit id="18adc01c0eaa64bd3fe6f5b836944558dd579c54" translate="yes" xml:space="preserve">
          <source>If the element you&amp;rsquo;re looking for doesn&amp;rsquo;t exist in the array, then the returned array of indices will be empty. For example:</source>
          <target state="translated">探している要素が配列に存在しない場合、返されるインデックスの配列は空になります。例えば：</target>
        </trans-unit>
        <trans-unit id="ae5f5ebbdda43d87574658252f8456304a3e6d83" translate="yes" xml:space="preserve">
          <source>If the file contains pickle data, then whatever object is stored in the pickle is returned.</source>
          <target state="translated">ファイルにピクルデータが含まれている場合は、ピクルに格納されているオブジェクトが何であっても返されます。</target>
        </trans-unit>
        <trans-unit id="52f9285704aeec7c0050eb73ae0eedae9e536c15" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npy&lt;/code&gt; file, then a single array is returned.</source>
          <target state="translated">ファイルが &lt;code&gt;.npy&lt;/code&gt; ファイルの場合、単一の配列が返されます。</target>
        </trans-unit>
        <trans-unit id="c850dbbea34f89942e452ade066952afb4aff87b" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npz&lt;/code&gt; file, the returned value supports the context manager protocol in a similar fashion to the open function:</source>
          <target state="translated">ファイルが &lt;code&gt;.npz&lt;/code&gt; ファイルの場合、戻り値はopen関数と同様の方法でコンテキストマネージャプロトコルをサポートします。</target>
        </trans-unit>
        <trans-unit id="6dd34773e8e6fce245333f3661e9174ce50590a5" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npz&lt;/code&gt; file, then a dictionary-like object is returned, containing &lt;code&gt;{filename: array}&lt;/code&gt; key-value pairs, one for each file in the archive.</source>
          <target state="translated">ファイルが &lt;code&gt;.npz&lt;/code&gt; ファイルの場合、アーカイブ内の各ファイルに1つずつ、 &lt;code&gt;{filename: array}&lt;/code&gt; キーと値のペアを含む辞書のようなオブジェクトが返されます。</target>
        </trans-unit>
        <trans-unit id="0a517df17f23da0350e5f4238549fbfa3ccd5684" translate="yes" xml:space="preserve">
          <source>If the file is not found or cannot be opened correctly.</source>
          <target state="translated">ファイルが見つからない、または正しく開けない場合。</target>
        </trans-unit>
        <trans-unit id="3eb136618e35fc45bcfb6109a519b0397c62a7f3" translate="yes" xml:space="preserve">
          <source>If the filename ends in &lt;code&gt;.gz&lt;/code&gt;, the file is automatically saved in compressed gzip format. &lt;a href=&quot;numpy.loadtxt#numpy.loadtxt&quot;&gt;&lt;code&gt;loadtxt&lt;/code&gt;&lt;/a&gt; understands gzipped files transparently.</source>
          <target state="translated">ファイル名が &lt;code&gt;.gz&lt;/code&gt; で終わる場合、ファイルは自動的に圧縮gzip形式で保存されます。&lt;a href=&quot;numpy.loadtxt#numpy.loadtxt&quot;&gt; &lt;code&gt;loadtxt&lt;/code&gt; &lt;/a&gt;はgzip圧縮されたファイルを透過的に理解します。</target>
        </trans-unit>
        <trans-unit id="3cd5e67735dce4fe85460703c53dc9836515a450" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D it is treated as a row vector. If the last argument is 1-D it is treated as a column vector. The other arguments must be 2-D.</source>
          <target state="translated">最初の引数が1-Dの場合は行ベクトルとして扱われます。最後の引数が1-Dの場合は列ベクトルとして扱われます。他の引数は2-Dでなければなりません。</target>
        </trans-unit>
        <trans-unit id="02ed5193bd3dcf84d786340881fcb3d577ef57f7" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D it is treated as row vector. If the last argument is 1-D it is treated as column vector. The other arguments must be 2-D.</source>
          <target state="translated">最初の引数が1-Dの場合は行ベクトルとして扱われます。最後の引数が1-Dの場合は列ベクトルとして扱われます。他の引数は2-Dでなければなりません。</target>
        </trans-unit>
        <trans-unit id="0a74c0a74431c3bd3b43bf07934fe3d61fd80338" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D, it is promoted to a matrix by prepending a 1 to its dimensions. After matrix multiplication the prepended 1 is removed.</source>
          <target state="translated">第1引数が1-Dの場合、その次元に1を前置して行列に昇格します。行列の乗算の後、前置された1は削除されます。</target>
        </trans-unit>
        <trans-unit id="89db4e5dab2cb1ce35a7fb31edd3413095e85f3c" translate="yes" xml:space="preserve">
          <source>If the first argument is a tuple, other arguments are ignored:</source>
          <target state="translated">第一引数がタプルの場合、他の引数は無視されます。</target>
        </trans-unit>
        <trans-unit id="727e22f05290aaa6c2959157d7df0bc582e3c538" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then &lt;a href=&quot;#numpy.ma.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; returns True:</source>
          <target state="translated">次の方程式が要素ごとのTrueの場合、&lt;a href=&quot;#numpy.ma.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; &lt;/a&gt;はTrueを返します。</target>
        </trans-unit>
        <trans-unit id="a4e333405efef301e87eb01476249ca72db784ba" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then &lt;a href=&quot;numpy.allclose#numpy.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; returns True:</source>
          <target state="translated">次の方程式が要素ごとにTrueの場合、&lt;a href=&quot;numpy.allclose#numpy.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; &lt;/a&gt;はTrueを返します。</target>
        </trans-unit>
        <trans-unit id="94cbab458f248cbb972811c2359461201e9861d5" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then allclose returns True.</source>
          <target state="translated">次の式が要素的にTrueであれば、allcloseはTrueを返します。</target>
        </trans-unit>
        <trans-unit id="1386561a26e41c95c312db50b7ef52259e4517da" translate="yes" xml:space="preserve">
          <source>If the given strings are equal, &lt;a href=&quot;#numpy.testing.assert_string_equal&quot;&gt;&lt;code&gt;assert_string_equal&lt;/code&gt;&lt;/a&gt; does nothing. If they are not equal, an AssertionError is raised, and the diff between the strings is shown.</source>
          <target state="translated">指定された文字列が等しい場合、&lt;a href=&quot;#numpy.testing.assert_string_equal&quot;&gt; &lt;code&gt;assert_string_equal&lt;/code&gt; &lt;/a&gt;は何もしません。それらが等しくない場合、AssertionErrorが発生し、文字列間の差分が表示されます。</target>
        </trans-unit>
        <trans-unit id="f5f5e437a85f1a89c55d54e0a09b57161df68a13" translate="yes" xml:space="preserve">
          <source>If the header file that contains the prototype for &lt;code&gt;double dot()&lt;/code&gt; also contains other prototypes that you want to wrap, so that you need to &lt;code&gt;%include&lt;/code&gt; this header file, then you will also need a &lt;code&gt;%ignore
dot;&lt;/code&gt; directive, placed after the &lt;code&gt;%rename&lt;/code&gt; and before the &lt;code&gt;%include&lt;/code&gt; directives. Or, if the function in question is a class method, you will want to use &lt;code&gt;%extend&lt;/code&gt; rather than &lt;code&gt;%inline&lt;/code&gt; in addition to &lt;code&gt;%ignore&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;double dot()&lt;/code&gt; のプロトタイプを含むヘッダーファイルに、ラップする他のプロトタイプも含まれているため &lt;code&gt;%include&lt;/code&gt; このヘッダーファイルを％includeする必要がある場合は、 &lt;code&gt;%ignore dot;&lt;/code&gt; も必要です。 &lt;code&gt;%rename&lt;/code&gt; の後、 &lt;code&gt;%include&lt;/code&gt; ディレクティブの前に配置されたディレクティブ。または、問題の関数がクラスメソッドである場合、 &lt;code&gt;%ignore&lt;/code&gt; に加えて％ &lt;code&gt;%inline&lt;/code&gt; ではなく &lt;code&gt;%extend&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="7e4a3d5e2d4e2e2a3ebb889979e38306c67da7f4" translate="yes" xml:space="preserve">
          <source>If the index arrays do not have the same shape, there is an attempt to broadcast them to the same shape. If they cannot be broadcast to the same shape, an exception is raised:</source>
          <target state="translated">インデックス配列が同じ形をしていない場合は,それらを同じ形にブロードキャストしようとします.同じ形状にブロードキャストできない場合は,例外が発生します.</target>
        </trans-unit>
        <trans-unit id="f745354786d48a61873aeb74a86c334de5c7a7b4" translate="yes" xml:space="preserve">
          <source>If the index expression contains comma separated arrays, then stack them along their first axis.</source>
          <target state="translated">インデックス式にカンマ区切りの配列が含まれている場合は、それらを最初の軸に沿ってスタックします。</target>
        </trans-unit>
        <trans-unit id="34ad012e6ac2224c1d99e1fa90fb54c844437b0d" translate="yes" xml:space="preserve">
          <source>If the index expression contains slice notation or scalars then create a 1-D array with a range indicated by the slice notation.</source>
          <target state="translated">インデックス式にスライス表記やスカラが含まれている場合は、スライス表記で示される範囲を持つ1次元配列を作成します。</target>
        </trans-unit>
        <trans-unit id="b729e3ef7cf0f40d514ca0e064da63fa121cea95" translate="yes" xml:space="preserve">
          <source>If the information is already documented and succinct enough for a how-to, just link to it, possibly after an introduction (&amp;ldquo;Three km/mi, take a right&amp;rdquo;).</source>
          <target state="translated">情報がすでに文書化されており、ハウツーに十分簡潔である場合は、おそらく紹介の後で、情報にリンクするだけです（「3 km / mi、右折」）。</target>
        </trans-unit>
        <trans-unit id="70dea339f55810f6be3e1b0c9e7aefd88107ebbf" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;a&lt;/code&gt; contains an imaginary part, it is silently discarded.</source>
          <target state="translated">入力 &lt;code&gt;a&lt;/code&gt; に虚数部が含まれている場合、それは黙って破棄されます。</target>
        </trans-unit>
        <trans-unit id="4637e99d70ef2c1cb40679370ac10807b840a3f4" translate="yes" xml:space="preserve">
          <source>If the input file does not exist or cannot be read.</source>
          <target state="translated">入力ファイルが存在しないか、読み込めない場合。</target>
        </trans-unit>
        <trans-unit id="bbf06b38d2758769a67207876edd570ca41378d4" translate="yes" xml:space="preserve">
          <source>If the input has a integer type the function is equivalent to np.max.</source>
          <target state="translated">入力が整数型の場合,この関数はnp.maxと等価です.</target>
        </trans-unit>
        <trans-unit id="7895a434c9eeafd563766c2013458a9eca1c5fea" translate="yes" xml:space="preserve">
          <source>If the input has a integer type the function is equivalent to np.min.</source>
          <target state="translated">入力が整数型の場合,この関数はnp.minと等価です.</target>
        </trans-unit>
        <trans-unit id="b307c09a45c4aabb639976a619f0171d6a01d0dd" translate="yes" xml:space="preserve">
          <source>If the input is 2d and axis is specified, the result is a list of lists.</source>
          <target state="translated">入力が2次元で軸を指定した場合、結果はリストのリストになります。</target>
        </trans-unit>
        <trans-unit id="7ed38fa8c8d2f0a335bd5a040aeda16b9d1b796e" translate="yes" xml:space="preserve">
          <source>If the input is not 1-dimensional, or contains elements with negative values, or if &lt;code&gt;minlength&lt;/code&gt; is negative.</source>
          <target state="translated">入力が1次元でない場合、または負の値の要素が含まれている場合、または &lt;code&gt;minlength&lt;/code&gt; が負の場合。</target>
        </trans-unit>
        <trans-unit id="10296cda117e24158759559beefea304129412f0" translate="yes" xml:space="preserve">
          <source>If the input parameter &lt;code&gt;n&lt;/code&gt; is larger than the size of the input, the input is padded by appending zeros at the end. Even though this is the common approach, it might lead to surprising results. If a different padding is desired, it must be performed before calling &lt;a href=&quot;#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">入力パラメーター &lt;code&gt;n&lt;/code&gt; が入力のサイズより大きい場合、入力は末尾にゼロを追加することによって埋め込まれます。これは一般的なアプローチですが、驚くべき結果につながる可能性があります。別のパディングが必要な場合は、&lt;a href=&quot;#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; を呼び出す&lt;/a&gt;前にそれを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="3fc060b3dda78a5634929550749227bb1804a61d" translate="yes" xml:space="preserve">
          <source>If the inputs are ndarrays, then np.greater is equivalent to &amp;lsquo;&amp;gt;&amp;rsquo;.</source>
          <target state="translated">入力がndarraysの場合、np.greaterは '&amp;gt;'と同等です。</target>
        </trans-unit>
        <trans-unit id="36e6b94197e7b6e49557830166101a92fecb27ad" translate="yes" xml:space="preserve">
          <source>If the inputs or dtype are complex, the output will follow a logarithmic spiral in the complex plane. (There are an infinite number of spirals passing through two points; the output will follow the shortest such path.)</source>
          <target state="translated">入力または dtype が複素数の場合、出力は複素数平面内の対数螺旋に従います。(2点を通過する螺旋は無限にあります。出力はそのような最短の経路に従います)。</target>
        </trans-unit>
        <trans-unit id="ce8f1e8f63cbe617564d9cd3d7c5c8bc3e2530ae" translate="yes" xml:space="preserve">
          <source>If the iterator is buffered, returns the size of the buffer being used, otherwise returns 0.</source>
          <target state="translated">イテレータがバッファリングされている場合は、使用されているバッファのサイズを返し、そうでない場合は0を返します。</target>
        </trans-unit>
        <trans-unit id="f3c918834625c8823bdade73b25f11346749b818" translate="yes" xml:space="preserve">
          <source>If the iterator is tracking a multi-index, this strips support for them, and does further iterator optimizations that are possible if multi-indices are not needed. This function also resets the iterator to its initial state.</source>
          <target state="translated">イテレータがマルチインデックスを追跡している場合、そのサポートを削除し、マルチインデックスが不要な場合に可能なイテレータの最適化を行います。この関数は,イテレータを初期状態にリセットします.</target>
        </trans-unit>
        <trans-unit id="7df15990c36906ed5503360d9305db9b7bfe762b" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; has different size.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; の最後の次元のサイズが異なる場合。</target>
        </trans-unit>
        <trans-unit id="5f26098ec8a9cbafe4e4d839766540a822d41056" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;a&lt;/code&gt; is not the same size as the second-to-last dimension of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">最後の次元場合の最後から2番目の寸法と同じ大きさではない &lt;code&gt;b&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb81ca8cc652031a811f2c78a93956ac1f2c926b" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;x1&lt;/code&gt; is not the same size as the second-to-last dimension of &lt;code&gt;x2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; の最後の次元が &lt;code&gt;x2&lt;/code&gt; の最後から2番目の次元と同じサイズでない場合。</target>
        </trans-unit>
        <trans-unit id="6d1f7f126415ee26c19732032b0ebefd0ac4317a" translate="yes" xml:space="preserve">
          <source>If the masked array has named fields, accessing a single entry returns a &lt;a href=&quot;arrays.scalars#numpy.void&quot;&gt;&lt;code&gt;numpy.void&lt;/code&gt;&lt;/a&gt; object if none of the fields are masked, or a 0d masked array with the same dtype as the initial array if at least one of the fields is masked.</source>
          <target state="translated">マスクされた配列に名前付きフィールドがある場合、単一のエントリにアクセスすると、&lt;a href=&quot;arrays.scalars#numpy.void&quot;&gt; &lt;code&gt;numpy.void&lt;/code&gt; &lt;/a&gt;フィールドもマスクされていない場合はnumpy.voidオブジェクトが返され、フィールドの少なくとも1つがマスクされている場合は初期配列と同じdtypeを持つ0dマスクされた配列が返されます。</target>
        </trans-unit>
        <trans-unit id="2fd0d252831ab8d15d091d4ef1abf6e28cded875" translate="yes" xml:space="preserve">
          <source>If the masked array has named fields, accessing a single entry returns a &lt;code&gt;numpy.void&lt;/code&gt; object if none of the fields are masked, or a 0d masked array with the same dtype as the initial array if at least one of the fields is masked.</source>
          <target state="translated">マスクされた配列に名前付きフィールドがある場合、単一のエントリにアクセスすると、 &lt;code&gt;numpy.void&lt;/code&gt; フィールドもマスクされていない場合はnumpy.voidオブジェクトが返され、少なくとも1つのフィールドがマスクされている場合は、初期配列と同じdtypeの0dマスクされた配列が返されます。</target>
        </trans-unit>
        <trans-unit id="ddd5cbab3c6e64e2766e2597df7dd32b3c4a768b" translate="yes" xml:space="preserve">
          <source>If the mode is a &amp;ldquo;write&amp;rdquo; mode, then this is the version of the file format used to create the file. None means use the oldest supported version that is able to store the data. Default: None</source>
          <target state="translated">モードが「書き込み」モードの場合、これはファイルの作成に使用されたファイル形式のバージョンです。Noneは、データを保存できるサポートされている最も古いバージョンを使用することを意味します。デフォルト：なし</target>
        </trans-unit>
        <trans-unit id="8ec6f09c123aa3a76dc4dc9103d999ab337134eb" translate="yes" xml:space="preserve">
          <source>If the mode is constant filling (&lt;code&gt;NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING&lt;/code&gt;), fill_value should point to an array object which holds the filling value (the first item will be the filling value if the array contains more than one item). For other cases, fill_value may be NULL.</source>
          <target state="translated">モードが一定の充填（ &lt;code&gt;NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING&lt;/code&gt; ）の場合、fill_valueは、充填値を保持する配列オブジェクトを指す必要があります（配列に複数の項目が含まれている場合、最初の項目が充填値になります）。その他の場合、fill_valueはNULLになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="510c4eb8a3d20ab4214058c75f9744c994e75f43" translate="yes" xml:space="preserve">
          <source>If the mode is constant filling (NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING), fill_value should point to an array object which holds the filling value (the first item will be the filling value if the array contains more than one item). For other cases, fill_value may be NULL.</source>
          <target state="translated">モードが定数充填(NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING)の場合、fill_valueは充填値を保持する配列オブジェクトを指すべきです(配列に複数の項目が含まれている場合、最初の項目が充填値となります)。それ以外の場合は、fill_value は NULL である可能性があります。</target>
        </trans-unit>
        <trans-unit id="be7395567c47ed030147671e19ef0b8f24978bfe" translate="yes" xml:space="preserve">
          <source>If the name is suffixed with the &amp;ldquo;?&amp;rdquo; modifier, the dimension is a core dimension only if it exists on all inputs and outputs that share it; otherwise it is ignored (and replaced by a dimension of size 1 for the elementary function).</source>
          <target state="translated">名前の末尾に「？」が付いている場合 修飾子、ディメンションは、それを共有するすべての入力と出力に存在する場合のみ、コアディメンションです。それ以外の場合は無視されます（および基本関数のサイズ1の次元に置き換えられます）。</target>
        </trans-unit>
        <trans-unit id="c3d1c518bb585ba44b9ba4aaf335820db98fa4f5" translate="yes" xml:space="preserve">
          <source>If the new array is larger than the original array, then the new array is filled with repeated copies of &lt;code&gt;a&lt;/code&gt;. Note that this behavior is different from a.resize(new_shape) which fills with zeros instead of repeated copies of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">新しい配列は元の配列よりも大きい場合、新しい配列が繰り返しコピーが充填されています。この動作は、 &lt;code&gt;a&lt;/code&gt; を繰り返しコピーする代わりにゼロで埋めるa.resize（new_shape）とは異なることに注意してください。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b5041b424abd93910d43bf1d34adce8cb0f61f85" translate="yes" xml:space="preserve">
          <source>If the number of objects in the selection tuple is less than &lt;em&gt;N&lt;/em&gt; , then &lt;code&gt;:&lt;/code&gt; is assumed for any subsequent dimensions.</source>
          <target state="translated">選択タプル内のオブジェクトの数が&lt;em&gt;N&lt;/em&gt;未満の場合、後続の次元には &lt;code&gt;:&lt;/code&gt; が想定されます。</target>
        </trans-unit>
        <trans-unit id="4f2a8e76e80cc97243c0461015d68ab374ad3374" translate="yes" xml:space="preserve">
          <source>If the number of objects in the selection tuple is less than &lt;em&gt;N&lt;/em&gt;, then &lt;code&gt;:&lt;/code&gt; is assumed for any subsequent dimensions.</source>
          <target state="translated">選択タプル内のオブジェクトの数が&lt;em&gt;N&lt;/em&gt;未満の場合、後続の次元では &lt;code&gt;:&lt;/code&gt; が想定されます。</target>
        </trans-unit>
        <trans-unit id="2928aac7d9000dc7b0628e4b095667d7efc04498" translate="yes" xml:space="preserve">
          <source>If the object in question is compiled in a language other than Python, using &lt;code&gt;??&lt;/code&gt; will return the same information as &lt;code&gt;?&lt;/code&gt;. You&amp;rsquo;ll find this with a lot of built-in objects and types, for example:</source>
          <target state="translated">問題のオブジェクトがPython以外の言語でコンパイルされている場合は、 &lt;code&gt;??&lt;/code&gt; &lt;code&gt;?&lt;/code&gt; と同じ情報を返します 。これは、多くの組み込みオブジェクトとタイプで見つかります。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="c5a6c4456ec6f4292b9cf18dc4d579bb22a84db3" translate="yes" xml:space="preserve">
          <source>If the object provided is an array, this function traverses the chain of &lt;code&gt;base&lt;/code&gt; pointers so that each array points to the owner of the memory directly. Once the base is set, it may not be changed to another value.</source>
          <target state="translated">提供されたオブジェクトが配列の場合、この関数は &lt;code&gt;base&lt;/code&gt; ポインターのチェーンを走査して、各配列がメモリの所有者を直接指すようにします。ベースが設定されると、別の値に変更できなくなります。</target>
        </trans-unit>
        <trans-unit id="89a89c71a1b9f2da8de85eabab619e5820532ff8" translate="yes" xml:space="preserve">
          <source>If the offsets of the fields and itemsize of a structured array satisfy the alignment conditions, the array will have the &lt;code&gt;ALIGNED&lt;/code&gt;&lt;a href=&quot;../reference/generated/numpy.ndarray.flags#numpy.ndarray.flags&quot;&gt;&lt;code&gt;flag&lt;/code&gt;&lt;/a&gt; set.</source>
          <target state="translated">構造化配列のフィールドとitemsizeのオフセットが整列条件を満たす場合、配列には &lt;code&gt;ALIGNED&lt;/code&gt; &lt;a href=&quot;../reference/generated/numpy.ndarray.flags#numpy.ndarray.flags&quot;&gt; &lt;code&gt;flag&lt;/code&gt; &lt;/a&gt;設定されます。</target>
        </trans-unit>
        <trans-unit id="657e1806ea99b60e1959c9ce313bdaa2fd70aa64" translate="yes" xml:space="preserve">
          <source>If the operand is flagged as write-only and a copy is needed, an uninitialized temporary array will be created and then copied to back to &lt;code&gt;op[i]&lt;/code&gt; on calling &lt;code&gt;NpyIter_Deallocate&lt;/code&gt;, instead of doing the unnecessary copy operation.</source>
          <target state="translated">オペランドに書き込み専用のフラグが付けられ、コピーが必要な場合、初期化されていない一時配列が作成され、不要なコピー操作を実行する代わりに、 &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; の呼び出し時に &lt;code&gt;op[i]&lt;/code&gt; にコピーされます。</target>
        </trans-unit>
        <trans-unit id="17f4400245338f1e4a33ed23afc91ef7ab8c40c6" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; is given, only the first &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; occurrences are replaced.</source>
          <target state="translated">オプションの引数&lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;が指定されている場合、最初の&lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; 個の&lt;/a&gt;出現のみが置き換えられます。</target>
        </trans-unit>
        <trans-unit id="650baf4400147a0e58c70982764ea43290cfecc2" translate="yes" xml:space="preserve">
          <source>If the package is not found.</source>
          <target state="translated">パッケージが見つからない場合</target>
        </trans-unit>
        <trans-unit id="2ad175da47137fbc79b21402b2a0b69af4d4bc0f" translate="yes" xml:space="preserve">
          <source>If the position of iter is changed, any subsequent call to PyArrayNeighborhoodIter_Next is undefined behavior, and PyArrayNeighborhoodIter_Reset must be called.</source>
          <target state="translated">iter の位置が変更された場合、それ以降の PyArrayNeighborhoodIter_Next の呼び出しは未定義の動作となり、PyArrayNeighborhoodIter_Reset が呼び出されなければなりません。</target>
        </trans-unit>
        <trans-unit id="66cca6496635da39ce18c4666654d2018c778c20" translate="yes" xml:space="preserve">
          <source>If the question is broad, narrow and redirect it</source>
          <target state="translated">疑問が広ければ、狭くしてリダイレクトする</target>
        </trans-unit>
        <trans-unit id="16e630a04286a25caaca20cb641690b37ba91ed8" translate="yes" xml:space="preserve">
          <source>If the release series is a new one, you will need to add a new section to the &lt;code&gt;doc/build/merge/index.html&lt;/code&gt; front page just after the &amp;ldquo;insert here&amp;rdquo; comment:</source>
          <target state="translated">リリースシリーズが新しいものである場合は、「ここに挿入」コメントの直後に、 &lt;code&gt;doc/build/merge/index.html&lt;/code&gt; フロントページに新しいセクションを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="8c927b8ff30da3cc5f4b149881b61cbe3118f463" translate="yes" xml:space="preserve">
          <source>If the requested data type is in non-native byte order, the NBO flag overrides it and the requested data type is converted to be in native byte order.</source>
          <target state="translated">要求されたデータ型が非ネイティブバイト順の場合、NBOフラグはそれを上書きし、要求されたデータ型はネイティブバイト順に変換されます。</target>
        </trans-unit>
        <trans-unit id="8a5c6764b6f67871837f5bb9b64736c18fe7a7ad" translate="yes" xml:space="preserve">
          <source>If the returned coefficients are &lt;code&gt;c&lt;/code&gt;, then</source>
          <target state="translated">返される係数が &lt;code&gt;c&lt;/code&gt; の場合、</target>
        </trans-unit>
        <trans-unit id="054023bbbbd71a4d456dd16da82bfb709a02f2cc" translate="yes" xml:space="preserve">
          <source>If the second argument is 1-D, it is promoted to a matrix by appending a 1 to its dimensions. After matrix multiplication the appended 1 is removed.</source>
          <target state="translated">第2引数が1-Dの場合、その次元に1を付加することで行列に昇格します。行列の乗算の後、付加された1は削除されます。</target>
        </trans-unit>
        <trans-unit id="b4b38312a537fa220f815af5dcf5f4139bad3681" translate="yes" xml:space="preserve">
          <source>If the selection tuple has all entries &lt;code&gt;:&lt;/code&gt; except the &lt;em&gt;p&lt;/em&gt;-th entry which is a slice object &lt;code&gt;i:j:k&lt;/code&gt;, then the returned array has dimension &lt;em&gt;N&lt;/em&gt; formed by concatenating the sub-arrays returned by integer indexing of elements &lt;em&gt;i&lt;/em&gt;, &lt;em&gt;i+k&lt;/em&gt;, &amp;hellip;, &lt;em&gt;i + (m - 1) k &amp;lt; j&lt;/em&gt;,</source>
          <target state="translated">選択タプルはすべてのエントリがある場合 &lt;code&gt;:&lt;/code&gt; 除く&lt;em&gt;P&lt;/em&gt;スライスオブジェクトで番目のエントリ &lt;code&gt;i:j:k&lt;/code&gt; 、次に返される配列を寸法している&lt;em&gt;Nは&lt;/em&gt;要素の整数インデクシングによって返さサブアレイ連結することによって形成された&lt;em&gt;I&lt;/em&gt;、&lt;em&gt;iは+ kは&lt;/em&gt;、&amp;hellip;、&lt;em&gt;i +（m-1）k &amp;lt;j&lt;/em&gt;、</target>
        </trans-unit>
        <trans-unit id="203e38312fd98260c8d96e3f0a471d9a5a4a4689" translate="yes" xml:space="preserve">
          <source>If the shapes are not compatible and cannot be broadcast according to NumPy&amp;rsquo;s broadcasting rules.</source>
          <target state="translated">形状に互換性がなく、NumPyのブロードキャストルールに従ってブロードキャストできない場合。</target>
        </trans-unit>
        <trans-unit id="9a652cfa7a533eb64735eb374de6f3a4977f5b9c" translate="yes" xml:space="preserve">
          <source>If the spacing between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; for one or more elements is larger than &lt;code&gt;nulp&lt;/code&gt;.</source>
          <target state="translated">1つ以上の要素の &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の間隔が &lt;code&gt;nulp&lt;/code&gt; より大きい場合。</target>
        </trans-unit>
        <trans-unit id="3600ee510b36714644dcc89a19bb177b5b6c4ba7" translate="yes" xml:space="preserve">
          <source>If the string is not the correct size to satisfy the requested &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">文字列が、要求された&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;count&lt;/code&gt; を満たすのに適切なサイズでない場合。</target>
        </trans-unit>
        <trans-unit id="8431a3b44693b10770bc98218be6d44b926dbd16" translate="yes" xml:space="preserve">
          <source>If the transition to C++ goes through it is possible that this form will be relaxed so that short class methods meant to be inlined can have the return type on the same line as the function name. However, that is yet to be determined.</source>
          <target state="translated">C++への移行が進めば、この形式が緩和され、インライン化された短いクラスメソッドの戻り値の型が関数名と同じ行になるようになる可能性があります。しかし、それはまだ決定されていません。</target>
        </trans-unit>
        <trans-unit id="ebc3886c14d49cd40506d4084002663f28dbcdd3" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;x&lt;/code&gt; is unsigned, then the output type is the unsigned platform integer:</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; のタイプが符号なしの場合、出力タイプは符号なしプラットフォーム整数になります。</target>
        </trans-unit>
        <trans-unit id="183bc4d9ba8fd4894a95c0f09db6946e16642c92" translate="yes" xml:space="preserve">
          <source>If the type of the input is complex.</source>
          <target state="translated">入力の種類が複素数の場合。</target>
        </trans-unit>
        <trans-unit id="95366e62fbbbe64ba41cdcaa0c22be8d3f384cd4" translate="yes" xml:space="preserve">
          <source>If the type of the input is float or complex.</source>
          <target state="translated">入力の型が float または複素数の場合。</target>
        </trans-unit>
        <trans-unit id="25291949b6396c31462d4c34b8e8b5c2797cb90a" translate="yes" xml:space="preserve">
          <source>If the ufunc has 2 inputs and 1 output and the second input is an Object array then a special-case check is performed so that NotImplemented is returned if the second input is not an ndarray, has the __array_priority__ attribute, and has an __r{op}__ special method. In this way, Python is signaled to give the other object a chance to complete the operation instead of using generic object-array calculations. This allows (for example) sparse matrices to override the multiplication operator 1-D loop.</source>
          <target state="translated">ufuncが2つの入力と1つの出力を持ち、2番目の入力がオブジェクト配列である場合、2番目の入力がndarrayではなく、__array_priority__属性を持ち、__r{op}__特別なメソッドを持っている場合、NotImplementedが返されるように、特殊ケースチェックが行われます。このようにして、Pythonは、汎用的なオブジェクト配列計算を使用する代わりに、他のオブジェクトに処理を完了する機会を与えるようにシグナルを送ります。これにより、(例えば)疎な行列は乗算演算子の1-Dループをオーバーライドすることができます。</target>
        </trans-unit>
        <trans-unit id="a4dffd94a98e9a9ee0037afd472e661e6232061e" translate="yes" xml:space="preserve">
          <source>If the underlying data is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, it is returned as such.</source>
          <target state="translated">基本となるデータが&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; の&lt;/a&gt;サブクラスである場合は、そのように返されます。</target>
        </trans-unit>
        <trans-unit id="c8138c9410f7b3ce9c5c6bb9d0523e6e1ea7bd8e" translate="yes" xml:space="preserve">
          <source>If the underlying data is a subclass of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, it is returned as such.</source>
          <target state="translated">基になるデータが&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; の&lt;/a&gt;サブクラスである場合、そのように返されます。</target>
        </trans-unit>
        <trans-unit id="10f03c3143f8af1fee84b593563d21e127566799" translate="yes" xml:space="preserve">
          <source>If the user tries to use any numpy functions not included in &lt;code&gt;HANDLED_FUNCTIONS&lt;/code&gt;, a &lt;code&gt;TypeError&lt;/code&gt; will be raised by numpy, indicating that this operation is not supported. For example, concatenating two &lt;code&gt;DiagonalArrays&lt;/code&gt; does not produce another diagonal array, so it is not supported.</source>
          <target state="translated">ユーザーが &lt;code&gt;HANDLED_FUNCTIONS&lt;/code&gt; に含まれていないnumpy関数を使用しようとすると、 &lt;code&gt;TypeError&lt;/code&gt; がnumpyによって発生し、この操作がサポートされていないことを示します。たとえば、2つの &lt;code&gt;DiagonalArrays&lt;/code&gt; 連結しても、別の対角配列は生成されないため、サポートされていません。</target>
        </trans-unit>
        <trans-unit id="23122d3c8d35684d3c1d392886f730d15f172384" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">値がデフォルト以外の場合、 &lt;code&gt;keepdims&lt;/code&gt; はndarrayのサブクラスの&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt;メソッドに&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;ます。サブクラスのメソッドが &lt;code&gt;keepdims&lt;/code&gt; を実装しない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="2abfa832de7674bd2d08ad1f7e2b845f18a0059c" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">値がデフォルト以外の場合、 &lt;code&gt;keepdims&lt;/code&gt; はndarrayのサブクラスの&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#min&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt;メソッドに&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;ます。サブクラスのメソッドが &lt;code&gt;keepdims&lt;/code&gt; を実装しない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="fb8acc52d13221f0fba6edb05a42e80cbebd0a2e" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; methods of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">値がデフォルト以外の場合、 &lt;code&gt;keepdims&lt;/code&gt; はndarrayのサブクラスの&lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt;メソッドに&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;ます。サブクラスのメソッドが &lt;code&gt;keepdims&lt;/code&gt; を実装しない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="287f0d6b5f9e62921d595f7d469377b448c9303e" translate="yes" xml:space="preserve">
          <source>If there are many steps, break them up</source>
          <target state="translated">ステップ数が多い場合は、分割して</target>
        </trans-unit>
        <trans-unit id="33c6901ff2ee0db95c77f2b313983f44526bb314" translate="yes" xml:space="preserve">
          <source>If there are only scalars or the maximum category of the scalars is higher than the maximum category of the arrays, the data types are combined with &lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt;&lt;code&gt;PyArray_PromoteTypes&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">スカラーしかない場合、またはスカラーの最大カテゴリが配列の最大カテゴリよりも大きい場合は、データ型が&lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt; &lt;code&gt;PyArray_PromoteTypes&lt;/code&gt; &lt;/a&gt;と組み合わされて戻り値が生成されます。</target>
        </trans-unit>
        <trans-unit id="33fe4c771f7142c020971d30614039b35a541395" translate="yes" xml:space="preserve">
          <source>If there are only scalars or the maximum category of the scalars is higher than the maximum category of the arrays, the data types are combined with &lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">スカラーのみがある場合、またはスカラーの最大カテゴリーが配列の最大カテゴリーよりも大きい場合、データ型は、&lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt;と組み合わされて戻り値を生成します。</target>
        </trans-unit>
        <trans-unit id="713f3b36701faad5c729c8225f4c0508fcfe41f1" translate="yes" xml:space="preserve">
          <source>If there is no dictionary passed in or &lt;code&gt;vardict&lt;/code&gt; is None then returns NumPy arrays in the globals() dictionary (all NumPy arrays in the namespace).</source>
          <target state="translated">ディクショナリが渡されない場合、または &lt;code&gt;vardict&lt;/code&gt; がNoneの場合、globals（）ディクショナリ内のNumPy配列（名前空間内のすべてのNumPy配列）を返します。</target>
        </trans-unit>
        <trans-unit id="d0c11d30de5e96bdaa85cb78bb53dddd3ba03ebc" translate="yes" xml:space="preserve">
          <source>If there is no library with the expected extension, or the library is defective and cannot be loaded.</source>
          <target state="translated">期待される拡張子を持つライブラリがない場合、またはライブラリに欠陥があり、ロードできない場合。</target>
        </trans-unit>
        <trans-unit id="ef27bb26cd9e20ec5eb81bab137d2b6e00a224b0" translate="yes" xml:space="preserve">
          <source>If there is only one Boolean array and no integer indexing array present, this is straight forward. Care must only be taken to make sure that the boolean index has &lt;em&gt;exactly&lt;/em&gt; as many dimensions as it is supposed to work with.</source>
          <target state="translated">ブール配列が1つしかなく、整数インデックス配列が存在しない場合、これは簡単です。ブールインデックスが、使用するのと&lt;em&gt;まったく同じ&lt;/em&gt;数のディメンションを持っていることを確認するように注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="e046df75fb04a45aea0ca0b9e3343d606d4ffa89" translate="yes" xml:space="preserve">
          <source>If there&amp;rsquo;s related background (tutorial, explanation, reference, alternative approach), bring it to the user&amp;rsquo;s attention with a link (&amp;ldquo;Directions from Route 7,&amp;rdquo; &amp;ldquo;Why so few filling stations?&amp;rdquo;).</source>
          <target state="translated">関連する背景（チュートリアル、説明、参照、代替アプローチ）がある場合は、リンク（「ルート7からの道順」、「なぜガソリンスタンドが少ないのですか？」）を使用してユーザーの注意を引きます。</target>
        </trans-unit>
        <trans-unit id="6e268d3c7b0192c893825d9fa07e4e49b28360ad" translate="yes" xml:space="preserve">
          <source>If these arrays are all collected in a structured array, then &lt;a href=&quot;#c.PyArray_Sort&quot;&gt;&lt;code&gt;PyArray_Sort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can also be used to sort the array directly.</source>
          <target state="translated">これらの配列がすべて構造化配列に収集されている場合、&lt;a href=&quot;#c.PyArray_Sort&quot;&gt; &lt;code&gt;PyArray_Sort&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）を使用して配列を直接ソートすることもできます。</target>
        </trans-unit>
        <trans-unit id="54dc9b5be81c958064f5d558fe01980eec4eadde" translate="yes" xml:space="preserve">
          <source>If these conditions are not met, a &lt;code&gt;ValueError: operands could not be broadcast together&lt;/code&gt; exception is thrown, indicating that the arrays have incompatible shapes. The size of the resulting array is the size that is not 1 along each axis of the inputs.</source>
          <target state="translated">これらの条件が満たされない場合、 &lt;code&gt;ValueError: operands could not be broadcast together&lt;/code&gt; 例外がスローされ、配列に互換性のない形状があることを示します。結果の配列のサイズは、入力の各軸に沿って1ではないサイズです。</target>
        </trans-unit>
        <trans-unit id="4b5797d27d90ecc738ae241c7f2d88131ab4d780" translate="yes" xml:space="preserve">
          <source>If these conditions hold, &lt;code&gt;__array_function__&lt;/code&gt; should return the result from calling its implementation for &lt;code&gt;func(*args, **kwargs)&lt;/code&gt;. Otherwise, it should return the sentinel value &lt;code&gt;NotImplemented&lt;/code&gt;, indicating that the function is not implemented by these types.</source>
          <target state="translated">これらの条件が満たされている場合、 &lt;code&gt;__array_function__&lt;/code&gt; は &lt;code&gt;func(*args, **kwargs)&lt;/code&gt; 実装を呼び出した結果を返す必要があります。それ以外の場合は、センチネル値 &lt;code&gt;NotImplemented&lt;/code&gt; を返し、関数がこれらのタイプによって実装されていないことを示します。</target>
        </trans-unit>
        <trans-unit id="c80ca8262eeedd9bef78dbd28fb2dc07a4582c48" translate="yes" xml:space="preserve">
          <source>If this array does not own its own memory, then base points to the Python object that owns it (perhaps another array object)</source>
          <target state="translated">この配列が自分のメモリを所有していない場合、base はそれを所有する Python オブジェクト (おそらく別の配列オブジェクト)を指します。</target>
        </trans-unit>
        <trans-unit id="f79009d9f8b9e9859082a3efe68d074e3e908ff8" translate="yes" xml:space="preserve">
          <source>If this array has the (deprecated) &lt;a href=&quot;array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag set, then this array is a working copy of a &amp;ldquo;misbehaved&amp;rdquo; array.</source>
          <target state="translated">この配列に（非推奨の）&lt;a href=&quot;array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;フラグが設定されている場合、この配列は「誤動作」配列の作業コピーです。</target>
        </trans-unit>
        <trans-unit id="f63b91f81d86b6356e230f230ee7da044adca895" translate="yes" xml:space="preserve">
          <source>If this array has the (deprecated) &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag set, then this array is a working copy of a &amp;ldquo;misbehaved&amp;rdquo; array.</source>
          <target state="translated">この配列に（非推奨の）&lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;フラグが設定されている場合、この配列は「正しく動作しない」配列の作業用コピーです。</target>
        </trans-unit>
        <trans-unit id="2e1498e4add4060095cafec2d44c32b17e6ac395" translate="yes" xml:space="preserve">
          <source>If this condition is not met, a &lt;code&gt;ValueError('frames are not aligned')&lt;/code&gt; exception is thrown indicating that the arrays have incompatible shapes. The size of the result array created by broadcast operations is the maximum size along each dimension from the input arrays. Note that the rule does not say anything about the two arrays needing to have the same number of dimensions. So, for example, if you have a 256 x 256 x 3 array of RGB values, and you want to scale each color in the image by a different value, you can multiply the image by a one-dimensional array with 3 values. Lining up the sizes of the trailing axes of these arrays according to the broadcast rule shows that they are compatible</source>
          <target state="translated">この条件が満たされない場合、 &lt;code&gt;ValueError('frames are not aligned')&lt;/code&gt; 例外がスローされ、配列に互換性のない形状があることを示します。ブロードキャスト操作によって作成された結果配列のサイズは、入力配列からの各次元に沿った最大サイズです。ルールは、同じ数の次元を持つ必要がある2つの配列については何も述べていないことに注意してください。したがって、たとえば、RGB値の256 x 256 x 3配列があり、画像の各色を異なる値でスケーリングする場合は、画像に3つの値を持つ1次元配列を掛けることができます。ブロードキャストルールに従ってこれらの配列の後軸のサイズを並べると、互換性があることがわかります</target>
        </trans-unit>
        <trans-unit id="b54640e63d198f32f1e8358a28ce29bc6179e6f7" translate="yes" xml:space="preserve">
          <source>If this function returns true, the caller should also check the inner loop stride of the operand, because if that stride is 0, then only the first element of the innermost external loop is being visited for the first time.</source>
          <target state="translated">この関数が真を返す場合、呼び出し元はオペランドの内部ループのストライドもチェックする必要があります。</target>
        </trans-unit>
        <trans-unit id="24a22c06faef1b4b61f295517b88ec97d1fc0a84" translate="yes" xml:space="preserve">
          <source>If this is &lt;code&gt;None&lt;/code&gt;, a reduction is performed over all the axes. If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">これが &lt;code&gt;None&lt;/code&gt; の場合、すべての軸で削減が実行されます。これが整数のタプルである場合、削減は以前のように単一の軸またはすべての軸ではなく、複数の軸で実行されます。</target>
        </trans-unit>
        <trans-unit id="33f579e70b917db4493a3111bc7067b3dc4d2ff2" translate="yes" xml:space="preserve">
          <source>If this is None, a reduction is performed over all the axes. If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">これが None の場合、縮小はすべての軸で実行されます。これがintのタプルである場合、以前のように1つの軸またはすべての軸ではなく、複数の軸で縮小が行われます。</target>
        </trans-unit>
        <trans-unit id="e4599c6e53b844db2376ed9e56ed7b49e63c6ec3" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a mean is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">これがintのタプルである場合、以前のように1つの軸またはすべての軸ではなく、複数の軸に渡って平均が実行されます。</target>
        </trans-unit>
        <trans-unit id="04767d2c5f5bbd4aab7323a751a31f226739a396" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">これがイントのタプルである場合、従来のように1つの軸またはすべての軸ではなく、複数の軸で縮小が行われます。</target>
        </trans-unit>
        <trans-unit id="e11ec2c8b461dd6b1390de16d518719c4d72ce55" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a standard deviation is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">これがイントのタプルであれば、従来のように1軸または全軸ではなく、複数の軸に渡って標準偏差が行われます。</target>
        </trans-unit>
        <trans-unit id="cdec667610de13f7517139e9ece6f88d2d290194" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a variance is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">これがイントのタプルである場合、分散は、以前のように1つの軸またはすべての軸ではなく、複数の軸に渡って実行されます。</target>
        </trans-unit>
        <trans-unit id="d50012ee6c384ff0215bab7085fcf98c562bc452" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the count is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">これがイントのタプルである場合、以前のように1つの軸またはすべての軸ではなく、複数の軸でカウントが実行されます。</target>
        </trans-unit>
        <trans-unit id="c674e367c6b1c23d3abf3ddc4c5a7a14ff593b5a" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the maximum is selected over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">これがイントのタプルである場合、以前のように1つの軸またはすべての軸ではなく、複数の軸で最大値が選択されます。</target>
        </trans-unit>
        <trans-unit id="a0756a48081a9a9cb1bfbc79e9843f0007e55c1d" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the minimum is selected over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">これがイントのタプルである場合、最小値は、以前のように1つの軸またはすべての軸ではなく、複数の軸にわたって選択されます。</target>
        </trans-unit>
        <trans-unit id="7573da3ff564f7261e16d53ba17d4d7c25b6abc9" translate="yes" xml:space="preserve">
          <source>If this is anything but the default value it will be passed through (in the special case of an empty array) to the &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; function of the underlying array. If the array is a sub-class and &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; does not have the kwarg &lt;code&gt;keepdims&lt;/code&gt; this will raise a RuntimeError.</source>
          <target state="translated">これがデフォルト値以外の場合は、（空の配列の特殊なケースでは）基になる配列の&lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt;関数に渡されます。配列がサブクラスで&lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt;にkwarg &lt;code&gt;keepdims&lt;/code&gt; がない場合、これはRuntimeErrorを発生させます。</target>
        </trans-unit>
        <trans-unit id="25b5fe8a90e7aa983d49aeb7de528ca7dae28481" translate="yes" xml:space="preserve">
          <source>If this is non- &lt;code&gt;NULL&lt;/code&gt;, then this data-type descriptor is a C-style contiguous array of another data-type descriptor. In other-words, each element that this descriptor describes is actually an array of some other base descriptor. This is most useful as the data-type descriptor for a field in another data-type descriptor. The fields member should be &lt;code&gt;NULL&lt;/code&gt; if this is non- &lt;code&gt;NULL&lt;/code&gt; (the fields member of the base descriptor can be non- &lt;code&gt;NULL&lt;/code&gt; however).</source>
          <target state="translated">これが &lt;code&gt;NULL&lt;/code&gt; 以外の場合、このデータ型記述子は、別のデータ型記述子のCスタイルの連続配列です。言い換えると、この記述子が記述する各要素は、実際には他の基本記述子の配列です。これは、別のデータ型記述子のフィールドのデータ型記述子として最も役立ちます。フィールド部材であるべき &lt;code&gt;NULL&lt;/code&gt; これは非ある場合 &lt;code&gt;NULL&lt;/code&gt; （ベース記述子のフィールド部材は、非することができる &lt;code&gt;NULL&lt;/code&gt; が）。</target>
        </trans-unit>
        <trans-unit id="9eef22bd67c15e89cde5d92734a40aa76d92e691" translate="yes" xml:space="preserve">
          <source>If this is non- &lt;code&gt;NULL&lt;/code&gt;, then this data-type descriptor is a C-style contiguous array of another data-type descriptor. In other-words, each element that this descriptor describes is actually an array of some other base descriptor. This is most useful as the data-type descriptor for a field in another data-type descriptor. The fields member should be &lt;code&gt;NULL&lt;/code&gt; if this is non- &lt;code&gt;NULL&lt;/code&gt; (the fields member of the base descriptor can be non- &lt;code&gt;NULL&lt;/code&gt; however). The &lt;code&gt;PyArray_ArrayDescr&lt;/code&gt; structure is defined using</source>
          <target state="translated">これが &lt;code&gt;NULL&lt;/code&gt; 以外の場合、このデータ型記述子は、別のデータ型記述子のCスタイルの連続した配列です。言い換えると、この記述子が記述する各要素は、実際には他のいくつかの基本記述子の配列です。これは、別のデータ型記述子のフィールドのデータ型記述子として最も役立ちます。フィールド部材であるべき &lt;code&gt;NULL&lt;/code&gt; これは非ある場合 &lt;code&gt;NULL&lt;/code&gt; （ベース記述子のフィールド部材は、非することができる &lt;code&gt;NULL&lt;/code&gt; が）。 &lt;code&gt;PyArray_ArrayDescr&lt;/code&gt; の構造を使用して定義されます</target>
        </trans-unit>
        <trans-unit id="2824d770011e81edcc48aaca00be40fe5064246e" translate="yes" xml:space="preserve">
          <source>If this is non-NULL, then this data-type-descriptor has fields described by a Python dictionary whose keys are names (and also titles if given) and whose values are tuples that describe the fields. Recall that a data-type-descriptor always describes a fixed-length set of bytes. A field is a named sub-region of that total, fixed-length collection. A field is described by a tuple composed of another data- type-descriptor and a byte offset. Optionally, the tuple may contain a title which is normally a Python string. These tuples are placed in this dictionary keyed by name (and also title if given).</source>
          <target state="translated">これがNULLでない場合、このデータ型記述子はPython辞書によって記述されたフィールドを持ち、そのキーは名前(与えられた場合はタイトルも)であり、その値はフィールドを記述するタプルです。データ型記述子は常に固定長のバイトの集合を記述していることを思い出してください。フィールドはその固定長のコレクションの名前付きのサブ領域です。フィールドは、別のデータ型記述子とバイトオフセットからなるタプルによって記述されます。オプションで、タプルは通常Python文字列であるタイトルを含むことができます。これらのタプルは、名前(与えられた場合にはタイトルも)でキーが設定されたこの辞書に配置されます。</target>
        </trans-unit>
        <trans-unit id="0d86cba4ba7294ed9f7338e68f7b4f37b35c1557" translate="yes" xml:space="preserve">
          <source>If this is not desirable, then the array should be cast to a larger integer type first:</source>
          <target state="translated">これが望ましくない場合は、まず配列をより大きな整数型にキャストする必要があります。</target>
        </trans-unit>
        <trans-unit id="1ae38fd1d446748062bddf73d4866a0b315e1322" translate="yes" xml:space="preserve">
          <source>If this is set to &lt;code&gt;True&lt;/code&gt;, axes which are reduced over will be left in the result as a dimension with size one, so that the result will broadcast correctly against the inputs. This option can only be used for generalized ufuncs that operate on inputs that all have the same number of core dimensions and with outputs that have no core dimensions , i.e., with signatures like &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; or &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt;. If used, the location of the dimensions in the output can be controlled with &lt;code&gt;axes&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">これが &lt;code&gt;True&lt;/code&gt; に設定されている場合、縮小された軸はサイズ1の次元として結果に残り、結果は入力に対して正しくブロードキャストされます。このオプションは、コア次元の数がすべて同じで、コア次元のない出力、つまり &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; または &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt; 。使用する場合、出力の次元の位置は、 &lt;code&gt;axes&lt;/code&gt; および &lt;code&gt;axis&lt;/code&gt; で制御できます。</target>
        </trans-unit>
        <trans-unit id="a675290349084bcd281fdfbd331891015b07aca9" translate="yes" xml:space="preserve">
          <source>If this is set to &lt;code&gt;True&lt;/code&gt;, axes which are reduced over will be left in the result as a dimension with size one, so that the result will broadcast correctly against the inputs. This option can only be used for generalized ufuncs that operate on inputs that all have the same number of core dimensions and with outputs that have no core dimensions, i.e., with signatures like &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; or &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt;. If used, the location of the dimensions in the output can be controlled with &lt;code&gt;axes&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">これを &lt;code&gt;True&lt;/code&gt; に設定すると、縮小された軸がサイズ1のディメンションとして結果に残されるため、結果は入力に対して正しくブロードキャストされます。このオプションは、すべて同じ数のコア次元を持つ入力と、コア次元を持たない出力、つまり &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; 、 &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt; ）などのシグネチャで動作する一般化されたufuncにのみ使用できます。、m）-&amp;gt;（）。使用する場合、出力内の寸法の位置は、 &lt;code&gt;axes&lt;/code&gt; と &lt;code&gt;axis&lt;/code&gt; 制御できます。</target>
        </trans-unit>
        <trans-unit id="86e30e948710dc5b2db29b7dc82437914fd08740" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes that are counted are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</source>
          <target state="translated">これが True に設定されている場合、カウントされる軸は、サイズ 1 の寸法として結果に残されます。このオプションを指定すると、結果は入力配列に対して正しくブロードキャストされます。</target>
        </trans-unit>
        <trans-unit id="74585a8bd339c6874f448a64d5fe0ba3642c10c6" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are normed over are left in the result as dimensions with size one. With this option the result will broadcast correctly against the original &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">これがTrueに設定されている場合、正規化された軸は、サイズ1の次元として結果に残ります。このオプションを使用すると、結果は元の &lt;code&gt;x&lt;/code&gt; に対して正しくブロードキャストされます。</target>
        </trans-unit>
        <trans-unit id="526b620d34688cc0c68a7ee67814781d453388f5" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the array.</source>
          <target state="translated">これがTrueに設定されている場合、縮小された軸はサイズ1の寸法として結果に残されます。このオプションを指定すると、結果は配列に対して正しくブロードキャストされます。</target>
        </trans-unit>
        <trans-unit id="015e500928e7c3f86f2c9b5121c746246fcd7a9f" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</source>
          <target state="translated">これが True に設定されている場合、縮小された軸はサイズ 1 の寸法として結果に残されます。このオプションを指定すると、結果は入力配列に対して正しくブロードキャストされます。</target>
        </trans-unit>
        <trans-unit id="4d739fbcafd1b0f422661a57db4976a28b66ef61" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これをTrueに設定すると、縮小された軸はサイズ1の寸法として結果に残ります。このオプションを使用すると、結果は元の&lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt;に対して正しくブロードキャストされます。</target>
        </trans-unit>
        <trans-unit id="caf30df07a09579107c0faa5c9aaad9ad8721644" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">これがTrueに設定されている場合、縮小された軸はサイズ1の次元として結果に残ります。このオプションを使用すると、結果は元の &lt;code&gt;a&lt;/code&gt; に対して正しくブロードキャストされます。</target>
        </trans-unit>
        <trans-unit id="668624d9e02d10dc8924733d51742fcc1923286c" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">これがTrueに設定されている場合、縮小された軸はサイズ1の次元として結果に残ります。このオプションを使用すると、結果は元の &lt;code&gt;arr&lt;/code&gt; に対して正しくブロードキャストされます。</target>
        </trans-unit>
        <trans-unit id="813c59426f99f6e2035686f0669f18c79ec2fc97" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">これがTrueに設定されている場合、縮小された軸はサイズ1の次元として結果に残ります。このオプションを使用すると、結果は元の配列 &lt;code&gt;a&lt;/code&gt; に対して正しくブロードキャストされます。</target>
        </trans-unit>
        <trans-unit id="28e1fe971ad9fdc32699e38250e14da5caf0bb91" translate="yes" xml:space="preserve">
          <source>If this value is anything but the default it is passed through as-is to the relevant functions of the sub-classes. If these functions do not have a &lt;code&gt;keepdims&lt;/code&gt; kwarg, a RuntimeError will be raised.</source>
          <target state="translated">この値がデフォルト以外の場合は、そのままサブクラスの関連する関数に渡されます。これらの関数に &lt;code&gt;keepdims&lt;/code&gt; kwarg がない場合、RuntimeErrorが発生します。</target>
        </trans-unit>
        <trans-unit id="dd4ec2a983c899a1017fcabb86ae5785ce4793ab" translate="yes" xml:space="preserve">
          <source>If true (default), then the object is copied. Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, etc.).</source>
          <target state="translated">true（デフォルト）の場合、オブジェクトがコピーされます。それ以外の場合、コピーは、__ array__がコピーを返す場合、objがネストされたシーケンスである場合、または他の要件（&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;order&lt;/code&gt; など）を満たすためにコピーが必要な場合にのみ作成されます。</target>
        </trans-unit>
        <trans-unit id="a6f5f638d5dadad294989835332dc69ea08c7e48" translate="yes" xml:space="preserve">
          <source>If true (default), then the object is copied. Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (&lt;code&gt;itemsize&lt;/code&gt;, unicode, &lt;code&gt;order&lt;/code&gt;, etc.).</source>
          <target state="translated">true（デフォルト）の場合、オブジェクトがコピーされます。それ以外の場合、__ array__がコピーを返す場合、objがネストされたシーケンスである場合、または他の要件（ &lt;code&gt;itemsize&lt;/code&gt; 、unicode、 &lt;code&gt;order&lt;/code&gt; など）を満たすためにコピーが必要な場合にのみ、コピーが作成されます。</target>
        </trans-unit>
        <trans-unit id="7cfded7f1f4f8985525752f730c915f025bbc3bd" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;stop&lt;/code&gt; is the last sample. Otherwise, it is not included. Default is True.</source>
          <target state="translated">trueの場合、 &lt;code&gt;stop&lt;/code&gt; は最後のサンプルです。それ以外の場合は含まれません。デフォルトはTrueです。</target>
        </trans-unit>
        <trans-unit id="89363179f510b5ee9e2706f4cf949aff38e269d9" translate="yes" xml:space="preserve">
          <source>If true, sample from the interval [low, high] instead of the default [low, high) Defaults to False</source>
          <target state="translated">true の場合、デフォルトの [low,high]の代わりに [low,high]の間隔からサンプリングします。</target>
        </trans-unit>
        <trans-unit id="ade7c82d0d30db8fc4ef391480e9db75f4fe6678" translate="yes" xml:space="preserve">
          <source>If true, use an &amp;ldquo;aligned&amp;rdquo; memory layout, otherwise use a &amp;ldquo;packed&amp;rdquo; layout.</source>
          <target state="translated">trueの場合は「整列」メモリレイアウトを使用し、そうでない場合は「パック」レイアウトを使用します。</target>
        </trans-unit>
        <trans-unit id="3ef0d38b764385bc39d70e5ad26d095da7b5d3f0" translate="yes" xml:space="preserve">
          <source>If used with &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;, the inner loop for the caller may get larger chunks than would be possible without buffering, because of how the strides are laid out.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;と一緒に使用すると、ストライドがどのように配置されるかによって、呼び出し側の内部ループが、バッファリングなしで可能なチャンクよりも大きなチャンクを取得する場合があります。</target>
        </trans-unit>
        <trans-unit id="e6e87a78ddc8c45866e59f696a01a91d82f291c2" translate="yes" xml:space="preserve">
          <source>If values in &lt;code&gt;x&lt;/code&gt; are beyond the bounds of &lt;code&gt;bins&lt;/code&gt;, 0 or &lt;code&gt;len(bins)&lt;/code&gt; is returned as appropriate.</source>
          <target state="translated">値場合 &lt;code&gt;x&lt;/code&gt; の境界を超えている &lt;code&gt;bins&lt;/code&gt; 、0又は &lt;code&gt;len(bins)&lt;/code&gt; 適切に戻されます。</target>
        </trans-unit>
        <trans-unit id="adc126c0d80d4b8b968260ca8a9cd270dc0bc84e" translate="yes" xml:space="preserve">
          <source>If values in &lt;code&gt;x&lt;/code&gt; are such that they fall outside the bin range, attempting to index &lt;code&gt;bins&lt;/code&gt; with the indices that &lt;a href=&quot;#numpy.digitize&quot;&gt;&lt;code&gt;digitize&lt;/code&gt;&lt;/a&gt; returns will result in an IndexError.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の値がビンの範囲外になるような値である場合、&lt;a href=&quot;#numpy.digitize&quot;&gt; &lt;code&gt;digitize&lt;/code&gt; &lt;/a&gt;が返すインデックスで &lt;code&gt;bins&lt;/code&gt; にインデックスを付けようとすると、IndexErrorが発生します。</target>
        </trans-unit>
        <trans-unit id="1061c821f897c8eeb5e101d31b7da69483d53c77" translate="yes" xml:space="preserve">
          <source>If we add another set of variables and observations &lt;code&gt;yarr&lt;/code&gt;, we can compute the row-wise Pearson correlation coefficients between the variables in &lt;code&gt;xarr&lt;/code&gt; and &lt;code&gt;yarr&lt;/code&gt;.</source>
          <target state="translated">別の変数のセットと観測値 &lt;code&gt;yarr&lt;/code&gt; を追加すると、 &lt;code&gt;xarr&lt;/code&gt; と &lt;code&gt;yarr&lt;/code&gt; の変数間の行ごとのピアソン相関係数を計算できます。</target>
        </trans-unit>
        <trans-unit id="b223152b4e60f22e3efa048a66b57e829307cf69" translate="yes" xml:space="preserve">
          <source>If we designed &lt;code&gt;rms&lt;/code&gt;, we probably made it a routine that takes an input-only array of length &lt;code&gt;n&lt;/code&gt; of &lt;code&gt;double&lt;/code&gt; values called &lt;code&gt;seq&lt;/code&gt; and returns the root mean square. The default behavior of &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;, however, will be to create a wrapper function that compiles, but is nearly impossible to use from the scripting language in the way the C routine was intended.</source>
          <target state="translated">&lt;code&gt;rms&lt;/code&gt; を設計した場合、おそらく &lt;code&gt;seq&lt;/code&gt; と呼ばれる長さ &lt;code&gt;n&lt;/code&gt; の &lt;code&gt;double&lt;/code&gt; 値の入力のみの配列を取り、二乗平均平方根を返すルーチンにした。ただし、&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;のデフォルトの動作は、コンパイルするラッパー関数を作成することですが、Cルーチンが意図した方法でスクリプト言語から使用することはほぼ不可能です。</target>
        </trans-unit>
        <trans-unit id="4a0434833c99496818e97fed2718d44b211d156f" translate="yes" xml:space="preserve">
          <source>If we do not know you yet, consider introducing yourself in &lt;a href=&quot;https://numpy.org/community/&quot;&gt;the mailing list or Slack&lt;/a&gt; before you start reviewing pull requests.</source>
          <target state="translated">まだあなたのことを知らない場合は、プルリクエストの確認を開始する前に&lt;a href=&quot;https://numpy.org/community/&quot;&gt;、メーリングリストまたはSlack&lt;/a&gt;に自己紹介することを検討してください。</target>
        </trans-unit>
        <trans-unit id="4cd7980a2cd59fdcee19fe4e74bfa7516ad561f7" translate="yes" xml:space="preserve">
          <source>If we exit and restart our Python interpreter, we&amp;rsquo;ll see that we generate the same random numbers again:</source>
          <target state="translated">Pythonインタープリターを終了して再起動すると、同じ乱数が再び生成されることがわかります。</target>
        </trans-unit>
        <trans-unit id="5905e93ff273c8c1408a7481f0933e6b894f0ba3" translate="yes" xml:space="preserve">
          <source>If we look at the &lt;code&gt;nbcases_ma&lt;/code&gt; masked array, this is what we have:</source>
          <target state="translated">&lt;code&gt;nbcases_ma&lt;/code&gt; マスクされた配列を見ると、次のようになっています。</target>
        </trans-unit>
        <trans-unit id="995e94e98f9bf00d5fa392b05fcaad89987b6cf9" translate="yes" xml:space="preserve">
          <source>If we operate on &lt;code&gt;arr&lt;/code&gt; with a numpy function, numpy will again use the &lt;code&gt;__array__&lt;/code&gt; interface to convert it to an array and then apply the function in the usual way.</source>
          <target state="translated">numpy関数を使用して &lt;code&gt;arr&lt;/code&gt; を操作する場合、numpyは再び &lt;code&gt;__array__&lt;/code&gt; インターフェイスを使用して配列に変換し、通常の方法で関数を適用します。</target>
        </trans-unit>
        <trans-unit id="a6db540dfc4c0d47c11450fd1091b665ccd4f2fc" translate="yes" xml:space="preserve">
          <source>If we subclass ndarray, we need to deal not only with explicit construction of our array type, but also &lt;a href=&quot;#view-casting&quot;&gt;View casting&lt;/a&gt; or &lt;a href=&quot;#new-from-template&quot;&gt;Creating new from template&lt;/a&gt;. NumPy has the machinery to do this, and it is this machinery that makes subclassing slightly non-standard.</source>
          <target state="translated">ndarrayをサブクラス化する場合は、配列型の明示的な構築だけでなく、&lt;a href=&quot;#view-casting&quot;&gt;ビューのキャスト&lt;/a&gt;や&lt;a href=&quot;#new-from-template&quot;&gt;テンプレートからの新規作成&lt;/a&gt;も処理する必要があります。NumPyにはこれを行うための機構があり、サブクラス化をわずかに非標準にするのはこの機構です。</target>
        </trans-unit>
        <trans-unit id="f97977f7edcb7ebd515a426a761fd048280b35b8" translate="yes" xml:space="preserve">
          <source>If we subclass ndarray, we need to deal not only with explicit construction of our array type, but also &lt;a href=&quot;#view-casting&quot;&gt;View casting&lt;/a&gt; or &lt;a href=&quot;#new-from-template&quot;&gt;Creating new from template&lt;/a&gt;. NumPy has the machinery to do this, and this machinery that makes subclassing slightly non-standard.</source>
          <target state="translated">ndarrayをサブクラス化する場合は、配列型の明示的な構築だけでなく、&lt;a href=&quot;#view-casting&quot;&gt;ビューのキャスト&lt;/a&gt;や&lt;a href=&quot;#new-from-template&quot;&gt;テンプレートからの新規作成&lt;/a&gt;も処理する必要があります。NumPyにはこれを行うための機構があり、サブクラス化をわずかに非標準にするこの機構があります。</target>
        </trans-unit>
        <trans-unit id="be3492efc8039f75947121fd3b30a1fa61841ee0" translate="yes" xml:space="preserve">
          <source>If we want to get the max and min at the same time, we can stack the indices first</source>
          <target state="translated">最大値と最小値を同時に取得したい場合は、最初にインデックスをスタックすることができます。</target>
        </trans-unit>
        <trans-unit id="0b08db0a15b738091c43209c89bb138ad98fa1a5" translate="yes" xml:space="preserve">
          <source>If writing to the value in &amp;lsquo;op&amp;rsquo; is desired, set the boolean &amp;lsquo;writeable&amp;rsquo; to 1. This raises an error when &amp;lsquo;op&amp;rsquo; is a scalar, list of lists, or other non-writeable &amp;lsquo;op&amp;rsquo;. This differs from passing &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; to PyArray_FromAny, where the writeable array may be a copy of the input.</source>
          <target state="translated">「op」の値への書き込みが必要な場合は、ブール値「writeable」を1に設定します。これにより、「op」がスカラー、リストのリスト、またはその他の書き込み不可能な「op」の場合、エラーが発生します。これは、書き込み可能な配列が入力のコピーである場合がある&lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;をPyArray_FromAnyに渡すこととは異なります。</target>
        </trans-unit>
        <trans-unit id="d75e358b391e7be55d7e5cd127dec8c0712acdf8" translate="yes" xml:space="preserve">
          <source>If you already have Matplotlib installed, you can import it with:</source>
          <target state="translated">すでにMatplotlibがインストールされている場合は、それを使ってインポートすることができます。</target>
        </trans-unit>
        <trans-unit id="7cdef2e4118adffef01cdccc2d7928ddab94e772" translate="yes" xml:space="preserve">
          <source>If you already have Python, you can install NumPy with:</source>
          <target state="translated">すでにPythonをお持ちの方は、NumPyをインストールしておきましょう。</target>
        </trans-unit>
        <trans-unit id="541c45cda5d06a312d0d288fb58df06c65cc4253" translate="yes" xml:space="preserve">
          <source>If you are a first-time contributor:</source>
          <target state="translated">初めて投稿される方</target>
        </trans-unit>
        <trans-unit id="f5262e9ba4f1ea7a14023d90619c6e73faa9ab31" translate="yes" xml:space="preserve">
          <source>If you are a maintainer, and it is not obvious from the PR description, add a short explanation of what a branch did to the merge message and, if closing an issue, also add &amp;ldquo;Closes gh-123&amp;rdquo; where 123 is the issue number.</source>
          <target state="translated">あなたがメンテナであり、PRの説明から明らかでない場合は、ブランチが行ったことの簡単な説明をマージメッセージに追加し、問題を閉じる場合は、「Closesgh-123」も追加します。123は問題番号です。 。</target>
        </trans-unit>
        <trans-unit id="62b5ecb7cbb27b133b9256518444e81bd1675873" translate="yes" xml:space="preserve">
          <source>If you are a subsequent reviewer on an already approved PR, please use the same review method as for a new PR (focus on the larger issues, resist the temptation to add only a few nitpicks). If you have commit rights and think no more review is needed, merge the PR.</source>
          <target state="translated">すでに承認されているPRの後続のレビュアーになる場合は、新しいPRと同じレビュー方法を使ってください(大きな問題に焦点を当て、いくつかの細かい点だけを追加したいという誘惑に負けないようにしてください)。コミット権があり、これ以上のレビューが必要ないと思われる場合は、PRをマージしてください。</target>
        </trans-unit>
        <trans-unit id="df553e5d4398ed0e4dcd8bdb41c75c9a32748a9c" translate="yes" xml:space="preserve">
          <source>If you are constructing an array using the C API, and specifying your own memory, you should use the function &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt;&lt;code&gt;PyArray_SetBaseObject&lt;/code&gt;&lt;/a&gt; to set the base to an object which owns the memory.</source>
          <target state="translated">C APIを使用して配列を作成し、独自のメモリを指定する場合は、関数&lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt; &lt;code&gt;PyArray_SetBaseObject&lt;/code&gt; &lt;/a&gt;を使用して、メモリを所有するオブジェクトにベースを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="348c2da24ae5fb5879e487ab21af4e5f5e066f22" translate="yes" xml:space="preserve">
          <source>If you are executing the commands above in the IPython shell, it might be necessary to use the command &lt;code&gt;plt.show()&lt;/code&gt; to show the image window.</source>
          <target state="translated">上記のコマンドをIPythonシェルで実行している場合は、コマンド &lt;code&gt;plt.show()&lt;/code&gt; を使用して画像ウィンドウを表示する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="c6a49d79de12888270772f40fca378141c156019" translate="yes" xml:space="preserve">
          <source>If you are executing the commands above in the IPython shell, it might be necessary to use the command &lt;code&gt;plt.show()&lt;/code&gt; to show the image window. Note also that we use a semicolon at the end of a line to suppress its output, but this is optional.</source>
          <target state="translated">上記のコマンドをIPythonシェルで実行している場合は、コマンド &lt;code&gt;plt.show()&lt;/code&gt; を使用して画像ウィンドウを表示する必要がある場合があります。行の終わりにセミコロンを使用して出力を抑制していることにも注意してください。ただし、これはオプションです。</target>
        </trans-unit>
        <trans-unit id="39a6add3139de0ce389e24494d0e34b85d48e6cd" translate="yes" xml:space="preserve">
          <source>If you are not a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend your class define special methods like &lt;code&gt;__add__&lt;/code&gt; and &lt;code&gt;__lt__&lt;/code&gt; that delegate to ufuncs just like ndarray does. An easy way to do this is to subclass from &lt;a href=&quot;generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt;&lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; の&lt;/a&gt;サブクラスでない場合は、 &lt;code&gt;__add__&lt;/code&gt; と同じようにufuncにデリゲートする__add__ や &lt;code&gt;__lt__&lt;/code&gt; などの特別なメソッドをクラスで定義することをお勧めします。これを行う簡単な方法は、&lt;a href=&quot;generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt; &lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt; &lt;/a&gt;からサブクラス化することです。</target>
        </trans-unit>
        <trans-unit id="7c035b2fcdae27121ab8105788f03a3cf705ba84" translate="yes" xml:space="preserve">
          <source>If you are unfamiliar with git/GitHub or the process of submitting a pull request (PR), check our &lt;a href=&quot;index#devindex&quot;&gt;Contributor Guide&lt;/a&gt;.</source>
          <target state="translated">git / GitHubまたはプルリクエスト（PR）を送信するプロセスに慣れていない場合は、&lt;a href=&quot;index#devindex&quot;&gt;コントリビューターガイドを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="ad4921cf970b61f597c75ff9a8df48494b979251" translate="yes" xml:space="preserve">
          <source>If you are unsure whether your tutorial is useful to the community, consider submitting an issue on GitHub suggesting it, or asking on the mailing list or Stack Overflow.</source>
          <target state="translated">自分のチュートリアルがコミュニティにとって有用かどうかわからない場合は、GitHub で課題を提出して提案したり、メーリングリストや Stack Overflow で質問したりすることを検討してみてください。</target>
        </trans-unit>
        <trans-unit id="0e97815d05cf1a3f4e8ef4ccabd6db0958203378" translate="yes" xml:space="preserve">
          <source>If you are using a development setup, make sure to run &lt;code&gt;git clean -xdf&lt;/code&gt; to delete all files not under version control (be careful not to lose any modifications you made, e.g. &lt;code&gt;site.cfg&lt;/code&gt;). In many cases files from old builds may lead to incorrect builds.</source>
          <target state="translated">開発セットアップを使用している場合は、必ず &lt;code&gt;git clean -xdf&lt;/code&gt; を実行して、バージョン管理されていないすべてのファイルを削除してください（ &lt;code&gt;site.cfg&lt;/code&gt; などの変更を失わないように注意してください）。多くの場合、古いビルドのファイルは誤ったビルドにつながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="b1cb5159432a421c78854c686fcae1e006f9ca62" translate="yes" xml:space="preserve">
          <source>If you are using your own image, this command might take a while to run, depending on the size of your image and your hardware. Don&amp;rsquo;t worry, this is normal! The SVD can be a pretty intensive computation.</source>
          <target state="translated">独自のイメージを使用している場合、イメージのサイズとハードウェアによっては、このコマンドの実行に時間がかかる場合があります。心配しないでください、これは正常です！SVDはかなり集中的な計算になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="430c1a827d0587f2549b92fdcd570838e5c44e06" translate="yes" xml:space="preserve">
          <source>If you are writing a package that you&amp;rsquo;d like to become part of NumPy, please write the tests as you develop the package. Every Python module, extension module, or subpackage in the NumPy package directory should have a corresponding &lt;code&gt;test_&amp;lt;name&amp;gt;.py&lt;/code&gt; file. Pytest examines these files for test methods (named &lt;code&gt;test*&lt;/code&gt;) and test classes (named &lt;code&gt;Test*&lt;/code&gt;).</source>
          <target state="translated">NumPyの一部になりたいパッケージを作成している場合は、パッケージを開発するときにテストを作成してください。NumPyパッケージディレクトリ内のすべてのPythonモジュール、拡張モジュール、またはサブパッケージには、対応する &lt;code&gt;test_&amp;lt;name&amp;gt;.py&lt;/code&gt; ファイルが必要です。Pytestは、これらのファイルを調べて、テストメソッド（ &lt;code&gt;test*&lt;/code&gt; という名前）とテストクラス（ &lt;code&gt;Test*&lt;/code&gt; という名前）を探します。</target>
        </trans-unit>
        <trans-unit id="773329737315bec4048498e2cb47eae44fac50c7" translate="yes" xml:space="preserve">
          <source>If you are writing a tutorial or how-to, we encourage you to use real images and data (provided they are appropriately licensed and available). This makes the material more engaging for readers, and choosing the right data can add pedagogical value to your content.</source>
          <target state="translated">チュートリアルやハウツーを書く場合は、実際の画像やデータを使用することをお勧めします(適切なライセンスを取得し、利用可能な場合に限ります)。これにより、教材は読者をより魅力的なものにし、適切なデータを選択することで、コンテンツに教育的な価値を付加することができます。</target>
        </trans-unit>
        <trans-unit id="d4136f331004a4bb7cc67364f6afc023fd507b25" translate="yes" xml:space="preserve">
          <source>If you are writing an extension module that will include quite a bit of your own algorithmic code as well, then Cython is a good match. Among its features is the ability to easily and quickly work with multidimensional arrays.</source>
          <target state="translated">もしあなたが独自のアルゴリズムコードを含む拡張モジュールを書くのであれば、Cythonが適しています。Cythonの機能の中には、多次元配列を簡単かつ迅速に扱える機能があります。</target>
        </trans-unit>
        <trans-unit id="97bfbc5e92312fd81c84cc357b8b556f1c360029" translate="yes" xml:space="preserve">
          <source>If you are writing code that needs to support older versions of numpy, note that prior to 1.15, &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; was not a context manager and did not have a &lt;code&gt;close&lt;/code&gt; method. Instead it relied on the destructor to initiate the writeback of the buffer.</source>
          <target state="translated">古いバージョンのnumpyをサポートする必要のあるコードを記述している場合、1.15より前は、&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;はコンテキストマネージャーではなく、 &lt;code&gt;close&lt;/code&gt; メソッドがなかったことに注意してください。代わりに、バッファのライトバックを開始するためにデストラクタに依存していました。</target>
        </trans-unit>
        <trans-unit id="36ae6f737ad58a255ae0b7d304bf552b5362f8bf" translate="yes" xml:space="preserve">
          <source>If you are writing the algorithm, then I recommend that you use the stride information contained in the array to access the elements of the array (the &lt;a href=&quot;../reference/c-api/array#c.PyArray_GetPtr&quot;&gt;&lt;code&gt;PyArray_GetPtr&lt;/code&gt;&lt;/a&gt; macros make this painless). Then, you can relax your requirements so as not to force a single-segment array and the data-copying that might result.</source>
          <target state="translated">アルゴリズムを作成している場合は、配列に含まれているストライド情報を使用して配列の要素にアクセスすることをお勧めします（&lt;a href=&quot;../reference/c-api/array#c.PyArray_GetPtr&quot;&gt; &lt;code&gt;PyArray_GetPtr&lt;/code&gt; &lt;/a&gt;マクロを使用すると簡単にアクセスできます）。次に、要件を緩和して、単一セグメントの配列とその結果生じる可能性のあるデータコピーを強制しないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="b55dd90ddf002e60cb33ced8fd77f1baf2f3e711" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t already comfortable with reading tutorials that contain a lot of code, you might not know how to interpret a code block that looks like this:</source>
          <target state="translated">多くのコードを含むチュートリアルを読むことにまだ慣れていない場合は、次のようなコードブロックを解釈する方法がわからない可能性があります。</target>
        </trans-unit>
        <trans-unit id="0aadabdedda0a7396088f7e7156f2221bf29f201" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t familiar with this style, it&amp;rsquo;s very easy to understand. If you see &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, you&amp;rsquo;re looking at &lt;strong&gt;input&lt;/strong&gt;, or the code that you would enter. Everything that doesn&amp;rsquo;t have &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; in front of it is &lt;strong&gt;output&lt;/strong&gt;, or the results of running your code. This is the style you see when you run &lt;code&gt;python&lt;/code&gt; on the command line, but if you&amp;rsquo;re using IPython, you might see a different style.</source>
          <target state="translated">このスタイルに慣れていない場合は、非常に理解しやすいです。 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; が表示されている場合は、&lt;strong&gt;入力&lt;/strong&gt;または&lt;strong&gt;入力&lt;/strong&gt;するコードを確認しています。 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; が前にないものはすべて&lt;strong&gt;出力される&lt;/strong&gt;か、コードの実行結果です。これは、コマンドラインで &lt;code&gt;python&lt;/code&gt; を実行したときに表示されるスタイルですが、IPythonを使用している場合は、別のスタイルが表示される場合があります。</target>
        </trans-unit>
        <trans-unit id="bb14ac1edba829d3112a46c925f71b9aef58fe4d" translate="yes" xml:space="preserve">
          <source>If you begin with a 1D array like this one:</source>
          <target state="translated">このように1次元配列から始めると</target>
        </trans-unit>
        <trans-unit id="241e24cd0257dc01f27616c2644b10c2652843e7" translate="yes" xml:space="preserve">
          <source>If you can&amp;rsquo;t avoid or eliminate missing values, but don&amp;rsquo;t want to deal with &lt;a href=&quot;../reference/constants#numpy.nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt; (Not A Number) values in your operations.</source>
          <target state="translated">欠落している値を回避または排除できないが、操作で&lt;a href=&quot;../reference/constants#numpy.nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt;（数値ではない）値を処理したくない場合。</target>
        </trans-unit>
        <trans-unit id="50d785ffa376c738acba9fd3062d7ce8c3507854" translate="yes" xml:space="preserve">
          <source>If you construct an array by passing in your own memory buffer as a parameter, you need to set the array&amp;rsquo;s &lt;code&gt;base&lt;/code&gt; property to ensure the lifetime of the memory buffer is appropriate.</source>
          <target state="translated">独自のメモリバッファをパラメータとして渡すことによって配列を構築する場合、メモリバッファの寿命が適切であることを保証するために、配列の &lt;code&gt;base&lt;/code&gt; プロパティを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="5a09672523495c2e56a3b155436551396bec1686" translate="yes" xml:space="preserve">
          <source>If you created this array &amp;ldquo;a&amp;rdquo;</source>
          <target state="translated">この配列「a」を作成した場合</target>
        </trans-unit>
        <trans-unit id="72ea524f17d30ae2b5b06f8b246da402ecc0aab1" translate="yes" xml:space="preserve">
          <source>If you define &lt;code&gt;__array_ufunc__&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;__array_ufunc__&lt;/code&gt; を定義する場合：</target>
        </trans-unit>
        <trans-unit id="ad02ce8758b2b7ef1353b5d6ceccf301d0d32341" translate="yes" xml:space="preserve">
          <source>If you depend on the current behavior, then we suggest copying the returned array explicitly, i.e., use &lt;code&gt;np.diagonal(a).copy()&lt;/code&gt; instead of just &lt;code&gt;np.diagonal(a)&lt;/code&gt;. This will work with both past and future versions of NumPy.</source>
          <target state="translated">現在の動作に依存している場合は、返された配列を明示的にコピーすることをお勧めします。つまり、単に &lt;code&gt;np.diagonal(a)&lt;/code&gt; ではなく &lt;code&gt;np.diagonal(a).copy()&lt;/code&gt; を使用します。これは、NumPyの過去のバージョンと将来のバージョンの両方で機能します。</target>
        </trans-unit>
        <trans-unit id="e04ecd6da4be5a785c0ba7636ed164c9197444de" translate="yes" xml:space="preserve">
          <source>If you didn&amp;rsquo;t actually mess up but there are merge conflicts, you need to resolve those. This can be one of the trickier things to get right. For a good description of how to do this, see &lt;a href=&quot;https://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging#Basic-Merge-Conflicts&quot;&gt;this article on merging conflicts&lt;/a&gt;.</source>
          <target state="translated">実際に混乱していなくても、マージの競合がある場合は、それらを解決する必要があります。これは、正しく行うのが難しいことの1つになる可能性があります。これを行う方法の適切な説明については、&lt;a href=&quot;https://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging#Basic-Merge-Conflicts&quot;&gt;競合のマージに関するこの記事を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e434a6791515ca1be095b9c944cc43b7244bf754" translate="yes" xml:space="preserve">
          <source>If you do this often, consider making CDN_URL and NPY_WHLS part of your default environment.</source>
          <target state="translated">このようなことを頻繁に行う場合は、CDN_URLとNPY_WHLSをデフォルト環境の一部にすることを検討してください。</target>
        </trans-unit>
        <trans-unit id="48d4a9d3c1a910573f5c99d8162fc661353211a4" translate="yes" xml:space="preserve">
          <source>If you do want to use Fortran ordering realize that there are two approaches to consider: 1) accept that the first index is just not the most rapidly changing in memory and have all your I/O routines reorder your data when going from memory to disk or visa versa, or use numpy&amp;rsquo;s mechanism for mapping the first index to the most rapidly varying data. We recommend the former if possible. The disadvantage of the latter is that many of numpy&amp;rsquo;s functions will yield arrays without Fortran ordering unless you are careful to use the &amp;lsquo;order&amp;rsquo; keyword. Doing this would be highly inconvenient.</source>
          <target state="translated">Fortranの順序付けを使用したい場合は、2つのアプローチを検討する必要があることを理解してください。1）最初のインデックスがメモリ内で最も急速に変化していないことを受け入れ、メモリからディスクに移動するときにすべてのI / Oルーチンでデータを並べ替えます。またはその逆、またはnumpyのメカニズムを使用して、最初のインデックスを最も急速に変化するデータにマッピングします。できれば前者をお勧めします。後者の欠点は、「order」キーワードを慎重に使用しない限り、numpyの関数の多くがFortran順序付けなしで配列を生成することです。これを行うのは非常に不便です。</target>
        </trans-unit>
        <trans-unit id="e095aad5306acb61c4cd71ef6f17e3d170477a48" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have Python yet, you might want to consider using &lt;a href=&quot;https://www.anaconda.com/&quot;&gt;Anaconda&lt;/a&gt;. It&amp;rsquo;s the easiest way to get started. The good thing about getting this distribution is the fact that you don&amp;rsquo;t need to worry too much about separately installing NumPy or any of the major packages that you&amp;rsquo;ll be using for your data analyses, like pandas, Scikit-Learn, etc.</source>
          <target state="translated">Pythonをまだお持ちでない場合は、&lt;a href=&quot;https://www.anaconda.com/&quot;&gt;Anacondaの&lt;/a&gt;使用を検討することをお勧めします。始めるのに最も簡単な方法です。このディストリビューションを入手することの良い点は、NumPyや、パンダ、Scikit-Learnなどのデータ分析に使用する主要なパッケージを個別にインストールすることについてあまり心配する必要がないという事実です。</target>
        </trans-unit>
        <trans-unit id="a32666f1e22aaef44f676905cda497776944f399" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have a &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; account, go to the &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; page, and make one.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;アカウントをお持ちでない場合は、&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;ページにアクセスして作成してください。</target>
        </trans-unit>
        <trans-unit id="a5bbc2f6b8c16d724bb2e3ebb23419fa6ae79cb5" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have a GitHub account, visit &lt;a href=&quot;https://github.com/join&quot;&gt;https://github.com/join&lt;/a&gt; to create one.</source>
          <target state="translated">GitHubアカウントをお持ちでない場合は、&lt;a href=&quot;https://github.com/join&quot;&gt;https：//github.com/joinにアクセス&lt;/a&gt;してアカウントを作成してください。</target>
        </trans-unit>
        <trans-unit id="00332ddab35edaceba6aacb138a662dde934bdb6" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t write to the array returned by this function, then you can just ignore all of the above.</source>
          <target state="translated">この関数によって返された配列に書き込まない場合は、上記のすべてを無視できます。</target>
        </trans-unit>
        <trans-unit id="ddf01261f92656913e0a2ec2a624205e1c2e4b27" translate="yes" xml:space="preserve">
          <source>If you forgot to make a backup branch:</source>
          <target state="translated">バックアップブランチを作るのを忘れていたら</target>
        </trans-unit>
        <trans-unit id="fe80a2730dc1732963891b3491f20ea69996dc7b" translate="yes" xml:space="preserve">
          <source>If you get a Python error that looks like the following:</source>
          <target state="translated">以下のようなPythonのエラーが出たら</target>
        </trans-unit>
        <trans-unit id="a53df4d5bfbd08adf0a5725999a9e0795dcb81f8" translate="yes" xml:space="preserve">
          <source>If you have a collection of tests that must be run multiple times with minor variations, it can be helpful to create a base class containing all the common tests, and then create a subclass for each variation. Several examples of this technique exist in NumPy; below are excerpts from one in &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py&quot;&gt;numpy/linalg/tests/test_linalg.py&lt;/a&gt;:</source>
          <target state="translated">マイナーバリエーションで複数回実行する必要があるテストのコレクションがある場合は、すべての一般的なテストを含む基本クラスを作成し、バリエーションごとにサブクラスを作成すると便利です。この手法のいくつかの例がNumPyに存在します。以下は、&lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py&quot;&gt;numpy / linalg / tests / test_linalg.pyの&lt;/a&gt; 1 つからの抜粋です。</target>
        </trans-unit>
        <trans-unit id="b76d68a8292694b360bf5a2e8b28bbbb6775f004" translate="yes" xml:space="preserve">
          <source>If you have already decided which type of document you want to write, you can check out the following specific guides:</source>
          <target state="translated">どのタイプの文書を書くかが決まっている場合は、以下のような具体的なガイドを参考にしてみてはいかがでしょうか。</target>
        </trans-unit>
        <trans-unit id="edd73a9e41446ceec5844edddba90601c9a86d6a" translate="yes" xml:space="preserve">
          <source>If you have an array of datetime64 day values, and you want a count of how many of them are valid dates, you can do this:</source>
          <target state="translated">datetime64日分の値の配列を持っていて、そのうちのいくつが有効な日付であるかを数えたい場合は、これを行うことができます。</target>
        </trans-unit>
        <trans-unit id="afdea327e298d690859d2830125b0506072aa9c8" translate="yes" xml:space="preserve">
          <source>If you have made changes to files that have changed also upstream, this may generate merge conflicts that you need to resolve. See &lt;a href=&quot;#recovering-from-mess-up&quot;&gt;below&lt;/a&gt; for help in this case.</source>
          <target state="translated">アップストリームでも変更されたファイルに変更を加えた場合、これにより、解決する必要のあるマージの競合が発生する可能性があります。この場合のヘルプについては、&lt;a href=&quot;#recovering-from-mess-up&quot;&gt;以下&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3940d12fada6e74d3a4f390741c7084734cc9f7c" translate="yes" xml:space="preserve">
          <source>If you have worked before with only one- or two-dimensional arrays in NumPy, you might use &lt;a href=&quot;../reference/generated/numpy.dot#numpy.dot&quot;&gt;&lt;code&gt;numpy.dot&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;numpy.matmul&lt;/code&gt;&lt;/a&gt; (or the &lt;code&gt;@&lt;/code&gt; operator) interchangeably. However, for n-dimensional arrays, they work in very different ways. For more details, check the documentation &lt;a href=&quot;../reference/generated/numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;numpy.matmul&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">以前にNumPyで1次元または2次元の配列のみを使用したことがある場合は、&lt;a href=&quot;../reference/generated/numpy.dot#numpy.dot&quot;&gt; &lt;code&gt;numpy.dot&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../reference/generated/numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;numpy.matmul&lt;/code&gt; &lt;/a&gt;（または &lt;code&gt;@&lt;/code&gt; 演算子）を同じ意味で使用できます。ただし、n次元配列の場合、それらは非常に異なる方法で機能します。詳細については、ドキュメント&lt;a href=&quot;../reference/generated/numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;numpy.matmul&lt;/code&gt; を&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="61245264d3565a00eccec23e4c121348aa40e38c" translate="yes" xml:space="preserve">
          <source>If you index &lt;code&gt;x&lt;/code&gt; at position 1 you get a structure:</source>
          <target state="translated">位置1で &lt;code&gt;x&lt;/code&gt; にインデックスを付けると、次の構造が得られます。</target>
        </trans-unit>
        <trans-unit id="19e171dd0ccd0c17916e231c961dda814be7cba5" translate="yes" xml:space="preserve">
          <source>If you just use Cython to compile a standard Python module, then you will get a C extension module that typically runs a bit faster than the equivalent Python module. Further speed increases can be gained by using the &lt;code&gt;cdef&lt;/code&gt; keyword to statically define C variables.</source>
          <target state="translated">Cythonを使用して標準のPythonモジュールをコンパイルするだけの場合、通常、同等のPythonモジュールよりも少し高速に実行されるC拡張モジュールを取得します。 &lt;code&gt;cdef&lt;/code&gt; キーワードを使用してC変数を静的に定義することにより、さらに速度を上げることができます。</target>
        </trans-unit>
        <trans-unit id="d4f3f5ddc9a07a1a97f869fb8e6afa7a875ab6d2" translate="yes" xml:space="preserve">
          <source>If you know you have boolean arguments, you can get away with using NumPy&amp;rsquo;s bitwise operators, but be careful with parentheses, like this: &lt;code&gt;z
= (x &amp;gt; 1) &amp;amp; (x &amp;lt; 2)&lt;/code&gt;. The absence of NumPy operator forms of &lt;code&gt;logical_and&lt;/code&gt; and &lt;code&gt;logical_or&lt;/code&gt; is an unfortunate consequence of Python&amp;rsquo;s design.</source>
          <target state="translated">ブール引数があることがわかっている場合は、NumPyのビット演算子を使用する必要はありませんが、次のように括弧に注意してください： &lt;code&gt;z = (x &amp;gt; 1) &amp;amp; (x &amp;lt; 2)&lt;/code&gt; 。 &lt;code&gt;logical_and&lt;/code&gt; と &lt;code&gt;logical_or&lt;/code&gt; のNumPy演算子形式がないことは、Pythonの設計の残念な結果です。</target>
        </trans-unit>
        <trans-unit id="0c28db0c64cef3fce82c680e83d5a3bf5a7d6611" translate="yes" xml:space="preserve">
          <source>If you know you have boolean arguments, you can get away with using NumPy&amp;rsquo;s bitwise operators, but be careful with parentheses, like this: z = (x &amp;gt; 1) &amp;amp; (x &amp;lt; 2). The absence of NumPy operator forms of logical_and and logical_or is an unfortunate consequence of Python&amp;rsquo;s design.</source>
          <target state="translated">ブール引数があることがわかっている場合は、NumPyのビット演算子を使用する必要はありませんが、次のように括弧に注意してください：z =（x&amp;gt; 1）＆（x &amp;lt;2）。logic_andおよびlogical_orのNumPy演算子形式がないことは、Pythonの設計の残念な結果です。</target>
        </trans-unit>
        <trans-unit id="b50bdabfd893e921c2545949ea3927871fd9123c" translate="yes" xml:space="preserve">
          <source>If you mess up during a rebase:</source>
          <target state="translated">リベース中に失敗したら</target>
        </trans-unit>
        <trans-unit id="d5b391b72fd29e26b5330f8bc73fd6e0406a58fe" translate="yes" xml:space="preserve">
          <source>If you need a stricter way to identify a &lt;em&gt;numerical&lt;/em&gt; scalar, use &lt;code&gt;isinstance(x, numbers.Number)&lt;/code&gt;, as that returns &lt;code&gt;False&lt;/code&gt; for most non-numerical elements such as strings.</source>
          <target state="translated">&lt;em&gt;数値&lt;/em&gt;スカラーを識別するためのより厳密な方法が必要な場合は、 &lt;code&gt;isinstance(x, numbers.Number)&lt;/code&gt; ）を使用します。これは、文字列などのほとんどの非数値要素に対して &lt;code&gt;False&lt;/code&gt; を返すためです。</target>
        </trans-unit>
        <trans-unit id="c4cb8ac1ba0fb6fc334cc562794b2ebe83f971f7" translate="yes" xml:space="preserve">
          <source>If you need help writing replies in reviews, check out some &lt;a href=&quot;https://scikit-learn.org/stable/developers/tips.html#saved-replies&quot;&gt;Standard replies for reviewing&lt;/a&gt;.</source>
          <target state="translated">レビューに返信を書くのに助けが必要な場合は、レビュー&lt;a href=&quot;https://scikit-learn.org/stable/developers/tips.html#saved-replies&quot;&gt;用の&lt;/a&gt;いくつかの標準返信を確認してください。</target>
        </trans-unit>
        <trans-unit id="6b620559920ae0493b1df8c4590d21b79ff5570f" translate="yes" xml:space="preserve">
          <source>If you need to generate a good seed &amp;ldquo;offline&amp;rdquo;, then &lt;code&gt;SeedSequence().entropy&lt;/code&gt; or using &lt;code&gt;secrets.randbits(128)&lt;/code&gt; from the standard library are both convenient ways.</source>
          <target state="translated">「オフライン」で適切なシードを生成する必要がある場合、 &lt;code&gt;SeedSequence().entropy&lt;/code&gt; または標準ライブラリからの &lt;code&gt;secrets.randbits(128)&lt;/code&gt; の使用はどちらも便利な方法です。</target>
        </trans-unit>
        <trans-unit id="9dadc35707bb7693c411ca705b6a79a8fd4bc6a1" translate="yes" xml:space="preserve">
          <source>If you need to generate a plot for your values, it&amp;rsquo;s very simple with &lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt;.</source>
          <target state="translated">値のプロットを生成する必要がある場合は、&lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlibを使用する&lt;/a&gt;と非常に簡単です。</target>
        </trans-unit>
        <trans-unit id="cd4f29a22f2d83f814cd7d3d9fed381be8da6e41" translate="yes" xml:space="preserve">
          <source>If you notice you messed up after the rebase:</source>
          <target state="translated">リベースしてから気がついたらめちゃくちゃになっていた。</target>
        </trans-unit>
        <trans-unit id="ee201455e7a9931a5a44547dd0593d53785f3676" translate="yes" xml:space="preserve">
          <source>If you obtained NumPy via git, get also the git submodules that contain additional parts required for building the documentation:</source>
          <target state="translated">NumPyをgit経由で取得した場合は、ドキュメントの構築に必要な追加パーツを含むgitサブモジュールも取得してください。</target>
        </trans-unit>
        <trans-unit id="fafc92af92f970e1f9bc871b99562e2a4dcbfd58" translate="yes" xml:space="preserve">
          <source>If you only had $150/month to pay towards the loan, how long would it take to pay-off a loan of $8,000 at 7% annual interest?</source>
          <target state="translated">月々150ドルしかローンの支払いができなかった場合、年利7%で8000ドルのローンを完済するにはどのくらいの期間がかかるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="f1851d09e17596b6fef1418fbf6cd4eb3f3c1218" translate="yes" xml:space="preserve">
          <source>If you only want to get the documentation, note that pre-built versions can be found at</source>
          <target state="translated">ドキュメントを手に入れたいだけなら、ビルド済みのバージョンは次の場所にあります。</target>
        </trans-unit>
        <trans-unit id="cdaa058c528b9ed4b2670e6e57274ac82ee4b4cf" translate="yes" xml:space="preserve">
          <source>If you plan a new feature or API change, it&amp;rsquo;s wisest to first email the NumPy &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;mailing list&lt;/a&gt; asking for comment. If you haven&amp;rsquo;t heard back in a week, it&amp;rsquo;s OK to ping the list again.</source>
          <target state="translated">新しい機能やAPIの変更を計画している場合は、最初にNumPy&lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;メーリングリスト&lt;/a&gt;にコメントを求めるメールを送信するのが賢明です。1週間経っても返信がない場合は、リストに再度pingを送信しても問題ありません。</target>
        </trans-unit>
        <trans-unit id="4ba77d4ac4c0346cf08567fdade124408903e3ad" translate="yes" xml:space="preserve">
          <source>If you prefer, you can use your own image as you work through this tutorial. In order to transform your image into a NumPy array that can be manipulated, you can use the &lt;code&gt;imread&lt;/code&gt; function from the &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.html#module-matplotlib.pyplot&quot;&gt;&lt;code&gt;matplotlib.pyplot&lt;/code&gt;&lt;/a&gt; submodule. Alternatively, you can use the &lt;a href=&quot;https://imageio.readthedocs.io/en/stable/userapi.html#imageio.imread&quot;&gt;&lt;code&gt;imageio.imread&lt;/code&gt;&lt;/a&gt; function from the &lt;code&gt;imageio&lt;/code&gt; library. Be aware that if you use your own image, you&amp;rsquo;ll likely need to adapt the steps below. For more information on how images are treated when converted to NumPy arrays, see &lt;a href=&quot;https://scikit-image.org/docs/stable/user_guide/numpy_images.html&quot;&gt;A crash course on NumPy for images&lt;/a&gt; from the &lt;code&gt;scikit-image&lt;/code&gt; documentation.</source>
          <target state="translated">必要に応じて、このチュートリアルで作業するときに独自の画像を使用できます。画像を操作可能なNumPy配列に変換するために、&lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.html#module-matplotlib.pyplot&quot;&gt; &lt;code&gt;matplotlib.pyplot&lt;/code&gt; &lt;/a&gt;サブモジュールの &lt;code&gt;imread&lt;/code&gt; 関数を使用できます。または、 &lt;code&gt;imageio&lt;/code&gt; ライブラリの&lt;a href=&quot;https://imageio.readthedocs.io/en/stable/userapi.html#imageio.imread&quot;&gt; &lt;code&gt;imageio.imread&lt;/code&gt; &lt;/a&gt;関数を使用することもできます。独自の画像を使用する場合は、以下の手順を調整する必要がある可能性があることに注意してください。NumPy配列に変換されたときの画像の処理方法の詳細については、 &lt;code&gt;scikit-image&lt;/code&gt; ドキュメントの&lt;a href=&quot;https://scikit-image.org/docs/stable/user_guide/numpy_images.html&quot;&gt;画像に関するNumPyのクラッシュコースを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="163df9c9003b7c4450bb235f2c67b2a07c0207a6" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;f2py&lt;/code&gt; with no arguments, and the line &lt;code&gt;numpy Version&lt;/code&gt; at the end matches the NumPy version printed from &lt;code&gt;python -m numpy.f2py&lt;/code&gt;, then you can use the shorter version. If not, or if you cannot run &lt;code&gt;f2py&lt;/code&gt;, you should replace all calls to &lt;code&gt;f2py&lt;/code&gt; here with the longer version.</source>
          <target state="translated">引数なしで &lt;code&gt;f2py&lt;/code&gt; を実行し、最後の行 &lt;code&gt;numpy Version&lt;/code&gt; が &lt;code&gt;python -m numpy.f2py&lt;/code&gt; から出力されたNumPyバージョンと一致する場合は、短いバージョンを使用できます。そうでない場合、または &lt;code&gt;f2py&lt;/code&gt; を実行できない場合は、ここで &lt;code&gt;f2py&lt;/code&gt; へのすべての呼び出しをより長いバージョンに置き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="e2ea4dd191a98ee740334a65dcfa6ac018c3ad8c" translate="yes" xml:space="preserve">
          <source>If you run across outside material that would be a useful addition to the NumPy docs, let us know by &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;opening an issue&lt;/a&gt;.</source>
          <target state="translated">NumPyドキュメントへの追加に役立つ外部の資料に出くわした場合は&lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;、問題を開いて&lt;/a&gt;お知らせください。</target>
        </trans-unit>
        <trans-unit id="c2f8a5ed085feb6d7cb818c6bb6a9239c65b61dd" translate="yes" xml:space="preserve">
          <source>If you run into a situation where a function or method is returning a pointer to an array, your best bet is to write your own version of the function to be wrapped, either with &lt;code&gt;%extend&lt;/code&gt; for the case of class methods or &lt;code&gt;%ignore&lt;/code&gt; and &lt;code&gt;%rename&lt;/code&gt; for the case of functions.</source>
          <target state="translated">関数またはメソッドが配列へのポインターを返す状況に遭遇した場合、最善の策は、ラップする関数の独自のバージョンを記述することです。クラスメソッドの場合は &lt;code&gt;%extend&lt;/code&gt; 、または &lt;code&gt;%ignore&lt;/code&gt; および &lt;code&gt;%rename&lt;/code&gt; 関数の場合は名前を変更します。</target>
        </trans-unit>
        <trans-unit id="2a7a60ee3a192da84e7197524a79fee3ab370312" translate="yes" xml:space="preserve">
          <source>If you see a good tutorial, how-to or explanation that is not included in the official documentation, you can suggest it to be added by &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;opening an issue on GitHub&lt;/a&gt;. Similarly, opening issues to suggest a tutorial, how-to or explanation that you can&amp;rsquo;t find anywhere is a great way to help the documentation team direct efforts towards what users are looking for. &lt;a href=&quot;https://github.com/numpy/numpy/issues/15760&quot;&gt;See this issue&lt;/a&gt; for an example of how to do this.</source>
          <target state="translated">公式ドキュメントに含まれていない優れたチュートリアル、ハウツー、または説明を見つけた場合は&lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;、GitHubで問題を開いて&lt;/a&gt;追加することを提案できます。同様に、どこにも見つからないチュートリアル、ハウツー、または説明を提案するために問題を開くことは、ドキュメントチームがユーザーが探しているものに向けて努力を向けるのに役立つ優れた方法です。&lt;a href=&quot;https://github.com/numpy/numpy/issues/15760&quot;&gt;これ&lt;/a&gt;を行う方法の例については、この問題を参照してください。</target>
        </trans-unit>
        <trans-unit id="c084a3f2a6106a54039205662cc0565194fa0738" translate="yes" xml:space="preserve">
          <source>If you specify an &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;a&lt;/code&gt; must be zero-padded or truncated, the extra/removed values will be added/removed at high frequencies. One can thus resample a series to &lt;code&gt;m&lt;/code&gt; points via Fourier interpolation by: &lt;code&gt;a_resamp = irfft(rfft(a), m)&lt;/code&gt;.</source>
          <target state="translated">あなたが指定した場合 &lt;code&gt;n&lt;/code&gt; ようなゼロパディングまたは切り捨てられている必要があり、余分な/削除値が高頻度で追加/削除されます。したがって、 &lt;code&gt;a_resamp = irfft(rfft(a), m)&lt;/code&gt; によってフーリエ補間を介してシリーズを &lt;code&gt;m&lt;/code&gt; ポイントにリサンプリングできます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dd256004a74583cc184f8439d5d048c30d412fb7" translate="yes" xml:space="preserve">
          <source>If you start with these arrays:</source>
          <target state="translated">これらの配列から始めると</target>
        </trans-unit>
        <trans-unit id="b2448ad4b64da661ec458b63dd3b9923ea02aca5" translate="yes" xml:space="preserve">
          <source>If you start with this array:</source>
          <target state="translated">この配列から始めた場合</target>
        </trans-unit>
        <trans-unit id="777d1be2db0dc4450d7b4eef96ddf2f8d5888d83" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend that you put all your override logic in &lt;code&gt;__array_ufunc__&lt;/code&gt; and not also override special methods. This ensures the class hierarchy is determined in only one place rather than separately by the ufunc machinery and by the binary operation rules (which gives preference to special methods of subclasses; the alternative way to enforce a one-place only hierarchy, of setting &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, would seem very unexpected and thus confusing, as then the subclass would not work at all with ufuncs).</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;をサブクラス化する場合、すべてのオーバーライドロジックを &lt;code&gt;__array_ufunc__&lt;/code&gt; に配置し、特別なメソッドもオーバーライドしないことをお勧めします。のみ階層ワン場所を強制する別の方法は、設定で、これは、クラス階層はサブクラスの特別な方法に優先を与える（ufunc機械によって、および二項演算規則によって唯一の場所ではなく、別々に決定されることを保証&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; を&lt;/a&gt;します&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;、サブクラスがufuncsでまったく機能しないため、非常に予期せず混乱を招くように見えます。</target>
        </trans-unit>
        <trans-unit id="2b988c177dc2b27c86ba6dc5904e8834a5cbf804" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend that you put all your override logic in &lt;code&gt;__array_ufunc__&lt;/code&gt; and not also override special methods. This ensures the class hierarchy is determined in only one place rather than separately by the ufunc machinery and by the binary operation rules (which gives preference to special methods of subclasses; the alternative way to enforce a one-place only hierarchy, of setting &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; to None, would seem very unexpected and thus confusing, as then the subclass would not work at all with ufuncs).</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;をサブクラス化する場合は、すべてのオーバーライドロジックを &lt;code&gt;__array_ufunc__&lt;/code&gt; に配置し、特別なメソッドもオーバーライドしないことをお勧めします。これにより、クラス階層は、ufunc機構と二項演算ルール（サブクラスの特別なメソッドを優先します。1か所のみの階層を適用する別の方法である&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;をどれも、非常に予想外で混乱しているように見えます。その場合、サブクラスはufuncsではまったく機能しません）。</target>
        </trans-unit>
        <trans-unit id="68630e24ebcf26648c6330182b68ffff11c7fe21" translate="yes" xml:space="preserve">
          <source>If you want to allow your new data-type to also be able to share in the scalar coercion rules, then you need to specify the scalarkind function in the data-type object&amp;rsquo;s &amp;ldquo;.f&amp;rdquo; member to return the kind of scalar the new data-type should be seen as (the value of the scalar is available to that function). Then, you can register data-types that can be cast to separately for each scalar kind that may be returned from your user-defined data-type. If you don&amp;rsquo;t register scalar coercion handling, then all of your user-defined data-types will be seen as &lt;a href=&quot;../reference/c-api/array#c.NPY_NOSCALAR&quot;&gt;&lt;code&gt;NPY_NOSCALAR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">新しいデータ型がスカラー強制ルールでも共有できるようにする場合は、データ型オブジェクトの「.f」メンバーでscalarkind関数を指定して、新しいデータのスカラーの種類を返す必要があります。 -typeは次のように見なされます（スカラーの値はその関数で使用できます）。次に、ユーザー定義のデータ型から返される可能性のあるスカラーの種類ごとに個別にキャストできるデータ型を登録できます。スカラー強制処理を登録しない場合、ユーザー定義のすべてのデータ型は&lt;a href=&quot;../reference/c-api/array#c.NPY_NOSCALAR&quot;&gt; &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; &lt;/a&gt;として表示されます。</target>
        </trans-unit>
        <trans-unit id="b381b011cdbc746e6a1a9147256650f6139d3056" translate="yes" xml:space="preserve">
          <source>If you want to be able to run the examples in this tutorial, you should also have &lt;a href=&quot;https://matplotlib.org/&quot;&gt;matplotlib&lt;/a&gt; and &lt;a href=&quot;https://scipy.org&quot;&gt;SciPy&lt;/a&gt; installed on your computer.</source>
          <target state="translated">このチュートリアルの例を実行できるようにする場合は、コンピューターに&lt;a href=&quot;https://matplotlib.org/&quot;&gt;matplotlib&lt;/a&gt;と&lt;a href=&quot;https://scipy.org&quot;&gt;SciPyも&lt;/a&gt;インストールしておく必要があります。</target>
        </trans-unit>
        <trans-unit id="e0e8bade3a2638408b33822bff54e29660bf3ff4" translate="yes" xml:space="preserve">
          <source>If you want to be able to run the examples in this tutorial, you should also have &lt;a href=&quot;https://matplotlib.org/&quot;&gt;matplotlib&lt;/a&gt; installed on your computer.</source>
          <target state="translated">このチュートリアルの例を実行できるようにする場合は、コンピューターに&lt;a href=&quot;https://matplotlib.org/&quot;&gt;matplotlib&lt;/a&gt;もインストールしておく必要があります。</target>
        </trans-unit>
        <trans-unit id="aaf81dbd7051e065aedb8dd44063737fadd7deaa" translate="yes" xml:space="preserve">
          <source>If you want to build NumPy in order to work on NumPy itself, use &lt;code&gt;runtests.py&lt;/code&gt;.To run NumPy&amp;rsquo;s full test suite:</source>
          <target state="translated">NumPy自体で作業するためにNumPyをビルドする場合は、 &lt;code&gt;runtests.py&lt;/code&gt; を使用します。NumPyの完全なテストスイートを実行するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="2bd528b5e948a367e7029016eb9b4a7e59a0c3cc" translate="yes" xml:space="preserve">
          <source>If you want to check your array, you can run::</source>
          <target state="translated">配列をチェックしたい場合は、:.</target>
        </trans-unit>
        <trans-unit id="239d78c449f1143da9fe3cab0308bfd5b8c57120" translate="yes" xml:space="preserve">
          <source>If you want to distribute your f2py extension module, then you only need to include the .pyf file and the Fortran code. The distutils extensions in NumPy allow you to define an extension module entirely in terms of this interface file. A valid &lt;code&gt;setup.py&lt;/code&gt; file allowing distribution of the &lt;code&gt;add.f&lt;/code&gt; module (as part of the package &lt;code&gt;f2py_examples&lt;/code&gt; so that it would be loaded as &lt;code&gt;f2py_examples.add&lt;/code&gt;) is:</source>
          <target state="translated">f2py拡張モジュールを配布する場合は、.pyfファイルとFortranコードを含めるだけで済みます。NumPyのdistutils拡張機能を使用すると、このインターフェイスファイルに関して拡張モジュールを完全に定義できます。有効な &lt;code&gt;setup.py&lt;/code&gt; の配布可能ファイル &lt;code&gt;add.f&lt;/code&gt; のモジュールは、（パッケージの一部として &lt;code&gt;f2py_examples&lt;/code&gt; それはとしてロードされますように &lt;code&gt;f2py_examples.add&lt;/code&gt; ）です。</target>
        </trans-unit>
        <trans-unit id="205839ed0e5eb197529b1363e1bb132c099c8dee" translate="yes" xml:space="preserve">
          <source>If you want to edit an array with aligned &lt;code&gt;double&lt;/code&gt; code, but the order doesn&amp;rsquo;t matter, you would use this.</source>
          <target state="translated">配列された &lt;code&gt;double&lt;/code&gt; コードで配列を編集したいが、順序が重要でない場合は、これを使用します。</target>
        </trans-unit>
        <trans-unit id="354259176d8d4848edf2f2ea177ee9321090388c" translate="yes" xml:space="preserve">
          <source>If you want to generate a list of coordinates where the elements exist, you can zip the arrays, iterate over the list of coordinates, and print them. For example:</source>
          <target state="translated">要素が存在する座標のリストを生成したい場合は、配列をzipで圧縮し、座標のリストを反復処理して印刷することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="09988ae17a5580ba08c41432cf193fcdceccc334" translate="yes" xml:space="preserve">
          <source>If you want to get the unique rows or columns, make sure to pass the &lt;code&gt;axis&lt;/code&gt; argument. To find the unique rows, specify &lt;code&gt;axis=0&lt;/code&gt; and for columns, specify &lt;code&gt;axis=1&lt;/code&gt;.</source>
          <target state="translated">一意の行または列を取得する場合は、必ず &lt;code&gt;axis&lt;/code&gt; 引数を渡してください。一意の行を見つけるには、 &lt;code&gt;axis=0&lt;/code&gt; を指定し、列には &lt;code&gt;axis=1&lt;/code&gt; を指定します。</target>
        </trans-unit>
        <trans-unit id="a706c6c7d842fe3c84f0f98172224bf53de48486" translate="yes" xml:space="preserve">
          <source>If you want to learn more about C and Fortran order, you can &lt;a href=&quot;../reference/internals#numpy-internals&quot;&gt;read more about the internal organization of NumPy arrays here&lt;/a&gt;. Essentially, C and Fortran orders have to do with how indices correspond to the order the array is stored in memory. In Fortran, when moving through the elements of a two-dimensional array as it is stored in memory, the &lt;strong&gt;first&lt;/strong&gt; index is the most rapidly varying index. As the first index moves to the next row as it changes, the matrix is stored one column at a time. This is why Fortran is thought of as a &lt;strong&gt;Column-major language&lt;/strong&gt;. In C on the other hand, the &lt;strong&gt;last&lt;/strong&gt; index changes the most rapidly. The matrix is stored by rows, making it a &lt;strong&gt;Row-major language&lt;/strong&gt;. What you do for C or Fortran depends on whether it&amp;rsquo;s more important to preserve the indexing convention or not reorder the data.</source>
          <target state="translated">CおよびFortranの順序について詳しく知りたい場合&lt;a href=&quot;../reference/internals#numpy-internals&quot;&gt;は、NumPy配列の内部構成について詳しくはこちらをご覧ください&lt;/a&gt;。基本的に、CおよびFortranの順序は、配列がメモリに格納される順序にインデックスがどのように対応するかと関係があります。 Fortranでは、メモリに格納されている2次元配列の要素を移動するとき、&lt;strong&gt;最初の&lt;/strong&gt;インデックスが最も急速に変化するインデックスです。最初のインデックスが変化するにつれて次の行に移動すると、行列は一度に1列ずつ格納されます。これが、Fortranが&lt;strong&gt;列優先言語&lt;/strong&gt;と見なされている理由&lt;strong&gt;です&lt;/strong&gt;。一方、Cでは、&lt;strong&gt;最後の&lt;/strong&gt;インデックスが最も急速に変化します。行列は行ごとに格納されるため、&lt;strong&gt;行が主要な言語になります&lt;/strong&gt;。CまたはFortranで何をするかは、索引付け規則を維持することがより重要であるか、データを並べ替えないかによって異なります。</target>
        </trans-unit>
        <trans-unit id="90eb7317f80793824fd5ca68d969b076155c2b6b" translate="yes" xml:space="preserve">
          <source>If you want to make use of these extensions in third-party projects, they are available on &lt;a href=&quot;https://pypi.org/&quot;&gt;PyPi&lt;/a&gt; as the &lt;a href=&quot;https://python.org/pypi/numpydoc&quot;&gt;numpydoc&lt;/a&gt; package.</source>
          <target state="translated">あなたは、サードパーティのプロジェクトでこれらの拡張機能を利用したい場合は、上で利用可能な&lt;a href=&quot;https://pypi.org/&quot;&gt;は、PyPI&lt;/a&gt;として&lt;a href=&quot;https://python.org/pypi/numpydoc&quot;&gt;numpydocの&lt;/a&gt;パッケージ。</target>
        </trans-unit>
        <trans-unit id="ce326a8e1b86089803e6e52c507c14343be2d322" translate="yes" xml:space="preserve">
          <source>If you want to print your reversed array, you can run:</source>
          <target state="translated">逆さにした配列を印刷したい場合は、実行します。</target>
        </trans-unit>
        <trans-unit id="0c1156594a53dfa7f56ad636c35e9f1ff1d1bf58" translate="yes" xml:space="preserve">
          <source>If you want to reset both the &lt;code&gt;iterindex&lt;/code&gt; range and the base pointers at the same time, you can do the following to avoid extra buffer copying (be sure to add the return code error checks when you copy this code).</source>
          <target state="translated">&lt;code&gt;iterindex&lt;/code&gt; 範囲とベースポインターの両方を同時にリセットする場合は、次のようにして、余分なバッファーのコピーを回避できます（このコードをコピーするときに、必ずリターンコードエラーチェックを追加してください）。</target>
        </trans-unit>
        <trans-unit id="64b7d79c9f444db203d014596ebfe464ce993392" translate="yes" xml:space="preserve">
          <source>If you want to select values from your array that fulfill certain conditions, it&amp;rsquo;s straightforward with NumPy.</source>
          <target state="translated">特定の条件を満たす配列から値を選択する場合は、NumPyを使用すると簡単です。</target>
        </trans-unit>
        <trans-unit id="37f52b8408b71a5a1ecc2762c718ea9d22604602" translate="yes" xml:space="preserve">
          <source>If you want to store a single ndarray object, store it as a .npy file using &lt;code&gt;np.save&lt;/code&gt;. If you want to store more than one ndarray object in a single file, save it as a .npz file using &lt;code&gt;np.savez&lt;/code&gt;. You can also save several arrays into a single file in compressed npz format with &lt;a href=&quot;../reference/generated/numpy.savez_compressed#numpy.savez_compressed&quot;&gt;&lt;code&gt;savez_compressed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">単一のndarrayオブジェクトを保存する場合は、np.saveを使用して.npyファイルとして保存し &lt;code&gt;np.save&lt;/code&gt; 。あなたが単一のファイルに複数のndarrayオブジェクトを保存したい場合は、使用して.npzファイルとして保存 &lt;code&gt;np.savez&lt;/code&gt; を。あなたはまたして圧縮されたNPZ形式で単一のファイルに複数のアレイを保存することができ&lt;a href=&quot;../reference/generated/numpy.savez_compressed#numpy.savez_compressed&quot;&gt; &lt;code&gt;savez_compressed&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88094cb7e9cc7094508fd58f64e280384e2b183f" translate="yes" xml:space="preserve">
          <source>If you want to work on some stuff with other people, where you are all committing into the same repository, or even the same branch, then just share it via &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;.</source>
          <target state="translated">すべてが同じリポジトリ、または同じブランチにコミットしている他の人と何かに取り組みたい場合は、&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;を介して共有してください。</target>
        </trans-unit>
        <trans-unit id="3d8a79d78dafc5ad7f75ccfea604d3c282656ec2" translate="yes" xml:space="preserve">
          <source>If you wanted to split this array into three equally shaped arrays, you would run:</source>
          <target state="translated">この配列を3つの均等な形の配列に分割したい場合は、以下のように実行します。</target>
        </trans-unit>
        <trans-unit id="fe157cf65afca39aaf28e7392b7bcce12c2fa490" translate="yes" xml:space="preserve">
          <source>If you wanted to split your array after the third and fourth column, you&amp;rsquo;d run:</source>
          <target state="translated">3番目と4番目の列の後で配列を分割する場合は、次のコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="f154266a0558b92de5f9f6ffafaf54fec025441e" translate="yes" xml:space="preserve">
          <source>If you wish to build against OpenBLAS but you also have BLIS available one may predefine the order of searching via the environment variable &lt;code&gt;NPY_BLAS_ORDER&lt;/code&gt; which is a comma-separated list of the above names which is used to determine what to search for, for instance:</source>
          <target state="translated">OpenBLASに対してビルドしたいが、BLISも利用できる場合は、環境変数 &lt;code&gt;NPY_BLAS_ORDER&lt;/code&gt; を使用して検索の順序を事前に定義できます。これは、検索対象を決定するために使用される上記の名前のコンマ区切りリストです。</target>
        </trans-unit>
        <trans-unit id="591a2b4b56f13d91fd0f488df05b473dc7163812" translate="yes" xml:space="preserve">
          <source>If you wish to build against OpenBLAS but you also have MKL available one may predefine the order of searching via the environment variable &lt;code&gt;NPY_LAPACK_ORDER&lt;/code&gt; which is a comma-separated list of the above names, for instance:</source>
          <target state="translated">OpenBLASに対してビルドしたいが、MKLも使用できる場合は、上記の名前のコンマ区切りリストである環境変数 &lt;code&gt;NPY_LAPACK_ORDER&lt;/code&gt; を使用して、検索の順序を事前に定義できます。</target>
        </trans-unit>
        <trans-unit id="05bc8da7a227df06fa8b2e6100a971876a03d9e2" translate="yes" xml:space="preserve">
          <source>If you wish to maintain compatibility with numpy and its subsequent versions (which might add new keyword arguments) but do not want to surface all of numpy&amp;rsquo;s arguments, your function&amp;rsquo;s signature should accept &lt;code&gt;**kwargs&lt;/code&gt;. For example:</source>
          <target state="translated">numpy以降のバージョン（新しいキーワード引数が追加される可能性があります）との互換性を維持したいが、numpyのすべての引数を表示したくない場合は、関数のシグネチャが &lt;code&gt;**kwargs&lt;/code&gt; を受け入れる必要があります。例えば：</target>
        </trans-unit>
        <trans-unit id="97b99e9167303c0b41027781a2b137980415f644" translate="yes" xml:space="preserve">
          <source>If you wish to work the examples in this tutorial, you must also have some software installed on your computer. Please see &lt;a href=&quot;https://scipy.org/install.html&quot;&gt;https://scipy.org/install.html&lt;/a&gt; for instructions.</source>
          <target state="translated">このチュートリアルの例を実行する場合は、コンピューターにいくつかのソフトウェアもインストールする必要があります。手順については、&lt;a href=&quot;https://scipy.org/install.html&quot;&gt;https：//scipy.org/install.html&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f6c90b5dde9be10d805961ffa80c714fdcbfb4da" translate="yes" xml:space="preserve">
          <source>If you write a missing doc you join the front line of open source, but it&amp;rsquo;s a meaningful contribution just to let us know what&amp;rsquo;s missing. If you want to compose a doc, run your thoughts by the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;mailing list&lt;/a&gt; for futher ideas and feedback. If you want to alert us to a gap, &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;open an issue&lt;/a&gt;. See &lt;a href=&quot;https://github.com/numpy/numpy/issues/15760&quot;&gt;this issue&lt;/a&gt; for an example.</source>
          <target state="translated">不足しているドキュメントを作成すると、オープンソースの最前線に加わりますが、不足しているものをお知らせいただくだけでも意味のある貢献です。ドキュメントを作成したい場合は、&lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;メーリングリストで&lt;/a&gt;考えを実行して、さらにアイデアやフィードバックを入手してください。ギャップを警告したい場合は&lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;、問題を開い&lt;/a&gt;てください。例については、&lt;a href=&quot;https://github.com/numpy/numpy/issues/15760&quot;&gt;この問題&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="435688685c403e3c5d5db1511c607affa0cd6d4f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a code contributor writing a docstring, see &lt;a href=&quot;docs/howto_document#docstring-intro&quot;&gt;Docstrings&lt;/a&gt;.</source>
          <target state="translated">あなたはドキュメンテーション文字列を書いたコードの貢献者であれば、参照&lt;a href=&quot;docs/howto_document#docstring-intro&quot;&gt;ドキュメンテーション文字列を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d9781eb57d03c99a0c0070bb4df55efb82815ef3" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a writer contributing ordinary (non-docstring) documentation, see &lt;a href=&quot;docs/howto_document#userdoc-guide&quot;&gt;User documentation&lt;/a&gt;.</source>
          <target state="translated">通常の（docstring以外の）ドキュメントを提供するライターの場合は、&lt;a href=&quot;docs/howto_document#userdoc-guide&quot;&gt;ユーザードキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="84b984ed21d4b1689868017ea7336aed57363a70" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re happy about the current status, mark the pull request as Approved (same way as Changes requested). Alternatively (for maintainers): merge the pull request, if you think it is ready to be merged.</source>
          <target state="translated">現在のステータスに満足している場合は、プルリクエストを承認済みとしてマークします（変更リクエストと同じ方法）。または（メンテナの場合）：マージする準備ができていると思われる場合は、プルリクエストをマージします。</target>
        </trans-unit>
        <trans-unit id="7557e5e98e1d6b39d314fab8f9700d862099c3ca" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re interested in learning more about Pandas, take a look at the &lt;a href=&quot;https://pandas.pydata.org/index.html&quot;&gt;official Pandas documentation&lt;/a&gt;. Learn how to install Pandas with the &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/install.html&quot;&gt;official Pandas installation information&lt;/a&gt;.</source>
          <target state="translated">パンダについて詳しく知りたい場合は、&lt;a href=&quot;https://pandas.pydata.org/index.html&quot;&gt;パンダ&lt;/a&gt;の公式ドキュメントをご覧ください。&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/install.html&quot;&gt;公式のPandasインストール情報を使用&lt;/a&gt;してPandasをインストールする方法を学びます。</target>
        </trans-unit>
        <trans-unit id="0da7f308127a1fe361554b03665675b46523369c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re looking for subjects, our formal roadmap for documentation is a &lt;em&gt;NumPy Enhancement Proposal (NEP)&lt;/em&gt;, &lt;a href=&quot;https://www.numpy.org/neps/nep-0044-restructuring-numpy-docs&quot;&gt;NEP 44 - Restructuring the NumPy Documentation&lt;/a&gt;. It identifies areas where our docs need help and lists several additions we&amp;rsquo;d like to see, including Jupyter notebooks.</source>
          <target state="translated">主題を探している場合、ドキュメントの正式なロードマップは、&lt;em&gt;NumPy拡張提案（NEP）&lt;/em&gt;、&lt;a href=&quot;https://www.numpy.org/neps/nep-0044-restructuring-numpy-docs&quot;&gt;NEP44-NumPyドキュメントの再構築&lt;/a&gt;です。ドキュメントでヘルプが必要な領域を特定し、Jupyterノートブックを含むいくつかの追加機能を一覧表示します。</target>
        </trans-unit>
        <trans-unit id="2ed6aac4fbb9a95f912d9c4a1bba39294044ad2e" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re reading this page, you probably want to help. This guide is meant to help you decide which kind of content you&amp;rsquo;ll write, as well as give you some tips and instructions for submitting it to the official NumPy documentation (that is, the documentation that ships with NumPy and lives on the &lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;official project pages&lt;/a&gt;). Keep in mind that if you don&amp;rsquo;t want to do this, writing a tutorial on your own blog, creating a YouTube video or answering questions on social media or Stack Overflow are also great contributions!</source>
          <target state="translated">あなたがこのページを読んでいるなら、あなたはおそらく助けたいと思うでしょう。このガイドは、作成するコンテンツの種類を決定するのに役立つだけでなく、公式のNumPyドキュメント（つまり、NumPyに付属し、&lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;公式プロジェクトに存在&lt;/a&gt;するドキュメント）に送信するためのヒントと手順を提供することを目的としています。ページ）。これを行いたくない場合は、自分のブログでチュートリアルを書いたり、YouTubeビデオを作成したり、ソーシャルメディアやStackOverflowで質問に答えたりすることも大きな貢献です。</target>
        </trans-unit>
        <trans-unit id="fc7594579a51a68345b4192c0906de63f2aaa750" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using the command line, you can read your saved CSV any time with a command such as:</source>
          <target state="translated">コマンドラインを使用している場合は、次のようなコマンドを使用して、保存したCSVをいつでも読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="d439391f6f76ed7b2f3c8457a29af3bd829a0ea7" translate="yes" xml:space="preserve">
          <source>If your PR is large or complicated, asking for input on the numpy-discussion mailing list may also be useful.</source>
          <target state="translated">PRの規模が大きかったり複雑だったりする場合は、numpy-discussionメーリングリストで意見を求めてみるのも有効かもしれません。</target>
        </trans-unit>
        <trans-unit id="bb1dc4c88210c13fc91fb612afbe4d0471d01d47" translate="yes" xml:space="preserve">
          <source>If your change introduces a deprecation, make sure to discuss this first on GitHub or the mailing list first. If agreement on the deprecation is reached, follow &lt;a href=&quot;http://www.numpy.org/neps/nep-0023-backwards-compatibility.html&quot;&gt;NEP 23 deprecation policy&lt;/a&gt; to add the deprecation.</source>
          <target state="translated">変更によって非推奨が導入された場合は、GitHubまたはメーリングリストで最初にこれについて話し合うようにしてください。非推奨について合意に達した場合は、&lt;a href=&quot;http://www.numpy.org/neps/nep-0023-backwards-compatibility.html&quot;&gt;NEP23の非推奨ポリシー&lt;/a&gt;に従って非推奨を追加します。</target>
        </trans-unit>
        <trans-unit id="85accb86465121a186b8d95e3c7a59851c6c91da" translate="yes" xml:space="preserve">
          <source>If your change introduces a deprecation, make sure to discuss this first on GitHub or the mailing list first. If agreement on the deprecation is reached, follow &lt;a href=&quot;https://numpy.org/neps/nep-0023-backwards-compatibility.html#nep23&quot;&gt;NEP 23 deprecation policy&lt;/a&gt; to add the deprecation.</source>
          <target state="translated">変更によって非推奨が導入された場合は、GitHubまたはメーリングリストで最初にこれについて話し合うようにしてください。非推奨について合意に達した場合は、&lt;a href=&quot;https://numpy.org/neps/nep-0023-backwards-compatibility.html#nep23&quot;&gt;NEP23の非推奨ポリシー&lt;/a&gt;に従って非推奨を追加してください。</target>
        </trans-unit>
        <trans-unit id="0ae48eb5fc08b6f0ede5d882f3a65c937350363d" translate="yes" xml:space="preserve">
          <source>If your changes involve modifications to the API or addition/modification of a function, add a release note to the &lt;code&gt;doc/release/upcoming_changes/&lt;/code&gt; directory, following the instructions and format in the &lt;code&gt;doc/release/upcoming_changes/README.rst&lt;/code&gt; file.</source>
          <target state="translated">変更にAPIの変更または関数の追加/変更が含まれる場合は、 &lt;code&gt;doc/release/upcoming_changes/README.rst&lt;/code&gt; ファイルの指示と形式に従って、リリースノートを &lt;code&gt;doc/release/upcoming_changes/&lt;/code&gt; ディレクトリに追加します。</target>
        </trans-unit>
        <trans-unit id="383746919525c98ba38f05552e38f10fc7e17a76" translate="yes" xml:space="preserve">
          <source>If your changes involve modifications to the API or addition/modification of a function, you should</source>
          <target state="translated">API の変更や関数の追加/変更を伴う変更の場合は、以下のようにしてください。</target>
        </trans-unit>
        <trans-unit id="d57214d0288965780d58c7b4b54223afc06a658d" translate="yes" xml:space="preserve">
          <source>If your commit introduces a new feature or changes functionality, post on the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-devel&quot;&gt;mailing list&lt;/a&gt; to explain your changes. For bug fixes, documentation updates, etc., this is generally not necessary, though if you do not get any reaction, do feel free to ask for review.</source>
          <target state="translated">コミットによって新機能が導入されたり、機能が変更されたりした場合は、&lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-devel&quot;&gt;メーリングリスト&lt;/a&gt;に投稿して変更について説明してください。バグ修正やドキュメントの更新などの場合、これは通常は必要ありませんが、何の反応も得られない場合は、遠慮なくレビューを依頼してください。</target>
        </trans-unit>
        <trans-unit id="9b42fea7ef12344e2f07dc65d3a5d4a69a61f251" translate="yes" xml:space="preserve">
          <source>If your commit introduces a new feature or changes functionality, post on the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;mailing list&lt;/a&gt; to explain your changes. For bug fixes, documentation updates, etc., this is generally not necessary, though if you do not get any reaction, do feel free to ask for review.</source>
          <target state="translated">コミットによって新機能が導入されたり、機能が変更されたりした場合は、&lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;メーリングリスト&lt;/a&gt;に投稿して変更について説明してください。バグ修正やドキュメントの更新などの場合、これは通常は必要ありませんが、何の反応も得られない場合は、遠慮なくレビューを依頼してください。</target>
        </trans-unit>
        <trans-unit id="ceebca4c980fce897cd94c7ea4093efdb4e34dd2" translate="yes" xml:space="preserve">
          <source>If your goal is to print such values with a fixed number of decimals, it is preferable to use numpy&amp;rsquo;s float printing routines to limit the number of printed decimals:</source>
          <target state="translated">このような値を固定の小数で印刷することが目標である場合は、numpyのfloat印刷ルーチンを使用して、印刷される小数の数を制限することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="5e8a3ab9024a9447fbb66b46a34249a781d9bca6" translate="yes" xml:space="preserve">
          <source>If your report involves any members of the committee, or if they feel they have a conflict of interest in handling it, then they will recuse themselves from considering your report. Alternatively, if for any reason you feel uncomfortable making a report to the committee, then you can also contact:</source>
          <target state="translated">あなたの報告書に委員会の委員が関与している場合、あるいは委員会の委員が報告書の処理に利害の対立があると感じた場合、委員会の委員はあなたの報告書を検討することを控えることになります。また、何らかの理由で委員会に報告書を提出することに抵抗を感じる場合は、以下の連絡先に連絡することもできます。</target>
        </trans-unit>
        <trans-unit id="3b1e83353521c6fb2d9909d1a47041f20fbc218d" translate="yes" xml:space="preserve">
          <source>If, however, you decide to deviate from this signature and do something like this:</source>
          <target state="translated">しかし、この署名から逸脱して、こんなことをすることになったら</target>
        </trans-unit>
        <trans-unit id="c323f3cd6a35ba341fff7e94a4d83cd135d073a2" translate="yes" xml:space="preserve">
          <source>Ignoring extreme values</source>
          <target state="translated">極端な価値観を無視して</target>
        </trans-unit>
        <trans-unit id="d887ce439b6be40447269f7cc275bae88c7965c1" translate="yes" xml:space="preserve">
          <source>Illustration image: &lt;a href=&quot;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&quot;&gt;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&lt;/a&gt;</source>
          <target state="translated">イラスト画像：&lt;a href=&quot;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&quot;&gt;https&lt;/a&gt; : //en.wikipedia.org/wiki/File : Composite_trapezoidal_rule_illustration.png</target>
        </trans-unit>
        <trans-unit id="8dc5a9232d67823e896b05855151653c2378fa30" translate="yes" xml:space="preserve">
          <source>Illustration, using the fact that the eigenvalues of a diagonal matrix are its diagonal elements, that multiplying a matrix on the left by an orthogonal matrix, &lt;code&gt;Q&lt;/code&gt;, and on the right by &lt;code&gt;Q.T&lt;/code&gt; (the transpose of &lt;code&gt;Q&lt;/code&gt;), preserves the eigenvalues of the &amp;ldquo;middle&amp;rdquo; matrix. In other words, if &lt;code&gt;Q&lt;/code&gt; is orthogonal, then &lt;code&gt;Q * A * Q.T&lt;/code&gt; has the same eigenvalues as &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">対角行列の固有値が対角要素であるという事実を使用して、左側の行列に直交行列 &lt;code&gt;Q&lt;/code&gt; を乗算し、右側に &lt;code&gt;Q.T&lt;/code&gt; （ &lt;code&gt;Q&lt;/code&gt; の転置）を乗算すると、図の固有値が保持されます。ミドル」マトリックス。つまり、 &lt;code&gt;Q&lt;/code&gt; が直交である場合、 &lt;code&gt;Q * A * Q.T&lt;/code&gt; は &lt;code&gt;A&lt;/code&gt; と同じ固有値を持ちます。</target>
        </trans-unit>
        <trans-unit id="aa91fcf02d0f861f5dcc65de755f413adabac4c5" translate="yes" xml:space="preserve">
          <source>Illustration:</source>
          <target state="translated">Illustration:</target>
        </trans-unit>
        <trans-unit id="50e19fda0d5b4b74a4a1a1d584e56578693a4ea4" translate="yes" xml:space="preserve">
          <source>Image</source>
          <target state="translated">Image</target>
        </trans-unit>
        <trans-unit id="536fc5481730660eaf684050e171a85c03ce521a" translate="yes" xml:space="preserve">
          <source>Image &lt;a href=&quot;#r7aa6c77779c0-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; illustrates trapezoidal rule &amp;ndash; y-axis locations of points will be taken from &lt;code&gt;y&lt;/code&gt; array, by default x-axis distances between points will be 1.0, alternatively they can be provided with &lt;code&gt;x&lt;/code&gt; array or with &lt;code&gt;dx&lt;/code&gt; scalar. Return value will be equal to combined area under the red lines.</source>
          <target state="translated">画像&lt;a href=&quot;#r7aa6c77779c0-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;は台形の規則を示しています。ポイントのy軸の位置は &lt;code&gt;y&lt;/code&gt; 配列から取得されます。デフォルトでは、ポイント間のx軸の距離は1.0ですが、 &lt;code&gt;x&lt;/code&gt; 配列または &lt;code&gt;dx&lt;/code&gt; スカラーで提供することもできます。戻り値は、赤い線の下の合計面積に等しくなります。</target>
        </trans-unit>
        <trans-unit id="a9fdbeb05caca869c7ab036893a4d3951315842f" translate="yes" xml:space="preserve">
          <source>Image filter in Cython</source>
          <target state="translated">Cython の画像フィルタ</target>
        </trans-unit>
        <trans-unit id="d6766ee0177892e2089a490e4a43072e37a3688f" translate="yes" xml:space="preserve">
          <source>Images and real-life data make text more engaging and powerful, but be sure what you use is appropriately licensed and available. Here again, even a rough idea for artwork can be polished by others.</source>
          <target state="translated">画像や実際のデータは、テキストをより魅力的で力強いものにしてくれますが、使用するものが適切にライセンスされ、利用可能であることを確認してください。ここでも、アートワークのラフなアイデアでも、他の人が磨いてくれることがあります。</target>
        </trans-unit>
        <trans-unit id="9e3e609852befab966299ce3a62b4f677877a107" translate="yes" xml:space="preserve">
          <source>Images are allowed, but should not be central to the explanation; users viewing the docstring as text must be able to comprehend its meaning without resorting to an image viewer. These additional illustrations are included using:</source>
          <target state="translated">画像は許可されていますが、説明の中心になるべきではありません。これらの追加のイラストは、以下のように使用して含まれています。</target>
        </trans-unit>
        <trans-unit id="4796b475dca83b62f81a07c968464a3ec0ce36b3" translate="yes" xml:space="preserve">
          <source>Imagine a series of commits A, B, C, D&amp;hellip; Imagine that there are two branches, &lt;em&gt;topic&lt;/em&gt; and &lt;em&gt;master&lt;/em&gt;. You branched &lt;em&gt;topic&lt;/em&gt; off &lt;em&gt;master&lt;/em&gt; when &lt;em&gt;master&lt;/em&gt; was at commit &amp;lsquo;E&amp;rsquo;. The graph of the commits looks like this:</source>
          <target state="translated">一連のコミットA、B、C、Dを想像してみてください&amp;hellip;&lt;em&gt;トピック&lt;/em&gt;と&lt;em&gt;マスターの&lt;/em&gt;2つのブランチがあると想像してください。&lt;em&gt;マスター&lt;/em&gt;がコミット 'E'にあったときに、&lt;em&gt;トピック&lt;/em&gt;を&lt;em&gt;マスター&lt;/em&gt;から分岐しました。コミットのグラフは次のようになります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d1a70afdce8219e6a6ff23faf95244260258e23" translate="yes" xml:space="preserve">
          <source>Imagine an array of 32-bit integers (each 4 bytes):</source>
          <target state="translated">32ビット整数の配列を想像してみてください(各4バイト)。</target>
        </trans-unit>
        <trans-unit id="56024d919b5d6ee0185b1f966812231e966a9f22" translate="yes" xml:space="preserve">
          <source>Immediately disconnect the originator from all NumPy communication channels.</source>
          <target state="translated">発信者をすべてのNumPy通信チャネルから直ちに切断します。</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">実施内容</target>
        </trans-unit>
        <trans-unit id="c12c46e2305d0716b258ac51f2e79f55da8c1069" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;__array_function__&lt;/code&gt; indicate that they can handle the operation by returning any value other than &lt;code&gt;NotImplemented&lt;/code&gt;.</source>
          <target state="translated">実装 &lt;code&gt;__array_function__&lt;/code&gt; は、彼らが以外の値を返すことによって操作を処理できることを示している &lt;code&gt;NotImplemented&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="45682c285dcaa4b3e31e357f40fa088a415ce505" translate="yes" xml:space="preserve">
          <source>Implementing this formula is simple and straightforward in NumPy:</source>
          <target state="translated">この式の実装は、NumPyではシンプルで簡単です。</target>
        </trans-unit>
        <trans-unit id="0e028e89dfea3c1cba7d9fc7a23453fc7abac732" translate="yes" xml:space="preserve">
          <source>Implements exec_command function that is (almost) equivalent to commands.getstatusoutput function but on NT, DOS systems the returned status is actually correct (though, the returned status values may be different by a factor). In addition, exec_command takes keyword arguments for (re-)defining environment variables.</source>
          <target state="translated">commands.getstatusoutput関数と(ほぼ)同等ですが、NT,DOSシステムでは、返されるステータスは実際には正しいものになります(ただし、返されるステータスの値はファクターによって異なる場合があります)。さらに、exec_commandは環境変数を(再)定義するためのキーワード引数を取ります。</target>
        </trans-unit>
        <trans-unit id="b794a9ed38f8d441574ce1ea158c0a341f3db730" translate="yes" xml:space="preserve">
          <source>Implements the complex comparisons between two complex numbers (structures with a real and imag member) using NumPy&amp;rsquo;s definition of the ordering which is lexicographic: comparing the real parts first and then the complex parts if the real parts are equal.</source>
          <target state="translated">辞書式の順序付けのNumPyの定義を使用して、2つの複素数（実数とimagのメンバーを持つ構造体）の間の複雑な比較を実装します。</target>
        </trans-unit>
        <trans-unit id="8c1ede9f9fcf093439f0e008232b895dda53883b" translate="yes" xml:space="preserve">
          <source>Implements the rules for scalar coercion. Scalars are only silently coerced from thistype to neededtype if this function returns nonzero. If scalar is &lt;a href=&quot;#c.NPY_NOSCALAR&quot;&gt;&lt;code&gt;NPY_NOSCALAR&lt;/code&gt;&lt;/a&gt;, then this function is equivalent to &lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt;&lt;code&gt;PyArray_CanCastSafely&lt;/code&gt;&lt;/a&gt;. The rule is that scalars of the same KIND can be coerced into arrays of the same KIND. This rule means that high-precision scalars will never cause low-precision arrays of the same KIND to be upcast.</source>
          <target state="translated">スカラー強制のルールを実装します。この関数がゼロ以外を返す場合にのみ、スカラーはこのタイプから必要なタイプにサイレントに強制変換されます。スカラーが&lt;a href=&quot;#c.NPY_NOSCALAR&quot;&gt; &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; の&lt;/a&gt;場合、この関数は&lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt; &lt;code&gt;PyArray_CanCastSafely&lt;/code&gt; &lt;/a&gt;と同等です。ルールは、同じKINDのスカラーを同じKINDの配列に強制変換できるというものです。このルールは、高精度のスカラーによって同じ種類の低精度の配列がアップキャストされることは決してないことを意味します。</target>
        </trans-unit>
        <trans-unit id="22af89867a4595ad888fcb4ec7aff9a5775524c5" translate="yes" xml:space="preserve">
          <source>Implements the rules for scalar coercion. Scalars are only silently coerced from thistype to neededtype if this function returns nonzero. If scalar is &lt;code&gt;NPY_NOSCALAR&lt;/code&gt;, then this function is equivalent to &lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt;&lt;code&gt;PyArray_CanCastSafely&lt;/code&gt;&lt;/a&gt;. The rule is that scalars of the same KIND can be coerced into arrays of the same KIND. This rule means that high-precision scalars will never cause low-precision arrays of the same KIND to be upcast.</source>
          <target state="translated">スカラー強制のルールを実装します。この関数がゼロ以外の値を返す場合、スカラーは暗黙的にthistypeからrequiredtypeに強制的に変換されます。スカラーが &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; の場合、この関数は&lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt; &lt;code&gt;PyArray_CanCastSafely&lt;/code&gt; &lt;/a&gt;と同等です。ルールは、同じ種類のスカラーを同じ種類の配列に強制変換できることです。このルールは、高精度のスカラーが同じKINDの低精度の配列をアップキャストすることは決してないことを意味します。</target>
        </trans-unit>
        <trans-unit id="cc6b2c01f5b15596a7e379b52c69cde1905611b5" translate="yes" xml:space="preserve">
          <source>Implications for subclassing</source>
          <target state="translated">サブクラス化への影響</target>
        </trans-unit>
        <trans-unit id="9b1ecf27a94cea1bc5736c0891a645368078e452" translate="yes" xml:space="preserve">
          <source>Implicit rules are used to determine the type specification of a variable (from the first-letter of its name) if the variable is not defined using &lt;code&gt;&amp;lt;variable type declaration&amp;gt;&lt;/code&gt;. Default implicit rule is given by</source>
          <target state="translated">変数が &lt;code&gt;&amp;lt;variable type declaration&amp;gt;&lt;/code&gt; を使用して定義されていない場合、暗黙のルールを使用して（名前の最初の文字から）変数の型指定を決定します。デフォルトの暗黙のルールはによって与えられます</target>
        </trans-unit>
        <trans-unit id="696ba2ae8759bcaca0a74feee3fb3d26911b302c" translate="yes" xml:space="preserve">
          <source>Implies</source>
          <target state="translated">Implies</target>
        </trans-unit>
        <trans-unit id="0951af8ad6c339672abaff4e57cd5d78b54b3d59" translate="yes" xml:space="preserve">
          <source>Import conventions</source>
          <target state="translated">インポート規約</target>
        </trans-unit>
        <trans-unit id="361838ee748707501d1086cda1d546a0bca541ea" translate="yes" xml:space="preserve">
          <source>ImportError</source>
          <target state="translated">ImportError</target>
        </trans-unit>
        <trans-unit id="2fdd9172a8740a8589e6db75bd8b770e98070548" translate="yes" xml:space="preserve">
          <source>Importing and exporting a CSV</source>
          <target state="translated">CSVのインポートとエクスポート</target>
        </trans-unit>
        <trans-unit id="a0b02515f5c051785b53791b2ce9293238d373b1" translate="yes" xml:space="preserve">
          <source>Importing data with &lt;code&gt;genfromtxt&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;genfromtxt&lt;/code&gt; を使用したデータのインポート</target>
        </trans-unit>
        <trans-unit id="5ce37d23b2e6f8bbdca3d0d3d416305b155ec2af" translate="yes" xml:space="preserve">
          <source>Importing data with genfromtxt</source>
          <target state="translated">genfromtxtでのデータのインポート</target>
        </trans-unit>
        <trans-unit id="c27d990de6ba5889ef7140c6c7a668ba89dfd7cb" translate="yes" xml:space="preserve">
          <source>Importing the API</source>
          <target state="translated">APIのインポート</target>
        </trans-unit>
        <trans-unit id="dd37ac12c1ad8599b8ebf308693dc3e055ea4be3" translate="yes" xml:space="preserve">
          <source>Improve detection of CPU features</source>
          <target state="translated">CPUの特徴の検出を改善</target>
        </trans-unit>
        <trans-unit id="3cf92b1447d3f56d21aa04032c4a2bb6319ee3e3" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;numpy.pad&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.pad&lt;/code&gt; のパフォーマンスを向上させる</target>
        </trans-unit>
        <trans-unit id="fc1f2a7f430fee41352adede4b4563f47e652af5" translate="yes" xml:space="preserve">
          <source>Improved automated bin estimators for &lt;code&gt;histogram&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;histogram&lt;/code&gt; 自動ビン推定量の改善</target>
        </trans-unit>
        <trans-unit id="c1f0700651c0f4723ea34b9b380874940d8f5904" translate="yes" xml:space="preserve">
          <source>Improved conversion from ctypes objects</source>
          <target state="translated">ctypesオブジェクトからの変換を改善</target>
        </trans-unit>
        <trans-unit id="518dff1009456384a218feffc1efa6923feaa474" translate="yes" xml:space="preserve">
          <source>Improved handling of zero-width string/unicode dtypes</source>
          <target state="translated">ゼロ幅文字列/unicodeのdtypesの取り扱いを改善</target>
        </trans-unit>
        <trans-unit id="58ab9853fb47f5464aeb249a62f870635c06737e" translate="yes" xml:space="preserve">
          <source>Improved precision of &lt;code&gt;ndarray.mean&lt;/code&gt; for float16 arrays</source>
          <target state="translated">float16配列の &lt;code&gt;ndarray.mean&lt;/code&gt; の精度が向上しました</target>
        </trans-unit>
        <trans-unit id="38934ca4956698ef07754fc3267371731cc1f9a9" translate="yes" xml:space="preserve">
          <source>Improved set operations</source>
          <target state="translated">セット操作の改善</target>
        </trans-unit>
        <trans-unit id="e19dfb0830377f2d40e7f347e095cf658ce8a748" translate="yes" xml:space="preserve">
          <source>Improved string representation for polynomials (&lt;code&gt;__str__&lt;/code&gt;)</source>
          <target state="translated">多項式の文字列表現の改善（ &lt;code&gt;__str__&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="df66ef4f9fec541e48971fe99984a92ee3d241bf" translate="yes" xml:space="preserve">
          <source>Improvements</source>
          <target state="translated">Improvements</target>
        </trans-unit>
        <trans-unit id="75cb8c222cfbf4c46e4378aa465749528ac0f696" translate="yes" xml:space="preserve">
          <source>Improvements to build warnings</source>
          <target state="translated">ビルド警告の改善</target>
        </trans-unit>
        <trans-unit id="21535b2ca395b919fe7ab1e068c3e3d0e600eb23" translate="yes" xml:space="preserve">
          <source>Improving the basic interface</source>
          <target state="translated">基本インターフェースの改善</target>
        </trans-unit>
        <trans-unit id="651ad1981d9513aaa48106696e9dc28fdbdbb95a" translate="yes" xml:space="preserve">
          <source>In &amp;lsquo;clip&amp;rsquo; mode, a negative index which would normally wrap will clip to 0 instead.</source>
          <target state="translated">「クリップ」モードでは、通常折り返される負のインデックスは代わりに0にクリップします。</target>
        </trans-unit>
        <trans-unit id="0a5b493d076f809b633ada78947b9be3536bf476" translate="yes" xml:space="preserve">
          <source>In 1.16 a number of functions have been introduced in the &lt;a href=&quot;#module-numpy.lib.recfunctions&quot;&gt;&lt;code&gt;numpy.lib.recfunctions&lt;/code&gt;&lt;/a&gt; module to help users account for this change. These are &lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#numpy.lib.recfunctions.structured_to_unstructured&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.structured_to_unstructured&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.lib.recfunctions.unstructured_to_structured&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.unstructured_to_structured&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.lib.recfunctions.apply_along_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.apply_along_fields&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.lib.recfunctions.assign_fields_by_name&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.assign_fields_by_name&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#numpy.lib.recfunctions.require_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.require_fields&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1.16では、ユーザーがこの変更を説明できるように、&lt;a href=&quot;#module-numpy.lib.recfunctions&quot;&gt; &lt;code&gt;numpy.lib.recfunctions&lt;/code&gt; &lt;/a&gt;モジュールにいくつかの関数が導入されました。これらは&lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt; &lt;/a&gt;です。&lt;a href=&quot;#numpy.lib.recfunctions.structured_to_unstructured&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.structured_to_unstructured&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#numpy.lib.recfunctions.unstructured_to_structured&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.unstructured_to_structured&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#numpy.lib.recfunctions.apply_along_fields&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.apply_along_fields&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#numpy.lib.recfunctions.assign_fields_by_name&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.assign_fields_by_name&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#numpy.lib.recfunctions.require_fields&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.require_fields&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2fa6844c3d81a6fe2067c8e0e928cef4f2f272dc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;range(6)&lt;/code&gt;, information on what kind of rounding is done in addition, and on how underflow is handled.</source>
          <target state="translated">&lt;code&gt;range(6)&lt;/code&gt; 、丸め処理の種類に関する情報を加えて行われ、アンダーフローの処理方法にされます。</target>
        </trans-unit>
        <trans-unit id="50fbd12243b4769e24084faa8adf2287f6b3d6cd" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;explicit mode&lt;/em&gt; the output can be directly controlled by specifying output subscript labels. This requires the identifier &amp;lsquo;-&amp;gt;&amp;rsquo; as well as the list of output subscript labels. This feature increases the flexibility of the function since summing can be disabled or forced when required. The call &lt;code&gt;np.einsum('i-&amp;gt;', a)&lt;/code&gt; is like &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;np.sum(a, axis=-1)&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; is like &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;np.diag(a)&lt;/code&gt;&lt;/a&gt;. The difference is that &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; does not allow broadcasting by default. Additionally &lt;code&gt;np.einsum('ij,jh-&amp;gt;ih', a, b)&lt;/code&gt; directly specifies the order of the output subscript labels and therefore returns matrix multiplication, unlike the example above in implicit mode.</source>
          <target state="translated">で&lt;em&gt;明示モード&lt;/em&gt;出力は、直接出力添字ラベルを指定することによって制御することができます。これには、識別子「-&amp;gt;」と出力添え字ラベルのリストが必要です。必要に応じて加算を無効にしたり強制したりできるため、この機能により関数の柔軟性が向上します。呼び出し &lt;code&gt;np.einsum('i-&amp;gt;', a)&lt;/code&gt; は&lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;np.sum(a, axis=-1)&lt;/code&gt; &lt;/a&gt;ようなもので、 &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; は&lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;np.diag(a)&lt;/code&gt; の&lt;/a&gt;ようなものです。違いは、&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;がデフォルトでブロードキャストを許可しないことです。さらに、 &lt;code&gt;np.einsum('ij,jh-&amp;gt;ih', a, b)&lt;/code&gt; は、出力の添え字ラベルの順序を直接指定するため、暗黙的なモードでの上記の例とは異なり、行列の乗算を返します。</target>
        </trans-unit>
        <trans-unit id="c0145016518b0031bebdd7367da2ce7b6495c4d5" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;explicit&lt;/em&gt; mode, &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; provides further flexibility to compute other array operations that might not be considered classical Einstein summation operations, by disabling, or forcing summation over specified subscript labels.</source>
          <target state="translated">&lt;em&gt;明示&lt;/em&gt;モード、&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; は&lt;/a&gt;無効、または指定された添字ラベル上和を強制することによって、古典的なアインシュタイン総和演算考慮されない可能性のある他の配列演算を計算するためのさらなる柔軟性を提供します。</target>
        </trans-unit>
        <trans-unit id="4c8b68052719d1c1d5215bfd711f82950ca7a1df" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;implicit mode&lt;/em&gt;, the chosen subscripts are important since the axes of the output are reordered alphabetically. This means that &lt;code&gt;np.einsum('ij', a)&lt;/code&gt; doesn&amp;rsquo;t affect a 2D array, while &lt;code&gt;np.einsum('ji', a)&lt;/code&gt; takes its transpose. Additionally, &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; returns a matrix multiplication, while, &lt;code&gt;np.einsum('ij,jh', a, b)&lt;/code&gt; returns the transpose of the multiplication since subscript &amp;lsquo;h&amp;rsquo; precedes subscript &amp;lsquo;i&amp;rsquo;.</source>
          <target state="translated">では&lt;em&gt;暗黙のモード&lt;/em&gt;出力の軸がアルファベット順に並べ替えされているので、選ばれた添字が重要です。つまり、 &lt;code&gt;np.einsum('ij', a)&lt;/code&gt; は2D配列に影響を与えませんが、 &lt;code&gt;np.einsum('ji', a)&lt;/code&gt; は転置を行います。さらに、 &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; は行列の乗算を返し、 &lt;code&gt;np.einsum('ij,jh', a, b)&lt;/code&gt; は、添字 'h'が添え字の前にあるため、乗算の転置を返します。 '私'。</target>
        </trans-unit>
        <trans-unit id="065543ba7b7c467e5ff1cf1108109daa4f6f9b2e" translate="yes" xml:space="preserve">
          <source>In C, there is no equivalent to the deprecation warnings that Python supports. One way to do deprecations is to flag them in the documentation and release notes, then remove or change the deprecated features in a future major version (NumPy 2.0 and beyond). Minor versions of NumPy should not have major C-API changes, however, that prevent code that worked on a previous minor release. For example, we will do our best to ensure that code that compiled and worked on NumPy 1.4 should continue to work on NumPy 1.7 (but perhaps with compiler warnings).</source>
          <target state="translated">C言語では、PythonがサポートしているDeprecationの警告に相当するものはありません。Deprecationを行う1つの方法は、ドキュメントやリリースノートでDeprecationにフラグを立て、将来のメジャーバージョン(NumPy 2.0以降)でDeprecatedの機能を削除したり変更したりすることです。しかし、NumPyのマイナーバージョンでは、以前のマイナーリリースで動作していたコードが動作しなくなるようなC-APIの大きな変更があってはなりません。例えば、NumPy 1.4でコンパイルして動作していたコードがNumPy 1.7でも動作することを保証するために最善を尽くします。</target>
        </trans-unit>
        <trans-unit id="a9ca8be4f66144d7c2dcc488bdd409f6a21dcaf9" translate="yes" xml:space="preserve">
          <source>In IPython it is also possible to run individual examples simply by copy-pasting them in doctest mode:</source>
          <target state="translated">IPythonでは、doctestモードでコピーペーストするだけで個々のサンプルを実行することも可能です。</target>
        </trans-unit>
        <trans-unit id="1971f366d86d58fc78c8e9d3d0151d96fbd74efd" translate="yes" xml:space="preserve">
          <source>In MATLAB the main tool available to you for customizing the environment is to modify the search path with the locations of your favorite functions. You can put such customizations into a startup script that MATLAB will run on startup.</source>
          <target state="translated">MATLABでは、環境をカスタマイズするために利用できる主なツールは、お気に入りの関数の位置で検索パスを変更することです。このようなカスタマイズは、MATLABが起動時に実行するスタートアップスクリプトに入れることができます。</target>
        </trans-unit>
        <trans-unit id="494eed34e26fa744c79b6950c743fa3931771a94" translate="yes" xml:space="preserve">
          <source>In MATLAB&amp;reg; the main tool available to you for customizing the environment is to modify the search path with the locations of your favorite functions. You can put such customizations into a startup script that MATLAB will run on startup.</source>
          <target state="translated">MATLAB&amp;reg;では、環境をカスタマイズするために使用できる主なツールは、お気に入りの関数の場所で検索パスを変更することです。このようなカスタマイズを、MATLABが起動時に実行する起動スクリプトに組み込むことができます。</target>
        </trans-unit>
        <trans-unit id="05b064c6c8d4ad79dd43510f89eb8bbc99cffd4b" translate="yes" xml:space="preserve">
          <source>In MATLAB&amp;reg;, arrays have pass-by-value semantics, with a lazy copy-on-write scheme to prevent actually creating copies until they are actually needed. Slice operations copy parts of the array.</source>
          <target state="translated">MATLAB&amp;reg;では、配列には値渡しのセマンティクスがあり、実際に必要になるまで実際にコピーが作成されないようにするための遅延コピーオンライトスキームがあります。スライス操作は、配列の一部をコピーします。</target>
        </trans-unit>
        <trans-unit id="35c279433c70eb2d4b30f568fbc349c5cc15292b" translate="yes" xml:space="preserve">
          <source>In MATLAB&amp;reg;, the basic data type is a multidimensional array of double precision floating point numbers. Most expressions take such arrays and return such arrays. Operations on the 2-D instances of these arrays are designed to act more or less like matrix operations in linear algebra.</source>
          <target state="translated">MATLAB&amp;reg;では、基本的なデータ型は倍精度浮動小数点数の多次元配列です。ほとんどの式はそのような配列を取り、そのような配列を返します。これらの配列の2次元インスタンスに対する演算は、線形代数の行列演算のように機能するように設計されています。</target>
        </trans-unit>
        <trans-unit id="7b6b97a69c13a8b76d236409c27d01def9d5d4b3" translate="yes" xml:space="preserve">
          <source>In MATLAB, the basic type, even for scalars, is a multidimensional array. Array assignments in MATLAB are stored as 2D arrays of double precision floating point numbers, unless you specify the number of dimensions and type. Operations on the 2D instances of these arrays are modeled on matrix operations in linear algebra.</source>
          <target state="translated">MATLABでは、スカラーであっても基本型は多次元配列です。MATLABでの配列の割り当ては、次元数と型を指定しない限り、倍精度浮動小数点数の2次元配列として保存されます。これらの配列の2Dインスタンスに対する操作は、線形代数の行列操作をモデルとしています。</target>
        </trans-unit>
        <trans-unit id="a7fc4e4e9aaf59319f61cb1b2c8333ad9f8d065b" translate="yes" xml:space="preserve">
          <source>In NumPy 1.16, you need to set the environment variable &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=1&lt;/code&gt; before importing NumPy to use NumPy function overrides.</source>
          <target state="translated">NumPy 1.16では、NumPyをインポートしてNumPy関数のオーバーライドを使用する前に、環境変数 &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=1&lt;/code&gt; を設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="2d05b90f328ed41700350ed32107071a1f6f3fbc" translate="yes" xml:space="preserve">
          <source>In NumPy 1.17, the protocol is enabled by default, but can be disabled with &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=0&lt;/code&gt;.</source>
          <target state="translated">NumPy 1.17では、プロトコルはデフォルトで有効になっていますが、 &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=0&lt;/code&gt; で無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="1b4938fa72e1c7213ec03de65817f46747825eb5" translate="yes" xml:space="preserve">
          <source>In NumPy 1.6.0, a type promotion API was created to encapsulate the mechanism for determining output types. See the functions &lt;a href=&quot;generated/numpy.result_type#numpy.result_type&quot;&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt;&lt;code&gt;min_scalar_type&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">NumPy 1.6.0では、タイププロモーションAPIが作成され、出力タイプを決定するメカニズムがカプセル化されました。詳細については、&lt;a href=&quot;generated/numpy.result_type#numpy.result_type&quot;&gt; &lt;code&gt;result_type&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;generated/numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;generated/numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt; &lt;code&gt;min_scalar_type&lt;/code&gt; &lt;/a&gt;関数を参照してください。</target>
        </trans-unit>
        <trans-unit id="6817ac22605fc4c2d0f573a2b14f3a89cb1e8f22" translate="yes" xml:space="preserve">
          <source>In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal, but depending on this fact is deprecated. Writing to the resulting array continues to work as it used to, but a FutureWarning is issued.</source>
          <target state="translated">NumPy 1.7と1.8では、対角線のコピーを返し続けますが、この事実によっては非推奨となります。結果の配列への書き込みは以前と同じように動作しますが、FutureWarningが発行されます。</target>
        </trans-unit>
        <trans-unit id="117fbe2ef07a30dba33092bb43c1ec1f63fe2b7a" translate="yes" xml:space="preserve">
          <source>In NumPy 1.7 and later, this form allows &lt;code&gt;base_dtype&lt;/code&gt; to be interpreted as a structured dtype. Arrays created with this dtype will have underlying dtype &lt;code&gt;base_dtype&lt;/code&gt; but will have fields and flags taken from &lt;code&gt;new_dtype&lt;/code&gt;. This is useful for creating custom structured dtypes, as done in &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record arrays&lt;/a&gt;.</source>
          <target state="translated">NumPy 1.7以降では、この形式により &lt;code&gt;base_dtype&lt;/code&gt; を構造化dtypeとして解釈できます。このdtypeで作成された配列には、基本となるdtype &lt;code&gt;base_dtype&lt;/code&gt; がありますが、フィールドとフラグは &lt;code&gt;new_dtype&lt;/code&gt; から取得されます。これは、&lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;レコード配列で&lt;/a&gt;行われるように、カスタム構造化dtypeを作成するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="11387d0f86941bf54bf7c514e7a5b1f0fd171696" translate="yes" xml:space="preserve">
          <source>In NumPy arrays have pass-by-reference semantics. Slice operations are views into an array.</source>
          <target state="translated">NumPyでは,配列は参照渡しのセマンティクスを持っています.スライス操作は配列へのビューです。</target>
        </trans-unit>
        <trans-unit id="0193a49a749beca871335b39ba584f160aa0e7bd" translate="yes" xml:space="preserve">
          <source>In NumPy the basic type is a multidimensional &lt;code&gt;array&lt;/code&gt;. Operations on these arrays in all dimensionalities including 2D are element-wise operations. One needs to use specific functions for linear algebra (though for matrix multiplication, one can use the &lt;code&gt;@&lt;/code&gt; operator in python 3.5 and above).</source>
          <target state="translated">NumPyでは、基本的なタイプは多次元 &lt;code&gt;array&lt;/code&gt; です。2Dを含むすべての次元でのこれらの配列の操作は、要素ごとの操作です。線形代数には特定の関数を使用する必要があります（ただし、行列の乗算には、Python 3.5以降では &lt;code&gt;@&lt;/code&gt; 演算子を使用できます）。</target>
        </trans-unit>
        <trans-unit id="3b53f7eb15b7831e508349b1a60777dcdbd79a0e" translate="yes" xml:space="preserve">
          <source>In NumPy versions &amp;lt;= 1.9.0 Nan is returned for slices that are all-NaN or empty. In later versions zero is returned.</source>
          <target state="translated">NumPyバージョン1.9.0以下では、すべてNaNまたは空のスライスに対してNanが返されます。新しいバージョンではゼロが返されます。</target>
        </trans-unit>
        <trans-unit id="36d3e5a6749595663c6dacbe6e7c386adcf1a912" translate="yes" xml:space="preserve">
          <source>In NumPy, dimensions are called &lt;strong&gt;axes&lt;/strong&gt;. This means that if you have a 2D array that looks like this:</source>
          <target state="translated">NumPyでは、寸法は&lt;strong&gt;軸&lt;/strong&gt;と呼ばれます。これは、次のような2D配列がある場合を意味します。</target>
        </trans-unit>
        <trans-unit id="175572b3b0d248e7569a97712bffa8366f334be5" translate="yes" xml:space="preserve">
          <source>In NumPy, the basic type is a multidimensional &lt;code&gt;array&lt;/code&gt;. Array assignments in NumPy are usually stored as &lt;a href=&quot;../reference/arrays#arrays&quot;&gt;n-dimensional arrays&lt;/a&gt; with the minimum type required to hold the objects in sequence, unless you specify the number of dimensions and type. NumPy performs operations element-by-element, so multiplying 2D arrays with &lt;code&gt;*&lt;/code&gt; is not a matrix multiplication &amp;ndash; it&amp;rsquo;s an element-by-element multiplication. (The &lt;code&gt;@&lt;/code&gt; operator, available since Python 3.5, can be used for conventional matrix multiplication.)</source>
          <target state="translated">NumPyでは、基本的なタイプは多次元 &lt;code&gt;array&lt;/code&gt; です。 NumPyでの配列割り当ては、次元数とタイプを指定しない限り、通常、オブジェクトを順番に保持するために必要な最小限のタイプの&lt;a href=&quot;../reference/arrays#arrays&quot;&gt;n次元配列&lt;/a&gt;として格納されます。 NumPyは要素ごとに演算を実行するため、2D配列に &lt;code&gt;*&lt;/code&gt; を乗算することは行列の乗算ではなく、要素ごとの乗算です。 （Python 3.5以降で使用可能な &lt;code&gt;@&lt;/code&gt; 演算子は、従来の行列乗算に使用できます。）</target>
        </trans-unit>
        <trans-unit id="ed78411a5f19815c75577c53c9647b97f455af34" translate="yes" xml:space="preserve">
          <source>In NumPy, there are 24 new fundamental Python types to describe different types of scalars. These type descriptors are mostly based on the types available in the C language that CPython is written in, with several additional types compatible with Python&amp;rsquo;s types.</source>
          <target state="translated">NumPyには、さまざまなタイプのスカラーを記述するための24の新しい基本的なPythonタイプがあります。これらの型記述子は、CPythonが記述されているC言語で使用可能な型に基づいており、Pythonの型と互換性のあるいくつかの型が追加されています。</target>
        </trans-unit>
        <trans-unit id="72d772d403bb9e7043a8b7f8c594e1144a74fb8c" translate="yes" xml:space="preserve">
          <source>In NumPy, universal functions are instances of the &lt;a href=&quot;generated/numpy.ufunc#numpy.ufunc&quot;&gt;&lt;code&gt;numpy.ufunc&lt;/code&gt;&lt;/a&gt; class. Many of the built-in functions are implemented in compiled C code. The basic ufuncs operate on scalars, but there is also a generalized kind for which the basic elements are sub-arrays (vectors, matrices, etc.), and broadcasting is done over other dimensions. One can also produce custom &lt;a href=&quot;generated/numpy.ufunc#numpy.ufunc&quot;&gt;&lt;code&gt;ufunc&lt;/code&gt;&lt;/a&gt; instances using the &lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt;&lt;code&gt;frompyfunc&lt;/code&gt;&lt;/a&gt; factory function.</source>
          <target state="translated">NumPyでは、ユニバーサル関数は&lt;a href=&quot;generated/numpy.ufunc#numpy.ufunc&quot;&gt; &lt;code&gt;numpy.ufunc&lt;/code&gt; &lt;/a&gt;クラスのインスタンスです。組み込み関数の多くは、コンパイルされたCコードで実装されています。基本的なufuncはスカラーで動作しますが、基本的な要素がサブ配列（ベクトル、行列など）であり、ブロードキャストが他の次元で行われる一般化された種類もあります。&lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt; &lt;code&gt;frompyfunc&lt;/code&gt; &lt;/a&gt;ファクトリ関数を使用してカスタム&lt;a href=&quot;generated/numpy.ufunc#numpy.ufunc&quot;&gt; &lt;code&gt;ufunc&lt;/code&gt; &lt;/a&gt;インスタンスを生成することもできます。</target>
        </trans-unit>
        <trans-unit id="0c775f1e9d60e517f99b3f4fb5fbef2cd48f1233" translate="yes" xml:space="preserve">
          <source>In NumPy, universal functions are instances of the &lt;code&gt;numpy.ufunc&lt;/code&gt; class. Many of the built-in functions are implemented in compiled C code. The basic ufuncs operate on scalars, but there is also a generalized kind for which the basic elements are sub-arrays (vectors, matrices, etc.), and broadcasting is done over other dimensions. One can also produce custom &lt;code&gt;ufunc&lt;/code&gt; instances using the &lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt;&lt;code&gt;frompyfunc&lt;/code&gt;&lt;/a&gt; factory function.</source>
          <target state="translated">NumPyでは、ユニバーサル関数は &lt;code&gt;numpy.ufunc&lt;/code&gt; クラスのインスタンスです。組み込み関数の多くは、コンパイルされたCコードで実装されます。基本的なufuncはスカラーで動作しますが、基本的な要素がサブ配列（ベクトル、行列など）である一般化された種類もあり、ブロードキャストは他の次元で行われます。&lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt; &lt;code&gt;frompyfunc&lt;/code&gt; &lt;/a&gt;ファクトリー関数を使用してカスタム &lt;code&gt;ufunc&lt;/code&gt; インスタンスを生成することもできます。</target>
        </trans-unit>
        <trans-unit id="15ce5a6b4ac0eac09144a9d2b2aa63ae33e8eb97" translate="yes" xml:space="preserve">
          <source>In NumPy, usually a synonym for &lt;a href=&quot;#term-array-scalar&quot;&gt;array scalar&lt;/a&gt;.</source>
          <target state="translated">NumPyでは、通常、&lt;a href=&quot;#term-array-scalar&quot;&gt;配列スカラーの&lt;/a&gt;同義語です。</target>
        </trans-unit>
        <trans-unit id="5a0e80530034196e1f24b0c9706df1a29c31a997" translate="yes" xml:space="preserve">
          <source>In NumPy, usually a synonym for &lt;a href=&quot;#term-dtype&quot;&gt;dtype&lt;/a&gt;. For the more general Python meaning, &lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-type&quot;&gt;see here.&lt;/a&gt;</source>
          <target state="translated">NumPyでは、通常、&lt;a href=&quot;#term-dtype&quot;&gt;dtypeの&lt;/a&gt;同義語です。より一般的なPythonの意味&lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-type&quot;&gt;については、ここを参照してください。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="774635ebbde845fd67b0f22449de4d887322609c" translate="yes" xml:space="preserve">
          <source>In Numeric, the ancestor of Numpy, broadcasting was implemented in several lines of code buried deep in ufuncobject.c. In NumPy, the notion of broadcasting has been abstracted so that it can be performed in multiple places. Broadcasting is handled by the function &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt;. This function requires a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; (or something that is a binary equivalent) to be passed in. The &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the broadcast number of dimensions and size in each dimension along with the total size of the broadcast result. It also keeps track of the number of arrays being broadcast and a pointer to an iterator for each of the arrays being broadcast.</source>
          <target state="translated">Numpyの祖先であるNumericでは、ufuncobject.cの奥深くに埋め込まれた数行のコードでブロードキャストが実装されました。 NumPyでは、ブロードキャストの概念が抽象化され、複数の場所で実行できるようになりました。ブロードキャストは、関数&lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt;によって処理されます。この関数では、&lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt;（またはバイナリの同等物）を渡す必要があります&lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt;は、ブロードキャスト結果の合計サイズとともに、ブロードキャストの次元数と各次元のサイズを追跡します。また、ブロードキャストされるアレイの数と、ブロードキャストされる各アレイのイテレータへのポインタも追跡します。</target>
        </trans-unit>
        <trans-unit id="8922bb1c700cbaf5cb6e489ccc3a2d78c8e39611" translate="yes" xml:space="preserve">
          <source>In Numeric, the ancestor of Numpy, broadcasting was implemented in several lines of code buried deep in ufuncobject.c. In NumPy, the notion of broadcasting has been abstracted so that it can be performed in multiple places. Broadcasting is handled by the function &lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt;. This function requires a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; (or something that is a binary equivalent) to be passed in. The &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the broadcast number of dimensions and size in each dimension along with the total size of the broadcast result. It also keeps track of the number of arrays being broadcast and a pointer to an iterator for each of the arrays being broadcast.</source>
          <target state="translated">Numpyの祖先であるNumericでは、放送はufuncobject.cの奥深くに埋め込まれた数行のコードで実装されていました。 NumPyでは、ブロードキャストの概念が抽象化されているため、複数の場所で実行できます。ブロードキャストは、関数&lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt;によって処理されます。この関数では、&lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt;（またはバイナリに相当するもの）を渡す必要があります&lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt;は、ブロードキャスト結果の合計サイズとともに、各次元のディメンションのブロードキャスト数とサイズを追跡します。また、ブロードキャストされている配列の数と、ブロードキャストされている各配列のイテレーターへのポインターを追跡します。</target>
        </trans-unit>
        <trans-unit id="22b48541001b861013a36c818439e26a1074dfe7" translate="yes" xml:space="preserve">
          <source>In Numpy 1.15, indexing an array with a multi-field index returned a copy of the result above, but with fields packed together in memory as if passed through &lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Numpy 1.15では、マルチフィールドインデックスを使用して配列にインデックスを&lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt; &lt;/a&gt;と、上記の結果のコピーが返されましたが、フィールドはnumpy.lib.recfunctions.repack_fieldsを通過したかのようにメモリにパックされています。</target>
        </trans-unit>
        <trans-unit id="1b22fd0d42a99bd19673ecd40259cf68612486f3" translate="yes" xml:space="preserve">
          <source>In Python 3.0, &lt;code&gt;//&lt;/code&gt; is the floor division operator and &lt;code&gt;/&lt;/code&gt; the true division operator. The &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; function is equivalent to true division in Python.</source>
          <target state="translated">Python 3.0では、 &lt;code&gt;//&lt;/code&gt; はフロア除算演算子および &lt;code&gt;/&lt;/code&gt; は真の除算演算子です。 &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; 関数はPythonで、真の除算に相当します。</target>
        </trans-unit>
        <trans-unit id="62fa547333a8d1dc9c0d4f4c02b89f627c6e6bc6" translate="yes" xml:space="preserve">
          <source>In Python, &lt;code&gt;//&lt;/code&gt; is the floor division operator and &lt;code&gt;/&lt;/code&gt; the true division operator. The &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; function is equivalent to true division in Python.</source>
          <target state="translated">Pythonでは、 &lt;code&gt;//&lt;/code&gt; は床除算演算子であり、 &lt;code&gt;/&lt;/code&gt; は真の除算演算子です。 &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; 関数はPythonで、真の除算に相当します。</target>
        </trans-unit>
        <trans-unit id="c2ae9f01dfbac70b64c2f45fa3c211ed297fec42" translate="yes" xml:space="preserve">
          <source>In Python, &lt;code&gt;arr[i, j]&lt;/code&gt; is exactly the same as &lt;code&gt;arr[(i, j)]&lt;/code&gt;&amp;mdash;so we can put &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; in a &lt;code&gt;tuple&lt;/code&gt; and then do the indexing with that.</source>
          <target state="translated">Pythonでは、 &lt;code&gt;arr[i, j]&lt;/code&gt; は &lt;code&gt;arr[(i, j)]&lt;/code&gt; ]とまったく同じです。したがって、 &lt;code&gt;i&lt;/code&gt; と &lt;code&gt;j&lt;/code&gt; を &lt;code&gt;tuple&lt;/code&gt; 、それを使用してインデックスを作成できます。</target>
        </trans-unit>
        <trans-unit id="060ed7eb6876dfc9a447b37757dfa0a45bd6069c" translate="yes" xml:space="preserve">
          <source>In Python, &lt;code&gt;x[(exp1, exp2, ..., expN)]&lt;/code&gt; is equivalent to &lt;code&gt;x[exp1, exp2, ..., expN]&lt;/code&gt;; the latter is just syntactic sugar for the former.</source>
          <target state="translated">Pythonでは、 &lt;code&gt;x[(exp1, exp2, ..., expN)]&lt;/code&gt; は &lt;code&gt;x[exp1, exp2, ..., expN]&lt;/code&gt; 。後者は前者の単なる構文糖です。</target>
        </trans-unit>
        <trans-unit id="667b044648896477b62af8727dbe5136eaaff74b" translate="yes" xml:space="preserve">
          <source>In Python:</source>
          <target state="translated">Pythonで。</target>
        </trans-unit>
        <trans-unit id="269b609eb84c47b360c36d70b62b2cd1bb86a5a5" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, each sub-type is called a &lt;code&gt;field&lt;/code&gt;. The &lt;code&gt;field&lt;/code&gt; has a name (a string), a type (any valid dtype), and an optional &lt;code&gt;title&lt;/code&gt;. See &lt;a href=&quot;reference/arrays.dtypes#arrays-dtypes&quot;&gt;Data type objects (dtype)&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#term-structured-data-type&quot;&gt;構造化データタイプ&lt;/a&gt;、各サブタイプと呼ばれる &lt;code&gt;field&lt;/code&gt; 。この &lt;code&gt;field&lt;/code&gt; は、名前（文字列）、タイプ（任意の有効なdtype）、およびオプションの &lt;code&gt;title&lt;/code&gt; ます。&lt;a href=&quot;reference/arrays.dtypes#arrays-dtypes&quot;&gt;データ型オブジェクト（dtype）を&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="78662ce2ae98004557ba9c8d13d5c59518b52877" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, each subtype is called a &lt;code&gt;field&lt;/code&gt;. The &lt;code&gt;field&lt;/code&gt; has a name (a string), a type (any valid dtype), and an optional &lt;code&gt;title&lt;/code&gt;. See &lt;a href=&quot;reference/arrays.dtypes#arrays-dtypes&quot;&gt;Data type objects (dtype)&lt;/a&gt;.</source>
          <target state="translated">で&lt;a href=&quot;#term-structured-data-type&quot;&gt;構造化データ型&lt;/a&gt;、各サブタイプと呼ばれる &lt;code&gt;field&lt;/code&gt; 。この &lt;code&gt;field&lt;/code&gt; は、名前（文字列）、タイプ（任意の有効なdtype）、およびオプションの &lt;code&gt;title&lt;/code&gt; ます。&lt;a href=&quot;reference/arrays.dtypes#arrays-dtypes&quot;&gt;データ型オブジェクト（dtype）を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7514faa85354deb212fc2851d0e9a73ad2bab680" translate="yes" xml:space="preserve">
          <source>In a dtype declaration, indicates that the data is &lt;a href=&quot;#term-big-endian&quot;&gt;big-endian&lt;/a&gt; (the bracket is big on the left).</source>
          <target state="translated">dtype宣言で、データが&lt;a href=&quot;#term-big-endian&quot;&gt;ビッグエンディアン&lt;/a&gt;であることを示します（左側の角かっこは大きい）。</target>
        </trans-unit>
        <trans-unit id="00f212b64142d015b24d77af65f90b372712d4ee" translate="yes" xml:space="preserve">
          <source>In a dtype declaration, indicates that the data is &lt;a href=&quot;#term-little-endian&quot;&gt;little-endian&lt;/a&gt; (the bracket is big on the right).</source>
          <target state="translated">dtype宣言で、データが&lt;a href=&quot;#term-little-endian&quot;&gt;リトルエンディアン&lt;/a&gt;であることを示します（右側の角かっこは大きい）。</target>
        </trans-unit>
        <trans-unit id="2721403cc827c0b84ea65a28ef2dffa50ceb53e2" translate="yes" xml:space="preserve">
          <source>In a nutshell, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; runs two main loops. The first loop converts each line of the file in a sequence of strings. The second loop converts each string to the appropriate data type. This mechanism is slower than a single loop, but gives more flexibility. In particular, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; is able to take missing data into account, when other faster and simpler functions like &lt;a href=&quot;../reference/generated/numpy.loadtxt#numpy.loadtxt&quot;&gt;&lt;code&gt;loadtxt&lt;/code&gt;&lt;/a&gt; cannot.</source>
          <target state="translated">一言で言えば、&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;は2つの主要なループを実行します。最初のループは、ファイルの各行を文字列のシーケンスに変換します。2番目のループは、各文字列を適切なデータ型に変換します。このメカニズムは単一のループよりも低速ですが、柔軟性が高くなります。特に、&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;は、loadtxtのような他のより高速で単純な関数では&lt;a href=&quot;../reference/generated/numpy.loadtxt#numpy.loadtxt&quot;&gt; &lt;code&gt;loadtxt&lt;/code&gt; &lt;/a&gt;な場合に、欠落しているデータを考慮に入れることができます。</target>
        </trans-unit>
        <trans-unit id="0643c04fa6f173d8a3f9cc4f3ce84f7f07625090" translate="yes" xml:space="preserve">
          <source>In a study, testing for a specific alternative to the null hypothesis requires use of the Noncentral F distribution. We need to calculate the area in the tail of the distribution that exceeds the value of the F distribution for the null hypothesis. We&amp;rsquo;ll plot the two probability distributions for comparison.</source>
          <target state="translated">ある研究では、帰無仮説の特定の代替案をテストするには、非中心F分布を使用する必要があります。帰無仮説のF分布の値を超える分布の裾の領域を計算する必要があります。比較のために2つの確率分布をプロットします。</target>
        </trans-unit>
        <trans-unit id="4a555d5f0fdb6581c9697563824e3d61c23e3de4" translate="yes" xml:space="preserve">
          <source>In a two&amp;rsquo;s-complement system negative numbers are represented by the two&amp;rsquo;s complement of the absolute value. This is the most common method of representing signed integers on computers &lt;a href=&quot;#r962252997619-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. A N-bit two&amp;rsquo;s-complement system can represent every integer in the range</source>
          <target state="translated">2の補数システムでは、負の数は絶対値の2の補数で表されます。これは、コンピューターで符号付き整数を表す最も一般的な方法です&lt;a href=&quot;#r962252997619-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。Nビットの2の補数システムは、範囲内のすべての整数を表すことができます</target>
        </trans-unit>
        <trans-unit id="77d7c8f0da722bad85b21b1524a660b76382145e" translate="yes" xml:space="preserve">
          <source>In a two-dimensional vector, the elements of axis 0 are rows and the elements of axis 1 are columns.</source>
          <target state="translated">2次元のベクトルでは、軸0の要素が行、軸1の要素が列となります。</target>
        </trans-unit>
        <trans-unit id="6ec708a7d401df6aafb3a323298b5e8a10e70e10" translate="yes" xml:space="preserve">
          <source>In addition &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; may be scalars, in which case:</source>
          <target state="translated">さらに &lt;code&gt;a&lt;/code&gt; または &lt;code&gt;b&lt;/code&gt; はスカラーである場合があります。その場合、</target>
        </trans-unit>
        <trans-unit id="85652b9aa303fc72ea7ade73af4f0dda2d5084d0" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;numpy.lib.io&lt;/code&gt; module provides several convenience functions derived from &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt;. These functions work the same way as the original, but they have different default values.</source>
          <target state="translated">&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;に加えて、 &lt;code&gt;numpy.lib.io&lt;/code&gt; モジュールは&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;から派生したいくつかの便利な関数を提供します。これらの関数は元の関数と同じように機能しますが、デフォルト値が異なります。</target>
        </trans-unit>
        <trans-unit id="a6237f20922b3630e0de0aceabbe18bc44178c19" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;numpy.lib.npyio&lt;/code&gt; module provides several convenience functions derived from &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt;. These functions work the same way as the original, but they have different default values.</source>
          <target state="translated">&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;に加えて、 &lt;code&gt;numpy.lib.npyio&lt;/code&gt; モジュールは&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;から派生したいくつかの便利な関数を提供します。これらの関数は元の関数と同じように機能しますが、デフォルト値が異なります。</target>
        </trans-unit>
        <trans-unit id="3b2e8925339289db83edc8e4d5703c4e6627acaa" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;__array_wrap__&lt;/code&gt;, which is called on the way out of the ufunc, there is also an &lt;code&gt;__array_prepare__&lt;/code&gt; method which is called on the way into the ufunc, after the output arrays are created but before any computation has been performed. The default implementation does nothing but pass through the array. &lt;code&gt;__array_prepare__&lt;/code&gt; should not attempt to access the array data or resize the array, it is intended for setting the output array type, updating attributes and metadata, and performing any checks based on the input that may be desired before computation begins. Like &lt;code&gt;__array_wrap__&lt;/code&gt;, &lt;code&gt;__array_prepare__&lt;/code&gt; must return an ndarray or subclass thereof or raise an error.</source>
          <target state="translated">&lt;code&gt;__array_wrap__&lt;/code&gt; からの途中で呼び出される__array_wrap__に加えて、出力配列が作成された後、計算が実行される前に、ufuncに入る途中で呼び出される &lt;code&gt;__array_prepare__&lt;/code&gt; メソッドもあります。デフォルトの実装は、配列を通過するだけです。 &lt;code&gt;__array_prepare__&lt;/code&gt; は、配列データへのアクセスや配列のサイズ変更を試みるべきではありません。これは、出力配列タイプの設定、属性とメタデータの更新、および計算を開始する前に必要な入力に基づくチェックの実行を目的としています。 &lt;code&gt;__array_wrap__&lt;/code&gt; と同様に、 &lt;code&gt;__array_prepare__&lt;/code&gt; はndarrayまたはそのサブクラスを返すか、エラーを発生させる必要があります。</target>
        </trans-unit>
        <trans-unit id="0202a847e7f1c55dfe19c04653df757ab3188d4f" translate="yes" xml:space="preserve">
          <source>In addition to attributes that can be specified via keyword arguments to &lt;code&gt;Configuration&lt;/code&gt; constructor, &lt;code&gt;Configuration&lt;/code&gt; instance (let us denote as &lt;code&gt;config&lt;/code&gt;) has the following attributes that can be useful in writing setup scripts:</source>
          <target state="translated">&lt;code&gt;Configuration&lt;/code&gt; コンストラクターのキーワード引数を介して指定できる属性に加えて、 &lt;code&gt;Configuration&lt;/code&gt; インスタンス（ &lt;code&gt;config&lt;/code&gt; と表記）には、セットアップスクリプトの作成に役立つ次の属性があります。</target>
        </trans-unit>
        <trans-unit id="9205eb129a4d89ef4a9eb5c8d77614ae87b40a33" translate="yes" xml:space="preserve">
          <source>In addition to field names, fields may also have an associated &lt;a href=&quot;../glossary#term-title&quot;&gt;title&lt;/a&gt;, an alternate name, which is sometimes used as an additional description or alias for the field. The title may be used to index an array, just like a field name.</source>
          <target state="translated">フィールド名に加えて、フィールドには、フィールドの追加の説明またはエイリアスとして使用されることもある代替名である&lt;a href=&quot;../glossary#term-title&quot;&gt;タイトル&lt;/a&gt;が関連付けられている場合もあります。タイトルは、フィールド名と同じように、配列にインデックスを付けるために使用できます。</target>
        </trans-unit>
        <trans-unit id="1ee5bd9d7a0e50bb5b466ac30e311415eba3cdbd" translate="yes" xml:space="preserve">
          <source>In addition to field names, structured array fields may have an associated &lt;a href=&quot;user/basics.rec#titles&quot;&gt;title&lt;/a&gt; which is an alias to the name and is commonly used for plotting.</source>
          <target state="translated">フィールド名に加えて、構造化配列フィールドには、名前のエイリアスであり、プロットに一般的に使用される&lt;a href=&quot;user/basics.rec#titles&quot;&gt;タイトル&lt;/a&gt;が関連付けられている場合があります。</target>
        </trans-unit>
        <trans-unit id="5d8a9cc27249ffd4d0b1366a65411d876d2aa7c5" translate="yes" xml:space="preserve">
          <source>In addition to sort, which returns a sorted copy of an array, you can use:</source>
          <target state="translated">配列のソートされたコピーを返す sort の他にも、以下のような方法があります。</target>
        </trans-unit>
        <trans-unit id="29ec49c4a4c9a814e9bec074f3eabcbf7dea786f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; class, the &lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module defines several constants.</source>
          <target state="translated">加え&lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; の&lt;/a&gt;クラス、&lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; の&lt;/a&gt;モジュールは、いくつかの定数を定義します。</target>
        </trans-unit>
        <trans-unit id="7b236bba71a2e6d9bbb7e9f54e04010c73fd209b" translate="yes" xml:space="preserve">
          <source>In addition to the Python C-API, there is a full and rich C-API for NumPy allowing sophisticated manipulations on a C-level. However, for most applications, only a few API calls will typically be used. For example, if you need to just extract a pointer to memory along with some shape information to pass to another calculation routine, then you will use very different calls than if you are trying to create a new array-like type or add a new data type for ndarrays. This chapter documents the API calls and macros that are most commonly used.</source>
          <target state="translated">PythonのC-APIに加えて、NumPyのための完全でリッチなC-APIがあり、Cレベルでの高度な操作を可能にしています。しかし、ほとんどのアプリケーションでは、通常はいくつかのAPIコールしか使用されません。例えば、形状情報と一緒にメモリへのポインタを抽出して別の計算ルーチンに渡す必要がある場合、新しい配列のような型を作成したり、ndarrays用の新しいデータ型を追加したりする場合とは全く異なる呼び出しを使用することになります。この章では、最も一般的に使用されるAPIコールとマクロについて説明します。</target>
        </trans-unit>
        <trans-unit id="4c1e50029232768a84bc4dc52748436e5f14647c" translate="yes" xml:space="preserve">
          <source>In addition, F2PY introduces the following statements:</source>
          <target state="translated">また、F2PYでは、以下のような記述を紹介しています。</target>
        </trans-unit>
        <trans-unit id="50f7370be70d6fe0e899df628f5a07f23f4c4044" translate="yes" xml:space="preserve">
          <source>In addition, building the documentation requires the Sphinx extension &lt;code&gt;plot_directive&lt;/code&gt;, which is shipped with &lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt;. This Sphinx extension can be installed by installing Matplotlib. You will also need Python&amp;gt;=3.6.</source>
          <target state="translated">さらに、ドキュメントを作成するには、&lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlibに&lt;/a&gt;付属しているSphinx拡張機能 &lt;code&gt;plot_directive&lt;/code&gt; が必要です。このSphinx拡張機能は、Matplotlibをインストールすることでインストールできます。Python&amp;gt; = 3.6も必要になります。</target>
        </trans-unit>
        <trans-unit id="55ae7a3680f09394c2ee157c2db0452e71e75c1c" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;em&gt;data&lt;/em&gt; is non-NULL, then &lt;em&gt;strides&lt;/em&gt; can also be provided. If &lt;em&gt;strides&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the array strides are computed as C-style contiguous (default) or Fortran-style contiguous (&lt;em&gt;flags&lt;/em&gt; is nonzero for &lt;em&gt;data&lt;/em&gt; = &lt;code&gt;NULL&lt;/code&gt; or &lt;em&gt;flags&lt;/em&gt; &amp;amp; &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; is nonzero non-NULL &lt;em&gt;data&lt;/em&gt;). Any provided &lt;em&gt;dims&lt;/em&gt; and &lt;em&gt;strides&lt;/em&gt; are copied into newly allocated dimension and strides arrays for the new array object.</source>
          <target state="translated">さらに、&lt;em&gt;データ&lt;/em&gt;が非NULLの場合、&lt;em&gt;ストライド&lt;/em&gt;も提供できます。&lt;em&gt;ストライド&lt;/em&gt;が &lt;code&gt;NULL&lt;/code&gt; の場合、配列ストライドはCスタイルの連続（デフォルト）またはFortranスタイルの連続（&lt;em&gt;フラグ&lt;/em&gt;は&lt;em&gt;data&lt;/em&gt; = &lt;code&gt;NULL&lt;/code&gt; または&lt;em&gt;flags&lt;/em&gt;＆&lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;はゼロ以外の非NULL &lt;em&gt;データ&lt;/em&gt;）として計算されます。指定された&lt;em&gt;dims&lt;/em&gt;と&lt;em&gt;strides&lt;/em&gt;は、新しく割り当てられた次元にコピーされ、新しい配列オブジェクトの配列をストライドします。</target>
        </trans-unit>
        <trans-unit id="176596f4a4076180f296c1297a5a4088a9dfbec9" translate="yes" xml:space="preserve">
          <source>In all the cases but the first one, the output will be a 1D array with a structured dtype. This dtype has as many fields as items in the sequence. The field names are defined with the &lt;code&gt;names&lt;/code&gt; keyword.</source>
          <target state="translated">最初のケースを除くすべてのケースで、出力は構造化されたdtypeを持つ1D配列になります。このdtypeには、シーケンス内のアイテムと同じ数のフィールドがあります。フィールド名は &lt;code&gt;names&lt;/code&gt; キーワードで定義されます。</target>
        </trans-unit>
        <trans-unit id="9d28ba92ccb218b4c16f2db7077723c632363102" translate="yes" xml:space="preserve">
          <source>In all the examples so far, the elements of &lt;code&gt;a&lt;/code&gt; are provided by the iterator one at a time, because all the looping logic is internal to the iterator. While this is simple and convenient, it is not very efficient. A better approach is to move the one-dimensional innermost loop into your code, external to the iterator. This way, NumPy&amp;rsquo;s vectorized operations can be used on larger chunks of the elements being visited.</source>
          <target state="translated">これまでのすべての例では、すべてのループロジックが反復子の内部にあるため、 &lt;code&gt;a&lt;/code&gt; の要素は、一度に1つずつ反復子によって提供されます。これはシンプルで便利ですが、あまり効率的ではありません。より良いアプローチは、1次元の最も内側のループをイテレータの外部のコードに移動することです。このように、NumPyのベクトル化された操作は、アクセスされる要素のより大きなチャンクで使用できます。</target>
        </trans-unit>
        <trans-unit id="8389ffaf8c2e94e518381d310c79dd3ec1608070" translate="yes" xml:space="preserve">
          <source>In almost all cases &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; should be used instead of this function, as that will also return true for 0d arrays. This is how numpy overloads functions in the style of the &lt;code&gt;dx&lt;/code&gt; arguments to &lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt;&lt;code&gt;gradient&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;bins&lt;/code&gt; argument to &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;. Some key differences:</source>
          <target state="translated">ほとんどすべての場合、この関数の代わりに &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; を使用する必要があります。0d配列に対してもtrueが返されるためです。これは、のスタイルでどのようにnumpyのオーバーロード機能である &lt;code&gt;dx&lt;/code&gt; の引数&lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt; &lt;code&gt;gradient&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;bins&lt;/code&gt; の引数&lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt;。主な違い：</target>
        </trans-unit>
        <trans-unit id="09406f1061497030999a27047c2ac1dba1e1fddd" translate="yes" xml:space="preserve">
          <source>In both cases, set the &lt;code&gt;BUILD_COMMIT&lt;/code&gt; variable to the current release tag - e.g. &lt;code&gt;v1.19.0&lt;/code&gt;:</source>
          <target state="translated">どちらの場合も、 &lt;code&gt;BUILD_COMMIT&lt;/code&gt; 変数を現在のリリースタグに設定します-例： &lt;code&gt;v1.19.0&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d0889b5074f2eea4eb02e68278d5fa430d814a4a" translate="yes" xml:space="preserve">
          <source>In case of merge conflicts, ask the PR submitter to &lt;a href=&quot;development_workflow#rebasing-on-master&quot;&gt;rebase on master&lt;/a&gt;.</source>
          <target state="translated">マージの競合が発生した場合は、PR送信者&lt;a href=&quot;development_workflow#rebasing-on-master&quot;&gt;にマスターに基づい&lt;/a&gt;てリベースするように依頼してください。</target>
        </trans-unit>
        <trans-unit id="3e277da1826bb81328288e7b48e1bc36cb3d9f8b" translate="yes" xml:space="preserve">
          <source>In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence are returned.</source>
          <target state="translated">最大値が複数回発生した場合、最初に発生した値に対応するインデックスが返されます。</target>
        </trans-unit>
        <trans-unit id="27e7146cba1027fb05de967eb96a8d0d4f3188c0" translate="yes" xml:space="preserve">
          <source>In case of multiple occurrences of the minimum values, the indices corresponding to the first occurrence are returned.</source>
          <target state="translated">最小値が複数回発生した場合、最初に発生した値に対応するインデックスが返されます。</target>
        </trans-unit>
        <trans-unit id="e0a4f4799ebef164e20467e93383e4d4633f2709" translate="yes" xml:space="preserve">
          <source>In case of severe and obvious breaches, e.g. personal threat or violent, sexist or racist language, we will immediately disconnect the originator from NumPy communication channels; please see the manual for details.</source>
          <target state="translated">個人的な脅迫や暴力的、性差別的、人種差別的な言葉など、重度で明らかな違反があった場合は、直ちに発信者をNumPyの通信チャネルから切断します。</target>
        </trans-unit>
        <trans-unit id="ae3b7f089e082a13dedd4fd05f16654244713a03" translate="yes" xml:space="preserve">
          <source>In cases not involving clear severe and obvious breaches of this code of conduct, the process for acting on any received code of conduct violation report will be:</source>
          <target state="translated">この行動規範の明らかな重大かつ明白な違反が含まれていない場合、受け取った行動規範違反報告書に対応するためのプロセスは、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="b7695ef954df8bd205d22a810fa2781d2a8a8dfc" translate="yes" xml:space="preserve">
          <source>In certain cases a failed installation or setup issue can cause you to see the following error message:</source>
          <target state="translated">インストールやセットアップに失敗した場合、以下のようなエラーメッセージが表示されることがあります。</target>
        </trans-unit>
        <trans-unit id="77e954d7daee979232398ad08ec5cc70a6a273a6" translate="yes" xml:space="preserve">
          <source>In code, arrays are often conveniently expressed as nested lists:</source>
          <target state="translated">コードでは、配列はしばしば入れ子になったリストとして便利に表現されます。</target>
        </trans-unit>
        <trans-unit id="c38db33a30014f091c11009d703bc2b8cd0eeadd" translate="yes" xml:space="preserve">
          <source>In complex cases, &lt;a href=&quot;../reference/generated/numpy.r_#numpy.r_&quot;&gt;&lt;code&gt;r_&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.c_#numpy.c_&quot;&gt;&lt;code&gt;c_&lt;/code&gt;&lt;/a&gt; are useful for creating arrays by stacking numbers along one axis. They allow the use of range literals (&amp;ldquo;:&amp;rdquo;)</source>
          <target state="translated">複雑なケースでは、&lt;a href=&quot;../reference/generated/numpy.r_#numpy.r_&quot;&gt; &lt;code&gt;r_&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../reference/generated/numpy.c_#numpy.c_&quot;&gt; &lt;code&gt;c_&lt;/code&gt; &lt;/a&gt;は、1つの軸に沿って数値を積み重ねて配列を作成するのに役立ちます。範囲リテラル（「：」）の使用を許可します</target>
        </trans-unit>
        <trans-unit id="298a2b20fe81aca60c55bf455754cf5365f9ba46" translate="yes" xml:space="preserve">
          <source>In contrast to Python, where slicing creates a copy, in NumPy slicing creates a &lt;a href=&quot;#term-view&quot;&gt;view&lt;/a&gt;.</source>
          <target state="translated">スライスによってコピーが作成されるPythonとは対照的に、NumPyではスライスによって&lt;a href=&quot;#term-view&quot;&gt;ビュー&lt;/a&gt;が作成されます。</target>
        </trans-unit>
        <trans-unit id="15906ca68f2a7d7e2f6c027ec51f5d69dd3bed29" translate="yes" xml:space="preserve">
          <source>In copying mode, &amp;lsquo;copy&amp;rsquo; is specified as a per-operand flag. This is done to provide control in a per-operand fashion. Buffering mode is specified as an iterator flag.</source>
          <target state="translated">コピーモードでは、「copy」がオペランドごとのフラグとして指定されます。これは、オペランドごとに制御を提供するために行われます。バッファリングモードは、イテレータフラグとして指定されます。</target>
        </trans-unit>
        <trans-unit id="d217a2b2edd5733cc1a08fd36e52adeffd147a5f" translate="yes" xml:space="preserve">
          <source>In ctypes, the return-value of a function is set to be &amp;lsquo;int&amp;rsquo; by default. This behavior can be changed by setting the restype attribute of the function. Use None for the restype if the function has no return value (&amp;lsquo;void&amp;rsquo;):</source>
          <target state="translated">ctypesでは、関数の戻り値はデフォルトで「int」に設定されています。この動作は、関数のrestype属性を設定することで変更できます。関数に戻り値がない場合（「void」）、restypeにNoneを使用します。</target>
        </trans-unit>
        <trans-unit id="20601c7341dfe87ba7a45fcff8c92729cd267fbb" translate="yes" xml:space="preserve">
          <source>In depth explanation of concepts, best practices and techniques</source>
          <target state="translated">概念、ベストプラクティス、テクニックを徹底解説</target>
        </trans-unit>
        <trans-unit id="2913833b48b2894352d88e1660f11e59aa09d3c6" translate="yes" xml:space="preserve">
          <source>In detail</source>
          <target state="translated">詳細はこちら</target>
        </trans-unit>
        <trans-unit id="18557e967a450637ab72e77508fbfb08c6b092fc" translate="yes" xml:space="preserve">
          <source>In effect, the slice and index array operation are independent. The slice operation extracts columns with index 1 and 2, (i.e. the 2nd and 3rd columns), followed by the index array operation which extracts rows with index 0, 2 and 4 (i.e the first, third and fifth rows).</source>
          <target state="translated">実質的に、スライス操作とインデックス配列操作は独立しています。スライス操作はインデックス 1 と 2 の列(つまり 2 番目と 3 番目の列)を抽出し、続いてインデックス配列操作はインデックス 0,2,4 の行(つまり 1 番目、3 番目、5 番目の行)を抽出します。</target>
        </trans-unit>
        <trans-unit id="0401f70e9e9ccb692db031dd68efec8a8e548588" translate="yes" xml:space="preserve">
          <source>In every case, the &amp;lsquo;descr&amp;rsquo; key is optional, but of course provides more information which may be important for various applications:</source>
          <target state="translated">いずれの場合も、「descr」キーはオプションですが、もちろん、さまざまなアプリケーションにとって重要となる可能性がある詳細情報を提供します。</target>
        </trans-unit>
        <trans-unit id="ed0824a3a5c26008c8df28fe72abd00f4b7f2a94" translate="yes" xml:space="preserve">
          <source>In every case, the moderator should make a reasonable effort to contact the originator, and tell them specifically how their language or actions qualify as a &amp;ldquo;clear and severe breach&amp;rdquo;. The moderator should also say that, if the originator believes this is unfair or they want to be reconnected to NumPy, they have the right to ask for a review, as below, by the Code of Conduct Committee. The moderator should copy this explanation to the Code of Conduct Committee.</source>
          <target state="translated">いずれの場合も、モデレーターは発信者に連絡するために合理的な努力を払い、彼らの言葉や行動が「明確で重大な違反」としてどのように適格であるかを具体的に伝える必要があります。モデレーターはまた、オリジネーターがこれが不公平であると信じている場合、またはNumPyに再接続したい場合は、以下のように行動規範委員会によるレビューを求める権利があると言う必要があります。モデレーターは、この説明を行動規範委員会にコピーする必要があります。</target>
        </trans-unit>
        <trans-unit id="7eac15d5d1d96d05ac021a41eb29548e9ee61a69" translate="yes" xml:space="preserve">
          <source>In fact, why don&amp;rsquo;t we try that?</source>
          <target state="translated">実は、やってみませんか？</target>
        </trans-unit>
        <trans-unit id="a50f2ab9bd768752351c518eb56b5f190e77022a" translate="yes" xml:space="preserve">
          <source>In general how to set and check your environment variables depends on your system. If you can open a correct python shell, you can also run the following in python:</source>
          <target state="translated">一般的に環境変数をどのように設定し、チェックするかはシステムに依存します。正しいpythonシェルを開くことができれば、pythonで以下のように実行することもできます。</target>
        </trans-unit>
        <trans-unit id="51a2782158f2135b3873b2bc91584160c3224ec1" translate="yes" xml:space="preserve">
          <source>In general if an index includes a Boolean array, the result will be identical to inserting &lt;code&gt;obj.nonzero()&lt;/code&gt; into the same position and using the integer array indexing mechanism described above. &lt;code&gt;x[ind_1, boolean_array, ind_2]&lt;/code&gt; is equivalent to &lt;code&gt;x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]&lt;/code&gt;.</source>
          <target state="translated">一般に、インデックスにブール配列が含まれている場合、結果は &lt;code&gt;obj.nonzero()&lt;/code&gt; を同じ位置に挿入し、上記の整数配列インデックスメカニズムを使用した場合と同じになります。 &lt;code&gt;x[ind_1, boolean_array, ind_2]&lt;/code&gt; は &lt;code&gt;x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a0426d4d5e9174343610861881dfacd8c07a4e5a" translate="yes" xml:space="preserve">
          <source>In general, a scalar argument of a F2PY generated wrapper function can be an ordinary Python scalar (integer, float, complex number) as well as an arbitrary sequence object (list, tuple, array, string) of scalars. In the latter case, the first element of the sequence object is passed to Fortran routine as a scalar argument.</source>
          <target state="translated">一般的に、F2PYで生成されたラッパー関数のスカラー引数は、通常のPythonスカラー(整数、浮動小数点、複素数)だけでなく、スカラーの任意のシーケンスオブジェクト(リスト、タプル、配列、文字列)を指定することができます。後者の場合、シーケンスオブジェクトの最初の要素はスカラー引数としてFortranルーチンに渡されます。</target>
        </trans-unit>
        <trans-unit id="41b09ab4340a010ae2242f6c23854be608350193" translate="yes" xml:space="preserve">
          <source>In general, array arguments of F2PY generated wrapper functions accept arbitrary sequences that can be transformed to NumPy array objects. An exception is &lt;code&gt;intent(inout)&lt;/code&gt; array arguments that always must be proper-contiguous and have proper type, otherwise an exception is raised. Another exception is &lt;code&gt;intent(inplace)&lt;/code&gt; array arguments that attributes will be changed &lt;em&gt;in situ&lt;/em&gt; if the argument has different type than expected (see &lt;code&gt;intent(inplace)&lt;/code&gt; attribute for more information).</source>
          <target state="translated">一般に、F2PYで生成されたラッパー関数の配列引数は、NumPy配列オブジェクトに変換できる任意のシーケンスを受け入れます。例外は &lt;code&gt;intent(inout)&lt;/code&gt; 配列引数であり、常に適切に連続し、適切な型である必要があります。そうでない場合、例外が発生します。もう1つの例外は、 &lt;code&gt;intent(inplace)&lt;/code&gt; 配列引数です。引数の型が予想と異なる場合、属性は&lt;em&gt;その場&lt;/em&gt;で変更さ&lt;em&gt;れ&lt;/em&gt;ます（詳細については、 &lt;code&gt;intent(inplace)&lt;/code&gt; 属性を参照してください）。</target>
        </trans-unit>
        <trans-unit id="ce9f087f4c4d9805ec9d46a8db9fd36d60eeb431" translate="yes" xml:space="preserve">
          <source>In general, for &lt;code&gt;values&lt;/code&gt;</source>
          <target state="translated">一般的に、 &lt;code&gt;values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4732749a65786e199f581dd65439c32d67356e7" translate="yes" xml:space="preserve">
          <source>In general, for arrays with more than two dimensions, &lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt; stacks along their second axes, &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt; stacks along their first axes, and &lt;a href=&quot;../reference/generated/numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt; allows for an optional arguments giving the number of the axis along which the concatenation should happen.</source>
          <target state="translated">一般に、3次元以上の配列の場合、&lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt;は2番目の軸に沿ってスタックし、&lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt; &lt;code&gt;vstack&lt;/code&gt; &lt;/a&gt;は最初の軸に沿ってスタックし、&lt;a href=&quot;../reference/generated/numpy.concatenate#numpy.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt;により、連結が発生する軸の番号を指定するオプションの引数を使用できます。</target>
        </trans-unit>
        <trans-unit id="31150963fe6ef250ba4e833d06b222cca1c2cb70" translate="yes" xml:space="preserve">
          <source>In general, if a NumPy array is proper-contiguous and has a proper type then it is directly passed to wrapped Fortran/C function. Otherwise, an element-wise copy of an input array is made and the copy, being proper-contiguous and with proper type, is used as an array argument.</source>
          <target state="translated">一般的に,NumPyの配列が適切な連続性を持ち,適切な型を持つ場合は,ラップされたFortran/C関数に直接渡されます.そうでなければ,入力配列の要素ごとのコピーが作成され,そのコピーは,適切な連続性を持ち,適切な型を持つものであれば,配列の引数として利用されます.</target>
        </trans-unit>
        <trans-unit id="13ea723c2a24ed6ef1771c5f258ea31816238b49" translate="yes" xml:space="preserve">
          <source>In general, if the array owns its own memory, as for &lt;code&gt;arr&lt;/code&gt; in this case, then &lt;code&gt;arr.base&lt;/code&gt; will be None - there are some exceptions to this - see the numpy book for more details.</source>
          <target state="translated">一般に、配列が独自のメモリを所有している場合、この場合の &lt;code&gt;arr&lt;/code&gt; の場合、 &lt;code&gt;arr.base&lt;/code&gt; はNoneになります（これにはいくつかの例外があります）。詳細については、numpyブックを参照してください。</target>
        </trans-unit>
        <trans-unit id="5abc873332e6b6be31064612f2de6812b8a80d3b" translate="yes" xml:space="preserve">
          <source>In general, it is not necessary to list class methods. Those that are not part of the public API have names that start with an underscore. In some cases, however, a class may have a great many methods, of which only a few are relevant (e.g., subclasses of ndarray). Then, it becomes useful to have an additional &lt;strong&gt;Methods&lt;/strong&gt; section:</source>
          <target state="translated">一般に、クラスメソッドをリストする必要はありません。パブリックAPIの一部ではないものには、アンダースコアで始まる名前が付いています。ただし、場合によっては、クラスに非常に多くのメソッドがあり、そのうちのいくつかだけが関連します（たとえば、ndarrayのサブクラス）。次に、追加の&lt;strong&gt;メソッド&lt;/strong&gt;セクションがあると便利になります。</target>
        </trans-unit>
        <trans-unit id="fcbe439e71ce76a6bc1cdecd65ffad854f695844" translate="yes" xml:space="preserve">
          <source>In general, numerical data arranged in an array-like structure in Python can be converted to arrays through the use of the array() function. The most obvious examples are lists and tuples. See the documentation for array() for details for its use. Some objects may support the array-protocol and allow conversion to arrays this way. A simple way to find out if the object can be converted to a numpy array using array() is simply to try it interactively and see if it works! (The Python Way).</source>
          <target state="translated">一般的に、Pythonで配列のような構造になっている数値データは、array()関数を使うことで配列に変換することができます。最もわかりやすい例はリストとタプルです。使い方の詳細は array()のドキュメントを参照してください。いくつかのオブジェクトは配列プロトコルをサポートしており、この方法で配列への変換を許可しているかもしれません。オブジェクトが array()を使って numpy 配列に変換できるかどうかを調べる簡単な方法は、単純に対話的に試してみて動作するかどうかを確認することです! (The Python Way)。</target>
        </trans-unit>
        <trans-unit id="4879f4fa7efdef399be3e3db9bf5ed36f36adbd1" translate="yes" xml:space="preserve">
          <source>In general, prefer &lt;a href=&quot;../reference/generated/numpy.save#numpy.save&quot;&gt;&lt;code&gt;numpy.save&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.load#numpy.load&quot;&gt;&lt;code&gt;numpy.load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一般に、&lt;a href=&quot;../reference/generated/numpy.save#numpy.save&quot;&gt; &lt;code&gt;numpy.save&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../reference/generated/numpy.load#numpy.load&quot;&gt; &lt;code&gt;numpy.load&lt;/code&gt; を優先し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="2636b2d2555459756347b2bec78d067967d80c45" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one C-series by another results in quotient and remainder terms that are not in the Chebyshev polynomial basis set. Thus, to express these results as C-series, it is typically necessary to &amp;ldquo;reproject&amp;rdquo; the results onto said basis set, which typically produces &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">一般に、C系列を（多項式で）除算すると、Chebyshev多項式基底関数セットにはない商項と剰余項が生成されます。したがって、これらの結果をCシリーズとして表現するには、通常、結果を前記基底セットに「再投影」する必要があります。これにより、通常、「直感的でない」（ただし正しい）結果が生成されます。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="e3455fcce926f7a356d4db4cbb1cca4337cab9da" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Hermite series by another results in quotient and remainder terms that are not in the Hermite polynomial basis set. Thus, to express these results as a Hermite series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Hermite basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">一般に、あるエルミート級数を別のエルミート級数で（多項式）除算すると、エルミート多項式基底セットにない商項と剰余項が生成されます。したがって、これらの結果をHermiteシリーズとして表現するには、結果をHermite基底関数セットに「再投影」する必要があります。これにより、「直感的でない」（しかし正しい）結果が生成される可能性があります。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="efbd236c04665a122a8e3491beed41d349724880" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Laguerre series by another results in quotient and remainder terms that are not in the Laguerre polynomial basis set. Thus, to express these results as a Laguerre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Laguerre basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">一般に、あるラゲール級数を別のラゲール級数で除算すると、ラゲール多項式基底関数セットにはない商項と剰余項が生成されます。したがって、これらの結果をラゲールシリーズとして表すには、結果をラゲール基底関数セットに「再投影」する必要があります。これにより、「直感的でない」（しかし正しい）結果が生成される場合があります。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="3e8f9ae8eb5287a2e2ca75de1027864d1ea7dce3" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Legendre series by another results in quotient and remainder terms that are not in the Legendre polynomial basis set. Thus, to express these results as a Legendre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Legendre basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">一般に、あるルジャンドル級数を別のルジャンドル級数で（多項式）除算すると、ルジャンドル多項式基底関数セットにない商項と剰余項が生成されます。したがって、これらの結果をルジャンドル級数として表現するには、結果をルジャンドル基底関数に「再投影」する必要があります。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="747e8b05b6e447bd7c26bc6951f1c707ad59f09d" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Chebyshev polynomial basis set. Thus, to express the product as a C-series, it is typically necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which typically produces &amp;ldquo;unintuitive live&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">一般に、2つのC系列の（多項式）積は、チェビシェフ多項式基底関数セットにない条件で結果として生成されます。したがって、製品をCシリーズとして表現するには、通常、製品を上記の基底セットに「再投影」する必要があります。これにより、通常、「直感的でない」ライブ（ただし正しい）結果が生成されます。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="140624c01263c11121eb8733a7573189c8b35148" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Hermite polynomial basis set. Thus, to express the product as a Hermite series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">一般に、2つのCシリーズの（多項式）積は、エルミート多項式基底関数セットにない項で結果として生成されます。したがって、製品をHermiteシリーズとして表現するには、製品を前述の基底関数セットに「再投影」する必要があります。これにより、「直感的でない」（しかし正しい）結果が生成される可能性があります。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="4be0c1b381e26e882c60023195f1e89d336414ac" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Laguerre polynomial basis set. Thus, to express the product as a Laguerre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">一般的に、2つのCシリーズの（多項式）積は、ラゲール多項式基底関数セットにない項で結果を出します。したがって、製品をラゲールシリーズとして表現するには、製品を上記のベーシスセットに「再投影」する必要があります。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="54659a570a760a1d9fe356eba1a0141427eabe1f" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Legendre polynomial basis set. Thus, to express the product as a Legendre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">一般に、2つのCシリーズの（多項式）積は、ルジャンドル多項式基底関数セットにない条件で結果として生成されます。したがって、製品をルジャンドルシリーズとして表現するには、製品を上記のベーシスセットに「再投影」する必要があります。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="afe18211391947a00635543978b5840ef054bbac" translate="yes" xml:space="preserve">
          <source>In general, the contents of signature files is case-sensitive. When scanning Fortran codes and writing a signature file, F2PY lowers all cases automatically except in multiline blocks or when &lt;code&gt;--no-lower&lt;/code&gt; option is used.</source>
          <target state="translated">一般に、署名ファイルの内容では大文字と小文字が区別されます。Fortranコードをスキャンして署名ファイルを書き込む場合、F2PYは、複数行ブロックの場合、または &lt;code&gt;--no-lower&lt;/code&gt; オプションが使用されている場合を除いて、すべてのケースを自動的に下げます。</target>
        </trans-unit>
        <trans-unit id="de938489906c2e0d2c954a8201ef415c1aa719ca" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a C-series needs to be &amp;ldquo;reprojected&amp;rdquo; onto the C-series basis set. Thus, typically, the result of this function is &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">一般に、Cシリーズを区別した結果は、Cシリーズの基底セットに「再投影」する必要があります。したがって、通常、この関数の結果は正しいとはいえ、「直感的ではありません」。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="dc47191395ffa64cfa2441fe3b165eeaca46d090" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Hermite series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">一般に、エルミートシリーズを微分した結果は、べき級数での同じ演算に似ていません。したがって、この関数の結果は、正しいとはいえ、「直感的でない」ことがあります。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="c6b49ce2210116245bad6e5bb6d187bba65b38de" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Laguerre series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">一般に、ラゲール級数を微分した結果は、べき級数での同じ演算に似ていません。したがって、この関数の結果は、正しいとはいえ、「直感的でない」ことがあります。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="68d490300c846fea9862fc337043383e53cf549a" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Legendre series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">一般に、ルジャンドル系列を微分した結果は、べき級数での同じ演算に似ていません。したがって、この関数の結果は、正しいとはいえ、「直感的でない」ことがあります。以下の例のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="ebd1b8db4b2a00ae669c478fea3d4050ecbe0184" translate="yes" xml:space="preserve">
          <source>In general, the shape of the resultant array will be the concatenation of the shape of the index array (or the shape that all the index arrays were broadcast to) with the shape of any unused dimensions (those not indexed) in the array being indexed.</source>
          <target state="translated">一般的に,結果として得られる配列の形状は,インデックス配列の形状(または,すべてのインデックス配列がブロードキャストされた形状)と,インデックス化される配列内の未使用の次元(インデックス化されていない次元)の形状を連結したものになります.</target>
        </trans-unit>
        <trans-unit id="a88de0d014385ccfe1e16b471b5821f10438fddf" translate="yes" xml:space="preserve">
          <source>In general, we follow the &lt;a href=&quot;https://developers.google.com/style&quot;&gt;Google developer documentation style guide&lt;/a&gt;.</source>
          <target state="translated">通常、&lt;a href=&quot;https://developers.google.com/style&quot;&gt;Googleデベロッパードキュメントのスタイルガイドに&lt;/a&gt;従います。</target>
        </trans-unit>
        <trans-unit id="f5de4ef25adb6cfc3610a2fc23a9d5023b6dda95" translate="yes" xml:space="preserve">
          <source>In general, when the boolean array has fewer dimensions than the array being indexed, this is equivalent to y[b, &amp;hellip;], which means y is indexed by b followed by as many : as are needed to fill out the rank of y. Thus the shape of the result is one dimension containing the number of True elements of the boolean array, followed by the remaining dimensions of the array being indexed.</source>
          <target state="translated">一般に、ブール配列の次元がインデックス付けされる配列よりも少ない場合、これはy [b、&amp;hellip;]と同等です。つまり、yはbの後に、yのランクを入力するために必要な数の：が続くインデックスになります。したがって、結果の形状は、ブール配列のTrue要素の数を含む1つの次元であり、その後にインデックスが付けられる配列の残りの次元が続きます。</target>
        </trans-unit>
        <trans-unit id="a094c205647147c910d02f3a8f4ccd59ee07b5bd" translate="yes" xml:space="preserve">
          <source>In general, you should target these typemap signatures specifically where you want them, and then clear them after you are done.</source>
          <target state="translated">一般的には、これらのタイプマップ署名は必要な場所にターゲットを絞って、それが終わったらクリアしてください。</target>
        </trans-unit>
        <trans-unit id="dd3e08bc1a57887f18c581f1dbde91b2bd716911" translate="yes" xml:space="preserve">
          <source>In higher dimensions, FFTs are used, e.g., for image analysis and filtering. The computational efficiency of the FFT means that it can also be a faster way to compute large convolutions, using the property that a convolution in the time domain is equivalent to a point-by-point multiplication in the frequency domain.</source>
          <target state="translated">高次元では,画像解析やフィルタリングなどにFFTが使用されます.FFTの計算効率は、時間領域での畳み込みが周波数領域でのポイントバイポイントの乗算と等価であるという特性を利用して、大規模な畳み込みを高速に計算できることを意味します。</target>
        </trans-unit>
        <trans-unit id="712c1e0b0bab41b8c1ae0fb7e5f87af642c68f33" translate="yes" xml:space="preserve">
          <source>In higher dimensions, the picture changes. NumPy prints higher-dimensional vectors as replications of row-by-column building blocks, as in this three-dimensional vector:</source>
          <target state="translated">高次元になると、絵が変わります。NumPyは、この3次元ベクトルのように、高次元のベクトルを行ごと列ごとのビルディングブロックの複製として印刷します。</target>
        </trans-unit>
        <trans-unit id="b07ddb1ceb7095c96bdb1f519b0d36703eda5462" translate="yes" xml:space="preserve">
          <source>In interactions between &lt;code&gt;ArrayLike&lt;/code&gt; objects and numbers or numpy arrays, the result is always another &lt;code&gt;ArrayLike&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ArrayLike&lt;/code&gt; オブジェクトと数値またはnumpy配列の間の相互作用では、結果は常に別の &lt;code&gt;ArrayLike&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="859968bca8846c38eabf846201d96ee61f1cb6f0" translate="yes" xml:space="preserve">
          <source>In linear space, the sequence starts at &lt;code&gt;base ** start&lt;/code&gt; (&lt;code&gt;base&lt;/code&gt; to the power of &lt;code&gt;start&lt;/code&gt;) and ends with &lt;code&gt;base ** stop&lt;/code&gt; (see &lt;code&gt;endpoint&lt;/code&gt; below).</source>
          <target state="translated">線形空間において、該シーケンスが開始 &lt;code&gt;base ** start&lt;/code&gt; （ &lt;code&gt;base&lt;/code&gt; のパワーに &lt;code&gt;start&lt;/code&gt; ）で終わる &lt;code&gt;base ** stop&lt;/code&gt; （参照 &lt;code&gt;endpoint&lt;/code&gt; 以下）を。</target>
        </trans-unit>
        <trans-unit id="e8987c188d2dc12518e96e9c96bc6fb94bc0c364" translate="yes" xml:space="preserve">
          <source>In many circumstances, datasets can be incomplete or tainted by the presence of invalid data. For example, a sensor may have failed to record a data, or recorded an invalid value. The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module provides a convenient way to address this issue, by introducing masked arrays.</source>
          <target state="translated">多くの状況で、無効なデータの存在によってデータセットが不完全になったり汚染されたりする可能性があります。たとえば、センサーがデータの記録に失敗したか、無効な値を記録した可能性があります。&lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; の&lt;/a&gt;モジュールは、マスクされた配列を導入することで、この問題に対処するための便利な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="af19adb5953933b119cf6e38053a7bd63ddf0076" translate="yes" xml:space="preserve">
          <source>In memory overlap checks, assume that operands with &lt;code&gt;NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE&lt;/code&gt; enabled are accessed only in the iterator order.</source>
          <target state="translated">メモリのオーバーラップチェックでは、 &lt;code&gt;NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE&lt;/code&gt; が有効になっているオペランドは、イテレータの順序でのみアクセスされると想定しています。</target>
        </trans-unit>
        <trans-unit id="bd53b438575f194778c1656e57b318d6b487ca6a" translate="yes" xml:space="preserve">
          <source>In more detail</source>
          <target state="translated">より詳細には</target>
        </trans-unit>
        <trans-unit id="f9e0501d6a0c7c31ee0e8c5ea3ca4747d4c70398" translate="yes" xml:space="preserve">
          <source>In most cases &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; should be used instead of this function, as that will also return true for 0d arrays. This is how numpy overloads functions in the style of the &lt;code&gt;dx&lt;/code&gt; arguments to &lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt;&lt;code&gt;gradient&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;bins&lt;/code&gt; argument to &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;. Some key differences:</source>
          <target state="translated">ほとんどの場合、この関数の代わりに &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; を使用する必要があります。これは、0d配列に対してもtrueを返すためです。これは、のスタイルでどのようにnumpyのオーバーロード機能である &lt;code&gt;dx&lt;/code&gt; の引数&lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt; &lt;code&gt;gradient&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;bins&lt;/code&gt; の引数&lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt;。いくつかの重要な違い：</target>
        </trans-unit>
        <trans-unit id="a5c743fe265d56156ca24d5e10903518aede0334" translate="yes" xml:space="preserve">
          <source>In most use cases the best way to install NumPy on your system is by using a pre-built package for your operating system. Please see &lt;a href=&quot;https://scipy.org/install.html&quot;&gt;https://scipy.org/install.html&lt;/a&gt; for links to available options.</source>
          <target state="translated">ほとんどのユースケースでは、システムにNumPyをインストールする最良の方法は、オペレーティングシステム用にビルド済みのパッケージを使用することです。利用可能なオプションへのリンクについては、&lt;a href=&quot;https://scipy.org/install.html&quot;&gt;https：//scipy.org/install.html&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="763b6e76c1532989efe227d788422ad02bd06f94" translate="yes" xml:space="preserve">
          <source>In normal buffering, the size of each inner loop is equal to the buffer size, or possibly larger if &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt; is specified. If &lt;a href=&quot;#c.NPY_ITER_REDUCE_OK&quot;&gt;&lt;code&gt;NPY_ITER_REDUCE_OK&lt;/code&gt;&lt;/a&gt; is enabled and a reduction occurs, the inner loops may become smaller depending on the structure of the reduction.</source>
          <target state="translated">通常のバッファリングでは、各内部ループのサイズはバッファサイズと同じか、&lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt;が指定されている場合はさらに大きくなります。場合&lt;a href=&quot;#c.NPY_ITER_REDUCE_OK&quot;&gt; &lt;code&gt;NPY_ITER_REDUCE_OK&lt;/code&gt; が&lt;/a&gt;有効になっており、還元が生じ、内部ループは還元の構造に応じて小さくなることがあります。</target>
        </trans-unit>
        <trans-unit id="2c60bcd4aa111fe243ec4d9e38a39cdb9410fc32" translate="yes" xml:space="preserve">
          <source>In numpy versions &amp;gt;= 1.7.0 the &lt;code&gt;basis&lt;/code&gt; and &lt;code&gt;cast&lt;/code&gt; class methods are also available. The cast method works like the convert method while the basis method returns the basis polynomial of given degree:</source>
          <target state="translated">numpyバージョン&amp;gt; = 1.7.0では、 &lt;code&gt;basis&lt;/code&gt; および &lt;code&gt;cast&lt;/code&gt; クラスメソッドも使用できます。castメソッドはconvertメソッドのように機能しますが、basisメソッドは指定された次数の基底多項式を返します。</target>
        </trans-unit>
        <trans-unit id="9a36a11020261b9ce301df38d29f32b272d351ef" translate="yes" xml:space="preserve">
          <source>In order to add a Python package to SciPy, its build script (&lt;code&gt;setup.py&lt;/code&gt;) must meet certain requirements. The most important requirement is that the package define a &lt;code&gt;configuration(parent_package='',top_path=None)&lt;/code&gt; function which returns a dictionary suitable for passing to &lt;code&gt;numpy.distutils.core.setup(..)&lt;/code&gt;. To simplify the construction of this dictionary, &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; provides the &lt;code&gt;Configuration&lt;/code&gt; class, described below.</source>
          <target state="translated">PythonパッケージをSciPyに追加するには、そのビルドスクリプト（ &lt;code&gt;setup.py&lt;/code&gt; ）が特定の要件を満たしている必要があります。最も重要な要件は、パッケージが &lt;code&gt;numpy.distutils.core.setup(..)&lt;/code&gt; に渡すのに適した辞書を返す &lt;code&gt;configuration(parent_package='',top_path=None)&lt;/code&gt; 関数を定義することです。このディクショナリの構築を簡略化するために、 &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; には、以下に説明する &lt;code&gt;Configuration&lt;/code&gt; クラスが用意されています。</target>
        </trans-unit>
        <trans-unit id="9195216b823d914ae553da6509b9641a3f8c45ff" translate="yes" xml:space="preserve">
          <source>In order to extract information from a given matrix, we can use the SVD to obtain 3 arrays which can be multiplied to obtain the original matrix. From the theory of linear algebra, given a matrix</source>
          <target state="translated">与えられた行列から情報を抽出するために、SVDを用いて、乗算して元の行列を得ることができる3つの配列を得ることができる。線形代数の理論から,与えられた行列</target>
        </trans-unit>
        <trans-unit id="60fc69a196f8bf024afb0ed60ca3a78c46194201" translate="yes" xml:space="preserve">
          <source>In order to improve the interface, directives should be provided. This is accomplished by constructing an interface definition file. It is usually best to start from the interface file that f2py can produce (where it gets its default behavior from). To get f2py to generate the interface file use the -h option:</source>
          <target state="translated">インターフェースを改善するために、ディレクティブを提供する必要があります。これは、インターフェース定義ファイルを構築することで達成されます。通常、f2pyが生成できるインターフェースファイル(デフォルトの動作を取得する場所)から始めるのがベストです。f2pyがインターフェースファイルを生成するためには、-hオプションを使用します。</target>
        </trans-unit>
        <trans-unit id="d5eaeb15f58484d8774fc878d68cb55c966f0844" translate="yes" xml:space="preserve">
          <source>In order to make use of the C-API from another extension module, the &lt;a href=&quot;#c.import_array&quot;&gt;&lt;code&gt;import_array&lt;/code&gt;&lt;/a&gt; function must be called. If the extension module is self-contained in a single .c file, then that is all that needs to be done. If, however, the extension module involves multiple files where the C-API is needed then some additional steps must be taken.</source>
          <target state="translated">別の拡張モジュールからC-APIを利用するには、&lt;a href=&quot;#c.import_array&quot;&gt; &lt;code&gt;import_array&lt;/code&gt; &lt;/a&gt;関数を呼び出す必要があります。拡張モジュールが単一の.cファイルに自己完結している場合、実行する必要があるのはそれだけです。ただし、拡張モジュールにC-APIが必要な複数のファイルが含まれている場合は、いくつかの追加手順を実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="c34adc34291107e6d105c5cd2a716fc5c0f9914c" translate="yes" xml:space="preserve">
          <source>In order to pay-off (i.e., have a future-value of 0) the $200,000 obtained today, a monthly payment of $1,854.02 would be required. Note that this example illustrates usage of &lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt;&lt;code&gt;fv&lt;/code&gt;&lt;/a&gt; having a default value of 0.</source>
          <target state="translated">今日得られた200,000ドルを支払う（つまり、future値が0である）には、月額1,854.02ドルの支払いが必要になります。この例では、デフォルト値が0の&lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt; &lt;code&gt;fv&lt;/code&gt; の&lt;/a&gt;使用法を示しています。</target>
        </trans-unit>
        <trans-unit id="c095a095337ad13b3d70a4b6ebd36dbc52f1334a" translate="yes" xml:space="preserve">
          <source>In order to prevent clobbering object pointers in fields of &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; type, numpy currently does not allow views of structured arrays containing objects.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt;タイプのフィールドでオブジェクトポインタが壊れるのを防ぐために、numpyは現在、オブジェクトを含む構造化配列のビューを許可していません。</target>
        </trans-unit>
        <trans-unit id="5f37a6feac047af18be703227c7a9f994a3a9fcc" translate="yes" xml:space="preserve">
          <source>In order to prevent clobbering object pointers in fields of &lt;code&gt;numpy.object&lt;/code&gt; type, numpy currently does not allow views of structured arrays containing objects.</source>
          <target state="translated">&lt;code&gt;numpy.object&lt;/code&gt; タイプのフィールドでオブジェクトポインタが壊れるのを防ぐために、numpyは現在、オブジェクトを含む構造化配列のビューを許可していません。</target>
        </trans-unit>
        <trans-unit id="1b7199a5c1d305f9cc30b6b7f154cecb0f39e6d3" translate="yes" xml:space="preserve">
          <source>In order to remove elements from an array, it&amp;rsquo;s simple to use indexing to select the elements that you want to keep.</source>
          <target state="translated">配列から要素を削除するには、インデックスを使用して、保持する要素を選択するのが簡単です。</target>
        </trans-unit>
        <trans-unit id="b465797b5de029b2baabd94edf6595fe5ee0db1d" translate="yes" xml:space="preserve">
          <source>In order to start using NumPy and all of the functions available in NumPy, you&amp;rsquo;ll need to import it. This can be easily done with this import statement:</source>
          <target state="translated">NumPyとNumPyで利用可能なすべての機能の使用を開始するには、それをインポートする必要があります。これは、次のインポートステートメントで簡単に実行できます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
