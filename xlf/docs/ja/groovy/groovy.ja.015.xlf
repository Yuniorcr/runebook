<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="groovy">
    <body>
      <group id="groovy">
        <trans-unit id="4e8a758e14e042fd44d1644b7c03d56755c84835" translate="yes" xml:space="preserve">
          <source>Subclasses should implement this method to provide good error resolution.</source>
          <target state="translated">サブクラスは、良好なエラー解決を提供するために、このメソッドを実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="48a548d0b5d2d73bb19fdf6f69c4cddfc9e8f4c9" translate="yes" xml:space="preserve">
          <source>Subclasses should implement this method to set the condition of the interruption statement</source>
          <target state="translated">サブクラスはこのメソッドを実装して割り込み文の条件を設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="32ab562220ed81620ccefa3948d1a774f1feaa20" translate="yes" xml:space="preserve">
          <source>Subclasses should implement this method whenever they need to perform special checks before the type checker starts working.</source>
          <target state="translated">サブクラスは、型チェッカーが動作を開始する前に特別なチェックを行う必要がある場合には、このメソッドを実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="c68b5b9b049084fab1d00a3f47d9b682f70fb6da" translate="yes" xml:space="preserve">
          <source>Subclasses should implement this method, which returns the list of accepted closure signatures.</source>
          <target state="translated">サブクラスはこのメソッドを実装しなければなりません。</target>
        </trans-unit>
        <trans-unit id="fa849d16a1883f2b020174ca4e3bb9a8a963f828" translate="yes" xml:space="preserve">
          <source>Subtract a Character from a Number.</source>
          <target state="translated">数字から文字を引き算します。</target>
        </trans-unit>
        <trans-unit id="7d501390aa64bdf2c9ae78827d17293277d1d079" translate="yes" xml:space="preserve">
          <source>Subtract a Character from a Number. The ordinal value of the Character is used in the subtraction (the ordinal value is the unicode value which for simple character sets is the ASCII value).</source>
          <target state="translated">数字から文字を引き算します。文字の序数値が減算に使用されます(序数値はユニコード値で、単純な文字セットの場合はASCII値です)。</target>
        </trans-unit>
        <trans-unit id="80739b5b536f0252ee4bb49d1cf80dec2291730b" translate="yes" xml:space="preserve">
          <source>Subtract a Number from a Character.</source>
          <target state="translated">文字から数字を引き算します。</target>
        </trans-unit>
        <trans-unit id="2829709b208cdecbc2effaee1c43f216d0c4a2cd" translate="yes" xml:space="preserve">
          <source>Subtract a Number from a Character. The ordinal value of the Character is used in the subtraction (the ordinal value is the unicode value which for simple character sets is the ASCII value).</source>
          <target state="translated">文字から数字を引き算します。文字の序数値が減算に使用されます (序数値はユニコード値で、単純な文字セットの場合はASCII値です)。</target>
        </trans-unit>
        <trans-unit id="383c4da009f675500b7dc7ae0296938c1e09b8bf" translate="yes" xml:space="preserve">
          <source>Subtract a number of days from this Timestamp and returns the new Timestamp object.</source>
          <target state="translated">このTimestampから日数を引き算し、新しいTimestampオブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="73d746887164b2f5e92e086f6b38e7a5028ad395" translate="yes" xml:space="preserve">
          <source>Subtract a number of days from this date and returns the new date.</source>
          <target state="translated">この日付から日数を引いて、新しい日付を返します。</target>
        </trans-unit>
        <trans-unit id="d1b908a2b53a9eda97aea98291d46913fec1a195" translate="yes" xml:space="preserve">
          <source>Subtract another Date from this one and return the number of days of the difference.</source>
          <target state="translated">この日付から別の日付を引いて、その差の日数を返します。</target>
        </trans-unit>
        <trans-unit id="90df6944beb186ade6e01024eae5a9be3b4868ce" translate="yes" xml:space="preserve">
          <source>Subtract another date from this one and return the number of days of the difference.</source>
          <target state="translated">この日付から別の日付を引いて、その差額の日数を返します。</target>
        </trans-unit>
        <trans-unit id="b1d58f1e1cf47da6c54dce03b400e8ead47438d0" translate="yes" xml:space="preserve">
          <source>Subtract one Character from another.</source>
          <target state="translated">1つの文字から別の文字を引き算します。</target>
        </trans-unit>
        <trans-unit id="670e4318f1084845e7f32b29745478fef01a079c" translate="yes" xml:space="preserve">
          <source>Subtract one Character from another. The ordinal values of the Characters is used in the comparison (the ordinal value is the unicode value which for simple character sets is the ASCII value).</source>
          <target state="translated">ある文字を別の文字から引き算します。比較には文字の序数値が使用されます(序数値はユニコード値で、単純な文字セットの場合はASCII値となります)。</target>
        </trans-unit>
        <trans-unit id="8458189362e1f0efadb179882bea2588a89dea40" translate="yes" xml:space="preserve">
          <source>Subtract one date from the other.</source>
          <target state="translated">片方の日付からもう片方の日付を引き算します。</target>
        </trans-unit>
        <trans-unit id="703b3f4be66eeba14f12112eb0178f45c56b038b" translate="yes" xml:space="preserve">
          <source>Subtraction of two Numbers.</source>
          <target state="translated">2つの数字の引き算。</target>
        </trans-unit>
        <trans-unit id="ea77f38e191237c8467b9bbbbfa7a3c905eb071f" translate="yes" xml:space="preserve">
          <source>Successful retrievals using get(key) and containsKey(key) usually run without locking. Unsuccessful ones (i.e., when the key is not present) do involve brief synchronization (locking). Also, the size and isEmpty methods are always synchronized.</source>
          <target state="translated">get(key)とcontainsKey(key)を使用した検索が成功した場合、通常はロックなしで実行されます。成功しなかった場合 (つまり、キーが存在しない場合)は、短時間の同期 (ロック)を必要とします。また、sizeメソッドとisEmptyメソッドは常に同期化されています。</target>
        </trans-unit>
        <trans-unit id="31de501c849ff7913e8233a72f933ee4b40759b9" translate="yes" xml:space="preserve">
          <source>Sums all the given items.</source>
          <target state="translated">与えられたすべての項目を合計します。</target>
        </trans-unit>
        <trans-unit id="a6906f65d4bdfb623c3779437b880666d674473e" translate="yes" xml:space="preserve">
          <source>Sums all the items from an array of items.</source>
          <target state="translated">項目の配列からすべての項目を合計します。</target>
        </trans-unit>
        <trans-unit id="4b759da08d81e2982b18ab18cfecdb92173bfcad" translate="yes" xml:space="preserve">
          <source>Sums the items from an Iterator, adding the result to some initial value.</source>
          <target state="translated">イテレータの項目を合計し、その結果を何らかの初期値に加算します。</target>
        </trans-unit>
        <trans-unit id="3292936c4cef8a406dd185feb7f5e9f5ad4bb035" translate="yes" xml:space="preserve">
          <source>Sums the items from an Iterator, adding the result to some initial value. This is equivalent to invoking the &quot;plus&quot; method on all items from the Iterator. The iterator will become exhausted of elements after determining the sum value.</source>
          <target state="translated">Iterator の項目を合計し、その結果を何らかの初期値に加算します。これは、イテレータのすべての項目に対して &quot;plus&quot; メソッドを呼び出すことと同等です。イテレータは、合計値を決定した後に要素を使い果たしてしまいます。</target>
        </trans-unit>
        <trans-unit id="44a8d4cb71f1a9055409cd78474fa859d6e1b627" translate="yes" xml:space="preserve">
          <source>Sums the items from an Iterator.</source>
          <target state="translated">イテレータの項目を合計します。</target>
        </trans-unit>
        <trans-unit id="7b0828ab8c0d5a6291096701a8058ed787770aa4" translate="yes" xml:space="preserve">
          <source>Sums the items from an Iterator. This is equivalent to invoking the &quot;plus&quot; method on all items from the Iterator. The iterator will become exhausted of elements after determining the sum value.</source>
          <target state="translated">Iterator の項目を合計します。これは、イテレータからのすべての項目に対して &quot;plus&quot; メソッドを呼び出すことと同等です。イテレータは、合計値を決定した後に要素を使い果たしてしまいます。</target>
        </trans-unit>
        <trans-unit id="0f21ed49c9b3729a874e6b6213a3aec5f55f4984" translate="yes" xml:space="preserve">
          <source>Sums the items in an Iterable, adding the result to some initial value.</source>
          <target state="translated">イテレータブル内の項目を合計し、その結果を何らかの初期値に加算します。</target>
        </trans-unit>
        <trans-unit id="938cc031c32a0a74fedcea0fa2ea03bca7774e36" translate="yes" xml:space="preserve">
          <source>Sums the items in an Iterable.</source>
          <target state="translated">イテレータブル内の項目を合計します。</target>
        </trans-unit>
        <trans-unit id="05846c3dab4dc24635cdc7e83333eed6761385f2" translate="yes" xml:space="preserve">
          <source>Sums the items in an Iterable. This is equivalent to invoking the &quot;plus&quot; method on all items in the Iterable.</source>
          <target state="translated">イタブル内の項目を合計します。これは、イタブル内のすべての項目に対して &quot;プラス &quot;メソッドを呼び出すことと同等です。</target>
        </trans-unit>
        <trans-unit id="5f97a9c084454b475824ce176a76670de5bc0260" translate="yes" xml:space="preserve">
          <source>Sums the items in an array, adding the result to some initial value.</source>
          <target state="translated">配列内の項目を合計し、その結果を初期値に加算します。</target>
        </trans-unit>
        <trans-unit id="8e6bc758df7e10d60725d5fd562f4cb6320501f3" translate="yes" xml:space="preserve">
          <source>Sums the items in an array.</source>
          <target state="translated">配列内の項目を合計します。</target>
        </trans-unit>
        <trans-unit id="f12f8dae3d9539e78ab7a3595c0ec92646ea4e58" translate="yes" xml:space="preserve">
          <source>Sums the items in an array. This is equivalent to invoking the &quot;plus&quot; method on all items in the array.</source>
          <target state="translated">配列内の項目を合計します。これは、配列内のすべての項目に対して &quot;plus&quot; メソッドを呼び出すことと同等です。</target>
        </trans-unit>
        <trans-unit id="ef7fec05c6f7a205563842bf6c760293ede2e021" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterable to some initial value.</source>
          <target state="translated">Iterableの各項目にクロージャを適用した結果をいくつかの初期値に合計します。</target>
        </trans-unit>
        <trans-unit id="2c34756e7df8dbbbdc5ad7ddd3d79525b4cabde0" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterable to some initial value. &lt;code&gt;iter.sum(initVal, closure)&lt;/code&gt; is equivalent to: &lt;code&gt;iter.collect(closure).sum(initVal)&lt;/code&gt;.</source>
          <target state="translated">Iterableの各アイテムにクロージャを適用した結果を初期値に合計します。 &lt;code&gt;iter.sum(initVal, closure)&lt;/code&gt; は、 &lt;code&gt;iter.collect(closure).sum(initVal)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="a22f8d5b1e322146f614b91be417a32eb8dcd5b5" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterable.</source>
          <target state="translated">Iterableの各項目にクロージャを適用した結果を合計します。</target>
        </trans-unit>
        <trans-unit id="a9cded5e8db4a11cbc31f73eebe70a9d23e9f6e6" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterable. &lt;code&gt;coll.sum(closure)&lt;/code&gt; is equivalent to: &lt;code&gt;coll.collect(closure).sum()&lt;/code&gt;.</source>
          <target state="translated">Iterableの各アイテムにクロージャを適用した結果を合計します。 &lt;code&gt;coll.sum(closure)&lt;/code&gt; と同等です： &lt;code&gt;coll.collect(closure).sum()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2d6eeefd666db6fd3abb4f06450eaebc3703a21" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterator to some initial value.</source>
          <target state="translated">Iterator の各項目にクロージャを適用した結果を何らかの初期値に合計します。</target>
        </trans-unit>
        <trans-unit id="138bf57a714ba157c5f8f2140c7144fec48bbd4d" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterator to some initial value. &lt;code&gt;iter.sum(initVal, closure)&lt;/code&gt; is equivalent to: &lt;code&gt;iter.collect(closure).sum(initVal)&lt;/code&gt;. The iterator will become exhausted of elements after determining the sum value.</source>
          <target state="translated">イテレータの各アイテムにクロージャを適用した結果を、ある初期値に合計します。 &lt;code&gt;iter.sum(initVal, closure)&lt;/code&gt; は、 &lt;code&gt;iter.collect(closure).sum(initVal)&lt;/code&gt; と同等です。合計値を決定した後、イテレータは要素を使い果たします。</target>
        </trans-unit>
        <trans-unit id="c0cb69a7faef35e6438266153f8981b96cdb6d92" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an array to some initial value.</source>
          <target state="translated">配列の各項目にクロージャを適用した結果をいくつかの初期値に合計します。</target>
        </trans-unit>
        <trans-unit id="45852392f7090c69aedbeec4ac994c8caed08176" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an array to some initial value. &lt;code&gt;array.sum(initVal, closure)&lt;/code&gt; is equivalent to: &lt;code&gt;array.collect(closure).sum(initVal)&lt;/code&gt;.</source>
          <target state="translated">配列の各項目にクロージャを適用した結果を、ある初期値に合計します。 &lt;code&gt;array.sum(initVal, closure)&lt;/code&gt; は、 &lt;code&gt;array.collect(closure).sum(initVal)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="46427b8197456a69d06f32a8b3afb429409c9174" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an array.</source>
          <target state="translated">配列の各項目にクロージャを適用した結果を合計します。</target>
        </trans-unit>
        <trans-unit id="b46103f8e5006bdeea7f9c154e982c8ee536abd8" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an array. &lt;code&gt;array.sum(closure)&lt;/code&gt; is equivalent to: &lt;code&gt;array.collect(closure).sum()&lt;/code&gt;.</source>
          <target state="translated">配列の各項目にクロージャを適用した結果を合計します。 &lt;code&gt;array.sum(closure)&lt;/code&gt; ：と同等です &lt;code&gt;array.collect(closure).sum()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dac66fb8810c157cd97e770e86c48d44f88a2152" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item returned from an iterator.</source>
          <target state="translated">イテレータから返された各項目にクロージャを適用した結果を合計します。</target>
        </trans-unit>
        <trans-unit id="377052f5b33eac246887eb27e6c100d565eca611" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item returned from an iterator. &lt;code&gt;iter.sum(closure)&lt;/code&gt; is equivalent to: &lt;code&gt;iter.collect(closure).sum()&lt;/code&gt;. The iterator will become exhausted of elements after determining the sum value.</source>
          <target state="translated">イテレータから返された各アイテムにクロージャを適用した結果を合計します。 &lt;code&gt;iter.sum(closure)&lt;/code&gt; と同等です： &lt;code&gt;iter.collect(closure).sum()&lt;/code&gt; 。合計値を決定した後、イテレータは要素を使い果たします。</target>
        </trans-unit>
        <trans-unit id="998c35057b1e937535f109c7111919f1f21ea66a" translate="yes" xml:space="preserve">
          <source>Support a 'least surprising' math model to scripting language users. This means that exact, or decimal math should be used for default calculations. This scheme assumes that by default, groovy literals with decimal points are instantiated as BigDecimal objects rather than binary floating points (Float, Double).</source>
          <target state="translated">スクリプト言語のユーザが驚くことのない数学モデルをサポートします。これは、デフォルトの計算には正確な、あるいは10進数の数学が使用されるべきであることを意味します。このスキームは、デフォルトでは、小数点を持つ groovy リテラルは、バイナリ浮動小数点 (Float,Double)ではなく、BigDecimal オブジェクトとしてインスタンス化されることを前提としています。</target>
        </trans-unit>
        <trans-unit id="300e75d2f3f2ad069bf75f6db0f8b032d657028b" translate="yes" xml:space="preserve">
          <source>Support assigning a range of values with a single assignment statement.</source>
          <target state="translated">単一の代入文での値の範囲の代入をサポートします。</target>
        </trans-unit>
        <trans-unit id="eb0573add916ac521520ae7e1a7edb406cc686a3" translate="yes" xml:space="preserve">
          <source>Support class for creating XML Factories</source>
          <target state="translated">XML ファクトリーを作成するためのサポートクラス</target>
        </trans-unit>
        <trans-unit id="a0ac0e736b440225051252fb545f21a87af58be3" translate="yes" xml:space="preserve">
          <source>Support creating a new Date having similar properties to an existing Date (which remains unaltered) but with some fields updated according to a Map of changes.</source>
          <target state="translated">既存の日付(変更されていないままの日付)と同様のプロパティを持つ新しい日付の作成をサポートしますが、いくつかのフィールドは変更のマップに従って更新されます。</target>
        </trans-unit>
        <trans-unit id="578fcb6595097c58dd9c3c70598121040321a782" translate="yes" xml:space="preserve">
          <source>Support for &lt;a href=&quot;command&quot;&gt;Command&lt;/a&gt; instances.</source>
          <target state="translated">&lt;a href=&quot;command&quot;&gt;コマンド&lt;/a&gt;インスタンスのサポート。</target>
        </trans-unit>
        <trans-unit id="27e429f7d79185fd5fa7dcfde4e209338be3fe84" translate="yes" xml:space="preserve">
          <source>Support for Closure &quot;right&quot; currying.</source>
          <target state="translated">クロージャー &quot;右 &quot;カレーに対応。</target>
        </trans-unit>
        <trans-unit id="bd9aff9c96085971df147f0319c92592cb9998b5" translate="yes" xml:space="preserve">
          <source>Support for Closure &quot;right&quot; currying. Parameters are supplied on the right rather than left as per the normal curry() method. Typical usage:</source>
          <target state="translated">クロージャーの &quot;右 &quot;カレーリングをサポートしています。パラメータは、通常の curry()メソッドのように左ではなく右で与えられます。典型的な使用法です。</target>
        </trans-unit>
        <trans-unit id="07d27c73edc627e408cf52788f3cd8c2cee9798e" translate="yes" xml:space="preserve">
          <source>Support for Closure currying at a given index.</source>
          <target state="translated">所定のインデックスでクロージャーカレーをサポート。</target>
        </trans-unit>
        <trans-unit id="77c240308ae9d403e4fdeb9fade24bf133f052c6" translate="yes" xml:space="preserve">
          <source>Support for Closure currying at a given index. Parameters are supplied from index position &quot;n&quot;. Typical usage:</source>
          <target state="translated">指定されたインデックスでのクロージャーカーリングをサポートします。パラメータはインデックス位置 &quot;n &quot;から与えられます。典型的な使用法。</target>
        </trans-unit>
        <trans-unit id="86fbafb2c6a6ef08ae544def5ecd2f5d1a459fde" translate="yes" xml:space="preserve">
          <source>Support for Closure currying.</source>
          <target state="translated">クロージャーカレーに対応しています。</target>
        </trans-unit>
        <trans-unit id="b6701c883c98ccd374b2032b56f3cdf62e6bdcb1" translate="yes" xml:space="preserve">
          <source>Support for Closure forward composition.</source>
          <target state="translated">クロージャーフォワードの構成をサポートします。</target>
        </trans-unit>
        <trans-unit id="95c9b5d31f5a9af4bcb77590911799ff25e785f9" translate="yes" xml:space="preserve">
          <source>Support for Closure reverse composition.</source>
          <target state="translated">クロージャーリバース構成に対応。</target>
        </trans-unit>
        <trans-unit id="0cd464c7aa84c67ca4cf28f95af944bd7e5c8ae1" translate="yes" xml:space="preserve">
          <source>Support for Groovlets which are Servlets written as a simple Groovy script.</source>
          <target state="translated">シンプルなGroovyスクリプトとして書かれたサーブレットであるGroovletをサポート。</target>
        </trans-unit>
        <trans-unit id="971f277b26127bb2b96f438a43258b36036a9c6e" translate="yes" xml:space="preserve">
          <source>Support for compilation related tasks.</source>
          <target state="translated">コンパイル関連業務のサポート。</target>
        </trans-unit>
        <trans-unit id="2712721bdf08058a3c0b6d90d89d52194d9c6991" translate="yes" xml:space="preserve">
          <source>Support for more complex commands.</source>
          <target state="translated">より複雑なコマンドのサポート。</target>
        </trans-unit>
        <trans-unit id="c398c8c180a493660e7da708b15d770393473fcc" translate="yes" xml:space="preserve">
          <source>Support for running a &lt;a href=&quot;shell&quot;&gt;Shell&lt;/a&gt; interactively using the JLine library.</source>
          <target state="translated">JLineライブラリを使用して&lt;a href=&quot;shell&quot;&gt;シェルを&lt;/a&gt;インタラクティブに実行するためのサポート。</target>
        </trans-unit>
        <trans-unit id="e7bd721822c04eca7566037be0ea0c447ce0bb1f" translate="yes" xml:space="preserve">
          <source>Support for running a &lt;a href=&quot;shell&quot;&gt;Shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;shell&quot;&gt;シェルの&lt;/a&gt;実行のサポート。</target>
        </trans-unit>
        <trans-unit id="e838211f110950da21190e2b4cd394331c2cfaad" translate="yes" xml:space="preserve">
          <source>Support for simple completers.</source>
          <target state="translated">シンプルな補完機能をサポートしています。</target>
        </trans-unit>
        <trans-unit id="b1847ef28b474109bae86b9ff6f88f30c6d1cb1e" translate="yes" xml:space="preserve">
          <source>Support for simple completors.</source>
          <target state="translated">シンプルな補完者をサポートしています。</target>
        </trans-unit>
        <trans-unit id="a4cd4262c16597d35c917b71e4dacdb860118533" translate="yes" xml:space="preserve">
          <source>Support methods for &lt;a href=&quot;statictypecheckingvisitor&quot;&gt;StaticTypeCheckingVisitor&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;statictypecheckingvisitor&quot;&gt;StaticTypeCheckingVisitorの&lt;/a&gt;サポートメソッド。</target>
        </trans-unit>
        <trans-unit id="b334e44ba370eeb1a9fcce805d296237600394b7" translate="yes" xml:space="preserve">
          <source>Support methods for DefaultGroovyMethods and PluginDefaultMethods.</source>
          <target state="translated">DefaultGroovyMethodsとPluginDefaultMethodsのメソッドをサポートします。</target>
        </trans-unit>
        <trans-unit id="40274db933b81a98b5c697affa7d5c7f16fa92d3" translate="yes" xml:space="preserve">
          <source>Support methods for Groovy category usage</source>
          <target state="translated">Groovyカテゴリの使い方のサポート方法</target>
        </trans-unit>
        <trans-unit id="588dfb8cd9cca2180f8096de40629699cecfce75" translate="yes" xml:space="preserve">
          <source>Support mutating a Calendar with a Map.</source>
          <target state="translated">地図を使ったカレンダーの突然変異をサポートしています。</target>
        </trans-unit>
        <trans-unit id="606b6da19d3862e2b1d54033b51c6a674ad9524f" translate="yes" xml:space="preserve">
          <source>Support mutating a Date with a Map.</source>
          <target state="translated">マップを使った日付の突然変異をサポートしています。</target>
        </trans-unit>
        <trans-unit id="0065fbb73dfe423e4f2b0b788b77b810d1895bf4" translate="yes" xml:space="preserve">
          <source>Support retrieving a subset of a BitSet using a Range</source>
          <target state="translated">Range を使用した BitSet のサブセットの取得をサポートします。</target>
        </trans-unit>
        <trans-unit id="cefe376baa46053e6ee5cd1185a7ec7bd5de75a2" translate="yes" xml:space="preserve">
          <source>Support subscript operator for list access.</source>
          <target state="translated">リストアクセスのための添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="0ce8c0aa36043dde1f96ca757bfc9ca258b03f47" translate="yes" xml:space="preserve">
          <source>Support subscript operator for list modification.</source>
          <target state="translated">リスト変更のための添え字演算子をサポートしました。</target>
        </trans-unit>
        <trans-unit id="948555c5f9bb59c7e564313dae8e9e5e33359ef5" translate="yes" xml:space="preserve">
          <source>Support subscript-style assignment for a BitSet.</source>
          <target state="translated">BitSetの添え字スタイルの代入をサポートしています。</target>
        </trans-unit>
        <trans-unit id="277c0c9a0992135998848b12d1623638750f1db0" translate="yes" xml:space="preserve">
          <source>Support the range subscript operator for StringBuilder.</source>
          <target state="translated">StringBuilder の範囲添え字演算子をサポートしました。</target>
        </trans-unit>
        <trans-unit id="09c4c0a5e355d7aa584752cfc33a252f0a73e60e" translate="yes" xml:space="preserve">
          <source>Support the range subscript operator for StringBuilder. Index values are treated as characters within the builder.</source>
          <target state="translated">StringBuilder の範囲添え字演算子をサポートします。インデックス値は、ビルダ内では文字として扱われます。</target>
        </trans-unit>
        <trans-unit id="acd26eb8b1a16f0820319830f663499ae85c68f8" translate="yes" xml:space="preserve">
          <source>Support the range subscript operator for a List.</source>
          <target state="translated">リストの範囲添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="930099686e74d43336ccb036b84c0e5da6eec9e3" translate="yes" xml:space="preserve">
          <source>Support the range subscript operator for an Array</source>
          <target state="translated">配列の範囲添字演算子をサポート</target>
        </trans-unit>
        <trans-unit id="b999effc2096576e1c862e817448092036970953" translate="yes" xml:space="preserve">
          <source>Support the range subscript operator for an eager or lazy List.</source>
          <target state="translated">イガーまたは怠惰なリストの範囲添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="8024a4e87a055ac0bfbf3a79248d3db4e937f9ff" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for ButtonGroup.</source>
          <target state="translated">ButtonGroupの添え字演算子をサポートしています。</target>
        </trans-unit>
        <trans-unit id="8883233fb47d8a916e31ae51ad0682c85c140a3e" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for Collection.</source>
          <target state="translated">コレクションの添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="137e043d5266d133be830bee498a61305b08656b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for Container.</source>
          <target state="translated">コンテナの添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="07b736f7865baa83c1f6bc649704d426a52a785a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for JComboBox.</source>
          <target state="translated">JComboBoxの添え字演算子をサポートしました。</target>
        </trans-unit>
        <trans-unit id="31a8136fdf49a95aaa951ea4ed67ec07e9acc80a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for JMenu.</source>
          <target state="translated">JMenuの添え字演算子をサポートしました。</target>
        </trans-unit>
        <trans-unit id="a6bfb46585e8e0eabd4032848ef55c15306e4cd5" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for JMenuBar.</source>
          <target state="translated">JMenuBarの添え字演算子をサポートしました。</target>
        </trans-unit>
        <trans-unit id="a0c882c6cd60c5c1b40d2bd576e5c94a555b1c4a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for JTabbedPane.</source>
          <target state="translated">JTabbedPaneの添え字演算子をサポートしました。</target>
        </trans-unit>
        <trans-unit id="67f5eb23bb29271d8db04f6cc3958a10877bd86b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for JToolBar.</source>
          <target state="translated">JToolBarの添え字演算子をサポートしました。</target>
        </trans-unit>
        <trans-unit id="3edb03f1dbd6dbc567ef944a1323b4462a95935b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for ListModel.</source>
          <target state="translated">ListModel の添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="d2b5237de01694410633b548a0f924fa610af129" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for TableColumnModel.</source>
          <target state="translated">TableColumnModel の添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="f26d8833306b343dfe6bb5e4ffca867bd20aad7e" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for TableModel.</source>
          <target state="translated">TableModel の添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="f63e2cb744c1c451ecc2c5de29107932d57249e8" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for TreeNode.</source>
          <target state="translated">TreeNode の添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="46b3703b70c5b77bb85b2a093946ef0c0693b3c5" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for TreePath.</source>
          <target state="translated">TreePath の添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="82ca1dcdc1480532f560c6be7abbec186ccf6ee7" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for a Bitset</source>
          <target state="translated">ビットセットの添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="a337c06c56778b26331f5a920f766882be3b0493" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for a Calendar.</source>
          <target state="translated">カレンダーの添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="77f7a0636dc8671f55b6f4130764c09c166c7835" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for a Date.</source>
          <target state="translated">日付の添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="b96b77d4e05609bf5ebac837d1ea604f4bd48580" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for a List.</source>
          <target state="translated">リストの添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="18104f39e920408c5dbd3d2de4a52926a170a585" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for a Map.</source>
          <target state="translated">マップの添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="b7d5a370e14d88ca3b733df074745e512491e1b8" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for an Iterable.</source>
          <target state="translated">イテレータブルの添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="da54421b2475020061b3a47e604a37ada578e23a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for an Iterable. Typical usage:</source>
          <target state="translated">イテレータブルの添え字演算子をサポートします。典型的な使用法。</target>
        </trans-unit>
        <trans-unit id="b136f29e517965b9fab5e959f6e4c99faa02cbad" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for an Iterator.</source>
          <target state="translated">イテレータの添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="712e012634442f739e8d9439273ee6c5469514b8" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for an Iterator. The iterator will be partially exhausted up until the idx entry after returning if a +ve or 0 idx is used, or fully exhausted if a -ve idx is used or no corresponding entry was found. Typical usage:</source>
          <target state="translated">イテレータの添え字演算子をサポートします。ve または 0 の idx が使用されている場合は返した後の idx エントリまで部分的にイテレータを使い果たし、-ve の idx が使用されている場合や対応するエントリが見つからなかった場合は完全に使い果たします。典型的な使用法。</target>
        </trans-unit>
        <trans-unit id="05e1c675a16d28913679eb9bf33a6f3849996840" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for mutating a Calendar.</source>
          <target state="translated">カレンダーを変異させるための添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="e3005a57b2f65de8b8ee3c9e383470c171c93a51" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for mutating a Calendar. Example usage:</source>
          <target state="translated">カレンダーを変異させるための添え字演算子をサポートします。使用例。</target>
        </trans-unit>
        <trans-unit id="0832f9dcf462ade3391f384e44f33f1d4a5d9801" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for mutating a Date.</source>
          <target state="translated">日付を突然変異させるための添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="dcdaffd8f1f395b917d10a9f7899c51471d965d2" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a boolean array</source>
          <target state="translated">論理値配列のコレクションでの添え字演算子のサポート</target>
        </trans-unit>
        <trans-unit id="38960d85e9835053606b584f60047fc89487b81f" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a byte array</source>
          <target state="translated">バイト配列のコレクションを持つ添え字演算子のサポート</target>
        </trans-unit>
        <trans-unit id="bfdd8cbe5169c3fba3ea647b156633a848266f23" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a char array</source>
          <target state="translated">char 配列のコレクションを持つ添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="90742627dc6eb2f9b4d8227c151fad8d57423b85" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a double array</source>
          <target state="translated">二重配列のコレクションを持つ添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="39150a8bf39dcd107e1c51ddc573ad89d6269053" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a float array</source>
          <target state="translated">float 配列のコレクションを持つ添え字演算子のサポート</target>
        </trans-unit>
        <trans-unit id="4e129074b798751ecffc90e0fd782beeab070ad2" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a long array</source>
          <target state="translated">長い配列のコレクションを持つ添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="7d242b1c1771299e2b79691a29aaefc7f993eb38" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a short array</source>
          <target state="translated">短い配列のコレクションを持つ添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="449fc6a9aae0653fc2a2dd933669712b98794a67" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for an int array</source>
          <target state="translated">int 配列のコレクションを持つ添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="406c3c4313afad025dc0f000a9d36af8c01ef6dc" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a boolean array</source>
          <target state="translated">論理値配列の範囲を持つ添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="eb5575ed4428458ede0b0ffe18053e0022f2c8b6" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a byte array</source>
          <target state="translated">バイト配列の範囲を持つ添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="e061d0f5fcf78a949d304e48051b333e3509a09b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a char array</source>
          <target state="translated">char 配列の範囲を持つ添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="d56f743158eb5c5d9a114b722ab2b8aa764c4884" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a double array</source>
          <target state="translated">二重配列の範囲を持つ添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="dc6bb5f77572817a5a2d27996636a61f948630a5" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a float array</source>
          <target state="translated">float 配列の範囲を持つ添え字演算子のサポート</target>
        </trans-unit>
        <trans-unit id="ad8c10b070d78470ed959ae01f3a4b6165c06ea0" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a long array</source>
          <target state="translated">長い配列の範囲を持つ添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="ee52af5b564b8bd5b211088bca646f5f8706167a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a short array</source>
          <target state="translated">短い配列の範囲を持つ添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="1fae014c47830c0263f0c70591acd2cb75401882" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for an int array</source>
          <target state="translated">int 配列の範囲を持つ添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="51b1c738fc5421c1900cbcf82f77be491419f636" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a boolean array</source>
          <target state="translated">論理値配列の IntRange での添え字演算子のサポート</target>
        </trans-unit>
        <trans-unit id="737a9dafe198558df1a051d1b235f28a914614a9" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a byte array</source>
          <target state="translated">バイト配列の IntRange での添え字演算子のサポート</target>
        </trans-unit>
        <trans-unit id="b2e85416ac1bef6482c8defff54899a74c630bad" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a char array</source>
          <target state="translated">char 配列の IntRange で添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="308844e7ffcdb4e852e6200501bf93b50edd1146" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a double array</source>
          <target state="translated">ダブル配列の IntRange での添え字演算子のサポート</target>
        </trans-unit>
        <trans-unit id="e8172d0a1db9a00b56b31db2555af86194397bdf" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a float array</source>
          <target state="translated">浮動小数点配列の IntRange での添え字演算子のサポート</target>
        </trans-unit>
        <trans-unit id="1d9f1a77baa8f3f7c7be70b2868cc3da8cbd873b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a long array</source>
          <target state="translated">長い配列のための IntRange での添え字演算子のサポート</target>
        </trans-unit>
        <trans-unit id="846540f6464f33fa68fb5a18a1bdda484d94be1a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a short array</source>
          <target state="translated">短い配列のための IntRange での添え字演算子のサポート</target>
        </trans-unit>
        <trans-unit id="86d49e4722c5856590c8457389b79e367a48336b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for an int array</source>
          <target state="translated">int 配列の IntRange で添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="135d071ce0e747dd6c86c1f1ea6ff0bd031e49c8" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a byte array</source>
          <target state="translated">バイト配列の ObjectRange での添え字演算子のサポート</target>
        </trans-unit>
        <trans-unit id="494432a9314d4c872a0569f09c6de99b5dacc87a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a char array</source>
          <target state="translated">char 配列の ObjectRange で添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="2efca516ac0e519470608b925ed538b8fb748e45" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a double array</source>
          <target state="translated">ダブル配列の ObjectRange での添え字演算子のサポート</target>
        </trans-unit>
        <trans-unit id="a688426210c62de688f8dcf07f4c2ab964d91970" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a float array</source>
          <target state="translated">float 配列の ObjectRange での添え字演算子のサポート</target>
        </trans-unit>
        <trans-unit id="2ee30662b569f7f70c6b555a7b4769ca93dd7017" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a long array</source>
          <target state="translated">長い配列の ObjectRange での添え字演算子のサポート</target>
        </trans-unit>
        <trans-unit id="92bb07165d787ba1a31571dfaf457860dd156cc3" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a short array</source>
          <target state="translated">短い配列の ObjectRange での添え字演算子のサポート</target>
        </trans-unit>
        <trans-unit id="0d8f69636a462dfdae8f77c74465fe081dcc0144" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for an int array</source>
          <target state="translated">int 配列の ObjectRange で添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="e81c22dfff611d4ce5af5cc7d3ba8e087782c019" translate="yes" xml:space="preserve">
          <source>Supported syntax:</source>
          <target state="translated">サポートされている構文。</target>
        </trans-unit>
        <trans-unit id="29082ca330fc6abf963f95d250bbb9faa7ada8ea" translate="yes" xml:space="preserve">
          <source>Supports integer based subscript operators for accessing at numbered columns starting at zero.</source>
          <target state="translated">ゼロから始まる番号付きの列にアクセスするための整数ベースの添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="685b4ee9fceb194e1bba657c003c3d9058d640a0" translate="yes" xml:space="preserve">
          <source>Supports integer based subscript operators for accessing at numbered columns starting at zero. Negative indices are supported, they will count from the last column backwards.</source>
          <target state="translated">ゼロから始まる番号付きの列にアクセスするための整数ベースの添え字演算子をサポートしています。負のインデックスがサポートされており、最後の列から逆算してカウントされます。</target>
        </trans-unit>
        <trans-unit id="d8a1dffb79c3a58bf51ad444252e384308031a1f" translate="yes" xml:space="preserve">
          <source>Supports integer based subscript operators for updating the values of numbered columns starting at zero.</source>
          <target state="translated">ゼロから始まる番号付き列の値を更新するための整数ベースの添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="b9040372ef64134ed11c8ca3980f52a75c335178" translate="yes" xml:space="preserve">
          <source>Supports integer based subscript operators for updating the values of numbered columns starting at zero. Negative indices are supported, they will count from the last column backwards.</source>
          <target state="translated">ゼロから始まる番号付き列の値を更新するための整数ベースの添え字演算子をサポートします。負のインデックスをサポートしており、最後の列から逆算してカウントします。</target>
        </trans-unit>
        <trans-unit id="e121e3a40b35411dcbf80ace25a2cab09c6a9d81" translate="yes" xml:space="preserve">
          <source>Supports integer-based subscript operators for accessing at numbered columns starting at zero.</source>
          <target state="translated">ゼロから始まる番号付きの列にアクセスするための整数ベースの添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="6650b1b6bbaec3d498660928194e1e004714a8ee" translate="yes" xml:space="preserve">
          <source>Supports integer-based subscript operators for accessing at numbered columns starting at zero. Negative indices are supported, they will count from the last column backwards.</source>
          <target state="translated">ゼロから始まる番号付きの列にアクセスするための整数ベースの添え字演算子をサポートしています。負のインデックスがサポートされており、最後の列から逆算してカウントされます。</target>
        </trans-unit>
        <trans-unit id="f6892c78c1164bf275bea2cf843d7c79de2a8d05" translate="yes" xml:space="preserve">
          <source>Supports only the five basic XML entities (gt, lt, quot, amp, apos)</source>
          <target state="translated">基本的な5つのXMLエンティティ(gt,lt,quot,amp,apos)のみをサポートします。</target>
        </trans-unit>
        <trans-unit id="272482f4c74fef3dcf775ef6e04d38a838b4eddf" translate="yes" xml:space="preserve">
          <source>Supports the division operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#dividedBy(long)&quot;&gt;Duration.dividedBy&lt;/a&gt; method.</source>
          <target state="translated">除算演算子をサポートします。&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#dividedBy(long)&quot;&gt;Duration.dividedBy&lt;/a&gt;メソッドを呼び出すのと同じです。</target>
        </trans-unit>
        <trans-unit id="6e3256613e913c27b4d30572865fb8f14dba9d45" translate="yes" xml:space="preserve">
          <source>Supports the getAt operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/ZoneOffset.html#getLong(java.time.temporal.TemporalField)&quot;&gt;ZoneOffset.getLong&lt;/a&gt; method.</source>
          <target state="translated">getAt演算子をサポートします。&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/ZoneOffset.html#getLong(java.time.temporal.TemporalField)&quot;&gt;ZoneOffset.getLong&lt;/a&gt;メソッドを呼び出すのと同じです。</target>
        </trans-unit>
        <trans-unit id="3d1b992b51a3b320adfa7435877250915682a88b" translate="yes" xml:space="preserve">
          <source>Supports the getAt operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAccessor.html#getLong(java.time.temporal.TemporalField)&quot;&gt;TemporalAccessor.getLong&lt;/a&gt; method.</source>
          <target state="translated">getAt演算子をサポートします。&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAccessor.html#getLong(java.time.temporal.TemporalField)&quot;&gt;TemporalAccessor.getLong&lt;/a&gt;メソッドを呼び出すのと同じです。</target>
        </trans-unit>
        <trans-unit id="45b564a7490c0cfc9ab37fb49992105cbdffd741" translate="yes" xml:space="preserve">
          <source>Supports the getAt operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAmount.html#get(TemporalUnit)&quot;&gt;TemporalAmount.get&lt;/a&gt; method.</source>
          <target state="translated">getAt演算子をサポートします。&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAmount.html#get(TemporalUnit)&quot;&gt;TemporalAmount.get&lt;/a&gt;メソッドを呼び出すのと同じです。</target>
        </trans-unit>
        <trans-unit id="9fbf8412864ed83f47c19fb2de0ad38b4c2d88bb" translate="yes" xml:space="preserve">
          <source>Supports the multiplication operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#multipliedBy(long)&quot;&gt;Duration.multipliedBy&lt;/a&gt; method.</source>
          <target state="translated">乗算演算子をサポートします。&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#multipliedBy(long)&quot;&gt;Duration.multipliedBy&lt;/a&gt;メソッドを呼び出すのと同じです。</target>
        </trans-unit>
        <trans-unit id="9c58b6034a8cda0cb4caab3bc1a085313bf5131d" translate="yes" xml:space="preserve">
          <source>Supports the multiply operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html#multipliedBy(int)&quot;&gt;Period.multipliedBy&lt;/a&gt; method.</source>
          <target state="translated">乗算演算子をサポートします。&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html#multipliedBy(int)&quot;&gt;Period.multipliedBy&lt;/a&gt;メソッドを呼び出すのと同じです。</target>
        </trans-unit>
        <trans-unit id="1f12770c32aa35e5994877bee4b25b602e3e93f3" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for CharSequence or StringBuffer with EmptyRange</source>
          <target state="translated">EmptyRange を持つ CharSequence または StringBuffer の範囲添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="c2d8232579b8962a2f78045b849d8783bfeba70b" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for CharSequence with IntRange.</source>
          <target state="translated">IntRangeを持つCharSequenceの範囲添字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="734ac83eea03aa14f6f645cbb62c57d5ebc7a7cb" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for CharSequence.</source>
          <target state="translated">CharSequence の範囲添字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="1c17ccd565eec637aeb61b93388e26907f417969" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for GString with IntRange.</source>
          <target state="translated">IntRangeでGStringの範囲添字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="2de30284c9a0e8fcec0804002be4e2ae2ec22240" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for GString.</source>
          <target state="translated">GString の範囲添字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="c21234956f0cebc724e038773b6489ec986cabd2" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for String with IntRange.</source>
          <target state="translated">IntRangeでStringの範囲添字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="30590a771f8986708ccb6659f99345ce35751d79" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for String.</source>
          <target state="translated">String の範囲添字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="87567806977a560b8169c7b6d539bc7ee1adcfbc" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for StringBuffer.</source>
          <target state="translated">StringBuffer の範囲添字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="e5b5e33b1e927360d37b9e7aff1c489178f6ab28" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for StringBuffer. Index values are treated as characters within the buffer.</source>
          <target state="translated">StringBufferの範囲添字演算子をサポートします。インデックス値はバッファ内の文字として扱われます。</target>
        </trans-unit>
        <trans-unit id="603e946fa86fe6630cb7e4e41deba0896a06b13b" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for StringBuilder.</source>
          <target state="translated">StringBuilder の範囲添字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="76f1d48bcdcf4c5ad55799e7efb5332d2c727357" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for StringBuilder. Index values are treated as characters within the builder.</source>
          <target state="translated">StringBuilder の範囲添え字演算子をサポートします。インデックス値は、ビルダ内では文字として扱われます。</target>
        </trans-unit>
        <trans-unit id="b3868e5ccdf1c52b1bcae61cb67a1658a621b670" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for a GPathResult.</source>
          <target state="translated">GPathResult の範囲添字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="847373efea045010884a5921e02aeb3939071729" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator for CharSequence.</source>
          <target state="translated">CharSequence の添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="643bb4275fc8f901b11dbe657ab42dacee233538" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator for GString.</source>
          <target state="translated">GString の添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="c14c15e33602a664d9d6717e5a114f93eff3f995" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator for String.</source>
          <target state="translated">String の添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="1eeaf121a846e73418ed8bb3f658e4d50c2b1ac6" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator for a GPathResult.</source>
          <target state="translated">GPathResult の添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="a5e7d8728bc31a020c837e7346295444cfb639ed" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator, e.g.</source>
          <target state="translated">添え字演算子をサポートします。</target>
        </trans-unit>
        <trans-unit id="63d6e6526a6efcf42b637b3fee8333d2c42dfe8a" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator, e.g. &lt;code&gt;matcher[index]&lt;/code&gt;, for a &lt;code&gt;Matcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Matcher&lt;/code&gt; の添え字演算子（ &lt;code&gt;matcher[index]&lt;/code&gt; など）をサポートします。</target>
        </trans-unit>
        <trans-unit id="b24a8e67655e2d3680c8d291f8d695bc52b8deef" translate="yes" xml:space="preserve">
          <source>Supports the unary minus operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#negated()&quot;&gt;Duration.negated&lt;/a&gt; method.</source>
          <target state="translated">単項マイナス演算子をサポートします。&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#negated()&quot;&gt;Duration.negated&lt;/a&gt;メソッドを呼び出すのと同じです。</target>
        </trans-unit>
        <trans-unit id="ef16973534d92d25c8ba950c50ef216e3d129c99" translate="yes" xml:space="preserve">
          <source>Supports the unary minus operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html#negated()&quot;&gt;Period.negated&lt;/a&gt; method.</source>
          <target state="translated">単項マイナス演算子をサポートします。&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html#negated()&quot;&gt;Period.negated&lt;/a&gt;メソッドを呼び出すのと同じです。</target>
        </trans-unit>
        <trans-unit id="ca1984ff7448bd1530fcb00a669677ddf234ba06" translate="yes" xml:space="preserve">
          <source>Supports the unary plus operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#abs()&quot;&gt;Duration.abs&lt;/a&gt; method.</source>
          <target state="translated">単項プラス演算子をサポートします。&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#abs()&quot;&gt;Duration.abs&lt;/a&gt;メソッドを呼び出すのと同じです。</target>
        </trans-unit>
        <trans-unit id="9671c499c2b0eccb12ed3d9fb0e71ffb8f89feef" translate="yes" xml:space="preserve">
          <source>Supports the unary plus operator; returns a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html&quot;&gt;Period&lt;/a&gt; with all unit values positive.</source>
          <target state="translated">単項プラス演算子をサポートします。すべての単位値が正の&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html&quot;&gt;期間&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="f2b3726eac67d7b17290df48a691ab6648c417ac" translate="yes" xml:space="preserve">
          <source>Supports the unary plus operator; returns a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html&quot;&gt;Period&lt;/a&gt; with all unit values positive. For example, a period of &quot;2 years, -3 months, and -4 days&quot; would result in a period of &quot;2 years, 3 months, and 4 days.&quot; No normalization is performed.</source>
          <target state="translated">単項プラス演算子をサポートします。すべての単位値が正の&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html&quot;&gt;期間&lt;/a&gt;を返します。たとえば、「2年、-3か月、および-4日」の期間は、「2年、3か月、および4日」の期間になります。正規化は実行されません。</target>
        </trans-unit>
        <trans-unit id="444b203ece3ce0e7f35d5c0aef68426d9b0d431c" translate="yes" xml:space="preserve">
          <source>Swaps two elements at the specified positions.</source>
          <target state="translated">指定した位置で2つの要素を入れ替えます。</target>
        </trans-unit>
        <trans-unit id="11d786b4e23376ea3dc79c4c0a88541bba21feca" translate="yes" xml:space="preserve">
          <source>Swing application to graphically display the tokens produced by the lexer.</source>
          <target state="translated">レキサーが生成したトークンをグラフィカルに表示するスイングアプリケーション。</target>
        </trans-unit>
        <trans-unit id="a505d05672b9c632c10baf50232815e236897342" translate="yes" xml:space="preserve">
          <source>SwingBuilder helper classes for creating components</source>
          <target state="translated">コンポーネントを作成するためのSwingBuilderヘルパークラス</target>
        </trans-unit>
        <trans-unit id="b4d5fef0fd56423d2005b5f23fc72bafc05788b9" translate="yes" xml:space="preserve">
          <source>Switches the builder's proxyBuilder during the execution of a closure.</source>
          <target state="translated">クロージャの実行中にビルダーのproxyBuilderを切り替えます。</target>
        </trans-unit>
        <trans-unit id="1d654f8f369be41ce70e791e599030be1914b8e6" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;a href=&quot;#toSpreadMap(java.util.Map)&quot;&gt;toSpreadMap(java.util.Map)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#toSpreadMap(java.util.Map)&quot;&gt;toSpreadMap（java.util.Map）の&lt;/a&gt;同義語。</target>
        </trans-unit>
        <trans-unit id="8bf9b65aa3eb7662090be9b911189d54f126ea4c" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;code&gt;compile(Phases.ALL)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;compile(Phases.ALL)&lt;/code&gt; の同義語。</target>
        </trans-unit>
        <trans-unit id="f7e7d4ec9c98e022a28f28595845ab382d8e7b30" translate="yes" xml:space="preserve">
          <source>Synonym for full compilation</source>
          <target state="translated">総集編の同義語</target>
        </trans-unit>
        <trans-unit id="922c2e5f4ef255d4058e512453e827f08ec07983" translate="yes" xml:space="preserve">
          <source>Synonym for write(text) allowing file.text = 'foo'.</source>
          <target state="translated">write(text)の同義語で、file.text='foo' を許可します。</target>
        </trans-unit>
        <trans-unit id="c6f6827d49ab5f403cdd18485a48da06676e323d" translate="yes" xml:space="preserve">
          <source>Synonym for write(text, charset) allowing:</source>
          <target state="translated">書き込み(text,charset)を許可するための同義語。</target>
        </trans-unit>
        <trans-unit id="38259ff21e4eb435a46c701dcdd29b24d58b4a78" translate="yes" xml:space="preserve">
          <source>Syntax supported:</source>
          <target state="translated">構文がサポートされています。</target>
        </trans-unit>
        <trans-unit id="1de8dba368e7754dc199c99b017f5c51265ee8dc" translate="yes" xml:space="preserve">
          <source>Syntax:</source>
          <target state="translated">Syntax:</target>
        </trans-unit>
        <trans-unit id="92f3ec2c7d54e41b31652ea8927f4cb0fe0d53b2" translate="yes" xml:space="preserve">
          <source>SyntaxErrorReportable</source>
          <target state="translated">SyntaxErrorReportable</target>
        </trans-unit>
        <trans-unit id="989982c92d7d7b069cc494d871290c6c79dd1bea" translate="yes" xml:space="preserve">
          <source>System.currentTimeMillis</source>
          <target state="translated">System.currentTimeMillis</target>
        </trans-unit>
        <trans-unit id="52f9440d82aa136e8330aac61d5581f83dc6cf89" translate="yes" xml:space="preserve">
          <source>Systematically generate permutations. Adapted from Java Code by Michael Gilleland (released with no restrictions) using an algorithm described here: Kenneth H. Rosen, Discrete Mathematics and Its Applications, 2nd edition (NY: McGraw-Hill, 1991), pp. 282-284</source>
          <target state="translated">順列を体系的に生成する。ここに記述されているアルゴリズムを用いて、Michael GillelandによるJava Code(無制限で公開)から採用。Kenneth H.Rosen,Discrete Mathematics and Its Applications,2nd edition (NY:McGraw-Hill,1991),pp.</target>
        </trans-unit>
        <trans-unit id="dab1fd1e591a63e3e5e200ee8fa3c5a14d2c00db" translate="yes" xml:space="preserve">
          <source>T foo(){}</source>
          <target state="translated">T foo(){}のようになります。</target>
        </trans-unit>
        <trans-unit id="8fe6d0b31eb59e6ac337f0b92f98cb3ad502463c" translate="yes" xml:space="preserve">
          <source>TODO Get list of groovydoc tags</source>
          <target state="translated">TODO groovydocタグのリストを取得する</target>
        </trans-unit>
        <trans-unit id="921b6844ab03e31995729bfc75953f8eac7378a3" translate="yes" xml:space="preserve">
          <source>TODO parse groovydoc to get tag content</source>
          <target state="translated">TODO groovydocを解析してタグの内容を取得する</target>
        </trans-unit>
        <trans-unit id="a4ba86ffe7ca973bae787f6414c279df51d0ddf5" translate="yes" xml:space="preserve">
          <source>TODO: Should return the URI for this source, but we can't know what it is here.</source>
          <target state="translated">TODO:このソースのURIを返すべきですが、それが何であるかはわかりません。</target>
        </trans-unit>
        <trans-unit id="cf93c98946db5510058c27414ea744e90e3279d8" translate="yes" xml:space="preserve">
          <source>TODO: experimental!</source>
          <target state="translated">ALL:実験的!</target>
        </trans-unit>
        <trans-unit id="3657c9335058621e4530f335028b3958464c5aa9" translate="yes" xml:space="preserve">
          <source>TODO: experimental! Annotates an AST node with matching contraints. This method should be called on an AST intended to be used as a pattern only. It will put node metadata on the AST node allowing customized behavior in pattern matching.</source>
          <target state="translated">TODO:experimental! ASTのノードに一致する矛盾点をアノテーションします。このメソッドは、パターンとしてのみ使用することを意図したASTに対して呼び出されるべきです。このメソッドは、パターンマッチングの動作をカスタマイズできるようにASTノードにメタデータを付与します。</target>
        </trans-unit>
        <trans-unit id="b1c7a681e02f969b203ba3592fa54d2c692bbb52" translate="yes" xml:space="preserve">
          <source>TableCellEditor</source>
          <target state="translated">TableCellEditor</target>
        </trans-unit>
        <trans-unit id="57561c4bfa715cb5f4cf7c5dbfce29a5881d0950" translate="yes" xml:space="preserve">
          <source>TableModelListener</source>
          <target state="translated">TableModelListener</target>
        </trans-unit>
        <trans-unit id="5d7cbdd762e595f129150b280be1165c581c52dc" translate="yes" xml:space="preserve">
          <source>Takes a statement and wraps it into a block statement which first element is the interruption check statement.</source>
          <target state="translated">文を受け取り、最初の要素が中断チェック文であるブロック文にラップします。</target>
        </trans-unit>
        <trans-unit id="354438b5f2c2435d85aef9e5e1d521b569efa655" translate="yes" xml:space="preserve">
          <source>Takes a zero based index and convert it into an SQL based 1 based index.</source>
          <target state="translated">ゼロベースのインデックスを取り、SQLベースの1ベースのインデックスに変換します。</target>
        </trans-unit>
        <trans-unit id="041aa4646c123f7952eaab5d26bd55d6a7709b46" translate="yes" xml:space="preserve">
          <source>Takes a zero based index and convert it into an SQL based 1 based index. A negative index will count backwards from the last column.</source>
          <target state="translated">ゼロベースのインデックスを取り、SQLベースの1ベースのインデックスに変換します。負のインデックスは、最後のカラムから逆算してカウントされます。</target>
        </trans-unit>
        <trans-unit id="72e15a873cff2714be38f04fe3477dcbcb571d1e" translate="yes" xml:space="preserve">
          <source>Takes the characters between nth (specified by occurrence) pair of &lt;code&gt;enclosure&lt;/code&gt; strings.</source>
          <target state="translated">n番目（出現によって指定される）の &lt;code&gt;enclosure&lt;/code&gt; 文字列のペアの間の文字を取ります。</target>
        </trans-unit>
        <trans-unit id="4fdd5b94d50723024ee61c7a3f2a6df16695a3b8" translate="yes" xml:space="preserve">
          <source>Takes the characters between the first occurrence of the two subsequent &lt;code&gt;enclosure&lt;/code&gt; strings.</source>
          <target state="translated">後続の2つの &lt;code&gt;enclosure&lt;/code&gt; ストリングの最初の出現の間の文字を取ります。</target>
        </trans-unit>
        <trans-unit id="8f5401efdd15336ecf28fb95881261864d11cc09" translate="yes" xml:space="preserve">
          <source>Takes the last ?</source>
          <target state="translated">最後の?</target>
        </trans-unit>
        <trans-unit id="5ad0f94b3f2dd848f00aba4d7d9abd45a61b5b02" translate="yes" xml:space="preserve">
          <source>Takes the last ? tokens of the list that form a simple expression, evaluates it and returns a result. &quot;Simple&quot; means evaluation is known to be side-effect free.</source>
          <target state="translated">単純な式を構成するリストの最後の ?トークンを取り、それを評価して結果を返します。&quot;単純 &quot;とは、評価が副作用のないことが知られていることを意味します。</target>
        </trans-unit>
        <trans-unit id="c304b15ae8ce0d2e4f76ba2ec779635f48eea681" translate="yes" xml:space="preserve">
          <source>Target.class</source>
          <target state="translated">Target.class</target>
        </trans-unit>
        <trans-unit id="7a099fd78212cd2ae28a2ff9a08f499c9dc92e4d" translate="yes" xml:space="preserve">
          <source>TargetBinding</source>
          <target state="translated">TargetBinding</target>
        </trans-unit>
        <trans-unit id="da5a824ba0bd242c7a60e17970f2791dec54d4ab" translate="yes" xml:space="preserve">
          <source>Tells if a class is one of the &quot;accept all&quot; classes as the left hand side of an assignment.</source>
          <target state="translated">あるクラスが課題の左側にある「すべてを受け入れる」クラスのいずれかであるかどうかを教えてくれます。</target>
        </trans-unit>
        <trans-unit id="0e09ff464218acfb2c73af0f0dc15dbca113a8c2" translate="yes" xml:space="preserve">
          <source>Tells if a class node is candidate for class literal bytecode optimization.</source>
          <target state="translated">クラスノードがクラスリテラルバイトコード最適化の候補であるかどうかを判定します。</target>
        </trans-unit>
        <trans-unit id="05493540c669c245f9637bf19d526e8d21f77a68" translate="yes" xml:space="preserve">
          <source>Tells if a class node is candidate for class literal bytecode optimization. If so, bytecode may use LDC instructions instead of static constant Class fields to retrieve class literals.</source>
          <target state="translated">クラスノードがクラスリテラルのバイトコード最適化の候補であるかどうかを判定します。そうであれば、バイトコードはクラスリテラルを取得するために、静的定数クラスフィールドの代わりにLDC命令を使用することができます。</target>
        </trans-unit>
        <trans-unit id="d1d9bbbc3e04be119c70847b1f19b96ddd5a0d78" translate="yes" xml:space="preserve">
          <source>Tells if an input string matches a token.</source>
          <target state="translated">入力文字列がトークンと一致するかどうかを判定します。</target>
        </trans-unit>
        <trans-unit id="fd4940f1c01e2547dee0d64e72579a3db1df3a96" translate="yes" xml:space="preserve">
          <source>Tells if the given string is a valid Java identifier.</source>
          <target state="translated">与えられた文字列が有効なJava識別子かどうかを判定します。</target>
        </trans-unit>
        <trans-unit id="2bf831a8ad75f4c75e56aee27a3bdb1640b165c2" translate="yes" xml:space="preserve">
          <source>Tells if this variable or the accessed variable is used in a closure context, like in the following example :</source>
          <target state="translated">次の例のように、この変数またはアクセスされた変数がクロージャのコンテキストで使用されるかどうかを通知します。</target>
        </trans-unit>
        <trans-unit id="a5816f31fd183aa07200a002c77102dff5452d37" translate="yes" xml:space="preserve">
          <source>Template engine configuration</source>
          <target state="translated">テンプレートエンジンの設定</target>
        </trans-unit>
        <trans-unit id="e12b935685180af8ae3137efb7001cba2cd17832" translate="yes" xml:space="preserve">
          <source>Template engine for use in templating scenarios where both the template source and the expected output are intended to be XML.</source>
          <target state="translated">テンプレートソースと期待される出力の両方がXMLであることを意図したテンプレートシナリオで使用するためのテンプレートエンジン。</target>
        </trans-unit>
        <trans-unit id="ef204f5f3596e2d30194001a07b4928b1a3949d3" translate="yes" xml:space="preserve">
          <source>TemplateEngine.createTemplate</source>
          <target state="translated">TemplateEngine.createTemplate</target>
        </trans-unit>
        <trans-unit id="dbf0ac726f3831ef2074d859816b327c66ed2b43" translate="yes" xml:space="preserve">
          <source>TemplateResolver</source>
          <target state="translated">TemplateResolver</target>
        </trans-unit>
        <trans-unit id="4436c0fa899dfbc2356893b025763c65d2d5384e" translate="yes" xml:space="preserve">
          <source>TemplateServlet.initTemplateEngine</source>
          <target state="translated">TemplateServlet.initTemplateEngine</target>
        </trans-unit>
        <trans-unit id="e593dd8801cfc67b3cac7df9ad54ee66fd2a486b" translate="yes" xml:space="preserve">
          <source>TemplateServlet.setVariables</source>
          <target state="translated">TemplateServlet.setVariables</target>
        </trans-unit>
        <trans-unit id="891b3675d27a4138af5360bd35bb314e25b67789" translate="yes" xml:space="preserve">
          <source>Templates may use the normal '${expression}' and '$variable' notations to insert an arbitrary expression into the template. In addition, support is also provided for special tags: &amp;lt;gsp:scriptlet&amp;gt; (for inserting code fragments) and &amp;lt;gsp:expression&amp;gt; (for code fragments which produce output).</source>
          <target state="translated">テンプレートは、通常の「$ {expression}」および「$ variable」表記を使用して、任意の式をテンプレートに挿入できます。さらに、特別なタグ&amp;lt;gsp：scriptlet&amp;gt;（コードフラグメントを挿入するため）および&amp;lt;gsp：expression&amp;gt;（出力を生成するコードフラグメントのため）のサポートも提供されます。</target>
        </trans-unit>
        <trans-unit id="00122ac4f85694e5831e7199490968568e2ab42e" translate="yes" xml:space="preserve">
          <source>Terence Parr parrt@magelang.com John Lilley jlilley@empathy.com Scott Stanchfield thetick@magelang.com Markus Mohnen mohnen@informatik.rwth-aachen.de Peter Williams pete.williams@sun.com Allan Jacobs Allan.Jacobs@eng.sun.com Steve Messick messick@redhills.com James Strachan jstrachan@protique.com John Pybus john@pybus.org John Rose rose00@mac.com Jeremy Rayner groovy@ross-rayner.com Alex Popescu the.mindstorm@gmail.com Martin Kempf mkempf@hsr.ch Reto Kleeb rkleeb@hsr.ch Version 1.00 December 9, 1997 -- initial release Version 1.01 December 10, 1997 fixed bug in octal def (0..7 not 0..8) Version 1.10 August 1998 (parrt) added tree construction fixed definition of WS,comments for mac,pc,unix newlines added unary plus Version 1.11 (Nov 20, 1998) Added &quot;shutup&quot; option to turn off last ambig warning. Fixed inner class def to allow named class defs as statements synchronized requires compound not simple statement add [] after builtInType DOT class in primaryExpression &quot;const&quot; is reserved but not valid..removed from modifiers Version 1.12 (Feb 2, 1999) Changed LITERAL_xxx to xxx in tree grammar. Updated java.g to use tokens {...} now for 2.6.0 (new feature). Version 1.13 (Apr 23, 1999) Didn't have (stat)? for else clause in tree parser. Didn't gen ASTs for interface extends. Updated tree parser too. Updated to 2.6.0. Version 1.14 (Jun 20, 1999) Allowed final/abstract on local classes. Removed local interfaces from methods Put instanceof precedence where it belongs...in relationalExpr It also had expr not type as arg; fixed it. Missing ! on SEMI in classBlock fixed: (expr) + &quot;string&quot; was parsed incorrectly (+ as unary plus). fixed: didn't like Object[].class in parser or tree parser Version 1.15 (Jun 26, 1999) Screwed up rule with instanceof in it. :( Fixed. Tree parser didn't like (expr).something; fixed. Allowed multiple inheritance in tree grammar. oops. Version 1.16 (August 22, 1999) Extending an interface built a wacky tree: had extra EXTENDS. Tree grammar didn't allow multiple superinterfaces. Tree grammar didn't allow empty var initializer: {} Version 1.17 (October 12, 1999) ESC lexer rule allowed 399 max not 377 max. java.tree.g didn't handle the expression of synchronized statements. Version 1.18 (August 12, 2001) Terence updated to Java 2 Version 1.3 by observing/combining work of Allan Jacobs and Steve Messick. Handles 1.3 src. Summary: o primary didn't include boolean.class kind of thing o constructor calls parsed explicitly now: see explicitConstructorInvocation o add strictfp modifier o missing objBlock after new expression in tree grammar o merged local class definition alternatives, moved after declaration o fixed problem with ClassName.super.field o reordered some alternatives to make things more efficient o long and double constants were not differentiated from int/float o whitespace rule was inefficient: matched only one char o add an examples directory with some nasty 1.3 cases o made Main.java use buffered IO and a Reader for Unicode support o supports UNICODE? Using Unicode charVocabulary makes code file big, but only in the bitsets at the end. I need to make ANTLR generate unicode bitsets more efficiently. Version 1.19 (April 25, 2002) Terence added in nice fixes by John Pybus concerning floating constants and problems with super() calls. John did a nice reorg of the primary/postfix expression stuff to read better and makes f.g.super() parse properly (it was METHOD_CALL not a SUPER_CTOR_CALL). Also: o &quot;finally&quot; clause was a root...made it a child of &quot;try&quot; o Added stuff for asserts too for Java 1.4, but *commented out* as it is not backward compatible. Version 1.20 (October 27, 2002) Terence ended up reorging John Pybus' stuff to remove some nondeterminisms and some syntactic predicates. Note that the grammar is stricter now; e.g., this(...) must be the first statement. Trinary ?: operator wasn't working as array name: (isBig ? bigDigits : digits)[i]; Checked parser/tree parser on source for Resin-2.0.5, jive-2.1.1, jdk 1.3.1, Lucene, antlr 2.7.2a4, and the 110k-line jGuru server source. Version 1.21 (October 17, 2003) Fixed lots of problems including: Ray Waldin: add typeDefinition to interfaceBlock in java.tree.g He found a problem/fix with floating point that start with 0 Ray also fixed problem that (int.class) was not recognized. Thorsten van Ellen noticed that \n are allowed incorrectly in strings. TJP fixed CHAR_LITERAL analogously. Version 1.21.2 (March, 2003) Changes by Matt Quail to support generics (as per JDK1.5/JSR14) Notes: o We only allow the &quot;extends&quot; keyword and not the &quot;implements&quot; keyword, since that's what JSR14 seems to imply. o Thanks to Monty Zukowski for his help on the antlr-interest mail list. o Thanks to Alan Eliasen for testing the grammar over his Fink source base Version 1.22 (July, 2004) Changes by Michael Studman to support Java 1.5 language extensions Notes: o Added support for annotations types o Finished off Matt Quail's generics enhancements to support bound type arguments o Added support for new for statement syntax o Added support for static import syntax o Added support for enum types o Tested against JDK 1.5 source base and source base of jdigraph project o Thanks to Matt Quail for doing the hard part by doing most of the generics work Version 1.22.1 (July 28, 2004) Bug/omission fixes for Java 1.5 language support o Fixed tree structure bug with classOrInterface - thanks to Pieter Vangorpto for spotting this o Fixed bug where incorrect handling of SR and BSR tokens would cause type parameters to be recognised as type arguments. o Enabled type parameters on constructors, annotations on enum constants and package definitions o Fixed problems when parsing if ((char.class.equals(c))) {} - solution by Matt Quail at Cenqua Version 1.22.2 (July 28, 2004) Slight refactoring of Java 1.5 language support o Refactored for/&quot;foreach&quot; productions so that original literal &quot;for&quot; literal is still used but the for sub-clauses vary by token type o Fixed bug where type parameter was not included in generic constructor's branch of AST Version 1.22.3 (August 26, 2004) Bug fixes as identified by Michael Stahl; clean up of tabs/spaces and other refactorings o Fixed typeParameters omission in identPrimary and newStatement o Replaced GT reconcilliation code with simple semantic predicate o Adapted enum/assert keyword checking support from Michael Stahl's java15 grammar o Refactored typeDefinition production and field productions to reduce duplication Version 1.22.4 (October 21, 2004) Small bux fixes o Added typeArguments to explicitConstructorInvocation, e.g. new</source>
          <target state="translated">Terence Parr parrt@magelang.com John Lilley jlilley@empathy.com Scott Stanchfield thetick@magelang.com Markus Mohnen mohnen@informatik.rwth-aachen.de Peter Williams pete.williams@sun.com Allan Jacobs Allan.Jacobs@eng.sun.com Steve Messick messick@redhills.com James Strachan jstrachan@protique.com John Pybus john@pybus.org John Rose rose00@mac.com Jeremy Rayner groovy@ross-rayner.com Alex Popescu the.mindstorm@gmail.com Martin Kempf mkempf@hsr.ch Reto Kleeb rkleeb@hsr.ch バージョン1.00 1997年12月9日 --初期リリース Version 1.01 1997年12月10日 8進数defのバグ修正 (0..8ではなく0.7)Version 1.10 1998年8月 (parrt)ツリー構造の追加 WSの定義の修正、mac,pc,unix用のコメントの修正 改行の追加 単項プラス Version 1.11 (1998年11月20日)最後の曖昧警告を消すための &quot;shutup &quot;オプションを追加しました。内部クラスのdefを修正し、名前付きクラスのdefをステートメントとして許可するようにしました。 同期化されたステートメントは単純なステートメントではなく、複合語を必要とします。java.gを更新し、2.6.0でトークン{...}を使用するようにしました(新機能)。バージョン1.13 (1999年4月23日)ツリーパーサの else 節に (stat)? インタフェース拡張のASTを生成しないようにした。ツリーパーサも更新。2.6.0に更新。Version 1.14 (Jun 20,1999)ローカルクラスのfinal/abstractを許可するようにした。メソッドからローカルインタフェースを削除し、relationalExprの中にinstanceofを優先するようにした。 また、exprの型がargになっていなかったのを修正した。classBlockのSEMIの! (expr)+&quot;文字列 &quot;の解析に失敗していたのを修正 (+を単項プラスにしていた)パーサやツリーパーサでObject[].classが気に入らなかったのを修正した Version 1.15 (Jun 26,1999)instanceofを含むルールをねじ込んでいた。ツリーパーサが (expr).somethingを嫌っていたのを修正。ツリー文法で複数継承を許可するようにした。Version 1.16 (1999年8月22日)インターフェイスの拡張で、EXTENDSを追加した。ツリー文法で複数のスーパーインターフェースを許可しなかった。ツリー文法は空の var initializer を許さない。{}バージョン 1.17 (1999年10月12日)ESC の lexer ルールで 399 max が 377 max ではなく 399 max になった。バージョン 1.18 (2001年8月12日)アラン・ジェイコブスとスティーブ・メシックの作業を観察・統合し、Java 2 バージョン 1.3 に更新。1.3のsrcを扱いました。要約:o プライマリに boolean.class のようなものが含まれていなかった o コンストラクタの呼び出しが明示的に解析されるようになった:explicitConstructorInvocation を参照 o strictfp 修飾子を追加 o ツリー文法の新しい式の後に objBlock が欠けていた o ローカルクラス定義の代替案をマージし、宣言後に移動 o ClassName.super.フィールドの問題を修正 o いくつかの代替案を並べ替えた。 o 物事をより効率的にするためにいくつかの選択肢を並べ替えた o longとdoubleの定数がint/floatと区別されていなかった o 空白のルールは非効率的だった:1つのcharにしかマッチしなかった o いくつかの厄介な1.3のケースを持つexamplesディレクトリを追加 o Main.javaではバッファリングされたIOとUnicodeサポートのためのReaderを使用した o UNICODEをサポートしていますか? Unicode charVocabularyを使うとコードファイルは大きくなりますが、最後のビットセットだけは大きくなります。ANTLRがより効率的にユニコードビットセットを生成するようにする必要があります。バージョン1.19 (2002年4月25日)Terenceは、John Pybusによる浮動定数とsuper()呼び出しの問題に関する素晴らしい修正を追加しました。ジョンは、primary/postfix式をより読みやすくするために、f.g.super()を適切にパースできるようにしました(これは、SUPER_CTOR_CALLではなく、METHOD_CALLでした)。o &quot;final &quot;節はルートでした...それを &quot;try &quot;の子にしました。 o Java 1.4のためにアサートのためのものも追加しましたが、後方互換性がないので*コメントアウトしました。バージョン1.20 (2002年10月27日)Terenceは、いくつかの非決定論といくつかの構文的述語を削除するために、John Pybusのものを再構成しました。文法がより厳密になったことに注意してください。Trinary ?:配列名として演算子が動作していなかった:(isBig ? bigDigits:digits)[i];Resin-2.0.5,jive-2.1.1,jdk 1.3.1,Lucene,antlr 2.7.2a4,110k行のjGuruサーバソースのパーサ/ツリーパーサをチェックしました。バージョン 1.21 (2003年10月17日)多くの問題を修正しました。Ray Waldin:java.tree.gのinterfaceBlockにtypeDefinitionを追加しました。 0から始まる浮動小数点の問題を修正しました。Thorsten van Ellenさんは、文字列の中で「\n」が間違って許可されていることに気づいた。CHAR_LITERALを類推して修正した。バージョン 1.21.2 (2003年3月)Matt Quailによるジェネリックをサポートするための変更 (JDK1.5/JSR14による)注意事項:o 我々は &quot;extends &quot;キーワードのみを許可し、&quot;implements &quot;キーワードは許可していません。o 彼のFinkソースベース上で文法をテストしてくれたAlan Eliasenに感謝します バージョン1.22 (2004年7月)Java 1.5言語拡張をサポートするためのMichael Studmanによる変更点 注意点:o 注釈型のサポートを追加しました o boundをサポートするためのMatt Quailのジェネリックスの強化を完了しました</target>
        </trans-unit>
        <trans-unit id="48a1454ddc5de44915d242d03aefb2a12bcfe0fe" translate="yes" xml:space="preserve">
          <source>Terence Parr parrt@magelang.com John Lilley jlilley@empathy.com Scott Stanchfield thetick@magelang.com Markus Mohnen mohnen@informatik.rwth-aachen.de Peter Williams pete.williams@sun.com Allan Jacobs Allan.Jacobs@eng.sun.com Steve Messick messick@redhills.com John Pybus john@pybus.org Version 1.00 December 9, 1997 -- initial release Version 1.01 December 10, 1997 fixed bug in octal def (0..7 not 0..8) Version 1.10 August 1998 (parrt) added tree construction fixed definition of WS,comments for mac,pc,unix newlines added unary plus Version 1.11 (Nov 20, 1998) Added &quot;shutup&quot; option to turn off last ambig warning. Fixed inner class def to allow named class defs as statements synchronized requires compound not simple statement add [] after builtInType DOT class in primaryExpression &quot;const&quot; is reserved but not valid..removed from modifiers Version 1.12 (Feb 2, 1999) Changed LITERAL_xxx to xxx in tree grammar. Updated java.g to use tokens {...} now for 2.6.0 (new feature). Version 1.13 (Apr 23, 1999) Didn't have (stat)? for else clause in tree parser. Didn't gen ASTs for interface extends. Updated tree parser too. Updated to 2.6.0. Version 1.14 (Jun 20, 1999) Allowed final/abstract on local classes. Removed local interfaces from methods Put instanceof precedence where it belongs...in relationalExpr It also had expr not type as arg; fixed it. Missing ! on SEMI in classBlock fixed: (expr) + &quot;string&quot; was parsed incorrectly (+ as unary plus). fixed: didn't like Object[].class in parser or tree parser Version 1.15 (Jun 26, 1999) Screwed up rule with instanceof in it. :( Fixed. Tree parser didn't like (expr).something; fixed. Allowed multiple inheritance in tree grammar. oops. Version 1.16 (August 22, 1999) Extending an interface built a wacky tree: had extra EXTENDS. Tree grammar didn't allow multiple superinterfaces. Tree grammar didn't allow empty var initializer: {} Version 1.17 (October 12, 1999) ESC lexer rule allowed 399 max not 377 max. java.tree.g didn't handle the expression of synchronized statements. Version 1.18 (August 12, 2001) Terence updated to Java 2 Version 1.3 by observing/combining work of Allan Jacobs and Steve Messick. Handles 1.3 src. Summary: o primary didn't include boolean.class kind of thing o constructor calls parsed explicitly now: see explicitConstructorInvocation o add strictfp modifier o missing objBlock after new expression in tree grammar o merged local class definition alternatives, moved after declaration o fixed problem with ClassName.super.field o reordered some alternatives to make things more efficient o long and double constants were not differentiated from int/float o whitespace rule was inefficient: matched only one char o add an examples directory with some nasty 1.3 cases o made Main.java use buffered IO and a Reader for Unicode support o supports UNICODE? Using Unicode charVocabulay makes code file big, but only in the bitsets at the end. I need to make ANTLR generate unicode bitsets more efficiently. Version 1.19 (April 25, 2002) Terence added in nice fixes by John Pybus concerning floating constants and problems with super() calls. John did a nice reorg of the primary/postfix expression stuff to read better and makes f.g.super() parse properly (it was METHOD_CALL not a SUPER_CTOR_CALL). Also: o &quot;finally&quot; clause was a root...made it a child of &quot;try&quot; o Added stuff for asserts too for Java 1.4, but *commented out* as it is not backward compatible. Version 1.20 (October 27, 2002) Terence ended up reorging John Pybus' stuff to remove some nondeterminisms and some syntactic predicates. Note that the grammar is stricter now; e.g., this(...) must be the first statement. Ternary ?: operator wasn't working as array name: (isBig ? bigDigits : digits)[i]; Checked parser/tree parser on source for Resin-2.0.5, jive-2.1.1, jdk 1.3.1, Lucene, antlr 2.7.2a4, and the 110k-line jGuru server source. Version 1.21 (October 17, 2003) Fixed lots of problems including: Ray Waldin: add typeDefinition to interfaceBlock in java.tree.g He found a problem/fix with floating point that start with 0 Ray also fixed problem that (int.class) was not recognized. Thorsten van Ellen noticed that \n are allowed incorrectly in strings. TJP fixed CHAR_LITERAL analogously. Version 1.21.2 (March, 2003) Changes by Matt Quail to support generics (as per JDK1.5/JSR14) Notes: o We only allow the &quot;extends&quot; keyword and not the &quot;implements&quot; keyword, since that's what JSR14 seems to imply. o Thanks to Monty Zukowski for his help on the antlr-interest mail list. o Thanks to Alan Eliasen for testing the grammar over his Fink source base Version 1.22 (July, 2004) Changes by Michael Studman to support Java 1.5 language extensions Notes: o Added support for annotations types o Finished off Matt Quail's generics enhancements to support bound type arguments o Added support for new for statement syntax o Added support for static import syntax o Added support for enum types o Tested against JDK 1.5 source base and source base of jdigraph project o Thanks to Matt Quail for doing the hard part by doing most of the generics work Version 1.22.1 (July 28, 2004) Bug/omission fixes for Java 1.5 language support o Fixed tree structure bug with classOrInterface - thanks to Pieter Vangorpto for spotting this o Fixed bug where incorrect handling of SR and BSR tokens would cause type parameters to be recognised as type arguments. o Enabled type parameters on constructors, annotations on enum constants and package definitions o Fixed problems when parsing if ((char.class.equals(c))) {} - solution by Matt Quail at Cenqua Version 1.22.2 (July 28, 2004) Slight refactoring of Java 1.5 language support o Refactored for/&quot;foreach&quot; productions so that original literal &quot;for&quot; literal is still used but the for sub-clauses vary by token type o Fixed bug where type parameter was not included in generic constructor's branch of AST Version 1.22.3 (August 26, 2004) Bug fixes as identified by Michael Stahl; clean up of tabs/spaces and other refactorings o Fixed typeParameters omission in identPrimary and newStatement o Replaced GT reconciliation code with simple semantic predicate o Adapted enum/assert keyword checking support from Michael Stahl's java15 grammar o Refactored typeDefinition production and field productions to reduce duplication Version 1.22.4 (October 21, 2004) Small bux fixes o Added typeArguments to explicitConstructorInvocation, e.g. new</source>
          <target state="translated">Terence Parr parrt@magelang.com John Lilley jlilley@empathy.com Scott Stanchfield thetick@magelang.com Markus Mohnen mohnen@informatik.rwth-aachen.de Peter Williams pete.williams@sun.com Allan Jacobs Allan.Jacobs@eng.sun.com Steve Messick messick@redhills.com John Pybus john@pybus.org バージョン 1.00 1997 年 12 月 9 日 --初期リリース バージョン 1.01 1997 年 12 月 10 日 00 1997年12月9日 --初期リリース Version 1.01 1997年12月10日 8進数defのバグ修正 (0..7ではなく0..8)Version 1.10 1998年8月 (parrt)ツリー構造の追加 WSの定義の修正、mac,pc,unix用のコメントの修正 改行の追加 単項プラス Version 1.11 (1998年11月20日)最後の曖昧警告を消すための &quot;shutup &quot;オプションを追加しました。内部クラスのdefを修正し、名前付きクラスのdefをステートメントとして許可するようにしました。 同期化されたステートメントは単純なステートメントではなく、複合語を必要とします。java.gを更新し、2.6.0でトークン{...}を使用するようにしました(新機能)。バージョン1.13 (1999年4月23日)ツリーパーサの else 節に (stat)? インタフェース拡張のASTを生成しないようにした。ツリーパーサも更新。2.6.0に更新。Version 1.14 (Jun 20,1999)ローカルクラスのfinal/abstractを許可するようにした。メソッドからローカルインタフェースを削除し、relationalExprの中にinstanceofを優先するようにした。 また、exprの型がargになっていなかったのを修正した。classBlockのSEMIの! (expr)+&quot;文字列 &quot;の解析に失敗していたのを修正 (+を単項プラスにしていた)パーサやツリーパーサでObject[].classが気に入らなかったのを修正した Version 1.15 (Jun 26,1999)instanceofを含むルールをねじ込んでいた。ツリーパーサが (expr).somethingを嫌っていたのを修正。ツリー文法で複数継承を許可するようにした。Version 1.16 (1999年8月22日)インターフェイスの拡張で、EXTENDSを追加した。ツリー文法で複数のスーパーインターフェースを許可しなかった。ツリー文法は空の var initializer を許さない。{}バージョン 1.17 (1999年10月12日)ESC の lexer ルールで 399 max が 377 max ではなく 399 max になった。バージョン 1.18 (2001年8月12日)アラン・ジェイコブスとスティーブ・メシックの作業を観察・統合し、Java 2 バージョン 1.3 に更新。1.3のsrcを扱いました。要約:o プライマリに boolean.class のようなものが含まれていなかった o コンストラクタの呼び出しが明示的に解析されるようになった:explicitConstructorInvocation を参照 o strictfp 修飾子を追加 o ツリー文法の新しい式の後に objBlock が欠けていた o ローカルクラス定義の代替案をマージし、宣言後に移動 o ClassName.super.フィールドの問題を修正 o いくつかの代替案を並べ替えた。 o 物事をより効率的にするためにいくつかの選択肢を並べ替えた o longとdoubleの定数がint/floatと区別されていなかった o 空白のルールは非効率的だった:1つのcharにしかマッチしなかった o いくつかの厄介な1.3のケースを持つexamplesディレクトリを追加した o Main.javaにバッファ付きIOとUnicodeサポートのためのReaderを使用させた o UNICODEをサポートしていますか? Unicode charVocabulayを使うと、コードファイルが大きくなりますが、最後のビットセットだけが大きくなります。ANTLRがもっと効率的にユニコードビットセットを生成できるようにする必要があります。バージョン1.19 (2002年4月25日)Terenceは、John Pybusによる浮動定数とsuper()呼び出しの問題に関する素晴らしい修正を追加しました。ジョンは、primary/postfix式をより読みやすくするために、f.g.super()を適切にパースできるようにしました(これは、SUPER_CTOR_CALLではなく、METHOD_CALLでした)。o &quot;final &quot;節はルートでした...それを &quot;try &quot;の子にしました。 o Java 1.4のためにアサートのためのものも追加しましたが、後方互換性がないので*コメントアウトしました。バージョン1.20 (2002年10月27日)Terenceは、いくつかの非決定論といくつかの構文的述語を削除するために、John Pybusのものを再構成しました。文法がより厳密になったことに注意してください。三項演算子が配列名として動作していなかった:(isBig ? bigDigits:digits)[i];Resin-2.0.5,jive-2.1.1,jdk 1.3.1,Lucene,antlr 2.7.2a4,110k行のjGuruサーバソースのパーサ/ツリーパーサをチェックしました。バージョン 1.21 (2003年10月17日)多くの問題を修正しました。Ray Waldin:java.tree.gのinterfaceBlockにtypeDefinitionを追加しました。 0から始まる浮動小数点の問題を修正しました。Thorsten van Ellenさんは、文字列の中で「\n」が間違って許可されていることに気づいた。CHAR_LITERALを類推して修正した。Version 1.21.2 (2003年3月)Matt Quailによる変更 (JDK1.5/JSR14による)注意点:o 我々は &quot;extends &quot;キーワードのみを許可し、&quot;implements &quot;キーワードは許可していません。 22 (2004年7月)Java 1.5言語拡張をサポートするためのMichael Studmanによる変更点 注意事項:o 注釈型のサポートを追加 o バインド型引数をサポートするためのMatt Quailのジェネリックス拡張を終了 o 文の構文のための新しいサポートを追加 o 静的インポート構文のサポートを追加 o 列挙型のサポートを追加 o JDK 1.5のソースベースとjdのソースベースでテストしました。</target>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes" xml:space="preserve">
          <source>Test</source>
          <target state="translated">Test</target>
        </trans-unit>
        <trans-unit id="22d23f24cd32f09242a53db536a945808560295a" translate="yes" xml:space="preserve">
          <source>Test if a method call is recursive if called within a given method node. Handles static calls as well. Currently known simplifications:</source>
          <target state="translated">与えられたメソッド・ノード内で呼び出された場合に、メソッド呼び出しが再帰的であるかどうかをテストします。静的な呼び出しにも対応しています。現在知られている単純化。</target>
        </trans-unit>
        <trans-unit id="8ceac294319c34b3b08934255a2a46a704ab7aeb" translate="yes" xml:space="preserve">
          <source>Test to determine if a ClassNode is a primitive type.</source>
          <target state="translated">ClassNodeがプリミティブ型であるかどうかを判定します。</target>
        </trans-unit>
        <trans-unit id="9403cb8e3b09787aa434a66b33f9f48728feb7eb" translate="yes" xml:space="preserve">
          <source>Test to determine if a ClassNode is a primitive type. Note: this only works for ClassNodes created using a predefined ClassNode</source>
          <target state="translated">ClassNode がプリミティブ型であるかどうかをテストします。注意:これは、定義済みの ClassNode を使用して作成された ClassNode に対してのみ機能します。</target>
        </trans-unit>
        <trans-unit id="efcab8f5a7c0064e3a92f17428182ce215e6823b" translate="yes" xml:space="preserve">
          <source>Test to determine if a ClassNode is a type belongs to the list of types which are allowed to initialize constants directly in bytecode instead of using &amp;lt;cinit&amp;gt;</source>
          <target state="translated">ClassNodeがタイプであるかどうかをテストして、&amp;lt;cinit&amp;gt;を使用する代わりにバイトコードで定数を直接初期化できるタイプのリストに属しているかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="317d6297ac6952a296eb2ddc257fdae5db4c3acc" translate="yes" xml:space="preserve">
          <source>Tests given value against specified type and changes generics of result.</source>
          <target state="translated">指定された値を指定された型と比較してテストし、結果のジェネリックを変更します。</target>
        </trans-unit>
        <trans-unit id="063eb35b9befe3464dd713e416056ece4259e856" translate="yes" xml:space="preserve">
          <source>Tests given value against specified type and changes generics of result. This is equivalent to: &lt;code&gt;self.filter(it -&amp;gt; it instanceof Type).map(it -&amp;gt; (Type) it)&lt;/code&gt;</source>
          <target state="translated">指定されたタイプに対して指定された値をテストし、結果のジェネリックを変更します。これは、 &lt;code&gt;self.filter(it -&amp;gt; it instanceof Type).map(it -&amp;gt; (Type) it)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="297a33c2b3cbe7da16caded2f3d349714f069bd6" translate="yes" xml:space="preserve">
          <source>Tests if a node is an inner class node, and if it is, then checks if the enclosing method is skipped.</source>
          <target state="translated">ノードが内部クラスのノードであるかどうかをテストし、そうであれば、囲み込みメソッドがスキップされているかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="328ba89482a1987881d000e13d7f357f23c9b1d6" translate="yes" xml:space="preserve">
          <source>Tests if groovydoc is present</source>
          <target state="translated">groovydocが存在するかどうかを調べる</target>
        </trans-unit>
        <trans-unit id="5fb815736873e34454c94811223e0a4810394010" translate="yes" xml:space="preserve">
          <source>Tests if some key maps into the specified value in this table.</source>
          <target state="translated">あるキーがこのテーブルの指定された値にマップされているかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="add0ba96e90c01761791705826395fed0f349dba" translate="yes" xml:space="preserve">
          <source>Tests if some key maps into the specified value in this table. This operation is more expensive than the &lt;code&gt;containsKey&lt;/code&gt; method.</source>
          <target state="translated">一部のキーがこのテーブルの指定された値にマップされているかどうかをテストします。この操作は、 &lt;code&gt;containsKey&lt;/code&gt; メソッドよりもコストがかかります。</target>
        </trans-unit>
        <trans-unit id="1e5b79dd75c69804ac69d0b591a74c9eee88301c" translate="yes" xml:space="preserve">
          <source>Tests if the specified object is a key in this table.</source>
          <target state="translated">指定されたオブジェクトがこのテーブルのキーであるかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="5a3838caffb4fd461c7b1a0ac5808c7ae0ee8b59" translate="yes" xml:space="preserve">
          <source>Tests if this CharSequence ends with any specified suffixes.</source>
          <target state="translated">この CharSequence が指定されたサフィックスで終わるかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="dea9b3965b823036214967b36b37dd1a8b716789" translate="yes" xml:space="preserve">
          <source>Tests if this CharSequence is blank.</source>
          <target state="translated">この CharSequence が空白であるかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="49212f1b5b77fc1ba50dd42e242f061373833989" translate="yes" xml:space="preserve">
          <source>Tests if this CharSequence starts with any specified prefixes.</source>
          <target state="translated">このCharSequenceが指定された接頭辞で始まるかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="86c27bae4e49a7c791a1aae1f78c196c87814064" translate="yes" xml:space="preserve">
          <source>Tests if this QName matches another object.</source>
          <target state="translated">このQNameが他のオブジェクトと一致するかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="0ac416154eaf4d481cc125feddea58871c1256c2" translate="yes" xml:space="preserve">
          <source>Tests this QName for equality with another object.</source>
          <target state="translated">このQNameが別のオブジェクトと等しいかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="a9cf2cef79fdf0aa5b76a94b1b479b909d61f565" translate="yes" xml:space="preserve">
          <source>Tests whether the provided class implements MBean.</source>
          <target state="translated">提供されたクラスが MBean を実装しているかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="5c0a04fe736541754976f6a02d03fdc39f9ee64b" translate="yes" xml:space="preserve">
          <source>Tests whether the provided class implements MBean. It uses the following runes</source>
          <target state="translated">提供されたクラスがMBeanを実装しているかどうかをテストします。以下のルーンを使用します。</target>
        </trans-unit>
        <trans-unit id="04001d250c417c421d5d967c360fc90b35f68b2e" translate="yes" xml:space="preserve">
          <source>Text processing helpers for the interactive command line terminal.</source>
          <target state="translated">対話的なコマンドラインターミナルのためのテキスト処理ヘルパー。</target>
        </trans-unit>
        <trans-unit id="bb34f30402043e44ae32896d840ce387a4b09777" translate="yes" xml:space="preserve">
          <source>That will produce the following output:</source>
          <target state="translated">そうすると、以下のような出力が出てきます。</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="ff58e4d37ea3d39dfbb57350dad837205a5b260f" translate="yes" xml:space="preserve">
          <source>The &quot;Ruby-style&quot; new conversions occur automatically unless the 'auto=false' flag is given when using the annotation. You might do this if you create a new method using meta programming.</source>
          <target state="translated">アノテーションを使用する際に 'auto=false' フラグが与えられていない限り、「Rubyスタイル」の新規変換は自動的に発生します。メタプログラミングを使って新しいメソッドを作成するとこうなるかもしれません。</target>
        </trans-unit>
        <trans-unit id="abaf21fddf45033ab2c9f43f7104088d40814a57" translate="yes" xml:space="preserve">
          <source>The &quot;load&quot; command will add the given file or path to the classpath in this configuration object. If the path does not exist, the path will be ignored.</source>
          <target state="translated">load &quot;コマンドは、指定されたファイルまたはパスをこの設定オブジェクトのクラスパスに追加します。パスが存在しない場合、パスは無視されます。</target>
        </trans-unit>
        <trans-unit id="c60ab597093e621854305c3505f5719eaec2ffc7" translate="yes" xml:space="preserve">
          <source>The &quot;main is&quot; part may only be once in the file. The String afterwards is the name of a class with a main method.</source>
          <target state="translated">main is」の部分はファイル内で1回だけでも構いません。後のStringはメインメソッドを持つクラスの名前です。</target>
        </trans-unit>
        <trans-unit id="12e2ad9f4f40932144714a1460d03531ba22986d" translate="yes" xml:space="preserve">
          <source>The &quot;str&quot; variable is closure shared.</source>
          <target state="translated">変数 &quot;str &quot;はクロージャ共有です。</target>
        </trans-unit>
        <trans-unit id="c847cbc1e1b5981b8a03d4b15cf1bf15d40091e2" translate="yes" xml:space="preserve">
          <source>The &quot;str&quot; variable is closure shared. The variable expression inside the closure references an accessed variable &quot;str&quot; which must have the closure shared flag set.</source>
          <target state="translated">変数 &quot;str&quot; はクロージャ共有です。クロージャ内部の変数式は、アクセスされた変数 &quot;str&quot; を参照し、クロージャ共有フラグがセットされていなければなりません。</target>
        </trans-unit>
        <trans-unit id="39940fc40491b10b14c8b07773b7fb0c04450a6e" translate="yes" xml:space="preserve">
          <source>The &quot;~&quot; character can be used to represent the user's home directory. It cannot fully complete to other users' homes in all operating systems, since java does not provide any way of determining that easily, but it will attempt a simplistic approach.</source>
          <target state="translated">文字 &quot;~&quot; は、ユーザのホーム・ディレクトリを表すために使用することができます。javaは簡単に決定する方法を提供していないので、すべてのオペレーティングシステムにおいて、他のユーザのホームまで完全に網羅することはできませんが、シンプルなアプローチを試みます。</target>
        </trans-unit>
        <trans-unit id="a052786f73a4f92e76bad5f0c863ba3cd193790a" translate="yes" xml:space="preserve">
          <source>The 'alias' command.</source>
          <target state="translated">alias' コマンド。</target>
        </trans-unit>
        <trans-unit id="40024a2623baca4354e986fca884b143a6cc6c9f" translate="yes" xml:space="preserve">
          <source>The 'clear' command.</source>
          <target state="translated">'クリア'コマンド。</target>
        </trans-unit>
        <trans-unit id="3b1cbc87993f31ce6273cefc6205a16b17b91a61" translate="yes" xml:space="preserve">
          <source>The 'display' command. Displays the current buffer (e.g. while method declaration was not finished).</source>
          <target state="translated">'display' コマンドです。現在のバッファを表示します(メソッド宣言が終了していない間など)。</target>
        </trans-unit>
        <trans-unit id="49f40f12151358c7d843d53687ed095e487a154e" translate="yes" xml:space="preserve">
          <source>The 'doc' command.</source>
          <target state="translated">'doc' コマンド。</target>
        </trans-unit>
        <trans-unit id="bc3ffba03d00f8c7b85d7091a061031e0b1eb2b0" translate="yes" xml:space="preserve">
          <source>The 'edit' command. Opens Editor to write into the current Buffer.</source>
          <target state="translated">edit' コマンド。エディタを開き、現在のバッファに書き込む。</target>
        </trans-unit>
        <trans-unit id="f3f7c1cec23633cc0cfaa9cb09f02911a1e9d149" translate="yes" xml:space="preserve">
          <source>The 'exit' command.</source>
          <target state="translated">exit」コマンド。</target>
        </trans-unit>
        <trans-unit id="046ba041acd9691591b162277d1a0f7106c9bb51" translate="yes" xml:space="preserve">
          <source>The 'forClass' annotation attribute for the &lt;code&gt;@Builder&lt;/code&gt; transform isn't applicable for this strategy. The 'useSetters' annotation attribute for the &lt;code&gt;@Builder&lt;/code&gt; transform is ignored by this strategy which always uses setters.</source>
          <target state="translated">&lt;code&gt;@Builder&lt;/code&gt; トランスフォームの「forClass」アノテーション属性は、この戦略には適用できません。 &lt;code&gt;@Builder&lt;/code&gt; トランスフォームの「useSetters」アノテーション属性は、常にセッターを使用するこのストラテジーでは無視されます。</target>
        </trans-unit>
        <trans-unit id="45835faea7523426faaaf8fa1e49229a32a26b8c" translate="yes" xml:space="preserve">
          <source>The 'grab' command.</source>
          <target state="translated">grab」コマンド。</target>
        </trans-unit>
        <trans-unit id="205fbf3975b12113a5c8bd8232bfa1665e8d1f5c" translate="yes" xml:space="preserve">
          <source>The 'help' command.</source>
          <target state="translated">help' コマンド。</target>
        </trans-unit>
        <trans-unit id="20ec27c9e0ddbd2a48fb1d21fc610eca2f90fc72" translate="yes" xml:space="preserve">
          <source>The 'history' command.</source>
          <target state="translated">'history' コマンド。</target>
        </trans-unit>
        <trans-unit id="2d489d33aa47e12f822416973b70f3e5da0b4497" translate="yes" xml:space="preserve">
          <source>The 'import' command.</source>
          <target state="translated">import」コマンド。</target>
        </trans-unit>
        <trans-unit id="7e8ac89c1c05e64fcbd55e0b499745677ba943e0" translate="yes" xml:space="preserve">
          <source>The 'inspect' command.</source>
          <target state="translated">inspect' コマンド。</target>
        </trans-unit>
        <trans-unit id="551c33d159644a8f5ef1c6ac388343537009ae2b" translate="yes" xml:space="preserve">
          <source>The 'load' command.</source>
          <target state="translated">load」コマンド。</target>
        </trans-unit>
        <trans-unit id="b6bc21ba2f0a2893871757da3c856326ee9de094" translate="yes" xml:space="preserve">
          <source>The 'purge' command.</source>
          <target state="translated">パージ」コマンド。</target>
        </trans-unit>
        <trans-unit id="ba59fbb5346c40fbb6302c6187328e618a3da7ed" translate="yes" xml:space="preserve">
          <source>The 'record' command.</source>
          <target state="translated">'record' コマンド。</target>
        </trans-unit>
        <trans-unit id="7c3791604975b9d1fb30c9a2bd534192e00088a0" translate="yes" xml:space="preserve">
          <source>The 'register' command. Registers a class as a new groovysh command. Requires the command to have matching constructors (shell) or (shell, name, alias).</source>
          <target state="translated">register' コマンドです。新しいgroovyshコマンドとしてクラスを登録します。コマンドには、一致するコンストラクタ (シェル)または (シェル、名前、エイリアス)が必要です。</target>
        </trans-unit>
        <trans-unit id="e2c14b48e8d21dde57913f41162e2eb4486751ed" translate="yes" xml:space="preserve">
          <source>The 'save' command.</source>
          <target state="translated">save」コマンド。</target>
        </trans-unit>
        <trans-unit id="9a925ff93968b41e2b76e842b170f7ec6c6d9eb0" translate="yes" xml:space="preserve">
          <source>The 'set' command, used to set preferences.</source>
          <target state="translated">set' コマンドは、環境設定を設定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="f931e78f8e44eb712f74c86f1afb6c2a241148eb" translate="yes" xml:space="preserve">
          <source>The 'shadow' command.</source>
          <target state="translated">'shadow'コマンド。</target>
        </trans-unit>
        <trans-unit id="5a09c2bfc8378532d9a0032fb6ba7ae84db4fe0b" translate="yes" xml:space="preserve">
          <source>The 'show' command.</source>
          <target state="translated">show' コマンド。</target>
        </trans-unit>
        <trans-unit id="a59faad4653d2f4a8eeb438184148004e01411e2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;closure#resolveStrategy&quot;&gt;Closure.resolveStrategy&lt;/a&gt; used by the closure.</source>
          <target state="translated">&lt;a href=&quot;closure#resolveStrategy&quot;&gt;Closure.resolveStrategyは&lt;/a&gt;閉鎖によって使用しました。</target>
        </trans-unit>
        <trans-unit id="4bb77833997045b8a169e0e940948f5de47f4a41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@AutoExternalize&lt;/code&gt; transform is implemented as a combination of the &lt;code&gt;@ExternalizeMethods&lt;/code&gt; and &lt;code&gt;@ExternalizeVerifier&lt;/code&gt; transforms.</source>
          <target state="translated">&lt;code&gt;@AutoExternalize&lt;/code&gt; は、変換の組み合わせとして実装され &lt;code&gt;@ExternalizeMethods&lt;/code&gt; と &lt;code&gt;@ExternalizeVerifier&lt;/code&gt; 変換。</target>
        </trans-unit>
        <trans-unit id="45203388f4746d69eda07f4e8e18ce996ab3c42d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@Builder&lt;/code&gt; AST transformation is used to help write classes that can be created using &lt;em&gt;fluent&lt;/em&gt; api calls. The transform supports multiple building strategies to cover a range of cases and there are a number of configuration options to customize the building process. In addition, a number of annotation attributes let you customise the building process. Not all annotation attributes are supported by all strategies. See the individual strategy documentation for more details. If you're an AST hacker, you can also define your own strategy class. The following strategies are bundled with Groovy:</source>
          <target state="translated">&lt;code&gt;@Builder&lt;/code&gt; AST変換を使用して作成することができ、ヘルプ・ライト・クラスに使用されている&lt;em&gt;流暢&lt;/em&gt;API呼び出しを。トランスフォームは、さまざまなケースをカバーするための複数の構築戦略をサポートし、構築プロセスをカスタマイズするための構成オプションがいくつかあります。さらに、いくつかの注釈属性を使用して、構築プロセスをカスタマイズできます。すべての注釈属性がすべての戦略でサポートされているわけではありません。詳細については、個々の戦略のドキュメントを参照してください。 ASTハッカーの場合は、独自の戦略クラスを定義することもできます。以下の戦略がGroovyにバンドルされています。</target>
        </trans-unit>
        <trans-unit id="294af73d6b365f57dad5fbc1d213db079ecf007c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@Canonical&lt;/code&gt; meta-annotation combines the &lt;code&gt;@EqualsAndHashCode&lt;/code&gt;, &lt;code&gt;@ToString&lt;/code&gt; and &lt;code&gt;@TupleConstructor&lt;/code&gt; annotations. It is used to assist in the creation of mutable classes. It instructs the compiler to execute AST transformations which add positional constructors, equals, hashCode and a pretty print toString to your class.</source>
          <target state="translated">&lt;code&gt;@Canonical&lt;/code&gt; メタアノテーションは組み合わせ &lt;code&gt;@EqualsAndHashCode&lt;/code&gt; を、 &lt;code&gt;@ToString&lt;/code&gt; と &lt;code&gt;@TupleConstructor&lt;/code&gt; 注釈。可変クラスの作成を支援するために使用されます。これは、位置コンストラクター、equals、hashCode、およびクラスにプリティプリントtoStringを追加するAST変換を実行するようにコンパイラーに指示します。</target>
        </trans-unit>
        <trans-unit id="e0722e38b1652aaa50007eeaae20094f5d8fdb78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@EqualsAndHashCode&lt;/code&gt; annotation instructs the compiler to execute an AST transformation which adds the necessary equals and hashCode methods to the class.</source>
          <target state="translated">&lt;code&gt;@EqualsAndHashCode&lt;/code&gt; のアノテーションは、クラスに必要等しいとhashCodeメソッドを追加AST変換を実行するようにコンパイラに指示します。</target>
        </trans-unit>
        <trans-unit id="256900570749f03c52bd249de8a600a89e77be38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@Immutable&lt;/code&gt; meta-annotation corresponds to adding the following annotations: &lt;a href=&quot;tostring&quot;&gt;ToString&lt;/a&gt;, &lt;a href=&quot;equalsandhashcode&quot;&gt;EqualsAndHashCode&lt;/a&gt;, &lt;a href=&quot;immutablebase&quot;&gt;ImmutableBase&lt;/a&gt;, &lt;a href=&quot;immutableoptions&quot;&gt;ImmutableOptions&lt;/a&gt;, &lt;a href=&quot;propertyoptions&quot;&gt;PropertyOptions&lt;/a&gt;, &lt;a href=&quot;tupleconstructor&quot;&gt;TupleConstructor&lt;/a&gt;, &lt;a href=&quot;mapconstructor&quot;&gt;MapConstructor&lt;/a&gt; and &lt;a href=&quot;knownimmutable&quot;&gt;KnownImmutable&lt;/a&gt;. Together these annotations instruct the compiler to execute the necessary transformations to add the necessary getters, constructors, equals, hashCode and other helper methods that are typically written when creating immutable classes with the defined properties.</source>
          <target state="translated">&lt;code&gt;@Immutable&lt;/code&gt; ：以下の注釈の追加にメタアノテーション対応&lt;a href=&quot;tostring&quot;&gt;のToString&lt;/a&gt;、&lt;a href=&quot;equalsandhashcode&quot;&gt;EqualsAndHashCode&lt;/a&gt;、&lt;a href=&quot;immutablebase&quot;&gt;ImmutableBase&lt;/a&gt;、&lt;a href=&quot;immutableoptions&quot;&gt;ImmutableOptions&lt;/a&gt;、&lt;a href=&quot;propertyoptions&quot;&gt;PropertyOptions&lt;/a&gt;、&lt;a href=&quot;tupleconstructor&quot;&gt;TupleConstructor&lt;/a&gt;、&lt;a href=&quot;mapconstructor&quot;&gt;MapConstructor&lt;/a&gt;と&lt;a href=&quot;knownimmutable&quot;&gt;KnownImmutableを&lt;/a&gt;。これらのアノテーションを組み合わせて、必要な変換を実行し、必要なゲッター、コンストラクター、equals、hashCode、および定義されたプロパティを持つ不変クラスを作成するときに通常作成されるその他のヘルパーメソッドを追加するようコンパイラーに指示します。</target>
        </trans-unit>
        <trans-unit id="9b3e01603be93f6ac5cc7246179a9d14cdfcb6f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@Immutable&lt;/code&gt; transformation in earlier versions of Groovy tried to be smart in the case of an immutable class with a single HashMap property, the supplied Map constructor tried to be compatible with both expected tuple behavior and expected named-argument behavior by peeking into the supplied map and guessing as to which approach might be applicable. Recent versions of Groovy now allow both &lt;code&gt;@TupleConstructor&lt;/code&gt; and &lt;code&gt;@MapConstructor&lt;/code&gt; annotations to co-exist which provide's a more flexible solution to this problem. While more flexible, the new approach isn't fully compatible with the previous approach. If for some reason you need the old behavior, you can try this property handler. Some features of the new approach won't be available to you.</source>
          <target state="translated">以前のバージョンのGroovyの &lt;code&gt;@Immutable&lt;/code&gt; 変換は、単一のHashMapプロパティを持つ不変クラスの場合にスマートにしようとしました。提供されたマップコンストラクターは、提供されたものを覗き込むことによって、期待されるタプル動作と期待される名前付き引数動作の両方と互換性を持たせようとしました。マップし、どのアプローチが適用可能かについて推測します。 Groovyの最近のバージョンでは、 &lt;code&gt;@MapConstructor&lt;/code&gt; アノテーションと@MapConstructorアノテーションの両方を &lt;code&gt;@TupleConstructor&lt;/code&gt; できるようになりました。これにより、この問題に対するより柔軟なソリューションが提供されます。新しいアプローチはより柔軟ですが、以前のアプローチと完全には互換性がありません。何らかの理由で古い動作が必要な場合は、このプロパティハンドラーを試すことができます。新しいアプローチの一部の機能は利用できません。</target>
        </trans-unit>
        <trans-unit id="8038db35abbd1b507d6ae9f58cbd615d327ce3a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@ImmutableBase&lt;/code&gt; annotation supports customization using &lt;code&gt;@PropertyOptions&lt;/code&gt; which allows a custom property handler to be defined. This is most typically used behind the scenes by the &lt;code&gt;@Immutable&lt;/code&gt; meta-annotation but you can also define your own handler. If a custom handler is present, it will determine the code generated for the getters and setters of any property.</source>
          <target state="translated">&lt;code&gt;@ImmutableBase&lt;/code&gt; 注釈支持体は、使用してカスタマイズ &lt;code&gt;@PropertyOptions&lt;/code&gt; カスタムプロパティハンドラを定義することができます。これは通常、 &lt;code&gt;@Immutable&lt;/code&gt; メタアノテーションによってバックグラウンドで使用されますが、独自のハンドラーを定義することもできます。カスタムハンドラーが存在する場合、任意のプロパティのゲッターとセッター用に生成されたコードを決定します。</target>
        </trans-unit>
        <trans-unit id="d660a9beb8629948ffda2454e012fd620ba319c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@MapConstructor&lt;/code&gt; annotation generates a public constructor unless an applicable &lt;a href=&quot;visibilityoptions&quot;&gt;VisibilityOptions&lt;/a&gt; annotation is also present. It can be useful to change the visibility if you want to also create a builder or provide your own static factory method for object creation. You can make the constructor private and access it from the builder or your factory method. (Note: you'll probably want to use &lt;code&gt;@CompileStatic&lt;/code&gt; in conjunction with such an approach since dynamic Groovy currently gives the ability to access even private constructors.)</source>
          <target state="translated">&lt;code&gt;@MapConstructor&lt;/code&gt; の該当しない限り、注釈はpublicコンストラクタを生成&lt;a href=&quot;visibilityoptions&quot;&gt;VisibilityOptionsの&lt;/a&gt;注釈も存在しています。ビルダーも作成したり、オブジェクト作成用の独自の静的ファクトリメソッドを提供したりする場合は、可視性を変更すると便利です。コンストラクターをプライベートにして、ビルダーまたはファクトリメソッドからアクセスできます。（注：動的Groovyは現在、プライベートコンストラクターにもアクセスできるため、このようなアプローチと組み合わせて &lt;code&gt;@CompileStatic&lt;/code&gt; を使用することをお勧めします。）</target>
        </trans-unit>
        <trans-unit id="0c060668381620633145cbb9ddc60d4b01c27127" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@MapConstructor&lt;/code&gt; annotation instructs the compiler to execute an AST transformation which adds the necessary constructor method to your class.</source>
          <target state="translated">&lt;code&gt;@MapConstructor&lt;/code&gt; の注釈は、あなたのクラスに必要なコンストラクタメソッドを追加するAST変換を実行するようにコンパイラに指示します。</target>
        </trans-unit>
        <trans-unit id="5d30fb89bfdef972798dad631327fddec3510e19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@MapConstructor&lt;/code&gt; annotation supports customization using &lt;code&gt;@PropertyOptions&lt;/code&gt; which allows a custom property handler to be defined. This is most typically used behind the scenes by the &lt;code&gt;@Immutable&lt;/code&gt; meta-annotation but you can also define your own handler. If a custom handler is present, it will determine the code generated when initializing any property (or field).</source>
          <target state="translated">&lt;code&gt;@MapConstructor&lt;/code&gt; の注釈には、使用してカスタマイズをサポートしてい &lt;code&gt;@PropertyOptions&lt;/code&gt; カスタムプロパティハンドラを定義することができます。これは通常、 &lt;code&gt;@Immutable&lt;/code&gt; メタアノテーションによってバックグラウンドで使用されますが、独自のハンドラーを定義することもできます。カスタムハンドラーが存在する場合、プロパティ（またはフィールド）を初期化するときに生成されるコードを決定します。</target>
        </trans-unit>
        <trans-unit id="7a6deaa7aa228067bb49f0cfb27c83f7ba76b6ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@TupleConstructor&lt;/code&gt; annotation generates a public constructor unless an applicable &lt;a href=&quot;visibilityoptions&quot;&gt;VisibilityOptions&lt;/a&gt; annotation is also present. It can be useful to change the visibility if you want to also create a builder or provide your own static factory method for object creation. You can make the constructor private and access it from the builder or your factory method. (Note: you'll probably want to use &lt;code&gt;@CompileStatic&lt;/code&gt; in conjunction with such an approach since dynamic Groovy currently gives the ability to access even private constructors.)</source>
          <target state="translated">&lt;code&gt;@TupleConstructor&lt;/code&gt; の該当しない限り、注釈はpublicコンストラクタを生成&lt;a href=&quot;visibilityoptions&quot;&gt;VisibilityOptionsの&lt;/a&gt;注釈も存在しています。ビルダーも作成したり、オブジェクト作成用の独自の静的ファクトリメソッドを提供したりする場合は、可視性を変更すると便利です。コンストラクターをプライベートにして、ビルダーまたはファクトリメソッドからアクセスできます。（注：動的Groovyは現在、プライベートコンストラクターにもアクセスできるため、このようなアプローチと組み合わせて &lt;code&gt;@CompileStatic&lt;/code&gt; を使用することをお勧めします。）</target>
        </trans-unit>
        <trans-unit id="7629884aa207cf4bfc51ba4ddfb30667cd6e46a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@TupleConstructor&lt;/code&gt; annotation instructs the compiler to execute an AST transformation which adds the necessary constructor method to your class.</source>
          <target state="translated">&lt;code&gt;@TupleConstructor&lt;/code&gt; の注釈は、あなたのクラスに必要なコンストラクタメソッドを追加するAST変換を実行するようにコンパイラに指示します。</target>
        </trans-unit>
        <trans-unit id="e8727009d134e37d65711ed260dc01f84627258d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@TupleConstructor&lt;/code&gt; annotation supports customization using &lt;code&gt;@PropertyOptions&lt;/code&gt; which allows a custom property handler to be defined. This is most typically used behind the scenes by the &lt;code&gt;@Immutable&lt;/code&gt; meta-annotation but you can also define your own handler. If a custom handler is present, it will determine the code generated when initializing any property (or field).</source>
          <target state="translated">&lt;code&gt;@TupleConstructor&lt;/code&gt; の注釈には、使用してカスタマイズをサポートしてい &lt;code&gt;@PropertyOptions&lt;/code&gt; カスタムプロパティハンドラを定義することができます。これは通常、 &lt;code&gt;@Immutable&lt;/code&gt; メタアノテーションによってバックグラウンドで使用されますが、独自のハンドラーを定義することもできます。カスタムハンドラーが存在する場合、プロパティ（またはフィールド）を初期化するときに生成されるコードを決定します。</target>
        </trans-unit>
        <trans-unit id="2c9da3c536494482e7240624f6308d8ee06c6f86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LineColumnReader&lt;/code&gt; is an extension to &lt;code&gt;BufferedReader&lt;/code&gt; that keeps track of the line and column information of where the cursor is.</source>
          <target state="translated">&lt;code&gt;LineColumnReader&lt;/code&gt; はに拡張され &lt;code&gt;BufferedReader&lt;/code&gt; のカーソルがどこにあるの行及び列情報を追跡します。</target>
        </trans-unit>
        <trans-unit id="b12d0acf730deb6bf7ba2f89201e89542b2f1843" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equals()&lt;/code&gt; method compares the values of the individual properties (and optionally fields) of the class. It can also optionally call equals on the super class. Two different equals method implementations are supported both of which support the equals contract outlined in the javadoc for &lt;code&gt;java.lang.Object&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;equals()&lt;/code&gt; メソッドは、クラスの個々のプロパティ（および必要に応じてフィールド）の値を比較します。オプションで、スーパークラスでequalsを呼び出すこともできます。2つの異なるequalsメソッドの実装がサポートされており、どちらもjavadoc forjava.lang.Objectで概説されているequalsコントラクトをサポートしてい &lt;code&gt;java.lang.Object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="830e28331ecb056779521290049a9d298a9e660d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hashCode()&lt;/code&gt; method is calculated using Groovy's &lt;code&gt;HashCodeHelper&lt;/code&gt; class which implements an algorithm similar to the one outlined in the book &lt;em&gt;Effective Java&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;hashCode()&lt;/code&gt; メソッドは、Groovyの使用して計算される &lt;code&gt;HashCodeHelper&lt;/code&gt; の本の中で概説されたものと同様のアルゴリズムを実装するクラス&lt;em&gt;効果的なJavaの&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="6e63d7611eab2d457e68aebe6268ff6c3ef50435" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;node&lt;/code&gt; variable refers to the AST node where the AST test annotation is put. In the previous example, it means that</source>
          <target state="translated">&lt;code&gt;node&lt;/code&gt; 変数は、AST試験注釈が入れられるASTノードを指します。前の例では、それは</target>
        </trans-unit>
        <trans-unit id="80313a71d12f637fc87968a63153d3f3e87a0de9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefix&lt;/code&gt; annotation attribute can be used to create setters with a different naming convention, e.g. with the prefix set to the empty String, you would use your setters as follows:</source>
          <target state="translated">&lt;code&gt;prefix&lt;/code&gt; 空の文字列にプレフィックスが設定された属性が異なる命名規則とセッターを作成するために使用することができ、注釈、例えば以下のように、あなたはあなたのセッターを使用します。</target>
        </trans-unit>
        <trans-unit id="62dadbb05ea9452a3f8698171e4c3c5adf50c815" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefix&lt;/code&gt; annotation attribute can be used to create setters with a different naming convention. The default is the empty string but you could change that to &quot;set&quot; as follows:</source>
          <target state="translated">&lt;code&gt;prefix&lt;/code&gt; 注釈属性が異なる命名規則とセッターを作成するために使用することができます。デフォルトは空の文字列ですが、次のように「set」に変更できます。</target>
        </trans-unit>
        <trans-unit id="c7e7da8f8ac1f58f269f14f2223d6021171e84d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefix&lt;/code&gt; annotation attribute, which defaults to the empty String for this strategy, can be used to create setters with a different naming convention, e.g. with the &lt;code&gt;prefix&lt;/code&gt; changed to 'set', you would use your setters as follows:</source>
          <target state="translated">&lt;code&gt;prefix&lt;/code&gt; を持つなど、この戦略のために空の文字列にデフォルトは、異なる命名規則とセッターを作成するために使用することができ、アノテーション属性、 &lt;code&gt;prefix&lt;/code&gt; 次のように「SET」に変更するには、あなたのセッターを使用します。</target>
        </trans-unit>
        <trans-unit id="530333b1471c9924eaa79d5f2383b3a99efb7aa0" translate="yes" xml:space="preserve">
          <source>The ASM api version to use when loading/parsing classes, and generating proxy adapter classes.</source>
          <target state="translated">クラスのロード/パース、プロキシアダプタクラスの生成時に使用するASM apiのバージョン。</target>
        </trans-unit>
        <trans-unit id="eacac5260137714b68dfd32df8448636a7cd8c2e" translate="yes" xml:space="preserve">
          <source>The AST transformations state data.</source>
          <target state="translated">AST変換の状態データです。</target>
        </trans-unit>
        <trans-unit id="bc5bdb44ecff5ba8f2ac6aeacb93c47323537a4b" translate="yes" xml:space="preserve">
          <source>The AnnotationCollector can be used to define aliases for groups of annotations. The Alias needs to be a class or annotation annotated with AnnotationCollector, otherwise nothing is required. The alias will be replaced on the AST level and will never appear in later. Any members of the class or annotation will be ignored, but could be used by a custom processor. Annotation arguments are mapped to the aliased annotations if existing. Should the default processor not be able to map one of the arguments and error will be given. Is this not wished or if you want a different mapping a custom processor has to be used. There are two ways of using the alias. The first way is by providing the annotations as list/array:</source>
          <target state="translated">AnnotationCollector は、アノテーションのグループのエイリアスを定義するために使用することができます。エイリアスは、AnnotationCollectorでアノテーションされたクラスまたはアノテーションである必要があります。エイリアスはASTレベルで置き換えられ、それ以降に表示されることはありません。クラスやアノテーションのメンバは無視されますが、カスタムプロセッサで使用することができます。アノテーションの引数は、エイリアスされたアノテーションが存在する場合には、エイリアスされたアノテーションにマップされます。デフォルトのプロセッサが引数のいずれかをマッピングできない場合は、エラーが発生します。これを望まない場合や、別のマッピングが必要な場合は、カスタムプロセッサを使用しなければなりません。エイリアスを使うには2つの方法があります。最初の方法は、アノテーションをリスト/配列として提供する方法です。</target>
        </trans-unit>
        <trans-unit id="5db2cc4cf1581ed432c22532522a07af4f3dc21e" translate="yes" xml:space="preserve">
          <source>The AstBuilder &quot;from code&quot; approach is used with a single Closure parameter. This transformation converts the ClosureExpression back into source code and rewrites the AST so that the &quot;from string&quot; builder is invoked on the source. In order for this to work, the closure source must be given a goto label. It is the &quot;from string&quot; approach's responsibility to remove the BlockStatement created by the label.</source>
          <target state="translated">AstBuilderの「文字列から」アプローチは、1つのClosureパラメータで使用されます。この変換は、ClosureExpressionをソースコードに変換し、&quot;from string &quot;ビルダーがソース上で呼び出されるようにASTを書き換えます。この変換を行うためには、クロージャのソースにgotoラベルを与えなければなりません。ラベルによって生成されたBlockStatementを削除するのは、&quot;from string &quot;アプローチの責任です。</target>
        </trans-unit>
        <trans-unit id="ba44980ebcb878656a29fe22ac4f96efa9fe21fd" translate="yes" xml:space="preserve">
          <source>The AstBuilder provides several ways to build an abstract syntax tree (AST) of Groovy code. You can convert a String into AST using the buildFromString method. You can convert code into AST using the buildFromCode method. You can use the AST DSL with the buildFromSpec method. For more information, see the resources on the Groovy wiki pages.</source>
          <target state="translated">AstBuilderには、Groovyコードの抽象構文ツリー(AST)を構築するためのいくつかの方法があります。文字列をASTに変換するには、buildFromStringメソッドを使用します。コードをASTに変換するには、buildFromCodeメソッドを使用します。buildFromSpecメソッドを使用すると、AST DSLを使用することができます。詳細については、Groovy wikiページのリソースを参照してください。</target>
        </trans-unit>
        <trans-unit id="dab7488dc458ebefa3af6c5f3c52ee882f8cbada" translate="yes" xml:space="preserve">
          <source>The Boolean value</source>
          <target state="translated">ブール値</target>
        </trans-unit>
        <trans-unit id="2c8b0170c089fc67b7592e8b879b1010a6efb451" translate="yes" xml:space="preserve">
          <source>The Class of the caller</source>
          <target state="translated">呼び出し元のクラス</target>
        </trans-unit>
        <trans-unit id="ea5ebdb121347917420d0529564950593f68fffa" translate="yes" xml:space="preserve">
          <source>The Class of the matched caller, or null if there aren't enough stackframes to satisfy matchLevel</source>
          <target state="translated">マッチしたコール元のクラス、あるいは matchLevel を満たすのに十分なスタックフレームがない場合は null。</target>
        </trans-unit>
        <trans-unit id="95afa2b448d534d00f17faabf8897f23ba200f8d" translate="yes" xml:space="preserve">
          <source>The ClassLoader to use during processing</source>
          <target state="translated">処理中に使用する ClassLoader</target>
        </trans-unit>
        <trans-unit id="3b325fd56fcb36df68df5c37735a434ab8c3e5a2" translate="yes" xml:space="preserve">
          <source>The Closure and Class MetaClasses are not replaceable.</source>
          <target state="translated">クロージャとクラスメタクラスは入れ替えができません。</target>
        </trans-unit>
        <trans-unit id="1f74d6daad2d2751944e6a7ff0057497d3e5b83e" translate="yes" xml:space="preserve">
          <source>The CompilationUnit collects all compilation data as it is generated by the compiler system. You can use this object to add additional source units to the compilation, or force the compilation to be run again (to affect only the deltas).</source>
          <target state="translated">CompilationUnit は、コンパイラシステムによって生成されたすべてのコンパイルデータを収集します。このオブジェクトを使用して、コンパイルにソースユニットを追加したり、コンパイルを強制的に再実行したりすることができます (デルタのみに影響を与えます)。</target>
        </trans-unit>
        <trans-unit id="9ae7fb01344a3870d231b2e7c5bef8b061d095f8" translate="yes" xml:space="preserve">
          <source>The ConfigObject instance</source>
          <target state="translated">ConfigObject インスタンス</target>
        </trans-unit>
        <trans-unit id="86d6344f85a9a90bbe2e3c76743d0dab1644efa3" translate="yes" xml:space="preserve">
          <source>The GPathResult instance created by consuming a stream of SAX events Note if one of the parse methods has been called then this returns null Note if this is called more than once all calls after the first will return null</source>
          <target state="translated">SAX イベントのストリームを消費して作成された GPathResult インスタンス 注意 1 つのパース・メソッドが呼び出された場合、これは null を返す 注意 1 回以上呼び出された場合、最初の呼び出し以降はすべて null を返す</target>
        </trans-unit>
        <trans-unit id="a1403f3f787db7ae0a251e57befceef1c173042a" translate="yes" xml:space="preserve">
          <source>The Generated annotation is used to mark members that have been generated.</source>
          <target state="translated">Generated アノテーションは、生成されたメンバーをマークするために使用されます。</target>
        </trans-unit>
        <trans-unit id="fee67b5a59c37f5eb850f04f216505b0ee5359f8" translate="yes" xml:space="preserve">
          <source>The Groovyc Ant task is frequently used in the context of a build system that knows the complete list of source files to be compiled. In such a context, it is wasteful for the Groovy compiler to go searching the classpath when looking for source files and hence by default the Groovyc Ant task calls the compiler in a special mode with such searching turned off. If you wish the compiler to search for source files then you need to set this flag to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Groovyc Antタスクは、コンパイルされるソースファイルの完全なリストを知っているビルドシステムのコンテキストで頻繁に使用されます。このような状況では、Groovyコンパイラがソースファイルを検索するときにクラスパスを検索するのは無駄であるため、デフォルトでは、GroovycAntタスクはそのような検索をオフにして特別なモードでコンパイラを呼び出します。コンパイラでソースファイルを検索する場合は、このフラグを &lt;code&gt;true&lt;/code&gt; に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="8a572e6d63360dc8ed46fe486e95453148a82ab3" translate="yes" xml:space="preserve">
          <source>The I/O container for the command to spit stuff out.</source>
          <target state="translated">物を吐き出すコマンドのI/Oコンテナ。</target>
        </trans-unit>
        <trans-unit id="9eac464c463300041620f1317542a0b36de1c9f1" translate="yes" xml:space="preserve">
          <source>The Inspector provides a unified access to an object's information that can be determined by introspection.</source>
          <target state="translated">インスペクタは、イントロスペクションによって決定される対象物の情報に統一的にアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="89049d18696c55626bdc93e465d8d30137733d5c" translate="yes" xml:space="preserve">
          <source>The Internal annotation is used to mark members that are internal.</source>
          <target state="translated">内部アノテーションは、内部であるメンバーをマークするために使用されます。</target>
        </trans-unit>
        <trans-unit id="9590c78dcd06317a3989b6bc16c6e0ac5dd7bc8d" translate="yes" xml:space="preserve">
          <source>The JDBC data type.</source>
          <target state="translated">JDBC データ型。</target>
        </trans-unit>
        <trans-unit id="bf1f48ddb64e5b808db4de3d772bd99c631f4770" translate="yes" xml:space="preserve">
          <source>The JDK Home to use when forked.</source>
          <target state="translated">フォークした時に使うJDK Home。</target>
        </trans-unit>
        <trans-unit id="a3cddd13c50bb85bd71529142341665bd0b10ae0" translate="yes" xml:space="preserve">
          <source>The JDK Home to use when forked. Ignored if &quot;executable&quot; is specified.</source>
          <target state="translated">フォーク時に使用するJDKホーム。実行可能 &quot;が指定されている場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="73a1a508d0e588f700050a09964ef490424aaf02" translate="yes" xml:space="preserve">
          <source>The JSON builder implements the &lt;code&gt;Writable&lt;/code&gt; interface, so that you can have the builder serialize itself the JSON payload to a writer.</source>
          <target state="translated">JSONビルダーは &lt;code&gt;Writable&lt;/code&gt; インターフェースを実装しているため、ビルダーにJSONペイロードをライターにシリアル化させることができます。</target>
        </trans-unit>
        <trans-unit id="c4210607df0d96c450f5b18b723cad635f89b1b1" translate="yes" xml:space="preserve">
          <source>The Java class enhanced by this MetaClass</source>
          <target state="translated">このMetaClassによって強化されたJavaクラス</target>
        </trans-unit>
        <trans-unit id="1ac137cd80780692f3c909dfbfd354042b337fa0" translate="yes" xml:space="preserve">
          <source>The JavaBean class should have a no-args constructor.</source>
          <target state="translated">JavaBeanクラスは、引数なしのコンストラクタを持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="dd439d1414bf7dc6b93f52c0dc2f310499844e0e" translate="yes" xml:space="preserve">
          <source>The JmxBeanInfoManager creates fully-described model mbean info object using the underlying meta map. The MBeanInfo object is used to provide description about the actual exported MBean instance.</source>
          <target state="translated">JmxBeanInfoManager は、基礎となるメタマップを使用して、完全に記述されたモデルの mbean info オブジェクトを作成します。MBeanInfo オブジェクトは、実際にエクスポートされた MBean インスタンスの説明を提供するために使用されます。</target>
        </trans-unit>
        <trans-unit id="872c671635593eaadcddb9effd4d01a4ea959ded" translate="yes" xml:space="preserve">
          <source>The JmxBuilderModelMBean is the MBean class that proxies exported POGO/POJO inside the MBeanServer. When JmxBuilder exports an object instance, an instance of this class is created and exported inside the MBeanServer.</source>
          <target state="translated">JmxBuilderModelMBean は、エクスポートした POGO/POJO を MBeanServer 内でプロキシする MBean クラスです。JmxBuilderがオブジェクトのインスタンスをエクスポートすると、このクラスのインスタンスが作成され、MBeanServer内にエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="f935c6274b761a9b967dde493b59c201774e5020" translate="yes" xml:space="preserve">
          <source>The JmxEventEmitter is a JMX Broadcaster class that is used to send generic events on the MBeanServer's event bus. It is used by the Emitter node () to send event to registered listeners.</source>
          <target state="translated">JmxEventEmitterは、MBeanServerのイベントバス上で一般的なイベントを送信するために使用されるJMX Broadcasterクラスです。これは、登録されたリスナーにイベントを送信するために Emitter ノード ()によって使用されます。</target>
        </trans-unit>
        <trans-unit id="0d08957bff2b6ad91314499adc0b8343bea9d846" translate="yes" xml:space="preserve">
          <source>The JmxEventListener class is used by the builder to listen to events on the event bus. It is used internally by JmxBuilder to handle attribute-change and operation-invoke events on the bean() node.</source>
          <target state="translated">JmxEventListener クラスは、ビルダがイベントバス上のイベントをリッスンするために使用します。JmxBuilder の内部では、Bean()ノードの属性変更イベントや操作呼び出しイベントを処理するために使用されます。</target>
        </trans-unit>
        <trans-unit id="791c37595668d995bb3f7137a2837e7869f379f8" translate="yes" xml:space="preserve">
          <source>The JmxMetaMapBuilder class is used to collect meta data passed in JmxBuilder nodes. Once collected, the data is then normalized to be represented uniformly regardless of the resource where it was obtained.</source>
          <target state="translated">JmxMetaMapBuilderクラスは、JmxBuilderノードで渡されたメタデータを収集するために使用します。収集されたデータは、取得したリソースに関係なく一様に表現されるように正規化されます。</target>
        </trans-unit>
        <trans-unit id="e1cf8f8fe2a9841c47ea577375d10ab0b3a498ec" translate="yes" xml:space="preserve">
          <source>The JmxTimerFactory class generates a timer() node for JmxBuilder. This node crates a standard JMX Timer object that can be used to provide timing signals to registered JMX listeners.</source>
          <target state="translated">JmxTimerFactory クラスは、JmxBuilder 用の timer()ノードを生成します。このノードは、登録されたJMXリスナーにタイミング信号を提供するために使用できる標準的なJMX Timerオブジェクトを生成します。</target>
        </trans-unit>
        <trans-unit id="d1015aa5213030445b24890b5298e5c4b7fb29c4" translate="yes" xml:space="preserve">
          <source>The MetaClass</source>
          <target state="translated">メタクラス</target>
        </trans-unit>
        <trans-unit id="70b9f38afa55b20e2322eb7214953e5ce4ce9d61" translate="yes" xml:space="preserve">
          <source>The MetaClass instance</source>
          <target state="translated">メタクラスのインスタンス</target>
        </trans-unit>
        <trans-unit id="260db7c9ae9624cfa33762fdc9180e7061158fff" translate="yes" xml:space="preserve">
          <source>The MetaClassCreationHandle instance</source>
          <target state="translated">MetaClassCreationHandleインスタンス</target>
        </trans-unit>
        <trans-unit id="304ce5f140b19a7e8c2ce15e0bd65caaaee29466" translate="yes" xml:space="preserve">
          <source>The MetaProperty or null if it doesn't exist</source>
          <target state="translated">MetaProperty、存在しない場合はnull。</target>
        </trans-unit>
        <trans-unit id="7243e642f153efeb15b0cd45bbbcf1e34d8e7b86" translate="yes" xml:space="preserve">
          <source>The Number corresponding to the addition of left and right</source>
          <target state="translated">左右の足し算に対応する番号</target>
        </trans-unit>
        <trans-unit id="4aa3b37e69477a774d6c510b9eeda86f2a333e6a" translate="yes" xml:space="preserve">
          <source>The Object can either be an instance of the class that this MetaObjectProtocol instance applies to or the java.lang.Class instance itself. If a method cannot be invoked a MissingMethodException is will be thrown</source>
          <target state="translated">オブジェクトは、このMetaObjectProtocolインスタンスが適用されるクラスのインスタンスか、java.lang.Classインスタンスそのものです。メソッドを呼び出すことができない場合は、MissingMethodExceptionがスローされます。</target>
        </trans-unit>
        <trans-unit id="f01609e35830c98cb8147ed0a154760cc0327e1b" translate="yes" xml:space="preserve">
          <source>The PrintWriter to write the &lt;a href=&quot;#usage&quot;&gt;usage&lt;/a&gt; help message to when &lt;code&gt;cli.usage()&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;cli.usage()&lt;/code&gt; が呼び出されたときに&lt;a href=&quot;#usage&quot;&gt;使用法の&lt;/a&gt;ヘルプメッセージを書き込むPrintWriter 。</target>
        </trans-unit>
        <trans-unit id="1ad7cb19c2bb4b46ecbb881cff1abf5fe7f4037b" translate="yes" xml:space="preserve">
          <source>The PrintWriter to write the &lt;a href=&quot;#usage&quot;&gt;usage&lt;/a&gt; help message to when &lt;code&gt;cli.usage()&lt;/code&gt; is called. Defaults to stdout but you can provide your own PrintWriter if desired.</source>
          <target state="translated">&lt;code&gt;cli.usage()&lt;/code&gt; が呼び出されたときに&lt;a href=&quot;#usage&quot;&gt;使用法の&lt;/a&gt;ヘルプメッセージを書き込むPrintWriter 。デフォルトはstdoutですが、必要に応じて独自のPrintWriterを提供できます。</target>
        </trans-unit>
        <trans-unit id="f3c0b48403b15a903f91f5257a20030e1e3b89f0" translate="yes" xml:space="preserve">
          <source>The PrintWriter to write to when invalid user input was provided to the &lt;a href=&quot;#parse(java.lang.String)&quot;&gt;parse(java.lang.String[])&lt;/a&gt; method.</source>
          <target state="translated">無効なユーザー入力が&lt;a href=&quot;#parse(java.lang.String)&quot;&gt;parse（java.lang.String []）&lt;/a&gt;メソッドに提供されたときに書き込むPrintWriter 。</target>
        </trans-unit>
        <trans-unit id="127ae9cbb960e452f7333cb76a15c3f3dcc5fd90" translate="yes" xml:space="preserve">
          <source>The PrintWriter to write to when invalid user input was provided to the &lt;a href=&quot;#parse(java.lang.String)&quot;&gt;parse(java.lang.String[])&lt;/a&gt; method. Defaults to stderr but you can provide your own PrintWriter if desired.</source>
          <target state="translated">無効なユーザー入力が&lt;a href=&quot;#parse(java.lang.String)&quot;&gt;parse（java.lang.String []）&lt;/a&gt;メソッドに提供されたときに書き込むPrintWriter 。デフォルトはstderrですが、必要に応じて独自のPrintWriterを提供できます。</target>
        </trans-unit>
        <trans-unit id="7a802aa7bf26ec7a1cc42a344ad8a273e764c485" translate="yes" xml:space="preserve">
          <source>The Swing component being edited.</source>
          <target state="translated">編集中のSwingコンポーネント。</target>
        </trans-unit>
        <trans-unit id="bdb2fc7e68bc1e57e68935cf223ed7a03e6b0e67" translate="yes" xml:space="preserve">
          <source>The System Property to set as a filename excludes pattern for collection of Classes.</source>
          <target state="translated">ファイル名として設定するシステムプロパティは、クラスのコレクションのパターンを除外します。</target>
        </trans-unit>
        <trans-unit id="6a1909fe3c15f658c03287f53b875168b744419d" translate="yes" xml:space="preserve">
          <source>The System Property to set as a filename excludes pattern for collection of Classes. When non-empty, the pattern will be used as Regular Expression pattern applied with the find operator against each candidate file.path. Key is &quot;javadocAssertion.src.excludesPattern&quot;. Default value is &quot;&quot;.</source>
          <target state="translated">ファイル名として設定するシステムプロパティは、クラスのコレクションのためのパターンを除外します。空でない場合は、各候補file.pathに対してfind演算子で適用される正規表現パターンとして使用されます。キーは &quot;javadocAssertion.src.excludesPattern&quot; です。デフォルト値は &quot;&quot;&quot; です。</target>
        </trans-unit>
        <trans-unit id="6e2f804b26b209506ffe905e468265879b10275e" translate="yes" xml:space="preserve">
          <source>The System Property to set as a filename excludes pattern for collection of Test Cases.</source>
          <target state="translated">ファイル名として設定するシステムプロパティは、テストケース集のパターンを除外します。</target>
        </trans-unit>
        <trans-unit id="b63561856de11fdd61e36dc53031f4a4c5c9997a" translate="yes" xml:space="preserve">
          <source>The System Property to set as a filename excludes pattern for collection of Test Cases. When non-empty, the pattern will be used as Regular Expression pattern applied with the find operator against each candidate file.path. Key is &quot;groovy.test.excludesPattern&quot;. Default value is &quot;&quot;.</source>
          <target state="translated">ファイル名として設定するシステムプロパティは、テストケースを収集するためのパターンを除外します。空でない場合は、各候補のfile.pathに対してfind演算子で適用される正規表現パターンとして使用されます。キーは &quot;groovy.test.excludesPattern &quot;です。デフォルト値は&quot;&quot;です。</target>
        </trans-unit>
        <trans-unit id="47b09e49327c616d7dfdf39837fa8bd53af76f55" translate="yes" xml:space="preserve">
          <source>The System Property to set as base directory for collection of Classes.</source>
          <target state="translated">クラスのコレクションのベースディレクトリとして設定するシステムプロパティです。</target>
        </trans-unit>
        <trans-unit id="4eeea8df2c671b1aaf1f285764880655e10de1e1" translate="yes" xml:space="preserve">
          <source>The System Property to set as base directory for collection of Classes. The pattern will be used as an Ant fileset include basedir. Key is &quot;javadocAssertion.src.dir&quot;. Defaults to the &lt;code&gt;./src&lt;/code&gt; directory</source>
          <target state="translated">クラスのコレクションのベースディレクトリとして設定するシステムプロパティ。このパターンは、Antファイルセットインクルードベースとして使用されます。キーは「javadocAssertion.src.dir」です。デフォルトは &lt;code&gt;./src&lt;/code&gt; ディレクトリです</target>
        </trans-unit>
        <trans-unit id="3bf415e47865f7516d23e95370920077c48370ee" translate="yes" xml:space="preserve">
          <source>The System Property to set as base directory for collection of Test Cases.</source>
          <target state="translated">テストケース集のベースディレクトリとして設定するシステムプロパティです。</target>
        </trans-unit>
        <trans-unit id="31447f96bb70b187e7844f2b264f55c03201f601" translate="yes" xml:space="preserve">
          <source>The System Property to set as base directory for collection of Test Cases. The pattern will be used as an Ant fileset include basedir. Key is &quot;groovy.test.dir&quot;. Default value is &quot;./test/&quot;.</source>
          <target state="translated">テストケース集のベースディレクトリとして設定するシステムプロパティです。パターンは、Antファイルセットinclude basedirとして使用します。キーは「groovy.test.dir」です。デフォルト値は&quot;./test/&quot;です。</target>
        </trans-unit>
        <trans-unit id="266958bc55466288051a176e383496d4feb92e74" translate="yes" xml:space="preserve">
          <source>The System Property to set as the filename pattern for collection of Classes.</source>
          <target state="translated">クラスのコレクションのファイル名パターンとして設定するシステム・プロパティ。</target>
        </trans-unit>
        <trans-unit id="2a90fedae02d009a3ffad52f02ac8b7d11b8745b" translate="yes" xml:space="preserve">
          <source>The System Property to set as the filename pattern for collection of Classes. The pattern will be used as Regular Expression pattern applied with the find operator against each candidate file.path. Key is &quot;javadocAssertion.src.pattern&quot;. Defaults to including all &lt;code&gt;.java&lt;/code&gt; and &lt;code&gt;.groovy&lt;/code&gt; files.</source>
          <target state="translated">クラスのコレクションのファイル名パターンとして設定するシステムプロパティ。このパターンは、各候補file.pathに対してfind演算子で適用される正規表現パターンとして使用されます。キーは「javadocAssertion.src.pattern」です。デフォルトでは、すべての &lt;code&gt;.java&lt;/code&gt; ファイルと &lt;code&gt;.groovy&lt;/code&gt; ファイルが含まれます。</target>
        </trans-unit>
        <trans-unit id="0000bd75ba6a74e57ac9cf53044c50c3c9d010ff" translate="yes" xml:space="preserve">
          <source>The System Property to set as the filename pattern for collection of Test Cases.</source>
          <target state="translated">テストケースのコレクションのファイル名パターンとして設定するシステムプロパティです。</target>
        </trans-unit>
        <trans-unit id="998db7b8bbfcee3c949aa177d7b90b7dfdb69720" translate="yes" xml:space="preserve">
          <source>The System Property to set as the filename pattern for collection of Test Cases. The pattern will be used as Regular Expression pattern applied with the find operator against each candidate file.path. Key is &quot;groovy.test.pattern&quot;. Default value is &quot;Test.groovy&quot;.</source>
          <target state="translated">テストケースのコレクションのファイル名パターンとして設定するシステムプロパティです。パターンは、各候補のfile.pathに対してfind演算子を使って適用される正規表現パターンとして使用されます。キーは &quot;groovy.test.pattern &quot;です。デフォルト値は &quot;Test.groovy &quot;です。</target>
        </trans-unit>
        <trans-unit id="84337e91be9e8ef75be1d04b6fdba516cbd8151f" translate="yes" xml:space="preserve">
          <source>The TimeUnit of the value parameter.</source>
          <target state="translated">値パラメータのTimeUnit。</target>
        </trans-unit>
        <trans-unit id="718e7ae897428930781dc6de636d2e594031a23c" translate="yes" xml:space="preserve">
          <source>The TimeUnit of the value parameter. By default it is TimeUnit.SECONDS.</source>
          <target state="translated">値パラメータのTimeUnit。デフォルトでは TimeUnit.SECONDS です。</target>
        </trans-unit>
        <trans-unit id="c92a8a6f01fd8d4e068bc1d01714e753c4596b32" translate="yes" xml:space="preserve">
          <source>The URL for a repo containing the grape/artifact.</source>
          <target state="translated">grape/artifactを含むレポのURL。</target>
        </trans-unit>
        <trans-unit id="de6a560d5da664892b518e4682d24979363ecddc" translate="yes" xml:space="preserve">
          <source>The URL for a repo containing the grape/artifact. A non-empty value is required unless value() is used.</source>
          <target state="translated">grape/artifact を含むレポの URL。value()を使用しない限り、空でない値を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="b6aadb5f5ba9e2b129360252950ed1939f90ac0b" translate="yes" xml:space="preserve">
          <source>The URL pattern does not require the &quot;*.groovy&quot; mapping. You can, for example, make it more Struts-like but groovy by making your mapping &quot;*.gdo&quot;.</source>
          <target state="translated">URLパターンでは、&quot;*.groovy &quot;というマッピングは必要ありません。例えば、マッピングを &quot;*.gdo &quot;にすることで、よりStrutsらしく、しかしgroovyにすることができます。</target>
        </trans-unit>
        <trans-unit id="adca94d915cd2e4151b8eb5471618fdec37d9c2b" translate="yes" xml:space="preserve">
          <source>The XML template engine can also be used as the engine for &lt;a href=&quot;../servlet/templateservlet&quot;&gt;TemplateServlet&lt;/a&gt; by placing the following in your web.xml file (plus a corresponding servlet-mapping element):</source>
          <target state="translated">XMLテンプレートエンジンは、web.xmlファイル（および対応するサーブレットマッピング要素）に以下を配置することにより、&lt;a href=&quot;../servlet/templateservlet&quot;&gt;TemplateServlet&lt;/a&gt;のエンジンとして使用することもできます。</target>
        </trans-unit>
        <trans-unit id="d9495cf1739a07e775ac543e8d0f74d2f8dd5b54" translate="yes" xml:space="preserve">
          <source>The YAML builder implements the &lt;code&gt;Writable&lt;/code&gt; interface, so that you can have the builder serialize itself the YAML payload to a writer.</source>
          <target state="translated">YAMLビルダーは &lt;code&gt;Writable&lt;/code&gt; インターフェースを実装しているため、ビルダーにYAMLペイロードをライターにシリアル化させることができます。</target>
        </trans-unit>
        <trans-unit id="a412e1e1d8cd3a68e2efff325b41048db7ad21bd" translate="yes" xml:space="preserve">
          <source>The above example prints this to standard output:</source>
          <target state="translated">上記の例では、これを標準出力に出力しています。</target>
        </trans-unit>
        <trans-unit id="ec91d8d1308de75b03d0376ac9545cec66180c83" translate="yes" xml:space="preserve">
          <source>The above example will generate code that is similar to the next snippet. Notice the difference between a String property and a def/Object property:</source>
          <target state="translated">上記の例は、次のスニペットに似たコードを生成します。String プロパティと def/Object プロパティの違いに注目してください。</target>
        </trans-unit>
        <trans-unit id="b257bfac16ef28eecdac4b554708ae5f69748970" translate="yes" xml:space="preserve">
          <source>The actual number of characters skipped</source>
          <target state="translated">実際にスキップされた文字数</target>
        </trans-unit>
        <trans-unit id="052bfa45246c41d68e26ad806f4e38a47fba851d" translate="yes" xml:space="preserve">
          <source>The alternative supported style regards any kind of inheritance as creation of a new type and is illustrated in the following example:</source>
          <target state="translated">代替的にサポートされているスタイルでは、どのような種類の継承も新しい型の作成とみなし、以下の例に示します。</target>
        </trans-unit>
        <trans-unit id="4bdb04cd00d0c115ee207c0ae5337f0b546086bb" translate="yes" xml:space="preserve">
          <source>The annotated Collection field must have a generic type</source>
          <target state="translated">注釈付きコレクションフィールドは、ジェネリック型を持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="aceff9ab81f781b7ab6d9e62431c1055127d2723" translate="yes" xml:space="preserve">
          <source>The annotated Collection field must not have a generic wildcard declared</source>
          <target state="translated">注釈付きコレクションフィールドは、一般的なワイルドカードが宣言されていてはなりません。</target>
        </trans-unit>
        <trans-unit id="9e547ff00f70b525a9f0ec9c47c86f3334dc81ae" translate="yes" xml:space="preserve">
          <source>The annotated variable will become a private field of the script class. The type of the field will be the same as the type of the variable. Example usage:</source>
          <target state="translated">アノテーションされた変数は、スクリプトクラスのプライベートフィールドになります。フィールドの型は、変数の型と同じになります。使用例。</target>
        </trans-unit>
        <trans-unit id="f318a85f6a5756ab184456f34f3ce55011832330" translate="yes" xml:space="preserve">
          <source>The annotation being referenced.</source>
          <target state="translated">参照されている注釈。</target>
        </trans-unit>
        <trans-unit id="5c20ea5b9d49bb4d3079400f6c7b508d5ddfe6c4" translate="yes" xml:space="preserve">
          <source>The annotation can be placed at the class level in which case it applies to all methods, constructors, and closures within the class and any inner classes. It can also be applied to an individual method, constructor, field with a Closure initial value or a Closure assigned to a local variable. In the case of fields (or local variables) it only adjusts the parameters of the referenced Closure not the field (or local variable) itself.</source>
          <target state="translated">アノテーションはクラスレベルで配置することができ、その場合はクラス内のすべてのメソッド、コンストラクタ、クロージャ、および任意の内部クラスに適用されます。また、個々のメソッド、コンストラクタ、Closureの初期値を持つフィールド、またはローカル変数に代入されたClosureにも適用することができます。フィールド(またはローカル変数)の場合は、フィールド(またはローカル変数)自体ではなく、参照されたクロージャのパラメータのみを調整します。</target>
        </trans-unit>
        <trans-unit id="9517f13d3119a99ae37232e6f8925dc3dc606f99" translate="yes" xml:space="preserve">
          <source>The annotation can be used on a whole class as shown above or selectively on a particular method, constructor or field.</source>
          <target state="translated">アノテーションは、上記のようにクラス全体に使用することもできますし、特定のメソッド、コンストラクタ、フィールドに選択的に使用することもできます。</target>
        </trans-unit>
        <trans-unit id="9dcd4f54b47563f3bd43966ca8e9a4fbea0a7944" translate="yes" xml:space="preserve">
          <source>The annotation can take the following parameters:</source>
          <target state="translated">アノテーションは以下のパラメータを取ることができます。</target>
        </trans-unit>
        <trans-unit id="06f750d18a3b109b97c136361abf51e190db88be" translate="yes" xml:space="preserve">
          <source>The annotation is intended to be used sparingly; perhaps in DSL scenarios or when using deeply nested structural types. In particular, there is no support for using the facility with two similarly named classes from different packages at the same time. Though it is OK to have different packages in different contexts. Also, there is no support for turning &quot;Ruby-style&quot; conversions off at the method, constructor or field level if already turned on at the class level.</source>
          <target state="translated">このアノテーションは、DSL のシナリオや、深く入れ子になった構造型を使用する場合など、控えめに使用することを意図しています。特に、異なるパッケージの似たような名前のクラスを同時に使うことはサポートされていません。異なるコンテキストで異なるパッケージがあっても構いませんが。また、クラスレベルで既にオンになっている場合に、メソッド、コンストラクタ、フィールドレベルで &quot;Rubyスタイル &quot;の変換をオフにすることもサポートされていません。</target>
        </trans-unit>
        <trans-unit id="3190b6c4518ac7ad1bc48cdc3e3e48499552b444" translate="yes" xml:space="preserve">
          <source>The annotation takes an optional parameter for the name of the field. This field must exist on the class and must be of type ReentrantReadWriteLock.</source>
          <target state="translated">アノテーションは、フィールド名のオプション・パラメータを取ります。このフィールドは、クラス上に存在し、ReentrantReadWriteLock タイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="6d2a41c58f84b983c4307e184fcf2882ccbdc7cf" translate="yes" xml:space="preserve">
          <source>The attribute value</source>
          <target state="translated">属性値</target>
        </trans-unit>
        <trans-unit id="dd9423271c2e0be1493ebeaf945a08093f8a561f" translate="yes" xml:space="preserve">
          <source>The attribute values of annotations must be primitive, String or Enum constants.</source>
          <target state="translated">アノテーションの属性値は、プリミティブ、文字列、または列挙定数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="e91a7321fc7ae255dea783ee8a8e3fd6aea9d2cb" translate="yes" xml:space="preserve">
          <source>The attribute values of annotations must be primitive, String or Enum constants. In various places, such constants can be seen during type resolution but won't be readily accessible in later phases, e.g. they might be embedded into constructor code. This method transforms constants that would appear in annotations early so they aren't lost. Subsequent processing determines whether they are valid, this method simply retains the constant value as a constant expression.</source>
          <target state="translated">アノテーションの属性値は、プリミティブ、String または Enum 定数でなければなりません。様々な場所で、そのような定数は型解決の間に見ることができますが、後のフェーズでは容易にアクセスできません。このメソッドは、アノテーションに現れるであろう定数を早期に変換し、失わないようにします。その後の処理でそれらが有効かどうかを判断しますが、このメソッドは単に定数の値を定数式として保持します。</target>
        </trans-unit>
        <trans-unit id="ba9d0f179fb12288dcac51469b2a074466e2e0af" translate="yes" xml:space="preserve">
          <source>The average of all of the items</source>
          <target state="translated">全項目の平均値</target>
        </trans-unit>
        <trans-unit id="70783273967fb37a38f643afd98e6b9187891321" translate="yes" xml:space="preserve">
          <source>The average of the items</source>
          <target state="translated">項目の平均値</target>
        </trans-unit>
        <trans-unit id="8395f1aa4e19271ad68a33fd7315e6d494f3ac12" translate="yes" xml:space="preserve">
          <source>The average of the values returned by applying the closure to each item from the Iterator.</source>
          <target state="translated">イテレータから各項目にクロージャを適用して返された値の平均値。</target>
        </trans-unit>
        <trans-unit id="3eb091fbf86b30307fd9a7fb7c9aaa700930da46" translate="yes" xml:space="preserve">
          <source>The average of the values returned by applying the closure to each item of the Iterable.</source>
          <target state="translated">イテレータブルの各項目にクロージャを適用して返される値の平均。</target>
        </trans-unit>
        <trans-unit id="7c9801aab1db27901fd7a9be59509eda4d8846c8" translate="yes" xml:space="preserve">
          <source>The average of the values returned by applying the closure to each item of the array.</source>
          <target state="translated">配列の各項目にクロージャを適用して返される値の平均。</target>
        </trans-unit>
        <trans-unit id="4bbf0434c30c3cf5371d3ed8bebd25d1c43ff05a" translate="yes" xml:space="preserve">
          <source>The bind path object. This class represents one &quot;step&quot; in the bind path.</source>
          <target state="translated">バインドパスオブジェクト。このクラスは、バインドパスの1つの &quot;ステップ &quot;を表します。</target>
        </trans-unit>
        <trans-unit id="4408519a715193017dfb9b02caa80e83767ca7d0" translate="yes" xml:space="preserve">
          <source>The binding also provides convenient methods:</source>
          <target state="translated">また、バインディングには便利な方法も用意されています。</target>
        </trans-unit>
        <trans-unit id="1c8a6a5839bf78280f2f5d8f72a3b8f0dac48502" translate="yes" xml:space="preserve">
          <source>The binding provided by TemplateServlet does already include some default variables. As of this writing, they are (copied from &lt;a href=&quot;servletbinding&quot;&gt;ServletBinding&lt;/a&gt;):</source>
          <target state="translated">TemplateServletによって提供されるバインディングには、すでにいくつかのデフォルト変数が含まれています。この記事の執筆時点では、それらは（&lt;a href=&quot;servletbinding&quot;&gt;ServletBinding&lt;/a&gt;からコピーされた）：</target>
        </trans-unit>
        <trans-unit id="170305b27b6f2f428a171b71d8192fdfc6377fe8" translate="yes" xml:space="preserve">
          <source>The cached class.</source>
          <target state="translated">キャッシュされたクラス。</target>
        </trans-unit>
        <trans-unit id="3de13709d4a99443765990411d8804e7d936d4c5" translate="yes" xml:space="preserve">
          <source>The call should be invoked separately</source>
          <target state="translated">呼び出しは個別に呼び出されなければなりません。</target>
        </trans-unit>
        <trans-unit id="fed53e69261b2dc331e4fdcb563927c92a857a5a" translate="yes" xml:space="preserve">
          <source>The character read, as an integer in the range 0 to 65535 (0x00-0xffff), or -1 if the end of the stream has been reached</source>
          <target state="translated">読み込んだ文字を 0 ~ 65535 (0x00-0xffff)の範囲の整数として、またはストリームの終了に達した場合は -1 として指定します。</target>
        </trans-unit>
        <trans-unit id="0b1006004394eb9f2a6da42ea7c5b946608b286e" translate="yes" xml:space="preserve">
          <source>The character used to split a single command line argument into parts.</source>
          <target state="translated">1つのコマンドライン引数を分割するために使用される文字です。</target>
        </trans-unit>
        <trans-unit id="e358d3e84c4ddc0c51dee898e085378748c11c44" translate="yes" xml:space="preserve">
          <source>The check works &lt;b&gt;only for options &lt;b&gt;one&lt;/b&gt; block below the current block. E.g. &lt;code&gt;config.isSet('foo.password')&lt;/code&gt; will always return false. &lt;dl&gt;
&lt;dt&gt;&lt;b&gt;Parameters:&lt;/b&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;code&gt;option&lt;/code&gt; - The name of the option&lt;/dd&gt;
&lt;/dl&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;b&gt;Returns:&lt;/b&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;code&gt;true&lt;/code&gt; if the option is set &lt;code&gt;false&lt;/code&gt; otherwise&lt;/dd&gt;
&lt;/dl&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;b&gt;Since:&lt;/b&gt;&lt;/dt&gt;
&lt;dd&gt;2.3.0&lt;/dd&gt;
&lt;/dl&gt; &lt;/b&gt;</source>
          <target state="translated">このチェック&lt;b&gt;は、現在のブロックの&lt;/b&gt;&lt;b&gt;&lt;b&gt;1&lt;/b&gt;&lt;/b&gt;&lt;b&gt;ブロック下の&lt;/b&gt;&lt;b&gt;オプションに対してのみ機能します。たとえば、 &lt;code&gt;config.isSet('foo.password')&lt;/code&gt; は常にfalseを返します。 &lt;b&gt;&lt;/b&gt;&lt;dl&gt; &lt;dt&gt; &lt;b&gt;パラメーター：&lt;/b&gt; &lt;/dt&gt; &lt;dd&gt; &lt;code&gt;option&lt;/code&gt; -オプションの名前 &lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt; &lt;b&gt;戻り値：&lt;/b&gt; &lt;/dt&gt; &lt;dd&gt; &lt;code&gt;true&lt;/code&gt; オプションが &lt;code&gt;false&lt;/code&gt; に設定されている場合はtrue、それ以外の場合 は true。&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt; &lt;b&gt;以来：&lt;/b&gt; &lt;/dt&gt; &lt;dd&gt; 2.3.0 &lt;/dd&gt; &lt;/dl&gt; &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="12f6e1d7ed0f1c99877990e1030d0f1489d503a8" translate="yes" xml:space="preserve">
          <source>The class contained by this metaclass</source>
          <target state="translated">このメタクラスに含まれるクラス</target>
        </trans-unit>
        <trans-unit id="02889e40310a5938acf27d4e92b62a80c8bb0b34" translate="yes" xml:space="preserve">
          <source>The class is automatically made final.</source>
          <target state="translated">クラスは自動的に最終的なものになります。</target>
        </trans-unit>
        <trans-unit id="d55ce426f3bc5d724c2889dfa22ff395fbda6a39" translate="yes" xml:space="preserve">
          <source>The class passed as a constructor parameter must be an AST transformation annotation. Alternatively, you can apply a global AST transformation by calling the &lt;a href=&quot;asttransformationcustomizer#ASTTransformationCustomizer(org.codehaus.groovy.transform.ASTTransformation)&quot;&gt;AST transformation&lt;/a&gt;. In that case, the transformation is applied once for the whole source unit. Unlike a global AST transformation declared in the META-INF/services/org.codehaus.groovy.transform.ASTTransformation file, which are applied if the file is in the classpath, using this customizer you'll have the choice to apply your transformation selectively. It can also be useful to debug global AST transformations without having to package your annotation in a jar file.</source>
          <target state="translated">コンストラクターパラメーターとして渡されるクラスは、AST変換アノテーションである必要があります。また、あなたは呼び出すことによりグローバルAST変換を適用することができます&lt;a href=&quot;asttransformationcustomizer#ASTTransformationCustomizer(org.codehaus.groovy.transform.ASTTransformation)&quot;&gt;AST変換を&lt;/a&gt;。その場合、変換はソースユニット全体に1回適用されます。 META-INF / services / org.codehaus.groovy.transform.ASTTransformationファイルで宣言されたグローバルAST変換とは異なり、ファイルがクラスパスにある場合に適用されますが、このカスタマイザーを使用すると、変換を選択的に適用することができます。 。アノテーションをjarファイルにパッケージ化せずに、グローバルAST変換をデバッグすることも役立ちます。</target>
        </trans-unit>
        <trans-unit id="8cad1da7d481a03ef9916a2ff7d8844930ea3cea" translate="yes" xml:space="preserve">
          <source>The classifier if in use, e.g.: &quot;jdk14&quot;</source>
          <target state="translated">使用されている場合の分類器、例えば &quot;jdk14&quot;</target>
        </trans-unit>
        <trans-unit id="ca27fb66cfe5fba5a9ac754d02a9f29c0105033f" translate="yes" xml:space="preserve">
          <source>The classpath as URL[] from this configuration.</source>
          <target state="translated">この設定からURL[]としてのクラスパスを指定します。</target>
        </trans-unit>
        <trans-unit id="8d1bf1f2d2c67f0aae89b6c3bc480661749348cd" translate="yes" xml:space="preserve">
          <source>The classpath as URL[] from this configuration. This can be used to construct a class loader.</source>
          <target state="translated">この設定からURL[]としてのクラスパス。これを使ってクラスローダを構築することができます。</target>
        </trans-unit>
        <trans-unit id="bd3926225e9f00ef4ebec16fbc04d966c7fe2b75" translate="yes" xml:space="preserve">
          <source>The closure</source>
          <target state="translated">閉鎖</target>
        </trans-unit>
        <trans-unit id="479f86662ac269b97cc2d894e9bac34d9794dd34" translate="yes" xml:space="preserve">
          <source>The closure code is executed after the specified phase has completed. If no phase is provided, then the code is executed after the &lt;a href=&quot;../../org/codehaus/groovy/control/compilephase#SEMANTIC_ANALYSIS&quot;&gt;semantic analysis&lt;/a&gt; phase and each subsequent phase.</source>
          <target state="translated">クロージャコードは、指定されたフェーズが完了した後に実行されます。フェーズが提供されていない場合、コードは&lt;a href=&quot;../../org/codehaus/groovy/control/compilephase#SEMANTIC_ANALYSIS&quot;&gt;セマンティック分析&lt;/a&gt;フェーズとそれに続く各フェーズの後に実行されます。</target>
        </trans-unit>
        <trans-unit id="d7e22c2e0c44fd389e3b41fde1dda05fedb35439" translate="yes" xml:space="preserve">
          <source>The closure is wrapped in a thread, and the thread is started immediately, only if the current thread is the EDT, otherwise the closure will be called immediately.</source>
          <target state="translated">クロージャはスレッドに包まれており、現在のスレッドがEDTである場合に限り、すぐにスレッドが開始され、そうでない場合はすぐにクロージャが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="66a119bbf2479d278c5b03976bf4d331b5a07a07" translate="yes" xml:space="preserve">
          <source>The closure must accept either 1 or 2 parameters. The first parameter is required and will be instance of the &lt;code&gt;type&lt;/code&gt; for which the closure is registered. The second optional parameter should be of type &lt;code&gt;String&lt;/code&gt; and, if available, will be passed the name of the key associated with this value if serializing a JSON Object. This parameter will be &lt;code&gt;null&lt;/code&gt; when serializing a JSON Array or when there is no way to determine the name of the key.</source>
          <target state="translated">クロージャーは、1つまたは2つのパラメーターを受け入れる必要があります。最初のパラメーターは必須であり、クロージャーが登録されている &lt;code&gt;type&lt;/code&gt; インスタンスになります。2番目のオプションのパラメーターは &lt;code&gt;String&lt;/code&gt; 型である必要があり、JSONオブジェクトをシリアル化する場合、使用可能な場合は、この値に関連付けられたキーの名前が渡されます。JSON配列をシリアル化する場合、またはキーの名前を判別する方法がない場合、このパラメーターは &lt;code&gt;null&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="d6ac82819478a5008a16cf393ea1fa535e93de24" translate="yes" xml:space="preserve">
          <source>The closure will be called with a single argument; the database statement (actually a &lt;code&gt;BatchingStatementWrapper&lt;/code&gt; helper object) associated with this batch.</source>
          <target state="translated">クロージャは単一の引数で呼び出されます。このバッチに関連付けられたデータベースステートメント（実際には &lt;code&gt;BatchingStatementWrapper&lt;/code&gt; ヘルパーオブジェクト）。</target>
        </trans-unit>
        <trans-unit id="ae8cb3c86be077ae32b3b768d99be03b18c7b824" translate="yes" xml:space="preserve">
          <source>The closure will be called with a single argument; the prepared statement (actually a &lt;code&gt;BatchingPreparedStatementWrapper&lt;/code&gt; helper object) associated with this batch.</source>
          <target state="translated">クロージャは単一の引数で呼び出されます。このバッチに関連付けられたプリペアドステートメント（実際には &lt;code&gt;BatchingPreparedStatementWrapper&lt;/code&gt; ヘルパーオブジェクト）。</target>
        </trans-unit>
        <trans-unit id="4ae276d6aaf9c3b8bb8aacf648ffb3e07a64cd0f" translate="yes" xml:space="preserve">
          <source>The column.</source>
          <target state="translated">コラムです。</target>
        </trans-unit>
        <trans-unit id="b8a31b50dfe2f995289113fae596103f2b81d59f" translate="yes" xml:space="preserve">
          <source>The command synopsis displayed as the first line in the usage help message, e.g., when &lt;code&gt;cli.usage()&lt;/code&gt; is called.</source>
          <target state="translated">コマンドの概要は、使用法のヘルプメッセージの最初の行として表示されます。たとえば、 &lt;code&gt;cli.usage()&lt;/code&gt; が呼び出された場合などです。</target>
        </trans-unit>
        <trans-unit id="06cad667cd962638ca743f083a07c3b0502fe46b" translate="yes" xml:space="preserve">
          <source>The command synopsis displayed as the first line in the usage help message, e.g., when &lt;code&gt;cli.usage()&lt;/code&gt; is called. When not set, a default synopsis is generated that shows the supported options and parameters.</source>
          <target state="translated">コマンドの概要は、使用法のヘルプメッセージの最初の行として表示されます。たとえば、 &lt;code&gt;cli.usage()&lt;/code&gt; が呼び出された場合などです。設定されていない場合、サポートされているオプションとパラメータを示すデフォルトの概要が生成されます。</target>
        </trans-unit>
        <trans-unit id="d18fc7b737edb2f0f86aeb308f5fb82c518e4b38" translate="yes" xml:space="preserve">
          <source>The compile phase after which the test code should run.</source>
          <target state="translated">テストコードが実行された後のコンパイルフェーズ。</target>
        </trans-unit>
        <trans-unit id="afcc42b40006b1f09d9251010aafdffd34d40bec" translate="yes" xml:space="preserve">
          <source>The compiler will call this method each time, in a source file, a method call using a closure literal is encountered and that the target method has the corresponding &lt;a href=&quot;../../lang/closure&quot;&gt;Closure&lt;/a&gt; parameter annotated with &lt;a href=&quot;closureparams&quot;&gt;ClosureParams&lt;/a&gt;. So imagine the following code needs to be compiled:</source>
          <target state="translated">コンパイラは、ソースファイルで、クロージャリテラルを使用したメソッド呼び出しが検出され、ターゲットメソッドに&lt;a href=&quot;closureparams&quot;&gt;ClosureParams&lt;/a&gt;アノテーションが付けられた対応する&lt;a href=&quot;../../lang/closure&quot;&gt;Closure&lt;/a&gt;パラメータがあるたびに、このメソッドを呼び出します。したがって、次のコードをコンパイルする必要があると想像してください。</target>
        </trans-unit>
        <trans-unit id="3808e32108176f69751a0339e1ed53d1e06027cc" translate="yes" xml:space="preserve">
          <source>The compiler will not output classes from these, the methods usually do not contain bodies. These kind of ClassNodes will be used in different checks, but not checks that work on the method bodies. For example if such a ClassNode is a super class to a primary ClassNode, then the abstract method test and others will be done with data based on these. Theoretically it is also possible to mix both (1 and 2) kind of classes in a hierarchy, but this probably works only in the newest Groovy versions. Such ClassNodes normally have to isResolved() returning true without having a redirect.In the Groovy compiler the only version of this, that exists, is a ClassNode created through a Class instance</source>
          <target state="translated">コンパイラはこれらからクラスを出力しません。このような種類のClassNodeは、異なるチェックで使用されますが、メソッドのボディに作用するチェックではありません。例えば、このような ClassNode がプライマリ ClassNode のスーパー・クラスである場合、抽象メソッド・テストなどはこれらを基にしたデータで行われます。理論的には、階層内に(1と2)種類のクラスを混在させることも可能ですが、これはおそらく最新のGroovyバージョンでしか動作しません。このようなClassNodesは通常、リダイレクトを持たずにisResolved()でtrueを返さなければなりません。</target>
        </trans-unit>
        <trans-unit id="850b5efb5f5d9bd3f0560dbbfb14716f649e832f" translate="yes" xml:space="preserve">
          <source>The configuration if in use (normally only used by internal ivy repositories).</source>
          <target state="translated">使用されている場合の設定(通常は内部の ivy リポジトリでのみ使用されます)。</target>
        </trans-unit>
        <trans-unit id="d7faea022679481783e94841e801c0632c55b402" translate="yes" xml:space="preserve">
          <source>The configuration if in use (normally only used by internal ivy repositories). One or more comma separated values with or without square brackets, e.g. for hibernate you might have &quot;default,proxool,oscache&quot; or &quot;[default,dbcp,swarmcache]&quot;. This last hibernate example assumes you have set up such configurations in your local Ivy repo and have changed your grape config (using grapeConfig.xml) or the &lt;code&gt;@GrabConfig&lt;/code&gt; annotation to point to that repo.</source>
          <target state="translated">使用中の構成（通常は内部のツタリポジトリでのみ使用されます）。角かっこ付きまたは角かっこなしの1つ以上のコンマ区切り値。たとえば、休止状態の場合は、「default、proxool、oscache」または「[default、dbcp、swarmcache]」があります。この最後の休止状態の例は、ローカルのIvyリポジトリでそのような構成をセットアップし、そのリポジトリを指すようにグレープ構成（grapeConfig.xmlを使用）または &lt;code&gt;@GrabConfig&lt;/code&gt; アノテーションを変更したことを前提としています。</target>
        </trans-unit>
        <trans-unit id="d1a60e2fa853eacff28c12440dec49c56afecdc7" translate="yes" xml:space="preserve">
          <source>The contents of the String builder.</source>
          <target state="translated">文字列ビルダーの内容です。</target>
        </trans-unit>
        <trans-unit id="4a4aab4772591a45dec107fd2e9fe47875d2b895" translate="yes" xml:space="preserve">
          <source>The contents of the character sequence</source>
          <target state="translated">文字列の内容</target>
        </trans-unit>
        <trans-unit id="f665bdf073d546e255843bb7fa9544a62b7c4f16" translate="yes" xml:space="preserve">
          <source>The current implementation will trigger specialized events in the following scenarios, you need not register a different listener as those events extend from PropertyChangeEvent</source>
          <target state="translated">現在の実装は、次のシナリオで特殊なイベントをトリガしますが、それらのイベントはPropertyChangeEventから拡張されるので、別のリスナーを登録する必要はありません。</target>
        </trans-unit>
        <trans-unit id="aa2b0935d80587b9e265b2719d52d7996bf5d785" translate="yes" xml:space="preserve">
          <source>The current phase</source>
          <target state="translated">現在の位相</target>
        </trans-unit>
        <trans-unit id="663e0af727247cd08dbfe73bff52e235110340bf" translate="yes" xml:space="preserve">
          <source>The custom base script may implement the run() method and specify a different method name to be used for the script body by declaring a single abstract method. For example:</source>
          <target state="translated">カスタムベースのスクリプトは、run()メソッドを実装し、単一の抽象メソッドを宣言することで、スクリプト本体に使用する別のメソッド名を指定することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="f2e34c2c7e5c999db4a0824f8059bf7756113c7d" translate="yes" xml:space="preserve">
          <source>The custom loader is used when parsing the template code</source>
          <target state="translated">カスタムローダーはテンプレートコードを解析する際に使用されます。</target>
        </trans-unit>
        <trans-unit id="1ca6098954c43f913ba3c64e90df8088c2b564b2" translate="yes" xml:space="preserve">
          <source>The deepest cause of the exception that can be found</source>
          <target state="translated">見つけることができる例外の最も深い原因</target>
        </trans-unit>
        <trans-unit id="8fed7a59b4c24557c03efc1e169c4b5b8e3c0cd8" translate="yes" xml:space="preserve">
          <source>The default implementation allows mutation of MetaClass instances before initialisation (before the initialize() method is called) but not after, thus ensuring Thread safety once a MetaClass has been constructed and placed in the registry</source>
          <target state="translated">デフォルトの実装では、初期化の前(initialize()メソッドが呼ばれる前)にMetaClassインスタンスの突然変異を許可していますが、それ以降は許可していません。</target>
        </trans-unit>
        <trans-unit id="0369a08ef21d243b44db8e7fa19111fcc8106a0b" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;a href=&quot;../../../../../groovy/transform/typechecked&quot;&gt;TypeChecked&lt;/a&gt;.</source>
          <target state="translated">デフォルトの実装は&lt;a href=&quot;../../../../../groovy/transform/typechecked&quot;&gt;TypeCheckedを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="ccbd3d0c31dab791dfc78e2ee441f1186a903c8a" translate="yes" xml:space="preserve">
          <source>The default implementation returns the result of calling &lt;a href=&quot;#visitChildren&quot;&gt;visitChildren&lt;/a&gt; on &lt;code&gt;ctx&lt;/code&gt;.</source>
          <target state="translated">デフォルトの実装では、呼び出しの結果を返す&lt;a href=&quot;#visitChildren&quot;&gt;visitChildrenを&lt;/a&gt;上 &lt;code&gt;ctx&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8c93b782d28b18159b4ef7fb9a86d95ab87ba8d" translate="yes" xml:space="preserve">
          <source>The default initial capacity</source>
          <target state="translated">デフォルトの初期容量</target>
        </trans-unit>
        <trans-unit id="921bbe96047cd5f5e009f6b1a8b71ad284e53cc5" translate="yes" xml:space="preserve">
          <source>The default initial number of table slots for this table (32).</source>
          <target state="translated">このテーブルのテーブルスロットのデフォルトの初期数(32)。</target>
        </trans-unit>
        <trans-unit id="2a0235f2f6bc645bf5e53f460b490ce2caa3598a" translate="yes" xml:space="preserve">
          <source>The default initial number of table slots for this table (32). Used when not otherwise specified in constructor.</source>
          <target state="translated">このテーブルのテーブルスロットのデフォルトの初期数 (32)。コンストラクタで指定されていない場合に使用されます。</target>
        </trans-unit>
        <trans-unit id="cd047e4711d4b6317b4497793f156661db1b11a1" translate="yes" xml:space="preserve">
          <source>The default load factor</source>
          <target state="translated">デフォルトの負荷率</target>
        </trans-unit>
        <trans-unit id="b4e8b83f74be0aa4cd12586b4ecddbda8abb74e9" translate="yes" xml:space="preserve">
          <source>The default source encoding.</source>
          <target state="translated">デフォルトのソースエンコーディング。</target>
        </trans-unit>
        <trans-unit id="2156c83dec97c28b53d21a341f92ef1aa0daaa7b" translate="yes" xml:space="preserve">
          <source>The default type checking handler is used by the standard type checker and doesn't handle any of the type checking errors by default. This just means that whenever a type checking error is detected, there's no additional information available to the type checker that could help it. The default handler is also capable of handling a collection of delegate handlers. If a list of delegates is set, then the type checker will try all the delegates until one is capable of handling an error.</source>
          <target state="translated">デフォルトの型チェックハンドラは、標準の型チェッカーによって使用され、デフォルトでは型チェックエラーを処理しません。これは、型検査エラーが検出されたときにはいつでも、型検査に役立つ追加情報が型検査器にはないことを意味しています。デフォルトのハンドラは、デリゲートハンドラの集合を扱うこともできます。デリゲートのリストが設定されている場合、タイプチェッカは、1つのデリゲートがエラーを処理できるようになるまで、すべてのデリゲートを試します。</target>
        </trans-unit>
        <trans-unit id="c93ee9502a59a55344833d10b6e63692489f009a" translate="yes" xml:space="preserve">
          <source>The default value for this option as a String; subject to type conversion and 'convert'.</source>
          <target state="translated">このオプ シ ョ ンのデフ ォル ト 値は String です。</target>
        </trans-unit>
        <trans-unit id="a739b1ad38b841cd2fa04a8074ef1077da23a9a2" translate="yes" xml:space="preserve">
          <source>The default value for this option as a String; subject to type conversion and 'convert'. Ignored for Boolean options.</source>
          <target state="translated">このオプ シ ョ ンのデフ ォル ト 値は String です。ブール値のオプションでは無視されます。</target>
        </trans-unit>
        <trans-unit id="0bac4f7d3a0265af4cdda31389b94208873f3c79" translate="yes" xml:space="preserve">
          <source>The delegate type is either the type of the annotated field (or property) or the return type of the annotated method. The method can be thought of as a getter or factory method for the delegate. All public instance methods present in the delegate type and not present in the owner class will be added to owner class at compile time. The implementation of such automatically added methods is code which calls through to the delegate as per the normal delegate pattern.</source>
          <target state="translated">デリゲートの型は、注釈付きフィールド(またはプロパティ)の型、または注釈付きメソッドの戻り値の型のいずれかです。メソッドは、デリゲートのゲッターまたはファクトリー・メソッドと考えることができます。デリゲート型に存在し、所有者クラスに存在しないすべてのパブリック・インスタンス・メソッドは、コンパイル時に所有者クラスに追加されます。このような自動的に追加されるメソッドの実装は、通常のデリゲートパターンに従ってデリゲートを呼び出すコードです。</target>
        </trans-unit>
        <trans-unit id="0af551f931ca1824e6ae59d39c1f9fdc65593c1b" translate="yes" xml:space="preserve">
          <source>The delegate used when invoking closures</source>
          <target state="translated">クローザを呼び出す際に使用するデリゲート</target>
        </trans-unit>
        <trans-unit id="da5a481646fd9ab2048ec3c70d70d40fc4c25698" translate="yes" xml:space="preserve">
          <source>The description for the remaining non-option arguments</source>
          <target state="translated">残りの非オプシ ョ ン引数の説明</target>
        </trans-unit>
        <trans-unit id="60c01151d0f392e7605b5a47b38d319dce929d2b" translate="yes" xml:space="preserve">
          <source>The description of this option</source>
          <target state="translated">このオプションの説明</target>
        </trans-unit>
        <trans-unit id="acf047b88dc904eaceac2bf0ff491efd1167e629" translate="yes" xml:space="preserve">
          <source>The document filter based on Parrot's lexer is for highlighting the content of text editor</source>
          <target state="translated">オウムのレキサーに基づく文書フィルタは、テキストエディタの内容を強調表示するためのものです。</target>
        </trans-unit>
        <trans-unit id="8897ab667aaab473e278c1a7493c2f1a2afa6c06" translate="yes" xml:space="preserve">
          <source>The empty args call will create a key whose value will be an empty JSON object:</source>
          <target state="translated">empty argsの呼び出しは、値が空のJSONオブジェクトとなるキーを作成します。</target>
        </trans-unit>
        <trans-unit id="4732dbf3c3fe3c33d319cd5d0d9b4500c95066cc" translate="yes" xml:space="preserve">
          <source>The empty args call will create a key whose value will be an empty YAML object:</source>
          <target state="translated">empty argsの呼び出しは、値が空のYAMLオブジェクトとなるキーを作成します。</target>
        </trans-unit>
        <trans-unit id="83bac1c4520db67dc9f9751222ec424f3e1dcdc8" translate="yes" xml:space="preserve">
          <source>The encoding as returned by the underlying OutputStreamWriter.</source>
          <target state="translated">基底となるOutputStreamWriterが返すエンコーディング。</target>
        </trans-unit>
        <trans-unit id="7209071caba4b5b26858a3a9b872daaeac068996" translate="yes" xml:space="preserve">
          <source>The encoding as returned by the underlying OutputStreamWriter. Can be the historical name.</source>
          <target state="translated">基底となる OutputStreamWriter が返すエンコーディング。ヒストリカル名を指定することができます。</target>
        </trans-unit>
        <trans-unit id="b32ee3e8c38d4c93010daac30bf6c76f82e10a7e" translate="yes" xml:space="preserve">
          <source>The encoding as returned by the underlying OutputStreamWriter. Will be the preferred name.</source>
          <target state="translated">基底となるOutputStreamWriterが返すエンコーディング。優先される名前になります。</target>
        </trans-unit>
        <trans-unit id="c4a1b6c77417175321e74a3e09c3c5bfa3b1a669" translate="yes" xml:space="preserve">
          <source>The example below shows the various possible use cases:</source>
          <target state="translated">以下の例では、様々なユースケースが考えられます。</target>
        </trans-unit>
        <trans-unit id="cda0c1c869121c0516b4b7eef52cfb72926a1f0c" translate="yes" xml:space="preserve">
          <source>The exit code.</source>
          <target state="translated">出口のコード。</target>
        </trans-unit>
        <trans-unit id="507fe61a8f648672fa6038e5dfbc9edeb36a23b2" translate="yes" xml:space="preserve">
          <source>The expanded toString() of this CharSequence</source>
          <target state="translated">この CharSequence の展開された toString()</target>
        </trans-unit>
        <trans-unit id="c2d08e701963d2aabc470d83a9d8da90b7362df5" translate="yes" xml:space="preserve">
          <source>The extension method registry is responsible for collecting methods (or static methods) which are added to existing classes and may be called like regular methods.</source>
          <target state="translated">拡張メソッドレジストリは、既存のクラスに追加され、通常のメソッドのように呼び出すことができるメソッド (または静的メソッド)を収集する役割を担っています。</target>
        </trans-unit>
        <trans-unit id="aa6754ebfc303c012b03fb4abba3b5f12ccb8b6c" translate="yes" xml:space="preserve">
          <source>The extension of the artifact (normally safe to leave at default value of &quot;jar&quot; but other values like &quot;zip&quot; are sometimes useful).</source>
          <target state="translated">アーティファクトの拡張子(通常は &quot;jar &quot;のデフォルト値のままにしておいても安全ですが、&quot;zip &quot;のような他の値が役に立つこともあります)。</target>
        </trans-unit>
        <trans-unit id="2e641d1d3bf6e1800547d3ef352762fcba029ed7" translate="yes" xml:space="preserve">
          <source>The extra grab configuration.</source>
          <target state="translated">おまけのグラボ構成。</target>
        </trans-unit>
        <trans-unit id="4cd2c5f11d6d27f858d5d3dc59a3083f35bfd20b" translate="yes" xml:space="preserve">
          <source>The field of this property</source>
          <target state="translated">本物件のフィールド</target>
        </trans-unit>
        <trans-unit id="b234649fde6d931b7e01052a7041604ee37062c4" translate="yes" xml:space="preserve">
          <source>The first argument of the method is only used to tell the class for which we add a static method. You can now define an extension module:</source>
          <target state="translated">メソッドの第一引数は、静的メソッドを追加するクラスを伝えるためにのみ使用されます。これで拡張モジュールを定義することができます。</target>
        </trans-unit>
        <trans-unit id="8f1c3d2c6a3794b89910b38b5fc0a80c1e72651e" translate="yes" xml:space="preserve">
          <source>The first element returned by the Iterable's iterator is returned. If the Iterable doesn't guarantee a defined order it may appear like a random element is returned.</source>
          <target state="translated">イテラーブルのイテレータによって返される最初の要素が返されます。イテレータブルが定義された順序を保証していない場合は、ランダムな要素が返されるように見えるかもしれません。</target>
        </trans-unit>
        <trans-unit id="f788a50cfac60f792deddd7ec215420ae4c26518" translate="yes" xml:space="preserve">
          <source>The following attributes are optional.</source>
          <target state="translated">以下の属性は任意です。</target>
        </trans-unit>
        <trans-unit id="7a78a58b8d15f66560b1ee62392912456c7f7d2b" translate="yes" xml:space="preserve">
          <source>The following code is generated:</source>
          <target state="translated">以下のようなコードが生成されます。</target>
        </trans-unit>
        <trans-unit id="c6db6ec58fab215cd6939fb661b05cc65eb0427a" translate="yes" xml:space="preserve">
          <source>The following example describes a closure as accepting a single signature (List&amp;lt;T&amp;gt; list -&amp;gt;):</source>
          <target state="translated">次の例では、クロージャを単一の署名（List &amp;lt;T&amp;gt; list-&amp;gt;）を受け入れるものとして説明しています。</target>
        </trans-unit>
        <trans-unit id="1deb2c32e07a91866a38699ca2b5e5576a8b7889" translate="yes" xml:space="preserve">
          <source>The following example shows how you can use this annotation on fields of a class:</source>
          <target state="translated">次の例は、クラスのフィールドでこのアノテーションを使用する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="38490d2869c131045bab21ff7ca6b124ab7e1e94" translate="yes" xml:space="preserve">
          <source>The following is an example usage. Note that within a &quot;with&quot; block you need to specify a parameter name so that this.println is not called instead of IndentPrinter.println:</source>
          <target state="translated">以下に使用例を示します。with &quot;ブロック内では、IndentPrinter.printlnの代わりにthis.printlnが呼ばれないように、パラメータ名を指定する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="bb6e88658d6aafa0e1c5fb88a8e22112ec44c060" translate="yes" xml:space="preserve">
          <source>The following is sample usage of the annotation forcing the script to timeout after 5 minutes (300 seconds):</source>
          <target state="translated">以下は、5分(300秒)後にスクリプトを強制的にタイムアウトさせるアノテーションの使用例です。</target>
        </trans-unit>
        <trans-unit id="7079281a140b1fc8b280d5f645e024ae9a37bc71" translate="yes" xml:space="preserve">
          <source>The following is sample usage of the annotation:</source>
          <target state="translated">以下にアノテーションの使用例を示します。</target>
        </trans-unit>
        <trans-unit id="879e99e6a011963f4f6df39ba4aa585918568fcd" translate="yes" xml:space="preserve">
          <source>The following properties are referenced when setting the configuration:</source>
          <target state="translated">設定時に参照するプロパティは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="20f832237a68dcebeb6521dde3b85b13bd8f5117" translate="yes" xml:space="preserve">
          <source>The following scenarios can not set accessible, i.e. the return value is false 1) SecurityException occurred 2) the accessible object is a Constructor object for the Class class</source>
          <target state="translated">以下のシナリオでは、アクセス可能なオブジェクトを設定することはできません。つまり、戻り値が false である 1)SecurityException が発生した 2)アクセス可能なオブジェクトがクラスクラスのコンストラクタオブジェクトである</target>
        </trans-unit>
        <trans-unit id="5775c2755497d25926312a1fe22b019fe16dce69" translate="yes" xml:space="preserve">
          <source>The following servlet init parameter name can be used to specify the encoding TemplateServlet will use to read the template groovy source files:</source>
          <target state="translated">以下の servlet init パラメータ名を使用して、TemplateServlet がテンプレート groovy ソースファイルを読み込む際に使用するエンコーディングを指定することができます。</target>
        </trans-unit>
        <trans-unit id="6c10ecb3564857baa02ca7a4bdd0fbed3c5fdf34" translate="yes" xml:space="preserve">
          <source>The following shows all of the different syntax forms supported by the node.</source>
          <target state="translated">以下に、ノードがサポートするすべての異なる構文形式を示します。</target>
        </trans-unit>
        <trans-unit id="402c79945cb622bc852b23a63a5a225b6b97c510" translate="yes" xml:space="preserve">
          <source>The following system properties are referenced when setting the configuration optimization options:</source>
          <target state="translated">構成の最適化オプションを設定する際には、以下のシステムプロパティが参照されます。</target>
        </trans-unit>
        <trans-unit id="589daf472d87f60da3820df2375540a65850b000" translate="yes" xml:space="preserve">
          <source>The following will be output:</source>
          <target state="translated">以下のように出力されます。</target>
        </trans-unit>
        <trans-unit id="3affea3413fcaa516e9b68e8682b4216a488ecf1" translate="yes" xml:space="preserve">
          <source>The found MetaProperty or null if it doesn't exist</source>
          <target state="translated">見つかったMetaProperty、存在しない場合はnull</target>
        </trans-unit>
        <trans-unit id="363824e3df035b97ca5a7ffba69200b946d3b768" translate="yes" xml:space="preserve">
          <source>The functionality provided by tr can be achieved using regular expressions but tr provides a much more compact notation and efficient implementation for certain scenarios.</source>
          <target state="translated">tr が提供する機能は正規表現を使用して実現できますが、tr はよりコンパクトな記法と特定のシナリオのための効率的な実装を提供します。</target>
        </trans-unit>
        <trans-unit id="8f49e8b4f671d3af1ab3b54839c50c3ad9cb19cd" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;canEqual&lt;/code&gt; methods will be something like below:</source>
          <target state="translated">生成される &lt;code&gt;equals&lt;/code&gt; メソッドと &lt;code&gt;canEqual&lt;/code&gt; メソッドは次のようになります。</target>
        </trans-unit>
        <trans-unit id="016adc8430975ce5b3714e3f00410813056eb5c1" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;toString&lt;/code&gt; will include property names and exclude the &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; properties.</source>
          <target state="translated">生成された &lt;code&gt;toString&lt;/code&gt; プロパティ名を含めると除外されます &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; のプロパティを。</target>
        </trans-unit>
        <trans-unit id="36d5e288e1f29d364f8118145d20f640ba8a3434" translate="yes" xml:space="preserve">
          <source>The generated Groovy class will:</source>
          <target state="translated">生成されたGroovyクラスは</target>
        </trans-unit>
        <trans-unit id="6ed368a0eaa66dbac47a9b89c0164f8d4c95bba4" translate="yes" xml:space="preserve">
          <source>The generated equals method will be something like below:</source>
          <target state="translated">生成されたイコールメソッドは以下のようなものになります。</target>
        </trans-unit>
        <trans-unit id="7d1e1567f7025b7a32483c0df7c9b9df0c6d2e4e" translate="yes" xml:space="preserve">
          <source>The generated map constructor will have an argument of type &lt;code&gt;Map&lt;/code&gt; unless a single property (or field) is included and the type of that property (or field) is Object, AbstractMap, Map or HashMap. In this case, the generated constructor will be of type &lt;code&gt;LinkedHashMap&lt;/code&gt;. This allows the possibility of also adding a tuple constructor without conflict, although no such constructor is added automatically. You can disable this behavior by setting the specialNamedArgHandling annotation attribute to false. This means that for the special case mentioned above, you will not be able to also add a tuple constructor with a single Map argument but you can supply any kind of map as your argument. We'd also recommend not having both a map constructor and a tuple constructor with a single Object, AbstractMap or HashMap since it can cause confusion as to which will be called.</source>
          <target state="translated">生成されたマップコンストラクターは、単一のプロパティ（またはフィールド）が含まれ、そのプロパティ（またはフィールド）のタイプがObject、AbstractMap、Map、またはHashMapでない限り、タイプ &lt;code&gt;Map&lt;/code&gt; の引数を持ちます。この場合、生成されるコンストラクターは &lt;code&gt;LinkedHashMap&lt;/code&gt; タイプになります。これにより、タプルコンストラクターを競合なしで追加することもできますが、そのようなコンストラクターは自動的に追加されません。 specialNamedArgHandlingアノテーション属性をfalseに設定することで、この動作を無効にできます。つまり、上記の特殊なケースでは、単一のMap引数を持つタプルコンストラクターを追加することはできませんが、引数として任意の種類のマップを指定できます。また、どちらが呼び出されるかについて混乱が生じる可能性があるため、単一のObject、AbstractMap、またはHashMapを持つマップコンストラクターとタプルコンストラクターの両方を使用しないことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="2054e20238e38cbabff60cf87d59cd3bda71ca2d" translate="yes" xml:space="preserve">
          <source>The generated method/constructor retains the visibility and return type of the original method/constructor but the &lt;a href=&quot;visibilityoptions&quot;&gt;VisibilityOptions&lt;/a&gt; annotation can be added to customize the visibility. You could have the annotated method/constructor private for instance but have the generated one be public.</source>
          <target state="translated">生成されたメソッド/コンストラクターは、元のメソッド/コンストラクターの可視性と戻り値の型を保持しますが、&lt;a href=&quot;visibilityoptions&quot;&gt;VisibilityOptions&lt;/a&gt;アノテーションを追加して可視性をカスタマイズできます。たとえば、アノテーション付きのメソッド/コンストラクターをプライベートにし、生成されたメソッド/コンストラクターをパブリックにすることができます。</target>
        </trans-unit>
        <trans-unit id="9d8c55bbbf0e4e8d80618bab6f8e1e859dd3d404" translate="yes" xml:space="preserve">
          <source>The generated methods must not already exist</source>
          <target state="translated">生成されたメソッドは、すでに存在してはいけません。</target>
        </trans-unit>
        <trans-unit id="c757fafc4af8d85241ca605d29734fb8e7040c3a" translate="yes" xml:space="preserve">
          <source>The groovy.lang.Closure will be given the class name as parameter. the return value decides if the element will be added or not.</source>
          <target state="translated">groovy.lang.Closureには、パラメータとしてクラス名が与えられます。</target>
        </trans-unit>
        <trans-unit id="73d792c97d713c524a35ad9cb7269ec2f224a2f7" translate="yes" xml:space="preserve">
          <source>The groovy.mock.interceptor is an all-groovy mock testing library.</source>
          <target state="translated">groovy.mock.interceptorは、オールグルーヴィーなモックテストライブラリです。</target>
        </trans-unit>
        <trans-unit id="d08cb5974fee471582bb6c391e801a198206f54c" translate="yes" xml:space="preserve">
          <source>The handle should be registered with the Groovy runtime &lt;strong&gt;before&lt;/strong&gt; Groovy loads, for example in your main method. &lt;code&gt;GroovySystem.metaClassRegistry.metaClassCreationHandle = new ExpandoMetaClassCreationHandle()&lt;/code&gt;</source>
          <target state="translated">ハンドルは、Groovyがロードさ&lt;strong&gt;れる前&lt;/strong&gt;に、たとえばmainメソッドでGroovyランタイム&lt;strong&gt;に&lt;/strong&gt;登録する必要があります。 &lt;code&gt;GroovySystem.metaClassRegistry.metaClassCreationHandle = new ExpandoMetaClassCreationHandle()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d7a6bf7e30e4e5adaebfa336015e1d6db546b0dc" translate="yes" xml:space="preserve">
          <source>The hash table data.</source>
          <target state="translated">ハッシュテーブルのデータです。</target>
        </trans-unit>
        <trans-unit id="0be72dcbde8376507858e5e3b4f88ceb470819fe" translate="yes" xml:space="preserve">
          <source>The idea for this AST transformation originated in &lt;a href=&quot;../test/groovytestcase#notYetImplemented()&quot;&gt;GroovyTestCase.notYetImplemented&lt;/a&gt;.</source>
          <target state="translated">このAST変換のアイデアは、&lt;a href=&quot;../test/groovytestcase#notYetImplemented()&quot;&gt;GroovyTestCase.notYetImplementedに&lt;/a&gt;端を発しています。</target>
        </trans-unit>
        <trans-unit id="1e6b7d618961498090102436a153ea6769f4ea92" translate="yes" xml:space="preserve">
          <source>The index of the generic type that will be the type of the closure's delegate.</source>
          <target state="translated">クロージャのデリゲートの型となる汎用型のインデックス。</target>
        </trans-unit>
        <trans-unit id="4a05df6a03c832914a468e9a8f09e99bb76121ca" translate="yes" xml:space="preserve">
          <source>The index of the generic type that will be the type of the closure's delegate. The generic types are considered with respect to the &lt;code&gt;@DelegatesTo.Target&lt;/code&gt; annotated parameter for this usage, with the index starting at 0.</source>
          <target state="translated">クロージャーのデリゲートのタイプとなるジェネリック型のインデックス。ジェネリック型は、この使用法の &lt;code&gt;@DelegatesTo.Target&lt;/code&gt; アノテーション付きパラメーターに関して考慮され、インデックスは0から始まります。</target>
        </trans-unit>
        <trans-unit id="8f4812f2fcebeff3b4ebb6e2b6159d4da2a14e7a" translate="yes" xml:space="preserve">
          <source>The initial size of the memory for the underlying VM if javac is run externally; ignored otherwise.</source>
          <target state="translated">javac が外部から実行される場合、基礎となる VM のメモリの初期サイズ。</target>
        </trans-unit>
        <trans-unit id="9906cb8cda50e01b5fc0296c2ebddf1998c07481" translate="yes" xml:space="preserve">
          <source>The initial size of the memory for the underlying VM if javac is run externally; ignored otherwise. Defaults to the standard VM memory setting. (Examples: 83886080, 81920k, or 80m)</source>
          <target state="translated">javacが外部で実行されている場合、基礎となるVMのメモリの初期サイズを指定しますが、それ以外の場合は無視されます。デフォルトは標準のVMメモリ設定です。(例:83886080、81920k、または80m)</target>
        </trans-unit>
        <trans-unit id="09418ac5ed51e2ae7deca28347160febab7297a9" translate="yes" xml:space="preserve">
          <source>The initial value</source>
          <target state="translated">初期値</target>
        </trans-unit>
        <trans-unit id="cca553e21f81b340e4552ee970c2d402d976a297" translate="yes" xml:space="preserve">
          <source>The interface implemented by all Groovy objects.</source>
          <target state="translated">すべてのGroovyオブジェクトで実装されているインターフェイスです。</target>
        </trans-unit>
        <trans-unit id="d36584fdf4c93d8244b01640584ce4681a2619d4" translate="yes" xml:space="preserve">
          <source>The isCallToSuper and fromInsideClass help the Groovy runtime perform optimisations on the call to go directly to the super class if necessary</source>
          <target state="translated">isCallToSuperとfromInsideClassは、Groovyランタイムが必要に応じて直接スーパークラスに行くための呼び出しの最適化を実行するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="7a7346df5fc4b24f592e6ab3da8efbdbdb2e3f57" translate="yes" xml:space="preserve">
          <source>The iterator stepped along by &lt;code&gt;num&lt;/code&gt; elements if they exist.</source>
          <target state="translated">イテレータは、存在する場合は &lt;code&gt;num&lt;/code&gt; 個の要素をステップ実行します。</target>
        </trans-unit>
        <trans-unit id="825771f9b59209884bd5990f89392f472ab52a1c" translate="yes" xml:space="preserve">
          <source>The java.lang.Class instance</source>
          <target state="translated">java.lang.Classのインスタンス</target>
        </trans-unit>
        <trans-unit id="39162451983f218a6022c93f55c40cf3576ffa56" translate="yes" xml:space="preserve">
          <source>The last element returned by the Iterable's iterator is returned. If the Iterable doesn't guarantee a defined order it may appear like a random element is returned.</source>
          <target state="translated">イテラーブルのイテレータによって返された最後の要素が返されます。イテレータブルが定義された順序を保証していない場合、ランダムな要素が返されるように見えるかもしれません。</target>
        </trans-unit>
        <trans-unit id="d2b9d6958fb3428a858e3ff1b7e7d575c9444949" translate="yes" xml:space="preserve">
          <source>The lexer for Groovy programming language, which is based on the lexer generated by Antlr4</source>
          <target state="translated">Antlr4 で生成されたレキサーをベースにした Groovy プログラミング言語用のレキサーです。</target>
        </trans-unit>
        <trans-unit id="9bacfbe842c2f1b3272b7632dbf718566ac8d700" translate="yes" xml:space="preserve">
          <source>The lexer reads JSON tokens in a streaming fashion from the underlying reader.</source>
          <target state="translated">レクサーは、基礎となるリーダーからストリーミング形式でJSONトークンを読み込みます。</target>
        </trans-unit>
        <trans-unit id="f5ca3610dac449f90a9e358ccee55e7567cc07b1" translate="yes" xml:space="preserve">
          <source>The line.</source>
          <target state="translated">ラインです。</target>
        </trans-unit>
        <trans-unit id="b7ba62139a54b7638c01550fb541cf6269ed40be" translate="yes" xml:space="preserve">
          <source>The list of (classpath resources) paths to type checking DSL scripts, also known as type checking extensions.</source>
          <target state="translated">型検査拡張機能としても知られる型検査DSLスクリプトへの(クラスパスリソースの)パスのリスト。</target>
        </trans-unit>
        <trans-unit id="e9ece14574ea4cdf3337639446998372a41bef30" translate="yes" xml:space="preserve">
          <source>The listener is invoked by &lt;a href=&quot;concurrentlinkedhashmap&quot;&gt;ConcurrentLinkedHashMap&lt;/a&gt; on a caller's thread and will not block other threads from operating on the map. An implementation should be aware that the caller's thread will not expect long execution times or failures as a side effect of the listener being notified. Execution safety and a fast turn around time can be achieved by performing the operation asynchronously, such as by submitting a task to an &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html&quot;&gt;ExecutorService&lt;/a&gt;.</source>
          <target state="translated">リスナーは、呼び出し元のスレッドで&lt;a href=&quot;concurrentlinkedhashmap&quot;&gt;ConcurrentLinkedHashMap&lt;/a&gt;によって呼び出され、他のスレッドがマップ上で動作するのをブロックしません。実装は、呼び出し元のスレッドが、通知されるリスナーの副作用として、長い実行時間や失敗を予期しないことに注意する必要があります。実行の安全性と迅速なターンアラウンドタイムは、&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html&quot;&gt;ExecutorServiceに&lt;/a&gt;タスクを送信するなど、非同期で操作を実行することで実現できます。</target>
        </trans-unit>
        <trans-unit id="47f12bc7a7163b88b7c40a6143c735e189ed9d15" translate="yes" xml:space="preserve">
          <source>The load factor for the hash table.</source>
          <target state="translated">ハッシュテーブルの負荷係数。</target>
        </trans-unit>
        <trans-unit id="24eb861382bd4ecd59d0d7b27ffc4a02974042ef" translate="yes" xml:space="preserve">
          <source>The long name of this option.</source>
          <target state="translated">このオプションの長い名前。</target>
        </trans-unit>
        <trans-unit id="16e53b8a2be8a710bfb615e37e77de8bcde7fbfe" translate="yes" xml:space="preserve">
          <source>The long name of this option. Defaults to the name of member being annotated.</source>
          <target state="translated">このオプションの長い名前。デフォルトは、アノテーションされるメンバーの名前です。</target>
        </trans-unit>
        <trans-unit id="a1c14e51c7082ed212704f80fa16a5caa5f4b2e7" translate="yes" xml:space="preserve">
          <source>The lower value in the range.</source>
          <target state="translated">範囲内の低い方の値。</target>
        </trans-unit>
        <trans-unit id="d70a0a182db9bd82ea7fc6368b0f23fdc024a4f0" translate="yes" xml:space="preserve">
          <source>The main class code visitor responsible for static type checking. It will perform various inspections like checking assignment types, type inference, ... Eventually, class nodes may be annotated with inferred type information.</source>
          <target state="translated">静的型検査を担当するメインクラスのコードビジタです。代入型のチェックや型推論など、様々な検査を行います。最終的には、クラスノードに推論された型情報がアノテーションされることがあります。</target>
        </trans-unit>
        <trans-unit id="a35d780b7b7d71330b5a704f00aff27069bd32b6" translate="yes" xml:space="preserve">
          <source>The main function of the registry If a meta class exists then return it otherwise create one, put it in the registry and return it</source>
          <target state="translated">レジストリの主な関数 メタクラスが存在する場合はそれを返し、そうでない場合はメタクラスを作成してレジストリに入れ、それを返します。</target>
        </trans-unit>
        <trans-unit id="e07dbd7ee535fe35b6529b949ce03a3cdd12de16" translate="yes" xml:space="preserve">
          <source>The main instance method of a script which has variables in scope as defined by the current &lt;a href=&quot;binding&quot;&gt;Binding&lt;/a&gt; instance.</source>
          <target state="translated">現在の&lt;a href=&quot;binding&quot;&gt;Binding&lt;/a&gt;インスタンスによって定義されたスコープ内の変数を持つスクリプトのメインインスタンスメソッド。</target>
        </trans-unit>
        <trans-unit id="a25dec9e9a77a814a53504ab23b75ca4e697cf0f" translate="yes" xml:space="preserve">
          <source>The map values are the normal values provided as the second parameter to &lt;code&gt;java.util.Calendar#set(int, int)&lt;/code&gt;. The keys can either be the normal fields values provided as the first parameter to that method or one of the following Strings:</source>
          <target state="translated">マップ値は、 &lt;code&gt;java.util.Calendar#set(int, int)&lt;/code&gt; の2番目のパラメーターとして提供される通常の値です。キーは、そのメソッドの最初のパラメーターとして提供される通常のフィールド値、または次の文字列のいずれかです。</target>
        </trans-unit>
        <trans-unit id="731e1e3475853eb36e2f419522ace251acd1d87b" translate="yes" xml:space="preserve">
          <source>The maximum elapsed time the script will be allowed to run for.</source>
          <target state="translated">スクリプトの実行が許可される最大経過時間。</target>
        </trans-unit>
        <trans-unit id="8a9744c288c3ec0b1b71c029102e0ca0c0c4e606" translate="yes" xml:space="preserve">
          <source>The maximum elapsed time the script will be allowed to run for. By default it is measure in seconds</source>
          <target state="translated">スクリプトの実行を許可する最大経過時間。デフォルトでは秒単位で設定されています。</target>
        </trans-unit>
        <trans-unit id="4c2ffed2aec71628097d548244a5403333d478d2" translate="yes" xml:space="preserve">
          <source>The maximum number of directory levels when recursing (default is -1 which means infinite, set to 0 for no recursion)</source>
          <target state="translated">再帰時のディレクトリレベルの最大数 (デフォルトは -1 で無限を意味し、再帰を行わない場合は 0 に設定)</target>
        </trans-unit>
        <trans-unit id="a3d134d4c35a591a550b0133ec3ffcec626a2ca1" translate="yes" xml:space="preserve">
          <source>The maximum size of the memory for the underlying VM if javac is run externally; ignored otherwise.</source>
          <target state="translated">javac が外部から実行される場合、基礎となる VM のメモリの最大サイズ。</target>
        </trans-unit>
        <trans-unit id="d53256043cb34b5f9af6acb675b49a62d63df5c8" translate="yes" xml:space="preserve">
          <source>The maximum size of the memory for the underlying VM if javac is run externally; ignored otherwise. Defaults to the standard VM memory setting. (Examples: 83886080, 81920k, or 80m)</source>
          <target state="translated">javacが外部で実行されている場合、基礎となるVMのメモリの最大サイズを指定します。デフォルトは標準のVMメモリ設定です。(例:83886080、81920k、または80m)</target>
        </trans-unit>
        <trans-unit id="be8a261b2c86bdec542c4bdc16f3f9b00cf90718" translate="yes" xml:space="preserve">
          <source>The maximum size the cache can grow to.</source>
          <target state="translated">キャッシュが成長できる最大サイズ。</target>
        </trans-unit>
        <trans-unit id="a932fa7b6f4119b32f6b4708d0afeedb86270516" translate="yes" xml:space="preserve">
          <source>The mechanics: during compilation, all methods are transformed to static ones with an additional self parameter of the type you supply as the annotation parameter (the default type for the self parameters is &lt;code&gt;Object&lt;/code&gt; which might be more broad reaching than you like so it is usually wise to specify a type). Properties invoked using 'this' references are transformed so that they are instead invoked on the additional self parameter and not on the Category instance. (Remember that once the category is applied, the reverse will occur and we will be back to conceptually having methods on the &lt;code&gt;this&lt;/code&gt; references again!)</source>
          <target state="translated">メカニズム：コンパイル中に、すべてのメソッドは、アノテーションパラメーターとして指定したタイプの追加の自己パラメーターを使用して静的メソッドに変換されます（自己パラメーターのデフォルトのタイプは &lt;code&gt;Object&lt;/code&gt; であり、通常よりも広範囲に及ぶ可能性があります）タイプを指定するのが賢明です）。 'this'参照を使用して呼び出されたプロパティは、Categoryインスタンスではなく、追加のselfパラメーターで呼び出されるように変換されます。 （カテゴリが適用されると、逆のことが発生し、 &lt;code&gt;this&lt;/code&gt; 参照のメソッドを概念的に再び持つことに戻ります！）</target>
        </trans-unit>
        <trans-unit id="2666c74280324e9c05645b343443d5ae919ca593" translate="yes" xml:space="preserve">
          <source>The message is a little cryptic, but it is basically the static compiler telling us that the third parameter, &lt;code&gt;age&lt;/code&gt; in our case, is unset. You can also add this annotation to your predefined constructors. These will be made private and an initializer will be set up to call your constructor. Any parameters to your constructor become the properties expected by the initializer. If you use such a builder on a constructor as well as on the class or on more than one constructor, then it is up to you to define unique values for 'builderClassName' and 'builderMethodName' for each annotation.</source>
          <target state="translated">メッセージは少しわかりにくいですが、基本的には静的コンパイラであり、3番目のパラメータ（この場合は &lt;code&gt;age&lt;/code&gt; ）が設定されていないことを示しています。このアノテーションを事前定義されたコンストラクターに追加することもできます。これらはプライベートになり、コンストラクターを呼び出すように初期化子が設定されます。コンストラクターへのパラメーターはすべて、初期化子が期待するプロパティになります。このようなビルダーをコンストラクター、クラス、または複数のコンストラクターで使用する場合は、アノテーションごとに「builderClassName」と「builderMethodName」に一意の値を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="233f1eda634fadbf2d6de9fdbba96a43cfac37b3" translate="yes" xml:space="preserve">
          <source>The meta map generated.</source>
          <target state="translated">メタマップが生成されました。</target>
        </trans-unit>
        <trans-unit id="481ab6cb4af59496e16e981430f5212574c520b3" translate="yes" xml:space="preserve">
          <source>The method &quot;is&quot; is used to test for equal references.</source>
          <target state="translated">メソッド &quot;is &quot;を使用して、均等な参照をテストします。</target>
        </trans-unit>
        <trans-unit id="10a0b965a2d07d42bb108200564cd0092fef8a4b" translate="yes" xml:space="preserve">
          <source>The method &quot;is&quot; is used to test for equal references. This method will return true only if the given parameter is null</source>
          <target state="translated">is &quot;メソッドは、等しい参照をテストするために使用されます。このメソッドは、与えられたパラメータがnullの場合にのみtrueを返します。</target>
        </trans-unit>
        <trans-unit id="046b59ea660985a374595a12ce69c4e51a167400" translate="yes" xml:space="preserve">
          <source>The method descriptor of the method from the trait</source>
          <target state="translated">形質からのメソッド記述子</target>
        </trans-unit>
        <trans-unit id="0b11d5e3b0af8fe608284cd9acdeefcad67a7934" translate="yes" xml:space="preserve">
          <source>The method is invoked when an AST Transformation is active.</source>
          <target state="translated">このメソッドはAST変換がアクティブなときに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="3ad8ddc19cf1fe16c4946011a31c3d7615aae395" translate="yes" xml:space="preserve">
          <source>The method is invoked when an AST Transformation is active. For local transformations, it is invoked once each time the local annotation is encountered. For global transformations, it is invoked once for every source unit, which is typically a source file.</source>
          <target state="translated">このメソッドは、AST変換がアクティブなときに呼び出されます。ローカル変換の場合は、ローカルアノテーションが見つかるたびに一度だけ呼び出されます。グローバル変換の場合は、ソース単位(通常はソースファイル)ごとに1回呼び出されます。</target>
        </trans-unit>
        <trans-unit id="16096b1fa8363d7f7f3486f5931631ff7821604c" translate="yes" xml:space="preserve">
          <source>The method is similar with &lt;a href=&quot;genericsutils#makeDeclaringAndActualGenericsTypeMap(org.codehaus.groovy.ast.ClassNode,%20org.codehaus.groovy.ast.ClassNode)&quot;&gt;GenericsUtils.makeDeclaringAndActualGenericsTypeMap&lt;/a&gt;, The main difference is that the method will try to map all placeholders found to the relevant exact types, but the other will not try even if the parameterized type has placeholders</source>
          <target state="translated">このメソッドは&lt;a href=&quot;genericsutils#makeDeclaringAndActualGenericsTypeMap(org.codehaus.groovy.ast.ClassNode,%20org.codehaus.groovy.ast.ClassNode)&quot;&gt;GenericsUtils.makeDeclaringAndActualGenericsTypeMap&lt;/a&gt;と似ています。主な違いは、メソッドは見つかったすべてのプレースホルダーを関連する正確なタイプにマップしようとしますが、パラメーター化されたタイプにプレースホルダーがある場合でも、他のメソッドは試行しないことです。</target>
        </trans-unit>
        <trans-unit id="ebd121539032d1aa634563f13cd1d7bb73f83b33" translate="yes" xml:space="preserve">
          <source>The method name</source>
          <target state="translated">メソッド名</target>
        </trans-unit>
        <trans-unit id="9107c6d41421afd6c4262deaacc88cd7b897fd8a" translate="yes" xml:space="preserve">
          <source>The method name to use for a builder factory method in the source class for easy access of the builder helper class for strategies which create such a helper class.</source>
          <target state="translated">このようなヘルパークラスを作成するストラテジーのためのビルダーヘルパークラスへのアクセスを容易にするために、ソースクラス内のビルダーファクトリーメソッドに使用するメソッド名。</target>
        </trans-unit>
        <trans-unit id="d156486b828194de0dc1376f435a69303f46b5c6" translate="yes" xml:space="preserve">
          <source>The method name to use for a builder factory method in the source class for easy access of the builder helper class for strategies which create such a helper class. Must not be used if using &lt;code&gt;forClass&lt;/code&gt;. Default is determined by the strategy, e.g. &lt;em&gt;builder&lt;/em&gt; or &lt;em&gt;createInitializer&lt;/em&gt;.</source>
          <target state="translated">ソースクラスのビルダーファクトリメソッドに使用するメソッド名。このようなヘルパークラスを作成するストラテジーのビルダーヘルパークラスに簡単にアクセスできます。 &lt;code&gt;forClass&lt;/code&gt; を使用する場合は使用しないでください。デフォルトは、&lt;em&gt;builder&lt;/em&gt;や&lt;em&gt;createInitializer&lt;/em&gt;などの戦略によって決定されます。</target>
        </trans-unit>
        <trans-unit id="19190b8bf1a50223552a2ea9092d0e868f9b58bb" translate="yes" xml:space="preserve">
          <source>The method omits padding and is equivalent to calling &lt;a href=&quot;encodinggroovymethods#encodeBase64Url(Byte%5B%5D,%20boolean)&quot;&gt;EncodingGroovyMethods.encodeBase64Url&lt;/a&gt; with a value of &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">このメソッドはパディングを省略し、 &lt;code&gt;false&lt;/code&gt; の値で&lt;a href=&quot;encodinggroovymethods#encodeBase64Url(Byte%5B%5D,%20boolean)&quot;&gt;EncodingGroovyMethods.encodeBase64Url&lt;/a&gt;を呼び出すのと同じです。</target>
        </trans-unit>
        <trans-unit id="fd16bad639c8dbfe1c2afb5d210c9fca412a986a" translate="yes" xml:space="preserve">
          <source>The method omits padding and is equivalent to calling &lt;a href=&quot;encodinggroovymethods#encodeBase64Url(byte%5B%5D,%20boolean)&quot;&gt;EncodingGroovyMethods.encodeBase64Url&lt;/a&gt; with a value of &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">このメソッドはパディングを省略し、 &lt;code&gt;false&lt;/code&gt; の値で&lt;a href=&quot;encodinggroovymethods#encodeBase64Url(byte%5B%5D,%20boolean)&quot;&gt;EncodingGroovyMethods.encodeBase64Url&lt;/a&gt;を呼び出すのと同じです。</target>
        </trans-unit>
        <trans-unit id="977caf0a01596f416e854564419eecf39b01c39d" translate="yes" xml:space="preserve">
          <source>The method returns</source>
          <target state="translated">メソッドは</target>
        </trans-unit>
        <trans-unit id="233550ffa2aace49d6789bba08354b9269776fba" translate="yes" xml:space="preserve">
          <source>The methods found in this class are made directly available in type checking scripts through the &lt;a href=&quot;groovytypecheckingextensionsupport&quot;&gt;GroovyTypeCheckingExtensionSupport&lt;/a&gt; class.</source>
          <target state="translated">このクラスにあるメソッドは、&lt;a href=&quot;groovytypecheckingextensionsupport&quot;&gt;GroovyTypeCheckingExtensionSupport&lt;/a&gt;クラスを介して型チェックスクリプトで直接使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="3f7b0d22db711005969846defb7c99717fa91841" translate="yes" xml:space="preserve">
          <source>The modified implementation is based on StringUtils#replace(String text, String searchString, String replacement, int max), Apache commons-lang3-3.6</source>
          <target state="translated">修正された実装は、StringUtils#replace(String text,String searchString,String replacement,int max)、Apache commons-lang3-3.6 に基づいています。</target>
        </trans-unit>
        <trans-unit id="50fbba6f75c792f1af5c5472d076319e1dc8e8c0" translate="yes" xml:space="preserve">
          <source>The module or artifact, e.g.: &quot;ant-junit&quot;.</source>
          <target state="translated">モジュールまたはアーティファクト、例えば &quot;ant-junit&quot;。</target>
        </trans-unit>
        <trans-unit id="9ecf7b850507e5a2a96948e13f72e6da5a6b2250" translate="yes" xml:space="preserve">
          <source>The module or artifact, e.g.: &quot;ant-junit&quot;. A non-empty value is required unless value() is used.</source>
          <target state="translated">モジュールまたはアーティファクト、例えば &quot;ant-junit&quot;。value()が使用されない限り、空でない値が必要です。</target>
        </trans-unit>
        <trans-unit id="8998068077ca7885c0e4186f470a1345f7bcaabe" translate="yes" xml:space="preserve">
          <source>The module or artifact, e.g.: &quot;ant-junit&quot;; required unless the compact form is used.</source>
          <target state="translated">モジュールまたはアーティファクト,例えば &quot;ant-junit&quot;;コンパクト形式を使用しない限り必須。</target>
        </trans-unit>
        <trans-unit id="67b83bce5d6428054b151a952a38c76fc1400e95" translate="yes" xml:space="preserve">
          <source>The name of the command.</source>
          <target state="translated">コマンドの名前です。</target>
        </trans-unit>
        <trans-unit id="43aae32f2ac7a4701fa066c8a7276ef64ed1c079" translate="yes" xml:space="preserve">
          <source>The name of the property. The name is &quot;get&quot;+ the capitalized propertyName or, in the case of boolean values, &quot;is&quot; + the capitalized propertyName</source>
          <target state="translated">プロパティの名前。名前は、&quot;get &quot;+大文字のプロパティ名、またはブール値の場合は &quot;is &quot;+大文字のプロパティ名です。</target>
        </trans-unit>
        <trans-unit id="38191355c55cbbc00969fffa25036a9e046325a0" translate="yes" xml:space="preserve">
          <source>The name of the property. The name is &quot;set&quot;+ the capitalized propertyName.</source>
          <target state="translated">プロパティの名前です。名前は &quot;set &quot;+大文字のpropertyNameです。</target>
        </trans-unit>
        <trans-unit id="a15c19401cb99e1843f9f1f65dd9a34cd037b984" translate="yes" xml:space="preserve">
          <source>The new MetaClass</source>
          <target state="translated">新しいMetaClass</target>
        </trans-unit>
        <trans-unit id="ce3d1a75c8717139ff820f7f834e634eaf7a158b" translate="yes" xml:space="preserve">
          <source>The newly created Calendar</source>
          <target state="translated">新しく作成されたカレンダー</target>
        </trans-unit>
        <trans-unit id="c75c777743c28c6ddb34992b6df6f585ae387f8b" translate="yes" xml:space="preserve">
          <source>The newly created Date</source>
          <target state="translated">新しく作成された日付</target>
        </trans-unit>
        <trans-unit id="343fa99691cb8eb1227394b817b70099749bdacd" translate="yes" xml:space="preserve">
          <source>The next example describes a closure as accepting two signatures (List&amp;lt;T&amp;gt; list -&amp;gt;) and (T t -&amp;gt;):</source>
          <target state="translated">次の例では、クロージャを2つの署名（List &amp;lt;T&amp;gt; list-&amp;gt;）と（T t-&amp;gt;）を受け入れるものとして説明しています。</target>
        </trans-unit>
        <trans-unit id="35ccc24e2e75124aaac905d871e93bf9a5f09134" translate="yes" xml:space="preserve">
          <source>The node must be called with either a value argument or a title: attribute.</source>
          <target state="translated">このノードは、value 引数または title:属性のいずれかを指定して呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="032b81eac6a8ead6bf3bea51101baeb3b3e0d8f0" translate="yes" xml:space="preserve">
          <source>The number of characters actually skipped</source>
          <target state="translated">実際に飛ばした文字数</target>
        </trans-unit>
        <trans-unit id="3c9016a339d21ce2a804e220ce7a8e37661b04db" translate="yes" xml:space="preserve">
          <source>The number of characters read or -1 if there are no more</source>
          <target state="translated">読み込んだ文字数、またはそれ以上の文字がない場合は-1</target>
        </trans-unit>
        <trans-unit id="ecf5ab475eeef8fcb49643a9532fa7b4dc7af88a" translate="yes" xml:space="preserve">
          <source>The number of characters read, or -1 if the end of the stream has been reached</source>
          <target state="translated">読み込んだ文字数、ストリームが終了した場合は-1。</target>
        </trans-unit>
        <trans-unit id="0f80b964b2a13be3af83a2b98edb531c0a483f10" translate="yes" xml:space="preserve">
          <source>The number of needed instructions is thus reduced from 15 to 4. For every entry we save 3 bytecode instructions. This allows better readable bytecode and it allows the JIT to see less bytecode to optimize, helping under the inlining threshold here or there.</source>
          <target state="translated">このようにして、必要な命令の数は15から4に削減されます。各エントリに対して、3つのバイトコード命令を保存しています。これにより、より読みやすいバイトコードを実現し、JIT が最適化するバイトコードの数を減らすことができます。</target>
        </trans-unit>
        <trans-unit id="d66cf7d98d8141c6d3db9afd12ffdb8fc3310252" translate="yes" xml:space="preserve">
          <source>The object holding the data value.</source>
          <target state="translated">データ値を保持するオブジェクト。</target>
        </trans-unit>
        <trans-unit id="850f532ee8584882c8e75e990fb14ebbbde70875" translate="yes" xml:space="preserve">
          <source>The object that registers method calls on it for the use with Mocks and Stubs. For each call a CallSpec object is added to the recorded list.</source>
          <target state="translated">モックやスタブで使用するために、その上にメソッドの呼び出しを登録するオブジェクトです。呼び出しごとにCallSpecオブジェクトが記録リストに追加されます。</target>
        </trans-unit>
        <trans-unit id="4375205097b015888ab65280d3b96851ded2b956" translate="yes" xml:space="preserve">
          <source>The old MetaClass</source>
          <target state="translated">旧MetaClass</target>
        </trans-unit>
        <trans-unit id="58e4156ceefaea5d9509b6380a238b14d924e012" translate="yes" xml:space="preserve">
          <source>The oldest entry(i.e. the Less Recently Used entry) will be evicted</source>
          <target state="translated">最も古いエントリ(つまり最近使用されていないエントリ)は削除されます。</target>
        </trans-unit>
        <trans-unit id="2dd46ef926874e9055f1e4cf7568213be97d6b34" translate="yes" xml:space="preserve">
          <source>The one and only implementation of a meta class. INTERNAL USE ONLY.</source>
          <target state="translated">メタクラスの唯一の実装です。内部使用のみ。</target>
        </trans-unit>
        <trans-unit id="91a1c774e1d0fe1b0b5303c859052c21b6258376" translate="yes" xml:space="preserve">
          <source>The one-sentence summary for the package derived from the beginning of the description.</source>
          <target state="translated">説明の冒頭から派生したパッケージの一文要約。</target>
        </trans-unit>
        <trans-unit id="9b73f8f765fe9a956ade4dde4833c77ee65e1eb9" translate="yes" xml:space="preserve">
          <source>The only difference between Java strings and JavaScript strings is that in JavaScript, a single quote must be escaped.</source>
          <target state="translated">Javaの文字列とJavaScriptの文字列の唯一の違いは、JavaScriptではシングルクォートをエスケープしなければならないことです。</target>
        </trans-unit>
        <trans-unit id="39accb2b332a1b9e56c3ee6ac627961ec2636b16" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;interceptConstruction&lt;/code&gt; flag allows mocking of constructor calls.</source>
          <target state="translated">オプションの &lt;code&gt;interceptConstruction&lt;/code&gt; フラグを使用すると、コンストラクター呼び出しのモックを作成できます。</target>
        </trans-unit>
        <trans-unit id="2144302020ab0d839d4af265778a87ee9caa1988" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;interceptConstruction&lt;/code&gt; flag allows mocking of constructor calls. These are represented in the demand specification using the class name as this example shows:</source>
          <target state="translated">オプションの &lt;code&gt;interceptConstruction&lt;/code&gt; フラグを使用すると、コンストラクター呼び出しのモックを作成できます。これらは、この例が示すように、クラス名を使用して需要仕様で表されます。</target>
        </trans-unit>
        <trans-unit id="d46ce745b7d040a6af0b7952e782405f90be5a6f" translate="yes" xml:space="preserve">
          <source>The optional parameter for tags like &quot;throws&quot; and &quot;param&quot;.</source>
          <target state="translated">throws &quot;や &quot;param &quot;のようなタグのオプションパラメータ。</target>
        </trans-unit>
        <trans-unit id="7e32f979195511f753ad4cf62e43dcd18cd136c7" translate="yes" xml:space="preserve">
          <source>The options array is used to modify the behavior of this hint. Each string in the option array consists of a key=value pair.</source>
          <target state="translated">オプシ ョ ン配列は、 このヒントの動作を変更するために用いられます。オプション配列の各文字列は、 key=value のペアで構成されています。</target>
        </trans-unit>
        <trans-unit id="7b48b46c9d0ec14ed87e0211dbb48b950e8e8d55" translate="yes" xml:space="preserve">
          <source>The order of parameters is given by the properties of any super classes (if &lt;code&gt;includeSuperProperties&lt;/code&gt; is set) with the most super first followed by the properties of the class followed by the fields of the class (if &lt;code&gt;includeFields&lt;/code&gt; is set). Within each grouping the order is as attributes appear within the respective class.</source>
          <target state="translated">パラメータの順序は、スーパークラスのプロパティ（ &lt;code&gt;includeSuperProperties&lt;/code&gt; が設定されている場合）によって指定され、最もスーパーが最初で、次にクラスのプロパティ、次にクラスのフィールド（ &lt;code&gt;includeFields&lt;/code&gt; が設定されている場合）が続きます。各グループ内での順序は、属性がそれぞれのクラス内に表示されるときです。</target>
        </trans-unit>
        <trans-unit id="5fbc45ad553a921f8843e5823598f573c5e856ec" translate="yes" xml:space="preserve">
          <source>The organisation or group, e.g.: &quot;org.apache.ant&quot;.</source>
          <target state="translated">組織やグループ。&quot;org.apache.ant&quot;。</target>
        </trans-unit>
        <trans-unit id="adc438730ea65642ec0cc71f1ada8471e6f24d75" translate="yes" xml:space="preserve">
          <source>The organisation or group, e.g.: &quot;org.apache.ant&quot;. A non-empty value is required unless value() is used.</source>
          <target state="translated">組織やグループ。例:&quot;org.apache.ant&quot; value()が使用されない限り、空でない値が必要です。</target>
        </trans-unit>
        <trans-unit id="5c1050236f9bfcb9f997fc983fb0d67f42762c0d" translate="yes" xml:space="preserve">
          <source>The organisation or group, e.g.: &quot;org.apache.ant&quot;; required unless the compact form is used.</source>
          <target state="translated">組織やグループ。&quot;org.apache.ant&quot;;コンパクトな形式が使われていない限り必須。</target>
        </trans-unit>
        <trans-unit id="cf0ae96fdb2085b66ea3bb93836f5dbda67d76df" translate="yes" xml:space="preserve">
          <source>The original AST or null if it cannot be returned</source>
          <target state="translated">元のASTを返すか,返せない場合はnullを返します.</target>
        </trans-unit>
        <trans-unit id="463c8561d710e01b478880e4165ed134de96d70b" translate="yes" xml:space="preserve">
          <source>The original Throwable but with a sanitized stack trace</source>
          <target state="translated">オリジナルのThrowableだが、スタックトレースはサニタイズされている</target>
        </trans-unit>
        <trans-unit id="550e2fe2cda92d999ef8b8744582f726ca7d70d3" translate="yes" xml:space="preserve">
          <source>The original slurper and lexer use this class. This is kept around in case someone needs its exact behavior. Enum listing all the possible JSON tokens that should be recognized by the lexer.</source>
          <target state="translated">オリジナルの slurper と lexer はこのクラスを使用しています。これは、その正確な動作を必要とする人がいる場合に備えて保管されています。レキサーが認識する可能性のあるすべてのJSONトークンをリストアップしたEnum。</target>
        </trans-unit>
        <trans-unit id="4cf6c32888a66c7be9b42c3c4ddc926c89cf2d2d" translate="yes" xml:space="preserve">
          <source>The other typical usage, uses the self object while creating some value:</source>
          <target state="translated">もう一つの典型的な使用法は、値を作成しながらselfオブジェクトを使用します。</target>
        </trans-unit>
        <trans-unit id="ca0fdc2ddc244d43905d142929aaff47d915c14d" translate="yes" xml:space="preserve">
          <source>The other way is to add annotations to the alias:</source>
          <target state="translated">もう一つの方法は、エイリアスにアノテーションを追加することです。</target>
        </trans-unit>
        <trans-unit id="f9e8045bb0c75ecafe6640585dfaad1f947bcf4b" translate="yes" xml:space="preserve">
          <source>The owning shell.</source>
          <target state="translated">所有する殻。</target>
        </trans-unit>
        <trans-unit id="74c2e67b95c48b05cb96c4651b224ecc651abf77" translate="yes" xml:space="preserve">
          <source>The parser for Groovy programming language, which is based on the parser generated by Antlr4</source>
          <target state="translated">Antlr4 で生成されたパーサをベースにした Groovy プログラミング言語用のパーサです。</target>
        </trans-unit>
        <trans-unit id="c4db92f843c33741921f53930bfa252393bdb5ad" translate="yes" xml:space="preserve">
          <source>The particular unit decremented by depends on the specific sub-type of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html&quot;&gt;Temporal&lt;/a&gt;. Most sub-types use a unit of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#SECONDS&quot;&gt;ChronoUnit.SECONDS&lt;/a&gt; except for</source>
          <target state="translated">によってデクリメントされる特定の単位は、&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html&quot;&gt;Temporalの&lt;/a&gt;特定のサブタイプによって異なります。ほとんどのサブタイプは、単位使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#SECONDS&quot;&gt;ChronoUnit.SECONDSを&lt;/a&gt;除い</target>
        </trans-unit>
        <trans-unit id="0931b94d8ae13c47b9a85df31fbc353bf2a74861" translate="yes" xml:space="preserve">
          <source>The particular unit incremented by depends on the specific sub-type of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html&quot;&gt;Temporal&lt;/a&gt;. Most sub-types use a unit of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#SECONDS&quot;&gt;ChronoUnit.SECONDS&lt;/a&gt; except for</source>
          <target state="translated">によってインクリメントされる特定の単位は、&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html&quot;&gt;Temporalの&lt;/a&gt;特定のサブタイプによって異なります。ほとんどのサブタイプは、単位使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#SECONDS&quot;&gt;ChronoUnit.SECONDSを&lt;/a&gt;除い</target>
        </trans-unit>
        <trans-unit id="e3baee579d0f99a112462a4af57608a9a896b5c9" translate="yes" xml:space="preserve">
          <source>The permission groovy.security.GroovyCodeSourcePermission will be used to determine if the given codeBase may be specified. That is, the current Policy set must have a GroovyCodeSourcePermission that implies the codeBase, or an exception will be thrown. This is to prevent callers from hijacking existing codeBase policy entries unless explicitly authorized by the user.</source>
          <target state="translated">パーミッションgroovy.security.GroovyCodeSourcePermissionは、与えられたcodeBaseが指定されてもよいかどうかを判断するために使用されます。つまり、現在のポリシーセットは、コードベースを暗示するGroovyCodeSourcePermissionを持っていなければならず、そうでなければ例外がスローされます。これは、ユーザーによって明示的に許可されていない限り、呼び出し元が既存のcodeBaseポリシーエントリをハイジャックすることを防ぐためです。</target>
        </trans-unit>
        <trans-unit id="b23c39fbfa279511d3e7fc40992076c646fe704c" translate="yes" xml:space="preserve">
          <source>The phases as an array, with a null entry.</source>
          <target state="translated">フェーズを配列で表したもので、ヌルエントリを持ちます。</target>
        </trans-unit>
        <trans-unit id="5a50aa1f415a2950a9c3ea1c28386340df92373c" translate="yes" xml:space="preserve">
          <source>The phases of the GroovyCompiler. This is an enum facade on top of the Phases object. In general, prefer using this object over Phases.</source>
          <target state="translated">GroovyCompilerのフェーズです。これはPhasesオブジェクトの上にある列挙ファサードです。一般的には、Phasesよりもこのオブジェクトを使用することを好みます。</target>
        </trans-unit>
        <trans-unit id="d0555c21af552adf2c625446c48cfa44d487360f" translate="yes" xml:space="preserve">
          <source>The position of the curried parameters will be calculated eagerly and implies all arguments prior to the specified n index are supplied. Default parameter values prior to the n index will not be available.</source>
          <target state="translated">カーブされたパラメータの位置は熱心に計算され、指定されたn個のインデックスより前のすべての引数が供給されたことを意味します。n インデックスより前のデフォルトのパラメータ値は利用できません。</target>
        </trans-unit>
        <trans-unit id="b99f34149701f4f317b757b6f7be07e6c77a0502" translate="yes" xml:space="preserve">
          <source>The position of the curried parameters will be calculated lazily, for example, if two overloaded doCall methods are available, the supplied arguments plus the curried arguments will be concatenated and the result used for method selection.</source>
          <target state="translated">例えば、2つのオーバーロードされたdoCallメソッドが利用可能な場合には、与えられた引数とcurryされた引数が連結され、その結果がメソッドの選択に使用されます。</target>
        </trans-unit>
        <trans-unit id="d4d57362120a781eed62a17257a436f5c3b9c1de" translate="yes" xml:space="preserve">
          <source>The position tree of multi-line comments.</source>
          <target state="translated">複数行コメントの位置ツリー。</target>
        </trans-unit>
        <trans-unit id="3d2d8d4480d18b9fc0a2174c8cfea817348cc881" translate="yes" xml:space="preserve">
          <source>The prefix to use when creating the setter methods.</source>
          <target state="translated">セッターメソッドを作成する際に使用する接頭辞。</target>
        </trans-unit>
        <trans-unit id="6dec45555f03c899ffc22df52915fd879b9c58b0" translate="yes" xml:space="preserve">
          <source>The prefix to use when creating the setter methods. Default is determined by the strategy which might use &quot;&quot; or &quot;set&quot; but you can choose your own, e.g. &quot;with&quot;. If non-empty the first letter of the property will be capitalized before being appended to the prefix.</source>
          <target state="translated">セッターメソッドを作成する際に使用する接頭辞。デフォルトは &quot;&quot; や &quot;set&quot; を使用するストラテジーによって決まりますが、&quot;with&quot; のように独自のものを選ぶこともできます。空でない場合は、プロパティの最初の文字が大文字になってからプレフィックスに追加されます。</target>
        </trans-unit>
        <trans-unit id="c03948908d1373a091dc6fd5073476e494fdead0" translate="yes" xml:space="preserve">
          <source>The problem this annotation tries to solve is to define the expected parameter types of the</source>
          <target state="translated">このアノテーションが解決しようとする問題は</target>
        </trans-unit>
        <trans-unit id="404ee7e80d97420044d8572424c53f96977d7292" translate="yes" xml:space="preserve">
          <source>The produced code for the above example looks like this:</source>
          <target state="translated">上記の例で生成されたコードは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="66d47ea438a29f8f03b670b0bcbb6770f0998399" translate="yes" xml:space="preserve">
          <source>The properties to use can be filtered using either the 'includes' or 'excludes' annotation attributes for &lt;code&gt;@Builder&lt;/code&gt;. The &lt;code&gt;@Builder&lt;/code&gt; 'buildMethodName' annotation attribute can be used for configuring the build method's name, default &quot;build&quot;. The &lt;code&gt;@Builder&lt;/code&gt; 'builderMethodName' and 'builderClassName' annotation attributes aren't applicable for this strategy. The &lt;code&gt;@Builder&lt;/code&gt; 'useSetters' annotation attribute is ignored by this strategy which always uses setters.</source>
          <target state="translated">使用するプロパティは、 &lt;code&gt;@Builder&lt;/code&gt; の「includes」または「excludes」アノテーション属性を使用してフィルタリングできます。 &lt;code&gt;@Builder&lt;/code&gt; 「buildMethodName」注釈属性は、ビルドメソッドの名前、デフォルトの「ビルド」を構成するために使用することができます。 &lt;code&gt;@Builder&lt;/code&gt; 「builderMethodName」と「builderClassName」注釈の属性は、この戦略には適用されません。 &lt;code&gt;@Builder&lt;/code&gt; 「useSetters」注釈属性は常にセッターを使用しています。この戦略では無視されます。</target>
        </trans-unit>
        <trans-unit id="0bccb759e3c0e6e0247c634660331a9f94034269" translate="yes" xml:space="preserve">
          <source>The properties value</source>
          <target state="translated">プロパティの値</target>
        </trans-unit>
        <trans-unit id="d776cd3bdbba7c1073d917e7c7a9132e4549183f" translate="yes" xml:space="preserve">
          <source>The properties within the class must themselves be &lt;code&gt;Comparable&lt;/code&gt; or &lt;code&gt;@Sortable&lt;/code&gt;.</source>
          <target state="translated">クラス内のプロパティは、それ自体が &lt;code&gt;Comparable&lt;/code&gt; または &lt;code&gt;@Sortable&lt;/code&gt; である必要があります。</target>
        </trans-unit>
        <trans-unit id="7ed4236c8f797aaa8636050cfd80ec30bfeeed44" translate="yes" xml:space="preserve">
          <source>The property handler class which creates the necessary code for getting, setting or initializing properties.</source>
          <target state="translated">プロパティの取得、設定、初期化に必要なコードを作成するプロパティハンドラクラスです。</target>
        </trans-unit>
        <trans-unit id="5c2099cb7601f141e152a819c05e4db6c35a60d7" translate="yes" xml:space="preserve">
          <source>The property name equivalent</source>
          <target state="translated">プロパティ名に相当する</target>
        </trans-unit>
        <trans-unit id="068bd70d79a0f3161e77c6b20503123007a1632e" translate="yes" xml:space="preserve">
          <source>The property to set on compilation failure.</source>
          <target state="translated">コンパイル失敗時に設定するプロパティ。</target>
        </trans-unit>
        <trans-unit id="1bed8d7b5a8bdc81a2320b7e7824add1844ac6dc" translate="yes" xml:space="preserve">
          <source>The property to set on compilation failure. This property will be set if the compilation fails.</source>
          <target state="translated">コンパイル失敗時に設定するプロパティです。このプロパティはコンパイルに失敗した場合に設定されます。</target>
        </trans-unit>
        <trans-unit id="b106043c5c6468760b416e5a4f5dc8142c486625" translate="yes" xml:space="preserve">
          <source>The property to set on compilation success.</source>
          <target state="translated">コンパイル成功時に設定するプロパティ。</target>
        </trans-unit>
        <trans-unit id="39baf3f1877fa6a76dce4eda62ece0b8909c7323" translate="yes" xml:space="preserve">
          <source>The property to set on compilation success. This property will not be set if the compilation fails, or if there are no files to compile.</source>
          <target state="translated">コンパイル成功時に設定するプロパティ。コンパイルに失敗した場合や、コンパイルするファイルがない場合には、このプロパティは設定されません。</target>
        </trans-unit>
        <trans-unit id="bc70b9bacce6273f76ef6e4471c4dab865527fa7" translate="yes" xml:space="preserve">
          <source>The purpose is the reduction of the size of the bytecode. Consider creating a three element Object[] with null values:</source>
          <target state="translated">目的はバイトコードのサイズを小さくすることです。null値を持つ3つの要素Object[]を作成することを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="666faa1948c36e5a23029d8167b7a82bae76aa8a" translate="yes" xml:space="preserve">
          <source>The qualified name including any dimension information.</source>
          <target state="translated">任意のディメンション情報を含む修飾名。</target>
        </trans-unit>
        <trans-unit id="98b1825554dc394c8049d1d532250cea4ed423f2" translate="yes" xml:space="preserve">
          <source>The qualified name including any dimension information. For example, a two dimensional array of String returns &quot;&lt;code&gt;java.lang.String[][]&lt;/code&gt;&quot;, and the parameterized type &lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt; returns &quot;&lt;code&gt;java.util.List&amp;lt;java.lang.Integer&amp;gt;&lt;/code&gt;&quot;.</source>
          <target state="translated">ディメンション情報を含む修飾名。たとえば、Stringの2次元配列は「 &lt;code&gt;java.lang.String[][]&lt;/code&gt; 」を返し、パラメータ化されたタイプ &lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt; は「 &lt;code&gt;java.util.List&amp;lt;java.lang.Integer&amp;gt;&lt;/code&gt; 」を返します。</target>
        </trans-unit>
        <trans-unit id="6749c09dae1f16ee309de33291725a38354b80c1" translate="yes" xml:space="preserve">
          <source>The qualified name of this type excluding any dimension information.</source>
          <target state="translated">このタイプの修飾名(ディメンジョン情報を除く)。</target>
        </trans-unit>
        <trans-unit id="5524ad7e8d6e056655d2c24925da6512f7f6b810" translate="yes" xml:space="preserve">
          <source>The qualified name of this type excluding any dimension information. For example, a two dimensional array of String returns &quot;&lt;code&gt;java.lang.String&lt;/code&gt;&quot;.</source>
          <target state="translated">ディメンション情報を除く、このタイプの修飾名。たとえば、Stringの2次元配列は、「 &lt;code&gt;java.lang.String&lt;/code&gt; 」を返します。</target>
        </trans-unit>
        <trans-unit id="afc755459d1d6c162948ac88fb407664086e913e" translate="yes" xml:space="preserve">
          <source>The recommended way of securing shells is to use allowed lists because it is guaranteed that future features of the Groovy language won't be accidentally allowed unless explicitly added to the allowed list. Using disallowed lists, you can limit the features of the language constructs supported by your shell by opting out, but new language features are then implicitly also available and this may not be desirable. The implication is that you might need to update your configuration with each new release.</source>
          <target state="translated">シェルの安全性を確保するために推奨される方法は、許可されたリストを使用することです。これは、Groovy 言語の将来の機能が、許可されたリストに明示的に追加されない限り、誤って許可されることがないことが保証されているからです。不許可リストを使うと、シェルがサポートしている言語構成の機能をオプトアウトすることで制限することができますが、新しい言語機能も暗黙のうちに利用可能になり、これは望ましくないかもしれません。これは望ましくないかもしれません。</target>
        </trans-unit>
        <trans-unit id="7890a44bd59bb88228f8c74508210c196c09f718" translate="yes" xml:space="preserve">
          <source>The replace method to use on the matcher.</source>
          <target state="translated">マッチャーで使用するreplaceメソッドです。</target>
        </trans-unit>
        <trans-unit id="2d65383712d8a239399641a0d18670d69f0cea91" translate="yes" xml:space="preserve">
          <source>The replacement used by the resource name matcher.</source>
          <target state="translated">リソース名マッチャが使用する置換。</target>
        </trans-unit>
        <trans-unit id="183b2d9cf750ef4356762e7761f879eb6c2e10e8" translate="yes" xml:space="preserve">
          <source>The resgistry</source>
          <target state="translated">レジストリー</target>
        </trans-unit>
        <trans-unit id="8b60066e74974428693cf317396c392559fe4dcf" translate="yes" xml:space="preserve">
          <source>The resolve strategy</source>
          <target state="translated">解決戦略</target>
        </trans-unit>
        <trans-unit id="d6a1ea6deab0be8f01a56df21bf7e874402baa48" translate="yes" xml:space="preserve">
          <source>The result is a closure which can have the following forms:</source>
          <target state="translated">その結果、次のような形式をとることができるクロージャが得られます。</target>
        </trans-unit>
        <trans-unit id="f8073c98c26e1541e605cf9192ccb46ebece88e7" translate="yes" xml:space="preserve">
          <source>The result of the merge</source>
          <target state="translated">マージの結果</target>
        </trans-unit>
        <trans-unit id="b4fd3dd77a58f818d8c3faf56a7c1b1b58fac08e" translate="yes" xml:space="preserve">
          <source>The result of the propertyMissing method or throws MissingPropertyException</source>
          <target state="translated">propertyMissingメソッドの結果、またはMissingPropertyExceptionをスローします。</target>
        </trans-unit>
        <trans-unit id="becf539a2208e344834f816674f2d5fcf96548ba" translate="yes" xml:space="preserve">
          <source>The resulting translated &lt;code&gt;String&lt;/code&gt;</source>
          <target state="translated">結果の翻訳された &lt;code&gt;String&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c1d34dfb3088ea17d04b40b40c5f003d8f05e4fe" translate="yes" xml:space="preserve">
          <source>The results of methodMissing or throws MissingMethodException</source>
          <target state="translated">methodMissingまたはthrows MissingMethodExceptionの結果</target>
        </trans-unit>
        <trans-unit id="476c927d4d90fe65f6bab20cb57f17b4834562dd" translate="yes" xml:space="preserve">
          <source>The return value of the invocation</source>
          <target state="translated">呼び出しの戻り値</target>
        </trans-unit>
        <trans-unit id="f772844e69ffcc0220695a141278b4ea7430de9f" translate="yes" xml:space="preserve">
          <source>The return value of the invoked method.</source>
          <target state="translated">呼び出されたメソッドの戻り値。</target>
        </trans-unit>
        <trans-unit id="62d80f160e3301c563f71de2f15701a15461fe3a" translate="yes" xml:space="preserve">
          <source>The return value of the method</source>
          <target state="translated">メソッドの戻り値</target>
        </trans-unit>
        <trans-unit id="d97df77d5d16cf6f0d57a6d6752ee61825a4cc88" translate="yes" xml:space="preserve">
          <source>The return value of the method which is null if the return type is void</source>
          <target state="translated">メソッドの戻り値で、戻り値の型がvoidの場合はnullとなります。</target>
        </trans-unit>
        <trans-unit id="8583dcdd18eee679eec49286a13176c4259a5294" translate="yes" xml:space="preserve">
          <source>The returning parameter is commonly set to true when using with to simplify object creation, such as this example:</source>
          <target state="translated">この例のように、オブジェクトの作成を簡略化するために with を使用する場合、戻り値のパラメータは一般的に true に設定されます。</target>
        </trans-unit>
        <trans-unit id="875acf317a8f8529a69052fe176958b2bd26bb44" translate="yes" xml:space="preserve">
          <source>The revision or version, e.g.: &quot;1.7.1&quot;.</source>
          <target state="translated">リビジョンまたはバージョン。&quot;1.7.1&quot;.</target>
        </trans-unit>
        <trans-unit id="5cd485b893e87dd0b6efe0f84be74a2b0e50d049" translate="yes" xml:space="preserve">
          <source>The revision or version, e.g.: &quot;1.7.1&quot;. A non-empty value is required unless value() is used.</source>
          <target state="translated">リビジョンまたはバージョン。&quot;1.7.1&quot;.value()を使用しない限り、空でない値が必要です。</target>
        </trans-unit>
        <trans-unit id="7c207af991fb99091fa8f287c2da7adabb871197" translate="yes" xml:space="preserve">
          <source>The right way to use it for JUnit 3 is:</source>
          <target state="translated">JUnit 3での正しい使い方は</target>
        </trans-unit>
        <trans-unit id="7d858a85c56dc4b03eac0fe169dc4fa68051e7d8" translate="yes" xml:space="preserve">
          <source>The root cause exception instance, with its stace trace modified to filter out groovy runtime classes</source>
          <target state="translated">ルート原因の例外インスタンスの stace トレースが変更され、groovy ランタイムクラスをフィルタリングするようになりました。</target>
        </trans-unit>
        <trans-unit id="865af8ea215cefa5991c9cc5122354fadb48bb74" translate="yes" xml:space="preserve">
          <source>The root cause exception instances, with stack trace modified to filter out groovy runtime classes</source>
          <target state="translated">グルーヴィーなランタイムクラスをフィルタリングするためにスタックトレースを修正したルート原因の例外インスタンス</target>
        </trans-unit>
        <trans-unit id="e93c1b520cbd7836f0f8c1b4fd013c4e8d1129b1" translate="yes" xml:space="preserve">
          <source>The root of the Abstract Syntax Tree for the source</source>
          <target state="translated">ソースの抽象構文ツリーのルート</target>
        </trans-unit>
        <trans-unit id="67a7915a02520c39d9f254645135aa63e22bb403" translate="yes" xml:space="preserve">
          <source>The root of the lexical parsing tree.</source>
          <target state="translated">字句解析ツリーのルート。</target>
        </trans-unit>
        <trans-unit id="56fa669d54b1368623bad8fc50daad712171e89f" translate="yes" xml:space="preserve">
          <source>The short name of this option.</source>
          <target state="translated">このオプションの短い名前。</target>
        </trans-unit>
        <trans-unit id="d865d69887c0552a76349586553be28eee417b21" translate="yes" xml:space="preserve">
          <source>The short name of this option. Defaults to the name of member being annotated if the longName is empty.</source>
          <target state="translated">このオプションの短い名前。longName が空の場合は、アノテーションされるメンバーの名前がデフォルトとなります。</target>
        </trans-unit>
        <trans-unit id="ba2891c2488b5c6f4342d686b2788cfdf34b392d" translate="yes" xml:space="preserve">
          <source>The shortcut switch</source>
          <target state="translated">ショートカットスイッチ</target>
        </trans-unit>
        <trans-unit id="1dc02e4e7a9421805995dea237ea87f71134df23" translate="yes" xml:space="preserve">
          <source>The signature of this method</source>
          <target state="translated">この方法の署名</target>
        </trans-unit>
        <trans-unit id="f1492be12bee4c707c0282e56184b32b47ef4804" translate="yes" xml:space="preserve">
          <source>The simple name of the annotation including the &quot;@&quot; or null if no such name is defined</source>
          <target state="translated">アノテーションの単純な名前で、&quot;@&quot;を含む。</target>
        </trans-unit>
        <trans-unit id="2b4b71213506f4e0356dfd5fc20a5f6e429010dd" translate="yes" xml:space="preserve">
          <source>The source units from which this unit is built.</source>
          <target state="translated">このユニットが構築されているソースユニット。</target>
        </trans-unit>
        <trans-unit id="01401bd4b3d5f57ed6503d187a050f41b2a42df8" translate="yes" xml:space="preserve">
          <source>The standard use for this method is when a table has an autoincrement ID column and you want to know what the ID is for a newly inserted row. In this example, we insert a single row into a table in which the first column contains the autoincrement ID:</source>
          <target state="translated">このメソッドの標準的な使用法は、テーブルにオートインクリメント ID カラムがあり、新しく挿入された行の ID が何であるかを知りたい場合です。この例では、最初の列にオートインクリメント ID が含まれているテーブルに 1 つの行を挿入します。</target>
        </trans-unit>
        <trans-unit id="9275509b872e0adb76980a0373cc6d87c6055af3" translate="yes" xml:space="preserve">
          <source>The stream can be for example a FileInputStream from a file with the following format:</source>
          <target state="translated">ストリームは、例えば、以下の形式のファイルからのFileInputStreamとすることができます。</target>
        </trans-unit>
        <trans-unit id="15cc0423f1955111b4c08c47e52328fbdd00b69f" translate="yes" xml:space="preserve">
          <source>The string must be in the form returned by the QName.toString() method, i.e. &quot;{namespaceURI}localPart&quot;, with the &quot;{namespaceURI}&quot; part being optional.</source>
          <target state="translated">文字列は、QName.toString()メソッドが返す形式、つまり &quot;{namespaceURI}localPart&quot; でなければなりません。</target>
        </trans-unit>
        <trans-unit id="22771b89b44cb0db24fad01ea17fe01b726ba658" translate="yes" xml:space="preserve">
          <source>The string representation of the annotation reference.</source>
          <target state="translated">アノテーション参照の文字列表現。</target>
        </trans-unit>
        <trans-unit id="5e599db1ac6ef94f8579d026e88b608cf27ff8b8" translate="yes" xml:space="preserve">
          <source>The string representation of the annotation reference. Initially implemented as a temporary hack stored from the source. To be replaced with strong-typed finer grained information.</source>
          <target state="translated">注釈参照の文字列表現。当初はソースから保存された一時的なハックとして実装された。強度の高いタイプのより細かい情報に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="fb22d22c184c47ba3163340422accef7dd9ed1ff" translate="yes" xml:space="preserve">
          <source>The sum of all of the items</source>
          <target state="translated">すべての項目の合計</target>
        </trans-unit>
        <trans-unit id="40d0ac42b8edc1dae134c503efef716fc53d98f4" translate="yes" xml:space="preserve">
          <source>The sum of all of the items.</source>
          <target state="translated">すべての項目の合計です。</target>
        </trans-unit>
        <trans-unit id="989e25ec9928e09df7ee1acc43fc9c0880df69ad" translate="yes" xml:space="preserve">
          <source>The sum of the values returned by applying the closure to each item from the Iterator.</source>
          <target state="translated">イテレータから各項目にクロージャを適用して返される値の合計。</target>
        </trans-unit>
        <trans-unit id="c9e7ecaf4ca357ee681a27b991a11fab6d65dff1" translate="yes" xml:space="preserve">
          <source>The sum of the values returned by applying the closure to each item of the Iterable.</source>
          <target state="translated">イテレータブルの各項目にクロージャを適用して返される値の合計。</target>
        </trans-unit>
        <trans-unit id="0e89a462ab069558ccc92abaa6becf7fe7ca0492" translate="yes" xml:space="preserve">
          <source>The sum of the values returned by applying the closure to each item of the array.</source>
          <target state="translated">配列の各項目にクロージャを適用して返される値の合計。</target>
        </trans-unit>
        <trans-unit id="e0fe680303e1ca58932bb92ab26453355acda86b" translate="yes" xml:space="preserve">
          <source>The sum of the values returned by applying the closure to each item of the collection.</source>
          <target state="translated">コレクションの各項目にクロージャを適用して返される値の合計。</target>
        </trans-unit>
        <trans-unit id="5ca0e801895a43143eb85bd9dd3e4c911b3a6cad" translate="yes" xml:space="preserve">
          <source>The table is rehashed when its size exceeds this threshold.</source>
          <target state="translated">テーブルのサイズがこのしきい値を超えると蒸し返されます。</target>
        </trans-unit>
        <trans-unit id="8516c49e4447a484bd801473d4d78b70be591b01" translate="yes" xml:space="preserve">
          <source>The table is rehashed when its size exceeds this threshold. (The value of this field is always (int)(capacity * loadFactor).)</source>
          <target state="translated">テーブルのサイズがこのしきい値を超えると、テーブルは再ハッシュされます。(このフィールドの値は常に(int)(capacity*loadFactor)です)。</target>
        </trans-unit>
        <trans-unit id="2509a2b15c4fec90b1a89dfc73783afc5e5011fd" translate="yes" xml:space="preserve">
          <source>The tag name, e.g.</source>
          <target state="translated">タグ名、例えば</target>
        </trans-unit>
        <trans-unit id="db1db9824ee90a8accc29a6f47094d8320d3122c" translate="yes" xml:space="preserve">
          <source>The tag name, e.g. &quot;deprecated&quot;, &quot;param&quot;, &quot;see&quot; or &quot;author&quot;.</source>
          <target state="translated">タグ名、例えば &quot;deprecated&quot;,&quot;param&quot;,&quot;see&quot;,&quot;author&quot;。</target>
        </trans-unit>
        <trans-unit id="bab8307ff605a63f18f27b4b6a7d097cd05e8a14" translate="yes" xml:space="preserve">
          <source>The tail of a declaration.</source>
          <target state="translated">宣言の尻尾。</target>
        </trans-unit>
        <trans-unit id="f9066d16633090f75058b4bd1ecc26ce2c11677e" translate="yes" xml:space="preserve">
          <source>The tail of a declaration. Either v1, v2, ... (with possible initializers) or else m(args){body}. The two arguments are the modifier list (if any) and the declaration head (if any). The declaration head is the variable type, or (for a method) the return type. If it is missing, then the variable type is taken from its initializer (if there is one). Otherwise, the variable type defaults to 'any'. DECIDE: Method return types default to the type of the method body, as an expression.</source>
          <target state="translated">宣言の末尾。v1,v2,...(可能なイニシャライザを含む)か、m(args){body}のいずれかです。2つの引数は修飾子リスト(あれば)と宣言の先頭(あれば)です。宣言の先頭は変数の型、または(メソッドの場合は)戻り値の型です。見つからない場合は、変数の型はそのイニシャライザから取得されます(もしあれば)。それ以外の場合、変数型のデフォルトは 'any' です。DECIDE.メソッドの戻り値の型は、式のようにメソッド本体の型をデフォルトとします。</target>
        </trans-unit>
        <trans-unit id="80c1cd374807e18badc9c825a6ddb035ef579c09" translate="yes" xml:space="preserve">
          <source>The template engine can also be used as the engine for &lt;a href=&quot;../servlet/templateservlet&quot;&gt;TemplateServlet&lt;/a&gt; by placing the following in your &lt;code&gt;web.xml&lt;/code&gt; file (plus a corresponding servlet-mapping element):</source>
          <target state="translated">テンプレートエンジンは、 &lt;code&gt;web.xml&lt;/code&gt; ファイル（および対応するサーブレットマッピング要素）に以下を配置することにより、&lt;a href=&quot;../servlet/templateservlet&quot;&gt;TemplateServlet&lt;/a&gt;のエンジンとして使用することもできます。</target>
        </trans-unit>
        <trans-unit id="c41f5167f4c55b11e4ca434e73cfd1cfefc8c204" translate="yes" xml:space="preserve">
          <source>The template engine makes an effort to throw descriptive exceptions with context lines, ie:</source>
          <target state="translated">テンプレートエンジンは、コンテキスト行を使って記述的な例外を投げるように努力しています。</target>
        </trans-unit>
        <trans-unit id="b8bfd67b666067ef82bd6d072ceb9ecda1903dc6" translate="yes" xml:space="preserve">
          <source>The template engine uses JSP style &amp;lt;% %&amp;gt; script and &amp;lt;%= %&amp;gt; expression syntax or GString style expressions. The variable '&lt;code&gt;out&lt;/code&gt;' is bound to the writer that the template is being written to.</source>
          <target state="translated">テンプレートエンジンは、JSPスタイルの&amp;lt;%%&amp;gt;スクリプトと&amp;lt;％=％&amp;gt;式の構文またはGStringスタイルの式を使用します。変数「 &lt;code&gt;out&lt;/code&gt; 」は、テンプレートが書き込まれているライターにバインドされています。</target>
        </trans-unit>
        <trans-unit id="b1e19b0f009154f105e8d40314ebe5b64bfebc12" translate="yes" xml:space="preserve">
          <source>The template that will produce the response text.</source>
          <target state="translated">レスポンステキストを生成するテンプレートです。</target>
        </trans-unit>
        <trans-unit id="a5ff9da155da96f8ae444a0f421dd2eedfdd8503" translate="yes" xml:space="preserve">
          <source>The text associated with the tag.</source>
          <target state="translated">タグに関連付けられたテキスト。</target>
        </trans-unit>
        <trans-unit id="79600bf9bc91a3b3f63e7ddccbd148d4dbd124ed" translate="yes" xml:space="preserve">
          <source>The timer task which has been scheduled.</source>
          <target state="translated">スケジュールされているタイマータスク。</target>
        </trans-unit>
        <trans-unit id="1a25852356fb8328146e29a2fd46930da5616780" translate="yes" xml:space="preserve">
          <source>The tool to simulate running script files via groovy command</source>
          <target state="translated">groovy コマンドでスクリプトファイルの実行をシミュレートするツール</target>
        </trans-unit>
        <trans-unit id="74e34865ea7d26c8fa280a51bc74328d5c56b6b2" translate="yes" xml:space="preserve">
          <source>The total number of mappings in the hash table.</source>
          <target state="translated">ハッシュテーブル内のマッピングの総数。</target>
        </trans-unit>
        <trans-unit id="10ed76980b7be55f6560da1b7d64f4c53cb55453" translate="yes" xml:space="preserve">
          <source>The traversal can be adapted by providing various options in the &lt;code&gt;options&lt;/code&gt; Map according to the following keys:</source>
          <target state="translated">トラバーサルは、次のキーに従って &lt;code&gt;options&lt;/code&gt; マップにさまざまなオプションを提供することで調整できます。</target>
        </trans-unit>
        <trans-unit id="31d840e6eaa37d1fb137aba5bd262f3661e3cc96" translate="yes" xml:space="preserve">
          <source>The type descriptor for a method node is a string containing the name of the method, its return type, and its parameter types in a canonical form.</source>
          <target state="translated">メソッド・ノードの型記述子は、メソッドの名前、戻り値の型、およびパラメータの型を正規化した文字列です。</target>
        </trans-unit>
        <trans-unit id="60a6d9396902e7a9d90719e486b0ecba2c7fd0a1" translate="yes" xml:space="preserve">
          <source>The type descriptor for a method node is a string containing the name of the method, its return type, and its parameter types in a canonical form. For simplicity, we use the format of a Java declaration without parameter names or generics.</source>
          <target state="translated">メソッド・ノードの型記述子は、メソッドの名前、戻り値の型、およびパラメータの型を含む文字列です。簡単にするために、パラメータ名やジェネリックを含まない Java 宣言の形式を使用します。</target>
        </trans-unit>
        <trans-unit id="bfcc6988d78bb654bf23686ac195aa641257ac4b" translate="yes" xml:space="preserve">
          <source>The type member should be used when the type of the delegate cannot be represented with &lt;a href=&quot;#value()&quot;&gt;value()&lt;/a&gt;, &lt;a href=&quot;#genericTypeIndex()&quot;&gt;genericTypeIndex()&lt;/a&gt; or &lt;a href=&quot;#target()&quot;&gt;target()&lt;/a&gt;.</source>
          <target state="translated">デリゲートのタイプを&lt;a href=&quot;#value()&quot;&gt;value（）&lt;/a&gt;、&lt;a href=&quot;#genericTypeIndex()&quot;&gt;genericTypeIndex（）、&lt;/a&gt;または&lt;a href=&quot;#target()&quot;&gt;target（）&lt;/a&gt;で表すことができない場合は、タイプメンバーを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="50630842e00d8b1cbbbfcf22c64fecd77803f9f9" translate="yes" xml:space="preserve">
          <source>The type member should be used when the type of the delegate cannot be represented with &lt;a href=&quot;#value()&quot;&gt;value()&lt;/a&gt;, &lt;a href=&quot;#genericTypeIndex()&quot;&gt;genericTypeIndex()&lt;/a&gt; or &lt;a href=&quot;#target()&quot;&gt;target()&lt;/a&gt;. In this case, it is possible to use a String to represent the type, at the cost of potential uncaught errors at compile time if the type is invalid and increased compile time.</source>
          <target state="translated">デリゲートのタイプを&lt;a href=&quot;#value()&quot;&gt;value（）&lt;/a&gt;、&lt;a href=&quot;#genericTypeIndex()&quot;&gt;genericTypeIndex（）、&lt;/a&gt;または&lt;a href=&quot;#target()&quot;&gt;target（）&lt;/a&gt;で表すことができない場合は、タイプメンバーを使用する必要があります。この場合、文字列を使用して型を表すことができますが、型が無効でコンパイル時間が長くなると、コンパイル時にキャッチされないエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="1bc0f50f2984205e14cb09cbea32c757feab1695" translate="yes" xml:space="preserve">
          <source>The type of exception thrown when timeout is reached.</source>
          <target state="translated">タイムアウトに達したときにスローされる例外の種類。</target>
        </trans-unit>
        <trans-unit id="e3db5653f498161246a313203cbeabe10b294791" translate="yes" xml:space="preserve">
          <source>The type of the artifact (normally safe to leave at default value of &quot;jar&quot; but other values like &quot;sources&quot; and &quot;javadoc&quot; are sometimes useful).</source>
          <target state="translated">アーティファクトの型(通常はデフォルト値の &quot;jar &quot;のままにしておいても安全ですが、&quot;sources &quot;や &quot;javadoc &quot;のような他の値が有用な場合もあります)。</target>
        </trans-unit>
        <trans-unit id="9c9e817a3159fb3177fbc64ceea3fd2bfa224982" translate="yes" xml:space="preserve">
          <source>The type of the artifact (normally safe to leave at default value of &quot;jar&quot; but other values like &quot;sources&quot; and &quot;javadoc&quot; are sometimes useful). But see also the &quot;classifier&quot; attribute which is also sometimes used for &quot;sources&quot; and &quot;javadoc&quot;.</source>
          <target state="translated">アーティファクトの型(通常はデフォルト値の &quot;jar &quot;のままにしておいても安全ですが、&quot;sources &quot;や &quot;javadoc &quot;のような他の値が有用な場合もあります)。しかし、&quot;sources &quot;や &quot;javadoc &quot;に使われることもある &quot;classifier &quot;属性も参照してください。</target>
        </trans-unit>
        <trans-unit id="4ca920006f30ed914765d9c352a38d568933b700" translate="yes" xml:space="preserve">
          <source>The type of the last encountered &quot;it&quot; implicit parameter.</source>
          <target state="translated">最後に遭遇した &quot;it&quot; 暗黙のパラメータの型。</target>
        </trans-unit>
        <trans-unit id="9145cf3f9b4a0d09e2af2393fd727c71ebcbb50d" translate="yes" xml:space="preserve">
          <source>The type of the variable annotated with &lt;code&gt;@BaseScript&lt;/code&gt; must extend &lt;a href=&quot;../lang/script&quot;&gt;Script&lt;/a&gt;. It will be used as the base script class. The annotated variable will become shortcut to &lt;code&gt;this&lt;/code&gt; object. Using this annotation will override base script set by Groovy compiler or &lt;a href=&quot;../../org/codehaus/groovy/control/compilerconfiguration&quot;&gt;CompilerConfiguration&lt;/a&gt; of &lt;a href=&quot;../lang/groovyshell&quot;&gt;GroovyShell&lt;/a&gt; Example usage:</source>
          <target state="translated">&lt;code&gt;@BaseScript&lt;/code&gt; アノテーションが付けられた変数のタイプは、&lt;a href=&quot;../lang/script&quot;&gt;Scriptを&lt;/a&gt;拡張する必要があります。基本スクリプトクラスとして使用されます。注釈付き変数は、 &lt;code&gt;this&lt;/code&gt; オブジェクトへのショートカットになります。この注釈を使用すると、Groovyのコンパイラやでベーススクリプトのセットを上書きします&lt;a href=&quot;../../org/codehaus/groovy/control/compilerconfiguration&quot;&gt;CompilerConfiguration&lt;/a&gt;の&lt;a href=&quot;../lang/groovyshell&quot;&gt;GroovyShell&lt;/a&gt;使用例：</target>
        </trans-unit>
        <trans-unit id="e03953b92d1333f0ce4ca03983b13c88c5391b2e" translate="yes" xml:space="preserve">
          <source>The type of the variable annotated with &lt;code&gt;@SourceURI&lt;/code&gt; must be assignment compatible with &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/net/URI.html&quot;&gt;URI&lt;/a&gt;. It will be used to hold a URI object that references the source for the current script.</source>
          <target state="translated">&lt;code&gt;@SourceURI&lt;/code&gt; アノテーションが付けられた変数のタイプは、&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/net/URI.html&quot;&gt;URIと&lt;/a&gt;互換性のある割り当てである必要があります。これは、現在のスクリプトのソースを参照するURIオブジェクトを保持するために使用されます。</target>
        </trans-unit>
        <trans-unit id="72e862454a23154b9c1eada46b694794e382df1f" translate="yes" xml:space="preserve">
          <source>The type on which the field was attempted to be called</source>
          <target state="translated">フィールドが呼び出されようとした型</target>
        </trans-unit>
        <trans-unit id="0ed994342edba2dd4caa2ae969bfced6ca083812" translate="yes" xml:space="preserve">
          <source>The type on which the method was attempted to be called</source>
          <target state="translated">メソッドが呼び出されようとした型</target>
        </trans-unit>
        <trans-unit id="f49a0db00f8e949a09804dd63a36e2982c2bdcc0" translate="yes" xml:space="preserve">
          <source>The type on which the property was attempted to be called</source>
          <target state="translated">プロパティが呼び出されようとした型。</target>
        </trans-unit>
        <trans-unit id="b5a0be639b682e898850486f3c19bb899731dea4" translate="yes" xml:space="preserve">
          <source>The type that could not be resolved</source>
          <target state="translated">解決できなかったタイプ</target>
        </trans-unit>
        <trans-unit id="22bda5fdc5e6227a7a0c58e47015e24d57b30c81" translate="yes" xml:space="preserve">
          <source>The underlying builder</source>
          <target state="translated">基礎となるビルダー</target>
        </trans-unit>
        <trans-unit id="49cf8100ba29bc770b0147077438349a48624460" translate="yes" xml:space="preserve">
          <source>The underlying template engine or &lt;code&gt;null&lt;/code&gt; on error.</source>
          <target state="translated">基になるテンプレートエンジンまたはエラーの場合は &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de822d367304dba12ea8e0e5913a14a4fba0d3f8" translate="yes" xml:space="preserve">
          <source>The unescaped text</source>
          <target state="translated">エスケープされていないテキスト</target>
        </trans-unit>
        <trans-unit id="66a791c097d23f087f3b2006b4a3b0840ed65768" translate="yes" xml:space="preserve">
          <source>The unqualified name of this type excluding any dimension information.</source>
          <target state="translated">ディメンジョン情報を除いたこのタイプの非限定名。</target>
        </trans-unit>
        <trans-unit id="932bb11f5980b36dd397c11008ff195342c0ab60" translate="yes" xml:space="preserve">
          <source>The unqualified name of this type excluding any dimension information. For example, a two dimensional array of String returns &quot;&lt;code&gt;String&lt;/code&gt;&quot;.</source>
          <target state="translated">ディメンション情報を除く、このタイプの非修飾名。たとえば、Stringの2次元配列は「 &lt;code&gt;String&lt;/code&gt; 」を返します。</target>
        </trans-unit>
        <trans-unit id="64ffcabf1d928e33cdd955774a39dbcd5dd5d5a5" translate="yes" xml:space="preserve">
          <source>The unqualified name of this type excluding any dimension or nesting information.</source>
          <target state="translated">ディメンジョンまたはネスティング情報を除いたこのタイプの非限定名。</target>
        </trans-unit>
        <trans-unit id="d7aa9ba3ba0215b9edea5f76f8e108e86c3953aa" translate="yes" xml:space="preserve">
          <source>The unqualified name of this type excluding any dimension or nesting information. For example, the class &lt;code&gt;Outer.Inner&lt;/code&gt; returns &quot;&lt;code&gt;Inner&lt;/code&gt;&quot;.</source>
          <target state="translated">ディメンションまたはネスト情報を除く、このタイプの非修飾名。たとえば、クラス &lt;code&gt;Outer.Inner&lt;/code&gt; は「 &lt;code&gt;Inner&lt;/code&gt; 」を返します。</target>
        </trans-unit>
        <trans-unit id="b210e5f5ae502f06e3eee85bb0d3cddc4c712ed2" translate="yes" xml:space="preserve">
          <source>The updated class</source>
          <target state="translated">更新されたクラス</target>
        </trans-unit>
        <trans-unit id="b40cc89ba60352f68fafcc4ac4c159121fb14767" translate="yes" xml:space="preserve">
          <source>The upper value in the range.</source>
          <target state="translated">範囲内の上限値。</target>
        </trans-unit>
        <trans-unit id="e7fce3baf91efcfcd8801fb20b926ae96377e08f" translate="yes" xml:space="preserve">
          <source>The usage message for this example (obtained using &lt;code&gt;cli.usage()&lt;/code&gt;) is shown below:</source>
          <target state="translated">この例の使用法メッセージ（ &lt;code&gt;cli.usage()&lt;/code&gt; を使用して取得）を以下に示します。</target>
        </trans-unit>
        <trans-unit id="6b984acccdc007ab5614270b95defc6666e03e99" translate="yes" xml:space="preserve">
          <source>The valid targetBytecode values.</source>
          <target state="translated">有効な targetBytecode の値。</target>
        </trans-unit>
        <trans-unit id="26e0cfaca318b8f4da7cebac77fcdbc02f5aa88f" translate="yes" xml:space="preserve">
          <source>The value at which the range originates (may be &lt;code&gt;null&lt;/code&gt;).</source>
          <target state="translated">範囲が発生する値（ &lt;code&gt;null&lt;/code&gt; の場合があります）。</target>
        </trans-unit>
        <trans-unit id="0402397f26735b2ed2400f8ddcfcc924e0ce9a91" translate="yes" xml:space="preserve">
          <source>The value can be retrieved by calling the &lt;code&gt;get&lt;/code&gt; method with a key that is equal to the original key.</source>
          <target state="translated">値は、元のキーと同じキーを使用して &lt;code&gt;get&lt;/code&gt; メソッドを呼び出すことで取得できます。</target>
        </trans-unit>
        <trans-unit id="f18423b74c988542bc6f5c88a519429fcc1c89e9" translate="yes" xml:space="preserve">
          <source>The value of a QName contains a &lt;b&gt;namespaceURI&lt;/b&gt;, a &lt;b&gt;localPart&lt;/b&gt; and a &lt;b&gt;prefix&lt;/b&gt;. The localPart provides the local part of the qualified name. The namespaceURI is a URI reference identifying the namespace.</source>
          <target state="translated">QNameの値には、&lt;b&gt;namespaceURI&lt;/b&gt;、&lt;b&gt;localPart&lt;/b&gt;、および&lt;b&gt;プレフィックス&lt;/b&gt;が含まれ&lt;b&gt;ます&lt;/b&gt;。localPartは、修飾名のローカル部分を提供します。namespaceURIは、名前空間を識別するURI参照です。</target>
        </trans-unit>
        <trans-unit id="d581e8a0b9a8abf2d88f586b7d5f11976e2b4718" translate="yes" xml:space="preserve">
          <source>The value of the executable attribute, if any.</source>
          <target state="translated">もしあれば、実行可能属性の値。</target>
        </trans-unit>
        <trans-unit id="a9c238280b9b2287b4cd66fc20e8037b6edcacf3" translate="yes" xml:space="preserve">
          <source>The value returned by the script</source>
          <target state="translated">スクリプトが返す値</target>
        </trans-unit>
        <trans-unit id="87217bb3f735edd3580af114cd6ab58dbbe6f228" translate="yes" xml:space="preserve">
          <source>The value returned from the execution of the script (if supported by the Script engine)</source>
          <target state="translated">スクリプトの実行から返される値 (スクリプトエンジンがサポートしている場合)</target>
        </trans-unit>
        <trans-unit id="d702c028dc14f7beea06e57a018660f6784af85a" translate="yes" xml:space="preserve">
          <source>The value separator for this multi-valued option.</source>
          <target state="translated">この複数値オプションの値の区切り文字。</target>
        </trans-unit>
        <trans-unit id="38f5980b9a59a25ffdbd05535eef7c76cba55950" translate="yes" xml:space="preserve">
          <source>The value separator for this multi-valued option. Only allowed for array-typed arguments.</source>
          <target state="translated">この複数の値を持つオプションの値の区切り文字。配列型の引数に対してのみ許可されます。</target>
        </trans-unit>
        <trans-unit id="6847d558c266cc9ad7b554d665f6eb7a61327329" translate="yes" xml:space="preserve">
          <source>The value the option should have if it did not appear on the command line. The specified String value will be split into parts with the &lt;code&gt;valueSeparator&lt;/code&gt; and converted to the option &lt;code&gt;type&lt;/code&gt; before it is set.</source>
          <target state="translated">オプションがコマンドラインに表示されなかった場合に必要な値。指定された文字列値は、 &lt;code&gt;valueSeparator&lt;/code&gt; で部分に分割され、設定される前にオプション &lt;code&gt;type&lt;/code&gt; に変換されます。</target>
        </trans-unit>
        <trans-unit id="3481a95548ae3ca973619a2db287d20033ea8206" translate="yes" xml:space="preserve">
          <source>The values of each of the attributes on the MBean</source>
          <target state="translated">MBean上の各属性の値。</target>
        </trans-unit>
        <trans-unit id="53301301b27b5840479d76543713ebc0154d3193" translate="yes" xml:space="preserve">
          <source>The xmlns namespace definition for &lt;code&gt;gsp:&lt;/code&gt; tags will be removed but other namespace definitions will be preserved (but may change to an equivalent position within the XML tree).</source>
          <target state="translated">&lt;code&gt;gsp:&lt;/code&gt; タグのxmlns名前空間定義は削除されますが、他の名前空間定義は保持されます（ただし、XMLツリー内の同等の位置に変更される場合があります）。</target>
        </trans-unit>
        <trans-unit id="5ba86101ce4cb5b4110e9233defd7487d64710f7" translate="yes" xml:space="preserve">
          <source>Then calling the command line with:</source>
          <target state="translated">そして、コマンドラインを使って呼び出します。</target>
        </trans-unit>
        <trans-unit id="21704ce2ef786ce4f4d39ef635a67321094be364" translate="yes" xml:space="preserve">
          <source>Then for the objects defined earlier, the following would be true:</source>
          <target state="translated">すると、先に定義したオブジェクトについては、次のようになります。</target>
        </trans-unit>
        <trans-unit id="ef5935a3802e9c731a629c2d3dea2e39fefd2688" translate="yes" xml:space="preserve">
          <source>Then it can be used inside a template like this:</source>
          <target state="translated">そして、このようなテンプレートの中で使用することができます。</target>
        </trans-unit>
        <trans-unit id="7717c315c219349dde87bf9f638b3cb7bca01e90" translate="yes" xml:space="preserve">
          <source>Then the output will be:</source>
          <target state="translated">そうすると、出力されるのは</target>
        </trans-unit>
        <trans-unit id="864c134c8c6b2e00f7e8bc3ed68b30a559cbae27" translate="yes" xml:space="preserve">
          <source>Then this description is supplied to CliBuilder during parsing, e.g.:</source>
          <target state="translated">そして、この記述は解析中に CliBuilder に供給されます。</target>
        </trans-unit>
        <trans-unit id="8374b2c2645caacda80d91902c858cf6eea4f9dd" translate="yes" xml:space="preserve">
          <source>Then you can create the structure using:</source>
          <target state="translated">その後、構造体を使って作成します。</target>
        </trans-unit>
        <trans-unit id="947e20775c08c2347253e8e5fa3ea40f8f8dd552" translate="yes" xml:space="preserve">
          <source>There are numerous options to customize the format of the generated output. E.g. if you change the first annotation to:</source>
          <target state="translated">生成される出力の形式をカスタマイズするためのオプションが多数あります。例えば、最初のアノテーションを.</target>
        </trans-unit>
        <trans-unit id="563196ba8420a662ed40e16f59935b76206ff249" translate="yes" xml:space="preserve">
          <source>There are several variables in the script binding:</source>
          <target state="translated">スクリプトバインディングにはいくつかの変数があります。</target>
        </trans-unit>
        <trans-unit id="b4572f137c1c0ff3c8ab5a5964aa37a98f650fc5" translate="yes" xml:space="preserve">
          <source>There are three types of ClassNodes:</source>
          <target state="translated">ClassNodesには3種類あります。</target>
        </trans-unit>
        <trans-unit id="1bba0d9440062e4b938ad280aac889cc0eb5c94e" translate="yes" xml:space="preserve">
          <source>There is also a convenience form of ignore that matches the same style as demand. E.g. instead of &lt;code&gt;mock.ignore('hasNext')&lt;/code&gt; you can use &lt;code&gt;mock.ignore.hasNext()&lt;/code&gt;. A Closure variation is also provided. This convenience shorthand only applies to the &lt;code&gt;String&lt;/code&gt; form of ignore and cannot be used with methods from &lt;code&gt;java.lang.Object&lt;/code&gt;. Be careful using this feature while mocking some of the fundamental Java classes like &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;Pattern&lt;/code&gt;. As these are used within the implementation of the ignore capability, strange behavior may be observed.</source>
          <target state="translated">需要と同じスタイルに一致する無視の便利な形式もあります。例えば代わりの &lt;code&gt;mock.ignore('hasNext')&lt;/code&gt; あなたが使用することができます &lt;code&gt;mock.ignore.hasNext()&lt;/code&gt; 。クロージャのバリエーションも提供されます。この便利な省略形は、 &lt;code&gt;String&lt;/code&gt; 形式のignoreにのみ適用され、 &lt;code&gt;java.lang.Object&lt;/code&gt; のメソッドでは使用できません。 &lt;code&gt;String&lt;/code&gt; や &lt;code&gt;Pattern&lt;/code&gt; などの基本的なJavaクラスの一部をモックするときは、この機能の使用に注意してください。これらは無視機能の実装内で使用されるため、奇妙な動作が観察される場合があります。</target>
        </trans-unit>
        <trans-unit id="16ebe4c456d8370715d9755e4586403958f169f6" translate="yes" xml:space="preserve">
          <source>There is also support for including or excluding fields/properties by name when constructing the equals and hashCode methods as shown here:</source>
          <target state="translated">また、以下に示すように、equalsメソッドやhashCodeメソッドを構築する際に、名前によるフィールド/プロパティの包含/除外もサポートされています。</target>
        </trans-unit>
        <trans-unit id="09e297702b5735499b1fd1768938b8ac48de65f4" translate="yes" xml:space="preserve">
          <source>There's no way in Java or Groovy to express the type signature of the expected closure call method from outside the closure itself, so we rely on an annotation here. Unfortunately, annotations also have limitations (like not being able to use generics placeholder as annotation values) that prevent us from expressing the type directly.</source>
          <target state="translated">予想されるクロージャの呼び出しメソッドの型シグネチャをクロージャ自体の外から表現する方法はJavaやGroovyにはないので、ここではアノテーションに頼っています。残念ながら、アノテーションには、型を直接表現することができない制限もあります(ジェネリックプレースホルダをアノテーションの値として使用できないなど)。</target>
        </trans-unit>
        <trans-unit id="c18b23776942b361d4b98fa35e6f9472dbefb7b1" translate="yes" xml:space="preserve">
          <source>Therefore, f(x,y, a:p, b:q) {s} is equivalent in all ways to f(x,y, [a:p,b:q], {s}). Spread arguments of sequence type count as unlabeled arguments, while spread arguments of map type count as labeled arguments. (This distinction must sometimes be checked dynamically.) A plain unlabeled argument is allowed to match a trailing Map or Closure argument: f(x, a:p) {s} === f(*[ x, [a:p], {s} ])</source>
          <target state="translated">したがって、f(x,y,a:p,b:q){s}はすべての点でf(x,y,[a:p,b:q],{s})と等価です。シーケンス型の広がり引数はラベルの付いていない引数としてカウントされ、マップ型の広がり引数はラベルの付いた引数としてカウントされます(この区別は時々チェックしなければなりません)。この区別は時々動的にチェックされなければなりません)ラベルの付いていないプレーンな引数は、後続のMapまたはClosure引数にマッチすることができます。</target>
        </trans-unit>
        <trans-unit id="bdf6f329bdd2bfe03d147cee437e1f28acbe9bec" translate="yes" xml:space="preserve">
          <source>These rules are different from Java's &quot;dumb expression&quot; restriction. Unlike Java, Groovy blocks can end with arbitrary (even dumb) expressions, as a consequence of optional 'return' and 'continue' tokens.</source>
          <target state="translated">これらのルールは、Javaの「ダム式」制限とは異なります。Javaとは異なり、Groovyブロックはオプションの'return'と'continue'トークンの結果として、任意の(ダムな)式で終わることができます。</target>
        </trans-unit>
        <trans-unit id="1dd6b0156ded337bff046c6c15b9f9acafbe9d9f" translate="yes" xml:space="preserve">
          <source>Things that can show up as expressions, but only in strict contexts like inside parentheses, argument lists, and list constructors.</source>
          <target state="translated">式として表示されますが、括弧内、引数リスト、リスト・コンストラクタなどの厳密なコンテキストでのみ表示されます。</target>
        </trans-unit>
        <trans-unit id="3f14934bd3a85bcc4e7a08b55ecfe6eb236ddcff" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;1.4&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 1.4.</source>
          <target state="translated">これ（ &lt;code&gt;&quot;1.4&quot;&lt;/code&gt; ）は、JDK1.4用にコンパイルするtargetBytecodeの値です。</target>
        </trans-unit>
        <trans-unit id="41689f1ac38712a28ee794030339205948d12a07" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;1.5&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 1.5.</source>
          <target state="translated">これ（ &lt;code&gt;&quot;1.5&quot;&lt;/code&gt; ）は、JDK1.5用にコンパイルするtargetBytecodeの値です。</target>
        </trans-unit>
        <trans-unit id="9f297bc1639a07cc1f354bdef8b770444ae17d9a" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;1.6&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 1.6.</source>
          <target state="translated">これ（ &lt;code&gt;&quot;1.6&quot;&lt;/code&gt; ）は、JDK1.6用にコンパイルするtargetBytecodeの値です。</target>
        </trans-unit>
        <trans-unit id="9fb8c7a4c95ce1386b3f28c134d8693268f0f7af" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;1.7&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 1.7.</source>
          <target state="translated">これ（ &lt;code&gt;&quot;1.7&quot;&lt;/code&gt; ）は、JDK1.7用にコンパイルするtargetBytecodeの値です。</target>
        </trans-unit>
        <trans-unit id="1cb5fc7c5b688d3d7cf1465b6b36be120c55f7d5" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;1.8&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 1.8.</source>
          <target state="translated">これ（ &lt;code&gt;&quot;1.8&quot;&lt;/code&gt; ）は、JDK1.8用にコンパイルするtargetBytecodeの値です。</target>
        </trans-unit>
        <trans-unit id="4db730fb6bbc9127357c8981de76c8767a22995c" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;10&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 10.</source>
          <target state="translated">これ（ &lt;code&gt;&quot;10&quot;&lt;/code&gt; ）は、JDK10用にコンパイルするtargetBytecodeの値です。</target>
        </trans-unit>
        <trans-unit id="7253e572c58af323680948d9124eb666a503dc70" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;11&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 11.</source>
          <target state="translated">これ（ &lt;code&gt;&quot;11&quot;&lt;/code&gt; ）は、JDK11用にコンパイルするtargetBytecodeの値です。</target>
        </trans-unit>
        <trans-unit id="f1a0d2ab0453c0d76f9aec2ffa7dab4ddcaac8ea" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;12&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 12.</source>
          <target state="translated">これ（ &lt;code&gt;&quot;12&quot;&lt;/code&gt; ）は、JDK12用にコンパイルするtargetBytecodeの値です。</target>
        </trans-unit>
        <trans-unit id="92239128e3fca4fd124d3c3ff8f83f20507689db" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;13&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 13.</source>
          <target state="translated">これ（ &lt;code&gt;&quot;13&quot;&lt;/code&gt; ）は、JDK13用にコンパイルするtargetBytecodeの値です。</target>
        </trans-unit>
        <trans-unit id="c9227107e2eef78c2490b7685cfcbd9e12fac74d" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;14&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 14.</source>
          <target state="translated">これ（ &lt;code&gt;&quot;14&quot;&lt;/code&gt; ）は、JDK14用にコンパイルするtargetBytecodeの値です。</target>
        </trans-unit>
        <trans-unit id="a8c680713844e7c900b549a36c6de7e34f563c98" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;15&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 15.</source>
          <target state="translated">これ（ &lt;code&gt;&quot;15&quot;&lt;/code&gt; ）は、JDK15用にコンパイルするtargetBytecodeの値です。</target>
        </trans-unit>
        <trans-unit id="f1c463b78b8f124ac2eec3fd756cac7f533dfce9" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;16&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 16.</source>
          <target state="translated">これ（ &lt;code&gt;&quot;16&quot;&lt;/code&gt; ）は、JDK16用にコンパイルするtargetBytecodeの値です。</target>
        </trans-unit>
        <trans-unit id="7b242e1445386ea26fd4353cac30d1a7873acc0d" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;9&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 9.</source>
          <target state="translated">これ（ &lt;code&gt;&quot;9&quot;&lt;/code&gt; ）は、JDK9用にコンパイルするtargetBytecodeの値です。</target>
        </trans-unit>
        <trans-unit id="beee2f48ce8c2bdd9d82e37070e460c27f51fba0" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../classnode&quot;&gt;ClassNode&lt;/a&gt; specialization is used when the lowest upper bound of two types cannot be represented by an existing type.</source>
          <target state="translated">この&lt;a href=&quot;../classnode&quot;&gt;ClassNode&lt;/a&gt;特殊化は、2つのタイプの下限を既存のタイプで表すことができない場合に使用されます。</target>
        </trans-unit>
        <trans-unit id="f55f8d16febb565101695bf40d07384fdcedba3d" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../classnode&quot;&gt;ClassNode&lt;/a&gt; specialization is used when the lowest upper bound of two types cannot be represented by an existing type. For example, if B extends A, C extends A and both C and B implement a common interface not implemented by A, then we use this class to represent the bound. At compile time, some classes like &lt;a href=&quot;../../classgen/asmclassgenerator&quot;&gt;AsmClassGenerator&lt;/a&gt; need to know about a real class node, so we compute a &quot;compile time&quot; node which will be used to return a name and a type class.</source>
          <target state="translated">この&lt;a href=&quot;../classnode&quot;&gt;ClassNode&lt;/a&gt;特殊化は、2つのタイプの下限を既存のタイプで表すことができない場合に使用されます。たとえば、BがAを拡張し、CがAを拡張し、CとBの両方がAによって実装されていない共通のインターフェイスを実装する場合、このクラスを使用して境界を表します。コンパイル時に、&lt;a href=&quot;../../classgen/asmclassgenerator&quot;&gt;AsmClassGeneratorの&lt;/a&gt;ような一部のクラスは、実際のクラスノードについて知る必要があるため、名前と型クラスを返すために使用される「コンパイル時」ノードを計算します。</target>
        </trans-unit>
        <trans-unit id="bd4628d474bbecaf52d4fae2554f6f6dafd33e5e" translate="yes" xml:space="preserve">
          <source>This AST transform creates (potentially) numerous constructors. You should take care to avoid constructors with duplicate signatures if you are defining your own constructors or combining with other AST transforms which create constructors (e.g. &lt;code&gt;@TupleConstructor&lt;/code&gt;); the order in which the particular transforms are processed becomes important in that case.</source>
          <target state="translated">このAST変換は、（潜在的に）多数のコンストラクターを作成します。独自のコンストラクターを定義する場合、またはコンストラクターを作成する他のAST変換（ &lt;code&gt;@TupleConstructor&lt;/code&gt; など）と組み合わせる場合は、署名が重複するコンストラクターを避けるように注意する必要があります。その場合、特定の変換が処理される順序が重要になります。</target>
        </trans-unit>
        <trans-unit id="e36f809432dd63402bc50997d22ab6edaf317f70" translate="yes" xml:space="preserve">
          <source>This AST transform might become a no-op if you are defining your own constructors or combining with other AST transforms which create constructors (e.g. &lt;code&gt;@InheritConstructors&lt;/code&gt;); the order in which the particular transforms are processed becomes important in that case. See the &lt;code&gt;force&lt;/code&gt; attribute for further details about customizing this behavior.</source>
          <target state="translated">このAST変換は、独自のコンストラクターを定義している場合、またはコンストラクターを作成する他のAST変換（ &lt;code&gt;@InheritConstructors&lt;/code&gt; など）と組み合わせている場合は、何もしない可能性があります。その場合、特定の変換が処理される順序が重要になります。この動作のカスタマイズの詳細については、 &lt;code&gt;force&lt;/code&gt; 属性を参照してください。</target>
        </trans-unit>
        <trans-unit id="15f2811221f75ab7d18ebc91f442dd8504abe34a" translate="yes" xml:space="preserve">
          <source>This AST transform normally uses default parameter values which creates multiple constructors under the covers. You should use with care if you are defining your own constructors or combining with other AST transforms which create constructors (e.g. &lt;code&gt;@InheritConstructors&lt;/code&gt;); the order in which the particular transforms are processed becomes important in that case. See the &lt;code&gt;defaults&lt;/code&gt; attribute for further details about customizing this behavior.</source>
          <target state="translated">このAST変換は通常、デフォルトのパラメーター値を使用して、内部で複数のコンストラクターを作成します。独自のコンストラクターを定義する場合、またはコンストラクターを作成する他のAST変換（ &lt;code&gt;@InheritConstructors&lt;/code&gt; など）と組み合わせる場合は、注意して使用する必要があります。その場合、特定の変換が処理される順序が重要になります。この動作のカスタマイズの詳細については、 &lt;code&gt;defaults&lt;/code&gt; 属性を参照してください。</target>
        </trans-unit>
        <trans-unit id="81e45867f90c0607353adaf6e73abff7c9d75404" translate="yes" xml:space="preserve">
          <source>This AST transformation aims at helping in debugging other AST transformations. It provides a basic infrastructure for performing tests on AST nodes. You can place this annotation on any node which accepts an annotation (types, methods, annotations, constructors, fields, local variables, packages or parameters), then use a script which is run against this AST node at a specific phase. For example, you could test the &lt;a href=&quot;field&quot;&gt;Field&lt;/a&gt; AST transformation this way:</source>
          <target state="translated">このAST変換は、他のAST変換のデバッグを支援することを目的としています。ASTノードでテストを実行するための基本的なインフラストラクチャを提供します。このアノテーションは、アノテーションを受け入れる任意のノード（タイプ、メソッド、アノテーション、コンストラクター、フィールド、ローカル変数、パッケージ、またはパラメーター）に配置し、特定のフェーズでこのASTノードに対して実行されるスクリプトを使用できます。たとえば、次の方法で&lt;a href=&quot;field&quot;&gt;フィールド&lt;/a&gt;AST変換をテストできます。</target>
        </trans-unit>
        <trans-unit id="29dcdadce343c996ed956f4651064a49228e35e3" translate="yes" xml:space="preserve">
          <source>This ClassLoader should be used as root of class loaders. Any RootLoader does have its own classpath. When searching for a class or resource this classpath will be used. Parent Classloaders are ignored first. If a class or resource can't be found in the classpath of the RootLoader, then parent is checked.</source>
          <target state="translated">このClassLoaderは、クラスローダーのルートとして使用する必要があります。どんなRootLoaderでも、それ自身のクラスパスを持っています。クラスやリソースを検索する際には、このクラスパスが使用されます。親クラスローダーは最初に無視されます。RootLoader のクラスパスにクラスやリソースが見つからない場合は、 parent がチェックされます。</target>
        </trans-unit>
        <trans-unit id="bf55f18fc8d0076e97f9f960b82f80de35bb3681" translate="yes" xml:space="preserve">
          <source>This MetaBeanProperty will create a pseudo property whose value is bound to an object using weak references. The values will go out of scope and be garbage collected when the object is collected In fact, this class should be called ExpandoProperty.</source>
          <target state="translated">このMetaBeanPropertyは、値が弱い参照を使ってオブジェクトにバインドされた疑似プロパティを作成します。値はスコープ外に出てしまい、オブジェクトが収集されたときにガベージコレクションされてしまいます。</target>
        </trans-unit>
        <trans-unit id="704cf8159f321950d7439d8157804780ec00808e" translate="yes" xml:space="preserve">
          <source>This MetaClass is for internal usage only!</source>
          <target state="translated">このメタクラスは内部で使用するためのものです。</target>
        </trans-unit>
        <trans-unit id="550e8ef2b445d11145333f7d61692b3a9a8521d7" translate="yes" xml:space="preserve">
          <source>This TestHarness exists so that a global transform can be run without using the Jar services mechanism, which requires building a jar. To use this simply create an instance of TransformTestHelper with an ASTTransformation and CompilePhase, then invoke parse(File) or parse(String). This test harness is not exactly the same as executing a global transformation but can greatly aide in debugging and testing a transform. You should still test your global transformation when packaged as a jar service before releasing it.</source>
          <target state="translated">このTestHarnessは、Jarサービスの仕組みを使わずにグローバル変換を実行できるようにするために存在します。これを使うには、ASTTransformationとCompilePhaseを指定してTransformTestHelperのインスタンスを作成し、parse(File)またはparse(String)を呼び出します。このテストハーネスは、グローバル変換を実行するのと全く同じではありませんが、変換のデバッグとテストに大いに役立ちます。グローバル変換をリリースする前に、jar サービスとしてパッケージ化されている場合は、グローバル変換をテストする必要があります。</target>
        </trans-unit>
        <trans-unit id="c82a01d51cf967248d2d13c51ea281168a11d159" translate="yes" xml:space="preserve">
          <source>This Writer is used to generate the call invocation byte codes for usage by invokedynamic.</source>
          <target state="translated">このライターは、invokedynamicで使用するための呼び出しバイトコードを生成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="3d417d2cc7f087e2cdc7df384d7a9c24827840c1" translate="yes" xml:space="preserve">
          <source>This allows callbacks to the ExpandoMetaClass for registering appending methods</source>
          <target state="translated">これにより、ExpandoMetaClassに追加メソッドを登録するためのコールバックが可能になります。</target>
        </trans-unit>
        <trans-unit id="d5ec4e7b6ccc818185756b4b5a332b9d3ffec2cf" translate="yes" xml:space="preserve">
          <source>This allows equals to be overridden by a closure</source>
          <target state="translated">これにより、等号がクロージャによってオーバーライドされるようになります。</target>
        </trans-unit>
        <trans-unit id="1a87473814b341719aa50b456949655ef70f8692" translate="yes" xml:space="preserve">
          <source>This allows hashCode to be overridden by a closure</source>
          <target state="translated">これにより、ハッシュコードがクロージャによってオーバーライドされるようになります。</target>
        </trans-unit>
        <trans-unit id="9be7fcf1022ddc09fab428bf809d227229df0478" translate="yes" xml:space="preserve">
          <source>This allows toString to be overridden by a closure</source>
          <target state="translated">これにより、toString をクロージャでオーバーライドすることができます。</target>
        </trans-unit>
        <trans-unit id="904b268e24ef2338f73c60ee6653805eb03db45f" translate="yes" xml:space="preserve">
          <source>This annotation adds Java-style listener support to a class based on an annotated Collection-property.</source>
          <target state="translated">このアノテーションは、アノテーションされた Collection-property に基づくクラスに Java スタイルのリスナー・サポートを追加します。</target>
        </trans-unit>
        <trans-unit id="456bbcadaaaab286f459087a19ee8bf423978b1b" translate="yes" xml:space="preserve">
          <source>This annotation can also be used to help the type checker (&lt;a href=&quot;../transform/typechecked&quot;&gt;TypeChecked&lt;/a&gt;) which would not report errors then if the delegate is of the documented type. Of course, it is also compatible with &lt;a href=&quot;../transform/compilestatic&quot;&gt;CompileStatic&lt;/a&gt;.</source>
          <target state="translated">このアノテーションは、デリゲートが文書化されたタイプである場合にエラーを報告しないタイプチェッカー（&lt;a href=&quot;../transform/typechecked&quot;&gt;TypeChecked&lt;/a&gt;）を支援するためにも使用できます。もちろん、&lt;a href=&quot;../transform/compilestatic&quot;&gt;CompileStatic&lt;/a&gt;とも互換性があります。</target>
        </trans-unit>
        <trans-unit id="f85deef9d102451f990e95bce3bc073d25fbab0b" translate="yes" xml:space="preserve">
          <source>This annotation can be added on a trait to declare the list of types that a class implementing that trait is supposed to extend. This is useful when you want to be able to call methods from the class implementing the trait without having to declare all of them as members of the trait. Self types are particularly useful in combination with &lt;a href=&quot;compilestatic&quot;&gt;CompileStatic&lt;/a&gt;, if you know that a trait can only be applied to a specific type but that the trait cannot extend that type itself. For example, imagine the following code:</source>
          <target state="translated">このアノテーションをトレイトに追加して、そのトレイトを実装するクラスが拡張することになっているタイプのリストを宣言できます。これは、すべてのメソッドをトレイトのメンバーとして宣言しなくても、トレイトを実装するクラスからメソッドを呼び出せるようにする場合に役立ちます。特性が特定の型にのみ適用できるが、特性がその型自体を拡張できないことがわかっている場合、自己型は&lt;a href=&quot;compilestatic&quot;&gt;CompileStatic&lt;/a&gt;と組み合わせて特に役立ちます。たとえば、次のコードを想像してみてください。</target>
        </trans-unit>
        <trans-unit id="90bf79a957044e0c4bcbe98180025021e13ba83a" translate="yes" xml:space="preserve">
          <source>This annotation can be used by API or DSL writers to document parameters which accept a closure. In that case, using this annotation, you can specify what the delegate type of the closure will be. This is important for IDE support.</source>
          <target state="translated">このアノテーションは、API または DSL ライターがクロージャを受け入れるパラメータを文書化するために使用できます。その場合、このアノテーションを使用して、クロージャのデリゲート型を指定することができます。これは、IDE サポートのために重要です。</target>
        </trans-unit>
        <trans-unit id="ecea2ce9782577916440255f7ef418cba5693cc7" translate="yes" xml:space="preserve">
          <source>This annotation can only be applied to a field of type Collection</source>
          <target state="translated">このアノテーションは、Collection 型のフィールドにのみ適用できます。</target>
        </trans-unit>
        <trans-unit id="23faf967c5242f98ba0f1bfb8360a62caf1714ca" translate="yes" xml:space="preserve">
          <source>This annotation is a declarative wrapper around the JDK's &lt;code&gt;java.util.concurrent.locks.ReentrantReadWriteLock&lt;/code&gt;. Objects containing this annotation will have a ReentrantReadWriteLock field named &lt;code&gt;$reentrantLock&lt;/code&gt; added to the class, and method access is protected by the lock. If the method is static then the field is static and named &lt;code&gt;$REENTRANTLOCK&lt;/code&gt;.</source>
          <target state="translated">このアノテーションは、JDKの &lt;code&gt;java.util.concurrent.locks.ReentrantReadWriteLock&lt;/code&gt; の宣言型ラッパーです。このアノテーションを含むオブジェクトには、 &lt;code&gt;$reentrantLock&lt;/code&gt; という名前のReentrantReadWriteLockフィールドがクラスに追加され、メソッドアクセスはロックによって保護されます。メソッドが静的である場合、フィールドは静的であり、 &lt;code&gt;$REENTRANTLOCK&lt;/code&gt; という名前が付けられます。</target>
        </trans-unit>
        <trans-unit id="9ee69ca6c59b77f4f301dba9f69b7ae03123c8fb" translate="yes" xml:space="preserve">
          <source>This annotation is added by</source>
          <target state="translated">このアノテーションは</target>
        </trans-unit>
        <trans-unit id="284afc2f65c87063203dea977155cf54b2e047bd" translate="yes" xml:space="preserve">
          <source>This annotation is used in conjunction with &lt;a href=&quot;withreadlock&quot;&gt;WithReadLock&lt;/a&gt; to support read and write synchronization on a method.</source>
          <target state="translated">このアノテーションは、&lt;a href=&quot;withreadlock&quot;&gt;WithReadLock&lt;/a&gt;と組み合わせて使用​​され、メソッドの読み取りと書き込みの同期をサポートします。</target>
        </trans-unit>
        <trans-unit id="17c946a06e7f552c5a667fd66607967ecf31f9f4" translate="yes" xml:space="preserve">
          <source>This annotation is used in conjunction with &lt;a href=&quot;withwritelock&quot;&gt;WithWriteLock&lt;/a&gt; to support read and write synchronization on a method.</source>
          <target state="translated">このアノテーションは、&lt;a href=&quot;withwritelock&quot;&gt;WithWriteLock&lt;/a&gt;と組み合わせて使用​​され、メソッドの読み取りと書き込みの同期をサポートします。</target>
        </trans-unit>
        <trans-unit id="887147df53ade494df6c8d9012ec7612dd2f4226" translate="yes" xml:space="preserve">
          <source>This applies to the grab and resolve calls.</source>
          <target state="translated">これは、グラブと解決コールに適用されます。</target>
        </trans-unit>
        <trans-unit id="a921b8a7c1a5d233057197c112f7c4cb8b092bff" translate="yes" xml:space="preserve">
          <source>This behavior can be disabled by setting the annotation's &lt;code&gt;interfaces&lt;/code&gt; element to false, i.e. &lt;code&gt;@Delegate(interfaces = false)&lt;/code&gt;, e.g. in the above example, the delegate definition would become:</source>
          <target state="translated">この動作は、アノテーションの &lt;code&gt;interfaces&lt;/code&gt; 要素をfalseに設定することで無効にできます。つまり、 &lt;code&gt;@Delegate(interfaces = false)&lt;/code&gt; 。たとえば、上記の例では、デリゲート定義は次のようになります。</target>
        </trans-unit>
        <trans-unit id="788d0e9e6025f3d507fbe4b1a671cab778fcc046" translate="yes" xml:space="preserve">
          <source>This builder supports the usual builder syntax made of nested method calls and closures, but also some specific aspects of JSON data structures, such as list of values, etc. Please make sure to have a look at the various methods provided by this builder to be able to learn about the various possibilities of usage.</source>
          <target state="translated">このビルダは、入れ子になったメソッド呼び出しやクロージャからなる通常のビルダ構文だけでなく、値のリストのような JSON データ構造のいくつかの特定の側面もサポートしています。このビルダーが提供する様々なメソッドを見て、様々な使用法の可能性を学ぶことができるようにしてください。</target>
        </trans-unit>
        <trans-unit id="f8635421fede240629f5bedb5b4f58cb9f602fa9" translate="yes" xml:space="preserve">
          <source>This cache contains mappings of file name to class.</source>
          <target state="translated">このキャッシュには、ファイル名とクラスのマッピングが含まれています。</target>
        </trans-unit>
        <trans-unit id="370ea64c9230c916cbe3b4f3656932f0e6a2c4bc" translate="yes" xml:space="preserve">
          <source>This cache contains mappings of file name to class. It is used to bypass compilation.</source>
          <target state="translated">このキャッシュには、ファイル名とクラスのマッピングが含まれています。コンパイルをバイパスするために使用されます。</target>
        </trans-unit>
        <trans-unit id="88d556d068acd75020d51487e54372a78b6ff46d" translate="yes" xml:space="preserve">
          <source>This class also supports optional guaranteed exclusive reads, simply by surrounding a call within a synchronized block, as in</source>
          <target state="translated">このクラスはオプションで排他的な読み出し保証もサポートしています。</target>
        </trans-unit>
        <trans-unit id="8508f2b4673f6cfee9a6f3c2b3e95fec3b67deb5" translate="yes" xml:space="preserve">
          <source>This class and its views and iterators implement all of the &lt;em&gt;optional&lt;/em&gt; methods of the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt; and &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html&quot;&gt;Iterator&lt;/a&gt; interfaces.</source>
          <target state="translated">このクラスとそのビューおよびイテレータは、&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt;および&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html&quot;&gt;Iterator&lt;/a&gt;インターフェイスのすべての&lt;em&gt;オプション&lt;/em&gt;メソッドを実装します。</target>
        </trans-unit>
        <trans-unit id="f7efe531dee1a194a6b26a56274948d2b3619130" translate="yes" xml:space="preserve">
          <source>This class checks the handling of labels in the AST</source>
          <target state="translated">このクラスはASTのラベルの扱いをチェックします。</target>
        </trans-unit>
        <trans-unit id="c32390b3fa0798fcae7e17bde6e60d95b95add0f" translate="yes" xml:space="preserve">
          <source>This class codes around a silly limitation of StringWriter which doesn't allow a StringBuffer to be passed in as a constructor for some bizarre reason. So we replicate the behaviour of StringWriter here but allow a StringBuffer to be passed in.</source>
          <target state="translated">このクラスは、StringBufferをコンストラクタとして渡すことができないというStringWriterのおかしな制限を回避するためのコードです。そこで、ここではStringWriterの動作を複製し、StringBufferを渡すことができるようにしています。</target>
        </trans-unit>
        <trans-unit id="ebc053f62ed97562a5d93d1422bb69af81f8e57b" translate="yes" xml:space="preserve">
          <source>This class contains a static utility method &lt;a href=&quot;#doExtendTraits(org.codehaus.groovy.ast.ClassNode,%20org.codehaus.groovy.control.SourceUnit,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;doExtendTraits(org.codehaus.groovy.ast.ClassNode, org.codehaus.groovy.control.SourceUnit, org.codehaus.groovy.control.CompilationUnit)&lt;/a&gt; aimed at generating code for a classnode implementing a trait.</source>
          <target state="translated">このクラスには、トレイトを実装するクラスノードのコードを生成することを目的とした静的ユーティリティメソッド&lt;a href=&quot;#doExtendTraits(org.codehaus.groovy.ast.ClassNode,%20org.codehaus.groovy.control.SourceUnit,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;doExtendTraits（org.codehaus.groovy.ast.ClassNode、org.codehaus.groovy.control.SourceUnit、org.codehaus.groovy.control.CompilationUnit）が含ま&lt;/a&gt;れています。</target>
        </trans-unit>
        <trans-unit id="d1390a9bb5928eb78b502051fa6490144b85fc73" translate="yes" xml:space="preserve">
          <source>This class contains guards, runtime filters and MethodType signatures used by indy.</source>
          <target state="translated">このクラスには、indyが使用するガード、ランタイムフィルタ、MethodTypeシグネチャが含まれています。</target>
        </trans-unit>
        <trans-unit id="69d74fd6b193fe5e0c2269389a27f951ab4b1918" translate="yes" xml:space="preserve">
          <source>This class contains helper methods for converting and comparing types. WARNING: This class is for internal use only. do not use it outside of its package and not outside groovy-core.</source>
          <target state="translated">このクラスには、型を変換したり比較したりするためのヘルパーメソッドが含まれています。警告:このクラスは内部でのみ使用するためのものです。パッケージの外では使用せず、groovy-core の外では使用しないでください。</target>
        </trans-unit>
        <trans-unit id="0e2eed5867aee96ae1999d8644dc789cf19d0975" translate="yes" xml:space="preserve">
          <source>This class contains math operations used by indy instead of the normal meta method and call site caching system. The goal is to avoid boxing, thus use primitive types for parameters and return types where possible. WARNING: This class is for internal use only. Do not use it outside of the org.codehaus.groovy.vmplugin.v7 package of groovy-core.</source>
          <target state="translated">このクラスには、通常のメタメソッドとサイトキャッシングシステムを呼び出す代わりに indy が使用する数学演算が含まれています。ボックス化を避けることを目的としているため、パラメータや戻り値の型には可能な限りプリミティブ型を使用しています。警告:このクラスは内部での使用のみを目的としています。org.codehaus.groovy.vmplugin.v7パッケージのgroovy-core以外では使用しないでください。</target>
        </trans-unit>
        <trans-unit id="48c7a1f038c0d6b2a23d2ab51b95c86eac51cf7a" translate="yes" xml:space="preserve">
          <source>This class contains methods special to optimizations used directly from bytecode in Groovy 1.8</source>
          <target state="translated">このクラスは、Groovy 1.8 のバイトコードから直接使用する最適化に特化したメソッドを含んでいます。</target>
        </trans-unit>
        <trans-unit id="316c4500322f8ef05e5c4de531c7dc7bc6e842c4" translate="yes" xml:space="preserve">
          <source>This class contains several transformers for used during method invocation.</source>
          <target state="translated">このクラスには、メソッド呼び出し時に使用するいくつかのトランスフォーマが含まれています。</target>
        </trans-unit>
        <trans-unit id="1768003da8eeae27f66ecf9e1f2dbf815c0a1e83" translate="yes" xml:space="preserve">
          <source>This class contains utility methods to determine which class called the current class to multiple levels of depth. Calls used to handle the groovy MOP are excluded from the level counting.</source>
          <target state="translated">このクラスには、現在のクラスがどのクラスから複数の深さのレベルに呼び出されたかを判断するためのユーティリティメソッドが含まれています。groovy MOP の処理に使用される呼び出しは、レベルカウントから除外されます。</target>
        </trans-unit>
        <trans-unit id="221b99a286abc745efa1b934a4f00c7b6aa4732f" translate="yes" xml:space="preserve">
          <source>This class controls the conversion from a Groovy script as a String into a tree representation of the AST of that script. The script itself will be a tree node, and each class in the script will be a tree node. The conversion creates tree nodes for any concrete class found within an AST visitor. So, if a tree node should be shown once for each ASTNode and the parent types will not appear as nodes. Custom subclasses of expression types will not appear in the tree. The String label of a tree node is defined by classname in AstBrowserProperties.properties.</source>
          <target state="translated">このクラスは、文字列としてのGroovyスクリプトから、そのスクリプトのASTのツリー表現への変換を制御します。スクリプト自体はツリーノードとなり、スクリプト内の各クラスはツリーノードとなります。変換は、ASTの訪問者内で見つかった任意の具体的なクラスのツリーノードを作成します。そのため、ツリーノードが各ASTNodeに対して1回表示されるべきで、親型がノードとして表示されない場合は、ツリーノードは表示されません。式型のカスタムサブクラスはツリーに表示されません。ツリーノードの文字列ラベルは、AstBrowserProperties.propertiesのclassnameで定義します。</target>
        </trans-unit>
        <trans-unit id="d454a30f57963a7de123921ca0b60e62b5e13e35" translate="yes" xml:space="preserve">
          <source>This class defines a single static method taking the string instance as first argument, allowing to define a new instance method on the String class:</source>
          <target state="translated">文字列のインスタンスを第一引数に取る静的メソッドを定義します。</target>
        </trans-unit>
        <trans-unit id="3e8b6ae7361745c2ea205471fce2c8b2f23b8fe8" translate="yes" xml:space="preserve">
          <source>This class defines a wrapper for accessing a specific column in &lt;code&gt;ResultSetMetaData&lt;/code&gt;. This allows iteration over columns using idiomatic Groovy, e.g.:</source>
          <target state="translated">このクラスは、 &lt;code&gt;ResultSetMetaData&lt;/code&gt; の特定の列にアクセスするためのラッパーを定義します。これにより、慣用的なGroovyを使用して列を反復処理できます。例：</target>
        </trans-unit>
        <trans-unit id="3f3f0165db0a67f63374a90150dc420fe8fa8906" translate="yes" xml:space="preserve">
          <source>This class defines all the encoding/decoding groovy methods which enhance the normal JDK classes when inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="translated">このクラスは、Groovy環境内では通常のJDKクラスを強化するエンコード/デコードgroovyメソッドを全て定義しています。静的なメソッドは、最初のパラメータにデスティネーションクラスを指定して使用します。</target>
        </trans-unit>
        <trans-unit id="ddd6dbb32c165e8ccdc7c778b5ff92b6e5a6e046" translate="yes" xml:space="preserve">
          <source>This class defines all the new SQL-related groovy methods which enhance the normal JDK SQL classes when inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="translated">このクラスは、Groovy環境内では通常のJDK SQLクラスを強化する新しいSQL関連のgroovyメソッドをすべて定義しています。静的なメソッドは、最初のパラメータに目的のクラスを指定して使用します。</target>
        </trans-unit>
        <trans-unit id="0e4cf1f1d1626756e2ccfaa4e27ca5b4fe7667ce" translate="yes" xml:space="preserve">
          <source>This class defines all the new Swing-related groovy methods which enhance the normal JDK Swing classes when inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="translated">このクラスは、Groovy環境内では通常のJDK Swingクラスを強化するSwing関連の新しいgroovyメソッドをすべて定義しています。静的なメソッドは、最初のパラメータに目的のクラスを指定して使用します。</target>
        </trans-unit>
        <trans-unit id="6bc8d743038c2ddaea690f3c08b6f791f09b985b" translate="yes" xml:space="preserve">
          <source>This class defines all the new XML-related groovy methods which enhance the normal JDK XML classes when inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="translated">このクラスは、Groovy環境内では通常のJDK XMLクラスを強化するXML関連の新しいgroovyメソッドをすべて定義しています。静的なメソッドは、最初のパラメータに目的のクラスを指定して使用します。</target>
        </trans-unit>
        <trans-unit id="98e53123fb5c78332de5d2876769f4a204051159" translate="yes" xml:space="preserve">
          <source>This class defines all the new static groovy methods which appear on normal JDK classes inside the Groovy environment. Static methods are used with the first parameter as the destination class.</source>
          <target state="translated">このクラスは、Groovy環境内の通常のJDKクラスに表示される新しい静的なgroovyメソッドをすべて定義します。静的メソッドは、最初のパラメータを宛先クラスとして使用します。</target>
        </trans-unit>
        <trans-unit id="faf10e978d074ae7e5e07e788c9748ff6b749eed" translate="yes" xml:space="preserve">
          <source>This class defines new Groovy methods which appear on normal JDK Date/Time API (java.time) classes inside the Groovy environment. These extensions require JDK 8 or above.</source>
          <target state="translated">このクラスは、Groovy 環境内の通常の JDK Date/Time API (java.time)クラスに表示される新しい Groovy メソッドを定義します。これらの拡張機能には、JDK 8 以上が必要です。</target>
        </trans-unit>
        <trans-unit id="5e8a356a24d0f45345f38f9c5e624401ea122feb" translate="yes" xml:space="preserve">
          <source>This class defines new Java 5 specific groovy methods which extend the normal JDK classes inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="translated">このクラスは、Groovy環境内の通常のJDKクラスを拡張する新しいJava 5固有のgroovyメソッドを定義します。静的なメソッドは、最初のパラメータに接続先のクラスを指定して使用します。</target>
        </trans-unit>
        <trans-unit id="3335bc6567d5a0923632b42415b2259b7d1a9ca9" translate="yes" xml:space="preserve">
          <source>This class defines new Java 6 specific groovy methods which extend the normal JDK classes inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="translated">このクラスは、Groovy環境内の通常のJDKクラスを拡張する新しいJava 6固有のgroovyメソッドを定義します。静的なメソッドは、最初のパラメータに接続先のクラスを指定して使用します。</target>
        </trans-unit>
        <trans-unit id="fbc656debe43046569a9d23c80bd193a41215a53" translate="yes" xml:space="preserve">
          <source>This class defines new Java 6 specific static groovy methods which extend the normal JDK classes inside the Groovy environment.</source>
          <target state="translated">このクラスは、Groovy環境内の通常のJDKクラスを拡張する、新しいJava 6固有の静的groovyメソッドを定義しています。</target>
        </trans-unit>
        <trans-unit id="48c87f705bf49123468d54ad93a33becf3eeea6d" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods for Files, URLs, URIs which appear on normal JDK classes inside the Groovy environment. Static methods are used with the first parameter being the destination class, i.e. &lt;code&gt;public static long size(File self)&lt;/code&gt; provides a &lt;code&gt;size()&lt;/code&gt; method for &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="translated">このクラスは、Groovy環境内の通常のJDKクラスに表示されるファイル、URL、URIの新しいgroovyメソッドを定義します。静的メソッドは、最初のパラメーターが宛先クラスである場合に使用されます。つまり、 &lt;code&gt;public static long size(File self)&lt;/code&gt; は、Fileの &lt;code&gt;size()&lt;/code&gt; メソッドを提供し &lt;code&gt;File&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aea9ee44a185e75c57ac3db064101c0dc7b71846" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods for Readers, Writers, InputStreams and OutputStreams which appear on normal JDK classes inside the Groovy environment. Static methods are used with the first parameter being the destination class, i.e. &lt;code&gt;public static T eachLine(InputStream self, Closure c)&lt;/code&gt; provides a &lt;code&gt;eachLine(Closure c)&lt;/code&gt; method for &lt;code&gt;InputStream&lt;/code&gt;.</source>
          <target state="translated">このクラスは、Groovy環境内の通常のJDKクラスに表示されるReaders、Writers、InputStreams、およびOutputStreamsの新しいgroovyメソッドを定義します。静的メソッドは、最初のパラメーターが宛先クラスである場合に使用されます。つまり、 &lt;code&gt;public static T eachLine(InputStream self, Closure c)&lt;/code&gt; は、 &lt;code&gt;InputStream&lt;/code&gt; の &lt;code&gt;eachLine(Closure c)&lt;/code&gt; メソッドを提供します。</target>
        </trans-unit>
        <trans-unit id="eb04b5af77efd219c4b5a9414f1ff8646ff26a61" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods for Sockets which enhance JDK classes inside the Groovy environment.</source>
          <target state="translated">このクラスは、Groovy環境内のJDKクラスを強化するソケット用の新しいgroovyメソッドを定義しています。</target>
        </trans-unit>
        <trans-unit id="94e1494a582102e49d29876303786a0362da0d77" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods which appear on Jaxb-related JDK classes (&lt;code&gt;JAXBContext&lt;/code&gt;, &lt;code&gt;Marshaller&lt;/code&gt;) inside the Groovy environment. Static methods are used with the first parameter being the destination class.</source>
          <target state="translated">このクラスは、Groovy環境内の &lt;code&gt;JAXBContext&lt;/code&gt; 関連のJDKクラス（JAXBContext、 &lt;code&gt;Marshaller&lt;/code&gt; ）に表示される新しいgroovyメソッドを定義します。静的メソッドは、最初のパラメーターが宛先クラスである場合に使用されます。</target>
        </trans-unit>
        <trans-unit id="afb7507827959ad4b29159fe5d7fffc42f2f585e" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods which appear on String-related JDK classes (String, CharSequence, Matcher) inside the Groovy environment. Static methods are used with the first parameter being the destination class, e.g. &lt;code&gt;public static String reverse(String self)&lt;/code&gt; provides a &lt;code&gt;reverse()&lt;/code&gt; method for &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">このクラスは、Groovy環境内のString関連のJDKクラス（String、CharSequence、Matcher）に表示される新しいgroovyメソッドを定義します。静的メソッドは、最初のパラメータが先クラス、例えばして使用される &lt;code&gt;public static String reverse(String self)&lt;/code&gt; を提供 &lt;code&gt;reverse()&lt;/code&gt; のための方法 &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f855a0c8edce7e177b8b45a6cbe1be9748fa85a5" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods which appear on normal JDK Date and Calendar classes inside the Groovy environment.</source>
          <target state="translated">このクラスは、Groovy環境内の通常のJDKのDateとCalendarクラスに表示される新しいgroovyメソッドを定義します。</target>
        </trans-unit>
        <trans-unit id="7539a6b02de0acc678a620086fdddde40b1d36f7" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods which appear on normal JDK classes inside the Groovy environment. Static methods are used with the first parameter being the destination class, i.e. &lt;code&gt;public static String reverse(String self)&lt;/code&gt; provides a &lt;code&gt;reverse()&lt;/code&gt; method for &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">このクラスは、Groovy環境内の通常のJDKクラスに表示される新しいgroovyメソッドを定義します。静的メソッドは、最初のパラメータが先クラス、すなわちされた状態で使用される &lt;code&gt;public static String reverse(String self)&lt;/code&gt; を提供 &lt;code&gt;reverse()&lt;/code&gt; のための方法 &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22d775343e0c1cedc8e65538de82853d5aec499d" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods which appear on normal JDK classes related to process management.</source>
          <target state="translated">このクラスは、プロセス管理に関連する通常のJDKクラスに現れる新しいgroovyメソッドを定義します。</target>
        </trans-unit>
        <trans-unit id="93c83296c1339bc893ca28a97ad7ad9e35c69b38" translate="yes" xml:space="preserve">
          <source>This class defines new groovy static methods which appear on normal JDK Date and Calendar classes inside the Groovy environment.</source>
          <target state="translated">このクラスは、Groovy環境内の通常のJDKのDateとCalendarクラスに表示される新しいgroovy静的メソッドを定義します。</target>
        </trans-unit>
        <trans-unit id="48764622300d44ff21eff5891fc9ff2ebe3f07cb" translate="yes" xml:space="preserve">
          <source>This class defines new static extension methods which appear on normal JDK Date/Time API (java.time) classes inside the Groovy environment.</source>
          <target state="translated">このクラスは、Groovy 環境内の通常の JDK Date/Time API (java.time)クラスに表示される新しい静的拡張メソッドを定義します。</target>
        </trans-unit>
        <trans-unit id="cf24bf76d96add06db8b90790f6d00a2cfad2055" translate="yes" xml:space="preserve">
          <source>This class does not provide the ability to customize the resulting output. A &lt;a href=&quot;jsongenerator&quot;&gt;JsonGenerator&lt;/a&gt; can be used if the ability to alter the resulting output is required.</source>
          <target state="translated">このクラスは、結果の出力をカスタマイズする機能を提供しません。A &lt;a href=&quot;jsongenerator&quot;&gt;JsonGeneratorは、&lt;/a&gt;結果の出力を変更する能力が必要とされる場合に使用することができます。</target>
        </trans-unit>
        <trans-unit id="c469cd04a8269f915fbdad81a3e9c2f515539197" translate="yes" xml:space="preserve">
          <source>This class handles caching internally and its advisable to not store references directly to objects of this class. The static factory method &lt;a href=&quot;classinfo#getClassInfo(java.lang.Class)&quot;&gt;ClassInfo.getClassInfo&lt;/a&gt; should be used to retrieve an instance from the cache. Internally the &lt;code&gt;Class&lt;/code&gt; associated with a &lt;code&gt;ClassInfo&lt;/code&gt; instance is kept as &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/ref/WeakReference.html&quot;&gt;WeakReference&lt;/a&gt;, so it not safe to reference and instance without the Class being either strongly or softly reachable.</source>
          <target state="translated">このクラスは内部でキャッシュを処理するため、このクラスのオブジェクトへの参照を直接保存しないことをお勧めします。キャッシュからインスタンスを取得するには、静的ファクトリメソッド&lt;a href=&quot;classinfo#getClassInfo(java.lang.Class)&quot;&gt;ClassInfo.getClassInfo&lt;/a&gt;を使用する必要があります。内部的には、 &lt;code&gt;ClassInfo&lt;/code&gt; インスタンスに関連付けられた &lt;code&gt;Class&lt;/code&gt; は&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/ref/WeakReference.html&quot;&gt;WeakReference&lt;/a&gt;として保持されるため、クラスが強くまたはソフトに到達可能でないと、参照してインスタンス化することは安全ではありません。</target>
        </trans-unit>
        <trans-unit id="6dde5778cb52a324896ffae7cfbf596d97d66c91" translate="yes" xml:space="preserve">
          <source>This class handles converting Strings to ASTNode lists.</source>
          <target state="translated">文字列をASTNodeのリストに変換します。</target>
        </trans-unit>
        <trans-unit id="9e92e6926c2a201584cdcb9f5d948909b564b830" translate="yes" xml:space="preserve">
          <source>This class handles the invocation of the ASTAnnotationTransformation when it is encountered by a tree walk. One instance of each exists for each phase of the compilation it applies to. Before invocation the</source>
          <target state="translated">このクラスは、ツリーウォークでASTAnnotationTransformationが呼び出されたときの処理を行います。それぞれのインスタンスは、コンパイルの各フェーズに1つずつ存在します。呼び出される前に</target>
        </trans-unit>
        <trans-unit id="c7e6d3f76a3c4311415b9304af550d64f39dd083" translate="yes" xml:space="preserve">
          <source>This class has several inner classes that also helps picking generic argument types instead of the parameter type.</source>
          <target state="translated">このクラスはいくつかの内部クラスを持っており、パラメータ型の代わりに一般的な引数型を選ぶのにも役立ちます。</target>
        </trans-unit>
        <trans-unit id="3837874bec8e4931d877954a86a0917c89371a7f" translate="yes" xml:space="preserve">
          <source>This class is &lt;b&gt;not&lt;/b&gt; thread-safe.</source>
          <target state="translated">このクラスはスレッドセーフではあり&lt;b&gt;ません&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="bb171051a560c489be8ec957676e4fd0c5c42c0f" translate="yes" xml:space="preserve">
          <source>This class is a general adapter to adapt a closure to any Java interface.</source>
          <target state="translated">このクラスは、クロージャを任意の Java インターフェイスに適応させるための一般的なアダプタです。</target>
        </trans-unit>
        <trans-unit id="1904a5f416e052d74d08f3361764dad66bf5f12b" translate="yes" xml:space="preserve">
          <source>This class is a general adapter to adapt a map of closures to any Java interface.</source>
          <target state="translated">このクラスは、クロージャのマップを任意の Java インターフェイスに適応させるための一般的なアダプタです。</target>
        </trans-unit>
        <trans-unit id="cd0e9b1d846e158bbf918633b43cd721a0206943" translate="yes" xml:space="preserve">
          <source>This class is a general adapter to map a call to a Java interface to a given delegate.</source>
          <target state="translated">このクラスは、Java インターフェイスへの呼び出しを与えられたデリゲートにマップするための一般的なアダプタです。</target>
        </trans-unit>
        <trans-unit id="407993abd5f454fb2d6c0556db6a1d0ca2f05505" translate="yes" xml:space="preserve">
          <source>This class is extended by several hint providers that make it easier to use as annotation values.</source>
          <target state="translated">このクラスは、いくつかのヒントプロバイダによって拡張されており、アノテーション値として使いやすくなっています。</target>
        </trans-unit>
        <trans-unit id="75718b0560771207235791afb3b9fda1625fc4bb" translate="yes" xml:space="preserve">
          <source>This class is for internal use only! This class will dispatch to the right type adapters according to the kind of binary expression that is provided.</source>
          <target state="translated">このクラスは内部使用専用です! このクラスは、提供された二項式の種類に応じて正しい型アダプタにディスパッチします。</target>
        </trans-unit>
        <trans-unit id="76d7804b1c6dc7652647c993f4fdf0eded744a8a" translate="yes" xml:space="preserve">
          <source>This class is important to the performance of the parser. It stores Value objects in a map where they are evaluated lazily. This is great for JSONPath types of application, and Object Serialization but not for maps that are going to be stored in a cache.</source>
          <target state="translated">このクラスはパーサーのパフォーマンスに重要です。Value オブジェクトをマップに格納し、そこでは怠惰に評価されます。これはJSONPathタイプのアプリケーションやオブジェクトのシリアライズには適していますが、キャッシュに保存されるマップには適していません。</target>
        </trans-unit>
        <trans-unit id="96572291f640285f4a1f9ecf3aa073f0a992daab" translate="yes" xml:space="preserve">
          <source>This class is instantiated and invoked when an AST transformation is activated. For Global AST Transformations, this interface is called once per SourceUnit, which is usually a Groovy source file. For Local AST Transformations, this interface is invoked once every time the Local annotation marker is encountered.</source>
          <target state="translated">このクラスは、ASTトランスフォームが有効になったときに呼び出されます。グローバルAST変換では、SourceUnit(通常はGroovyのソースファイル)ごとに1回呼び出されます。ローカルAST変換の場合は、ローカルアノテーションマーカーが見つかるたびに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="cc67996ced277a761581444c4cf862c08d075467" translate="yes" xml:space="preserve">
          <source>This class is responsible for assembling JMX Attribute Info from the meta map. It cycles through the meta map from the Node and generate JMX Info objects used to expose information in the MBeanServer.</source>
          <target state="translated">このクラスは、メタマップから JMX 属性情報をアセンブルします。ノードからメタマップを循環させ、MBeanServer で情報を公開するために使用される JMX Info オブジェクトを生成します。</target>
        </trans-unit>
        <trans-unit id="075476029820d79cc983f42159f8eb4cdea63809" translate="yes" xml:space="preserve">
          <source>This class is responsible for assembling JMX Operation Info from the meta map. It cycles through the provided meta map from the bean() node and generate JMX Info objects used to expose information in the MBeanServer.</source>
          <target state="translated">このクラスは、メタマップから JMX 操作情報をアセンブルします。Bean()ノードから提供されたメタマップを循環させ、MBeanServerで情報を公開するために使用されるJMX Infoオブジェクトを生成します。</target>
        </trans-unit>
        <trans-unit id="4b30124afd1417d4b385c76f80bcf34578d51bd0" translate="yes" xml:space="preserve">
          <source>This class is the base for any annotation alias processor.</source>
          <target state="translated">このクラスは、任意のアノテーション・エイリアス・プロセッサのベースとなります。</target>
        </trans-unit>
        <trans-unit id="5924197edb00c649d5d755fc6516a87d87145be3" translate="yes" xml:space="preserve">
          <source>This class is the factory for the emitter node. This node facilitates the declaration of a JMX event emitter. The emitter is used to broadcast arbitrary event on the MBeanServer's event bus. Registered listeners are able to consume event once sent.</source>
          <target state="translated">このクラスはエミッタノードのファクトリです。このノードは、JMX イベントエミッタの宣言を容易にします。エミッタは、MBeanServerのイベントバス上で任意のイベントをブロードキャストするために使用されます。登録されたリスナーは、送信されたイベントを消費することができます。</target>
        </trans-unit>
        <trans-unit id="653683ec37c7baebfd2f2bbe95b36d002cf25d2e" translate="yes" xml:space="preserve">
          <source>This class is used as a pluggable way to resolve class names. An instance of this class has to be added to &lt;a href=&quot;compilationunit&quot;&gt;CompilationUnit&lt;/a&gt; using &lt;a href=&quot;compilationunit#setClassNodeResolver(org.codehaus.groovy.control.ClassNodeResolver)&quot;&gt;CompilationUnit.setClassNodeResolver&lt;/a&gt;. The CompilationUnit will then set the resolver on the &lt;a href=&quot;resolvevisitor&quot;&gt;ResolveVisitor&lt;/a&gt; each time new. The ResolveVisitor will prepare name lookup and then finally ask the resolver if the class exists. This resolver then can return either a SourceUnit or a ClassNode. In case of a SourceUnit the compiler is notified that a new source is to be added to the compilation queue. In case of a ClassNode no further action than the resolving is done. The lookup result is stored in the helper class LookupResult. This class provides a class cache to cache lookups. If you don't want this, you have to override the methods &lt;a href=&quot;classnoderesolver#cacheClass(java.lang.String,%20org.codehaus.groovy.ast.ClassNode)&quot;&gt;ClassNodeResolver.cacheClass&lt;/a&gt; and &lt;a href=&quot;classnoderesolver#getFromClassCache(java.lang.String)&quot;&gt;ClassNodeResolver.getFromClassCache&lt;/a&gt;. Custom lookup logic is supposed to go into the method &lt;a href=&quot;classnoderesolver#findClassNode(java.lang.String,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;ClassNodeResolver.findClassNode&lt;/a&gt; while the entry method is &lt;a href=&quot;classnoderesolver#resolveName(java.lang.String,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;ClassNodeResolver.resolveName&lt;/a&gt;</source>
          <target state="translated">このクラスは、クラス名を解決するためのプラグ可能な方法として使用されます。このクラスのインスタンスは、&lt;a href=&quot;compilationunit&quot;&gt;CompilationUnit.setClassNodeResolver&lt;/a&gt;を使用して&lt;a href=&quot;compilationunit#setClassNodeResolver(org.codehaus.groovy.control.ClassNodeResolver)&quot;&gt;CompilationUnitに&lt;/a&gt;追加する必要があります。その後、CompilationUnitは、新規になる&lt;a href=&quot;resolvevisitor&quot;&gt;たびにResolveVisitorに&lt;/a&gt;リゾルバーを設定します。 ResolveVisitorは名前検索を準備し、最後にクラスが存在するかどうかをリゾルバーに尋ねます。このリゾルバーは、SourceUnitまたはClassNodeのいずれかを返すことができます。 SourceUnitの場合、新しいソースがコンパイルキューに追加されることがコンパイラに通知されます。 ClassNodeの場合、解決以外のアクションは実行されません。ルックアップ結果は、ヘルパークラスLookupResultに格納されます。このクラスは、ルックアップをキャッシュするためのクラスキャッシュを提供します。これが必要ない場合は、メソッドをオーバーライドする必要があります&lt;a href=&quot;classnoderesolver#cacheClass(java.lang.String,%20org.codehaus.groovy.ast.ClassNode)&quot;&gt;ClassNodeResolver.cacheClass&lt;/a&gt;および&lt;a href=&quot;classnoderesolver#getFromClassCache(java.lang.String)&quot;&gt;ClassNodeResolver.getFromClassCache&lt;/a&gt;。カスタムルックアップロジックは、エントリメソッドが&lt;a href=&quot;classnoderesolver#resolveName(java.lang.String,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;ClassNodeResolver.resolveNameである&lt;/a&gt;間、メソッド&lt;a href=&quot;classnoderesolver#findClassNode(java.lang.String,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;ClassNodeResolver.findClassNode&lt;/a&gt;に入ることになっています。</target>
        </trans-unit>
        <trans-unit id="f14354187c290397fd82b9881697595ff4486600" translate="yes" xml:space="preserve">
          <source>This class is used internally by the compiler to transform expressions like multiple assignments into a list of assignments.</source>
          <target state="translated">このクラスはコンパイラによって内部的に使用され、複数の代入のような式を代入のリストに変換します。</target>
        </trans-unit>
        <trans-unit id="8b644eb64cd81a47f8da1cd879e99bb7530c7027" translate="yes" xml:space="preserve">
          <source>This class is used to describe generic type signatures for ClassNodes.</source>
          <target state="translated">ClassNodesの汎用型シグネチャを記述します。</target>
        </trans-unit>
        <trans-unit id="ec6a7563ff7840c43f2735a87393e68cb11d3a71" translate="yes" xml:space="preserve">
          <source>This class is used to make extension methods lookup faster. Basically, it will only collect the list of extension methods (see &lt;a href=&quot;../../runtime/m12n/extensionmodule&quot;&gt;ExtensionModule&lt;/a&gt; if the list of extension modules has changed. It avoids recomputing the whole list each time we perform a method lookup.</source>
          <target state="translated">このクラスは、拡張メソッドのルックアップを高速化するために使用されます。基本的に、拡張メソッドのリストのみを収集します（拡張モジュールのリストが変更されている場合は、&lt;a href=&quot;../../runtime/m12n/extensionmodule&quot;&gt;ExtensionModuleを&lt;/a&gt;参照してください。メソッドルックアップを実行するたびにリスト全体を再計算することを回避します。</target>
        </trans-unit>
        <trans-unit id="5036dcc6c04f6c16da5439995a0999d3e2a24e94" translate="yes" xml:space="preserve">
          <source>This class may be used as a direct replacement for any use of java.util.Hashtable that does not depend on readers being blocked during updates. Like Hashtable but unlike java.util.HashMap, this class does NOT allow</source>
          <target state="translated">このクラスは、更新時にリーダがブロックされることに依存しないjava.util.Hashtableの使用の直接の代替として使用することができます。Hashtableと同様ですが、java.util.HashMapとは異なり、このクラスは</target>
        </trans-unit>
        <trans-unit id="d272b41b9db7786d68de80b43d127b8fd19109cd" translate="yes" xml:space="preserve">
          <source>This class mutates the Java AST, whilst it is still a Java AST, in readiness for conversion to Groovy, yippee-ky-a !</source>
          <target state="translated">このクラスは、Java ASTがJava ASTである間に、Groovyに変換できるようにJava ASTを変異させます。</target>
        </trans-unit>
        <trans-unit id="55d9c8517d3a0e99ce14f62132a7aaace2185bbd" translate="yes" xml:space="preserve">
          <source>This class provides a very simple linked list of memory managed elements. This class does not support concurrent modifications nor will it check for them. This class is also not thread safe.</source>
          <target state="translated">このクラスは、メモリ管理された要素の非常にシンプルなリンクされたリストを提供します。このクラスは同時変更をサポートしておらず、それをチェックすることもありません。また、このクラスはスレッドセーフではありません。</target>
        </trans-unit>
        <trans-unit id="28a37ccc500981db234c339f5342ff417d4b979f" translate="yes" xml:space="preserve">
          <source>This class provides an AST Transformation to add a log field to a class.</source>
          <target state="translated">このクラスはログフィールドをクラスに追加するためのAST変換を提供します。</target>
        </trans-unit>
        <trans-unit id="b3a68d6bf431714254204e9288b4f6f5070f27cb" translate="yes" xml:space="preserve">
          <source>This class provides an empty implementation of &lt;a href=&quot;groovyparservisitor&quot;&gt;GroovyParserVisitor&lt;/a&gt;, which can be extended to create a visitor which only needs to handle a subset of the available methods.</source>
          <target state="translated">このクラスは、&lt;a href=&quot;groovyparservisitor&quot;&gt;GroovyParserVisitorの&lt;/a&gt;空の実装を提供します。これを拡張して、使用可能なメソッドのサブセットのみを処理する必要があるビジターを作成できます。</target>
        </trans-unit>
        <trans-unit id="c9b1f302f9aedce71bb6896db58d1478516c5a7c" translate="yes" xml:space="preserve">
          <source>This class provides helper methods to determine the type from a widening operation for example for a plus operation.</source>
          <target state="translated">このクラスは、例えばプラス操作のためのワイドニング操作から型を決定するヘルパーメソッドを提供します。</target>
        </trans-unit>
        <trans-unit id="9d718529ccca05eed963c102f62e0edbdeac53d0" translate="yes" xml:space="preserve">
          <source>This class represents a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt; that is optimized for a small number of entries. For a number of entries up to &lt;code&gt;listSize&lt;/code&gt; the entries are stored in arrays. After &lt;code&gt;listSize&lt;/code&gt; entries are exceeded storage switches internally to a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt; and converts back to being array based when its size is less than or equal to &lt;code&gt;listSize&lt;/code&gt;. Null keys or values are not supported. This class is not thread safe.</source>
          <target state="translated">このクラスは、少数のエントリ用に最適化された&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;マップ&lt;/a&gt;を表します。 &lt;code&gt;listSize&lt;/code&gt; までのエントリの数については、エントリは配列に格納されます。後 &lt;code&gt;listSize&lt;/code&gt; エントリを記憶する内部スイッチ超えた&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;マップ&lt;/a&gt;のサイズ未満か等しい場合に基づいて、バックアレイであるに変換 &lt;code&gt;listSize&lt;/code&gt; 。ヌルキーまたは値はサポートされていません。このクラスはスレッドセーフではありません。</target>
        </trans-unit>
        <trans-unit id="0f6265e2af3bfac2864af2a93fa49da29483f821" translate="yes" xml:space="preserve">
          <source>This class represents a MetaMethod that is a closure that pretends to be a static method. It is used by ExpandoMetaClass to allow addition of static methods defined as closures</source>
          <target state="translated">このクラスは、静的メソッドのふりをしたクロージャであるMetaMethodを表します。クロージャとして定義された静的メソッドを追加できるようにするためにExpandoMetaClassで使用されます。</target>
        </trans-unit>
        <trans-unit id="5ff97f4943b1b4f4e15e6cd296448b65369de926" translate="yes" xml:space="preserve">
          <source>This class represents a list of expressions used to create closures. Example: &lt;code&gt;
 def foo = (1;2;;)
 &lt;/code&gt; The right side is a ClosureListExpression consisting of two ConstantExpressions for the values 1 and 2, and two EmptyStatement entries. The ClosureListExpression defines a new variable scope. All created Closures share this scope.</source>
          <target state="translated">このクラスは、クロージャの作成に使用される式のリストを表します。例： &lt;code&gt; def foo = (1;2;;) &lt;/code&gt; 右側は、値1と2の2つのConstantExpressionsと2つのEmptyStatementエントリで構成されるClosureListExpressionです。ClosureListExpressionは、新しい変数スコープを定義します。作成されたすべてのクロージャは、このスコープを共有します。</target>
        </trans-unit>
        <trans-unit id="e490a48691949cdd943dd24ddf11e92b18b4c106" translate="yes" xml:space="preserve">
          <source>This class represents a property with multiple setters. Unlike a MetaBeanProperty you cannot get the setter in this case. Instead invocation is done through the meta class of the property recevier.</source>
          <target state="translated">このクラスは、複数のセッターを持つプロパティを表します。MetaBeanPropertyとは異なり、この場合はセッターを取得することができません。代わりに、呼び出しはプロパティのメタクラスを介して行われます。</target>
        </trans-unit>
        <trans-unit id="b9fe55eb136f2d9bda5b170f7ec0b6ef4984da04" translate="yes" xml:space="preserve">
          <source>This class represents a reference to the most actual incarnation of a Metaclass. INTERNAL USE ONLY.</source>
          <target state="translated">このクラスは、メタクラスの最も実際的な化身への参照を表します。内部使用のみ。</target>
        </trans-unit>
        <trans-unit id="b1af226539f2899b14379794e0635a39c3ce7e1e" translate="yes" xml:space="preserve">
          <source>This class represents a sequence of &lt;a href=&quot;bytecodeinstruction&quot;&gt;BytecodeInstruction&lt;/a&gt;s or &lt;a href=&quot;../ast/astnode&quot;&gt;ASTNode&lt;/a&gt;s. The evaluation is depending on the type of the visitor.</source>
          <target state="translated">このクラスは、&lt;a href=&quot;bytecodeinstruction&quot;&gt;BytecodeInstruction&lt;/a&gt;または&lt;a href=&quot;../ast/astnode&quot;&gt;ASTNode&lt;/a&gt;のシーケンスを表します。評価は訪問者のタイプによって異なります。</target>
        </trans-unit>
        <trans-unit id="5460585a78cb458d104b1c09f4518524d3250db9" translate="yes" xml:space="preserve">
          <source>This class represents an error that is thrown when a bug is recognized inside the runtime. Basically it is thrown when a constraint is not fulfilled that should be fulfilled.</source>
          <target state="translated">このクラスは、ランタイム内部でバグが認識されたときにスローされるエラーを表します。基本的には、満たすべき制約が満たされていない場合にスローされます。</target>
        </trans-unit>
        <trans-unit id="9e8efb041e1d70cfb3206ad25e6c209a78c9bbd0" translate="yes" xml:space="preserve">
          <source>This class represents non public API used by AsmClassGenerator. Don't use this class in your code</source>
          <target state="translated">このクラスは AsmClassGenerator が使用する非パブリック API を表します。このクラスをコード中で使用しないでください。</target>
        </trans-unit>
        <trans-unit id="8dc5c7fcffd17f002fdf6362493892385bbec93d" translate="yes" xml:space="preserve">
          <source>This class returns half bound &lt;a href=&quot;fullbinding&quot;&gt;FullBinding&lt;/a&gt;s on the source half to the model object for every property reference (and I do mean every, valid or not, queried before or not). These returned half bindings are stored strongly in a list when generated. Changing the model will keep all existing bindings but change the source on all of the bindings. Formerly Known as Model Binding.</source>
          <target state="translated">このクラスは、すべてのプロパティ参照のモデルオブジェクトにソース半分のハーフバウンド&lt;a href=&quot;fullbinding&quot;&gt;FullBindingを&lt;/a&gt;返します（つまり、有効かどうかにかかわらず、以前にクエリされたかどうかを意味します）。これらの返されたハーフバインディングは、生成時にリストに強力に保存されます。モデルを変更すると、既存のすべてのバインディングが保持されますが、すべてのバインディングのソースが変更されます。以前はモデルバインディングと呼ばれていました。</target>
        </trans-unit>
        <trans-unit id="9e6c51aebeac50037713f9721b08801c77dc34e7" translate="yes" xml:space="preserve">
          <source>This class returns half bound &lt;a href=&quot;fullbinding&quot;&gt;FullBinding&lt;/a&gt;s on the source half to the model object for every property reference (and I do mean every, valid or not, queried before or not). These returned half bindings are stored strongly in a list when generated. Changing the model will keep all existing bindings but change the source on all of the bininfs Formerly Known as Model Binding.</source>
          <target state="translated">このクラスは、すべてのプロパティ参照のモデルオブジェクトにソース半分のハーフバウンド&lt;a href=&quot;fullbinding&quot;&gt;FullBindingを&lt;/a&gt;返します（つまり、有効かどうかにかかわらず、以前にクエリされたかどうかを意味します）。これらの返されたハーフバインディングは、生成時にリストに強力に保存されます。モデルを変更すると、既存のすべてのバインディングが保持されますが、以前はモデルバインディングと呼ばれていたすべてのbininfのソースが変更されます。</target>
        </trans-unit>
        <trans-unit id="c8b96a7d9802784a5662432c77e71b4d3622ca61" translate="yes" xml:space="preserve">
          <source>This class takes Groovy source code, compiles it to a specific compile phase, and then decompiles it back to the groovy source. It is used by GroovyConsole's AST Browser, but can also be invoked from the command line.</source>
          <target state="translated">このクラスは、Groovyのソースコードを受け取り、特定のコンパイルフェーズにコンパイルしてから、groovyのソースにデコンパイルして戻します。これはGroovyConsoleのAST Browserで使用されますが、コマンドラインから呼び出すこともできます。</target>
        </trans-unit>
        <trans-unit id="806720aed213bca40586cfe6fc91e7e7625aa6f6" translate="yes" xml:space="preserve">
          <source>This class will delegate all calls to a WriterController given in the constructor.</source>
          <target state="translated">このクラスは、コンストラクタで与えられたWriterControllerの呼び出しをすべてデリゲートします。</target>
        </trans-unit>
        <trans-unit id="2c4727fcfc1ab42e56910178a7ab2ce60355d891" translate="yes" xml:space="preserve">
          <source>This code is executed after the method is called.</source>
          <target state="translated">このコードは、メソッドが呼び出された後に実行されます。</target>
        </trans-unit>
        <trans-unit id="3715f6b9738b222d0f7aca024f9cc5c22e37d357" translate="yes" xml:space="preserve">
          <source>This code is executed after the method is optionally called.</source>
          <target state="translated">このコードは、オプションでメソッドが呼び出された後に実行されます。</target>
        </trans-unit>
        <trans-unit id="93109698a32aa712b1940a99bdbc8567f3433156" translate="yes" xml:space="preserve">
          <source>This code is executed before the method is called.</source>
          <target state="translated">このコードは、メソッドが呼び出される前に実行されます。</target>
        </trans-unit>
        <trans-unit id="75ed3577608647dd335811066a354027a410204a" translate="yes" xml:space="preserve">
          <source>This code is executed before the method is optionally called.</source>
          <target state="translated">このコードは、オプションでメソッドが呼ばれる前に実行されます。</target>
        </trans-unit>
        <trans-unit id="c4b42f2f4e1fd4b46e3443559ab2f4536ce215e3" translate="yes" xml:space="preserve">
          <source>This code is transformed by the compiler into something resembling the following snippet. Notice the difference between a String and a def/Object property:</source>
          <target state="translated">このコードは、コンパイラによって次のように変換されます。String と def/Object プロパティの違いに注目してください。</target>
        </trans-unit>
        <trans-unit id="c33c1278e97a91dcb6edf06c86644b99e9f271d8" translate="yes" xml:space="preserve">
          <source>This comparator is used when we return the list of methods from DGM which name correspond to a given name.</source>
          <target state="translated">このコンパレータは、与えられた名前に対応するメソッドのリストを DGM から返すときに使用されます。</target>
        </trans-unit>
        <trans-unit id="e75617b624f61b0683d73241b7a0d46ab3599d9b" translate="yes" xml:space="preserve">
          <source>This comparator is used when we return the list of methods from DGM which name correspond to a given name. As we also lookup for DGM methods of superclasses or interfaces, it may be possible to find two methods which have the same name and the same arguments. In that case, we should not add the method from superclass or interface otherwise the system won't be able to select the correct method, resulting in an ambiguous method selection for similar methods.</source>
          <target state="translated">このコンパレータは、与えられた名前に対応する名前のメソッドのリストを DGM から返すときに使用します。スーパークラスやインタフェースの DGM メソッドも検索しているので、同じ名前で同じ引数を持つ 2 つのメソッドを見つけることができるかもしれません。その場合、スーパークラスやインターフェースのメソッドを追加しないようにしないと、システムが正しいメソッドを選択することができず、結果的に類似したメソッドの選択が曖昧になってしまいます。</target>
        </trans-unit>
        <trans-unit id="4894b9b16a69165c0c31e618c60bcc10ce7fe009" translate="yes" xml:space="preserve">
          <source>This compilation customizer allows addiing various types of imports to the compilation unit. Supports adding:</source>
          <target state="translated">このコンパイルカスタマイザでは、コンパイルユニットに様々な種類のインポートを追加することができます。追加をサポートしています。</target>
        </trans-unit>
        <trans-unit id="9ba2a85f884d7fa0e633cdb111b7b24677cc8a10" translate="yes" xml:space="preserve">
          <source>This completer tries to behave as similar as possible to</source>
          <target state="translated">この補欠は、可能な限り</target>
        </trans-unit>
        <trans-unit id="050f26d61c4d7297780b69903203f0b647dfe314" translate="yes" xml:space="preserve">
          <source>This constant is for comparing targetBytecode to ensure it is set to JDK 1.5 or later.</source>
          <target state="translated">この定数は、targetBytecodeがJDK 1.5以降に設定されていることを確認するために、targetBytecodeを比較するためのものです。</target>
        </trans-unit>
        <trans-unit id="c8629d832b003b8c89dc03855aac1608ff5226a1" translate="yes" xml:space="preserve">
          <source>This constant is for comparing targetBytecode to ensure it is set to an earlier value than JDK 1.5.</source>
          <target state="translated">この定数は、targetBytecodeがJDK 1.5よりも古い値に設定されていることを確認するために、targetBytecodeを比較するためのものです。</target>
        </trans-unit>
        <trans-unit id="d318776f0e97720de67dae45081b1705371f4405" translate="yes" xml:space="preserve">
          <source>This constructor is public to permit tools that require a JavaBean instance to operate.</source>
          <target state="translated">このコンストラクタは、JavaBeanインスタンスを必要とするツールが動作することを許可するためのパブリックなものです。</target>
        </trans-unit>
        <trans-unit id="adebfc74f0005704245e8892d5946a9a3b3e0d7b" translate="yes" xml:space="preserve">
          <source>This converts a possibly negative index to a real index into the array.</source>
          <target state="translated">これは、負の可能性のあるインデックスを配列の実数に変換します。</target>
        </trans-unit>
        <trans-unit id="89580999f8cc2ab98adcb35587949a71043dac5a" translate="yes" xml:space="preserve">
          <source>This creates and starts the socket server on a new Thread.</source>
          <target state="translated">新しいスレッドにソケットサーバを作成して起動します。</target>
        </trans-unit>
        <trans-unit id="4cfe97596d83c01a3c1b2f921489c411e8f50f6a" translate="yes" xml:space="preserve">
          <source>This creates and starts the socket server on a new Thread. There is no need to call run or spawn a new thread yourself.</source>
          <target state="translated">これは、新しいスレッド上にソケットサーバを作成して起動します。自分でrunを呼び出したり、新しいスレッドを生成したりする必要はありません。</target>
        </trans-unit>
        <trans-unit id="f210b6ef5e62f107b81d83cc8ea5f60a3593e2ba" translate="yes" xml:space="preserve">
          <source>This customizer allows applying an AST transformation to a source unit with several strategies. Creating a customizer with the &lt;a href=&quot;asttransformationcustomizer#ASTTransformationCustomizer(java.lang.Class)&quot;&gt; class constructor&lt;/a&gt; will trigger an AST transformation for each class node of a source unit. However, you cannot pass parameters to the annotation so the default values will be used. Writing :</source>
          <target state="translated">このカスタマイザを使用すると、いくつかの戦略を使用してAST変換をソースユニットに適用できます。&lt;a href=&quot;asttransformationcustomizer#ASTTransformationCustomizer(java.lang.Class)&quot;&gt;クラスコンストラクター&lt;/a&gt;を使用してカスタマイザーを作成すると、ソースユニットのクラスノードごとにAST変換がトリガーされます。ただし、注釈にパラメータを渡すことはできないため、デフォルト値が使用されます。書く：</target>
        </trans-unit>
        <trans-unit id="7c14dcaf1099adb43e65b7bae2bb439c3ad65669" translate="yes" xml:space="preserve">
          <source>This customizer allows securing source code by controlling what code constructs are permitted. This is typically done when using Groovy for its scripting or domain specific language (DSL) features. For example, if you only want to allow arithmetic operations in a groovy shell, you can configure this customizer to restrict package imports, method calls and so on.</source>
          <target state="translated">このカスタマイザは、どのようなコード構成が許可されるかを制御することで、ソースコードの安全性を確保することができます。これは通常、Groovy をスクリプトやドメイン固有の言語 (DSL)機能に使用する場合に行われます。例えば、groovyシェルで算術演算のみを許可したい場合、このカスタマイザを設定してパッケージのインポートやメソッドの呼び出しなどを制限することができます。</target>
        </trans-unit>
        <trans-unit id="c5a34da6d1a917395eafdae691fc9b3b8e14c4ed" translate="yes" xml:space="preserve">
          <source>This differs from normal setters in that we need to add a declared exception java.beans.PropertyVetoException</source>
          <target state="translated">これは、宣言された例外を追加する必要があるという点で、通常のセッターとは異なります。</target>
        </trans-unit>
        <trans-unit id="a09a623dc06b4ba819cd522a87f90fc6033ededc" translate="yes" xml:space="preserve">
          <source>This enumeration can be used whenever it is preferred to annotate a class as &lt;a href=&quot;typechecked&quot;&gt;TypeChecked&lt;/a&gt; in general, but where only one or more methods are &quot;dynamic&quot;. This allows the user to annotate the class itself then annotate only the methods which require exclusion.</source>
          <target state="translated">この列挙は、一般に&lt;a href=&quot;typechecked&quot;&gt;TypeChecked&lt;/a&gt;としてクラスに注釈を付けることが望ましい場合はいつでも使用できますが、1つ以上のメソッドのみが「動的」です。これにより、ユーザーはクラス自体に注釈を付けてから、除外が必要なメソッドのみに注釈を付けることができます。</target>
        </trans-unit>
        <trans-unit id="d7e2273d5cb9c0c49c2bb24c5a83bf004429212a" translate="yes" xml:space="preserve">
          <source>This enumeration is used by the AST transformations which rely on static type checking, either to store or to retrieve information from AST node metadata. The values of this enumeration are used as metadata keys.</source>
          <target state="translated">この列挙は、静的な型検査に依存するAST変換によって使用され、ASTノードのメタデータから情報を取得したり保存したりするために使用されます。この列挙の値がメタデータのキーとなります。</target>
        </trans-unit>
        <trans-unit id="ab60dfbbe5ec836f7b35f8c976d66e68b2ce1c5a" translate="yes" xml:space="preserve">
          <source>This example prints out file counts and size aggregates for groovy source files within a directory tree:</source>
          <target state="translated">この例では、ディレクトリツリー内のgroovyソースファイルのファイル数とサイズの集計を表示します。</target>
        </trans-unit>
        <trans-unit id="b3f387a9504f8b156c1813987d3758205ede705a" translate="yes" xml:space="preserve">
          <source>This example shows a common convention. When mixing short and long names, the short names are often one character in size. One character options with arguments don't require a space between the option and the argument, e.g. &lt;code&gt;-Ddebug=true&lt;/code&gt;. The example also shows the use of '_' when no short option is applicable.</source>
          <target state="translated">この例は、一般的な規則を示しています。短い名前と長い名前を混在させる場合、短い名前のサイズは1文字になることがよくあります。引数付きの1文字のオプションでは、オプションと引数の間にスペースは必要ありません（例： &lt;code&gt;-Ddebug=true&lt;/code&gt; )。この例は、短いオプションが適用できない場合の「_」の使用も示しています。</target>
        </trans-unit>
        <trans-unit id="f2dddbad35ebae3e8699d18932c17e50f8f9d1bb" translate="yes" xml:space="preserve">
          <source>This example uses a mix of the JSP style and GString style placeholders but you can typically use just one style if you wish. Running this example will produce this output:</source>
          <target state="translated">この例では、JSP スタイルと GString スタイルのプレースホルダを混在させて使用していますが、必要に応じて通常は 1 つのスタイルだけを使用することもできます。この例を実行すると、以下のような出力が得られます。</target>
        </trans-unit>
        <trans-unit id="7819bf00abfa1a28062447c4112ec17536e74c15" translate="yes" xml:space="preserve">
          <source>This example will produce this output:</source>
          <target state="translated">この例では、このような出力が得られます。</target>
        </trans-unit>
        <trans-unit id="6a9df6b19f4850ac1dca0ca99754733c1765bf4e" translate="yes" xml:space="preserve">
          <source>This exception is thrown if an attempt is made to set a read only property</source>
          <target state="translated">この例外は、読み取り専用のプロパティを設定しようとした場合にスローされます。</target>
        </trans-unit>
        <trans-unit id="c3c90e86c15b6995f6996affd8fd0622412caea4" translate="yes" xml:space="preserve">
          <source>This exception is thrown if the runtime is unable to select a method. This class builds the exception text when calling getMessage.</source>
          <target state="translated">この例外は、ランタイムがメソッドを選択できない場合にスローされます。このクラスは、getMessageを呼び出す際に例外のテキストをビルドします。</target>
        </trans-unit>
        <trans-unit id="7a099c6f741eb0347d0ea40c91b286e1ba7e1c6f" translate="yes" xml:space="preserve">
          <source>This extension also supports optional type checking of the model</source>
          <target state="translated">この拡張機能は、オプションでモデルの型チェックもサポートしています。</target>
        </trans-unit>
        <trans-unit id="2e0f02c76915f7464bc8c11fd1e37c238231e442" translate="yes" xml:space="preserve">
          <source>This factory allows the generation of a &lt;a href=&quot;../secureastcustomizer&quot;&gt;SecureASTCustomizer&lt;/a&gt;. Embedded elements are delegated to a &lt;a href=&quot;../secureastcustomizer&quot;&gt;SecureASTCustomizer&lt;/a&gt; instance.</source>
          <target state="translated">このファクトリでは、&lt;a href=&quot;../secureastcustomizer&quot;&gt;SecureASTCustomizerを&lt;/a&gt;生成できます。埋め込まれた要素は、&lt;a href=&quot;../secureastcustomizer&quot;&gt;SecureASTCustomizer&lt;/a&gt;インスタンスに委任されます。</target>
        </trans-unit>
        <trans-unit id="75bc8d98e4b55661fc8e92d226274681ee70c5d6" translate="yes" xml:space="preserve">
          <source>This factory allows the generation of an &lt;a href=&quot;../importcustomizer&quot;&gt;import customizer&lt;/a&gt;. You may embed several elements:</source>
          <target state="translated">このファクトリでは、&lt;a href=&quot;../importcustomizer&quot;&gt;インポートカスタマイザを&lt;/a&gt;生成できます。いくつかの要素を埋め込むことができます。</target>
        </trans-unit>
        <trans-unit id="6408936103d79d9191656e5b5b91824ad76e65c7" translate="yes" xml:space="preserve">
          <source>This factory class is used to create a listener() node for JmxBuilder. Listener nodes are used to create a generic event listener (that is automatically registered with the MBean) that can handle any event broadcasted on the MBeanServer's event bus.</source>
          <target state="translated">このファクトリクラスは、JmxBuilder の Listener()ノードを作成するために使用します。リスナーノードは、MBeanServerのイベントバス上でブロードキャストされたイベントを処理できる汎用イベントリスナー(MBeanに自動的に登録されます)を作成するために使用します。</target>
        </trans-unit>
        <trans-unit id="64a41a5aefc83666cff21add72710b51c3a25d2f" translate="yes" xml:space="preserve">
          <source>This factory generates an ASTTransformationCustomizer.</source>
          <target state="translated">ASTTransformationCustomizerを生成します。</target>
        </trans-unit>
        <trans-unit id="613b0e8a47bfd00974cb820fbc8fcdabb33420f9" translate="yes" xml:space="preserve">
          <source>This factory generates an array of compilation customizers.</source>
          <target state="translated">このファクトリは、コンパイル・カスタマイザーの配列を生成します。</target>
        </trans-unit>
        <trans-unit id="9250f3138d28ed13d750ef456e16992d0448f7fb" translate="yes" xml:space="preserve">
          <source>This factory is the correct way to wire together a Groovy parser and lexer.</source>
          <target state="translated">このファクトリは、Groovy パーサーとレキサーを一緒に配線する正しい方法です。</target>
        </trans-unit>
        <trans-unit id="92ce93b17831cccaf34755de29d405aee9ba805a" translate="yes" xml:space="preserve">
          <source>This factory lets a user define a compilation customizer without having to define an anonymous inner class.</source>
          <target state="translated">このファクトリを使用すると、ユーザーは匿名の内部クラスを定義することなくコンパイルカスタマイザーを定義することができます。</target>
        </trans-unit>
        <trans-unit id="0f3cad60cfab134b21507e52064941c3963e3069" translate="yes" xml:space="preserve">
          <source>This factory returns a container node for all other nodes that are used to collect meta data for resources that are exported to the MBeanServer for management.</source>
          <target state="translated">このファクトリは、管理のために MBeanServer にエクスポートされるリソースのメタデータを収集するために使用される他のすべてのノードのコンテナノードを返します。</target>
        </trans-unit>
        <trans-unit id="974ec32a45157e53b4a9707aa7c20f425a6b5889" translate="yes" xml:space="preserve">
          <source>This factory returns the bean() node. This node is used to declaratively expose a POGO/POJO to be exported to the MBeanServer for management. You can use the builder node to declare the descriptor or embed the descriptor directly in the object being exposed using static variable descriptor (or jmx). You should note that embedded descriptor takes precedence over declared builder descriptor.</source>
          <target state="translated">このファクトリは、bean()ノードを返します。このノードは、管理のために MBeanServer にエクスポートされる POGO/POJO を宣言的に公開するために使用されます。ビルダー・ノードを使用して記述子を宣言したり、静的変数記述子(または jmx)を使用して公開するオブジェクトに直接記述子を埋め込んだりすることができます。埋め込みディスクリプタは、宣言されたビルダーディスクリプタよりも優先されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="34a50447c879fcb2342872b489a204ccc49314ed" translate="yes" xml:space="preserve">
          <source>This feature is particularly useful on operating systems which place limitations on the size of the command line (e.g. Windows). The feature is similar to the 'Command Line Argument File' processing supported by javadoc and javac. Consult the corresponding documentation for those tools if you wish to see further examples.</source>
          <target state="translated">この機能は、コマンドラインのサイズに制限があるオペレーティングシステム(Windowsなど)で特に有用です。この機能は javadoc や javac でサポートされている 'Command Line Argument File' 処理に似ています。さらに例を見たい場合は、これらのツールの対応するドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="ce367d20dbb2c637770c58d933db6117f53236b0" translate="yes" xml:space="preserve">
          <source>This field is used to track assignments in if/else branches, for loops and while loops.</source>
          <target state="translated">このフィールドは、if/elseブランチ、forループ、whileループでの割り当てを追跡するために使用されます。</target>
        </trans-unit>
        <trans-unit id="cbf12fc93c6526242b10d4458cb6d1beee3e2d25" translate="yes" xml:space="preserve">
          <source>This field is used to track assignments in if/else branches, for loops and while loops. For example, in the following code: &lt;code&gt;if (cond) { x = 1 } else { x = '123' }&lt;/code&gt; the inferred type of x after the if/else statement should be the LUB of int and String.</source>
          <target state="translated">このフィールドは、if / elseブランチ、forループ、およびwhileループの割り当てを追跡するために使用されます。たとえば、次のコードでは、次のようになります &lt;code&gt;if (cond) { x = 1 } else { x = '123' }&lt;/code&gt; if / elseステートメントの後のxの推定タイプは、intとStringのLUBである必要があります。</target>
        </trans-unit>
        <trans-unit id="1d467559145b6ea3f70124f19c4aef65c4321104" translate="yes" xml:space="preserve">
          <source>This field used for type derivation Check IfStatement matched pattern: Object var1; if (!</source>
          <target state="translated">型の導出に使用されるこのフィールドは、IfStatementがパターンにマッチしたかどうかをチェックします。オブジェクト var1;if (!</target>
        </trans-unit>
        <trans-unit id="0bd93366cf93d2b7dd6b74705e67955660b7f0e0" translate="yes" xml:space="preserve">
          <source>This field used for type derivation Check IfStatement matched pattern: Object var1; if (!(var1 instanceOf Runnable)){ return } // Here var1 instance of Runnable</source>
          <target state="translated">このフィールドは型の導出に使用されます。 IfStatementがパターンにマッチしたかどうかをチェックします。オブジェクト var1;if (! //ここでは var1 実行可能なインスタンス</target>
        </trans-unit>
        <trans-unit id="b090238d44551f2e3d0b2f1cf114fd579922fca8" translate="yes" xml:space="preserve">
          <source>This fixes strict jline 2.12 ArgumentCompleter See https://github.com/jline/jline2/pull/202</source>
          <target state="translated">これは strict jline 2.12 ArgumentCompleter を修正したものです。 https://github.com/jline/jline2/pull/202 を参照してください。</target>
        </trans-unit>
        <trans-unit id="850443fd7300e262bc8d43a95f5840748fef1125" translate="yes" xml:space="preserve">
          <source>This gets the code statement of the closure.</source>
          <target state="translated">これはクロージャのコード文を取得します。</target>
        </trans-unit>
        <trans-unit id="692a8f7be3be9f9075aa6a114742d6a2eca54b83" translate="yes" xml:space="preserve">
          <source>This gets the code statement of the closure. You can read this method to find out what actions the closure is going to perform.</source>
          <target state="translated">これは、クロージャのコード文を取得します。このメソッドを読むことで、クロージャがどのようなアクションを実行しようとしているかを知ることができます。</target>
        </trans-unit>
        <trans-unit id="3a0d23a5c458818da1444db6470960e4731416f6" translate="yes" xml:space="preserve">
          <source>This has the same interface as the original JsonSlurper written for version 1.8.0, but its implementation has completely changed. It is now up to 20x faster than before, and its speed competes and often substantially exceeds popular common JSON parsers circa Jan, 2014.</source>
          <target state="translated">これはバージョン1.8.0用に書かれたオリジナルのJsonSlurperと同じインターフェイスを持っていますが、その実装は完全に変更されています。以前よりも最大20倍速くなり、その速度は2014年1月頃の人気のある一般的なJSONパーサーと競合し、しばしば大幅に上回っています。</target>
        </trans-unit>
        <trans-unit id="f01f9c203f4513ef8926ff9ee372b31db329b713" translate="yes" xml:space="preserve">
          <source>This hint handles all those cases by picking the generics from the first argument of the method (by default).</source>
          <target state="translated">このヒントは、(デフォルトでは)メソッドの第一引数からジェネリックをピックすることで、これらのすべてのケースを処理します。</target>
        </trans-unit>
        <trans-unit id="8328da1e3c3000c040f7a4774ac735b142d97837" translate="yes" xml:space="preserve">
          <source>This holds a mapping from value key to value value to maximize laziness.</source>
          <target state="translated">これは、怠惰を最大化するために、値のキーから値の値へのマッピングを保持しています。</target>
        </trans-unit>
        <trans-unit id="74974d1e6f40fe28cb6229fba49e41c77b4b9dfd" translate="yes" xml:space="preserve">
          <source>This implementation breaks the contract of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/List.html#get(int)&quot;&gt;List.get&lt;/a&gt; as it a) possibly modifies the underlying list and b) does NOT throw an &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/IndexOutOfBoundsException.html&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; when &lt;code&gt;index &amp;lt; 0 || index &amp;gt;= size()&lt;/code&gt;.</source>
          <target state="translated">この実装は、a）基になるリストを変更する可能性があり、b） &lt;code&gt;index &amp;lt; 0 || index &amp;gt;= size()&lt;/code&gt; 場合に&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/IndexOutOfBoundsException.html&quot;&gt;IndexOutOfBoundsExceptionをスロー&lt;/a&gt;しないため、&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/List.html#get(int)&quot;&gt;List.get&lt;/a&gt;のコントラクトを破ります|| インデックス&amp;gt; = size（）。</target>
        </trans-unit>
        <trans-unit id="b8e1fbe89d11c8857d6efca6ff572126bb4b9fb0" translate="yes" xml:space="preserve">
          <source>This implementation provides a verbosity flag switching log statements. The servlet init parameter name is:</source>
          <target state="translated">この実装では、冗長フラグの切り替えログ文を提供します。サーブレットのinitパラメータ名は</target>
        </trans-unit>
        <trans-unit id="bfe169c077ea389406a1a9f2f85518f31a03e1e3" translate="yes" xml:space="preserve">
          <source>This interface allows the user to provide a custom expression checker if the dis/allowed expression lists are not sufficient</source>
          <target state="translated">このインターフェイスでは、許可されていない/許可されていない式のリストが十分でない場合に、ユーザーがカスタム式チェッカを提供することができます。</target>
        </trans-unit>
        <trans-unit id="f685dd51bbeafd50fa968a283a1c649d74afa7b5" translate="yes" xml:space="preserve">
          <source>This interface allows the user to provide a custom statement checker if the dis/allowed statement lists are not sufficient</source>
          <target state="translated">このインターフェイスでは、ユーザは、許可されていない/許可されていないステートメントのリストが十分でない場合に、カスタムステートメントチェッカーを提供することができます。</target>
        </trans-unit>
        <trans-unit id="2337efc6043edb753db0bcb30b3f4690571b8928" translate="yes" xml:space="preserve">
          <source>This interface defines a complete generic visitor for a parse tree produced by &lt;a href=&quot;groovyparser&quot;&gt;GroovyParser&lt;/a&gt;.</source>
          <target state="translated">このインターフェースは、&lt;a href=&quot;groovyparser&quot;&gt;GroovyParser&lt;/a&gt;によって生成された解析ツリーの完全な汎用ビジターを定義します。</target>
        </trans-unit>
        <trans-unit id="2900e3be61204d298b4a3fee9de9690a314c1fa7" translate="yes" xml:space="preserve">
          <source>This interface defines a high-level API for handling type checking errors. As a dynamic language and a platform for developing DSLs, the Groovy language provides a lot of means to supply custom bindings or methods that are not possible to find at compile time. However, it is still possible to help the compiler, for example by telling it what is the type of an unresolved property. For basic DSL type checking, implementing those methods would help the type checker and make it silent where it normally throws errors.</source>
          <target state="translated">このインタフェースは、型チェックエラーを処理するための高レベルAPIを定義します。動的言語であり、DSLを開発するためのプラットフォームであるGroovy言語は、コンパイル時には見つけられないカスタムバインディングやメソッドを提供するための多くの手段を提供しています。しかし、未解決のプロパティの型をコンパイラに伝えるなど、コンパイラを支援することは可能です。基本的な DSL の型チェックのために、これらのメソッドを実装することで、型チェッカーを助け、通常エラーをスローする場所では無音にすることができます。</target>
        </trans-unit>
        <trans-unit id="14a3094142b4fffa63ea1c44ae063fa652e1bd9e" translate="yes" xml:space="preserve">
          <source>This interface is for AST transformations which must be aware of the compilation unit where they are applied.</source>
          <target state="translated">このインタフェースは、AST変換が適用されるコンパイル単位を意識したものでなければなりません。</target>
        </trans-unit>
        <trans-unit id="b19bc498138b8f77f8e42e14567db95fb471708c" translate="yes" xml:space="preserve">
          <source>This is JmxBuilder's factory builder class. It is the parent node to all other children nodes supported by JmxBuilder.</source>
          <target state="translated">JmxBuilderのファクトリビルダークラスです。JmxBuilder がサポートする他のすべての子ノードの親ノードとなります。</target>
        </trans-unit>
        <trans-unit id="5f542101a83909bc55b807fe7fad6cb48b595713" translate="yes" xml:space="preserve">
          <source>This is a Token sub class to track line information</source>
          <target state="translated">線路情報を追跡するためのトークンサブクラスです。</target>
        </trans-unit>
        <trans-unit id="b5b6cd0c90811ee4dbf92dd31e30b69e6a4b7932" translate="yes" xml:space="preserve">
          <source>This is a basic implementation of a map able to forget its values. This map uses internally a ConcurrentHashMap, thus should be safe for concurrency. hashcode and equals are used to find the entries and should thus be implemented properly for the keys. This map does not support null keys.</source>
          <target state="translated">これは、値を忘れることができるマップの基本的な実装です。このマップは内部的に ConcurrentHashMap を使用しているので、同時実行でも安全です。 hashcode と equals はエントリの検索に使用されます。このマップはヌルキーをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="ecd84853e48a3218ca7dae60fa14210067325fe4" translate="yes" xml:space="preserve">
          <source>This is a basic parser with no index overlay.</source>
          <target state="translated">これはインデックスオーバーレイのない基本的なパーサーです。</target>
        </trans-unit>
        <trans-unit id="bd1aba50be39fcc34d283e005a86755e0b3badd7" translate="yes" xml:space="preserve">
          <source>This is a basic parser with no index overlay. It is wicked fast, but not as fast at the INDEX_OVERLAY. It should be on average the fastest known JSON parser on the JVM circa Jan 2014. But not as fast as INDEX_OVERLAY.</source>
          <target state="translated">インデックスオーバーレイのない基本的なパーサーです。非常に高速ですが、INDEX_OVERLAYではそれほど高速ではありません。2014年1月頃のJVM上では、平均して最速の既知のJSONパーサーであるはずです。しかし、index_overlayほど速くはありません。</target>
        </trans-unit>
        <trans-unit id="4d663199a467bd31d2d6cc978eef89dea6a3add1" translate="yes" xml:space="preserve">
          <source>This is a bit of plumbing which resumes collection of string constructor bodies, after an embedded expression has been parsed.</source>
          <target state="translated">これは、埋め込まれた式が解析された後に、文字列コンストラクタボディのコレクションを再開するためのちょっとした配管です。</target>
        </trans-unit>
        <trans-unit id="229cccdf96ec491181b6b4aefce4ce6c2b429a0f" translate="yes" xml:space="preserve">
          <source>This is a bit of plumbing which resumes collection of string constructor bodies, after an embedded expression has been parsed. Usage: new GroovyRecognizer(new GroovyLexer(in).plumb()).</source>
          <target state="translated">これは、埋め込まれた式が解析された後に、文字列コンストラクタボディのコレクションを再開するためのちょっとした配管です。使用法:new GroovyRecognizer(new GroovyLexer(in).plumb())。</target>
        </trans-unit>
        <trans-unit id="0186d9b2589f2bdddecc55d72affdc0ae0321117" translate="yes" xml:space="preserve">
          <source>This is a bit of plumbing which resumes collection of string constructor bodies, after an embedded expression has been parsed. Usage: new JavaRecognizer(new JavaLexer(in).plumb()).</source>
          <target state="translated">これは、埋め込まれた式が解析された後に、文字列コンストラクタボディのコレクションを再開するためのちょっとした配管です。使用法:new JavaRecognizer(new JavaLexer(in).plumb())。</target>
        </trans-unit>
        <trans-unit id="8f11df9510d09a2eefc345dd606cc8bb630671ad" translate="yes" xml:space="preserve">
          <source>This is a generated class used internally during the writing of bytecode within the CallSiteWriter logic. This is not a class exposed to users, as is the case with almost all classes in the org.codehaus.groovy packages.</source>
          <target state="translated">これは、CallSiteWriter ロジック内でバイトコードを書く際に内部的に使用される生成クラスです。org.codehaus.groovy パッケージのほとんどすべてのクラスがそうであるように、これはユーザに公開されるクラスではありません。</target>
        </trans-unit>
        <trans-unit id="8988c21207c9c0283d7bdfe9794fc76b8616da94" translate="yes" xml:space="preserve">
          <source>This is a helper class introduced in Groovy 2.1.0, which is used only by indy. This class is for internal use only.</source>
          <target state="translated">Groovy 2.1.0で導入されたヘルパークラスで、indyのみで使用します。このクラスは内部でのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="fd736de461897ac841a6a4d9f0a851a81005bbd5" translate="yes" xml:space="preserve">
          <source>This is a helper class, to provide a controlled entry point for the groovyc ant task forked mode.</source>
          <target state="translated">これはヘルパークラスで、groovyc antタスクのフォークモードのための制御されたエントリポイントを提供します。</target>
        </trans-unit>
        <trans-unit id="1e04a2a9657e4a822125c0bfc5d51625bdcd91ab" translate="yes" xml:space="preserve">
          <source>This is a hook for subclasses to plugin a custom strategy for mapping names to explicit methods.</source>
          <target state="translated">これは、サブクラスが名前を明示的なメソッドにマッピングするためのカスタム戦略をプラグインするためのフックです。</target>
        </trans-unit>
        <trans-unit id="6073183624d646ab13405c550c66ceae2d7e6073" translate="yes" xml:space="preserve">
          <source>This is a hook for subclasses to plugin a custom strategy for mapping names to factories.</source>
          <target state="translated">これは、サブクラスが名前を工場にマッピングするためのカスタム戦略をプラグインするためのフックです。</target>
        </trans-unit>
        <trans-unit id="3873541ad75fb8f477c82880ea8c90da25f7477f" translate="yes" xml:space="preserve">
          <source>This is a hook for subclasses to plugin a custom strategy for mapping names to property methods.</source>
          <target state="translated">これは、名前をプロパティメソッドにマッピングするためのカスタム戦略をサブクラスにプラグインするためのフックです。</target>
        </trans-unit>
        <trans-unit id="851a6e18d0cb9ae66a159433966e5c40ef10ca00" translate="yes" xml:space="preserve">
          <source>This is a implementation of DL distance between two Object arrays instead of character streams.</source>
          <target state="translated">文字ストリームの代わりに、2つのオブジェクト配列間のDL距離を実装したものです。</target>
        </trans-unit>
        <trans-unit id="e5dc74906a59f9ecb021663128a7faa33f6bff55" translate="yes" xml:space="preserve">
          <source>This is a implementation of DL distance between two Object arrays instead of character streams. The objects are compared using their equals method. No objects may be null. This implementation is based on Chas Emerick's implementation of Levenshtein Distance for jakarta commons.</source>
          <target state="translated">これは、文字ストリームの代わりに2つのオブジェクト配列間のDL距離を実装したものです。オブジェクトは、それらの equals メソッドを使用して比較されます。オブジェクトがヌルになることはありません。この実装は、Chas EmerickによるJakarta commonsのためのLevenshtein Distanceの実装に基づいています。</target>
        </trans-unit>
        <trans-unit id="3f63b7ad6a94acd9220b6ceb153faa4b94cff8d8" translate="yes" xml:space="preserve">
          <source>This is a slightly modified version of the Damerau Levenshtein distance algorithm.</source>
          <target state="translated">これは、Damerau Levenshtein距離アルゴリズムを少し修正したものです。</target>
        </trans-unit>
        <trans-unit id="6379b9e33df64353e3c1267e96d9abfd788c6427" translate="yes" xml:space="preserve">
          <source>This is a slightly modified version of the Damerau Levenshtein distance algorithm. It has a additional test to see if a character has switched case, in the original algorithm this counts as a substitution. The &quot;cost&quot; for a substitution is given as 10 instead of 1 in this version, this enables transpositions and case modifications to have a lower cost than substitutions. Currently the lowercase versions of t_j and s_i isn't cached, its probable that some speed could be gained from this. This version is based on Chas Emerick's implementation of Levenshtein Distance for jakarta commons.</source>
          <target state="translated">これは、Damerau Levenshtein 距離アルゴリズムを少し修正したものです。オリジナルのアルゴリズムでは、文字が大文字小文字を入れ替えたかどうかを確認するテストが追加されていますが、これは置換としてカウントされます。このバージョンでは、置換のための「コスト」が1ではなく10として与えられており、転置や大文字小文字の変更が置換よりも低いコストで行えるようになっています。現在、t_j と s_i の小文字版はキャッシュされていません。このバージョンは、Chas Emerick氏のLevenshtein Distanceの実装に基づいています。</target>
        </trans-unit>
        <trans-unit id="1edb3c98dd64270eec01a19ffa8efd13aa8ca31a" translate="yes" xml:space="preserve">
          <source>This is a static access auto download enabler.</source>
          <target state="translated">これは静的アクセス自動ダウンロードイネーブラーです。</target>
        </trans-unit>
        <trans-unit id="116aa4ab4439a80ee9ba7112e165f856489f00f2" translate="yes" xml:space="preserve">
          <source>This is a static access auto download enabler. It will set the 'autoDownload' value to the passed in arguments map if not already set. If 'autoDownload' is set the value will not be adjusted.</source>
          <target state="translated">これは、静的アクセス自動ダウンロードイネーブラーです。autoDownload' が設定されていない場合は、引数として渡されたマップに 'autoDownload' の値を設定します。autoDownload' が設定されている場合、値は調整されません。</target>
        </trans-unit>
        <trans-unit id="858274acd50bf067c3073a5802ebcb847cb11033" translate="yes" xml:space="preserve">
          <source>This is a static access kill-switch.</source>
          <target state="translated">これは静的アクセスキルスイッチです。</target>
        </trans-unit>
        <trans-unit id="6fe1b6d5fdbc3093d68f9306c05bf649d9053221" translate="yes" xml:space="preserve">
          <source>This is a static access kill-switch. All of the static shortcut methods in this class will not work if this property is set to false. By default it is set to true.</source>
          <target state="translated">これは静的アクセス・キルスイッチです。このプロパティが false に設定されていると、このクラスのすべての静的ショートカットメソッドは動作しません。デフォルトでは true に設定されています。</target>
        </trans-unit>
        <trans-unit id="9354b1e014a107432bcac0ae43777acc06c0de53" translate="yes" xml:space="preserve">
          <source>This is a utility class used as a helper for JmxBuilder.</source>
          <target state="translated">JmxBuilderのヘルパーとして使用するユーティリティクラスです。</target>
        </trans-unit>
        <trans-unit id="a5225ac2335eb47576067c0b8960cb72cb13bccd" translate="yes" xml:space="preserve">
          <source>This is also different than scripting.dev.java.net which used an initial lowercase.</source>
          <target state="translated">また、頭文字の小文字を使用していたscripting.dev.java.netとは異なります。</target>
        </trans-unit>
        <trans-unit id="579c6bcb0a618a267161c2207b075c96e7d5d24d" translate="yes" xml:space="preserve">
          <source>This is also different than scripting.dev.java.net which used an initial lowercase. But these are proper names and should be capitalized.</source>
          <target state="translated">これも、頭文字の小文字を使っていたscripting.dev.java.netとは違います。しかし、これらは適切な名前であり、大文字にする必要があります。</target>
        </trans-unit>
        <trans-unit id="85d017a024d6049f47ed0da7428c2774554debb2" translate="yes" xml:space="preserve">
          <source>This is an AST Node that provides some sort of looping mechanism. Typically in the form of a block that will be executed repeatedly. DoWhileStatements, WhileStatements, and ForStatements are all examples of LoopingStatements.</source>
          <target state="translated">これは、ある種のループ機構を提供するASTノードです。通常は繰り返し実行されるブロックの形をしています。DoWhileStatements,WhileStatements,ForStatementsはすべてLoopingStatementsの例です。</target>
        </trans-unit>
        <trans-unit id="0c9815db791daee2a8e2b715b6bdfe0a35a3e307" translate="yes" xml:space="preserve">
          <source>This is an annotation on a class, currently just &lt;a href=&quot;asttransformation&quot;&gt;ASTTransformation&lt;/a&gt;. This provides information about how and when to apply the transformation, such as what phase it should be applied in. The allowed phase is a function of how the transformation is introduced into the compile process. If the transform is automatically added via a marker annotation only the SEMANTIC_ANALYSIS and latter phases are legal for the phase(). This is because the annotations are not inspected until after the classes are all resolved. Also, only annotation types present during the SEMANTIC_ANALYSIS phase will be handled. Transformations adding other annotations that are transformable will have those new annotations only considered in latter phases, and only if the type was present in the source unit during SEMANTIC_ANALYSIS.</source>
          <target state="translated">これはクラスのアノテーションであり、現在は&lt;a href=&quot;asttransformation&quot;&gt;ASTTransformation&lt;/a&gt;のみです。これにより、変換を適用する方法とタイミングに関する情報が提供されます。たとえば、どのフェーズに適用する必要があるかなどです。許可されるフェーズは、変換がコンパイルプロセスにどのように導入されるかによって決まります。マーカー注釈を介して変換が自動的に追加される場合、SEMANTIC_ANALYSISとそれ以降のフェーズのみがphase（）に有効です。これは、クラスがすべて解決されるまでアノテーションが検査されないためです。また、SEMANTIC_ANALYSISフェーズ中に存在する注釈タイプのみが処理されます。変換可能な他の注釈を追加する変換では、これらの新しい注釈は後のフェーズでのみ考慮され、SEMANTIC_ANALYSIS中にタイプがソースユニットに存在した場合にのみ考慮されます。</target>
        </trans-unit>
        <trans-unit id="11e12582da84504f1479b7b5bbe01a600457f89e" translate="yes" xml:space="preserve">
          <source>This is because the Value construct is a type of index overlay that merely tracks where the token is located in the buffer, and what if any thing we noted about it (like can be converted to a decimal number, etc.).  To mitigate memory leaks this class along with CharSequenceValue implement two constructs, namely, chop, and lazyChop.  A chop is when we convert backing buffer of a Value object into a smaller buffer. A lazyChop is when we do a chop but only when a get operation is called.  The lazyChop is performed on the tree that is touched by the JSONPath expression or its ilk.  The chop operation can be done during parsing or lazily by storing the values in this construct.</source>
          <target state="translated">これは、Value コンストラクトが、単にトークンがバッファ内のどこに位置しているかを追跡するだけのインデックスオーバーレイの一種であるためであり、もし我々がそれについて注意したことがあれば(例えば、10進数に変換することができるなど)、それが何であるかを追跡するためです。メモリリークを軽減するために、このクラスは CharSequenceValue と一緒に chop と lazyChop という 2 つの構造体を実装しています。chopとは、Valueオブジェクトのバッキングバッファをより小さいバッファに変換することです。lazyChopは、取得操作が呼ばれたときにのみchopを行います。lazyChopはJSONPath式やその類のものが触れるツリーに対して実行されます。chop 操作は、この構造体に値を格納することで、解析中に行うことも、怠惰に行うこともできます。</target>
        </trans-unit>
        <trans-unit id="741dcdf92b314485a30d1f79b83cc4f348ec1d58" translate="yes" xml:space="preserve">
          <source>This is commonly used to simplify object creation, such as this example:</source>
          <target state="translated">この例のように、オブジェクトの作成を簡略化するためによく使われます。</target>
        </trans-unit>
        <trans-unit id="1248b519078b17c04626ddc0fb70c6f2e9facdfe" translate="yes" xml:space="preserve">
          <source>This is especially useful when executing foreign scripts that you do not have control over. Inject this transformation into a script that you need to interrupt based on some custom criteria.</source>
          <target state="translated">これは、制御できない外国のスクリプトを実行する場合に特に便利です。この変換を、いくつかのカスタム基準に基づいて中断する必要があるスクリプトに注入します。</target>
        </trans-unit>
        <trans-unit id="64f713a0f10d16561ee1c527588ce545628f9d79" translate="yes" xml:space="preserve">
          <source>This is especially useful when executing foreign scripts that you do not have control over. Inject this transformation into a script that you need to interrupt.</source>
          <target state="translated">これは、制御できない外国のスクリプトを実行するときに特に便利です。割り込みが必要なスクリプトにこの変換を注入します。</target>
        </trans-unit>
        <trans-unit id="5f5f8b6a917691ae26019a384a5b0e4890168174" translate="yes" xml:space="preserve">
          <source>This is especially useful when executing foreign scripts that you do not have control over. Inject this transformation into a script that you want to timeout after a specified amount of time.</source>
          <target state="translated">これは、制御できない外国のスクリプトを実行する場合に特に便利です。指定した時間後にタイムアウトさせたいスクリプトにこの変換を注入します。</target>
        </trans-unit>
        <trans-unit id="282c12052be9cf10b5ec3f4611f0fd964e9e4aa8" translate="yes" xml:space="preserve">
          <source>This is for internal use only.</source>
          <target state="translated">これは内部で使用するためだけのものです。</target>
        </trans-unit>
        <trans-unit id="58697d7fd61dc831ec59911b870e50930ffb3220" translate="yes" xml:space="preserve">
          <source>This is for internal use only. When an argument method is null, we cannot determine its type, so we use this one as a wildcard.</source>
          <target state="translated">これは内部で使用するためだけのものです。引数メソッドがnullの場合は型が判別できないので、これをワイルドカードとして使用しています。</target>
        </trans-unit>
        <trans-unit id="4110ed8e2a3513345d548ed89e5744b457556f9f" translate="yes" xml:space="preserve">
          <source>This is helpful for tests that don't currently work but should work one day, when the tested functionality has been implemented.</source>
          <target state="translated">これは、テストされた機能が実装されたときに、現在は動作していないが、ある日動作するはずのテストに役立ちます。</target>
        </trans-unit>
        <trans-unit id="40f30890de5ca0bafe206b76653f0c2a1f3cc299" translate="yes" xml:space="preserve">
          <source>This is just a dummy value used because String annotations values can not be null.</source>
          <target state="translated">文字列アノテーションの値をnullにすることはできないので、これは単なるダミー値です。</target>
        </trans-unit>
        <trans-unit id="6be2a0c0559d3297ae4eb1f68ef079c6642f7daf" translate="yes" xml:space="preserve">
          <source>This is just a dummy value used because String annotations values can not be null. It will be replaced by the fully qualified class name of the annotated class.</source>
          <target state="translated">Stringアノテーションの値をNULLにすることはできないので、これは単なるダミー値です。アノテーションされたクラスの完全修飾されたクラス名に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="7cfc24f9ba4df725de185c873e645d95b8f9a980" translate="yes" xml:space="preserve">
          <source>This is mostly for debugging and testing.</source>
          <target state="translated">これは主にデバッグやテストのためのものです。</target>
        </trans-unit>
        <trans-unit id="755a53945cc3fcceccdbfdf945d1dd8ce166c6d1" translate="yes" xml:space="preserve">
          <source>This is not 100% true for days. Days can actually be 23, 24 or 25 hours long (due to daylight saving adjustments.)</source>
          <target state="translated">これは日については100%当てはまるわけではありません。日は実際には23時間、24時間、25時間になることもあります(サマータイム調整のため)。</target>
        </trans-unit>
        <trans-unit id="e69572989e14bc32e4253df5a71968b90a55a7b4" translate="yes" xml:space="preserve">
          <source>This is similar to pop on a Stack where the first item in the list represents the top of the stack. Note: The behavior of this method changed in Groovy 2.5 to align with Java. If you need the old behavior use 'removeLast'.</source>
          <target state="translated">これは、リストの最初の項目がスタックの先頭を表すスタック上のポップに似ています。注意:このメソッドの動作は、Groovy 2.5でJavaに合わせて変更されました。古い動作を使用したい場合は、'removeLast'を使用してください。</target>
        </trans-unit>
        <trans-unit id="2541054c8b1af0657d417013a4c3cc09b16432fc" translate="yes" xml:space="preserve">
          <source>This is similar to push on a Stack where the first item in the list represents the top of the stack. Note: The behavior of this method changed in Groovy 2.5 to align with Java. If you need the old behavior use 'add'.</source>
          <target state="translated">これは、リストの最初の項目がスタックの先頭を表すスタック上のプッシュに似ています。注意:このメソッドの動作は、Groovy 2.5でJavaに合わせて変更されました。以前の動作を使いたい場合は 'add' を使用してください。</target>
        </trans-unit>
        <trans-unit id="aef33e4880a31dfb6572ddc1eafa9904f03c5153" translate="yes" xml:space="preserve">
          <source>This is so we don't have to reorder the stack when we call this method.</source>
          <target state="translated">これは、このメソッドを呼び出すときにスタックを並べ替える必要がないようにするためです。</target>
        </trans-unit>
        <trans-unit id="e6d75685c8a50a89d652d071d7093c3bf15cd602" translate="yes" xml:space="preserve">
          <source>This is so we don't have to reorder the stack when we call this method. At some point a better name might be in order.</source>
          <target state="translated">これは、このメソッドを呼び出すときにスタックを並べ替える必要がないようにするためです。ある時点では、もっと良い名前が必要かもしれません。</target>
        </trans-unit>
        <trans-unit id="f165cfd45f1ba553776e75f2e2f8cd2ea732f465" translate="yes" xml:space="preserve">
          <source>This is the base class for classes responsible for creating modules using properties.</source>
          <target state="translated">これは、プロパティを使ってモジュールを作成するクラスの基底クラスです。</target>
        </trans-unit>
        <trans-unit id="afb852c75331161be3de5047f08fe81e729e8211" translate="yes" xml:space="preserve">
          <source>This is the complement the behavior of the decapitalize(string) method.</source>
          <target state="translated">これは、decapitalize(string)メソッドの補完動作です。</target>
        </trans-unit>
        <trans-unit id="80b2bed606ff187cd7718223d7b85bc65c304789" translate="yes" xml:space="preserve">
          <source>This is the complement the behavior of the decapitalize(string) method. We handle names that begin with an initial lowerCase followed by upperCase with special JavaBean behavior (which is to make no change). See GROOVY-3211.</source>
          <target state="translated">これは、decapitalize(string)メソッドの動作を補完するものです。最初に小文字で始まる名前の後に大文字で始まる名前を、特別なJavaBeanの動作(これは変更しないということです)で扱います。GROOVY-3211を参照してください。</target>
        </trans-unit>
        <trans-unit id="aa3d520cd1c348add237bd7a66f5ecae3276e75e" translate="yes" xml:space="preserve">
          <source>This is the factory for node JmxBuilder.connectorClient. A call to this node returns an instance of the JMXConnector interface.</source>
          <target state="translated">ノード JmxBuilder.connectorClient のファクトリです。このノードを呼び出すと、JMXConnector インターフェースのインスタンスが返されます。</target>
        </trans-unit>
        <trans-unit id="1940febb7e000c374518f8af3b2bab8b6e867ba7" translate="yes" xml:space="preserve">
          <source>This is the grammar for what can follow a dot: x.a, x.</source>
          <target state="translated">これはドットの後に続くものの文法です:x.a,x.</target>
        </trans-unit>
        <trans-unit id="40f014c6ef17ec9a663f43144dcaa01def5b2977" translate="yes" xml:space="preserve">
          <source>This is the grammar for what can follow a dot: x.a, x.@a, x.&amp;amp;a, x.'a', etc. Note: &lt;code&gt;typeArguments&lt;/code&gt; is handled by the caller of &lt;code&gt;namePart&lt;/code&gt;.</source>
          <target state="translated">これは、ドットの後に続くことができるものの文法です：xa、x。@ a、x。＆a、x.'a 'など。注： &lt;code&gt;typeArguments&lt;/code&gt; は、 &lt;code&gt;namePart&lt;/code&gt; の呼び出し元によって処理されます。</target>
        </trans-unit>
        <trans-unit id="e3383554d710d086a6eaaccc8bcae06fb7d68886" translate="yes" xml:space="preserve">
          <source>This is the implemented method for NotificationListener.</source>
          <target state="translated">NotificationListenerに実装されているメソッドです。</target>
        </trans-unit>
        <trans-unit id="443ffb1b205dda6b43691a31bf4efab8981aa292" translate="yes" xml:space="preserve">
          <source>This is the implemented method for NotificationListener. It is called by an event emitter to dispatch JMX events to listeners. Here it handles internal JmxBuilder events.</source>
          <target state="translated">NotificationListener の実装メソッドです。イベントエミッタから呼び出され、JMXイベントをリスナーにディスパッチします。ここでは、JmxBuilderの内部イベントを処理します。</target>
        </trans-unit>
        <trans-unit id="8507fa3ee221e6d15aa495ec0771ccde8a6a13ad" translate="yes" xml:space="preserve">
          <source>This is the main method responsible for writing a tag and its attributes.</source>
          <target state="translated">これは、タグとその属性を記述するための主なメソッドです。</target>
        </trans-unit>
        <trans-unit id="8e6641635e8b64ec4febd6d638bc3e9143705eca" translate="yes" xml:space="preserve">
          <source>This is the main method responsible for writing a tag and its attributes. The arguments may be:</source>
          <target state="translated">これはタグとその属性を記述するメインのメソッドです。引数は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="bc39540baf6302d792409499cb068b434a441c03" translate="yes" xml:space="preserve">
          <source>This is the management interface for JmxEventEmitter. This MBean is used internally by JmxBuilder to broadcast events to registered listeners of the underlying MBeanServer.</source>
          <target state="translated">JmxEventEmitter の管理インターフェースです。この MBean は、JmxBuilder が内部で使用し、基礎となる MBeanServer の登録リスナーにイベントをブロードキャストするために使用します。</target>
        </trans-unit>
        <trans-unit id="a5b95a30505f17692ef2b43986549d96c8c4624a" translate="yes" xml:space="preserve">
          <source>This is the original slurper included in case someone relies on its exact behavior. JSON slurper which parses text or reader content into a data structure of lists and maps.</source>
          <target state="translated">これは、誰かがその正確な動作を信頼している場合に備えて含まれているオリジナルのスラーパーです。テキストや読者のコンテンツをリストやマップのデータ構造に解析する JSON スラーパー。</target>
        </trans-unit>
        <trans-unit id="99a8ced6206d14a027d70a5e32a450ce537c155b" translate="yes" xml:space="preserve">
          <source>This is the parser interface that backs the new JsonSlurper. It was derived from the Boon JSON parser.</source>
          <target state="translated">これは、新しい JsonSlurper をバックアップするパーサーインターフェイスです。これは Boon JSON パーサーから派生したものです。</target>
        </trans-unit>
        <trans-unit id="a3d06e9412c890cb691176655a805bf3748ea2d9" translate="yes" xml:space="preserve">
          <source>This is the server connector factory used for node JmxBuilder.connectorServer(). A call to this node returns an instance of JMXConnectorServer interface (rmi default).</source>
          <target state="translated">これは、ノード JmxBuilder.connectorServer()で使用されるサーバ・コネクタ・ファクトリです。このノードを呼び出すと、JMXConnectorServer インタフェースのインスタンスが返されます(rmi のデフォルト)。</target>
        </trans-unit>
        <trans-unit id="230e13efb9db1565670b6fea571db7753bc5e0ed" translate="yes" xml:space="preserve">
          <source>This is the standard Groovy module factory. This factory will build a module using the &lt;a href=&quot;metainfextensionmodule&quot;&gt;MetaInfExtensionModule&lt;/a&gt; by default, unless a key named &quot;moduleFactory&quot; is found in the properties file. If this is the case, then a new factory is instantiated and used instead of this factory.</source>
          <target state="translated">これは標準のGroovyモジュールファクトリです。このファクトリは、プロパティファイルに「moduleFactory」という名前のキーが見つからない限り、デフォルトで&lt;a href=&quot;metainfextensionmodule&quot;&gt;MetaInfExtensionModule&lt;/a&gt;を使用してモジュールをビルドします。この場合、このファクトリの代わりに新しいファクトリがインスタンス化されて使用されます。</target>
        </trans-unit>
        <trans-unit id="a7ec506a9828d694bfe5804799dc8c732a9b5a54" translate="yes" xml:space="preserve">
          <source>This is used to defer content creation until the point when it is streamed to the output destination. Oftentimes, content will be defined but not necessarily created (as is may be the case with a Closure definition.) In that case, the output is then 'deferred' to the point when it is serialized to the writer. This class may be used whenever an object should be responsible for creating its own textual representation, but creating the entire output as a single String would be inefficient (such as outputting a multi-gigabyte XML document.)</source>
          <target state="translated">これは、出力先にストリーム配信されるまでコンテンツの作成を延期するために使用されます。多くの場合、コンテンツは定義されますが、必ずしも作成されるわけではありません(Closureの定義のような場合があります)。このクラスは、オブジェクトがそれ自身のテキスト表現を作成する責任がある場合に使用されますが、単一の文字列として出力全体を作成するのは非効率的です(例えば、複数のギガバイトのXML文書を出力するような場合)。</target>
        </trans-unit>
        <trans-unit id="f8e14e7d5baf0cfd30f91810036e80282c090c67" translate="yes" xml:space="preserve">
          <source>This is useful to temporary change the building context to another builder without the need for a contrived setup. It will also take care of restoring the previous proxyBuilder when the execution finishes, even if an exception was thrown from inside the closure.</source>
          <target state="translated">これは、ビルディングコンテキストを一時的に別のビルダに変更したい場合に便利です。また、クロージャの内部から例外が投げられた場合でも、実行終了時に前の proxyBuilder を復元してくれます。</target>
        </trans-unit>
        <trans-unit id="ad15a34847d2c1a8ad922f0d89041ba75723b49e" translate="yes" xml:space="preserve">
          <source>This is useful to temporary change the building context to another builder without the need for a contrived setup. It will also take care of restoring the previous proxyBuilder when the execution finishes, even if an exception was thrown from inside the closure. Additionally it will use the closure's result as the value for the node identified by 'name' and assign any attributes that might have been set.</source>
          <target state="translated">これは、ビルディングコンテキストを一時的に別のビルダに変更したい場合に便利です。また、クロージャの内部から例外がスローされた場合でも、実行終了時に前の proxyBuilder を復元します。さらに、クロージャの結果を 'name' で識別されるノードの値として使用し、設定されている可能性のある属性を代入します。</target>
        </trans-unit>
        <trans-unit id="c37a541753d2b221857f2d671ab7f729da865698" translate="yes" xml:space="preserve">
          <source>This is useful to temporary change the building context to another builder without the need for a contrived setup. It will also take care of restoring the previous proxyBuilder when the execution finishes, even if an exception was thrown from inside the closure. Additionally it will use the closure's result as the value for the node identified by 'name'.</source>
          <target state="translated">これは、ビルディングコンテキストを一時的に別のビルダに変更したい場合に便利です。また、クロージャの内部から例外がスローされた場合でも、実行が終了したときに前のproxyBuilderを復元します。さらに、クロージャの結果を 'name' で識別されるノードの値として使用します。</target>
        </trans-unit>
        <trans-unit id="456d789e81e107b1750587cc65f969df3b091526" translate="yes" xml:space="preserve">
          <source>This local transform adds a logging ability to your program using Apache Commons logging. Every method call on a unbound variable named</source>
          <target state="translated">このローカル変換は、Apache Commons のロギングを使ってプログラムにロギング機能を追加します。という名前の結合されていない変数へのすべてのメソッド呼び出しは</target>
        </trans-unit>
        <trans-unit id="ccdbe2f2abb77f14d2958b7203c74bc3c3238f26" translate="yes" xml:space="preserve">
          <source>This local transform adds a logging ability to your program using Log4j logging. Every method call on a unbound variable named</source>
          <target state="translated">このローカル変換は、Log4jロギングを使用してプログラムにロギング機能を追加します。という名前の結合されていない変数へのすべてのメソッド呼び出しは</target>
        </trans-unit>
        <trans-unit id="7ca89366d56f13b0ae77d15760011e4c8ce3c9d6" translate="yes" xml:space="preserve">
          <source>This local transform adds a logging ability to your program using Log4j2 logging. Every method call on a unbound variable named</source>
          <target state="translated">このローカル変換は、Log4j2ロギングを使用してプログラムにロギング機能を追加します。という名前の結合されていない変数に対するすべてのメソッド呼び出しは</target>
        </trans-unit>
        <trans-unit id="5c21e31e0e213d1b747f0881d81cf15af0983e63" translate="yes" xml:space="preserve">
          <source>This local transform adds a logging ability to your program using LogBack logging. Every method call on a unbound variable named</source>
          <target state="translated">このローカル変換は、LogBack ロギングを使用してプログラムにロギング機能を追加します。という名前の結合されていない変数に対するすべてのメソッド呼び出しは</target>
        </trans-unit>
        <trans-unit id="f0a3244e657380e150930ad3c42321efd1a93ab0" translate="yes" xml:space="preserve">
          <source>This local transform adds a logging ability to your program using java.util.logging. Every method call on a unbound variable named</source>
          <target state="translated">このローカル変換は、java.util.loggingを使用してプログラムにロギング機能を追加します。という名前の結合されていない変数に対するすべてのメソッド呼び出しは</target>
        </trans-unit>
        <trans-unit id="9f16b0ae746e9cea59cf9a1537bd1d3eab7d8506" translate="yes" xml:space="preserve">
          <source>This map is for object serialization mainly. The idea is the final conversion of the Value objects are delayed until the last possible moment, i.e., just before injected into a bean.</source>
          <target state="translated">このマップは主にオブジェクトのシリアライズのためのものです。Valueオブジェクトの最終的な変換は、可能な限り最後の瞬間、すなわち、ビーンに注入される直前まで遅延されます。</target>
        </trans-unit>
        <trans-unit id="133261c522611d55bc1ac660860148968370dbb5" translate="yes" xml:space="preserve">
          <source>This maps only builds once you ask for a key for the first time. It is designed to not incur the overhead of creating a map unless needed.</source>
          <target state="translated">このマップは、最初に鍵を要求したときにのみビルドされます。必要でない限りマップ作成のオーバーヘッドが発生しないように設計されています。</target>
        </trans-unit>
        <trans-unit id="8a8f2d66e087d02e8f596d67c48d249055c88c63" translate="yes" xml:space="preserve">
          <source>This may be true even for values not contained in the range. Example: from = 1.5, to = 3, next() increments by 1 containsWithinBounds(2) == true contains(2) == false</source>
          <target state="translated">これは、範囲に含まれていない値に対しても真である可能性があります。例:from=1.5,to=3,next()は 1 つずつインクリメントします containsWithinBounds(2)==true contains(2)==false</target>
        </trans-unit>
        <trans-unit id="75f0bf4a66a79592bf20cb9599e2cee6c0cf02d5" translate="yes" xml:space="preserve">
          <source>This may not be available in future groovy.util.CliBuilder versions.</source>
          <target state="translated">これは将来のgroovy.util.CliBuilderのバージョンでは利用できないかもしれません。</target>
        </trans-unit>
        <trans-unit id="0bf475abb2d654e508f4a3ea6b60068d3049398d" translate="yes" xml:space="preserve">
          <source>This may not be available in future groovy.util.CliBuilder versions. Use groovy.cli.commons.CliBuilder if you need this feature.</source>
          <target state="translated">これは将来のgroovy.util.CliBuilderのバージョンでは利用できないかもしれません。この機能が必要な場合は、groovy.cli.commons.CliBuilderを使用してください。</target>
        </trans-unit>
        <trans-unit id="29237a4ce5bb61ce2deb69d6d749c4af551bfff9" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;executeBatch()&lt;/code&gt; will be called automatically after the &lt;code&gt;withBatch&lt;/code&gt; closure has finished but may be called explicitly if desired as well for more fine-grained partitioning of the batch.</source>
          <target state="translated">つまり、 &lt;code&gt;executeBatch()&lt;/code&gt; は、 &lt;code&gt;withBatch&lt;/code&gt; クロージャが終了した後に自動的に呼び出されますが、必要に応じて、バッチをよりきめ細かく分割するために明示的に呼び出すこともできます。</target>
        </trans-unit>
        <trans-unit id="8281417fefc279cbb9a25f17712e4ba86882d29f" translate="yes" xml:space="preserve">
          <source>This method adds a SyntaxException to the error collector.</source>
          <target state="translated">このメソッドは、エラーコレクタに SyntaxException を追加します。</target>
        </trans-unit>
        <trans-unit id="0973d91b058fb6569284667e2f673bb040878f3c" translate="yes" xml:space="preserve">
          <source>This method adds a SyntaxException to the error collector. The exception should specify the line and column number of the error. This method should be reserved for real errors in the syntax of the SourceUnit. If your error is not in syntax, and is a semantic error, or more general error, then use addException or use the error collector directly by retrieving it with getErrorCollector().</source>
          <target state="translated">このメソッドは、エラーコレクタに SyntaxException を追加します。この例外は、エラーの行番号とカラム番号を指定しなければなりません。このメソッドは、SourceUnit の構文の中にある本当のエラーのために予約されているはずです。エラーがシンタックスではなく、意味的なエラー、あるいはもっと一般的なエラーである場合は addException を使用するか、あるいは getErrorCollector()でエラーコレクタを直接取得して使用します。</target>
        </trans-unit>
        <trans-unit id="d41389a9f429a0e723f818e52d3c8405048d8434" translate="yes" xml:space="preserve">
          <source>This method adds an exception to the error collector.</source>
          <target state="translated">このメソッドは、エラーコレクタに例外を追加します。</target>
        </trans-unit>
        <trans-unit id="ad248a00756ca0b2876764f3cadf2058210b535e" translate="yes" xml:space="preserve">
          <source>This method adds an exception to the error collector. The Exception most likely has no line number attached to it. For this reason you should use this method sparingly. Prefer using addError for syntax errors or add an error to the &lt;a href=&quot;errorcollector&quot;&gt;ErrorCollector&lt;/a&gt; directly by retrieving it with getErrorCollector().</source>
          <target state="translated">このメソッドは、エラーコレクターに例外を追加します。ほとんどの場合、例外には行番号が付加されていません。このため、この方法は慎重に使用する必要があります。構文エラーにはaddErrorを使用するか、getErrorCollector（）でエラーを取得して&lt;a href=&quot;errorcollector&quot;&gt;ErrorCollectorに&lt;/a&gt;直接エラーを追加することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="26b9b9919b102efb75bc0c62d72758785b908443" translate="yes" xml:space="preserve">
          <source>This method builds a single ModelMBeanAttribute info from a given meta data map object.</source>
          <target state="translated">このメソッドは、指定されたメタデータマップオブジェクトから単一のModelMBeanAttribute情報を構築します。</target>
        </trans-unit>
        <trans-unit id="7ef8522c2c1425ca76a2dd9e7f7424d35413e383" translate="yes" xml:space="preserve">
          <source>This method calls the JsonLexer to parser the output of the builder, so this may not be an optimal method to call, and should be used mainly for debugging purpose for a human-readable output of the JSON content.</source>
          <target state="translated">このメソッドは、ビルダーの出力をパーサするために JsonLexer を呼び出しますので、これを呼び出すのは最適な方法ではないかもしれませんし、主に人間が読める JSON コンテンツを出力するためのデバッグ目的で使用するべきです。</target>
        </trans-unit>
        <trans-unit id="573fa6ce3c9bb7134c818285958a90ae1c94d15a" translate="yes" xml:space="preserve">
          <source>This method can be used to ensure that no threaded created by a reference manager will be active.</source>
          <target state="translated">このメソッドを使用すると、参照マネージャによって作成されたスレッドがアクティブにならないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="1267ce3e9e0625435626c7617e6d61f20f27e4e8" translate="yes" xml:space="preserve">
          <source>This method can be used to ensure that no threaded created by a reference manager will be active. This is useful if the Groovy runtime itself is loaded through a class loader which should be disposed off. Without calling this method and if a threaded reference manager is active the class loader cannot be unloaded! Per default no threaded manager will be used.</source>
          <target state="translated">このメソッドを使用することで、リファレンスマネージャによって作成されたスレッドがアクティブにならないようにすることができます。これは、Groovyランタイム自体が廃棄されるべきクラスローダーを通してロードされている場合に便利です。このメソッドを呼び出さず、スレッド化された参照マネージャがアクティブな場合、クラスローダーをアンロードすることはできません!デフォルトでは、スレッド化されたマネージャはありません。デフォルトでは、スレッド化されたマネージャは使用されません。</target>
        </trans-unit>
        <trans-unit id="736cd8a3422bc2feffa8beea26a3ea358d3a8479" translate="yes" xml:space="preserve">
          <source>This method can return &lt;code&gt;null&lt;/code&gt; if the &lt;code&gt;Class&lt;/code&gt; is no longer reachable through any strong or soft references. A non-null return value indicates that this &lt;code&gt;ClassInfo&lt;/code&gt; is valid.</source>
          <target state="translated">強い参照またはソフト参照を介して &lt;code&gt;Class&lt;/code&gt; 到達できなくなった場合、このメソッドは &lt;code&gt;null&lt;/code&gt; を返す可能性があります。null以外の戻り値は、この &lt;code&gt;ClassInfo&lt;/code&gt; が有効であることを示します。</target>
        </trans-unit>
        <trans-unit id="1756cd8d9775e9730b98c4c1627c9b5e632ec24f" translate="yes" xml:space="preserve">
          <source>This method does not check the elements to verify they contain non-null reference values.</source>
          <target state="translated">このメソッドは、要素が非 null 参照値を含むことを確認するために要素をチェックしません。</target>
        </trans-unit>
        <trans-unit id="465f96fa4d41f78b2ce5fda3f4227272109aa863" translate="yes" xml:space="preserve">
          <source>This method doesn't do a full validation of the resulting QName. In particular, it doesn't check that the resulting namespace URI is a legal URI (per RFC 2396 and RFC 2732), nor that the resulting local part is a legal NCName per the XML Namespaces specification.</source>
          <target state="translated">このメソッドは、結果の QName の完全な検証を行いません。特に、結果の名前空間 URI が (RFC 2396 および RFC 2732 に基づく)正規の URI であるかどうか、また、結果のローカル部分が XML Namespaces 仕様に基づく正規の NCName であるかどうかをチェックしません。</target>
        </trans-unit>
        <trans-unit id="52e513008c99e7d305fccff13849c1a1c80774aa" translate="yes" xml:space="preserve">
          <source>This method exists to be binary compatible with 1.7 - 1.8.6 compiled code.</source>
          <target state="translated">このメソッドは、1.7~1.8.6のコンパイル済みコードとバイナリ互換性があるように存在します。</target>
        </trans-unit>
        <trans-unit id="c641e7c52a070377f45e131e44d063d090fa6d00" translate="yes" xml:space="preserve">
          <source>This method extracts ModelMBeanConstructorInfo from provided meta map.</source>
          <target state="translated">このメソッドは、提供されたメタマップから ModelMBeanConstructorInfo を抽出します。</target>
        </trans-unit>
        <trans-unit id="34c2983f225d2e36614f43dbb936a7baf6ddf732" translate="yes" xml:space="preserve">
          <source>This method extracts ModelMBeanConstructorInfo from provided meta map. It also iterates over any parameters and builds the necessary MBeanParameterInfo array.</source>
          <target state="translated">このメソッドは、提供されたメタマップから ModelMBeanConstructorInfo を抽出します。また、任意のパラメータを反復処理し、必要な MBeanParameterInfo 配列を構築します。</target>
        </trans-unit>
        <trans-unit id="150789d2ce17bb14a2771276abea7c787a906d8f" translate="yes" xml:space="preserve">
          <source>This method extracts an array of MBeanConstructorInfo from a list of meta maps.</source>
          <target state="translated">このメソッドは、メタマップのリストから MBeanConstructorInfo の配列を抽出します。</target>
        </trans-unit>
        <trans-unit id="60a3e8f2070dce89ae81b802d499b2bd30f90563" translate="yes" xml:space="preserve">
          <source>This method extracts an array of MBeanOperationInfo from a list of meta maps.</source>
          <target state="translated">このメソッドは、メタマップのリストから MBeanOperationInfo の配列を抽出します。</target>
        </trans-unit>
        <trans-unit id="263fa2d4242a10d1bba7914ee9c3b6eaba971c49" translate="yes" xml:space="preserve">
          <source>This method is &quot;safe&quot; in that it will always return a value and never throw an exception</source>
          <target state="translated">このメソッドは常に値を返し、例外が発生しないという点で「安全」です。</target>
        </trans-unit>
        <trans-unit id="6f930ab10785ce3649f57bd225433f23ebd52975" translate="yes" xml:space="preserve">
          <source>This method is a default implementation for the invoke method given in InvocationHandler.</source>
          <target state="translated">このメソッドは、InvocationHandler で与えられた invoke メソッドのデフォルトの実装です。</target>
        </trans-unit>
        <trans-unit id="181a7ec346ddcc5f94d1cf5c7bd4f8177dda29ec" translate="yes" xml:space="preserve">
          <source>This method is a default implementation for the invoke method given in InvocationHandler. Any call to a method with a declaring class that is not Object, excluding toString() and default methods is redirected to invokeCustom.</source>
          <target state="translated">このメソッドは、InvocationHandler で与えられた invoke メソッドのデフォルトの実装です。toString()およびデフォルト・メソッドを除く、Object ではない宣言クラスを持つメソッドへの呼び出しはすべて invokeCustom にリダイレクトされます。</target>
        </trans-unit>
        <trans-unit id="0243bed2cf01409831d3e3bb5e0becbccc0e7f22" translate="yes" xml:space="preserve">
          <source>This method is called by he handle to realize the bean constructor with property map.</source>
          <target state="translated">このメソッドは,プロパティマップを用いてBeanコンストラクタを実現するために,ハンドルから呼び出されます.</target>
        </trans-unit>
        <trans-unit id="32f82b3d67ea451eb2c3571e5b0255127a98cff1" translate="yes" xml:space="preserve">
          <source>This method is called by the ++ operator for enums.</source>
          <target state="translated">このメソッドは、列挙型の場合は++演算子で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="1c4289e3c70251c89708316752c7fc742b1a3b57" translate="yes" xml:space="preserve">
          <source>This method is called by the ++ operator for enums. It will invoke Groovy's default next behaviour for enums do not have their own next method.</source>
          <target state="translated">このメソッドは、列挙型の++演算子によって呼び出されます。これは、enumsが独自のnextメソッドを持たない場合のGroovyのデフォルトのnextの振る舞いを呼び出します。</target>
        </trans-unit>
        <trans-unit id="457141bbf0ee6f1da111f0f8db21015e1177879a" translate="yes" xml:space="preserve">
          <source>This method is called by the -- operator for enums.</source>
          <target state="translated">このメソッドは enums の --演算子によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="80cf9ab5395bfa1c37797650a89d31d82b67f5fb" translate="yes" xml:space="preserve">
          <source>This method is called by the -- operator for enums. It will invoke Groovy's default previous behaviour for enums that do not have their own previous method.</source>
          <target state="translated">このメソッドは、列挙型の --演算子によって呼び出されます。これは、独自の前のメソッドを持たない列挙型の列挙型に対して、Groovyのデフォルトの前の振る舞いを呼び出します。</target>
        </trans-unit>
        <trans-unit id="1d7f17602988167c7174cc4303d3eb837ccaa4f4" translate="yes" xml:space="preserve">
          <source>This method is called by the handle to realize the bean constructor with property map.</source>
          <target state="translated">このメソッドは,ハンドルから呼び出され,プロパティマップを用いてBeanコンストラクタを実現します.</target>
        </trans-unit>
        <trans-unit id="3250ef3629af744acf4f1c9198cc633e9a922e7c" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker before throwing an &quot;ambiguous method&quot; error, giving the chance to the extension to select the method properly.</source>
          <target state="translated">このメソッドは、&quot;あいまいなメソッド &quot;エラーを投げる前にタイプチェッカーによって呼び出され、拡張機能が適切にメソッドを選択する機会を与えます。</target>
        </trans-unit>
        <trans-unit id="bf23fd2465394a74d715d408a8f25c8bce28f2b6" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker before throwing an &quot;ambiguous method&quot; error, giving the chance to the extension to select the method properly. This means that when this method is called, the &quot;nodes&quot; parameter contains at least two methods. If the returned list still contains at least two methods, then the type checker will throw an ambiguous method call error. If the returned method contains 1 element, then the type checker will not throw any error. It is invalid to return an empty list.</source>
          <target state="translated">このメソッドは、&quot;ambiguous method&quot; エラーがスローされる前に型チェッカーによって呼び出され、拡張機能がメソッドを適切に選択する機会を与えます。これは、このメソッドが呼び出されたときに、&quot;nodes&quot; パラメータに少なくとも 2 つのメソッドが含まれていることを意味します。返されたリストに少なくとも2つのメソッドが含まれている場合、型チェッカーは曖昧なメソッド呼び出しエラーをスローします。返されたメソッドに1つの要素が含まれている場合、型チェッカーはエラーをスローしません。空のリストを返すことは無効です。</target>
        </trans-unit>
        <trans-unit id="5bd058a5f1dad9fd10cd41da813b584b34292dcf" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a method call cannot be resolved.</source>
          <target state="translated">このメソッドは、メソッドの呼び出しが解決できない場合に、型チェッカーによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="d1635a0a9cf4ddc4f991b78c462cd28f64e95f41" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a method call cannot be resolved. Extensions may override this method to handle missing methods and prevent the type checker from throwing an error.</source>
          <target state="translated">このメソッドは、メソッドの呼び出しが解決できない場合に型チェッカーによって呼び出されます。拡張機能はこのメソッドをオーバーライドして、見つからないメソッドを処理し、型チェッカーがエラーを出さないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="5d562c165b33158604a8d7b6404c28720d2074f3" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a property expression cannot be resolved (for example, when a property doesn't exist).</source>
          <target state="translated">このメソッドは、プロパティ式が解決できない場合(プロパティが存在しない場合など)、型チェッカーによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="132aa2a69d68d1893ec79f63a47c8d6c72a91536" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a property expression cannot be resolved (for example, when a property doesn't exist). It gives the extension a chance to resolve it.</source>
          <target state="translated">このメソッドは、プロパティ式を解決できない場合 (プロパティが存在しない場合など)、型チェッカーによって呼び出されます。これは、拡張機能に解決する機会を与えます。</target>
        </trans-unit>
        <trans-unit id="af1e5a5ee4210f5472ccdfef7a053239430f1f37" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a variable expression cannot be resolved.</source>
          <target state="translated">このメソッドは、変数式が解決できない場合に、型チェッカーによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="76c7e2b17c02ed11975ad5a1246ebf8e0384df5b" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a variable expression cannot be resolved. It gives the extension a chance to resolve it for the type checker.</source>
          <target state="translated">このメソッドは、変数式を解決できない場合に型チェッカーによって呼び出されます。これは、拡張機能に型チェッカーのために変数式を解決する機会を与えます。</target>
        </trans-unit>
        <trans-unit id="24c509ff50700509e7072e5bf1d5cfe4ccd9c387" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when an assignment is not allowed by the type checker.</source>
          <target state="translated">このメソッドは、型チェッカーによって代入が許可されていない場合に、型チェッカーによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="788e0b6b33909d27195a8757233c0e6432f5e5eb" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when an assignment is not allowed by the type checker. Extensions may override this method to allow such assignments where the type checker normally disallows them.</source>
          <target state="translated">このメソッドは、型チェッカーによって代入が許可されていない場合に、型チェッカーによって呼び出されます。拡張機能はこのメソッドをオーバーライドして、型チェッカーが通常は許可しないような代入を許可することができます。</target>
        </trans-unit>
        <trans-unit id="dae2966d00451172c913ae2ad39d7fd262e4b659" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when an attribute expression cannot be resolved (for example, when an attribute doesn't exist).</source>
          <target state="translated">このメソッドは、属性式が解決できない場合(属性が存在しない場合など)、型チェッカーによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="f407dcbe206c19d0fc48753b7163e649e8b6df6d" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when an attribute expression cannot be resolved (for example, when an attribute doesn't exist). It gives the extension a chance to resolve it.</source>
          <target state="translated">このメソッドは、属性式を解決できない場合 (例えば、属性が存在しない場合)に型チェッカーによって呼び出されます。これは、拡張機能に解決する機会を与えます。</target>
        </trans-unit>
        <trans-unit id="f24dfabfb34102b6f318752ab09222b7e3d270a2" translate="yes" xml:space="preserve">
          <source>This method is called for all Methods not defined on Object.</source>
          <target state="translated">このメソッドは、Object に定義されていないすべてのメソッドに対して呼び出されます。</target>
        </trans-unit>
        <trans-unit id="c123aa6bd463d76f74528853afb07e35dfbd4af8" translate="yes" xml:space="preserve">
          <source>This method is called for all Methods not defined on Object. The delegate should be called here.</source>
          <target state="translated">このメソッドは、Objectに定義されていないすべてのMethodに対して呼び出されます。ここではデリゲートを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="e263d0484bccb2058d38f8bf9eacd404f003eccc" translate="yes" xml:space="preserve">
          <source>This method is called once the template engine is initialized, providing the resolver with the template engine configuration and its template class loader.</source>
          <target state="translated">このメソッドは、テンプレートエンジンが初期化されると呼び出され、リゾルバにテンプレートエンジンの設定とそのテンプレートクラスローダーを提供します。</target>
        </trans-unit>
        <trans-unit id="0d82b61e044bfa56fbd2265af61cf2acecdd51e0" translate="yes" xml:space="preserve">
          <source>This method is called when an exception occurs while invoking this method.</source>
          <target state="translated">このメソッドは、このメソッドの呼び出し中に例外が発生した場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="3383d8f9c80df52829fdca412aee2ffee5f93888" translate="yes" xml:space="preserve">
          <source>This method is for convenience.</source>
          <target state="translated">この方法は便宜上のものです。</target>
        </trans-unit>
        <trans-unit id="9242bd1cd2be2a765050fb4ef347893057fa4da1" translate="yes" xml:space="preserve">
          <source>This method is for convenience. It allows to get around the need for defining dump ctors in subclasses. See unit tests for details.</source>
          <target state="translated">このメソッドは便宜上のものです。これにより、サブクラスでダンプクトールを定義する必要性を回避することができます。詳細はユニットテストを参照してください。</target>
        </trans-unit>
        <trans-unit id="c7d7725943eccf3c92e66a0d48dd502528f6b703" translate="yes" xml:space="preserve">
          <source>This method is meant to be overridden by custom GroovyDoc implementations, using custom class templates.</source>
          <target state="translated">このメソッドは、カスタムクラスのテンプレートを使用して、カスタムGroovyDocの実装によってオーバーライドされることを意図しています。</target>
        </trans-unit>
        <trans-unit id="8e09772b977dedc07d07d96cc2d72542f64ca1c5" translate="yes" xml:space="preserve">
          <source>This method is meant to be overridden by custom GroovyDoc implementations, using custom doc templates.</source>
          <target state="translated">このメソッドは、カスタムのdocテンプレートを使用して、カスタムのGroovyDoc実装によってオーバーライドされることを意図しています。</target>
        </trans-unit>
        <trans-unit id="e3f94c56bab43f0b3780ed88b92cbab7aa06914d" translate="yes" xml:space="preserve">
          <source>This method is meant to be overridden by custom GroovyDoc implementations, using custom package templates.</source>
          <target state="translated">このメソッドは、カスタムパッケージテンプレートを使用したカスタムGroovyDoc実装によってオーバーライドされることを意図しています。</target>
        </trans-unit>
        <trans-unit id="be3f5aaf4fe5b29a387b1c08f22380405a4b43e6" translate="yes" xml:space="preserve">
          <source>This method is not in use anymore.</source>
          <target state="translated">この方法はもう使われていません。</target>
        </trans-unit>
        <trans-unit id="d479a6f7032861e095021709f96d24a323c7ce9f" translate="yes" xml:space="preserve">
          <source>This method is not in use anymore. Use &lt;a href=&quot;groovyc#makeCompileUnit(groovy.lang.GroovyClassLoader)&quot;&gt;Groovyc.makeCompileUnit&lt;/a&gt; instead.</source>
          <target state="translated">このメソッドはもう使用されていません。代わりに&lt;a href=&quot;groovyc#makeCompileUnit(groovy.lang.GroovyClassLoader)&quot;&gt;Groovyc.makeCompileUnit&lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="8df7d11b3e43da5003d64921acb230c01052ce02" translate="yes" xml:space="preserve">
          <source>This method is responsible for instantiating a node and configure its properties.</source>
          <target state="translated">このメソッドは、ノードのインスタンス化とプロパティの設定を行います。</target>
        </trans-unit>
        <trans-unit id="2553db016825bd58a6c41d37b4ac7d9fdb343726" translate="yes" xml:space="preserve">
          <source>This method is responsible for performing type inference on closure argument types whenever code like this is found: &lt;code&gt;foo.collect { it.toUpperCase() }&lt;/code&gt;.</source>
          <target state="translated">このメソッドは、 &lt;code&gt;foo.collect { it.toUpperCase() }&lt;/code&gt; ようなコードが見つかるたびに、クロージャ引数型に対して型推論を実行する役割を果たします。</target>
        </trans-unit>
        <trans-unit id="96aa2c86a54f44a86c05cf0e9b642e0ff2c34049" translate="yes" xml:space="preserve">
          <source>This method is responsible for performing type inference on closure argument types whenever code like this is found: &lt;code&gt;foo.collect { it.toUpperCase() }&lt;/code&gt;. In this case, the type checker tries to find if the &lt;code&gt;collect&lt;/code&gt; method has its &lt;a href=&quot;../../../../../groovy/lang/closure&quot;&gt;Closure&lt;/a&gt; argument annotated with &lt;a href=&quot;../../../../../groovy/transform/stc/closureparams&quot;&gt;ClosureParams&lt;/a&gt;. If yes, then additional type inference can be performed and the type of &lt;code&gt;it&lt;/code&gt; may be inferred.</source>
          <target state="translated">このメソッドは、 &lt;code&gt;foo.collect { it.toUpperCase() }&lt;/code&gt; ようなコードが見つかるたびに、クロージャ引数型に対して型推論を実行する役割を果たします。この場合、型チェッカーは、 &lt;code&gt;collect&lt;/code&gt; メソッドに&lt;a href=&quot;../../../../../groovy/transform/stc/closureparams&quot;&gt;ClosureParams&lt;/a&gt;アノテーションが付けられた&lt;a href=&quot;../../../../../groovy/lang/closure&quot;&gt;Closure&lt;/a&gt;引数があるかどうかを見つけようとします。yesの場合は、追加型推論を行うことが可能との種類 &lt;code&gt;it&lt;/code&gt; 推論することができます。</target>
        </trans-unit>
        <trans-unit id="39e70e7519f9c69520febf8336038092afe788f5" translate="yes" xml:space="preserve">
          <source>This method is similar to &lt;a href=&quot;#propX(org.codehaus.groovy.ast.expr.Expression,%20org.codehaus.groovy.ast.expr.Expression)&quot;&gt;propX(Expression, Expression)&lt;/a&gt; but will make sure that if the property being accessed is defined inside the classnode provided as a parameter, then a getter call is generated instead of a field access.</source>
          <target state="translated">このメソッドは&lt;a href=&quot;#propX(org.codehaus.groovy.ast.expr.Expression,%20org.codehaus.groovy.ast.expr.Expression)&quot;&gt;propX（Expression、Expression）に&lt;/a&gt;似ていますが、アクセスされるプロパティがパラメーターとして提供されるクラスノード内で定義されている場合、フィールドアクセスの代わりにgetter呼び出しが生成されるようにします。</target>
        </trans-unit>
        <trans-unit id="5af1f84f364b43bda693a94d6efdcb175387d500" translate="yes" xml:space="preserve">
          <source>This method is used to pull all the new methods out of the local thread context with a particular name.</source>
          <target state="translated">このメソッドは、特定の名前を持つローカルスレッドコンテキストからすべての新しいメソッドを引き出すために使用されます。</target>
        </trans-unit>
        <trans-unit id="debc8862f9ee94379022acc734d3d04be7a4a835" translate="yes" xml:space="preserve">
          <source>This method looks up a simple (weak) hash map for an existing template object that matches the source URL. If there is no cache entry, a new one is created by the underlying template engine. This new instance is put to the cache for consecutive calls.</source>
          <target state="translated">このメソッドは、ソースURLに一致する既存のテンプレートオブジェクトの単純な(弱い)ハッシュマップを検索します。キャッシュエントリがない場合、基礎となるテンプレートエンジンによって新しいものが作成されます。この新しいインスタンスは、連続した呼び出しのためにキャッシュに置かれます。</target>
        </trans-unit>
        <trans-unit id="50f405bf763411bbbae4b569b75520c8c6ab7da2" translate="yes" xml:space="preserve">
          <source>This method looks up a simple (weak) hash map for an existing template object that matches the source file. If the source file didn't change in length and its last modified stamp hasn't changed compared to a precompiled template object, this template is used. Otherwise, there is no or an invalid template object cache entry, a new one is created by the underlying template engine. This new instance is put to the cache for consecutive calls.</source>
          <target state="translated">このメソッドは、ソースファイルにマッチする既存のテンプレートオブジェクトの単純な(弱い)ハッシュマップを検索します。ソースファイルの長さが変更されておらず、最終的に修正されたスタンプがコンパイル済みのテンプレートオブジェクトと比較して変更されていない場合、このテンプレートが使用されます。そうでない場合は、テンプレートオブジェクトのキャッシュエントリが存在しないか、または無効なテンプレートオブジェクトのキャッシュエントリがある場合は、基礎となるテンプレートエンジンによって新しいものが作成されます。この新しいインスタンスは、連続した呼び出しのためにキャッシュに置かれます。</target>
        </trans-unit>
        <trans-unit id="70b580668132556ed8e21d6f55d11fdd505e1db6" translate="yes" xml:space="preserve">
          <source>This method may be used by a caller in class C to check whether to enable access to a member of declaring class D successfully if Java8#checkCanSetAccessible(java.lang.reflect.AccessibleObject, java.lang.Class) returns true and any of the following hold:</source>
          <target state="translated">このメソッドは、Java8#checkCanSetAccessible(java.lang.reflect.AccessibleObject,java.lang.Class)がtrueを返し、以下のいずれかがホールドされた場合に、宣言クラスDのメンバへのアクセスを正常に有効にするかどうかをチェックするために、クラスCの呼び出し元によって使用されることがあります。</target>
        </trans-unit>
        <trans-unit id="403c2e4b9a79e63110b8121635756398ae996fda" translate="yes" xml:space="preserve">
          <source>This method returns the left hand side of the declaration cast to the TupleExpression type.</source>
          <target state="translated">このメソッドは、TupleExpression 型にキャストされた宣言の左側を返します。</target>
        </trans-unit>
        <trans-unit id="3eeba1201f99a5e2e68118e5c0e2cd8aa46418b3" translate="yes" xml:space="preserve">
          <source>This method returns the left hand side of the declaration cast to the TupleExpression type. This is an unsafe method to call. In a single assignment statement, the left hand side will be a VariableExpression and a ClassCastException will occur. If you invoke this method then be sure to invoke isMultipleAssignmentDeclaration() first to check that it is safe to do so. If that method returns true then this method is safe to call.</source>
          <target state="translated">このメソッドは、TupleExpression 型にキャストされた宣言の左側を返します。このメソッドを呼び出すことは安全ではありません。単一の代入文では、左側がVariableExpressionになり、ClassCastExceptionが発生します。このメソッドを呼び出す場合は、必ず最初に isMultipleAssignmentDeclaration()を呼び出して安全であることを確認してください。そのメソッドが真を返す場合は、このメソッドを呼び出しても安全です。</target>
        </trans-unit>
        <trans-unit id="781dddff54ea389bba98f4620fb6ffb4990bacbc" translate="yes" xml:space="preserve">
          <source>This method returns the left hand side of the declaration cast to the VariableExpression type.</source>
          <target state="translated">このメソッドは、VariableExpression型にキャストされた宣言の左側を返します。</target>
        </trans-unit>
        <trans-unit id="6d0cf4b5f8e84212c7ef85c55fbf13a8f51d14d1" translate="yes" xml:space="preserve">
          <source>This method returns the left hand side of the declaration cast to the VariableExpression type. This is an unsafe method to call. In a multiple assignment statement, the left hand side will be a TupleExpression and a ClassCastException will occur. If you invoke this method then be sure to invoke isMultipleAssignmentDeclaration() first to check that it is safe to do so. If that method returns true then this method is safe to call.</source>
          <target state="translated">このメソッドは、VariableExpression 型にキャストされた宣言の左側を返します。このメソッドを呼び出すことは安全ではありません。複数の代入文では、左側が TupleExpression になり、ClassCastException が発生します。このメソッドを呼び出す場合は、必ず最初に isMultipleAssignmentDeclaration()を呼び出して安全であることを確認してください。そのメソッドが真を返す場合は、このメソッドを呼び出しても安全です。</target>
        </trans-unit>
        <trans-unit id="557432b29293b21b623d72897910f098d1d9b99f" translate="yes" xml:space="preserve">
          <source>This method returns the list of methods named against the supplied parameter that are defined on the specified receiver, but it will also add &quot;non existing&quot; methods that will be generated afterwards by the compiler, for example if a method is using default values and that the specified class node isn't compiled yet.</source>
          <target state="translated">このメソッドは、指定されたパラメータに対して指定されたメソッドのリストを返しますが、例えば、メソッドがデフォルト値を使用していて、指定されたクラスノードがまだコンパイルされていない場合など、コンパイラによって後から生成される &quot;既存ではない&quot; メソッドも追加します。</target>
        </trans-unit>
        <trans-unit id="7c021d108112247d1976e0f0916701f3b8b31579" translate="yes" xml:space="preserve">
          <source>This method returns the method name as String if it is no dynamic calculated method name, but a constant.</source>
          <target state="translated">このメソッドは、動的に計算されたメソッド名ではなく定数の場合、メソッド名をStringで返します。</target>
        </trans-unit>
        <trans-unit id="ea5673ca5049872b33d116e64a53321be9dfe401" translate="yes" xml:space="preserve">
          <source>This method satisfies the general contract of the &lt;code&gt;Object.equals&lt;/code&gt; method.</source>
          <target state="translated">このメソッドは、 &lt;code&gt;Object.equals&lt;/code&gt; メソッドの一般的なコントラクトを満たします。</target>
        </trans-unit>
        <trans-unit id="e6de05f9ed26a209b6ba119f444e9aeb1971f83b" translate="yes" xml:space="preserve">
          <source>This method sets the leftExpression for this BinaryExpression.</source>
          <target state="translated">このメソッドは、この BinaryExpression の leftExpression を設定します。</target>
        </trans-unit>
        <trans-unit id="9538691d379a9f29ae41a5c0329eeba449cfee5a" translate="yes" xml:space="preserve">
          <source>This method sets the leftExpression for this BinaryExpression. The parameter must be either a VariableExpression or a TupleExpression with one or more elements.</source>
          <target state="translated">このメソッドは、この BinaryExpression の leftExpression を設定します。パラメータは、1 つ以上の要素を持つ VariableExpression または TupleExpression のいずれかでなければなりません。</target>
        </trans-unit>
        <trans-unit id="cabac7eca3eafa23e66e3fc5b9e599e6f515924d" translate="yes" xml:space="preserve">
          <source>This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; array. See the class Javadoc for more details.</source>
          <target state="translated">このメソッドは、 &lt;code&gt;params&lt;/code&gt; 配列にそのようなパラメーターを指定することにより、名前付きおよび名前付き序数パラメーターをサポートします。詳細については、クラスJavadocを参照してください。</target>
        </trans-unit>
        <trans-unit id="5ac687259610806fa3ccf67d52b8a0cdcf309f5f" translate="yes" xml:space="preserve">
          <source>This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; list. Here is an example:</source>
          <target state="translated">このメソッドは、 &lt;code&gt;params&lt;/code&gt; リストにそのようなパラメーターを指定することにより、名前付きおよび名前付きの順序パラメーターをサポートします。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="08f6b6d6cce9316b59fc041647b88bdcb3661eb8" translate="yes" xml:space="preserve">
          <source>This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; list. See the class Javadoc for more details.</source>
          <target state="translated">このメソッドは、 &lt;code&gt;params&lt;/code&gt; リストにそのようなパラメーターを指定することにより、名前付きおよび名前付きの順序パラメーターをサポートします。詳細については、クラスJavadocを参照してください。</target>
        </trans-unit>
        <trans-unit id="35c38527fe587a9d1b961b352a1036dd0d02b5a0" translate="yes" xml:space="preserve">
          <source>This method supports named and named ordinal parameters. See the class Javadoc for more details.</source>
          <target state="translated">このメソッドは、名前付き順序パラメータと名前付き順序パラメータをサポートしています。詳細は Javadoc クラスを参照してください。</target>
        </trans-unit>
        <trans-unit id="a1cb160878d23efb8494710e1845624e733ba117" translate="yes" xml:space="preserve">
          <source>This method takes source code, compiles it, then reverses it back to source.</source>
          <target state="translated">このメソッドは、ソースコードを取得してコンパイルし、ソースに戻します。</target>
        </trans-unit>
        <trans-unit id="1802525bd308357b0932ba02bb3c41457d24c77a" translate="yes" xml:space="preserve">
          <source>This method tells you if this declaration is a multiple assignment declaration, which has the form &quot;def (x, y) = ...&quot; in Groovy.</source>
          <target state="translated">このメソッドは、この宣言がGroovyの「def (x,y)=...」という形式の多重代入宣言であるかどうかを教えてくれます。</target>
        </trans-unit>
        <trans-unit id="647f4610cd39ef87d4f0b710da06531ff2a5d253" translate="yes" xml:space="preserve">
          <source>This method tells you if this declaration is a multiple assignment declaration, which has the form &quot;def (x, y) = ...&quot; in Groovy. If this method returns true, then the left hand side is an ArgumentListExpression. Do not call &quot;getVariableExpression()&quot; on this object if this method returns true, instead use &quot;getLeftExpression()&quot;.</source>
          <target state="translated">このメソッドは、この宣言が複数代入宣言であるかどうかを教えてくれます。&quot;def (x,y)=....&quot;という形をしたGroovyの宣言です。このメソッドがtrueを返した場合、左側がArgumentListExpressionになります。このメソッドが真を返す場合は、このオブジェクトの &quot;getVariableExpression()&quot; を呼び出さず、代わりに &quot;getLeftExpression()&quot; を使用してください。</target>
        </trans-unit>
        <trans-unit id="03ceb4930438c953107282fc0e25906885994308" translate="yes" xml:space="preserve">
          <source>This method tokenizes a string by space characters, but ignores spaces in quoted parts,that are parts in '' or &quot;&quot;.</source>
          <target state="translated">このメソッドは、文字列をスペース文字でトークン化しますが、引用符で囲まれた部分のスペースは無視されます。</target>
        </trans-unit>
        <trans-unit id="25594fed498b016c91d8453a3caab76c908e2263" translate="yes" xml:space="preserve">
          <source>This method tokenizes a string by space characters, but ignores spaces in quoted parts,that are parts in '' or &quot;&quot;. The method does allows the usage of &quot;&quot; in '' and '' in &quot;&quot;. The space character between tokens is not returned.</source>
          <target state="translated">このメソッドは、文字列をスペース文字でトークン化しますが、引用符で囲まれた部分のスペースは無視します。このメソッドは '' 内の &quot;&quot; と '' 内の '' を使用することができます。トークン間のスペース文字は返されません。</target>
        </trans-unit>
        <trans-unit id="b2a84c08a545e26a0cfa5751f177172834124990" translate="yes" xml:space="preserve">
          <source>This methods creates a list of all methods with this name of the current class and of all super classes</source>
          <target state="translated">このメソッドは、現在のクラスとすべてのスーパークラスのこの名前を持つすべてのメソッドのリストを作成します。</target>
        </trans-unit>
        <trans-unit id="d2b2f984e596021625b1464da65d3078af780eae" translate="yes" xml:space="preserve">
          <source>This methods returns a list of all methods of the given name defined in the current class</source>
          <target state="translated">このメソッドは、現在のクラスで定義されている指定された名前のすべてのメソッドのリストを返します。</target>
        </trans-unit>
        <trans-unit id="45509752471fda490b1c2f1641894ee63c1ba53e" translate="yes" xml:space="preserve">
          <source>This methods returns the same array as used in the constructor. Changing the values will result in changes of the GString. It is not recommended to do so.</source>
          <target state="translated">このメソッドは、コンストラクタで使用したものと同じ配列を返します。値を変更するとGStringの変更になります。そのようなことをすることは推奨されていません。</target>
        </trans-unit>
        <trans-unit id="b66768732e0971c70f8284792c2afe59afe722c7" translate="yes" xml:space="preserve">
          <source>This modifies the original instance and returns it, it does not clone</source>
          <target state="translated">これは元のインスタンスを変更してそれを返します。</target>
        </trans-unit>
        <trans-unit id="d03be5ef16854ca34754ab795102a0c1c0f386c3" translate="yes" xml:space="preserve">
          <source>This object is a GUI for looking at the AST that Groovy generates. Usage: java groovy.console.ui.AstBrowser [filename] where [filename] is an existing Groovy script.</source>
          <target state="translated">このオブジェクトは、Groovyが生成するASTを見るためのGUIです。Usage:java groovy.console.ui.AstBrowser [filename]ここで、[filename]は既存のGroovyスクリプトです。</target>
        </trans-unit>
        <trans-unit id="3e97fa1c7af0c729d57b97541a44507ce0cc0d67" translate="yes" xml:space="preserve">
          <source>This object is a GUI for looking at the AST that Groovy generates. Usage: java groovy.inspect.swingui.AstBrowser [filename] where [filename] is an existing Groovy script.</source>
          <target state="translated">このオブジェクトは、Groovyが生成するASTを見るためのGUIです。使用法:java groovy.inspect.swingui.AstBrowser [filename]ここで、[filename]は既存のGroovyスクリプトです。</target>
        </trans-unit>
        <trans-unit id="e2ffc04181a72b4f0f1c3e416c94b05a7ff37bfe" translate="yes" xml:space="preserve">
          <source>This object represents a Groovy script</source>
          <target state="translated">このオブジェクトは、Groovy スクリプトを表します。</target>
        </trans-unit>
        <trans-unit id="a3a6a41f25ea556ddea2ab91cb5c7b51b70dd65b" translate="yes" xml:space="preserve">
          <source>This only leaves the 'out' argument unbound. The only method on the &lt;a href=&quot;../lang/writable&quot;&gt;writable&lt;/a&gt; interface is &lt;a href=&quot;../lang/writable#writeTo&quot;&gt;writeTo(Writer out)&lt;/a&gt; so groovy rules about casting a closure to a one-method-interface apply and the above works. I.e. we return the now one argument closure as the Writable which can be serialized to System.out, a file, etc according to the Writable interface contract.</source>
          <target state="translated">これにより、「out」引数がバインドされないままになります。&lt;a href=&quot;../lang/writable&quot;&gt;書き込み可能な&lt;/a&gt;インターフェイスの唯一のメソッドは&lt;a href=&quot;../lang/writable#writeTo&quot;&gt;writeTo（Writer out）である&lt;/a&gt;ため、1つのメソッドインターフェイスにクロージャをキャストすることに関するグルーヴィーなルールが適用され、上記が機能します。つまり、Writableインターフェイスコントラクトに従ってSystem.out、ファイルなどにシリアル化できるWritableとして、現在1つの引数クロージャを返します。</target>
        </trans-unit>
        <trans-unit id="3860a813e268f2ea6fc72207bdceca72d569484a" translate="yes" xml:space="preserve">
          <source>This pattern can therefore be used to avoid explicit casts everywhere you need to call a method that you know is defined in the class that will implement the trait but normally don't have access to, which is often the case where a trait needs to be applied on a class provided by a third-party library.</source>
          <target state="translated">そのため、このパターンを使用することで、形質を実装するクラスで定義されていることはわかっていても、通常はアクセスできないメソッドを呼び出す必要がある場合には、明示的なキャストを回避することができます。</target>
        </trans-unit>
        <trans-unit id="ace59be916b50b31486861d73ed18eaca30ec5fa" translate="yes" xml:space="preserve">
          <source>This property allows customizing the program name displayed in the synopsis when &lt;code&gt;cli.usage()&lt;/code&gt; is called.</source>
          <target state="translated">このプロパティを使用すると、 &lt;code&gt;cli.usage()&lt;/code&gt; が呼び出されたときに概要に表示されるプログラム名をカスタマイズできます。</target>
        </trans-unit>
        <trans-unit id="51e8331273416e517eaeaf7fa7a23b0549036735" translate="yes" xml:space="preserve">
          <source>This property allows customizing the program name displayed in the synopsis when &lt;code&gt;cli.usage()&lt;/code&gt; is called. Ignored if the &lt;a href=&quot;#usage&quot;&gt;usage&lt;/a&gt; property is set.</source>
          <target state="translated">このプロパティを使用すると、 &lt;code&gt;cli.usage()&lt;/code&gt; が呼び出されたときに概要に表示されるプログラム名をカスタマイズできます。&lt;a href=&quot;#usage&quot;&gt;使用法&lt;/a&gt;プロパティが設定されている場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="8e7c100040c65811e98b4b5e3b269e9270590f58" translate="yes" xml:space="preserve">
          <source>This property controls whether to include the destination classes directory in the classpath given to the compiler.</source>
          <target state="translated">このプロパティは、コンパイラに与えられたクラスパスに目的のクラス・ディレクトリを含めるかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="7d2d8961f859455e3fb30c095ca4f0b27f60c5a9" translate="yes" xml:space="preserve">
          <source>This property controls whether to include the destination classes directory in the classpath given to the compiler. The default value is &quot;true&quot;.</source>
          <target state="translated">このプロパティは、コンパイラに与えられたクラスパスにコピー先のクラス・ディレクトリを含めるかどうかを制御します。デフォルト値は &quot;true &quot;です。</target>
        </trans-unit>
        <trans-unit id="f9f8e158e1fb916ac4a14cb9fc36f54eb916b032" translate="yes" xml:space="preserve">
          <source>This queue is backed by a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentLinkedQueue.html&quot;&gt;ConcurrentLinkedQueue&lt;/a&gt; and is thread safe. The iterator will only return non-null values (reachable) and is based on the &quot;weakly consistent&quot; iterator of the underlying &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentLinkedQueue.html&quot;&gt;ConcurrentLinkedQueue&lt;/a&gt;.</source>
          <target state="translated">このキューは&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentLinkedQueue.html&quot;&gt;ConcurrentLinkedQueue&lt;/a&gt;によってサポートされており、スレッドセーフです。イテレータはnull以外の値（到達可能）のみを返し、基になる&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentLinkedQueue.html&quot;&gt;ConcurrentLinkedQueueの&lt;/a&gt;「弱く一貫性のある」イテレータに基づいています。</target>
        </trans-unit>
        <trans-unit id="c0554c74e1813aa666f0f951e0bf2132582a22d5" translate="yes" xml:space="preserve">
          <source>This registry makes use of the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html&quot;&gt;ServiceLoader&lt;/a&gt; facility. The preferred method for registering new &lt;a href=&quot;groovyrunner&quot;&gt;GroovyRunner&lt;/a&gt; providers is to place them in a provider-configuration file in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;. The preferred method for accessing the registered runners is by making use of the &lt;code&gt;Iterable&lt;/code&gt; interface using an enhanced for-loop.</source>
          <target state="translated">このレジストリは、&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html&quot;&gt;ServiceLoader&lt;/a&gt;機能を利用します。新しい&lt;a href=&quot;groovyrunner&quot;&gt;GroovyRunner&lt;/a&gt;プロバイダーを登録するための推奨される方法は、リソースディレクトリ &lt;code&gt;META-INF/services&lt;/code&gt; のプロバイダー構成ファイルにそれらを配置することです。登録されたランナーにアクセスするための推奨される方法は、拡張されたforループを使用して &lt;code&gt;Iterable&lt;/code&gt; インターフェースを利用することです。</target>
        </trans-unit>
        <trans-unit id="8a509478dc010fd7ae4333771f3db41a8b51de80" translate="yes" xml:space="preserve">
          <source>This results in an effective change in the default value, which each @Grab can still override</source>
          <target state="translated">この結果、デフォルト値が有効に変更され、各 @Grab はまだオーバーライドすることができます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
