<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="ocaml">
    <body>
      <group id="ocaml">
        <trans-unit id="8b5246ec3fd3ea63c509be27737c36d3be01173e" translate="yes" xml:space="preserve">
          <source>Load in the debugger the indicated .cmo or .cma object file. The file is loaded in an environment consisting only of the OCaml standard library plus the definitions provided by object files previously loaded using load_printer. If this file depends on other object files not yet loaded, the debugger automatically loads them if it is able to find them in the search path. The loaded file does not have direct access to the modules of the program being debugged.</source>
          <target state="translated">指定された .cmo または .cma オブジェクトファイルをデバッガにロードします。このファイルは、OCaml 標準ライブラリと、load_printer を使用して以前にロードされたオブジェクトファイルによって提供された定義のみで構成される環境でロードされます。このファイルがまだロードされていない他のオブジェクトファイルに依存している場合、デバッガは、検索パスでそれらを見つけることができれば、自動的にそれらをロードします。ロードされたファイルは、デバッグされているプログラムのモジュールに直接アクセスすることはできません。</target>
        </trans-unit>
        <trans-unit id="9554426e849ebccce273355d09330acd0af5f810" translate="yes" xml:space="preserve">
          <source>Load information from file, which has been produced by ocamldoc -dump. Several -load options can be given.</source>
          <target state="translated">ocamldoc -dump で生成されたファイルから情報をロードします。いくつかの-loadオプションを与えることができます。</target>
        </trans-unit>
        <trans-unit id="1468bdc0578724ddc204f4a8076fd367c4f00ada" translate="yes" xml:space="preserve">
          <source>Load the given file instead of the default initialization file. The default file is .ocamlinit in the current directory if it exists, otherwise XDG_CONFIG_HOME/ocaml/init.ml or .ocamlinit in the user&amp;rsquo;s home directory.</source>
          <target state="translated">デフォルトの初期化ファイルの代わりに、指定されたファイルをロードします。デフォルトのファイルは、現在のディレクトリにある場合は.ocamlinitです。存在しない場合は、ユーザーのホームディレクトリにあるXDG_CONFIG_HOME / ocaml /init.mlまたは.ocamlinitです。</target>
        </trans-unit>
        <trans-unit id="22c136cf2e9c1518388c865d582646bebe003932" translate="yes" xml:space="preserve">
          <source>Load the program and execute it until the given time. Useful when you already know approximately at what time the problem appears. Also useful to set breakpoints on function values that have not been computed at time 0 (see section &lt;a href=&quot;#s%3Abreakpoints&quot;&gt;17.5&lt;/a&gt;).</source>
          <target state="translated">プログラムをロードし、指定された時間まで実行します。問題が発生するおおよその時刻がすでにわかっている場合に便利です。時間0で計算されていない関数値にブレークポイントを設定する場合にも役立ちます（セクション&lt;a href=&quot;#s%3Abreakpoints&quot;&gt;17.5を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="3e63214a47f4377c1d66c127f747b02a52318db2" translate="yes" xml:space="preserve">
          <source>Load the program and stop on the first event.</source>
          <target state="translated">プログラムをロードし、最初のイベントで停止します。</target>
        </trans-unit>
        <trans-unit id="06d5cb576439af064f31b513f860fdcf129f485b" translate="yes" xml:space="preserve">
          <source>Loading codes</source>
          <target state="translated">コードの読み込み</target>
        </trans-unit>
        <trans-unit id="f75d20b246e4621320b31b1c098e452853a4ac67" translate="yes" xml:space="preserve">
          <source>Local opens are supported in class expressions since OCaml 4.06.</source>
          <target state="translated">OCaml 4.06 以降、クラス式でローカルオープンがサポートされるようになりました。</target>
        </trans-unit>
        <trans-unit id="570b10f925c51b325fdc93e2d97c8848252648e2" translate="yes" xml:space="preserve">
          <source>Local opens are supported in class types since OCaml 4.06.</source>
          <target state="translated">OCaml 4.06 以降、クラスタイプでローカルオープンがサポートされています。</target>
        </trans-unit>
        <trans-unit id="7a006a52c95463d27833642d291aafafbbe657d6" translate="yes" xml:space="preserve">
          <source>Local substitutions behave like destructive substitutions (with ... := ...) but instead of being applied to a whole signature after the fact, they are introduced during the specification of the signature, and will apply to all the items that follow.</source>
          <target state="translated">局所的な置換は、破壊的な置換(...:=....で)のように振る舞いますが、実際に署名全体に適用されるのではなく、署名の指定中に導入され、その後に続くすべての項目に適用されます。</target>
        </trans-unit>
        <trans-unit id="a3b9f4a56a716ca3242cf294551816b0edc61b5d" translate="yes" xml:space="preserve">
          <source>Lock a region for reading, and block if already locked</source>
          <target state="translated">リージョンを読み込み用にロックし、すでにロックされている場合はブロックする</target>
        </trans-unit>
        <trans-unit id="46f366a2b18c94da3f95550dd69540c8a030c1d1" translate="yes" xml:space="preserve">
          <source>Lock a region for reading, or fail if already locked</source>
          <target state="translated">リージョンを読み込み用にロックするか、既にロックされている場合は失敗する</target>
        </trans-unit>
        <trans-unit id="7b934b756e8fc53911807eb32d2b56437692262d" translate="yes" xml:space="preserve">
          <source>Lock a region for writing, and block if already locked</source>
          <target state="translated">書き込む領域をロックし、すでにロックされている場合はブロックする</target>
        </trans-unit>
        <trans-unit id="c93a16a3ed8e2fb19e43651da0d9564d29f64855" translate="yes" xml:space="preserve">
          <source>Lock a region for writing, or fail if already locked</source>
          <target state="translated">書込み用の領域をロックするか、すでにロックされている場合は失敗します。</target>
        </trans-unit>
        <trans-unit id="4c7af655541e99448e1ec9e27d57b823c87c4cdc" translate="yes" xml:space="preserve">
          <source>Lock the given mutex.</source>
          <target state="translated">指定されたミューテックスをロックします。</target>
        </trans-unit>
        <trans-unit id="ef84af5a92860b1f205389a08e46e19c1d0376bf" translate="yes" xml:space="preserve">
          <source>Lock the given mutex. Only one thread can have the mutex locked at any time. A thread that attempts to lock a mutex already locked by another thread will suspend until the other thread unlocks the mutex.</source>
          <target state="translated">指定されたミューテックスをロックします。1つのスレッドだけがいつでもミューテックスをロックすることができます。他のスレッドが既にロックしているミューテックスをロックしようとするスレッドは、他のスレッドがミューテックスのロックを解除するまでサスペンドします。</target>
        </trans-unit>
        <trans-unit id="d1d6079f6b5f44c82f4e240cfc0156faa4fc5b60" translate="yes" xml:space="preserve">
          <source>Locking</source>
          <target state="translated">Locking</target>
        </trans-unit>
        <trans-unit id="d744573647f56d06b5b86078a49e94460efb4548" translate="yes" xml:space="preserve">
          <source>Locks for mutual exclusion.</source>
          <target state="translated">相互排除のためのロック。</target>
        </trans-unit>
        <trans-unit id="2911f8b42aa989ed16139a00c9d592e0e4e835c2" translate="yes" xml:space="preserve">
          <source>Long_val(v) returns the long int encoded in value v.</source>
          <target state="translated">Long_val(v)は、値 v でエンコードされた長い int を返します。</target>
        </trans-unit>
        <trans-unit id="911e3c5ea58f72e14fe5b81b5acd435c6c333d4f" translate="yes" xml:space="preserve">
          <source>Low-level functions</source>
          <target state="translated">低レベル機能</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="c934410bd452bcb5e709691c6c967b3dbcd37b50" translate="yes" xml:space="preserve">
          <source>MD5 message digest.</source>
          <target state="translated">MD5メッセージのダイジェスト。</target>
        </trans-unit>
        <trans-unit id="c6426140160e26a1863b2e621495d7c29a1605e0" translate="yes" xml:space="preserve">
          <source>Make inlining decisions at the point of definition of a function rather than at the call site(s). This mirrors the behaviour of OCaml compilers not using Flambda. Compared to compilation using the new Flambda inlining heuristics (for example at -O2) it produces smaller .cmx files, shorter compilation times and code that probably runs rather slower. When using -Oclassic, only the following options described in this section are relevant: -inlining-report and -inline. If any other of the options described in this section are used, the behaviour is undefined and may cause an error in future versions of the compiler.</source>
          <target state="translated">呼び出しサイトではなく、関数の定義の時点でインライン化の決定を行います。これは、Flambdaを使用していないOCamlコンパイラの動作を反映しています。新しいFlambdaインライン化ヒューリスティックを使用してコンパイルする場合(例えば-O2で)と比較すると、.cmxファイルが小さくなり、コンパイル時間が短くなり、コードの実行速度が遅くなります。Oclassic を使用する場合、このセクションで説明されている以下のオプションのみが関係します:-inlining-report と -inline。このセクションで説明されている他のオプションが使用された場合、その動作は未定義であり、将来のバージョンのコンパイラでエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="be8c42ef87bb8b55a6444a52383572cda55e1591" translate="yes" xml:space="preserve">
          <source>Making a custom generator handle custom tags (see &lt;a href=&quot;#sss%3Aocamldoc-custom-tags&quot;&gt;16.2.5&lt;/a&gt;) is very simple.</source>
          <target state="translated">カスタムジェネレーターにカスタムタグ（&lt;a href=&quot;#sss%3Aocamldoc-custom-tags&quot;&gt;16.2.5を&lt;/a&gt;参照）を処理させるのは非常に簡単です。</target>
        </trans-unit>
        <trans-unit id="fee138b412931aab18dbc01608d4cef40bddbdba" translate="yes" xml:space="preserve">
          <source>Management of signals</source>
          <target state="translated">信号の管理</target>
        </trans-unit>
        <trans-unit id="e8766772088c50c0ea69ddcc9e68cc232fadded3" translate="yes" xml:space="preserve">
          <source>Manipulation of backtrace information</source>
          <target state="translated">バックトレース情報の操作</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="c43329032df3d96e24d72c385d12a422e571b619" translate="yes" xml:space="preserve">
          <source>Map CR to NL on input.</source>
          <target state="translated">入力時にCRをNLにマップします。</target>
        </trans-unit>
        <trans-unit id="62b1ed02cf5951695363e86b8efaae11f6285d79" translate="yes" xml:space="preserve">
          <source>Map NL to CR on input.</source>
          <target state="translated">入力時にNLをCRにマップします。</target>
        </trans-unit>
        <trans-unit id="face92f1c006ac531f226f881711266fcb0854d2" translate="yes" xml:space="preserve">
          <source>Map each element to a subsequence, then return each element of this sub-sequence in turn.</source>
          <target state="translated">各要素を部分系列にマッピングし、この部分系列の各要素を順番に返します。</target>
        </trans-unit>
        <trans-unit id="9d1e9a2774804659a435bcd137155a2fc9950a33" translate="yes" xml:space="preserve">
          <source>Map each element to a subsequence, then return each element of this sub-sequence in turn. This transformation is lazy, it only applies when the result is traversed.</source>
          <target state="translated">各要素を部分系列にマッピングし、この部分系列の各要素を順番に返します。この変換は遅延しており、結果がトラバースされたときにのみ適用されます。</target>
        </trans-unit>
        <trans-unit id="874e0cf467c242a8715d382d0113f4ffe8e8b9dc" translate="yes" xml:space="preserve">
          <source>Mapping files into memory</source>
          <target state="translated">ファイルをメモリにマッピング</target>
        </trans-unit>
        <trans-unit id="792fe4aaafb220da5ab17388e5844c93f1d95290" translate="yes" xml:space="preserve">
          <source>Margin</source>
          <target state="translated">Margin</target>
        </trans-unit>
        <trans-unit id="4e68d70db4cb0c9f7b47b7e8261347a139a40f40" translate="yes" xml:space="preserve">
          <source>Mark as fatal the warnings specified in the argument warning-list. The compiler will stop with an error when one of these warnings is emitted. The warning-list has the same meaning as for the -w option: a + sign (or an uppercase letter) marks the corresponding warnings as fatal, a - sign (or a lowercase letter) turns them back into non-fatal warnings, and a @ sign both enables and marks as fatal the corresponding warnings.</source>
          <target state="translated">引数 warning-list で指定された警告を致命的なものとしてマークします。これらの警告のいずれかが発せられると、コンパイラはエラーで停止します。warning-list は -w オプションと同じ意味を持ちます。+記号 (または大文字)は対応する警告を致命的なものとしてマークし、-記号 (または小文字)はそれらを致命的でない警告に戻します。</target>
        </trans-unit>
        <trans-unit id="9651ed6afe7f40f844d844247a351f306f618725" translate="yes" xml:space="preserve">
          <source>Mark parity errors.</source>
          <target state="translated">パリティエラーをマークします。</target>
        </trans-unit>
        <trans-unit id="9cdfbcba7d735bd862886d7bc92cdad6e808e063" translate="yes" xml:space="preserve">
          <source>Marshal</source>
          <target state="translated">Marshal</target>
        </trans-unit>
        <trans-unit id="facd64ea9fa3010a0e9705a9b4261b78f3ecb660" translate="yes" xml:space="preserve">
          <source>Marshaling of data structures.</source>
          <target state="translated">データ構造のマーシャリング。</target>
        </trans-unit>
        <trans-unit id="dad9eec833cc64e444f260559ec864ea918d9fe7" translate="yes" xml:space="preserve">
          <source>Match any single character belonging to the given character set. Valid character sets are: single character constants 'c'; ranges of characters 'c&lt;sub&gt;1&lt;/sub&gt;'-'c&lt;sub&gt;2&lt;/sub&gt;' (all characters between c&lt;sub&gt;1&lt;/sub&gt; and c&lt;sub&gt;2&lt;/sub&gt;, inclusive); and the union of two or more character sets, denoted by concatenation.</source>
          <target state="translated">指定された文字セットに属する任意の1文字に一致します。有効な文字セットは次のとおりです。単一文字定数 'c'; 文字「Cの範囲&lt;sub&gt;1&lt;/sub&gt; -'c ' &lt;sub&gt;2&lt;/sub&gt;（Cとの間の全ての文字' &lt;sub&gt;1&lt;/sub&gt;及びC &lt;sub&gt;2&lt;/sub&gt;、含みます）。連結で示される2つ以上の文字セットの和集合。</target>
        </trans-unit>
        <trans-unit id="9ff233319bdf1bc966fa073a62017cfcf28311ec" translate="yes" xml:space="preserve">
          <source>Match any single character not belonging to the given character set.</source>
          <target state="translated">与えられた文字セットに属さない単一の文字にマッチします。</target>
        </trans-unit>
        <trans-unit id="f7ad8e08bddf311e1561c76915c116ddac2c9064" translate="yes" xml:space="preserve">
          <source>Match the end of the lexer input.</source>
          <target state="translated">入力されたレキサーの末尾にマッチします。</target>
        </trans-unit>
        <trans-unit id="624939b9202c5d64193aa77b5ed57d3e219078ff" translate="yes" xml:space="preserve">
          <source>Match the same strings as &lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#regexp&quot;&gt;正規表現&lt;/a&gt;と同じ文字列に一致します。</target>
        </trans-unit>
        <trans-unit id="6d643dda70d07a9bff87dc40b34a36dca7c58f10" translate="yes" xml:space="preserve">
          <source>Matching &lt;em&gt;any&lt;/em&gt; amount of whitespace, a space in the format string also matches no amount of whitespace at all; hence, the call &lt;code&gt;bscanf&amp;nbsp;ib&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;Price&amp;nbsp;=&amp;nbsp;%d&amp;nbsp;$&quot;&amp;nbsp;(fun&amp;nbsp;p&amp;nbsp;-&amp;gt;&amp;nbsp;p)&lt;/code&gt; succeeds and returns &lt;code&gt;1&lt;/code&gt; when reading an input with various whitespace in it, such as &lt;code&gt;Price&amp;nbsp;=&amp;nbsp;1&amp;nbsp;$&lt;/code&gt;, &lt;code&gt;Price&amp;nbsp;&amp;nbsp;=&amp;nbsp;&amp;nbsp;1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$&lt;/code&gt;, or even &lt;code&gt;Price=1$&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;任意の&lt;/em&gt;量の空白に一致&lt;em&gt;する&lt;/em&gt;と、フォーマット文字列内のスペースもまったく一致しません。したがって、 &lt;code&gt;bscanf&amp;nbsp;ib&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;Price&amp;nbsp;=&amp;nbsp;%d&amp;nbsp;$&quot;&amp;nbsp;(fun&amp;nbsp;p&amp;nbsp;-&amp;gt;&amp;nbsp;p)&lt;/code&gt; の呼び出しは成功し、 &lt;code&gt;Price&amp;nbsp;=&amp;nbsp;1&amp;nbsp;$&lt;/code&gt; 、 &lt;code&gt;Price&amp;nbsp;&amp;nbsp;=&amp;nbsp;&amp;nbsp;1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$&lt;/code&gt; 、さらには &lt;code&gt;Price=1$&lt;/code&gt; など、さまざまな空白を含む入力を読み取るときに &lt;code&gt;1&lt;/code&gt; を返します。1 $。</target>
        </trans-unit>
        <trans-unit id="c9ba4e48291cd2cf0b811e179ed03624617f0f18" translate="yes" xml:space="preserve">
          <source>Matching proceeds as described before, except that if the value matches some pattern &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; which has a guard cond&lt;sub&gt;i&lt;/sub&gt;, then the expression cond&lt;sub&gt;i&lt;/sub&gt; is evaluated (in an environment enriched by the bindings performed during matching). If cond&lt;sub&gt;i&lt;/sub&gt; evaluates to true, then &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; is evaluated and its value returned as the result of the matching, as usual. But if cond&lt;sub&gt;i&lt;/sub&gt; evaluates to false, the matching is resumed against the patterns following &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;.</source>
          <target state="translated">マッチングは前述のように進行しますが、値がガード条件&lt;sub&gt;i&lt;/sub&gt;を持つパターン&lt;a href=&quot;patterns#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;と一致する場合、式cond &lt;sub&gt;i&lt;/sub&gt;が評価されます（マッチング中に実行されるバインディングによって強化された環境で）。cond &lt;sub&gt;i&lt;/sub&gt;がtrueと評価された場合、&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;が評価され、通常どおり、マッチングの結果としてその値が返されます。ただし、cond &lt;sub&gt;i&lt;/sub&gt;がfalseと評価された場合、&lt;a href=&quot;patterns#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;iに&lt;/sub&gt;続くパターンに対してマッチングが再開されます。&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="b4fe7526fed514734906dd56f0808fdf64d5c5e7" translate="yes" xml:space="preserve">
          <source>Material inside boxes nested deeper is printed as an ellipsis (more precisely as the text returned by &lt;a href=&quot;format#VALget_ellipsis_text&quot;&gt;&lt;code&gt;Format.get_ellipsis_text&lt;/code&gt;&lt;/a&gt;&lt;code&gt;()&lt;/code&gt;).</source>
          <target state="translated">より深くネストされたボックス内のマテリアルは、省略記号として出力されます（より正確には、&lt;a href=&quot;format#VALget_ellipsis_text&quot;&gt; &lt;code&gt;Format.get_ellipsis_text&lt;/code&gt; &lt;/a&gt; &lt;code&gt;()&lt;/code&gt; によって返されるテキストとして）。</target>
        </trans-unit>
        <trans-unit id="8c775e0b631e27aa872cba9538a7ad38db0e8382" translate="yes" xml:space="preserve">
          <source>Maximal number of bindings per bucket.</source>
          <target state="translated">バケットごとのバインディングの最大数。</target>
        </trans-unit>
        <trans-unit id="de4aecc225c29a9b00684b7a91e8d4a7c0c4fcf7" translate="yes" xml:space="preserve">
          <source>Maximum amount of out-of-heap memory for each custom value allocated in the minor heap. When a custom value is allocated on the minor heap and holds more than this many bytes, only this value is counted against &lt;code&gt;custom_minor_ratio&lt;/code&gt; and the rest is directly counted against &lt;code&gt;custom_major_ratio&lt;/code&gt;. Note: this only applies to values allocated with &lt;code&gt;caml_alloc_custom_mem&lt;/code&gt; (e.g. bigarrays). Default: 8192 bytes.</source>
          <target state="translated">マイナーヒープに割り当てられたカスタム値ごとのヒープ外メモリの最大量。カスタム値がマイナーヒープに割り当てられ、これより多くのバイトを保持している場合、この値のみが &lt;code&gt;custom_minor_ratio&lt;/code&gt; に対してカウントされ、残りは &lt;code&gt;custom_major_ratio&lt;/code&gt; に対して直接カウントされます。注：これは、 &lt;code&gt;caml_alloc_custom_mem&lt;/code&gt; で割り当てられた値（bigarrayなど）にのみ適用されます。デフォルト：8192バイト。</target>
        </trans-unit>
        <trans-unit id="3a4b693ac7f8f148df9e57169d08a10429066cdc" translate="yes" xml:space="preserve">
          <source>Maximum formatting depth</source>
          <target state="translated">書式化の最大深度</target>
        </trans-unit>
        <trans-unit id="43e8208d3223642a44e274b068fe9167dea74624" translate="yes" xml:space="preserve">
          <source>Maximum indentation limit</source>
          <target state="translated">最大インデント制限</target>
        </trans-unit>
        <trans-unit id="57d9251c94f60be5c0a454afa29832266764bb87" translate="yes" xml:space="preserve">
          <source>Maximum length of a floatarray.</source>
          <target state="translated">floatatarrayの最大長。</target>
        </trans-unit>
        <trans-unit id="0a82d8640ca6e8be934710976326d9e3d41c21e3" translate="yes" xml:space="preserve">
          <source>Maximum length of a floatarray. This is also the maximum length of a &lt;code&gt;float&amp;nbsp;array&lt;/code&gt; when OCaml is configured with &lt;code&gt;--enable-flat-float-array&lt;/code&gt;.</source>
          <target state="translated">floatarrayの最大長。これは、OCamlが &lt;code&gt;--enable-flat-float-array&lt;/code&gt; で構成されている場合の &lt;code&gt;float&amp;nbsp;array&lt;/code&gt; 最大長でもあります。</target>
        </trans-unit>
        <trans-unit id="75f830d8170e15a87cf9b64f314629724f342359" translate="yes" xml:space="preserve">
          <source>Maximum length of a normal array (i.e.</source>
          <target state="translated">通常の配列の最大長(すなわち</target>
        </trans-unit>
        <trans-unit id="9e07a269e552f76233aa4f04ad4c80b7015574f5" translate="yes" xml:space="preserve">
          <source>Maximum length of a normal array (i.e. any array whose elements are not of type &lt;code&gt;float&lt;/code&gt;). The maximum length of a &lt;code&gt;float&amp;nbsp;array&lt;/code&gt; is &lt;code&gt;max_floatarray_length&lt;/code&gt; if OCaml was configured with &lt;code&gt;--enable-flat-float-array&lt;/code&gt; and &lt;code&gt;max_array_length&lt;/code&gt; if configured with &lt;code&gt;--disable-flat-float-array&lt;/code&gt;.</source>
          <target state="translated">通常の配列（つまり、要素が &lt;code&gt;float&lt;/code&gt; 型ではない配列）の最大長。最大長 &lt;code&gt;float&amp;nbsp;array&lt;/code&gt; ある &lt;code&gt;max_floatarray_length&lt;/code&gt; のOCamlを用いて構成されている場合 &lt;code&gt;--enable-flat-float-array&lt;/code&gt; と &lt;code&gt;max_array_length&lt;/code&gt; で構成されている場合 &lt;code&gt;--disable-flat-float-array&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4de1705370b8992fe2eac57ca9e570d5b6fdbf4" translate="yes" xml:space="preserve">
          <source>Maximum length of an ephemeron, ie the maximum number of keys an ephemeron could contain</source>
          <target state="translated">エフェメロンの最大長、すなわち、エフェメロンが含むことができる最大の鍵の数。</target>
        </trans-unit>
        <trans-unit id="c8d2ea9cbf5aa25afab320da73d2cb8746b9c6ea" translate="yes" xml:space="preserve">
          <source>Maximum length of strings and byte sequences.</source>
          <target state="translated">文字列とバイト列の最大長。</target>
        </trans-unit>
        <trans-unit id="111798f4ee1440503f39a9ca5e215b57ed0edd0d" translate="yes" xml:space="preserve">
          <source>Maximum read wait (in 0.1s units).</source>
          <target state="translated">最大読み込み待ち時間(0.1秒単位)。</target>
        </trans-unit>
        <trans-unit id="421dda9f026ffda8002440f413ce7dac542281cc" translate="yes" xml:space="preserve">
          <source>Maximum size reached by the major heap, in words.</source>
          <target state="translated">言葉で言うと、メジャーヒープが到達した最大サイズ。</target>
        </trans-unit>
        <trans-unit id="0867fadb65552799103f1e2c59b6996e3bca055e" translate="yes" xml:space="preserve">
          <source>Maybe the most frequent examples of non-genericity derive from the interactions between polymorphic types and mutation. A simple example appears when typing the following expression</source>
          <target state="translated">おそらく、非遺伝性の最も頻繁な例は、多型と突然変異の間の相互作用に由来しています。単純な例は、次の式を入力すると現れます。</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="58b588830d79aaa6edd4ede9d25c9ec5e38ae494" translate="yes" xml:space="preserve">
          <source>Mechanisms are available to control event collection at runtime.</source>
          <target state="translated">実行時にイベント収集を制御するためのメカニズムが用意されています。</target>
        </trans-unit>
        <trans-unit id="d5747d498a7435bd2232d8a279011040168fdf61" translate="yes" xml:space="preserve">
          <source>Memory management control and statistics; finalised values.</source>
          <target state="translated">メモリ管理の制御と統計、最終的な値。</target>
        </trans-unit>
        <trans-unit id="e1d5fee5c92276c92276efd0e44640e46a30110a" translate="yes" xml:space="preserve">
          <source>Memory mapping of a file as a Bigarray.</source>
          <target state="translated">ファイルのメモリマッピングをBIGRAYにしました。</target>
        </trans-unit>
        <trans-unit id="d453e5fd051d62abb4952e6dce9f9a70c5c2e73f" translate="yes" xml:space="preserve">
          <source>Memory mapping of a file as a Bigarray. &lt;code&gt;map_file&amp;nbsp;fd&amp;nbsp;kind&amp;nbsp;layout&amp;nbsp;shared&amp;nbsp;dims&lt;/code&gt; returns a Bigarray of kind &lt;code&gt;kind&lt;/code&gt;, layout &lt;code&gt;layout&lt;/code&gt;, and dimensions as specified in &lt;code&gt;dims&lt;/code&gt;. The data contained in this Bigarray are the contents of the file referred to by the file descriptor &lt;code&gt;fd&lt;/code&gt; (as opened previously with &lt;code&gt;Unix.openfile&lt;/code&gt;, for example). The optional &lt;code&gt;pos&lt;/code&gt; parameter is the byte offset in the file of the data being mapped; it defaults to 0 (map from the beginning of the file).</source>
          <target state="translated">Bigarrayとしてのファイルのメモリマッピング。 &lt;code&gt;map_file&amp;nbsp;fd&amp;nbsp;kind&amp;nbsp;layout&amp;nbsp;shared&amp;nbsp;dims&lt;/code&gt; 戻る種類のBigarray &lt;code&gt;kind&lt;/code&gt; 、レイアウトの &lt;code&gt;layout&lt;/code&gt; で指定され、かつ寸法 &lt;code&gt;dims&lt;/code&gt; 。このBigarrayに含まれるデータは、ファイル記述子 &lt;code&gt;fd&lt;/code&gt; によって参照されるファイルの内容です（たとえば、以前に &lt;code&gt;Unix.openfile&lt;/code&gt; で開かれたもの）。オプションの &lt;code&gt;pos&lt;/code&gt; パラメーターは、マップされるデータのファイル内のバイトオフセットです。デフォルトは0（ファイルの先頭からマップ）です。</target>
        </trans-unit>
        <trans-unit id="880d9fe17162cdc8dbe19eec2a7dab314180b634" translate="yes" xml:space="preserve">
          <source>Merge two lists: Assuming that &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; are sorted according to the comparison function &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;merge&amp;nbsp;cmp&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; will return a sorted list containing all the elements of &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt;.</source>
          <target state="translated">2つのリストをマージする： &lt;code&gt;l1&lt;/code&gt; と &lt;code&gt;l2&lt;/code&gt; が比較関数 &lt;code&gt;cmp&lt;/code&gt; に従ってソートされていると仮定すると、 &lt;code&gt;merge&amp;nbsp;cmp&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; は、 &lt;code&gt;l1&lt;/code&gt; と &lt;code&gt;l2&lt;/code&gt; のすべての要素を含むソートされたリストを返します。</target>
        </trans-unit>
        <trans-unit id="f82c912801fa2f38788ef8f80f6481aca333a281" translate="yes" xml:space="preserve">
          <source>Merge two lists: Assuming that &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; are sorted according to the comparison function &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;merge&amp;nbsp;cmp&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; will return a sorted list containing all the elements of &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt;. If several elements compare equal, the elements of &lt;code&gt;l1&lt;/code&gt; will be before the elements of &lt;code&gt;l2&lt;/code&gt;. Not tail-recursive (sum of the lengths of the arguments).</source>
          <target state="translated">2つのリストをマージする： &lt;code&gt;l1&lt;/code&gt; と &lt;code&gt;l2&lt;/code&gt; が比較関数 &lt;code&gt;cmp&lt;/code&gt; に従ってソートされていると仮定すると、 &lt;code&gt;merge&amp;nbsp;cmp&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; は、 &lt;code&gt;l1&lt;/code&gt; と &lt;code&gt;l2&lt;/code&gt; のすべての要素を含むソートされたリストを返します。複数の要素が等しい場合、 &lt;code&gt;l1&lt;/code&gt; の要素は &lt;code&gt;l2&lt;/code&gt; の要素の前になります。末尾再帰ではありません（引数の長さの合計）。</target>
        </trans-unit>
        <trans-unit id="6bf991e7854ed942e57f7a8ae958526d710e4851" translate="yes" xml:space="preserve">
          <source>Message too long</source>
          <target state="translated">メッセージが長すぎる</target>
        </trans-unit>
        <trans-unit id="fe901f98d707d8893028273fbe15a247b6dc752f" translate="yes" xml:space="preserve">
          <source>Method calls to objects are not at present inlined by Flambda.</source>
          <target state="translated">オブジェクトへのメソッド呼び出しは、現在のところ Flambda ではインライン化されていません。</target>
        </trans-unit>
        <trans-unit id="725d48f23a2318240368857da2dd4a836394a9b1" translate="yes" xml:space="preserve">
          <source>Method overridden.</source>
          <target state="translated">メソッドはオーバーライドされます。</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="73d77f95747bb6c235ba5d9d8dd5594481b601b7" translate="yes" xml:space="preserve">
          <source>Methods may have an explicitly polymorphic type, allowing them to be used polymorphically in programs (even for the same object). The explicit declaration may be done in one of three ways: (1) by giving an explicit polymorphic type in the method definition, immediately after the method name, &lt;em&gt;i.e.&lt;/em&gt;method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;: {'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;}&lt;sup&gt;+&lt;/sup&gt;.&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;; (2) by a forward declaration of the explicit polymorphic type through a virtual method definition; (3) by importing such a declaration through inheritance and/or constraining the type of &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="translated">メソッドは明示的にポリモーフィックな型を持っている場合があり、プログラムで（同じオブジェクトに対しても）ポリモーフィックに使用できます。明示的な宣言は、次の3つの方法のいずれかで実行できます。（1）メソッド名の直後にメソッド定義で明示的なポリモーフィック型を指定する。&lt;em&gt;つまり、&lt;/em&gt; method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;：{' &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; } &lt;sup&gt;+&lt;/sup&gt;。&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; = &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; ; （2）仮想メソッド定義による明示的なポリモーフィック型の前方宣言による。 （3）継承を通じてそのような宣言をインポートすること、および/または&lt;em&gt;自己&lt;/em&gt;のタイプを制約することによって。</target>
        </trans-unit>
        <trans-unit id="977a75b1b527cafb43a310b768323025de5a89bf" translate="yes" xml:space="preserve">
          <source>Methods need not be declared previously, as shown by the example:</source>
          <target state="translated">メソッドは、例に示すように、事前に宣言する必要はありません。</target>
        </trans-unit>
        <trans-unit id="48a374e74161047aa235fbb3100763be5b812693" translate="yes" xml:space="preserve">
          <source>Middle mouse button</source>
          <target state="translated">マウスの中ボタン</target>
        </trans-unit>
        <trans-unit id="0d193e7dfe2ad2529b4896dcc5d46972be46e952" translate="yes" xml:space="preserve">
          <source>Minimum number of bytes to process for input operations</source>
          <target state="translated">入力操作のために処理する最小バイト数</target>
        </trans-unit>
        <trans-unit id="d481070b2cfb403e278c0dca62449244848cbded" translate="yes" xml:space="preserve">
          <source>Minimum number of bytes to process for output operations</source>
          <target state="translated">出力操作のために処理する最小バイト数</target>
        </trans-unit>
        <trans-unit id="d5be9f6d96fb9719bc05c3c57eba753a99104553" translate="yes" xml:space="preserve">
          <source>Minimum number of characters to read before the read request is satisfied.</source>
          <target state="translated">読み取り要求が満たされるまでに読み取る文字数の最小値。</target>
        </trans-unit>
        <trans-unit id="1858c250815195a7d6f8064ba7ae2ae308e2c946" translate="yes" xml:space="preserve">
          <source>Minor collection and major GC slice.</source>
          <target state="translated">マイナーコレクション、メジャーGCスライス。</target>
        </trans-unit>
        <trans-unit id="ba7f64b06da5b1e4fcb3453af263375fd663c205" translate="yes" xml:space="preserve">
          <source>Minutes 0..59</source>
          <target state="translated">分数 0...59</target>
        </trans-unit>
        <trans-unit id="314bb4fc83d55b365225efaa4fc333e95057e960" translate="yes" xml:space="preserve">
          <source>Miscellaneous functions</source>
          <target state="translated">その他の機能</target>
        </trans-unit>
        <trans-unit id="39b08ec421dc1322ebeee3c79275c01cc8b3d8fe" translate="yes" xml:space="preserve">
          <source>Missing cmx file.</source>
          <target state="translated">cmx ファイルがありません。</target>
        </trans-unit>
        <trans-unit id="d081333d4e9bb27d1f44459f14c2d45dd9f81b1c" translate="yes" xml:space="preserve">
          <source>Missing fields in a record pattern.</source>
          <target state="translated">レコードパターンにフィールドが存在しない。</target>
        </trans-unit>
        <trans-unit id="37f242d312b71edb3517a2032fd66710ec76680c" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;Format&lt;/code&gt; provides a complete set of &lt;code&gt;printf&lt;/code&gt; like functions for pretty-printing using format string specifications.</source>
          <target state="translated">Module &lt;code&gt;Format&lt;/code&gt; は、フォーマット文字列仕様を使用してプリティプリントするための &lt;code&gt;printf&lt;/code&gt; のような関数の完全なセットを提供します。</target>
        </trans-unit>
        <trans-unit id="bad989c3e6325882d6507e66e3602a4dd7dd1950" translate="yes" xml:space="preserve">
          <source>Module Arg</source>
          <target state="translated">モジュール Arg</target>
        </trans-unit>
        <trans-unit id="6abf3bb1d160573e61d46e6b5f81e5508ae82e88" translate="yes" xml:space="preserve">
          <source>Module Arg: parsing of command line arguments</source>
          <target state="translated">モジュール Arg:コマンドライン引数の解析</target>
        </trans-unit>
        <trans-unit id="a56fcb800d5771af9f080dd53abe44c449867565" translate="yes" xml:space="preserve">
          <source>Module Array</source>
          <target state="translated">モジュール配列</target>
        </trans-unit>
        <trans-unit id="dc2ddb4a440e52c266e257d745c23b9dadfa5b3d" translate="yes" xml:space="preserve">
          <source>Module Array: array operations</source>
          <target state="translated">モジュール配列:配列操作</target>
        </trans-unit>
        <trans-unit id="0d18ab309cc5cd2e46cd375092084b640f8135f4" translate="yes" xml:space="preserve">
          <source>Module ArrayLabels</source>
          <target state="translated">モジュール ArrayLabels</target>
        </trans-unit>
        <trans-unit id="cc6ff72196a05305dab9e2db994ea05cd60e104b" translate="yes" xml:space="preserve">
          <source>Module ArrayLabels: array operations (with labels)</source>
          <target state="translated">モジュール ArrayLabels:配列操作 (ラベル付き)</target>
        </trans-unit>
        <trans-unit id="f93c03acf357c6454b6e5285450c3f3f3f30bb2c" translate="yes" xml:space="preserve">
          <source>Module Ast_helper: helper functions for AST construction</source>
          <target state="translated">モジュール Ast_helper:AST構築のためのヘルパー関数</target>
        </trans-unit>
        <trans-unit id="4f633b64e1901b821e83c2d2917c9c7dfe7b2811" translate="yes" xml:space="preserve">
          <source>Module Ast_mapper: -ppx rewriter interface</source>
          <target state="translated">モジュール Ast_mapper:-ppx リライタインタフェース</target>
        </trans-unit>
        <trans-unit id="523d5c8f5c6bb7605890429c1f11b8c345bdf0a9" translate="yes" xml:space="preserve">
          <source>Module Asttypes: auxiliary types used by Parsetree</source>
          <target state="translated">モジュール Asttypes:Parsetree が使用する補助型</target>
        </trans-unit>
        <trans-unit id="cc643dfec1e07f16e63a2f5d40439c635b5a0da0" translate="yes" xml:space="preserve">
          <source>Module Bigarray</source>
          <target state="translated">モジュール ビッグアレイ</target>
        </trans-unit>
        <trans-unit id="8b457fad35d3c5733311bed4d1abc1928bb9ab28" translate="yes" xml:space="preserve">
          <source>Module Bigarray.Array0</source>
          <target state="translated">モジュール Bigarray.Array0</target>
        </trans-unit>
        <trans-unit id="0606447c86667b05a149e8ca96cc9d366dcdc45f" translate="yes" xml:space="preserve">
          <source>Module Bigarray.Array1</source>
          <target state="translated">モジュール Bigarray.Array1</target>
        </trans-unit>
        <trans-unit id="4e9d1f71e428cb53a57134b56fbd980b03c94e2c" translate="yes" xml:space="preserve">
          <source>Module Bigarray.Array2</source>
          <target state="translated">モジュール Bigarray.Array2</target>
        </trans-unit>
        <trans-unit id="27d48e9da9c33900ca44d6ecad351863f7bdaf5c" translate="yes" xml:space="preserve">
          <source>Module Bigarray.Array3</source>
          <target state="translated">モジュール Bigarray.Array3</target>
        </trans-unit>
        <trans-unit id="d4d26b36f6d58ffaea1f504565e46f4f60567d67" translate="yes" xml:space="preserve">
          <source>Module Bigarray.Genarray</source>
          <target state="translated">モジュールBigarray.Genarray</target>
        </trans-unit>
        <trans-unit id="f3762282f9caa555d54286fbb90a1e96b4c7c432" translate="yes" xml:space="preserve">
          <source>Module Bigarray: large, multi-dimensional, numerical arrays</source>
          <target state="translated">Bigarrayモジュール:大規模、多次元、数値配列</target>
        </trans-unit>
        <trans-unit id="8ecd3446e16a821dd5e1adff2cc82cb3a5130a89" translate="yes" xml:space="preserve">
          <source>Module Bool</source>
          <target state="translated">モジュールブール</target>
        </trans-unit>
        <trans-unit id="6c3e715d33fc29b958efa37ae69668a59a1706ff" translate="yes" xml:space="preserve">
          <source>Module Bool: boolean values</source>
          <target state="translated">モジュール Bool:boolean 値</target>
        </trans-unit>
        <trans-unit id="bddc2144c4c529dd8430235937580a143554e16c" translate="yes" xml:space="preserve">
          <source>Module Buffer</source>
          <target state="translated">モジュールバッファ</target>
        </trans-unit>
        <trans-unit id="43c2c38aaa41d7ed5d989a9cc184b3794181c9f7" translate="yes" xml:space="preserve">
          <source>Module Buffer: extensible buffers</source>
          <target state="translated">モジュールバッファ:拡張可能なバッファ</target>
        </trans-unit>
        <trans-unit id="72216591b14162977cfdb1c07def7995da644395" translate="yes" xml:space="preserve">
          <source>Module Bytes</source>
          <target state="translated">モジュールバイト数</target>
        </trans-unit>
        <trans-unit id="9c11fb2e91c5b00fbb9701a94d4424a17d04a49c" translate="yes" xml:space="preserve">
          <source>Module Bytes: byte sequences</source>
          <target state="translated">モジュールバイト:バイト列</target>
        </trans-unit>
        <trans-unit id="a85f0c0beeed2c6b8ad5ef29ccdfab63a21b9d52" translate="yes" xml:space="preserve">
          <source>Module BytesLabels</source>
          <target state="translated">モジュールバイトラベル</target>
        </trans-unit>
        <trans-unit id="f6cf68f0aad404a1f34cfeef9f8dc2bc6273085e" translate="yes" xml:space="preserve">
          <source>Module BytesLabels: byte sequences (with labels)</source>
          <target state="translated">モジュールBytesLabels:バイトシーケンス(ラベル付き)</target>
        </trans-unit>
        <trans-unit id="f99b095fc3c2466d64fae5588a546e997e1e5f16" translate="yes" xml:space="preserve">
          <source>Module Callback</source>
          <target state="translated">モジュールコールバック</target>
        </trans-unit>
        <trans-unit id="559eafeaa053a08996c324cd386ae9221fc17b97" translate="yes" xml:space="preserve">
          <source>Module Callback: registering OCaml values with the C runtime</source>
          <target state="translated">モジュールコールバック:OCamlの値をCランタイムに登録する</target>
        </trans-unit>
        <trans-unit id="d1355614e6d5e948afbb68e8c6119679a9a45955" translate="yes" xml:space="preserve">
          <source>Module CamlinternalFormat</source>
          <target state="translated">モジュール CamlinternalFormat</target>
        </trans-unit>
        <trans-unit id="b4d1db84ed7881aa6f76ae9db16693820f6725ae" translate="yes" xml:space="preserve">
          <source>Module CamlinternalFormatBasics</source>
          <target state="translated">モジュール CamlinternalFormatBasics</target>
        </trans-unit>
        <trans-unit id="93e7f0366b4e8dbdb121c6899472d74fc9e300ed" translate="yes" xml:space="preserve">
          <source>Module CamlinternalLazy</source>
          <target state="translated">モジュール CamlinternalLazy</target>
        </trans-unit>
        <trans-unit id="030e686bde89aa913f3dbe8fe375396e5953e5e6" translate="yes" xml:space="preserve">
          <source>Module CamlinternalMod</source>
          <target state="translated">モジュール CamlinternalMod</target>
        </trans-unit>
        <trans-unit id="dd6ad5c3473f26f582d139567a98ea0e9d3d3b4e" translate="yes" xml:space="preserve">
          <source>Module CamlinternalOO</source>
          <target state="translated">モジュール CamlinternalOO</target>
        </trans-unit>
        <trans-unit id="79e77ccf8fe8cad52d93078cb896ef207ae08837" translate="yes" xml:space="preserve">
          <source>Module Char</source>
          <target state="translated">モジュール チャート</target>
        </trans-unit>
        <trans-unit id="eb75d51c88cc6b02cf6aca6015384b8720d875a9" translate="yes" xml:space="preserve">
          <source>Module Char: character operations</source>
          <target state="translated">モジュール char:文字操作</target>
        </trans-unit>
        <trans-unit id="5548e02ff9068a8bd2671e455dd9adf27f571d77" translate="yes" xml:space="preserve">
          <source>Module Complex</source>
          <target state="translated">モジュール複合体</target>
        </trans-unit>
        <trans-unit id="142a8ecd6426e808bdec26ab206584b15b18b324" translate="yes" xml:space="preserve">
          <source>Module Complex: Complex numbers</source>
          <target state="translated">モジュールの複素数。複素数</target>
        </trans-unit>
        <trans-unit id="bf0d5f1ae3231eea0973a205c212df89a0b65712" translate="yes" xml:space="preserve">
          <source>Module Condition</source>
          <target state="translated">モジュール条件</target>
        </trans-unit>
        <trans-unit id="a6a62a2154dc372d92c88ec0dfbedc61b73cd367" translate="yes" xml:space="preserve">
          <source>Module Condition: condition variables to synchronize between threads</source>
          <target state="translated">モジュールの条件:スレッド間で同期するための条件変数</target>
        </trans-unit>
        <trans-unit id="c923312ef4200761b1302981bacdcb52bccc44f9" translate="yes" xml:space="preserve">
          <source>Module Digest</source>
          <target state="translated">モジュールダイジェスト</target>
        </trans-unit>
        <trans-unit id="8bbfa8ae15ecab1209610ac5a66a651f78875a78" translate="yes" xml:space="preserve">
          <source>Module Digest: MD5 message digest</source>
          <target state="translated">モジュールダイジェスト:MD5メッセージダイジェスト</target>
        </trans-unit>
        <trans-unit id="02c49caa12242dda259d7307d31dd98fda25b90d" translate="yes" xml:space="preserve">
          <source>Module Dynlink</source>
          <target state="translated">ダイナリンクモジュール</target>
        </trans-unit>
        <trans-unit id="17df668e4cee0361dd61ce759ea047d4ccf6ce2f" translate="yes" xml:space="preserve">
          <source>Module Dynlink: dynamic loading of bytecode object files</source>
          <target state="translated">Module Dynlink:バイトコードオブジェクトファイルの動的ロード</target>
        </trans-unit>
        <trans-unit id="9c62be44cefe5016fcac970fcb981646c02e96b6" translate="yes" xml:space="preserve">
          <source>Module Ephemeron</source>
          <target state="translated">モジュール エフェメロン</target>
        </trans-unit>
        <trans-unit id="306ceb414fe45593e76183fffc1c6e8063a97af7" translate="yes" xml:space="preserve">
          <source>Module Ephemeron.GenHashTable</source>
          <target state="translated">モジュール Ephemeron.GenHashTable</target>
        </trans-unit>
        <trans-unit id="3c0d413a4c6a68f4547228b7fbcd4303cea78dd7" translate="yes" xml:space="preserve">
          <source>Module Ephemeron.K1</source>
          <target state="translated">モジュール エフェメロン.K1</target>
        </trans-unit>
        <trans-unit id="cc37a3b6fff03344d782218dfc93f84de56f0454" translate="yes" xml:space="preserve">
          <source>Module Ephemeron.K2</source>
          <target state="translated">モジュール エフェメロン.K2</target>
        </trans-unit>
        <trans-unit id="4dbed2786938f2a0e76b0e83d9e7aee1f6ba1c21" translate="yes" xml:space="preserve">
          <source>Module Ephemeron.Kn</source>
          <target state="translated">モジュール Ephemeron.Kn</target>
        </trans-unit>
        <trans-unit id="9bc16c26307d248abe81e5774136cc291bdc2f67" translate="yes" xml:space="preserve">
          <source>Module Ephemeron: Ephemerons and weak hash table</source>
          <target state="translated">モジュール エフェメロン エフェメロンと弱いハッシュテーブル</target>
        </trans-unit>
        <trans-unit id="965c3d92c5cef899a73c03e9b00b354453a07c58" translate="yes" xml:space="preserve">
          <source>Module Event</source>
          <target state="translated">モジュールイベント</target>
        </trans-unit>
        <trans-unit id="f6dd977ad9cdd9e33bfa766d7ff4615d50d92bac" translate="yes" xml:space="preserve">
          <source>Module Event: first-class synchronous communication</source>
          <target state="translated">モジュールイベント:第一種同期通信</target>
        </trans-unit>
        <trans-unit id="95908861b116393327d9f6360c9aa8ce9f3fc3d9" translate="yes" xml:space="preserve">
          <source>Module Filename</source>
          <target state="translated">モジュールのファイル名</target>
        </trans-unit>
        <trans-unit id="2a2de638ce58f0d0a702b4d4f313c4f37216533f" translate="yes" xml:space="preserve">
          <source>Module Filename: operations on file names</source>
          <target state="translated">Module Filename:ファイル名の操作</target>
        </trans-unit>
        <trans-unit id="dbf4558ebef769a096f39fa6c0312334a381fec2" translate="yes" xml:space="preserve">
          <source>Module Float</source>
          <target state="translated">モジュールフロート</target>
        </trans-unit>
        <trans-unit id="c0ebb1cca64e0c8f91ce7a3e1f3ba4030ed3b8f4" translate="yes" xml:space="preserve">
          <source>Module Float.Array</source>
          <target state="translated">モジュール Float.Array</target>
        </trans-unit>
        <trans-unit id="445a0b0a1771a9581127d17829402c08430bebed" translate="yes" xml:space="preserve">
          <source>Module Float.ArrayLabels</source>
          <target state="translated">モジュール Float.ArrayLabels</target>
        </trans-unit>
        <trans-unit id="a3600f92b6696937343502269bc8090397c0e51e" translate="yes" xml:space="preserve">
          <source>Module Float: Floating-point numbers</source>
          <target state="translated">モジュールの Float。浮動小数点数</target>
        </trans-unit>
        <trans-unit id="f2cecfe8e0ae9b3a901adc050a10fa4ea0c7797d" translate="yes" xml:space="preserve">
          <source>Module Format</source>
          <target state="translated">モジュール形式</target>
        </trans-unit>
        <trans-unit id="12bb5435b16c5c8b6ab86cf0323be7dcc9f30566" translate="yes" xml:space="preserve">
          <source>Module Format: pretty printing</source>
          <target state="translated">モジュール形式:かなりの印刷</target>
        </trans-unit>
        <trans-unit id="acb444a56b618a584c9cdb2f01ce73257415d59a" translate="yes" xml:space="preserve">
          <source>Module Fun</source>
          <target state="translated">モジュールファン</target>
        </trans-unit>
        <trans-unit id="40b410ee83d227d662e6b02df5f6cd601cb1762f" translate="yes" xml:space="preserve">
          <source>Module Fun: function values</source>
          <target state="translated">モジュール ファン:関数値</target>
        </trans-unit>
        <trans-unit id="d07aebf1d4ebd5c2e42b08423a93172511323b0f" translate="yes" xml:space="preserve">
          <source>Module Gc</source>
          <target state="translated">モジュールGc</target>
        </trans-unit>
        <trans-unit id="ac86c6af7ac7bc4fc4841fea39b50ce532e9eae3" translate="yes" xml:space="preserve">
          <source>Module Gc.Memprof</source>
          <target state="translated">モジュール Gc.Memprof</target>
        </trans-unit>
        <trans-unit id="017db642bb8f1e27af62b289d7afc0311dfb9b9d" translate="yes" xml:space="preserve">
          <source>Module Gc: memory management control and statistics; finalized values</source>
          <target state="translated">モジュールGc:メモリ管理制御と統計;最終値</target>
        </trans-unit>
        <trans-unit id="13184731a834066fef8c861de2b8b904d78a2c40" translate="yes" xml:space="preserve">
          <source>Module Genlex</source>
          <target state="translated">モジュール Genlex</target>
        </trans-unit>
        <trans-unit id="4ee3df3538f22bd946cb81aed2d740d6af4e43d7" translate="yes" xml:space="preserve">
          <source>Module Genlex: a generic lexical analyzer</source>
          <target state="translated">モジュール Genlex:汎用語彙解析器</target>
        </trans-unit>
        <trans-unit id="6d8fffbaf37dc886f091f1fcec194d70a8a56139" translate="yes" xml:space="preserve">
          <source>Module Hashtbl</source>
          <target state="translated">モジュール Hashtbl</target>
        </trans-unit>
        <trans-unit id="45ea31d5ad955fa4490b30ef1a1270d2c6392bda" translate="yes" xml:space="preserve">
          <source>Module Hashtbl: hash tables and hash functions</source>
          <target state="translated">モジュール Hashtbl:ハッシュテーブルとハッシュ関数</target>
        </trans-unit>
        <trans-unit id="49f5fed72bf1186b3606fcd64d3620ad4b5e6d3f" translate="yes" xml:space="preserve">
          <source>Module Int</source>
          <target state="translated">モジュール内部</target>
        </trans-unit>
        <trans-unit id="acab9c65663172b6b3cf63cdb91db7c853666939" translate="yes" xml:space="preserve">
          <source>Module Int32</source>
          <target state="translated">モジュール Int32</target>
        </trans-unit>
        <trans-unit id="59af84ad710fb152c38038123bed434bcda5ee5d" translate="yes" xml:space="preserve">
          <source>Module Int32: 32-bit integers</source>
          <target state="translated">モジュール Int32:32ビット整数</target>
        </trans-unit>
        <trans-unit id="afb57e65a2c5001e2ebbf893ab00402f586e67a7" translate="yes" xml:space="preserve">
          <source>Module Int64</source>
          <target state="translated">モジュール Int64</target>
        </trans-unit>
        <trans-unit id="b5dcbf9b29416b9da9d5777bc0cbfff746fd3bff" translate="yes" xml:space="preserve">
          <source>Module Int64: 64-bit integers</source>
          <target state="translated">モジュール Int64:64 ビット整数</target>
        </trans-unit>
        <trans-unit id="c67951c6b0d56d43a8d0b9f4a75238e26b84e176" translate="yes" xml:space="preserve">
          <source>Module Int: integers</source>
          <target state="translated">モジュール Int:整数</target>
        </trans-unit>
        <trans-unit id="6cbdc748b0a834da10d99ca83f0f783ca0b5c0b5" translate="yes" xml:space="preserve">
          <source>Module Lazy</source>
          <target state="translated">モジュール 怠惰</target>
        </trans-unit>
        <trans-unit id="6ed3c69956723eb0ea9cccf3b3f808a1e740d7bd" translate="yes" xml:space="preserve">
          <source>Module Lazy: deferred computations</source>
          <target state="translated">Module Lazy:deferred computations</target>
        </trans-unit>
        <trans-unit id="9d9af75cdf4a76dd0ace806f7dd01595ce9a4e7f" translate="yes" xml:space="preserve">
          <source>Module Lexing</source>
          <target state="translated">モジュールレキシング</target>
        </trans-unit>
        <trans-unit id="cda606f5e00de0f84675796ae085f4bffba696d6" translate="yes" xml:space="preserve">
          <source>Module Lexing: the run-time library for lexers generated by ocamllex</source>
          <target state="translated">モジュールレキシング:ocamllex で生成されたレキサーのためのランタイムライブラリ</target>
        </trans-unit>
        <trans-unit id="0ba47168d0ea302d6485e2bceea2a3d5ea07497a" translate="yes" xml:space="preserve">
          <source>Module List</source>
          <target state="translated">モジュール一覧</target>
        </trans-unit>
        <trans-unit id="d95ac15be64ca43f1623a9f9232b997c5bf2c1d4" translate="yes" xml:space="preserve">
          <source>Module List: list operations</source>
          <target state="translated">モジュールリスト:リスト操作</target>
        </trans-unit>
        <trans-unit id="daeda2f1f3fc9215afe3219e87ce40a8a991bc71" translate="yes" xml:space="preserve">
          <source>Module ListLabels</source>
          <target state="translated">モジュールリストラベル</target>
        </trans-unit>
        <trans-unit id="9abd62669e68c48ade8c878e63da864a392f2017" translate="yes" xml:space="preserve">
          <source>Module ListLabels: list operations (with labels)</source>
          <target state="translated">モジュール ListLabels:リスト操作 (ラベル付き)</target>
        </trans-unit>
        <trans-unit id="41eb27b154c8a0a9fe8b6fcd4251fc8ecd2542f7" translate="yes" xml:space="preserve">
          <source>Module Location: source code locations</source>
          <target state="translated">モジュールの場所:ソースコードの場所</target>
        </trans-unit>
        <trans-unit id="09ea5f0fd44fa46552a5f30cbf18b1bf609af0ea" translate="yes" xml:space="preserve">
          <source>Module Longident: long identifiers</source>
          <target state="translated">モジュール Longident:長い識別子</target>
        </trans-unit>
        <trans-unit id="10b6935577db632331cb02bf7fee39599c44a34e" translate="yes" xml:space="preserve">
          <source>Module Map</source>
          <target state="translated">モジュールマップ</target>
        </trans-unit>
        <trans-unit id="723c875a6e9814d580d5129ea7f70d98fe17170f" translate="yes" xml:space="preserve">
          <source>Module Map: association tables over ordered types</source>
          <target state="translated">モジュールマップ:順序付けされた型の上のアソシエーションテーブル</target>
        </trans-unit>
        <trans-unit id="996a073e0bd0499fc31006fad291c31374a4ad0a" translate="yes" xml:space="preserve">
          <source>Module Marshal</source>
          <target state="translated">モジュールマーシャル</target>
        </trans-unit>
        <trans-unit id="937c5df760edcb5aeb3c943766622a05d26ea688" translate="yes" xml:space="preserve">
          <source>Module Marshal: marshaling of data structures</source>
          <target state="translated">モジュールマーシャル:データ構造のマーシャリング</target>
        </trans-unit>
        <trans-unit id="2d7a3c934043e76f7e6aa5bab83a410c8b18ba72" translate="yes" xml:space="preserve">
          <source>Module MoreLabels</source>
          <target state="translated">モジュール MoreLabels</target>
        </trans-unit>
        <trans-unit id="4b77f1b995f3d850723fe2d5f0d94f538cb8bc90" translate="yes" xml:space="preserve">
          <source>Module MoreLabels.Hashtbl</source>
          <target state="translated">モジュール MoreLabels.Hashtbl</target>
        </trans-unit>
        <trans-unit id="760a84c4680b6780dd84d385973bbf20f33f4210" translate="yes" xml:space="preserve">
          <source>Module MoreLabels.Map</source>
          <target state="translated">モジュールMoreLabels.Map</target>
        </trans-unit>
        <trans-unit id="25069e19c5b1b2db1e702799063dde780224c560" translate="yes" xml:space="preserve">
          <source>Module MoreLabels.Set</source>
          <target state="translated">モジュールMoreLabels.Set</target>
        </trans-unit>
        <trans-unit id="1b19605374bddf60dcda0218ce57f2d6c6393746" translate="yes" xml:space="preserve">
          <source>Module MoreLabels: Include modules Hashtbl, Map and Set with labels</source>
          <target state="translated">モジュールMoreLabels。Hashtbl,Map,Set モジュールをラベル付きでインクルードします。</target>
        </trans-unit>
        <trans-unit id="699fda78007ab6ee795d1ec46cb5ba0fadbcd152" translate="yes" xml:space="preserve">
          <source>Module Mutex</source>
          <target state="translated">モジュールミューテックス</target>
        </trans-unit>
        <trans-unit id="9441c63e9620994d64788047f899a67dff634072" translate="yes" xml:space="preserve">
          <source>Module Mutex: locks for mutual exclusion</source>
          <target state="translated">モジュールミューテックス:相互排除のためのロック</target>
        </trans-unit>
        <trans-unit id="1838869d8ec86c1a2d37dff5dc780f83b0fec1d6" translate="yes" xml:space="preserve">
          <source>Module Nativeint</source>
          <target state="translated">モジュール Nativeint</target>
        </trans-unit>
        <trans-unit id="cc1d1c0c97415413ce2342a3f6f55d45834011c5" translate="yes" xml:space="preserve">
          <source>Module Nativeint: processor-native integers</source>
          <target state="translated">モジュール Nativeint:プロセッサネイティブ整数</target>
        </trans-unit>
        <trans-unit id="7b4ea02830398a7975c1360e1989452b5c984a6e" translate="yes" xml:space="preserve">
          <source>Module Obj</source>
          <target state="translated">モジュールオブジェクト</target>
        </trans-unit>
        <trans-unit id="272ea9eeccbd009ebb96e6b41a649184070812a9" translate="yes" xml:space="preserve">
          <source>Module Obj.Ephemeron</source>
          <target state="translated">モジュール Obj.エフェメロン</target>
        </trans-unit>
        <trans-unit id="85d7d19a5339d91797722162ab420ee924fd4061" translate="yes" xml:space="preserve">
          <source>Module Obj.Extension_constructor</source>
          <target state="translated">モジュール Obj.Extension_constructor</target>
        </trans-unit>
        <trans-unit id="5fe9ce284b5e4679d29a8e61897d87de3d56edfa" translate="yes" xml:space="preserve">
          <source>Module Oo</source>
          <target state="translated">モジュールOo</target>
        </trans-unit>
        <trans-unit id="5ab66589e35c123c9f9433f57b4d129d3e642f10" translate="yes" xml:space="preserve">
          <source>Module Oo: object-oriented extension</source>
          <target state="translated">モジュール Oo:オブジェクト指向拡張</target>
        </trans-unit>
        <trans-unit id="552e8a4259199d9b2043147a832aca29c2875d9a" translate="yes" xml:space="preserve">
          <source>Module Option</source>
          <target state="translated">モジュールオプション</target>
        </trans-unit>
        <trans-unit id="aa8d3db6fe714bb3b01fd318b7f50f3a7d37c609" translate="yes" xml:space="preserve">
          <source>Module Option: option values</source>
          <target state="translated">モジュールオプション:オプション値</target>
        </trans-unit>
        <trans-unit id="ee462040d70476901068cb4b27d7246c72808b85" translate="yes" xml:space="preserve">
          <source>Module Parse: OCaml syntax parsing</source>
          <target state="translated">モジュールパース。OCaml 構文解析</target>
        </trans-unit>
        <trans-unit id="caf367dbe7aff2e9ccc52d81e33ebb4ebae22ff7" translate="yes" xml:space="preserve">
          <source>Module Parsetree: OCaml syntax tree</source>
          <target state="translated">モジュール Parsetree。OCaml 構文ツリー</target>
        </trans-unit>
        <trans-unit id="7614cdd9f0ec33aa4685f6bd34afeb038456c5ae" translate="yes" xml:space="preserve">
          <source>Module Parsing</source>
          <target state="translated">モジュールの解析</target>
        </trans-unit>
        <trans-unit id="674971f0c437aab44e4076ee335788a7f95f2d06" translate="yes" xml:space="preserve">
          <source>Module Parsing: the run-time library for parsers generated by ocamlyacc</source>
          <target state="translated">モジュール解析:ocamlyacc で生成されたパーサのためのランタイムライブラリ</target>
        </trans-unit>
        <trans-unit id="c5588d487861f64669575fcb69cb5b074b4f41fb" translate="yes" xml:space="preserve">
          <source>Module Pervasives: deprecated alias for Stdlib</source>
          <target state="translated">モジュール Pervasives:Stdlib の非推奨エイリアス</target>
        </trans-unit>
        <trans-unit id="1a1dc73aec1ccbac02b8e8f43ee58892b59b0745" translate="yes" xml:space="preserve">
          <source>Module Pprintast: OCaml syntax printing</source>
          <target state="translated">モジュール Pprintast。OCaml 構文の印刷</target>
        </trans-unit>
        <trans-unit id="b5e430425b7a707621c40fc5db568b1422825347" translate="yes" xml:space="preserve">
          <source>Module Printexc</source>
          <target state="translated">モジュール印刷</target>
        </trans-unit>
        <trans-unit id="c879b5b58ad9c94051bbfc78df7ae8670b40859d" translate="yes" xml:space="preserve">
          <source>Module Printexc.Slot</source>
          <target state="translated">モジュール Printexc.Slot</target>
        </trans-unit>
        <trans-unit id="72f9916225d741d402336a087d22708a6a08547d" translate="yes" xml:space="preserve">
          <source>Module Printexc: facilities for printing exceptions</source>
          <target state="translated">モジュール Printexc:例外を印刷するための機能</target>
        </trans-unit>
        <trans-unit id="8ef8e2302f5298816f3c9a62eb7ff84ee4558dc9" translate="yes" xml:space="preserve">
          <source>Module Printf</source>
          <target state="translated">モジュール印刷</target>
        </trans-unit>
        <trans-unit id="0f2f2beac76b39281ec8d02c364037eaeb98cbcb" translate="yes" xml:space="preserve">
          <source>Module Printf: formatting printing functions</source>
          <target state="translated">モジュール Printf:フォーマット印刷機能</target>
        </trans-unit>
        <trans-unit id="e12960179cefb13cef1a39ceeab8802831a8d8f8" translate="yes" xml:space="preserve">
          <source>Module Queue</source>
          <target state="translated">モジュールキュー</target>
        </trans-unit>
        <trans-unit id="053310d8755ceed37f1727f1d1a1abcfeefaea2f" translate="yes" xml:space="preserve">
          <source>Module Queue: first-in first-out queues</source>
          <target state="translated">モジュールキュー:先入れ先出しキュー</target>
        </trans-unit>
        <trans-unit id="ef161e448a0a073f4c747dde06ec44412c5ae309" translate="yes" xml:space="preserve">
          <source>Module Random</source>
          <target state="translated">モジュールランダム</target>
        </trans-unit>
        <trans-unit id="1b8723087c253ef44125a63809350dd54cc9e5e8" translate="yes" xml:space="preserve">
          <source>Module Random.State</source>
          <target state="translated">モジュール Random.State</target>
        </trans-unit>
        <trans-unit id="0dfee50267f747d0f1636dd29878bc9fbb3994b9" translate="yes" xml:space="preserve">
          <source>Module Random: pseudo-random number generator (PRNG)</source>
          <target state="translated">モジュールランダム:擬似乱数発生器 (PRNG)</target>
        </trans-unit>
        <trans-unit id="14e0c591450e8a2f60ddb8562b4eb14af09e5b51" translate="yes" xml:space="preserve">
          <source>Module Result</source>
          <target state="translated">モジュール結果</target>
        </trans-unit>
        <trans-unit id="5eafde20b375d72096c25a3285f206655630e2ae" translate="yes" xml:space="preserve">
          <source>Module Result: result values</source>
          <target state="translated">モジュールの結果:結果の値</target>
        </trans-unit>
        <trans-unit id="49dde4ae279ace1dea00b588ae3d4054f614e24e" translate="yes" xml:space="preserve">
          <source>Module Scanf</source>
          <target state="translated">モジュールScanf</target>
        </trans-unit>
        <trans-unit id="9aa3fa82fa6bc6d8e6dabdd6356bda9b0137aefa" translate="yes" xml:space="preserve">
          <source>Module Scanf.Scanning</source>
          <target state="translated">モジュール Scanf.スキャニング</target>
        </trans-unit>
        <trans-unit id="93459bcb89eeedf8df411de000f7c2b7c9780503" translate="yes" xml:space="preserve">
          <source>Module Scanf: formatted input functions</source>
          <target state="translated">モジュールScanf:フォーマットされた入力機能</target>
        </trans-unit>
        <trans-unit id="f5360c938c49ae1cd63d56a4fc35fd3890f06a01" translate="yes" xml:space="preserve">
          <source>Module Seq</source>
          <target state="translated">モジュールシーク</target>
        </trans-unit>
        <trans-unit id="745c27dde866b15642e25a8b7002225f218d5efe" translate="yes" xml:space="preserve">
          <source>Module Seq: functional iterators</source>
          <target state="translated">モジュール Seq:関数イテレータ</target>
        </trans-unit>
        <trans-unit id="2e0b5bb25d996e8a2a59e644edb186eb56df4a38" translate="yes" xml:space="preserve">
          <source>Module Set</source>
          <target state="translated">モジュールセット</target>
        </trans-unit>
        <trans-unit id="67541933874b03516f40829e2167ebbae9f49f77" translate="yes" xml:space="preserve">
          <source>Module Set: sets over ordered types</source>
          <target state="translated">モジュールセット:順序付けされたタイプの上にセットされます。</target>
        </trans-unit>
        <trans-unit id="eb15bed9d67a6d8605a1857d27cc2f85878fa8b5" translate="yes" xml:space="preserve">
          <source>Module Spacetime</source>
          <target state="translated">モジュール時空</target>
        </trans-unit>
        <trans-unit id="34b13666199abdbce5a1c2329aac36b498b7e871" translate="yes" xml:space="preserve">
          <source>Module Spacetime.Series</source>
          <target state="translated">モジュール時空.シリーズ</target>
        </trans-unit>
        <trans-unit id="4ed586d95f752bc00d8837393fbda372cb0681cb" translate="yes" xml:space="preserve">
          <source>Module Spacetime.Snapshot</source>
          <target state="translated">モジュール Spacetime.Snapshot</target>
        </trans-unit>
        <trans-unit id="c3ff8e88da485589309cef464360394198823612" translate="yes" xml:space="preserve">
          <source>Module Spacetime: memory profiler</source>
          <target state="translated">モジュール時空:メモリプロファイラ</target>
        </trans-unit>
        <trans-unit id="49d4f336aa17896a5ff3ff9448ea7a4608c970ea" translate="yes" xml:space="preserve">
          <source>Module Stack</source>
          <target state="translated">モジュールスタック</target>
        </trans-unit>
        <trans-unit id="ecef102202227813e5a4bf6e1e72dfe223f093c2" translate="yes" xml:space="preserve">
          <source>Module Stack: last-in first-out stacks</source>
          <target state="translated">モジュールスタック:ラストインファーストアウトスタック</target>
        </trans-unit>
        <trans-unit id="958de5433af391dd3de782eaa1308532356d8dda" translate="yes" xml:space="preserve">
          <source>Module StdLabels</source>
          <target state="translated">モジュール標準ラベル</target>
        </trans-unit>
        <trans-unit id="5c6cfb9453daaec927ca632937f9ea620e55191b" translate="yes" xml:space="preserve">
          <source>Module StdLabels.Array</source>
          <target state="translated">モジュール StdLabels.Array</target>
        </trans-unit>
        <trans-unit id="18fabd24c30510aa2b8a03d1edb5b5d1ecd2653b" translate="yes" xml:space="preserve">
          <source>Module StdLabels.Bytes</source>
          <target state="translated">モジュール StdLabels.Bytes</target>
        </trans-unit>
        <trans-unit id="6d01f040c78ef0b845f05e2b484d4280c974e590" translate="yes" xml:space="preserve">
          <source>Module StdLabels.List</source>
          <target state="translated">モジュール StdLabels.List</target>
        </trans-unit>
        <trans-unit id="1cd5288d0fdc22e9eb53ef8ba091154cc4f412a2" translate="yes" xml:space="preserve">
          <source>Module StdLabels.String</source>
          <target state="translated">モジュール StdLabels.String</target>
        </trans-unit>
        <trans-unit id="6319cdcea700dd1fcd120036bbd03d1e43944c48" translate="yes" xml:space="preserve">
          <source>Module StdLabels: Include modules Array, List and String with labels</source>
          <target state="translated">モジュール StdLabels。配列、リスト、文字列のモジュールをラベル付きでインクルード</target>
        </trans-unit>
        <trans-unit id="ec7ff76184d2e7ae3e758550a03699c6d8049bc7" translate="yes" xml:space="preserve">
          <source>Module Stdlib</source>
          <target state="translated">モジュール Stdlib</target>
        </trans-unit>
        <trans-unit id="2c4a0131cb2ed42ae1c9005e8a590e1a54091746" translate="yes" xml:space="preserve">
          <source>Module Stdlib: the initially opened module</source>
          <target state="translated">モジュール Stdlib:最初に開かれたモジュール</target>
        </trans-unit>
        <trans-unit id="c5e94b392b5c848b46e6e013f4fd8019d3c00a4e" translate="yes" xml:space="preserve">
          <source>Module Str</source>
          <target state="translated">モジュールStr</target>
        </trans-unit>
        <trans-unit id="7a5614285483e72abcf9faabc441c693739ffb77" translate="yes" xml:space="preserve">
          <source>Module Str: regular expressions and string processing</source>
          <target state="translated">モジュールStr.正規表現と文字列処理</target>
        </trans-unit>
        <trans-unit id="7f7138e5bba47e7b41c63652637ee7a8b037bea0" translate="yes" xml:space="preserve">
          <source>Module Stream</source>
          <target state="translated">モジュールストリーム</target>
        </trans-unit>
        <trans-unit id="a10278f414b080e077e13858c56aa56fde51bd41" translate="yes" xml:space="preserve">
          <source>Module Stream: streams and parsers</source>
          <target state="translated">モジュールストリーム:ストリームとパーサ</target>
        </trans-unit>
        <trans-unit id="14ab9c78a29a26ab6d1cdf26aea5144a4e15f83e" translate="yes" xml:space="preserve">
          <source>Module String</source>
          <target state="translated">モジュール文字列</target>
        </trans-unit>
        <trans-unit id="70d219088316f00d44e6354f32e38b06be5fe6f8" translate="yes" xml:space="preserve">
          <source>Module String: string operations</source>
          <target state="translated">モジュール String:文字列操作</target>
        </trans-unit>
        <trans-unit id="cc3e85713ed5e07464558eda70637c5642cbf379" translate="yes" xml:space="preserve">
          <source>Module StringLabels</source>
          <target state="translated">モジュール StringLabels</target>
        </trans-unit>
        <trans-unit id="ac95abe374ec440091969c5ee120b8542ebb8f77" translate="yes" xml:space="preserve">
          <source>Module StringLabels: string operations (with labels)</source>
          <target state="translated">モジュール StringLabels:文字列操作 (ラベル付き)</target>
        </trans-unit>
        <trans-unit id="6d5b8544f315aab96f8817d79bb089eae9451184" translate="yes" xml:space="preserve">
          <source>Module Sys</source>
          <target state="translated">モジュールシステム</target>
        </trans-unit>
        <trans-unit id="958984972bc48fce8fefbe326a85479ad724c6a0" translate="yes" xml:space="preserve">
          <source>Module Sys.Immediate64</source>
          <target state="translated">モジュール Sys.Immediate64</target>
        </trans-unit>
        <trans-unit id="629ea4ee2faa04c5bb6a3adf93e15571e0d8394e" translate="yes" xml:space="preserve">
          <source>Module Sys: system interface</source>
          <target state="translated">モジュール Sys:システムインタフェース</target>
        </trans-unit>
        <trans-unit id="48051dde4d899f8ff82f4d3479ec93c3c7647b0f" translate="yes" xml:space="preserve">
          <source>Module Thread</source>
          <target state="translated">モジュールスレッド</target>
        </trans-unit>
        <trans-unit id="a862836a470588219a4249125bd8f10755fd16b0" translate="yes" xml:space="preserve">
          <source>Module Thread: lightweight threads</source>
          <target state="translated">モジュールスレッド:軽量スレッド</target>
        </trans-unit>
        <trans-unit id="9156d38a7fa11dbaedc16f3d0706294aac2ebee0" translate="yes" xml:space="preserve">
          <source>Module ThreadUnix</source>
          <target state="translated">モジュール ThreadUnix</target>
        </trans-unit>
        <trans-unit id="a6798276f98df7d87c62baea2b0202dd5654a1c0" translate="yes" xml:space="preserve">
          <source>Module ThreadUnix: thread-compatible system calls</source>
          <target state="translated">モジュール ThreadUnix:スレッド互換のシステムコール</target>
        </trans-unit>
        <trans-unit id="dd9e553dcec01d6ecdaeef8c6bce2f1ed535807c" translate="yes" xml:space="preserve">
          <source>Module Uchar</source>
          <target state="translated">モジュールのUchar</target>
        </trans-unit>
        <trans-unit id="61e8da370a37852b69424f5d308f6e8b6a190cbb" translate="yes" xml:space="preserve">
          <source>Module Uchar: Unicode characters</source>
          <target state="translated">モジュール Uchar。Unicode 文字</target>
        </trans-unit>
        <trans-unit id="16ecb69a288aecc5495371b2c1779751b68e31b4" translate="yes" xml:space="preserve">
          <source>Module Unit</source>
          <target state="translated">モジュール単位</target>
        </trans-unit>
        <trans-unit id="2ba1b1b3ef272d41eba2286920064169778f337d" translate="yes" xml:space="preserve">
          <source>Module Unit: unit values</source>
          <target state="translated">モジュール単位:単位値</target>
        </trans-unit>
        <trans-unit id="1792b1adb6606ac02ca5a4965131d6116d82599a" translate="yes" xml:space="preserve">
          <source>Module Unix</source>
          <target state="translated">モジュールUnix</target>
        </trans-unit>
        <trans-unit id="68685cf371d09d0be037c8891fdbb041a6955bb4" translate="yes" xml:space="preserve">
          <source>Module Unix.LargeFile</source>
          <target state="translated">モジュール Unix.LargeFile</target>
        </trans-unit>
        <trans-unit id="c09a1e52642105e9e7b0b8457efac3458d40b0f0" translate="yes" xml:space="preserve">
          <source>Module Unix: Unix system calls</source>
          <target state="translated">モジュールUnix。Unix システムコール</target>
        </trans-unit>
        <trans-unit id="e446500e934433078817abf2e14140a9f2567531" translate="yes" xml:space="preserve">
          <source>Module UnixLabels</source>
          <target state="translated">モジュールUnixLabels</target>
        </trans-unit>
        <trans-unit id="29d97bc7771ac286b2f7fa8d869eb8a2a0f2e806" translate="yes" xml:space="preserve">
          <source>Module UnixLabels.LargeFile</source>
          <target state="translated">モジュール UnixLabels.LargeFile</target>
        </trans-unit>
        <trans-unit id="bbc3a336379a1ab64349969278912adaf93249f4" translate="yes" xml:space="preserve">
          <source>Module UnixLabels: Labeled Unix system calls</source>
          <target state="translated">UnixLabels モジュール。ラベル付き Unix システムコール</target>
        </trans-unit>
        <trans-unit id="d87aa68b013503ed8844fab06b1f94a6cf80b676" translate="yes" xml:space="preserve">
          <source>Module Weak</source>
          <target state="translated">モジュールの弱さ</target>
        </trans-unit>
        <trans-unit id="c0fbea6de11552e58adf74acc30f65573ee8b35b" translate="yes" xml:space="preserve">
          <source>Module Weak: arrays of weak pointers</source>
          <target state="translated">弱いモジュール:弱いポインタの配列</target>
        </trans-unit>
        <trans-unit id="331d2760734f7e482dfad8fe98cac289cb021696" translate="yes" xml:space="preserve">
          <source>Module expressions are the module-level equivalent of value expressions: they evaluate to modules, thus providing implementations for the specifications expressed in module types.</source>
          <target state="translated">モジュール式はモジュールレベルの値式と同等のもので、モジュールに対して評価します。</target>
        </trans-unit>
        <trans-unit id="bbd0d4a8e429ad9704ed8561d8b8ccf363cf691b" translate="yes" xml:space="preserve">
          <source>Module type Ephemeron.S</source>
          <target state="translated">モジュールタイプ Ephemeron.S</target>
        </trans-unit>
        <trans-unit id="5ba5bbb64dc581113ae02747f71e2e95524ad670" translate="yes" xml:space="preserve">
          <source>Module type Ephemeron.SeededS</source>
          <target state="translated">モジュールタイプ Ephemeron.SeededS</target>
        </trans-unit>
        <trans-unit id="e7fc3d9e09cfcef4e28717f43e53f614492c4a07" translate="yes" xml:space="preserve">
          <source>Module type Hashtbl.HashedType</source>
          <target state="translated">モジュール型 Hashtbl.HashedType</target>
        </trans-unit>
        <trans-unit id="553e3c5393f8ee87abd320792f53df0480a89437" translate="yes" xml:space="preserve">
          <source>Module type Hashtbl.S</source>
          <target state="translated">モジュール型Hashtbl.S</target>
        </trans-unit>
        <trans-unit id="d4f4885e8e252ac679a71b98e38ae6b36bec3794" translate="yes" xml:space="preserve">
          <source>Module type Hashtbl.SeededHashedType</source>
          <target state="translated">モジュール型Hashtbl.SeededHashedType</target>
        </trans-unit>
        <trans-unit id="19a7fd61f14defb9b6e4cfd12105dcf424fb68dc" translate="yes" xml:space="preserve">
          <source>Module type Hashtbl.SeededS</source>
          <target state="translated">モジュール型Hashtbl.SeededS</target>
        </trans-unit>
        <trans-unit id="c3a914203d81a68cd8f34d38dd3525c65fb9c5ba" translate="yes" xml:space="preserve">
          <source>Module type Map.OrderedType</source>
          <target state="translated">モジュール型Map.OrderedType</target>
        </trans-unit>
        <trans-unit id="d326bc02f7f0598bde27deba9a371a4e51379f13" translate="yes" xml:space="preserve">
          <source>Module type Map.S</source>
          <target state="translated">モジュールタイプMap.S</target>
        </trans-unit>
        <trans-unit id="d9f4fc879c6159477aa40865bb89618115962c18" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Hashtbl.HashedType</source>
          <target state="translated">モジュール型MoreLabels.Hashtbl.HashedType</target>
        </trans-unit>
        <trans-unit id="fac1d1343fd73a7f1801158d9ea0bc13f5f2438e" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Hashtbl.S</source>
          <target state="translated">モジュール型MoreLabels.Hashtbl.S</target>
        </trans-unit>
        <trans-unit id="227008c4795726cb8535f817b67718075184d4b4" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Hashtbl.SeededHashedType</source>
          <target state="translated">モジュール型MoreLabels.Hashtbl.SeededHashedType</target>
        </trans-unit>
        <trans-unit id="378116ae1fbf467ddaea54a32b51349c6761a1c1" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Hashtbl.SeededS</source>
          <target state="translated">モジュール型MoreLabels.Hashtbl.SeededS</target>
        </trans-unit>
        <trans-unit id="3ae291b8f1ed6643e66aaa62f2bc341a327d4675" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Map.OrderedType</source>
          <target state="translated">モジュール型MoreLabels.Map.OrderedType</target>
        </trans-unit>
        <trans-unit id="7154f17264fbac973b9fa0370b2c6d6369cde11d" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Map.S</source>
          <target state="translated">モジュール型MoreLabels.Map.S</target>
        </trans-unit>
        <trans-unit id="a999b8bf8010daee6d4715724a5de3c63e349192" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Set.OrderedType</source>
          <target state="translated">モジュール型MoreLabels.Set.OrderedType</target>
        </trans-unit>
        <trans-unit id="10f02d0b490b6bd1c3b28accd09985393baabab9" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Set.S</source>
          <target state="translated">モジュール型MoreLabels.Set.S</target>
        </trans-unit>
        <trans-unit id="05df05949b4417b3b5d633c96eec842e5cc5a73c" translate="yes" xml:space="preserve">
          <source>Module type Set.OrderedType</source>
          <target state="translated">モジュール型 Set.OrderedType</target>
        </trans-unit>
        <trans-unit id="0540217cacc40a66bb6b0dcbe128de08a49bb684" translate="yes" xml:space="preserve">
          <source>Module type Set.S</source>
          <target state="translated">モジュールタイプ Set.S</target>
        </trans-unit>
        <trans-unit id="6682efa59e414919e3f347ffa12dbd5a9ef7d4b0" translate="yes" xml:space="preserve">
          <source>Module type Sys.Immediate64.Immediate</source>
          <target state="translated">モジュールタイプ Sys.Immediate64.Immediate</target>
        </trans-unit>
        <trans-unit id="c6a12e0efd39177b624b9104a3d6be80c5fdf8d7" translate="yes" xml:space="preserve">
          <source>Module type Sys.Immediate64.Non_immediate</source>
          <target state="translated">モジュールタイプ Sys.Immediate64.Non_immediate</target>
        </trans-unit>
        <trans-unit id="4946361a74879d2b9ef81babbb5a11b0fd75747a" translate="yes" xml:space="preserve">
          <source>Module type Weak.S</source>
          <target state="translated">モジュールタイプのWeak.S</target>
        </trans-unit>
        <trans-unit id="e18ca9fec937a1c5383f1670e1007cb899397310" translate="yes" xml:space="preserve">
          <source>Module types</source>
          <target state="translated">モジュールの種類</target>
        </trans-unit>
        <trans-unit id="c5882558195a629df9610d22ab7a2bb696dfa08e" translate="yes" xml:space="preserve">
          <source>Module types are the module-level equivalent of type expressions: they specify the general shape and type properties of modules.</source>
          <target state="translated">モジュールタイプは、モジュールレベルではタイプ式と同等のものです。</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="1bdeaa58662002456132d5e4df075bf678e694ae" translate="yes" xml:space="preserve">
          <source>Modules are typically thought of as static components. This extension makes it possible to pack a module as a first-class value, which can later be dynamically unpacked into a module.</source>
          <target state="translated">モジュールは一般的に静的なコンポーネントとして考えられています。この拡張機能により、モジュールをファーストクラスの値としてパッケージ化することが可能になり、後で動的にモジュールに展開することができます。</target>
        </trans-unit>
        <trans-unit id="bb3f2d6730fda28eebf828a1b5d994ee25cda13c" translate="yes" xml:space="preserve">
          <source>Month of year 0..11</source>
          <target state="translated">年の月 0...11</target>
        </trans-unit>
        <trans-unit id="7368e316821f8931f19a457402e063b7f5ee9a7c" translate="yes" xml:space="preserve">
          <source>More character operations are provided in module &lt;a href=&quot;char&quot;&gt;&lt;code&gt;Char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">より多くの文字操作がモジュール&lt;a href=&quot;char&quot;&gt; &lt;code&gt;Char&lt;/code&gt; で&lt;/a&gt;提供されます。</target>
        </trans-unit>
        <trans-unit id="98c4048d66ba3c4b91263b34fa74fb272d60a783" translate="yes" xml:space="preserve">
          <source>More complex standalone OCaml programs are typically composed of multiple source files, and can link with precompiled libraries. Chapters &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; and &lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt; explain how to use the batch compilers ocamlc and ocamlopt. Recompilation of multi-file OCaml projects can be automated using third-party build systems, such as the &lt;a href=&quot;https://github.com/ocaml/ocamlbuild/&quot;&gt;ocamlbuild&lt;/a&gt; compilation manager.</source>
          <target state="translated">より複雑なスタンドアロンOCamlプログラムは通常、複数のソースファイルで構成されており、プリコンパイルされたライブラリとリンクできます。第&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;章と第&lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt;章では、バッチコンパイラocamlcとocamloptの使用方法について説明します。マルチファイルOCamlプロジェクトの&lt;a href=&quot;https://github.com/ocaml/ocamlbuild/&quot;&gt;再&lt;/a&gt;コンパイルは、ocamlbuildコンパイルマネージャーなどのサードパーティビルドシステムを使用して自動化できます。</target>
        </trans-unit>
        <trans-unit id="561b0023eb18eba22354cdb393742a8b59c73c03" translate="yes" xml:space="preserve">
          <source>More examples of binary methods can be found in sections &lt;a href=&quot;advexamples#ss%3Astring-as-class&quot;&gt;6.2.1&lt;/a&gt; and &lt;a href=&quot;advexamples#ss%3Aset-as-class&quot;&gt;6.2.3&lt;/a&gt;.</source>
          <target state="translated">バイナリメソッドのその他の例は、セクション&lt;a href=&quot;advexamples#ss%3Astring-as-class&quot;&gt;6.2.1&lt;/a&gt;および&lt;a href=&quot;advexamples#ss%3Aset-as-class&quot;&gt;6.2.3にあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="51d19b2b2f97ccba7609ee2b5ad377c0b117b048" translate="yes" xml:space="preserve">
          <source>More formatters can be created with &lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt;&lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;format#VALformatter_of_buffer&quot;&gt;&lt;code&gt;Format.formatter_of_buffer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;format#VALformatter_of_symbolic_output_buffer&quot;&gt;&lt;code&gt;Format.formatter_of_symbolic_output_buffer&lt;/code&gt;&lt;/a&gt; or using &lt;a href=&quot;format#formatter&quot;&gt;custom formatters&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt; &lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;format#VALformatter_of_buffer&quot;&gt; &lt;code&gt;Format.formatter_of_buffer&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;format#VALformatter_of_symbolic_output_buffer&quot;&gt; &lt;code&gt;Format.formatter_of_symbolic_output_buffer&lt;/code&gt; &lt;/a&gt;を使用するか、&lt;a href=&quot;format#formatter&quot;&gt;カスタムフォーマッター&lt;/a&gt;を使用して、さらに多くのフォーマッターを作成できます。</target>
        </trans-unit>
        <trans-unit id="6948d057e07078f31d8b94099955db506d318be0" translate="yes" xml:space="preserve">
          <source>More generally, as soon as a type variable appears in a position describing mutable state it becomes invariant. As a corollary, covariant variables will never denote mutable locations and can be safely generalized. For a better description, interested readers can consult the original article by Jacques Garrigue on &lt;a href=&quot;http://www.math.nagoya-u.ac.jp/~garrigue/papers/morepoly-long.pdf&quot;&gt;http://www.math.nagoya-u.ac.jp/~garrigue/papers/morepoly-long.pdf&lt;/a&gt;</source>
          <target state="translated">より一般的には、型変数が可変状態を表す位置に現れるとすぐに、それは不変になります。当然の結果として、共変変数は可変位置を示すことはなく、安全に一般化できます。より良い説明については、興味のある読者は&lt;a href=&quot;http://www.math.nagoya-u.ac.jp/~garrigue/papers/morepoly-long.pdf&quot;&gt;http://www.math.nagoya-u.ac.jp/~garrigue/papers/morepoly-long.pdfの&lt;/a&gt;JacquesGarrigueによる元の記事を参照することができます。</target>
        </trans-unit>
        <trans-unit id="c805dcb67ff19c680fa8d577587f09aa3b1df1b0" translate="yes" xml:space="preserve">
          <source>More important is the fact that polymorphic variants, while being type-safe, result in a weaker type discipline. That is, core language variants do actually much more than ensuring type-safety, they also check that you use only declared constructors, that all constructors present in a data-structure are compatible, and they enforce typing constraints to their parameters.</source>
          <target state="translated">さらに重要なのは、多相バリアントは型安全でありながら、型の規律を弱くしてしまうという事実です。つまり、コア言語のバリアントは、実際には型の安全性を保証する以上のことをしているのです。</target>
        </trans-unit>
        <trans-unit id="e832f6beb4577f420972cdf48bcfee3bb6d20aec" translate="yes" xml:space="preserve">
          <source>More list operations are provided in module &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">その他のリスト操作は、モジュール&lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; で&lt;/a&gt;提供されています。</target>
        </trans-unit>
        <trans-unit id="e0c233b3a7dba4306b68b837cdcd9f763220099a" translate="yes" xml:space="preserve">
          <source>More precisely, consider the expression:</source>
          <target state="translated">より正確には、表現を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="2403a8574f06c5e570469506e110ecacf6fc95f8" translate="yes" xml:space="preserve">
          <source>More precisely: when a semantic tag is opened or closed then both and successive 'tag-printing' and 'tag-marking' operations occur:</source>
          <target state="translated">より正確には、セマンティックタグが開かれたり閉じられたりすると、「タグ印刷」と「タグマーキング」の両方と連続した操作が発生します。</target>
        </trans-unit>
        <trans-unit id="f9eabc59e9a2d75ca1154fdc14a5cb14b6f18138" translate="yes" xml:space="preserve">
          <source>More string operations are provided in module &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">より多くの文字列操作がモジュール&lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; で&lt;/a&gt;提供されます。</target>
        </trans-unit>
        <trans-unit id="20302dcfb13e0aacdfb918a9998d06e11ec681a9" translate="yes" xml:space="preserve">
          <source>MoreLabels</source>
          <target state="translated">MoreLabels</target>
        </trans-unit>
        <trans-unit id="f2d9c7352bab5b013f1b4948abc890b999a592c8" translate="yes" xml:space="preserve">
          <source>Moreover, being the last defined type is a quite unstable position that may change surreptitiously after adding or moving around a type definition, or after opening a module (see chapter &lt;a href=&quot;moduleexamples#c%3Amoduleexamples&quot;&gt;2&lt;/a&gt;). Consequently, adding explicit type annotations to guide disambiguation is more robust than relying on the last defined type disambiguation.</source>
          <target state="translated">さらに、最後に定義された型であることは非常に不安定な位置であり、型定義を追加または移動した後、またはモジュールを開いた後に密かに変更される可能性があります（第&lt;a href=&quot;moduleexamples#c%3Amoduleexamples&quot;&gt;2&lt;/a&gt;章を参照）。その結果、明確化をガイドするために明示的な型注釈を追加することは、最後に定義された型の明確化に依存するよりも堅牢です。</target>
        </trans-unit>
        <trans-unit id="b575cbbaf8906b9c5a5ee4c9f1a89643a318a7a5" translate="yes" xml:space="preserve">
          <source>Moreover, opening a box after the &lt;a href=&quot;format#maxindent&quot;&gt;maximum indentation limit&lt;/a&gt; splits the line whether or not the box would end up fitting on the line.</source>
          <target state="translated">さらに、&lt;a href=&quot;format#maxindent&quot;&gt;最大インデント制限の&lt;/a&gt;後にボックスを開くと、ボックスがラインに収まるかどうかに関係なく、ラインが分割されます。</target>
        </trans-unit>
        <trans-unit id="4bacee78a2fc3a758d3d73b2a613831022d03403" translate="yes" xml:space="preserve">
          <source>Moreover, the table shouldn't be modified during a call to &lt;code&gt;iter&lt;/code&gt;. Use &lt;code&gt;filter_map_inplace&lt;/code&gt; in this case.</source>
          <target state="translated">さらに、 &lt;code&gt;iter&lt;/code&gt; の呼び出し中にテーブルを変更しないでください。この場合、 &lt;code&gt;filter_map_inplace&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="938a8c4d2e6fe32d5784eafdd62df55fa7c40576" translate="yes" xml:space="preserve">
          <source>Moreover, weak types cannot appear in the signature of toplevel modules: types must be known at compilation time. Otherwise, different compilation units could replace the weak type with different and incompatible types. For this reason, compiling the following small piece of code</source>
          <target state="translated">さらに、弱い型はtoplevelモジュールのシグネチャには現れません:型はコンパイル時に知られていなければなりません。そうしないと、異なるコンパイルユニットが弱い型を異なる互換性のない型に置き換えてしまう可能性があります。このため、次のような小さなコードをコンパイルすると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="3770beeb0150f7b961905b2a3287d7d10a959428" translate="yes" xml:space="preserve">
          <source>Moreover, when the type definitions are exposed, the type checker is able to infer variance information on its own and one can benefit from the relaxed value restriction even unknowingly. However, this is not the case anymore when defining new abstract types. As an illustration, we can define a module type collection as:</source>
          <target state="translated">さらに、型の定義が公開されると、型チェッカーは独自に分散情報を推論することができ、知らず知らずのうちにも緩和された値制限の恩恵を受けることができます。しかし、新しい抽象型を定義する場合はそうではありません。例として、モジュールの型コレクションを次のように定義することができます。</target>
        </trans-unit>
        <trans-unit id="ce25d2287fa6866cf43b250692213d18a00fc939" translate="yes" xml:space="preserve">
          <source>Most functions in the &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; module come in two variants: a short version that operates on &lt;a href=&quot;format#VALstd_formatter&quot;&gt;&lt;code&gt;Format.std_formatter&lt;/code&gt;&lt;/a&gt; and the generic version prefixed by &lt;code&gt;pp_&lt;/code&gt; that takes a formatter as its first argument.</source>
          <target state="translated">&lt;a href=&quot;format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt;モジュールのほとんどの関数には、&lt;a href=&quot;format#VALstd_formatter&quot;&gt; &lt;code&gt;Format.std_formatter&lt;/code&gt; &lt;/a&gt;で動作する短いバージョンと、最初の引数として &lt;code&gt;pp_&lt;/code&gt; をとるpp_で始まる汎用バージョンの2つのバリエーションがあります。</target>
        </trans-unit>
        <trans-unit id="60ca906dcdb56968f58923bddaabb17961cb58f1" translate="yes" xml:space="preserve">
          <source>Multi-index are also supported through a second variant of indexing operators</source>
          <target state="translated">マルチインデックスは、インデックス演算子の第二のバリアントでもサポートされています。</target>
        </trans-unit>
        <trans-unit id="ac17c3be367cdf7b78ca9f7d7c50f262d3737c1d" translate="yes" xml:space="preserve">
          <source>Multiple inheritance is allowed. Only the last definition of a method is kept: the redefinition in a subclass of a method that was visible in the parent class overrides the definition in the parent class. Previous definitions of a method can be reused by binding the related ancestor. Below, super is bound to the ancestor printable_point. The name super is a pseudo value identifier that can only be used to invoke a super-class method, as in super#print.</source>
          <target state="translated">複数の継承が許可されています。メソッドの最後の定義のみが保持されます:親クラスで表示されていたメソッドのサブクラスでの再定義は、親クラスでの定義を上書きします。メソッドの以前の定義は、関連する祖先をバインドすることで再利用することができます。以下では、super を先祖の printable_point にバインドしています。superという名前は、super#printのように、スーパークラスのメソッドを呼び出すためだけに使用できる擬似的な値の識別子です。</target>
        </trans-unit>
        <trans-unit id="de3d99d65d2f00ba5445685c943974a51e9484a3" translate="yes" xml:space="preserve">
          <source>Multiple levels of packing can be achieved by combining -pack with -for-pack. Consider the following example:</source>
          <target state="translated">複数のレベルのパッキングは、-pack と -for-pack を組み合わせることで実現できます。次の例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="2b9ee6e2b5fcdbd970e8f069acf17877e49e0441" translate="yes" xml:space="preserve">
          <source>Multiplication</source>
          <target state="translated">Multiplication</target>
        </trans-unit>
        <trans-unit id="549313c817d85e3b3f930b86928b72bbc44715d8" translate="yes" xml:space="preserve">
          <source>Multiplication.</source>
          <target state="translated">Multiplication.</target>
        </trans-unit>
        <trans-unit id="0d9a3f742b2bc9ffe56449aed4b901aa2ce9a0f4" translate="yes" xml:space="preserve">
          <source>Multiplicative inverse (&lt;code&gt;1/z&lt;/code&gt;).</source>
          <target state="translated">逆数（ &lt;code&gt;1/z&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bd2b0f087b02e413546a53c4f93f4cdf1581cc30" translate="yes" xml:space="preserve">
          <source>Mutex</source>
          <target state="translated">Mutex</target>
        </trans-unit>
        <trans-unit id="ff8d388bea0cae09717df1b41a4b4c493e6970fa" translate="yes" xml:space="preserve">
          <source>Mutexes (mutual-exclusion locks) are used to implement critical sections and protect shared mutable data structures against concurrent accesses. The typical use is (if &lt;code&gt;m&lt;/code&gt; is the mutex associated with the data structure &lt;code&gt;D&lt;/code&gt;):</source>
          <target state="translated">ミューテックス（相互排他ロック）は、クリティカルセクションを実装し、共有の可変データ構造を同時アクセスから保護するために使用されます。典型的な使用法は次のとおりです（ &lt;code&gt;m&lt;/code&gt; がデータ構造 &lt;code&gt;D&lt;/code&gt; に関連付けられたミューテックスである場合）：</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="e353e4d6aad1380c87ec233564134a4a344dffe7" translate="yes" xml:space="preserve">
          <source>Name of service or port number</source>
          <target state="translated">サービス名またはポート番号</target>
        </trans-unit>
        <trans-unit id="ae264d14a11c34ace5fbb1bb8a6dd75bfdb17d89" translate="yes" xml:space="preserve">
          <source>Name or IP address of host</source>
          <target state="translated">ホストの名前またはIPアドレス</target>
        </trans-unit>
        <trans-unit id="549333ca0fbff4a493ab5e0bc0f95428f0fc7de0" translate="yes" xml:space="preserve">
          <source>Name space</source>
          <target state="translated">ネームスペース</target>
        </trans-unit>
        <trans-unit id="756b76addd8adeb70cb127b2a93c3fa37d752c2d" translate="yes" xml:space="preserve">
          <source>Name the output files prefix.ml, prefix.mli, prefix.output, instead of the default naming convention.</source>
          <target state="translated">出力ファイルには、デフォルトの命名規則ではなく、prefix.ml,prefix.mli,prefix.output という名前をつけます。</target>
        </trans-unit>
        <trans-unit id="8c095b2219367daec6dcc1e5087ff4061bfc41c9" translate="yes" xml:space="preserve">
          <source>Named pipe</source>
          <target state="translated">ネームドパイプ</target>
        </trans-unit>
        <trans-unit id="296294d67daa5c2f7bd477f7158b245e13beb631" translate="yes" xml:space="preserve">
          <source>Namely, the inferred remaining case is Some _, which is split into Some (Int, _) and Some (Bool, _), which are both untypable because deep expects a non-existing char t as the first element of the tuple. Note that the refutation case could be omitted here, because it is automatically added when there is only one case in the pattern matching.</source>
          <target state="translated">つまり、推測される残りのケースはSome _で、これはSome (Int,_)とSome (Bool,_)に分割されています。反論ケースは、パターンマッチングで1つのケースしかない場合に自動的に追加されるため、ここでは省略することができます。</target>
        </trans-unit>
        <trans-unit id="e162aabfb0fa43d82b67a374234c4cb74d9be965" translate="yes" xml:space="preserve">
          <source>Names that are defined as abstract types in a signature can be implemented in a matching structure by any kind of type definition (provided it has the same number of type parameters). The exact implementation of the type will be hidden to the users of the structure. In particular, if the type is implemented as a variant type or record type, the associated constructors and fields will not be accessible to the users; if the type is implemented as an abbreviation, the type equality between the type name and the right-hand side of the abbreviation will be hidden from the users of the structure. Users of the structure consider that type as incompatible with any other type: a fresh type has been generated.</source>
          <target state="translated">シグネチャで抽象型として定義されている名前は、どんな種類の型定義でもマッチング構造体に実装することができます(同じ数の型パラメータを持つことを条件とします)。型の正確な実装は,構造体の利用者には隠されます。特に,その型がバリアント型やレコード型として実装されている場合,関連するコンストラクタやフィールドは利用者にはアクセスできません;その型が省略形として実装されている場合,型名と省略形の右側との間の型の等質性は構造体の利用者には隠されます。構造体の利用者は,その型を他の型と互換性がないものとみなします:新しい型が生成されました。</target>
        </trans-unit>
        <trans-unit id="9e848993d9abd7bcd0da1a886c50f6a34ca40770" translate="yes" xml:space="preserve">
          <source>Naming labels come in two flavours: &lt;a href=&quot;#label&quot;&gt;label&lt;/a&gt; for normal arguments and &lt;a href=&quot;#optlabel&quot;&gt;optlabel&lt;/a&gt; for optional ones. They are simply distinguished by their first character, either ~ or ?.</source>
          <target state="translated">：命名ラベルは、2つのフレーバー来る&lt;a href=&quot;#label&quot;&gt;ラベル&lt;/a&gt;通常の引数とするために&lt;a href=&quot;#optlabel&quot;&gt;optlabel&lt;/a&gt;オプションのもののために。それらは、最初の文字（〜または？）によって単純に区別されます。</target>
        </trans-unit>
        <trans-unit id="be64c74e17dde72651549865ed8544a38961913d" translate="yes" xml:space="preserve">
          <source>Nativeint</source>
          <target state="translated">Nativeint</target>
        </trans-unit>
        <trans-unit id="6121887e44c8bb72f2cd96f891df9010238c7905" translate="yes" xml:space="preserve">
          <source>Nativeint_val(v) returns the long integer contained in the nativeintv.</source>
          <target state="translated">Nativeint_val(v)は nativeintv に含まれる長い整数を返します。</target>
        </trans-unit>
        <trans-unit id="fe99dc11adcd3f4c5eeceb4413e82bcd56b5ef61" translate="yes" xml:space="preserve">
          <source>Natural logarithm (in base &lt;code&gt;e&lt;/code&gt;).</source>
          <target state="translated">自然対数（基数 &lt;code&gt;e&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2f187f5dc4cb75173c53a77254bdd4b7078911c3" translate="yes" xml:space="preserve">
          <source>Natural logarithm.</source>
          <target state="translated">自然対数。</target>
        </trans-unit>
        <trans-unit id="b710ee6a1b2df5b06e260b4de6bc7921f957917e" translate="yes" xml:space="preserve">
          <source>Negation of &lt;a href=&quot;stdlib#VAL(=)&quot;&gt;&lt;code&gt;(=)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VAL(=)&quot;&gt; &lt;code&gt;(=)&lt;/code&gt; の&lt;/a&gt;否定。</target>
        </trans-unit>
        <trans-unit id="8919121a4837a7384f394582f637a0af70744796" translate="yes" xml:space="preserve">
          <source>Negation of &lt;a href=&quot;stdlib#VAL(=)&quot;&gt;&lt;code&gt;(=)&lt;/code&gt;&lt;/a&gt;. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VAL(=)&quot;&gt; &lt;code&gt;(=)&lt;/code&gt; の&lt;/a&gt;否定。左結合演算子。詳細については、&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="9befaab36628d9f7863760f1639c08f6661eaa9f" translate="yes" xml:space="preserve">
          <source>Negation of &lt;a href=&quot;stdlib#VAL(==)&quot;&gt;&lt;code&gt;(==)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VAL(==)&quot;&gt; &lt;code&gt;(==)&lt;/code&gt; の&lt;/a&gt;否定。</target>
        </trans-unit>
        <trans-unit id="f4f78c719756b0216b5efd59f9661b9e8b62f6c6" translate="yes" xml:space="preserve">
          <source>Negation of &lt;a href=&quot;stdlib#VAL(==)&quot;&gt;&lt;code&gt;(==)&lt;/code&gt;&lt;/a&gt;. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VAL(==)&quot;&gt; &lt;code&gt;(==)&lt;/code&gt; の&lt;/a&gt;否定。左結合演算子。詳細については、&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="77f939047f0ba0a97a64071a5a435763eb58f7bd" translate="yes" xml:space="preserve">
          <source>Negative infinity.</source>
          <target state="translated">負の無限大。</target>
        </trans-unit>
        <trans-unit id="8ba9abe745a8f0e4e877cc69abc52cdee83e48b7" translate="yes" xml:space="preserve">
          <source>Network dropped connection on reset</source>
          <target state="translated">リセット時にネットワークの接続が切断された</target>
        </trans-unit>
        <trans-unit id="ea849e260b8735345217e4f53f113c9fcde5b394" translate="yes" xml:space="preserve">
          <source>Network is down</source>
          <target state="translated">ネットワークがダウンしています</target>
        </trans-unit>
        <trans-unit id="d34a1412dd6535ceabe7960d72728113a96b875c" translate="yes" xml:space="preserve">
          <source>Network is unreachable</source>
          <target state="translated">ネットワークに接続できない</target>
        </trans-unit>
        <trans-unit id="c006cf01dc92514d04743559daf156d417fe5f82" translate="yes" xml:space="preserve">
          <source>New applications that need arbitrary-precision arithmetic should use the Zarith library (&lt;a href=&quot;https://github.com/ocaml/Zarith&quot;&gt;https://github.com/ocaml/Zarith&lt;/a&gt;) instead of the Num library, and older applications that already use Num are encouraged to switch to Zarith. Zarith delivers much better performance than Num and has a nicer API.</source>
          <target state="translated">任意精度の演算が必要な新しいアプリケーションでは、Numライブラリの代わりにZarithライブラリ（&lt;a href=&quot;https://github.com/ocaml/Zarith&quot;&gt;https://github.com/ocaml/Zarith&lt;/a&gt;）を使用する必要があります。すでにNumを使用している古いアプリケーションでは、Zarithに切り替えることをお勧めします。Zarithは、Numよりもはるかに優れたパフォーマンスを提供し、より優れたAPIを備えています。</target>
        </trans-unit>
        <trans-unit id="280be44a9152ebadb2bdb39840c63ece14ec70f7" translate="yes" xml:space="preserve">
          <source>New variant type or record type: no equation, a representation.</source>
          <target state="translated">新しいバリアント型またはレコード型:方程式なし、表現。</target>
        </trans-unit>
        <trans-unit id="7e1039fc69f9291b60d0860a59005e4bab261192" translate="yes" xml:space="preserve">
          <source>Next, we run the program under afl-fuzz:</source>
          <target state="translated">次に、afl-fuzzでプログラムを実行します。</target>
        </trans-unit>
        <trans-unit id="2981f6fc6fe648e38aa58e8e417c3c2d93457ab6" translate="yes" xml:space="preserve">
          <source>No attempt has been made at mathematical rigor: words are employed with their intuitive meaning, without further definition. As a consequence, the typing rules have been left out, by lack of the mathematical framework required to express them, while they are definitely part of a full formal definition of the language.</source>
          <target state="translated">数学的な厳密さは試みられていません:単語は、それ以上の定義なしに、直感的な意味で使用されています。結果として、類型規則は、それらを表現するために必要な数学的枠組みがないために取り残されていますが、それらは言語の完全な形式的定義の一部であることは間違いありません。</target>
        </trans-unit>
        <trans-unit id="e792e65ee8a80fd8989ad1b66325f180ccd8b365" translate="yes" xml:space="preserve">
          <source>No buffer space available</source>
          <target state="translated">利用可能なバッファスペースがない</target>
        </trans-unit>
        <trans-unit id="aa02cb7a520e805604b436b26d2e3b0230ac3573" translate="yes" xml:space="preserve">
          <source>No child process</source>
          <target state="translated">子供の処理ができない</target>
        </trans-unit>
        <trans-unit id="4b716f8eaa691d689900e51bfb7cf3470f97f3d4" translate="yes" xml:space="preserve">
          <source>No coeffects:</source>
          <target state="translated">補正はしていません。</target>
        </trans-unit>
        <trans-unit id="4e0b86ee8d4ae90b6347fb23a23aee01ef7d1ad2" translate="yes" xml:space="preserve">
          <source>No effects:</source>
          <target state="translated">効果はありません。</target>
        </trans-unit>
        <trans-unit id="ac84bf2f78b29d7fcdb0dbd9e9503065301a53a2" translate="yes" xml:space="preserve">
          <source>No locks available</source>
          <target state="translated">ロックなし</target>
        </trans-unit>
        <trans-unit id="62c6526007299ca03f778b5b7ce0d726354cae0d" translate="yes" xml:space="preserve">
          <source>No route to host</source>
          <target state="translated">ホストへのルートがない</target>
        </trans-unit>
        <trans-unit id="5c0580667d6055e92a026b8c67fa943060b2c89d" translate="yes" xml:space="preserve">
          <source>No space left on device</source>
          <target state="translated">デバイス上に空きスペースがありません</target>
        </trans-unit>
        <trans-unit id="7e7d314f83d9dd80d3f3a1d2cf49d2c2861bf468" translate="yes" xml:space="preserve">
          <source>No string in the result contains the &lt;code&gt;sep&lt;/code&gt; character.</source>
          <target state="translated">結果の文字列に &lt;code&gt;sep&lt;/code&gt; 文字が含まれていません。</target>
        </trans-unit>
        <trans-unit id="e5feee0204f5532e0cb04d5be298f4c467c05e6f" translate="yes" xml:space="preserve">
          <source>No such device</source>
          <target state="translated">そのような装置はありません。</target>
        </trans-unit>
        <trans-unit id="112765ee706d5c7ea20d7309d6bf892b8a5aa7eb" translate="yes" xml:space="preserve">
          <source>No such device or address</source>
          <target state="translated">そのようなデバイスやアドレスはありません</target>
        </trans-unit>
        <trans-unit id="8a6cb568f806ffae868a77b519003a5df95ec0c3" translate="yes" xml:space="preserve">
          <source>No such file or directory</source>
          <target state="translated">そのようなファイルやディレクトリはありません</target>
        </trans-unit>
        <trans-unit id="0cf4a772e5ca24befae7ddee66e425eeaa8130aa" translate="yes" xml:space="preserve">
          <source>No such process</source>
          <target state="translated">そのようなプロセスはありません。</target>
        </trans-unit>
        <trans-unit id="db516bd236f8b19cb9f7f134b81fc52a48b48cab" translate="yes" xml:space="preserve">
          <source>Non-Flambda versions of the compiler cannot inline functions that contain a definition of another function. However -Oclassic does permit this. Further, non-Flambda versions also cannot inline functions that are only themselves exposed as a result of a previous pass of inlining, but again this is permitted by -Oclassic. For example:</source>
          <target state="translated">Flambda 以外のバージョンのコンパイラでは、他の関数の定義を含む関数をインライン化することはできません。しかし、-Oclassic ではこれを許可しています。さらに、Flambda 以外のバージョンでは、以前のインライン化のパスの結果としてそれ自体だけが公開されている関数をインライン化することもできませんが、これも -Oclassic では許可されています。しかし、これも -Oclassic によって許可されています。</target>
        </trans-unit>
        <trans-unit id="5a7fec4c0093183b651e94da8602d12888a9798d" translate="yes" xml:space="preserve">
          <source>Non-blocking version of &lt;a href=&quot;event#VALsync&quot;&gt;&lt;code&gt;Event.sync&lt;/code&gt;&lt;/a&gt;: offer all the communication possibilities specified in the event to the outside world, and if one can take place immediately, perform it and return &lt;code&gt;Some&amp;nbsp;r&lt;/code&gt; where &lt;code&gt;r&lt;/code&gt; is the result value of that communication.</source>
          <target state="translated">ノンブロッキングバージョン&lt;a href=&quot;event#VALsync&quot;&gt; &lt;code&gt;Event.sync&lt;/code&gt; &lt;/a&gt;：プラン1は、すぐに場所を取る、それを実行して返すことができる場合は、外の世界にイベントに指定され、すべての通信の可能性 &lt;code&gt;Some&amp;nbsp;r&lt;/code&gt; &lt;code&gt;r&lt;/code&gt; はその通信の結果値です。</target>
        </trans-unit>
        <trans-unit id="e1c495fe7e42478c735910f07114d91295ddc81f" translate="yes" xml:space="preserve">
          <source>Non-blocking version of &lt;a href=&quot;event#VALsync&quot;&gt;&lt;code&gt;Event.sync&lt;/code&gt;&lt;/a&gt;: offer all the communication possibilities specified in the event to the outside world, and if one can take place immediately, perform it and return &lt;code&gt;Some&amp;nbsp;r&lt;/code&gt; where &lt;code&gt;r&lt;/code&gt; is the result value of that communication. Otherwise, return &lt;code&gt;None&lt;/code&gt; without blocking.</source>
          <target state="translated">ノンブロッキングバージョン&lt;a href=&quot;event#VALsync&quot;&gt; &lt;code&gt;Event.sync&lt;/code&gt; &lt;/a&gt;：プラン1は、すぐに場所を取る、それを実行して返すことができる場合は、外の世界にイベントに指定され、すべての通信の可能性 &lt;code&gt;Some&amp;nbsp;r&lt;/code&gt; &lt;code&gt;r&lt;/code&gt; はその通信の結果値です。それ以外の場合は、ブロックせずに &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="f7955c5f7147285808f393b0a2f015ae8bfdf418" translate="yes" xml:space="preserve">
          <source>Non-generalized type variables in a type cause no difficulties inside a given structure or compilation unit (the contents of a .ml file, or an interactive session), but they cannot be allowed inside signatures nor in compiled interfaces (.cmi file), because they could be used inconsistently later. Therefore, the compiler flags an error when a structure or compilation unit defines a value name whose type contains non-generalized type variables. There are two ways to fix this error:</source>
          <target state="translated">型内の非一般化型変数は、与えられた構造体やコンパイル・ユニット(.mlファイルの内容や対話型セッション)の内部では問題になりませんが、シグネチャやコンパイルされたインタフェース(.cmiファイル)の内部では、後で矛盾して使用される可能性があるため、許可することはできません。そのため、構造体やコンパイル・ユニットが、型に汎用化されていない型変数を含む値名を定義した場合、コンパイラはエラー・フラグを立てます。このエラーを修正する方法は2つあります。</target>
        </trans-unit>
        <trans-unit id="74b76795e362f5a2898817253827ed1f46066a45" translate="yes" xml:space="preserve">
          <source>Non-principal type.</source>
          <target state="translated">非プリンシパル型。</target>
        </trans-unit>
        <trans-unit id="552623d2d3482ef2ceb23ffcc0f0d612c140eb4c" translate="yes" xml:space="preserve">
          <source>Non-regular recursive algebraic data types correspond to polymorphic algebraic data types whose parameter types vary between the left and right side of the type definition. For instance, it might be interesting to define a datatype that ensures that all lists are nested at the same depth:</source>
          <target state="translated">非正規再帰的代数データ型は多相代数データ型に対応しており、そのパラメータ型は型定義の左辺と右辺の間で変化します。例えば、すべてのリストが同じ深さに入れ子になっていることを保証するデータ型を定義すると面白いかもしれません。</target>
        </trans-unit>
        <trans-unit id="4722a32b4738403c181ac5e3a12ee6eb896bca7c" translate="yes" xml:space="preserve">
          <source>Non-returning statement.</source>
          <target state="translated">返しのない発言。</target>
        </trans-unit>
        <trans-unit id="187ac81e9effe553285ccadbb88b811d43fd0c04" translate="yes" xml:space="preserve">
          <source>Nonoptional label applied as optional.</source>
          <target state="translated">オプションとして適用される非オプションラベル。</target>
        </trans-unit>
        <trans-unit id="af7065271027eca5c68630d7333cfc9de2dd8678" translate="yes" xml:space="preserve">
          <source>Nonterminal symbols are like regular OCaml symbols, except that they cannot end with ' (single quote).</source>
          <target state="translated">非終端記号は通常のOCaml記号のようなものですが、末尾が'(シングルクォート)で終わることができないことを除いては、この記号を使うことはできません。</target>
        </trans-unit>
        <trans-unit id="8c779683d49742e5580a38345a8dbcc07ab2e152" translate="yes" xml:space="preserve">
          <source>Norm squared: given &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt;, returns &lt;code&gt;x^2&amp;nbsp;+&amp;nbsp;y^2&lt;/code&gt;.</source>
          <target state="translated">ノルムの二乗： &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt; 与えられると、 &lt;code&gt;x^2&amp;nbsp;+&amp;nbsp;y^2&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="ddc420b7c8d61b9e4310ab8493f4d729522accc5" translate="yes" xml:space="preserve">
          <source>Norm: given &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt;, returns &lt;code&gt;sqrt(x^2&amp;nbsp;+&amp;nbsp;y^2)&lt;/code&gt;.</source>
          <target state="translated">ノルム： &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt; 与えられると、 &lt;code&gt;sqrt(x^2&amp;nbsp;+&amp;nbsp;y^2)&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="517d7530daae5b9c5977ddf4fbfb276d8be8264d" translate="yes" xml:space="preserve">
          <source>Normal number, none of the below</source>
          <target state="translated">通常の数値、以下のいずれでもない</target>
        </trans-unit>
        <trans-unit id="36fb1748b422ce3ad94d8a06d8205b349c379068" translate="yes" xml:space="preserve">
          <source>Normally the compiler generates a type error if you attempt to pass to a function a parameter whose type is different from the expected one. However, in the specific case where the expected type is a non-labeled function type, and the argument is a function expecting optional parameters, the compiler will attempt to transform the argument to have it match the expected type, by passing None for all optional parameters.</source>
          <target state="translated">通常、期待される型とは異なる型のパラメータを関数に渡そうとすると、コンパイラは型エラーを発生させます。しかし、期待される型が非ラベル関数型であり、引数がオプション・パラメータを期待する関数である場合、コンパイラは、すべてのオプション・パラメータに None を渡すことで、期待される型と一致するように引数を変換します。</target>
        </trans-unit>
        <trans-unit id="c792fa3c18a06a015ea04948e5b4604135e35115" translate="yes" xml:space="preserve">
          <source>Normally, the allocation rate is measured by counting the in-heap size of allocated blocks. However, it often happens that finalized objects contain pointers to out-of-heap memory blocks and other resources (such as file descriptors, X Windows bitmaps, etc.). For those blocks, the in-heap size of blocks is not a good measure of the quantity of resources allocated by the program.</source>
          <target state="translated">通常、割り当て率は割り当てられたブロックのインヒープサイズを数えることで測定されます。しかし、ファイナライズされたオブジェクトには、アウトオブヒープのメモリブロックや他のリソース(ファイルディスクリプタやX Windowsビットマップなど)へのポインタが含まれていることがよくあります。これらのブロックについては、ブロックのインヒープサイズは、プログラムによって割り当てられたリソースの量を示す良い尺度ではありません。</target>
        </trans-unit>
        <trans-unit id="1ff9300a83f8a35da371237256262716296f049b" translate="yes" xml:space="preserve">
          <source>Normally, the debugger takes checkpoints of the program state from time to time. That is, it makes a copy of the current state of the program (using the Unix system call fork). If the variable checkpoints is set to off, the debugger will not take any checkpoints.</source>
          <target state="translated">通常、デバッガは時々プログラムの状態のチェックポイントを取ります。つまり、プログラムの現在の状態のコピーを作成します (Unix システムコールフォークを使用)。変数 checkpoints が off に設定されている場合、デバッガはチェックポイントを取りません。</target>
        </trans-unit>
        <trans-unit id="338469a733ebda5aa0e30bb1db80e0e157e51892" translate="yes" xml:space="preserve">
          <source>Not a directory</source>
          <target state="translated">ディレクトリではない</target>
        </trans-unit>
        <trans-unit id="9faeba3fc7b5c9d7e01764096168b9e8e374411d" translate="yes" xml:space="preserve">
          <source>Not a number: result of an undefined operation</source>
          <target state="translated">数値ではありません:未定義の操作の結果</target>
        </trans-unit>
        <trans-unit id="4c8ae112a2e8df4e520ecf91813337acb821264b" translate="yes" xml:space="preserve">
          <source>Not all functions are provided by all Unix variants. If some functions are not available, they will raise Invalid_arg when called.</source>
          <target state="translated">すべての Unix バリアントですべての関数が提供されているわけではありません。いくつかの関数が利用できない場合は、呼び出されたときに Invalid_arg が発生します。</target>
        </trans-unit>
        <trans-unit id="a251fde2cab1783fbc45a17d3491954f07532d2e" translate="yes" xml:space="preserve">
          <source>Not all header available in the caml/ directory were described in previous sections. All those unmentioned headers are part of the internal runtime API, for which there is &lt;em&gt;no&lt;/em&gt; stability guarantee. If you really need access to this internal runtime API, this section provides some guidelines that may help you to write code that might not break on every new version of OCaml.</source>
          <target state="translated">caml /ディレクトリで使用可能なすべてのヘッダーが、前のセクションで説明されているわけではありません。これらの言及されていないヘッダーはすべて、内部ランタイムAPIの一部であり、安定性の保証はあり&lt;em&gt;ませ&lt;/em&gt;ん。この内部ランタイムAPIに本当にアクセスする必要がある場合、このセクションでは、OCamlのすべての新しいバージョンで壊れない可能性のあるコードを書くのに役立ついくつかのガイドラインを提供します。</target>
        </trans-unit>
        <trans-unit id="a9199f21841e17aae508bebd4889b3a7dc1d36c6" translate="yes" xml:space="preserve">
          <source>Not an executable file</source>
          <target state="translated">実行可能ファイルではない</target>
        </trans-unit>
        <trans-unit id="facd4c2d5bdce52a545593e87469a809ac0e1231" translate="yes" xml:space="preserve">
          <source>Not enough memory</source>
          <target state="translated">メモリが足りない</target>
        </trans-unit>
        <trans-unit id="cf34be1f750ab01dd0f009456dd21934f44155fb" translate="yes" xml:space="preserve">
          <source>Not for the casual user.</source>
          <target state="translated">気軽なユーザーには向かない。</target>
        </trans-unit>
        <trans-unit id="4152727c8d99325fa09c8beae5e73e4b8bd46f0c" translate="yes" xml:space="preserve">
          <source>Not the normal way of pretty-printing, since imperative line splitting may interfere with current line counters and box size calculation. Using break hints within an enclosing vertical box is a better alternative.</source>
          <target state="translated">通常のプリティープリントの方法ではありません。ブレークヒントを縦長のボックス内で使用することは、より良い代替手段です。</target>
        </trans-unit>
        <trans-unit id="a819c9b54780bf0db302a106d8d765a494007de9" translate="yes" xml:space="preserve">
          <source>Note as well that parent directories in the given path will not be created when opening the trace. The runtime assumes the path is accessible for creating and writing the trace. The program will fail to start if this requirement isn&amp;rsquo;t met.</source>
          <target state="translated">また、トレースを開いたときに、指定されたパスの親ディレクトリが作成されないことにも注意してください。ランタイムは、トレースの作成と書き込みのためにパスにアクセスできることを前提としています。この要件が満たされない場合、プログラムは開始に失敗します。</target>
        </trans-unit>
        <trans-unit id="037c57d3261561d20c1db3424456e04def230f71" translate="yes" xml:space="preserve">
          <source>Note here the (self : int #iterator) idiom, which ensures that this object implements the interface iterator.</source>
          <target state="translated">ここでは (self:int #iterator)というイディオムに注意してください。これは、このオブジェクトがイテレータのインターフェイスを実装していることを保証するものです。</target>
        </trans-unit>
        <trans-unit id="c3ce8074b0d7cbaefabb1e3d3e4d3c74808df3a8" translate="yes" xml:space="preserve">
          <source>Note here the special syntax (#point0 as 'a) we have to use to quantify the extensible part of #point0. As for the variable binder, it can be omitted in class specifications. If you want polymorphism inside object field it must be quantified independently.</source>
          <target state="translated">ここでは、#point0の拡張可能な部分を定量化するために使用する特別な構文(#point0を'a'とする)に注意してください。変数バインダーについては、クラスの仕様では省略することができます。オブジェクトフィールドの中で多相性を持たせたい場合は、独立して定量化しなければなりません。</target>
        </trans-unit>
        <trans-unit id="ab69a65854dd6fec6962d0e2d5e4784cf692204e" translate="yes" xml:space="preserve">
          <source>Note in particular that -inline does not have the meaning that it has in the previous compiler or in -Oclassic mode. In both of those situations -inline was effectively some kind of basic assessment of inlining benefit. However in Flambda inlining mode it corresponds to a constraint on the search; the assessment of benefit is independent, as described above.</source>
          <target state="translated">特に、-inline は以前のコンパイラや -Oclassic モードでは意味を持ちません。これらの状況では、-inline は事実上、インラインの利点の基本的な評価のようなものでした。しかし、Flambda のインラインモードでは、-inline は検索の制約に対応しています。</target>
        </trans-unit>
        <trans-unit id="90e7c8c1273c2167af15e26d1e579c38f8f99528" translate="yes" xml:space="preserve">
          <source>Note on polymorphic variant tags: the current implementation accepts lowercase variant tags in addition to capitalized variant tags, but we suggest you avoid lowercase variant tags for portability and compatibility with future OCaml versions.</source>
          <target state="translated">多相バリアントタグに関する注意事項:現在の実装では、大文字のバリアントタグに加えて小文字のバリアントタグを受け付けていますが、移植性と将来のOCamlバージョンとの互換性のために、小文字のバリアントタグは避けることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="8abc6d55c7e6502cb76253097a56d727be818505" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;dynlink#VALloadfile&quot;&gt;&lt;code&gt;Dynlink.loadfile&lt;/code&gt;&lt;/a&gt; changes the allowed-units list.</source>
          <target state="translated">&lt;a href=&quot;dynlink#VALloadfile&quot;&gt; &lt;code&gt;Dynlink.loadfile&lt;/code&gt; &lt;/a&gt;は、許可されたユニットのリストを変更することに注意してください。</target>
        </trans-unit>
        <trans-unit id="08d26a6dbdf7cb76c9e11d80524e91dc7d0ef610" translate="yes" xml:space="preserve">
          <source>Note that entering open Mod merely accesses the compiled interface (.cmi file) for Mod, but does not load the implementation of Mod, and does not cause any error if no implementation of Mod has been loaded. The error &amp;ldquo;reference to undefined global Mod&amp;rdquo; will occur only when executing a value or module definition that refers to Mod.</source>
          <target state="translated">open Modを入力すると、Modのコンパイル済みインターフェイス（.cmiファイル）にアクセスするだけで、Modの実装は読み込まれず、Modの実装が読み込まれていなくてもエラーは発生しないことに注意してください。「未定義のグローバルModへの参照」というエラーは、Modを参照する値またはモジュール定義を実行する場合にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="2165fbecefe21675865f5a8f169aa75121b7dd25" translate="yes" xml:space="preserve">
          <source>Note that for clarity&amp;rsquo;s sake, the method print is explicitly marked as overriding another definition by annotating the method keyword with an exclamation mark !. If the method print were not overriding the print method of printable_point, the compiler would raise an error:</source>
          <target state="translated">わかりやすくするために、メソッドprintは、メソッドキーワードに感嘆符！で注釈を付けることにより、別の定義をオーバーライドするものとして明示的にマークされていることに注意してください。メソッドprintがprintable_pointのprintメソッドをオーバーライドしていない場合、コンパイラーはエラーを発生させます。</target>
        </trans-unit>
        <trans-unit id="0c8b0cd07d8b3eb1cb5c73f85a9b93dce5e210f3" translate="yes" xml:space="preserve">
          <source>Note that in this case you should not compute dependencies for mylib.mli together with the other files, hence the need to pass explicitly the list of files to process. If mylib.mli itself has dependencies, you should compute them using -as-map.</source>
          <target state="translated">この場合、mylib.mliの依存関係を他のファイルと一緒に計算すべきではないことに注意してください。mylib.mli自身に依存関係がある場合は、-as-mapを使って計算する必要があります。</target>
        </trans-unit>
        <trans-unit id="63274ceec059ea43f06cf7d5143c9d0f279449fe" translate="yes" xml:space="preserve">
          <source>Note that it would be unsafe if &lt;code&gt;s&lt;/code&gt; was passed as an additional parameter to the function &lt;code&gt;f&lt;/code&gt; as it could escape this way and be mutated in the future -- &lt;code&gt;string_init&lt;/code&gt; would give up ownership of &lt;code&gt;s&lt;/code&gt; to pass it to &lt;code&gt;f&lt;/code&gt;, and could not call &lt;code&gt;unsafe_to_string&lt;/code&gt; safely.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; が関数 &lt;code&gt;f&lt;/code&gt; に追加のパラメーターとして渡された場合、この方法でエスケープして将来変更される可能性があるため、安全ではないことに注意してください &lt;code&gt;string_init&lt;/code&gt; は &lt;code&gt;s&lt;/code&gt; の所有権を放棄して &lt;code&gt;f&lt;/code&gt; に渡し、 &lt;code&gt;unsafe_to_string&lt;/code&gt; を呼び出すことができませんでした。安全に。</target>
        </trans-unit>
        <trans-unit id="b4753a1c807609006c1cb1222f68e354a9ec0d33" translate="yes" xml:space="preserve">
          <source>Note that label comments take precedence over item comments, so:</source>
          <target state="translated">ラベルコメントはアイテムコメントよりも優先されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a919535701ff97d2e364548f37fa537e17d9cc03" translate="yes" xml:space="preserve">
          <source>Note that lazy_two has type int lazy_t. However, the type 'a lazy_t is an internal type name, so the type 'a Lazy.t should be preferred when possible.</source>
          <target state="translated">lazy_twoはint lazy_tという型を持っていることに注意してください。ただし、型'a lazy_tは内部的な型名なので、可能であれば型'a Lazy.tの方が望ましいです。</target>
        </trans-unit>
        <trans-unit id="bdbd6ed5e065f79a1664cc5e3d9e396319783be3" translate="yes" xml:space="preserve">
          <source>Note that line splitting policy is box specific: the policy of a box does not rule the policy of inner boxes. For instance, if a vertical box is nested in an horizontal box, all break hints within the vertical box will split the line.</source>
          <target state="translated">行分割のポリシーはボックス固有のものであることに注意してください:ボックスのポリシーは、内側のボックスのポリシーを支配しません。例えば、縦長のボックスが横長のボックスに入れ子になっている場合、縦長のボックス内のすべてのブレークヒントが行を分割します。</target>
        </trans-unit>
        <trans-unit id="0ce52db53f4883581f49385acd3aa04301c1b07b" translate="yes" xml:space="preserve">
          <source>Note that no information is propagated about the contents of strings, even in safe-string mode, because it cannot yet be guaranteed that they are immutable throughout a given program.</source>
          <target state="translated">安全文字列モードであっても、文字列の内容についての情報は伝搬されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="9ecfaba3e31b928fe62c543cf4b58b08adf9f38d" translate="yes" xml:space="preserve">
          <source>Note that once &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; was called, there is no way to revert to the non-randomized default behavior of &lt;a href=&quot;hashtbl#VALcreate&quot;&gt;&lt;code&gt;Hashtbl.create&lt;/code&gt;&lt;/a&gt;. This is intentional. Non-randomized hash tables can still be created using &lt;code&gt;Hashtbl.create&amp;nbsp;~random:false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hashtbl.randomize()&lt;/code&gt; が呼び出されると、&lt;a href=&quot;hashtbl#VALcreate&quot;&gt; &lt;code&gt;Hashtbl.create&lt;/code&gt; の&lt;/a&gt;ランダム化されていないデフォルトの動作に戻す方法がないことに注意してください。これは意図的なものです。ランダム化されていないハッシュテーブルは、 &lt;code&gt;Hashtbl.create&amp;nbsp;~random:false&lt;/code&gt; を使用して作成できます。</target>
        </trans-unit>
        <trans-unit id="d3eb4400a3041e1bc0872d4c6fadfee7b45a0533" translate="yes" xml:space="preserve">
          <source>Note that only top-level structures can be mapped to separately-compiled files, but neither functors nor module types. However, all module-class objects can appear as components of a structure, so the solution is to put the functor or module type inside a structure, which can then be mapped to a file.</source>
          <target state="translated">トップレベルの構造体だけが個別にコンパイルされたファイルにマッピングできますが、ファンクタもモジュール型もマッピングできないことに注意してください。しかし、すべてのモジュールクラスオブジェクトは構造体のコンポーネントとして現れることができるので、解決策は、ファンクタやモジュールタイプを構造体の中に入れて、ファイルにマッピングすることです。</target>
        </trans-unit>
        <trans-unit id="45d50cbdd93bc0057831e01783483dc11563f7c4" translate="yes" xml:space="preserve">
          <source>Note that since immediate objects do not define a class type, they have no such restriction.</source>
          <target state="translated">即時オブジェクトはクラス型を定義しないので、そのような制限はないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="2bd433ffb5b0bba6a711c0ea5bb3b1c7a88c90b0" translate="yes" xml:space="preserve">
          <source>Note that the callback can be postponed slightly after the actual event. The callstack passed to the callback is always accurate, but the program state may have evolved.</source>
          <target state="translated">コールバックは、実際のイベントの少し後に延期することができることに注意してください。コールバックに渡されるコールスタックは常に正確ですが、プログラムの状態が進化している可能性があります。</target>
        </trans-unit>
        <trans-unit id="c2ef9b9d1aff860780f332e0b33c8e88450455d7" translate="yes" xml:space="preserve">
          <source>Note that the coercion (&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;:&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;) is actually an abbreviated form, and will only work in presence of private abbreviations if neither the type of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; nor &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; contain any type variables. If they do, you must use the full form (&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;) where &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is the expected type of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;. Concretely, this would be (x : N.t :&amp;gt; int) and (l : N.t list :&amp;gt; int list) for the above examples.</source>
          <target state="translated">強制（&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;：&amp;gt; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;）は実際には省略形であり、&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;の型も&lt;a href=&quot;types#typexpr&quot;&gt;typexprの&lt;/a&gt;型にも型変数が含まれていない場合にのみ、プライベートな省略形が存在する場合にのみ機能することに注意してください。 （彼らが行う場合は、完全な形式を使用する必要があり&lt;a href=&quot;expr#expr&quot;&gt;式expr&lt;/a&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;）&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;の予想されるタイプである&lt;a href=&quot;expr#expr&quot;&gt;式exprを&lt;/a&gt;。具体的には、上記の例では（x：Nt：&amp;gt; int）と（l：Nt list：&amp;gt; int list）になります。</target>
        </trans-unit>
        <trans-unit id="50817e39131d67a96275cac53949dd6c7173b3db" translate="yes" xml:space="preserve">
          <source>Note that the following identifiers are keywords of the Camlp4 extensions and should be avoided for compatibility reasons.</source>
          <target state="translated">以下の識別子は Camlp4 拡張モジュールのキーワードであり、互換性の理由から避けるべきであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6d6f602690ce2c063c471eee010ebbe59f6bbddc" translate="yes" xml:space="preserve">
          <source>Note that the instrumented runtime is an alternative runtime for OCaml programs. It is only referenced during the linking stage of the final executable. This means that the compilation stage does not need to be altered to enable instrumentation.</source>
          <target state="translated">インストルメントランタイムは、OCamlプログラムの代替ランタイムであることに注意してください。最終的な実行ファイルのリンク段階でのみ参照されます。これは、インストルメンテーションを有効にするためにコンパイル段階を変更する必要がないことを意味します。</target>
        </trans-unit>
        <trans-unit id="5971f9da22f0faace6bfec873b81d408ac540d78" translate="yes" xml:space="preserve">
          <source>Note that the new type &lt;code&gt;'a&amp;nbsp;IntHashtbl.t&lt;/code&gt; is not compatible with the type &lt;code&gt;('a,'b)&amp;nbsp;Hashtbl.t&lt;/code&gt; of the generic interface. For example, &lt;code&gt;Hashtbl.length&amp;nbsp;h&lt;/code&gt; would not type-check, you must use &lt;code&gt;IntHashtbl.length&lt;/code&gt;.</source>
          <target state="translated">新しいタイプ &lt;code&gt;'a&amp;nbsp;IntHashtbl.t&lt;/code&gt; は、ジェネリックインターフェイスのタイプ &lt;code&gt;('a,'b)&amp;nbsp;Hashtbl.t&lt;/code&gt; と互換性がないことに注意してください。たとえば、 &lt;code&gt;Hashtbl.length&amp;nbsp;h&lt;/code&gt; はタイプチェックを行わないため、 &lt;code&gt;IntHashtbl.length&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="f01438030239e56aa11911507a85c74b4e412af5" translate="yes" xml:space="preserve">
          <source>Note that the relationship between object, class and type in OCaml is different than in mainstream object-oriented languages such as Java and C++, so you shouldn&amp;rsquo;t assume that similar keywords mean the same thing. Object-oriented features are used much less frequently in OCaml than in those languages. OCaml has alternatives that are often more appropriate, such as modules and functors. Indeed, many OCaml programs do not use objects at all.</source>
          <target state="translated">OCamlのオブジェクト、クラス、タイプの関係は、JavaやC ++などの主流のオブジェクト指向言語とは異なるため、類似したキーワードが同じことを意味するとは限りません。オブジェクト指向機能は、OCamlではそれらの言語よりもはるかに少ない頻度で使用されます。OCamlには、モジュールやファンクターなど、多くの場合より適切な代替手段があります。実際、多くのOCamlプログラムはオブジェクトをまったく使用していません。</target>
        </trans-unit>
        <trans-unit id="4c7b8526d94d8c27ed35f7c7cec40a0edae7df3f" translate="yes" xml:space="preserve">
          <source>Note that the two types AbstractStringSet.set and NoCaseStringSet.set are not compatible, and values of these two types do not match. This is the correct behavior: even though both set types contain elements of the same type (strings), they are built upon different orderings of that type, and different invariants need to be maintained by the operations (being strictly increasing for the standard ordering and for the case-insensitive ordering). Applying operations from AbstractStringSet to values of type NoCaseStringSet.set could give incorrect results, or build lists that violate the invariants of NoCaseStringSet.</source>
          <target state="translated">AbstractStringSet.setとNoCaseStringSet.setの2つの型は互換性がなく、これら2つの型の値は一致しないことに注意してください。これは正しい動作です。両方のセット型には同じ型の要素 (文字列)が含まれているにもかかわらず、その型の異なる順序付けに基づいて構築されているため、演算によって異なる不変量を維持する必要があります (標準の順序付けと大文字小文字を区別しない順序付けでは厳密に増加します)。AbstractStringSet の操作を NoCaseStringSet.set 型の値に適用すると、正しくない結果が得られたり、NoCaseStringSet の不変量に違反するリストが作成されたりする可能性があります。</target>
        </trans-unit>
        <trans-unit id="c3e9f41fd86b1c950c9ef81d22b068692eccf75f" translate="yes" xml:space="preserve">
          <source>Note that the type constructor regular_nested always appears as 'a regular_nested in the definition above, with the same parameter 'a. Equipped with this type, one can compute a maximal depth with a classic recursive function</source>
          <target state="translated">コンストラクタregular_nested型は,上の定義では常に同じパラメータ'a'を持つ'a regular_nested'として現れることに注意してください.この型を用いて,古典的な再帰関数</target>
        </trans-unit>
        <trans-unit id="f894cfb3f87405bfa359dfc278dfe88f62a0e6bb" translate="yes" xml:space="preserve">
          <source>Note that the type money is not a subtype of type comparable, as the self type appears in contravariant position in the type of method leq. Indeed, an object m of class money has a method leq that expects an argument of type money since it accesses its value method. Considering m of type comparable would allow a call to method leq on m with an argument that does not have a method value, which would be an error.</source>
          <target state="translated">自己型がメソッド leq の型の中で矛盾した位置に現れるので、型 money は比較可能な型のサブタイプではないことに注意してください。実際、moneyクラスのオブジェクトmは、その値メソッドにアクセスするので、money型の引数を期待するメソッドleqを持っています。m を comparable 型と考えると、メソッド値を持たない引数で m のメソッド leq を呼び出すことができますが、これはエラーになります。</target>
        </trans-unit>
        <trans-unit id="95b3888a7e3a6dd69b6635ff1d23f6223d9986c2" translate="yes" xml:space="preserve">
          <source>Note that the type of p is point. This is an abbreviation automatically defined by the class definition above. It stands for the object type &amp;lt;get_x : int; move : int -&amp;gt; unit&amp;gt;, listing the methods of class point along with their types.</source>
          <target state="translated">pのタイプがポイントであることに注意してください。これは、上記のクラス定義によって自動的に定義された略語です。オブジェクトタイプ&amp;lt;get_x：int;を表します。move：int-&amp;gt; unit&amp;gt;、クラスポイントのメソッドとそのタイプを一覧表示します。</target>
        </trans-unit>
        <trans-unit id="66b9f6fff51ab2e45034f690441bdecd68df53d9" translate="yes" xml:space="preserve">
          <source>Note that the word-delimited form, for example {sql|...|sql}, should not be used for signaling that an extension is in use. Indeed, the user cannot see from the code whether this string literal has different semantics than they expect. Moreover, giving semantics to a specific delimiter limits the freedom to change the delimiter to avoid escaping issues.</source>
          <target state="translated">例えば {sql|...|sql}のような単語で区切られた形式は、拡張機能が使用されていることを示すために使用すべきではないことに注意してください。実際、ユーザはこの文字列リテラルが期待していたものとは異なるセマンティクスを持っているかどうかをコードから知ることはできません。さらに、特定のデリミタにセマンティクスを与えると、エスケープ問題を避けるためにデリミタを変更する自由が制限されます。</target>
        </trans-unit>
        <trans-unit id="5daea91835e86ffb05aea9cef4296c3068906517" translate="yes" xml:space="preserve">
          <source>Note that this construction is only useful if the exception is raised between match&amp;hellip;with. Exception patterns can be combined with ordinary patterns at the toplevel,</source>
          <target state="translated">この構造は、match&amp;hellip;withの間に例外が発生した場合にのみ役立つことに注意してください。例外パターンは、トップレベルで通常のパターンと組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="6c35684e12f57c72020fa856c51c0081aec8613e" translate="yes" xml:space="preserve">
          <source>Note that this is not the same thing as private and protected methods in Java or C++, which can be called from other objects of the same class. This is a direct consequence of the independence between types and classes in OCaml: two unrelated classes may produce objects of the same type, and there is no way at the type level to ensure that an object comes from a specific class. However a possible encoding of friend methods is given in section &lt;a href=&quot;#s%3Afriends&quot;&gt;3.17&lt;/a&gt;.</source>
          <target state="translated">これは、同じクラスの他のオブジェクトから呼び出すことができるJavaまたはC ++のプライベートメソッドおよび保護されたメソッドと同じではないことに注意してください。これは、OCamlの型とクラス間の独立性の直接的な結果です。2つの無関係なクラスが同じ型のオブジェクトを生成する可能性があり、オブジェクトが特定のクラスからのものであることを保証する方法は型レベルではありません。ただし、フレンドメソッドの可能なエンコーディングはセクション&lt;a href=&quot;#s%3Afriends&quot;&gt;3.17に記載されてい&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="5301e9ce9eaee70b52bc0e30c461f8dc4f50979b" translate="yes" xml:space="preserve">
          <source>Note that this syntax is not valid within OCaml: average has an universally quantified type 'a inside the type of one of its argument whereas for polymorphic recursion the universally quantified type was introduced before the rest of the type. This position of the universally quantified type means that average is a second-rank polymorphic function. This kind of higher-rank functions is not directly supported by OCaml: type inference for second-rank polymorphic function and beyond is undecidable; therefore using this kind of higher-rank functions requires to handle manually these universally quantified types.</source>
          <target state="translated">この構文は OCaml 内では有効ではないことに注意してください。平均はその引数の一つの型の中に普遍的に定量化された型 'a' を持っていますが、多相再帰では、普遍的に定量化された型は他の型の前に導入されています。この普遍的に定量化された型の位置は、平均が2ランク目の多相関数であることを意味します。この種の高ランク関数はOCamlでは直接サポートされていません:2ランク目以降の多相関数の型推論は決定できないため、この種の高ランク関数を使用するには、これらの普遍的に定量化された型を手動で処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="0537a61ab3006dae26fac6b5f19a889d7c194bae" translate="yes" xml:space="preserve">
          <source>Note that this will only affect the prefix of the trace file, there is no option to specify the full effective file name. This restriction is in place to make room for future improvements to the instrumented runtime, where the single trace file per session design may be replaced.</source>
          <target state="translated">これはトレースファイルのプレフィックスにのみ影響し、完全な有効なファイル名を指定するオプションはないことに注意してください。この制限は、将来的にインストルメントランタイムが改善され、セッションデザインごとに1つのトレースファイルが置き換えられるようにするために設けられています。</target>
        </trans-unit>
        <trans-unit id="e53f78797414436c28938372fd25e7a220604184" translate="yes" xml:space="preserve">
          <source>Note that we can rewrite the type of f and f' as</source>
          <target state="translated">f と f' の型を</target>
        </trans-unit>
        <trans-unit id="9855ac639cc02bb505afbab05f1ffccd97cf7fa0" translate="yes" xml:space="preserve">
          <source>Note that when &lt;code&gt;fn&lt;/code&gt; is called all the functions registered with &lt;a href=&quot;stdlib#VALat_exit&quot;&gt;&lt;code&gt;at_exit&lt;/code&gt;&lt;/a&gt; have already been called. Because of this you must make sure any output channel &lt;code&gt;fn&lt;/code&gt; writes on is flushed.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; が呼び出されると、&lt;a href=&quot;stdlib#VALat_exit&quot;&gt; &lt;code&gt;at_exit&lt;/code&gt; に&lt;/a&gt;登録されているすべての関数がすでに呼び出されていることに注意してください。このため、 &lt;code&gt;fn&lt;/code&gt; が書き込む出力チャネルがフラッシュされていることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="5902b468c9420c576a1090e7ba4580b19535ba05" translate="yes" xml:space="preserve">
          <source>Note that when you don&amp;rsquo;t need an argument, you can still use a wildcard pattern, but you must prefix it with the label.</source>
          <target state="translated">引数が必要ない場合でも、ワイルドカードパターンを使用できますが、接頭辞としてラベルを付ける必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="42951dc6e5e061dd8581c9cd3e18ab7ff1122703" translate="yes" xml:space="preserve">
          <source>Note that you can also remove manifest types, by substituting with the same type.</source>
          <target state="translated">マニフェスト型を削除するには、同じ型で代用することで、マニフェスト型を削除することもできることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6d24bd50ee40c13de42decb018fafac2cc30412b" translate="yes" xml:space="preserve">
          <source>Note that, if a comment appears immediately next to multiple items, as in:</source>
          <target state="translated">のように、複数の項目のすぐ隣にコメントが表示されている場合は注意してください。</target>
        </trans-unit>
        <trans-unit id="579e1ef453daed542dee9b6448ed260939315131" translate="yes" xml:space="preserve">
          <source>Note that, in the &lt;a href=&quot;modtypes#specification&quot;&gt;specification&lt;/a&gt; case, the &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;s must be parenthesized if they use the with&lt;a href=&quot;modtypes#mod-constraint&quot;&gt;mod-constraint&lt;/a&gt; construct.</source>
          <target state="translated">&lt;a href=&quot;modtypes#specification&quot;&gt;仕様の&lt;/a&gt;場合、&lt;a href=&quot;modtypes#module-type&quot;&gt;モジュールタイプ&lt;/a&gt;がwith &lt;a href=&quot;modtypes#mod-constraint&quot;&gt;mod-constraint&lt;/a&gt;構文を使用する場合は、括弧で囲む必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9ecccd058b8859c03de2fd449f57787fc6750b3c" translate="yes" xml:space="preserve">
          <source>Note that, unlike type declarations, type substitution declarations are not recursive, so substitutions like the following are rejected:</source>
          <target state="translated">型宣言とは異なり、型置換宣言は再帰的ではないので、以下のような置換は拒否されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="78d522de17989d9555a8bbce2b8df8ef04eb9f91" translate="yes" xml:space="preserve">
          <source>Note the difference between these two coercions: in the case of to_c2, the type #c2 = &amp;lt; m : 'a; .. &amp;gt; as 'a is polymorphically recursive (according to the explicit recursion in the class type of c2); hence the success of applying this coercion to an object of class c0. On the other hand, in the first case, c1 was only expanded and unrolled twice to obtain &amp;lt; m : &amp;lt; m : c1; .. &amp;gt;; .. &amp;gt; (remember #c1 = &amp;lt; m : c1; .. &amp;gt;), without introducing recursion. You may also note that the type of to_c2 is #c2 -&amp;gt; c2 while the type of to_c1 is more general than #c1 -&amp;gt; c1. This is not always true, since there are class types for which some instances of #c are not subtypes of c, as explained in section &lt;a href=&quot;#s%3Abinary-methods&quot;&gt;3.16&lt;/a&gt;. Yet, for parameterless classes the coercion (_ :&amp;gt; c) is always more general than (_ : #c :&amp;gt; c).</source>
          <target state="translated">これらの2つの強制の違いに注意してください。to_c2の場合、タイプ＃c2 = &amp;lt;m： 'a; ..&amp;gt; as'aは多形的に再帰的です（c2のクラスタイプの明示的な再帰による）。したがって、この強制をクラスc0のオブジェクトに適用することに成功しました。一方、最初のケースでは、c1は2回だけ展開および展開され、&amp;lt;m：&amp;lt;m：c1;が取得されました。 ..&amp;gt;; ..&amp;gt;（＃c1 = &amp;lt;m：c1; ..&amp;gt;を思い出してください）、再帰を導入しません。 to_c2のタイプは＃c2-&amp;gt; c2であるのに対し、to_c1のタイプは＃c1-&amp;gt; c1よりも一般的であることに注意してください。セクション&lt;a href=&quot;#s%3Abinary-methods&quot;&gt;3.16で&lt;/a&gt;説明されているように、＃cの一部のインスタンスがcのサブタイプではないクラスタイプがあるため、これは常に当てはまるとは限りません。ただし、パラメーターのないクラスの場合、強制（_：&amp;gt; c）は常に（_：＃c：&amp;gt;よりも一般的です。c）。</target>
        </trans-unit>
        <trans-unit id="75c5273bc385a2bc73dec61088cee3a19dd057d4" translate="yes" xml:space="preserve">
          <source>Note the use of double underscores in Mylib__A and Mylib__B. These were chosen on purpose; the compiler uses the following heuristic when printing paths: given a path Lib__fooBar, if Lib.FooBar exists and is an alias for Lib__fooBar, then the compiler will always display Lib.FooBar instead of Lib__fooBar. This way the long Mylib__ names stay hidden and all the user sees is the nicer dot names. This is how the OCaml standard library is compiled.</source>
          <target state="translated">Mylib__AとMylib__Bではダブルアンダースコアを使用していることに注意してください。コンパイラはパスを印刷する際に以下のようなヒューリスティックな方法を使っています。Lib__fooBarというパスが与えられ、Lib.FooBarが存在し、Lib__fooBarのエイリアスである場合、コンパイラは常にLib__fooBarの代わりにLib.FooBarを表示します。このようにして、長いMylib__の名前は隠されたままで、ユーザが見るのはより良いドット名だけになります。これがOCaml標準ライブラリのコンパイル方法です。</target>
        </trans-unit>
        <trans-unit id="dd1d07e0d8f7923bb8cef98de8decf201a2336ee" translate="yes" xml:space="preserve">
          <source>Note the use of override for method times. Writing new money2 (k *. repr) instead of {&amp;lt; repr = k *. repr &amp;gt;} would not behave well with inheritance: in a subclass money3 of money2 the times method would return an object of class money2 but not of class money3 as would be expected.</source>
          <target state="translated">メソッド時間のオーバーライドの使用に注意してください。{&amp;lt;repr = k *の代わりに新しいmoney2（k *。repr）を書き込む。repr&amp;gt;}は、継承では適切に動作しません。money2のサブクラスmoney3では、timesメソッドはクラスmoney2のオブジェクトを返しますが、予想どおりクラスmoney3のオブジェクトは返しません。</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="a7c6195c71846fafbab4e4cc00dfd41c54465d1b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Lazy.force&lt;/code&gt; is not thread-safe. If you use this module in a multi-threaded program, you will need to add some locks.</source>
          <target state="translated">注： &lt;code&gt;Lazy.force&lt;/code&gt; はスレッドセーフではありません。このモジュールをマルチスレッドプログラムで使用する場合は、いくつかのロックを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="6ee1f0993f734f3d32255902fa4253dbe8464720" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;lazy_t&lt;/code&gt; is the built-in type constructor used by the compiler for the &lt;code&gt;lazy&lt;/code&gt; keyword. You should not use it directly. Always use &lt;code&gt;Lazy.t&lt;/code&gt; instead.</source>
          <target state="translated">注： &lt;code&gt;lazy_t&lt;/code&gt; は、コンパイラーが &lt;code&gt;lazy&lt;/code&gt; キーワードに使用する組み込み型コンストラクターです。直接使用しないでください。代わりに常に &lt;code&gt;Lazy.t&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="c65beeb77bdc7dc7ee42cc9da173d89eac9e501e" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;open_in&lt;/code&gt; returns a formatted input channel that efficiently reads characters in large chunks; in contrast, &lt;code&gt;from_channel&lt;/code&gt; below returns formatted input channels that must read one character at a time, leading to a much slower scanning rate.</source>
          <target state="translated">注： &lt;code&gt;open_in&lt;/code&gt; は、大きなチャンクの文字を効率的に読み取るフォーマット済みの入力チャネルを返します。対照的に、以下の &lt;code&gt;from_channel&lt;/code&gt; は、一度に1文字を読み取る必要があるフォーマット済みの入力チャネルを返すため、スキャン速度が大幅に低下します。</target>
        </trans-unit>
        <trans-unit id="fbb80132052a566980a3f39541caf9bc002b1c90" translate="yes" xml:space="preserve">
          <source>Note: Existing command line options can be redefined using this function.</source>
          <target state="translated">注意:既存のコマンドラインオプションは、この関数を使用して再定義することができます。</target>
        </trans-unit>
        <trans-unit id="f8f6141fe67a802e7e2bf4927ccb64d0289512ae" translate="yes" xml:space="preserve">
          <source>Note: For maximum backwards compatibility in Unicode mode, if the argument is not a valid UTF-8 string, this function will fall back to assuming that it is encoded in the current code page.</source>
          <target state="translated">注記:Unicode モードでの後方互換性を最大化するために、引数が有効な UTF-8 文字列でない場合、この関数は、それが現在のコードページでエンコードされていると仮定してフォールバックします。</target>
        </trans-unit>
        <trans-unit id="2ae74bcb6937d84acfff2f5cc371f0df0a9df245" translate="yes" xml:space="preserve">
          <source>Note: If lazy patterns appear in multiple cases in a pattern-matching, lazy expressions may be forced even outside of the case ultimately selected by the pattern matching. In the example above, the suspension &lt;code&gt;x&lt;/code&gt; is always computed.</source>
          <target state="translated">注：パターンマッチングでレイジーパターンが複数のケースに出現する場合、パターンマッチングによって最終的に選択されたケースの外でもレイジー式が強制される場合があります。上記の例では、サスペンション &lt;code&gt;x&lt;/code&gt; は常に計算されます。</target>
        </trans-unit>
        <trans-unit id="2d7d69b5a35fb8fdd2ec3a14decb5554cdfa109f" translate="yes" xml:space="preserve">
          <source>Note: Including the header files without first defining CAML_NAME_SPACE introduces in scope short names for most functions. Those short names are deprecated, and may be removed in the future because they usually produce clashes with names defined by other C libraries.</source>
          <target state="translated">注意:CAML_NAME_SPACE を最初に定義せずにヘッダファイルを含めると、ほとんどの関数にスコープ内の短い名前が導入されます。これらの短い名前は非推奨であり、将来的には削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="51519ebae7f9975b891bddfc046ca788658aed4d" translate="yes" xml:space="preserve">
          <source>Note: It is a &lt;em&gt;programming error&lt;/em&gt; if other kinds of exceptions are raised by &lt;code&gt;finally&lt;/code&gt;, as any exception raised in &lt;code&gt;work&amp;nbsp;()&lt;/code&gt; will be lost in the event of a &lt;a href=&quot;fun#EXCEPTIONFinally_raised&quot;&gt;&lt;code&gt;Fun.Finally_raised&lt;/code&gt;&lt;/a&gt; exception. Therefore, one should make sure to handle those inside the finally.</source>
          <target state="translated">注：これは&lt;em&gt;プログラミングエラー&lt;/em&gt;の例外の他の種類のことで提起された場合 &lt;code&gt;finally&lt;/code&gt; 任意の例外が育ちとして、 &lt;code&gt;work&amp;nbsp;()&lt;/code&gt; が発生した場合に失われる&lt;a href=&quot;fun#EXCEPTIONFinally_raised&quot;&gt; &lt;code&gt;Fun.Finally_raised&lt;/code&gt; &lt;/a&gt;例外。したがって、最終的には内部で処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="bedbf1279049e8ebd79ce828d1966e381406da84" translate="yes" xml:space="preserve">
          <source>Note: OCaml strings used to be modifiable in place, for instance via the &lt;a href=&quot;string#VALset&quot;&gt;&lt;code&gt;String.set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string#VALblit&quot;&gt;&lt;code&gt;String.blit&lt;/code&gt;&lt;/a&gt; functions described below. This usage is only possible when the compiler is put in &quot;unsafe-string&quot; mode by giving the &lt;code&gt;-unsafe-string&lt;/code&gt; command-line option. This compatibility mode makes the types &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;bytes&lt;/code&gt; (see module &lt;a href=&quot;bytes&quot;&gt;&lt;code&gt;Bytes&lt;/code&gt;&lt;/a&gt;) interchangeable so that functions expecting byte sequences can also accept strings as arguments and modify them.</source>
          <target state="translated">注：OCaml文字列は、たとえば、以下で説明する&lt;a href=&quot;string#VALset&quot;&gt; &lt;code&gt;String.set&lt;/code&gt; &lt;/a&gt;関数と&lt;a href=&quot;string#VALblit&quot;&gt; &lt;code&gt;String.blit&lt;/code&gt; &lt;/a&gt;関数を介して、その場で変更可能でした。この使用法は、コンパイラが &lt;code&gt;-unsafe-string&lt;/code&gt; コマンドラインオプションを指定して「unsafe-string」モードになっている場合にのみ可能です。この互換モードにより、 &lt;code&gt;string&lt;/code&gt; と &lt;code&gt;bytes&lt;/code&gt; の型（モジュール&lt;a href=&quot;bytes&quot;&gt; &lt;code&gt;Bytes&lt;/code&gt; を&lt;/a&gt;参照）が交換可能になり、バイトシーケンスを期待する関数も文字列を引数として受け入れて変更できるようになります。</target>
        </trans-unit>
        <trans-unit id="c72b40ee4e5477e5f7d6e7553ca34de54319049d" translate="yes" xml:space="preserve">
          <source>Note: On some systems, with interactive input, an end-of-file may be followed by more characters. However, ocamllex will not correctly handle regular expressions that contain eof followed by something else.</source>
          <target state="translated">注意:システムによっては、インタラクティブな入力では、ファイルの末尾にさらに多くの文字が続く場合があります。しかし、 ocamllex は eof の後に他の何かが続く正規表現を正しく処理しません。</target>
        </trans-unit>
        <trans-unit id="01558340b88b057d42608e1a6ec3ca0cfdf079a7" translate="yes" xml:space="preserve">
          <source>Note: The strings returned by caml_stat_strdup_to_os and caml_stat_strdup_of_os are allocated using caml_stat_alloc, so they need to be deallocated using caml_stat_free when they are no longer needed.</source>
          <target state="translated">注意:caml_stat_strdup_to_os と caml_stat_strdup_of_os が返す文字列は caml_stat_alloc を使って確保されているので、不要になったら caml_stat_free を使って deallocated する必要があります。</target>
        </trans-unit>
        <trans-unit id="7848f4c2eb8f564919b210b8bbfed2cdf5ec566d" translate="yes" xml:space="preserve">
          <source>Note: This example is on a Unix system. The exact command lines may be different on other systems.</source>
          <target state="translated">注意:この例はUnixシステムでのものです。正確なコマンドラインは他のシステムでは異なるかもしれません。</target>
        </trans-unit>
        <trans-unit id="84be470836b2d22c5aa15438ce95fd6f0d863631" translate="yes" xml:space="preserve">
          <source>Note: This is an experimental feature of OCaml: the set of APIs below, as well as their exact semantics are not final and subject to change in future releases.</source>
          <target state="translated">注意:これはOCamlの実験的な機能です:以下のAPIのセット、およびそれらの正確なセマンティクスは最終的なものではなく、将来のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="823ecd73e96dee992922fa24d09d174fea0a6e57" translate="yes" xml:space="preserve">
          <source>Note: To prevent the interpretation of a &lt;code&gt;@&lt;/code&gt; character as a pretty-printing indication, escape it with a &lt;code&gt;%&lt;/code&gt; character. Old quotation mode &lt;code&gt;@@&lt;/code&gt; is deprecated since it is not compatible with formatted input interpretation of character &lt;code&gt;'@'&lt;/code&gt;.</source>
          <target state="translated">注： &lt;code&gt;@&lt;/code&gt; 文字がプリティプリント表示として解釈されないようにするには、 &lt;code&gt;%&lt;/code&gt; 文字でエスケープします。古い引用モード &lt;code&gt;@@&lt;/code&gt; は、文字 &lt;code&gt;'@'&lt;/code&gt; のフォーマットされた入力解釈と互換性がないため、非推奨になりました。</target>
        </trans-unit>
        <trans-unit id="6d9bd6a881cbdf7f9df1e298990c77110c41a774" translate="yes" xml:space="preserve">
          <source>Note: When changing to a low-fragmentation policy, you may need to augment the &lt;code&gt;space_overhead&lt;/code&gt; setting, for example using &lt;code&gt;100&lt;/code&gt; instead of the default &lt;code&gt;80&lt;/code&gt; which is tuned for next-fit. Indeed, the difference in fragmentation behavior means that different policies will have different proportion of &quot;wasted space&quot; for a given program. Less fragmentation means a smaller heap so, for the same amount of wasted space, a higher proportion of wasted space. This makes the GC work harder, unless you relax it by increasing &lt;code&gt;space_overhead&lt;/code&gt;.</source>
          <target state="translated">注：断片化の少ないポリシーに変更する場合は、 &lt;code&gt;space_overhead&lt;/code&gt; 設定を拡張する必要がある場合があります。たとえば、next-fit用に調整されたデフォルトの &lt;code&gt;80&lt;/code&gt; の代わりに &lt;code&gt;100&lt;/code&gt; を使用します。実際、断片化の動作の違いは、ポリシーが異なれば、特定のプログラムの「無駄なスペース」の割合も異なることを意味します。断片化が少ないということはヒープが小さいことを意味するため、同じ量の無駄なスペースに対して、無駄なスペースの割合が高くなります。これにより、 &lt;code&gt;space_overhead&lt;/code&gt; を増やして緩和しない限り、GCの動作が難しくなります。</target>
        </trans-unit>
        <trans-unit id="e1c53f545ae2f49916857c5dbc74afbbb3f17b01" translate="yes" xml:space="preserve">
          <source>Note: a scanning action may often require to examine one character in advance; when this 'lookahead' character does not belong to the token read, it is stored back in the scanning buffer and becomes the next character yet to be read.</source>
          <target state="translated">この「ルックヘッド」文字がトークンの読み込みに属していない場合は、スキャンバッファに格納され、次の文字が読み込まれることになります。</target>
        </trans-unit>
        <trans-unit id="1704bf03b020589de313c230890a2e46b48b94e8" translate="yes" xml:space="preserve">
          <source>Note: all directives start with a # (sharp) symbol. This # must be typed before the directive, and must not be confused with the # prompt displayed by the interactive loop. For instance, typing #quit;; will exit the toplevel loop, but typing quit;; will result in an &amp;ldquo;unbound value quit&amp;rdquo; error.</source>
          <target state="translated">注：すべてのディレクティブは＃（シャープ）記号で始まります。この＃は、ディレクティブの前に入力する必要があり、インタラクティブループによって表示される＃プロンプトと混同しないでください。たとえば、＃quit ;;と入力します。トップレベルのループを終了しますが、quit ;;と入力します。「unboundvaluequit」エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="661bb9a4a4fadd61ccae3d7f4cea4d69fb6a3c2a" translate="yes" xml:space="preserve">
          <source>Note: all input/output functions can raise &lt;code&gt;Sys_error&lt;/code&gt; when the system calls they invoke fail.</source>
          <target state="translated">注：すべての入出力関数は、呼び出すシステムコールが失敗すると、 &lt;code&gt;Sys_error&lt;/code&gt; を発生させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="0f409c4273c4016899888e40b1686a702c39d6ff" translate="yes" xml:space="preserve">
          <source>Note: all the functions of this module (except &lt;a href=&quot;unix#VALerror_message&quot;&gt;&lt;code&gt;Unix.error_message&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unix#VALhandle_unix_error&quot;&gt;&lt;code&gt;Unix.handle_unix_error&lt;/code&gt;&lt;/a&gt;) are liable to raise the &lt;a href=&quot;unix#EXCEPTIONUnix_error&quot;&gt;&lt;code&gt;Unix.Unix_error&lt;/code&gt;&lt;/a&gt; exception whenever the underlying system call signals an error.</source>
          <target state="translated">注：このモジュールのすべての関数（&lt;a href=&quot;unix#VALerror_message&quot;&gt; &lt;code&gt;Unix.error_message&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;unix#VALhandle_unix_error&quot;&gt; &lt;code&gt;Unix.handle_unix_error&lt;/code&gt; &lt;/a&gt;を除く）は、基礎となるシステムコールがエラーを通知するたびに&lt;a href=&quot;unix#EXCEPTIONUnix_error&quot;&gt; &lt;code&gt;Unix.Unix_error&lt;/code&gt; &lt;/a&gt;例外を発生させる傾向があります。</target>
        </trans-unit>
        <trans-unit id="9881244812e43ce519dbdb2a33d7a86a78dc2b73" translate="yes" xml:space="preserve">
          <source>Note: changing the allocation policy at run-time forces a heap compaction, which is a lengthy operation unless the heap is small (e.g. at the start of the program).</source>
          <target state="translated">注意:実行時に割り当てポリシーを変更すると、ヒープが小さくない限り (プログラムの開始時など)、ヒープの圧縮が強制されます。</target>
        </trans-unit>
        <trans-unit id="8e740cc9128b3de503776a812fd3bb3f85d80f59" translate="yes" xml:space="preserve">
          <source>Note: do not use the C int type in correspondence with (int [@untagged]). This is because they often differ in size.</source>
          <target state="translated">注意:(int [@untagged])に対応してCのint型を使用しないでください。これは、サイズが異なることが多いからです。</target>
        </trans-unit>
        <trans-unit id="32f28c1f397eec585fd0b2e1caaaf11772a9b784" translate="yes" xml:space="preserve">
          <source>Note: if the program is compiled with the &lt;code&gt;-rectypes&lt;/code&gt; option, ill-founded recursive definitions of the form &lt;code&gt;let&amp;nbsp;rec&amp;nbsp;x&amp;nbsp;=&amp;nbsp;lazy&amp;nbsp;x&lt;/code&gt; or &lt;code&gt;let&amp;nbsp;rec&amp;nbsp;x&amp;nbsp;=&amp;nbsp;lazy(lazy(...(lazy&amp;nbsp;x)))&lt;/code&gt; are accepted by the type-checker and lead, when forced, to ill-formed values that trigger infinite loops in the garbage collector and other parts of the run-time system. Without the &lt;code&gt;-rectypes&lt;/code&gt; option, such ill-founded recursive definitions are rejected by the type-checker.</source>
          <target state="translated">注：プログラムがコンパイルされている場合で &lt;code&gt;-rectypes&lt;/code&gt; オプションを、フォームの悪口を設立再帰的な定義は &lt;code&gt;let&amp;nbsp;rec&amp;nbsp;x&amp;nbsp;=&amp;nbsp;lazy&amp;nbsp;x&lt;/code&gt; か &lt;code&gt;let&amp;nbsp;rec&amp;nbsp;x&amp;nbsp;=&amp;nbsp;lazy(lazy(...(lazy&amp;nbsp;x)))&lt;/code&gt; タイプによって受け入れられています-チェッカーとリードは、強制された場合、ガベージコレクターとランタイムシステムの他の部分で無限ループをトリガーする不正な形式の値になります。 &lt;code&gt;-rectypes&lt;/code&gt; オプションがないと、そのような根拠のない再帰的定義はタイプチェッカーによって拒否されます。</target>
        </trans-unit>
        <trans-unit id="ebef76f46f02ed8c6dbb4a7a51649415bd9b78c4" translate="yes" xml:space="preserve">
          <source>Note: in order to insure that the dynamically-loaded modules have access to all the libraries that are visible to the main program (and not just to the parts of those libraries that are actually used in the main program), programs using the dynlink library should be linked with -linkall.</source>
          <target state="translated">注意:動的にロードされたモジュールがメインプログラムから見えるすべてのライブラリにアクセスできるようにするために (メインプログラムで実際に使用されているライブラリの部分だけでなく)、dynlink ライブラリを使用するプログラムは -linkall でリンクされている必要があります。</target>
        </trans-unit>
        <trans-unit id="38ff267a2f14d6dd07cded0766c39d2aeb6bc63e" translate="yes" xml:space="preserve">
          <source>Note: in the case of &lt;code&gt;global_substitute&lt;/code&gt; and &lt;code&gt;substitute_first&lt;/code&gt;, a call to &lt;code&gt;matched_string&lt;/code&gt; is only valid within the &lt;code&gt;subst&lt;/code&gt; argument, not after &lt;code&gt;global_substitute&lt;/code&gt; or &lt;code&gt;substitute_first&lt;/code&gt; returns.</source>
          <target state="translated">注：の場合に &lt;code&gt;global_substitute&lt;/code&gt; と &lt;code&gt;substitute_first&lt;/code&gt; 、への呼び出し &lt;code&gt;matched_string&lt;/code&gt; は内でのみ有効です &lt;code&gt;subst&lt;/code&gt; ではないの後に、引数 &lt;code&gt;global_substitute&lt;/code&gt; または &lt;code&gt;substitute_first&lt;/code&gt; 戻ります。</target>
        </trans-unit>
        <trans-unit id="922b543ff896ef77cd9d8044969360c9a53c3cbf" translate="yes" xml:space="preserve">
          <source>Note: in the interactive system, when input is read from &lt;a href=&quot;stdlib#VALstdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;, the newline character that triggers evaluation is part of the input; thus, the scanning specifications must properly skip this additional newline character (for instance, simply add a &lt;code&gt;'\n'&lt;/code&gt; as the last character of the format string).</source>
          <target state="translated">注：対話型システムでは、入力が&lt;a href=&quot;stdlib#VALstdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt;から読み取られると、評価をトリガーする改行文字が入力の一部になります。したがって、スキャン仕様では、この追加の改行文字を適切にスキップする必要があります（たとえば、フォーマット文字列の最後の文字として &lt;code&gt;'\n'&lt;/code&gt; を追加するだけです）。</target>
        </trans-unit>
        <trans-unit id="145e7cd4d750ab522e65fe8e15a2f8018a1e2e0d" translate="yes" xml:space="preserve">
          <source>Note: installation of signal handlers is performed via the functions &lt;a href=&quot;sys#VALsignal&quot;&gt;&lt;code&gt;Sys.signal&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sys#VALset_signal&quot;&gt;&lt;code&gt;Sys.set_signal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">注：シグナルハンドラーのインストールは、関数&lt;a href=&quot;sys#VALsignal&quot;&gt; &lt;code&gt;Sys.signal&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;sys#VALset_signal&quot;&gt; &lt;code&gt;Sys.set_signal&lt;/code&gt; を&lt;/a&gt;介して実行されます。</target>
        </trans-unit>
        <trans-unit id="629c5048579fb0ed4f8a77f6a5cbc67a5d0b3404" translate="yes" xml:space="preserve">
          <source>Note: it is not recommended to use warning sets (i.e. letters) as arguments to -warn-error in production code, because this can break your build when future versions of OCaml add some new warnings.</source>
          <target state="translated">注意:プロダクションコードで警告セット(文字など)を-warn-errorの引数として使用することは推奨されていません。</target>
        </trans-unit>
        <trans-unit id="443e1ada797e5067adc60f24f10b243b6714e1e3" translate="yes" xml:space="preserve">
          <source>Note: never use &lt;code&gt;print_flush&lt;/code&gt; in the normal course of a pretty-printing routine, since the pretty-printer uses a complex buffering machinery to properly indent the output; manually flushing those buffers at random would conflict with the pretty-printer strategy and result to poor rendering.</source>
          <target state="translated">注：プリティプリンターは複雑なバッファリング機構を使用して出力を適切にインデントするため、プリティプリントルーチンの通常の過程では &lt;code&gt;print_flush&lt;/code&gt; を使用しないでください。これらのバッファーを手動でランダムにフラッシュすると、プリティプリンター戦略と競合し、レンダリングが低下します。</target>
        </trans-unit>
        <trans-unit id="9341c4536efd6e856d0cfcbf40db0f74c45c131a" translate="yes" xml:space="preserve">
          <source>Note: printing within tabulation box is line directed, so arbitrary line splitting inside a tabulation box leads to poor rendering. Yet, controlled use of tabulation boxes allows simple printing of columns within module &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">注：集計ボックス内での印刷は行方向であるため、集計ボックス内で任意の行を分割すると、レンダリングが不十分になります。それでも、集計ボックスの制御された使用により、モジュール&lt;a href=&quot;format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt;内の列の簡単な印刷が可能になります。</target>
        </trans-unit>
        <trans-unit id="d9834335cf6fe5fc53b95c18382af756506e19d5" translate="yes" xml:space="preserve">
          <source>Note: the acquire and release functions described above were introduced in OCaml 3.12. Older code uses the following historical names, declared in &amp;lt;caml/signals.h&amp;gt;:</source>
          <target state="translated">注：上記の取得および解放機能は、OCaml3.12で導入されました。古いコードは、&amp;lt;caml /signals.h&amp;gt;で宣言されている次の履歴名を使用しています。</target>
        </trans-unit>
        <trans-unit id="2177e9bf34eb19b28eb32c96470882b643de2040" translate="yes" xml:space="preserve">
          <source>Note: the argument to &lt;code&gt;regexp&lt;/code&gt; is usually a string literal. In this case, any backslash character in the regular expression must be doubled to make it past the OCaml string parser. For example, the following expression:</source>
          <target state="translated">注： &lt;code&gt;regexp&lt;/code&gt; の引数は通常、文字列リテラルです。この場合、正規表現のバックスラッシュ文字を2倍にして、OCaml文字列パーサーを通過させる必要があります。たとえば、次の式：</target>
        </trans-unit>
        <trans-unit id="ffd47f5e6d4b6f57e31724916a1771922f810447" translate="yes" xml:space="preserve">
          <source>Note: the finalize, compare, hash, serialize and deserialize functions attached to custom block descriptors must never trigger a garbage collection. Within these functions, do not call any of the OCaml allocation functions, and do not perform a callback into OCaml code. Do not use CAMLparam to register the parameters to these functions, and do not use CAMLreturn to return the result.</source>
          <target state="translated">注意:カスタムブロック記述子に接続されたfinalize、compare、hash、serialize、deserialize関数は、決してガベージコレクションをトリガしてはなりません。これらの関数内では、OCaml のアロケーション関数を呼び出したり、OCaml コードへのコールバックを実行したりしてはいけません。これらの関数のパラメータを登録するために CAMLparam を使用したり、結果を返すために CAMLreturn を使用したりしてはいけません。</target>
        </trans-unit>
        <trans-unit id="2fa124181f0ab52f95d5aba93b0fc5a2ffbf20f4" translate="yes" xml:space="preserve">
          <source>Note: the notions of space and line splitting are abstract for the pretty-printing engine, since those notions can be completely redefined by the programmer. However, in the pretty-printer default setting, ``output a space'' simply means printing a space character (ASCII code 32) and ``split the line'' means printing a newline character (ASCII code 10).</source>
          <target state="translated">注意:スペースと行分割の概念は pretty-printing エンジンにとっては抽象的なものです。しかし、 pretty-printer のデフォルト設定では、 ``output a space'' は単にスペース文字 (ASCII コード 32)を出力することを意味し、 ``split the line'' は改行文字 (ASCII コード 10)を出力することを意味しています。</target>
        </trans-unit>
        <trans-unit id="8057d5d098672ea84c975196f3af91fed42a2aa5" translate="yes" xml:space="preserve">
          <source>Note: the operators &amp;amp;&amp;amp;, ||, and ~- are handled specially and it is not advisable to change their meaning.</source>
          <target state="translated">注：演算子&amp;amp;&amp;amp;、||、および〜-は特別に処理されるため、意味を変更することはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="7efcff7406c86de78d66a3b54bdcef50f38f8039" translate="yes" xml:space="preserve">
          <source>Note: this API is EXPERIMENTAL. It may change without prior notice.</source>
          <target state="translated">注意:このAPIは実験的なものです。予告なく変更されることがあります。</target>
        </trans-unit>
        <trans-unit id="6965dbae3f43f8571341ee41d021ab34917b0487" translate="yes" xml:space="preserve">
          <source>Note: this is not the normal way to output a new line; the preferred method is using break hints within a vertical pretty-printing box.</source>
          <target state="translated">注意:これは、改行を出力する通常の方法ではありません。</target>
        </trans-unit>
        <trans-unit id="c7ebc2b8878898c4c60d71b3c20e680a573cda23" translate="yes" xml:space="preserve">
          <source>Note: this only applies to the native compiler. So whenever you use any of these methods, you have to provide an alternative byte-code stub that ignores all the special annotations.</source>
          <target state="translated">注意:これはネイティブコンパイラにのみ適用されます。そのため、これらのメソッドを使用する際には、特別なアノテーションをすべて無視した代替のバイトコードスタブを提供しなければなりません。</target>
        </trans-unit>
        <trans-unit id="87c9f2b925633b8f6e73b9bf63c5cdc7777edeca" translate="yes" xml:space="preserve">
          <source>Note: this possibility is offered only for backward compatibility with older versions of OCaml and will be removed in a future version. New code should use byte sequences and the Bytes.set function.</source>
          <target state="translated">注意:この可能性は古いバージョンのOCamlとの下位互換性のためだけに提供されており、将来のバージョンでは削除される予定です。新しいコードは、バイトシーケンスとBytes.set関数を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="4d8d829c25ab6089d7e4980f899718094fb71afc" translate="yes" xml:space="preserve">
          <source>Note: when a label declaration is followed by a semi-colon, attributes can also be put after the semi-colon (in which case they are merged to those specified before).</source>
          <target state="translated">注意:ラベル宣言の後にセミコロンが続く場合、属性をセミコロンの後に置くこともできます (その場合、前に指定されたものにマージされます)。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="d5e45a48a978d6899712bd076f72479aeea810fa" translate="yes" xml:space="preserve">
          <source>Nothing happens if &lt;code&gt;d&lt;/code&gt; is smaller than 2.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; が2より小さい場合、何も起こりません。</target>
        </trans-unit>
        <trans-unit id="39fb7c03e6cb136de7fbdb71a619368064c85b64" translate="yes" xml:space="preserve">
          <source>Nothing happens if &lt;code&gt;max&lt;/code&gt; is smaller than 2.</source>
          <target state="translated">&lt;code&gt;max&lt;/code&gt; が2より小さい場合、何も起こりません。</target>
        </trans-unit>
        <trans-unit id="dc088a60c877ce62f962886fe65bf44f1be80800" translate="yes" xml:space="preserve">
          <source>Notice that it is not possible to pass options to ocamlrun when invoking a.out directly.</source>
          <target state="translated">a.out を直接起動した場合、オプションを ocamlrun に渡すことができないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="74aaf1392791cdacd5b251b350a4fa759d0daf50" translate="yes" xml:space="preserve">
          <source>Notice that our function call above prints &amp;ldquo;lazy_two evaluation&amp;rdquo; and then returns the plain value of the computation.</source>
          <target state="translated">上記の関数呼び出しは「lazy_twoevaluation」を出力してから、計算のプレーン値を返すことに注意してください。</target>
        </trans-unit>
        <trans-unit id="4c42130e4cbfad9b1ab31f04d64c0912792bf5e1" translate="yes" xml:space="preserve">
          <source>Notice that the bytecode libraries unix.cma and threads.cma must be given twice: when building the runtime system (so that ocamlc knows which C primitives are required) and also when building the bytecode executable (so that the bytecode from unix.cma and threads.cma is actually linked in).</source>
          <target state="translated">バイトコードライブラリunix.cmaとthreads.cmaは2回与えなければならないことに注意してください:ランタイムシステムを構築するとき(ocamlcがどのCプリミティブが必要かを知るため)と、バイトコード実行ファイルを構築するとき(unix.cmaとthreads.cmaのバイトコードが実際にリンクされるため)です。</target>
        </trans-unit>
        <trans-unit id="6f0646640caf022897bba768e601eae5583de16c" translate="yes" xml:space="preserve">
          <source>Now for a real symbolic processing, we define the derivative of an expression with respect to a variable dv:</source>
          <target state="translated">ここで、実際の記号処理のために、変数 dv に関する式の微分を定義します。</target>
        </trans-unit>
        <trans-unit id="d31c772d9b3d93fe10a1d16923ec1381b4e0e40a" translate="yes" xml:space="preserve">
          <source>Now if we annotate the arguments and result with [@unboxed], the native-code compiler will be able to avoid all these allocations:</source>
          <target state="translated">これで、引数と結果を [@unboxed]でアノテーションすると、ネイティブコードのコンパイラはこれらのすべてのアノテーションを回避できるようになりました。</target>
        </trans-unit>
        <trans-unit id="4c9da36ea65d19919b99ea34d11ca3b1c7c4a4a7" translate="yes" xml:space="preserve">
          <source>Now if we look at the value of lazy_two, we see that it is not displayed as &amp;lt;lazy&amp;gt; anymore but as lazy 2.</source>
          <target state="translated">ここで、lazy_twoの値を見ると、&amp;lt;lazy&amp;gt;としてではなく、lazy2として表示されていることがわかります。</target>
        </trans-unit>
        <trans-unit id="e70cad05eff4f060c1122a9df879ce632eabd808" translate="yes" xml:space="preserve">
          <source>Now, here is a sample OCaml program prog.ml that uses the curses module:</source>
          <target state="translated">さて、ここではcursesモジュールを使用したOCamlのサンプルプログラムprog.mlを紹介します。</target>
        </trans-unit>
        <trans-unit id="bb1a9455d741ea437460b8735fa1fd8568d51cbd" translate="yes" xml:space="preserve">
          <source>Now, we can use the two functions fib and format_result in any C program, just like regular C functions. Just remember to call caml_startup (or caml_startup_exn) once before.</source>
          <target state="translated">これで、どのような C プログラムでも、通常の C 関数と同じように、fib と format_result の 2 つの関数を使うことができるようになりました。ただ、caml_startup (または caml_startup_exn)を前に一度だけ呼び出すことを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="3138d7df51fb63c0581ea81498fd68c3e05c37c6" translate="yes" xml:space="preserve">
          <source>Number is 0.0 or -0.0</source>
          <target state="translated">数値は0.0または-0.0</target>
        </trans-unit>
        <trans-unit id="599fcc81bb79a4df28a99bc27dc454bdb406e359" translate="yes" xml:space="preserve">
          <source>Number is positive or negative infinity</source>
          <target state="translated">数は正負の無限大</target>
        </trans-unit>
        <trans-unit id="dd6a12894e1886f16551dce8aa6a476046e0e378" translate="yes" xml:space="preserve">
          <source>Number of bindings present in the table. Same value as returned by &lt;a href=&quot;hashtbl#VALlength&quot;&gt;&lt;code&gt;Hashtbl.length&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">テーブルに存在するバインディングの数。&lt;a href=&quot;hashtbl#VALlength&quot;&gt; &lt;code&gt;Hashtbl.length&lt;/code&gt; &lt;/a&gt;によって返される値と同じ値。</target>
        </trans-unit>
        <trans-unit id="6c993eaebae88d7a870c6aedb7b2959b80e3c4ac" translate="yes" xml:space="preserve">
          <source>Number of bits per character (5-8).</source>
          <target state="translated">1文字あたりのビット数(5~8)。</target>
        </trans-unit>
        <trans-unit id="556c7d37711ec6f2f70fe3dcea838b8ca1371010" translate="yes" xml:space="preserve">
          <source>Number of blocks in the free list.</source>
          <target state="translated">フリーリストのブロック数。</target>
        </trans-unit>
        <trans-unit id="b30e61fc6036da5db3f139d2340ea9277079b7a3" translate="yes" xml:space="preserve">
          <source>Number of buckets in the table.</source>
          <target state="translated">テーブルのバケツの数。</target>
        </trans-unit>
        <trans-unit id="fd43d1f40b17a39ffbd688d74199162e00feb899" translate="yes" xml:space="preserve">
          <source>Number of contiguous pieces of memory that make up the major heap.</source>
          <target state="translated">メジャーヒープを構成するメモリの連続した部分の数。</target>
        </trans-unit>
        <trans-unit id="22bfd01520799f6fb0b893646db43e4eff4024a4" translate="yes" xml:space="preserve">
          <source>Number of heap compactions since the program was started.</source>
          <target state="translated">プログラムが開始されてからのヒープ圧縮の回数。</target>
        </trans-unit>
        <trans-unit id="a3275a16ef5f550e3a9777e377a1e501bfdab390" translate="yes" xml:space="preserve">
          <source>Number of links</source>
          <target state="translated">リンク数</target>
        </trans-unit>
        <trans-unit id="ea1a2280ac441cab2cdb5c0495373425c8df6602" translate="yes" xml:space="preserve">
          <source>Number of live blocks in the major heap.</source>
          <target state="translated">メジャーヒープ内のライブブロックの数。</target>
        </trans-unit>
        <trans-unit id="f456114fcb5877ccbceb91eb404b219b9ce44ade" translate="yes" xml:space="preserve">
          <source>Number of major collection cycles completed since the program was started.</source>
          <target state="translated">プログラム開始以降に完了した主要な収集サイクルの数</target>
        </trans-unit>
        <trans-unit id="9386df61202e08b36cb678baacc9b23f2a02d67b" translate="yes" xml:space="preserve">
          <source>Number of minor collections since the program was started.</source>
          <target state="translated">番組開始以来のマイナーコレクション数</target>
        </trans-unit>
        <trans-unit id="809a46ad96dee431d9a0e29595d29eae99894471" translate="yes" xml:space="preserve">
          <source>Number of stop bits (1-2).</source>
          <target state="translated">ストップビット数(1-2)。</target>
        </trans-unit>
        <trans-unit id="68d3ddb5d0c96281ae43ec9c22a0b4e3422e79bf" translate="yes" xml:space="preserve">
          <source>Number of wasted words due to fragmentation. These are 1-words free blocks placed between two live blocks. They are not available for allocation.</source>
          <target state="translated">断片化による無駄な単語の数。2つのライブブロックの間に配置された1ワードフリーブロックです。割り当てには利用できません。</target>
        </trans-unit>
        <trans-unit id="ce81b5c3bd146557576eb8ed07acd1dffea0dab3" translate="yes" xml:space="preserve">
          <source>Number of words allocated in the major heap, including the promoted words, since the program was started.</source>
          <target state="translated">プログラムが開始されてから、促進語を含むメジャーヒープに割り当てられた語数。</target>
        </trans-unit>
        <trans-unit id="d5ca08671f1b43ba25ac654a59ea877d2a2b67a5" translate="yes" xml:space="preserve">
          <source>Number of words allocated in the minor heap since the program was started.</source>
          <target state="translated">プログラムを開始してからマイナーヒープに割り当てられた単語数。</target>
        </trans-unit>
        <trans-unit id="2252886aac21fa9ff4a9c573d75468a53aea2f8b" translate="yes" xml:space="preserve">
          <source>Number of words allocated in the minor heap since the program was started. This number is accurate in byte-code programs, but only an approximation in programs compiled to native code.</source>
          <target state="translated">プログラムが開始されてからマイナーヒープに割り当てられたワード数。この数値はバイトコードのプログラムでは正確ですが、ネイティブコードにコンパイルされたプログラムでは近似値に過ぎません。</target>
        </trans-unit>
        <trans-unit id="f7984519fd15afeac8c64ab5080cc953cb9c00a2" translate="yes" xml:space="preserve">
          <source>Number of words allocated in the minor heap that survived a minor collection and were moved to the major heap since the program was started.</source>
          <target state="translated">マイナーヒープに割り当てられた単語のうち、マイナーコレクションを生き残り、プログラムが開始されてからメジャーヒープに移動された単語の数。</target>
        </trans-unit>
        <trans-unit id="c8f31dc5c12c1a7f06ec7bd177c5b77d43639c8d" translate="yes" xml:space="preserve">
          <source>Number of words in the free list.</source>
          <target state="translated">フリーリストの単語数。</target>
        </trans-unit>
        <trans-unit id="89158a98cc97e9ec991a351e0adf4b876875a73a" translate="yes" xml:space="preserve">
          <source>Number of words of live data in the major heap, including the header words.</source>
          <target state="translated">メジャーヒープ内のライブデータのワード数(ヘッダーワードを含む)。</target>
        </trans-unit>
        <trans-unit id="4497ca18a980559e81799d511efa2fbf2cfc2a06" translate="yes" xml:space="preserve">
          <source>Number very close to 0.0, has reduced precision</source>
          <target state="translated">0.0に非常に近い数値で、精度が低下しています。</target>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="7a33aed24260554ed4044e957096dba2b5814942" translate="yes" xml:space="preserve">
          <source>OCAMLLIB</source>
          <target state="translated">OCAMLLIB</target>
        </trans-unit>
        <trans-unit id="18f162a99ff8d53ff64a6b4e151cb31d5e551861" translate="yes" xml:space="preserve">
          <source>OCAMLPARAM (environment variable)</source>
          <target state="translated">オーカムパラム</target>
        </trans-unit>
        <trans-unit id="63bde53850374ed2ceaca560296ca5ae4288cfc9" translate="yes" xml:space="preserve">
          <source>OCAMLRUNPARAM</source>
          <target state="translated">OCAMLRUNPARAM</target>
        </trans-unit>
        <trans-unit id="5a645a796dc3a615a92ec7a9d69a83018587cfd3" translate="yes" xml:space="preserve">
          <source>OCAMLTOP_INCLUDE_PATH</source>
          <target state="translated">OCAMLTOP_INCLUDE_PATH</target>
        </trans-unit>
        <trans-unit id="8d2f44eaaa8da1e94f7c788d8bdd29ded4da06e4" translate="yes" xml:space="preserve">
          <source>OCAMLTOP_UTF_8</source>
          <target state="translated">OCAMLTOP_UTF_8</target>
        </trans-unit>
        <trans-unit id="ad1263844890ea6d4fa757c36f64dd4aa02ae452" translate="yes" xml:space="preserve">
          <source>OCAML_EVENTLOG_ENABLED can be set to the p flag in order to start the program with event collection paused.</source>
          <target state="translated">OCAML_EVENTLOG_ENABLEDは、イベント収集を一時停止した状態でプログラムを開始するために、pフラグに設定することができます。</target>
        </trans-unit>
        <trans-unit id="5452f25317c588b2d021a1ead667fb17370d1d55" translate="yes" xml:space="preserve">
          <source>OCAML_FLEXLINK</source>
          <target state="translated">OCAML_FLEXLINK</target>
        </trans-unit>
        <trans-unit id="180089a275079837ea5e6f4afd0b87d27e4469c6" translate="yes" xml:space="preserve">
          <source>OCAML_FLEXLINK (environment variable)</source>
          <target state="translated">OCAML_FLEXLINK (環境変数)</target>
        </trans-unit>
        <trans-unit id="0cdddb7074ce2b9a9f470e52afd10a9b95816171" translate="yes" xml:space="preserve">
          <source>OCaml allows us to defer some computation until later when we need the result of that computation.</source>
          <target state="translated">OCamlでは、計算結果が必要になったときまで、いくつかの計算を延期することができます。</target>
        </trans-unit>
        <trans-unit id="40aa7560087d20b8f8199f53d34735d850d308b1" translate="yes" xml:space="preserve">
          <source>OCaml code executing in the traditional toplevel system uses the bytecode interpreter. When increased performance is required, or for testing programs that will only execute correctly when compiled to native code, the &lt;em&gt;native toplevel&lt;/em&gt; may be used instead.</source>
          <target state="translated">従来のトップレベルシステムで実行されるOCamlコードは、バイトコードインタープリターを使用します。パフォーマンスの向上が必要な場合、またはネイティブコードにコンパイルされた場合にのみ正しく実行されるプログラムをテストする場合は、代わりに&lt;em&gt;ネイティブトップレベル&lt;/em&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="267c01d6c4260bac5e8f28a01de2593eca32db2c" translate="yes" xml:space="preserve">
          <source>OCaml has no built-in notion of variable &amp;ndash; identifiers whose current value can be changed by assignment. (The let binding is not an assignment, it introduces a new identifier with a new scope.) However, the standard library provides references, which are mutable indirection cells, with operators ! to fetch the current contents of the reference and := to assign the contents. Variables can then be emulated by let-binding a reference. For instance, here is an in-place insertion sort over arrays:</source>
          <target state="translated">OCamlには変数の概念が組み込まれていません&amp;ndash;割り当てによって現在の値を変更できる識別子。（letバインディングは割り当てではなく、新しいスコープを持つ新しい識別子を導入します。）ただし、標準ライブラリは、演算子を使用して、変更可能な間接セルである参照を提供します。参照の現在の内容をフェッチし、：=で内容を割り当てます。次に、参照をlet-bindingすることにより、変数をエミュレートできます。たとえば、配列に対するインプレース挿入ソートは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="5cb3adc8841417401cbe5cbf1dccabafc62d9c42" translate="yes" xml:space="preserve">
          <source>OCaml integers (signed, 31 bits on 32-bit architectures, 63 bits on 64-bit architectures) (&lt;a href=&quot;bigarray#TYPEint_elt&quot;&gt;&lt;code&gt;Bigarray.int_elt&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">OCaml整数（符号付き、32ビットアーキテクチャでは31ビット、64ビットアーキテクチャでは63ビット）（&lt;a href=&quot;bigarray#TYPEint_elt&quot;&gt; &lt;code&gt;Bigarray.int_elt&lt;/code&gt; &lt;/a&gt;）、</target>
        </trans-unit>
        <trans-unit id="64a9ccb34887b4bee6ea9726429d33718de72371" translate="yes" xml:space="preserve">
          <source>OCaml is a functional language: functions in the full mathematical sense are supported and can be passed around freely just as any other piece of data. For instance, here is a deriv function that takes any float function as argument and returns an approximation of its derivative function:</source>
          <target state="translated">OCaml は関数型言語です:完全な数学的意味での関数がサポートされており、他のデータと同じように自由に渡すことができます。例えば、ここに任意の float 関数を引数にとり、その派生関数の近似値を返す派生関数があります。</target>
        </trans-unit>
        <trans-unit id="3ef8c1d2377beafebd9185056587e4432d10a17d" translate="yes" xml:space="preserve">
          <source>OCaml provides exceptions for signalling and handling exceptional conditions. Exceptions can also be used as a general-purpose non-local control structure, although this should not be overused since it can make the code harder to understand. Exceptions are declared with the exception construct, and signalled with the raise operator. For instance, the function below for taking the head of a list uses an exception to signal the case where an empty list is given.</source>
          <target state="translated">OCamlは、シグナリングや例外的な状態を処理するための例外を提供しています。例外は汎用的な非ローカル制御構造として使用することもできますが、これはコードを理解しにくくする可能性があるため、過度に使用すべきではありません。例外は例外構造体で宣言し、raise演算子でシグナリングします。例えば、リストの先頭を取るための以下の関数は、空のリストが与えられた場合に例外を使用してシグナルを出しています。</target>
        </trans-unit>
        <trans-unit id="5bb9dff10bdb65bfb239e824ad6d8af0b7cc9004" translate="yes" xml:space="preserve">
          <source>OCaml runs on several operating systems. The parts of this manual that are specific to one operating system are presented as shown below:</source>
          <target state="translated">OCamlはいくつかのオペレーティングシステム上で動作します。本マニュアルでは、あるオペレーティングシステムに特有の部分を以下のように紹介しています。</target>
        </trans-unit>
        <trans-unit id="1726ed3129ec43182a952dcd0e32f27c1495a2bf" translate="yes" xml:space="preserve">
          <source>OCaml source files and object files (.cmo, .cmx, .ml) comprising the OCaml part of the library;</source>
          <target state="translated">ライブラリのOCaml部分を構成するOCamlソースファイルとオブジェクトファイル(.cmo,.cmx,.ml)。</target>
        </trans-unit>
        <trans-unit id="f9b33a87ea85672b2f3dc3cc175ebdefe40c9d34" translate="yes" xml:space="preserve">
          <source>OCaml supports the assert construct to check debugging assertions. The expression assert&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; and returns () if &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates to true. If it evaluates to false the exception Assert_failure is raised with the source file name and the location of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; as arguments. Assertion checking can be turned off with the -noassert compiler option. In this case, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is not evaluated at all.</source>
          <target state="translated">OCamlは、デバッグアサーションをチェックするためのassertコンストラクトをサポートしています。式&lt;a href=&quot;#expr&quot;&gt;assertexpr&lt;/a&gt;は、式&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;を評価し、&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;がtrueと評価された場合は（）を返します。falseと評価された場合、例外Assert_failureは、ソースファイル名と&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;の場所を引数として発生します。アサーションチェックは、-noassertコンパイラオプションを使用してオフにできます。この場合、&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;はまったく評価されません。</target>
        </trans-unit>
        <trans-unit id="6c85e2232603a9909d0b7ff1b3926fe7e6d893e4" translate="yes" xml:space="preserve">
          <source>OCaml type</source>
          <target state="translated">OCaml型</target>
        </trans-unit>
        <trans-unit id="62d72b1edf8e07e587e3d50ac25c27ae51c1a8cd" translate="yes" xml:space="preserve">
          <source>OCaml's floating-point numbers follow the IEEE 754 standard, using double precision (64 bits) numbers. Floating-point operations never raise an exception on overflow, underflow, division by zero, etc. Instead, special IEEE numbers are returned as appropriate, such as &lt;code&gt;infinity&lt;/code&gt; for &lt;code&gt;1.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt;, &lt;code&gt;neg_infinity&lt;/code&gt; for &lt;code&gt;-1.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt;, and &lt;code&gt;nan&lt;/code&gt; ('not a number') for &lt;code&gt;0.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt;. These special numbers then propagate through floating-point computations as expected: for instance, &lt;code&gt;1.0&amp;nbsp;/.&amp;nbsp;infinity&lt;/code&gt; is &lt;code&gt;0.0&lt;/code&gt;, and any arithmetic operation with &lt;code&gt;nan&lt;/code&gt; as argument returns &lt;code&gt;nan&lt;/code&gt; as result.</source>
          <target state="translated">OCamlの浮動小数点数は、倍精度（64ビット）数を使用して、IEEE754標準に準拠しています。浮動小数点演算のような、その代わりに、特別なIEEE番号が適宜戻される等、ゼロによるオーバーフロー、アンダーフロー、分割に例外が発生したことがない &lt;code&gt;infinity&lt;/code&gt; のために &lt;code&gt;1.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt; 、 &lt;code&gt;neg_infinity&lt;/code&gt; ため &lt;code&gt;-1.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt; 、および &lt;code&gt;0.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt; の場合は &lt;code&gt;nan&lt;/code&gt; （「数値ではない」）。 0.0。これらの特殊な数値は、期待どおりに浮動小数点計算を介して伝播します &lt;code&gt;1.0&amp;nbsp;/.&amp;nbsp;infinity&lt;/code&gt; たとえば、1.0 /。無限大は &lt;code&gt;0.0&lt;/code&gt; であり、引数として &lt;code&gt;nan&lt;/code&gt; を使用する算術演算は、結果として &lt;code&gt;nan&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="bd9ec7fcee833e36e4b14ae69e1e560823d2194a" translate="yes" xml:space="preserve">
          <source>OCamldoc calls the OCaml type-checker to obtain type information. The following options impact the type-checking phase. They have the same meaning as for the ocamlc and ocamlopt commands.</source>
          <target state="translated">OCamldoc は OCaml のタイプチェッカーを呼び出してタイプ情報を取得します。以下のオプションは、型チェックのフェーズに影響を与えます。これらは ocamlc および ocamlopt コマンドと同じ意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="e9fd7b104be92b2bbccb12043665773616dd39a8" translate="yes" xml:space="preserve">
          <source>OCamldoc can associate comments to some elements of the language encountered in the source files. The association is made according to the locations of comments with respect to the language elements. The locations of comments in .mli and .ml files are different.</source>
          <target state="translated">OCamldocは、ソースファイルで遭遇した言語のいくつかの要素にコメントを関連付けることができます。この関連付けは、言語要素に対するコメントの位置に応じて行われます。.mliファイルと.mlファイルのコメントの位置は異なります。</target>
        </trans-unit>
        <trans-unit id="faec01ad8468873527336baad11c51145d082115" translate="yes" xml:space="preserve">
          <source>OCamldoc can produce documentation in various formats: HTML, L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X, TeXinfo, Unix man pages, and dot dependency graphs. Moreover, users can add their own custom generators, as explained in section &lt;a href=&quot;#s%3Aocamldoc-custom-generators&quot;&gt;16.3&lt;/a&gt;.</source>
          <target state="translated">OCamldocは、HTML、L &lt;sup&gt;A&lt;/sup&gt; T &lt;sub&gt;E&lt;/sub&gt; X、TeXinfo、Unixのマニュアルページ、ドット依存関係グラフなど、さまざまな形式のドキュメントを作成できます。さらに、セクション&lt;a href=&quot;#s%3Aocamldoc-custom-generators&quot;&gt;16.3で&lt;/a&gt;説明されているように、ユーザーは独自のカスタムジェネレーターを追加できます。</target>
        </trans-unit>
        <trans-unit id="4a97a33abb490cfa006083e0758a66c65ccefd2d" translate="yes" xml:space="preserve">
          <source>OCamldoc is invoked via the command ocamldoc, as follows:</source>
          <target state="translated">OCamldocは、以下のようにOCAMldocコマンドで起動します。</target>
        </trans-unit>
        <trans-unit id="4a9e742b8c79265cdf1d7a881feb63c658daf697" translate="yes" xml:space="preserve">
          <source>OCamldoc operates in two steps:</source>
          <target state="translated">OCamldocは2つのステップで動作します。</target>
        </trans-unit>
        <trans-unit id="62d31081ef8855113f2a0517703c8269e167e955" translate="yes" xml:space="preserve">
          <source>OPAM switches will be provided for Spacetime-configured compilers.</source>
          <target state="translated">Spacetime-configured compilersにはOPAMスイッチが用意されます。</target>
        </trans-unit>
        <trans-unit id="cdb8f90af03d5b6035972034e7db2381c61fb84c" translate="yes" xml:space="preserve">
          <source>Obj</source>
          <target state="translated">Obj</target>
        </trans-unit>
        <trans-unit id="72a83add2c5ede877c10d23f302d3e17accbadab" translate="yes" xml:space="preserve">
          <source>Objects</source>
          <target state="translated">Objects</target>
        </trans-unit>
        <trans-unit id="7a7417369b52b8eb7878a369c0569d594dbf4af1" translate="yes" xml:space="preserve">
          <source>Objects are composed of a hidden internal state which is a record of instance variables, and a set of methods for accessing and modifying these variables. The structure of an object is described by the toplevel class that created it.</source>
          <target state="translated">オブジェクトは、インスタンス変数の記録である隠れた内部状態と、その変数にアクセスして変更するためのメソッドのセットで構成されています。オブジェクトの構造は、そのオブジェクトを作成したトップレベルクラスによって記述されます。</target>
        </trans-unit>
        <trans-unit id="7d201edcc8c7a34735ba42eb0dde4de7ae96dbd1" translate="yes" xml:space="preserve">
          <source>Objects are represented as blocks with tag Object_tag. The first field of the block refers to the object&amp;rsquo;s class and associated method suite, in a format that cannot easily be exploited from C. The second field contains a unique object ID, used for comparisons. The remaining fields of the object contain the values of the instance variables of the object. It is unsafe to access directly instance variables, as the type system provides no guarantee about the instance variables contained by an object.</source>
          <target state="translated">オブジェクトは、タグObject_tagを持つブロックとして表されます。ブロックの最初のフィールドは、Cから簡単に利用できない形式で、オブジェクトのクラスと関連するメソッドスイートを参照します。2番目のフィールドには、比較に使用される一意のオブジェクトIDが含まれます。オブジェクトの残りのフィールドには、オブジェクトのインスタンス変数の値が含まれています。型システムはオブジェクトに含まれるインスタンス変数について保証を提供しないため、インスタンス変数に直接アクセスすることは安全ではありません。</target>
        </trans-unit>
        <trans-unit id="b4792dc04542c4957b7299aef2bdc36a1978fd6e" translate="yes" xml:space="preserve">
          <source>Objects can also be cloned, whether they are functional or imperative. The library function Oo.copy makes a shallow copy of an object. That is, it returns a new object that has the same methods and instance variables as its argument. The instance variables are copied but their contents are shared. Assigning a new value to an instance variable of the copy (using a method call) will not affect instance variables of the original, and conversely. A deeper assignment (for example if the instance variable is a reference cell) will of course affect both the original and the copy.</source>
          <target state="translated">オブジェクトは、機能的なものでも命令的なものでも、クローンを作成することができます。ライブラリ関数 Oo.copy は、オブジェクトの浅いコピーを行います。つまり、引数と同じメソッドとインスタンス変数を持つ新しいオブジェクトを返します。インスタンス変数はコピーされますが、その内容は共有されます。コピーのインスタンス変数に新しい値を代入しても(メソッド呼び出しを使用して)、元のインスタンス変数には影響しませんし、逆に、コピーのインスタンス変数には影響しません。より深い代入(例えば、インスタンス変数が参照セルである場合)は、もちろんオリジナルとコピーの両方に影響を与えます。</target>
        </trans-unit>
        <trans-unit id="f6212b229fd84e14b8e1bd78d95275e70aab5b8c" translate="yes" xml:space="preserve">
          <source>Objects can be compared using the generic comparison functions = and &amp;lt;&amp;gt;. Two objects are equal if and only if they are physically equal. In particular, an object and its copy are not equal.</source>
          <target state="translated">オブジェクトは、一般的な比較関数=および&amp;lt;&amp;gt;を使用して比較できます。2つのオブジェクトは、物理的に等しい場合にのみ等しくなります。特に、オブジェクトとそのコピーは等しくありません。</target>
        </trans-unit>
        <trans-unit id="70e562beb45bc84c915a01804d2101ba51908f44" translate="yes" xml:space="preserve">
          <source>Ocaml_operators</source>
          <target state="translated">Ocaml_operators</target>
        </trans-unit>
        <trans-unit id="ee3ae917b76500c4d6f5198aee13dfba5343c14b" translate="yes" xml:space="preserve">
          <source>Of course the constraint may also be an explicit method type. Only occurrences of quantified variables are required.</source>
          <target state="translated">もちろん、制約は明示的なメソッド型でもよい。定量化された変数の出現のみが必要です。</target>
        </trans-unit>
        <trans-unit id="390a64456209ce68498258cb6922119e7dbf8e07" translate="yes" xml:space="preserve">
          <source>Of course, not all abstract types can be refined, as this would contradict the exhaustiveness check. Namely, builtin types (those defined by the compiler itself, such as int or array), and abstract types defined by the local module, are non-instantiable, and as such cause a type error rather than introduce an equation.</source>
          <target state="translated">もちろん、すべての抽象型をリファインできるわけではありません。つまり、組み込み型 (int や配列のようにコンパイラ自身で定義された型)やローカルモジュールで定義された抽象型はインスタンス化できないので、式を導入するよりも型エラーを起こしてしまいます。</target>
        </trans-unit>
        <trans-unit id="fcd38f73712f3f921494c6d0ba6b9d46d4b7cbdf" translate="yes" xml:space="preserve">
          <source>Of course, private methods can also be virtual. Then, the keywords must appear in this order method private virtual.</source>
          <target state="translated">もちろん、プライベートメソッドもバーチャルにすることができます。そうすると、キーワードはこの順番でメソッド・プライベート・バーチャルが出現しなければなりません。</target>
        </trans-unit>
        <trans-unit id="61f10114972b3e32658bfd9f3e9aeeb732ce426d" translate="yes" xml:space="preserve">
          <source>Of course, this applies to all sorts of accounts.</source>
          <target state="translated">もちろん、これはあらゆる種類のアカウントに当てはまります。</target>
        </trans-unit>
        <trans-unit id="9ce8d8c0b88abbfc440d3dc4b57a2cf0a75a3a5f" translate="yes" xml:space="preserve">
          <source>Of course, you will always encounter this error if you have mutually recursive functions across modules. That is, function Mod1.f calls function Mod2.g, and function Mod2.g calls function Mod1.f. In this case, no matter what permutations you perform on the command line, the program will be rejected at link-time. Fixes:</source>
          <target state="translated">もちろん、モジュール間で相互に再帰的な関数を使用している場合には、必ずこのエラーが発生します。つまり、関数Mod1.fが関数Mod2.gを呼び出し、関数Mod2.gが関数Mod1.fを呼び出しているということです。修正されています。</target>
        </trans-unit>
        <trans-unit id="3abc8fb824d1ca26c79cf75a199925a3994ef82b" translate="yes" xml:space="preserve">
          <source>On ARM and PowerPC processors (32 and 64 bits), fused multiply-add (FMA) instructions can be generated for a floating-point multiplication followed by a floating-point addition or subtraction, as in x *. y +. z. The FMA instruction avoids rounding the intermediate result x *. y, which is generally beneficial, but produces floating-point results that differ slightly from those produced by the bytecode interpreter.</source>
          <target state="translated">ARM および PowerPC プロセッサ (32 ビットおよび 64 ビット)では、浮動小数点の乗算に続いて浮動小数点の加算または減算を行うために、fused multiply-add (FMA)命令を生成することができます。</target>
        </trans-unit>
        <trans-unit id="7e4743b988a9d2c98b0f15c07522d89801266295" translate="yes" xml:space="preserve">
          <source>On IA32 processors only (Intel and AMD x86 processors in 32-bit mode), some intermediate results in floating-point computations are kept in extended precision rather than being rounded to double precision like the bytecode compiler always does. Floating-point results can therefore differ slightly between bytecode and native code.</source>
          <target state="translated">IA32 プロセッサのみ (32 ビットモードの Intel および AMD x86 プロセッサ)では、浮動小数点演算の中間結果の一部は、バイトコード コンパイラが常に行うように倍精度に丸められるのではなく、拡張精度で保持されます。そのため、浮動小数点の結果は、バイトコードとネイティブコードで若干異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="5dbf10944f284d7a264460f6a902cd99abf3e37d" translate="yes" xml:space="preserve">
          <source>On Windows, it is not implemented. Use threads.</source>
          <target state="translated">Windowsでは実装されていません。スレッドを使用します。</target>
        </trans-unit>
        <trans-unit id="dade53b6a22945b59c406518b5b7ced4711e03de" translate="yes" xml:space="preserve">
          <source>On Windows, not implemented.</source>
          <target state="translated">Windowsでは、実装されていません。</target>
        </trans-unit>
        <trans-unit id="8906e1dc157f50b42f72e0cd4030336afb142f2b" translate="yes" xml:space="preserve">
          <source>On Windows, this function can only wait for a given PID, not any child process.</source>
          <target state="translated">Windowsでは、この関数は与えられたPIDを待つだけで、子プロセスを待つことはできません。</target>
        </trans-unit>
        <trans-unit id="8acef991e8908183d9940b463de2698612bbf4fe" translate="yes" xml:space="preserve">
          <source>On Windows: Not implemented, use &lt;a href=&quot;unix#VALwaitpid&quot;&gt;&lt;code&gt;Unix.waitpid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windowsの場合：実装されていません&lt;a href=&quot;unix#VALwaitpid&quot;&gt; &lt;code&gt;Unix.waitpid&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="b247888acfd86ad89effa228bc273bc912c169cc" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented (no inter-process signals on Windows).</source>
          <target state="translated">Windowsでは:実装されていません(Windowsではプロセス間信号はありません)。</target>
        </trans-unit>
        <trans-unit id="5b7ecaf2e67d2e221d004d06c969e40c1f3fa6b9" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented, use &lt;a href=&quot;unix#VALcreate_process&quot;&gt;&lt;code&gt;Unix.create_process&lt;/code&gt;&lt;/a&gt; or threads.</source>
          <target state="translated">Windowsの場合：実装されていない場合は、&lt;a href=&quot;unix#VALcreate_process&quot;&gt; &lt;code&gt;Unix.create_process&lt;/code&gt; &lt;/a&gt;またはスレッドを使用します。</target>
        </trans-unit>
        <trans-unit id="275242bb70c12d899890264c377bf0698c3fd50b" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented.</source>
          <target state="translated">Windowsでは:実装されていません。</target>
        </trans-unit>
        <trans-unit id="29d73771d5997e1e56b96cce84c556b6aa2f143d" translate="yes" xml:space="preserve">
          <source>On each case of a pattern-matching definition (function, match&amp;hellip;with construct, try&amp;hellip;with construct):</source>
          <target state="translated">パターンマッチング定義の各ケースで（関数、一致...構成で、試行...構成で）：</target>
        </trans-unit>
        <trans-unit id="8e88170bb615e04bffb73dc9ab941d16c68ec80f" translate="yes" xml:space="preserve">
          <source>On entrance to a function:</source>
          <target state="translated">ある機能の入り口で</target>
        </trans-unit>
        <trans-unit id="e06905e7e7cd277c45d37ec140ed32c4c8da539c" translate="yes" xml:space="preserve">
          <source>On most systems, the file produced by the linking phase can be run directly, as in:</source>
          <target state="translated">ほとんどのシステムでは、リンクフェーズで生成されたファイルは、以下のように直接実行することができます。</target>
        </trans-unit>
        <trans-unit id="f81f9f71a735722a72705b16087220b85ed634fb" translate="yes" xml:space="preserve">
          <source>On native Windows, the following environment variable is also consulted:</source>
          <target state="translated">ネイティブWindowsでは、以下の環境変数も参照されます。</target>
        </trans-unit>
        <trans-unit id="8007c691da700e3ae4175b6d76c73c8fb4dfce47" translate="yes" xml:space="preserve">
          <source>On one example that was known to be bad for next-fit and first-fit, next-fit takes 28s using 855Mio of memory, first-fit takes 47s using 566Mio of memory, best-fit takes 27s using 545Mio of memory.</source>
          <target state="translated">next-fitとfirst-fitが悪いことがわかっていた例では、next-fitは855Mioのメモリを使って28秒、first-fitは566Mioのメモリを使って47秒、best-fitは545Mioのメモリを使って27秒かかります。</target>
        </trans-unit>
        <trans-unit id="be6baf20c0bc95c4d024106e11bc89c9ce694fe9" translate="yes" xml:space="preserve">
          <source>On platforms that support dynamic loading, ocamlrun can link dynamically with C shared libraries (DLLs) providing additional C primitives beyond those provided by the standard runtime system. The names for these libraries are provided at link time as described in section &lt;a href=&quot;intfc#ss%3Adynlink-c-code&quot;&gt;20.1.4&lt;/a&gt;), and recorded in the bytecode executable file; ocamlrun, then, locates these libraries and resolves references to their primitives when the bytecode executable program starts.</source>
          <target state="translated">動的ロードをサポートするプラットフォームでは、ocamlrunはC共有ライブラリ（DLL）と動的にリンクして、標準のランタイムシステムによって提供されるもの以外の追加のCプリミティブを提供できます。これらのライブラリの名前は、セクション&lt;a href=&quot;intfc#ss%3Adynlink-c-code&quot;&gt;20.1.4&lt;/a&gt;）で説明されているようにリンク時に提供され、バイトコード実行可能ファイルに記録されます。次に、ocamlrunはこれらのライブラリを見つけ、バイトコード実行可能プログラムの起動時にそれらのプリミティブへの参照を解決します。</target>
        </trans-unit>
        <trans-unit id="2f23214a8cc0b25426327d7520ebefaf7e3dc98b" translate="yes" xml:space="preserve">
          <source>On some ports, special options are required on the final linking phase that links together the object file produced by the -output-obj option and the remainder of the program. Those options are shown in the configuration file Makefile.config generated during compilation of OCaml, as the variable OC_LDFLAGS.</source>
          <target state="translated">いくつかのポートでは、-output-objオプションで生成されたオブジェクトファイルとプログラムの残りの部分をリンクする最終的なリンクフェーズで特別なオプションが必要になります。これらのオプションは、OCamlのコンパイル中に生成された設定ファイルMakefile.configに、変数OC_LDFLAGSとして示されています。</target>
        </trans-unit>
        <trans-unit id="cd1d4e4f1b5f80e398835cf87ca32c2f6861e659" translate="yes" xml:space="preserve">
          <source>On start-up (before the first phrase is read), if the file .ocamlinit exists in the current directory, its contents are read as a sequence of OCaml phrases and executed as per the #use directive described in section &lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;. The evaluation outcode for each phrase are not displayed. If the current directory does not contain an .ocamlinit file, the file XDG_CONFIG_HOME/ocaml/init.ml is looked up according to the XDG base directory specification and used instead (on Windows this is skipped). If that file doesn&amp;rsquo;t exist then an [.ocamlinit] file in the users&amp;rsquo; home directory (determined via environment variable HOME) is used if existing.</source>
          <target state="translated">起動時（最初のフレーズが読み取られる前）、ファイル.ocamlinitが現在のディレクトリに存在する場合、その内容はOCamlフレーズのシーケンスとして読み取られ、セクション&lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2で&lt;/a&gt;説明されている#useディレクティブに従って実行されます。各フレーズの評価アウトコードは表示されません。現在のディレクトリに.ocamlinitファイルが含まれていない場合、ファイルXDG_CONFIG_HOME / ocaml / init.mlはXDGベースディレクトリの仕様に従って検索され、代わりに使用されます（Windowsではこれはスキップされます）。そのファイルが存在しない場合は、ユーザーのホームディレクトリ（環境変数HOMEで決定）にある[.ocamlinit]ファイルが存在する場合はそれが使用されます。</target>
        </trans-unit>
        <trans-unit id="06b84befbd60a3041accf5742277784b546af6a5" translate="yes" xml:space="preserve">
          <source>On start-up, the debugger will read commands from an initialization file before giving control to the user. The default file is .ocamldebug in the current directory if it exists, otherwise .ocamldebug in the user&amp;rsquo;s home directory.</source>
          <target state="translated">起動時に、デバッガーはユーザーに制御を与える前に初期化ファイルからコマンドを読み取ります。デフォルトのファイルは、現在のディレクトリにある場合は.ocamldebugであり、存在しない場合は、ユーザーのホームディレクトリにある.ocamldebugです。</target>
        </trans-unit>
        <trans-unit id="4cd11bf07751e14f362666e5c1bd69ee93954cd1" translate="yes" xml:space="preserve">
          <source>On the C side, a pointer to the value registered under name n is obtained by calling caml_named_value(n). The returned pointer must then be dereferenced to recover the actual OCaml value. If no value is registered under the name n, the null pointer is returned. For example, here is a C wrapper that calls the OCaml function f above:</source>
          <target state="translated">C 側では、caml_named_value(n)を呼び出すことで、名前 n で登録された値へのポインタを取得します。そして、返されたポインタは、実際のOCaml値を回復するために参照を解除しなければなりません。名前nの下に値が登録されていない場合は、nullポインタが返されます。例えば、上のOCaml関数fを呼び出すCのラッパーを以下に示します。</target>
        </trans-unit>
        <trans-unit id="064af06a1d91392c727df0b16b39810d1213c9db" translate="yes" xml:space="preserve">
          <source>On the OCaml side, registration is performed by evaluating Callback.registern v. Here, n is the global name (an arbitrary string) and v the OCaml value. For instance:</source>
          <target state="translated">OCaml 側では、Callback.registern v を評価することで登録を行います。ここで、n はグローバル名(任意の文字列)、v は OCaml の値です。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="5de3701f349d27c7db926bd7951f46017d144e8d" translate="yes" xml:space="preserve">
          <source>On the debugged program side, the socket name is passed through the CAML_DEBUG_SOCKET environment variable.</source>
          <target state="translated">デバッグされたプログラム側では、環境変数 CAML_DEBUG_SOCKET にソケット名を渡します。</target>
        </trans-unit>
        <trans-unit id="8c3a47d696ce0714f9f1c41b24081abcae43afd6" translate="yes" xml:space="preserve">
          <source>On the other hand, a class for polymorphic references must explicitly list the type parameters in its declaration. Class type parameters are listed between [ and ]. The type parameters must also be bound somewhere in the class body by a type constraint.</source>
          <target state="translated">一方、多相参照のためのクラスは、宣言の中で明示的に型パラメータをリストアップしなければなりません。クラスの型パラメータは[]と[]の間に記載されています。また、型パラメータはクラス本体のどこかで型制約によってバインドされていなければなりません。</target>
        </trans-unit>
        <trans-unit id="fde94d852235534ebe9a07117621ba74b29f99ae" translate="yes" xml:space="preserve">
          <source>Once a runtime is unloaded, it cannot be started up again without reloading the shared library and reinitializing its static data. Therefore, at the moment, the facility is only useful for building reloadable shared libraries.</source>
          <target state="translated">一度ランタイムがアンロードされると、共有ライブラリをリロードして静的データを再初期化しない限り、ランタイムを再度起動することはできません。そのため、現時点では、この機能はリロード可能な共有ライブラリの構築にのみ有用です。</target>
        </trans-unit>
        <trans-unit id="91fcb0d46bf0fa0b289db31330eb16f274c3b00f" translate="yes" xml:space="preserve">
          <source>Once compiled and linked with the instrumented runtime, any OCaml program can generate &lt;em&gt;trace files&lt;/em&gt; that can then be read and analyzed by users in order to understand specific runtime behaviors.</source>
          <target state="translated">コンパイルされ、インストルメントされたランタイムとリンクされると、OCamlプログラムは&lt;em&gt;トレースファイル&lt;/em&gt;を生成できます。&lt;em&gt;トレースファイル&lt;/em&gt;は、特定のランタイムの動作を理解するために、ユーザーが読み取って分析&lt;em&gt;する&lt;/em&gt;ことができます。</target>
        </trans-unit>
        <trans-unit id="d1d1a0a00f7b028b377134ebb6383b1db4d55c3d" translate="yes" xml:space="preserve">
          <source>Once the appropriate compiler has been selected the program should be built as normal (ensuring that all files are built with the Spacetime compiler&amp;mdash;there is currently no protection to ensure this is the case, but it is essential). For many uses it will not be necessary to change the code of the program to use the profiler.</source>
          <target state="translated">適切なコンパイラを選択したら、プログラムを通常どおりにビルドする必要があります（すべてのファイルがSpacetimeコンパイラでビルドされていることを確認します。現在、これを保証する保護はありませんが、必須です）。多くの用途では、プロファイラーを使用するためにプログラムのコードを変更する必要はありません。</target>
        </trans-unit>
        <trans-unit id="40c6b2bb41ee454dbfaccf9b93d05b18a714000d" translate="yes" xml:space="preserve">
          <source>One can also use this to completely remove a field:</source>
          <target state="translated">また、これを使用してフィールドを完全に削除することもできます。</target>
        </trans-unit>
        <trans-unit id="0de9b9cc70a42dc4f700bcc1de9462f06fdcb0c2" translate="yes" xml:space="preserve">
          <source>One can write</source>
          <target state="translated">書けるものは書ける</target>
        </trans-unit>
        <trans-unit id="e15e35f605f634d4dc006143de05c9a72bf8ebe2" translate="yes" xml:space="preserve">
          <source>One could think of defining the type abbreviation directly:</source>
          <target state="translated">一つは、タイプの略語を直接定義することを考えることができます。</target>
        </trans-unit>
        <trans-unit id="75c4aedb3397880f828378b13f6f7ae32fd18ccd" translate="yes" xml:space="preserve">
          <source>One could think that a private method should remain private in a subclass. However, since the method is visible in a subclass, it is always possible to pick its code and define a method of the same name that runs that code, so yet another (heavier) solution would be:</source>
          <target state="translated">プライベートメソッドはサブクラスではプライベートのままであるべきだと考えることができます。しかし、メソッドはサブクラスで可視化されているので、そのコードを選択して、そのコードを実行する同名のメソッドを定義することは常に可能です。</target>
        </trans-unit>
        <trans-unit id="99f1bbfebca36b804f1d02940b9fe648bbeb9dc0" translate="yes" xml:space="preserve">
          <source>One important restriction is that types introduced by openstruct ... end cannot appear in the signature of the enclosing structure, unless they are defined equal to some non-local type. So:</source>
          <target state="translated">一つの重要な制限は、openstruct ...endによって導入された型は、非ローカル型と同等に定義されていない限り、囲い込み構造体のシグネチャには現れないということです。そのため、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="dae76e80271c4a94dd62fcba165e22dd596cb51b" translate="yes" xml:space="preserve">
          <source>One may extract a public method from an object using the C function caml_get_public_method (declared in &amp;lt;caml/mlvalues.h&amp;gt;.) Since public method tags are hashed in the same way as variant tags, and methods are functions taking self as first argument, if you want to do the method call foo#bar from the C side, you should call:</source>
          <target state="translated">C関数caml_get_public_method（&amp;lt;caml / mlvalues.h&amp;gt;で宣言）を使用して、オブジェクトからパブリックメソッドを抽出できます。パブリックメソッドタグはバリアントタグと同じ方法でハッシュされ、メソッドは自分自身を最初の引数として取る関数であるため、 C側からメソッド呼び出しfoo＃barを実行する場合は、次を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="e8c0b5251da945468988a280889faaa02e2f8010" translate="yes" xml:space="preserve">
          <source>One may wish to open an account and simultaneously deposit some initial amount. Although the initial implementation did not address this requirement, it can be achieved by using an initializer.</source>
          <target state="translated">口座を開設すると同時に、いくつかの初期金額を入金したい場合がある。初期の実装ではこの要件には対応していませんでしたが、イニシャライザを使用することでこれを実現することができます。</target>
        </trans-unit>
        <trans-unit id="ac45b2b8f5570a34d56bdec8e442987bb58c7b07" translate="yes" xml:space="preserve">
          <source>One may wonder whether it is possible to treat primitive types such as integers and strings as objects. Although this is usually uninteresting for integers or strings, there may be some situations where this is desirable. The class money above is such an example. We show here how to do it for strings.</source>
          <target state="translated">整数や文字列のような原始的な型をオブジェクトとして扱うことは可能なのだろうかと疑問に思うかもしれません。これは通常、整数や文字列の場合には興味をそそられませんが、これが望ましい状況もあるかもしれません。上のクラスmoneyはそのような例です。ここでは、文字列に対してそれを行う方法を示します。</target>
        </trans-unit>
        <trans-unit id="b3a6da4a2194d9a62f8ff334748a426441e352b3" translate="yes" xml:space="preserve">
          <source>One should notice that the use of the &lt;code&gt;parser&lt;/code&gt; keyword and associated notation for streams are only available through camlp4 extensions. This means that one has to preprocess its sources</source>
          <target state="translated">ストリームの &lt;code&gt;parser&lt;/code&gt; キーワードと関連する表記法の使用は、camlp4拡張機能を介してのみ利用可能であることに注意してください。これは、ソースを前処理する必要があることを意味します</target>
        </trans-unit>
        <trans-unit id="0c4137e328694d44e01b837a396be545fdedd151" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays</source>
          <target state="translated">一次元配列</target>
        </trans-unit>
        <trans-unit id="6073cf4225ea4cf9fd99b377fa082aad9eea6d61" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays.</source>
          <target state="translated">一次元配列。</target>
        </trans-unit>
        <trans-unit id="19597e0daea38469940aa2541294449599b19f03" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays. The &lt;code&gt;Array1&lt;/code&gt; structure provides operations similar to those of &lt;a href=&quot;bigarray.genarray&quot;&gt;&lt;code&gt;Bigarray.Genarray&lt;/code&gt;&lt;/a&gt;, but specialized to the case of one-dimensional arrays. (The &lt;a href=&quot;bigarray.array2&quot;&gt;&lt;code&gt;Bigarray.Array2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;bigarray.array3&quot;&gt;&lt;code&gt;Bigarray.Array3&lt;/code&gt;&lt;/a&gt; structures below provide operations specialized for two- and three-dimensional arrays.) Statically knowing the number of dimensions of the array allows faster operations, and more precise static type-checking.</source>
          <target state="translated">1次元配列。 &lt;code&gt;Array1&lt;/code&gt; 構造は同様の動作を提供&lt;a href=&quot;bigarray.genarray&quot;&gt; &lt;code&gt;Bigarray.Genarray&lt;/code&gt; を&lt;/a&gt;するが、1次元配列の場合に特化しました。（以下の&lt;a href=&quot;bigarray.array2&quot;&gt; &lt;code&gt;Bigarray.Array2&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;bigarray.array3&quot;&gt; &lt;code&gt;Bigarray.Array3&lt;/code&gt; &lt;/a&gt;構造は、2次元および3次元配列に特化した操作を提供します。）配列の次元数を静的に知ることにより、操作が高速になり、静的型チェックがより正確になります。</target>
        </trans-unit>
        <trans-unit id="5e57737797ac7cce48fd7410f424583fc8513250" translate="yes" xml:space="preserve">
          <source>Only consider using &lt;code&gt;print_flush&lt;/code&gt; when displaying all pending material is mandatory (for instance in case of interactive use when you want the user to read some text) and when resetting the pretty-printer state will not disturb further pretty-printing.</source>
          <target state="translated">保留中のすべての資料の表示が必須であり（たとえば、ユーザーにテキストを読んでもらいたいインタラクティブな使用の場合）、プリティプリンターの状態をリセットしてもプリティプリントが妨げられない場合にのみ、 &lt;code&gt;print_flush&lt;/code&gt; の使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="57c1f2f7c1cbc3df8fd97de870c8cc67eed2b309" translate="yes" xml:space="preserve">
          <source>Only elements (values, types, classes, ...) declared in the .mli file are kept. In other terms, definitions from the .ml file that are not exported in the .mli file are not documented.</source>
          <target state="translated">.mliファイルで宣言された要素(値、型、クラス、...)のみが保持されます。言い換えれば、.mlファイルからの定義で、.mliファイルにエクスポートされていないものはドキュメント化されません。</target>
        </trans-unit>
        <trans-unit id="9b33e1f6fc9c9ddf7561ddbbf58ce1315c78aa84" translate="yes" xml:space="preserve">
          <source>Only generative effects:</source>
          <target state="translated">生成効果のみ。</target>
        </trans-unit>
        <trans-unit id="5fd27083a589b2ea8c548b530eaf11c8f07666db" translate="yes" xml:space="preserve">
          <source>Only the override can be used to actually override fields, and only the Oo.copy primitive can be used externally.</source>
          <target state="translated">実際にフィールドをオーバーライドするのはオーバーライドだけで、外部からはOo.copyプリミティブしか使えません。</target>
        </trans-unit>
        <trans-unit id="39d7997d1c51094c34071c019aa4016ceac60919" translate="yes" xml:space="preserve">
          <source>Oo</source>
          <target state="translated">Oo</target>
        </trans-unit>
        <trans-unit id="879894b2b7b07e597e8cd61a26bfd25635e3e7b3" translate="yes" xml:space="preserve">
          <source>Open a descriptor on a directory</source>
          <target state="translated">ディレクトリの記述子を開く</target>
        </trans-unit>
        <trans-unit id="42cdbc4aac5165559359ac8e455a8abf3fb22ee2" translate="yes" xml:space="preserve">
          <source>Open for append</source>
          <target state="translated">アペンドのためのオープン</target>
        </trans-unit>
        <trans-unit id="f22f60235dedec7386d0bead1c3c094a8425cdd5" translate="yes" xml:space="preserve">
          <source>Open for reading</source>
          <target state="translated">開いて読む</target>
        </trans-unit>
        <trans-unit id="9fe9ee1f7787491ffb2ce2a09f2e3a1c47b49760" translate="yes" xml:space="preserve">
          <source>Open for reading and writing</source>
          <target state="translated">読み書きOK</target>
        </trans-unit>
        <trans-unit id="e02c2958f8bca2d69a22cec109cddef10f1b7f6a" translate="yes" xml:space="preserve">
          <source>Open for writing</source>
          <target state="translated">書くためにオープン</target>
        </trans-unit>
        <trans-unit id="0c50ee9bdb83bc2966178eb9517aa2ed3bb705c2" translate="yes" xml:space="preserve">
          <source>Open in non-blocking mode</source>
          <target state="translated">ノンブロッキングモードでのオープン</target>
        </trans-unit>
        <trans-unit id="be813666b3c7520ae92cd0a1c6783279f682b877" translate="yes" xml:space="preserve">
          <source>Open statement shadows an already defined identifier.</source>
          <target state="translated">オープンステートメントは、すでに定義されている識別子をシャドウイングします。</target>
        </trans-unit>
        <trans-unit id="50ebdf1219ecd6520cbac717e097eb9be6c3aaca" translate="yes" xml:space="preserve">
          <source>Open statement shadows an already defined label or constructor.</source>
          <target state="translated">オープンステートメントは、すでに定義されているラベルやコンストラクタをシャドーにします。</target>
        </trans-unit>
        <trans-unit id="12f7d6bffbe087ced7c1077d53f97324fb2738f7" translate="yes" xml:space="preserve">
          <source>Open the named file for reading, and return a new input channel on that file, positioned at the beginning of the file.</source>
          <target state="translated">読み込み用に名前のついたファイルを開き、そのファイルの先頭に位置する新しい入力チャンネルを返します。</target>
        </trans-unit>
        <trans-unit id="6cca06bc653ed2aa9b9ca617abff820d8ae7223d" translate="yes" xml:space="preserve">
          <source>Open the named file for writing, and return a new output channel on that file, positioned at the beginning of the file.</source>
          <target state="translated">書き込み用に名前のついたファイルを開き、そのファイルの先頭に位置する新しい出力チャンネルを返します。</target>
        </trans-unit>
        <trans-unit id="8ff1c4e694cef020d3159f32a866f2a047386814" translate="yes" xml:space="preserve">
          <source>Open the named file for writing, and return a new output channel on that file, positioned at the beginning of the file. The file is truncated to zero length if it already exists. It is created if it does not already exists.</source>
          <target state="translated">書き込みのために名前のついたファイルを開き、そのファイルの先頭に位置する新しい出力チャンネルを返します。ファイルは、既に存在する場合は長さ0に切り捨てられます。既に存在しない場合は作成されます。</target>
        </trans-unit>
        <trans-unit id="855fccd9cd030742446f7fcafaafb5b0c12184d8" translate="yes" xml:space="preserve">
          <source>Open the named file with the given flags.</source>
          <target state="translated">指定されたフラグで名前のついたファイルを開きます。</target>
        </trans-unit>
        <trans-unit id="df722ec03c209e9326d618d229491b24151a9084" translate="yes" xml:space="preserve">
          <source>Open the named file with the given flags. Third argument is the permissions to give to the file if it is created (see &lt;a href=&quot;unix#VALumask&quot;&gt;&lt;code&gt;Unix.umask&lt;/code&gt;&lt;/a&gt;). Return a file descriptor on the named file.</source>
          <target state="translated">指定されたフラグを使用して名前付きファイルを開きます。3番目の引数は、ファイルが作成された場合にファイルに与えるアクセス許可です（&lt;a href=&quot;unix#VALumask&quot;&gt; &lt;code&gt;Unix.umask&lt;/code&gt; を&lt;/a&gt;参照）。名前付きファイルのファイル記述子を返します。</target>
        </trans-unit>
        <trans-unit id="f49f1f535c925238e318a33c608a939bf58bc5fe" translate="yes" xml:space="preserve">
          <source>Open the named file with the given flags. Third argument is the permissions to give to the file if it is created. Return a file descriptor on the named file.</source>
          <target state="translated">与えられたフラグで名前のついたファイルを開きます。第三引数は、ファイルが作成された場合にそのファイルに与えるパーミッションです。指定されたファイルのファイルディスクリプタを返します。</target>
        </trans-unit>
        <trans-unit id="83c183b6c4d6c2979639b113137c57ec0de409f0" translate="yes" xml:space="preserve">
          <source>Opening a module enables lighter access to its components, at the cost of making it harder to identify in which module a identifier has been defined. In particular, opened modules can shadow identifiers present in the current scope, potentially leading to confusing errors:</source>
          <target state="translated">モジュールをオープンにすると、そのコンポーネントへのアクセスが軽くなりますが、その代償として、どのモジュールで識別子が定義されているかの識別が困難になります。特に、オープンされたモジュールは、現在のスコープに存在する識別子の影になってしまう可能性があり、混乱を招く可能性があります。</target>
        </trans-unit>
        <trans-unit id="f5209b9452f8161599a2a771725ad2ccd16a6bec" translate="yes" xml:space="preserve">
          <source>Opening modes for &lt;a href=&quot;stdlib#VALopen_out_gen&quot;&gt;&lt;code&gt;open_out_gen&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdlib#VALopen_in_gen&quot;&gt;&lt;code&gt;open_in_gen&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALopen_out_gen&quot;&gt; &lt;code&gt;open_out_gen&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;stdlib#VALopen_in_gen&quot;&gt; &lt;code&gt;open_in_gen&lt;/code&gt; の&lt;/a&gt;オープンモード。</target>
        </trans-unit>
        <trans-unit id="f9f27f60f5932e4abb4b4ed37257f5c7c5328157" translate="yes" xml:space="preserve">
          <source>Opens the given module before processing the interface or implementation files. If several -open options are given, they are processed in order, just as if the statements open!Module1;;...open!ModuleN;; were added at the top of each file.</source>
          <target state="translated">インターフェースや実装ファイルを処理する前に、与えられたモジュールを開きます。複数の -open オプションが与えられた場合は、open!Module1;;...open!ModuleN;;が各ファイルの先頭に追加されたかのように、順番に処理されます。</target>
        </trans-unit>
        <trans-unit id="785a4531dce5036578aea8e49ed353d58a926529" translate="yes" xml:space="preserve">
          <source>Operating system currently executing the OCaml program.</source>
          <target state="translated">OCamlプログラムを実行中のOS。</target>
        </trans-unit>
        <trans-unit id="21abc6dbd0063cb952c1cc150a7203c29ccc476d" translate="yes" xml:space="preserve">
          <source>Operating system currently executing the OCaml program. One of</source>
          <target state="translated">OCamlプログラムを実行中のOS。のいずれかの</target>
        </trans-unit>
        <trans-unit id="0fc51a5c314382c855158eda38ff5409a7e69535" translate="yes" xml:space="preserve">
          <source>Operation already in progress</source>
          <target state="translated">作業はすでに進行中</target>
        </trans-unit>
        <trans-unit id="25ef925607b43bca64c3829868d9989b76540d3a" translate="yes" xml:space="preserve">
          <source>Operation not permitted</source>
          <target state="translated">操作不可</target>
        </trans-unit>
        <trans-unit id="c49e2a256113761881fb1a1fa41d066e27d70d15" translate="yes" xml:space="preserve">
          <source>Operation not supported on socket</source>
          <target state="translated">ソケットでの操作はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="8fdc938d87d0b18a567701392c335d0c883fa4b7" translate="yes" xml:space="preserve">
          <source>Operation now in progress</source>
          <target state="translated">運用中</target>
        </trans-unit>
        <trans-unit id="db648ff618df972b87b0f378a6996fcda48575ee" translate="yes" xml:space="preserve">
          <source>Operation would block</source>
          <target state="translated">操作はブロックされます</target>
        </trans-unit>
        <trans-unit id="66d4b9b2ab0289179c7507e1de79db969d3d4674" translate="yes" xml:space="preserve">
          <source>Operations on binary trees are naturally expressed as recursive functions following the same structure as the type definition itself. For instance, here are functions performing lookup and insertion in ordered binary trees (elements increase from left to right):</source>
          <target state="translated">二分木に対する操作は、当然ながら型定義自体と同じ構造を持つ再帰関数として表現されます。例えば,順序付き二進木(左から右に要素が増えていく)の中で,ルックアップと挿入を行う関数を以下に示します.</target>
        </trans-unit>
        <trans-unit id="46ba0f6e1bd0b179a386572eb306814fd822f312" translate="yes" xml:space="preserve">
          <source>Operations on file descriptors</source>
          <target state="translated">ファイルディスクリプタの操作</target>
        </trans-unit>
        <trans-unit id="d8dd6735ea7932a85dd5996051b8e28bae8e00af" translate="yes" xml:space="preserve">
          <source>Operations on file names</source>
          <target state="translated">ファイル名の操作</target>
        </trans-unit>
        <trans-unit id="cb3fabd6bce5c3e474e507106204018aa930b99e" translate="yes" xml:space="preserve">
          <source>Operations on file names.</source>
          <target state="translated">ファイル名の操作。</target>
        </trans-unit>
        <trans-unit id="d0e7fd3b17cf5a9396bca0fcd458a4b1c3357462" translate="yes" xml:space="preserve">
          <source>Operations on format strings</source>
          <target state="translated">フォーマット文字列の操作</target>
        </trans-unit>
        <trans-unit id="62d745537237adfa18d0a04a59f915fbeb6922d1" translate="yes" xml:space="preserve">
          <source>Operations on internal representations of values.</source>
          <target state="translated">値の内部表現に対する操作。</target>
        </trans-unit>
        <trans-unit id="ef05a420fdb91696847263f07548f0822231b601" translate="yes" xml:space="preserve">
          <source>Operations on large files</source>
          <target state="translated">大容量ファイルの操作</target>
        </trans-unit>
        <trans-unit id="884b46ea59004fc7b9feee6503d70fe0de517a3c" translate="yes" xml:space="preserve">
          <source>Operations on large files.</source>
          <target state="translated">大容量ファイルの操作。</target>
        </trans-unit>
        <trans-unit id="392a9d3b032591e4ff18dd78bdf784b52dd45f89" translate="yes" xml:space="preserve">
          <source>Operations on objects</source>
          <target state="translated">オブジェクトに対する操作</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="c4083b8c5eac166a2a2acd9a240e21f33de8bf2b" translate="yes" xml:space="preserve">
          <source>Operator class</source>
          <target state="translated">オペレータクラス</target>
        </trans-unit>
        <trans-unit id="2866cf078fa7e1a2f2d0a2ea0ea2b67ee507cc6b" translate="yes" xml:space="preserve">
          <source>Operator names starting with a # character and containing more than one # character are reserved for extensions.</source>
          <target state="translated">文字で始まり、2つ以上の#文字を含む演算子名は、拡張子のために予約されています。</target>
        </trans-unit>
        <trans-unit id="45483f2ad274c0501b5ffbf4bf59ee7cd50884a0" translate="yes" xml:space="preserve">
          <source>Optimisation with Flambda is not currently supported when generating bytecode.</source>
          <target state="translated">バイトコードを生成する際にFlambdaを使った最適化は現在サポートされていません。</target>
        </trans-unit>
        <trans-unit id="fdf5e093149fa15365c797b12b39a00d5ec3a138" translate="yes" xml:space="preserve">
          <source>Optimization</source>
          <target state="translated">Optimization</target>
        </trans-unit>
        <trans-unit id="9d029eff2b929a5ac0d4af743cee64e78c8571a4" translate="yes" xml:space="preserve">
          <source>Optimize the produced code for space rather than for time. This results in slightly smaller but slightly slower programs. The default is to optimize for speed.</source>
          <target state="translated">生成されたコードを時間のためではなく、スペースのために最適化します。これにより、プログラムは少し小さくなりますが、少し遅くなります。デフォルトでは、速度のために最適化されています。</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="b4461387353942c5c9a36536dba32b4583899a32" translate="yes" xml:space="preserve">
          <source>Option values explicitly indicate the presence or absence of a value.</source>
          <target state="translated">オプション値は、値の有無を明示的に示します。</target>
        </trans-unit>
        <trans-unit id="eed9d5149119da92f8108cc447b5c8a63bc1983d" translate="yes" xml:space="preserve">
          <source>Option values.</source>
          <target state="translated">オプションの値。</target>
        </trans-unit>
        <trans-unit id="b72c0a2e7190e2eb7aaa162394774f42f8444781" translate="yes" xml:space="preserve">
          <source>Optional arguments are actually implemented as option types. If you do not give a default value, you have access to their internal representation, type 'a option = None | Some of 'a. You can then provide different behaviors when an argument is present or not.</source>
          <target state="translated">オプション引数は、実際にはオプション型として実装されています。デフォルト値を与えない場合は、その内部表現にアクセスすることができます。そして、引数が存在する場合としない場合とで異なる動作を提供することができます。</target>
        </trans-unit>
        <trans-unit id="57beea4dfffda43497b4bb0d9bd857b0df0104e1" translate="yes" xml:space="preserve">
          <source>Optional parameters may also commute with non-optional or unlabeled ones, as long as they are applied simultaneously. By nature, optional arguments do not commute with unlabeled arguments applied independently.</source>
          <target state="translated">オプション引数は、それらが同時に適用されている限り、非オプション引数やラベルの付いていない引数と共存することができます。本来、オプション引数は、独立して適用されるラベルの付いていない引数とは共存しません。</target>
        </trans-unit>
        <trans-unit id="659fd3897d334a8024280ea2db630f05a96e06e0" translate="yes" xml:space="preserve">
          <source>Optionally, missing fields can be made explicit by ending the list of fields with a trailing wildcard _::</source>
          <target state="translated">オプションで、フィールドのリストを最後にワイルドカード _:で終わらせることで、欠落しているフィールドを明示することができます。</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="de973f948db8258d8d749bfe279d72496cf0c025" translate="yes" xml:space="preserve">
          <source>Options selecting a built-in generator to ocamldoc, such as -html, have no effect if a custom generator of the same kind is provided using -g. If the kinds do not match, the selected built-in generator is used and the custom one is ignored.</source>
          <target state="translated">html のように ocamldoc にビルトインジェネレータを選択するオプションは、同じ種類のカスタムジェネレータが -g を使って提供されている場合には何の効果もありません。種類が一致しない場合は、選択されたビルトインジェネレータが使われ、カスタムジェネレータは無視されます。</target>
        </trans-unit>
        <trans-unit id="ecfdbe107bba41b0abba570531e3c3d244ee7166" translate="yes" xml:space="preserve">
          <source>Options to &lt;a href=&quot;unix#VALgetaddrinfo&quot;&gt;&lt;code&gt;Unix.getaddrinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALgetaddrinfo&quot;&gt; &lt;code&gt;Unix.getaddrinfo&lt;/code&gt; の&lt;/a&gt;オプション。</target>
        </trans-unit>
        <trans-unit id="acbc13cd4094c5e7aa7a8e52fa68629dbf0813f9" translate="yes" xml:space="preserve">
          <source>Options to &lt;a href=&quot;unix#VALgetnameinfo&quot;&gt;&lt;code&gt;Unix.getnameinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALgetnameinfo&quot;&gt; &lt;code&gt;Unix.getnameinfo&lt;/code&gt; の&lt;/a&gt;オプション。</target>
        </trans-unit>
        <trans-unit id="cabf18c33657daede436c9425e69c4a2df9c4ba4" translate="yes" xml:space="preserve">
          <source>Or, equivalently:</source>
          <target state="translated">あるいは、同等に。</target>
        </trans-unit>
        <trans-unit id="1c2251dba4688a589e898c162858a821fdb5b816" translate="yes" xml:space="preserve">
          <source>Other comments for &lt;a href=&quot;hashtbl#VALiter&quot;&gt;&lt;code&gt;Hashtbl.iter&lt;/code&gt;&lt;/a&gt; apply as well.</source>
          <target state="translated">&lt;a href=&quot;hashtbl#VALiter&quot;&gt; &lt;code&gt;Hashtbl.iter&lt;/code&gt; に関する&lt;/a&gt;他のコメントも同様に適用されます。</target>
        </trans-unit>
        <trans-unit id="f72667213aa60e61b77943168bfb7d9b47ab1a35" translate="yes" xml:space="preserve">
          <source>Other generic comparisons such as (&amp;lt;, &amp;lt;=, ...) can also be used on objects. The relation &amp;lt; defines an unspecified but strict ordering on objects. The ordering relationship between two objects is fixed once for all after the two objects have been created and it is not affected by mutation of fields.</source>
          <target state="translated">（&amp;lt;、&amp;lt;=、...）などの他の一般的な比較もオブジェクトで使用できます。関係&amp;lt;は、オブジェクトの指定されていないが厳密な順序を定義します。2つのオブジェクト間の順序関係は、2つのオブジェクトが作成された後、一度だけ固定され、フィールドの変更の影響を受けません。</target>
        </trans-unit>
        <trans-unit id="8d3a931554b88e85d13e345dd0998e69549806d3" translate="yes" xml:space="preserve">
          <source>Other types do not introduce new subtyping, but they may propagate the subtyping of their arguments. For instance, &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;*&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt;*&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt; when &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; are respectively subtypes of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt;. For function types, the relation is more subtle: &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt; if &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a supertype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt;. For this reason, function types are covariant in their second argument (like tuples), but contravariant in their first argument. Mutable types, like array or ref are neither covariant nor contravariant, they are nonvariant, that is they do not propagate subtyping.</source>
          <target state="translated">他のタイプは新しいサブタイプを導入しませんが、引数のサブタイプを伝播する可能性があります。例えば、&lt;a href=&quot;types#typexpr&quot;&gt;TYP &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; *&lt;a href=&quot;types#typexpr&quot;&gt;標準&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;のサブタイプである&lt;a href=&quot;types#typexpr&quot;&gt;標準&lt;/a&gt;' &lt;sub&gt;1つの&lt;/sub&gt;*&lt;a href=&quot;types#typexpr&quot;&gt;標準&lt;/a&gt;' &lt;sub&gt;2&lt;/sub&gt;とき&lt;a href=&quot;types#typexpr&quot;&gt;TYP &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;及び&lt;a href=&quot;types#typexpr&quot;&gt;TYP &lt;/a&gt;&lt;sub&gt;2を&lt;/sub&gt;それぞれのサブタイプである&lt;a href=&quot;types#typexpr&quot;&gt;標準&lt;/a&gt;' &lt;sub&gt;1&lt;/sub&gt;及び&lt;a href=&quot;types#typexpr&quot;&gt;TYP&lt;/a&gt; ' &lt;sub&gt;2&lt;/sub&gt;。関数型の場合、関係はより微妙である：&lt;a href=&quot;types#typexpr&quot;&gt;標準&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; - &amp;gt; &lt;a href=&quot;types#typexpr&quot;&gt;TYP &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;のサブタイプである&lt;a href=&quot;types#typexpr&quot;&gt;TYP&lt;/a&gt; ' &lt;sub&gt;1&lt;/sub&gt; - &amp;gt; &lt;a href=&quot;types#typexpr&quot;&gt;TYP&lt;/a&gt; ' &lt;sub&gt;2&lt;/sub&gt;場合&lt;a href=&quot;types#typexpr&quot;&gt;TYP &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;のスーパータイプである&lt;a href=&quot;types#typexpr&quot;&gt;TYP&lt;/a&gt; ' &lt;sub&gt;1&lt;/sub&gt;及び&lt;a href=&quot;types#typexpr&quot;&gt;TYP &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;のサブタイプである&lt;a href=&quot;types#typexpr&quot;&gt;標準&lt;/a&gt;' &lt;sub&gt;2&lt;/sub&gt;。このため、関数タイプは2番目の引数（タプルなど）では共変ですが、最初の引数では反変です。arrayやrefのような可変型は、共変でも反変でもありません。それらは非変です。つまり、サブタイプを伝播しません。</target>
        </trans-unit>
        <trans-unit id="88cb471cac1651f6cd901864ed749958654b7d77" translate="yes" xml:space="preserve">
          <source>Otherwise the function being called is substituted at the call site with its body having been rewritten such that any recursive calls to that function &lt;em&gt;or any others in the same mutually-recursive group&lt;/em&gt; are annotated with the attribute unrolled(n &amp;minus; 1). Inlining may continue on that body.</source>
          <target state="translated">それ以外の場合、呼び出される関数は、その関数&lt;em&gt;または同じ相互再帰グループ内の他の&lt;/em&gt;関数への再帰呼び出しに属性unrolled（n &amp;minus; 1）の注釈が付けられるように、呼び出しサイトで本体が書き換えられて置き換えられます。そのボディにインライン化が続く場合があります。</target>
        </trans-unit>
        <trans-unit id="5cf7d27ce868f52e567b02e4ec391690c62f134e" translate="yes" xml:space="preserve">
          <source>Otherwise, nothing happens.</source>
          <target state="translated">そうでなければ、何も起こらない。</target>
        </trans-unit>
        <trans-unit id="4c86b00df30e667ed3c1e54e980a320c6bfb8e87" translate="yes" xml:space="preserve">
          <source>Otherwise, the initialising array is lifted out and subject to the normal constant sharing procedure; creation of the array consists of bulk copying the initialising array into a fresh value on the OCaml heap.</source>
          <target state="translated">それ以外の場合は、初期化配列が持ち出され、通常の定数共有手順に従うことになります。</target>
        </trans-unit>
        <trans-unit id="aafa7eee672f6b85c088cd2cb345b72adf66f904" translate="yes" xml:space="preserve">
          <source>Otherwise, the symbol is bound to a (statically-allocated) &lt;em&gt;preallocated block&lt;/em&gt; containing one field. At runtime, the defining expression will be evaluated and the first field of the block filled with the resulting value. This &lt;em&gt;initialise-symbol&lt;/em&gt; binding causes one extra indirection but ensures, by virtue of the symbol&amp;rsquo;s address being known at compile time, that uses of the value are not captured by closures.</source>
          <target state="translated">それ以外の場合、シンボルは1つのフィールドを含む（静的に割り当てられた）&lt;em&gt;事前に&lt;/em&gt;割り当てられた&lt;em&gt;ブロック&lt;/em&gt;にバインドされます。実行時に、定義式が評価され、ブロックの最初のフィールドに結果の値が入力されます。この&lt;em&gt;初期化-シンボル&lt;/em&gt;バインディングにより、1つの余分な間接参照が発生しますが、コンパイル時にシンボルのアドレスがわかっているため、値の使用がクロージャによってキャプチャされないことが保証されます。</target>
        </trans-unit>
        <trans-unit id="1e89ee3a810516da1f61deb1e918aa6f94233ccf" translate="yes" xml:space="preserve">
          <source>Our iterator works, as shows its first use for summation. However, since objects themselves are not polymorphic (only their constructors are), using the fold method fixes its type for this individual object. Our next attempt to use it as a string iterator fails.</source>
          <target state="translated">私たちのイテレータは、最初に和算に使用したことを示しているように動作します。しかし、オブジェクト自体はポリモーフィックではないので (コンストラクタだけがそうです)、fold メソッドを使うと、この個々のオブジェクトの型が修正されます。これを文字列イテレータとして使おうとした次の試みは失敗しました。</target>
        </trans-unit>
        <trans-unit id="0be297b561141a6a2d82a7108dddc36e1cc22dba" translate="yes" xml:space="preserve">
          <source>Out of memory</source>
          <target state="translated">記憶の外</target>
        </trans-unit>
        <trans-unit id="6e02b9b7b5116b9cf2721c4e3f0f7bdbc58079e4" translate="yes" xml:space="preserve">
          <source>Output GC statistics at program exit.</source>
          <target state="translated">プログラム終了時にGC統計情報を出力します。</target>
        </trans-unit>
        <trans-unit id="7671f0341e3d098b8c9393d0300f5e4d7f5c6621" translate="yes" xml:space="preserve">
          <source>Output baud rate (0 means close connection).</source>
          <target state="translated">出力ボーレート(0 はクローズ接続を意味します。</target>
        </trans-unit>
        <trans-unit id="0c09cf6b42600a87ca03143becccdcb8b33419e1" translate="yes" xml:space="preserve">
          <source>Output code that does not use OCaml&amp;rsquo;s built-in automata interpreter. Instead, the automaton is encoded by OCaml functions. This option improves performance when using the native compiler, but decreases it when using the bytecode compiler.</source>
          <target state="translated">OCamlの組み込みオートマトンインタープリターを使用しない出力コード。代わりに、オートマトンはOCaml関数によってエンコードされます。このオプションは、ネイティブコンパイラを使用する場合はパフォーマンスを向上させますが、バイトコードコンパイラを使用する場合はパフォーマンスを低下させます。</target>
        </trans-unit>
        <trans-unit id="743a4b6a0ace04e22a3f7d73badb17283ccbd3bc" translate="yes" xml:space="preserve">
          <source>Output dot code describing the type dependency graph instead of the module dependency graph.</source>
          <target state="translated">モジュール依存性グラフではなく、型依存性グラフを記述したドットコードを出力します。</target>
        </trans-unit>
        <trans-unit id="2da5f56773c68337139a5eca245caeacb63ae861" translate="yes" xml:space="preserve">
          <source>Output functions on standard error</source>
          <target state="translated">標準誤差の出力関数</target>
        </trans-unit>
        <trans-unit id="99ab5418296d95f226bfcd5834dc0e99eb65877d" translate="yes" xml:space="preserve">
          <source>Output functions on standard output</source>
          <target state="translated">標準出力の出力機能</target>
        </trans-unit>
        <trans-unit id="2900df23d8753bef8ba40bb95924b811a8a31a30" translate="yes" xml:space="preserve">
          <source>Output one line per file, regardless of the length.</source>
          <target state="translated">ファイルの長さに関係なく、1ファイルにつき1行を出力します。</target>
        </trans-unit>
        <trans-unit id="052a1c1bf420fd7d12e0f3d0ea009ebee9739c3a" translate="yes" xml:space="preserve">
          <source>Output raw dependencies of the form</source>
          <target state="translated">形式の生の依存関係を出力</target>
        </trans-unit>
        <trans-unit id="49bd2e99d5d5374f1bd9969053ecf288c36f827f" translate="yes" xml:space="preserve">
          <source>Output signature of the functor &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ファンクター&lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; の&lt;/a&gt;署名を出力します。</target>
        </trans-unit>
        <trans-unit id="5145c8c79a32654b4778e9f93670595bbd8d1719" translate="yes" xml:space="preserve">
          <source>Output signature of the functor &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ファンクター&lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; の&lt;/a&gt;署名を出力します。</target>
        </trans-unit>
        <trans-unit id="d31f223f57817b5e1d76b337263e2c889f885c49" translate="yes" xml:space="preserve">
          <source>Output the generated documentation to file instead of ocamldoc.out. This option is meaningful only in conjunction with the -latex, -texi, or -dot options.</source>
          <target state="translated">生成されたドキュメントを ocamldoc.out の代わりにファイルに出力します。このオプションは、-latex,-texi,-dotオプションと組み合わせてのみ意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="95791b995af7b93d84b0104e38a8bf231ca37bde" translate="yes" xml:space="preserve">
          <source>Outside of this domain, &lt;code&gt;pp_set_geometry&lt;/code&gt; raises an invalid argument exception whereas &lt;code&gt;pp_safe_set_geometry&lt;/code&gt; does nothing.</source>
          <target state="translated">このドメイン外では、 &lt;code&gt;pp_set_geometry&lt;/code&gt; は無効な引数例外を &lt;code&gt;pp_safe_set_geometry&lt;/code&gt; せますが、pp_safe_set_geometryは何もしません。</target>
        </trans-unit>
        <trans-unit id="b6d1264bc905918faeda24a1a224e8b90ab0b9d7" translate="yes" xml:space="preserve">
          <source>Outside the structure, its components can be referred to using the &amp;ldquo;dot notation&amp;rdquo;, that is, identifiers qualified by a structure name. For instance, PrioQueue.insert is the function insert defined inside the structure PrioQueue and PrioQueue.queue is the type queue defined in PrioQueue.</source>
          <target state="translated">構造体の外部では、そのコンポーネントは「ドット表記」、つまり構造体名で修飾された識別子を使用して参照できます。たとえば、PrioQueue.insertは構造体PrioQueue内で定義された関数insertであり、PrioQueue.queueはPrioQueueで定義されたタイプキューです。</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="09bd6a353a7bb8a33e37cfee71ada9fc9ce37d89" translate="yes" xml:space="preserve">
          <source>PATH</source>
          <target state="translated">PATH</target>
        </trans-unit>
        <trans-unit id="da18ad2a8cc0702f3ea2d5253be6cbd4ca251be5" translate="yes" xml:space="preserve">
          <source>PF_INET is fully supported; PF_INET6 is fully supported (since 4.01.0); PF_UNIX is not supported</source>
          <target state="translated">PF_INETは完全にサポートされています;PF_INET6は完全にサポートされています(4.01.0以降);PF_UNIXはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="4dc6925c70ec89b041de02dd5e2ee478c8a2fff1" translate="yes" xml:space="preserve">
          <source>Pair operations</source>
          <target state="translated">ペア操作</target>
        </trans-unit>
        <trans-unit id="f699f295e5ae4ac633cfa18437fed38d028b3fdb" translate="yes" xml:space="preserve">
          <source>Parameter</source>
          <target state="translated">Parameter</target>
        </trans-unit>
        <trans-unit id="06f18dad25a25477df3046f706b5e47ba6a1cff9" translate="yes" xml:space="preserve">
          <source>Parameterize one function by the other. That is, instead of having</source>
          <target state="translated">一方の関数を他方の関数でパラメータ化します。つまり</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="da3863839aefaac9ffd796e91309941e5a0aabf4" translate="yes" xml:space="preserve">
          <source>Parenthesized expressions can also contain coercions (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;] :&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;) (see subsection &lt;a href=&quot;#ss%3Aexpr-coercions&quot;&gt;7.7.7&lt;/a&gt; below).</source>
          <target state="translated">括弧で囲まれた式には、強制（&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; [：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; ]：&amp;gt; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;）を含めることもできます（以下のサブセクション&lt;a href=&quot;#ss%3Aexpr-coercions&quot;&gt;7.7.7を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="78e82529fec7a054cadaa05482779b54cccd0e7d" translate="yes" xml:space="preserve">
          <source>Parenthesized expressions can contain a type constraint, as in (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;). This constraint forces the type of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; to be compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;.</source>
          <target state="translated">括弧で囲まれた式には、（&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;）のように型制約を含めることができます。この制約により、&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;のタイプは&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;と互換性があります。</target>
        </trans-unit>
        <trans-unit id="7294d33710169103141018bfcb0ee5ad3daa81e2" translate="yes" xml:space="preserve">
          <source>Parsing</source>
          <target state="translated">Parsing</target>
        </trans-unit>
        <trans-unit id="b2eda9d52f18e0568a63bc181bcaa6ee3a98404e" translate="yes" xml:space="preserve">
          <source>Parsing of command line arguments.</source>
          <target state="translated">コマンドライン引数のパース</target>
        </trans-unit>
        <trans-unit id="6c9e17bd7715006188f45f1708aaf0fea52ec4f8" translate="yes" xml:space="preserve">
          <source>Part &lt;a href=&quot;index#p%3Acommands&quot;&gt;III&lt;/a&gt;, &amp;ldquo;The OCaml tools&amp;rdquo;, documents the compilers, toplevel system, and programming utilities.</source>
          <target state="translated">パート&lt;a href=&quot;index#p%3Acommands&quot;&gt;III&lt;/a&gt;「OCamlツール」では、コンパイラ、トップレベルシステム、およびプログラミングユーティリティについて説明しています。</target>
        </trans-unit>
        <trans-unit id="18c889dcbcc02d29f2665be2a7454d8a1987503b" translate="yes" xml:space="preserve">
          <source>Part &lt;a href=&quot;index#p%3Alibrary&quot;&gt;IV&lt;/a&gt;, &amp;ldquo;The OCaml library&amp;rdquo;, describes the modules provided in the standard library.</source>
          <target state="translated">パート&lt;a href=&quot;index#p%3Alibrary&quot;&gt;IV&lt;/a&gt;「OCamlライブラリ」では、標準ライブラリで提供されるモジュールについて説明します。</target>
        </trans-unit>
        <trans-unit id="2f0668847ca907120f5188c16ff537453a2eafe0" translate="yes" xml:space="preserve">
          <source>Part &lt;a href=&quot;index#p%3Arefman&quot;&gt;II&lt;/a&gt;, &amp;ldquo;The OCaml language&amp;rdquo;, is the reference description of the language.</source>
          <target state="translated">パート&lt;a href=&quot;index#p%3Arefman&quot;&gt;II&lt;/a&gt;「OCaml言語」は、言語のリファレンスの説明です。</target>
        </trans-unit>
        <trans-unit id="903f9019ed78ac57cfad4f904e7657f4fe68eff9" translate="yes" xml:space="preserve">
          <source>Part &lt;a href=&quot;index#p%3Atutorials&quot;&gt;I&lt;/a&gt;, &amp;ldquo;An introduction to OCaml&amp;rdquo;, gives an overview of the language.</source>
          <target state="translated">パート&lt;a href=&quot;index#p%3Atutorials&quot;&gt;I&lt;/a&gt;「OCamlの紹介」では、言語の概要を説明します。</target>
        </trans-unit>
        <trans-unit id="b1a2c5985aa86cde57c2ecbbc6cbc8380d79481d" translate="yes" xml:space="preserve">
          <source>Part I An introduction to OCaml</source>
          <target state="translated">第1部 OCamlの紹介</target>
        </trans-unit>
        <trans-unit id="a62eaed854d7e70fe37691fb3a427228618bcb89" translate="yes" xml:space="preserve">
          <source>Part II The OCaml language</source>
          <target state="translated">第二部 OCaml言語</target>
        </trans-unit>
        <trans-unit id="6b5891d0deb20c4e4a3137af20b7932727b436b5" translate="yes" xml:space="preserve">
          <source>Part III The OCaml tools</source>
          <target state="translated">第三部 OCamlツール</target>
        </trans-unit>
        <trans-unit id="a29da75cd43003faab118a1eb6915f585144a3e6" translate="yes" xml:space="preserve">
          <source>Part IV The OCaml library</source>
          <target state="translated">第四部 OCamlライブラリ</target>
        </trans-unit>
        <trans-unit id="952bed16abbd7542df79c253d7d2a383bf3f6501" translate="yes" xml:space="preserve">
          <source>Part V Appendix</source>
          <target state="translated">第五部 付録</target>
        </trans-unit>
        <trans-unit id="259899217f837489155c6afc61bda7baa0892067" translate="yes" xml:space="preserve">
          <source>Partial match: missing cases in pattern-matching.</source>
          <target state="translated">部分一致:パターンマッチングにおけるケースの欠落。</target>
        </trans-unit>
        <trans-unit id="ae3a92949ce10ed0b574a754bc455be19981923a" translate="yes" xml:space="preserve">
          <source>Partially applied function: expression whose result has function type and is ignored.</source>
          <target state="translated">部分的に適用される関数:結果が関数型を持ち、無視される式。</target>
        </trans-unit>
        <trans-unit id="122dc2b1a442a4492301d7cfaae94e0455545b63" translate="yes" xml:space="preserve">
          <source>Pass free variables via specialised arguments rather than closures (an optimisation for reducing allocation). See section &lt;a href=&quot;#ss%3Aflambda-unbox-closures&quot;&gt;21.9.3&lt;/a&gt;. This may have a small performance penalty.</source>
          <target state="translated">クロージャ（割り当てを減らすための最適化）ではなく、特殊な引数を介して自由変数を渡します。セクション&lt;a href=&quot;#ss%3Aflambda-unbox-closures&quot;&gt;21.9.3を&lt;/a&gt;参照してください。これにより、パフォーマンスがわずかに低下する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8139f1329d56ecac27be1fc05605291efd738915" translate="yes" xml:space="preserve">
          <source>Pass the -llibname option to the C linker when linking in &amp;ldquo;custom runtime&amp;rdquo; mode (see the -custom option). This causes the given C library to be linked with the program.</source>
          <target state="translated">「カスタムランタイム」モードでリンクする場合は、-llibnameオプションをCリンカーに渡します（-customオプションを参照）。これにより、指定されたCライブラリがプログラムにリンクされます。</target>
        </trans-unit>
        <trans-unit id="df106032363559c3f40628cbdd6ff4a26fa7fd35" translate="yes" xml:space="preserve">
          <source>Pass the -llibname option to the C linker when linking in &amp;ldquo;custom runtime&amp;rdquo; mode. See the corresponding option for ocamlc, in chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;.</source>
          <target state="translated">「カスタムランタイム」モードでリンクする場合は、-llibnameオプションをCリンカーに渡します。第&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;章のocamlcに対応するオプションを参照してください。</target>
        </trans-unit>
        <trans-unit id="ceed386065448933a097ec35067876966e85d14f" translate="yes" xml:space="preserve">
          <source>Pass the -llibname option to the linker . This causes the given C library to be linked with the program.</source>
          <target state="translated">リンカに -llibname オプションを渡します。これにより、指定された C ライブラリがプログラムにリンクされます。</target>
        </trans-unit>
        <trans-unit id="a59af1bc11afda37b34f10079d3a9dec8ef0d8df" translate="yes" xml:space="preserve">
          <source>Pass the given option to the C compiler and linker, when linking in &amp;ldquo;custom runtime&amp;rdquo; mode. See the corresponding option for ocamlc, in chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;.</source>
          <target state="translated">「カスタムランタイム」モードでリンクする場合は、指定されたオプションをCコンパイラとリンカに渡します。第&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;章のocamlcに対応するオプションを参照してください。</target>
        </trans-unit>
        <trans-unit id="b35478fccd7fbafbf25aff91256c23a1c032cf84" translate="yes" xml:space="preserve">
          <source>Pass the given option to the C compiler and linker. For instance,-ccopt -Ldir causes the C linker to search for C libraries in directory dir.</source>
          <target state="translated">与えられたオプションをCコンパイラとリンカに渡します。例えば、-ccopt -Ldirを指定すると、CリンカはディレクトリdirにあるCライブラリを検索します。</target>
        </trans-unit>
        <trans-unit id="273a7a00d3bf42c46d56c858df14b11822928560" translate="yes" xml:space="preserve">
          <source>Pass the given option to the C compiler and linker. When linking in &amp;ldquo;custom runtime&amp;rdquo; mode, for instance-ccopt -Ldir causes the C linker to search for C libraries in directory dir.(See the -custom option.)</source>
          <target state="translated">指定されたオプションをCコンパイラとリンカに渡します。「カスタムランタイム」モードでリンクする場合、たとえば-ccopt -Ldirを指定すると、Cリンカーはディレクトリdir内のCライブラリを検索します（-customオプションを参照してください）。</target>
        </trans-unit>
        <trans-unit id="72dfe02cbb8cc21321b311387b88011ec8835c71" translate="yes" xml:space="preserve">
          <source>Pattern matching on an extensible variant type requires a default case to handle unknown variant constructors:</source>
          <target state="translated">拡張可能な variant 型でのパターンマッチングでは、未知の variant コンストラクタを処理するためにデフォルトのケースが必要です。</target>
        </trans-unit>
        <trans-unit id="93c3d48bb09ccd90e9aae3bcf8d34d9478c3b2ab" translate="yes" xml:space="preserve">
          <source>Patterns are &lt;em&gt;linear&lt;/em&gt;: a variable cannot be bound several times by a given pattern. In particular, there is no way to test for equality between two parts of a data structure using only a pattern (but when guards can be used for this purpose).</source>
          <target state="translated">パターンは&lt;em&gt;線形&lt;/em&gt;です。変数を特定のパターンで複数回バインドすることはできません。特に、パターンのみを使用してデータ構造の2つの部分が等しいかどうかをテストする方法はありません（ただし、この目的でガードを使用できる場合）。</target>
        </trans-unit>
        <trans-unit id="e3abd39dc618aa8814823785a44aa53f573df633" translate="yes" xml:space="preserve">
          <source>Patterns are templates that allow selecting data structures of a given shape, and binding identifiers to components of the data structure. This selection operation is called pattern matching; its outcome is either &amp;ldquo;this value does not match this pattern&amp;rdquo;, or &amp;ldquo;this value matches this pattern, resulting in the following bindings of names to values&amp;rdquo;.</source>
          <target state="translated">パターンは、特定の形状のデータ構造を選択し、データ構造のコンポーネントに識別子をバインドできるようにするテンプレートです。この選択操作はパターンマッチングと呼ばれます。その結果は、「この値がこのパターンと一致しない」、または「この値がこのパターンと一致するため、名前が値に次のようにバインドされる」という結果になります。</target>
        </trans-unit>
        <trans-unit id="7c689af30d05364792d515c0faaa88a9ab2da162" translate="yes" xml:space="preserve">
          <source>Perform a full major collection and compact the heap.</source>
          <target state="translated">完全なメジャーコレクションを実行し、ヒープをコンパクトにします。</target>
        </trans-unit>
        <trans-unit id="d3d568817e2f7ecd125459c14fd92de23c2c2e40" translate="yes" xml:space="preserve">
          <source>Perform a full major collection and compact the heap. Note that heap compaction is a lengthy operation.</source>
          <target state="translated">完全なメジャーコレクションを実行し、ヒープを圧縮します。ヒープの圧縮は長時間の操作であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="055dbe4520a583e58ae39a293f647d64d4770ec6" translate="yes" xml:space="preserve">
          <source>Perform a transitive reduction of the dependency graph before outputting the dot code. This can be useful if there are a lot of transitive dependencies that clutter the graph.</source>
          <target state="translated">ドットコードを出力する前に、依存関係グラフの推移的縮小を実行します。これは、グラフが乱雑になるような遷移的な依存関係がたくさんある場合に便利です。</target>
        </trans-unit>
        <trans-unit id="f7a67fe1a67339dfb0ee43e9f1cd0038c969bd66" translate="yes" xml:space="preserve">
          <source>Perform even more optimisation than usual, possibly including unrolling of recursive functions. Compilation times may be significantly lengthened.</source>
          <target state="translated">通常よりもさらに多くの最適化を行い、再帰的な関数の展開を含む場合があります。コンパイル時間が大幅に長くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="b87d065999353ac9c7a4517b1177b42e5b1d7054" translate="yes" xml:space="preserve">
          <source>Perform more optimisation than usual. Compilation times may be lengthened. (This flag is an abbreviation for a certain set of parameters described in section &lt;a href=&quot;#s%3Aflambda-defaults&quot;&gt;21.5&lt;/a&gt;.)</source>
          <target state="translated">通常よりも多くの最適化を実行します。コンパイル時間が長くなる可能性があります。（このフラグは、セクション&lt;a href=&quot;#s%3Aflambda-defaults&quot;&gt;21.5で&lt;/a&gt;説明されている特定のパラメーターセットの省略形です。）</target>
        </trans-unit>
        <trans-unit id="22610c9aaccb16a1bee9b7cee9dfb32918779ba0" translate="yes" xml:space="preserve">
          <source>Performance notice: values of type &lt;code&gt;int32&lt;/code&gt; occupy more memory space than values of type &lt;code&gt;int&lt;/code&gt;, and arithmetic operations on &lt;code&gt;int32&lt;/code&gt; are generally slower than those on &lt;code&gt;int&lt;/code&gt;. Use &lt;code&gt;int32&lt;/code&gt; only when the application requires exact 32-bit arithmetic.</source>
          <target state="translated">パフォーマンスに関する注意： &lt;code&gt;int32&lt;/code&gt; 型の値は、 &lt;code&gt;int&lt;/code&gt; 型の値よりも多くのメモリ空間を占有し、 &lt;code&gt;int32&lt;/code&gt; の算術演算は、一般に &lt;code&gt;int&lt;/code&gt; の算術演算よりも遅くなります。 &lt;code&gt;int32&lt;/code&gt; は、アプリケーションが正確な32ビット演算を必要とする場合にのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="662740b47a420ed740a0039a0fb0aa90dd4e339b" translate="yes" xml:space="preserve">
          <source>Performance notice: values of type &lt;code&gt;int64&lt;/code&gt; occupy more memory space than values of type &lt;code&gt;int&lt;/code&gt;, and arithmetic operations on &lt;code&gt;int64&lt;/code&gt; are generally slower than those on &lt;code&gt;int&lt;/code&gt;. Use &lt;code&gt;int64&lt;/code&gt; only when the application requires exact 64-bit arithmetic.</source>
          <target state="translated">パフォーマンスに関する注意： &lt;code&gt;int64&lt;/code&gt; 型の値は、 &lt;code&gt;int&lt;/code&gt; 型の値よりも多くのメモリ空間を占有し、 &lt;code&gt;int64&lt;/code&gt; の算術演算は、一般に &lt;code&gt;int&lt;/code&gt; の算術演算よりも遅くなります。 &lt;code&gt;int64&lt;/code&gt; は、アプリケーションが正確な64ビット演算を必要とする場合にのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="9583bec530f000172f8c0f05a57970fabee45e7c" translate="yes" xml:space="preserve">
          <source>Performance notice: values of type &lt;code&gt;nativeint&lt;/code&gt; occupy more memory space than values of type &lt;code&gt;int&lt;/code&gt;, and arithmetic operations on &lt;code&gt;nativeint&lt;/code&gt; are generally slower than those on &lt;code&gt;int&lt;/code&gt;. Use &lt;code&gt;nativeint&lt;/code&gt; only when the application requires the extra bit of precision over the &lt;code&gt;int&lt;/code&gt; type.</source>
          <target state="translated">パフォーマンス通知：タイプの値は、 &lt;code&gt;nativeint&lt;/code&gt; 型タイプの値よりも多くのメモリ空間占有 &lt;code&gt;int&lt;/code&gt; 型にし、算術演算を &lt;code&gt;nativeint&lt;/code&gt; 型一般的に遅い上のものよりも &lt;code&gt;int&lt;/code&gt; 型。 &lt;code&gt;nativeint&lt;/code&gt; は、アプリケーションが &lt;code&gt;int&lt;/code&gt; 型よりも高い精度を必要とする場合にのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="170a28a9db6d27d7212fc6dc249434a57517e7bc" translate="yes" xml:space="preserve">
          <source>Period</source>
          <target state="translated">Period</target>
        </trans-unit>
        <trans-unit id="d016004473e0e58d7682856755147e33256bb813" translate="yes" xml:space="preserve">
          <source>Permission denied</source>
          <target state="translated">許可拒否</target>
        </trans-unit>
        <trans-unit id="ca053ed9d5deaad2a727eb5b9ce7480cd5b49c87" translate="yes" xml:space="preserve">
          <source>Permit sending of broadcast messages</source>
          <target state="translated">ブロードキャストメッセージの送信を許可する</target>
        </trans-unit>
        <trans-unit id="29e98f8d6c9356b9f9b3cb0dd0fac5d3d678c8e6" translate="yes" xml:space="preserve">
          <source>Physical equality test.</source>
          <target state="translated">物理的な平等性のテスト。</target>
        </trans-unit>
        <trans-unit id="764dcc2a562c9da7446795d50aa77b7dbdc6bc96" translate="yes" xml:space="preserve">
          <source>Physical inequality test.</source>
          <target state="translated">物理的な不等式試験。</target>
        </trans-unit>
        <trans-unit id="9077104dc61ea39ed76dd5e6b7f00ad4f53b057c" translate="yes" xml:space="preserve">
          <source>Pipe abstract syntax trees through preprocessor command.</source>
          <target state="translated">プリプロセッサコマンドで抽象構文木をパイプします。</target>
        </trans-unit>
        <trans-unit id="258a386ac1d80ecc73cf9133d40fece735aa3f44" translate="yes" xml:space="preserve">
          <source>Pipe sources through preprocessor command.</source>
          <target state="translated">プリプロセッサコマンドによるパイプソース</target>
        </trans-unit>
        <trans-unit id="8c0094bdf1788f2095a6baf0ac9fd3dc283b5db4" translate="yes" xml:space="preserve">
          <source>Pipes and redirections</source>
          <target state="translated">パイプとリダイレクト</target>
        </trans-unit>
        <trans-unit id="48afc6d396ff51a5ed35b5868fabdc57f1c9fb87" translate="yes" xml:space="preserve">
          <source>Pollable event</source>
          <target state="translated">汚染可能なイベント</target>
        </trans-unit>
        <trans-unit id="4044893229fcfc93927dd395fda2603f25cbf9b0" translate="yes" xml:space="preserve">
          <source>Polling</source>
          <target state="translated">Polling</target>
        </trans-unit>
        <trans-unit id="b87c82743d31a59fa081b4b5917f7e5fb9a91553" translate="yes" xml:space="preserve">
          <source>Polymorphic methods are called in exactly the same way as normal methods, but you should be aware of some limitations of type inference. Namely, a polymorphic method can only be called if its type is known at the call site. Otherwise, the method will be assumed to be monomorphic, and given an incompatible type.</source>
          <target state="translated">ポリモーフィックメソッドは通常のメソッドと全く同じ方法で呼び出されますが、型推論にはいくつかの制限があることに注意する必要があります。すなわち、ポリモーフィック・メソッドは、呼び出し元で型がわかっている場合にのみ呼び出すことができます。そうでない場合、そのメソッドは単相性があるとみなされ、互換性のない型が与えられます。</target>
        </trans-unit>
        <trans-unit id="9825069b45f85b17a181b73e838bf2e21e0bf759" translate="yes" xml:space="preserve">
          <source>Polymorphic type annotations in let-definitions behave in a way similar to polymorphic methods:</source>
          <target state="translated">let-definitionにおける多相型アノテーションは、多相型メソッドと似たような振る舞いをします。</target>
        </trans-unit>
        <trans-unit id="213691ff9b4dc02fdb3bf4a27f4eb612ef11f926" translate="yes" xml:space="preserve">
          <source>Polymorphic variant tags</source>
          <target state="translated">多形バリアントタグ</target>
        </trans-unit>
        <trans-unit id="22aa46a8a43e1108e30e6c20c787a6de9123751d" translate="yes" xml:space="preserve">
          <source>Polymorphic variant types describe the values a polymorphic variant may take.</source>
          <target state="translated">多相バリアントタイプは、多相バリアントが取ることができる値を記述します。</target>
        </trans-unit>
        <trans-unit id="2029098a5b14173ba88c69574469d4e0ce8f59cd" translate="yes" xml:space="preserve">
          <source>Polymorphic variants are an alternate form of variant values, not belonging explicitly to a predefined variant type, and following specific typing rules. They can be either constant, written `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;, or non-constant, written `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;(v).</source>
          <target state="translated">ポリモーフィックバリアントは、バリアント値の代替形式であり、事前定義されたバリアントタイプに明示的に属しておらず、特定の入力規則に従います。それらは、定数で記述された ` &lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;、または非定数で記述された` &lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;（v）のいずれかです。</target>
        </trans-unit>
        <trans-unit id="2610209437f25d35cbd42b41c775ccdcaf3af336" translate="yes" xml:space="preserve">
          <source>Position (in &lt;a href=&quot;sys#VALargv&quot;&gt;&lt;code&gt;Sys.argv&lt;/code&gt;&lt;/a&gt;) of the argument being processed.</source>
          <target state="translated">処理中の引数の位置（&lt;a href=&quot;sys#VALargv&quot;&gt; &lt;code&gt;Sys.argv&lt;/code&gt; 内&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="45f6ef1f36c845706de35765267136890ed1fd7c" translate="yes" xml:space="preserve">
          <source>Position (in &lt;a href=&quot;sys#VALargv&quot;&gt;&lt;code&gt;Sys.argv&lt;/code&gt;&lt;/a&gt;) of the argument being processed. You can change this value, e.g. to force &lt;a href=&quot;arg#VALparse&quot;&gt;&lt;code&gt;Arg.parse&lt;/code&gt;&lt;/a&gt; to skip some arguments. &lt;a href=&quot;arg#VALparse&quot;&gt;&lt;code&gt;Arg.parse&lt;/code&gt;&lt;/a&gt; uses the initial value of &lt;a href=&quot;arg#VALcurrent&quot;&gt;&lt;code&gt;Arg.current&lt;/code&gt;&lt;/a&gt; as the index of argument 0 (the program name) and starts parsing arguments at the next element.</source>
          <target state="translated">処理中の引数の位置（&lt;a href=&quot;sys#VALargv&quot;&gt; &lt;code&gt;Sys.argv&lt;/code&gt; 内&lt;/a&gt;）。この値を変更して、たとえば&lt;a href=&quot;arg#VALparse&quot;&gt; &lt;code&gt;Arg.parse&lt;/code&gt; &lt;/a&gt;にいくつかの引数をスキップさせることができます。&lt;a href=&quot;arg#VALparse&quot;&gt; &lt;code&gt;Arg.parse&lt;/code&gt; &lt;/a&gt;は、引数0（プログラム名）のインデックスとして&lt;a href=&quot;arg#VALcurrent&quot;&gt; &lt;code&gt;Arg.current&lt;/code&gt; &lt;/a&gt;の初期値を使用し、次の要素で引数の解析を開始します。</target>
        </trans-unit>
        <trans-unit id="48fd514253c1577755278adb384c498032582797" translate="yes" xml:space="preserve">
          <source>Position tracking mode works as follows. At each token, the lexing engine will copy &lt;code&gt;lex_curr_p&lt;/code&gt; to &lt;code&gt;lex_start_p&lt;/code&gt;, then change the &lt;code&gt;pos_cnum&lt;/code&gt; field of &lt;code&gt;lex_curr_p&lt;/code&gt; by updating it with the number of characters read since the start of the &lt;code&gt;lexbuf&lt;/code&gt;. The other fields are left unchanged by the lexing engine. In order to keep them accurate, they must be initialised before the first use of the lexbuf, and updated by the relevant lexer actions (i.e. at each end of line -- see also &lt;code&gt;new_line&lt;/code&gt;).</source>
          <target state="translated">位置追跡モードは次のように機能します。各トークンには、字句エンジンがコピーされます &lt;code&gt;lex_curr_p&lt;/code&gt; に &lt;code&gt;lex_start_p&lt;/code&gt; 、その後、変更 &lt;code&gt;pos_cnum&lt;/code&gt; の分野 &lt;code&gt;lex_curr_p&lt;/code&gt; を開始以来、読み文字の数でそれを更新することにより &lt;code&gt;lexbuf&lt;/code&gt; 。他のフィールドは、字句解析エンジンによって変更されません。それらを正確に保つために、それらはlexbufを最初に使用する前に初期化され、関連するレクサーアクションによって更新される必要があります（つまり、行の両端で &lt;code&gt;new_line&lt;/code&gt; も参照してください）。</target>
        </trans-unit>
        <trans-unit id="d2013d98249e5e8bcfd7d895cc29b28e763b3a92" translate="yes" xml:space="preserve">
          <source>Positioning modes for &lt;a href=&quot;unix#VALlseek&quot;&gt;&lt;code&gt;Unix.lseek&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALlseek&quot;&gt; &lt;code&gt;Unix.lseek&lt;/code&gt; の&lt;/a&gt;ポジショニングモード。</target>
        </trans-unit>
        <trans-unit id="22c07ff7a6172b892fe2ca9c53ec2061c8855ce1" translate="yes" xml:space="preserve">
          <source>Positioning modes for &lt;a href=&quot;unixlabels#VALlseek&quot;&gt;&lt;code&gt;UnixLabels.lseek&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALlseek&quot;&gt; &lt;code&gt;UnixLabels.lseek&lt;/code&gt; の&lt;/a&gt;ポジショニングモード。</target>
        </trans-unit>
        <trans-unit id="cd4683fadf7005eca07e4d6267ddbb19ebcb91fa" translate="yes" xml:space="preserve">
          <source>Positions</source>
          <target state="translated">Positions</target>
        </trans-unit>
        <trans-unit id="653a3645251575bf9279abc23fa56dfc34058739" translate="yes" xml:space="preserve">
          <source>Positive infinity.</source>
          <target state="translated">正の無限大。</target>
        </trans-unit>
        <trans-unit id="f86a729c53a1915ca3654adc8aae51c101d917df" translate="yes" xml:space="preserve">
          <source>Power function.</source>
          <target state="translated">パワー機能。</target>
        </trans-unit>
        <trans-unit id="8fbbe41e74c44588da3a875aa227d393b9e7e864" translate="yes" xml:space="preserve">
          <source>Power function. &lt;code&gt;pow&amp;nbsp;z1&amp;nbsp;z2&lt;/code&gt; returns &lt;code&gt;z1&lt;/code&gt; to the &lt;code&gt;z2&lt;/code&gt; power.</source>
          <target state="translated">べき関数。 &lt;code&gt;pow&amp;nbsp;z1&amp;nbsp;z2&lt;/code&gt; は、 &lt;code&gt;z1&lt;/code&gt; を &lt;code&gt;z2&lt;/code&gt; の累乗に戻します。</target>
        </trans-unit>
        <trans-unit id="5789da79b475d584d15053c8dde659f5c24e3de1" translate="yes" xml:space="preserve">
          <source>Precedence level and associativity of operators</source>
          <target state="translated">演算子の先行レベルと連想性</target>
        </trans-unit>
        <trans-unit id="ef8a0e66b4c1574357482510c167de122caee2aa" translate="yes" xml:space="preserve">
          <source>Predecessor.</source>
          <target state="translated">Predecessor.</target>
        </trans-unit>
        <trans-unit id="b3d4df1b4fc8bba29600c89de44c71635c187145" translate="yes" xml:space="preserve">
          <source>Predecessor. &lt;code&gt;Int32.pred&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;Int32.sub&amp;nbsp;x&amp;nbsp;Int32.one&lt;/code&gt;.</source>
          <target state="translated">前任者。 &lt;code&gt;Int32.pred&amp;nbsp;x&lt;/code&gt; は &lt;code&gt;Int32.sub&amp;nbsp;x&amp;nbsp;Int32.one&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a365fc68958b3868521e16be1f99a37de6553c7a" translate="yes" xml:space="preserve">
          <source>Predecessor. &lt;code&gt;Int64.pred&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;Int64.sub&amp;nbsp;x&amp;nbsp;Int64.one&lt;/code&gt;.</source>
          <target state="translated">前任者。 &lt;code&gt;Int64.pred&amp;nbsp;x&lt;/code&gt; は &lt;code&gt;Int64.sub&amp;nbsp;x&amp;nbsp;Int64.one&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3760cb7859c8cbaa586b1b23829a81faa04f5005" translate="yes" xml:space="preserve">
          <source>Predecessor. &lt;code&gt;Nativeint.pred&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;Nativeint.sub&amp;nbsp;x&amp;nbsp;Nativeint.one&lt;/code&gt;.</source>
          <target state="translated">前任者。 &lt;code&gt;Nativeint.pred&amp;nbsp;x&lt;/code&gt; は &lt;code&gt;Nativeint.sub&amp;nbsp;x&amp;nbsp;Nativeint.one&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a72b78329d76d9323072a7e5e631c531e356e518" translate="yes" xml:space="preserve">
          <source>Predefined data structures include tuples, arrays, and lists. There are also general mechanisms for defining your own data structures, such as records and variants, which will be covered in more detail later; for now, we concentrate on lists. Lists are either given in extension as a bracketed list of semicolon-separated elements, or built from the empty list [] (pronounce &amp;ldquo;nil&amp;rdquo;) by adding elements in front using the :: (&amp;ldquo;cons&amp;rdquo;) operator.</source>
          <target state="translated">事前定義されたデータ構造には、タプル、配列、およびリストが含まれます。レコードやバリアントなど、独自のデータ構造を定義するための一般的なメカニズムもあります。これらについては、後で詳しく説明します。今のところ、リストに集中します。リストは、セミコロンで区切られた要素の括弧で囲まれたリストとして拡張で指定されるか、：:（ &quot;cons&quot;）演算子を使用して前に要素を追加することにより、空のリスト[]（「nil」と発音）から作成されます。</target>
        </trans-unit>
        <trans-unit id="2d1410f8fbd254f890a3355e9bcb2305c86175f5" translate="yes" xml:space="preserve">
          <source>Predefined parsers</source>
          <target state="translated">定義済みパーサ</target>
        </trans-unit>
        <trans-unit id="1f3e08e9e6eb753141109ff66d4be4a3ea38babd" translate="yes" xml:space="preserve">
          <source>Predicates and comparisons</source>
          <target state="translated">述語と比較</target>
        </trans-unit>
        <trans-unit id="90eceb016c51a762f15c7287008c113f6f37296c" translate="yes" xml:space="preserve">
          <source>Prefix</source>
          <target state="translated">Prefix</target>
        </trans-unit>
        <trans-unit id="a46adfa85b9e12a0f2b4120e9bc73717dcfc0bd1" translate="yes" xml:space="preserve">
          <source>Preprocessor warning.</source>
          <target state="translated">プリプロセッサの警告。</target>
        </trans-unit>
        <trans-unit id="9d8c2216bf58d48c75b9b44385be2473949e9115" translate="yes" xml:space="preserve">
          <source>Preprocessors that generate OCaml source code can insert line number directives in their output so that error messages produced by the compiler contain line numbers and file names referring to the source file before preprocessing, instead of after preprocessing. A line number directive is composed of a # (sharp sign), followed by a positive integer (the source line number), optionally followed by a character string (the source file name). Line number directives are treated as blanks during lexical analysis.</source>
          <target state="translated">OCamlソースコードを生成するプリプロセッサは、コンパイラが生成するエラーメッセージに、前処理後ではなく、前処理前にソースファイルを参照する行番号とファイル名が含まれるように、その出力に行番号ディレクティブを挿入することができます。行番号ディレクティブは、#(シャープサイン)の後に正の整数 (ソース行番号)が続き、オプションで文字列 (ソースファイル名)が続きます。行番号ディレクティブは、字句解析の際には空白として扱われます。</target>
        </trans-unit>
        <trans-unit id="bace76147e38ae19d3a0c11609fc9d38e774f7e8" translate="yes" xml:space="preserve">
          <source>Pretty-printing</source>
          <target state="translated">Pretty-printing</target>
        </trans-unit>
        <trans-unit id="1cccabcdd6a358d979939998cc033a04308c5cf5" translate="yes" xml:space="preserve">
          <source>Pretty-printing boxes</source>
          <target state="translated">プリティ印刷の箱</target>
        </trans-unit>
        <trans-unit id="b2a4462f39466982126a74de486bca0779a059f3" translate="yes" xml:space="preserve">
          <source>Pretty-printing termination</source>
          <target state="translated">プリティプリント終了</target>
        </trans-unit>
        <trans-unit id="fb3bd5a8a477c68713e4b63b07bf86de7633d445" translate="yes" xml:space="preserve">
          <source>Pretty-printing.</source>
          <target state="translated">Pretty-printing.</target>
        </trans-unit>
        <trans-unit id="8dc354dacf2179400fda256bb8b5273768f4fa0d" translate="yes" xml:space="preserve">
          <source>Primitives with several arguments are always curried. The C function does not necessarily have the same name as the ML function.</source>
          <target state="translated">複数の引数を持つプリミティブは常にカレー化されます.C関数は必ずしもML関数と同じ名前を持つとは限りません.</target>
        </trans-unit>
        <trans-unit id="4927a230a7393e58f700f3b895b9a8e2141e1502" translate="yes" xml:space="preserve">
          <source>Print a boolean in the current pretty-printing box.</source>
          <target state="translated">現在のプリティ印刷ボックスにブーリアンを印刷します。</target>
        </trans-unit>
        <trans-unit id="429be0de1bf187c6aed029fd0f262066cde03fe6" translate="yes" xml:space="preserve">
          <source>Print a byte sequence on standard error.</source>
          <target state="translated">標準エラーにバイト列を表示します。</target>
        </trans-unit>
        <trans-unit id="c9b40235213e3b9b233db12ee353ee4db3cf9b5e" translate="yes" xml:space="preserve">
          <source>Print a byte sequence on standard output.</source>
          <target state="translated">標準出力にバイト列を印刷します。</target>
        </trans-unit>
        <trans-unit id="a6c581c84ffe95bc9ceacf3ea66bdfc3a0500bac" translate="yes" xml:space="preserve">
          <source>Print a character in the current pretty-printing box.</source>
          <target state="translated">現在のプリティ印刷ボックスに文字を印刷します。</target>
        </trans-unit>
        <trans-unit id="af319c36a4f3c8916104f4d0b89b33a561567553" translate="yes" xml:space="preserve">
          <source>Print a character on standard error.</source>
          <target state="translated">標準誤差に文字を表示します。</target>
        </trans-unit>
        <trans-unit id="26d52b245107b56716114cb4df780a3991c94880" translate="yes" xml:space="preserve">
          <source>Print a character on standard output.</source>
          <target state="translated">標準出力に文字を印刷します。</target>
        </trans-unit>
        <trans-unit id="3800dc392ff64d7282401e28ec9718d894a98136" translate="yes" xml:space="preserve">
          <source>Print a floating point number in the current pretty-printing box.</source>
          <target state="translated">現在のプリティ印刷ボックスに浮動小数点数を印刷します。</target>
        </trans-unit>
        <trans-unit id="d1d3361cbb609b643a25135cfa13aaa39fdd8216" translate="yes" xml:space="preserve">
          <source>Print a floating-point number, in decimal, on standard error.</source>
          <target state="translated">浮動小数点数を10進数で表示します。</target>
        </trans-unit>
        <trans-unit id="1f593ed3a39b6bcdd833537c6e2868f7d6bbca3c" translate="yes" xml:space="preserve">
          <source>Print a floating-point number, in decimal, on standard output.</source>
          <target state="translated">浮動小数点数を10進数で標準出力に出力します。</target>
        </trans-unit>
        <trans-unit id="d6af9922bfeade8a893e020a9b67b642c05b2584" translate="yes" xml:space="preserve">
          <source>Print a list of checkpoints.</source>
          <target state="translated">チェックポイントのリストを印刷します。</target>
        </trans-unit>
        <trans-unit id="87b79eb900647a5ec2eb44f25634fcf150fb96e4" translate="yes" xml:space="preserve">
          <source>Print a newline character on standard error, and flush standard error.</source>
          <target state="translated">標準エラーに改行文字を表示し、標準エラーをフラッシュします。</target>
        </trans-unit>
        <trans-unit id="d02b6c71fe25d1c006f404421e4a18e508b909cb" translate="yes" xml:space="preserve">
          <source>Print a newline character on standard output, and flush standard output.</source>
          <target state="translated">標準出力に改行文字を印刷し、標準出力をフラッシュします。</target>
        </trans-unit>
        <trans-unit id="51802e08b4337c0255ed47927f1d410b8ef886cb" translate="yes" xml:space="preserve">
          <source>Print a newline character on standard output, and flush standard output. This can be used to simulate line buffering of standard output.</source>
          <target state="translated">標準出力に改行文字を印刷し、標準出力をフラッシュします。これは、標準出力の行バッファリングをシミュレートするために使用することができます。</target>
        </trans-unit>
        <trans-unit id="57b23be15f00e2b2a766ad074fcad3032022f804" translate="yes" xml:space="preserve">
          <source>Print a raw backtrace in the same format &lt;code&gt;Printexc.print_backtrace&lt;/code&gt; uses.</source>
          <target state="translated">&lt;code&gt;Printexc.print_backtrace&lt;/code&gt; が使用するのと同じ形式で生のバックトレースを出力します。</target>
        </trans-unit>
        <trans-unit id="c59315f70ac13c50e613039426e9b1da6c2b46f5" translate="yes" xml:space="preserve">
          <source>Print a string on standard error.</source>
          <target state="translated">標準エラーに文字列を表示します。</target>
        </trans-unit>
        <trans-unit id="81468c7ebab1c5a01e13d71f20b9d3f79ab019c7" translate="yes" xml:space="preserve">
          <source>Print a string on standard output.</source>
          <target state="translated">標準出力に文字列を出力します。</target>
        </trans-unit>
        <trans-unit id="239e667539d760b95fb67e7af2b14556bf1672e4" translate="yes" xml:space="preserve">
          <source>Print a string, followed by a newline character on standard error and flush standard error.</source>
          <target state="translated">標準エラーに改行文字が続く文字列を表示し、標準エラーをフラッシュします。</target>
        </trans-unit>
        <trans-unit id="b8454715c8134bb32c9d0b6d5fbc4e1e14a1d87c" translate="yes" xml:space="preserve">
          <source>Print a string, followed by a newline character, on standard output and flush standard output.</source>
          <target state="translated">改行文字の後に続く文字列を標準出力に印刷し、標準出力をフラッシュします。</target>
        </trans-unit>
        <trans-unit id="aea61c3ac5c7b0566ed5cae1ecfdd4c2c861ba39" translate="yes" xml:space="preserve">
          <source>Print all external commands before they are executed, Useful to debug C library problems.</source>
          <target state="translated">実行前にすべての外部コマンドを表示することができ、C ライブラリの問題をデバッグするのに便利です。</target>
        </trans-unit>
        <trans-unit id="7a899efa55e1195ca5fc1dec39f5ecdae93ca337" translate="yes" xml:space="preserve">
          <source>Print all external commands before they are executed, in particular invocations of the C compiler and linker in -custom mode. Useful to debug C library problems.</source>
          <target state="translated">実行前にすべての外部コマンド、特に-custom モードでの C コンパイラとリンカの呼び出しを表示します。C ライブラリの問題をデバッグするのに便利です。</target>
        </trans-unit>
        <trans-unit id="ba058a59bfe6821df26150e86333708758eaa075" translate="yes" xml:space="preserve">
          <source>Print all external commands before they are executed, in particular invocations of the assembler, C compiler, and linker. Useful to debug C library problems.</source>
          <target state="translated">実行前のすべての外部コマンド、特にアセンブラ、C コンパイラ、リンカの呼び出しを表示します。C ライブラリの問題をデバッグするのに便利です。</target>
        </trans-unit>
        <trans-unit id="b5f2c30cc981864c89d951572dd7385b78870825" translate="yes" xml:space="preserve">
          <source>Print an integer in the current pretty-printing box.</source>
          <target state="translated">現在のプリティ印刷ボックスに整数を印刷します。</target>
        </trans-unit>
        <trans-unit id="7301d26fde81fa8ebca08848cc545bc293615fb7" translate="yes" xml:space="preserve">
          <source>Print an integer, in decimal, on standard error.</source>
          <target state="translated">標準誤差に10進数で整数を表示します。</target>
        </trans-unit>
        <trans-unit id="a65bdad25891620217c526a1bfe2956ce94697a0" translate="yes" xml:space="preserve">
          <source>Print an integer, in decimal, on standard output.</source>
          <target state="translated">標準出力に10進数で整数を出力します。</target>
        </trans-unit>
        <trans-unit id="9fd336c14b87ef3c0b1b68245b3a09479680e247" translate="yes" xml:space="preserve">
          <source>Print short version number and exit.</source>
          <target state="translated">短縮版番号を印刷して終了します。</target>
        </trans-unit>
        <trans-unit id="a0d0598affdc572bce9de228afda6b8df92c487b" translate="yes" xml:space="preserve">
          <source>Print the call stack. This is useful to see which sequence of function calls led to the currently executing frame. With a positive argument, print only the innermost count frames. With a negative argument, print only the outermost -count frames.</source>
          <target state="translated">呼び出しスタックを表示します。これは、どの関数呼び出しのシーケンスが現在実行中のフレームにつながっているかを確認するのに便利です。正の引数を指定すると、一番内側のカウントフレームのみを表示します。負の引数を指定すると、一番外側の-countフレームのみを表示します。</target>
        </trans-unit>
        <trans-unit id="ebc9d9bde218642565c4a6b872c662229c0a649a" translate="yes" xml:space="preserve">
          <source>Print the current values of the memory management counters (in human-readable form) into the channel argument.</source>
          <target state="translated">メモリ管理カウンタの現在の値を(人間が読める形式で)チャネル引数に印刷します。</target>
        </trans-unit>
        <trans-unit id="dc013ee29b9caea327ae49687d5fe8992469fe80" translate="yes" xml:space="preserve">
          <source>Print the list of all breakpoints.</source>
          <target state="translated">すべてのブレークポイントのリストを印刷します。</target>
        </trans-unit>
        <trans-unit id="1d6309cbc48bcf93fb84c3b2d1628070ff67c985" translate="yes" xml:space="preserve">
          <source>Print the list of commands.</source>
          <target state="translated">コマンドの一覧を印刷します。</target>
        </trans-unit>
        <trans-unit id="605058b80e7766b1d24469032cba6edad61bd169" translate="yes" xml:space="preserve">
          <source>Print the list of events in the given module (the current module, by default).</source>
          <target state="translated">指定されたモジュール(デフォルトでは現在のモジュール)のイベントのリストを表示します。</target>
        </trans-unit>
        <trans-unit id="d77e8c1c85630588cf87f0de278c43bd22bba915" translate="yes" xml:space="preserve">
          <source>Print the location of the standard library, then exit.</source>
          <target state="translated">標準ライブラリの場所を印刷して終了します。</target>
        </trans-unit>
        <trans-unit id="7a63cdf9922cb9019770831699ca2ec88440cd9f" translate="yes" xml:space="preserve">
          <source>Print the magic number expected by this version of the runtime and exit.</source>
          <target state="translated">このバージョンのランタイムで期待されるマジックナンバーを表示して終了します。</target>
        </trans-unit>
        <trans-unit id="2e3ef87917612025838d457d0180249b2e9da839" translate="yes" xml:space="preserve">
          <source>Print the magic number of the bytecode executable given as argument and exit.</source>
          <target state="translated">引数として与えられたバイトコード実行ファイルのマジックナンバーを表示して終了します。</target>
        </trans-unit>
        <trans-unit id="c72d9d8cbad237171877aaaf4f221e80c28b652a" translate="yes" xml:space="preserve">
          <source>Print the names of the primitives known to this version of ocamlrun and exit.</source>
          <target state="translated">このバージョンの ocamlrun で既知のプリミティブの名前を表示して終了します。</target>
        </trans-unit>
        <trans-unit id="451ad6ffbbc59e311404fa1ba33469fe44332e2f" translate="yes" xml:space="preserve">
          <source>Print the signature of the corresponding component.</source>
          <target state="translated">対応するコンポーネントの署名を印刷します。</target>
        </trans-unit>
        <trans-unit id="ac80a952e8e6f2080883594473fea6bc18893d21" translate="yes" xml:space="preserve">
          <source>Print the signatures of components with name ident in all the above categories.</source>
          <target state="translated">上記の全てのカテゴリで名前がidentのコンポーネントの署名を印刷します。</target>
        </trans-unit>
        <trans-unit id="d5306c346b09fa982bbe727b7d468447dd3c8b02" translate="yes" xml:space="preserve">
          <source>Print the value of a specific configuration variable from the -config output, then exit. If the variable does not exist, the exit code is non-zero. This option is only available since OCaml 4.08, so script authors should have a fallback for older versions.</source>
          <target state="translated">特定の設定変数の値を -config 出力から出力し、終了します。変数が存在しない場合、終了コードは0以外の値になります。このオプションは OCaml 4.08 以降でのみ使用可能なので、スクリプト作成者は古いバージョンのフォールバックを用意しておくべきです。</target>
        </trans-unit>
        <trans-unit id="e07a93c8767c3a47dc5d7c8df32e7ea1d844894b" translate="yes" xml:space="preserve">
          <source>Print the value of the debugger variable variable.</source>
          <target state="translated">デバッガ変数の値を表示します。</target>
        </trans-unit>
        <trans-unit id="c95223754157223c4209b46470cc23e01254d61f" translate="yes" xml:space="preserve">
          <source>Print the values of the given variables. print can be abbreviated as p.</source>
          <target state="translated">与えられた変数の値を表示します。</target>
        </trans-unit>
        <trans-unit id="eeec5e23ff4ea21114a2bb9f163e9c3c32699c18" translate="yes" xml:space="preserve">
          <source>Print the version number of ocamlc and a detailed summary of its configuration, then exit.</source>
          <target state="translated">ocamlcのバージョン番号と設定の詳細な要約を印刷して終了します。</target>
        </trans-unit>
        <trans-unit id="f991152ef21a1e26c709ecfc065e65ac98aa7ae9" translate="yes" xml:space="preserve">
          <source>Print the version number of ocamlopt and a detailed summary of its configuration, then exit.</source>
          <target state="translated">ocamloptのバージョン番号と設定の詳細な要約を印刷して終了します。</target>
        </trans-unit>
        <trans-unit id="debb51048032a6428ea36a4a0ee08b746d4a77db" translate="yes" xml:space="preserve">
          <source>Print the version number of the compiler and the location of the standard library directory, then exit.</source>
          <target state="translated">コンパイラのバージョン番号と標準ライブラリのディレクトリの場所を表示して終了します。</target>
        </trans-unit>
        <trans-unit id="2fe4aaf2f5e45563655a656455ed20e66a1462f4" translate="yes" xml:space="preserve">
          <source>Print the version number of the compiler in short form (e.g. 3.11.0), then exit.</source>
          <target state="translated">コンパイラのバージョン番号を短い形式(例:3.11.0)で表示し、終了します。</target>
        </trans-unit>
        <trans-unit id="6f76b94e10000b8d214946bc7f1bda961d7f3c84" translate="yes" xml:space="preserve">
          <source>Print the working directory for ocamldebug.</source>
          <target state="translated">ocamldebugの作業ディレクトリを表示します。</target>
        </trans-unit>
        <trans-unit id="d9213c853b1c42118f3c94b86c97afa5e9fd9869" translate="yes" xml:space="preserve">
          <source>Print version string and exit.</source>
          <target state="translated">バージョン文字列を印刷して終了します。</target>
        </trans-unit>
        <trans-unit id="4e959478171465cf9e996cbfb9a74d21f6548b19" translate="yes" xml:space="preserve">
          <source>Printexc</source>
          <target state="translated">Printexc</target>
        </trans-unit>
        <trans-unit id="49c6710eb43a270c0d99f60d369594f6b1f09d42" translate="yes" xml:space="preserve">
          <source>Printf</source>
          <target state="translated">Printf</target>
        </trans-unit>
        <trans-unit id="2d9a110ab864d8027d59b85870bd7507b21f2b32" translate="yes" xml:space="preserve">
          <source>Prints a list of all available directives, with corresponding argument type if appropriate.</source>
          <target state="translated">利用可能なすべてのディレクティブのリストを、適切な場合は対応する引数の型とともに表示します。</target>
        </trans-unit>
        <trans-unit id="3d0169f16c8bbedbeb3705f057d992b36bb4c783" translate="yes" xml:space="preserve">
          <source>Prior to OCaml 4.06, there were a number of restrictions: one could only remove types and modules at the outermost level (not inside submodules), and in the case of with type the definition had to be another type constructor with the same type parameters.</source>
          <target state="translated">OCaml 4.06以前には、いくつかの制限がありました。型とモジュールを削除できるのは最外層(サブモジュールの内部ではなく)のみで、型付きの場合は定義は同じ型パラメータを持つ別の型コンストラクタでなければなりませんでした。</target>
        </trans-unit>
        <trans-unit id="994eb8f645a2e271bf1f8673e4483c670cc953a0" translate="yes" xml:space="preserve">
          <source>Private method made public implicitly.</source>
          <target state="translated">暗黙のうちに公開されたプライベートメソッド</target>
        </trans-unit>
        <trans-unit id="165156bef8f5f2f887c0fff1c8cc018aec48829d" translate="yes" xml:space="preserve">
          <source>Private methods are inherited (they are by default visible in subclasses), unless they are hidden by signature matching, as described below.</source>
          <target state="translated">プライベートメソッドは継承されます (デフォルトではサブクラスで表示されます)。</target>
        </trans-unit>
        <trans-unit id="6e9361563af3076dde9f52a56836232ccfd3da4f" translate="yes" xml:space="preserve">
          <source>Private methods are methods that do not appear in object interfaces. They can only be invoked from other methods of the same object.</source>
          <target state="translated">プライベートメソッドとは、オブジェクトインターフェイスには現れないメソッドのことです。これらのメソッドは、同じオブジェクトの他のメソッドからのみ呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="f5e7b644834b86be6fc64d7be1a52e0d85f180ab" translate="yes" xml:space="preserve">
          <source>Private methods can be made public in a subclass.</source>
          <target state="translated">プライベートメソッドはサブクラスで公開することができます。</target>
        </trans-unit>
        <trans-unit id="1c59d88954e8cc2ecd75753618fa9214f76b159d" translate="yes" xml:space="preserve">
          <source>Private row types are type abbreviations where part of the structure of the type is left abstract. Concretely &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; in the above should denote either an object type or a polymorphic variant type, with some possibility of refinement left. If the private declaration is used in an interface, the corresponding implementation may either provide a ground instance, or a refined private type.</source>
          <target state="translated">プライベート行タイプは、タイプの構造の一部が抽象のままであるタイプの省略形です。具体的には、上記の&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;は、オブジェクト型または多形型バリアント型のいずれかを示している必要がありますが、改良の可能性が残っています。プライベート宣言がインターフェイスで使用される場合、対応する実装は、グラウンドインスタンス、または洗練されたプライベートタイプのいずれかを提供します。</target>
        </trans-unit>
        <trans-unit id="cb686dcfd0b69cd31f6a449daa606192aede292e" translate="yes" xml:space="preserve">
          <source>Private type declarations in module signatures, of the form type t = private ..., enable libraries to reveal some, but not all aspects of the implementation of a type to clients of the library. In this respect, they strike a middle ground between abstract type declarations, where no information is revealed on the type implementation, and data type definitions and type abbreviations, where all aspects of the type implementation are publicized. Private type declarations come in three flavors: for variant and record types (section &lt;a href=&quot;#ss%3Aprivate-types-variant&quot;&gt;8.3.1&lt;/a&gt;), for type abbreviations (section &lt;a href=&quot;#ss%3Aprivate-types-abbrev&quot;&gt;8.3.2&lt;/a&gt;), and for row types (section &lt;a href=&quot;#ss%3Aprivate-rows&quot;&gt;8.3.3&lt;/a&gt;).</source>
          <target state="translated">タイプt = private ...の形式のモジュール署名のプライベート型宣言により、ライブラリは、ライブラリのクライアントに型の実装のすべてではないが一部の側面を明らかにすることができます。この点で、これらは、型の実装に関する情報が公開されていない抽象型宣言と、型の実装のすべての側面が公開されているデータ型の定義および型の省略形との中間に位置します。プライベート型宣言には、バリアント型とレコード型（セクション&lt;a href=&quot;#ss%3Aprivate-types-variant&quot;&gt;8.3.1&lt;/a&gt;）、型の省略形（セクション&lt;a href=&quot;#ss%3Aprivate-types-abbrev&quot;&gt;8.3.2&lt;/a&gt;）、および行型（セクション&lt;a href=&quot;#ss%3Aprivate-rows&quot;&gt;8.3.3&lt;/a&gt;）の3つの種類があります。</target>
        </trans-unit>
        <trans-unit id="59b94c84bf3c7510e8be0728f720ae8fe7ce120f" translate="yes" xml:space="preserve">
          <source>Process file as a .ml file.</source>
          <target state="translated">ファイルを.mlファイルとして処理します。</target>
        </trans-unit>
        <trans-unit id="2522d3db6f5a48e899f57863a3c7250dfc54b325" translate="yes" xml:space="preserve">
          <source>Process file as a .mli file.</source>
          <target state="translated">ファイルを.mliファイルとして処理します。</target>
        </trans-unit>
        <trans-unit id="473f55eac53bc8ce93f412c1c946aa28996d5086" translate="yes" xml:space="preserve">
          <source>Process file as a file name, even if it starts with a dash (-) character.</source>
          <target state="translated">ダッシュ(-)文字で始まる場合でも、ファイル名としてファイルを処理します。</target>
        </trans-unit>
        <trans-unit id="fd5dbcb4f5b812065ae1369a8e3dde027c4b2109" translate="yes" xml:space="preserve">
          <source>Process file as the grammar specification, even if its name starts with a dash (-) character. This option must be the last on the command line.</source>
          <target state="translated">ファイル名がダッシュ(-)文字で始まっていても、文法指定として処理します。このオプションは、コマンドラインの最後に指定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="0588b71974aef4ab5b2e1fdf75767f0460174967" translate="yes" xml:space="preserve">
          <source>Process handling</source>
          <target state="translated">プロセスハンドリング</target>
        </trans-unit>
        <trans-unit id="f7450c7a1b38c58c319dbbe91b6f643f07f53490" translate="yes" xml:space="preserve">
          <source>Process the file filename as a text file, even if its extension is not .txt.</source>
          <target state="translated">拡張子が.txtでない場合でも、ファイル名をテキストファイルとして処理します。</target>
        </trans-unit>
        <trans-unit id="15640d84a678dcf20fe0f7b4064e40aca256536e" translate="yes" xml:space="preserve">
          <source>Process the file filename as an implementation file, even if its extension is not .ml.</source>
          <target state="translated">ファイル名の拡張子が.mlでなくても、実装ファイルとして処理します。</target>
        </trans-unit>
        <trans-unit id="34a335c98c4d1d8038830a8a0365142ca983d65b" translate="yes" xml:space="preserve">
          <source>Process the file filename as an interface file, even if its extension is not .mli.</source>
          <target state="translated">ファイル名の拡張子が.mliでなくても、インターフェイスファイルとして処理します。</target>
        </trans-unit>
        <trans-unit id="968e872ce419fcfe72f51852dada13fcf08024c1" translate="yes" xml:space="preserve">
          <source>Processor-native integers.</source>
          <target state="translated">プロセッサネイティブの整数。</target>
        </trans-unit>
        <trans-unit id="b4186ada56824b293fd62da84a86d8573ac62f45" translate="yes" xml:space="preserve">
          <source>Profiling interrupt</source>
          <target state="translated">プロファイリング割り込み</target>
        </trans-unit>
        <trans-unit id="a6ea8abb2d5aee6b3ffd36cd9d01f1bea2305efb" translate="yes" xml:space="preserve">
          <source>Profiling of a program's space behaviour over time.</source>
          <target state="translated">プログラムの宇宙空間での振る舞いを経時的にプロファイリング。</target>
        </trans-unit>
        <trans-unit id="6ef3f3bc4c4c8078545ca3c591413a9d5b343787" translate="yes" xml:space="preserve">
          <source>Profiling of a program's space behaviour over time. Currently only supported on x86-64 platforms running 64-bit code.</source>
          <target state="translated">プログラムの空間の挙動を時間をかけてプロファイリングします。現在のところ、64ビットコードを実行するx86-64プラットフォームでのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="723b0e2b1580f96f4e037bd5029db086fd9ab217" translate="yes" xml:space="preserve">
          <source>Profiling with ocamlprof only records execution counts, not the actual time spent within each function. There is currently no way to perform time profiling on bytecode programs generated by ocamlc. For time profiling of native code, users are recommended to use standard tools such as perf (on Linux), Instruments (on macOS) and DTrace. Profiling with gprof is no longer supported.</source>
          <target state="translated">ocamlprofによるプロファイリングは実行回数を記録するだけで、各関数内で実際に使われた時間は記録されません。現在のところ、ocamlcによって生成されたバイトコードプログラムの時間プロファイリングを実行する方法はありません。ネイティブコードの時間プロファイリングには、perf (Linux)、Instruments (macOS)、DTraceなどの標準的なツールを使うことをお勧めします。gprofによるプロファイリングはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="9d68007b0763cb230f9034ec96f52b39d03ad630" translate="yes" xml:space="preserve">
          <source>Program</source>
          <target state="translated">Program</target>
        </trans-unit>
        <trans-unit id="bd74641b834d4b980ea6b99d6f71d4205f5d04af" translate="yes" xml:space="preserve">
          <source>Program termination</source>
          <target state="translated">プログラム終了</target>
        </trans-unit>
        <trans-unit id="6b2d4e1f190973fd4686a60486cb7a38ca6a26aa" translate="yes" xml:space="preserve">
          <source>Programmers which come to rely on the internal API for a use-case which they find realistic and useful are encouraged to open a request for improvement on the bug tracker.</source>
          <target state="translated">現実的で便利だと思うユースケースのために内部APIに依存するようになったプログラマは、バグトラッカー上で改善のためのリクエストを公開することが推奨されています。</target>
        </trans-unit>
        <trans-unit id="3b712ae7d0703efbf3d9ee4609e41b3f3cd65989" translate="yes" xml:space="preserve">
          <source>Programs built with Spacetime instrumentation have a dependency on the libunwind library unless that was unavailable at configure time or the -disable-libunwind option was specified (see section &lt;a href=&quot;#s%3Aspacetime-runtimeoverhead&quot;&gt;22.3&lt;/a&gt;).</source>
          <target state="translated">Spacetimeインストルメンテーションでビルドされたプログラムは、configure時に使用できないか、-disable-libunwindオプションが指定されていない限り、libunwindライブラリに依存します（セクション&lt;a href=&quot;#s%3Aspacetime-runtimeoverhead&quot;&gt;22.3を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="0fa08ed45d5cab3757f6b4a975eb9165de6f9e78" translate="yes" xml:space="preserve">
          <source>Programs running with Spacetime instrumentation consume significantly more memory than their non-instrumented counterparts. It is expected that this memory overhead will also be reduced in the future.</source>
          <target state="translated">時空インストルメンテーションを使用して実行されるプログラムは、インストルメンテーションを使用していないプログラムと比較して、大幅に多くのメモリを消費します。このメモリオーバーヘッドも将来的には減少すると予想されています。</target>
        </trans-unit>
        <trans-unit id="63eb6a78b9751a02e1fca63835a2dcf55273437c" translate="yes" xml:space="preserve">
          <source>Programs that use system threads must be linked as follows:</source>
          <target state="translated">システムスレッドを使用するプログラムは、以下のようにリンクする必要があります。</target>
        </trans-unit>
        <trans-unit id="0718dd6f86f5aa1f5dc9d3d0b3619bb6a1c50300" translate="yes" xml:space="preserve">
          <source>Programs that use the dynlink library simply need to link dynlink.cma or dynlink.cmxa with their object files and other libraries.</source>
          <target state="translated">dynlink ライブラリを使用するプログラムは、dynlink.cma または dynlink.cmxa をオブジェクトファイルや他のライブラリとリンクするだけでよい。</target>
        </trans-unit>
        <trans-unit id="0463620b1afee3e694aec11b31b76a4b1f96ef6a" translate="yes" xml:space="preserve">
          <source>Programs that use the str library must be linked as follows:</source>
          <target state="translated">strライブラリを使用するプログラムは、以下のようにリンクする必要があります。</target>
        </trans-unit>
        <trans-unit id="7a42d2cc2a8eda80048327543bb9aaaac9921c36" translate="yes" xml:space="preserve">
          <source>Programs that use the unix library must be linked as follows:</source>
          <target state="translated">unix ライブラリを使用するプログラムは、以下のようにリンクする必要があります。</target>
        </trans-unit>
        <trans-unit id="9639408739caea934aae30d0b4689565093312fd" translate="yes" xml:space="preserve">
          <source>Propose the same interface as usual hash table. However since the bindings are weak, even if &lt;code&gt;mem&amp;nbsp;h&amp;nbsp;k&lt;/code&gt; is true, a subsequent &lt;code&gt;find&amp;nbsp;h&amp;nbsp;k&lt;/code&gt; may raise &lt;code&gt;Not_found&lt;/code&gt; because the garbage collector can run between the two.</source>
          <target state="translated">通常のハッシュテーブルと同じインターフェースを提案します。ただし、バインディングが弱いため、 &lt;code&gt;mem&amp;nbsp;h&amp;nbsp;k&lt;/code&gt; がtrueであっても、ガベージコレクターが2つの間で実行される可能性があるため、後続の &lt;code&gt;find&amp;nbsp;h&amp;nbsp;k&lt;/code&gt; &lt;code&gt;Not_found&lt;/code&gt; する可能性があります。</target>
        </trans-unit>
        <trans-unit id="677789471bfc26b9baa2dcb7bdc1e90f13c9beac" translate="yes" xml:space="preserve">
          <source>Protocol family not supported</source>
          <target state="translated">サポートされていないプロトコルファミリ</target>
        </trans-unit>
        <trans-unit id="59bb2975367cf35f9a618efe163f6de98389a1c2" translate="yes" xml:space="preserve">
          <source>Protocol not available</source>
          <target state="translated">プロトコルが利用できない</target>
        </trans-unit>
        <trans-unit id="05ba63ff22fffa946a6c1e3e8b9d184a5a911e55" translate="yes" xml:space="preserve">
          <source>Protocol not supported</source>
          <target state="translated">サポートされていないプロトコル</target>
        </trans-unit>
        <trans-unit id="3ff5f085a157b60cb28dba0860f39cd3e12b11e1" translate="yes" xml:space="preserve">
          <source>Protocol wrong type for socket</source>
          <target state="translated">ソケットのプロトコルのタイプが間違っている</target>
        </trans-unit>
        <trans-unit id="c4d4ebfdd03b691f619d61cbe366c6ce68fc905a" translate="yes" xml:space="preserve">
          <source>Provides</source>
          <target state="translated">Provides</target>
        </trans-unit>
        <trans-unit id="2c6c2f6ed5db6aa314135e5ee7ea36dd719021ca" translate="yes" xml:space="preserve">
          <source>Pseudo-random number generators (PRNG).</source>
          <target state="translated">擬似乱数発生器(PRNG)。</target>
        </trans-unit>
        <trans-unit id="1b0ee00b6267b2378862d1f872c21158ec230b1a" translate="yes" xml:space="preserve">
          <source>Put f and g in the same module.</source>
          <target state="translated">fとgを同じモジュールに入れます。</target>
        </trans-unit>
        <trans-unit id="938d4423167ad6f26c3a678405b921c5056207ce" translate="yes" xml:space="preserve">
          <source>Put the calling process in a new session and detach it from its controlling terminal.</source>
          <target state="translated">呼び出し中のプロセスを新しいセッションに入れて、制御している端末から切り離します。</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="d325fcd919384f395c02751e03d2cd0288b98cca" translate="yes" xml:space="preserve">
          <source>Queue</source>
          <target state="translated">Queue</target>
        </trans-unit>
        <trans-unit id="caf4b4627b80a9efca6390b0b35ddb954aa1057f" translate="yes" xml:space="preserve">
          <source>Quiet mode. ocamllex normally outputs informational messages to standard output. They are suppressed if option -q is used.</source>
          <target state="translated">ocamllex は通常、情報メッセージを標準出力に出力します。オプション -q が使用された場合、これらのメッセージは出力されません。</target>
        </trans-unit>
        <trans-unit id="34ac50a5c5471cd48d6cd7a69a966ff47405312e" translate="yes" xml:space="preserve">
          <source>Quit character (usually ctrl-\).</source>
          <target state="translated">文字を終了します。</target>
        </trans-unit>
        <trans-unit id="eb98a3a6f1365300e275eadb0e82fb6a60fe00cb" translate="yes" xml:space="preserve">
          <source>Quite often, this happens when defining function using higher order function. To avoid this problem, a solution is to add an explicit argument to the function:</source>
          <target state="translated">これは、高次関数を使って関数を定義する場合によく起こります。この問題を回避するには、関数に明示的な引数を追加することです。</target>
        </trans-unit>
        <trans-unit id="c053941a8974103fdf9adc10b4e10c54a97ef236" translate="yes" xml:space="preserve">
          <source>Quoted string literals provide an alternative lexical syntax for string literals. They are useful to represent strings of arbitrary content without escaping. Quoted strings are delimited by a matching pair of {&lt;a href=&quot;#quoted-string-id&quot;&gt;quoted-string-id&lt;/a&gt;| and |&lt;a href=&quot;#quoted-string-id&quot;&gt;quoted-string-id&lt;/a&gt;} with the same &lt;a href=&quot;#quoted-string-id&quot;&gt;quoted-string-id&lt;/a&gt; on both sides. Quoted strings do not interpret any character in a special way but requires that the sequence |&lt;a href=&quot;#quoted-string-id&quot;&gt;quoted-string-id&lt;/a&gt;} does not occur in the string itself. The identifier &lt;a href=&quot;#quoted-string-id&quot;&gt;quoted-string-id&lt;/a&gt; is a (possibly empty) sequence of lowercase letters and underscores that can be freely chosen to avoid such issue (e.g. {|hello|}, {ext|hello {|world|}|ext}, ...).</source>
          <target state="translated">引用符で囲まれた文字列リテラルは、文字列リテラルの代替の字句構文を提供します。これらは、エスケープせずに任意のコンテンツの文字列を表すのに役立ちます。引用符で囲まれた文字列は、{ &lt;a href=&quot;#quoted-string-id&quot;&gt;quoted-string-id&lt;/a&gt; |の一致するペアで区切られます。および|両側に同じ&lt;a href=&quot;#quoted-string-id&quot;&gt;quoted-string-id&lt;/a&gt;を持つ&lt;a href=&quot;#quoted-string-id&quot;&gt;quoted-string-id&lt;/a&gt; } 。引用符で囲まれた文字列は、文字を特別な方法で解釈しませんが、シーケンス| &lt;a href=&quot;#quoted-string-id&quot;&gt;quoted-string-id&lt;/a&gt; }は、文字列自体には含まれません。識別子&lt;a href=&quot;#quoted-string-id&quot;&gt;quoted-string-id&lt;/a&gt;は、このような問題を回避するために自由に選択できる小文字とアンダースコアの（おそらく空の）シーケンスです（例：{| hello |}、{ext | hello {| world |} | ext}、。 ..）。</target>
        </trans-unit>
        <trans-unit id="06576556d1ad802f247cad11ae748be47b70cd9c" translate="yes" xml:space="preserve">
          <source>R</source>
          <target state="translated">R</target>
        </trans-unit>
        <trans-unit id="e2bea001712992baa23e8c78c49863e0902c0ce2" translate="yes" xml:space="preserve">
          <source>Radix</source>
          <target state="translated">Radix</target>
        </trans-unit>
        <trans-unit id="7f36ea5d3de965c70c84ceca6f79a298f9099835" translate="yes" xml:space="preserve">
          <source>Raise &lt;a href=&quot;scanf#EXCEPTIONScan_failure&quot;&gt;&lt;code&gt;Scanf.Scan_failure&lt;/code&gt;&lt;/a&gt; if the input does not match the format.</source>
          <target state="translated">レイズ&lt;a href=&quot;scanf#EXCEPTIONScan_failure&quot;&gt; &lt;code&gt;Scanf.Scan_failure&lt;/code&gt; を&lt;/a&gt;入力フォーマットと一致しない場合。</target>
        </trans-unit>
        <trans-unit id="36954e0616fd4ab6826cea4b2073a23dd8a2d4f9" translate="yes" xml:space="preserve">
          <source>Raise &lt;code&gt;End_of_file&lt;/code&gt; if the end of input is encountered while some more characters are needed to read the current conversion specification.</source>
          <target state="translated">現在の変換仕様を読み取るためにさらにいくつかの文字が必要なときに入力の終わりに遭遇した場合は、 &lt;code&gt;End_of_file&lt;/code&gt; を上げます。</target>
        </trans-unit>
        <trans-unit id="95b72d1aa196f806e25d927281ae1551701421c8" translate="yes" xml:space="preserve">
          <source>Raise &lt;code&gt;Failure&lt;/code&gt; if a conversion to a number is not possible.</source>
          <target state="translated">レイズ &lt;code&gt;Failure&lt;/code&gt; 数への変換ができない場合。</target>
        </trans-unit>
        <trans-unit id="4636335a7fccd892fe73a73b7c56c21ea55d250f" translate="yes" xml:space="preserve">
          <source>Raise &lt;code&gt;Invalid_argument&lt;/code&gt; if the format string is invalid.</source>
          <target state="translated">レイズ &lt;code&gt;Invalid_argument&lt;/code&gt; フォーマット文字列が無効である場合。</target>
        </trans-unit>
        <trans-unit id="216738342707122846d4fd6eb0c45706f7b73de1" translate="yes" xml:space="preserve">
          <source>Raise exception &lt;code&gt;Failure&lt;/code&gt; with the given string.</source>
          <target state="translated">指定された文字列で例外 &lt;code&gt;Failure&lt;/code&gt; を発生させます。</target>
        </trans-unit>
        <trans-unit id="491cba7a17e27d1b41d46ea369641a1550e51813" translate="yes" xml:space="preserve">
          <source>Raise exception &lt;code&gt;Invalid_argument&lt;/code&gt; with the given string.</source>
          <target state="translated">指定された文字列で例外 &lt;code&gt;Invalid_argument&lt;/code&gt; を発生させます。</target>
        </trans-unit>
        <trans-unit id="501ee443ddbcf53091ea1067a9ae3f57f6ebfd33" translate="yes" xml:space="preserve">
          <source>Raise the given exception value</source>
          <target state="translated">与えられた例外値を上げる</target>
        </trans-unit>
        <trans-unit id="d60f8969db97c2bb35b2563ab6ed6e4f03404bad" translate="yes" xml:space="preserve">
          <source>Raised by &lt;code&gt;Arg.parse_argv&lt;/code&gt; when the user asks for help.</source>
          <target state="translated">ユーザーが助けを求めたときに &lt;code&gt;Arg.parse_argv&lt;/code&gt; によって発生します。</target>
        </trans-unit>
        <trans-unit id="27f983f5e162cd924b236f06287a0bff869f30db" translate="yes" xml:space="preserve">
          <source>Raised by parsers when none of the first components of the stream patterns is accepted.</source>
          <target state="translated">ストリームパターンの最初の構成要素がどれも受け入れられない場合に、パーサによって発生します。</target>
        </trans-unit>
        <trans-unit id="952a898b7a6fd8d0bc9671d84982b32bf6b9fe77" translate="yes" xml:space="preserve">
          <source>Raised by parsers when the first component of a stream pattern is accepted, but one of the following components is rejected.</source>
          <target state="translated">ストリームパターンの最初のコンポーネントが受け入れられたが、次のコンポーネントのいずれかが拒否された場合に、パーサによって発生します。</target>
        </trans-unit>
        <trans-unit id="60fda7c1c7cec524ae01e28e6f47d5fde4832cac" translate="yes" xml:space="preserve">
          <source>Raised by the system calls below when an error is encountered.</source>
          <target state="translated">エラーが発生した場合、以下のシステムコールで発生します。</target>
        </trans-unit>
        <trans-unit id="a87f07092a3a001bf1b834aa708db58b4b2fc5a9" translate="yes" xml:space="preserve">
          <source>Raised by the system calls below when an error is encountered. The first component is the error code; the second component is the function name; the third component is the string parameter to the function, if it has one, or the empty string otherwise.</source>
          <target state="translated">エラーが発生した場合、以下のシステムコールで発生します。第一成分はエラーコード、第二成分は関数名、第三成分は関数の文字列パラメータ (パラメータがある場合はその文字列、そうでない場合は空文字列)です。</target>
        </trans-unit>
        <trans-unit id="194b55d81062da090b368377d76b9a43588fb263" translate="yes" xml:space="preserve">
          <source>Raised when &lt;a href=&quot;queue#VALtake&quot;&gt;&lt;code&gt;Queue.take&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;queue#VALpeek&quot;&gt;&lt;code&gt;Queue.peek&lt;/code&gt;&lt;/a&gt; is applied to an empty queue.</source>
          <target state="translated">場合に発生し&lt;a href=&quot;queue#VALtake&quot;&gt; &lt;code&gt;Queue.take&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;queue#VALpeek&quot;&gt; &lt;code&gt;Queue.peek&lt;/code&gt; が&lt;/a&gt;空のキューに適用されます。</target>
        </trans-unit>
        <trans-unit id="70c7459e6d2df687f73674d472326ed2008cb773" translate="yes" xml:space="preserve">
          <source>Raised when &lt;a href=&quot;stack#VALpop&quot;&gt;&lt;code&gt;Stack.pop&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stack#VALtop&quot;&gt;&lt;code&gt;Stack.top&lt;/code&gt;&lt;/a&gt; is applied to an empty stack.</source>
          <target state="translated">場合に発生し&lt;a href=&quot;stack#VALpop&quot;&gt; &lt;code&gt;Stack.pop&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;stack#VALtop&quot;&gt; &lt;code&gt;Stack.top&lt;/code&gt; が&lt;/a&gt;空のスタックに適用されます。</target>
        </trans-unit>
        <trans-unit id="23d24598ec09335bef9be1ec042a3cc6569685ca" translate="yes" xml:space="preserve">
          <source>Raised when a parser encounters a syntax error.</source>
          <target state="translated">構文エラーが発生した場合に発生します。</target>
        </trans-unit>
        <trans-unit id="f202fef5cc0e634106d4608a58d1831f7472ff13" translate="yes" xml:space="preserve">
          <source>Raised when a parser encounters a syntax error. Can also be raised from the action part of a grammar rule, to initiate error recovery.</source>
          <target state="translated">パーサーが構文エラーに遭遇したときに発生します。エラー回復を開始するために、文法ルールのアクション部分から発生させることもできます。</target>
        </trans-unit>
        <trans-unit id="2ae11633db0e7da3516b2e0225f22dfb074f61b7" translate="yes" xml:space="preserve">
          <source>Raises an invalid argument exception if the returned geometry does not satisfy &lt;a href=&quot;format#VALcheck_geometry&quot;&gt;&lt;code&gt;Format.check_geometry&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返されたジオメトリが&lt;a href=&quot;format#VALcheck_geometry&quot;&gt; &lt;code&gt;Format.check_geometry&lt;/code&gt; を&lt;/a&gt;満たさない場合、無効な引数の例外が発生します。</target>
        </trans-unit>
        <trans-unit id="e41f4a95b91b1b7d3f518258afac3a6e567857f5" translate="yes" xml:space="preserve">
          <source>Raising arbitrary exceptions from C is more delicate: the exception identifier is dynamically allocated by the OCaml program, and therefore must be communicated to the C function using the registration facility described below in section &lt;a href=&quot;#ss%3Ac-register-exn&quot;&gt;20.7.3&lt;/a&gt;. Once the exception identifier is recovered in C, the following functions actually raise the exception:</source>
          <target state="translated">Cから任意の例外を発生させることはより繊細です。例外識別子はOCamlプログラムによって動的に割り当てられるため、以下のセクション&lt;a href=&quot;#ss%3Ac-register-exn&quot;&gt;20.7.3で&lt;/a&gt;説明する登録機能を使用してC関数に伝達する必要があります。例外識別子がCで回復されると、次の関数が実際に例外を発生させます。</target>
        </trans-unit>
        <trans-unit id="58d888c08aa561f370e38cee976121532a883d71" translate="yes" xml:space="preserve">
          <source>Random</source>
          <target state="translated">Random</target>
        </trans-unit>
        <trans-unit id="d00e5de923d2fb499cc63830a172dced4874a46e" translate="yes" xml:space="preserve">
          <source>Raw backtrace slots</source>
          <target state="translated">生のバックトレーススロット</target>
        </trans-unit>
        <trans-unit id="e4ce60b8828e956013eeab15d66339b705f8bbb9" translate="yes" xml:space="preserve">
          <source>Raw backtraces</source>
          <target state="translated">生のバックトレース</target>
        </trans-unit>
        <trans-unit id="b5b8cb76a84d201ebabeaff1f6e3a3a5860bdc27" translate="yes" xml:space="preserve">
          <source>Raw backtraces cannot be marshalled. If you need marshalling, you should use the array returned by the &lt;code&gt;backtrace_slots&lt;/code&gt; function of the next section.</source>
          <target state="translated">生のバックトレースはマーシャリングできません。マーシャリングが必要な場合は、次のセクションの &lt;code&gt;backtrace_slots&lt;/code&gt; 関数によって返される配列を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="a377c099adff515091e70dcb22c7db7203b2316a" translate="yes" xml:space="preserve">
          <source>Raw socket</source>
          <target state="translated">生のソケット</target>
        </trans-unit>
        <trans-unit id="4cb7c0865348e2999ad6f51a8b71faa68d7a22f8" translate="yes" xml:space="preserve">
          <source>Re-exported variant type or record type: an equation, a representation.</source>
          <target state="translated">再度エクスポートされたバリアント型またはレコード型:方程式、表現。</target>
        </trans-unit>
        <trans-unit id="64dfcf3ac85b42a4d5f54acc3201c4eef3261f89" translate="yes" xml:space="preserve">
          <source>Re-schedule the calling thread without suspending it.</source>
          <target state="translated">呼び出しスレッドを中断せずに再スケジュールします。</target>
        </trans-unit>
        <trans-unit id="f2512ca26766e71583adc6edd50373f5839822c3" translate="yes" xml:space="preserve">
          <source>Re-schedule the calling thread without suspending it. This function can be used to give scheduling hints, telling the scheduler that now is a good time to switch to other threads.</source>
          <target state="translated">呼び出したスレッドを中断せずに再スケジューリングします。この関数は、スケジューラにスケジューリングのヒントを与え、他のスレッドに切り替えるのに適したタイミングであることを伝えます。</target>
        </trans-unit>
        <trans-unit id="38b32003b07368691f1f80f28b6e5008499f9ee7" translate="yes" xml:space="preserve">
          <source>Re-shaping Bigarrays</source>
          <target state="translated">ビガレイの再整形</target>
        </trans-unit>
        <trans-unit id="ccc014cfb02135583355873ad00c0361f061abe4" translate="yes" xml:space="preserve">
          <source>Read a 4-byte float</source>
          <target state="translated">4 バイトのフロートの読み込み</target>
        </trans-unit>
        <trans-unit id="6ce591d11020ba17c35a7b7213eb3d8a7f2e7397" translate="yes" xml:space="preserve">
          <source>Read a digest from the given input channel.</source>
          <target state="translated">与えられた入力チャンネルからダイジェストを読み込みます。</target>
        </trans-unit>
        <trans-unit id="6abf4e7e7c125c3e76e1801fe87fa4883e72f6b5" translate="yes" xml:space="preserve">
          <source>Read a signed 1-byte integer</source>
          <target state="translated">符号付き1バイト整数の読み込み</target>
        </trans-unit>
        <trans-unit id="71fe81b04c2829d569497cb34072d498c20d57df" translate="yes" xml:space="preserve">
          <source>Read a signed 2-byte integer</source>
          <target state="translated">符号付き2バイト整数の読み込み</target>
        </trans-unit>
        <trans-unit id="b16c938fdffeee8bd1dbcd5043af23124f4907c3" translate="yes" xml:space="preserve">
          <source>Read a signed 4-byte integer</source>
          <target state="translated">符号付き4バイト整数の読み込み</target>
        </trans-unit>
        <trans-unit id="ded1b67059cacac26764983c31cbd02b0e0cac19" translate="yes" xml:space="preserve">
          <source>Read a signed 8-byte integer</source>
          <target state="translated">符号付き8バイト整数の読み込み</target>
        </trans-unit>
        <trans-unit id="d30e01e9ef051947cd7c2401618bc8954386d497" translate="yes" xml:space="preserve">
          <source>Read additional newline-terminated command line arguments from filename.</source>
          <target state="translated">ファイル名から、改行で終わるコマンドライン引数を追加で読み込みます。</target>
        </trans-unit>
        <trans-unit id="d60d751c7d878040cce554ef4627185c7b2d3920" translate="yes" xml:space="preserve">
          <source>Read additional newline-terminated command line arguments from filename. It is not possible to pass a scriptfile via file to the toplevel.</source>
          <target state="translated">filename から、改行終端のコマンドライン引数を追加で読み込みます。ファイル経由のscriptfileをtoplevelに渡すことはできません。</target>
        </trans-unit>
        <trans-unit id="76835ba4a31ac07483f46f43fa6c985ae1bff9b6" translate="yes" xml:space="preserve">
          <source>Read additional null character terminated command line arguments from filename.</source>
          <target state="translated">ファイル名からヌル文字で終了したコマンドライン引数を追加で読み込みます。</target>
        </trans-unit>
        <trans-unit id="2122d0c469288519c91629a369aa2bba0ff43acd" translate="yes" xml:space="preserve">
          <source>Read additional null character terminated command line arguments from filename. It is not possible to pass a scriptfile via file to the toplevel.</source>
          <target state="translated">ヌル文字で終了したコマンドライン引数をファイル名から追加で読み込みます。ファイル経由でscriptfileをtoplevelに渡すことはできません。</target>
        </trans-unit>
        <trans-unit id="7a26fe31a2c0a8c7224fa3039d8cfb00b78512e3" translate="yes" xml:space="preserve">
          <source>Read an 8-byte float</source>
          <target state="translated">8 バイトのフロートの読み込み</target>
        </trans-unit>
        <trans-unit id="f0d6329ef4b06a86875dd2b3a89bd475040195a4" translate="yes" xml:space="preserve">
          <source>Read an array of 1-byte quantities</source>
          <target state="translated">1バイト量の配列を読み込む</target>
        </trans-unit>
        <trans-unit id="31f8cf88f9bcfee42eab62d3bcc4e91f216fbcbe" translate="yes" xml:space="preserve">
          <source>Read an array of 2-byte quantities</source>
          <target state="translated">2バイト量の配列を読み込む</target>
        </trans-unit>
        <trans-unit id="629ec05ac2ba9fa5ed43a7da5945c4794a87ff25" translate="yes" xml:space="preserve">
          <source>Read an array of 4-byte quantities</source>
          <target state="translated">4バイト量の配列を読み込む</target>
        </trans-unit>
        <trans-unit id="4271deb4d0b3a7e8812b99d0449d3e1b0240445d" translate="yes" xml:space="preserve">
          <source>Read an array of 8-byte quantities</source>
          <target state="translated">8バイト量の配列を読み込む</target>
        </trans-unit>
        <trans-unit id="ac825a1f3b1937d32ea50c327b0ba22a748ffda1" translate="yes" xml:space="preserve">
          <source>Read an element of a generic Bigarray.</source>
          <target state="translated">ジェネリックビグレイの要素を読む</target>
        </trans-unit>
        <trans-unit id="9c41d1ccd2cf647c34256b9f1a313fa0d3f1bcd9" translate="yes" xml:space="preserve">
          <source>Read an element of a generic Bigarray. &lt;code&gt;Genarray.get&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt; returns the element of &lt;code&gt;a&lt;/code&gt; whose coordinates are &lt;code&gt;i1&lt;/code&gt; in the first dimension, &lt;code&gt;i2&lt;/code&gt; in the second dimension, ..., &lt;code&gt;iN&lt;/code&gt; in the &lt;code&gt;N&lt;/code&gt;-th dimension.</source>
          <target state="translated">一般的なBigarrayの要素を読み取ります。 &lt;code&gt;Genarray.get&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt; の要素を返し、その座標である &lt;code&gt;i1&lt;/code&gt; 最初の次元で、 &lt;code&gt;i2&lt;/code&gt; を第二次元での、...、 &lt;code&gt;iN&lt;/code&gt; における &lt;code&gt;N&lt;/code&gt; 番目のディメンション。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="67349a86f7563898607682268ae95a1f61056dc9" translate="yes" xml:space="preserve">
          <source>Read an integer encoded in binary format (4 bytes, big-endian) from the given input channel.</source>
          <target state="translated">指定された入力チャンネルからバイナリ形式(4 バイト、ビッグエンディアン)でエンコードされた整数を読み込みます。</target>
        </trans-unit>
        <trans-unit id="33e9c74f4180396e136f31afbdcec851f5f66b00" translate="yes" xml:space="preserve">
          <source>Read an integer encoded in binary format (4 bytes, big-endian) from the given input channel. See &lt;a href=&quot;stdlib#VALoutput_binary_int&quot;&gt;&lt;code&gt;output_binary_int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指定された入力チャネルから、バイナリ形式（4バイト、ビッグエンディアン）でエンコードされた整数を読み取ります。&lt;a href=&quot;stdlib#VALoutput_binary_int&quot;&gt; &lt;code&gt;output_binary_int&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7ac938561144649bc1155f569e56036f2fdfd2c7" translate="yes" xml:space="preserve">
          <source>Read an propagate the delayed dependencies for module aliases in file, so that the following files will depend on the exported aliased modules if they use them. See the example below.</source>
          <target state="translated">ファイル内のモジュールエイリアスの遅延依存関係を伝搬して、次のファイルがエイリアスされたモジュールを使用する場合に、エクスポートされたエイリアスされたモジュールに依存するように読み込みます。以下の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="886ea27c8bec585df975149a00402cd79c637ee6" translate="yes" xml:space="preserve">
          <source>Read an unsigned 1-byte integer</source>
          <target state="translated">符号なし1バイト整数の読み込み</target>
        </trans-unit>
        <trans-unit id="a0c70c66a803617f07522cf4c684939542a5fba7" translate="yes" xml:space="preserve">
          <source>Read an unsigned 2-byte integer</source>
          <target state="translated">符号なし2バイト整数の読み込み</target>
        </trans-unit>
        <trans-unit id="50bbf9a0280a7ce2b8bbbe0030193ddd1a363831" translate="yes" xml:space="preserve">
          <source>Read an unsigned 4-byte integer</source>
          <target state="translated">符号なし4バイト整数の読み込み</target>
        </trans-unit>
        <trans-unit id="316d26280ca41288433d99fb399411a2cc1faadb" translate="yes" xml:space="preserve">
          <source>Read an unsigned 8-byte integer</source>
          <target state="translated">符号なし8バイト整数の読み込み</target>
        </trans-unit>
        <trans-unit id="e86508915a0d56a2f11022c831d9f04464b83ca9" translate="yes" xml:space="preserve">
          <source>Read characters from the given input channel, until a newline character is encountered.</source>
          <target state="translated">指定された入力チャンネルから、改行文字が見つかるまで文字を読み込みます。</target>
        </trans-unit>
        <trans-unit id="73846446201ce3c7e60e58af2642dc5ece7a008d" translate="yes" xml:space="preserve">
          <source>Read characters from the given input channel, until a newline character is encountered. Return the string of all characters read, without the newline character at the end.</source>
          <target state="translated">指定された入力チャンネルから、改行文字が見つかるまで文字を読み込みます。読み込んだすべての文字の文字列を返します。</target>
        </trans-unit>
        <trans-unit id="f8f467b17b835e6d668da3cfd0cd0dff2106036b" translate="yes" xml:space="preserve">
          <source>Read debugger commands from the script filename.</source>
          <target state="translated">スクリプトのファイル名からデバッガコマンドを読み込みます。</target>
        </trans-unit>
        <trans-unit id="9f666d340bc1a11b2f16b993b989b8d17ce60207" translate="yes" xml:space="preserve">
          <source>Read one character from the given input channel.</source>
          <target state="translated">指定された入力チャンネルから1文字を読み込みます。</target>
        </trans-unit>
        <trans-unit id="9131dce42813e8ec41b39beb9e3ff10f19dc602b" translate="yes" xml:space="preserve">
          <source>Read permission</source>
          <target state="translated">許可を読む</target>
        </trans-unit>
        <trans-unit id="5e0313b5eab47220b914011434d8a7cc69c1dfa7" translate="yes" xml:space="preserve">
          <source>Read the contents of a link.</source>
          <target state="translated">リンク先の内容を読む。</target>
        </trans-unit>
        <trans-unit id="1101c25e2994338c1c2eb973a4f3f47e5e391381" translate="yes" xml:space="preserve">
          <source>Read the contents of a symbolic link.</source>
          <target state="translated">シンボリックリンクの内容を読み込みます。</target>
        </trans-unit>
        <trans-unit id="31a359da53b69b3ea6b092a55c310d55d6ebea95" translate="yes" xml:space="preserve">
          <source>Read the grammar specification from standard input. The default output file names are stdin.ml and stdin.mli.</source>
          <target state="translated">標準入力から文法指定を読み込みます。デフォルトの出力ファイル名は stdin.ml と stdin.mli です。</target>
        </trans-unit>
        <trans-unit id="18b8434ffb8be92faae1a806cd108694f763b2b0" translate="yes" xml:space="preserve">
          <source>Read the representation of a structured value, as produced by &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt;&lt;code&gt;output_value&lt;/code&gt;&lt;/a&gt;, and return the corresponding value.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALoutput_value&quot;&gt; &lt;code&gt;output_value&lt;/code&gt; &lt;/a&gt;によって生成された構造化値の表現を読み取り、対応する値を返します。</target>
        </trans-unit>
        <trans-unit id="1b341d52843a5bf78cfe433947040df998396cbe" translate="yes" xml:space="preserve">
          <source>Read the representation of a structured value, as produced by &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt;&lt;code&gt;output_value&lt;/code&gt;&lt;/a&gt;, and return the corresponding value. This function is identical to &lt;a href=&quot;marshal#VALfrom_channel&quot;&gt;&lt;code&gt;Marshal.from_channel&lt;/code&gt;&lt;/a&gt;; see the description of module &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; for more information, in particular concerning the lack of type safety.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALoutput_value&quot;&gt; &lt;code&gt;output_value&lt;/code&gt; &lt;/a&gt;によって生成された構造化値の表現を読み取り、対応する値を返します。この関数は&lt;a href=&quot;marshal#VALfrom_channel&quot;&gt; &lt;code&gt;Marshal.from_channel&lt;/code&gt; &lt;/a&gt;と同じです。特に型安全性の欠如に関する詳細については、モジュール&lt;a href=&quot;marshal&quot;&gt; &lt;code&gt;Marshal&lt;/code&gt; &lt;/a&gt;の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="e9627fd30596032c688ad807a751d4e103b2c13d" translate="yes" xml:space="preserve">
          <source>Read the standard input as a script file rather than starting an interactive session.</source>
          <target state="translated">対話的なセッションを開始するのではなく、スクリプトファイルとして標準入力を読み込みます。</target>
        </trans-unit>
        <trans-unit id="c0827111eae7b98567c87474f4b43f73cf9df084" translate="yes" xml:space="preserve">
          <source>Read, compile and execute source phrases from the given file. This is textual inclusion: phrases are processed just as if they were typed on standard input. The reading of the file stops at the first error encountered.</source>
          <target state="translated">与えられたファイルからソースフレーズを読み込み、コンパイルし、実行します。これはテキストインクルージョンです:フレーズは標準入力で入力されたかのように処理されます。ファイルの読み込みは、最初のエラーが発生した時点で停止します。</target>
        </trans-unit>
        <trans-unit id="fd7967994dfc943a9d75a158de2c9b6edcab50b2" translate="yes" xml:space="preserve">
          <source>Read-only file system</source>
          <target state="translated">読み取り専用ファイルシステム</target>
        </trans-unit>
        <trans-unit id="e251a56e473195fc043435e63c0bd44f25861fa8" translate="yes" xml:space="preserve">
          <source>Reading format strings from input</source>
          <target state="translated">入力からフォーマット文字列を読み込む</target>
        </trans-unit>
        <trans-unit id="5f40594d4332209f624490fba4a21a0d8f2420fc" translate="yes" xml:space="preserve">
          <source>Reads complete as writes (depending on O_SYNC/O_DSYNC)</source>
          <target state="translated">書き込みとして読み込み完了(O_SYNC/O_DSYNCによる</target>
        </trans-unit>
        <trans-unit id="06d761e12b94d1da8094c742a6a4c7e7ebc3906f" translate="yes" xml:space="preserve">
          <source>Reasonable defaults for functions &lt;code&gt;out_spaces&lt;/code&gt; and &lt;code&gt;out_newline&lt;/code&gt; are respectively &lt;code&gt;out_funs.out_string&amp;nbsp;(String.make&amp;nbsp;n&amp;nbsp;'&amp;nbsp;')&amp;nbsp;0&amp;nbsp;n&lt;/code&gt; and &lt;code&gt;out_funs.out_string&amp;nbsp;&quot;\n&quot;&amp;nbsp;0&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;out_spaces&lt;/code&gt; と &lt;code&gt;out_newline&lt;/code&gt; の妥当なデフォルトは、それぞれ &lt;code&gt;out_funs.out_string&amp;nbsp;(String.make&amp;nbsp;n&amp;nbsp;'&amp;nbsp;')&amp;nbsp;0&amp;nbsp;n&lt;/code&gt; &lt;code&gt;out_funs.out_string&amp;nbsp;&quot;\n&quot;&amp;nbsp;0&amp;nbsp;1&lt;/code&gt; とout_funs.out_string &quot;\ n&quot; 01です。</target>
        </trans-unit>
        <trans-unit id="9b3342b2d0538c1531ee9aae57b07f20c9dab43f" translate="yes" xml:space="preserve">
          <source>Receive data from a connected socket.</source>
          <target state="translated">接続されたソケットからデータを受信します。</target>
        </trans-unit>
        <trans-unit id="495d38b61f84619813658e11cf80eb64bc551bc0" translate="yes" xml:space="preserve">
          <source>Receive data from an unconnected socket.</source>
          <target state="translated">接続されていないソケットからデータを受信します。</target>
        </trans-unit>
        <trans-unit id="1a799052460df4566a7952caba304831fe0a14ce" translate="yes" xml:space="preserve">
          <source>Reception is enabled.</source>
          <target state="translated">受付が有効になっています。</target>
        </trans-unit>
        <trans-unit id="95acc15fad87944379696aedcca3bee2d5c818f5" translate="yes" xml:space="preserve">
          <source>Recognize XON/XOFF characters on input.</source>
          <target state="translated">入力時にXON/XOFF文字を認識します。</target>
        </trans-unit>
        <trans-unit id="61eee862a5e72ab7ea8fe95e4746a73711431897" translate="yes" xml:space="preserve">
          <source>Recognize file names ending with string as interface files (instead of the default .mli).</source>
          <target state="translated">文字列で終わるファイル名をインターフェイスファイルとして認識するようになりました (デフォルトの .mli の代わりに)。</target>
        </trans-unit>
        <trans-unit id="347a8e34dcdfe0c261bbae1b232251ad673cf4a9" translate="yes" xml:space="preserve">
          <source>Record debugging information</source>
          <target state="translated">デバッグ情報の記録</target>
        </trans-unit>
        <trans-unit id="910f4030ea52bda376b5aa3aca46c5ba6aa007f1" translate="yes" xml:space="preserve">
          <source>Record fields</source>
          <target state="translated">レコードフィールド</target>
        </trans-unit>
        <trans-unit id="ab31373329ebda7a9ecee39f6fc1d37f1ce7c824" translate="yes" xml:space="preserve">
          <source>Record fields can also be accessed through pattern-matching:</source>
          <target state="translated">レコードフィールドは、パターンマッチングによってアクセスすることもできます。</target>
        </trans-unit>
        <trans-unit id="a1cf7c53e7cf560426af957246ab1c5b36c8505f" translate="yes" xml:space="preserve">
          <source>Record fields can also be modified by assignment, provided they are declared mutable in the definition of the record type:</source>
          <target state="translated">レコードフィールドは、レコードタイプの定義でミューティアブルと宣言されていれば、代入によって変更することもできます。</target>
        </trans-unit>
        <trans-unit id="26b2a5b6fdc37fc99da7b0607b037ff3a884f246" translate="yes" xml:space="preserve">
          <source>Record values are labeled tuples of values. The record value written {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=v&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip;;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=v&lt;sub&gt;n&lt;/sub&gt;} associates the value v&lt;sub&gt;i&lt;/sub&gt; to the record field &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;, for i = 1 &amp;hellip; n. The current implementation supports records with up to 2&lt;sup&gt;22&lt;/sup&gt; &amp;minus; 1 fields (4194303 fields).</source>
          <target state="translated">レコード値には、値のタプルのラベルが付けられます。書き込まれたレコード値{&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; = v &lt;sub&gt;1&lt;/sub&gt; ; &amp;hellip;;&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; = V &lt;sub&gt;N&lt;/sub&gt; }は、V値を関連付ける&lt;sub&gt;I&lt;/sub&gt;レコードフィールドに&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;iが&lt;/sub&gt;I = 1のため、... N。現在の実装では、最大2 &lt;sup&gt;22&lt;/sup&gt; &amp;minus; 1フィールド（4194303フィールド）のレコードがサポートされています。</target>
        </trans-unit>
        <trans-unit id="a02fbaf92ab6f668ba8c58db00c88fa0b033da16" translate="yes" xml:space="preserve">
          <source>Records are also represented by zero-tagged blocks. The ordering of labels in the record type declaration determines the layout of the record fields: the value associated to the label declared first is stored in field 0 of the block, the value associated to the second label goes in field 1, and so on.</source>
          <target state="translated">レコードは、ゼロタグ付きのブロックでも表現されます。最初に宣言されたラベルに関連付けられた値はブロックのフィールド0に格納され、2番目のラベルに関連付けられた値はフィールド1に格納されるなど、レコードタイプ宣言におけるラベルの順序はレコードフィールドのレイアウトを決定します。</target>
        </trans-unit>
        <trans-unit id="50a39f91dc419f213f3f430557f69794fa4719cc" translate="yes" xml:space="preserve">
          <source>Recursive classes can be used to define objects whose types are mutually recursive.</source>
          <target state="translated">再帰的なクラスは、型が相互に再帰的なオブジェクトを定義するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="57f808596bec53448916381d4754315ccc18b74d" translate="yes" xml:space="preserve">
          <source>Recursive definitions of names are introduced by letrec:</source>
          <target state="translated">名前の再帰的な定義はletrecによって導入されています。</target>
        </trans-unit>
        <trans-unit id="a4779850ffe8cff34ad7d948ec38d13e841f8164" translate="yes" xml:space="preserve">
          <source>Recursive functions are defined with the let rec binding:</source>
          <target state="translated">再帰関数はlet recバインディングで定義されます。</target>
        </trans-unit>
        <trans-unit id="1d353d1981023ac46b358959ff73a6f6b4d85dd9" translate="yes" xml:space="preserve">
          <source>Recursive module definitions, introduced by the module rec &amp;hellip;and &amp;hellip; construction, generalize regular module definitions module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;=&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; and module specifications module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; by allowing the defining &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; and the &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; to refer recursively to the module identifiers being defined. A typical example of a recursive module definition is:</source>
          <target state="translated">モジュールrec&amp;hellip;および&amp;hellip;構築によって導入された再帰モジュール定義は、通常のモジュール定義を一般化します。modulemodule &lt;a href=&quot;names#module-name&quot;&gt;-name&lt;/a&gt; = &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;およびモジュール仕様modulemodule &lt;a href=&quot;names#module-name&quot;&gt;-name&lt;/a&gt;：&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;を定義することにより、&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;および&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;を定義されているモジュール識別子を再帰的に参照します。再帰モジュール定義の典型的な例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="eb8e04bf713983ca46edb8008396708aa79152e5" translate="yes" xml:space="preserve">
          <source>Redefining formatter output</source>
          <target state="translated">フォーマッタ出力の再定義</target>
        </trans-unit>
        <trans-unit id="1e482b78115537fa1c38984758e5cd15f5753d32" translate="yes" xml:space="preserve">
          <source>Redefining output functions</source>
          <target state="translated">出力機能の再定義</target>
        </trans-unit>
        <trans-unit id="1a791fb89307dba01bce8608462fad99f40b16f5" translate="yes" xml:space="preserve">
          <source>Redefining semantic tag operations</source>
          <target state="translated">セマンティックタグ操作の再定義</target>
        </trans-unit>
        <trans-unit id="ff0501a0bef34fc88116df27f2efa64b96b25ae6" translate="yes" xml:space="preserve">
          <source>Redirect the standard pretty-printer output to the given channel.</source>
          <target state="translated">標準のプリティプリンタの出力を指定されたチャンネルにリダイレクトします。</target>
        </trans-unit>
        <trans-unit id="c1f536bf9044d5654bf01fe4a0d29f6dd1268674" translate="yes" xml:space="preserve">
          <source>Redirect the standard pretty-printer output to the given channel. (All the output functions of the standard formatter are set to the default output functions printing to the given channel.)</source>
          <target state="translated">標準プリティープリンタの出力を指定されたチャンネルにリダイレクトします。(標準フォーマッタのすべての出力関数は、指定されたチャンネルに印刷するデフォルトの出力関数に設定されています)。</target>
        </trans-unit>
        <trans-unit id="bc5c411817f17db821dafb6a6686007ee18c9713" translate="yes" xml:space="preserve">
          <source>Redirecting the standard formatter output</source>
          <target state="translated">標準フォーマッタ出力のリダイレクト</target>
        </trans-unit>
        <trans-unit id="16f6909a6a6e1cc00213c91c99a81a703a9ee676" translate="yes" xml:space="preserve">
          <source>Redundant case in a pattern matching (unused match case).</source>
          <target state="translated">パターンマッチングでの冗長ケース(未使用のマッチケース)。</target>
        </trans-unit>
        <trans-unit id="238fe5d52f17b0fe9911a63bfec331920e535cc6" translate="yes" xml:space="preserve">
          <source>Redundant sub-pattern in a pattern-matching.</source>
          <target state="translated">パターンマッチングでの冗長なサブパターン。</target>
        </trans-unit>
        <trans-unit id="37aba70e342850096daafd45baa804ba09bbd307" translate="yes" xml:space="preserve">
          <source>Refer to documentation on yacc for more details and guidance in how to use error recovery.</source>
          <target state="translated">エラー回復の使用方法の詳細とガイダンスについては、yaccのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="49711308b42a4846bba12eba8a7e15f9e53d5624" translate="yes" xml:space="preserve">
          <source>Reference assignment (update the reference given as first argument with the value of the second argument).</source>
          <target state="translated">参照の代入(第1引数に与えられた参照を第2引数の値で更新する)。</target>
        </trans-unit>
        <trans-unit id="122a8c607714911f9c55a95520ba352930d18102" translate="yes" xml:space="preserve">
          <source>Reference cells can be implemented as objects. The naive definition fails to typecheck:</source>
          <target state="translated">参照セルはオブジェクトとして実装することができます。ナイーブな定義ではタイプチェックに失敗します。</target>
        </trans-unit>
        <trans-unit id="9de79c805af623bf5ca8641671f754beff12d79f" translate="yes" xml:space="preserve">
          <source>Reference the regular expression bound to &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; by an earlier let&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;=&lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt; definition.</source>
          <target state="translated">以前の&lt;a href=&quot;lex#ident&quot;&gt;letident&lt;/a&gt; = &lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;定義によって&lt;a href=&quot;lex#ident&quot;&gt;identに&lt;/a&gt;バインドされた正規表現を参照します。</target>
        </trans-unit>
        <trans-unit id="a091fe7db1bf4411fef339d55d431e81767afbcb" translate="yes" xml:space="preserve">
          <source>Reference to undefined global mod</source>
          <target state="translated">未定義のグローバルMODへの参照</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="4694bd4be677ce4663069cbb84ca82da59029a24" translate="yes" xml:space="preserve">
          <source>References are also useful to write functions that maintain a current state between two calls to the function. For instance, the following pseudo-random number generator keeps the last returned number in a reference:</source>
          <target state="translated">参照は、2回の関数呼び出しの間に現在の状態を維持する関数を書くのにも便利です。例えば、以下の擬似乱数発生器は、最後に返された数値をリファレンスに保持します。</target>
        </trans-unit>
        <trans-unit id="cf1a98eb8bda259c5e6b53f5f44a52d8c3f772c6" translate="yes" xml:space="preserve">
          <source>Refill handlers are a recent (optional) feature introduced in 4.02, documented below in subsection &lt;a href=&quot;#ss%3Arefill-handlers&quot;&gt;13.2.7&lt;/a&gt;.</source>
          <target state="translated">リフィルハンドラーは、4.02で導入された最近の（オプションの）機能であり、以下のサブセクション&lt;a href=&quot;#ss%3Arefill-handlers&quot;&gt;13.2.7に記載されてい&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="1f6e9c6e085af786bdc00af692163b916a0cfeee" translate="yes" xml:space="preserve">
          <source>Regarding the atomicity guarantees given by &lt;code&gt;~cloexec:true&lt;/code&gt; or by the use of the &lt;code&gt;O_CLOEXEC&lt;/code&gt; flag: on all platforms it is guaranteed that a concurrently-executing Caml thread cannot leak the descriptor by starting a new process. On Linux, this guarantee extends to concurrently-executing C threads. As of Feb 2017, other operating systems lack the necessary system calls and still expose a window of vulnerability during which a C thread can see the newly-created file descriptor in ``keep-on-exec'' mode.</source>
          <target state="translated">&lt;code&gt;~cloexec:true&lt;/code&gt; または &lt;code&gt;O_CLOEXEC&lt;/code&gt; フラグの使用によって与えられるアトミック性の保証に関して：すべてのプラットフォームで、同時に実行されるCamlスレッドが新しいプロセスを開始することによって記述子をリークできないことが保証されます。Linuxでは、この保証は同時に実行されるCスレッドにも適用されます。2017年2月の時点で、他のオペレーティングシステムには必要なシステムコールがなく、Cスレッドが新しく作成されたファイル記述子を「keep-on-exec」モードで見ることができる脆弱性のウィンドウがまだ公開されています。</target>
        </trans-unit>
        <trans-unit id="77d7183b5b67f0148ca5d09be4416ccc6e902609" translate="yes" xml:space="preserve">
          <source>Register the function named printer-name (a value path) as a printer for objects whose types match the argument type of the function. That is, the debugger will call printer-name when it has such an object to print. The printing function printer-name must use the Format library module to produce its output, otherwise its output will not be correctly located in the values printed by the toplevel loop.</source>
          <target state="translated">型が関数の引数の型と一致するオブジェクトのプリンタとして printer-name という名前の関数 (値のパス)を登録します。つまり、デバッガは、印刷するオブジェクトがあるときに printer-name を呼び出します。印刷関数 printer-name は、Format ライブラリ・モジュールを使用して出力を生成する必要があります。</target>
        </trans-unit>
        <trans-unit id="d7abeab29a5ab9bb4cd5dff7b62e29222042952f" translate="yes" xml:space="preserve">
          <source>Register the given function to be called at program termination time.</source>
          <target state="translated">プログラム終了時に呼び出される関数を登録します。</target>
        </trans-unit>
        <trans-unit id="46539f816e7562760cc9adc223f7359c10aad574" translate="yes" xml:space="preserve">
          <source>Register the given function to be called at program termination time. The functions registered with &lt;code&gt;at_exit&lt;/code&gt; will be called when the program does any of the following:</source>
          <target state="translated">プログラム終了時に呼び出される特定の関数を登録します。 &lt;code&gt;at_exit&lt;/code&gt; に登録されている関数は、プログラムが次のいずれかを実行したときに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="ca874b55b0f92111a93cd652711639493fdbfb06" translate="yes" xml:space="preserve">
          <source>Registering OCaml values with the C runtime.</source>
          <target state="translated">OCamlの値をCランタイムに登録します。</target>
        </trans-unit>
        <trans-unit id="ee478efa11b298959e74cf6618239180535fbb82" translate="yes" xml:space="preserve">
          <source>Registration of a global variable v is achieved by calling caml_register_global_root(&amp;amp;v) just before or just after a valid value is stored in v for the first time; likewise, registration of an arbitrary location p is achieved by calling caml_register_global_root(p).</source>
          <target state="translated">グローバル変数vの登録は、有効な値がvに初めて格納される直前または直後にcaml_register_global_root（＆v）を呼び出すことによって実現されます。同様に、任意の場所pの登録は、caml_register_global_root（p）を呼び出すことによって実現されます。</target>
        </trans-unit>
        <trans-unit id="3172c4ae8fee97c04bb506eac2e6f47443f5a679" translate="yes" xml:space="preserve">
          <source>Regular expressions</source>
          <target state="translated">正規表現</target>
        </trans-unit>
        <trans-unit id="5c96cb6f219058eabf8872d9c4a4d120512db91e" translate="yes" xml:space="preserve">
          <source>Regular expressions and high-level string processing</source>
          <target state="translated">正規表現と高レベルの文字列処理</target>
        </trans-unit>
        <trans-unit id="c8a073b89aebe0e05ff91f4dd2316f67e5c58000" translate="yes" xml:space="preserve">
          <source>Regular file</source>
          <target state="translated">通常のファイル</target>
        </trans-unit>
        <trans-unit id="09f7c403fe69451818e2b0ac1a8669a89a95d11b" translate="yes" xml:space="preserve">
          <source>Reject invalid formats that were accepted in legacy format implementations. You should use this flag to detect and fix such invalid formats, as they will be rejected by future OCaml versions.</source>
          <target state="translated">レガシーフォーマットの実装で受け入れられた無効なフォーマットを拒否します。このフラグを使用して、将来の OCaml バージョンでは拒否されるので、このような無効なフォーマットを検出して修正する必要があります。</target>
        </trans-unit>
        <trans-unit id="75d017d689a1b5a76f0fc05ac1a94a6933ae9c60" translate="yes" xml:space="preserve">
          <source>Remark that the type inferred for empty is 'a list and not '_weak5 list that should have occurred with the value restriction since f () is a function application.</source>
          <target state="translated">emptyのために推測される型は'リストであり,f()が関数の応用であるため,値の制限で発生したはずの'_weak5リストではないことに注意してください.</target>
        </trans-unit>
        <trans-unit id="7230db168d899f594b95cb697d95bc8534a0e07f" translate="yes" xml:space="preserve">
          <source>Remove all elements from the table.</source>
          <target state="translated">テーブルからすべての要素を削除します。</target>
        </trans-unit>
        <trans-unit id="f662b3f3ba722f6f477ef995251656740bd0a589" translate="yes" xml:space="preserve">
          <source>Remove an empty directory.</source>
          <target state="translated">空のディレクトリを削除します。</target>
        </trans-unit>
        <trans-unit id="c2426d9587ba25986a9d9a8464f4cf28f49b4e2a" translate="yes" xml:space="preserve">
          <source>Remove blank characters until the first asterisk (&amp;rsquo;*&amp;rsquo;) in each line of comments.</source>
          <target state="translated">コメントの各行の最初のアスタリスク（ '*'）まで空白文字を削除します。</target>
        </trans-unit>
        <trans-unit id="1a90aad5043757c8a9c09d20150830c67e086bfe" translate="yes" xml:space="preserve">
          <source>Remove from the sequence the elements that do not satisfy the given predicate.</source>
          <target state="translated">与えられた述語を満たさない要素をシーケンスから削除します。</target>
        </trans-unit>
        <trans-unit id="246687551a774323a453e92a24c7aeb3ca4bfd55" translate="yes" xml:space="preserve">
          <source>Remove from the sequence the elements that do not satisfy the given predicate. This transformation is lazy, it only applies when the result is traversed.</source>
          <target state="translated">与えられた述語を満たさない要素をシーケンスから削除します。この変換は,結果がトラバースされた場合にのみ適用されます.</target>
        </trans-unit>
        <trans-unit id="154733fd338d63aa2d2c057d675c182891618bf4" translate="yes" xml:space="preserve">
          <source>Remove the first element of the stream, possibly unfreezing it before.</source>
          <target state="translated">ストリームの最初の要素を削除します。</target>
        </trans-unit>
        <trans-unit id="c7086cf1b363660ebe16e430065ac77061a13da5" translate="yes" xml:space="preserve">
          <source>Remove the given directory from the list of directories searched for source and compiled files. Do nothing if the list does not contain the given directory.</source>
          <target state="translated">ソースファイルとコンパイル済みファイルを検索したディレクトリのリストから、指定したディレクトリを削除します。リストに指定されたディレクトリが含まれていない場合は何もしません。</target>
        </trans-unit>
        <trans-unit id="d75cdb70394e3076742148661a4f0d138cc86e65" translate="yes" xml:space="preserve">
          <source>Remove the given file name from the file system.</source>
          <target state="translated">指定したファイル名をファイルシステムから削除します。</target>
        </trans-unit>
        <trans-unit id="262409bb33e2295bb03d4481acb2bd31bdd6a400" translate="yes" xml:space="preserve">
          <source>Remove the named function from the table of toplevel printers.</source>
          <target state="translated">トップレベルプリンタのテーブルから名前付き関数を削除します。</target>
        </trans-unit>
        <trans-unit id="b422e6336e9a1f5c8e7676d4cec59ce1f3784507" translate="yes" xml:space="preserve">
          <source>Remove the named function from the table of value printers.</source>
          <target state="translated">値プリンタのテーブルから名前付き関数を削除します。</target>
        </trans-unit>
        <trans-unit id="4ee176e699b353c43f07d0d5894fb3b5591faa05" translate="yes" xml:space="preserve">
          <source>Remove unused function arguments even when the argument is not specialised. This may have a small performance penalty. See section &lt;a href=&quot;#ss%3Aflambda-remove-unused-args&quot;&gt;21.10.3&lt;/a&gt;.</source>
          <target state="translated">引数が特殊化されていない場合でも、未使用の関数引数を削除します。これにより、パフォーマンスがわずかに低下する可能性があります。セクション&lt;a href=&quot;#ss%3Aflambda-remove-unused-args&quot;&gt;21.10.3を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="65afa3a5b7a241b9b346985f5c59de2a52cab400" translate="yes" xml:space="preserve">
          <source>Removes the named file</source>
          <target state="translated">名前付きファイルを削除します。</target>
        </trans-unit>
        <trans-unit id="604bf9f212cb4c463abdb6d2939a2df34df83931" translate="yes" xml:space="preserve">
          <source>Removes the named file.</source>
          <target state="translated">指定されたファイルを削除します。</target>
        </trans-unit>
        <trans-unit id="de8b3ff4a64a143b656296bc695d5afd78e79aa5" translate="yes" xml:space="preserve">
          <source>Rename a file.</source>
          <target state="translated">ファイル名を変更します。</target>
        </trans-unit>
        <trans-unit id="7720bbeaac7a5506aba04ac2c6b2a56b722aedef" translate="yes" xml:space="preserve">
          <source>Rename a file. &lt;code&gt;rename&amp;nbsp;oldpath&amp;nbsp;newpath&lt;/code&gt; renames the file called &lt;code&gt;oldpath&lt;/code&gt;, giving it &lt;code&gt;newpath&lt;/code&gt; as its new name, moving it between directories if needed. If &lt;code&gt;newpath&lt;/code&gt; already exists, its contents will be replaced with those of &lt;code&gt;oldpath&lt;/code&gt;. Depending on the operating system, the metadata (permissions, owner, etc) of &lt;code&gt;newpath&lt;/code&gt; can either be preserved or be replaced by those of &lt;code&gt;oldpath&lt;/code&gt;.</source>
          <target state="translated">ファイルの名前を変更します。 &lt;code&gt;rename&amp;nbsp;oldpath&amp;nbsp;newpath&lt;/code&gt; 呼ばれるファイル名前の変更 &lt;code&gt;oldpath&lt;/code&gt; 、それは与え、 &lt;code&gt;newpath&lt;/code&gt; 必要ならばディレクトリ間の移動を行なう、その新しい名前として。場合 &lt;code&gt;newpath&lt;/code&gt; ががすでに存在して、その内容は、のものと置き換えられます &lt;code&gt;oldpath&lt;/code&gt; は。オペレーティングシステムに応じて、 &lt;code&gt;newpath&lt;/code&gt; のメタデータ（権限、所有者など）を保持するか、 &lt;code&gt;oldpath&lt;/code&gt; のメタデータに置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="bc5cc2bb555df30d0e6eb7d5f83b5d27a1ab09a6" translate="yes" xml:space="preserve">
          <source>Rename the files containing A and B to Mylib__A and Mylib__B.</source>
          <target state="translated">AとBを含むファイルの名前をMylib__AとMylib__Bに変更します。</target>
        </trans-unit>
        <trans-unit id="c385e347b2af0a4d67c9b1c9902c4b0b140d1abd" translate="yes" xml:space="preserve">
          <source>Replacement</source>
          <target state="translated">Replacement</target>
        </trans-unit>
        <trans-unit id="4af5403b14a97b367235b42df07a20480e0e8dc8" translate="yes" xml:space="preserve">
          <source>Report also the children that receive stop signals.</source>
          <target state="translated">停止信号を受信している子どもたちも報告してください。</target>
        </trans-unit>
        <trans-unit id="31955c1eb0a065ad822d3b3d4ad5258e4de34617" translate="yes" xml:space="preserve">
          <source>Report the socket type</source>
          <target state="translated">ソケットの種類を報告</target>
        </trans-unit>
        <trans-unit id="b995b5804e4a58ffb2ca58aa3da67303300eebb1" translate="yes" xml:space="preserve">
          <source>Report whether socket listening is enabled</source>
          <target state="translated">ソケットリスニングが有効かどうかを報告する</target>
        </trans-unit>
        <trans-unit id="74f3137f7768beda858520d1ea23501430d993b1" translate="yes" xml:space="preserve">
          <source>Reposition the descriptor to the beginning of the directory</source>
          <target state="translated">ディスクリプタをディレクトリの先頭に配置しなおす</target>
        </trans-unit>
        <trans-unit id="360bc539904b3901915f57b0aead8cb40373f0de" translate="yes" xml:space="preserve">
          <source>Representation</source>
          <target state="translated">Representation</target>
        </trans-unit>
        <trans-unit id="355b1015abcd18678f55cad9402d887e0ca4b33c" translate="yes" xml:space="preserve">
          <source>Reraise the exception using the given raw_backtrace for the origin of the exception</source>
          <target state="translated">与えられた例外の元となる raw_backtrace を使用して例外を再起動します。</target>
        </trans-unit>
        <trans-unit id="296dc2dc7b2de91362fa32e69066f2f832ae36c7" translate="yes" xml:space="preserve">
          <source>Reset the search path. This requires confirmation.</source>
          <target state="translated">検索パスをリセットします。これには確認が必要です。</target>
        </trans-unit>
        <trans-unit id="295d138411ff2d3558e23677e76f1c926ca63f6d" translate="yes" xml:space="preserve">
          <source>Resizing of stacks and memory manager tables.</source>
          <target state="translated">スタックとメモリマネージャテーブルのサイズ変更。</target>
        </trans-unit>
        <trans-unit id="4d2b9449646a0ee5d5e77b1f7dfdbd7898f4fbf0" translate="yes" xml:space="preserve">
          <source>Resource deadlock would occur</source>
          <target state="translated">リソースデッドロックが発生する</target>
        </trans-unit>
        <trans-unit id="449bb9231a38851e27ffef4f8fb9c50338c502b0" translate="yes" xml:space="preserve">
          <source>Resource temporarily unavailable; try again</source>
          <target state="translated">リソースは一時的に利用できません。</target>
        </trans-unit>
        <trans-unit id="ec49ae807f32a58e971b5d6d176e30540b9c5004" translate="yes" xml:space="preserve">
          <source>Resource unavailable</source>
          <target state="translated">リソースが利用できない</target>
        </trans-unit>
        <trans-unit id="29e3e7a7da9b9395cec89d34d65a1a1b2f7fa2d8" translate="yes" xml:space="preserve">
          <source>Restricting the PrioQueue structure by this signature results in another view of the PrioQueue structure where the remove_top function is not accessible and the actual representation of priority queues is hidden:</source>
          <target state="translated">このシグネチャで PrioQueue 構造を制限すると、 remove_top 関数にアクセスできず、優先度キューの実際の表現が隠された PrioQueue 構造の別のビューになります。</target>
        </trans-unit>
        <trans-unit id="5faa59d4bc3756040b8ce9e673c09f929e6ee9ba" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">Result</target>
        </trans-unit>
        <trans-unit id="299a15e6a23badee14ff1ded59c353807a27199b" translate="yes" xml:space="preserve">
          <source>Result too large</source>
          <target state="translated">結果が大きすぎる</target>
        </trans-unit>
        <trans-unit id="3209d576f81c84414e8e8f7fb17ec71753c4c605" translate="yes" xml:space="preserve">
          <source>Result type</source>
          <target state="translated">結果の種類</target>
        </trans-unit>
        <trans-unit id="eff426904f949a5bd0420c1f1a0fa5c365e9b7cf" translate="yes" xml:space="preserve">
          <source>Result values handle computation results and errors in an explicit and declarative manner without resorting to exceptions.</source>
          <target state="translated">結果値は、例外に頼ることなく、明示的かつ宣言的な方法で計算結果やエラーを処理します。</target>
        </trans-unit>
        <trans-unit id="e5e52a78448e1694bad44e829c624deb768c1a7b" translate="yes" xml:space="preserve">
          <source>Result values.</source>
          <target state="translated">結果の値。</target>
        </trans-unit>
        <trans-unit id="612e12d29278b5519294bc25cdaddffec6d0f1c6" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="translated">Results</target>
        </trans-unit>
        <trans-unit id="d79bd092e077fc09c2c60f3a10064d1ff431ce29" translate="yes" xml:space="preserve">
          <source>Return 30 random bits in a nonnegative integer.</source>
          <target state="translated">非負の整数で30ビットのランダムビットを返します。</target>
        </trans-unit>
        <trans-unit id="1fa095160436e3371f86a43a981b3849b81bf640" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;()&lt;/code&gt; if the stream is empty, else raise &lt;a href=&quot;stream#EXCEPTIONFailure&quot;&gt;&lt;code&gt;Stream.Failure&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ストリームが空の場合は &lt;code&gt;()&lt;/code&gt; を返し、そうでない場合は&lt;a href=&quot;stream#EXCEPTIONFailure&quot;&gt; &lt;code&gt;Stream.Failure&lt;/code&gt; を発生させ&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="593f7c342701e8ec458be23245e66f430d3e4385" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;(minor_words,&amp;nbsp;promoted_words,&amp;nbsp;major_words)&lt;/code&gt;.</source>
          <target state="translated">戻り値 &lt;code&gt;(minor_words,&amp;nbsp;promoted_words,&amp;nbsp;major_words)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="550faf169ef998eb1fa031a11f506f86d397328c" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;(minor_words,&amp;nbsp;promoted_words,&amp;nbsp;major_words)&lt;/code&gt;. This function is as fast as &lt;code&gt;quick_stat&lt;/code&gt;.</source>
          <target state="translated">戻り値 &lt;code&gt;(minor_words,&amp;nbsp;promoted_words,&amp;nbsp;major_words)&lt;/code&gt; 。この関数は &lt;code&gt;quick_stat&lt;/code&gt; と同じくらい高速です。</target>
        </trans-unit>
        <trans-unit id="9f0b04958e3d5768c711ed65e736e75e41370385" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;None&lt;/code&gt; if the given string is not a valid representation of a float.</source>
          <target state="translated">指定された文字列がfloatの有効な表現でない場合は、 &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="c545d6d7e7201b009d3907cdeef8a3094f6baaaf" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;None&lt;/code&gt; if the given string is not a valid representation of an integer, or if the integer represented exceeds the range of integers representable in type &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">指定された文字列が整数の有効な表現ではない場合、または表現された整数が &lt;code&gt;int&lt;/code&gt; 型で表現可能な整数の範囲を超えている場合は、 &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="da7031cc3ae71e32dda9f527b40a39b784155601" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;None&lt;/code&gt; if the line read is not a valid representation of a floating-point number.</source>
          <target state="translated">読み取られた行が浮動小数点数の有効な表現でない場合は、 &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="eb750c7d172d1acc02da983e44f7470133e58fa7" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;None&lt;/code&gt; if the line read is not a valid representation of an integer.</source>
          <target state="translated">読み取られた行が整数の有効な表現でない場合は、 &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="4c08ab7d1ba46fbe58475fb0109d0a5d45d82a5b" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;None&lt;/code&gt; if the string is not &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">文字列が &lt;code&gt;&quot;true&quot;&lt;/code&gt; または &lt;code&gt;&quot;false&quot;&lt;/code&gt; ない場合は &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="7a9bf0c2b04774eefa1cb998fa96e21caf677aa9" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;Some&lt;/code&gt; of &quot;the first element&quot; of the stream, or &lt;code&gt;None&lt;/code&gt; if the stream is empty.</source>
          <target state="translated">ストリームの「最初の要素」の &lt;code&gt;Some&lt;/code&gt; を返します。ストリームが空の場合は &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="e5292c8ae26a2eae7733924ca1310706bedf5f1b" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;true&lt;/code&gt; if the file name is relative and does not start with an explicit reference to the current directory (&lt;code&gt;./&lt;/code&gt; or &lt;code&gt;../&lt;/code&gt; in Unix), &lt;code&gt;false&lt;/code&gt; if it starts with an explicit reference to the root directory or the current directory.</source>
          <target state="translated">ファイル名が相対的であり、現在のディレクトリ（Unixでは &lt;code&gt;./&lt;/code&gt; または &lt;code&gt;../&lt;/code&gt; ）への明示的な参照で始まらない場合は &lt;code&gt;true&lt;/code&gt; を返し、ルートディレクトリまたは現在のディレクトリへの明示的な参照で始まる場合は &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="030a8f8301c3d1e7373bffe5d869f33138c7c3d8" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;true&lt;/code&gt; if the file name is relative to the current directory, &lt;code&gt;false&lt;/code&gt; if it is absolute (i.e.</source>
          <target state="translated">ファイル名が現在のディレクトリに相対的で &lt;code&gt;true&lt;/code&gt; 場合はtrueを返し、絶対的である場合は &lt;code&gt;false&lt;/code&gt; を返します（つまり、</target>
        </trans-unit>
        <trans-unit id="4b0417d3670b3192288bd57b2b9590c65ba93693" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;true&lt;/code&gt; if the file name is relative to the current directory, &lt;code&gt;false&lt;/code&gt; if it is absolute (i.e. in Unix, starts with &lt;code&gt;/&lt;/code&gt;).</source>
          <target state="translated">ファイル名が現在のディレクトリに相対的で &lt;code&gt;true&lt;/code&gt; 場合はtrueを返し、絶対的である場合は &lt;code&gt;false&lt;/code&gt; を返します（つまり、Unixでは &lt;code&gt;/&lt;/code&gt; で始まります）。</target>
        </trans-unit>
        <trans-unit id="a015b737ab1e9eb668c2cceaf398634872781ae2" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;true&lt;/code&gt; if the given file descriptor refers to a terminal or console window, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">戻り &lt;code&gt;true&lt;/code&gt; 与えられたファイルディスクリプタは、端末またはコンソールウィンドウを参照する場合 &lt;code&gt;false&lt;/code&gt; そう。</target>
        </trans-unit>
        <trans-unit id="63f3b056b45d4d28af4aaf0cff1c1765dbae49af" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;true&lt;/code&gt; if the given queue is empty, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">指定されたキューが空の場合は &lt;code&gt;true&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="3d192ae098f93a15f44ef685976f769d2b43da8a" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;true&lt;/code&gt; if the given stack is empty, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">指定されたスタックが空の場合は &lt;code&gt;true&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="45f1622b98a145c2db6db8c2f9d7a5e025a1042e" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with all lowercase letters translated to uppercase, including accented letters of the ISO Latin-1 (8859-1) character set.</source>
          <target state="translated">ISO Latin-1 (8859-1)文字セットのアクセント付き文字を含む、すべての小文字を大文字に翻訳した引数のコピーを返します。</target>
        </trans-unit>
        <trans-unit id="127b47230d0d9b183fb460c794103afb437a3f74" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with all lowercase letters translated to uppercase, using the US-ASCII character set.</source>
          <target state="translated">US-ASCII文字セットを使用して、すべての小文字を大文字に変換した引数のコピーを返します。</target>
        </trans-unit>
        <trans-unit id="44df7d1f4660ce15440564ef6140d488f89e8817" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with all uppercase letters translated to lowercase, including accented letters of the ISO Latin-1 (8859-1) character set.</source>
          <target state="translated">ISO Latin-1 (8859-1)文字セットのアクセント付き文字を含む、すべての大文字を小文字に翻訳した引数のコピーを返します。</target>
        </trans-unit>
        <trans-unit id="003998c9bfbb3770499527204f4346a8d1868e5a" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with all uppercase letters translated to lowercase, using the US-ASCII character set.</source>
          <target state="translated">US-ASCII文字セットを使用して、すべての大文字を小文字に変換した引数のコピーを返します。</target>
        </trans-unit>
        <trans-unit id="5a3d642112c3a92152f04255363b1ba2fa9a2589" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with special characters represented by escape sequences, following the lexical conventions of OCaml.</source>
          <target state="translated">引数のコピーを、OCamlの字句規則に従って、エスケープシーケンスで表現された特殊文字で返します。</target>
        </trans-unit>
        <trans-unit id="1a4a332a5b94aa334390f511abb510b3ddb62618" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with special characters represented by escape sequences, following the lexical conventions of OCaml. All characters outside the ASCII printable range (32..126) are escaped, as well as backslash and double-quote.</source>
          <target state="translated">引数のコピーを、OCamlの字句規則に従って、エスケープシーケンスで表現された特殊文字で返します。ASCII の印刷可能範囲 (32~126)以外のすべての文字は、バックスラッシュやダブルクォートと同様にエスケープされます。</target>
        </trans-unit>
        <trans-unit id="03f41a484dc0ff3d58c57c1442a5f726ce61570b" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with special characters represented by escape sequences, following the lexical conventions of OCaml. If there is no special character in the argument, return the original string itself, not a copy. Its inverse function is Scanf.unescaped.</source>
          <target state="translated">引数のコピーを返します。特殊文字はエスケープシーケンスで表され、OCamlの字句規則に従います。引数に特殊文字がない場合は、コピーではなく元の文字列そのものを返します。その逆関数は Scanf.unescaped です。</target>
        </trans-unit>
        <trans-unit id="69572fdafff64426a35c582a448aa44913d1d625" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with the first character set to lowercase, using the ISO Latin-1 (8859-1) character set..</source>
          <target state="translated">ISO Latin-1 (8859-1)文字セットを使用して、最初の文字を小文字に設定した引数のコピーを返します。</target>
        </trans-unit>
        <trans-unit id="fd2d2d82cb94ada562d6a342e526b209b60b887f" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with the first character set to lowercase, using the US-ASCII character set.</source>
          <target state="translated">US-ASCII文字セットを使用して、最初の文字を小文字に設定した引数のコピーを返します。</target>
        </trans-unit>
        <trans-unit id="7bdec61eece118da7a683a1371f3a01fee398774" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with the first character set to uppercase, using the ISO Latin-1 (8859-1) character set..</source>
          <target state="translated">ISO Latin-1 (8859-1)文字セットを使用して、最初の文字を大文字に設定した引数のコピーを返します。</target>
        </trans-unit>
        <trans-unit id="864a8ca7c0f4e575f15013bf4127c071a3cb479f" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with the first character set to uppercase, using the US-ASCII character set.</source>
          <target state="translated">US-ASCII文字セットを使用して、最初の文字を大文字に設定した引数のコピーを返します。</target>
        </trans-unit>
        <trans-unit id="36b16f76788b251356e4d1d6761232482d9e6cfe" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, without leading and trailing whitespace.</source>
          <target state="translated">引数のコピーを返します。</target>
        </trans-unit>
        <trans-unit id="b23827dffec2b473204f6248d962a6ed70248d91" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, without leading and trailing whitespace. The bytes regarded as whitespace are the ASCII characters &lt;code&gt;'&amp;nbsp;'&lt;/code&gt;, &lt;code&gt;'\012'&lt;/code&gt;, &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;'\r'&lt;/code&gt;, and &lt;code&gt;'\t'&lt;/code&gt;.</source>
          <target state="translated">前後の空白なしで、引数のコピーを返します。空白と見なされるバイトは、ASCII文字 &lt;code&gt;'&amp;nbsp;'&lt;/code&gt; 、 &lt;code&gt;'\012'&lt;/code&gt; 、 &lt;code&gt;'\n'&lt;/code&gt; 、 &lt;code&gt;'\r'&lt;/code&gt; 、および &lt;code&gt;'\t'&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="60901456f742a0ed9dbc830f83569b7759f1d0ef" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, without leading and trailing whitespace. The characters regarded as whitespace are: &lt;code&gt;'&amp;nbsp;'&lt;/code&gt;, &lt;code&gt;'\012'&lt;/code&gt;, &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;'\r'&lt;/code&gt;, and &lt;code&gt;'\t'&lt;/code&gt;. If there is neither leading nor trailing whitespace character in the argument, return the original string itself, not a copy.</source>
          <target state="translated">前後の空白なしで、引数のコピーを返します。空白と見なされる文字は、 &lt;code&gt;'&amp;nbsp;'&lt;/code&gt; 、 &lt;code&gt;'\012'&lt;/code&gt; 、 &lt;code&gt;'\n'&lt;/code&gt; 、 &lt;code&gt;'\r'&lt;/code&gt; 、および &lt;code&gt;'\t'&lt;/code&gt; です。引数に先頭または末尾の空白文字がない場合は、コピーではなく、元の文字列自体を返します。</target>
        </trans-unit>
        <trans-unit id="d4f5b339b958187225951bea4339edf97319b51f" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, without leading and trailing whitespace. The characters regarded as whitespace are: &lt;code&gt;'&amp;nbsp;'&lt;/code&gt;, &lt;code&gt;'\012'&lt;/code&gt;, &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;'\r'&lt;/code&gt;, and &lt;code&gt;'\t'&lt;/code&gt;. If there is no leading nor trailing whitespace character in the argument, return the original string itself, not a copy.</source>
          <target state="translated">前後の空白なしで、引数のコピーを返します。空白と見なされる文字は、 &lt;code&gt;'&amp;nbsp;'&lt;/code&gt; 、 &lt;code&gt;'\012'&lt;/code&gt; 、 &lt;code&gt;'\n'&lt;/code&gt; 、 &lt;code&gt;'\r'&lt;/code&gt; 、および &lt;code&gt;'\t'&lt;/code&gt; です。引数に先頭または末尾の空白文字がない場合は、コピーではなく、元の文字列自体を返します。</target>
        </trans-unit>
        <trans-unit id="1f0d1f1cd1efa4cd387335c99c184eb54c9a2799" translate="yes" xml:space="preserve">
          <source>Return a copy of the current contents of the buffer.</source>
          <target state="translated">バッファの現在の内容のコピーを返します。</target>
        </trans-unit>
        <trans-unit id="fbd80ca31570862a4af03aabff797ab0adc0d40f" translate="yes" xml:space="preserve">
          <source>Return a copy of the current contents of the buffer. The buffer itself is unchanged.</source>
          <target state="translated">現在のバッファの内容のコピーを返します。バッファ自体は変更されません。</target>
        </trans-unit>
        <trans-unit id="8e2c49b318ff8a7310eff42bce315e30f2c05660" translate="yes" xml:space="preserve">
          <source>Return a copy of the given hashtable.</source>
          <target state="translated">与えられたハッシュテーブルのコピーを返します。</target>
        </trans-unit>
        <trans-unit id="7fb9371aa6a43be6ab72a21320b2f310a5cd11cb" translate="yes" xml:space="preserve">
          <source>Return a copy of the given queue.</source>
          <target state="translated">与えられたキューのコピーを返します。</target>
        </trans-unit>
        <trans-unit id="88e995de1b77c7933088c28dae39cec90133db31" translate="yes" xml:space="preserve">
          <source>Return a copy of the given stack.</source>
          <target state="translated">与えられたスタックのコピーを返します。</target>
        </trans-unit>
        <trans-unit id="93bf205a4b71edb1af1ca3b4635ed7d07eb9abaa" translate="yes" xml:space="preserve">
          <source>Return a copy of the given state.</source>
          <target state="translated">与えられた状態のコピーを返します。</target>
        </trans-unit>
        <trans-unit id="5db994c18b13ca47f2460850e0609a5cda1c1ad0" translate="yes" xml:space="preserve">
          <source>Return a copy of the given string.</source>
          <target state="translated">与えられた文字列のコピーを返します。</target>
        </trans-unit>
        <trans-unit id="9eb890add67386c423d7d9d793c6fd6e71086858" translate="yes" xml:space="preserve">
          <source>Return a fresh reference containing the given value.</source>
          <target state="translated">与えられた値を含む新しい参照を返します。</target>
        </trans-unit>
        <trans-unit id="7f6e164b350620b04bdde9dfe7361263308ce8c1" translate="yes" xml:space="preserve">
          <source>Return a new byte sequence that contains the same bytes as the argument.</source>
          <target state="translated">引数と同じバイトを含む新しいバイト列を返します。</target>
        </trans-unit>
        <trans-unit id="3288df26f3728e4af6621ea5a70e0e92d0691d62" translate="yes" xml:space="preserve">
          <source>Return a new byte sequence that contains the same bytes as the given string.</source>
          <target state="translated">与えられた文字列と同じバイト数を含む新しいバイト列を返します。</target>
        </trans-unit>
        <trans-unit id="e35d88ad5aec4e0bee772d3ccb669d6e610bda6f" translate="yes" xml:space="preserve">
          <source>Return a new channel.</source>
          <target state="translated">新しいチャンネルを返します。</target>
        </trans-unit>
        <trans-unit id="4fc8680a0f4820443679c4ca33bffc768d3a4af2" translate="yes" xml:space="preserve">
          <source>Return a new condition variable.</source>
          <target state="translated">新しい条件変数を返します。</target>
        </trans-unit>
        <trans-unit id="f73e3fd5045de7f968d83b57ce77ff2e244d6d94" translate="yes" xml:space="preserve">
          <source>Return a new file descriptor referencing the same file as the given descriptor.</source>
          <target state="translated">与えられたディスクリプタと同じファイルを参照する新しいファイルディスクリプタを返します。</target>
        </trans-unit>
        <trans-unit id="022bd62ac3f4fef8b66c421752d380647a257c3e" translate="yes" xml:space="preserve">
          <source>Return a new file descriptor referencing the same file as the given descriptor. See &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt;&lt;code&gt;Unix.set_close_on_exec&lt;/code&gt;&lt;/a&gt; for documentation on the &lt;code&gt;cloexec&lt;/code&gt; optional argument.</source>
          <target state="translated">指定された記述子と同じファイルを参照する新しいファイル記述子を返します。 &lt;code&gt;cloexec&lt;/code&gt; オプション引数のドキュメントについては、&lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt; &lt;code&gt;Unix.set_close_on_exec&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="bbc741461c44e92671a1d3e08ce17aef58d13652" translate="yes" xml:space="preserve">
          <source>Return a new mutex.</source>
          <target state="translated">新しいミューテックスを返します。</target>
        </trans-unit>
        <trans-unit id="a250463867298e9eaf9678c8350c6716043386cc" translate="yes" xml:space="preserve">
          <source>Return a new queue, initially empty.</source>
          <target state="translated">新しいキューを返します。</target>
        </trans-unit>
        <trans-unit id="29293bb0256d01cced68ba9adcdef7067e73cc71" translate="yes" xml:space="preserve">
          <source>Return a new stack, initially empty.</source>
          <target state="translated">新しいスタックを返します。</target>
        </trans-unit>
        <trans-unit id="b632b9591eab85fbc96a1c3fd08f92e29ab6f5bc" translate="yes" xml:space="preserve">
          <source>Return a new string that contains the same bytes as the given byte sequence.</source>
          <target state="translated">与えられたバイト列と同じバイトを含む新しい文字列を返します。</target>
        </trans-unit>
        <trans-unit id="eaa2ddecfab0e29c2e8e9bbf8c5bc2d1ac627095" translate="yes" xml:space="preserve">
          <source>Return a quoted version of a file name, suitable for use as one argument in a command line, escaping all meta-characters.</source>
          <target state="translated">コマンドラインの一つの引数として使用するのに適した、引用符で囲まれたファイル名を返します。</target>
        </trans-unit>
        <trans-unit id="eb33ef2fdd22ebcc2818d5a53e55762ccaf36484" translate="yes" xml:space="preserve">
          <source>Return a quoted version of a file name, suitable for use as one argument in a command line, escaping all meta-characters. Warning: under Windows, the output is only suitable for use with programs that follow the standard Windows quoting conventions.</source>
          <target state="translated">すべてのメタキャラクタをエスケープして、コマンドラインの一つの引数として使用するのに適した、引用符で囲まれたファイル名を返します。警告:Windows では、出力は Windows の標準的な引用符付けの規約に従ったプログラムでの使用にのみ適しています。</target>
        </trans-unit>
        <trans-unit id="008c82eb7a3488f2068808aaf085122455ce86c2" translate="yes" xml:space="preserve">
          <source>Return a string describing the given error code.</source>
          <target state="translated">与えられたエラーコードを記述した文字列を返します。</target>
        </trans-unit>
        <trans-unit id="6308615f291e3990cb87826cb856a820e487ae9b" translate="yes" xml:space="preserve">
          <source>Return a string from a raw backtrace, in the same format &lt;code&gt;Printexc.get_backtrace&lt;/code&gt; uses.</source>
          <target state="translated">&lt;code&gt;Printexc.get_backtrace&lt;/code&gt; が使用するのと同じ形式で、生のバックトレースから文字列を返します。</target>
        </trans-unit>
        <trans-unit id="12151c7c9dff07c2f242a2cf5034d277c5760738" translate="yes" xml:space="preserve">
          <source>Return a string representing the given character, with special characters escaped following the lexical conventions of OCaml.</source>
          <target state="translated">与えられた文字を表す文字列を返し、特殊文字はOCamlの字句規則に従ってエスケープされます。</target>
        </trans-unit>
        <trans-unit id="1ae4c08f96ad04052340d504c28314a0c07f4294" translate="yes" xml:space="preserve">
          <source>Return a string representing the given character, with special characters escaped following the lexical conventions of OCaml. All characters outside the ASCII printable range (32..126) are escaped, as well as backslash, double-quote, and single-quote.</source>
          <target state="translated">OCamlの字句規則に従って特殊文字をエスケープした、指定された文字を表す文字列を返します。ASCII の印刷可能範囲 (32~126)以外のすべての文字は、バックスラッシュ、ダブルクォート、シングルクォートと同様にエスケープされます。</target>
        </trans-unit>
        <trans-unit id="3e8e3e80004732f400a60500d80e26ba6bb55cfe" translate="yes" xml:space="preserve">
          <source>Return an OCaml Bigarray wrapping the data pointed to by p. kind is the kind of array elements (one of the CAML_BA_ kind constants above). layout is CAML_BA_C_LAYOUT for an array with C layout and CAML_BA_FORTRAN_LAYOUT for an array with Fortran layout. numdims is the number of dimensions in the array. dims is an array of numdims long integers, giving the sizes of the array in each dimension.</source>
          <target state="translated">kind は,配列の要素の種類(上記の CAML_BA_kind 定数の 1 つ)を指定します.</target>
        </trans-unit>
        <trans-unit id="0c740844be0e075a677fcb6369986cf1020d7188" translate="yes" xml:space="preserve">
          <source>Return an integer identifying this object, unique for the current execution of the program.</source>
          <target state="translated">このオブジェクトを識別する整数を返します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
