<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="ocaml">
    <body>
      <group id="ocaml">
        <trans-unit id="20b2d8ee46fbd0ec43648349d2f501735b50eb59" translate="yes" xml:space="preserve">
          <source>The complete OCaml distribution can be accessed via the &lt;a href=&quot;https://ocaml.org/&quot;&gt;ocaml.org website&lt;/a&gt;. This site contains a lot of additional information on OCaml.</source>
          <target state="translated">完全なOCamlディストリビューションは、&lt;a href=&quot;https://ocaml.org/&quot;&gt;ocaml.orgWebサイト&lt;/a&gt;からアクセスできます。このサイトには、OCamlに関する多くの追加情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="581d160324d6b1dcf6f5966e788655a0b8d7c61c" translate="yes" xml:space="preserve">
          <source>The complex number &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">複素数 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a94f375eaa7012dabdc57ca285225234540e0a33" translate="yes" xml:space="preserve">
          <source>The complex number &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">複素数 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b43370e6d1b0c376b1980b552194da8b6181987d" translate="yes" xml:space="preserve">
          <source>The complex number &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">複素数 &lt;code&gt;i&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ad39316a87edf772e43a6c5b64a3e41e9c0e181" translate="yes" xml:space="preserve">
          <source>The concrete type describing the behavior associated with a keyword.</source>
          <target state="translated">キーワードに関連付けられた動作を記述する具体的な型。</target>
        </trans-unit>
        <trans-unit id="79be6aae51e8c401b2476f5b4f2a107a9fdc32ef" translate="yes" xml:space="preserve">
          <source>The constant pi.</source>
          <target state="translated">定数πです。</target>
        </trans-unit>
        <trans-unit id="8ad8c44fad65df83c02fac0ee5f9d77f6672d992" translate="yes" xml:space="preserve">
          <source>The constraint on self&amp;rsquo;s type is requiring a public move method, and this is sufficient to override private.</source>
          <target state="translated">selfの型に対する制約は、public moveメソッドを必要とし、これはprivateをオーバーライドするのに十分です。</target>
        </trans-unit>
        <trans-unit id="a279814e737c452af822699c5733e5455892c221" translate="yes" xml:space="preserve">
          <source>The constraints associated to each constructor can be recovered through pattern-matching. Namely, if the type of the scrutinee of a pattern-matching contains a locally abstract type, this type can be refined according to the constructor used. These extra constraints are only valid inside the corresponding branch of the pattern-matching. If a constructor has some existential variables, fresh locally abstract types are generated, and they must not escape the scope of this branch.</source>
          <target state="translated">各コンストラクタに関連付けられた制約は、パターンマッチングによって回復することができる。つまり、パターン・マッチングのスクルーティニーの型に局所的に抽象的な型が含まれている場合、この型は使用されるコンストラクタに応じて洗練されます。これらの追加制約は、パターンマッチングの対応するブランチ内でのみ有効です。コンストラクタがいくつかの実在変数を持っている場合、新しい局所的に抽象化された型が生成され、このブランチのスコープから抜け出してはいけません。</target>
        </trans-unit>
        <trans-unit id="72a6619fc6d35a54f266cbb1b53bb99ad5b03227" translate="yes" xml:space="preserve">
          <source>The construct constraint'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; allows the specification of type parameters. Any actual type argument corresponding to the type parameter &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; has to be an instance of &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; (more precisely, &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; are unified). Type variables of &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; can appear in the type equation and the type declaration.</source>
          <target state="translated">構成制約の&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; = &lt;a href=&quot;types#typexpr&quot;&gt;typexprを&lt;/a&gt;使用すると、型パラメーターを指定できます。型パラメーター&lt;a href=&quot;lex#ident&quot;&gt;identに&lt;/a&gt;対応する実際の型引数は、&lt;a href=&quot;types#typexpr&quot;&gt;typexprの&lt;/a&gt;インスタンスである必要があります（より正確には、&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;と&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;は統合されています）。&lt;a href=&quot;types#typexpr&quot;&gt;typexprの&lt;/a&gt;型変数は、型方程式と型宣言に含めることができます。</target>
        </trans-unit>
        <trans-unit id="a6dcf637d8dc6131f0b0eb619e7d7999e61b6d1b" translate="yes" xml:space="preserve">
          <source>The construct constraint&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; forces the two type expressions to be equal. This is typically used to specify type parameters: in this way, they can be bound to specific type expressions.</source>
          <target state="translated">構築物は、制約&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; = &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;等しくなるために2つの型の式を強制します。これは通常、型パラメーターを指定するために使用されます。このようにして、特定の型式にバインドできます。</target>
        </trans-unit>
        <trans-unit id="e91937a9ebb9b2f875d8df7aec3ae920407278b6" translate="yes" xml:space="preserve">
          <source>The construct constraint&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; forces the two type expressions to be equals. This is typically used to specify type parameters: in that way they can be bound to specific type expressions.</source>
          <target state="translated">構築物は、制約&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; = &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;等しいされる2つの型の式を強制します。これは通常、型パラメーターを指定するために使用されます。このようにして、特定の型式にバインドできます。</target>
        </trans-unit>
        <trans-unit id="4111af28e88c74529d924590f2259579d7eddcd6" translate="yes" xml:space="preserve">
          <source>The construction moduletypeof&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; expands to the module type (signature or functor type) inferred for the module expression &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;. To make this module type reusable in many situations, it is intentionally not strengthened: abstract types and datatypes are not explicitly related with the types of the original module. For the same reason, module aliases in the inferred type are expanded.</source>
          <target state="translated">&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;の構築moduletypeは、モジュール式&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;に対して推測されるモジュールタイプ（署名またはファンクタータイプ）に展開されます。このモジュールタイプを多くの状況で再利用できるようにするために、意図的に強化されていません。抽象タイプとデータタイプは、元のモジュールのタイプと明示的に関連付けられていません。同じ理由で、推測されたタイプのモジュールエイリアスが展開されます。</target>
        </trans-unit>
        <trans-unit id="760fdc00af3cbc0e13df9af8553cc7a286bca119" translate="yes" xml:space="preserve">
          <source>The constructor &lt;code&gt;()&lt;/code&gt; is included here so that it has a path, but it is not intended to be used in user-defined data types.</source>
          <target state="translated">コンストラクター &lt;code&gt;()&lt;/code&gt; は、パスを持つようにここに含まれていますが、ユーザー定義のデータ型で使用するためのものではありません。</target>
        </trans-unit>
        <trans-unit id="a3003c0bbe668e94ab79defd3f710132d87092a6" translate="yes" xml:space="preserve">
          <source>The constructors &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; are included here so that they have paths, but they are not intended to be used in user-defined data types.</source>
          <target state="translated">コンストラクター &lt;code&gt;false&lt;/code&gt; および &lt;code&gt;true&lt;/code&gt; は、パスを持つようにここに含まれていますが、ユーザー定義のデータ型で使用するためのものではありません。</target>
        </trans-unit>
        <trans-unit id="16640eb9daf1519aa608d0b29675645a8a35f3cb" translate="yes" xml:space="preserve">
          <source>The content inside {%foo: ... %} is target-specific and will only be interpreted by the backend foo, and ignored by the others. The backends of the distribution are latex, html, texi and man. If no target is specified (syntax {% ... %}), latex is chosen by default. Custom generators may support their own target prefix.</source>
          <target state="translated">内部の {%foo:...%}の内容はターゲット固有のものであり、バックエンドの foo のみが解釈し、他のものは無視されます。ディストリビューションのバックエンドは latex,html,texi,man です。ターゲットが指定されていない場合 (構文 {% ...%})、デフォルトでは latex が選択されます。カスタムジェネレータは、独自のターゲット接頭辞をサポートしているかもしれません。</target>
        </trans-unit>
        <trans-unit id="1c5c2fffb0418b713216d4c77f75ee03f3710a80" translate="yes" xml:space="preserve">
          <source>The contents of custom blocks are not scanned by the garbage collector, and must therefore not contain any pointer inside the OCaml heap. In other terms, never store an OCaml value in a custom block, and do not use Field, Store_field nor caml_modify to access the data part of a custom block. Conversely, any C data structure (not containing heap pointers) can be stored in a custom block.</source>
          <target state="translated">カスタムブロックの内容はガベージコレクタによってスキャンされないので、OCamlヒープ内にポインタを含んではいけません。言い換えれば、カスタムブロックに OCaml の値を保存してはいけませんし、カスタムブロックのデータ部分にアクセスするために Field,Store_field,caml_modify を使用してはいけません。逆に、任意のC言語のデータ構造(ヒープポインタを含まない)をカスタムブロックに格納することができます。</target>
        </trans-unit>
        <trans-unit id="785642c4a4c006be73a07a4f7ec8afa9d91aa1ff" translate="yes" xml:space="preserve">
          <source>The conventional name for the current directory (e.g.</source>
          <target state="translated">カレントディレクトリの従来の名前 (例えば</target>
        </trans-unit>
        <trans-unit id="ab0089cb61bfc166d7c15a2b68e795215831943d" translate="yes" xml:space="preserve">
          <source>The conventional name for the current directory (e.g. &lt;code&gt;.&lt;/code&gt; in Unix).</source>
          <target state="translated">現在のディレクトリ（例えば、従来の名前 &lt;code&gt;.&lt;/code&gt; UNIXの場合）。</target>
        </trans-unit>
        <trans-unit id="545670a3a8b2e0fff49a5ac43c08636390916185" translate="yes" xml:space="preserve">
          <source>The conventional name for the parent of the current directory (e.g.</source>
          <target state="translated">カレントディレクトリの親の従来の名前(例えば</target>
        </trans-unit>
        <trans-unit id="9b950ea81536e7df7421680a6cf3781982072c75" translate="yes" xml:space="preserve">
          <source>The conventional name for the parent of the current directory (e.g. &lt;code&gt;..&lt;/code&gt; in Unix).</source>
          <target state="translated">カレントディレクトリの親のための従来の名前（例： &lt;code&gt;..&lt;/code&gt; UNIXの場合）。</target>
        </trans-unit>
        <trans-unit id="33e422b54f028d0f9f99ad979df276c42ced7356" translate="yes" xml:space="preserve">
          <source>The conversion characters and their meanings are:</source>
          <target state="translated">変換文字とその意味は</target>
        </trans-unit>
        <trans-unit id="8cb23e02c094574c60663d78adfeb6ade600463a" translate="yes" xml:space="preserve">
          <source>The corresponding C type must be intnat.</source>
          <target state="translated">対応するC型はintnatでなければなりません。</target>
        </trans-unit>
        <trans-unit id="31b0b9138835461b550a52acf6e1102fcf625f54" translate="yes" xml:space="preserve">
          <source>The cost of a &lt;em&gt;primitive&lt;/em&gt;. Primitives encompass operations including arithmetic and memory access.</source>
          <target state="translated">&lt;em&gt;プリミティブ&lt;/em&gt;のコスト。プリミティブには、算術およびメモリアクセスを含む操作が含まれます。</target>
        </trans-unit>
        <trans-unit id="2821dc95f75734aab94e295a923c218e0df1c9bf" translate="yes" xml:space="preserve">
          <source>The cost of a branch.</source>
          <target state="translated">枝にかかる費用。</target>
        </trans-unit>
        <trans-unit id="c804487a1287d7acc06a19d856642958b1444628" translate="yes" xml:space="preserve">
          <source>The cost of a direct function call.</source>
          <target state="translated">直接関数を呼び出すためのコスト。</target>
        </trans-unit>
        <trans-unit id="534cefa77673c331e56e7d9f6dd6b1f2ed24344c" translate="yes" xml:space="preserve">
          <source>The cost of an allocation.</source>
          <target state="translated">割り振りのコスト。</target>
        </trans-unit>
        <trans-unit id="9c86a389e7f94b0cbdc2d7b61509a2068780aa63" translate="yes" xml:space="preserve">
          <source>The cost of an indirect function call.</source>
          <target state="translated">間接関数呼び出しのコスト。</target>
        </trans-unit>
        <trans-unit id="3ad4c2d03309e92f9ae01be1d5e41f51136f454b" translate="yes" xml:space="preserve">
          <source>The current default is next-fit, as the best-fit policy is new and not yet widely tested. We expect best-fit to become the default in the future.</source>
          <target state="translated">ベストフィットポリシーは新しく、まだ広くテストされていないため、現在のデフォルトはnext-fitとなっています。将来的にはベストフィットがデフォルトになると予想しています。</target>
        </trans-unit>
        <trans-unit id="3b8c08752945457971d1f3f4ac09df0af940d32a" translate="yes" xml:space="preserve">
          <source>The current implementation limits each variant type to have at most 246 non-constant constructors and 2&lt;sup&gt;30&lt;/sup&gt;&amp;minus;1 constant constructors.</source>
          <target state="translated">現在の実装では、各バリアント型が最大246個の非定数コンストラクターと2&lt;sup&gt;個の&lt;/sup&gt;30-1定数コンストラクターを持つように制限されています。</target>
        </trans-unit>
        <trans-unit id="f9a96ae8d528ab0d30d73879bd55f0ed974647fc" translate="yes" xml:space="preserve">
          <source>The current implementation places practically no restrictions on the length of string literals.</source>
          <target state="translated">現在の実装では、文字列リテラルの長さに実質的な制限はありません。</target>
        </trans-unit>
        <trans-unit id="8888fe7c320796681a86d9fc38d5331494f11ea4" translate="yes" xml:space="preserve">
          <source>The current implementation uses Heap Sort. It runs in constant stack space.</source>
          <target state="translated">現在の実装では、ヒープソートを使用しています。これは一定のスタックスペースで動作します。</target>
        </trans-unit>
        <trans-unit id="aa3296295a4df646c086eb4650f57f70f9f85c18" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</source>
          <target state="translated">現在の実装は Merge Sort を使用しています。これは一定のヒープ空間と対数スタック空間で動作します。</target>
        </trans-unit>
        <trans-unit id="b5d51df06a97d47df008e45a13c0928311228904" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It uses &lt;code&gt;n/2&lt;/code&gt; words of heap space, where &lt;code&gt;n&lt;/code&gt; is the length of the array. It is usually faster than the current implementation of &lt;a href=&quot;arraylabels#VALsort&quot;&gt;&lt;code&gt;ArrayLabels.sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在の実装では、マージソートを使用しています。 &lt;code&gt;n/2&lt;/code&gt; ワードのヒープスペースを使用します。ここで、 &lt;code&gt;n&lt;/code&gt; は配列の長さです。通常、&lt;a href=&quot;arraylabels#VALsort&quot;&gt; &lt;code&gt;ArrayLabels.sort&lt;/code&gt; &lt;/a&gt;の現在の実装よりも高速です。</target>
        </trans-unit>
        <trans-unit id="d71af0bf722f0a317f82d7cfc36b49481534370f" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It uses a temporary array of length &lt;code&gt;n/2&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the length of the array. It is usually faster than the current implementation of &lt;a href=&quot;array#VALsort&quot;&gt;&lt;code&gt;Array.sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在の実装では、マージソートを使用しています。長さ &lt;code&gt;n/2&lt;/code&gt; の一時配列を使用します。ここで、 &lt;code&gt;n&lt;/code&gt; は配列の長さです。通常、&lt;a href=&quot;array#VALsort&quot;&gt; &lt;code&gt;Array.sort&lt;/code&gt; &lt;/a&gt;の現在の実装よりも高速です。</target>
        </trans-unit>
        <trans-unit id="bdff8609298ac6203743f842126dd2f7ca872714" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It uses a temporary floatarray of length &lt;code&gt;n/2&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the length of the floatarray. It is usually faster than the current implementation of &lt;a href=&quot;float.array#VALsort&quot;&gt;&lt;code&gt;Float.Array.sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在の実装では、マージソートを使用しています。これは、長さ &lt;code&gt;n/2&lt;/code&gt; の一時的なfloatarrayを使用します。ここで、 &lt;code&gt;n&lt;/code&gt; はfloatarrayの長さです。通常、&lt;a href=&quot;float.array#VALsort&quot;&gt; &lt;code&gt;Float.Array.sort&lt;/code&gt; &lt;/a&gt;の現在の実装よりも高速です。</target>
        </trans-unit>
        <trans-unit id="b20647dbf18c92523a7fd6b83c3b58c9724e3e7a" translate="yes" xml:space="preserve">
          <source>The custom break is useful if you want to change which visible (non-whitespace) characters are printed in case of break or no break. For example, when printing a list</source>
          <target state="translated">カスタム改行は、改行や改行なしの場合に表示される(空白以外の)文字を変更したい場合に便利です。例えば、リストを印刷する場合</target>
        </trans-unit>
        <trans-unit id="8b24549afabe1745d997e15b64b4d2aae161436a" translate="yes" xml:space="preserve">
          <source>The data is considered by the garbage collector alive if all the full keys are alive and if the ephemeron is alive. When one of the keys is not considered alive anymore by the GC, the data is emptied from the ephemeron. The data could be alive for another reason and in that case the GC will not free it, but the ephemeron will not hold the data anymore.</source>
          <target state="translated">すべてのフルキーがアライブであり、エフェメロンがアライブであれば、データはガベージコレクタによってアライブとみなされる。GC によってキーの 1 つがもう生きているとみなされない場合、データはエフェメロンから空になる。データは別の理由で生きている可能性があり、その場合、GC はそれを解放しないが、エフェ メロンはデータを保持しない。</target>
        </trans-unit>
        <trans-unit id="ac0854565c0cabc94cf88db7d79f91eea95e9a7c" translate="yes" xml:space="preserve">
          <source>The data part of a custom block v can be accessed via the pointer Data_custom_val(v). This pointer has type void * and should be cast to the actual type of the data stored in the custom block.</source>
          <target state="translated">カスタムブロックvのデータ部分は、ポインタData_custom_val(v)を介してアクセスすることができます。このポインタの型は void*であり、カスタムブロックに格納されているデータの実際の型にキャストする必要があります。</target>
        </trans-unit>
        <trans-unit id="e8e6e6b562a36d00a364c6de4dc0a4ef30f6a91f" translate="yes" xml:space="preserve">
          <source>The debugger can print the current value of simple expressions. The expressions can involve program variables: all the identifiers that are in scope at the selected program point can be accessed.</source>
          <target state="translated">デバッガは、単純な式の現在の値を表示することができます。式にはプログラム変数を使用することができます。</target>
        </trans-unit>
        <trans-unit id="f8c3dc260564ad64dea40270472823def2648071" translate="yes" xml:space="preserve">
          <source>The debugger communicate with the program being debugged through a Unix socket. You may need to change the socket name, for example if you need to run the debugger on a machine and your program on another.</source>
          <target state="translated">デバッガは、Unix ソケットを介してデバッグされているプログラムと通信します。例えば、あるマシンでデバッガを実行し、別のマシンでプログラムを実行する必要がある場合など、ソケット名を変更する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="89cf1e71a9b9ce7771fbb1158aff4c5ec71b350f" translate="yes" xml:space="preserve">
          <source>The debugger execute the OCaml runtime ocamlrun on the program. Rarely useful; moreover it prevents the debugging of programs compiled in &amp;ldquo;custom runtime&amp;rdquo; mode.</source>
          <target state="translated">デバッガーはプログラムでOCamlランタイムocamlrunを実行します。めったに役に立ちません。さらに、「カスタムランタイム」モードでコンパイルされたプログラムのデバッグを防ぎます。</target>
        </trans-unit>
        <trans-unit id="d8a4e05ea8e12b749680b25bf9ad4fb77bd551fb" translate="yes" xml:space="preserve">
          <source>The debugger is compatible with the Dynlink module. However, when an external module is not yet loaded, it is impossible to set a breakpoint in its code. In order to facilitate setting breakpoints in dynamically loaded code, the debugger stops the program each time new modules are loaded. This behavior can be disabled using the break_on_load variable:</source>
          <target state="translated">デバッガはDynlinkモジュールと互換性があります。しかし、外部モジュールがまだロードされていない場合、そのコードにブレークポイントを設定することはできません。動的にロードされたコードにブレークポイントを設定しやすくするために、新しいモジュールがロードされるたびにデバッガはプログラムを停止します。この動作は、変数 break_on_load を使用して無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="67085f47487648631c3de0d3b7f5a54b54f116e7" translate="yes" xml:space="preserve">
          <source>The debugger searches for source files and compiled interface files in a list of directories, the search path. The search path initially contains the current directory . and the standard library directory. The directory command adds directories to the path.</source>
          <target state="translated">デバッガは、ソース・ファイルとコンパイルされたインターフェイス・ファイルをディレクトリのリスト (検索パス)で検索します。検索パスには、最初にカレント・ディレクトリ .と標準ライブラリ・ディレクトリが含まれます。directory コマンドは、ディレクトリをパスに追加します。</target>
        </trans-unit>
        <trans-unit id="d81bce2c8314b77a05e6061c8832d983f35d9089" translate="yes" xml:space="preserve">
          <source>The debugger starts executing the debugged program only when needed. This allows setting breakpoints or assigning debugger variables before execution starts. There are several ways to start execution:</source>
          <target state="translated">デバッガは、必要なときだけデバッグされたプログラムの実行を開始します。これにより、実行が開始される前にブレークポイントを設定したり、デバッガ変数を割り当てたりすることができます。実行を開始する方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="6c85faabbbf8e1f661bc7a77c9db172d2189ae3c" translate="yes" xml:space="preserve">
          <source>The declaration of a variant type lists all possible forms for values of that type. Each case is identified by a name, called a constructor, which serves both for constructing values of the variant type and inspecting them by pattern-matching. Constructor names are capitalized to distinguish them from variable names (which must start with a lowercase letter). For instance, here is a variant type for doing mixed arithmetic (integers and floats):</source>
          <target state="translated">変形型の宣言は、その型の値に対して可能なすべての形式をリストアップします。各ケースはコンストラクタと呼ばれる名前で識別され、これはバリアント型の値の構築とパターンマッチによる検査の両方の役割を果たします。コンストラクタ名は、変数名 (小文字で始まらなければならない)と区別するために大文字で表記されます。例えば、ここでは混合演算 (整数と浮動小数点演算)を行うためのバリアント型を示します。</target>
        </trans-unit>
        <trans-unit id="6dc771c421fb48e91d66c641d430796a079c9f9c" translate="yes" xml:space="preserve">
          <source>The declarations of the built-in types and the components of module Stdlib are printed one by one in typewriter font, followed by a short comment. All library modules and the components they provide are indexed at the end of this report.</source>
          <target state="translated">組み込み型とモジュールStdlibのコンポーネントの宣言は、1つずつタイプライターフォントで印刷され、その後に短いコメントが付けられています。すべてのライブラリモジュールとそれらが提供するコンポーネントは、このレポートの最後にインデックスが付けられています。</target>
        </trans-unit>
        <trans-unit id="2765fb82c88da6a8123fcc1afb411e9f247fbfa9" translate="yes" xml:space="preserve">
          <source>The default representation. In the present version of OCaml, the default is the boxed representation.</source>
          <target state="translated">デフォルトの表現。現在のバージョンのOCamlでは、デフォルトは箱形表現です。</target>
        </trans-unit>
        <trans-unit id="74b33452fd1e9690245e62c43fa2151918346419" translate="yes" xml:space="preserve">
          <source>The default setting is &amp;rsquo;auto&amp;rsquo;, and the current heuristic checks that the TERM environment variable exists and is not empty or dumb, and that &amp;rsquo;isatty(stderr)&amp;rsquo; holds.</source>
          <target state="translated">デフォルト設定は「auto」であり、現在のヒューリスティックは、TERM環境変数が存在し、空またはダムではないこと、および「isatty（stderr）」が保持されていることを確認します。</target>
        </trans-unit>
        <trans-unit id="08126df5b12a33c60b2609d1299988ea98c261cf" translate="yes" xml:space="preserve">
          <source>The default setting is -w +a-4-6-7-9-27-29-32..42-44-45-48-50-60. It is displayed by  -help. Note that warnings 5 and 10 are not always triggered, depending on the internals of the type checker.</source>
          <target state="translated">初期設定は-w +a-4-6-7-9-27-29-32...42-44-45-48-50-60です。これは -help で表示されます。警告5と10は、タイプチェッカの内部に依存して、常にトリガされるとは限らないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="ed097a6c98a3e8cb9832ea96755d5d9244c148bd" translate="yes" xml:space="preserve">
          <source>The default setting is -w +a-4-6-7-9-27-29-32..42-44-45-48-50-60. It is displayed by ocamlc -help. Note that warnings 5 and 10 are not always triggered, depending on the internals of the type checker.</source>
          <target state="translated">デフォルトの設定は -w +a-4-6-7-9-27-29-32...42-44-45-48-50-60 です。これは ocamlc -help で表示されます。警告5と10は、タイプチェッカの内部に依存して、常にトリガされるとは限らないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="7ab6f8a18cb9ae711fa680c3d32f93edfefbee98" translate="yes" xml:space="preserve">
          <source>The default setting is -w +a-4-6-7-9-27-29-32..42-44-45-48-50-60. It is displayed by ocamlopt -help. Note that warnings 5 and 10 are not always triggered, depending on the internals of the type checker.</source>
          <target state="translated">デフォルトの設定は -w +a-4-6-7-9-27-29-32...42-44-45-48-50-60 です。これは ocamlopt -help で表示されます。警告5と10は、タイプチェッカの内部に依存して、常にトリガされるとは限らないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="3eff228cd3aa401186be612172c09c21427569b2" translate="yes" xml:space="preserve">
          <source>The default setting is -warn-error -a+31 (only warning 31 is fatal).</source>
          <target state="translated">デフォルトの設定は -warn-error -a+31 (警告31のみが致命的)です。</target>
        </trans-unit>
        <trans-unit id="d8b548e294caad0232bcef920b432423c497646b" translate="yes" xml:space="preserve">
          <source>The default setting is contextual.</source>
          <target state="translated">デフォルトの設定は文脈に合わせて設定されています。</target>
        </trans-unit>
        <trans-unit id="4549da8d617844ebcd908e7e44273e838886bca2" translate="yes" xml:space="preserve">
          <source>The default settings (when not using -Oclassic) are for one round of optimisation using the following parameters.</source>
          <target state="translated">デフォルトの設定(-Oclassicを使用していない場合)は、以下のパラメータを使用して1ラウンドの最適化を行います。</target>
        </trans-unit>
        <trans-unit id="5f4796a7bec8a2fd44bd0c64ad6daa008bf2c968" translate="yes" xml:space="preserve">
          <source>The default trace filename is caml-{PID}.eventlog, where {PID} is the process identifier of the traced program.</source>
          <target state="translated">デフォルトのトレースファイル名は caml-{PID}.eventlog で、{PID}はトレースされたプログラムのプロセス識別子です。</target>
        </trans-unit>
        <trans-unit id="56ba28d4eda458e2debd6c11d3035373c9678204" translate="yes" xml:space="preserve">
          <source>The definition val [mutable] &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; adds an instance variable &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; whose initial value is the value of expression &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;. The flag mutable allows physical modification of this variable by methods.</source>
          <target state="translated">定義val [mutable] &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; = &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;は、初期値が式&lt;a href=&quot;expr#expr&quot;&gt;exprの&lt;/a&gt;値であるインスタンス変数&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;を追加します。フラグ可変により、メソッドによるこの変数の物理的な変更が可能になります。</target>
        </trans-unit>
        <trans-unit id="a51442850ae9805c91c304fd05e9989dc50518ce" translate="yes" xml:space="preserve">
          <source>The deserialize field can be set to custom_deserialize_default to indicate that deserialization is not supported. In this case, do not register the struct custom_operations with the deserializer using register_custom_operations (see below).</source>
          <target state="translated">deserializeフィールドをcustom_deserialize_defaultに設定することで、デシリアライズがサポートされていないことを示すことができます。この場合、register_custom_operations(後述)を使用して構造体custom_operationsをデシリアライザに登録しないでください。</target>
        </trans-unit>
        <trans-unit id="7d06ebe0f4fedec527437bd502a65f8f670ba5db" translate="yes" xml:space="preserve">
          <source>The deserialize field contains a pointer to a C function that is called whenever a custom block with identifier identifier needs to be deserialized (un-marshaled) using the OCaml functions input_value or Marshal.from_.... This user-provided function is responsible for reading back the data written by the serialize operation, using the deserialize_... functions defined in &amp;lt;caml/intext.h&amp;gt; and listed below. It must then rebuild the data part of the custom block and store it at the pointer given as the dst argument. Finally, it returns the size in bytes of the data part of the custom block. This size must be identical to the wsize_32 result of the serialize operation if the architecture is 32 bits, or wsize_64 if the architecture is 64 bits.</source>
          <target state="translated">deserializeフィールドには、OCaml関数input_valueまたはMarshal.from _...を使用して識別子識別子を持つカスタムブロックを逆シリアル化（非マーシャリング）する必要があるときに呼び出されるC関数へのポインタが含まれます。このユーザー提供関数は&amp;lt;caml / intext.h&amp;gt;で定義され、以下にリストされているdeserialize _...関数を使用して、serialize操作によって書き込まれたデータを読み戻します。次に、カスタムブロックのデータ部分を再構築し、dst引数として指定されたポインターに格納する必要があります。最後に、カスタムブロックのデータ部分のサイズをバイト単位で返します。このサイズは、アーキテクチャが32ビットの場合はシリアル化操作のwsize_32の結果と同じである必要があり、アーキテクチャが64ビットの場合はwsize_64と同じである必要があります。</target>
        </trans-unit>
        <trans-unit id="e12a3fa498a55d5d0c412779070a2ed53e0f6b56" translate="yes" xml:space="preserve">
          <source>The deterministic automata generated by ocamllex are limited to at most 32767 transitions. The message above indicates that your lexer definition is too complex and overflows this limit. This is commonly caused by lexer definitions that have separate rules for each of the alphabetic keywords of the language, as in the following example.</source>
          <target state="translated">ocamllexによって生成される決定論的オートマトンは、最大で32767の遷移に制限されています。上のメッセージは、あなたのレキサー定義が複雑すぎて、この制限を超えていることを示しています。これは、次の例のように、言語のアルファベット・キーワードごとに別々のルールを持っている語彙定義によってよく起こります。</target>
        </trans-unit>
        <trans-unit id="f264a27cdcd5df325cf7076559a44cc284c906a3" translate="yes" xml:space="preserve">
          <source>The deterministic automata generated by ocamllex maintain a table of positions inside the scanned lexer buffer. The size of this table is limited to at most 255 cells. This error should not show up in normal situations.</source>
          <target state="translated">ocamllexによって生成された決定論的オートマトンは、スキャンされたレキサーバッファ内の位置のテーブルを保持します。このテーブルのサイズは最大255セルに制限されています。このエラーは通常の状況では表示されないはずです。</target>
        </trans-unit>
        <trans-unit id="3158707a3751ac6c5252dbe261969b8247c51cac" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;1.0&lt;/code&gt; and the smallest exactly representable floating-point number greater than &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;1.0&lt;/code&gt; と、 &lt;code&gt;1.0&lt;/code&gt; より大きい正確に表現可能な最小の浮動小数点数との差。</target>
        </trans-unit>
        <trans-unit id="2adcbc0a31dc0085a55ca93ed2f074bdee4bf581" translate="yes" xml:space="preserve">
          <source>The difference between open and include is that open simply provides short names for the components of the opened structure, without defining any components of the current structure, while include also adds definitions for the components of the included structure.</source>
          <target state="translated">openとincludeの違いは、openは現在の構造体のコンポーネントを定義せずに、単にオープンされた構造体のコンポーネントの短い名前を提供することであり、includeはまた、インクルードされた構造体のコンポーネントの定義を追加します。</target>
        </trans-unit>
        <trans-unit id="9aa0efd021b346152ef35413cf1dcb66bfc3d8c0" translate="yes" xml:space="preserve">
          <source>The difficulty usually lies in defining instances of the pattern above by inheritance. This can be done in a natural and obvious manner in OCaml, as shown on the following example manipulating windows.</source>
          <target state="translated">難しいのは、通常、上記のパターンのインスタンスを継承によって定義することにあります。これは、以下のウィンドウを操作する例に示されているように、OCamlでは自然で明白な方法で行うことができます。</target>
        </trans-unit>
        <trans-unit id="7c440f9c47d69da4fc51fae25d28e485866ceeae" translate="yes" xml:space="preserve">
          <source>The directory containing the OCaml standard library. (If OCAMLLIB is not set, CAMLLIB will be used instead.) Used to locate the ld.conf configuration file for dynamic loading (see section &lt;a href=&quot;#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;). If not set, default to the library directory specified when compiling OCaml.</source>
          <target state="translated">OCaml標準ライブラリを含むディレクトリ。（OCAMLLIBが設定されていない場合は、代わりにCAMLLIBが使用されます。）動的ロード用のld.conf構成ファイルを見つけるために使用されます（セクション&lt;a href=&quot;#s%3Aocamlrun-dllpath&quot;&gt;11.3を&lt;/a&gt;参照）。設定されていない場合、デフォルトでOCamlのコンパイル時に指定されたライブラリディレクトリになります。</target>
        </trans-unit>
        <trans-unit id="84d3f5e5913ebfecb51ac69e325978cd0b7f44c0" translate="yes" xml:space="preserve">
          <source>The directory separator (e.g.</source>
          <target state="translated">ディレクトリの区切り文字(例</target>
        </trans-unit>
        <trans-unit id="6ff406baa499fe8d2e26970180e41618d3f08eae" translate="yes" xml:space="preserve">
          <source>The directory separator (e.g. &lt;code&gt;/&lt;/code&gt; in Unix).</source>
          <target state="translated">ディレクトリ区切り文字（例：Unixの &lt;code&gt;/&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cabc8641d53a500b754d86780ff17e145160ba34" translate="yes" xml:space="preserve">
          <source>The distinction between &lt;code&gt;bytes&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt; was introduced in OCaml 4.02, and the &quot;unsafe-string&quot; compatibility mode was the default until OCaml 4.05. Starting with 4.06, the compatibility mode is opt-in; we intend to remove the option in the future.</source>
          <target state="translated">&lt;code&gt;bytes&lt;/code&gt; と &lt;code&gt;string&lt;/code&gt; の区別はOCaml4.02で導入され、「unsafe-string」互換モードはOCaml4.05までのデフォルトでした。4.06以降、互換モードはオプトインです。将来的にはこのオプションを削除する予定です。</target>
        </trans-unit>
        <trans-unit id="8186633942c846dfc9406083eb5c8a8657d3ebba" translate="yes" xml:space="preserve">
          <source>The domain of a coercion can often be omitted. For instance, one can define:</source>
          <target state="translated">強制の領域は、しばしば省略することができる。例えば、人は定義することができます。</target>
        </trans-unit>
        <trans-unit id="8f7c83c21065a6dbadc8d2a47e55b23520a044b2" translate="yes" xml:space="preserve">
          <source>The dump file is written only if the program terminates normally (by calling exit or by falling through). It is not written if the program terminates with an uncaught exception.</source>
          <target state="translated">ダンプファイルは、プログラムが正常に終了した場合(exitを呼び出すか、フォールスルーして終了した場合)にのみ書き込まれます。捕まえられなかった例外でプログラムが終了した場合は書き込まれません。</target>
        </trans-unit>
        <trans-unit id="73f7bba6640e6313fca9805d26493bd64599c1bc" translate="yes" xml:space="preserve">
          <source>The dynlink library supports type-safe dynamic loading and linking of bytecode object files (.cmo and .cma files) in a running bytecode program, or of native plugins (usually .cmxs files) in a running native program. Type safety is ensured by limiting the set of modules from the running program that the loaded object file can access, and checking that the running program and the loaded object file have been compiled against the same interfaces for these modules. In native code, there are also some compatibility checks on the implementations (to avoid errors with cross-module optimizations); it might be useful to hide .cmx files when building native plugins so that they remain independent of the implementation of modules in the main program.</source>
          <target state="translated">dynlink ライブラリは、実行中のバイトコードプログラム内のバイトコードオブジェクトファイル (.cmo および .cma ファイル)や、実行中のネイティブプログラム内のネイティブプラグイン (通常は .cmxs ファイル)の型安全な動的ロードおよびリンクをサポートします。型の安全性は、ロードされたオブジェクトファイルがアクセスできる実行中のプログラムのモジュールのセットを制限し、実行中のプログラムとロードされたオブジェクトファイルがこれらのモジュールのための同じインタフェースに対してコンパイルされていることを確認することで保証されています。ネイティブコードでは、(クロスモジュール最適化によるエラーを避けるために)実装の互換性チェックも行われています。</target>
        </trans-unit>
        <trans-unit id="bfccb11647d7c3a22dd1b9fca91bf4419d42d590" translate="yes" xml:space="preserve">
          <source>The easiest way to define a custom generator is the following this example, here extending the current HTML generator. We don&amp;rsquo;t have to know if this is the original HTML generator defined in ocamldoc or if it has been extended already by a previously loaded custom generator :</source>
          <target state="translated">カスタムジェネレーターを定義する最も簡単な方法は、次の例です。ここでは、現在のHTMLジェネレーターを拡張します。これがocamldocで定義された元のHTMLジェネレーターであるかどうか、または以前にロードされたカスタムジェネレーターによってすでに拡張されているかどうかを知る必要はありません。</target>
        </trans-unit>
        <trans-unit id="58f055689b02c7748240c0805950d6c0e3a0e111" translate="yes" xml:space="preserve">
          <source>The elements are passed to &lt;code&gt;f&lt;/code&gt; in increasing order with respect to the ordering over the type of the elements.</source>
          <target state="translated">要素は、要素のタイプの順序に関して昇順で &lt;code&gt;f&lt;/code&gt; に渡されます。</target>
        </trans-unit>
        <trans-unit id="6710aa8b225c8ca5f7b41012a718cf1001e66889" translate="yes" xml:space="preserve">
          <source>The else&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; part can be omitted, in which case it defaults to else().</source>
          <target state="translated">else &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;3の&lt;/sub&gt;部分は省略できます。その場合、デフォルトでelse（）になります。</target>
        </trans-unit>
        <trans-unit id="9282996444b9faf1c947138395efb723dd3e6881" translate="yes" xml:space="preserve">
          <source>The empty map.</source>
          <target state="translated">空の地図。</target>
        </trans-unit>
        <trans-unit id="8e51b0d5d7e271c88e867edd7cf3a56d6061ba51" translate="yes" xml:space="preserve">
          <source>The empty sequence, containing no elements.</source>
          <target state="translated">要素を含まない空のシーケンス。</target>
        </trans-unit>
        <trans-unit id="0ac903ee0be4b8d03c2629dea67dc51a5e1dc555" translate="yes" xml:space="preserve">
          <source>The empty set.</source>
          <target state="translated">空のセット。</target>
        </trans-unit>
        <trans-unit id="bcc5ac53238f78e7ccd13efd320b3aba2a2a43c4" translate="yes" xml:space="preserve">
          <source>The environment variable OCAML_COLOR is considered if -color is not provided. Its values are auto/always/never as above.</source>
          <target state="translated">環境変数OCAML_COLORは、-colorが指定されていない場合に考慮されます。その値は上記のようにauto/always/everです。</target>
        </trans-unit>
        <trans-unit id="bc5a16c0802c0d6eab8dd39659b932cb9d3eeec2" translate="yes" xml:space="preserve">
          <source>The environment variable OCAML_ERROR_STYLE is considered if -error-style is not provided. Its values are short/contextual as above.</source>
          <target state="translated">環境変数OCAML_ERROR_STYLEは、-error-styleが指定されていない場合に考慮されます。その値は、上記のように短く、コンテキスト的なものです。</target>
        </trans-unit>
        <trans-unit id="d7f093c02c802f297eef039f1f8ed6be219bfe78" translate="yes" xml:space="preserve">
          <source>The ephemerons complicate the notion of liveness of values, because it is not anymore an equivalence with the reachability from root value by usual pointers (not weak and not ephemerons). With ephemerons the notion of liveness is constructed by the least fixpoint of: A value is alive if:</source>
          <target state="translated">エフェメロンは、通常のポインタ(弱くもなく、エフェメロンでもない)による根元値からの到達可能性との等価性がなくなってしまうため、値の活性度の概念を複雑にしてしまう。エフェメロンでは、生きているという概念は、以下の最小フィックスポイントによって構成されます。値が生きている場合。</target>
        </trans-unit>
        <trans-unit id="f38c615e4885039a9f6a96adebc7d8b6a2703f76" translate="yes" xml:space="preserve">
          <source>The equal function for 16-character digest.</source>
          <target state="translated">16文字ダイジェスト用のイコール関数です。</target>
        </trans-unit>
        <trans-unit id="4745822a26883aa3e079c90a04c121006a19e95e" translate="yes" xml:space="preserve">
          <source>The equal function for chars.</source>
          <target state="translated">charsのイコール関数です。</target>
        </trans-unit>
        <trans-unit id="975faf8015348dfd4f8f27ef557f89666b74bd4f" translate="yes" xml:space="preserve">
          <source>The equal function for floating-point numbers, compared using &lt;a href=&quot;float#VALcompare&quot;&gt;&lt;code&gt;Float.compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;float#VALcompare&quot;&gt; &lt;code&gt;Float.compare&lt;/code&gt; &lt;/a&gt;を使用して比較した、浮動小数点数の等しい関数。</target>
        </trans-unit>
        <trans-unit id="9f25af14cf81fd197468c0aef6ee60036c040bc5" translate="yes" xml:space="preserve">
          <source>The equal function for int32s.</source>
          <target state="translated">int32のイコール関数です。</target>
        </trans-unit>
        <trans-unit id="43353326c31a51a2e1e40be3cfbc055a576f0c46" translate="yes" xml:space="preserve">
          <source>The equal function for int64s.</source>
          <target state="translated">int64のイコール関数です。</target>
        </trans-unit>
        <trans-unit id="9acc244879540dd60658943a5fc7d40212cd5702" translate="yes" xml:space="preserve">
          <source>The equal function for native ints.</source>
          <target state="translated">ネイティブインツのイコール関数。</target>
        </trans-unit>
        <trans-unit id="287fd038b43c08ac15387236db89c8b9dfd89564" translate="yes" xml:space="preserve">
          <source>The equal function for strings.</source>
          <target state="translated">文字列のためのイコール関数。</target>
        </trans-unit>
        <trans-unit id="4a7926a9ee2ed830da3e6706d16691abddc39c2a" translate="yes" xml:space="preserve">
          <source>The equality function for byte sequences.</source>
          <target state="translated">バイト列の等値関数。</target>
        </trans-unit>
        <trans-unit id="af06b8ab4789de98e0de35bd84609d867593cd6b" translate="yes" xml:space="preserve">
          <source>The equality predicate used to compare keys.</source>
          <target state="translated">鍵の比較に使用される等号述語。</target>
        </trans-unit>
        <trans-unit id="83858c6c1566ad5f65edb208e38dd2558053de52" translate="yes" xml:space="preserve">
          <source>The equivalent of -inline but used when speculative inlining starts at toplevel. See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt;. Not used in -Oclassic mode.</source>
          <target state="translated">-inlineと同等ですが、投機的なインライン化がトップレベルで開始する場合に使用されます。セクション&lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6を&lt;/a&gt;参照してください。-Oclassicモードでは使用されません。</target>
        </trans-unit>
        <trans-unit id="94cdb8a214ed46b885c25876cd3600fef2503877" translate="yes" xml:space="preserve">
          <source>The error messages are almost identical to those of ocamlc. See section &lt;a href=&quot;comp#s%3Acomp-errors&quot;&gt;9.4&lt;/a&gt;.</source>
          <target state="translated">エラーメッセージはocamlcのメッセージとほとんど同じです。セクション&lt;a href=&quot;comp#s%3Acomp-errors&quot;&gt;9.4を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7f378c773556e60ceb5a7a9d15fb2d1a81df83d7" translate="yes" xml:space="preserve">
          <source>The evaluation of the body of a class only takes place at object creation time. Therefore, in the following example, the instance variable x is initialized to different values for two different objects.</source>
          <target state="translated">クラスの本体の評価は、オブジェクト作成時にのみ行われます。そのため、以下の例では、インスタンス変数xは2つの異なるオブジェクトに対して異なる値に初期化されています。</target>
        </trans-unit>
        <trans-unit id="823e43ea0dd60b51d8777275d399ee78c608b08d" translate="yes" xml:space="preserve">
          <source>The exact definition of which free variables are captured in a closure is not specified and can vary between bytecode and native code (and according to optimization flags). In particular, a function value accessing a global reference may or may not include the reference in its closure. If it does, unmarshaling the corresponding closure will create a new reference, different from the global one.</source>
          <target state="translated">どの自由変数がクロージャに取り込まれるかの正確な定義は指定されておらず、バイトコードとネイティブコードで(そして最適化フラグによって)異なる可能性があります。特に、グローバル参照にアクセスする関数値は、そのクロージャにその参照を含む場合と含まない場合があります。含まれている場合、対応するクロージャをアンマーシャリングすると、グローバル参照とは異なる新しい参照が作成されます。</target>
        </trans-unit>
        <trans-unit id="367c1c92926004568a37375dcb37462e755ae202" translate="yes" xml:space="preserve">
          <source>The execution of a program is affected by certain information it receives when the debugger starts it, such as the command-line arguments to the program and its working directory. The debugger provides commands to specify this information (set arguments and cd). These commands must be used before program execution starts. If you try to change the arguments or the working directory after starting your program, the debugger will kill the program (after asking for confirmation).</source>
          <target state="translated">プログラムの実行は、プログラムへのコマンドライン引数や作業ディレクトリなど、デバッガが起動したときに受け取る特定の情報によって影響を受けます。デバッガは、この情報を指定するためのコマンド (引数の設定や cd)を提供します。これらのコマンドは、プログラムの実行が開始される前に使用する必要があります。プログラムの起動後に引数や作業ディレクトリを変更しようとすると、デバッガーは (確認を求めた後に)プログラムを終了させます。</target>
        </trans-unit>
        <trans-unit id="891519fb02f7659ffef41323f18ea6f26295ee67" translate="yes" xml:space="preserve">
          <source>The execution times (CPU times) of a process.</source>
          <target state="translated">プロセスの実行時間(CPU時間)。</target>
        </trans-unit>
        <trans-unit id="ea3566383d4d77e6af67a2d9e1c982e58d1aacae" translate="yes" xml:space="preserve">
          <source>The exhaustiveness check is aware of GADT constraints, and can automatically infer that some cases cannot happen. For instance, the following pattern matching is correctly seen as exhaustive (the Add case cannot happen).</source>
          <target state="translated">排他性チェックは、GADT制約を認識しており、いくつかのケースが起こらないことを自動的に推論することができます。例えば、以下のパターン・マッチングは、正しく網羅性があるとみなされます(Addのケースは起こらない)。</target>
        </trans-unit>
        <trans-unit id="682f2afe18d27a6b2d5109af77f4241c373f09ce" translate="yes" xml:space="preserve">
          <source>The expression</source>
          <target state="translated">表現</target>
        </trans-unit>
        <trans-unit id="48d5ec0634b8a1782837ee8b1ca9761b0c8a2b02" translate="yes" xml:space="preserve">
          <source>The expression (&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;) evaluates to the same module as &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;.</source>
          <target state="translated">式（&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;）は、&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;と同じモジュールに評価されます。</target>
        </trans-unit>
        <trans-unit id="fc9adc4308aa68c065cc84caf08fbc1ea795d7aa" translate="yes" xml:space="preserve">
          <source>The expression (&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;:&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;) checks that &lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt; matches the type of &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; (that is, that the implementation &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; meets the type specification &lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;). The whole expression evaluates to the same class as &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;, except that all components not specified in &lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt; are hidden and can no longer be accessed.</source>
          <target state="translated">式（&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;：&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;）は、&lt;a href=&quot;#class-type&quot;&gt;class-&lt;/a&gt; typeが&lt;a href=&quot;#class-expr&quot;&gt;class-exprの&lt;/a&gt;型と一致すること（つまり、実装&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;が型仕様&lt;a href=&quot;#class-type&quot;&gt;class-typeと&lt;/a&gt;一致すること）をチェックします。式全体は、&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;と同じクラスに評価されますが、&lt;a href=&quot;#class-type&quot;&gt;class-typeで&lt;/a&gt;指定されていないすべてのコンポーネントが非表示になり、アクセスできなくなります。</target>
        </trans-unit>
        <trans-unit id="8f1374da867ccabac7aad3663177813cdc0a9fa8" translate="yes" xml:space="preserve">
          <source>The expression (&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;) evaluates to the same module as &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;.</source>
          <target state="translated">式（&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;）は、&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;と同じモジュールに評価されます。</target>
        </trans-unit>
        <trans-unit id="1fd1fd31681b7a2cf0269cba7eed69aec7e48ffe" translate="yes" xml:space="preserve">
          <source>The expression (&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;) checks that the type of &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; is a subtype of &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;, that is, that all components specified in &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; are implemented in &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;, and their implementation meets the requirements given in &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;. In other terms, it checks that the implementation &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; meets the type specification &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;. The whole expression evaluates to the same module as &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;, except that all components not specified in &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; are hidden and can no longer be accessed.</source>
          <target state="translated">式（&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;：&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;）は、&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;のタイプが&lt;a href=&quot;modtypes#module-type&quot;&gt;module-typeの&lt;/a&gt;サブタイプであること、つまり、&lt;a href=&quot;modtypes#module-type&quot;&gt;module-typeで&lt;/a&gt;指定されたすべてのコンポーネントが&lt;a href=&quot;#module-expr&quot;&gt;module-exprに&lt;/a&gt;実装され、それらの実装が&lt;a href=&quot;modtypes#module-type&quot;&gt;モジュールタイプで&lt;/a&gt;指定された要件。つまり、実装&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;が型指定&lt;a href=&quot;modtypes#module-type&quot;&gt;module-typeを&lt;/a&gt;満たしていることを確認します。式全体は、&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;と同じモジュールに評価されますが、&lt;a href=&quot;modtypes#module-type&quot;&gt;module-typeで&lt;/a&gt;指定されていないすべてのコンポーネントが非表示になり、アクセスできなくなります。</target>
        </trans-unit>
        <trans-unit id="bef2d23b52ee970fade1b06935e7b9ced9f528d5" translate="yes" xml:space="preserve">
          <source>The expression (module&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;:&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;) converts the module (structure or functor) denoted by module expression &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; to a value of the core language that encapsulates this module. The type of this core language value is (module&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;). The &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; annotation can be omitted if it can be inferred from the context.</source>
          <target state="translated">式（module &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;：&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;）は、モジュール式&lt;a href=&quot;modules#module-expr&quot;&gt;module-exprで&lt;/a&gt;示されるモジュール（構造体またはファンクター）を、このモジュールをカプセル化するコア言語の値に変換します。このコア言語値のタイプは（module &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;）です。&lt;a href=&quot;#package-type&quot;&gt;パッケージ型の&lt;/a&gt;それは文脈から推測できる場合は注釈を省略することができます。</target>
        </trans-unit>
        <trans-unit id="c3d05c07c0894d4fd053f92bb2e5d69fce8d15a3" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;#&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; invokes the method &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; of the object denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;.</source>
          <target state="translated">式&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;＃&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;は、&lt;a href=&quot;#expr&quot;&gt;exprで&lt;/a&gt;示されるオブジェクトのメソッド&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;を呼び出します。</target>
        </trans-unit>
        <trans-unit id="a5fe9ec8f9aa27454f205256c37ed9a50e6170e6" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&amp;amp;&amp;amp;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates to true if both &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluate to true; otherwise, it evaluates to false. The first component, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, is evaluated first. The second component, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, is not evaluated if the first component evaluates to false. Hence, the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&amp;amp;&amp;amp;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; behaves exactly as</source>
          <target state="translated">表現&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;amp;&amp;amp;&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;の両方の場合は評価する真に&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;と&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;2が&lt;/sub&gt;trueと評価。それ以外の場合は、falseと評価されます。第一の成分は、&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、最初に評価されます。最初のコンポーネントがfalseと評価された場合、&lt;sub&gt;2&lt;/sub&gt;番目のコンポーネント&lt;a href=&quot;#expr&quot;&gt;expr2&lt;/a&gt;は評価されません。したがって、式&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;amp;&amp;amp; &lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;厳密として振る舞います&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="67be0419a621a610a2e5884430cdee8308e61e8d" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; evaluates to the n-tuple of the values of expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. The evaluation order of the subexpressions is not specified.</source>
          <target state="translated">式&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、...、&lt;a href=&quot;#expr&quot;&gt;exprは&lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt;式の値のnタプルに評価は、&lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;1に&lt;/sub&gt;するために&lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt;。部分式の評価順序は指定されていません。</target>
        </trans-unit>
        <trans-unit id="f82e349965c8472e346c4996f8f13cfaa04ee8f5" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;) returns the value of element number &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; in the array denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. The first element has number 0; the last element has number n&amp;minus;1, where n is the size of the array. The exception Invalid_argument is raised if the access is out of bounds.</source>
          <target state="translated">式&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;（&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;）要素番号の値を返し&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;で表される配列内&lt;a href=&quot;#expr&quot;&gt;のexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;。最初の要素の番号は0です。最後の要素の数はn-1です。ここで、nは配列のサイズです。アクセスが範囲外の場合、例外Invalid_argumentが発生します。</target>
        </trans-unit>
        <trans-unit id="b86cf48755f90d38c3703b093a559d201d41505d" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;)&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; modifies in-place the array denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, replacing element number &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; by the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;. The exception Invalid_argument is raised if the access is out of bounds. The value of the whole expression is ().</source>
          <target state="translated">式&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;（&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;）&amp;lt; - &lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;3つの&lt;/sub&gt;インプレース修正によって示さ配列&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;要素数置き換え、&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;の値によって&lt;a href=&quot;#expr&quot;&gt;はexpr &lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;。アクセスが範囲外の場合、例外Invalid_argumentが発生します。式全体の値は（）です。</target>
        </trans-unit>
        <trans-unit id="82e23d1a40c45b5cca334a602a3b8464c8cb5ac6" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to a record value, and returns the value associated to &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; in this record value.</source>
          <target state="translated">式&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;。&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;評価するには、&lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;レコードの値に、そしてに関連する値戻り&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;このレコードの値です。</target>
        </trans-unit>
        <trans-unit id="fac0b26bb16a9c0e18d3fa3496db97765aa8519f" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to a record value, which is then modified in-place by replacing the value associated to &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; in this record by the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. This operation is permitted only if &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; has been declared mutable in the definition of the record type. The whole expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates to the unit value ().</source>
          <target state="translated">式&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;。&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&amp;lt; - &lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;評価する&lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;その後に関連する値置き換えることによってその場で変更されたレコードの値に&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;の値によって、このレコードに&lt;a href=&quot;#expr&quot;&gt;はexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;。この操作は、レコードタイプの定義で&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;が可変であると宣言されている場合にのみ許可されます。式全体&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;。&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&amp;lt; - &lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;2件の&lt;/sub&gt;単位の値に評価されます（）。</target>
        </trans-unit>
        <trans-unit id="7cd6fc3dc672a6d7077ed6957a582e1952b94590" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.[&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;] returns the value of character number &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; in the string denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. The first character has number 0; the last character has number n&amp;minus;1, where n is the length of the string. The exception Invalid_argument is raised if the access is out of bounds.</source>
          <target state="translated">式&lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; ]文字数の値を返す&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;で表される文字列で&lt;a href=&quot;#expr&quot;&gt;はexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;。最初の文字の番号は0です。最後の文字の番号はn-1です。ここで、nは文字列の長さです。アクセスが範囲外の場合、例外Invalid_argumentが発生します。</target>
        </trans-unit>
        <trans-unit id="19a3eefaad7e437247b3bc6db656e1c074dfe4b0" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.[&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;]&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; modifies in-place the string denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, replacing character number &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; by the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;. The exception Invalid_argument is raised if the access is out of bounds. The value of the whole expression is ().</source>
          <target state="translated">式&lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; ] &amp;lt; - &lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;3つの&lt;/sub&gt;インプレース修正を付した文字列&lt;a href=&quot;#expr&quot;&gt;のexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、文字数交換&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;の値によって&lt;a href=&quot;#expr&quot;&gt;はexpr &lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;。アクセスが範囲外の場合、例外Invalid_argumentが発生します。式全体の値は（）です。</target>
        </trans-unit>
        <trans-unit id="54bc0bbda0902a87059f4ab52fd17c9a2c5cb0cd" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; first, then &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, and returns the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="translated">式&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;。&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;2件の&lt;/sub&gt;評価するには、&lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;次に、最初&lt;a href=&quot;#expr&quot;&gt;のexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;、および戻り値&lt;a href=&quot;#expr&quot;&gt;はexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="c3309f1c657c39dcf14b482d1d2b52b485c6e1c1" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;||&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates to true if one of the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates to true; otherwise, it evaluates to false. The first component, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, is evaluated first. The second component, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, is not evaluated if the first component evaluates to true. Hence, the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;||&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; behaves exactly as</source>
          <target state="translated">表現&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; || &lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;式のいずれかがあればTrueに評価&lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;と&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; TRUEに評価します。それ以外の場合は、falseと評価されます。第一の成分は、&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、最初に評価されます。最初のコンポーネントがtrueと評価された場合、&lt;sub&gt;2&lt;/sub&gt;番目のコンポーネント&lt;a href=&quot;#expr&quot;&gt;expr2&lt;/a&gt;は評価されません。したがって、式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; || &lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;振る舞う正確に同じ&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="465cc162397700c3a7233e4d6be2e63f71fde0fe" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;(&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;) evaluates &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to a functor and &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; to a module, and applies the former to the latter. The type of &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; must match the type expected for the arguments of the functor &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.</source>
          <target state="translated">発現&lt;a href=&quot;#module-expr&quot;&gt;モジュール-exprの&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;（&lt;a href=&quot;#module-expr&quot;&gt;モジュール-exprの&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;）を評価&lt;a href=&quot;#module-expr&quot;&gt;モジュール-exprを&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;ファンクタとする&lt;a href=&quot;#module-expr&quot;&gt;モジュール式expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;モジュールに、後者に前者を適用します。種類&lt;a href=&quot;#module-expr&quot;&gt;モジュールのexpr &lt;/a&gt;&lt;sub&gt;2は&lt;/sub&gt;ファンクタの引数に期待されるタイプと一致しなければならない&lt;a href=&quot;#module-expr&quot;&gt;モジュール式expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="1e4e8d9bdc0d328e50497d061e05aaaa6759bfe6" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to the class bound to the name &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt;. Similarly, the expression [&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;]&lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to the parametric class bound to the name &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt;, in which type parameters have been instantiated respectively to &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">式&lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt;は、&lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt;という名前にバインドされたクラスに評価されます。同様に、式[ &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、... &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; ]&lt;a href=&quot;names#class-path&quot;&gt;クラスパス&lt;/a&gt;名にバインドされたパラメトリッククラスに評価される&lt;a href=&quot;names#class-path&quot;&gt;クラスパス&lt;/a&gt;タイプパラメータがそれぞれにインスタンス化された、&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、... &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="88f78fb35dd0d933beef57fab438013880471ef8" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; is equivalent to the class type bound to the name &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;. Similarly, the expression [&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;]&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; is equivalent to the parametric class type bound to the name &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;, in which type parameters have been instantiated to respectively &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">表現&lt;a href=&quot;names#classtype-path&quot;&gt;するClassType-パスは、&lt;/a&gt;名前にバインドされたクラス型と同等である&lt;a href=&quot;names#classtype-path&quot;&gt;のClassTypeパス&lt;/a&gt;。同様に、式[ &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、... &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; ]&lt;a href=&quot;names#classtype-path&quot;&gt;するClassTypeパスは、&lt;/a&gt;名前にバインドされたパラメトリッククラス型に相当する&lt;a href=&quot;names#classtype-path&quot;&gt;するClassTypeパス&lt;/a&gt;タイプパラメータがそれぞれにインスタンス化された、&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、... &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="9bdccee9cf7f9a846ebb0d6ce9a9a4d063b0d4f4" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;) evaluates to the variant value whose constructor is &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;, and whose arguments are the values of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">式&lt;a href=&quot;names#constr&quot;&gt;コンストラクタ&lt;/a&gt;（&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、...、&lt;a href=&quot;#expr&quot;&gt;式exprの&lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt;）コンストラクタバリアント値に評価される&lt;a href=&quot;names#constr&quot;&gt;コンストラクタ&lt;/a&gt;、その引数の値であり、&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ...&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="fd2b0c9502549e5b50e4ab2002a089216e807b74" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates to the unary variant value whose constructor is &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;, and whose argument is the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. Similarly, the expression &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;) evaluates to the n-ary variant value whose constructor is &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; and whose arguments are the values of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">表現&lt;a href=&quot;names#constr&quot;&gt;コンストラクタ&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;コンストラクタです単項バリアント値に評価&lt;a href=&quot;names#constr&quot;&gt;コンストラクタ&lt;/a&gt;、およびその引数の値である&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;。同様に、式&lt;a href=&quot;names#constr&quot;&gt;コンストラクタ&lt;/a&gt;（&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、...、&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;nは&lt;/sub&gt;コンストラクタであるn進バリアント値）を評価&lt;a href=&quot;names#constr&quot;&gt;コンストラクタ&lt;/a&gt;と引数の値である&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、...、&lt;a href=&quot;#expr&quot;&gt;exprは&lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="86658bc3c80f7feb554c6583c0fa9ad438f2d77f" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&amp;lt;-&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; modifies in-place the current object by replacing the value associated to &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; by the value of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;. Of course, this instance variable must have been declared mutable.</source>
          <target state="translated">式&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; &amp;lt; &lt;a href=&quot;expr#expr&quot;&gt;-expr&lt;/a&gt;は、&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-nameに&lt;/a&gt;関連付けられた値を&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;の値に置き換えることにより、現在のオブジェクトをインプレースで変更します。もちろん、このインスタンス変数は可変であると宣言されている必要があります。</target>
        </trans-unit>
        <trans-unit id="7ac13a35707432acbcfeb9a3119c7ad181cc342a" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#modtype-path&quot;&gt;modtype-path&lt;/a&gt; is equivalent to the module type bound to the name &lt;a href=&quot;names#modtype-path&quot;&gt;modtype-path&lt;/a&gt;. The expression (&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;) denotes the same type as &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;.</source>
          <target state="translated">式&lt;a href=&quot;names#modtype-path&quot;&gt;modtype-path&lt;/a&gt;は、名前&lt;a href=&quot;names#modtype-path&quot;&gt;modtype-pathに&lt;/a&gt;バインドされたモジュールタイプと同等です。式（&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;）は、&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;と同じタイプを示します。</target>
        </trans-unit>
        <trans-unit id="63b697cf7e46dafd21affd4bfc9ae60ca539fafc" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; evaluates to the module bound to the name &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.</source>
          <target state="translated">式&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;は、名前&lt;a href=&quot;names#module-path&quot;&gt;module-pathに&lt;/a&gt;バインドされたモジュールに評価されます。</target>
        </trans-unit>
        <trans-unit id="374fd1d5eec03fb1c40077ef206acff290b1b338" translate="yes" xml:space="preserve">
          <source>The expression [|&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;|] evaluates to a n-element array, whose elements are initialized with the values of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; respectively. The order in which these expressions are evaluated is unspecified.</source>
          <target state="translated">式[| &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ; &amp;hellip;; &lt;a href=&quot;#expr&quot;&gt;exprは&lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; |]評価し、その要素の値で初期化されているn型素子アレイに&lt;a href=&quot;#expr&quot;&gt;はexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;ために&lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;nは&lt;/sub&gt;それぞれ。これらの式が評価される順序は指定されていません。</target>
        </trans-unit>
        <trans-unit id="e45182f3efd80314e85a55d033c068a05794bdeb" translate="yes" xml:space="preserve">
          <source>The expression `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates to the polymorphic variant value whose tag is &lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;, and whose argument is the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;.</source>
          <target state="translated">式 ` &lt;a href=&quot;names#tag-name&quot;&gt;tag-name &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;は、タグが&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;であり、引数が&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;の値である多態的なバリアント値に評価されます。</target>
        </trans-unit>
        <trans-unit id="c7801f0a175513fedc9db3b2ea095ee870659f32" translate="yes" xml:space="preserve">
          <source>The expression does not change the observable state of the world save for possibly affecting the state of the garbage collector by performing an allocation. Expressions that only have generative effects and whose results are unused may be eliminated by the compiler. However, unlike expressions with &amp;ldquo;no effects&amp;rdquo;, such expressions will never be eligible for duplication.</source>
          <target state="translated">この式は、割り当てを実行することによってガベージコレクターの状態に影響を与える可能性があることを除いて、世界の観測可能な状態を変更しません。生成効果のみがあり、結果が使用されない式は、コンパイラーによって削除される場合があります。ただし、「効果なし」の表現とは異なり、そのような表現は複製の対象にはなりません。</target>
        </trans-unit>
        <trans-unit id="06268c11c08cbf54ec4d6dfccb9fea053ea40756" translate="yes" xml:space="preserve">
          <source>The expression does not change the observable state of the world. For example, it must not write to any mutable storage, call arbitrary external functions or change control flow (e.g. by raising an exception). Note that allocation is &lt;em&gt;not&lt;/em&gt; classed as having &amp;ldquo;no effects&amp;rdquo; (see below).</source>
          <target state="translated">この表現は、世界の観察可能な状態を変えるものではありません。たとえば、可変ストレージへの書き込み、任意の外部関数の呼び出し、または制御フローの変更（例外の発生など）を行ってはなりません。割り当ては「影響なし」として分類され&lt;em&gt;ない&lt;/em&gt;ことに注意してください（以下を参照）。</target>
        </trans-unit>
        <trans-unit id="54674c43e48502affde9ef34390ab16ef7402518" translate="yes" xml:space="preserve">
          <source>The expression does not observe the effects (in the sense described above) of other expressions. For example, it must not read from any mutable storage or call arbitrary external functions.</source>
          <target state="translated">その式は、他の式の効果(上述の意味で)を観察してはならない。例えば、それは任意の変異可能なストレージから読み取ったり、任意の外部関数を呼び出したりしてはいけません。</target>
        </trans-unit>
        <trans-unit id="66513182b7246bbaa2fec620bc98c1dc1505d3a1" translate="yes" xml:space="preserve">
          <source>The expression e in let x = e in e&amp;rsquo;.</source>
          <target state="translated">式ein let x = e in e '。</target>
        </trans-unit>
        <trans-unit id="fafa3e808d29aa326f8219b2a729faf94bb92f2f" translate="yes" xml:space="preserve">
          <source>The expression forname=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;downto&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;do&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;done evaluates similarly, except that name is successively bound to the values n, n&amp;minus;1, &amp;hellip;, p+1, p. The loop body is never evaluated if n &amp;lt; p.</source>
          <target state="translated">発現にforNameは= &lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;とdownto &lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;行う&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;3件の&lt;/sub&gt;その名前を連続値N、N-1、...、P + 1、Pに結合している以外は、完了評価する同様。n &amp;lt;pの場合、ループ本体は評価されません。</target>
        </trans-unit>
        <trans-unit id="9d57f96f2e7c598ac2e5a92cdba5ecd224f400d7" translate="yes" xml:space="preserve">
          <source>The expression forname=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;to&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;do&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;done first evaluates the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; (the boundaries) into integer values n and p. Then, the loop body &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; is repeatedly evaluated in an environment where name is successively bound to the values n, n+1, &amp;hellip;, p&amp;minus;1, p. The loop body is never evaluated if n &amp;gt; p.</source>
          <target state="translated">発現にforName = &lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;まで&lt;a href=&quot;#expr&quot;&gt;のexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; DO &lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;式は行わ最初評価する&lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;と&lt;a href=&quot;#expr&quot;&gt;exprは&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;の整数値nおよびpに（境界）。次に、ループ本体&lt;a href=&quot;#expr&quot;&gt;のexpr &lt;/a&gt;&lt;sub&gt;3は&lt;/sub&gt;繰り返し名前を連続値N、N + 1、...、P-1、Pに結合されている環境で評価されます。n&amp;gt; pの場合、ループ本体は評価されません。</target>
        </trans-unit>
        <trans-unit id="13ea45faff3269f614a52ad4b80de5d2a8ebf30f" translate="yes" xml:space="preserve">
          <source>The expression fun [[?]&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;:] &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;-&amp;gt;&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; evaluates to a function from values to classes. When this function is applied to a value v, this value is matched against the pattern &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; and the result is the result of the evaluation of &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; in the extended environment.</source>
          <target state="translated">表現の楽しみ[[]？&lt;a href=&quot;lex#label-name&quot;&gt;ラベル名&lt;/a&gt;：]&lt;a href=&quot;patterns#pattern&quot;&gt;パターン&lt;/a&gt;- &amp;gt;&lt;a href=&quot;#class-expr&quot;&gt;クラス-exprのの&lt;/a&gt;クラスへの値から関数に評価されます。この関数が値vに適用されると、この値はパターン&lt;a href=&quot;patterns#pattern&quot;&gt;パターン&lt;/a&gt;と照合され、結果は拡張環境での&lt;a href=&quot;#class-expr&quot;&gt;class-exprの&lt;/a&gt;評価の結果になります。</target>
        </trans-unit>
        <trans-unit id="5a2641611d76e3a4d8e4ffbce3daf0019fe517c9" translate="yes" xml:space="preserve">
          <source>The expression fun(type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; introduces a type constructor named &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt; which is considered abstract in the scope of the sub-expression, but then replaced by a fresh type variable. Note that contrary to what the syntax could suggest, the expression fun(type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; itself does not suspend the evaluation of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; as a regular abstraction would. The syntax has been chosen to fit nicely in the context of function declarations, where it is generally used. It is possible to freely mix regular function parameters with pseudo type parameters, as in:</source>
          <target state="translated">式fun（type &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;）-&amp;gt; &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;は、&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-nameという名前の&lt;/a&gt;型コンストラクターを導入します。これは、部分式のスコープでは抽象と見なされますが、新しい型変数に置き換えられます。構文が示唆するものとは反対に、式fun（type &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;）-&amp;gt; &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;自体は、通常の抽象化のように&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;の評価を一時停止しないことに注意してください。構文は、一般的に使用される関数宣言のコンテキストにうまく適合するように選択されています。次のように、通常の関数パラメータと疑似型パラメータを自由に組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="dc2f0b7a211a145ce7e8a7301a70f0d4c7d342fe" translate="yes" xml:space="preserve">
          <source>The expression functor(&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; evaluates to a functor that takes as argument modules of the type &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, binds &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; to these modules, evaluates &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; in the extended environment, and returns the resulting modules as results. No restrictions are placed on the type of the functor argument; in particular, a functor may take another functor as argument (&amp;ldquo;higher-order&amp;rdquo; functor).</source>
          <target state="translated">発現ファンクタ（&lt;a href=&quot;names#module-name&quot;&gt;モジュール名&lt;/a&gt;：&lt;a href=&quot;modtypes#module-type&quot;&gt;モジュール型&lt;/a&gt;&amp;gt; - ）&lt;a href=&quot;#module-expr&quot;&gt;モジュールはexprの&lt;/a&gt;型の引数モジュールとして取るファンクタに評価&lt;a href=&quot;modtypes#module-type&quot;&gt;モジュール型&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、結合の&lt;a href=&quot;names#module-name&quot;&gt;モジュール名&lt;/a&gt;これらのモジュールに、評価し&lt;a href=&quot;#module-expr&quot;&gt;モジュール-exprの&lt;/a&gt;拡張された環境で、結果のモジュールを結果として返します。ファンクター引数のタイプに制限はありません。特に、ファンクターは別のファンクターを引数として取る場合があります（「高階」ファンクター）。</target>
        </trans-unit>
        <trans-unit id="39045ca493f5041229a426581d36cb35d6454361" translate="yes" xml:space="preserve">
          <source>The expression if&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;then&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;else&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; evaluates to the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; if &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; evaluates to the boolean true, and to the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; if &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; evaluates to the boolean false.</source>
          <target state="translated">if式&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;その後、&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;他の&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;3件&lt;/sub&gt;の値に評価&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;もし&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;1件の&lt;/sub&gt;ブールに評価真、との値に&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;かの&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;ブールfalseと評価。</target>
        </trans-unit>
        <trans-unit id="4cee2fb74666dafe45945b12c3589890b3ad2f7a" translate="yes" xml:space="preserve">
          <source>The expression include&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; in a structure re-exports in the current structure all definitions of the structure denoted by &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;. For instance, if you define a module S as below</source>
          <target state="translated">式には、構造体に&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;が含まれ、module-exprで示される構造体のすべての定義が現在の構造体に再エクスポートされ&lt;a href=&quot;#module-expr&quot;&gt;ます&lt;/a&gt;。たとえば、モジュールSを次のように定義すると</target>
        </trans-unit>
        <trans-unit id="5348485cb90b4b3e0999ac25862d4723d8c8e9d9" translate="yes" xml:space="preserve">
          <source>The expression include&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt; in a signature performs textual inclusion of the components of the signature denoted by &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;. It behaves as if the components of the included signature were copied at the location of the include. The &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt; argument must refer to a module type that is a signature, not a functor type.</source>
          <target state="translated">発現には、&lt;a href=&quot;#module-type&quot;&gt;モジュール型&lt;/a&gt;で示される署名のコンポーネントの署名を行うテキスト包含に&lt;a href=&quot;#module-type&quot;&gt;モジュール型&lt;/a&gt;。インクルードされた署名のコンポーネントがインクルードの場所にコピーされたかのように動作します。&lt;a href=&quot;#module-type&quot;&gt;モジュール型の&lt;/a&gt;引数は、署名ではなく、ファンクタ型でモジュール型を参照しなければなりません。</target>
        </trans-unit>
        <trans-unit id="b2aa219207ffe702cd009fe575887afe0cfda1d7" translate="yes" xml:space="preserve">
          <source>The expression is not evaluated this time; notice that &amp;ldquo;lazy_two evaluation&amp;rdquo; is not printed. The result of the initial computation is simply returned.</source>
          <target state="translated">今回は式は評価されません。「lazy_twoevaluation」は出力されないことに注意してください。初期計算の結果は単純に返されます。</target>
        </trans-unit>
        <trans-unit id="8bad5791aee2947a352057622227636c6db71ed9" translate="yes" xml:space="preserve">
          <source>The expression lazy&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; returns a value v of type Lazy.t that encapsulates the computation of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. The argument &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is not evaluated at this point in the program. Instead, its evaluation will be performed the first time the function Lazy.force is applied to the value v, returning the actual value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. Subsequent applications of Lazy.force to v do not evaluate &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; again. Applications of Lazy.force may be implicit through pattern matching (see &lt;a href=&quot;patterns#sss%3Apat-lazy&quot;&gt;7.6&lt;/a&gt;).</source>
          <target state="translated">式遅延&lt;a href=&quot;#expr&quot;&gt;exprは&lt;/a&gt;の演算カプセル化タイプLazy.tの値v返す&lt;a href=&quot;#expr&quot;&gt;式exprを&lt;/a&gt;。引数&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;は、プログラムのこの時点では評価されません。代わりに、関数Lazy.forceが値vに最初に適用されたときにその評価が実行され、&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;実際の値が返されます。その後のLazy.forceのvへの適用では、&lt;a href=&quot;#expr&quot;&gt;exprは&lt;/a&gt;再度評価されません。 Lazy.forceの適用は、パターンマッチングによって暗黙的に行われる場合があります（&lt;a href=&quot;patterns#sss%3Apat-lazy&quot;&gt;7.6を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="d836be1d196aa1c9fd598fef8e21c88679d68ac4" translate="yes" xml:space="preserve">
          <source>The expression letmodule&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;=&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; locally binds the module expression &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; to the identifier &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; during the evaluation of the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. It then returns the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. For example:</source>
          <target state="translated">発現letmodule&lt;a href=&quot;names#module-name&quot;&gt;モジュール名&lt;/a&gt;=&lt;a href=&quot;modules#module-expr&quot;&gt;モジュール-exprの&lt;/a&gt;中の&lt;a href=&quot;#expr&quot;&gt;exprは&lt;/a&gt;局所的にモジュール式に結合する&lt;a href=&quot;modules#module-expr&quot;&gt;モジュール式exprを&lt;/a&gt;識別子に&lt;a href=&quot;names#module-name&quot;&gt;モジュール名&lt;/a&gt;式の評価中に&lt;a href=&quot;#expr&quot;&gt;式expr&lt;/a&gt;。次に、&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;の値を返します。例えば：</target>
        </trans-unit>
        <trans-unit id="f314e61bf1988c22719a609f5831e22bbdc7dc32" translate="yes" xml:space="preserve">
          <source>The expression object&lt;a href=&quot;#class-body&quot;&gt;class-body&lt;/a&gt;end denotes a class body. This is the prototype for an object : it lists the instance variables and methods of an object of this class.</source>
          <target state="translated">式オブジェクト&lt;a href=&quot;#class-body&quot;&gt;class-&lt;/a&gt; bodyendは、クラス本体を示します。これはオブジェクトのプロトタイプです。このクラスのオブジェクトのインスタンス変数とメソッドを一覧表示します。</target>
        </trans-unit>
        <trans-unit id="6d92cd34881d32ef8ac6eb5fb33636280b1183b9" translate="yes" xml:space="preserve">
          <source>The expression open&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; in a signature does not specify any components. It simply affects the parsing of the following items of the signature, allowing components of the module denoted by &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; to be referred to by their simple names name instead of path accesses &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.name. The scope of the open stops at the end of the signature expression.</source>
          <target state="translated">シグニチャ内の式&lt;a href=&quot;names#module-path&quot;&gt;openmodule-path&lt;/a&gt;は、コンポーネントを指定しません。これは、署名の次の項目の解析に影響を与えるだけであり、&lt;a href=&quot;names#module-path&quot;&gt;module-pathで&lt;/a&gt;示されるモジュールのコンポーネントを、path access module-path.nameではなく単純な名前nameで参照できるようにし&lt;a href=&quot;names#module-path&quot;&gt;ます&lt;/a&gt;。オープンのスコープは、シグニチャ式の最後で停止します。</target>
        </trans-unit>
        <trans-unit id="3374b1493b2b2832203e28fc7202ca2b6bc44cc6" translate="yes" xml:space="preserve">
          <source>The expression open&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; in a structure does not define any components nor perform any bindings. It simply affects the parsing of the following items of the structure, allowing components of the module denoted by &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; to be referred to by their simple names name instead of path accesses &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.name. The scope of the open stops at the end of the structure expression.</source>
          <target state="translated">構造内の式&lt;a href=&quot;names#module-path&quot;&gt;openmodule-path&lt;/a&gt;は、コンポーネントを定義したり、バインディングを実行したりしません。これは、構造体の次の項目の解析に影響を与えるだけであり、&lt;a href=&quot;names#module-path&quot;&gt;module-pathで&lt;/a&gt;示されるモジュールのコンポーネントを、path access module-path.nameではなく単純な名前nameで参照できるようにし&lt;a href=&quot;names#module-path&quot;&gt;ます&lt;/a&gt;。オープンのスコープは、構造式の最後で停止します。</target>
        </trans-unit>
        <trans-unit id="d045a7e48acb78229180ba1f49811e331b9b826a" translate="yes" xml:space="preserve">
          <source>The expression while&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;do&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;done repeatedly evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; while &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; evaluates to true. The loop condition &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is evaluated and tested at the beginning of each iteration. The whole while &amp;hellip; done expression evaluates to the unit value ().</source>
          <target state="translated">一方、表現&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; DO &lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;を繰り返し行っては評価&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;2を&lt;/sub&gt;しながら、&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;1件の&lt;/sub&gt;TRUEと評価されます。ループ条件&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;1が&lt;/sub&gt;評価され、各反復の開始時にテストされています。 while&amp;hellip;done式全体が単位値（）に評価されます。</target>
        </trans-unit>
        <trans-unit id="e7999e39ad27377cd7dc800aeafcf6be489d1e7a" translate="yes" xml:space="preserve">
          <source>The expression {&amp;lt;&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;&amp;gt;} evaluates to a copy of the current object in which the values of instance variables &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; have been replaced by the values of the corresponding expressions &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">式{&amp;lt;&lt;a href=&quot;names#inst-var-name&quot;&gt;工大-VAR名&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; = &lt;a href=&quot;expr#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ; &amp;hellip;;&lt;a href=&quot;names#inst-var-name&quot;&gt;インスト-VAR名&lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; = &lt;a href=&quot;expr#expr&quot;&gt;exprは&lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; &amp;gt;}インスタンス変数の値は、ここで現在のオブジェクトのコピーに評価&lt;a href=&quot;names#inst-var-name&quot;&gt;INST-VAR名&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、...、&lt;a href=&quot;names#inst-var-name&quot;&gt;INST-VAR名&lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt;対応の値によって置き換えられています式は&lt;a href=&quot;expr#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、...、&lt;a href=&quot;expr#expr&quot;&gt;式expr&lt;/a&gt;&lt;sub&gt;のn&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="a02ea084f763d805328a3e7ce4d219962ddcb521" translate="yes" xml:space="preserve">
          <source>The expression {&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;with&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;] ; &amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] } builds a fresh record with fields &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; equal to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, and all other fields having the same value as in the record &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. In other terms, it returns a shallow copy of the record &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, except for the fields &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, which are initialized to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. As previously, single identifier &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;, a qualified identifier &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; and it is possible to add an optional type constraint on each field being updated with {&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;with&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;}.</source>
          <target state="translated">式{ &lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;持つ&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [= &lt;a href=&quot;#expr&quot;&gt;exprは&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ]。 &amp;hellip;;&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;nが&lt;/sub&gt;[= &lt;a href=&quot;#expr&quot;&gt;exprは&lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; ]}フィールド新鮮なレコードを構築する&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ...&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt;に等しい&lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;1つの&lt;/sub&gt;...&lt;a href=&quot;#expr&quot;&gt;式expr &lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt;、およびレコードと同じ値を持つ他のすべてのフィールド&lt;a href=&quot;#expr&quot;&gt;はexprを&lt;/a&gt;。他の点では、レコードの浅いコピーを返す&lt;a href=&quot;#expr&quot;&gt;式exprを&lt;/a&gt;フィールドを除き、&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;1つの&lt;/sub&gt;...&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt;に初期化され、&lt;a href=&quot;#expr&quot;&gt;exprと&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ...&lt;a href=&quot;#expr&quot;&gt;式expr&lt;/a&gt;&lt;sub&gt;のn&lt;/sub&gt;。以前のように、単一の識別子&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;は、&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; =&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;、修飾された識別子&lt;a href=&quot;names#module-path&quot;&gt;モジュールパスを表します&lt;/a&gt;。&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;は&lt;a href=&quot;names#module-path&quot;&gt;モジュールパスを&lt;/a&gt;表します。&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;K&lt;/sub&gt; =&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;K&lt;/sub&gt;、{で更新される各フィールドに任意のタイプの制約を追加することが可能である&lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;持つ&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; = &lt;a href=&quot;#expr&quot;&gt;exprは&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ; &amp;hellip;; &lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; = &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; }。</target>
        </trans-unit>
        <trans-unit id="81df39f38d8523b1217ede44454dadcb59a82246" translate="yes" xml:space="preserve">
          <source>The expression {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;] ; &amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;]} evaluates to the record value { field&lt;sub&gt;1&lt;/sub&gt; = v&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip;; field&lt;sub&gt;n&lt;/sub&gt; = v&lt;sub&gt;n&lt;/sub&gt; } where v&lt;sub&gt;i&lt;/sub&gt; is the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; for i = 1,&amp;hellip; , n. A single identifier &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;, and a qualified identifier &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;. The fields &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; must all belong to the same record type; each field of this record type must appear exactly once in the record expression, though they can appear in any order. The order in which &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are evaluated is not specified. Optional type constraints can be added after each field {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;;&amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;} to force the type of &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; to be compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;.</source>
          <target state="translated">式{&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [= &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ]; &amp;hellip;;&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; [= &lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt;レコード値{フィールドに]}評価する&lt;sub&gt;1&lt;/sub&gt; = V &lt;sub&gt;1&lt;/sub&gt;。 &amp;hellip;;フィールド&lt;sub&gt;N&lt;/sub&gt; = V &lt;sub&gt;N&lt;/sub&gt; }、V &lt;sub&gt;iは、&lt;/sub&gt;の値である&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;I&lt;/sub&gt; I = 1のために...、N。単一の識別子&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;は、&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; =&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;kを表し&lt;/sub&gt;、修飾された識別子&lt;a href=&quot;names#module-path&quot;&gt;モジュールパスを表します&lt;/a&gt;。&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;は&lt;a href=&quot;names#module-path&quot;&gt;モジュールパスを&lt;/a&gt;表します。&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; =&lt;a href=&quot;names#field&quot;&gt;体&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;。フィールドの&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;に&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;nは&lt;/sub&gt;全て同じレコードタイプに属している必要があります。このレコードタイプの各フィールドは、任意の順序で表示できますが、レコード式に1回だけ表示される必要があります。順序&lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;に&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt;評価さが指定されていません。任意のタイプの制約は、各フィールド{後に添加することができる&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; = &lt;a href=&quot;#expr&quot;&gt;exprは&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ; ...;&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; = &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; }は、次のタイプを強制します。&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;kは&lt;/sub&gt;と互換性があることが&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;K&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="770439db3ff36f7c9028cd337c7098117fa187ed" translate="yes" xml:space="preserve">
          <source>The expressions (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;) and begin&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;end have the same value as &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. The two constructs are semantically equivalent, but it is good style to use begin &amp;hellip; end inside control structures:</source>
          <target state="translated">式（&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;）とbegin &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; endは、&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;と同じ値になります。2つの構造は意味的に同等ですが、制御構造内でbegin&amp;hellip;endを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="c9bf76fd4e9d4e7583a34999f67c07a62a02f933" translate="yes" xml:space="preserve">
          <source>The expressions Field(v, n), Byte(v, n) and Byte_u(v, n) are valid l-values. Hence, they can be assigned to, resulting in an in-place modification of value v. Assigning directly to Field(v, n) must be done with care to avoid confusing the garbage collector (see below).</source>
          <target state="translated">式 Field(v,n),Byte(v,n)および Byte_u(v,n)は有効な l 値である。Field(v,n)に直接代入する場合は、ガベージコレクタを混乱させないように注意して行う必要があります (後述)。</target>
        </trans-unit>
        <trans-unit id="d39a1aaa7be45538447c135e96180858a54150e6" translate="yes" xml:space="preserve">
          <source>The expressions letopen&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; and &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;) are strictly equivalent. These constructions locally open the module referred to by the module path &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; in the respective scope of the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;.</source>
          <target state="translated">letopen式&lt;a href=&quot;names#module-path&quot;&gt;モジュールパス&lt;/a&gt;内&lt;a href=&quot;#expr&quot;&gt;のexpr&lt;/a&gt;と&lt;a href=&quot;names#module-path&quot;&gt;モジュールパス&lt;/a&gt;（&lt;a href=&quot;#expr&quot;&gt;exprは&lt;/a&gt;）厳密に等価です。これらの構造は、式&lt;a href=&quot;#expr&quot;&gt;exprの&lt;/a&gt;それぞれのスコープ内のモジュールパス&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;によって参照されるモジュールをローカルに開きます。</target>
        </trans-unit>
        <trans-unit id="e1d5d2150f39dd154ec68fa36cfff5333db652cf" translate="yes" xml:space="preserve">
          <source>The external function f is not available</source>
          <target state="translated">外部機能Fが利用できない</target>
        </trans-unit>
        <trans-unit id="e5f529de453636246288677488101d22e2108e01" translate="yes" xml:space="preserve">
          <source>The field width is composed of an optional integer literal indicating the maximal width of the token to read. For instance, &lt;code&gt;%6d&lt;/code&gt; reads an integer, having at most 6 decimal digits; &lt;code&gt;%4f&lt;/code&gt; reads a float with at most 4 characters; and &lt;code&gt;%8[\000-\255]&lt;/code&gt; returns the next 8 characters (or all the characters still available, if fewer than 8 characters are available in the input).</source>
          <target state="translated">フィールド幅は、読み取るトークンの最大幅を示すオプションの整数リテラルで構成されます。たとえば、 &lt;code&gt;%6d&lt;/code&gt; は、最大6桁の10進数の整数を読み取ります。 &lt;code&gt;%4f&lt;/code&gt; は、最大4文字のfloatを読み取ります。そして &lt;code&gt;%8[\000-\255]&lt;/code&gt; （未満8つの文字入力に利用可能である場合、またはまだ利用可能なすべての文字）次の8つの文字を返します。</target>
        </trans-unit>
        <trans-unit id="ae52f5d3cbe515efd2a7aaa53a21566c409e073d" translate="yes" xml:space="preserve">
          <source>The file curses_stubs.c can be compiled with:</source>
          <target state="translated">curses_stubs.cファイルは、以下のようにコンパイルすることができます。</target>
        </trans-unit>
        <trans-unit id="c9cf1595a49bfb32957e71e1d6050587722d1094" translate="yes" xml:space="preserve">
          <source>The file custom.cmo is created and can be used this way :</source>
          <target state="translated">ファイルcustom.cmoが作成され、このように使用することができます。</target>
        </trans-unit>
        <trans-unit id="139f2d48257c0343c4b071f4794d59ad6e533fc9" translate="yes" xml:space="preserve">
          <source>The file that ocamlrun is trying to execute (e.g. the file given as first non-option argument to ocamlrun) either does not exist, or is not a valid executable bytecode file.</source>
          <target state="translated">ocamlrunが実行しようとしているファイル(例:ocamlrunへの最初の非オプション引数として与えられたファイル)が存在しないか、有効な実行可能なバイトコードファイルではありません。</target>
        </trans-unit>
        <trans-unit id="9df79524971faf6930542e99bcb97fb7e6ed0d2f" translate="yes" xml:space="preserve">
          <source>The file that ocamlrun is trying to execute is not a valid executable bytecode file. Probably it has been truncated or mangled since created. Erase and rebuild it.</source>
          <target state="translated">ocamlrunが実行しようとしているファイルは、有効な実行可能バイトコードファイルではありません。おそらく、作成時から切り捨てられているか、あるいは改ざんされている可能性があります。消去して再構築してください。</target>
        </trans-unit>
        <trans-unit id="1479d9789eb939b776377dc8d01919fe50c91085" translate="yes" xml:space="preserve">
          <source>The files that define the compilation units can be compiled separately using the ocamlc -c command (the -c option means &amp;ldquo;compile only, do not try to link&amp;rdquo;); this produces compiled interface files (with extension .cmi) and compiled object code files (with extension .cmo). When all units have been compiled, their .cmo files are linked together using the ocamlc command. For instance, the following commands compile and link a program composed of two compilation units Aux and Main:</source>
          <target state="translated">コンパイル単位を定義するファイルは、ocamlc -cコマンドを使用して個別にコンパイルできます（-cオプションは、「コンパイルのみ、リンクを試みない」ことを意味します）。これにより、コンパイルされたインターフェイスファイル（拡張子.cmi）とコンパイルされたオブジェクトコードファイル（拡張子.cmo）が生成されます。すべてのユニットがコンパイルされると、それらの.cmoファイルはocamlcコマンドを使用してリンクされます。たとえば、次のコマンドは、2つのコンパイルユニットAuxとMainで構成されるプログラムをコンパイルしてリンクします。</target>
        </trans-unit>
        <trans-unit id="218142a8cd84298a616575dd3b1a7d204717b40e" translate="yes" xml:space="preserve">
          <source>The files you can use to define custom generators are installed in the ocamldoc sub-directory of the OCaml standard library.</source>
          <target state="translated">カスタムジェネレータを定義するために使用できるファイルは、OCaml標準ライブラリの ocamldoc サブディレクトリにインストールされています。</target>
        </trans-unit>
        <trans-unit id="59dbb07f3aaa12eeacf11b0514d46f8f8f33f5ee" translate="yes" xml:space="preserve">
          <source>The finalize field contains a pointer to a C function that is called when the block becomes unreachable and is about to be reclaimed. The block is passed as first argument to the function. The finalize field can also be custom_finalize_default to indicate that no finalization function is associated with the block.</source>
          <target state="translated">finalizeフィールドには、ブロックが到達不可能になり、再利用されようとしているときに呼び出されるC関数へのポインタが含まれています。ブロックは、この関数の第一引数として渡されます。finalize フィールドには、ブロックには最終化関数が関連付けられていないことを示すために custom_finalize_default を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="db242e09b65549d74785bc5f6a999727dbb33d18" translate="yes" xml:space="preserve">
          <source>The first argument of Store_field and Store_double_field must be a variable declared by CAMLparam* or a parameter declared by CAMLlocal* to ensure that a garbage collection triggered by the evaluation of the other arguments will not invalidate the first argument after it is computed.</source>
          <target state="translated">Store_field と Store_double_field の第一引数は、計算後に他の引数の評価によってトリガされるガベージコレクションが第一引数を無効にしないことを確実にするために、CAMLparam*によって宣言された変数または CAMLlocal*によって宣言されたパラメータでなければなりません。</target>
        </trans-unit>
        <trans-unit id="483025a84206923192f7c9762bbef7fe0c59cbd8" translate="yes" xml:space="preserve">
          <source>The first case is an exact variant type: all possible tags are known, with their associated types, and they can all be present. Its structure is fully known.</source>
          <target state="translated">最初のケースは、正確なバリアントタイプです:すべての可能なタグと関連するタイプが既知であり、それらはすべて存在することができます。その構造は完全に知られています。</target>
        </trans-unit>
        <trans-unit id="26e2eb8f32164f7d7049d034e263952e663d7410" translate="yes" xml:space="preserve">
          <source>The first case is simple: g is passed ~y and then ~x, but f expects ~x and then ~y. This is correctly handled if we know the type of g to be x:int -&amp;gt; y:int -&amp;gt; int in advance, but otherwise this causes the above type clash. The simplest workaround is to apply formal parameters in a standard order.</source>
          <target state="translated">最初のケースは単純です。gには〜y、次に〜xが渡されますが、fには〜x、次に〜yが渡されます。gの型がx：int-&amp;gt; y：int-&amp;gt; intであることが事前にわかっている場合、これは正しく処理されますが、そうでない場合、上記の型の衝突が発生します。最も簡単な回避策は、仮パラメーターを標準の順序で適用することです。</target>
        </trans-unit>
        <trans-unit id="7ddf571ff45a432684168e808086b6b09e060a7b" translate="yes" xml:space="preserve">
          <source>The first declaration is incorrect, because the string literal &lt;code&gt;&quot;hello&quot;&lt;/code&gt; could be shared by the compiler with other parts of the program, and mutating &lt;code&gt;incorrect&lt;/code&gt; is a bug. You must always use the second version, which performs a copy and is thus correct.</source>
          <target state="translated">文字列リテラル &lt;code&gt;&quot;hello&quot;&lt;/code&gt; はコンパイラによってプログラムの他の部分と共有される可能性があり、 &lt;code&gt;incorrect&lt;/code&gt; はバグであるため、最初の宣言は正しくありません。常に2番目のバージョンを使用する必要があります。これはコピーを実行するため、正しいものです。</target>
        </trans-unit>
        <trans-unit id="7a8e55f0808e48aad9f2858718bff1a1afbe6952" translate="yes" xml:space="preserve">
          <source>The first form of attributes is attached with a postfix notation on &amp;ldquo;algebraic&amp;rdquo; categories:</source>
          <target state="translated">属性の最初の形式には、「代数的」カテゴリの接尾辞表記が添付されています。</target>
        </trans-unit>
        <trans-unit id="c20d4143c725e414a8fe296ef743e273f408fd33" translate="yes" xml:space="preserve">
          <source>The first form of extension node is used for &amp;ldquo;algebraic&amp;rdquo; categories:</source>
          <target state="translated">拡張ノードの最初の形式は、「代数的」カテゴリに使用されます。</target>
        </trans-unit>
        <trans-unit id="9e06920ecf0cdfc759a972552119b98dac760381" translate="yes" xml:space="preserve">
          <source>The first non-option argument is taken to be the name of the file containing the executable bytecode. (That file is searched in the executable path as well as in the current directory.) The remaining arguments are passed to the OCaml program, in the string array Sys.argv. Element 0 of this array is the name of the bytecode executable file; elements 1 to n are the remaining arguments arg&lt;sub&gt;1&lt;/sub&gt; to arg&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">最初の非オプション引数は、実行可能バイトコードを含むファイルの名前と見なされます。 （そのファイルは、実行可能パスと現在のディレクトリで検索されます。）残りの引数は、文字列配列Sys.argvでOCamlプログラムに渡されます。この配列の要素0は、バイトコード実行可能ファイルの名前です。要素1からn残りの引数は、Argれる&lt;sub&gt;1&lt;/sub&gt;引数に&lt;sub&gt;N&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="4b219d7a443ce004c101ae67774c3ff8d7838f69" translate="yes" xml:space="preserve">
          <source>The first two cases refer to a value identifier, either unqualified or qualified by the path to the structure that define it. * refers to the result just computed (typically, the value of a function application), and is valid only if the selected event is an &amp;ldquo;after&amp;rdquo; event (typically, a function application). $integer refer to a previously printed value. The remaining four forms select part of an expression: respectively, a record field, an array element, a string element, and the current contents of a reference.</source>
          <target state="translated">最初の2つのケースは、値識別子を参照します。値識別子は、修飾されていないか、それを定義する構造へのパスによって修飾されています。*は、計算されたばかりの結果（通常、関数適用の値）を指し、選択されたイベントが「後」イベント（通常、関数適用）である場合にのみ有効です。$ integerは、以前に出力された値を参照します。残りの4つの形式は、式の一部を選択します。それぞれ、レコードフィールド、配列要素、文字列要素、および参照の現在の内容です。</target>
        </trans-unit>
        <trans-unit id="2239d147af301ebf1848d9c3aed42b025297f0fd" translate="yes" xml:space="preserve">
          <source>The five classes of floating-point numbers, as determined by the &lt;a href=&quot;float#VALclassify_float&quot;&gt;&lt;code&gt;Float.classify_float&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;float#VALclassify_float&quot;&gt; &lt;code&gt;Float.classify_float&lt;/code&gt; &lt;/a&gt;関数によって決定される、浮動小数点数の5つのクラス。</target>
        </trans-unit>
        <trans-unit id="e5f4b14dbb83404562f202cb46321bbf598f23f0" translate="yes" xml:space="preserve">
          <source>The five classes of floating-point numbers, as determined by the &lt;a href=&quot;stdlib#VALclassify_float&quot;&gt;&lt;code&gt;classify_float&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALclassify_float&quot;&gt; &lt;code&gt;classify_float&lt;/code&gt; &lt;/a&gt;関数によって決定される浮動小数点数の5つのクラス。</target>
        </trans-unit>
        <trans-unit id="681b526c61bdcee2f004dd7b0da14d09277654dc" translate="yes" xml:space="preserve">
          <source>The flags -Oclassic, -O2 and -O3 are applied before all other flags, meaning that certain parameters may be overridden without having to specify every parameter usually invoked by the given optimisation level.</source>
          <target state="translated">Oclassic,-O2,-O3のフラグは、他のすべてのフラグの前に適用され、特定のパラメータをオーバーライドすることができます。</target>
        </trans-unit>
        <trans-unit id="41e4ad6689358b23fa1eb693a69c5cf4c073612a" translate="yes" xml:space="preserve">
          <source>The flags for &lt;a href=&quot;unix#VALrecv&quot;&gt;&lt;code&gt;Unix.recv&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unix#VALrecvfrom&quot;&gt;&lt;code&gt;Unix.recvfrom&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unix#VALsend&quot;&gt;&lt;code&gt;Unix.send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unix#VALsendto&quot;&gt;&lt;code&gt;Unix.sendto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">フラグ&lt;a href=&quot;unix#VALrecv&quot;&gt; &lt;code&gt;Unix.recv&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;unix#VALrecvfrom&quot;&gt; &lt;code&gt;Unix.recvfrom&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;unix#VALsend&quot;&gt; &lt;code&gt;Unix.send&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;unix#VALsendto&quot;&gt; &lt;code&gt;Unix.sendto&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7fd4283b647a522a0c9037980c206ad3a14cfba5" translate="yes" xml:space="preserve">
          <source>The flags for &lt;a href=&quot;unixlabels#VALrecv&quot;&gt;&lt;code&gt;UnixLabels.recv&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unixlabels#VALrecvfrom&quot;&gt;&lt;code&gt;UnixLabels.recvfrom&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unixlabels#VALsend&quot;&gt;&lt;code&gt;UnixLabels.send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unixlabels#VALsendto&quot;&gt;&lt;code&gt;UnixLabels.sendto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">フラグ&lt;a href=&quot;unixlabels#VALrecv&quot;&gt; &lt;code&gt;UnixLabels.recv&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;unixlabels#VALrecvfrom&quot;&gt; &lt;code&gt;UnixLabels.recvfrom&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;unixlabels#VALsend&quot;&gt; &lt;code&gt;UnixLabels.send&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;unixlabels#VALsendto&quot;&gt; &lt;code&gt;UnixLabels.sendto&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e26b9a410e534dd152b1e84e847e91afe66a6921" translate="yes" xml:space="preserve">
          <source>The flags to &lt;a href=&quot;unix#VALopenfile&quot;&gt;&lt;code&gt;Unix.openfile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopenfile&quot;&gt; &lt;code&gt;Unix.openfile&lt;/code&gt; &lt;/a&gt;へのフラグ。</target>
        </trans-unit>
        <trans-unit id="92926c8ba910a78b19eb9560e04391f617314f85" translate="yes" xml:space="preserve">
          <source>The flags to &lt;a href=&quot;unixlabels#VALopenfile&quot;&gt;&lt;code&gt;UnixLabels.openfile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALopenfile&quot;&gt; &lt;code&gt;UnixLabels.openfile&lt;/code&gt; &lt;/a&gt;へのフラグ。</target>
        </trans-unit>
        <trans-unit id="da416c9b0c9ec887e3c9fed14c90d2a6cfe00274" translate="yes" xml:space="preserve">
          <source>The flags to the &lt;code&gt;Marshal.to_*&lt;/code&gt; functions below.</source>
          <target state="translated">&lt;code&gt;Marshal.to_*&lt;/code&gt; へのフラグは以下で機能します。</target>
        </trans-unit>
        <trans-unit id="e8910a8a70e1456ec6a90eb77007ffc0da7c2187" translate="yes" xml:space="preserve">
          <source>The floating point 0.</source>
          <target state="translated">浮動小数点0です。</target>
        </trans-unit>
        <trans-unit id="4ab9429d7283ec75f0e02bc07dcd3134a72594e2" translate="yes" xml:space="preserve">
          <source>The floating-point -1.</source>
          <target state="translated">浮動小数点-1です。</target>
        </trans-unit>
        <trans-unit id="2f12a48f02e6b8cb1bc97e090aa405bfffaff9d2" translate="yes" xml:space="preserve">
          <source>The floating-point 1.</source>
          <target state="translated">浮動小数点1である。</target>
        </trans-unit>
        <trans-unit id="0cf650e7443d1e286b4973d2572d41f2dd1c5a71" translate="yes" xml:space="preserve">
          <source>The following bindings for the most common debugger commands are available in the *camldebug-progname* buffer:</source>
          <target state="translated">最も一般的なデバッガコマンドの以下のバインディングが *camldebug-progname*バッファで利用できます。</target>
        </trans-unit>
        <trans-unit id="fa8fb8f6579c8a754f8160f2c545902f2c3649f3" translate="yes" xml:space="preserve">
          <source>The following built-in types and predefined exceptions are always defined in the compilation environment, but are not part of any module. As a consequence, they can only be referred by their short names.</source>
          <target state="translated">以下の組み込み型と定義済み例外は常にコンパイル環境で定義されていますが、どのモジュールにも含まれていません。結果として、これらは短い名前でしか参照できません。</target>
        </trans-unit>
        <trans-unit id="741949c165a3e82c7b1f8762527481edfe04447a" translate="yes" xml:space="preserve">
          <source>The following character sequences are also keywords:</source>
          <target state="translated">以下の文字列もキーワードです。</target>
        </trans-unit>
        <trans-unit id="34ab75b655a01e99e773cf2e772887f93cd01533" translate="yes" xml:space="preserve">
          <source>The following characters are considered as blanks: space, horizontal tabulation, carriage return, line feed and form feed. Blanks are ignored, but they separate adjacent identifiers, literals and keywords that would otherwise be confused as one single identifier, literal or keyword.</source>
          <target state="translated">次の文字はブランクとみなされます:スペース、水平集計、キャリッジリターン、改行、フォームフィード。ブランクは無視されますが、隣接する識別子、リテラル、キーワードを分離します。</target>
        </trans-unit>
        <trans-unit id="bfd936c99ec75ec8467efb2fa73208d1cfd7da18" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamlc. The options -pack, -a, -c and -output-obj are mutually exclusive.</source>
          <target state="translated">以下のコマンドラインオプションは ocamlc によって認識されます。pack,-a,-c,-output-objオプションは相互に排他的です。</target>
        </trans-unit>
        <trans-unit id="8fe55eff2fce3bd36f31017706fd97b0e53f6496" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamldep.</source>
          <target state="translated">ocamldepでは以下のコマンドラインオプションが認識されます。</target>
        </trans-unit>
        <trans-unit id="885f4ff9e5ff4ddb2e7d9854020f77ada3553ef5" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamllex.</source>
          <target state="translated">ocamllex は以下のコマンドラインオプションを認識します。</target>
        </trans-unit>
        <trans-unit id="ba3896a823e9e144bf0d4b7e1f61010aad966b5f" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamlmktop.</source>
          <target state="translated">ocamlmktopでは以下のコマンドラインオプションが認識されます。</target>
        </trans-unit>
        <trans-unit id="1edcf650050ceecdfe0b7ab459ca56279ebf0aae" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamlopt. The options -pack, -a, -shared, -c and -output-obj are mutually exclusive.</source>
          <target state="translated">以下のコマンドラインオプションは ocamlopt が認識します。pack,-a,-shared,-c,-output-objオプションは相互に排他的です。</target>
        </trans-unit>
        <trans-unit id="f01e63f748272442f586e0dcde7deabec94a1be5" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamlrun.</source>
          <target state="translated">ocamlrunでは以下のコマンドラインオプションが認識されます。</target>
        </trans-unit>
        <trans-unit id="df87076d9fe00726ba61eaa8293d8eef997abd39" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by the ocaml command.</source>
          <target state="translated">ocamlコマンドでは、以下のコマンドラインオプションが認識されます。</target>
        </trans-unit>
        <trans-unit id="d8652df34978643d1ab214e3a8b1d14afa637e47" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized:</source>
          <target state="translated">以下のコマンドラインオプションが認識されます。</target>
        </trans-unit>
        <trans-unit id="ea03de4698c2ebdfac27067880c0104b3ab3bd1f" translate="yes" xml:space="preserve">
          <source>The following commands create the custom.cma file from files file&lt;sub&gt;1&lt;/sub&gt;.ml[i], ..., file&lt;sub&gt;n&lt;/sub&gt;.ml[i] :</source>
          <target state="translated">次のコマンドは、ファイルfile &lt;sub&gt;1&lt;/sub&gt; .ml [i]、...、file &lt;sub&gt;n&lt;/sub&gt; .ml [i]からcustom.cmaファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="2ef4512268a1e60220a903be3d8066db5cafc567" translate="yes" xml:space="preserve">
          <source>The following commands display information on checkpoints and events:</source>
          <target state="translated">以下のコマンドは、チェックポイントやイベントの情報を表示します。</target>
        </trans-unit>
        <trans-unit id="d56705239611e41383cc5a0fc4c62ec9ece9f729" translate="yes" xml:space="preserve">
          <source>The following commands execute the program forward or backward, starting at the current time. The execution will stop either when specified by the command or when a breakpoint is encountered.</source>
          <target state="translated">以下のコマンドは、現在の時刻を起点として、プログラムを前進または後退させて実行します。実行は、コマンドで指定されたとき、またはブレークポイントが発生したときに停止します。</target>
        </trans-unit>
        <trans-unit id="aa8b474e507be285882f655940a333fef3ed7e16" translate="yes" xml:space="preserve">
          <source>The following constants are treated like built-in constant constructors:</source>
          <target state="translated">以下の定数は組み込み定数のコンストラクタのように扱われます。</target>
        </trans-unit>
        <trans-unit id="f046204697990bb2d0f4cd47a0f626a4abb10376" translate="yes" xml:space="preserve">
          <source>The following directives control the toplevel behavior, load files in memory, and trace program execution.</source>
          <target state="translated">以下のディレクティブは、トップレベルの動作、メモリ内のファイルのロード、プログラムの実行のトレースを制御します。</target>
        </trans-unit>
        <trans-unit id="0e3f41e76fac899ccc6e7dc6bb71eadc7f7839bf" translate="yes" xml:space="preserve">
          <source>The following environment variables are also consulted:</source>
          <target state="translated">また、以下の環境変数も参照しています。</target>
        </trans-unit>
        <trans-unit id="86dc8be3269b92b9232bc979a84ec53ac86636df" translate="yes" xml:space="preserve">
          <source>The following example illustrates how statically-allocated C and Fortran arrays can be made available to OCaml.</source>
          <target state="translated">次の例では、静的に割り当てられた C および Fortran 配列を OCaml で利用できるようにする方法を説明します。</target>
        </trans-unit>
        <trans-unit id="7b95c269aef6e820286357345f289155493b43dd" translate="yes" xml:space="preserve">
          <source>The following example illustrates the assignment of integers and block tags to constructors:</source>
          <target state="translated">次の例では、コンストラクタへの整数とブロックタグの割り当てを説明しています。</target>
        </trans-unit>
        <trans-unit id="bb54e0eb9f74bd676ad11ff69ff7bddb5206be2e" translate="yes" xml:space="preserve">
          <source>The following example of file toto.ml shows where to place comments in a .ml file.</source>
          <target state="translated">次の例では、toto.mlファイルのどこにコメントを配置するかを示しています。</target>
        </trans-unit>
        <trans-unit id="fb214a3cbe4113b36d77da33d2aad1393c44f7c9" translate="yes" xml:space="preserve">
          <source>The following example shows the passing of a two-dimensional Bigarray to a C function and a Fortran function.</source>
          <target state="translated">以下の例では、二次元のBigarrayをC関数とFortran関数に渡しています。</target>
        </trans-unit>
        <trans-unit id="28d8c0cb68d2ae92275d2ecc53225fa520b47419" translate="yes" xml:space="preserve">
          <source>The following example uses a private type abbreviation to define a module of nonnegative integers:</source>
          <target state="translated">以下の例では、プライベート型の略語を使用して、非負の整数のモジュールを定義しています。</target>
        </trans-unit>
        <trans-unit id="d3ae00605da64b105662093b0c38586124245f33" translate="yes" xml:space="preserve">
          <source>The following example, known as the subject/observer pattern, is often presented in the literature as a difficult inheritance problem with inter-connected classes. The general pattern amounts to the definition a pair of two classes that recursively interact with one another.</source>
          <target state="translated">サブジェクト/オブザーバーパターンとして知られる以下の例は、相互に接続されたクラスの難しい継承問題として、しばしば文献で紹介されています。一般的なパターンは,互いに再帰的に相互作用する2つのクラスのペアを定義するものです.</target>
        </trans-unit>
        <trans-unit id="fe79f151ba4780648aa79dae8b08c42dcb70ffa0" translate="yes" xml:space="preserve">
          <source>The following functions are exposed to help write compatible C stubs. To use them, you need to include both &amp;lt;caml/misc.h&amp;gt; and &amp;lt;caml/osdeps.h&amp;gt;.</source>
          <target state="translated">次の関数は、互換性のあるCスタブの作成に役立つように公開されています。それらを使用するには、&amp;lt;caml /misc.h&amp;gt;と&amp;lt;caml / osdeps.h&amp;gt;の両方を含める必要があります。</target>
        </trans-unit>
        <trans-unit id="832fc1be181c5700f255f7f5cd917c79991599e3" translate="yes" xml:space="preserve">
          <source>The following functions are slightly more efficient than caml_alloc, but also much more difficult to use.</source>
          <target state="translated">以下の関数は、caml_allocよりも若干効率が良いですが、使いこなすのが大変です。</target>
        </trans-unit>
        <trans-unit id="e63d19b6970bf278c78ca3c011faa62ed74f62ae" translate="yes" xml:space="preserve">
          <source>The following functions can be called from the semantic actions of lexer definitions (the ML code enclosed in braces that computes the value returned by lexing functions). They give access to the character string matched by the regular expression associated with the semantic action. These functions must be applied to the argument &lt;code&gt;lexbuf&lt;/code&gt;, which, in the code generated by &lt;code&gt;ocamllex&lt;/code&gt;, is bound to the lexer buffer passed to the parsing function.</source>
          <target state="translated">次の関数は、レクサー定義（字句関数によって返される値を計算する中括弧で囲まれたMLコード）のセマンティックアクションから呼び出すことができます。これらは、セマンティックアクションに関連付けられた正規表現と一致する文字列へのアクセスを提供します。これらの関数は、引数 &lt;code&gt;lexbuf&lt;/code&gt; に適用する必要があります。この引数は、 &lt;code&gt;ocamllex&lt;/code&gt; によって生成されたコードで、解析関数に渡されたレクサーバッファーにバインドされます。</target>
        </trans-unit>
        <trans-unit id="45f2a5408f593c266bc5b945e256185ab7faa225" translate="yes" xml:space="preserve">
          <source>The following functions implement the POSIX standard terminal interface. They provide control over asynchronous communication ports and pseudo-terminals. Refer to the &lt;code&gt;termios&lt;/code&gt; man page for a complete description.</source>
          <target state="translated">以下の関数は、POSIX標準端末インターフェースを実装します。これらは、非同期通信ポートと疑似端末を制御します。完全な説明については、 &lt;code&gt;termios&lt;/code&gt; のマニュアルページを参照してください。</target>
        </trans-unit>
        <trans-unit id="04b159ad2babd8305b93430182e2074b26259f77" translate="yes" xml:space="preserve">
          <source>The following functions, defined in &amp;lt;caml/intext.h&amp;gt;, are provided to write and read back the contents of custom blocks in a portable way. Those functions handle endianness conversions when e.g. data is written on a little-endian machine and read back on a big-endian machine.</source>
          <target state="translated">&amp;lt;caml / intext.h&amp;gt;で定義されている次の関数は、カスタムブロックの内容を移植可能な方法で読み書きするために提供されています。これらの関数は、データがリトルエンディアンマシンで書き込まれ、ビッグエンディアンマシンで読み戻される場合などに、エンディアン変換を処理します。</target>
        </trans-unit>
        <trans-unit id="d4d76bd017aaace084c2fe4ba75e854a770052fa" translate="yes" xml:space="preserve">
          <source>The following idiom separates description and definition.</source>
          <target state="translated">次の慣用句では、記述と定義を分けています。</target>
        </trans-unit>
        <trans-unit id="abdd18dbed9ebbfffd9a3d53fecf519fa1b39456" translate="yes" xml:space="preserve">
          <source>The following invariant holds for any file name &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="translated">次不変では任意のファイル名に成り立つ &lt;code&gt;s&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="da4c18672e8270bfb1a76f87b23a373991175930" translate="yes" xml:space="preserve">
          <source>The following language semantics apply specifically to constant float arrays. (By &amp;ldquo;constant float array&amp;rdquo; is meant an array consisting entirely of floating point numbers that are known at compile time. A common case is a literal such as [| 42.0; 43.0; |].</source>
          <target state="translated">次の言語セマンティクスは、特に定数float配列に適用されます。（「定数浮動小数点配列」とは、コンパイル時に既知の浮動小数点数のみで構成される配列を意味します。一般的なケースは、[| 42.0; 43.0; |]などのリテラルです。</target>
        </trans-unit>
        <trans-unit id="2f8a143ee55050d3e9f8c912fc4c49000ef1b06a" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -dot option:</source>
          <target state="translated">以下のオプションは、-dot オプションと併用して適用されます。</target>
        </trans-unit>
        <trans-unit id="166817d7c28936e2b423cdda7a6aa67512725a8e" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -html option:</source>
          <target state="translated">以下のオプシ ョ ンは、 -html オプシ ョ ン と 合わせて適用 さ れます。</target>
        </trans-unit>
        <trans-unit id="4ecf6b7625e3e537050eaf9dc3a7fa22f048e25b" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -latex option:</source>
          <target state="translated">以下のオプシ ョ ンは、 -latex オプシ ョ ン と と も に適用 さ れます。</target>
        </trans-unit>
        <trans-unit id="cbc2ec126f36a5f0afa27f31d58d5bda45d9c06d" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -man option:</source>
          <target state="translated">以下のオプションは、-man オプションと一緒に適用されます。</target>
        </trans-unit>
        <trans-unit id="051fe64a5d38a370f62ad07eadfb825faac6621f" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -texi option:</source>
          <target state="translated">以下のオプションは、-texiオプションと一緒に適用されます。</target>
        </trans-unit>
        <trans-unit id="3d4dbac485d984712c71b7a64c65bc9a132b2436" translate="yes" xml:space="preserve">
          <source>The following options are recognized by ocamlprof:</source>
          <target state="translated">ocamlprofでは以下のオプションが認識されます。</target>
        </trans-unit>
        <trans-unit id="6a846492c1f0c6319e8b3788beab792307a98121" translate="yes" xml:space="preserve">
          <source>The following options determine the format for the generated documentation.</source>
          <target state="translated">以下のオプションは、生成されるドキュメントのフォーマットを決定します。</target>
        </trans-unit>
        <trans-unit id="8c2e53d36ec19399f7c32f9aac23861dbfe9cf9f" translate="yes" xml:space="preserve">
          <source>The following rules must be respected in order to avoid name clashes resulting in cross-reference errors:</source>
          <target state="translated">相互参照エラーの原因となる名前の衝突を避けるためには、以下のルールを尊重しなければなりません。</target>
        </trans-unit>
        <trans-unit id="097e045769a0dca8fade64c26d195db8b9414337" translate="yes" xml:space="preserve">
          <source>The following sample interface file foo.mli illustrates the placement rules for comments in .mli files.</source>
          <target state="translated">次のサンプルインターフェイスファイル foo.mli は、.mli ファイル内のコメントの配置ルールを示しています。</target>
        </trans-unit>
        <trans-unit id="ebfe702602d2495e52da52309ab1711b73354bb5" translate="yes" xml:space="preserve">
          <source>The following table gives the list of predefined @-tags, with their syntax and meaning.</source>
          <target state="translated">次の表は、定義済みの@タグのリストと、その構文と意味を示しています。</target>
        </trans-unit>
        <trans-unit id="dd8a8320baafd30cfa4602768ee2151691b2708f" translate="yes" xml:space="preserve">
          <source>The following table lists the precedence level of all operator classes from the highest to the lowest precedence. A few other syntactic constructions are also listed as references.</source>
          <target state="translated">以下の表では、すべての演算子クラスの優先順位が最も高いものから最も低いものまでをリストアップしています。他のいくつかの構文も参照としてリストアップされています。</target>
        </trans-unit>
        <trans-unit id="9e256f5eaf5d8b81e4043192160908c1bd8faea3" translate="yes" xml:space="preserve">
          <source>The following table summarize what OCaml types can be unboxed, and what C types should be used in correspondence:</source>
          <target state="translated">以下の表では、どのようなOCamlの型がアンボックス化できるのか、対応して使用すべきCの型は何かをまとめています。</target>
        </trans-unit>
        <trans-unit id="ef06aa8040c0f03b521f5cef891b934434387cc7" translate="yes" xml:space="preserve">
          <source>The following terminology is used in this chapter of the manual.</source>
          <target state="translated">マニュアルのこの章では、以下の用語を使用しています。</target>
        </trans-unit>
        <trans-unit id="1699520402e7ac3828d5b8bcc342d6a427931baa" translate="yes" xml:space="preserve">
          <source>The following two functions are deprecated. Use module &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">次の2つの関数は非推奨です。代わりにモジュール&lt;a href=&quot;marshal&quot;&gt; &lt;code&gt;Marshal&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="b87aaa89310b1024b8a1a7a3d739748757473aea" translate="yes" xml:space="preserve">
          <source>The form exception&lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt; generates a new exception, distinct from all other exceptions in the system. The form exception&lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt;=&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; gives an alternate name to an existing exception.</source>
          <target state="translated">フォーム例外&lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt;は、システム内の他のすべての例外とは異なり、新しい例外を生成します。形式exceptionconstr &lt;a href=&quot;names#constr-name&quot;&gt;-name&lt;/a&gt; = &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;は、既存の例外に代替名を付けます。</target>
        </trans-unit>
        <trans-unit id="b37d1605c59154ddd022186be0bfed3eb3e2b35d" translate="yes" xml:space="preserve">
          <source>The form external&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt; is similar, except that it requires in addition the name to be implemented as the external function specified in &lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt; (see chapter &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;).</source>
          <target state="translated">外部&lt;a href=&quot;names#value-name&quot;&gt;値名&lt;/a&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; = &lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt;の形式も同様ですが、&lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declarationで&lt;/a&gt;指定された外部関数として名前を実装する必要がある点が異なります（第&lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;章を参照）。</target>
        </trans-unit>
        <trans-unit id="3184fd8520491af729727e8e58dedc4128114b17" translate="yes" xml:space="preserve">
          <source>The format of decimal floating-point numbers is &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;dd.ddd&amp;nbsp;(e|E)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt;, where &lt;code&gt;d&lt;/code&gt; stands for a decimal digit.</source>
          <target state="translated">10進浮動小数点数の形式は &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;dd.ddd&amp;nbsp;(e|E)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt; 。ここで、 &lt;code&gt;d&lt;/code&gt; は10進数字を表します。</target>
        </trans-unit>
        <trans-unit id="7828f8d5d5c611bdddc6c78b6ef04afbcd5d417e" translate="yes" xml:space="preserve">
          <source>The format of hexadecimal floating-point numbers is &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;0(x|X)&amp;nbsp;hh.hhh&amp;nbsp;(p|P)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt;, where &lt;code&gt;h&lt;/code&gt; stands for an hexadecimal digit and &lt;code&gt;d&lt;/code&gt; for a decimal digit.</source>
          <target state="translated">16進浮動小数点数の形式は、 &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;0(x|X)&amp;nbsp;hh.hhh&amp;nbsp;(p|P)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt; 。ここで、 &lt;code&gt;h&lt;/code&gt; は16進数を表し、 &lt;code&gt;d&lt;/code&gt; は10進数を表します。</target>
        </trans-unit>
        <trans-unit id="812ca11444f87b91a5c1a4d58c74d93fafa141dc" translate="yes" xml:space="preserve">
          <source>The format of lexer definitions is as follows:</source>
          <target state="translated">レクサーの定義の形式は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="127323cd14f10ff976ce82741602642432da7e75" translate="yes" xml:space="preserve">
          <source>The format string &lt;code&gt;fmt&lt;/code&gt; is a character string which contains three types of objects: plain characters and conversion specifications as specified in the &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt; module, and pretty-printing indications specific to the &lt;code&gt;Format&lt;/code&gt; module.</source>
          <target state="translated">フォーマット文字列 &lt;code&gt;fmt&lt;/code&gt; は、&lt;a href=&quot;printf&quot;&gt; &lt;code&gt;Printf&lt;/code&gt; &lt;/a&gt;モジュールで指定されたプレーン文字と変換仕様、および &lt;code&gt;Format&lt;/code&gt; モジュールに固有のプリティプリント表示の3種類のオブジェクトを含む文字列です。</target>
        </trans-unit>
        <trans-unit id="98fb30c95542494775f06815271fe47f1e740e5d" translate="yes" xml:space="preserve">
          <source>The format string is a character string which contains three types of objects:</source>
          <target state="translated">フォーマット文字列は、3種類のオブジェクトを含む文字列です。</target>
        </trans-unit>
        <trans-unit id="66553eccbf80219caa1c3c646bc08b8b25b163d4" translate="yes" xml:space="preserve">
          <source>The format string is a character string which contains two types of objects: plain characters, which are simply copied to the output channel, and conversion specifications, each of which causes conversion and printing of arguments.</source>
          <target state="translated">フォーマット文字列は、出力チャンネルに単純にコピーされるプレーンな文字と、それぞれが引数の変換や印刷を引き起こす変換指定の2種類のオブジェクトを含む文字列です。</target>
        </trans-unit>
        <trans-unit id="9fd14a172518628e19f32be0e91f3d86d102d1cd" translate="yes" xml:space="preserve">
          <source>The formatted input functions can read from any kind of input, including strings, files, or anything that can return characters. The more general source of characters is named a &lt;em&gt;formatted input channel&lt;/em&gt; (or &lt;em&gt; scanning buffer&lt;/em&gt;) and has type &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt;. The more general formatted input function reads from any scanning buffer and is named &lt;code&gt;bscanf&lt;/code&gt;.</source>
          <target state="translated">フォーマットされた入力関数は、文字列、ファイル、または文字を返すことができるものを含む、あらゆる種類の入力から読み取ることができます。より一般的な文字のソースは、&lt;em&gt;フォーマットされた入力チャネル&lt;/em&gt;（または&lt;em&gt;スキャンバッファー&lt;/em&gt;）と呼ばれ、タイプは&lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt; &lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt; &lt;/a&gt;です。より一般的なフォーマットの入力関数は、任意のスキャンバッファーから読み取り、 &lt;code&gt;bscanf&lt;/code&gt; という名前が付けられます。</target>
        </trans-unit>
        <trans-unit id="e23bc34a1d5333a784d920ce0ee827fd82d18c4c" translate="yes" xml:space="preserve">
          <source>The former alternative is more convenient for the final users of the library, however.</source>
          <target state="translated">しかし、図書館の最終利用者にとっては、前者の方が便利です。</target>
        </trans-unit>
        <trans-unit id="cf9a1462b05ebbf56fca1e287e7b7e2870abd6cd" translate="yes" xml:space="preserve">
          <source>The former operator will sometimes fail to coerce an expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; from a type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to a type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; even if type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a subtype of type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;: in the current implementation it only expands two levels of type abbreviations containing objects and/or polymorphic variants, keeping only recursion when it is explicit in the class type (for objects). As an exception to the above algorithm, if both the inferred type of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt; are ground (&lt;em&gt;i.e.&lt;/em&gt; do not contain type variables), the former operator behaves as the latter one, taking the inferred type of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; as &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. In case of failure with the former operator, the latter one should be used.</source>
          <target state="translated">前者オペレータが時々発現強制的に失敗する&lt;a href=&quot;#expr&quot;&gt;のexprを&lt;/a&gt;型から&lt;a href=&quot;types#typexpr&quot;&gt;TYP &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;型に&lt;a href=&quot;types#typexpr&quot;&gt;TYP &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;も入力すると&lt;a href=&quot;types#typexpr&quot;&gt;TYP &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;タイプのサブタイプである&lt;a href=&quot;types#typexpr&quot;&gt;標準&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;：現在の実装では、オブジェクトのみを含むタイプの略語2つのレベルを拡張および/または多形バリアント。クラスタイプ（オブジェクトの場合）で明示的である場合にのみ再帰を保持します。上記のアルゴリズムの例外として、推定されたタイプの&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;と&lt;a href=&quot;types#typexpr&quot;&gt;typの&lt;/a&gt;両方がグラウンドである（&lt;em&gt;つまり&lt;/em&gt;、タイプ変数を含まない）場合、前者の演算子は後者の演算子として動作し、推定されたタイプの&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;を取得します。&lt;a href=&quot;types#typexpr&quot;&gt;タイプ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;として。前者のオペレーターで失敗した場合は、後者のオペレーターを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="e62ce70c70537475c1b181d579e82b479775978d" translate="yes" xml:space="preserve">
          <source>The fprintf function is like printf except that it takes an output channel as the first argument. The %a specifier can be useful to define custom printer (for custom types). For instance, we can create a printing template that converts an integer argument to signed decimal:</source>
          <target state="translated">fprintf 関数は printf と似ていますが、出力チャネルを第 1 引数に取ることを除きます。a 指定子は、(カスタム型の)カスタム・プリンタを定義するのに便利です。例えば、整数の引数を符号付き 10 進数に変換する印刷テンプレートを作成できます。</target>
        </trans-unit>
        <trans-unit id="d13a291c5fa3db94f06d27016206ff693957ed08" translate="yes" xml:space="preserve">
          <source>The front-end is a part of compiler-libs library. Programs that use the compiler-libs library should be built as follows:</source>
          <target state="translated">フロントエンドは compiler-libs ライブラリの一部です。compiler-libsライブラリを使用するプログラムは以下のようにビルドしてください。</target>
        </trans-unit>
        <trans-unit id="4658f7d95c6ccb485b665c4a8fd77d14df445b99" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;caml_process_pending_actions&lt;/code&gt; from &amp;lt;caml/signals.h&amp;gt; executes any pending signal handlers and finalisers, Memprof callbacks, and requested minor and major garbage collections. In particular, it can raise asynchronous exceptions. It is recommended to call it regularly at safe points inside long-running non-blocking C code.</source>
          <target state="translated">&amp;lt;caml / signal.h&amp;gt;の関数 &lt;code&gt;caml_process_pending_actions&lt;/code&gt; は、保留中のシグナルハンドラーとファイナライザー、Memprofコールバックを実行し、マイナーおよびメジャーのガベージコレクションを要求しました。特に、非同期例外が発生する可能性があります。長時間実行される非ブロッキングCコード内の安全な場所で定期的に呼び出すことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="0830c833940b33a13600b2fc8f3c6ec9ed72ba39" translate="yes" xml:space="preserve">
          <source>The function's output is specified by the following invariants:</source>
          <target state="translated">関数の出力は以下の不変量で指定されます。</target>
        </trans-unit>
        <trans-unit id="b16f05a4538c91ac60ba6969c4d9b5e686f1d91a" translate="yes" xml:space="preserve">
          <source>The functions from module &lt;a href=&quot;random.state&quot;&gt;&lt;code&gt;Random.State&lt;/code&gt;&lt;/a&gt; manipulate the current state of the random generator explicitly. This allows using one or several deterministic PRNGs, even in a multi-threaded program, without interference from other parts of the program.</source>
          <target state="translated">モジュール&lt;a href=&quot;random.state&quot;&gt; &lt;code&gt;Random.State&lt;/code&gt; &lt;/a&gt;の関数は、ランダムジェネレーターの現在の状態を明示的に操作します。これにより、マルチスレッドプログラムでも、プログラムの他の部分からの干渉を受けることなく、1つまたは複数の決定論的PRNGを使用できます。</target>
        </trans-unit>
        <trans-unit id="cbce52b776ac08f2366078197c98e1659ba43ad5" translate="yes" xml:space="preserve">
          <source>The functions in this module are thread safe.</source>
          <target state="translated">このモジュールの関数はスレッドセーフです。</target>
        </trans-unit>
        <trans-unit id="511113955645abe47f0e74cfd8701cd531b7acf8" translate="yes" xml:space="preserve">
          <source>The functions in this section append binary encodings of integers to buffers.</source>
          <target state="translated">このセクションの関数は、整数のバイナリエンコーディングをバッファに追加します。</target>
        </trans-unit>
        <trans-unit id="735840deef678499261950948d63f843f78e8b4b" translate="yes" xml:space="preserve">
          <source>The functions in this section binary encode and decode integers to and from byte sequences.</source>
          <target state="translated">このセクションの関数は、バイト列への整数のエンコードとバイト列からの整数のデコードをバイナリで行います。</target>
        </trans-unit>
        <trans-unit id="692df968d9b76de8295f62a1cc39eca74e7c54e9" translate="yes" xml:space="preserve">
          <source>The functor Client may also be redefined when some new features of the account can be given to the client.</source>
          <target state="translated">ファンクタClientは、アカウントのいくつかの新しい機能をクライアントに与えることができる場合に再定義されることもあります。</target>
        </trans-unit>
        <trans-unit id="23eb5fdacb362f1e019b7a5da5dbe8a3fbb9da5e" translate="yes" xml:space="preserve">
          <source>The functorial interface allows the use of specific comparison and hash functions, either for performance/security concerns, or because keys are not hashable/comparable with the polymorphic builtins.</source>
          <target state="translated">ファンクショナル・インターフェイスは、性能やセキュリティ上の懸念や、鍵がハッシュ化できない/ポリモーフィック・ビルトインと比較できないために、特定の比較関数やハッシュ関数を使用することを可能にしています。</target>
        </trans-unit>
        <trans-unit id="9842cecf834f807f4e52659d4bb05e758d2b67ff" translate="yes" xml:space="preserve">
          <source>The general formatted input function</source>
          <target state="translated">一般的な書式設定された入力機能</target>
        </trans-unit>
        <trans-unit id="39ea5439ffc8a37ae7dfd624fd6123810662e231" translate="yes" xml:space="preserve">
          <source>The generated module defines one parsing function per entry point in the grammar. These functions have the same names as the entry points. Parsing functions take as arguments a lexical analyzer (a function from lexer buffers to tokens) and a lexer buffer, and return the semantic attribute of the corresponding entry point. Lexical analyzer functions are usually generated from a lexer specification by the ocamllex program. Lexer buffers are an abstract data type implemented in the standard library module Lexing. Tokens are values from the concrete type token, defined in the interface file grammar.mli produced by ocamlyacc.</source>
          <target state="translated">生成されたモジュールは、文法のエントリポイントごとに1つの解析関数を定義します。これらの関数はエントリポイントと同じ名前を持っています。解析関数は、語彙解析器(語彙バッファからトークンへの関数)と語彙バッファを引数にとり、対応するエントリポイントの意味属性を返します。語彙解析関数は通常、 ocamllexプログラムによって語彙指定から生成されます。レクサーバッファは標準ライブラリモジュールLexingで実装されている抽象データ型です。トークンは、 ocamlyaccによって生成されたインターフェースファイル grammar.mliで定義されている具象型トークンの値です。</target>
        </trans-unit>
        <trans-unit id="a2263e6287694d2f2d32e4219ff36b6fad805902" translate="yes" xml:space="preserve">
          <source>The generated trace files are stored using the &lt;em&gt;Common Trace Format&lt;/em&gt;, which is a general purpose binary tracing format. A complete trace consists of:</source>
          <target state="translated">生成されたトレースファイルは、汎用のバイナリ&lt;em&gt;トレース形式&lt;/em&gt;である&lt;em&gt;Common TraceFormat&lt;/em&gt;を使用して保存されます。完全なトレースは次のもので構成されます。</target>
        </trans-unit>
        <trans-unit id="05828d489f6ac2387f6a65167157fb9f23021c22" translate="yes" xml:space="preserve">
          <source>The greatest representable 32-bit integer, 2&lt;sup&gt;31&lt;/sup&gt; - 1.</source>
          <target state="translated">最大表現可能な32ビット整数、2 &lt;sup&gt;31&lt;/sup&gt; - 1です。</target>
        </trans-unit>
        <trans-unit id="a404ad0913817fcb80ea923a9800ed75493e4170" translate="yes" xml:space="preserve">
          <source>The greatest representable 64-bit integer, 2&lt;sup&gt;63&lt;/sup&gt; - 1.</source>
          <target state="translated">最大表現可能な64ビット整数、2 &lt;sup&gt;63&lt;/sup&gt; - 1です。</target>
        </trans-unit>
        <trans-unit id="4f471d57c7b55d66ee6fb3224ba15693e2e1e916" translate="yes" xml:space="preserve">
          <source>The greatest representable integer.</source>
          <target state="translated">表現可能な最大の整数。</target>
        </trans-unit>
        <trans-unit id="83953d60191eeb31cc3f9a4dc8dba81bf1560d9f" translate="yes" xml:space="preserve">
          <source>The greatest representable native integer, either 2&lt;sup&gt;31&lt;/sup&gt; - 1 on a 32-bit platform, or 2&lt;sup&gt;63&lt;/sup&gt; - 1 on a 64-bit platform.</source>
          <target state="translated">最大の表現ネイティブ整数、いずれか2 &lt;sup&gt;31&lt;/sup&gt; - 32ビットプラットフォーム上の1、または2 &lt;sup&gt;63&lt;/sup&gt; - 1 64ビットプラットフォーム上で。</target>
        </trans-unit>
        <trans-unit id="e04fd04f5b90806f4bde8e56f9e1f7c424d03265" translate="yes" xml:space="preserve">
          <source>The hash field can be set to custom_hash_default, in which case the custom block is ignored during hash computation.</source>
          <target state="translated">ハッシュフィールドを custom_hash_default に設定することができ、その場合はハッシュ計算中にカスタムブロックは無視されます。</target>
        </trans-unit>
        <trans-unit id="d1bdc212a7c36c7cbf75250ae2e9cd081ccee7eb" translate="yes" xml:space="preserve">
          <source>The hash field contains a pointer to a C function that is called whenever OCaml&amp;rsquo;s generic hash operator (see module &lt;a href=&quot;libref/hashtbl&quot;&gt;Hashtbl&lt;/a&gt;) is applied to a custom block. The C function can return an arbitrary integer representing the hash value of the data contained in the given custom block. The hash value must be compatible with the compare function, in the sense that two structurally equal data (that is, two custom blocks for which compare returns 0) must have the same hash value.</source>
          <target state="translated">ハッシュフィールドには、OCamlの汎用ハッシュ演算子（モジュール&lt;a href=&quot;libref/hashtbl&quot;&gt;Hashtblを&lt;/a&gt;参照）がカスタムブロックに適用されるたびに呼び出されるC関数へのポインターが含まれています。C関数は、指定されたカスタムブロックに含まれるデータのハッシュ値を表す任意の整数を返すことができます。ハッシュ値は、2つの構造的に等しいデータ（つまり、compareが0を返す2つのカスタムブロック）が同じハッシュ値を持っている必要があるという意味で、compare関数と互換性がある必要があります。</target>
        </trans-unit>
        <trans-unit id="3784686c2bcba80c99df973ccfa187b6dc78d6d0" translate="yes" xml:space="preserve">
          <source>The hash function for floating-point numbers.</source>
          <target state="translated">浮動小数点数のハッシュ関数。</target>
        </trans-unit>
        <trans-unit id="afd0450a8b37538d5ad7af752cb7dc24545ce1f7" translate="yes" xml:space="preserve">
          <source>The header and the trailer sections are OCaml code that is copied as is into file grammar.ml. Both sections are optional. The header goes at the beginning of the output file; it usually contains open directives and auxiliary functions required by the semantic actions of the rules. The trailer goes at the end of the output file.</source>
          <target state="translated">ヘッダーとトレイラーのセクションは、そのまま grammar.ml ファイルにコピーされた OCaml コードです。両方のセクションはオプションです。ヘッダーは出力ファイルの先頭にあり、通常はオープンディレクティブとルールのセマンティックアクションに必要な補助関数を含んでいます。トレーラーは出力ファイルの最後に置かれます。</target>
        </trans-unit>
        <trans-unit id="7a49035078d6028cf4719edc4791d70f6385a46e" translate="yes" xml:space="preserve">
          <source>The header and trailer sections are arbitrary OCaml text enclosed in curly braces. Either or both can be omitted. If present, the header text is copied as is at the beginning of the output file and the trailer text at the end. Typically, the header section contains the open directives required by the actions, and possibly some auxiliary functions used in the actions.</source>
          <target state="translated">ヘッダー部とトレーラー部は、中括弧で囲まれた任意のOCamlテキストです。どちらか一方または両方を省略することができます。存在する場合は、出力ファイルの先頭にヘッダーテキストがそのままコピーされ、最後にトレーラテキストがコピーされます。通常、ヘッダセクションには、アクションで必要とされるオープンディレクティブと、アクションで使用されるいくつかの補助関数が含まれています。</target>
        </trans-unit>
        <trans-unit id="65fb09bbdabd2dfcd32a5c38a54fcbcdf3587281" translate="yes" xml:space="preserve">
          <source>The identifiers below are reserved as keywords, and cannot be employed otherwise:</source>
          <target state="translated">以下の識別子はキーワードとして予約されており、それ以外では使用できません。</target>
        </trans-unit>
        <trans-unit id="a3cdbac9abe023e77c0d5c1367f0671359c68a73" translate="yes" xml:space="preserve">
          <source>The implementation allows efficient sharing of large numerical arrays between OCaml code and C or Fortran numerical libraries.</source>
          <target state="translated">この実装により、OCamlコードとCやFortranの数値ライブラリとの間で、大きな数値配列を効率的に共有することができます。</target>
        </trans-unit>
        <trans-unit id="37db43ed15e53d861a8a0109f7b167f500eef59c" translate="yes" xml:space="preserve">
          <source>The implementation is checked against the interface file x.mli (if it exists) as described in the manual for ocamlc (chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;).</source>
          <target state="translated">ocamlcのマニュアル（第&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;章）で説明されているように、実装はインターフェイスファイルx.mli（存在する場合）に対してチェックされます。</target>
        </trans-unit>
        <trans-unit id="f0e6ef3c775c3e80317b4caf9ce4c73cd303a6bf" translate="yes" xml:space="preserve">
          <source>The include file &amp;lt;caml/bigarray.h&amp;gt; must be included in the C stub file. It declares the functions, constants and macros discussed below.</source>
          <target state="translated">インクルードファイル&amp;lt;caml / bigarray.h&amp;gt;は、Cスタブファイルにインクルードする必要があります。これは、以下で説明する関数、定数、およびマクロを宣言します。</target>
        </trans-unit>
        <trans-unit id="535f73d31ed740bfcbb9fa46992a794cf0b8e833" translate="yes" xml:space="preserve">
          <source>The information returned by the &lt;a href=&quot;unix#VALstat&quot;&gt;&lt;code&gt;Unix.stat&lt;/code&gt;&lt;/a&gt; calls.</source>
          <target state="translated">&lt;a href=&quot;unix#VALstat&quot;&gt; &lt;code&gt;Unix.stat&lt;/code&gt; &lt;/a&gt;呼び出しによって返される情報。</target>
        </trans-unit>
        <trans-unit id="0dab77f7c802e91039a17f7a96119c9dc7d99b16" translate="yes" xml:space="preserve">
          <source>The information returned by the &lt;a href=&quot;unixlabels#VALstat&quot;&gt;&lt;code&gt;UnixLabels.stat&lt;/code&gt;&lt;/a&gt; calls.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALstat&quot;&gt; &lt;code&gt;UnixLabels.stat&lt;/code&gt; &lt;/a&gt;呼び出しによって返される情報。</target>
        </trans-unit>
        <trans-unit id="432250b262611d097e3c2e7a360d5606d16533ba" translate="yes" xml:space="preserve">
          <source>The inheritance construct inherit&lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt; provides for inclusion of methods and instance variables from other class types. The instance variable and method types from &lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt; are added into the current class type.</source>
          <target state="translated">継承コンストラクトは&lt;a href=&quot;#class-body-type&quot;&gt;class-body-typeを&lt;/a&gt;継承し、他のクラスタイプのメソッドとインスタンス変数を含めることができます。&lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt;のインスタンス変数とメソッドタイプが現在のクラスタイプに追加されます。</target>
        </trans-unit>
        <trans-unit id="0a6f2342a82527fef9c1f1e57a822b49fe405407" translate="yes" xml:space="preserve">
          <source>The inheritance construct inherit&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; allows reusing methods and instance variables from other classes. The class expression &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; must evaluate to a class body. The instance variables, methods and initializers from this class body are added into the current class. The addition of a method will override any previously defined method of the same name.</source>
          <target state="translated">継承コンストラクトは&lt;a href=&quot;#class-expr&quot;&gt;class-exprを&lt;/a&gt;継承し、他のクラスのメソッドとインスタンス変数を再利用できます。クラス式&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;は、クラス本体に評価される必要があります。このクラス本体のインスタンス変数、メソッド、および初期化子が現在のクラスに追加されます。メソッドを追加すると、以前に定義した同じ名前のメソッドが上書きされます。</target>
        </trans-unit>
        <trans-unit id="e6a4c6ce7609b4fdb581947deed89b2c406dd7c0" translate="yes" xml:space="preserve">
          <source>The initial benefit value is then scaled by a factor that attempts to compensate for the fact that the current point in the code, if under some number of conditional branches, may be cold. (Flambda does not currently compute hot and cold paths.) The factor&amp;mdash;the estimated probability that the inliner really is on a &lt;em&gt;hot&lt;/em&gt; path&amp;mdash;is calculated as 1/(1 + f)&lt;sup&gt;d&lt;/sup&gt;, where f is set by -inline-branch-factor and d is the nesting depth of branches at the current point. As the inliner descends into more deeply-nested branches, the benefit of inlining thus lessens.</source>
          <target state="translated">次に、初期の利益値は、コード内の現在のポイントが、いくつかの条件付き分岐の下にある場合、コールドである可能性があるという事実を補正しようとする係数によってスケーリングされます。 （Flambda現在ホットとコールドの経路を計算しない。）インライナが実際にあること要因推定確率&lt;em&gt;ホット&lt;/em&gt;パスを-1 /（1 + F）として計算さ&lt;sup&gt;D&lt;/sup&gt; Fにより設定され、-inline-たブランチfactorおよびdは、現在のポイントでのブランチのネストの深さです。インライン化がより深くネストされたブランチに下降するにつれて、インライン化の利点は減少します。</target>
        </trans-unit>
        <trans-unit id="605d70d1e078307745dd48e9410e6df59a2d38ed" translate="yes" xml:space="preserve">
          <source>The initial size of the major heap (in words).</source>
          <target state="translated">メジャーヒープの初期サイズ(言葉で言うと)。</target>
        </trans-unit>
        <trans-unit id="d19155151a59efc551f6b49f7c9952f00e4278ab" translate="yes" xml:space="preserve">
          <source>The inliner is directed using attributes. For non-recursive functions (and one-step unrolling of recursive functions, although @unroll is more clear for this purpose) the following are supported:</source>
          <target state="translated">インライナーは属性を使って指示されます。非再帰的な関数(および再帰的な関数のワンステップアンロール、この目的のためには@unrollの方が明確ですが)については、以下がサポートされています。</target>
        </trans-unit>
        <trans-unit id="ec62c15f868750119abec49b24817b3f70272bf1" translate="yes" xml:space="preserve">
          <source>The inliner may discover a call site to a recursive function where something is known about the arguments: for example, they may be equal to some other variables currently in scope. In this situation it may be beneficial to &lt;em&gt;specialise&lt;/em&gt; the function to those arguments. This is done by copying the declaration of the function (and any others involved in any same mutually-recursive declaration) and noting the extra information about the arguments. The arguments augmented by this information are known as &lt;em&gt;specialised arguments&lt;/em&gt;. In order to try to ensure that specialisation is not performed uselessly, arguments are only specialised if it can be shown that they are &lt;em&gt;invariant&lt;/em&gt;: in other words, during the execution of the recursive function(s) themselves, the arguments never change.</source>
          <target state="translated">インライナーは、引数について何かがわかっている再帰関数への呼び出しサイトを検出する場合があります。たとえば、引数は現在スコープ内にある他の変数と等しい場合があります。この状況では、関数をこれらの引数に&lt;em&gt;特化&lt;/em&gt;することが有益な場合があります。これは、関数の宣言（および同じ相互再帰宣言に関係する他の宣言）をコピーし、引数に関する追加情報に注意することによって行われます。この情報によって拡張された引数は、&lt;em&gt;特殊な引数&lt;/em&gt;として知られて&lt;em&gt;います&lt;/em&gt;。特殊化が無駄に実行されないようにするために、引数は、&lt;em&gt;不変&lt;/em&gt;であることが示される場合にのみ特殊化されます。&lt;em&gt;&lt;/em&gt;：言い換えると、再帰関数自体の実行中、引数は変更されません。</target>
        </trans-unit>
        <trans-unit id="0c51b8b56bbf10eb40d95b1f8d06cf0bb2a8da17" translate="yes" xml:space="preserve">
          <source>The inliner will be able to consider inlining a call to a function in a first class module if it knows which particular function is going to be called. The presence of the first-class module record that wraps the set of functions in the module does not per se inhibit inlining.</source>
          <target state="translated">インライナは、どの特定の関数が呼び出されるかを知っていれば、ファースト・クラス・モジュール内の関数の呼び出しをインライン化することを考慮することができます。モジュール内の関数のセットをラップしているファーストクラスのモジュールレコードが存在しても、それ自体がインライン化を阻害するわけではありません。</target>
        </trans-unit>
        <trans-unit id="f97af2287565035553d926928c75a2ecba69b6f2" translate="yes" xml:space="preserve">
          <source>The inlining depth starts at zero and is increased by one every time the inliner descends into another function. It is then decreased by one every time the inliner leaves such function. If the depth exceeds the value set by -inline-max-depth then speculation stops. This parameter is intended as a general backstop for situations where the inlining threshold does not control the search sufficiently.</source>
          <target state="translated">インラインの深さはゼロから始まり、インライナーが別の関数に降りるたびに1ずつ増加します。その後、インライナーがそのような関数から出るたびに1ずつ減少します。深さが-inline-max-depthで設定された値を超えると、投機は停止します。このパラメータは、インラインのしきい値が検索を十分に制御できない場合の一般的なバックストップとして意図されています。</target>
        </trans-unit>
        <trans-unit id="1fef85946e0fcf5a71d076de458a459e1642b8d5" translate="yes" xml:space="preserve">
          <source>The input signature of the functor &lt;a href=&quot;hashtbl.make&quot;&gt;&lt;code&gt;Hashtbl.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ファンクター&lt;a href=&quot;hashtbl.make&quot;&gt; &lt;code&gt;Hashtbl.Make&lt;/code&gt; &lt;/a&gt;の入力署名。</target>
        </trans-unit>
        <trans-unit id="06d18381a5748615e440710ac855b1a56b9c2889" translate="yes" xml:space="preserve">
          <source>The input signature of the functor &lt;a href=&quot;hashtbl.makeseeded&quot;&gt;&lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ファンクター&lt;a href=&quot;hashtbl.makeseeded&quot;&gt; &lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt; &lt;/a&gt;の入力署名。</target>
        </trans-unit>
        <trans-unit id="95c572128ac8d5e1df8128cf0a673f5f91f32169" translate="yes" xml:space="preserve">
          <source>The inside of documentation comments (**&amp;hellip;*) consists of free-form text with optional formatting annotations, followed by optional &lt;em&gt;tags&lt;/em&gt; giving more specific information about parameters, version, authors, &amp;hellip; The tags are distinguished by a leading @ character. Thus, a documentation comment has the following shape:</source>
          <target state="translated">ドキュメントコメントの内部（**&amp;hellip;*）は、オプションのフォーマット注釈付きの自由形式のテキストと、それに続くパラメータ、バージョン、作成者などに関するより具体的な情報を提供するオプションの&lt;em&gt;タグ&lt;/em&gt;で構成されます。タグは先頭の@文字で区別されます。したがって、ドキュメントのコメントは次のような形になります。</target>
        </trans-unit>
        <trans-unit id="148efbe2c3192ef6b3c2f5ce513345372f5ff8d7" translate="yes" xml:space="preserve">
          <source>The instance variables of a class are visible only in the body of the methods defined in the same class or a class that inherits from the class defining the instance variables. The expression &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; evaluates to the value of the given instance variable. The expression &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; assigns the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; to the instance variable &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;, which must be mutable. The whole expression &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates to ().</source>
          <target state="translated">クラスのインスタンス変数は、同じクラスまたはインスタンス変数を定義するクラスから継承するクラスで定義されたメソッドの本体にのみ表示されます。式&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;は、指定されたインスタンス変数の値に評価されます。式&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; &amp;lt; &lt;a href=&quot;#expr&quot;&gt;-expr&lt;/a&gt;は、&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;の値をインスタンス変数&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;に割り当てます。インスタンス変数は可変である必要があります。式全体&lt;a href=&quot;names#inst-var-name&quot;&gt;研-VAR-名&lt;/a&gt;&amp;lt; - &lt;a href=&quot;#expr&quot;&gt;exprのを&lt;/a&gt;評価する（）へ。</target>
        </trans-unit>
        <trans-unit id="1983ba3b3cbd666c6b286b10b7424eaa8d46d8e4" translate="yes" xml:space="preserve">
          <source>The instrumentation that afl-fuzz requires is not generated by default, and must be explicitly enabled, by passing the -afl-instrument option to ocamlopt.</source>
          <target state="translated">afl-fuzzが必要とするインストルメンテーションはデフォルトでは生成されず、 ocamloptに-afl-instrumentオプションを渡すことで明示的に有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="9c38a45a391c534fde7023ac64ba050bd0bfc352" translate="yes" xml:space="preserve">
          <source>The instrumented runtime aims to provide insight into the runtime&amp;rsquo;s execution while maintaining a low overhead. However, this overhead may become more noticeable depending on how a program executes. The instrumented runtime currently puts a strong emphasis on tracing &lt;em&gt;garbage collection&lt;/em&gt; events. This means that programs with heavy garbage collection activity may be more susceptible to tracing induced performance penalties.</source>
          <target state="translated">インストルメント化されたランタイムは、低いオーバーヘッドを維持しながら、ランタイムの実行に関する洞察を提供することを目的としています。ただし、プログラムの実行方法によっては、このオーバーヘッドがより顕著になる場合があります。インストルメント化されたランタイムは現在、&lt;em&gt;ガベージコレクション&lt;/em&gt;イベントのトレースに重点を置いています。これは、ガベージコレクションアクティビティが多いプログラムは、トレースによって引き起こされるパフォーマンスペナルティの影響を受けやすい可能性があることを意味します。</target>
        </trans-unit>
        <trans-unit id="c752c8999051d42387c90e33a51fa248e92151ee" translate="yes" xml:space="preserve">
          <source>The instrumented runtime can also be used with the OCaml bytecode interpreter. This can be done by either using the -runtime-variant=i flag when linking the program with ocamlc, or by running the generated bytecode through ocamlruni:</source>
          <target state="translated">インストルメンテーションされたランタイムは、OCamlバイトコードインタプリタでも使用することができます。これは、プログラムを ocamlc とリンクする際に -runtime-variant=i フラグを使うか、生成されたバイトコードを ocamlruni で実行することで実現できます。</target>
        </trans-unit>
        <trans-unit id="bdd8c2054ca56fa61b478da767e7a87b2d4b4462" translate="yes" xml:space="preserve">
          <source>The instrumented runtime does not support the fork system call. A child process forked from an instrumented program will not be traced.</source>
          <target state="translated">インスツルメンテッド・ランタイムはフォーク・システム・コールをサポートしていません。インストルメントされたプログラムからフォークされた子プロセスはトレースされません。</target>
        </trans-unit>
        <trans-unit id="83cc8fe30284169270dc9bfd2599a1edfd3403c6" translate="yes" xml:space="preserve">
          <source>The integer in a &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;precision&lt;/code&gt; can also be specified as &lt;code&gt;*&lt;/code&gt;, in which case an extra integer argument is taken to specify the corresponding &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;precision&lt;/code&gt;. This integer argument precedes immediately the argument to print. For instance, &lt;code&gt;%.*f&lt;/code&gt; prints a &lt;code&gt;float&lt;/code&gt; with as many fractional digits as the value of the argument given before the float.</source>
          <target state="translated">&lt;code&gt;width&lt;/code&gt; または &lt;code&gt;precision&lt;/code&gt; の整数は &lt;code&gt;*&lt;/code&gt; として指定することもできます。その場合、対応する &lt;code&gt;width&lt;/code&gt; または &lt;code&gt;precision&lt;/code&gt; を指定するために追加の整数引数が取られます。この整数引数は、印刷する引数の直前にあります。たとえば、 &lt;code&gt;%.*f&lt;/code&gt; は、 &lt;code&gt;float&lt;/code&gt; の前に指定された引数の値と同じ数の小数桁を含むfloatを出力します。</target>
        </trans-unit>
        <trans-unit id="0b15dd3f5ba2129587d0969abe183388bad06fc4" translate="yes" xml:space="preserve">
          <source>The interface of a class can also be specified in a module signature, and used to restrict the inferred signature of a module.</source>
          <target state="translated">クラスのインターフェースは、モジュールのシグネチャで指定することもでき、モジュールの推論シグネチャを制限するために使用されます。</target>
        </trans-unit>
        <trans-unit id="105395de5f7d644b47550655e63b2ed02fcd3fdf" translate="yes" xml:space="preserve">
          <source>The keys and data of an ephemeron are said to be full if they point to a value, or empty if the value has never been set, has been unset, or was erased by the GC. In the function that accesses the keys or data these two states are represented by the &lt;code&gt;option&lt;/code&gt; type.</source>
          <target state="translated">エフェメロンのキーとデータは、値を指している場合はいっぱいであると言われ、値が設定されていない、設定されていない、またはGCによって消去されている場合は空であると言われます。キーまたはデータにアクセスする関数では、これら2つの状態は &lt;code&gt;option&lt;/code&gt; タイプで表されます。</target>
        </trans-unit>
        <trans-unit id="6634b8f0a482d759792ec8ca2ac4ce6773a03e6f" translate="yes" xml:space="preserve">
          <source>The keyword as in that type binds the type variable 'a to the object type &amp;lt; .. &amp;gt;. Therefore, Oo.copy takes an object with any methods (represented by the ellipsis), and returns an object of the same type. The type of Oo.copy is different from type &amp;lt; .. &amp;gt; -&amp;gt; &amp;lt; .. &amp;gt; as each ellipsis represents a different set of methods. Ellipsis actually behaves as a type variable.</source>
          <target state="translated">その型のようなキーワードは、型変数 'aをオブジェクト型&amp;lt;..&amp;gt;にバインドします。したがって、Oo.copyは、任意のメソッド（省略記号で表されます）を持つオブジェクトを受け取り、同じタイプのオブジェクトを返します。Oo.copyのタイプは、タイプ&amp;lt;..&amp;gt;-&amp;gt; &amp;lt;..&amp;gt;とは異なります。これは、各省略記号が異なるメソッドのセットを表すためです。省略記号は、実際には型変数として動作します。</target>
        </trans-unit>
        <trans-unit id="26d04af0b9de3d4d2a72eb74f835f5f6f6e937e3" translate="yes" xml:space="preserve">
          <source>The keywords - and -. can appear both as infix and prefix operators. When they appear as prefix operators, they are interpreted respectively as the functions (~-) and (~-.).</source>
          <target state="translated">キーワード-や -.は、接頭辞演算子としても接頭辞演算子としても出現します。接頭辞演算子として現れる場合は、それぞれ関数 (~-)と (~-.)</target>
        </trans-unit>
        <trans-unit id="63ad31bd653530cc49e2890ef110e7033521237a" translate="yes" xml:space="preserve">
          <source>The kind of array elements is one of the following constants:</source>
          <target state="translated">配列の要素の種類は以下の定数のいずれかです。</target>
        </trans-unit>
        <trans-unit id="ad467b38d8db4456aa825c50933b9ea245ee8d05" translate="yes" xml:space="preserve">
          <source>The language accepts external declarations with one or two flag strings in addition to the C function&amp;rsquo;s name. These flags are reserved for the implementation of the standard library.</source>
          <target state="translated">この言語は、C関数の名前に加えて1つまたは2つのフラグ文字列を含む外部宣言を受け入れます。これらのフラグは、標準ライブラリの実装用に予約されています。</target>
        </trans-unit>
        <trans-unit id="b8cdc3190f510239fa37ad383f7499bbcfcecc73" translate="yes" xml:space="preserve">
          <source>The largest positive finite value of type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">型 &lt;code&gt;float&lt;/code&gt; の最大の正の有限値。</target>
        </trans-unit>
        <trans-unit id="9b02fd4b3ae9e22d2aa52705a920bd39b960133e" translate="yes" xml:space="preserve">
          <source>The last two entries are valid for any n &amp;gt; 3.</source>
          <target state="translated">最後の2つのエントリは、n&amp;gt; 3の場合に有効です。</target>
        </trans-unit>
        <trans-unit id="411f2ed0253bd263770b7a506015d3b73acb28b7" translate="yes" xml:space="preserve">
          <source>The latter is slightly more efficient, as it allows clients of the module to call directly the C function instead of going through the corresponding OCaml function. On the other hand, it should not be used in library modules if they have side-effects at toplevel, as this direct call interferes with the linker&amp;rsquo;s algorithm for removing unused modules from libraries at link-time.</source>
          <target state="translated">後者は、モジュールのクライアントが対応するOCaml関数を経由する代わりに、C関数を直接呼び出すことができるため、わずかに効率的です。一方、トップレベルで副作用がある場合は、ライブラリモジュールで使用しないでください。この直接呼び出しは、リンク時にライブラリから未使用のモジュールを削除するリンカーのアルゴリズムに干渉します。</target>
        </trans-unit>
        <trans-unit id="e0d5230f60bcbec268122dc0a17e6710399bb6df" translate="yes" xml:space="preserve">
          <source>The lazy expression lazy_expr is forced only if the lazy_guard value yields true once computed. Indeed, a simple wildcard pattern (not lazy) never forces the lazy expression&amp;rsquo;s evaluation. However, a pattern with keyword lazy, even if it is wildcard, always forces the evaluation of the deferred computation.</source>
          <target state="translated">レイジー式lazy_exprは、lazy_guard値が計算されるとtrueになる場合にのみ強制されます。実際、単純なワイルドカードパターン（レイジーではない）がレイジー式の評価を強制することはありません。ただし、キーワードlazyを含むパターンは、ワイルドカードであっても、常に遅延計算の評価を強制します。</target>
        </trans-unit>
        <trans-unit id="cfa4f4b740be36ff7f795509d500d37f7af78f8b" translate="yes" xml:space="preserve">
          <source>The legacy bigarray library bundled with the compiler is a compatibility library with exactly the same interface as before, i.e. with map_file included.</source>
          <target state="translated">コンパイラにバンドルされているレガシー bigarray ライブラリは、以前と全く同じインターフェイスを持つ互換性のあるライブラリです。</target>
        </trans-unit>
        <trans-unit id="3c3cccf18cbaa6ce05baa77a874dea7a1d1ade41" translate="yes" xml:space="preserve">
          <source>The let and let rec constructs bind value names locally, as for the core language expressions.</source>
          <target state="translated">let および let rec は、コア言語の式と同様に、値の名前をローカルにバインドします。</target>
        </trans-unit>
        <trans-unit id="a230275b7985703b310f49dd04772a11ba7b81ae" translate="yes" xml:space="preserve">
          <source>The let and letrec constructs bind value names locally. The construct</source>
          <target state="translated">let および letrec は値の名前をローカルにバインドします。コンストラクタ</target>
        </trans-unit>
        <trans-unit id="4a7c897adf765ad531b54431abd748cbea11f170" translate="yes" xml:space="preserve">
          <source>The list is not empty.</source>
          <target state="translated">リストは空ではありません。</target>
        </trans-unit>
        <trans-unit id="e80da8bc0045d539fc55b1771c12707e1366c643" translate="yes" xml:space="preserve">
          <source>The list of options, each followed by the corresponding &lt;code&gt;doc&lt;/code&gt; string. Beware: options that have an empty &lt;code&gt;doc&lt;/code&gt; string will not be included in the list.</source>
          <target state="translated">オプションのリスト。それぞれに対応する &lt;code&gt;doc&lt;/code&gt; 文字列が続きます。注意：空の &lt;code&gt;doc&lt;/code&gt; 文字列を持つオプションはリストに含まれません。</target>
        </trans-unit>
        <trans-unit id="37a09eb76bbb9dc4b8871dbc8586b6f3b99c21f6" translate="yes" xml:space="preserve">
          <source>The list of possible syntactic class is as follows:</source>
          <target state="translated">可能な構文クラスのリストは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="7119efad1f349c18d670dab6d20261e060049541" translate="yes" xml:space="preserve">
          <source>The loadingmode variable controls how the program is executed.</source>
          <target state="translated">ローディングモード変数は、プログラムの実行方法を制御します。</target>
        </trans-unit>
        <trans-unit id="15f3b2280a23c9730e0ae9df7fd26ba354827556" translate="yes" xml:space="preserve">
          <source>The macros CAMLlocal1 to CAMLlocal5 declare and initialize one to five local variables of type value. The variable names are given as arguments to the macros. CAMLlocalN(x, n) declares and initializes a local variable of type value [n]. You can use several calls to these macros if you have more than 5 local variables.</source>
          <target state="translated">CAMLlocal1 から CAMLlocal5 マクロは、値型のローカル変数を 1 つから 5 つまで宣言し、初期化します。変数名はマクロの引数として与えられます。CAMLlocalN(x,n)は、値[n]型のローカル変数を宣言し、初期化します。5 個以上のローカル変数がある場合は、これらのマクロを複数回呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="1aaef768b1af4841714c0865edff6a7e10553a66" translate="yes" xml:space="preserve">
          <source>The macros CAMLreturn, CAMLreturn0, and CAMLreturnT are used to replace the C keyword return. Every occurrence of return x must be replaced by CAMLreturn (x) if x has type value, or CAMLreturnT (t, x) (where t is the type of x); every occurrence of return without argument must be replaced by CAMLreturn0. If your C function is a procedure (i.e. if it returns void), you must insert CAMLreturn0 at the end (to replace C&amp;rsquo;s implicit return).</source>
          <target state="translated">マクロCAMLreturn、CAMLreturn0、およびCAMLreturnTは、Cキーワードreturnを置き換えるために使用されます。 xにタイプ値がある場合はリターンxが出現するたびに、CAMLreturn（x）、またはCAMLreturnT（t、x）（tはxのタイプ）に置き換える必要があります。引数のないreturnが発生するたびに、CAMLreturn0に置き換える必要があります。 C関数がプロシージャである場合（つまり、voidを返す場合）、最後にCAMLreturn0を挿入する必要があります（Cの暗黙的な戻りを置き換えるため）。</target>
        </trans-unit>
        <trans-unit id="885b3218ec0a809028025c650e9f6b490326927a" translate="yes" xml:space="preserve">
          <source>The main advantage of dynamic linking is that it preserves the platform-independence of bytecode executables. That is, the bytecode executable contains no machine code, and can therefore be compiled on platform A and executed on other platforms B, C, &amp;hellip;, as long as the required shared libraries are available on all these platforms. In contrast, executables generated by ocamlc -custom run only on the platform on which they were created, because they embark a custom-tailored runtime system specific to that platform. In addition, dynamic linking results in smaller executables.</source>
          <target state="translated">ダイナミックリンクの主な利点は、バイトコード実行可能ファイルのプラットフォームに依存しないことです。つまり、バイトコード実行可能ファイルにはマシンコードが含まれていないため、必要な共有ライブラリがこれらすべてのプラットフォームで利用可能である限り、プラットフォームAでコンパイルし、他のプラットフォームB、Cなどで実行できます。対照的に、ocamlc -customによって生成された実行可能ファイルは、そのプラットフォームに固有のカスタム調整されたランタイムシステムを開始するため、作成されたプラットフォームでのみ実行されます。さらに、動的リンクにより、実行可能ファイルが小さくなります。</target>
        </trans-unit>
        <trans-unit id="31c9f9893f98dd3b2cb21409e3d29c4b1dc69b68" translate="yes" xml:space="preserve">
          <source>The main differences between 'Bigarrays' and standard OCaml arrays are as follows:</source>
          <target state="translated">Bigarrays」と標準のOCaml配列との主な違いは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="6fcf71e83dbbe5bf7b82af138897c5021410d4ef" translate="yes" xml:space="preserve">
          <source>The major GC speed is computed from this parameter. This is the memory that will be &quot;wasted&quot; because the GC does not immediately collect unreachable blocks. It is expressed as a percentage of the memory used for live data. The GC will work more (use more CPU time and collect blocks more eagerly) if &lt;code&gt;space_overhead&lt;/code&gt; is smaller. Default: 80.</source>
          <target state="translated">主要なGC速度は、このパラメーターから計算されます。これは、GCが到達不能なブロックをすぐに収集しないため、「浪費」されるメモリです。これは、ライブデータに使用されるメモリのパーセンテージとして表されます。 &lt;code&gt;space_overhead&lt;/code&gt; が小さい場合、GCはより多く機能します（より多くのCPU時間を使用し、ブロックをより熱心に収集します）。デフォルト：80。</target>
        </trans-unit>
        <trans-unit id="30da6783cb2d914f60ad876ac28283601a269030" translate="yes" xml:space="preserve">
          <source>The maximum depth of any speculative inlining search. See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt;.</source>
          <target state="translated">投機的なインライン検索の最大深度。セクション&lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="14b6f2abfdc332a11cef59acff883ca20f69b025" translate="yes" xml:space="preserve">
          <source>The maximum depth of any unrolling of recursive functions during any speculative inlining search. See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt;.</source>
          <target state="translated">投機的なインライン検索中の再帰関数の展開の最大深度。セクション&lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6537d7fb4312afbfc14faa7b11bce9479277bccc" translate="yes" xml:space="preserve">
          <source>The maximum formatting depth is the maximum number of pretty-printing boxes simultaneously open.</source>
          <target state="translated">書式の深さの最大値は、プリティ印刷のボックスを同時に開く最大数です。</target>
        </trans-unit>
        <trans-unit id="fa16112992d556366d6be6ead64cb5e2ddc5d021" translate="yes" xml:space="preserve">
          <source>The maximum size of the stack (in words). This is only relevant to the byte-code runtime, as the native code runtime uses the operating system's stack. Default: 1024k.</source>
          <target state="translated">スタックの最大サイズ(ワード)。ネイティブコードランタイムはオペレーティングシステムのスタックを使用するので、これはバイトコードランタイムにのみ関係します。デフォルトは1024kです。</target>
        </trans-unit>
        <trans-unit id="3dcda863ccacea505bd2a294ce1ed4f2df1932a4" translate="yes" xml:space="preserve">
          <source>The meaning of format string type parameters is as follows:</source>
          <target state="translated">フォーマット文字列型パラメータの意味は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="290889214c915b5911f3b92719bce41512c0c609" translate="yes" xml:space="preserve">
          <source>The memory layout of Bigarrays is entirely compatible with that of arrays in C and Fortran, allowing large arrays to be passed back and forth between OCaml code and C / Fortran code with no data copying at all.</source>
          <target state="translated">Bigarraysのメモリレイアウトは、CやFortranの配列と完全に互換性があり、データのコピーを一切行わずにOCamlコードとC/Fortranコードの間で大規模な配列を行き来することができます。</target>
        </trans-unit>
        <trans-unit id="db529abafebd1568315a8328ddaf314170689aa7" translate="yes" xml:space="preserve">
          <source>The memory management counters are returned in a &lt;code&gt;stat&lt;/code&gt; record.</source>
          <target state="translated">メモリ管理カウンタは、 &lt;code&gt;stat&lt;/code&gt; レコードで返されます。</target>
        </trans-unit>
        <trans-unit id="c4a3b03ef777eb26c6ae028dd5d106d607d702a8" translate="yes" xml:space="preserve">
          <source>The metadata file is available in the OCaml installation. Its location can be obtained using the following command:</source>
          <target state="translated">メタデータファイルは、OCamlのインストールで利用可能です。その場所は、以下のコマンドを使用して取得することができます。</target>
        </trans-unit>
        <trans-unit id="e072a2bbaafe77d3313822b37614800d154b59ef" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; provides formatted input functions or &lt;em&gt;scanners&lt;/em&gt;.</source>
          <target state="translated">モジュール&lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt;は、フォーマットされた入力関数または&lt;em&gt;スキャナーを&lt;/em&gt;提供し&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="98dc8a81338816e727b183ae8835ac70814be748" translate="yes" xml:space="preserve">
          <source>The module type expression functor(&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;)-&amp;gt;&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is the type of functors (functions from modules to modules) that take as argument a module of type &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and return as result a module of type &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. The module type &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; can use the name &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; to refer to type components of the actual argument of the functor. If the type &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; does not depend on type components of &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;, the module type expression can be simplified with the alternative short syntax &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; . No restrictions are placed on the type of the functor argument; in particular, a functor may take another functor as argument (&amp;ldquo;higher-order&amp;rdquo; functor).</source>
          <target state="translated">モジュールタイプ式functor（&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;：&lt;a href=&quot;#module-type&quot;&gt;module-type &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;）-&amp;gt; &lt;a href=&quot;#module-type&quot;&gt;module-type &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;は、タイプ&lt;a href=&quot;#module-type&quot;&gt;module-type &lt;/a&gt;&lt;sub&gt;1の&lt;/sub&gt;モジュールを引数として取り、結果として返すファンクターのタイプ（モジュールからモジュールへの関数）です。タイプ&lt;a href=&quot;#module-type&quot;&gt;モジュールのモジュール-タイプ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;。モジュールタイプの&lt;a href=&quot;#module-type&quot;&gt;モジュール型&lt;/a&gt;&lt;sub&gt;2は、&lt;/sub&gt;名前に使用できる&lt;a href=&quot;names#module-name&quot;&gt;モジュール名を&lt;/a&gt;ファンクタの実引数の構成要素を入力するために参照します。タイプの場合は&lt;a href=&quot;#module-type&quot;&gt;モジュール型&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;のタイプのコンポーネントに依存しない&lt;a href=&quot;names#module-name&quot;&gt;モジュール名&lt;/a&gt;、モジュール型の式は、代替短い構文で単純化することができます&lt;a href=&quot;#module-type&quot;&gt;モジュールタイプ&lt;/a&gt;&lt;sub&gt;1-&lt;/sub&gt; &amp;gt;&lt;a href=&quot;#module-type&quot;&gt;モジュールタイプ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;。ファンクター引数のタイプに制限はありません。特に、ファンクターは別のファンクターを引数として取る場合があります（「高階」ファンクター）。</target>
        </trans-unit>
        <trans-unit id="19e87897038acb2ea0b22d40eb32fcf01d0bb4bf" translate="yes" xml:space="preserve">
          <source>The most common usage of variant types is to describe recursive data structures. Consider for example the type of binary trees:</source>
          <target state="translated">変形型の最も一般的な使用法は、再帰的なデータ構造を記述することです。例えば、バイナリツリーの型を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="969c39463cdd83094435d7ff5442eba358f5bbab" translate="yes" xml:space="preserve">
          <source>The most user-friendly way to use the debugger is to run it under Emacs. See the file emacs/README in the distribution for information on how to load the Emacs Lisp files for OCaml support.</source>
          <target state="translated">デバッガを使用する最もユーザーフレンドリーな方法は、Emacs で実行することです。OCaml サポートのために Emacs Lisp ファイルをロードする方法については、配布物の emacs/README ファイルを参照してください。</target>
        </trans-unit>
        <trans-unit id="78aad986fb7a4eb2c56f1239f1a0ea9f7c757987" translate="yes" xml:space="preserve">
          <source>The motivation is that, by letting &amp;lsquo;ocamlopt&amp;lsquo; deal with boxing, it can often decide to suppress it entirely.</source>
          <target state="translated">その動機は、「ocamlopt」にボクシングを処理させることで、ボクシングを完全に抑制することを決定できる場合が多いということです。</target>
        </trans-unit>
        <trans-unit id="e080b5bf8fc37b589b95288dd439c400c34b427b" translate="yes" xml:space="preserve">
          <source>The multiplier is k, M, or G, for multiplication by 2&lt;sup&gt;10&lt;/sup&gt;, 2&lt;sup&gt;20&lt;/sup&gt;, and 2&lt;sup&gt;30&lt;/sup&gt; respectively.</source>
          <target state="translated">乗算器は、2乗算のため、K、M、またはGであり、&lt;sup&gt;10&lt;/sup&gt;、2 &lt;sup&gt;20&lt;/sup&gt;、2 &lt;sup&gt;30&lt;/sup&gt;、それぞれ。</target>
        </trans-unit>
        <trans-unit id="e5001d83b2b93aa689b354ed2086458f2935a047" translate="yes" xml:space="preserve">
          <source>The name of the file containing the executable currently running.</source>
          <target state="translated">現在実行中の実行ファイルを含むファイル名。</target>
        </trans-unit>
        <trans-unit id="59eca0c39d17cb0f2108d6d77b193b119b04559b" translate="yes" xml:space="preserve">
          <source>The name of the file containing the executable currently running. This name may be absolute or relative to the current directory, depending on the platform and whether the program was compiled to bytecode or a native executable.</source>
          <target state="translated">現在実行中の実行ファイルを含むファイル名。この名前は、プラットフォームと、プログラムがバイトコードにコンパイルされたものかネイティブの実行ファイルかに応じて、カレントディレクトリからの絶対値または相対値になります。</target>
        </trans-unit>
        <trans-unit id="cf0030b90670a18e3de17304172d5e4c928be425" translate="yes" xml:space="preserve">
          <source>The name of the initial temporary directory: Under Unix, the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, or &quot;/tmp&quot; if the variable is not set.</source>
          <target state="translated">初期一時ディレクトリの名前：Unixでは、 &lt;code&gt;TMPDIR&lt;/code&gt; 環境変数の値。変数が設定されていない場合は「/ tmp」。</target>
        </trans-unit>
        <trans-unit id="7c8b8d9700396ab187abf8b0e62dcd1c6f319473" translate="yes" xml:space="preserve">
          <source>The name of the initial temporary directory: Under Unix, the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, or &quot;/tmp&quot; if the variable is not set. Under Windows, the value of the &lt;code&gt;TEMP&lt;/code&gt; environment variable, or &quot;.&quot; if the variable is not set.</source>
          <target state="translated">初期一時ディレクトリの名前：Unixでは、 &lt;code&gt;TMPDIR&lt;/code&gt; 環境変数の値。変数が設定されていない場合は「/ tmp」。Windowsでは、 &lt;code&gt;TEMP&lt;/code&gt; 環境変数の値または「。」変数が設定されていない場合。</target>
        </trans-unit>
        <trans-unit id="3c9a52823f32936b8fa5faaa814adee980e5c3ce" translate="yes" xml:space="preserve">
          <source>The name of the temporary directory: Under Unix, the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, or &quot;/tmp&quot; if the variable is not set.</source>
          <target state="translated">一時ディレクトリの名前：Unixでは、 &lt;code&gt;TMPDIR&lt;/code&gt; 環境変数の値。変数が設定されていない場合は「/ tmp」。</target>
        </trans-unit>
        <trans-unit id="bd4c9b92bb5cafc665608d7e7c71ee74b72bd3e4" translate="yes" xml:space="preserve">
          <source>The name of the temporary directory: Under Unix, the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, or &quot;/tmp&quot; if the variable is not set. Under Windows, the value of the &lt;code&gt;TEMP&lt;/code&gt; environment variable, or &quot;.&quot; if the variable is not set. The temporary directory can be changed with &lt;a href=&quot;filename#VALset_temp_dir_name&quot;&gt;&lt;code&gt;Filename.set_temp_dir_name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一時ディレクトリの名前：Unixでは、 &lt;code&gt;TMPDIR&lt;/code&gt; 環境変数の値。変数が設定されていない場合は「/ tmp」。 Windowsでは、 &lt;code&gt;TEMP&lt;/code&gt; 環境変数の値または「。」変数が設定されていない場合。一時ディレクトリは、&lt;a href=&quot;filename#VALset_temp_dir_name&quot;&gt; &lt;code&gt;Filename.set_temp_dir_name&lt;/code&gt; &lt;/a&gt;で変更できます。</target>
        </trans-unit>
        <trans-unit id="80a92c6fec8ac40ba4e0c4025b59dde0b751953a" translate="yes" xml:space="preserve">
          <source>The named file could not be found in the current directory, nor in the directories of the search path.</source>
          <target state="translated">指定されたファイルは、カレントディレクトリにも検索パスのディレクトリにも見つかりませんでした。</target>
        </trans-unit>
        <trans-unit id="952b3090c265f73e61fb891aab443a8262a5704d" translate="yes" xml:space="preserve">
          <source>The named file could not be found in the current directory, nor in the directories of the search path. The filename is either a compiled interface file (.cmi file), or a compiled bytecode file (.cmo file). If filename has the format mod.cmi, this means you are trying to compile a file that references identifiers from module mod, but you have not yet compiled an interface for module mod. Fix: compile mod.mli or mod.ml first, to create the compiled interface mod.cmi.</source>
          <target state="translated">指定されたファイルは、カレント・ディレクトリにも検索パスのディレクトリにも見つかりませんでした。ファイル名は、コンパイルされたインターフェイスファイル (.cmi ファイル)か、コンパイルされたバイトコードファイル (.cmo ファイル)のいずれかです。ファイル名に mod.cmi という形式がある場合、モジュール mod の識別子を参照するファイルをコンパイルしようとしていることを意味しますが、モジュール mod のためのインターフェイスをまだコンパイルしていないことを意味します。修正方法:コンパイルされたインターフェイス mod.cmi を作成するために、まず mod.mli か mod.ml をコンパイルしてください。</target>
        </trans-unit>
        <trans-unit id="a2f02d60d1e116f8243f8229b3fd568a95c8a809" translate="yes" xml:space="preserve">
          <source>The names of the entry points must be valid identifiers for OCaml values (starting with a lowercase letter). Similarly, the arguments arg&lt;sub&gt;1&lt;/sub&gt;&amp;hellip; arg&lt;sub&gt;n&lt;/sub&gt; must be valid identifiers for OCaml. Each entry point becomes an OCaml function that takes n+1 arguments, the extra implicit last argument being of type Lexing.lexbuf. Characters are read from the Lexing.lexbuf argument and matched against the regular expressions provided in the rule, until a prefix of the input matches one of the rule. The corresponding action is then evaluated and returned as the result of the function.</source>
          <target state="translated">エントリポイントの名前は、OCaml値の有効な識別子（小文字で始まる）である必要があります。同様に、引数は引数&lt;sub&gt;1&lt;/sub&gt; ...引数&lt;sub&gt;nは&lt;/sub&gt;OCamlのための有効な識別子でなければなりません。各エントリポイントは、n + 1個の引数を取るOCaml関数になり、余分な暗黙の最後の引数はタイプLexing.lexbufです。文字はLexing.lexbuf引数から読み取られ、入力のプレフィックスがルールの1つと一致するまで、ルールで提供される正規表現と照合されます。次に、対応するアクションが評価され、関数の結果として返されます。</target>
        </trans-unit>
        <trans-unit id="a5ca4780e331ea88692f3bab8f908b1e857d3545" translate="yes" xml:space="preserve">
          <source>The names of the two C functions must be given in the primitive declaration, as follows:</source>
          <target state="translated">2つのC言語の関数の名前は、以下のようにプリミティブ宣言で与えなければなりません。</target>
        </trans-unit>
        <trans-unit id="2af38c50738eb4e1ac67f27fb83521c12f9da713" translate="yes" xml:space="preserve">
          <source>The native C character type under Windows is WCHAR, two bytes wide, while under Unix it is char, one byte wide. A type char_os is defined in &amp;lt;caml/misc.h&amp;gt; that stands for the concrete C character type of each platform. Strings in the platform encoding are of type char_os *.</source>
          <target state="translated">WindowsでのネイティブC文字タイプは2バイト幅のWCHARですが、Unixでは1バイト幅のcharです。タイプchar_osは、各プラットフォームの具体的なC文字タイプを表す&amp;lt;caml /misc.h&amp;gt;で定義されています。プラットフォームエンコーディングの文字列は、char_os *型です。</target>
        </trans-unit>
        <trans-unit id="376053bbccd9cdcd8890b3fbdf88ead49637bae1" translate="yes" xml:space="preserve">
          <source>The native integer -1.</source>
          <target state="translated">ネイティブ整数-1。</target>
        </trans-unit>
        <trans-unit id="9ee1fc5518ff6fbf2992ed7e1ec40186e53f6653" translate="yes" xml:space="preserve">
          <source>The native integer 0.</source>
          <target state="translated">ネイティブ整数の0。</target>
        </trans-unit>
        <trans-unit id="4bcc40875771e327d2f0e7c0fa203d846f93e6b4" translate="yes" xml:space="preserve">
          <source>The native integer 1.</source>
          <target state="translated">ネイティブの整数 1.</target>
        </trans-unit>
        <trans-unit id="5c20da3e1fe2cd472edcbc03735391872edbfb80" translate="yes" xml:space="preserve">
          <source>The native-code compiler is only available on certain platforms. It produces code that runs faster than the bytecode produced by ocamlc, at the cost of increased compilation time and executable code size. Compatibility with the bytecode compiler is extremely high: the same source code should run identically when compiled with ocamlc and ocamlopt.</source>
          <target state="translated">ネイティブコードコンパイラは特定のプラットフォームでのみ利用可能です。ocamlcで生成されたバイトコードよりも高速に動作するコードを生成しますが、コンパイル時間と実行可能なコードサイズの増加を犠牲にしています。バイトコードコンパイラとの互換性は非常に高くなっています:同じソースコードを ocamlc と ocamlopt でコンパイルしても同じように動作します。</target>
        </trans-unit>
        <trans-unit id="5e5e7155dfdf15208a1cbe9f526ab06c992a1a3c" translate="yes" xml:space="preserve">
          <source>The native-code compiler ocamlopt also supports the -output-obj option, causing it to output a C object file or a shared library containing the native code for all OCaml modules on the command-line, as well as the OCaml startup code. Initialization is performed by calling caml_startup (or caml_startup_exn) as in the case of the bytecode compiler.</source>
          <target state="translated">ネイティブコードコンパイラ ocamlopt は -output-obj オプションもサポートしており、コマンドライン上のすべての OCaml モジュールのネイティブコードと OCaml スタートアップコードを含む C オブジェクトファイルまたは共有ライブラリを出力します。初期化はバイトコードコンパイラの場合と同様に caml_startup (または caml_startup_exn)を呼び出すことで行われます。</target>
        </trans-unit>
        <trans-unit id="36be14bc239e78c132c193d0ff0e16beb22b0661" translate="yes" xml:space="preserve">
          <source>The native-code compiler performs a number of optimizations that the bytecode compiler does not perform, especially when the Flambda optimizer is active. In particular, the native-code compiler identifies and eliminates &amp;ldquo;dead code&amp;rdquo;, i.e. computations that do not contribute to the results of the program. For example,</source>
          <target state="translated">ネイティブコードコンパイラは、特にFlambdaオプティマイザがアクティブな場合、バイトコードコンパイラが実行しない多くの最適化を実行します。特に、ネイティブコードコンパイラは、「デッドコード」、つまりプログラムの結果に寄与しない計算を識別して排除します。例えば、</target>
        </trans-unit>
        <trans-unit id="f90676a471e21697a3a109feb2073705f4c086a3" translate="yes" xml:space="preserve">
          <source>The next allocation can trigger a garbage collection. The garbage collector assumes that all structured blocks contain well-formed values. Newly created blocks contain random data, which generally do not represent well-formed values.</source>
          <target state="translated">次の割り当ては、ガベージコレクションをトリガすることができます。ガベージコレクタは、すべての構造化されたブロックが整形値を含むことを前提としています。新しく作成されたブロックにはランダムなデータが含まれており、一般的には整形値を表すことはありません。</target>
        </trans-unit>
        <trans-unit id="33f94342d426b6ca7b5a6cd5848192a5418df90c" translate="yes" xml:space="preserve">
          <source>The next step is to compile and link the program with the instrumented runtime. This can be done by using the -runtime-variant flag:</source>
          <target state="translated">次のステップは、プログラムをコンパイルして、インストルメントされたランタイムとリンクさせることです。これは -run-time-variant フラグを使うことで行うことができます。</target>
        </trans-unit>
        <trans-unit id="bbe1c650255dd39febc517d8d6e9ecf4a27a4e50" translate="yes" xml:space="preserve">
          <source>The notion of input channel for the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module: those channels provide all the machinery necessary to read from any source of characters, including a &lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt;&lt;code&gt;in_channel&lt;/code&gt;&lt;/a&gt; value.</source>
          <target state="translated">&lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt;モジュールの入力チャネルの概念：これらのチャネルは、&lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt; &lt;code&gt;in_channel&lt;/code&gt; &lt;/a&gt;値を含む、任意の文字ソースから読み取るために必要なすべての機構を提供します。</target>
        </trans-unit>
        <trans-unit id="16542651eb8af79575740dab6d97e5baeedd8889" translate="yes" xml:space="preserve">
          <source>The notion of input channel for the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module: those channels provide all the machinery necessary to read from any source of characters, including a &lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt;&lt;code&gt;in_channel&lt;/code&gt;&lt;/a&gt; value. A Scanf.Scanning.in_channel value is also called a</source>
          <target state="translated">&lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt;モジュールの入力チャネルの概念：これらのチャネルは、&lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt; &lt;code&gt;in_channel&lt;/code&gt; &lt;/a&gt;値を含む、任意の文字ソースから読み取るために必要なすべての機構を提供します。Scanf.Scanning.in_channel値は、</target>
        </trans-unit>
        <trans-unit id="dc0369bec5d64b7e5ca44539b36eca9c14402a44" translate="yes" xml:space="preserve">
          <source>The num library implements integer arithmetic and rational arithmetic in arbitrary precision. It was split off the core OCaml distribution starting with the 4.06.0 release, and can now be found at &lt;a href=&quot;https://github.com/ocaml/num&quot;&gt;https://github.com/ocaml/num&lt;/a&gt;.</source>
          <target state="translated">numライブラリは、整数演算と有理演算を任意の精度で実装します。4.06.0リリース以降、コアOCamlディストリビューションから分割され、&lt;a href=&quot;https://github.com/ocaml/num&quot;&gt;https：//github.com/ocaml/numにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0976e8b95aee4f6b6b94a903578443416a16fd1d" translate="yes" xml:space="preserve">
          <source>The number of samples in this block (&amp;gt;= 1).</source>
          <target state="translated">このブロック内のサンプル数（&amp;gt; = 1）。</target>
        </trans-unit>
        <trans-unit id="80c5921664757a5de49c34516dd5a9044bf527fa" translate="yes" xml:space="preserve">
          <source>The object type c0 is an abbreviation for &amp;lt;m : 'a; n : int&amp;gt; as 'a. Consider now the type declaration:</source>
          <target state="translated">オブジェクトタイプc0は、&amp;lt;m： 'a;の略語です。n：int&amp;gt; as'a。ここで型宣言について考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="c4798644a1b3b83b3464a016d6b7ad72bf5f4632" translate="yes" xml:space="preserve">
          <source>The object type c1 is an abbreviation for the type &amp;lt;m : 'a&amp;gt; as 'a. The coercion from an object of type c0 to an object of type c1 is correct:</source>
          <target state="translated">オブジェクトタイプc1は、タイプ&amp;lt;m： 'a&amp;gt;の略語である' aです。タイプc0のオブジェクトからタイプc1のオブジェクトへの強制は正しいです：</target>
        </trans-unit>
        <trans-unit id="4e56b5bcc7c0be28d1a5ad641e4581f9a06b6925" translate="yes" xml:space="preserve">
          <source>The ocaml.alert or alert attribute serves two purposes: (i) to mark component with an alert to be triggered when the component is referenced, and (ii) to control which alert names are enabled. In the first form, the attribute takes an identifier possibly followed by a message. Here is an example of a value declaration marked with an alert:</source>
          <target state="translated">ocaml.alertまたはalert属性は2つの目的を持っています。(i)コンポーネントが参照されたときにアラートが発生するようにコンポーネントをマークすること、(ii)どのアラート名が有効になるかを制御することです。最初の形式では、属性は識別子を取り、その後にメッセージが続く可能性があります。ここでは、アラートでマークされた値宣言の例を示します。</target>
        </trans-unit>
        <trans-unit id="663c4b2feb0ff61316e473a7d7058b8a8ac77602" translate="yes" xml:space="preserve">
          <source>The ocamlc command has a command-line interface similar to the one of most C compilers. It accepts several types of arguments and processes them sequentially, after all options have been processed:</source>
          <target state="translated">ocamlcコマンドはほとんどのCコンパイラに似たコマンドラインインタフェースを持っています。いくつかのタイプの引数を受け取り、すべてのオプションが処理された後に順次処理を行います。</target>
        </trans-unit>
        <trans-unit id="8ccd15521b1aa9660fdf126df14cf7897ed7444c" translate="yes" xml:space="preserve">
          <source>The ocamlcp and ocamloptp commands also accept all the options of the corresponding ocamlc or ocamlopt compiler, except the -pp (preprocessing) option.</source>
          <target state="translated">ocamlcp と ocamloptp コマンドは,-pp (前処理)オプションを除いて,対応する ocamlc または ocamlopt コンパイラのすべてのオプションを受け入れます.</target>
        </trans-unit>
        <trans-unit id="fa91a0c172cde52b6822b93be7514538cd75d072" translate="yes" xml:space="preserve">
          <source>The ocamldep command scans a set of OCaml source files (.ml and .mli files) for references to external compilation units, and outputs dependency lines in a format suitable for the make utility. This ensures that make will compile the source files in the correct order, and recompile those files that need to when a source file is modified.</source>
          <target state="translated">ocamldepコマンドは、一連のOCamlソースファイル(.mlと.mliファイル)をスキャンして外部のコンパイルユニットへの参照を探し、makeユーティリティに適した形式で依存行を出力します。これにより、make はソースファイルを正しい順序でコンパイルし、ソースファイルが変更されたときに必要なファイルを再コンパイルします。</target>
        </trans-unit>
        <trans-unit id="5bc0cf38a6832c2cb08c4085b324377b241b03c6" translate="yes" xml:space="preserve">
          <source>The ocamllex command produces a lexical analyzer from a set of regular expressions with attached semantic actions, in the style of lex. Assuming the input file is lexer.mll, executing</source>
          <target state="translated">ocamllexコマンドは、意味的なアクションを付加した正規表現のセットから、 lexのスタイルで語彙解析器を生成します。入力ファイルが lexer.mll であると仮定して</target>
        </trans-unit>
        <trans-unit id="785a09dfb0b7bb6413c4e50f2cabd1b69c63c6b4" translate="yes" xml:space="preserve">
          <source>The ocamlmklib command facilitates the construction of libraries containing both OCaml code and C code, and usable both in static linking and dynamic linking modes. This command is available under Windows since Objective Caml 3.11 and under other operating systems since Objective Caml 3.03.</source>
          <target state="translated">ocamlmklibコマンドは、OCamlコードとCコードの両方を含むライブラリの構築を容易にし、スタティックリンクとダイナミックリンクの両方のモードで使用できます。このコマンドは、WindowsではObjective Caml 3.11以降、その他のオペレーティングシステムではObjective Caml 3.03以降で利用できます。</target>
        </trans-unit>
        <trans-unit id="37782ee3b2232fe93bbe77ca370d4160e2021dd2" translate="yes" xml:space="preserve">
          <source>The ocamlmklib command takes three kinds of arguments:</source>
          <target state="translated">ocamlmklibコマンドは3種類の引数を取ります。</target>
        </trans-unit>
        <trans-unit id="68dd5d1772fdc70b18042e2faf73bb6d263b83ef" translate="yes" xml:space="preserve">
          <source>The ocamlmktop command builds OCaml toplevels that contain user code preloaded at start-up.</source>
          <target state="translated">ocamlmktopコマンドは、起動時にプリロードされたユーザコードを含むOCaml toplevelsをビルドします。</target>
        </trans-unit>
        <trans-unit id="6831997e14580584458639904bb3e8b4303221cf" translate="yes" xml:space="preserve">
          <source>The ocamlmktop command takes as argument a set of .cmo and .cma files, and links them with the object files that implement the OCaml toplevel. The typical use is:</source>
          <target state="translated">ocamlmktopコマンドは引数に.cmoと.cmaファイルのセットを取り、それらをOCaml toplevelを実装したオブジェクトファイルとリンクします。典型的な使用法は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="ab3cce8e0848dae6978b901dc63aa4ea6c79e945" translate="yes" xml:space="preserve">
          <source>The ocamlopt command has a command-line interface very close to that of ocamlc. It accepts the same types of arguments, and processes them sequentially, after all options have been processed:</source>
          <target state="translated">ocamlopt コマンドは ocamlc に非常に近いコマンドラインインタフェースを持っています。同じタイプの引数を受け付け、すべてのオプションが処理された後に順次処理します。</target>
        </trans-unit>
        <trans-unit id="9f43adb44cad300b255a2ab339a13959b026d322" translate="yes" xml:space="preserve">
          <source>The ocamlprof command produces a source listing of the program modules where execution counts have been inserted as comments. For instance,</source>
          <target state="translated">ocamlprofコマンドは、実行回数がコメントとして挿入されたプログラムモジュールのソースリストを生成します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="b7ea8af81e418a1edb4e459f8a9a2eab6da15605" translate="yes" xml:space="preserve">
          <source>The ocamlrun command comprises three main parts: the bytecode interpreter, that actually executes bytecode files; the memory allocator and garbage collector; and a set of C functions that implement primitive operations such as input/output.</source>
          <target state="translated">ocamlrunコマンドは,バイトコードファイルを実際に実行するバイトコードインタプリタ,メモリアロケータとガベージコレクタ,入出力などのプリミティブな操作を実装するC関数のセットの3つの主要な部分から構成されています.</target>
        </trans-unit>
        <trans-unit id="ba3256951b99c851dcb6d71a9ee49e018d24d2bb" translate="yes" xml:space="preserve">
          <source>The ocamlrun command executes bytecode files produced by the linking phase of the ocamlc command.</source>
          <target state="translated">ocamlrunコマンドは、ocamlcコマンドのリンクフェーズで生成されたバイトコードファイルを実行します。</target>
        </trans-unit>
        <trans-unit id="9e1235caedb5ccfed4248d72a0e38e7bda7a4c82" translate="yes" xml:space="preserve">
          <source>The ocamlrun command searches shared libraries in the following directories, in the order indicated:</source>
          <target state="translated">ocamlrunコマンドは、以下のディレクトリの共有ライブラリを指定された順番で検索します。</target>
        </trans-unit>
        <trans-unit id="45cf460ec88bc5d152326aaf5ae83eb8df678857" translate="yes" xml:space="preserve">
          <source>The ocamlyacc command produces a parser from a context-free grammar specification with attached semantic actions, in the style of yacc. Assuming the input file is grammar.mly, executing</source>
          <target state="translated">ocamlyaccコマンドは、yaccのスタイルで、意味的なアクションを付加したコンテキストフリーの文法指定からパーサを生成します。入力ファイルが grammar.mly であると仮定して</target>
        </trans-unit>
        <trans-unit id="028fe9d310df119de0ec84424c8896799e9e2f82" translate="yes" xml:space="preserve">
          <source>The ocamlyacc command recognizes the following options:</source>
          <target state="translated">ocamlyaccコマンドは以下のオプションを認識します。</target>
        </trans-unit>
        <trans-unit id="2c12a611ec5444a4dcbe094626c7878666edcceb" translate="yes" xml:space="preserve">
          <source>The only case we have reasonable confidence is safe is if the produced &lt;code&gt;bytes&lt;/code&gt; is shared -- used as an immutable byte sequence. This is possibly useful for incremental migration of low-level programs that manipulate immutable sequences of bytes (for example &lt;a href=&quot;marshal#VALfrom_bytes&quot;&gt;&lt;code&gt;Marshal.from_bytes&lt;/code&gt;&lt;/a&gt;) and previously used the &lt;code&gt;string&lt;/code&gt; type for this purpose.</source>
          <target state="translated">生成された &lt;code&gt;bytes&lt;/code&gt; が共有されている場合、つまり不変のバイトシーケンスとして使用されている場合は、安全であると合理的に確信できる唯一のケースです。これは、バイトの不変シーケンス（&lt;a href=&quot;marshal#VALfrom_bytes&quot;&gt; &lt;code&gt;Marshal.from_bytes&lt;/code&gt; など&lt;/a&gt;）を操作し、以前はこの目的で &lt;code&gt;string&lt;/code&gt; 型を使用していた低レベルプログラムの増分移行に役立つ可能性があります。</target>
        </trans-unit>
        <trans-unit id="9599505a809ca09e4fab73b6902744c16bc81fdd" translate="yes" xml:space="preserve">
          <source>The only case where that transformation is not possible is if a given function call may raise distinct exceptions with the same constructor but different string values. In this case, you will have to check for specific string values. This is dangerous API design and it should be discouraged: it&amp;rsquo;s better to define more precise exception constructors than store useful information in strings.</source>
          <target state="translated">その変換が不可能な唯一のケースは、特定の関数呼び出しが同じコンストラクターで異なる文字列値で別個の例外を発生させる可能性がある場合です。この場合、特定の文字列値を確認する必要があります。これは危険なAPI設計であり、推奨されません。有用な情報を文字列に格納するよりも、より正確な例外コンストラクターを定義することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="2cedfa4c8d920a307290831222d9cbd51790caf6" translate="yes" xml:space="preserve">
          <source>The only difference with the let construct described above is that the bindings of names to values performed by the pattern-matching are considered already performed when the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are evaluated. That is, the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; can reference identifiers that are bound by one of the patterns &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, and expect them to have the same value as in &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, the body of the letrec construct.</source>
          <target state="translated">構築物は、上記のletとの唯一の違いは、値の名前のバインディングは、パターンマッチングによって行うことである式は場合既に実行と考えられる&lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;に&lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;n個&lt;/sub&gt;に評価されます。すなわち、式は、である&lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;に&lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt;パターンの一つにより結合されている識別子を参照することができる&lt;a href=&quot;patterns#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、...、&lt;a href=&quot;patterns#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt;、それらはと同じ値を持つことを期待&lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;、letrecコンストラクトの本体。</target>
        </trans-unit>
        <trans-unit id="774d89b5de623ddb891076997b98ef614701dff8" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;flags&lt;/code&gt; are:</source>
          <target state="translated">オプションの &lt;code&gt;flags&lt;/code&gt; は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="8e89406e3e1bdda8e82d077bce710e73570e29fe" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;precision&lt;/code&gt; is a dot &lt;code&gt;.&lt;/code&gt; followed by an integer indicating how many digits follow the decimal point in the &lt;code&gt;%f&lt;/code&gt;, &lt;code&gt;%e&lt;/code&gt;, &lt;code&gt;%E&lt;/code&gt;, &lt;code&gt;%h&lt;/code&gt;, and &lt;code&gt;%H&lt;/code&gt; conversions or the maximum number of significant digits to appear for the &lt;code&gt;%F&lt;/code&gt;, &lt;code&gt;%g&lt;/code&gt; and &lt;code&gt;%G&lt;/code&gt; conversions. For instance, &lt;code&gt;%.4f&lt;/code&gt; prints a &lt;code&gt;float&lt;/code&gt; with 4 fractional digits.</source>
          <target state="translated">オプションの &lt;code&gt;precision&lt;/code&gt; はドット &lt;code&gt;.&lt;/code&gt; その後に、 &lt;code&gt;%f&lt;/code&gt; 、 &lt;code&gt;%e&lt;/code&gt; 、 &lt;code&gt;%E&lt;/code&gt; 、 &lt;code&gt;%h&lt;/code&gt; 、および &lt;code&gt;%H&lt;/code&gt; 変換の小数点以下の桁数、または &lt;code&gt;%F&lt;/code&gt; 、 &lt;code&gt;%g&lt;/code&gt; 、および &lt;code&gt;%G&lt;/code&gt; 変換で表示される有効桁の最大数を示す整数が続きます。。たとえば、 &lt;code&gt;%.4f&lt;/code&gt; は、4桁の小数部の &lt;code&gt;float&lt;/code&gt; を出力します。</target>
        </trans-unit>
        <trans-unit id="5468298bc781912cae47e80a93f5f848cf36f0ca" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;random&lt;/code&gt; parameter (a boolean) controls whether the internal organization of the hash table is randomized at each execution of &lt;code&gt;Hashtbl.create&lt;/code&gt; or deterministic over all executions.</source>
          <target state="translated">オプションの &lt;code&gt;random&lt;/code&gt; パラメータ（ブール値）は、ハッシュテーブルの内部編成が &lt;code&gt;Hashtbl.create&lt;/code&gt; の実行ごとにランダム化されるか、すべての実行にわたって決定論的であるかを制御します。</target>
        </trans-unit>
        <trans-unit id="af162af26700a86b364c7a2731480ce8c43ff2a7" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;width&lt;/code&gt; is an integer indicating the minimal width of the result. For instance, &lt;code&gt;%6d&lt;/code&gt; prints an integer, prefixing it with spaces to fill at least 6 characters.</source>
          <target state="translated">オプションの &lt;code&gt;width&lt;/code&gt; は、結果の最小幅を示す整数です。たとえば、 &lt;code&gt;%6d&lt;/code&gt; は整数を出力し、少なくとも6文字を埋めるためにスペースを前に付けます。</target>
        </trans-unit>
        <trans-unit id="a984b2d5c22765574cbc75b87562636eb520c87c" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;code&gt;?stdin&lt;/code&gt; and &lt;code&gt;?stdout&lt;/code&gt; and &lt;code&gt;?stderr&lt;/code&gt; are file names used to redirect the standard input, the standard output, or the standard error of the command. If &lt;code&gt;~stdin:f&lt;/code&gt; is given, a redirection &lt;code&gt;&amp;lt;&amp;nbsp;f&lt;/code&gt; is performed and the standard input of the command reads from file &lt;code&gt;f&lt;/code&gt;. If &lt;code&gt;~stdout:f&lt;/code&gt; is given, a redirection &lt;code&gt;&amp;gt;&amp;nbsp;f&lt;/code&gt; is performed and the standard output of the command is written to file &lt;code&gt;f&lt;/code&gt;. If &lt;code&gt;~stderr:f&lt;/code&gt; is given, a redirection &lt;code&gt;2&amp;gt;&amp;nbsp;f&lt;/code&gt; is performed and the standard error of the command is written to file &lt;code&gt;f&lt;/code&gt;. If both &lt;code&gt;~stdout:f&lt;/code&gt; and &lt;code&gt;~stderr:f&lt;/code&gt; are given, with the exact same file name &lt;code&gt;f&lt;/code&gt;, a &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt; redirection is performed so that the standard output and the standard error of the command are interleaved and redirected to the same file &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">オプションの引数 &lt;code&gt;?stdin&lt;/code&gt; と &lt;code&gt;?stdout&lt;/code&gt; および &lt;code&gt;?stderr&lt;/code&gt; は、コマンドの標準入力、標準出力、または標準エラーをリダイレクトするために使用されるファイル名です。場合 &lt;code&gt;~stdin:f&lt;/code&gt; 与えられ、リダイレクト &lt;code&gt;&amp;lt;&amp;nbsp;f&lt;/code&gt; 実行され、コマンドの標準入力は、ファイルから読み込む &lt;code&gt;f&lt;/code&gt; 。場合 &lt;code&gt;~stdout:f&lt;/code&gt; 与えられ、リダイレクト &lt;code&gt;&amp;gt;&amp;nbsp;f&lt;/code&gt; 実行され、コマンドの標準出力をファイルに書き込まれ &lt;code&gt;f&lt;/code&gt; 。場合 &lt;code&gt;~stderr:f&lt;/code&gt; 与えられ、リダイレクト &lt;code&gt;2&amp;gt;&amp;nbsp;f&lt;/code&gt; 実行され、コマンドの標準エラーをファイルに書き込まれ &lt;code&gt;f&lt;/code&gt; 。両方の場合 &lt;code&gt;~stdout:f&lt;/code&gt; と &lt;code&gt;~stderr:f&lt;/code&gt; が指定され、まったく同じファイル名 &lt;code&gt;f&lt;/code&gt; で、 &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt; リダイレクトが実行され、コマンドの標準出力と標準エラーがインターリーブされ、同じファイル &lt;code&gt;f&lt;/code&gt; にリダイレクトされます。</target>
        </trans-unit>
        <trans-unit id="3e256823745bc0b0bb3e5fba44ec11d079e0f250" translate="yes" xml:space="preserve">
          <source>The optional type equation =&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; makes the defined type equivalent to the type expression &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;: one can be substituted for the other during typing. If no type equation is given, a new type is generated: the defined type is incompatible with any other type.</source>
          <target state="translated">オプションの種類は、式= &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;型の発現に定義されたタイプと同等になり&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;：一方は、タイピング中に他に置換することができます。型方程式が指定されていない場合、新しい型が生成されます。定義された型は他の型と互換性がありません。</target>
        </trans-unit>
        <trans-unit id="4236d000dcf5d91e24113385c5dda11fb81d860b" translate="yes" xml:space="preserve">
          <source>The optional type parameters are either one type variable '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;, for type constructors with one parameter, or a list of type variables ('&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;,&amp;hellip;,'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;), for type constructors with several parameters. Each type parameter may be prefixed by a variance constraint + (resp. -) indicating that the parameter is covariant (resp. contravariant). These type parameters can appear in the type expressions of the right-hand side of the definition, optionally restricted by a variance constraint ; &lt;em&gt;i.e.&lt;/em&gt; a covariant parameter may only appear on the right side of a functional arrow (more precisely, follow the left branch of an even number of arrows), and a contravariant parameter only the left side (left branch of an odd number of arrows). If the type has a representation or an equation, and the parameter is free (&lt;em&gt;i.e.&lt;/em&gt; not bound via a type constraint to a constructed type), its variance constraint is checked but subtyping &lt;em&gt;etc.&lt;/em&gt; will use the inferred variance of the parameter, which may be less restrictive; otherwise (&lt;em&gt;i.e.&lt;/em&gt; for abstract types or non-free parameters), the variance must be given explicitly, and the parameter is invariant if no variance is given.</source>
          <target state="translated">オプションの型パラメーターは、1つのパラメーターを持つ型コンストラクターの場合は1つの型変数 ' &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;、または複数のパラメーターを持つ型コンストラクターの場合は型変数のリスト（' &lt;a href=&quot;lex#ident&quot;&gt;ident &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、&amp;hellip;、 ' &lt;a href=&quot;lex#ident&quot;&gt;ident &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;）のいずれかです。各タイプのパラメーターの前に、パラメーターが共変（または反変）であることを示す分散制約+（または-）を付けることができます。これらの型パラメーターは、定義の右側の型式に表示でき、オプションで分散制約によって制限されます。&lt;em&gt;すなわち&lt;/em&gt;共変パラメーターは機能矢印の右側にのみ表示され（より正確には、偶数の矢印の左側の分岐をたどります）、反変パラメーターは左側にのみ表示されます（奇数の矢印の左側の分岐）。型に表現または方程式があり、パラメーターが自由である場合（&lt;em&gt;つまり&lt;/em&gt;、型制約を介して構築された型にバインドされていない場合）、その分散制約はチェックされますが、サブタイプ&lt;em&gt;など&lt;/em&gt;はパラメーターの推定分散を使用します。制限が少ない;それ以外の場合（&lt;em&gt;つまり&lt;/em&gt;、抽象型または非自由パラメーターの場合）、分散を明示的に指定する必要があり、分散が指定されていない場合、パラメーターは不変です。</target>
        </trans-unit>
        <trans-unit id="dca346bd513d4a4a22688d0f639db0a9deec76c9" translate="yes" xml:space="preserve">
          <source>The optional type representation describes the data structure representing the defined type, by giving the list of associated constructors (if it is a variant type) or associated fields (if it is a record type). If no type representation is given, nothing is assumed on the structure of the type besides what is stated in the optional type equation.</source>
          <target state="translated">オプションの型表現は,定義された型を表すデータ構造を記述し,関連するコンストラクタ(バリアント型の場合)や関連するフィールド(レコード型の場合)のリストを与えることで,定義された型を表現します.型表現が指定されていない場合は、オプションの型の式に記述されている以外には、型の構造は何も仮定されません。</target>
        </trans-unit>
        <trans-unit id="c913082fd743d89983385840500d287f715d0b40" translate="yes" xml:space="preserve">
          <source>The order in which the .cmo files are given to ocamlc during the linking phase determines the order in which the module definitions occur. Hence, in the example above, Aux appears first and Main can refer to it, but Aux cannot refer to Main.</source>
          <target state="translated">リンクの段階で .cmo ファイルが ocamlc に与えられる順序は、モジュール定義の発生順序を決定します。したがって、上の例では、Auxが最初に現れ、Mainはそれを参照することができますが、AuxはMainを参照することはできません。</target>
        </trans-unit>
        <trans-unit id="9875c6ba3859a4c01a0b128c6fb6274d60da0369" translate="yes" xml:space="preserve">
          <source>The order in which the bindings are passed to &lt;code&gt;f&lt;/code&gt; is unspecified. However, if the table contains several bindings for the same key, they are passed to &lt;code&gt;f&lt;/code&gt; in reverse order of introduction, that is, the most recent binding is passed first.</source>
          <target state="translated">バインディングが &lt;code&gt;f&lt;/code&gt; に渡される順序は指定されていません。ただし、テーブルに同じキーの複数のバインディングが含まれている場合、それらは導入の逆の順序で &lt;code&gt;f&lt;/code&gt; に渡されます。つまり、最新のバインディングが最初に渡されます。</target>
        </trans-unit>
        <trans-unit id="0038d1e71d2d22bcc5fc3fc7481009a2bb18e7e5" translate="yes" xml:space="preserve">
          <source>The order in which the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are evaluated is not specified.</source>
          <target state="translated">式&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;、&lt;a href=&quot;#argument&quot;&gt;引数&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、&amp;hellip;、&lt;a href=&quot;#argument&quot;&gt;引数&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;が評価される順序は指定されていません。</target>
        </trans-unit>
        <trans-unit id="63c6c1451d4aeaf3a047e06c6ffd102113e24f2b" translate="yes" xml:space="preserve">
          <source>The other caveat is that by default symbolic links are a privileged operation. Administrators will always need to be running elevated (or with UAC disabled) and by default normal user accounts need to be granted the SeCreateSymbolicLinkPrivilege via Local Security Policy (secpol.msc) or via Active Directory.</source>
          <target state="translated">もう一つの注意点は、デフォルトではシンボリックリンクは特権操作であるということです。管理者は常に昇格した状態(または UAC を無効にした状態)で実行する必要があり、デフォルトでは通常のユーザーアカウントはローカルセキュリティポリシー(secpol.msc)または Active Directory 経由で SeCreateSymbolicLinkPrivilege を付与する必要があります。</target>
        </trans-unit>
        <trans-unit id="69042c37de15f706ea13e0d0d27fbaa418b8568a" translate="yes" xml:space="preserve">
          <source>The other form of function definition is introduced by the keyword fun:</source>
          <target state="translated">関数定義のもう一つの形式は、キーワード fun で紹介されています。</target>
        </trans-unit>
        <trans-unit id="9ef7b523167e57b31abccd875bb07306286ad08a" translate="yes" xml:space="preserve">
          <source>The output buffer of a symbolic pretty-printer.</source>
          <target state="translated">シンボリックプリティプリンタの出力バッファ。</target>
        </trans-unit>
        <trans-unit id="197edf84eebbfd7ce0d59bc84a2b213982ad8e53" translate="yes" xml:space="preserve">
          <source>The output of the linking phase is a file containing compiled bytecode that can be executed by the OCaml bytecode interpreter: the command named ocamlrun. If a.out is the name of the file produced by the linking phase, the command</source>
          <target state="translated">リンクフェーズの出力は、OCamlバイトコードインタプリタで実行可能なコンパイル済みバイトコードを含むファイルです:ocamlrunというコマンドです。a.outがリンクフェーズで生成されたファイルの名前である場合、コマンド</target>
        </trans-unit>
        <trans-unit id="f86bd69d544011aefe916eee4af7cd635e073e0c" translate="yes" xml:space="preserve">
          <source>The output of the linking phase is a regular Unix or Windows executable file. It does not need ocamlrun to run.</source>
          <target state="translated">リンクフェーズの出力は、通常のUnixまたはWindowsの実行ファイルです。実行するために ocamlrun を必要としません。</target>
        </trans-unit>
        <trans-unit id="3ce0fa21bd7ce51645890738324e05068fce2adc" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;ephemeron.k1.make&quot;&gt;&lt;code&gt;Ephemeron.K1.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ephemeron.k2.make&quot;&gt;&lt;code&gt;Ephemeron.K2.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ファンクター&lt;a href=&quot;ephemeron.k1.make&quot;&gt; &lt;code&gt;Ephemeron.K1.Make&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;ephemeron.k2.make&quot;&gt; &lt;code&gt;Ephemeron.K2.Make&lt;/code&gt; &lt;/a&gt;の出力シグネチャ。</target>
        </trans-unit>
        <trans-unit id="5b888b9c1ae97afb61ed88f6dcc91b6356987780" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;ephemeron.k1.make&quot;&gt;&lt;code&gt;Ephemeron.K1.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ephemeron.k2.make&quot;&gt;&lt;code&gt;Ephemeron.K2.Make&lt;/code&gt;&lt;/a&gt;. These hash tables are weak in the keys. If all the keys of a binding are alive the binding is kept, but if one of the keys of the binding is dead then the binding is removed.</source>
          <target state="translated">ファンクター&lt;a href=&quot;ephemeron.k1.make&quot;&gt; &lt;code&gt;Ephemeron.K1.Make&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;ephemeron.k2.make&quot;&gt; &lt;code&gt;Ephemeron.K2.Make&lt;/code&gt; &lt;/a&gt;の出力シグネチャ。これらのハッシュテーブルはキーが弱いです。バインディングのすべてのキーが有効な場合、バインディングは保持されますが、バインディングのキーの1つが無効な場合、バインディングは削除されます。</target>
        </trans-unit>
        <trans-unit id="6df4d9df08fab00830fd043eb96f7af5ace9c32e" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;ephemeron.k1.makeseeded&quot;&gt;&lt;code&gt;Ephemeron.K1.MakeSeeded&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ephemeron.k2.makeseeded&quot;&gt;&lt;code&gt;Ephemeron.K2.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ファンクター&lt;a href=&quot;ephemeron.k1.makeseeded&quot;&gt; &lt;code&gt;Ephemeron.K1.MakeSeeded&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;ephemeron.k2.makeseeded&quot;&gt; &lt;code&gt;Ephemeron.K2.MakeSeeded&lt;/code&gt; &lt;/a&gt;の出力シグネチャ。</target>
        </trans-unit>
        <trans-unit id="ebc4f49be3b37069506238985b68b76a704e8a12" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;hashtbl.make&quot;&gt;&lt;code&gt;Hashtbl.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ファンクター&lt;a href=&quot;hashtbl.make&quot;&gt; &lt;code&gt;Hashtbl.Make&lt;/code&gt; &lt;/a&gt;の出力シグネチャ。</target>
        </trans-unit>
        <trans-unit id="acd77c5116baf2558a8ee6e7372f7c8f987c6831" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;hashtbl.makeseeded&quot;&gt;&lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ファンクター&lt;a href=&quot;hashtbl.makeseeded&quot;&gt; &lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt; &lt;/a&gt;の出力シグネチャ。</target>
        </trans-unit>
        <trans-unit id="ffa1e6deb7c02cb5fb60673b1d37d74545f296d4" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;weak.make&quot;&gt;&lt;code&gt;Weak.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ファンクター&lt;a href=&quot;weak.make&quot;&gt; &lt;code&gt;Weak.Make&lt;/code&gt; &lt;/a&gt;の出力シグネチャ。</target>
        </trans-unit>
        <trans-unit id="235dcfaccc10009cd349c37e2f6b3ea0f93a7b42" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;callstack_size&lt;/code&gt; is the length of the callstack recorded at every sample. Its default is &lt;code&gt;max_int&lt;/code&gt;.</source>
          <target state="translated">パラメータ &lt;code&gt;callstack_size&lt;/code&gt; は、すべてのサンプルで記録されたコールスタックの長さです。デフォルトは &lt;code&gt;max_int&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2e070830e786df33101debf41e042d4603dc7e8c" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;sampling_rate&lt;/code&gt; is the sampling rate in samples per word (including headers). Usually, with cheap callbacks, a rate of 1e-4 has no visible effect on performance, and 1e-3 causes the program to run a few percent slower</source>
          <target state="translated">パラメータ &lt;code&gt;sampling_rate&lt;/code&gt; は、単語あたりのサンプル数（ヘッダーを含む）のサンプリングレートです。通常、安価なコールバックでは、1e-4のレートはパフォーマンスに目に見える影響を与えず、1e-3はプログラムの実行を数パーセント遅くします</target>
        </trans-unit>
        <trans-unit id="49970203f15065fd920f5133460488f7c2c20b5b" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;tracker&lt;/code&gt; determines how to track sampled blocks over their lifetime in the minor and major heap.</source>
          <target state="translated">パラメータ &lt;code&gt;tracker&lt;/code&gt; は、マイナーヒープとメジャーヒープの存続期間にわたってサンプリングされたブロックを追跡する方法を決定します。</target>
        </trans-unit>
        <trans-unit id="09fbb96897f07cf55eb54e9bcb8824b504ac0830" translate="yes" xml:space="preserve">
          <source>The parameter patterns ~&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; and ~(&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;]) are shorthands for respectively ~&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt;:&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; and ~&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt;:(&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;]), and similarly for their optional counterparts.</source>
          <target state="translated">パラメータパターンは〜&lt;a href=&quot;lex#label-name&quot;&gt;ラボ&lt;/a&gt;と〜（&lt;a href=&quot;lex#label-name&quot;&gt;ラボ&lt;/a&gt;[：&lt;a href=&quot;types#typexpr&quot;&gt;TYP&lt;/a&gt; ]）は、それぞれのための略記法である〜&lt;a href=&quot;lex#label-name&quot;&gt;ラボ&lt;/a&gt;：&lt;a href=&quot;lex#label-name&quot;&gt;ラボ&lt;/a&gt;や〜&lt;a href=&quot;lex#label-name&quot;&gt;ラボ&lt;/a&gt;:(&lt;a href=&quot;lex#label-name&quot;&gt;ラボ&lt;/a&gt;[：&lt;a href=&quot;types#typexpr&quot;&gt;TYP&lt;/a&gt; ]）、同様にそれらの任意の対応のために。</target>
        </trans-unit>
        <trans-unit id="1e5974a12a7d51f44c9175604dd69a6dc4db175f" translate="yes" xml:space="preserve">
          <source>The parameter x_init is, of course, visible in the whole body of the definition, including methods. For instance, the method get_offset in the class below returns the position of the object relative to its initial position.</source>
          <target state="translated">パラメータ x_init は、もちろんメソッドを含めた定義の全体で見ることができます。例えば、以下のクラスのメソッド get_offset は、オブジェクトの初期位置からの相対的な位置を返します。</target>
        </trans-unit>
        <trans-unit id="e95fd7cf7f4ba7d41d47acfb96f75946ad23cd79" translate="yes" xml:space="preserve">
          <source>The parser also enters error recovery mode if one of the grammar actions raises the Parsing.Parse_error exception.</source>
          <target state="translated">また、文法アクションのいずれかが Parsing.Parse_error 例外を発生させた場合、パーサはエラー回復モードに入ります。</target>
        </trans-unit>
        <trans-unit id="34d65af266245e845378220e5a545186f7764e3e" translate="yes" xml:space="preserve">
          <source>The pass analyses functions to determine which arguments are unused. Removal is effected by creating a wrapper function, which will be inlined at every direct call site, that accepts the original arguments and then discards the unused ones before calling the original function. As a consequence, this transformation may be detrimental if the original function is usually indirectly called, since such calls will now bounce through the wrapper. (The technique of &lt;em&gt;direct call surrogates&lt;/em&gt; used to reduce this penalty during unboxing of closure variables (see above) does not yet apply to the pass that removes unused arguments.)</source>
          <target state="translated">パスは関数を分析して、未使用の引数を判別します。削除は、すべての直接呼び出しサイトでインライン化されるラッパー関数を作成することによって実行されます。ラッパー関数は、元の引数を受け入れ、元の関数を呼び出す前に未使用の引数を破棄します。結果として、元の関数が通常間接的に呼び出される場合、このような呼び出しはラッパーを介してバウンスするため、この変換は有害である可能性があります。 （クロージャ変数のボックス化解除中にこのペナルティを減らすために使用される&lt;em&gt;直接呼び出しサロゲート&lt;/em&gt;の手法（上記を参照）は、未使用の引数を削除するパスにはまだ適用されません。）</target>
        </trans-unit>
        <trans-unit id="ddb1f22a5bac6d00f359ad560b86fb3d4abcbdd7" translate="yes" xml:space="preserve">
          <source>The pattern 'c'..'d' is a shorthand for the pattern</source>
          <target state="translated">パターン'c'...d'の略語です。</target>
        </trans-unit>
        <trans-unit id="78a9eb434825f2c323017a519a3d60fa9f698c76" translate="yes" xml:space="preserve">
          <source>The pattern (&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;) matches the same values as &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. A type constraint can appear in a parenthesized pattern, as in (&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;). This constraint forces the type of &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to be compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;.</source>
          <target state="translated">パターン（&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;）は、&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;と同じ値に一致します。タイプ制約は、（&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;）のように、括弧で囲まれたパターンで表示できます。この制約により、&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;のタイプは&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;と互換性があります。</target>
        </trans-unit>
        <trans-unit id="16ae7f98de1b36c58b45270ed0fb02b7e9c6764a" translate="yes" xml:space="preserve">
          <source>The pattern (module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;) matches a package with type &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; and binds it to &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;. It is not allowed in toplevel let bindings. Again &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; can be omitted if it can be inferred from the enclosing pattern.</source>
          <target state="translated">パターン（module &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;：&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;）は、タイプ&lt;a href=&quot;#package-type&quot;&gt;package-typeの&lt;/a&gt;パッケージと一致し、それを&lt;a href=&quot;names#module-name&quot;&gt;module-nameに&lt;/a&gt;バインドします。トップレベルのletバインディングでは許可されていません。この場合も、&lt;a href=&quot;#package-type&quot;&gt;パッケージタイプ&lt;/a&gt;は、囲んでいるパターンから推測できる場合は省略できます。</target>
        </trans-unit>
        <trans-unit id="f60d5e8c331afa9fe8e1e6db86c21aacdc85acef" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; matches n-tuples whose components match the patterns &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; through &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. That is, the pattern matches the tuple values (v&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, v&lt;sub&gt;n&lt;/sub&gt;) such that &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; matches v&lt;sub&gt;i&lt;/sub&gt; for i = 1,&amp;hellip; , n.</source>
          <target state="translated">パターン&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、&amp;hellip;、&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;nは&lt;/sub&gt;、コンポーネントがパターン&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;から&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;nに&lt;/sub&gt;一致するnタプルに一致します。パターンが一致することである、タプル値（V &lt;sub&gt;1&lt;/sub&gt;、...、V &lt;sub&gt;N&lt;/sub&gt;）は、その&lt;a href=&quot;#pattern&quot;&gt;パターンは&lt;/a&gt;&lt;sub&gt;iが&lt;/sub&gt;V一致&lt;sub&gt;I&lt;/sub&gt; ...、I = 1のために、N。</target>
        </trans-unit>
        <trans-unit id="f6da6c23d8212831014d6c0f7d9fd644913b7199" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;::&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; matches non-empty lists whose heads match &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, and whose tails match &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="translated">パターン&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ::&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;試合非空でヘッド一致リスト&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;尾と一致し、&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;2を&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="41348db0bf142801b4dc26e958764633a28f85d6" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;as&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt; matches the same values as &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. If the matching against &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is successful, the name &lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt; is bound to the matched value, in addition to the bindings performed by the matching against &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.</source>
          <target state="translated">パターン&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;として&lt;a href=&quot;names#value-name&quot;&gt;値名&lt;/a&gt;と同じ値に一致する&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;。マッチングした場合&lt;a href=&quot;#pattern&quot;&gt;、パターン&lt;/a&gt;&lt;sub&gt;1は&lt;/sub&gt;成功し、名前の&lt;a href=&quot;names#value-name&quot;&gt;値名&lt;/a&gt;に対してマッチングによって行わバインディングに加えて、一致した値にバインドされる&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="9299c9cb5135cc2b4bedfa03f575390c8ead0e50" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; represents the logical &amp;ldquo;or&amp;rdquo; of the two patterns &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. A value matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; if it matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; or &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. The two sub-patterns &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; must bind exactly the same identifiers to values having the same types. Matching is performed from left to right. More precisely, in case some value v matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, the bindings performed are those of &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; when v matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. Otherwise, value v matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; whose bindings are performed.</source>
          <target state="translated">パターン&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; |&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;は、2つのパターン&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;と&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;の論理「or」を表します。値が&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1に&lt;/sub&gt;一致する|&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;、それが一致した場合&lt;a href=&quot;#pattern&quot;&gt;、パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;または&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;2を&lt;/sub&gt;。 2つのサブパターン&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;と&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;は、まったく同じ識別子を同じタイプの値にバインドする必要があります。マッチングは左から右に実行されます。より正確には、ある値vが&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1に&lt;/sub&gt;一致する場合|&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;実行バインディングはのものである&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; vが一致した場合&lt;a href=&quot;#pattern&quot;&gt;、パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;。それ以外の場合、値vは、バインディングが実行される&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;と一致します。</target>
        </trans-unit>
        <trans-unit id="00b0db5a51b1f1d5c7c59b426eaf70572b94fa7f" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;(&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;) matches all variants whose constructor is equal to &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;, and whose arguments match &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. It is a type error if n is not the number of arguments expected by the constructor.</source>
          <target state="translated">パターン&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;（&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、&amp;hellip;、&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;）は、コンストラクターが&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;と等しく、引数が&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;nに&lt;/sub&gt;一致するすべてのバリアントに一致します。nがコンストラクターによって予期される引数の数でない場合、これは型エラーです。</target>
        </trans-unit>
        <trans-unit id="d790d4519563bbe23e283cddeb381557179c1ed8" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;_ matches all variants whose constructor is &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;.</source>
          <target state="translated">パターン&lt;a href=&quot;names#constr&quot;&gt;constr_&lt;/a&gt;は、コンストラクターが&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;であるすべてのバリアントに一致します。</target>
        </trans-unit>
        <trans-unit id="3c4b162c77607f7f0c96e87989be66403257ce86" translate="yes" xml:space="preserve">
          <source>The pattern [&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] matches lists of length n whose elements match &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, respectively. This pattern behaves like &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:: &amp;hellip; ::&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;::[].</source>
          <target state="translated">パターン[&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ; &amp;hellip;; &lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; ]は、要素がそれぞれ&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;nに&lt;/sub&gt;一致する長さnのリストに一致します。このパターンは、&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ::&amp;hellip;::&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; :: []のように動作します。</target>
        </trans-unit>
        <trans-unit id="5be2296eeedc0ad28df110fb34fef15f60597b6f" translate="yes" xml:space="preserve">
          <source>The pattern [|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;|] matches arrays of length n such that the i-th array element matches the pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;, for i = 1,&amp;hellip; , n.</source>
          <target state="translated">パターン[| &lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ; &amp;hellip;; &lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; |]は、i = 1、&amp;hellip;、nの場合、i番目の配列要素がパターン&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;と一致するように、長さnの配列と一致します。</target>
        </trans-unit>
        <trans-unit id="1788df79d59202a4d26aad006675bcfb219b3e5f" translate="yes" xml:space="preserve">
          <source>The pattern `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; matches all polymorphic variants whose tag is equal to &lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;, and whose argument matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.</source>
          <target state="translated">パターン`&lt;a href=&quot;names#tag-name&quot;&gt;タグ名&lt;/a&gt;&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1は、&lt;/sub&gt;そのタグに等しいすべての多型変異体と一致する&lt;a href=&quot;names#tag-name&quot;&gt;タグ名&lt;/a&gt;、およびその引数と一致する&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="d78189bca7a2a4a7c7d4b24d2ca0b9ace362515e" translate="yes" xml:space="preserve">
          <source>The pattern lazy&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; matches a value v of type Lazy.t, provided &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; matches the result of forcing v with Lazy.force. A successful match of a pattern containing lazy sub-patterns forces the corresponding parts of the value being matched, even those that imply no test such as lazy&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt; or lazy_. Matching a value with a &lt;a href=&quot;expr#pattern-matching&quot;&gt;pattern-matching&lt;/a&gt; where some patterns contain lazy sub-patterns may imply forcing parts of the value, even when the pattern selected in the end has no lazy sub-pattern.</source>
          <target state="translated">パターンレイジー&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;は、タイプLazy.tの値vと一致します。ただし、&lt;a href=&quot;#pattern&quot;&gt;パターンが&lt;/a&gt;Lazy.forceでvを強制した結果と一致する場合に限ります。レイジーサブパターンを含むパターンの一致が成功すると、レイジー&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;やlazy_などのテストがないことを意味する部分であっても、値の対応する部分が強制的に一致します。一部のパターンにレイジーサブパターンが含まれている&lt;a href=&quot;expr#pattern-matching&quot;&gt;パターン&lt;/a&gt;マッチングと値を一致させると、最後に選択したパターンにレイジーサブパターンがない場合でも、値の一部が強制される可能性があります。</target>
        </trans-unit>
        <trans-unit id="16f7adce7fddea3b9b8f86106681f2bc5fc82ba6" translate="yes" xml:space="preserve">
          <source>The pattern {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [=&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;] ; &amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; [=&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] } matches records that define at least the fields &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; through &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, and such that the value associated to &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; matches the pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;, for i = 1,&amp;hellip; , n. A single identifier &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; , and a single qualified identifier &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; . The record value can define more fields than &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;; the values associated to these extra fields are not taken into account for matching. Optionally, a record pattern can be terminated by ;_ to convey the fact that not all fields of the record type are listed in the record pattern and that it is intentional. Optional type constraints can be added field by field with {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;;&amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;} to force the type of &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; to be compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;.</source>
          <target state="translated">パターン{&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [=&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ]; &amp;hellip;;&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; [=&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; ]}は、少なくともフィールド&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;から&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;を定義するレコードと一致し、&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;iに&lt;/sub&gt;関連付けられた値がパターン&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;と一致するようにします（i = 1、&amp;hellip;、n）。単一の識別子&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;は、&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; =&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;kを表し&lt;/sub&gt;、単一の修飾された識別子&lt;a href=&quot;names#module-path&quot;&gt;モジュールパスを表します&lt;/a&gt;。&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;は&lt;a href=&quot;names#module-path&quot;&gt;モジュールパス&lt;/a&gt;。&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; =&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;。レコード値は、&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;よりも多くのフィールドを定義できます。これらの追加フィールドに関連付けられた値は、マッチングの対象にはなりません。オプションで、レコードパターンを; _で終了して、レコードタイプのすべてのフィールドがレコードパターンにリストされているわけではなく、意図的なものであることを伝えることができます。オプションの型制約は、{&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; =&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ;&amp;hellip;;でフィールドごとに追加できます。&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; =&lt;a href=&quot;#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; }の型強制する&lt;a href=&quot;names#field&quot;&gt;フィールド&lt;/a&gt;&lt;sub&gt;Kを&lt;/sub&gt;と互換性があるように&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;K&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="28c11f2884ea2e751e90db06b713059bf8743ce8" translate="yes" xml:space="preserve">
          <source>The pointer returned by caml_named_value is constant and can safely be cached in a C variable to avoid repeated name lookups. The value pointed to cannot be changed from C. However, it might change during garbage collection, so must always be recomputed at the point of use. Here is a more efficient variant of call_caml_f above that calls caml_named_value only once:</source>
          <target state="translated">caml_named_value によって返されるポインタは定数であり、名前の再検索を避けるために C 変数に安全にキャッシュすることができます。指された値は C から変更することはできません。しかし、ガベージコレクション中に変更される可能性があるので、使用時には常に再計算されなければなりません。ここでは、caml_named_value を一度だけ呼び出す、上記の call_caml_f のより効率的な変形例を紹介します。</target>
        </trans-unit>
        <trans-unit id="32e4ea607d04ac6fcfc5da2a4f99be29eb749147" translate="yes" xml:space="preserve">
          <source>The policy used for allocating in the major heap. Possible values are 0, 1 and 2.</source>
          <target state="translated">メジャーヒープでの割り当てに使用されるポリシー。指定可能な値は 0,1,2 です。</target>
        </trans-unit>
        <trans-unit id="a0575e3a19290f6df5fdcaa47a106f8449112455" translate="yes" xml:space="preserve">
          <source>The polymorphic hash functions</source>
          <target state="translated">多相ハッシュ関数</target>
        </trans-unit>
        <trans-unit id="10931e6e8e695da4d6f07c1443d2547e5cf128cc" translate="yes" xml:space="preserve">
          <source>The polymorphism may be left implicit in public method specifications: any type variable which is not bound to a class parameter and does not appear elsewhere inside the class specification will be assumed to be universal, and made polymorphic in the resulting method type. Writing an explicit polymorphic type will disable this behaviour.</source>
          <target state="translated">クラスパラメータにバインドされておらず、クラス仕様内の他の場所には存在しない型変数は、普遍的なものとみなされ、結果として得られるメソッドの型に多相性を持たせることができます。明示的な多相型を記述すると、この動作は無効になります。</target>
        </trans-unit>
        <trans-unit id="46f55cdbce1c396ddb68caad025838e2c114c305" translate="yes" xml:space="preserve">
          <source>The precedence declarations are used in the following way to resolve reduce/reduce and shift/reduce conflicts:</source>
          <target state="translated">優先順位の宣言は、reduce/reduceとshift/reduceの競合を解決するために以下のように使用されます。</target>
        </trans-unit>
        <trans-unit id="1442484d01949a40882f7fd1198334b88701ef0b" translate="yes" xml:space="preserve">
          <source>The pretty-printer must split the line at this point,</source>
          <target state="translated">プリティプリンターはこの時点でラインを分割しなければなりません。</target>
        </trans-unit>
        <trans-unit id="e659673f1b18fb1d82b63a1c55173f87e4ba3218" translate="yes" xml:space="preserve">
          <source>The pretty-printing engine uses the concepts of pretty-printing box and break hint to drive indentation and line splitting behavior of the pretty-printer.</source>
          <target state="translated">pretty-printing エンジンは、 pretty-printing box と break hint の概念を使用して、 pretty-printer のインデントと行分割の動作を駆動します。</target>
        </trans-unit>
        <trans-unit id="a53dbcb487f74a0958c713e69a144733631dbfe2" translate="yes" xml:space="preserve">
          <source>The pretty-printing functions output material that is delayed in the pretty-printer queue and stacks in order to compute proper line splitting. In contrast, basic I/O output functions write directly in their output device. As a consequence, the output of a basic I/O function may appear before the output of a pretty-printing function that has been called before. For instance, &lt;code&gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Stdlib.print_string&amp;nbsp;&quot;&amp;lt;&quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Format.print_string&amp;nbsp;&quot;PRETTY&quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Stdlib.print_string&amp;nbsp;&quot;&amp;gt;&quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Format.print_string&amp;nbsp;&quot;TEXT&quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt; leads to output &lt;code&gt;&amp;lt;&amp;gt;PRETTYTEXT&lt;/code&gt;.</source>
          <target state="translated">プリティプリント機能は、適切な行分割を計算するために、プリティプリンタのキューとスタックで遅延したマテリアルを出力します。対照的に、基本的なI / O出力関数は、出力デバイスに直接書き込みます。結果として、基本的なI / O関数の出力は、以前に呼び出されたプリティプリント関数の出力の前に表示される場合があります。たとえば、 &lt;code&gt;&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Stdlib.print_string&amp;nbsp;&quot;&amp;lt;&quot;;&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Format.print_string&amp;nbsp;&quot;PRETTY&quot;;&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Stdlib.print_string&amp;nbsp;&quot;&amp;gt;&quot;;&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Format.print_string&amp;nbsp;&quot;TEXT&quot;;&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt; 出力 &lt;code&gt;&amp;lt;&amp;gt;PRETTYTEXT&lt;/code&gt; につながります。</target>
        </trans-unit>
        <trans-unit id="f51978ff177538bd6acc10bb07871f9792c046ef" translate="yes" xml:space="preserve">
          <source>The pretty-printing indication characters are introduced by a &lt;code&gt;@&lt;/code&gt; character, and their meanings are:</source>
          <target state="translated">プリティプリント表示文字は &lt;code&gt;@&lt;/code&gt; 文字で導入され、その意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="433dda59f28a1c16b7f6ad751b61d21f14015c15" translate="yes" xml:space="preserve">
          <source>The previous coercion problem can often be avoided by first defining the abbreviation, using a class type:</source>
          <target state="translated">先ほどの強制問題は、最初にクラス型を使って略語を定義することで回避できることが多いです。</target>
        </trans-unit>
        <trans-unit id="cb0dbd05eb51d23e1a522b80e905369b8eb83ac6" translate="yes" xml:space="preserve">
          <source>The printing function printer-name should have type Format.formatter-&amp;gt;t-&amp;gt;unit, where t is the type for the values to be printed, and should output its textual representation for the value of type t on the given formatter, using the functions provided by the Format library. For backward compatibility, printer-name can also have type t-&amp;gt;unit and should then output on the standard formatter, but this usage is deprecated.</source>
          <target state="translated">印刷関数printer-nameのタイプはFormat.formatter-&amp;gt; t-&amp;gt; unitである必要があります。ここで、tは印刷される値のタイプであり、指定されたフォーマッターでタイプtの値のテキスト表現を出力する必要があります。 Formatライブラリによって提供される関数。下位互換性のために、printer-nameはタイプt-&amp;gt; unitを持つこともでき、標準のフォーマッターで出力する必要がありますが、この使用法は非推奨です。</target>
        </trans-unit>
        <trans-unit id="8883bf4f143303eb37a391cfe05fa314bafceca6" translate="yes" xml:space="preserve">
          <source>The problem here is that SET specifies the type element abstractly, so that the type equality between element in the result of the functor and t in its argument is forgotten. Consequently, WrongStringSet.element is not the same type as string, and the operations of WrongStringSet cannot be applied to strings. As demonstrated above, it is important that the type element in the signature SET be declared equal to Elt.t; unfortunately, this is impossible above since SET is defined in a context where Elt does not exist. To overcome this difficulty, OCaml provides a with type construct over signatures that allows enriching a signature with extra type equalities:</source>
          <target state="translated">ここで問題なのは、SETが抽象的に要素の型を指定しているため、ファンクタの結果の要素とその引数のtとの型の等質性が忘れられてしまうことです。その結果、WrongStringSet.elementは文字列と同じ型ではなく、WrongStringSetの演算を文字列に適用することができません。上で実証したように、シグネチャ SET の型要素が Elt.t と等しいと宣言されることが重要ですが、残念ながら、SET は Elt が存在しないコンテキストで定義されているため、これは上では不可能です。この困難さを克服するために、OCamlは署名の上にwith型構成を提供しており、これにより署名に余分な型の均等性を与えることができます。</target>
        </trans-unit>
        <trans-unit id="79d5207edef86d719b23b481fee7c2e0aa2b94e6" translate="yes" xml:space="preserve">
          <source>The problem here is that quantification was wrongly located: it is not the class we want to be polymorphic, but the fold method. This can be achieved by giving an explicitly polymorphic type in the method definition.</source>
          <target state="translated">ここでの問題は、定量化が間違って配置されていたということです。これは、メソッドの定義で明示的に多相性のある型を与えることで実現できます。</target>
        </trans-unit>
        <trans-unit id="d28eba679c98023f0747aaf9581f0f01fc941cfe" translate="yes" xml:space="preserve">
          <source>The process terminated normally by &lt;code&gt;exit&lt;/code&gt;; the argument is the return code.</source>
          <target state="translated">プロセスは終了により正常に &lt;code&gt;exit&lt;/code&gt; 。引数は戻りコードです。</target>
        </trans-unit>
        <trans-unit id="168ecaee8748c10e62b8f47e3dcea6c8cbd65579" translate="yes" xml:space="preserve">
          <source>The process was killed by a signal; the argument is the signal number.</source>
          <target state="translated">引数はシグナル番号です。</target>
        </trans-unit>
        <trans-unit id="34eaa6addd6d491cf217fc8965c116ada2b0beed" translate="yes" xml:space="preserve">
          <source>The process was stopped by a signal; the argument is the signal number.</source>
          <target state="translated">引数にはシグナル番号を指定します。</target>
        </trans-unit>
        <trans-unit id="c048c9cffeb4593d3904a5383fdb63616e02e942" translate="yes" xml:space="preserve">
          <source>The produced file has the executable bit set, and it manages to launch the bytecode interpreter by itself.</source>
          <target state="translated">生成されたファイルには実行可能ビットが設定されており、バイトコードインタプリタを自分で起動することができます。</target>
        </trans-unit>
        <trans-unit id="5147f68b7fbbbd5f93868579353c15f80510e07f" translate="yes" xml:space="preserve">
          <source>The program behaves exactly as if the following phrases were entered at top-level:</source>
          <target state="translated">プログラムは、トップレベルで以下のフレーズが入力されたかのように正確に動作します。</target>
        </trans-unit>
        <trans-unit id="f484a5296a71c426225e4ed54accc59929e24d8b" translate="yes" xml:space="preserve">
          <source>The program being executed contains a &amp;ldquo;stray&amp;rdquo; exception. That is, it raises an exception at some point, and this exception is never caught. This causes immediate termination of the program. The name of the exception is printed, along with its string, byte sequence, and integer arguments (arguments of more complex types are not correctly printed). To locate the context of the uncaught exception, compile the program with the -g option and either run it again under the ocamldebug debugger (see chapter &lt;a href=&quot;debugger#c%3Adebugger&quot;&gt;17&lt;/a&gt;), or run it with ocamlrun -b or with the OCAMLRUNPARAM environment variable set to b=1.</source>
          <target state="translated">実行中のプログラムに「漂遊」例外が含まれています。つまり、ある時点で例外が発生し、この例外がキャッチされることはありません。これにより、プログラムが直ちに終了します。例外の名前が、その文字列、バイトシーケンス、および整数引数とともに出力されます（より複雑なタイプの引数は正しく出力されません）。キャッチされなかった例外のコンテキストを見つけるには、-gオプションを指定してプログラムをコンパイルし、ocamldebugデバッガー（第&lt;a href=&quot;debugger#c%3Adebugger&quot;&gt;17&lt;/a&gt;章を参照）で再度実行するか、ocamlrun-bまたはOCAMLRUNPARAM環境変数をb = 1に設定して実行します。 。</target>
        </trans-unit>
        <trans-unit id="b266af3c49a1ad66480fec482895593ef57dff7e" translate="yes" xml:space="preserve">
          <source>The program being executed requires more memory than available. Either the program builds excessively large data structures; or the program contains too many nested function calls, and the stack overflows. In some cases, your program is perfectly correct, it just requires more memory than your machine provides. In other cases, the &amp;ldquo;out of memory&amp;rdquo; message reveals an error in your program: non-terminating recursive function, allocation of an excessively large array, string or byte sequence, attempts to build an infinite list or other data structure, &amp;hellip;</source>
          <target state="translated">実行中のプログラムは、使用可能なメモリよりも多くのメモリを必要とします。プログラムが過度に大きなデータ構造を構築するかのどちらかです。または、プログラムに含まれるネストされた関数呼び出しが多すぎて、スタックがオーバーフローします。場合によっては、プログラムが完全に正しいことがあり、マシンが提供するよりも多くのメモリが必要になります。その他の場合、「メモリ不足」メッセージは、プログラムのエラーを明らかにします。非終了の再帰関数、過度に大きな配列、文字列またはバイトシーケンスの割り当て、無限リストまたはその他のデータ構造の構築の試み、&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="a503f7e4a9e093239bc1734598a0ac0302624fc9" translate="yes" xml:space="preserve">
          <source>The program being profiled must exit normally or be caused to exit using the SIGINT signal (e.g. by pressing Ctrl+C). When the program exits files will be written in the directory that was the working directory when the program was started. One Spacetime file will be written for each process that was involved, indexed by process ID; there will normally only be one such. The Spacetime files may be substantial. The directory to which they are written may be overridden by setting the OCAML_SPACETIME_SNAPSHOT_DIR environment variable before the program is started.</source>
          <target state="translated">プロファイルされているプログラムは正常に終了するか,SIGINT信号(例えばCtrl+Cキーを押して終了させる)を使って終了させなければなりません.プログラムが終了すると、プログラムが起動した時の作業ディレクトリにファイルが書き込まれます。Spacetimeファイルは,プロセスIDのインデックスが付けられたプロセスごとに書き込まれます.Spacetimeファイルはかなりの量になるかもしれません。それらが書き込まれるディレクトリは、プログラムが起動する前にOCAML_SPACETIME_SNAPSHOT_DIR環境変数を設定することで上書きすることができます。</target>
        </trans-unit>
        <trans-unit id="3cc4a8046bc314aed242125f697f2a900a2c88e8" translate="yes" xml:space="preserve">
          <source>The program is run directly by the debugger. This is the default mode.</source>
          <target state="translated">プログラムはデバッガによって直接実行されます。これがデフォルトモードです。</target>
        </trans-unit>
        <trans-unit id="869eb5aeb2fdd87b2a28ba89f60a8c2af784a6d6" translate="yes" xml:space="preserve">
          <source>The program will have to start event collection explicitly. Starting and stopping event collection programmatically can be done by calling Gc.eventlog_resume and Gc.eventlog_pause) from within the program. Refer to the &lt;a href=&quot;libref/gc&quot;&gt;Gc&lt;/a&gt; module documentation for more information.</source>
          <target state="translated">プログラムは、イベント収集を明示的に開始する必要があります。プログラムでイベント収集を開始および停止するには、プログラム内からGc.eventlog_resumeおよびGc.eventlog_pause）を呼び出します。詳細については、&lt;a href=&quot;libref/gc&quot;&gt;Gc&lt;/a&gt;モジュールのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="07c2399b10db28be424b9d95192597cf13943884" translate="yes" xml:space="preserve">
          <source>The projections from p may be replaced by uses of the variables x and y, potentially meaning that p becomes unused.</source>
          <target state="translated">pからの投影は、変数xとyの使用に置き換えられ、潜在的にはpが使用されなくなることを意味します。</target>
        </trans-unit>
        <trans-unit id="0e07f245bb0c49e7a50bc84525e1cacf4689e631" translate="yes" xml:space="preserve">
          <source>The propagation can help to eliminate allocations in cases such as:</source>
          <target state="translated">のような場合には、伝搬により割り当てをなくすことができます。</target>
        </trans-unit>
        <trans-unit id="f79e766e028d6e095da9d529d5a9dfbe0498d920" translate="yes" xml:space="preserve">
          <source>The propagation performed by the simplification pass is also important for discovering which functions flow to indirect call sites. This can enable the transformation of such call sites into direct call sites, which makes them eligible for an inlining transformation.</source>
          <target state="translated">単純化パスによって実行される伝搬は、どの関数が間接コールサイトに流れるかを発見するためにも重要である。これにより、そのようなコールサイトを直接コールサイトに変換することが可能となり、インライン変換の対象となる。</target>
        </trans-unit>
        <trans-unit id="94c9da3eb2e38629000eda75e07fe34fd5562fd6" translate="yes" xml:space="preserve">
          <source>The reason for the error: unknown option, invalid or missing argument, etc.</source>
          <target state="translated">エラーの理由:不明なオプション、無効な引数、または欠落した引数など。</target>
        </trans-unit>
        <trans-unit id="a43dbd7b9edc2247945720db7869546aded72b86" translate="yes" xml:space="preserve">
          <source>The reason is that at least one of the methods has a polymorphic type (here, the type of the value stored in the reference cell), thus either the class should be parametric, or the method type should be constrained to a monomorphic type. A monomorphic instance of the class could be defined by:</source>
          <target state="translated">その理由は、少なくとも1つのメソッドが多相型(ここでは参照セルに格納されている値の型)を持っているため、クラスがパラメトリックであるか、メソッドの型が単相型に拘束されている必要があるからです。クラスの単相インスタンスは次のように定義することができます。</target>
        </trans-unit>
        <trans-unit id="072461fde3d0d8b6efbc5a6868695ccf66c6f021" translate="yes" xml:space="preserve">
          <source>The reason this is unsafe is because the simplification pass believes that fst a holds the value 42; and indeed it must, unless type soundness has been broken via unsafe operations.</source>
          <target state="translated">これが安全でない理由は、単純化パスは fst a が値 42 を保持していると考えているからです。</target>
        </trans-unit>
        <trans-unit id="c67a48b57781f36d335583c6c3fd5c675bbebd44" translate="yes" xml:space="preserve">
          <source>The recursive definition is guaranteed to behave as described above if the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are function definitions (fun &amp;hellip; or function &amp;hellip;), and the patterns &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are just value names, as in:</source>
          <target state="translated">再帰的な定義は、式があれば、上記のように動作することが保証されて&lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;1に&lt;/sub&gt;するために&lt;a href=&quot;#expr&quot;&gt;exprを&lt;/a&gt;&lt;sub&gt;n個&lt;/sub&gt;の関数定義（楽し...または関数が...）であり、パターン&lt;a href=&quot;patterns#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1つの&lt;/sub&gt;...&lt;a href=&quot;patterns#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;Nは&lt;/sub&gt;のように、単に値の名前です。</target>
        </trans-unit>
        <trans-unit id="be50e5ba6751e078d213ea17d81f37abaeae3a78" translate="yes" xml:space="preserve">
          <source>The registration causes the contents of the variable or memory location to be updated by the garbage collector whenever the value in such variable or location is moved within the OCaml heap. In the presence of threads care must be taken to ensure appropriate synchronisation with the OCaml runtime to avoid a race condition against the garbage collector when reading or writing the value. (See section &lt;a href=&quot;#ss%3Aparallel-execution-long-running-c-code&quot;&gt;20.12.2&lt;/a&gt;.)</source>
          <target state="translated">登録により、変数またはメモリ位置の値がOCamlヒープ内で移動されるたびに、変数またはメモリ位置の内容がガベージコレクタによって更新されます。スレッドが存在する場合は、値の読み取りまたは書き込み時にガベージコレクターとの競合状態を回避するために、OCamlランタイムとの適切な同期を確保するように注意する必要があります。（セクション&lt;a href=&quot;#ss%3Aparallel-execution-long-running-c-code&quot;&gt;20.12.2を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="e498792eb5a8e5a1f7711c5d76148d563e2627fe" translate="yes" xml:space="preserve">
          <source>The registration mechanism described above can also be used to communicate exception identifiers from OCaml to C. The OCaml code registers the exception by evaluating Callback.register_exceptionn exn, where n is an arbitrary name and exn is an exception value of the exception to register. For example:</source>
          <target state="translated">OCaml コードは、Callback.register_exceptionn exn を評価して例外を登録します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="7e412ad57efe185f94f3f66dee663594387b73ec" translate="yes" xml:space="preserve">
          <source>The regular expressions are in the style of lex, with a more OCaml-like syntax.</source>
          <target state="translated">正規表現は lex のスタイルで、より OCaml に近い構文です。</target>
        </trans-unit>
        <trans-unit id="ca763eb3bdb448bf22bb32fc59cd71ec5db35a9f" translate="yes" xml:space="preserve">
          <source>The representation is chosen according to the following, in decreasing order of priority:</source>
          <target state="translated">表現は、以下のように優先度の高い順に選択されます。</target>
        </trans-unit>
        <trans-unit id="6cb9b87429c5694aec26392deb0ded32f7bf6b82" translate="yes" xml:space="preserve">
          <source>The representation of marshaled values is not human-readable, and uses bytes that are not printable characters. Therefore, input and output channels used in conjunction with &lt;code&gt;Marshal.to_channel&lt;/code&gt; and &lt;code&gt;Marshal.from_channel&lt;/code&gt; must be opened in binary mode, using e.g. &lt;code&gt;open_out_bin&lt;/code&gt; or &lt;code&gt;open_in_bin&lt;/code&gt;; channels opened in text mode will cause unmarshaling errors on platforms where text channels behave differently than binary channels, e.g. Windows.</source>
          <target state="translated">マーシャリングされた値の表現は人間が読める形式ではなく、印刷可能な文字ではないバイトを使用します。したがって、 &lt;code&gt;Marshal.to_channel&lt;/code&gt; および &lt;code&gt;Marshal.from_channel&lt;/code&gt; と組み合わせて使用​​される入力チャネルと出力チャネルは、たとえば &lt;code&gt;open_out_bin&lt;/code&gt; または &lt;code&gt;open_in_bin&lt;/code&gt; を使用してバイナリモードで開く必要があります。テキストモードで開かれたチャネルは、テキストチャネルがバイナリチャネルとは異なる動作をするプラットフォーム（Windowsなど）でアンマーシャリングエラーを引き起こします。</target>
        </trans-unit>
        <trans-unit id="b30fdf8a2c0fb75299c4dafd61caaf7a19cc1857" translate="yes" xml:space="preserve">
          <source>The rest of the binding is the same for both platforms:</source>
          <target state="translated">残りの縛りは両台とも同じです。</target>
        </trans-unit>
        <trans-unit id="44c9e601546b4f760808bdd19852d33ad5355c07" translate="yes" xml:space="preserve">
          <source>The restriction can also be performed during the definition of the structure, as in</source>
          <target state="translated">のように、構造体の定義中に制限を行うこともできます。</target>
        </trans-unit>
        <trans-unit id="dc0357393d60a0f1fa7baa5274ba71a46d90f408" translate="yes" xml:space="preserve">
          <source>The resulting P.cmx object file has sub-modules P.Q, P.Q.A and P.B.</source>
          <target state="translated">結果として得られるP.cmxオブジェクトファイルは、サブモジュールP.Q、P.Q.A、P.Bを持ちます。</target>
        </trans-unit>
        <trans-unit id="540f70e6d81a40f7974a7c5702a14ef36eff5dc8" translate="yes" xml:space="preserve">
          <source>The resulting benefit value is known as the &lt;em&gt;estimated benefit&lt;/em&gt;.</source>
          <target state="translated">結果として得られる利益値は、&lt;em&gt;推定利益&lt;/em&gt;として知られています。</target>
        </trans-unit>
        <trans-unit id="f24d01c073b212c7b11b8ff5380c3e1f163e921d" translate="yes" xml:space="preserve">
          <source>The resulting program can then be traced by running it with the environment variable OCAML_EVENTLOG_ENABLED:</source>
          <target state="translated">結果のプログラムは、環境変数OCAML_EVENTLOG_ENABLEDで実行することでトレースすることができます。</target>
        </trans-unit>
        <trans-unit id="0936bfa6fa4fa6c80130298ea1d5af175d858507" translate="yes" xml:space="preserve">
          <source>The resulting trace contains only one event payload, namely a &lt;em&gt;flush&lt;/em&gt; event, indicating how much time was spent flushing the trace file to disk.</source>
          <target state="translated">結果のトレースには、1つのイベントペイロード、つまり&lt;em&gt;フラッシュ&lt;/em&gt;イベントのみが含まれ、トレースファイルをディスクにフラッシュするのに費やされた時間を示します。</target>
        </trans-unit>
        <trans-unit id="5ed3a555a7ebebf96c3208ad39f845704f68067a" translate="yes" xml:space="preserve">
          <source>The resulting trace will contain all events encountered during the program&amp;rsquo;s execution:</source>
          <target state="translated">結果のトレースには、プログラムの実行中に発生したすべてのイベントが含まれます。</target>
        </trans-unit>
        <trans-unit id="76a2e5fedee04aeb14150359846ceeb930560151" translate="yes" xml:space="preserve">
          <source>The results of calling &lt;a href=&quot;string#VALmake&quot;&gt;&lt;code&gt;String.make&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes#VALmake&quot;&gt;&lt;code&gt;Bytes.make&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes#VALcreate&quot;&gt;&lt;code&gt;Bytes.create&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#VALmake&quot;&gt;&lt;code&gt;Array.make&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;stdlib#VALref&quot;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt; are guaranteed to be heap-allocated and non-constant except when the length argument is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;string#VALmake&quot;&gt; &lt;code&gt;String.make&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;bytes#VALmake&quot;&gt; &lt;code&gt;Bytes.make&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;bytes#VALcreate&quot;&gt; &lt;code&gt;Bytes.create&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;array#VALmake&quot;&gt; &lt;code&gt;Array.make&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;stdlib#VALref&quot;&gt; &lt;code&gt;ref&lt;/code&gt; &lt;/a&gt;を呼び出した結果は、length引数が &lt;code&gt;0&lt;/code&gt; の場合を除いて、ヒープに割り当てられ、一定でないことが保証されます。</target>
        </trans-unit>
        <trans-unit id="dab88c1cb3eef6aab0ce452f5d3a24ee29766571" translate="yes" xml:space="preserve">
          <source>The right way to solve this problem for optional parameters is to add a type annotation to the argument bump.</source>
          <target state="translated">オプションのパラメータに対するこの問題を解決する正しい方法は、引数のバンプに型のアノテーションを追加することです。</target>
        </trans-unit>
        <trans-unit id="021484aa4f766fbe935de88999e6cb6d7bb47d1e" translate="yes" xml:space="preserve">
          <source>The rules may contain the special symbol error to indicate resynchronization points, as in yacc.</source>
          <target state="translated">ルールは、yaccのように、再同期点を示すための特別なシンボルエラーを含んでいてもよい。</target>
        </trans-unit>
        <trans-unit id="b2425e4fb8fd4780c2506baebfe7345c64646daa" translate="yes" xml:space="preserve">
          <source>The run-time library for lexers generated by &lt;code&gt;ocamllex&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ocamllex&lt;/code&gt; によって生成されたレクサーのランタイムライブラリ。</target>
        </trans-unit>
        <trans-unit id="2d4e630606c50faf5f2e5b24a4b0bf1a04b6c5db" translate="yes" xml:space="preserve">
          <source>The run-time library for parsers generated by &lt;code&gt;ocamlyacc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ocamlyacc&lt;/code&gt; によって生成されたパーサーのランタイムライブラリ。</target>
        </trans-unit>
        <trans-unit id="b06b765c6160900806a7c7c50af837787bf9890a" translate="yes" xml:space="preserve">
          <source>The runtime overhead imposed by Spacetime varies considerably depending on the particular program being profiled. The overhead may be as low as ten percent&amp;mdash;but more usually programs should be expected to run at perhaps a third or quarter of their normal speed. It is expected that this overhead will be reduced in future versions of the compiler.</source>
          <target state="translated">Spacetimeによって課せられる実行時のオーバーヘッドは、プロファイリングされる特定のプログラムによって大幅に異なります。オーバーヘッドは10％程度と低い場合がありますが、通常、プログラムは通常の3分の1または4分の1の速度で実行されると予想されます。このオーバーヘッドは、コンパイラの将来のバージョンで削減されることが期待されます。</target>
        </trans-unit>
        <trans-unit id="7ef99f2b64955164c9593d8e632198f04c1ea43d" translate="yes" xml:space="preserve">
          <source>The runtime representation of a function. This includes pointers to the code of the function together with the values of any variables that are used in the body of the function but actually defined outside of the function, in the enclosing scope. The values of such variables, collectively known as the &lt;em&gt;environment&lt;/em&gt;, are required because the function may be invoked from a place where the original bindings of such variables are no longer in scope. A group of possibly mutually-recursive functions defined using &lt;em&gt;let rec&lt;/em&gt; all share a single closure. (Note to developers: in the Flambda source code a &lt;em&gt;closure&lt;/em&gt; always corresponds to a single function; a &lt;em&gt;set of closures&lt;/em&gt; refers to a group of such.)</source>
          <target state="translated">関数の実行時表現。これには、関数のコードへのポインターと、関数の本体で使用されているが実際には関数の外部で、囲んでいるスコープで定義されている変数の値が含まれます。このような変数の元のバインディングがスコープ内にない場所から関数を呼び出すことができるため、このような変数の値（まとめて&lt;em&gt;環境&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;）が必要です。&lt;em&gt;let rec&lt;/em&gt;を使用&lt;em&gt;して&lt;/em&gt;定義された、相互再帰的な可能性のある関数のグループはすべて、単一のクロージャーを共有します。 （開発者への注意：Flambdaソースコードでは、&lt;em&gt;クロージャは&lt;/em&gt;常に単一の関数に対応します。&lt;em&gt;クロージャのセット&lt;/em&gt;はそのようなグループを参照します。）</target>
        </trans-unit>
        <trans-unit id="09e0b17c8f9005f5c598030be2554c687ccaa24d" translate="yes" xml:space="preserve">
          <source>The same feature is provided for method definitions.</source>
          <target state="translated">メソッドの定義についても同様の機能が用意されています。</target>
        </trans-unit>
        <trans-unit id="f69459bd2efc915e393510bd7d020112db264859" translate="yes" xml:space="preserve">
          <source>The same goes for &lt;code&gt;set_double_field&lt;/code&gt; and &lt;code&gt;set_tag&lt;/code&gt;. However, for &lt;code&gt;set_tag&lt;/code&gt;, in the case of immutable blocks where the middle-end optimizers never see code that discriminates on their tag (for example records), the operation should be safe. Such uses are nonetheless discouraged.</source>
          <target state="translated">&lt;code&gt;set_double_field&lt;/code&gt; と &lt;code&gt;set_tag&lt;/code&gt; についても同じことが言えます。ただし、 &lt;code&gt;set_tag&lt;/code&gt; の場合、ミドルエンドオプティマイザがタグを区別するコード（レコードなど）を認識しない不変ブロックの場合、操作は安全である必要があります。それにもかかわらず、そのような使用は推奨されません。</target>
        </trans-unit>
        <trans-unit id="c251a3b5f6c58244053faab7ecc98ddabddcb4f0" translate="yes" xml:space="preserve">
          <source>The same ownership discipline that makes &lt;code&gt;unsafe_to_string&lt;/code&gt; correct applies to &lt;code&gt;unsafe_of_string&lt;/code&gt;: you may use it if you were the owner of the &lt;code&gt;string&lt;/code&gt; value, and you will own the return &lt;code&gt;bytes&lt;/code&gt; in the same mode.</source>
          <target state="translated">&lt;code&gt;unsafe_to_string&lt;/code&gt; を正しくするのと同じ所有権の規律がunsafe_of_stringに適用され &lt;code&gt;unsafe_of_string&lt;/code&gt; 。 &lt;code&gt;string&lt;/code&gt; 値の所有者である場合はそれを使用でき、同じモードで戻り &lt;code&gt;bytes&lt;/code&gt; を所有します。</target>
        </trans-unit>
        <trans-unit id="1ac338637d2a5fce3a9f3793f3f8813dc5e79b82" translate="yes" xml:space="preserve">
          <source>The same shortcut is available for enumerated lists, using &amp;rsquo;+&amp;rsquo; instead of &amp;rsquo;-&amp;rsquo;. Note that only one list can be defined by this shortcut in nested lists.</source>
          <target state="translated">'-'の代わりに '+'を使用して、列挙リストにも同じショートカットを使用できます。ネストされたリストでは、このショートカットで定義できるリストは1つだけであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a96000f19b19300268f15d1d76e944ef3a1ebf04" translate="yes" xml:space="preserve">
          <source>The same syntactic form is also used to attach attributes to labels and constructors in type declarations:</source>
          <target state="translated">同じ構文形式は、型宣言のラベルやコンストラクタに属性を付けるためにも使われます。</target>
        </trans-unit>
        <trans-unit id="c56f9cdc02f4eaf0671121f748c04b2b039e6299" translate="yes" xml:space="preserve">
          <source>The scanning indications introduce slight differences in the syntax of &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; format strings, compared to those used for the &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt; module. However, the scanning indications are similar to those used in the &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; module; hence, when producing formatted text to be scanned by &lt;a href=&quot;scanf#VALbscanf&quot;&gt;&lt;code&gt;Scanf.bscanf&lt;/code&gt;&lt;/a&gt;, it is wise to use printing functions from the &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; module (or, if you need to use functions from &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt;, banish or carefully double check the format strings that contain &lt;code&gt;'@'&lt;/code&gt; characters).</source>
          <target state="translated">スキャン表示は、&lt;a href=&quot;printf&quot;&gt; &lt;code&gt;Printf&lt;/code&gt; &lt;/a&gt;モジュールで使用されるものと比較して、&lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt;フォーマット文字列の構文にわずかな違いをもたらします。ただし、スキャン表示は&lt;a href=&quot;format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt;モジュールで使用されるものと同様です。したがって、&lt;a href=&quot;scanf#VALbscanf&quot;&gt; &lt;code&gt;Scanf.bscanf&lt;/code&gt; &lt;/a&gt;でスキャンするフォーマット済みテキストを作成する場合は、&lt;a href=&quot;format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt;モジュールの印刷関数を使用することをお勧めします（または、&lt;a href=&quot;printf&quot;&gt; &lt;code&gt;Printf&lt;/code&gt; の&lt;/a&gt;関数を使用する必要がある場合は、 &lt;code&gt;'@'&lt;/code&gt; を含むフォーマット文字列を削除するか、慎重に再確認してください。文字）。</target>
        </trans-unit>
        <trans-unit id="d497c2d6e07b975e5682bc991cd842d916c5c070" translate="yes" xml:space="preserve">
          <source>The second case is an open variant type, describing a polymorphic variant value: it gives the list of all tags the value could take, with their associated types. This type is still compatible with a variant type containing more tags. A special case is the unknown type, which does not define any tag, and is compatible with any variant type.</source>
          <target state="translated">2つ目のケースは、多相バリアント値を記述するオープンバリアント型で、値が取りうるすべてのタグのリストと関連する型を提供します。この型は、より多くのタグを含むバリアント型と互換性があります。特別なケースとして、タグを定義しない未知の型があり、どのバリアント型とも互換性があります。</target>
        </trans-unit>
        <trans-unit id="f4cd062edd42fc49d3c066f95872cdcd6b75a514" translate="yes" xml:space="preserve">
          <source>The second drawback of dynamic linking is that it complicates the construction of the library. The C compiler and linker flags to compile to position-independent code and build a shared library vary wildly between different Unix systems. Also, dynamic linking is not supported on all Unix systems, requiring a fall-back case to static linking in the Makefile for the library. The ocamlmklib command (see section &lt;a href=&quot;#s%3Aocamlmklib&quot;&gt;20.14&lt;/a&gt;) tries to hide some of these system dependencies.</source>
          <target state="translated">ダイナミックリンクの2つ目の欠点は、ライブラリの構築が複雑になることです。位置に依存しないコードにコンパイルして共有ライブラリを構築するためのCコンパイラとリンカのフラグは、Unixシステムによって大きく異なります。また、動的リンクはすべてのUnixシステムでサポートされているわけではないため、ライブラリのMakefileで静的リンクにフォールバックする必要があります。ocamlmklibコマンド（セクション&lt;a href=&quot;#s%3Aocamlmklib&quot;&gt;20.14を&lt;/a&gt;参照）は、これらのシステム依存関係の一部を隠そうとします。</target>
        </trans-unit>
        <trans-unit id="f1cce543693960e06654a40bc08d8813b14f9075" translate="yes" xml:space="preserve">
          <source>The second example is more subtle: while we intended the argument bump to be of type ?step:int -&amp;gt; int -&amp;gt; int, it is inferred as step:int -&amp;gt; int -&amp;gt; 'a. These two types being incompatible (internally normal and optional arguments are different), a type error occurs when applying bump_it to the real bump.</source>
          <target state="translated">2番目の例はもっと微妙です。引数bumpの型を？step：int-&amp;gt; int-&amp;gt; intにするつもりでしたが、step：int-&amp;gt; int-&amp;gt; 'aとして推測されます。これらの2つの型には互換性がなく（内部的に通常の引数とオプションの引数が異なります）、実際のバンプにbump_itを適用すると型エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="9d4ee921aaa1ec3723cdbada30294d66c801a5b5" translate="yes" xml:space="preserve">
          <source>The second form of attributes are attached to &amp;ldquo;blocks&amp;rdquo; such as type declarations, class fields, etc:</source>
          <target state="translated">属性の2番目の形式は、型宣言、クラスフィールドなどの「ブロック」に付加されます。</target>
        </trans-unit>
        <trans-unit id="4bcf7cdc991e4c97ac21aa1c7ae7ff5801e85d37" translate="yes" xml:space="preserve">
          <source>The second major class of non-genericity is directly related to the problem of type inference for polymorphic functions. In some circumstances, the type inferred by OCaml might be not general enough to allow the definition of some recursive functions, in particular for recursive function acting on non-regular algebraic data type.</source>
          <target state="translated">非一般性の第二の主要なクラスは、多相関数の型推論の問題に直接関連しています。いくつかの状況では、OCamlによって推論された型は、いくつかの再帰関数、特に非正規代数データ型に作用する再帰関数の定義を可能にするのに十分に一般的ではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="ddae56c7d78a1170cc9452541524e5c04728b654" translate="yes" xml:space="preserve">
          <source>The semantic tag handling functions specific to a formatter: &lt;code&gt;mark&lt;/code&gt; versions are the 'tag-marking' functions that associate a string marker to a tag in order for the pretty-printing engine to write those markers as 0 length tokens in the output device of the formatter.</source>
          <target state="translated">フォーマッタに固有のセマンティックタグ処理関数： &lt;code&gt;mark&lt;/code&gt; バージョンは、文字列マーカーをタグに関連付けて、きれいな印刷エンジンがそれらのマーカーを長さ0のトークンとして出力デバイスに書き込む「タグマーキング」関数です。フォーマッター。</target>
        </trans-unit>
        <trans-unit id="bff7da471def393c1b371feaa59a0379272afe47" translate="yes" xml:space="preserve">
          <source>The semantic tag handling functions specific to a formatter: &lt;code&gt;mark&lt;/code&gt; versions are the 'tag-marking' functions that associate a string marker to a tag in order for the pretty-printing engine to write those markers as 0 length tokens in the output device of the formatter. &lt;code&gt;print&lt;/code&gt; versions are the 'tag-printing' functions that can perform regular printing when a tag is closed or opened.</source>
          <target state="translated">フォーマッタに固有のセマンティックタグ処理関数： &lt;code&gt;mark&lt;/code&gt; バージョンは、文字列マーカーをタグに関連付けて、きれいな印刷エンジンがそれらのマーカーを長さ0のトークンとして出力デバイスに書き込む「タグマーキング」関数です。フォーマッター。 &lt;code&gt;print&lt;/code&gt; バージョンは、タグを閉じたり開いたりしたときに通常の印刷を実行できる「タグ印刷」機能です。</target>
        </trans-unit>
        <trans-unit id="2bcc6c39a05b6e4644ddb92b4ebfbec3f0bd5823" translate="yes" xml:space="preserve">
          <source>The semantics is clear: match the scrutinee against the pattern, if it matches, test the guard, and if the guard passes, take the branch. In particular, consider the input (Consta, Constb), where a fails the test is_neutrala, while b passes the test is_neutralb. With the left-to-right semantics, the clause above is &lt;em&gt;not&lt;/em&gt; taken by its input: matching (Consta, Constb) against the or-pattern succeeds in the left branch, it returns the environment x-&amp;gt;a, and then the guard is_neutrala is tested and fails, the branch is not taken.</source>
          <target state="translated">セマンティクスは明確です。精査者をパターンと照合し、一致する場合はガードをテストし、ガードが合格した場合はブランチを取得します。特に、入力（Consta、Constb）について考えてみます。ここで、aはテストis_neutralaに失敗し、bはテストis_neutralbに合格します。左から右へのセマンティクスでは、上記の句は入力に使用され&lt;em&gt;ません&lt;/em&gt;。orパターンに対する（Consta、Constb）のマッチングは左側のブランチで成功し、環境x-&amp;gt; aを返し、ガードis_neutralaテストされて失敗した場合、ブランチは取得されません。</target>
        </trans-unit>
        <trans-unit id="7a1ca7a03baad7716212210f3fc88fe09e15dd50" translate="yes" xml:space="preserve">
          <source>The semantics of or-patterns in OCaml is specified with a left-to-right bias: a value v matches the pattern p|q if it matches p or q, but if it matches both, the environment captured by the match is the environment captured by p, never the one captured by q.</source>
          <target state="translated">OCamlにおけるor-patternのセマンティクスは左から右へのバイアスで指定されています:値vはパターンp|qにマッチしますが、それがpまたはqにマッチする場合、マッチによって捕捉される環境はpによって捕捉される環境であり、決してqによって捕捉される環境ではありません。</target>
        </trans-unit>
        <trans-unit id="33bae5ab3c39edb36e6026c0e18053f2831c7697" translate="yes" xml:space="preserve">
          <source>The serialize field can be set to custom_serialize_default, in which case the Failure exception is raised when attempting to serialize the custom block.</source>
          <target state="translated">serializeフィールドをcustom_serialize_defaultに設定することができ、その場合、カスタムブロックをシリアライズしようとしたときにFailure例外が発生します。</target>
        </trans-unit>
        <trans-unit id="d40ce64ff61f966dff5d5f82bc2dc3bb7256bb8b" translate="yes" xml:space="preserve">
          <source>The serialize field contains a pointer to a C function that is called whenever the custom block needs to be serialized (marshaled) using the OCaml functions output_value or Marshal.to_.... For a custom block, those functions first write the identifier of the block (as given by the identifier field) to the output stream, then call the user-provided serialize function. That function is responsible for writing the data contained in the custom block, using the serialize_... functions defined in &amp;lt;caml/intext.h&amp;gt; and listed below. The user-provided serialize function must then store in its bsize_32 and bsize_64 parameters the sizes in bytes of the data part of the custom block on a 32-bit architecture and on a 64-bit architecture, respectively.</source>
          <target state="translated">serializeフィールドには、OCaml関数output_valueまたはMarshal.to _...を使用してカスタムブロックをシリアル化（マーシャリング）する必要があるときに呼び出されるC関数へのポインターが含まれます。カスタムブロックの場合、これらの関数は最初にの識別子を書き込みます。 （識別子フィールドで指定されたように）出力ストリームにブロックしてから、ユーザー提供のシリアル化関数を呼び出します。この関数は、&amp;lt;caml / intext.h&amp;gt;で定義され、以下にリストされているserialize _...関数を使用して、カスタムブロックに含まれるデータを書き込む役割を果たします。次に、ユーザー提供のシリアル化関数は、32ビットアーキテクチャと64ビットアーキテクチャのカスタムブロックのデータ部分のサイズを、それぞれbsize_32パラメーターとbsize_64パラメーターにバイト単位で格納する必要があります。</target>
        </trans-unit>
        <trans-unit id="d2942136b250ae1097e80c746ad490f52ed3542e" translate="yes" xml:space="preserve">
          <source>The set of command line flags relating to optimisation should typically be specified to be the same across an entire project. Flambda does not currently record the requested flags in the .cmx files. As such, inlining of functions from previously-compiled units will subject their code to the optimisation parameters of the unit currently being compiled, rather than those specified when they were previously compiled. It is hoped to rectify this deficiency in the future.</source>
          <target state="translated">最適化に関連するコマンドラインフラグのセットは、通常、プロジェクト全体で同じになるように指定する必要があります。Flambda は現在、要求されたフラグを .cmx ファイルに記録していません。そのため、以前にコンパイルされたユニットから関数をインライン化すると、そのコードは、以前にコンパイルされたときに指定された最適化パラメータではなく、現在コンパイルされているユニットの最適化パラメータに従うことになります。将来的には、この欠陥を修正することが望まれています。</target>
        </trans-unit>
        <trans-unit id="75f7516c7000daca4e41898b962a62fb90ba554f" translate="yes" xml:space="preserve">
          <source>The set of output functions specific to a formatter:</source>
          <target state="translated">フォーマッタに固有の出力関数のセット。</target>
        </trans-unit>
        <trans-unit id="58f5c99c8953630f7d0eb9e43e64f07f7389a46f" translate="yes" xml:space="preserve">
          <source>The set of output functions specific to a formatter: the &lt;code&gt;out_string&lt;/code&gt; function performs all the pretty-printer string output. It is called with a string &lt;code&gt;s&lt;/code&gt;, a start position &lt;code&gt;p&lt;/code&gt;, and a number of characters &lt;code&gt;n&lt;/code&gt;; it is supposed to output characters &lt;code&gt;p&lt;/code&gt; to &lt;code&gt;p&amp;nbsp;+&amp;nbsp;n&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; of &lt;code&gt;s&lt;/code&gt;., the &lt;code&gt;out_flush&lt;/code&gt; function flushes the pretty-printer output device., &lt;code&gt;out_newline&lt;/code&gt; is called to open a new line when the pretty-printer splits the line., the &lt;code&gt;out_spaces&lt;/code&gt; function outputs spaces when a break hint leads to spaces instead of a line split. It is called with the number of spaces to output., the &lt;code&gt;out_indent&lt;/code&gt; function performs new line indentation when the pretty-printer splits the line. It is called with the indentation value of the new line. By default: fields &lt;code&gt;out_string&lt;/code&gt; and &lt;code&gt;out_flush&lt;/code&gt; are output device specific; (e.g. &lt;a href=&quot;stdlib#VALoutput_string&quot;&gt;&lt;code&gt;output_string&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdlib#VALflush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;stdlib#TYPEout_channel&quot;&gt;&lt;code&gt;out_channel&lt;/code&gt;&lt;/a&gt; device, or &lt;code&gt;Buffer.add_substring&lt;/code&gt; and &lt;a href=&quot;stdlib#VALignore&quot;&gt;&lt;code&gt;ignore&lt;/code&gt;&lt;/a&gt; for a &lt;code&gt;Buffer.t&lt;/code&gt; output device),, field &lt;code&gt;out_newline&lt;/code&gt; is equivalent to &lt;code&gt;out_string&amp;nbsp;&quot;\n&quot;&amp;nbsp;0&amp;nbsp;1&lt;/code&gt;;, fields &lt;code&gt;out_spaces&lt;/code&gt; and &lt;code&gt;out_indent&lt;/code&gt; are equivalent to &lt;code&gt;out_string&amp;nbsp;(String.make&amp;nbsp;n&amp;nbsp;'&amp;nbsp;')&amp;nbsp;0&amp;nbsp;n&lt;/code&gt;.</source>
          <target state="translated">フォーマッターに固有の出力関数のセット： &lt;code&gt;out_string&lt;/code&gt; 関数は、プリティプリンターの文字列出力をすべて実行します。これは、文字列 &lt;code&gt;s&lt;/code&gt; 、開始位置 &lt;code&gt;p&lt;/code&gt; 、および文字数 &lt;code&gt;n&lt;/code&gt; で呼び出されます。それは、出力文字になっている &lt;code&gt;p&lt;/code&gt; に &lt;code&gt;p&amp;nbsp;+&amp;nbsp;n&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; の &lt;code&gt;s&lt;/code&gt; 。、 &lt;code&gt;out_flush&lt;/code&gt; 機能はプリティプリンタ出力デバイスをフラッシュし、。 &lt;code&gt;out_newline&lt;/code&gt; はプリティプリンタは、ラインを分割するときに、新しい行を開くために呼び出され、。 &lt;code&gt;out_spaces&lt;/code&gt; の機能ブレークヒントが行分割ではなくスペースにつながる場合にスペースを出力します。出力するスペースの数で呼び出されます。、 &lt;code&gt;out_indent&lt;/code&gt; この関数は、プリティプリンターが行を分割するときに改行インデントを実行します。新しい行のインデント値で呼び出されます。デフォルト：フィールド &lt;code&gt;out_string&lt;/code&gt; および &lt;code&gt;out_flush&lt;/code&gt; は出力デバイス固有です。 （たとえば、&lt;a href=&quot;stdlib#TYPEout_channel&quot;&gt; &lt;code&gt;out_channel&lt;/code&gt; &lt;/a&gt;デバイスの場合は&lt;a href=&quot;stdlib#VALoutput_string&quot;&gt; &lt;code&gt;output_string&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;stdlib#VALflush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;Buffer.t&lt;/code&gt; 出力デバイスの場合は &lt;code&gt;Buffer.add_substring&lt;/code&gt; と&lt;a href=&quot;stdlib#VALignore&quot;&gt; &lt;code&gt;ignore&lt;/code&gt; &lt;/a&gt;）、、フィールド &lt;code&gt;out_newline&lt;/code&gt; は &lt;code&gt;out_string&amp;nbsp;&quot;\n&quot;&amp;nbsp;0&amp;nbsp;1&lt;/code&gt; ;と同等であり、フィールド &lt;code&gt;out_spaces&lt;/code&gt; と &lt;code&gt;out_indent&lt;/code&gt; は &lt;code&gt;out_string&amp;nbsp;(String.make&amp;nbsp;n&amp;nbsp;'&amp;nbsp;')&amp;nbsp;0&amp;nbsp;n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fe430d7f65b9a4115dd36213fde72e2766eb905" translate="yes" xml:space="preserve">
          <source>The short expressions are translated into calls to functions of the Bigarray module as described in the following table.</source>
          <target state="translated">短い式は、以下の表で説明するように、Bigarrayモジュールの関数の呼び出しに変換されます。</target>
        </trans-unit>
        <trans-unit id="3ec3650bd7c2cf484db50a370f6c089d2295064a" translate="yes" xml:space="preserve">
          <source>The signature MYHASH then contains all the fields of the signature of the module Hashtbl (with strengthened type definitions), plus the new field replace. An implementation of this signature can be obtained easily by using the include construct again, but this time at the structure level:</source>
          <target state="translated">署名MYHASHには、モジュールHashtblの署名(型定義を強化したもの)のすべてのフィールドと、新しいフィールドreplaceが含まれています。このシグネチャの実装は、再びinclude構造を使うことで簡単に得ることができますが、今回は構造体レベルでの実装です。</target>
        </trans-unit>
        <trans-unit id="70846c98b1e5f76d1a8eeae9357dba832f61e830" translate="yes" xml:space="preserve">
          <source>The simplification pass removes unused let bindings so long as their corresponding defining expressions have &amp;ldquo;no effects&amp;rdquo;. See the section &amp;ldquo;Treatment of effects&amp;rdquo; below for the precise definition of this term.</source>
          <target state="translated">単純化パスは、対応する定義式に「影響がない」限り、未使用のletバインディングを削除します。この用語の正確な定義については、以下の「影響の処理」のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="0fef5e19c04ebce13dc54db7219bcb47397db9b0" translate="yes" xml:space="preserve">
          <source>The singleton sequence containing only the given element.</source>
          <target state="translated">与えられた要素のみを含むシングルトンシーケンス。</target>
        </trans-unit>
        <trans-unit id="c4bcd7d574236ad63f44f94fc9e518268676361d" translate="yes" xml:space="preserve">
          <source>The size (in words) of the minor heap. Changing this parameter will trigger a minor collection. Default: 256k.</source>
          <target state="translated">マイナーヒープのサイズ (ワード)。このパラメータを変更すると、マイナーコレクションが起動します。デフォルト:256k。</target>
        </trans-unit>
        <trans-unit id="a7507f679adbb7afe1b145bc75e44b72811c4382" translate="yes" xml:space="preserve">
          <source>The size in bits of a native integer.</source>
          <target state="translated">ネイティブ整数のビット単位のサイズ。</target>
        </trans-unit>
        <trans-unit id="85cc984ceaff2d2d3db71a0f154333bd58e0401c" translate="yes" xml:space="preserve">
          <source>The size in bits of a native integer. This is equal to &lt;code&gt;32&lt;/code&gt; on a 32-bit platform and to &lt;code&gt;64&lt;/code&gt; on a 64-bit platform.</source>
          <target state="translated">ネイティブ整数のビット単位のサイズ。これは、に等しい。 &lt;code&gt;32&lt;/code&gt; 、32ビットのプラットフォーム上とに &lt;code&gt;64&lt;/code&gt; の64ビットのプラットフォーム上。</target>
        </trans-unit>
        <trans-unit id="64bd44d9e49c2e76cdcec87737e9935d12ee6bdc" translate="yes" xml:space="preserve">
          <source>The size of the block, in words, excluding the header.</source>
          <target state="translated">ブロックの大きさを単語で表したもので、ヘッダを除いたもの。</target>
        </trans-unit>
        <trans-unit id="e6050e441d76daaaf25b47ad3fafeab9c8db6155" translate="yes" xml:space="preserve">
          <source>The size of the window used by the major GC for smoothing out variations in its workload. This is an integer between 1 and 50. Default: 1.</source>
          <target state="translated">作業負荷の変動を平滑化するために主要な GC によって使用されるウィンドウのサイズ。これは、1 から 50 までの整数である。デフォルト:1。</target>
        </trans-unit>
        <trans-unit id="e707fef1fa0d611c38a23a134e978234bf5dd431" translate="yes" xml:space="preserve">
          <source>The smallest positive, non-zero, non-denormalized value of type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">型 &lt;code&gt;float&lt;/code&gt; の最小の正、非ゼロ、非正規化値。</target>
        </trans-unit>
        <trans-unit id="a3b9782a5db6a027afd3f2671f6d34f2dca120c7" translate="yes" xml:space="preserve">
          <source>The smallest representable 32-bit integer, -2&lt;sup&gt;31&lt;/sup&gt;.</source>
          <target state="translated">最小の表現の32ビット整数、-2 &lt;sup&gt;31&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="1bcd225542d9f92f6251d4bb2d635ef483db75e2" translate="yes" xml:space="preserve">
          <source>The smallest representable 64-bit integer, -2&lt;sup&gt;63&lt;/sup&gt;.</source>
          <target state="translated">最小の表現の64ビット整数、-2 &lt;sup&gt;63&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="e75cf5a86c7fa5d080ac26a1f47b98cef3adf163" translate="yes" xml:space="preserve">
          <source>The smallest representable integer.</source>
          <target state="translated">表現可能な最小の整数。</target>
        </trans-unit>
        <trans-unit id="b7ad80500b883d3470a8546d7763368d6a139abd" translate="yes" xml:space="preserve">
          <source>The smallest representable native integer, either -2&lt;sup&gt;31&lt;/sup&gt; on a 32-bit platform, or -2&lt;sup&gt;63&lt;/sup&gt; on a 64-bit platform.</source>
          <target state="translated">最小の表現ネイティブのいずれかの整数、-2 &lt;sup&gt;31&lt;/sup&gt; 32ビットプラットフォーム上で、または-2 &lt;sup&gt;63&lt;/sup&gt; 64ビットプラットフォーム上で。</target>
        </trans-unit>
        <trans-unit id="16618ca96c698ad7bfc1856d7b38af8d4e0524d6" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt&quot;&gt;&lt;code&gt;Unix.getsockopt&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt&quot;&gt;&lt;code&gt;Unix.setsockopt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">相談することができるソケットオプション&lt;a href=&quot;unix#VALgetsockopt&quot;&gt; &lt;code&gt;Unix.getsockopt&lt;/code&gt; &lt;/a&gt;とで変性し&lt;a href=&quot;unix#VALsetsockopt&quot;&gt; &lt;code&gt;Unix.setsockopt&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67e810815e754c36f51190792dabe6b7f6d39fc1" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt&quot;&gt;&lt;code&gt;Unix.getsockopt&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt&quot;&gt;&lt;code&gt;Unix.setsockopt&lt;/code&gt;&lt;/a&gt;. These options have a boolean (&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;) value.</source>
          <target state="translated">相談することができるソケットオプション&lt;a href=&quot;unix#VALgetsockopt&quot;&gt; &lt;code&gt;Unix.getsockopt&lt;/code&gt; &lt;/a&gt;とで変性し&lt;a href=&quot;unix#VALsetsockopt&quot;&gt; &lt;code&gt;Unix.setsockopt&lt;/code&gt; &lt;/a&gt;。これらのオプションにはブール値（ &lt;code&gt;true&lt;/code&gt; / &lt;code&gt;false&lt;/code&gt; ）があります。</target>
        </trans-unit>
        <trans-unit id="6598491cb35302bb16af6b6c7a9e151f8e63d9b8" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_float&quot;&gt;&lt;code&gt;Unix.getsockopt_float&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_float&quot;&gt;&lt;code&gt;Unix.setsockopt_float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">相談することができるソケットオプション&lt;a href=&quot;unix#VALgetsockopt_float&quot;&gt; &lt;code&gt;Unix.getsockopt_float&lt;/code&gt; &lt;/a&gt;とで変性し&lt;a href=&quot;unix#VALsetsockopt_float&quot;&gt; &lt;code&gt;Unix.setsockopt_float&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2019ae655a591c32fb8f40c0b2ba647816b414ae" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_float&quot;&gt;&lt;code&gt;Unix.getsockopt_float&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_float&quot;&gt;&lt;code&gt;Unix.setsockopt_float&lt;/code&gt;&lt;/a&gt;. These options have a floating-point value representing a time in seconds. The value 0 means infinite timeout.</source>
          <target state="translated">相談することができるソケットオプション&lt;a href=&quot;unix#VALgetsockopt_float&quot;&gt; &lt;code&gt;Unix.getsockopt_float&lt;/code&gt; &lt;/a&gt;とで変性し&lt;a href=&quot;unix#VALsetsockopt_float&quot;&gt; &lt;code&gt;Unix.setsockopt_float&lt;/code&gt; &lt;/a&gt;。これらのオプションには、時間を秒単位で表す浮動小数点値があります。値0は、無限のタイムアウトを意味します。</target>
        </trans-unit>
        <trans-unit id="2e1595d080e9d78ca9f7ddffc0fd77da50d67b0c" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_int&quot;&gt;&lt;code&gt;Unix.getsockopt_int&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_int&quot;&gt;&lt;code&gt;Unix.setsockopt_int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">相談することができるソケットオプション&lt;a href=&quot;unix#VALgetsockopt_int&quot;&gt; &lt;code&gt;Unix.getsockopt_int&lt;/code&gt; &lt;/a&gt;とで変性し&lt;a href=&quot;unix#VALsetsockopt_int&quot;&gt; &lt;code&gt;Unix.setsockopt_int&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6570006f88037fbe57d746e9ffa8ebe2113c3daa" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_int&quot;&gt;&lt;code&gt;Unix.getsockopt_int&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_int&quot;&gt;&lt;code&gt;Unix.setsockopt_int&lt;/code&gt;&lt;/a&gt;. These options have an integer value.</source>
          <target state="translated">相談することができるソケットオプション&lt;a href=&quot;unix#VALgetsockopt_int&quot;&gt; &lt;code&gt;Unix.getsockopt_int&lt;/code&gt; &lt;/a&gt;とで変性し&lt;a href=&quot;unix#VALsetsockopt_int&quot;&gt; &lt;code&gt;Unix.setsockopt_int&lt;/code&gt; &lt;/a&gt;。これらのオプションには整数値があります。</target>
        </trans-unit>
        <trans-unit id="67cb053530374f0ae91755129be399861c2e62b8" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_optint&quot;&gt;&lt;code&gt;Unix.getsockopt_optint&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_optint&quot;&gt;&lt;code&gt;Unix.setsockopt_optint&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">相談することができるソケットオプション&lt;a href=&quot;unix#VALgetsockopt_optint&quot;&gt; &lt;code&gt;Unix.getsockopt_optint&lt;/code&gt; &lt;/a&gt;とで変性し&lt;a href=&quot;unix#VALsetsockopt_optint&quot;&gt; &lt;code&gt;Unix.setsockopt_optint&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b02d9606ae3049641c3c0b7a49b93173582ba252" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_optint&quot;&gt;&lt;code&gt;Unix.getsockopt_optint&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_optint&quot;&gt;&lt;code&gt;Unix.setsockopt_optint&lt;/code&gt;&lt;/a&gt;. These options have a value of type &lt;code&gt;int&amp;nbsp;option&lt;/code&gt;, with &lt;code&gt;None&lt;/code&gt; meaning ``disabled''.</source>
          <target state="translated">相談することができるソケットオプション&lt;a href=&quot;unix#VALgetsockopt_optint&quot;&gt; &lt;code&gt;Unix.getsockopt_optint&lt;/code&gt; &lt;/a&gt;とで変性し&lt;a href=&quot;unix#VALsetsockopt_optint&quot;&gt; &lt;code&gt;Unix.setsockopt_optint&lt;/code&gt; &lt;/a&gt;。これらのオプションの値は &lt;code&gt;int&amp;nbsp;option&lt;/code&gt; であり、 &lt;code&gt;None&lt;/code&gt; は「無効」を意味します。</target>
        </trans-unit>
        <trans-unit id="773642dab704b446e24c880397ae53bf6b4f36e8" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt&quot;&gt;&lt;code&gt;UnixLabels.getsockopt&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt&quot;&gt;&lt;code&gt;UnixLabels.setsockopt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">相談することができるソケットオプション&lt;a href=&quot;unixlabels#VALgetsockopt&quot;&gt; &lt;code&gt;UnixLabels.getsockopt&lt;/code&gt; &lt;/a&gt;とで変性し&lt;a href=&quot;unixlabels#VALsetsockopt&quot;&gt; &lt;code&gt;UnixLabels.setsockopt&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="127c95d87113564ad21001801dba75443274ac20" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt&quot;&gt;&lt;code&gt;UnixLabels.getsockopt&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt&quot;&gt;&lt;code&gt;UnixLabels.setsockopt&lt;/code&gt;&lt;/a&gt;. These options have a boolean (&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;) value.</source>
          <target state="translated">相談することができるソケットオプション&lt;a href=&quot;unixlabels#VALgetsockopt&quot;&gt; &lt;code&gt;UnixLabels.getsockopt&lt;/code&gt; &lt;/a&gt;とで変性し&lt;a href=&quot;unixlabels#VALsetsockopt&quot;&gt; &lt;code&gt;UnixLabels.setsockopt&lt;/code&gt; &lt;/a&gt;。これらのオプションにはブール値（ &lt;code&gt;true&lt;/code&gt; / &lt;code&gt;false&lt;/code&gt; ）があります。</target>
        </trans-unit>
        <trans-unit id="5d121887ffb4d5fad74076fcd7a6ddb33c6b3f62" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_float&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_float&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_float&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">相談することができるソケットオプション&lt;a href=&quot;unixlabels#VALgetsockopt_float&quot;&gt; &lt;code&gt;UnixLabels.getsockopt_float&lt;/code&gt; &lt;/a&gt;とで変性し&lt;a href=&quot;unixlabels#VALsetsockopt_float&quot;&gt; &lt;code&gt;UnixLabels.setsockopt_float&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03fad790fcf2b775879fa18d8ded24985ac1495f" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_float&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_float&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_float&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_float&lt;/code&gt;&lt;/a&gt;. These options have a floating-point value representing a time in seconds. The value 0 means infinite timeout.</source>
          <target state="translated">相談することができるソケットオプション&lt;a href=&quot;unixlabels#VALgetsockopt_float&quot;&gt; &lt;code&gt;UnixLabels.getsockopt_float&lt;/code&gt; &lt;/a&gt;とで変性し&lt;a href=&quot;unixlabels#VALsetsockopt_float&quot;&gt; &lt;code&gt;UnixLabels.setsockopt_float&lt;/code&gt; &lt;/a&gt;。これらのオプションには、時間を秒単位で表す浮動小数点値があります。値0は、無限のタイムアウトを意味します。</target>
        </trans-unit>
        <trans-unit id="4cd8b0a441c72f8156f95e88c710953c3fa2ced0" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_int&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_int&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_int&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">相談することができるソケットオプション&lt;a href=&quot;unixlabels#VALgetsockopt_int&quot;&gt; &lt;code&gt;UnixLabels.getsockopt_int&lt;/code&gt; &lt;/a&gt;とで変性し&lt;a href=&quot;unixlabels#VALsetsockopt_int&quot;&gt; &lt;code&gt;UnixLabels.setsockopt_int&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af5931adebaf9a357ecb0df8a73e7c072f718e8d" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_int&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_int&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_int&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_int&lt;/code&gt;&lt;/a&gt;. These options have an integer value.</source>
          <target state="translated">相談することができるソケットオプション&lt;a href=&quot;unixlabels#VALgetsockopt_int&quot;&gt; &lt;code&gt;UnixLabels.getsockopt_int&lt;/code&gt; &lt;/a&gt;とで変性し&lt;a href=&quot;unixlabels#VALsetsockopt_int&quot;&gt; &lt;code&gt;UnixLabels.setsockopt_int&lt;/code&gt; &lt;/a&gt;。これらのオプションには整数値があります。</target>
        </trans-unit>
        <trans-unit id="55d3d9fad514eda7c3e614c6496c099599e1e6e6" translate="yes" xml:space="preserve">
          <source>The solution of this conundrum is to use an explicitly polymorphic type annotation for the type 'a:</source>
          <target state="translated">この難問を解決するには、型'a.に対して明示的に多相性を持つ型アノテーションを使用することです。</target>
        </trans-unit>
        <trans-unit id="ca3eb9c8c5023c43f9da6f2e55f310ac29817523" translate="yes" xml:space="preserve">
          <source>The sort function above does not modify its input list: it builds and returns a new list containing the same elements as the input list, in ascending order. There is actually no way in OCaml to modify a list in-place once it is built: we say that lists are &lt;em&gt;immutable&lt;/em&gt; data structures. Most OCaml data structures are immutable, but a few (most notably arrays) are &lt;em&gt;mutable&lt;/em&gt;, meaning that they can be modified in-place at any time.</source>
          <target state="translated">上記の並べ替え関数は、入力リストを変更しません。入力リストと同じ要素を含む新しいリストを昇順で作成して返します。OCamlには、リストが作成された後、その場でリストを変更する方法は実際にはありません。リストは&lt;em&gt;不変の&lt;/em&gt;データ構造であると言えます。ほとんどのOCamlデータ構造は不変ですが、いくつか（特に配列）は&lt;em&gt;変更可能です&lt;/em&gt;。つまり、いつでもインプレースで変更できます。</target>
        </trans-unit>
        <trans-unit id="3aef2817764bb52ac263b2fae2a148fec94730b6" translate="yes" xml:space="preserve">
          <source>The space character in format strings</source>
          <target state="translated">フォーマット文字列のスペース文字</target>
        </trans-unit>
        <trans-unit id="c0c0e1ff4d5efd916e94aa7b9b072f20bb6cc011" translate="yes" xml:space="preserve">
          <source>The special comment (**/**) tells OCamldoc to discard elements placed after this comment, up to the end of the current class, class type, module or module type, or up to the next stop comment. For instance:</source>
          <target state="translated">特別なコメント(**/**)は、このコメントの後に置かれた要素を、現在のクラス、クラスタイプ、モジュールまたはモジュールタイプの最後まで、または次のストップコメントまで破棄するようOCamldocに指示します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="cebcc58b51afa7136699d267676f15d0e280a3f4" translate="yes" xml:space="preserve">
          <source>The special comment is not already associated to the previous element.</source>
          <target state="translated">特別なコメントが前の要素にまだ関連付けられていない。</target>
        </trans-unit>
        <trans-unit id="5435aaea40f8385771bfff6ba0d166cd3c0eeccb" translate="yes" xml:space="preserve">
          <source>The special comment is not the first one of a toplevel module.</source>
          <target state="translated">特別なコメントは、トップレベルのモジュールの最初のものではありません。</target>
        </trans-unit>
        <trans-unit id="06de91b2368326e2f06fbc6d38cdade544c2bc74" translate="yes" xml:space="preserve">
          <source>The specification exception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt; in a signature requires the matching structure to provide an exception with the name and arguments specified in the definition, and makes the exception available to all users of the structure.</source>
          <target state="translated">シグニチャの仕様例外&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt;は、定義で指定された名前と引数で例外を提供するために一致する構造を必要とし、構造のすべてのユーザーが例外を利用できるようにします。</target>
        </trans-unit>
        <trans-unit id="fc96b351853386bb44b989f2d36255658c8e97cf" translate="yes" xml:space="preserve">
          <source>The specification of a method is written method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;, where &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; is the name of the method and &lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt; its expected type, possibly polymorphic. The flag private indicates that the method cannot be accessed from outside the object.</source>
          <target state="translated">メソッドの仕様は、method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;：&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;と記述されます。ここで、&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;はメソッドの名前であり、&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexprは&lt;/a&gt;その予想される型であり、多形である可能性があります。フラグprivateは、オブジェクトの外部からメソッドにアクセスできないことを示します。</target>
        </trans-unit>
        <trans-unit id="816c127c5b84f64b52fb9fd685c1cb4ac8a4ea85" translate="yes" xml:space="preserve">
          <source>The standard error output for the process.</source>
          <target state="translated">プロセスの標準誤差出力。</target>
        </trans-unit>
        <trans-unit id="db78c9295b1256ee8e8a6b6086c5f3651f2fa1cd" translate="yes" xml:space="preserve">
          <source>The standard formatter to write to standard output.</source>
          <target state="translated">標準出力に書き込む標準フォーマッタ。</target>
        </trans-unit>
        <trans-unit id="ba48c9ea4ac16d1bd2010fb99db24330d34c33b1" translate="yes" xml:space="preserve">
          <source>The standard input for the process.</source>
          <target state="translated">プロセスの標準入力です。</target>
        </trans-unit>
        <trans-unit id="375db9af8a0d4dc3c0ba86650eeff121048506df" translate="yes" xml:space="preserve">
          <source>The standard input notion for the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt;モジュールの標準入力概念。</target>
        </trans-unit>
        <trans-unit id="464e4c58fe500861730075b12f1fb6435b04534f" translate="yes" xml:space="preserve">
          <source>The standard input notion for the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module. &lt;code&gt;Scanning.stdin&lt;/code&gt; is the &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt; formatted input channel attached to &lt;a href=&quot;stdlib#VALstdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt;モジュールの標準入力概念。 &lt;code&gt;Scanning.stdin&lt;/code&gt; は、&lt;a href=&quot;stdlib#VALstdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; に&lt;/a&gt;接続された&lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt; &lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt; &lt;/a&gt;形式の入力チャネルです。</target>
        </trans-unit>
        <trans-unit id="aecb465e5714800c091e84c331cee9577b92a018" translate="yes" xml:space="preserve">
          <source>The standard library directory.</source>
          <target state="translated">標準のライブラリディレクトリ。</target>
        </trans-unit>
        <trans-unit id="defad1b44801f55e161dc009fb41cef1fe3ba956" translate="yes" xml:space="preserve">
          <source>The standard output for the process.</source>
          <target state="translated">プロセスの標準出力です。</target>
        </trans-unit>
        <trans-unit id="f1326096be35fcaff4666a9f746f76c98f98925e" translate="yes" xml:space="preserve">
          <source>The str library provides high-level string processing functions, some based on regular expressions. It is intended to support the kind of file processing that is usually performed with scripting languages such as awk, perl or sed.</source>
          <target state="translated">str ライブラリは高レベルの文字列処理関数を提供します。これは、通常 awk,perl,sed などのスクリプト言語で実行されるファイル処理をサポートすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="6d5110986ab904812febd54df3e70e3cfe974039" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;cmd&lt;/code&gt; is the command to call. The list &lt;code&gt;args&lt;/code&gt; is the list of arguments to pass to this command. It can be empty.</source>
          <target state="translated">文字列 &lt;code&gt;cmd&lt;/code&gt; は、呼び出すコマンドです。list &lt;code&gt;args&lt;/code&gt; は、このコマンドに渡す引数のリストです。空にすることができます。</target>
        </trans-unit>
        <trans-unit id="4ea036aba8bc423b44bed368aa0538f1848ee618" translate="yes" xml:space="preserve">
          <source>The string buffer in which &lt;code&gt;str_formatter&lt;/code&gt; writes.</source>
          <target state="translated">&lt;code&gt;str_formatter&lt;/code&gt; が書き込む文字列バッファ。</target>
        </trans-unit>
        <trans-unit id="7a78fd29209652bbda7cca4022b56527d5c814fe" translate="yes" xml:space="preserve">
          <source>The struct custom_operations is defined in &amp;lt;caml/custom.h&amp;gt; and contains the following fields:</source>
          <target state="translated">structcustom_operationsは&amp;lt;caml / custom.h&amp;gt;で定義されており、次のフィールドが含まれています。</target>
        </trans-unit>
        <trans-unit id="a298a05448f3ad20cfa9581c95c5d1288fc8e676" translate="yes" xml:space="preserve">
          <source>The syntactic class of constants comprises literals from the four base types (integers, floating-point numbers, characters, character strings), the integer variants, and constant constructors from both normal and polymorphic variants, as well as the special constants false, true, (), [], and [||], which behave like constant constructors, and beginend, which is equivalent to ().</source>
          <target state="translated">定数の構文クラスは、4つの基底型(整数、浮動小数点数、文字、文字列)、整数の変種、正規変種と多相変種の定数コンストラクタ、定数コンストラクタのように振る舞う特殊な定数False、true、()、[]、[||]、そして()と等価なBeginendからなる。</target>
        </trans-unit>
        <trans-unit id="a830f98dedde0a3c31b9928e1164ca27920971ea" translate="yes" xml:space="preserve">
          <source>The syntax for rules is as usual:</source>
          <target state="translated">ルールの構文はいつも通りです。</target>
        </trans-unit>
        <trans-unit id="11b8e75b70b6bcdf9c144d7d28884193fb2da070" translate="yes" xml:space="preserve">
          <source>The syntax is exactly the same as for class expressions, but the result is a single object rather than a class. All the constructs described in the rest of this section also apply to immediate objects.</source>
          <target state="translated">構文はクラス式と全く同じですが、結果はクラスではなく単一のオブジェクトになります。このセクションの残りの部分で説明されているすべての構文は、即時オブジェクトにも適用されます。</target>
        </trans-unit>
        <trans-unit id="f75ce09e5843f380505e811b0272a865314bf4e9" translate="yes" xml:space="preserve">
          <source>The syntax of the language is given in BNF-like notation. Terminal symbols are set in typewriter font (likethis). Non-terminal symbols are set in italic font (likethat). Square brackets [&amp;hellip;] denote optional components. Curly brackets {&amp;hellip;} denotes zero, one or several repetitions of the enclosed components. Curly brackets with a trailing plus sign {&amp;hellip;}&lt;sup&gt;+&lt;/sup&gt; denote one or several repetitions of the enclosed components. Parentheses (&amp;hellip;) denote grouping.</source>
          <target state="translated">言語の構文は、BNFのような表記で示されます。終端記号はタイプライターフォントで設定されます（このように）。非終端記号はイタリックフォントで設定されます（そのように）。角括弧[&amp;hellip;]はオプションのコンポーネントを示します。中括弧{&amp;hellip;}は、囲まれたコンポーネントの0回、1回、または数回の繰り返しを示します。末尾にプラス記号が付いた中括弧{&amp;hellip;} &lt;sup&gt;+&lt;/sup&gt;は、囲まれたコンポーネントの1回または複数回の繰り返しを示します。括弧（&amp;hellip;）はグループ化を示します。</target>
        </trans-unit>
        <trans-unit id="aa08323f8802e6d50ccec78b682ef7b93d7f7d1e" translate="yes" xml:space="preserve">
          <source>The table below lists the symbols defined in the initial environment and their initial meaning. (See the description of the core library module Stdlib in chapter &lt;a href=&quot;core#c%3Acorelib&quot;&gt;25&lt;/a&gt; for more details). Their meaning may be changed at any time using let(&lt;a href=&quot;names#infix-op&quot;&gt;infix-op&lt;/a&gt;)name&lt;sub&gt;1&lt;/sub&gt;name&lt;sub&gt;2&lt;/sub&gt;= &amp;hellip;</source>
          <target state="translated">次の表に、初期環境で定義されている記号とその初期の意味を示します。（詳細については、第&lt;a href=&quot;core#c%3Acorelib&quot;&gt;25&lt;/a&gt;章のコアライブラリモジュールStdlibの説明を参照してください）。それらの意味は、let（&lt;a href=&quot;names#infix-op&quot;&gt;infix-op&lt;/a&gt;）name &lt;sub&gt;1&lt;/sub&gt; name &lt;sub&gt;2&lt;/sub&gt; =&amp;hellip;を使用していつでも変更できます。</target>
        </trans-unit>
        <trans-unit id="4265c38e98429479cc2782e5d12f7b2b292f3497" translate="yes" xml:space="preserve">
          <source>The table below shows the relative precedences and associativity of operators and non-closed constructions. The constructions with higher precedence come first. For infix and prefix symbols, we write &amp;ldquo;*&amp;hellip;&amp;rdquo; to mean &amp;ldquo;any symbol starting with *&amp;rdquo;.</source>
          <target state="translated">次の表は、演算子と閉じていない構造の相対的な優先順位と結合性を示しています。優先順位の高い構造が最初に来ます。中置記号と接頭記号の場合、「*&amp;hellip;」は「*で始まる任意の記号」を意味します。</target>
        </trans-unit>
        <trans-unit id="1ca02ca74768b06f8e3e1c2b6d1dd2805e4d9dc1" translate="yes" xml:space="preserve">
          <source>The table below shows the relative precedences and associativity of operators and non-closed pattern constructions. The constructions with higher precedences come first.</source>
          <target state="translated">下の表は、演算子と非閉じたパターン構造の相対的な優先順位と連想性を示しています。優先順位の高い構文が優先されます。</target>
        </trans-unit>
        <trans-unit id="2aaedd4906bf37d963daebc10f3ce2cae137d335" translate="yes" xml:space="preserve">
          <source>The table below shows the relative precedences and associativity of operators and non-closed type constructions. The constructions with higher precedences come first.</source>
          <target state="translated">下の表は、演算子と非閉型構文の相対的な優先順位と連想性を示しています。優先順位の高い構文が優先されます。</target>
        </trans-unit>
        <trans-unit id="873780c573d904e6823105d70079b69ff6aa2a60" translate="yes" xml:space="preserve">
          <source>The tag-marking operation is the simpler tag specific operation: it simply writes a tag specific string into the output device of the formatter. Tag-marking does not interfere with line-splitting computation.</source>
          <target state="translated">タグマーキング操作は、より単純なタグ固有の操作です:それは単にタグ固有の文字列をフォーマッタの出力デバイスに書き込むだけです。タグマーキングは改行の計算を妨害しません。</target>
        </trans-unit>
        <trans-unit id="3e9b336647566103c9dc222eca78097e8e36a10d" translate="yes" xml:space="preserve">
          <source>The tag-printing operation is the more involved tag specific operation: it can print arbitrary material to the formatter. Tag-printing is tightly linked to the current pretty-printer operations.</source>
          <target state="translated">タグ印刷操作は、より複雑なタグ固有の操作です:それは、フォーマッタに任意の材料を印刷することができます。タグ印刷は、現在のプリティプリンタ操作と密接にリンクされています。</target>
        </trans-unit>
        <trans-unit id="bc0467c82797c179e1082f88331fe596f582254d" translate="yes" xml:space="preserve">
          <source>The term type we have defined above is an &lt;em&gt;indexed&lt;/em&gt; type, where a type parameter reflects a property of the value contents. Another use of GADTs is &lt;em&gt;singleton&lt;/em&gt; types, where a GADT value represents exactly one type. This value can be used as runtime representation for this type, and a function receiving it can have a polytypic behavior.</source>
          <target state="translated">上で定義したタイプという用語は&lt;em&gt;インデックス付き&lt;/em&gt;タイプであり、タイプパラメーターは値の内容のプロパティを反映します。GADTのもう1つの用途は、GADT値が正確に1つのタイプを表す&lt;em&gt;シングルトン&lt;/em&gt;タイプです。この値は、このタイプのランタイム表現として使用でき、この値を受け取る関数は、ポリタイプの動作をすることができます。</target>
        </trans-unit>
        <trans-unit id="bff74d740aa663829cf4f77edbb8806d1bc466d0" translate="yes" xml:space="preserve">
          <source>The termination status of a process.</source>
          <target state="translated">プロセスの終了状態。</target>
        </trans-unit>
        <trans-unit id="e0c71035b432f40f8ce6567e0659d0f94303a4bb" translate="yes" xml:space="preserve">
          <source>The termination status of a process. See module &lt;a href=&quot;sys&quot;&gt;&lt;code&gt;Sys&lt;/code&gt;&lt;/a&gt; for the definitions of the standard signal numbers. Note that they are not the numbers used by the OS.</source>
          <target state="translated">プロセスの終了ステータス。標準信号番号の定義については、モジュール&lt;a href=&quot;sys&quot;&gt; &lt;code&gt;Sys&lt;/code&gt; &lt;/a&gt;を参照してください。これらはOSで使用される番号ではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="b998179643d8f25a6de4e2f828c6ab63197c25fd" translate="yes" xml:space="preserve">
          <source>The third case is a closed variant type. It gives information about all the possible tags and their associated types, and which tags are known to potentially appear in values. The exact variant type (first case) is just an abbreviation for a closed variant type where all possible tags are also potentially present.</source>
          <target state="translated">3番目のケースはクローズドバリアント型です。これは、すべての可能性のあるタグとそれに関連するタイプ、およびどのタグが値に潜在的に現れることが知られているかについての情報を与えます。厳密バリアント型(最初のケース)は、すべての可能なタグが潜在的に存在するクローズドバリアント型の略語にすぎません。</target>
        </trans-unit>
        <trans-unit id="72c73fe652e0c0e0cf068757abf72958b2266b30" translate="yes" xml:space="preserve">
          <source>The threads library allows concurrent programming in OCaml. It provides multiple threads of control (also called lightweight processes) that execute concurrently in the same memory space. Threads communicate by in-place modification of shared data structures, or by sending and receiving data on communication channels.</source>
          <target state="translated">スレッドライブラリは、OCamlでの並行プログラミングを可能にします。これは、同じメモリ空間で同時に実行する複数の制御スレッド(軽量プロセスとも呼ばれる)を提供します。スレッドは、共有データ構造をその場で変更したり、通信チャネルでデータを送受信したりすることで通信を行います。</target>
        </trans-unit>
        <trans-unit id="ee8a007db9b67f061741b11b1f8ef10fd7dfa6a8" translate="yes" xml:space="preserve">
          <source>The threads library is implemented by time-sharing on a single processor. It will not take advantage of multi-processor machines. Using this library will therefore never make programs run faster. However, many programs are easier to write when structured as several communicating processes.</source>
          <target state="translated">スレッドライブラリは、単一プロセッサ上でのタイムシェアリングによって実装されています。マルチプロセッサマシンを利用することはありません。したがって、このライブラリを使用してもプログラムの実行速度が速くなることはありません。しかし、多くのプログラムは、複数の通信プロセスとして構造化されている方が書きやすいです。</target>
        </trans-unit>
        <trans-unit id="d5a20efffaf644d1427994b098f56c7f31e6be5e" translate="yes" xml:space="preserve">
          <source>The three kinds of interval timers.</source>
          <target state="translated">インターバルタイマーの3種類。</target>
        </trans-unit>
        <trans-unit id="4b1f416d7e4aa2468aa653df39f4953c40bbd756" translate="yes" xml:space="preserve">
          <source>The three type parameters to &lt;code&gt;Genarray.t&lt;/code&gt; identify the array element kind and layout, as follows:</source>
          <target state="translated">&lt;code&gt;Genarray.t&lt;/code&gt; の3つの型パラメーターは、次のように配列要素の種類とレイアウトを識別します。</target>
        </trans-unit>
        <trans-unit id="27a8084722c0c59b716ab80edd05f2b005dea978" translate="yes" xml:space="preserve">
          <source>The toplevel system does not perform line editing, but it can easily be used in conjunction with an external line editor such as ledit, or rlwrap. An improved toplevel, utop, is also available. Another option is to use ocaml under Gnu Emacs, which gives the full editing power of Emacs (command run-caml from library inf-caml).</source>
          <target state="translated">トップレベルは行編集を行いませんが、editやrlwrapなどの外部行エディタと併用することで簡単に使用できます。改良された toplevel,utop も利用可能です。もう一つの選択肢は、Gnu Emacs の下で ocaml を使うことで、Emacs の編集機能をフルに利用することができます (ライブラリ inf-caml から run-caml コマンドを実行してください)。</target>
        </trans-unit>
        <trans-unit id="0efc25c223657f44333e6ed3dee74d2f834fa753" translate="yes" xml:space="preserve">
          <source>The total amount of memory allocated by the program since it was started is (in words) &lt;code&gt;minor_words&amp;nbsp;+&amp;nbsp;major_words&amp;nbsp;-&amp;nbsp;promoted_words&lt;/code&gt;. Multiply by the word size (4 on a 32-bit machine, 8 on a 64-bit machine) to get the number of bytes.</source>
          <target state="translated">プログラムが開始されてから割り当てられたメモリの合計量は、（単語で） &lt;code&gt;minor_words&amp;nbsp;+&amp;nbsp;major_words&amp;nbsp;-&amp;nbsp;promoted_words&lt;/code&gt; です。ワードサイズ（32ビットマシンでは4、64ビットマシンでは8）を掛けて、バイト数を取得します。</target>
        </trans-unit>
        <trans-unit id="f4eb40ef4dc24c3e0ad0bdb73cac37d303dc7aee" translate="yes" xml:space="preserve">
          <source>The transformation is implemented by adding a new wrapper function in the manner of that used when unboxing specialised arguments. The closure variables are still free in the wrapper, but the intention is that when the wrapper is inlined at direct call sites, the relevant values are passed directly to the main function via the new specialised arguments.</source>
          <target state="translated">この変換は、特殊な引数を取り出す際に使用する方法で、 新しいラッパー関数を追加することで実装されています。クロージャ変数はまだラッパー内で自由ですが、ラッパーが直接コールサイトでインライン化されたときに、 関連する値が新しい特殊な引数を介して直接メイン関数に渡されるようにすることを意図しています。</target>
        </trans-unit>
        <trans-unit id="2e984d305346aebd0ab69a424dfacb7e6aa1b981" translate="yes" xml:space="preserve">
          <source>The transformation is implemented by creating a wrapper function that accepts the original arguments. Meanwhile, the original function is renamed and extra arguments are added corresponding to the unboxed specialised arguments; this new function is called from the wrapper. The wrapper will then be inlined at direct call sites. Indeed, all call sites will be direct unless -unbox-closures is being used, since they will have been generated by the compiler when originally specialising the function. (In the case of -unbox-closures other functions may appear with specialised arguments; in this case there may be indirect calls and these will incur a small penalty owing to having to bounce through the wrapper. The technique of &lt;em&gt;direct call surrogates&lt;/em&gt; used for -unbox-closures is not used by the transformation to unbox specialised arguments.)</source>
          <target state="translated">変換は、元の引数を受け入れるラッパー関数を作成することによって実装されます。一方、元の関数の名前が変更され、ボックス化されていない特殊な引数に対応する引数が追加されます。この新しい関数はラッパーから呼び出されます。その後、ラッパーは直接呼び出しサイトにインライン化されます。実際、-unbox-closuresが使用されていない限り、すべての呼び出しサイトは直接になります。これは、元々関数を特殊化したときにコンパイラーによって生成されたためです。 （-unbox-closuresの場合、他の関数が特殊な引数で表示される場合があります。この場合、間接呼び出しが発生する可能性があり、ラッパーを介してバウンスする必要があるため、これらにはわずかなペナルティが発生します。&lt;em&gt;直接呼び出しサロゲート&lt;/em&gt;の手法&lt;em&gt;&lt;/em&gt; -unbox-closuresに使用されるのは、ボックス化解除の特殊な引数への変換では使用されません。）</target>
        </trans-unit>
        <trans-unit id="8198b57a18523f699b5f95a3eca2418108615522" translate="yes" xml:space="preserve">
          <source>The transformation replaces closure variables by specialised arguments. The aim is to cause more closures to become closed. It is particularly applicable, as a means of reducing allocation, where the function concerned cannot be inlined or specialised. For example, some non-recursive function might be too large to inline; or some recursive function might offer no opportunities for specialisation perhaps because its only argument is one of type unit.</source>
          <target state="translated">この変換は、クロージャ変数を特殊な引数で置き換えます。目的は、より多くのクロージャをクロージャにすることです。これは、特に、関連する関数がインライン化できなかったり、特殊化できなかったりする場合に、割り当てを減らす手段として適用できます。例えば、非再帰的な関数は大きすぎてインライン化できないかもしれませんし、再帰的な関数は、引数がユニット型のものしかないため、特殊化の機会がないかもしれません。</target>
        </trans-unit>
        <trans-unit id="2ec534b61d911e890ad6935004cee0e7049d17f2" translate="yes" xml:space="preserve">
          <source>The transformation to unbox specialised arguments never introduces extra allocation.</source>
          <target state="translated">特殊な引数をアンボックス化する変換は、余分なアロケーションを導入することはありません。</target>
        </trans-unit>
        <trans-unit id="3e701b3559c3cd620429a438a8bb4dcb9c99e51c" translate="yes" xml:space="preserve">
          <source>The transformation will not unbox arguments if it would result in the original function having sufficiently many arguments so as to inhibit tail-call optimisation.</source>
          <target state="translated">テールコールの最適化を阻害するように元の関数が十分に多くの引数を持つことになる場合、変換は引数をアンボックス化しません。</target>
        </trans-unit>
        <trans-unit id="3231a8b466d35dcee0deec7b0a92803db2aeb3cd" translate="yes" xml:space="preserve">
          <source>The transformations in this section relate to the splitting apart of &lt;em&gt;boxed&lt;/em&gt; (that is to say, non-immediate) values. They are largely intended to reduce allocation, which tends to result in a runtime performance profile with lower variance and smaller tails.</source>
          <target state="translated">このセクションの変換は、&lt;em&gt;ボックス化された&lt;/em&gt;（つまり、非即時の）値の分割に関連しています。これらは主に割り当てを減らすことを目的としており、分散が小さくテールが小さいランタイムパフォーマンスプロファイルになる傾向があります。</target>
        </trans-unit>
        <trans-unit id="6eb73189e94327227c50de51480db7a0a57ff2cd" translate="yes" xml:space="preserve">
          <source>The two arguments used and max give the GC an idea of how much out-of-heap resources are consumed by the finalized block being allocated: you give the amount of resources allocated to this object as parameter used, and the maximum amount that you want to see in floating garbage as parameter max. The units are arbitrary: the GC cares only about the ratio used / max.</source>
          <target state="translated">used と max の 2 つの引数は、GC に割り当てられているファイナライズされたブロックでどれだけの out-of-heap リソースが消費されているかのアイデアを与えます。単位は任意です:GC は、使用される比率/max だけを気にします。</target>
        </trans-unit>
        <trans-unit id="de645ad92a5669480afb7be4dd3aef35389b655e" translate="yes" xml:space="preserve">
          <source>The two components of a type definition, the optional equation and the optional representation, can be combined independently, giving rise to four typical situations:</source>
          <target state="translated">型定義の2つの構成要素である任意の式と任意の表現は、独立して組み合わせることができ、4つの典型的な状況を生み出します。</target>
        </trans-unit>
        <trans-unit id="ed0d501a57672abb475f57d2ac37627ee51ce36b" translate="yes" xml:space="preserve">
          <source>The two parameters used and max are used to control the speed of garbage collection when the finalized object contains pointers to out-of-heap resources. Generally speaking, the OCaml incremental major collector adjusts its speed relative to the allocation rate of the program. The faster the program allocates, the harder the GC works in order to reclaim quickly unreachable blocks and avoid having large amount of &amp;ldquo;floating garbage&amp;rdquo; (unreferenced objects that the GC has not yet collected).</source>
          <target state="translated">使用される2つのパラメーターとmaxは、ファイナライズされたオブジェクトにヒープ外のリソースへのポインターが含まれている場合に、ガベージコレクションの速度を制御するために使用されます。一般的に言えば、OCamlインクリメンタルメジャーコレクターは、プログラムの割り当て率に応じて速度を調整します。プログラムの割り当てが速いほど、到達不能なブロックをすばやく再利用し、大量の「フローティングガベージ」（GCがまだ収集していない参照されていないオブジェクト）が発生しないようにするために、GCの動作が難しくなります。</target>
        </trans-unit>
        <trans-unit id="1b4b8bfbffcea6080868e73fa6fa91ada3a5aee9" translate="yes" xml:space="preserve">
          <source>The type #&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; is a special kind of abbreviation. This abbreviation unifies with the type of any object belonging to a subclass of the class type &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;. It is handled in a special way as it usually hides a type variable (an ellipsis, representing the methods that may be added in a subclass). In particular, it vanishes when the ellipsis gets instantiated. Each type expression #&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; defines a new type variable, so type #&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;-&amp;gt;#&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; is usually not the same as type (#&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;as'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;) -&amp;gt;'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;.</source>
          <target state="translated">タイプ＃&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;は、特別な種類の省略形です。この省略形は、クラスタイプ&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-pathの&lt;/a&gt;サブクラスに属するオブジェクトのタイプと統合されます。通常、型変数（サブクラスに追加される可能性のあるメソッドを表す省略記号）を非表示にするため、特別な方法で処理されます。特に、省略記号がインスタンス化されると消えます。各タイプ式＃を&lt;a href=&quot;names#classtype-path&quot;&gt;するClassTypeパスは、&lt;/a&gt;式＃のように、新しいタイプの変数を定義&lt;a href=&quot;names#classtype-path&quot;&gt;するClassTypeパスが&lt;/a&gt;&amp;gt;＃1 -&lt;a href=&quot;names#classtype-path&quot;&gt;するClassTypeパスは、&lt;/a&gt;通常（＃型と同じではありません&lt;a href=&quot;names#classtype-path&quot;&gt;するClassTypeパス&lt;/a&gt;として&lt;a href=&quot;lex#ident&quot;&gt;IDENT&lt;/a&gt;） - &amp;gt;」&lt;a href=&quot;lex#ident&quot;&gt;IDENT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2098df733b38a624b57b6a1ed22bd572f1e7f4fb" translate="yes" xml:space="preserve">
          <source>The type &amp;lt; m : int &amp;gt; we see here is just the expansion of c, due to the use of a reference; we have succeeded in getting back an object of type c.</source>
          <target state="translated">ここに表示されるタイプ&amp;lt;m：int&amp;gt;は、参照を使用しているため、cの展開にすぎません。タイプcのオブジェクトを取り戻すことに成功しました。</target>
        </trans-unit>
        <trans-unit id="2cb5a55287de7cc9d410124fb3cd96a5d5e22f24" translate="yes" xml:space="preserve">
          <source>The type &amp;lt; {&lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt;;} ..&amp;gt; is the type of an object whose method names and types are described by &lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, and possibly some other methods represented by the ellipsis. This ellipsis actually is a special kind of type variable (called &lt;em&gt;row variable&lt;/em&gt; in the literature) that stands for any number of extra method types.</source>
          <target state="translated">タイプ&amp;lt;{ &lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt; ;} ..&amp;gt;は、メソッド名とタイプが&lt;a href=&quot;#method-type&quot;&gt;メソッドタイプ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、&amp;hellip;、&lt;a href=&quot;#method-type&quot;&gt;メソッドタイプ&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;、および場合によっては省略記号で表される他のいくつかのメソッドによって記述されるオブジェクトのタイプです。この省略記号は、実際には特別な種類の型変数（文献では&lt;em&gt;行変数&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;）であり、任意の数の追加のメソッド型を表します。</target>
        </trans-unit>
        <trans-unit id="ea78845a66a3de51237a6160ba5250e692cfe066" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;'a&amp;nbsp;t&lt;/code&gt; is a &lt;b&gt;delayed list&lt;/b&gt;, i.e. a list where some evaluation is needed to access the next element. This makes it possible to build infinite sequences, to build sequences as we traverse them, and to transform them in a lazy fashion rather than upfront.</source>
          <target state="translated">タイプ &lt;code&gt;'a&amp;nbsp;t&lt;/code&gt; は&lt;b&gt;遅延リスト&lt;/b&gt;、つまり次の要素にアクセスするために何らかの評価が必要なリストです。これにより、無限のシーケンスを構築し、それらをトラバースするときにシーケンスを構築し、前もってではなく怠惰な方法でそれらを変換することが可能になります。</target>
        </trans-unit>
        <trans-unit id="3e093dd6adec72b6cbeb6815ff6a81bdec059a25" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Genarray.t&lt;/code&gt; is the type of Bigarrays with variable numbers of dimensions.</source>
          <target state="translated">タイプ &lt;code&gt;Genarray.t&lt;/code&gt; は、可変数の次元を持つBigarrayのタイプです。</target>
        </trans-unit>
        <trans-unit id="c17aafa409f735e2a7fb7b2d3ed8979e96c9a297" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Genarray.t&lt;/code&gt; is the type of Bigarrays with variable numbers of dimensions. Any number of dimensions between 0 and 16 is supported.</source>
          <target state="translated">タイプ &lt;code&gt;Genarray.t&lt;/code&gt; は、可変数の次元を持つBigarrayのタイプです。0から16までの任意の数の次元がサポートされます。</target>
        </trans-unit>
        <trans-unit id="444bb838dc88582dbd178720dcfda52e51470b21" translate="yes" xml:space="preserve">
          <source>The type N.t is incompatible with int, ensuring that nonnegative integers and regular integers are not confused. However, if x has type N.t, the coercion (x :&amp;gt; int) is legal and returns the underlying integer, just like N.to_int x. Deep coercions are also supported: if l has type N.t list, the coercion (l :&amp;gt; int list) returns the list of underlying integers, like List.map N.to_int l but without copying the list l.</source>
          <target state="translated">タイプNtはintと互換性がないため、非負の整数と通常の整数が混同されません。ただし、xのタイプがNtの場合、強制（x：&amp;gt; int）は有効であり、N.to_int xと同様に、基になる整数を返します。ディープ強制もサポートされています。lの型がNtlistの場合、強制（l：&amp;gt; int list）は、List.map N.to_int lのように、リストlをコピーせずに、基になる整数のリストを返します。</target>
        </trans-unit>
        <trans-unit id="fa132651b99c1854c25fdf68be9f2ebc9e6e4a11" translate="yes" xml:space="preserve">
          <source>The type describing the status of an interval timer</source>
          <target state="translated">インターバルタイマの状態を記述するタイプ</target>
        </trans-unit>
        <trans-unit id="25486382c0973b8dd5baf2bfa2b12dda90d4ed79" translate="yes" xml:space="preserve">
          <source>The type error here comes from the fact that during the definition of depth, the type checker first assigns to depth the type 'a -&amp;gt; 'b . When typing the pattern matching, 'a -&amp;gt; 'b becomes 'a nested -&amp;gt; 'b, then 'a nested -&amp;gt; int once the List branch is typed. However, when typing the application depth n in the Nested branch, the type checker encounters a problem: depth n is applied to 'a list nested, it must therefore have the type 'a list nested -&amp;gt; 'b. Unifying this constraint with the previous one leads to the impossible constraint 'a list nested = 'a nested. In other words, within its definition, the recursive function depth is applied to values of type 'a t with different types 'a due to the non-regularity of the type constructor nested. This creates a problem because the type checker had introduced a new type variable 'a only at the &lt;em&gt;definition&lt;/em&gt; of the function depth whereas, here, we need a different type variable for every &lt;em&gt;application&lt;/em&gt; of the function depth.</source>
          <target state="translated">ここでのタイプエラーは、深さの定義中に、タイプチェッカーが最初にタイプ 'a-&amp;gt;' bを深さに割り当てるという事実に起因します。パターンマッチングを入力すると、 'a-&amp;gt;' bは 'ネストされた-&amp;gt;' bになり、リストブランチが入力されると 'ネストされた-&amp;gt; intになります。ただし、ネストされたブランチにアプリケーションの深さnを入力すると、タイプチェッカーで問題が発生します。深さnはネストされたリストに適用されるため、「リストがネストされたリスト」と入力する必要があります。この制約を前の制約と統合すると、不可能な制約 'ネストされたリスト='ネストされた制約になります。言い換えると、その定義内で、再帰関数の深さは、ネストされた型コンストラクターの不規則性のために、異なる型 'aを持つ型'の値に適用されます。型チェッカーが新しい型変数を導入したため、これは問題を引き起こします。&lt;em&gt;&lt;/em&gt;関数深度の&lt;em&gt;定義&lt;/em&gt;ですが、ここでは、関数深度の&lt;em&gt;アプリケーション&lt;/em&gt;ごとに異なる型変数が必要です。</target>
        </trans-unit>
        <trans-unit id="1fa9c8aa5ef431c67c6adbd4b206fd03f62c7ba9" translate="yes" xml:space="preserve">
          <source>The type expression '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; stands for the type variable named &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;. The type expression _ stands for either an anonymous type variable or anonymous type parameters. In data type definitions, type variables are names for the data type parameters. In type constraints, they represent unspecified types that can be instantiated by any type to satisfy the type constraint. In general the scope of a named type variable is the whole top-level phrase where it appears, and it can only be generalized when leaving this scope. Anonymous variables have no such restriction. In the following cases, the scope of named type variables is restricted to the type expression where they appear: 1) for universal (explicitly polymorphic) type variables; 2) for type variables that only appear in public method specifications (as those variables will be made universal, as described in section &lt;a href=&quot;classes#sss%3Aclty-meth&quot;&gt;7.9.1&lt;/a&gt;); 3) for variables used as aliases, when the type they are aliased to would be invalid in the scope of the enclosing definition (i.e. when it contains free universal type variables, or locally defined types.)</source>
          <target state="translated">型式 ' &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;は、&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;という名前の型変数を表します。型式_は、匿名型変数または匿名型パラメーターのいずれかを表します。データ型定義では、型変数はデータ型パラメーターの名前です。タイプ制約では、タイプ制約を満たすために任意のタイプでインスタンス化できる未指定のタイプを表します。一般に、名前付き型変数のスコープは、それが表示される最上位のフレーズ全体であり、このスコープを離れるときにのみ一般化できます。匿名変数にはそのような制限はありません。以下の場合、名前付き型変数のスコープは、それらが現れる型式に制限されます。1）ユニバーサル（明示的にポリモーフィック）型変数の場合。 2）パブリックメソッド仕様にのみ表示される型変数の場合（セクション&lt;a href=&quot;classes#sss%3Aclty-meth&quot;&gt;7.9.1で&lt;/a&gt;説明されているように、これらの変数はユニバーサルになるため））; 3）エイリアスとして使用される変数の場合、エイリアスされるタイプが、囲んでいる定義のスコープ内で無効になる場合（つまり、無料のユニバーサルタイプ変数またはローカルで定義されたタイプが含まれる場合）。</target>
        </trans-unit>
        <trans-unit id="b361863db6506eaaf72bc73833dd7a710012beed" translate="yes" xml:space="preserve">
          <source>The type expression (&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;) denotes the same type as &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;.</source>
          <target state="translated">型式（&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;）は、&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;と同じ型を示します。</target>
        </trans-unit>
        <trans-unit id="caf716551ec1bcc30d2653d9a50db98a601e3996" translate="yes" xml:space="preserve">
          <source>The type expression (&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;,&amp;hellip;, &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;) &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;, where &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; is a type constructor with n parameters, denotes the application of the n-ary type constructor &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; to the types &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; through &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">タイプ式（&lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、...、&lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt;）&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;、&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstrは、&lt;/a&gt; n個のパラメータを有するタイプのコンストラクタでは、n進型コンストラクタのアプリケーション示し&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;タイプに&lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;スルー&lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;nは&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="6b1267fea7ae64838d1130ee8c9de538451b3845" translate="yes" xml:space="preserve">
          <source>The type expression &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;, where &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; is a type constructor with one parameter, denotes the application of the unary type constructor &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; to the type &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;.</source>
          <target state="translated">タイプ式&lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;、&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstrは&lt;/a&gt;つのパラメータを有するタイプのコンストラクタでは、単項型コンストラクタのアプリケーション示し&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;型に&lt;a href=&quot;#typexpr&quot;&gt;typexprを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="134280a727f04e70e93aab40360430e6a4a2edfe" translate="yes" xml:space="preserve">
          <source>The type expression &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;* &amp;hellip; *&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; denotes the type of tuples whose elements belong to types &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; respectively.</source>
          <target state="translated">タイプ式&lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; * ... * &lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n個&lt;/sub&gt;の要素タイプに属するタプルのタイプ意味&lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、... &lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;nは&lt;/sub&gt;それぞれ。</target>
        </trans-unit>
        <trans-unit id="fd49bc22f7c62d9c4ae3e943e6b56abafe95d35b" translate="yes" xml:space="preserve">
          <source>The type expression &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; denotes the type of functions mapping arguments of type &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to results of type &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="translated">型発現&lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; - &amp;gt; &lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;タイプの引数をマッピング関数の意味型&lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;種類の結果に&lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="48f68ff9fb1de19b9947374a080e92592e2bffa5" translate="yes" xml:space="preserve">
          <source>The type expression &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;as'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; denotes the same type as &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;, and also binds the type variable &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; to type &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; both in &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; and in other types. In general the scope of an alias is the same as for a named type variable, and covers the whole enclosing definition. If the type variable &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; actually occurs in &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;, a recursive type is created. Recursive types for which there exists a recursive path that does not contain an object or polymorphic variant type constructor are rejected, except when the -rectypes mode is selected.</source>
          <target state="translated">型発現&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;として&lt;a href=&quot;lex#ident&quot;&gt;IDENTが&lt;/a&gt;同じタイプを示し&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;、また、型変数の結合&lt;a href=&quot;lex#ident&quot;&gt;IDENT&lt;/a&gt;タイプを&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;に両方&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;および他のタイプです。一般に、エイリアスのスコープは名前付き型変数のスコープと同じであり、囲んでいる定義全体をカバーします。型変数&lt;a href=&quot;lex#ident&quot;&gt;identが&lt;/a&gt;実際に&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;で発生する場合、再帰型が作成されます。-rectypesモードが選択されている場合を除き、オブジェクトまたはポリモーフィックバリアント型コンストラクターを含まない再帰パスが存在する再帰型は拒否されます。</target>
        </trans-unit>
        <trans-unit id="c6801841411231abefa49731a3af05dc93c2d6bf" translate="yes" xml:space="preserve">
          <source>The type for Unicode characters.</source>
          <target state="translated">Unicode文字のタイプです。</target>
        </trans-unit>
        <trans-unit id="7710723d784526bfd14ff8684cd4f3768c3a88c0" translate="yes" xml:space="preserve">
          <source>The type for integer values.</source>
          <target state="translated">整数値の型です。</target>
        </trans-unit>
        <trans-unit id="9382d7daf14dbc0dd9ad2ac68253c35ad1396cc7" translate="yes" xml:space="preserve">
          <source>The type for option values.</source>
          <target state="translated">オプション値の型。</target>
        </trans-unit>
        <trans-unit id="f5d8396849b8d6781e4d124b104e7abf0c738fb9" translate="yes" xml:space="preserve">
          <source>The type for option values. Either &lt;code&gt;None&lt;/code&gt; or a value &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt;.</source>
          <target state="translated">オプション値のタイプ。どちらか &lt;code&gt;None&lt;/code&gt; か、値 &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d6a4f1c52488e6ba5ba76a0aea28a22e82a6300" translate="yes" xml:space="preserve">
          <source>The type for result values.</source>
          <target state="translated">結果値の型です。</target>
        </trans-unit>
        <trans-unit id="93ce0c547a2cc6ec0a54327ae4897e498aad029d" translate="yes" xml:space="preserve">
          <source>The type for result values. Either a value &lt;code&gt;Ok&amp;nbsp;v&lt;/code&gt; or an error &lt;code&gt;Error&amp;nbsp;e&lt;/code&gt;.</source>
          <target state="translated">結果値のタイプ。値 &lt;code&gt;Ok&amp;nbsp;v&lt;/code&gt; またはエラー &lt;code&gt;Error&amp;nbsp;e&lt;/code&gt; いずれか。</target>
        </trans-unit>
        <trans-unit id="5c0b6a8e9537b83d5facebd9c46c52d219d5b39a" translate="yes" xml:space="preserve">
          <source>The type inferred for sort, 'a list -&amp;gt; 'a list, means that sort can actually apply to lists of any type, and returns a list of the same type. The type 'a is a &lt;em&gt;type variable&lt;/em&gt;, and stands for any given type. The reason why sort can apply to lists of any type is that the comparisons (=, &amp;lt;=, etc.) are &lt;em&gt;polymorphic&lt;/em&gt; in OCaml: they operate between any two values of the same type. This makes sort itself polymorphic over all list types.</source>
          <target state="translated">ソートのために推測されるタイプ、「リスト-&amp;gt;」リストは、ソートが実際に任意のタイプのリストに適用できることを意味し、同じタイプのリストを返します。タイプ 'aは&lt;em&gt;タイプ変数&lt;/em&gt;であり、任意のタイプを表します。ソートが任意のタイプのリストに適用できる理由は、比較（=、&amp;lt;=など）がOCamlでは&lt;em&gt;多形&lt;/em&gt;であるためです。それらは同じタイプの任意の2つの値の間で機能します。これにより、すべてのリストタイプでソート自体が多態的になります。</target>
        </trans-unit>
        <trans-unit id="9c08084fecb7e84be89d27f0d722611fa9cc32c8" translate="yes" xml:space="preserve">
          <source>The type name must be implemented by a type compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;. All users of the structure know that the type name is compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;.</source>
          <target state="translated">タイプ名は、&lt;a href=&quot;types#typexpr&quot;&gt;typexprと&lt;/a&gt;互換性のあるタイプで実装する必要があります。構造体のすべてのユーザーは、型名が&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;と互換性があることを知っています。</target>
        </trans-unit>
        <trans-unit id="3ebe16a502ab193556c30fa1d8f9ab51fb2a92a2" translate="yes" xml:space="preserve">
          <source>The type name must be implemented by a variant type or record type with exactly the constructors or fields specified. All users of the structure have access to the constructors or fields, and can use them to create or inspect values of that type. However, users of the structure consider that type as incompatible with any other type: a fresh type has been generated.</source>
          <target state="translated">型名は、指定されたコンストラクタまたはフィールドを正確に持つバリアント型またはレコード型によって実装されなければなりません。構造体のすべてのユーザはコンストラクタやフィールドにアクセスでき、その型の値を作成したり検査したりするためにそれらを使うことができます。しかし,構造体のユーザは,その型を他の型と互換性がないものとみなします:新しい型が生成されました。</target>
        </trans-unit>
        <trans-unit id="95162088ecc49c178a74b8a108f2f06d181cf540" translate="yes" xml:space="preserve">
          <source>The type of (read-only) character strings.</source>
          <target state="translated">(読み取り専用の)文字列の型。</target>
        </trans-unit>
        <trans-unit id="0cb54904d6ce772d0ceeac1ee805267485217e2e" translate="yes" xml:space="preserve">
          <source>The type of (writable) byte sequences.</source>
          <target state="translated">(書き込み可能な)バイト列の型。</target>
        </trans-unit>
        <trans-unit id="175f1511e76274de17f3f982e04261ad9ff87edf" translate="yes" xml:space="preserve">
          <source>The type of Oo.copy is the following:</source>
          <target state="translated">Oo.copyの種類は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="ed9cbb3bbfa2f749813e7746851407d1f9f2830e" translate="yes" xml:space="preserve">
          <source>The type of PRNG states.</source>
          <target state="translated">PRNG状態の種類。</target>
        </trans-unit>
        <trans-unit id="31f3bef48e012323310e56008b546bd70a23ee79" translate="yes" xml:space="preserve">
          <source>The type of a generator module depends on the kind of generated documentation. Here is the list of generator module types, with the name of the generator class in the module :</source>
          <target state="translated">ジェネレータ・モジュールのタイプは、生成されるドキュメントの種類に依存します。ここでは、ジェネレータ・モジュールのタイプのリストを、モジュール内のジェネレータ・クラスの名前とともに示します。</target>
        </trans-unit>
        <trans-unit id="474468ccde94e04dc6d84d6aa522d6290591ae8e" translate="yes" xml:space="preserve">
          <source>The type of arrays of weak pointers (weak arrays).</source>
          <target state="translated">弱いポインタの配列(弱い配列)の型。</target>
        </trans-unit>
        <trans-unit id="49335a2fa0da36592772610d625d9e7862131665" translate="yes" xml:space="preserve">
          <source>The type of arrays of weak pointers (weak arrays). A weak pointer is a value that the garbage collector may erase whenever the value is not used any more (through normal pointers) by the program. Note that finalisation functions are run before the weak pointers are erased, because the finalisation functions can make values alive again (before 4.03 the finalisation functions were run after).</source>
          <target state="translated">弱いポインタの配列(弱い配列)の型です。弱いポインタは、その値がプログラムによって(通常のポインタを通して)これ以上使われなくなったときに、ガベージコレクタが消去することができる値です。弱いポインタが消去される前に最終化関数が実行されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b2b210af5769dfe8a33b57a953fcf512009f49e6" translate="yes" xml:space="preserve">
          <source>The type of arrays whose elements have type 'a.</source>
          <target state="translated">要素の型が 'a' である配列の型。</target>
        </trans-unit>
        <trans-unit id="0595a4cfa984f250f4abe368aae01bbd26bbe40a" translate="yes" xml:space="preserve">
          <source>The type of booleans (truth values).</source>
          <target state="translated">ブーリアン(真理値)の型。</target>
        </trans-unit>
        <trans-unit id="57f43364adb027e8e1ba3b2312688a97e5a4bfee" translate="yes" xml:space="preserve">
          <source>The type of characters.</source>
          <target state="translated">登場人物の種類。</target>
        </trans-unit>
        <trans-unit id="8faa31d4f6bd583eef19e62cfd7cf4d795b85cb0" translate="yes" xml:space="preserve">
          <source>The type of commands for &lt;code&gt;shutdown&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shutdown&lt;/code&gt; 用のコマンドのタイプ。</target>
        </trans-unit>
        <trans-unit id="3b3f99b8924ec20003595b05b507f3dd92f84242" translate="yes" xml:space="preserve">
          <source>The type of communication channels carrying values of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;'a&lt;/code&gt; の値を伝送する通信チャネルのタイプ。</target>
        </trans-unit>
        <trans-unit id="e4bee64553824e660fa6229cc5c7107b80d346c9" translate="yes" xml:space="preserve">
          <source>The type of communication events returning a result of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;'a&lt;/code&gt; の結果を返す通信イベントのタイプ。</target>
        </trans-unit>
        <trans-unit id="4694bbb21fec365f7f23def5ef3c32491f195566" translate="yes" xml:space="preserve">
          <source>The type of compiled regular expressions.</source>
          <target state="translated">コンパイルされた正規表現の型。</target>
        </trans-unit>
        <trans-unit id="cf94d66ebaa6a6bac9b3992799eba28dae304024" translate="yes" xml:space="preserve">
          <source>The type of complex numbers.</source>
          <target state="translated">複素数の種類。</target>
        </trans-unit>
        <trans-unit id="9493cdeccb2ee09d3bbc2192a85ea88bdc22d219" translate="yes" xml:space="preserve">
          <source>The type of complex numbers. &lt;code&gt;re&lt;/code&gt; is the real part and &lt;code&gt;im&lt;/code&gt; the imaginary part.</source>
          <target state="translated">複素数のタイプ。 &lt;code&gt;re&lt;/code&gt; は実数部であり、 &lt;code&gt;im&lt;/code&gt; は虚数部です。</target>
        </trans-unit>
        <trans-unit id="a919227d85c7433279106182e9342eaf933551d4" translate="yes" xml:space="preserve">
          <source>The type of condition variables.</source>
          <target state="translated">条件変数の種類です。</target>
        </trans-unit>
        <trans-unit id="2948f756f59cbab66ed838f1fd09d9a51206608c" translate="yes" xml:space="preserve">
          <source>The type of delayed lists containing elements of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;'a&lt;/code&gt; の要素を含む遅延リストのタイプ。</target>
        </trans-unit>
        <trans-unit id="19b1cace17bd70c1c864fc3ccf8d84d6aeafa3b9" translate="yes" xml:space="preserve">
          <source>The type of delayed lists containing elements of type &lt;code&gt;'a&lt;/code&gt;. Note that the concrete list node &lt;code&gt;'a&amp;nbsp;node&lt;/code&gt; is delayed under a closure, not a &lt;code&gt;lazy&lt;/code&gt; block, which means it might be recomputed every time we access it.</source>
          <target state="translated">タイプ &lt;code&gt;'a&lt;/code&gt; の要素を含む遅延リストのタイプ。具体的なリストノード &lt;code&gt;'a&amp;nbsp;node&lt;/code&gt; は、 &lt;code&gt;lazy&lt;/code&gt; ブロックではなく、クロージャの下で遅延することに注意してください。つまり、アクセスするたびに再計算される可能性があります。</target>
        </trans-unit>
        <trans-unit id="528bf9052fce3ac6805ffa892e89bbfb27784ec6" translate="yes" xml:space="preserve">
          <source>The type of descriptors over opened directories.</source>
          <target state="translated">開かれたディレクトリの上にあるディスクリプタの種類。</target>
        </trans-unit>
        <trans-unit id="416a1434458aaedb356cff26edc4284a6edf9ec7" translate="yes" xml:space="preserve">
          <source>The type of digests: 16-character strings.</source>
          <target state="translated">ダイジェストの種類。16文字の文字列。</target>
        </trans-unit>
        <trans-unit id="ed7f6fa3fdb11f6e5f157b97ab1334e5206abde6" translate="yes" xml:space="preserve">
          <source>The type of error codes.</source>
          <target state="translated">エラーコードの種類です。</target>
        </trans-unit>
        <trans-unit id="374429438a468e5405acbf7c3ebd3a8090be7716" translate="yes" xml:space="preserve">
          <source>The type of error codes. Errors defined in the POSIX standard and additional errors from UNIX98 and BSD. All other errors are mapped to EUNKNOWNERR.</source>
          <target state="translated">エラーコードの種類。POSIX 標準で定義されているエラーと、UNIX98 および BSD からの追加エラー。その他のすべてのエラーは EUNKNOWNERR にマップされます。</target>
        </trans-unit>
        <trans-unit id="90aa20107e0953510225d3286a9c720778df2ae3" translate="yes" xml:space="preserve">
          <source>The type of exception values.</source>
          <target state="translated">例外値の種類です。</target>
        </trans-unit>
        <trans-unit id="6d9a06fd1a883a7ff59af6a47cff3a54b165e238" translate="yes" xml:space="preserve">
          <source>The type of file access rights, e.g.</source>
          <target state="translated">ファイルアクセス権の種類、例えば</target>
        </trans-unit>
        <trans-unit id="c7a1b61ab121d17826ae99852665f41b9088bb6f" translate="yes" xml:space="preserve">
          <source>The type of file access rights, e.g. &lt;code&gt;0o640&lt;/code&gt; is read and write for user, read for group, none for others</source>
          <target state="translated">ファイルアクセス権のタイプ。たとえば、 &lt;code&gt;0o640&lt;/code&gt; はユーザーに対して読み取りと書き込み、グループに対して読み取り、その他に対してはなし</target>
        </trans-unit>
        <trans-unit id="dd46f8d4353ac7fec53695a7079f8ba6a127a094" translate="yes" xml:space="preserve">
          <source>The type of float arrays with packed representation.</source>
          <target state="translated">パック表現のfloat配列の型です。</target>
        </trans-unit>
        <trans-unit id="1ae512fb6e68d577ece237ab0b35021285c8a32b" translate="yes" xml:space="preserve">
          <source>The type of floating-point numbers.</source>
          <target state="translated">浮動小数点数の型。</target>
        </trans-unit>
        <trans-unit id="882f6167872619af22e623d191dbe06d50c3e5c8" translate="yes" xml:space="preserve">
          <source>The type of format strings. 'a is the type of the parameters of the format, 'f is the result type for the printf-style functions, 'b is the type of the first argument given to %a and %t printing functions (see module &lt;a href=&quot;libref/printf&quot;&gt;Printf&lt;/a&gt;), 'c is the result type of these functions, and also the type of the argument transmitted to the first argument of kprintf-style functions, 'd is the result type for the scanf-style functions (see module &lt;a href=&quot;libref/scanf&quot;&gt;Scanf&lt;/a&gt;), and 'e is the type of the receiver function for the scanf-style functions.</source>
          <target state="translated">フォーマット文字列のタイプ。'aはフォーマットのパラメーターのタイプ、' fはprintfスタイル関数の結果タイプ、 'bは％aおよび％t印刷関数に指定された最初の引数のタイプ（モジュール&lt;a href=&quot;libref/printf&quot;&gt;Printfを&lt;/a&gt;参照）' cはこれらの関数の結果タイプであり、kprintfスタイル関数の最初の引数に送信される引数のタイプでもあります。'dはscanfスタイル関数の結果タイプ（モジュール&lt;a href=&quot;libref/scanf&quot;&gt;Scanfを&lt;/a&gt;参照）、 'eはscanfスタイル関数のレシーバー関数のタイプ。</target>
        </trans-unit>
        <trans-unit id="19c398a9ad6d40134bc9da4aab8cb49e3ed44b56" translate="yes" xml:space="preserve">
          <source>The type of formatted input scanners: &lt;code&gt;('a,&amp;nbsp;'b,&amp;nbsp;'c,&amp;nbsp;'d)&amp;nbsp;scanner&lt;/code&gt; is the type of a formatted input function that reads from some formatted input channel according to some format string; more precisely, if &lt;code&gt;scan&lt;/code&gt; is some formatted input function, then &lt;code&gt;scan&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ic&amp;nbsp;fmt&amp;nbsp;f&lt;/code&gt; applies &lt;code&gt;f&lt;/code&gt; to all the arguments specified by format string &lt;code&gt;fmt&lt;/code&gt;, when &lt;code&gt;scan&lt;/code&gt; has read those arguments from the &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt; formatted input channel &lt;code&gt;ic&lt;/code&gt;.</source>
          <target state="translated">フォーマットされた入力スキャナーのタイプ：（ &lt;code&gt;('a,&amp;nbsp;'b,&amp;nbsp;'c,&amp;nbsp;'d)&amp;nbsp;scanner&lt;/code&gt; は、フォーマットされた入力チャネルからフォーマット文字列に従って読み取るフォーマットされた入力関数のタイプです。場合は、より正確には、 &lt;code&gt;scan&lt;/code&gt; 、いくつかのフォーマットの入力関数であり、その後、 &lt;code&gt;scan&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ic&amp;nbsp;fmt&amp;nbsp;f&lt;/code&gt; 適用 &lt;code&gt;f&lt;/code&gt; すべての引数にフォーマット文字列で指定された &lt;code&gt;fmt&lt;/code&gt; 場合、 &lt;code&gt;scan&lt;/code&gt; からそれらの引数を読み取った&lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt; &lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt; &lt;/a&gt;入力チャネルフォーマット &lt;code&gt;ic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aea5a1b18ac88613e37414b6827c2703455101bb" translate="yes" xml:space="preserve">
          <source>The type of hash tables from type &lt;code&gt;'a&lt;/code&gt; to type &lt;code&gt;'b&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;'a&lt;/code&gt; からタイプ &lt;code&gt;'b&lt;/code&gt; までのハッシュテーブルのタイプ。</target>
        </trans-unit>
        <trans-unit id="696255785a919ef1978b95f3b810845f1d5f24f3" translate="yes" xml:space="preserve">
          <source>The type of input channel.</source>
          <target state="translated">入力チャンネルの種類です。</target>
        </trans-unit>
        <trans-unit id="2733bfc9210840c12ac529e5664090014cfaed19" translate="yes" xml:space="preserve">
          <source>The type of integer numbers.</source>
          <target state="translated">整数の種類です。</target>
        </trans-unit>
        <trans-unit id="12a16543916e281f6e705178f7068ae7b81eabd0" translate="yes" xml:space="preserve">
          <source>The type of lexer buffers.</source>
          <target state="translated">レクサーバッファの種類です。</target>
        </trans-unit>
        <trans-unit id="9e6ff741c03d54a16b116276f6d1b7c29c419556" translate="yes" xml:space="preserve">
          <source>The type of lexer buffers. A lexer buffer is the argument passed to the scanning functions defined by the generated scanners. The lexer buffer holds the current state of the scanner, plus a function to refill the buffer from the input.</source>
          <target state="translated">レキサーバッファの種類です。レキサーバッファは、生成されたスキャナによって定義された走査関数に渡される引数です。レクサーバッファはスキャナの現在の状態を保持し、さらに入力からバッファを補充する関数を保持します。</target>
        </trans-unit>
        <trans-unit id="6b78930ebe1ff9598f2ce1e960c8d2f960ca9edd" translate="yes" xml:space="preserve">
          <source>The type of lists whose elements have type 'a.</source>
          <target state="translated">要素の型が 'a' であるリストの型。</target>
        </trans-unit>
        <trans-unit id="0f4c8fdad1b3bd84e4c3cca78b35e83c55b502de" translate="yes" xml:space="preserve">
          <source>The type of location information found in backtraces.</source>
          <target state="translated">バックトレースで見つけた位置情報の種類。</target>
        </trans-unit>
        <trans-unit id="498bd9a851a6cfafcb8f5766233f38fdc36ca792" translate="yes" xml:space="preserve">
          <source>The type of location information found in backtraces. &lt;code&gt;start_char&lt;/code&gt; and &lt;code&gt;end_char&lt;/code&gt; are positions relative to the beginning of the line.</source>
          <target state="translated">バックトレースで見つかった位置情報のタイプ。 &lt;code&gt;start_char&lt;/code&gt; と &lt;code&gt;end_char&lt;/code&gt; は、行の先頭を基準にした位置です。</target>
        </trans-unit>
        <trans-unit id="ed706b6a75175b21f33900096f47f5ce25dcd56f" translate="yes" xml:space="preserve">
          <source>The type of maps from type &lt;code&gt;key&lt;/code&gt; to type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;key&lt;/code&gt; からタイプ &lt;code&gt;'a&lt;/code&gt; へのマップのタイプ。</target>
        </trans-unit>
        <trans-unit id="5234180ce852e2c9add54e2a43fe30af56ce71bf" translate="yes" xml:space="preserve">
          <source>The type of metadata associated with allocations.</source>
          <target state="translated">割り当てに関連付けられたメタデータの種類。</target>
        </trans-unit>
        <trans-unit id="2a7ce6248520399ff389ae062f84b764cade9171" translate="yes" xml:space="preserve">
          <source>The type of metadata associated with allocations. This is the type of records passed to the callback triggered by the sampling of an allocation.</source>
          <target state="translated">アロケーションに関連付けられたメタデータのタイプです。これは、アロケーションのサンプリングによってトリガーされたコールバックに渡されるレコードのタイプです。</target>
        </trans-unit>
        <trans-unit id="c1e287e9bbc376eb420f29d58e9d26ead8ee6aa7" translate="yes" xml:space="preserve">
          <source>The type of mutexes.</source>
          <target state="translated">ミューテックスの種類です。</target>
        </trans-unit>
        <trans-unit id="74a3a571763275675b862ae9f296a04facfd9dc7" translate="yes" xml:space="preserve">
          <source>The type of one-dimensional Bigarrays whose elements have OCaml type &lt;code&gt;'a&lt;/code&gt;, representation kind &lt;code&gt;'b&lt;/code&gt;, and memory layout &lt;code&gt;'c&lt;/code&gt;.</source>
          <target state="translated">要素がOCamlタイプ &lt;code&gt;'a&lt;/code&gt; 、表現の種類 &lt;code&gt;'b&lt;/code&gt; 、およびメモリレイアウト &lt;code&gt;'c&lt;/code&gt; を持つ1次元Bigarrayのタイプ。</target>
        </trans-unit>
        <trans-unit id="427b82aee3c183b2b5534df6717057b224234245" translate="yes" xml:space="preserve">
          <source>The type of optional values of type 'a.</source>
          <target state="translated">'a型のオプション値の型。</target>
        </trans-unit>
        <trans-unit id="a247986af85700af0514a9a8547e14b281ce0624" translate="yes" xml:space="preserve">
          <source>The type of output channel.</source>
          <target state="translated">出力チャンネルの種類です。</target>
        </trans-unit>
        <trans-unit id="bb4593e8016738b30531d3a2d698c5003680100a" translate="yes" xml:space="preserve">
          <source>The type of queues containing elements of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;'a&lt;/code&gt; の要素を含むキューのタイプ。</target>
        </trans-unit>
        <trans-unit id="2ed3d947a75f974c4a636eeee9cca0bdcea8439d" translate="yes" xml:space="preserve">
          <source>The type of references (mutable indirection cells) containing a value of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;'a&lt;/code&gt; の値を含む参照のタイプ（可変間接セル）。</target>
        </trans-unit>
        <trans-unit id="0c47f9a8e4ac2d5a708feb705e0eb216916eb90e" translate="yes" xml:space="preserve">
          <source>The type of scanning buffers.</source>
          <target state="translated">走査バッファの種類です。</target>
        </trans-unit>
        <trans-unit id="641cb810f5f62717bfd7cda0a11b14f8777c6464" translate="yes" xml:space="preserve">
          <source>The type of scanning buffers. A scanning buffer is the source from which a formatted input function gets characters. The scanning buffer holds the current state of the scan, plus a function to get the next char from the input, and a token buffer to store the string matched so far.</source>
          <target state="translated">スキャニングバッファの種類です。スキャニングバッファは、フォーマットされた入力関数が文字を取得するソースです。スキャンバッファは、スキャンの現在の状態に加えて、入力から次の文字を取得する関数と、これまでにマッチした文字列を格納するトークンバッファを保持しています。</target>
        </trans-unit>
        <trans-unit id="2da9a74d002d27ad159cff07bde988e8e266d179" translate="yes" xml:space="preserve">
          <source>The type of sets.</source>
          <target state="translated">セットの種類です。</target>
        </trans-unit>
        <trans-unit id="00e670e3a2a21e4cdf70bf2240d4a5a94082c733" translate="yes" xml:space="preserve">
          <source>The type of signed 32-bit integers. Literals for 32-bit integers are suffixed by l. See the &lt;a href=&quot;libref/int32&quot;&gt;Int32&lt;/a&gt; module.</source>
          <target state="translated">符号付き32ビット整数のタイプ。32ビット整数のリテラルの接尾辞はlです。&lt;a href=&quot;libref/int32&quot;&gt;Int32&lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="049aa2f5e1bceacd2dc3e7900753d299e293a211" translate="yes" xml:space="preserve">
          <source>The type of signed 64-bit integers. Literals for 64-bit integers are suffixed by L. See the &lt;a href=&quot;libref/int64&quot;&gt;Int64&lt;/a&gt; module.</source>
          <target state="translated">符号付き64ビット整数のタイプ。64ビット整数のリテラルの接尾辞はLです&lt;a href=&quot;libref/int64&quot;&gt;。Int64&lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="14572b24035765d23bfc1ab5989635cd85be76c9" translate="yes" xml:space="preserve">
          <source>The type of signed, platform-native integers (32 bits on 32-bit processors, 64 bits on 64-bit processors). Literals for native integers are suffixed by n. See the &lt;a href=&quot;libref/nativeint&quot;&gt;Nativeint&lt;/a&gt; module.</source>
          <target state="translated">符号付きのプラットフォームネイティブ整数のタイプ（32ビットプロセッサでは32ビット、64ビットプロセッサでは64ビット）。ネイティブ整数のリテラルには、接尾辞nが付いています。&lt;a href=&quot;libref/nativeint&quot;&gt;Nativeint&lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="de5b2958f6bf6b0150e2e607a78d659c4f79eb05" translate="yes" xml:space="preserve">
          <source>The type of socket addresses.</source>
          <target state="translated">ソケットアドレスの種類。</target>
        </trans-unit>
        <trans-unit id="db586c580808d7d4b0a9c2a68894ac1deac9713a" translate="yes" xml:space="preserve">
          <source>The type of socket addresses. &lt;code&gt;ADDR_UNIX&amp;nbsp;name&lt;/code&gt; is a socket address in the Unix domain; &lt;code&gt;name&lt;/code&gt; is a file name in the file system. &lt;code&gt;ADDR_INET(addr,port)&lt;/code&gt; is a socket address in the Internet domain; &lt;code&gt;addr&lt;/code&gt; is the Internet address of the machine, and &lt;code&gt;port&lt;/code&gt; is the port number.</source>
          <target state="translated">ソケットアドレスのタイプ。 &lt;code&gt;ADDR_UNIX&amp;nbsp;name&lt;/code&gt; は、Unixドメインのソケットアドレスです。 &lt;code&gt;name&lt;/code&gt; は、ファイルシステム内のファイル名です。 &lt;code&gt;ADDR_INET(addr,port)&lt;/code&gt; は、インターネットドメインのソケットアドレスです。 &lt;code&gt;addr&lt;/code&gt; はマシンのインターネットアドレスであり、 &lt;code&gt;port&lt;/code&gt; はポート番号です。</target>
        </trans-unit>
        <trans-unit id="608407eaec3033fe97cbe414b0ad430f843c8db2" translate="yes" xml:space="preserve">
          <source>The type of socket domains.</source>
          <target state="translated">ソケットドメインの種類です。</target>
        </trans-unit>
        <trans-unit id="57d14d79c33e13c0f239ad5001df98545855ce4a" translate="yes" xml:space="preserve">
          <source>The type of socket domains. Not all platforms support IPv6 sockets (type &lt;code&gt;PF_INET6&lt;/code&gt;).</source>
          <target state="translated">ソケットドメインのタイプ。すべてのプラットフォームがIPv6ソケット（タイプ &lt;code&gt;PF_INET6&lt;/code&gt; ）をサポートしているわけではありません。</target>
        </trans-unit>
        <trans-unit id="5b519e0b22d95beab7899e8dfff601ea38a0a80e" translate="yes" xml:space="preserve">
          <source>The type of socket domains. Not all platforms support IPv6 sockets (type &lt;code&gt;PF_INET6&lt;/code&gt;). Windows does not support &lt;code&gt;PF_UNIX&lt;/code&gt;.</source>
          <target state="translated">ソケットドメインのタイプ。すべてのプラットフォームがIPv6ソケット（タイプ &lt;code&gt;PF_INET6&lt;/code&gt; ）をサポートしているわけではありません。Windowsは &lt;code&gt;PF_UNIX&lt;/code&gt; をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="2727d81576dab1fb5a38c8713ea564ef66856040" translate="yes" xml:space="preserve">
          <source>The type of socket kinds, specifying the semantics of communications.</source>
          <target state="translated">通信のセマンティクスを指定するソケットの種類。</target>
        </trans-unit>
        <trans-unit id="1b3007fcdc44e3284ad3118e0dffc7d71aaf743c" translate="yes" xml:space="preserve">
          <source>The type of socket kinds, specifying the semantics of communications. &lt;code&gt;SOCK_SEQPACKET&lt;/code&gt; is included for completeness, but is rarely supported by the OS, and needs system calls that are not available in this library.</source>
          <target state="translated">通信のセマンティクスを指定するソケットの種類のタイプ。 &lt;code&gt;SOCK_SEQPACKET&lt;/code&gt; は完全を期すために含まれていますが、OSでサポートされることはめったになく、このライブラリでは使用できないシステムコールが必要です。</target>
        </trans-unit>
        <trans-unit id="156e03b4fa592223c0c98868c0491cee08f03432" translate="yes" xml:space="preserve">
          <source>The type of stacks containing elements of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;'a&lt;/code&gt; の要素を含むスタックのタイプ。</target>
        </trans-unit>
        <trans-unit id="3f65d04f78e3ceb4ae3eccd621111d1fffe7fea7" translate="yes" xml:space="preserve">
          <source>The type of streams holding values of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;'a&lt;/code&gt; の値を保持するストリームのタイプ。</target>
        </trans-unit>
        <trans-unit id="6765ffbd6cdd35348726a7b361a85542a02c62ba" translate="yes" xml:space="preserve">
          <source>The type of tables that contain elements of type &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 型の要素を含むテーブルの型。</target>
        </trans-unit>
        <trans-unit id="d36f05d8ed34a2aeecd6a307e47d3388f2f3349d" translate="yes" xml:space="preserve">
          <source>The type of tables that contain elements of type &lt;code&gt;data&lt;/code&gt;. Note that weak hash sets cannot be marshaled using &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt;&lt;code&gt;output_value&lt;/code&gt;&lt;/a&gt; or the functions of the &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 型の要素を含むテーブルの型。弱いハッシュセットは、&lt;a href=&quot;stdlib#VALoutput_value&quot;&gt; &lt;code&gt;output_value&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;marshal&quot;&gt; &lt;code&gt;Marshal&lt;/code&gt; &lt;/a&gt;モジュールの関数を使用してマーシャリングできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="376291c83380bfe855667ba5075e67da3fc440d1" translate="yes" xml:space="preserve">
          <source>The type of the elements stored in the table.</source>
          <target state="translated">テーブルに格納されている要素の種類。</target>
        </trans-unit>
        <trans-unit id="27a01f06c2807810d54d563bff488d148e91f692" translate="yes" xml:space="preserve">
          <source>The type of the hashtable keys.</source>
          <target state="translated">ハッシュテーブルのキーの種類。</target>
        </trans-unit>
        <trans-unit id="419849ba8c429fc85eb7b7159392b7645493c383" translate="yes" xml:space="preserve">
          <source>The type of the map keys.</source>
          <target state="translated">マップキーの種類です。</target>
        </trans-unit>
        <trans-unit id="07c0446d50346f3a3a5ced32244b2b1d6aa72fb4" translate="yes" xml:space="preserve">
          <source>The type of the set elements.</source>
          <target state="translated">セット要素の型。</target>
        </trans-unit>
        <trans-unit id="5f9b34617afb59cca236cf1ed744d053aeba331d" translate="yes" xml:space="preserve">
          <source>The type of the unit value.</source>
          <target state="translated">単位値の種類です。</target>
        </trans-unit>
        <trans-unit id="558f0da7756d6b8a5e6fa053bc9e88665bde8e00" translate="yes" xml:space="preserve">
          <source>The type of this expression, t, contains type variables that cannot be generalized</source>
          <target state="translated">この式の型である t は、一般化できない型変数を含んでいます。</target>
        </trans-unit>
        <trans-unit id="f38374ae48a76fc267fc266e7d1fb3adac8f8923" translate="yes" xml:space="preserve">
          <source>The type of thread handles.</source>
          <target state="translated">糸を扱うタイプです。</target>
        </trans-unit>
        <trans-unit id="911e648755e2ce01883554d3b0a3d8fbef08dfa3" translate="yes" xml:space="preserve">
          <source>The type of three-dimensional Bigarrays whose elements have OCaml type &lt;code&gt;'a&lt;/code&gt;, representation kind &lt;code&gt;'b&lt;/code&gt;, and memory layout &lt;code&gt;'c&lt;/code&gt;.</source>
          <target state="translated">要素がOCamlタイプ &lt;code&gt;'a&lt;/code&gt; 、表現の種類 &lt;code&gt;'b&lt;/code&gt; 、およびメモリレイアウト &lt;code&gt;'c&lt;/code&gt; を持つ3次元Bigarrayのタイプ。</target>
        </trans-unit>
        <trans-unit id="a93d7af7669a780db37d7a6a35b93628bedc91cc" translate="yes" xml:space="preserve">
          <source>The type of tokens.</source>
          <target state="translated">トークンの種類です。</target>
        </trans-unit>
        <trans-unit id="a2fe884e37cec8d7d8dffba0f78cacab0927a183" translate="yes" xml:space="preserve">
          <source>The type of tokens. The lexical classes are: &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Float&lt;/code&gt; for integer and floating-point numbers; &lt;code&gt;String&lt;/code&gt; for string literals, enclosed in double quotes; &lt;code&gt;Char&lt;/code&gt; for character literals, enclosed in single quotes; &lt;code&gt;Ident&lt;/code&gt; for identifiers (either sequences of letters, digits, underscores and quotes, or sequences of 'operator characters' such as &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, etc); and &lt;code&gt;Kwd&lt;/code&gt; for keywords (either identifiers or single 'special characters' such as &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;}&lt;/code&gt;, etc).</source>
          <target state="translated">トークンのタイプ。字句クラスは次のとおりです。整数および浮動小数点数の場合は &lt;code&gt;Int&lt;/code&gt; および &lt;code&gt;Float&lt;/code&gt; 。 &lt;code&gt;String&lt;/code&gt; を二重引用符で囲まれた文字列リテラルのため; &lt;code&gt;Char&lt;/code&gt; 単一引用符で囲まれた文字リテラル、ため。 &lt;code&gt;Ident&lt;/code&gt; 識別子の（いずれかの文字、数字、下線および引用符、または配列の配列のような「オペレータ文字」 &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、など）。そして &lt;code&gt;Kwd&lt;/code&gt; キーワード（識別子または例えば単一「特殊文字」のいずれかのために &lt;code&gt;(&lt;/code&gt; 、 &lt;code&gt;}&lt;/code&gt; 、など）。</target>
        </trans-unit>
        <trans-unit id="a131ee154ce5805d4743ddd4e7ac6f8f0a846600" translate="yes" xml:space="preserve">
          <source>The type of two-dimensional Bigarrays whose elements have OCaml type &lt;code&gt;'a&lt;/code&gt;, representation kind &lt;code&gt;'b&lt;/code&gt;, and memory layout &lt;code&gt;'c&lt;/code&gt;.</source>
          <target state="translated">要素がOCamlタイプ &lt;code&gt;'a&lt;/code&gt; 、表現の種類 &lt;code&gt;'b&lt;/code&gt; 、およびメモリレイアウト &lt;code&gt;'c&lt;/code&gt; を持つ2次元Bigarrayのタイプ。</target>
        </trans-unit>
        <trans-unit id="fb1acfc22850de31c2fb5225a9fc570f7727191c" translate="yes" xml:space="preserve">
          <source>The type of zero-dimensional Bigarrays whose elements have OCaml type &lt;code&gt;'a&lt;/code&gt;, representation kind &lt;code&gt;'b&lt;/code&gt;, and memory layout &lt;code&gt;'c&lt;/code&gt;.</source>
          <target state="translated">要素がOCamlタイプ &lt;code&gt;'a&lt;/code&gt; 、表現の種類 &lt;code&gt;'b&lt;/code&gt; 、およびメモリレイアウト &lt;code&gt;'c&lt;/code&gt; を持つゼロ次元Bigarrayのタイプ。</target>
        </trans-unit>
        <trans-unit id="6c3babab89ffd173e9518cc78562c29d921585ef" translate="yes" xml:space="preserve">
          <source>The type parameter in the declaration may actually be constrained in the body of the class definition. In the class type, the actual value of the type parameter is displayed in the constraint clause.</source>
          <target state="translated">宣言の中の型パラメータは、実際にはクラス定義の本文で制約されることがあります。クラス型では、型パラメータの実際の値が制約節に表示されます。</target>
        </trans-unit>
        <trans-unit id="5037564652e82350a92a754ff0cf691d4922b52e" translate="yes" xml:space="preserve">
          <source>The type representation = [|] &lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt; { |&lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt; } describes a variant type. The constructor declarations &lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; describe the constructors associated to this variant type. The constructor declaration &lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;* &amp;hellip; *&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; declares the name &lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt; as a non-constant constructor, whose arguments have types &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. The constructor declaration &lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt; declares the name &lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt; as a constant constructor. Constructor names must be capitalized.</source>
          <target state="translated">タイプ表現= [|] &lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt; {| &lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt; }はバリアント型を記述します。コンストラクタ宣言は&lt;a href=&quot;#constr-decl&quot;&gt;、赤緯コンストラクタ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、...、&lt;a href=&quot;#constr-decl&quot;&gt;コンストラクタ-赤緯&lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt;この変異型に関連するコンストラクタを記述する。コンストラクタ宣言の&lt;a href=&quot;names#constr-name&quot;&gt;コンストラクタ名&lt;/a&gt;の&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; * ... * &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;nが&lt;/sub&gt;名を宣言&lt;a href=&quot;names#constr-name&quot;&gt;コンストラクタ名&lt;/a&gt;引数の型持っている非定数コンストラクタ、など&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ... &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;nと&lt;/sub&gt;。コンストラクター宣言&lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt;は名前&lt;a href=&quot;names#constr-name&quot;&gt;constr-nameを&lt;/a&gt;宣言します定数コンストラクターとして。コンストラクター名は大文字にする必要があります。</target>
        </trans-unit>
        <trans-unit id="6bb673b534c3fd2e98456972d5696bd025fa4d55" translate="yes" xml:space="preserve">
          <source>The type representation ={&lt;a href=&quot;#field-decl&quot;&gt;field-decl&lt;/a&gt; { ;&lt;a href=&quot;#field-decl&quot;&gt;field-decl&lt;/a&gt; } [;] } describes a record type. The field declarations &lt;a href=&quot;#field-decl&quot;&gt;field-decl&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#field-decl&quot;&gt;field-decl&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; describe the fields associated to this record type. The field declaration &lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt; declares &lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt; as a field whose argument has type &lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;. The field declaration mutable&lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;  behaves similarly; in addition, it allows physical modification of this field. Immutable fields are covariant, mutable fields are non-variant. Both mutable and immutable fields may have explicitly polymorphic types. The polymorphism of the contents is statically checked whenever a record value is created or modified. Extracted values may have their types instantiated.</source>
          <target state="translated">タイプ表現= { &lt;a href=&quot;#field-decl&quot;&gt;field-decl&lt;/a&gt; {; &lt;a href=&quot;#field-decl&quot;&gt;field-decl&lt;/a&gt; } [;]}は、レコードタイプを記述します。フィールド宣言&lt;a href=&quot;#field-decl&quot;&gt;フィールド-供述&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;、...、&lt;a href=&quot;#field-decl&quot;&gt;フィールド-供述&lt;/a&gt;&lt;sub&gt;nが&lt;/sub&gt;このレコードタイプに関連するフィールドを記述します。フィールド宣言&lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt;：&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;は、引数の型が&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexprで&lt;/a&gt;あるフィールドとして&lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt;を宣言します。フィールド宣言可変&lt;a href=&quot;names#field-name&quot;&gt;フィールド名&lt;/a&gt;：&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;同様に動作します。さらに、このフィールドを物理的に変更できます。不変フィールドは共変であり、可変フィールドは非変です。可変フィールドと不変フィールドの両方に、明示的にポリモーフィックなタイプがあります。レコード値が作成または変更されるたびに、コンテンツのポリモーフィズムが静的にチェックされます。抽出された値には、そのタイプがインスタンス化される場合があります。</target>
        </trans-unit>
        <trans-unit id="2cc55907fc102b663d0673eb99112e552f4a435a" translate="yes" xml:space="preserve">
          <source>The type representing wallclock time and calendar date.</source>
          <target state="translated">壁掛け時計の時刻とカレンダーの日付を表すタイプです。</target>
        </trans-unit>
        <trans-unit id="719afb56f810f882e663e05949b4c0135dc8e565" translate="yes" xml:space="preserve">
          <source>The type variables appearing as type parameters can optionally be prefixed by + or - to indicate that the type constructor is covariant or contravariant with respect to this parameter. This variance information is used to decide subtyping relations when checking the validity of :&amp;gt; coercions (see section &lt;a href=&quot;expr#ss%3Aexpr-coercions&quot;&gt;7.7.7&lt;/a&gt;).</source>
          <target state="translated">型パラメーターとして表示される型変数には、オプションで+または-の接頭辞を付けて、型コンストラクターがこのパラメーターに関して共変または反変であることを示すことができます。この分散情報は、：&amp;gt;強制の有効性をチェックするときにサブタイプ関係を決定するために使用されます（セクション&lt;a href=&quot;expr#ss%3Aexpr-coercions&quot;&gt;7.7.7を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="da4bb1f94026133ed9e6ee3397f9022a4a5493c7" translate="yes" xml:space="preserve">
          <source>The types and their meanings are:</source>
          <target state="translated">種類とその意味は</target>
        </trans-unit>
        <trans-unit id="cf539767254769cb84eb0b1abbb2be61f0f57486" translate="yes" xml:space="preserve">
          <source>The typical usage is:</source>
          <target state="translated">典型的な使い方です。</target>
        </trans-unit>
        <trans-unit id="9e2cdbd104780129e6eb6af11e6842e3411789d0" translate="yes" xml:space="preserve">
          <source>The typical use of private types is in the export signature of a module, to ensure that construction of values of the private type always go through the functions provided by the module, while still allowing pattern-matching outside the defining module. For example:</source>
          <target state="translated">プライベート型の典型的な使用法は、モジュールのエクスポートシグネチャで、プライベート型の値の構築が常にモジュールによって提供される関数を介して行われることを確実にしながらも、定義されたモジュールの外部でパターンマッチを可能にすることです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="76fc86bc826ecd117df214c518ef9dca7c54b653" translate="yes" xml:space="preserve">
          <source>The typing of immediate objects is slightly different from explicitly defining a class in two respects. First, the inferred object type may contain free type variables. Second, since the class body of an immediate object will never be extended, its self type can be unified with a closed object type.</source>
          <target state="translated">即時オブジェクトの型付けは、2つの点でクラスを明示的に定義するのとは少し異なります。第一に、推論されたオブジェクトの型は自由な型変数を含むことができます。第二に、即時オブジェクトのクラス本体は決して拡張されないので、その自己型は閉じたオブジェクト型で統一することができます。</target>
        </trans-unit>
        <trans-unit id="379766838ae430347d582312c2b9bd97e93485b9" translate="yes" xml:space="preserve">
          <source>The typing of pattern matching in presence of GADT can generate many existential types. When necessary, error messages refer to these existential types using compiler-generated names. Currently, the compiler generates these names according to the following nomenclature:</source>
          <target state="translated">GADTの存在下でのパターン・マッチングの型付けは、多くの実在型を生成することができます。必要に応じて、エラーメッセージは、コンパイラが生成した名前を使用してこれらの実存型を参照します。現在、コンパイラは以下の命名法に従ってこれらの名前を生成します。</target>
        </trans-unit>
        <trans-unit id="b139709c938696abfe6558bd71c73b15692ae467" translate="yes" xml:space="preserve">
          <source>The unit type</source>
          <target state="translated">ユニットタイプ</target>
        </trans-unit>
        <trans-unit id="f157a3529b6639761d0fe3370101d0cd58a51217" translate="yes" xml:space="preserve">
          <source>The unit type.</source>
          <target state="translated">ユニットタイプです。</target>
        </trans-unit>
        <trans-unit id="6b7a079da5bd24c487f37916205b8998acfd3262" translate="yes" xml:space="preserve">
          <source>The unix library makes many Unix system calls and system-related library functions available to OCaml programs. This chapter describes briefly the functions provided. Refer to sections 2 and 3 of the Unix manual for more details on the behavior of these functions.</source>
          <target state="translated">unix ライブラリは、多くの Unix システムコールとシステム関連のライブラリ関数を OCaml プログラムで利用できるようにします。この章では、提供される関数について簡単に説明します。これらの関数の動作の詳細については、Unixマニュアルの第2章と第3章を参照してください。</target>
        </trans-unit>
        <trans-unit id="61f8335838db8a8ae9ab9030edc50991b021708a" translate="yes" xml:space="preserve">
          <source>The unrolling depth applies to calls within the same mutually-recursive group of functions. Each time an inlining of such a call is performed the depth is incremented by one when examining the resulting body. If the depth reaches the limit set by -inline-max-unroll then speculation stops.</source>
          <target state="translated">展開深度は、同じ相互再帰的な関数グループ内の呼び出しに適用されます。このような呼び出しのインライン化が実行されるたびに、結果のボディを調べるときに深さが1ずつ増加します。深さが-inline-max-unrollで設定された限界に達すると、推測は停止します。</target>
        </trans-unit>
        <trans-unit id="ef46466283aedcffa1e3418737dde034112c7cb9" translate="yes" xml:space="preserve">
          <source>The unused specialised argument f may now be removed, leaving:</source>
          <target state="translated">使われていない特殊な引数fは削除され、残ったままになっているかもしれません。</target>
        </trans-unit>
        <trans-unit id="f25fc5451b4b7e9e596e2f95c2648b7f2f987a8b" translate="yes" xml:space="preserve">
          <source>The usage for ocamlrun is:</source>
          <target state="translated">ocamlrunの使い方は</target>
        </trans-unit>
        <trans-unit id="fdf174ec233170184c634afe9d8c6e98683f2f9c" translate="yes" xml:space="preserve">
          <source>The user must make sure that the parameter &lt;code&gt;s&lt;/code&gt; is the same string that was passed to the matching or searching function.</source>
          <target state="translated">ユーザーは、パラメーター &lt;code&gt;s&lt;/code&gt; がマッチングまたは検索関数に渡されたものと同じ文字列であることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="9cc30db23fbb2629fd5d6a40fb9f9a4aa615d10c" translate="yes" xml:space="preserve">
          <source>The user starts manually the program, when asked by the debugger. Allows remote debugging (see section &lt;a href=&quot;#ss%3Adebugger-communication&quot;&gt;17.8.8&lt;/a&gt;).</source>
          <target state="translated">ユーザーは、デバッガーから要求されたときに、プログラムを手動で開始します。リモートデバッグを許可します（セクション&lt;a href=&quot;#ss%3Adebugger-communication&quot;&gt;17.8.8を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="642aefa1c3276d4815d6372b5c2ba0e28849644d" translate="yes" xml:space="preserve">
          <source>The value of lazy_two is displayed as &amp;lt;lazy&amp;gt;, which means the expression has not been evaluated yet, and its final value is unknown.</source>
          <target state="translated">lazy_twoの値は&amp;lt;lazy&amp;gt;として表示されます。これは、式がまだ評価されておらず、最終的な値が不明であることを意味します。</target>
        </trans-unit>
        <trans-unit id="e44eeca632e1ee708a87c7d08ac7f919078da583" translate="yes" xml:space="preserve">
          <source>The value path printer-name must refer to one of the functions defined by the object files loaded using load_printer. It cannot reference the functions of the program being debugged.</source>
          <target state="translated">値のパス printer-name は、load_printer を使用してロードされたオブジェクトファイルによって定義された関数の 1 つを参照しなければなりません。デバッグされているプログラムの関数を参照することはできません。</target>
        </trans-unit>
        <trans-unit id="213346982c2b5edd8a2868f6648a75de11f3a7a1" translate="yes" xml:space="preserve">
          <source>The value restriction combined with this generalization for covariant type parameters is called the relaxed value restriction.</source>
          <target state="translated">共変型パラメータに対するこの一般化と組み合わせた値制限を緩和値制限と呼ぶ。</target>
        </trans-unit>
        <trans-unit id="3e457e086f638356c025d7f98eea16073334d087" translate="yes" xml:space="preserve">
          <source>The variance indicated by the + and - annotations on parameters is enforced only for abstract and private types, or when there are type constraints. Otherwise, for abbreviations, variant and record types without type constraints, the variance properties of the type constructor are inferred from its definition, and the variance annotations are only checked for conformance with the definition.</source>
          <target state="translated">パラメータの+および-アノテーションによって示される分散は、抽象型およびプライベート型の場合、または型制約がある場合にのみ強制されます。それ以外の場合、型制約のない省略形、バリアント型、レコード型については、型コンストラクタの分散プロパティはその定義から推測され、分散アノテーションは定義に適合するかどうかのみチェックされます。</target>
        </trans-unit>
        <trans-unit id="a2c84e520b4d58847b9a0936e0ff6718cecdfce8" translate="yes" xml:space="preserve">
          <source>The variant &lt;code&gt;caml_process_pending_actions_exn&lt;/code&gt; is provided, that returns the exception instead of raising it directly into OCaml code. Its result must be tested using Is_exception_result, and followed by Extract_exception if appropriate. It is typically used for clean up before re-raising:</source>
          <target state="translated">バリアント &lt;code&gt;caml_process_pending_actions_exn&lt;/code&gt; が提供されており、OCamlコードに直接発生させるのではなく、例外を返します。その結果は、Is_exception_resultを使用してテストし、必要に応じてExtract_exceptionを続ける必要があります。これは通常、再レイズする前のクリーンアップに使用されます。</target>
        </trans-unit>
        <trans-unit id="4d3e8b9825c91e7d1c1de2e5964ef9a6faa3a9d6" translate="yes" xml:space="preserve">
          <source>The variant value `VConstr is represented by hash_variant(&quot;VConstr&quot;). The variant value `VConstr(v) is represented by a block of size 2 and tag 0, with field number 0 containing hash_variant(&quot;VConstr&quot;) and field number 1 containing v.</source>
          <target state="translated">バリアント値 `VConstr' は hash_variant(&quot;VConstr&quot;)で表されます。バリアント値 `VConstr(v)はサイズ2、タグ0のブロックで表現され、フィールド番号0にはhash_variant(&quot;VConstr&quot;)が、フィールド番号1にはvが格納されます。</target>
        </trans-unit>
        <trans-unit id="fe7a7371cf1264e74123560fc9eaab0ccf8deadd" translate="yes" xml:space="preserve">
          <source>The version number for the element.</source>
          <target state="translated">要素のバージョン番号。</target>
        </trans-unit>
        <trans-unit id="a12195f2bfc0b341eebc2706c0f898b85f60cd39" translate="yes" xml:space="preserve">
          <source>The warning-list argument is a sequence of warning specifiers, with no separators between them. A warning specifier is one of the following:</source>
          <target state="translated">warning-list 引数は、警告指定子のシーケンスであり、それらの間にセパレータはありません。警告指定子は以下のいずれかです。</target>
        </trans-unit>
        <trans-unit id="3155774bd8f5952cba7da2b05dd2d603a1c4e3ad" translate="yes" xml:space="preserve">
          <source>The with part does pattern matching on the exception value with the same syntax and behavior as match. Thus, several exceptions can be caught by one try&amp;hellip;with construct:</source>
          <target state="translated">with部分は、matchと同じ構文と動作で例外値のパターンマッチングを実行します。したがって、1回の試行でいくつかの例外をキャッチできます&amp;hellip;次の構文を使用します。</target>
        </trans-unit>
        <trans-unit id="3bee62c92457d9c1edd0b95b70b38529cd1e173d" translate="yes" xml:space="preserve">
          <source>The workaround is easy: you should put a type constraint on the parameter.</source>
          <target state="translated">回避策は簡単です:パラメータに型制約を設定してください。</target>
        </trans-unit>
        <trans-unit id="8e5abc2079ccb81595a85c637140e96ed3e00651" translate="yes" xml:space="preserve">
          <source>Then, the following command uses custom.cma as custom generator:</source>
          <target state="translated">そして、以下のコマンドでは、カスタムジェネレータとしてcustom.cmaを使用します。</target>
        </trans-unit>
        <trans-unit id="7da202378d7326ed462fca4e0c21921b3c299f46" translate="yes" xml:space="preserve">
          <source>There are no type expressions describing (defined) variant types nor record types, since those are always named, i.e. defined before use and referred to by name. Type definitions are described in section &lt;a href=&quot;typedecl#ss%3Atypedefs&quot;&gt;7.8.1&lt;/a&gt;.</source>
          <target state="translated">（定義された）バリアント型やレコード型を説明する型式はありません。これらは常に名前が付けられているためです。つまり、使用前に定義され、名前で参照されます。タイプ定義はセクション&lt;a href=&quot;typedecl#ss%3Atypedefs&quot;&gt;7.8.1で&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="2ed327f049e48284a0a623ce9851b6b43632572d" translate="yes" xml:space="preserve">
          <source>There are several restrictions on &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;にはいくつかの制限があります：</target>
        </trans-unit>
        <trans-unit id="b5816a972e7e95d82645db243fd7e0a0acf5b5d4" translate="yes" xml:space="preserve">
          <source>There are six CAMLparam macros: CAMLparam0 to CAMLparam5, which take zero to five arguments respectively. If your function has no more than 5 parameters of type value, use the corresponding macros with these parameters as arguments. If your function has more than 5 parameters of type value, use CAMLparam5 with five of these parameters, and use one or more calls to the CAMLxparam macros for the remaining parameters (CAMLxparam1 to CAMLxparam5).</source>
          <target state="translated">CAMLparamマクロは6つあります。CAMLparam0 から CAMLparam5 までの 6 つのマクロがあり、それぞれ 0 から 5 個の引数を取ります。型の値のパラメータが 5 個以下の場合は、これらのパラメータを引数として対応するマクロを使用します。型の値が 5 個以上のパラメータを持つ関数の場合は、これらのパラメータのうち 5 個を引数として CAMLparam5 を使用し、残りのパラメータ(CAMLxparam1 から CAMLxparam5)については CAMLxparam マクロを 1 回以上コールします。</target>
        </trans-unit>
        <trans-unit id="66a70237d0ffb18913597dc8bc48a2788fdf2980" translate="yes" xml:space="preserve">
          <source>There are two drawbacks to dynamic linking. The first is that the resulting executable is not stand-alone: it requires the shared libraries, as well as ocamlrun, to be installed on the machine executing the code. If you wish to distribute a stand-alone executable, it is better to link it statically, using ocamlc -custom -ccopt -static or ocamlopt -ccopt -static. Dynamic linking also raises the &amp;ldquo;DLL hell&amp;rdquo; problem: some care must be taken to ensure that the right versions of the shared libraries are found at start-up time.</source>
          <target state="translated">ダイナミックリンクには2つの欠点があります。 1つ目は、結果の実行可能ファイルがスタンドアロンではないことです。コードを実行するマシンに共有ライブラリとocamlrunをインストールする必要があります。スタンドアロンの実行可能ファイルを配布する場合は、ocamlc -custom -ccopt-staticまたはocamlopt-ccopt -staticを使用して、静的にリンクすることをお勧めします。ダイナミックリンクは「DLL地獄」の問題も引き起こします。起動時に正しいバージョンの共有ライブラリが見つかるように注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="b66d252bf6e5adb16a8a81b0a31bcc98e8083e8f" translate="yes" xml:space="preserve">
          <source>There are two exceptions: for constructors and record fields in type definitions, the associated comment can only be placed after the constructor or field definition, without blank lines or other comments between them. The special comment for a constructor with another constructor following must be placed before the &amp;rsquo;|&amp;rsquo; character separating the two constructors.</source>
          <target state="translated">2つの例外があります。型定義のコンストラクターとレコードフィールドの場合、関連するコメントは、コンストラクターまたはフィールド定義の後にのみ配置でき、間に空白行やその他のコメントはありません。別のコンストラクターが後に続くコンストラクターの特別なコメントは、「|」の前に配置する必要があります。 2つのコンストラクターを区切る文字。</target>
        </trans-unit>
        <trans-unit id="3eea4041f7bae7ed250a35d69c8993bc99a56a95" translate="yes" xml:space="preserve">
          <source>There are two valid use-cases that respect this ownership discipline:</source>
          <target state="translated">この所有権の規律を尊重した2つの有効なユースケースがあります。</target>
        </trans-unit>
        <trans-unit id="0f4c01af210fd3e27d304b7f41d713af6236e4a1" translate="yes" xml:space="preserve">
          <source>There are two ways to obtain OCaml function values (closures) to be passed to the callback functions described above. One way is to pass the OCaml function as an argument to a primitive function. For example, if the OCaml code contains the declaration</source>
          <target state="translated">上で説明したコールバック関数に渡すOCaml関数の値(クロージャ)を取得するには、2つの方法があります。1つの方法は、OCaml関数をプリミティブ関数の引数として渡す方法です。たとえば、OCaml コードに次のような宣言が含まれているとします。</target>
        </trans-unit>
        <trans-unit id="f796d8197ff409294fcb0b2b9480a2ce5fecdc08" translate="yes" xml:space="preserve">
          <source>There is a printf function in the &lt;a href=&quot;libref/printf&quot;&gt;Printf&lt;/a&gt; module (see chapter &lt;a href=&quot;moduleexamples#c%3Amoduleexamples&quot;&gt;2&lt;/a&gt;) that allows you to make formatted output more concisely. It follows the behavior of the printf function from the C standard library. The printf function takes a format string that describes the desired output as a text interspered with specifiers (for instance %d, %f). Next, the specifiers are substituted by the following arguments in their order of apparition in the format string:</source>
          <target state="translated">&lt;a href=&quot;libref/printf&quot;&gt;Printf&lt;/a&gt;モジュール（第&lt;a href=&quot;moduleexamples#c%3Amoduleexamples&quot;&gt;2&lt;/a&gt;章を参照）にはprintf関数があり、フォーマットされた出力をより簡潔にすることができます。これは、C標準ライブラリのprintf関数の動作に従います。printf関数は、目的の出力を指定子（たとえば、％d、％f）が散在するテキストとして記述するフォーマット文字列を取ります。次に、指定子は、フォーマット文字列内の出現順に次の引数に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="0926f9a5aad069ce9f290befa2171e8e69385aeb" translate="yes" xml:space="preserve">
          <source>There is a single classification for coeffects:</source>
          <target state="translated">係数には一つの分類があります。</target>
        </trans-unit>
        <trans-unit id="86860c4a3904e32a0066d40f9221fe10cbd4529f" translate="yes" xml:space="preserve">
          <source>There is a single input (the string &amp;ldquo;secret code&amp;rdquo;) which causes this program to crash, but finding it by blind random search is infeasible.</source>
          <target state="translated">このプログラムをクラッシュさせる単一の入力（文字列「シークレットコード」）がありますが、ブラインドランダム検索でそれを見つけることは不可能です。</target>
        </trans-unit>
        <trans-unit id="f530a5d8b189e6bec332a6ff74e1e85c4100c796" translate="yes" xml:space="preserve">
          <source>There is an additional lexical rule to escape the special characters &lt;code&gt;'%'&lt;/code&gt; and &lt;code&gt;'@'&lt;/code&gt; in format strings: if a special character follows a &lt;code&gt;'%'&lt;/code&gt; character, it is treated as a plain character. In other words, &lt;code&gt;&quot;%%&quot;&lt;/code&gt; is considered as a plain &lt;code&gt;'%'&lt;/code&gt; and &lt;code&gt;&quot;%@&quot;&lt;/code&gt; as a plain &lt;code&gt;'@'&lt;/code&gt;.</source>
          <target state="translated">フォーマット文字列の特殊文字 &lt;code&gt;'%'&lt;/code&gt; および &lt;code&gt;'@'&lt;/code&gt; をエスケープするための追加の字句規則があります。特殊文字が &lt;code&gt;'%'&lt;/code&gt; 文字の後に続く場合、それはプレーン文字として扱われます。つまり、 &lt;code&gt;&quot;%%&quot;&lt;/code&gt; はプレーンな &lt;code&gt;'%'&lt;/code&gt; と見なされ、 &lt;code&gt;&quot;%@&quot;&lt;/code&gt; はプレーンな &lt;code&gt;'@'&lt;/code&gt; 」と見なされます。</target>
        </trans-unit>
        <trans-unit id="89300e6e8eb5caa8716a6d136ca3ce59e33af664" translate="yes" xml:space="preserve">
          <source>There is another partial solution to the problem of unnecessary weak type, which is implemented directly within the type checker. Briefly, it is possible to prove that weak types that only appear as type parameters in covariant positions &amp;ndash;also called positive positions&amp;ndash; can be safely generalized to polymorphic types. For instance, the type 'a list is covariant in 'a:</source>
          <target state="translated">不要な弱い型の問題に対する別の部分的な解決策があります。これは、型チェッカー内に直接実装されます。簡単に言うと、共変位置（正の位置とも呼ばれる）で型パラメーターとしてのみ表示される弱い型を、ポリモーフィック型に安全に一般化できることを証明できます。たとえば、タイプ 'リストは' a：で共変です。</target>
        </trans-unit>
        <trans-unit id="4839904c7c8092d09c24e4a4ca03c2ca6d8ace01" translate="yes" xml:space="preserve">
          <source>There is another, more direct way to create an object: create it without going through a class.</source>
          <target state="translated">オブジェクトを作成するもう一つの、より直接的な方法があります。</target>
        </trans-unit>
        <trans-unit id="6713ccaa14a77e18cc0d165c630249a7f39edf84" translate="yes" xml:space="preserve">
          <source>There is no blank line or another special comment between the special comment and the element. However, a regular comment can occur between the special comment and the element.</source>
          <target state="translated">特殊コメントと要素の間には空行や別の特殊コメントは存在しない。しかし、特殊コメントと要素の間には、通常のコメントが発生することがあります。</target>
        </trans-unit>
        <trans-unit id="420c7eecf9b88f0fd685ede8cd7d5594dccc6b10" translate="yes" xml:space="preserve">
          <source>There is no linearity restriction over as bound variables. When a variable is bound more than once, the previous rules are to be extended as follows:</source>
          <target state="translated">束縛された変数に対する直線性の制限はありません.ある変数が複数回束縛されている場合、前の規則を次のように拡張します。</target>
        </trans-unit>
        <trans-unit id="e2df4086644aefdc6d4fa1daff752de72504dccd" translate="yes" xml:space="preserve">
          <source>There is nothing particular about functors that inhibits inlining compared to normal functions. To the inliner, these both look the same, except that functors are marked as such.</source>
          <target state="translated">ファンクタには、通常の関数に比べてインライン化を阻害するようなものは特にありません。インライナーにとっては、ファンクタがそのようにマークされていることを除けば、どちらも同じように見えます。</target>
        </trans-unit>
        <trans-unit id="6f7526b0137b40ba5befc330c948531d764b9b23" translate="yes" xml:space="preserve">
          <source>There is sometimes an alternative between using modules or classes for parametric data types. Indeed, there are situations when the two approaches are quite similar. For instance, a stack can be straightforwardly implemented as a class:</source>
          <target state="translated">パラメトリックデータ型にモジュールやクラスを使うという選択肢もあります。実際、この2つのアプローチが非常に似ている場合があります。例えば、スタックはクラスとして簡単に実装することができます。</target>
        </trans-unit>
        <trans-unit id="6f6f12e3992f209be063993c601fdba9acbc537c" translate="yes" xml:space="preserve">
          <source>Therefore, after placing an int in store, we cannot use it to store any value other than an int. More generally, weak types protect the program from undue mutation of values with a polymorphic type.</source>
          <target state="translated">したがって、intをストアに置いた後は、int以外の値をストアするのには使えません。より一般的には、弱い型は、多相型での値の不当な変異からプログラムを保護します。</target>
        </trans-unit>
        <trans-unit id="e9c813ad0d9ef31d493524a8ea85262d92050cce" translate="yes" xml:space="preserve">
          <source>These .cmt and .cmti files are typically useful for code inspection tools.</source>
          <target state="translated">これらの.cmtと.cmtiファイルは、一般的にコード検査ツールに便利です。</target>
        </trans-unit>
        <trans-unit id="69311f08c70520540fee4cbe4bda7e98116c0238" translate="yes" xml:space="preserve">
          <source>These annotations explicitly require the defined value to be polymorphic, and allow one to use this polymorphism in recursive occurrences (when using letrec). Note however that this is a normal polymorphic type, unifiable with any instance of itself.</source>
          <target state="translated">これらのアノテーションは、定義された値が多相であることを明示的に要求し、再帰的な出現(letrecを使用する場合)でこの多相性を使用することを可能にしています。ただし、これは通常の多相型であり、それ自体の任意のインスタンスで統一可能であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="43e7d9c598d98633999ba13a3dcc444ba12214ad" translate="yes" xml:space="preserve">
          <source>These eleven name spaces are distinguished both by the context and by the capitalization of the identifier: whether the first letter of the identifier is in lowercase (written &lt;a href=&quot;lex#lowercase-ident&quot;&gt;lowercase-ident&lt;/a&gt; below) or in uppercase (written &lt;a href=&quot;lex#capitalized-ident&quot;&gt;capitalized-ident&lt;/a&gt;). Underscore is considered a lowercase letter for this purpose.</source>
          <target state="translated">これら11名のスペースは、文脈によって、および識別子の大文字の両方によって区別される：識別子の最初の文字が小文字（書き込まれているか否かを&lt;a href=&quot;lex#lowercase-ident&quot;&gt;小文字-IDENT&lt;/a&gt;以下）または大文字（書き込みに&lt;a href=&quot;lex#capitalized-ident&quot;&gt;大文字-IDENT&lt;/a&gt;）。この目的では、アンダースコアは小文字と見なされます。</target>
        </trans-unit>
        <trans-unit id="870297f2b83ed8726b893d830c917d6f224b681b" translate="yes" xml:space="preserve">
          <source>These files reside in the caml/ subdirectory of the OCaml standard library directory, which is returned by the command ocamlc -where (usually /usr/local/lib/ocaml or /usr/lib/ocaml).</source>
          <target state="translated">これらのファイルは OCaml 標準ライブラリディレクトリの caml/サブディレクトリにあり、 ocamlc -where (通常は /usr/local/lib/ocaml または /usr/lib/ocaml)コマンドで返されます。</target>
        </trans-unit>
        <trans-unit id="3be7b63190a743842c43dfb1591048d46124470c" translate="yes" xml:space="preserve">
          <source>These functions are the same as the basic functions, except that they use (and update) the given PRNG state instead of the default one.</source>
          <target state="translated">これらの関数は基本的な関数と同じですが、デフォルトのPRNG状態ではなく、与えられたPRNG状態を使用(更新)することを除いては、基本的な関数と同じです。</target>
        </trans-unit>
        <trans-unit id="239ea6a3f14d9dc171a9d56f5158d10f257a786d" translate="yes" xml:space="preserve">
          <source>These functions are used to traverse the slots of a raw backtrace and extract information from them in a programmer-friendly format.</source>
          <target state="translated">これらの関数は、生のバックトレースのスロットを辿り、そこから情報をプログラマフレンドリーな形式で抽出するために使用されます。</target>
        </trans-unit>
        <trans-unit id="7cf57b7b10c266fa7ea278e39e177192d8ca0786" translate="yes" xml:space="preserve">
          <source>These functions poll for pending signals by calling asynchronous callbacks (section &lt;a href=&quot;#ss%3Ac-process-pending-actions&quot;&gt;20.5.3&lt;/a&gt;) before releasing and after acquiring the lock. They can therefore execute arbitrary OCaml code including raising an asynchronous exception.</source>
          <target state="translated">これらの関数は、ロックを解放する前と取得した後に非同期コールバック（セクション&lt;a href=&quot;#ss%3Ac-process-pending-actions&quot;&gt;20.5.3&lt;/a&gt;）を呼び出すことにより、保留中のシグナルをポーリングします。したがって、非同期例外の発生を含め、任意のOCamlコードを実行できます。</target>
        </trans-unit>
        <trans-unit id="be1ff51841b268ac0bc83ac53b16b105790d419d" translate="yes" xml:space="preserve">
          <source>These functions return immediately &lt;code&gt;true&lt;/code&gt; in the Win32 implementation.</source>
          <target state="translated">これらの関数は、Win32実装ではすぐに &lt;code&gt;true&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="7ce3216765c88e5c48af00b3c110ef4d63384284" translate="yes" xml:space="preserve">
          <source>These goals are often reached not just by inlining itself but also by other optimisations that the compiler is able to perform as a result of inlining.</source>
          <target state="translated">これらの目標は、インライン化そのものだけでなく、インライン化の結果としてコンパイラが実行できる他の最適化によっても達成されることが多いです。</target>
        </trans-unit>
        <trans-unit id="4386b22d00bf9e30129abfc3148f83106ab4fda2" translate="yes" xml:space="preserve">
          <source>These options are passed as is to ocamlc or ocamlopt. See the documentation of these commands.</source>
          <target state="translated">これらのオプションはそのまま ocamlc または ocamlopt に渡されます。これらのコマンドのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="484df2de1a8035aff891a6ad2ca2a206e2085ae8" translate="yes" xml:space="preserve">
          <source>These options are passed as is to the C compiler. Refer to the documentation of the C compiler.</source>
          <target state="translated">これらのオプションはそのままCコンパイラに渡されます。Cコンパイラのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="4eeaa8b4b44d8ce0bdc7032fda14b43069cb254a" translate="yes" xml:space="preserve">
          <source>These options are useful when you have, for example, a type and a value with the same name. If you do not specify prefixes, L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X will complain about multiply defined labels.</source>
          <target state="translated">これらのオプションは、たとえば、同じ名前のタイプと値がある場合に役立ちます。あなたは接頭辞を指定しない場合は、L &lt;sup&gt;A&lt;/sup&gt; T &lt;sub&gt;E&lt;/sub&gt; Xは、多重定義されたラベルに文句を言うでしょう。</target>
        </trans-unit>
        <trans-unit id="bd109aa38e89265e3d535e5b8837cacc7cebe8b5" translate="yes" xml:space="preserve">
          <source>These parameters are ultimately bounded by the arguments provided to the corresponding command-line flags (or their default values):</source>
          <target state="translated">これらのパラメータは、最終的には対応するコマンドラインフラグ (またはそのデフォルト値)に与えられた引数によって制限されます。</target>
        </trans-unit>
        <trans-unit id="201eef9e30770a6e41dd8bf1c6f8c6e7106ea2b8" translate="yes" xml:space="preserve">
          <source>These program generators are very close to the well-known lex and yacc commands that can be found in most C programming environments. This chapter assumes a working knowledge of lex and yacc: while it describes the input syntax for ocamllex and ocamlyacc and the main differences with lex and yacc, it does not explain the basics of writing a lexer or parser description in lex and yacc. Readers unfamiliar with lex and yacc are referred to &amp;ldquo;Compilers: principles, techniques, and tools&amp;rdquo; by Aho, Sethi and Ullman (Addison-Wesley, 1986), or &amp;ldquo;Lex &amp;amp; Yacc&amp;rdquo;, by Levine, Mason and Brown (O&amp;rsquo;Reilly, 1992).</source>
          <target state="translated">これらのプログラムジェネレーターは、ほとんどのCプログラミング環境で見られるよく知られたlexおよびyaccコマンドに非常に近いものです。この章では、lexとyaccの実用的な知識があることを前提としています。ocamllexとocamlyaccの入力構文、およびlexとyaccとの主な違いについて説明しますが、lexとyaccでレクサーまたはパーサーの説明を記述する基本については説明しません。lexとyaccに慣れていない読者は、Aho、Sethi、Ullmanによる「Compilers：principles、techniques、and tools」（Addison-Wesley、1986）、またはLevine、Mason、Brownによる「Lex＆Yacc」（O'Reilly）を参照してください。 、1992）。</target>
        </trans-unit>
        <trans-unit id="a01d3add6122970dc3dbf24500aab00b1c8c4545" translate="yes" xml:space="preserve">
          <source>These text messages are usually not stable over time: call sites building these constructors may refine the message in a future version to make it more explicit, etc. Therefore, it is dangerous to match over the precise value of the message. For example, until OCaml 4.02, Array.iter2 would raise the exception</source>
          <target state="translated">これらのテキストメッセージは通常、時間の経過とともに安定したものではありません:これらのコンストラクタを構築しているコールサイトは、将来のバージョンでメッセージをより明示的にするなど、メッセージを改良するかもしれません。したがって、メッセージの正確な値を超えてマッチするのは危険です。例えば、OCaml 4.02までは、Array.iter2は例外を発生させていました。</target>
        </trans-unit>
        <trans-unit id="056363d88c08f1781faea018bb808d8587eb9a45" translate="yes" xml:space="preserve">
          <source>These two files together define a structure named A as if the following definition was entered at top-level:</source>
          <target state="translated">これら2つのファイルを合わせて、トップレベルで以下の定義を入力した場合のように、Aという名前の構造体を定義します。</target>
        </trans-unit>
        <trans-unit id="2c3373b0a618202574e74bfc05210cbd553b7e77" translate="yes" xml:space="preserve">
          <source>These weakened dependencies make possible to use module aliases in place of the -pack mechanism. Suppose that you have a library Mylib composed of modules A and B. Using -pack, one would issue the command line</source>
          <target state="translated">これらの弱体化された依存関係により、-pack 機構の代わりにモジュールエイリアスを使用することが可能になります。モジュールAとBで構成されたMylibライブラリがあるとします。</target>
        </trans-unit>
        <trans-unit id="e5e847d2a87ac8165d8955c02fcafa07afd4fca2" translate="yes" xml:space="preserve">
          <source>They only differ by their labels. Detailed interfaces can be found in &lt;code&gt;arrayLabels.mli&lt;/code&gt;, &lt;code&gt;bytesLabels.mli&lt;/code&gt;, &lt;code&gt;listLabels.mli&lt;/code&gt; and &lt;code&gt;stringLabels.mli&lt;/code&gt;.</source>
          <target state="translated">ラベルだけが異なります。詳細なインターフェイスは、 &lt;code&gt;arrayLabels.mli&lt;/code&gt; 、 &lt;code&gt;bytesLabels.mli&lt;/code&gt; 、 &lt;code&gt;listLabels.mli&lt;/code&gt; 、および &lt;code&gt;stringLabels.mli&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="2b235c592e19c9ae8ea4fa2dac4a8048ec27fa43" translate="yes" xml:space="preserve">
          <source>They only differ by their labels. They are provided to help porting from previous versions of OCaml. The contents of this module are subject to change.</source>
          <target state="translated">これらはラベルの違いだけです。これらは以前のバージョンのOCamlからの移植を助けるために提供されています。このモジュールの内容は変更されることがあります。</target>
        </trans-unit>
        <trans-unit id="4e865936f70f95a35530da646f08d349c8618ab8" translate="yes" xml:space="preserve">
          <source>This ability provides class constructors as can be found in other languages. Several constructors can be defined this way to build objects of the same class but with different initialization patterns; an alternative is to use initializers, as described below in section &lt;a href=&quot;#s%3Ainitializers&quot;&gt;3.4&lt;/a&gt;.</source>
          <target state="translated">この機能は、他の言語で見られるようなクラスコンストラクターを提供します。この方法で複数のコンストラクターを定義して、同じクラスであるが初期化パターンが異なるオブジェクトを作成できます。別の方法は、以下のセクション&lt;a href=&quot;#s%3Ainitializers&quot;&gt;3.4で&lt;/a&gt;説明するように、初期化子を使用することです。</target>
        </trans-unit>
        <trans-unit id="4e4da690687d8f30331d0881e81b870c14418b6d" translate="yes" xml:space="preserve">
          <source>This allows delaying the formatting of backtraces to when they are actually printed, which may be useful if you record more backtraces than you print.</source>
          <target state="translated">これにより、バックトレースのフォーマットを実際に印刷されたときまで遅らせることができます。</target>
        </trans-unit>
        <trans-unit id="9cf2b05351c309723aa496873af8b5e1e89659d8" translate="yes" xml:space="preserve">
          <source>This allows the following idiom, keeping a list of all objects belonging to a class or its subclasses:</source>
          <target state="translated">これにより、クラスまたはそのサブクラスに属するすべてのオブジェクトのリストを保持する、次のイディオムが可能になります。</target>
        </trans-unit>
        <trans-unit id="d3f29de16e9f8798d1932dbc922db0d447425dac" translate="yes" xml:space="preserve">
          <source>This approach lets you access A and B directly inside the library, and as Mylib.A and Mylib.B from outside. It also has the advantage that Mylib is no longer monolithic: if you use Mylib.A, only Mylib__A will be linked in, not Mylib__B.</source>
          <target state="translated">このアプローチでは、ライブラリの内部ではAとBに直接アクセスでき、外部からはMylib.AとMylib.Bとしてアクセスすることができます。また、Mylibはもはやモノリシックではないという利点もあります。Mylib.Aを使うと、Mylib__BではなくMylib__Aだけがリンクされます。</target>
        </trans-unit>
        <trans-unit id="1372a67563bf716e071b3b183d02ea2f598a4156" translate="yes" xml:space="preserve">
          <source>This attribute is attached to a function application and always takes an integer argument. Each time the inliner sees the attribute it behaves as follows:</source>
          <target state="translated">この属性は関数アプリケーションにアタッチされ、常に整数の引数を取ります。インライナがこの属性を見るたびに、以下のように動作します。</target>
        </trans-unit>
        <trans-unit id="09b4b8d9fa337a2eb876a44b79cb348c9e5f0855" translate="yes" xml:space="preserve">
          <source>This box behaves as an horizontal box if it fits on a single line, otherwise it behaves as a vertical box.</source>
          <target state="translated">このボックスは、一本の線上に収まる場合は横長のボックスとして振る舞い、そうでない場合は縦長のボックスとして振る舞います。</target>
        </trans-unit>
        <trans-unit id="b7625b4398585ec56f1ee579a0692c7819ab1dcb" translate="yes" xml:space="preserve">
          <source>This box features command &lt;code&gt;set_tab&lt;/code&gt; to define cell boundaries, and command &lt;code&gt;print_tab&lt;/code&gt; to move from cell to cell and split the line when there is no more cells to print on the line.</source>
          <target state="translated">このボックスには、セルの境界を定義するコマンド &lt;code&gt;set_tab&lt;/code&gt; と、セル &lt;code&gt;print_tab&lt;/code&gt; を移動して行に印刷するセルがなくなったときに行を分割するコマンドprint_tabがあります。</target>
        </trans-unit>
        <trans-unit id="00d886ace2f3bb025615806e435389e25f058b58" translate="yes" xml:space="preserve">
          <source>This box is the general purpose pretty-printing box.</source>
          <target state="translated">この箱は、汎用の可愛いプリントボックスです。</target>
        </trans-unit>
        <trans-unit id="4790a08c0b8ba22758a78bbaf58c7ad274884241" translate="yes" xml:space="preserve">
          <source>This box prints lines separated into cells of fixed width.</source>
          <target state="translated">このボックスは、一定の幅のセルに区切られた線を印刷します。</target>
        </trans-unit>
        <trans-unit id="9521c4e75869b633ff289e3509ef90a59f7e6d5f" translate="yes" xml:space="preserve">
          <source>This box prints material as much as possible on every line.</source>
          <target state="translated">このボックスは、すべての行で可能な限りの材料を印刷します。</target>
        </trans-unit>
        <trans-unit id="f4388d065629c7972988d67b92adade884cfc189" translate="yes" xml:space="preserve">
          <source>This box prints material on a single line.</source>
          <target state="translated">このボックスは、1行に材料を印刷します。</target>
        </trans-unit>
        <trans-unit id="0ed97b2eb7c12b24bf9da6774de6d18d44c03f8a" translate="yes" xml:space="preserve">
          <source>This box prints material on as many lines as break hints in the box.</source>
          <target state="translated">この箱は、箱の中のブレークヒントのように多くの行に材料を印刷します。</target>
        </trans-unit>
        <trans-unit id="bac037b45f5205c0421d44bb0a7e2d59de5d5640" translate="yes" xml:space="preserve">
          <source>This builds a runtime system with the required primitives. The OCaml linker generates bytecode for this custom runtime system. The bytecode is appended to the end of the custom runtime system, so that it will be automatically executed when the output file (custom runtime + bytecode) is launched.</source>
          <target state="translated">これは、必要なプリミティブでランタイムシステムを構築します。OCamlリンカーは、このカスタムランタイムシステム用のバイトコードを生成します。バイトコードはカスタムランタイムシステムの最後に追加され、出力ファイル(カスタムランタイム+バイトコード)が起動されたときに自動的に実行されます。</target>
        </trans-unit>
        <trans-unit id="b017452d5ed8ae35ceea59902e09d1ad45c8bde1" translate="yes" xml:space="preserve">
          <source>This can be used as a replacement for &lt;a href=&quot;format#VALasprintf&quot;&gt;&lt;code&gt;Format.asprintf&lt;/code&gt;&lt;/a&gt; to delay formatting decisions. Using the string returned by &lt;a href=&quot;format#VALasprintf&quot;&gt;&lt;code&gt;Format.asprintf&lt;/code&gt;&lt;/a&gt; in a formatting context forces formatting decisions to be taken in isolation, and the final string may be created prematurely. &lt;a href=&quot;format#VALdprintf&quot;&gt;&lt;code&gt;Format.dprintf&lt;/code&gt;&lt;/a&gt; allows delay of formatting decisions until the final formatting context is known. For example:</source>
          <target state="translated">これは、&lt;a href=&quot;format#VALasprintf&quot;&gt; &lt;code&gt;Format.asprintf&lt;/code&gt; の&lt;/a&gt;代わりに使用して、フォーマットの決定を遅らせることができます。&lt;a href=&quot;format#VALasprintf&quot;&gt; &lt;code&gt;Format.asprintf&lt;/code&gt; &lt;/a&gt;によって返された文字列をフォーマットコンテキストで使用すると、フォーマットの決定が個別に行われるようになり、最終的な文字列が時期尚早に作成される可能性があります。&lt;a href=&quot;format#VALdprintf&quot;&gt; &lt;code&gt;Format.dprintf&lt;/code&gt; を&lt;/a&gt;使用すると、最終的なフォーマットコンテキストがわかるまで、フォーマットの決定を遅らせることができます。例えば：</target>
        </trans-unit>
        <trans-unit id="736b6a8d2382f934d9e36c672b75eae9562bc868" translate="yes" xml:space="preserve">
          <source>This case combines the previous two: the representation of the type is made visible to all users, and no fresh type is generated.</source>
          <target state="translated">このケースは前の2つを組み合わせたもので、型の表現がすべてのユーザに見えるようになり、新鮮な型は生成されません。</target>
        </trans-unit>
        <trans-unit id="0b0b9d32c2c99f0a8a9065915f71e59738d0f44f" translate="yes" xml:space="preserve">
          <source>This chapter covers more advanced questions related to the limitations of polymorphic functions and types. There are some situations in OCaml where the type inferred by the type checker may be less generic than expected. Such non-genericity can stem either from interactions between side-effect and typing or the difficulties of implicit polymorphic recursion and higher-rank polymorphism.</source>
          <target state="translated">この章では、多相関数と型の制限に関するより高度な質問を扱います。OCamlでは、型チェッカーによって推定される型が予想よりも汎用性が低い場合があります。このような非汎用性は、副作用と型付けの間の相互作用、または暗黙の多相再帰や高ランク多相性の難しさのいずれかに起因しています。</target>
        </trans-unit>
        <trans-unit id="e99967e6f113e515abf96820acbd0c907f9ea256" translate="yes" xml:space="preserve">
          <source>This chapter describes OCamldoc, a tool that generates documentation from special comments embedded in source files. The comments used by OCamldoc are of the form (**&amp;hellip;*) and follow the format described in section &lt;a href=&quot;#s%3Aocamldoc-comments&quot;&gt;16.2&lt;/a&gt;.</source>
          <target state="translated">この章では、ソースファイルに埋め込まれた特別なコメントからドキュメントを生成するツールであるOCamldocについて説明します。OCamldocで使用されるコメントは、形式（**&amp;hellip;*）であり、セクション&lt;a href=&quot;#s%3Aocamldoc-comments&quot;&gt;16.2で&lt;/a&gt;説明されている形式に従います。</target>
        </trans-unit>
        <trans-unit id="22979b22da128bdede671815a07fda413464a01f" translate="yes" xml:space="preserve">
          <source>This chapter describes how the execution of OCaml programs can be profiled, by recording how many times functions are called, branches of conditionals are taken, &amp;hellip;</source>
          <target state="translated">この章では、関数が呼び出された回数、条件の分岐が取られた回数を記録することにより、OCamlプログラムの実行をプロファイリングする方法について説明します。</target>
        </trans-unit>
        <trans-unit id="fc58c64bbca12c120e6be347ae738db5e914ab57" translate="yes" xml:space="preserve">
          <source>This chapter describes how user-defined primitives, written in C, can be linked with OCaml code and called from OCaml functions, and how these C functions can call back to OCaml code.</source>
          <target state="translated">この章では、Cで書かれたユーザー定義プリミティブをOCamlコードとリンクしてOCaml関数から呼び出す方法と、これらのC関数がOCamlコードにコールバックする方法について説明します。</target>
        </trans-unit>
        <trans-unit id="084829076e627e4169c9229a38a24e09ad828c7b" translate="yes" xml:space="preserve">
          <source>This chapter describes language extensions and convenience features that are implemented in OCaml, but not described in the OCaml reference manual.</source>
          <target state="translated">この章では、OCamlに実装されているが、OCamlリファレンスマニュアルには記載されていない言語拡張や便利な機能について説明します。</target>
        </trans-unit>
        <trans-unit id="995a07b1158b72f353eb1ac428ac4123f6853088" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml batch compiler ocamlc, which compiles OCaml source files to bytecode object files and links these object files to produce standalone bytecode executable files. These executable files are then run by the bytecode interpreter ocamlrun.</source>
          <target state="translated">この章では、OCamlのソースファイルをバイトコードオブジェクトファイルにコンパイルし、これらのオブジェクトファイルをリンクしてスタンドアロンのバイトコード実行ファイルを生成するOCamlcバッチコンパイラについて説明します。これらの実行ファイルは、バイトコードインタプリタ ocamlrun によって実行されます。</target>
        </trans-unit>
        <trans-unit id="6b065bf42750f41d77bac34c5d6dddd1489b34a0" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml core library, which is composed of declarations for built-in types and exceptions, plus the module Stdlib that provides basic operations on these built-in types. The Stdlib module is special in two ways:</source>
          <target state="translated">この章では、組み込み型と例外の宣言と、これらの組み込み型に対する基本的な操作を提供するモジュールStdlibから構成されるOCamlコアライブラリについて説明します。Stdlibモジュールは2つの点で特別です。</target>
        </trans-unit>
        <trans-unit id="36bc4b25a8de2e3c8b0cfa69654d56ac54e08f29" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml front-end, which declares the abstract syntax tree used by the compiler, provides a way to parse, print and pretty-print OCaml code, and ultimately allows one to write abstract syntax tree preprocessors invoked via the -ppx flag (see chapters &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; and &lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt;).</source>
          <target state="translated">この章では、コンパイラが使用する抽象構文ツリーを宣言し、OCamlコードを解析、印刷、プリティプリントする方法を提供し、最終的に-ppxフラグを介して呼び出される抽象構文ツリープリプロセッサを記述できるようにするOCamlフロントエンドについて説明します。 （第&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;章と第&lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt;章を参照）。</target>
        </trans-unit>
        <trans-unit id="8c5ce841e2ff9db70cbc0f9643176a189658c748" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml high-performance native-code compiler ocamlopt, which compiles OCaml source files to native code object files and links these object files to produce standalone executables.</source>
          <target state="translated">この章では、OCamlのソースファイルをネイティブコードのオブジェクトファイルにコンパイルし、これらのオブジェクトファイルをリンクしてスタンドアロンの実行ファイルを生成するOCamloptというOCaml高性能ネイティブコードコンパイラについて説明します。</target>
        </trans-unit>
        <trans-unit id="07729068091da08d36b2e49ba6d4e4d523bd49f5" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml instrumented runtime, a runtime variant allowing the collection of events and metrics.</source>
          <target state="translated">この章では、イベントとメトリクスの収集を可能にするランタイムバリアントであるOCamlのインストルメントランタイムについて説明します。</target>
        </trans-unit>
        <trans-unit id="69ddd94c98a17da2cbc644dd1e169145a2b86378" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml source-level replay debugger ocamldebug.</source>
          <target state="translated">この章では、OCamlのソースレベルリプレイデバッガ ocamldebugについて説明します。</target>
        </trans-unit>
        <trans-unit id="1b3bef73d988061d29d6941712ad9747d92ad9a4" translate="yes" xml:space="preserve">
          <source>This chapter describes the functions provided by the OCaml standard library. The modules from the standard library are automatically linked with the user&amp;rsquo;s object code files by the ocamlc command. Hence, these modules can be used in standalone programs without having to add any .cmo file on the command line for the linking phase. Similarly, in interactive use, these globals can be used in toplevel phrases without having to load any .cmo file in memory.</source>
          <target state="translated">この章では、OCaml標準ライブラリが提供する機能について説明します。標準ライブラリのモジュールは、ocamlcコマンドによってユーザーのオブジェクトコードファイルに自動的にリンクされます。したがって、これらのモジュールは、リンクフェーズのコマンドラインに.cmoファイルを追加しなくても、スタンドアロンプ​​ログラムで使用できます。同様に、インタラクティブな使用では、これらのグローバルは、メモリに.cmoファイルをロードしなくてもトップレベルのフレーズで使用できます。</target>
        </trans-unit>
        <trans-unit id="43ad0f253c7b2080f9dd53e8aa8d98648421148a" translate="yes" xml:space="preserve">
          <source>This chapter describes the toplevel system for OCaml, that permits interactive use of the OCaml system through a read-eval-print loop (REPL). In this mode, the system repeatedly reads OCaml phrases from the input, then typechecks, compile and evaluate them, then prints the inferred type and result value, if any. The system prints a # (sharp) prompt before reading each phrase.</source>
          <target state="translated">この章では、読み取り-評価-印刷ループ(REPL)を介してOCamlシステムをインタラクティブに使用できるOCaml用のtoplevelシステムについて説明します。このモードでは、システムは入力から OCaml フレーズを繰り返し読み込み、タイプチェック、コンパイル、評価を行い、推論されたタイプと結果の値があればそれを表示します。システムは、各フレーズを読み込む前に#(シャープ)プロンプトを表示します。</target>
        </trans-unit>
        <trans-unit id="69c3d7e39acb1d5e622db5124a13613835b7634c" translate="yes" xml:space="preserve">
          <source>This chapter describes two program generators: ocamllex, that produces a lexical analyzer from a set of regular expressions with associated semantic actions, and ocamlyacc, that produces a parser from a grammar with associated semantic actions.</source>
          <target state="translated">この章では、2つのプログラム生成器について説明します:ocamllexは、関連する意味的な動作を持つ正規表現の集合から語彙解析器を生成します。</target>
        </trans-unit>
        <trans-unit id="210573b7ce8135e7e064f066b6ebcd12cb7b792a" translate="yes" xml:space="preserve">
          <source>This chapter details each of these situations and, if it is possible, how to recover genericity.</source>
          <target state="translated">この章では、これらのそれぞれの状況を詳細に説明し、可能であれば、どのようにしてジェネラリティを回復するかを説明します。</target>
        </trans-unit>
        <trans-unit id="34e2681602b9187f866a2387ff78cec658492716" translate="yes" xml:space="preserve">
          <source>This chapter gives an overview of the new features in OCaml 3: labels, and polymorphic variants.</source>
          <target state="translated">この章では、OCaml 3の新機能であるラベルと多相バリアントの概要を説明します。</target>
        </trans-unit>
        <trans-unit id="3588c35304425734153b099a7cdbb31b7ab306d6" translate="yes" xml:space="preserve">
          <source>This chapter gives an overview of the object-oriented features of OCaml.</source>
          <target state="translated">この章では、OCamlのオブジェクト指向機能の概要を説明します。</target>
        </trans-unit>
        <trans-unit id="f743cd4aa8589a6f7ccb3236942f7a143fef8068" translate="yes" xml:space="preserve">
          <source>This chapter introduces the module system of OCaml.</source>
          <target state="translated">この章では、OCamlのモジュールシステムを紹介します。</target>
        </trans-unit>
        <trans-unit id="641fe4386aeca969ab9cc8d868ad085c0c8ea3bb" translate="yes" xml:space="preserve">
          <source>This construction is useful because the type constructors it introduces can be used in places where a type variable is not allowed. For instance, one can use it to define an exception in a local module within a polymorphic function.</source>
          <target state="translated">この構文は、導入された型コンストラクタを型変数が許されていない場所で使用することができるので便利です。例えば、これを使用して、ポリモーフィック関数内のローカルモジュールで例外を定義することができます。</target>
        </trans-unit>
        <trans-unit id="42d44fb398c8f2ad20178f128be9005c0c3a7520" translate="yes" xml:space="preserve">
          <source>This correspond to the commuting label mode of Objective Caml 3.00 through 3.02, with some additional flexibility on total applications. The so-called classic mode (-nolabels options) is now deprecated for normal use.</source>
          <target state="translated">これは、Objective Caml 3.00 から 3.02 の通勤ラベルモードに対応しています。いわゆるクラシックモード (-nolabels オプション)は、通常の使用では非推奨となりました。</target>
        </trans-unit>
        <trans-unit id="0703f0be9e37d286e36c6f06a582f656747a10b9" translate="yes" xml:space="preserve">
          <source>This creates a new module &lt;code&gt;IntHashtbl&lt;/code&gt;, with a new type &lt;code&gt;'a&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;IntHashtbl.t&lt;/code&gt; of tables from &lt;code&gt;int&lt;/code&gt; to &lt;code&gt;'a&lt;/code&gt;. In this example, &lt;code&gt;h&lt;/code&gt; contains &lt;code&gt;string&lt;/code&gt; values so its type is &lt;code&gt;string&amp;nbsp;IntHashtbl.t&lt;/code&gt;.</source>
          <target state="translated">これにより、 &lt;code&gt;int&lt;/code&gt; から &lt;code&gt;'a&lt;/code&gt; までのテーブルの新しいタイプ &lt;code&gt;'a&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;IntHashtbl.t&lt;/code&gt; &lt;code&gt;IntHashtbl&lt;/code&gt; を持つ新しいモジュール &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;IntHashtblが作成されます。この例では、 &lt;code&gt;h&lt;/code&gt; には &lt;code&gt;string&lt;/code&gt; 値が含まれているため、その型は &lt;code&gt;string&amp;nbsp;IntHashtbl.t&lt;/code&gt; です。&lt;br/&gt;</target>
        </trans-unit>
        <trans-unit id="c2d68deb1edda584ae4e6e7569ccd1f525a47a80" translate="yes" xml:space="preserve">
          <source>This creates a new module &lt;code&gt;PairsMap&lt;/code&gt;, with a new type &lt;code&gt;'a&amp;nbsp;PairsMap.t&lt;/code&gt; of maps from &lt;code&gt;int&amp;nbsp;*&amp;nbsp;int&lt;/code&gt; to &lt;code&gt;'a&lt;/code&gt;. In this example, &lt;code&gt;m&lt;/code&gt; contains &lt;code&gt;string&lt;/code&gt; values so its type is &lt;code&gt;string&amp;nbsp;PairsMap.t&lt;/code&gt;.</source>
          <target state="translated">これにより、新しいタイプ &lt;code&gt;'a&amp;nbsp;PairsMap.t&lt;/code&gt; の &lt;code&gt;int&amp;nbsp;*&amp;nbsp;int&lt;/code&gt; から &lt;code&gt;'a&lt;/code&gt; へのマップを持つ新しいモジュール &lt;code&gt;PairsMap&lt;/code&gt; が作成されます。この例では、 &lt;code&gt;m&lt;/code&gt; には &lt;code&gt;string&lt;/code&gt; 値が含まれているため、その型は &lt;code&gt;string&amp;nbsp;PairsMap.t&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="390961a477909cf3be486ca4a271404c23f7a126" translate="yes" xml:space="preserve">
          <source>This creates a new module &lt;code&gt;PairsSet&lt;/code&gt;, with a new type &lt;code&gt;PairsSet.t&lt;/code&gt; of sets of &lt;code&gt;int&amp;nbsp;*&amp;nbsp;int&lt;/code&gt;.</source>
          <target state="translated">これにより、 &lt;code&gt;int&amp;nbsp;*&amp;nbsp;int&lt;/code&gt; セットの新しいタイプ &lt;code&gt;PairsSet.t&lt;/code&gt; を持つ新しいモジュール &lt;code&gt;PairsSet&lt;/code&gt; が作成されます。</target>
        </trans-unit>
        <trans-unit id="75cd13267b497efe97847c8300244e98191e876f" translate="yes" xml:space="preserve">
          <source>This creates the bytecode file mytoplevel, containing the OCaml toplevel system, plus the code from the three .cmo files. This toplevel is directly executable and is started by:</source>
          <target state="translated">これにより、バイトコードファイルmytoplevelが作成され、OCamlトップレベルシステムと3つの.cmoファイルのコードが含まれています。このトップレベルは直接実行可能であり、以下のコマンドで起動されます。</target>
        </trans-unit>
        <trans-unit id="f5b1409a54230dba201ee4c701c307570dc6eae6" translate="yes" xml:space="preserve">
          <source>This declaration does more than hiding the y method, it also makes the type c incompatible with any other closed object type, meaning that only o will be of type c. In that respect it behaves similarly to private record types. But private row types are more flexible with respect to incremental refinement. This feature can be used in combination with functors.</source>
          <target state="translated">この宣言は、yメソッドを隠すだけでなく、c型を他の閉じたオブジェクト型と互換性のないものにします。しかし、プライベート行型は、インクリメンタル・リファインメントに関しては、より柔軟性があります。この機能は、ファンクタと組み合わせて使用することができます。</target>
        </trans-unit>
        <trans-unit id="62b4223715d06df11caf2304744d5adfa549ab4f" translate="yes" xml:space="preserve">
          <source>This declaration expresses that a value of type number is either an integer, a floating-point number, or the constant Error representing the result of an invalid operation (e.g. a division by zero).</source>
          <target state="translated">この宣言は、number型の値が整数、浮動小数点数、定数のいずれかであることを表現します。 Error 無効な演算の結果を表すエラー(例:ゼロによる除算)。</target>
        </trans-unit>
        <trans-unit id="650dca8821c23c4d144204d01cac7fd4b83e068e" translate="yes" xml:space="preserve">
          <source>This defines name&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name&lt;sub&gt;n&lt;/sub&gt; as mutually recursive functions local to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;.</source>
          <target state="translated">これは、名前&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;名前&lt;sub&gt;n&lt;/sub&gt;を&lt;a href=&quot;#expr&quot;&gt;exprに&lt;/a&gt;ローカルな相互再帰関数として定義します。</target>
        </trans-unit>
        <trans-unit id="ab9d147194e992eb8205321a938f103ca896c88b" translate="yes" xml:space="preserve">
          <source>This defines the type constructor as an abbreviation for the type expression on the right of the = sign.</source>
          <target state="translated">これは、=記号の右にある型表現の略として、型コンストラクタを定義しています。</target>
        </trans-unit>
        <trans-unit id="749cd341985f67a650d96523cab212ab33c78584" translate="yes" xml:space="preserve">
          <source>This defines the value name name as a function with type type that executes by calling the given C function. For instance, here is how the int_of_string primitive is declared in the standard library module Stdlib:</source>
          <target state="translated">これは、与えられたC言語の関数を呼び出すことで実行される型を持つ関数として、値の名前を定義します。例えば、標準ライブラリモジュールStdlibでint_of_stringプリミティブがどのように宣言されているかというと、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="d5ba8edf36d0fb0da29929bdb415469de948dad5" translate="yes" xml:space="preserve">
          <source>This definition reads as follows: a binary tree containing values of type 'a (an arbitrary type) is either empty, or is a node containing one value of type 'a and two subtrees also containing values of type 'a, that is, two 'a btree.</source>
          <target state="translated">この定義は次のように読み取れます:型'a(任意の型)の値を含むバイナリツリーは空か、型'aの値を1つ含むノードと型'aの値を含む2つのサブツリーを含むノード、つまり2つの型'a btreeです。</target>
        </trans-unit>
        <trans-unit id="8d8e09fb17ca3bdcd19c8523134e3e779a73a386" translate="yes" xml:space="preserve">
          <source>This directive registers the function named printer-name (a value path) as a printer for values whose types match the argument type of the function. That is, the toplevel loop will call printer-name when it has such a value to print.</source>
          <target state="translated">このディレクティブは,関数の引数の型と一致する値のプリンタとして,printer-nameという名前の関数(値のパス)を登録します.つまり、トップレベルループは、そのような値があるときに printer-name を呼び出して印刷します。</target>
        </trans-unit>
        <trans-unit id="2e68ea2c0517c1d20b6ed32dd8f6c253ddb6f201" translate="yes" xml:space="preserve">
          <source>This document is intended as a reference manual for the OCaml language. It lists the language constructs, and gives their precise syntax and informal semantics. It is by no means a tutorial introduction to the language: there is not a single example. A good working knowledge of OCaml is assumed.</source>
          <target state="translated">この文書は、OCaml言語のリファレンスマニュアルとして意図されています。言語の構成要素をリストアップし、その正確な構文と非公式な意味論を示しています。これは決して言語のチュートリアル的な導入ではありません:例は一つもありません。OCamlについての十分な知識があることが前提となっています。</target>
        </trans-unit>
        <trans-unit id="74df0e696ad77b21b87792ac16ae61fcae218478" translate="yes" xml:space="preserve">
          <source>This engine makes it possible to implement a low-overhead memory profiler as an OCaml library.</source>
          <target state="translated">このエンジンにより、低オーバーヘッドのメモリプロファイラをOCamlライブラリとして実装することが可能になります。</target>
        </trans-unit>
        <trans-unit id="f3fa2a6f69f904187160e52f45b06e671158e7a1" translate="yes" xml:space="preserve">
          <source>This enters a regular toplevel loop, except that the code from foo.cmo, bar.cmo and gee.cmo is already loaded in memory, just as if you had typed:</source>
          <target state="translated">これは通常のトップレベルループに入りますが、foo.cmo,bar.cmo,gee.cmoのコードはすでにメモリにロードされていることを除いては、まるでタイプしたかのようです。</target>
        </trans-unit>
        <trans-unit id="ac5c02e5a2be940db6035f15a82bb532610ff549" translate="yes" xml:space="preserve">
          <source>This error appears when trying to link an incomplete or incorrectly ordered set of files. Either you have forgotten to provide an implementation for the compilation unit named mod on the command line (typically, the file named mod.cmo, or a library containing that file). Fix: add the missing .ml or .cmo file to the command line. Or, you have provided an implementation for the module named mod, but it comes too late on the command line: the implementation of mod must come before all bytecode object files that reference mod. Fix: change the order of .ml and .cmo files on the command line.</source>
          <target state="translated">このエラーは、不完全なファイルや順序が間違っているファイルのセットをリンクしようとしたときに表示されます。mod という名前のコンパイルユニットの実装をコマンドラインで提供するのを忘れているか(通常は mod.cmo という名前のファイルか、そのファイルを含むライブラリ)、または、.ml または .cmo という名前のファイルをコマンドラインに追加するのを忘れているかのどちらかです。修正方法:不足している .ml または .cmo ファイルをコマンドラインに追加してください。あるいは、mod という名前のモジュールの実装を提供しているが、コマンドラインでは遅すぎます:mod の実装は mod を参照するすべてのバイトコードオブジェクトファイルの前に来なければなりません。修正方法:コマンドライン上の .ml と .cmo ファイルの順番を変更してください。</target>
        </trans-unit>
        <trans-unit id="01feea14de8e0c629d6af124eee3f63c75a3e58e" translate="yes" xml:space="preserve">
          <source>This error appears when trying to link code that calls external functions written in C. As explained in chapter &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;, such code must be linked with C libraries that implement the required f C function. If the C libraries in question are not shared libraries (DLLs), the code must be linked in &amp;ldquo;custom runtime&amp;rdquo; mode. Fix: add the required C libraries to the command line, and possibly the -custom option.</source>
          <target state="translated">このエラーは、Cで記述された外部関数を呼び出すコードをリンクしようとすると表示されます。第&lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;章で説明したように、このようなコードは、必要なfC関数を実装するCライブラリにリンクする必要があります。問題のCライブラリが共有ライブラリ（DLL）でない場合、コードは「カスタムランタイム」モードでリンクする必要があります。修正：必要なCライブラリをコマンドラインに追加し、場合によっては-customオプションを追加します。</target>
        </trans-unit>
        <trans-unit id="c3322e1b78b0d097c04a82c8abad2b9e17591c8f" translate="yes" xml:space="preserve">
          <source>This explicit overriding annotation also works for val and inherit:</source>
          <target state="translated">この明示的なオーバーライドアノテーションは,valや inheritでも動作します.</target>
        </trans-unit>
        <trans-unit id="1c31e1e38cacd668c448b1b245b9768d081710af" translate="yes" xml:space="preserve">
          <source>This expression evaluates to a functional value with one argument. When this function is applied to a value v, this value is matched against each pattern &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. If one of these matchings succeeds, that is, if the value v matches the pattern &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; for some i, then the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; associated to the selected pattern is evaluated, and its value becomes the value of the function application. The evaluation of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; takes place in an environment enriched by the bindings performed during the matching.</source>
          <target state="translated">この式は、1つの引数を持つ関数値に評価されます。この関数が値vに適用されると、この値は各パターン&lt;a href=&quot;patterns#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;から&lt;a href=&quot;patterns#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;nに&lt;/sub&gt;一致します。これらの一致の1つが成功した場合、つまり、値vが一部のiのパターン&lt;a href=&quot;patterns#pattern&quot;&gt;パターン&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;と一致した場合、選択したパターンに関連付けられた式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;が評価され、その値が関数適用の値になります。&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;の評価は、マッチング中に実行されたバインディングによって強化された環境で行われます。</target>
        </trans-unit>
        <trans-unit id="15e34d384bc13e41a20958589d5dd84188cb9c53" translate="yes" xml:space="preserve">
          <source>This expression has type t&lt;sub&gt;1&lt;/sub&gt;, but is used with type t&lt;sub&gt;2&lt;/sub&gt;</source>
          <target state="translated">この式は、型T有する&lt;sub&gt;1&lt;/sub&gt;が、型Tと共に使用される&lt;sub&gt;2&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="c752faae770745f4efadec9ad9e3c86712116bf8" translate="yes" xml:space="preserve">
          <source>This expression is equivalent to:</source>
          <target state="translated">この式に相当します。</target>
        </trans-unit>
        <trans-unit id="a8f6d05e23df51dd5500167d330c8fab6501e536" translate="yes" xml:space="preserve">
          <source>This extension allows user to define empty variants. Empty variant type can be eliminated by refutation case of pattern matching.</source>
          <target state="translated">この拡張機能により、ユーザは空のバリアントを定義することができます。空のバリアント型は、パターンマッチングの反論ケースで排除することができます。</target>
        </trans-unit>
        <trans-unit id="c21aac0cfc0a526fe8feeb656d5151ae30a38c66" translate="yes" xml:space="preserve">
          <source>This extension is intended to provide a convenient syntax for working with monads and applicatives.</source>
          <target state="translated">この拡張機能は、モナドやアプリカティブを扱うのに便利な構文を提供することを目的としています。</target>
        </trans-unit>
        <trans-unit id="ba4fa874a00f72ae6a3e4ed02825e2050e5a7719" translate="yes" xml:space="preserve">
          <source>This extension makes it possible to open any module expression in module structures and expressions. A similar mechanism is also available inside module types, but only for extended module paths (e.g. F(X).G(Y)).</source>
          <target state="translated">この拡張により、モジュール構造や式の中で任意のモジュール式を開くことが可能になります。同様のメカニズムはモジュール型の内部でも利用可能ですが、拡張されたモジュールパス (例えば F(X).G(Y))に対してのみ利用可能です。</target>
        </trans-unit>
        <trans-unit id="4bded797c2b65154bcb84bdfa2fb5ae024b3d73a" translate="yes" xml:space="preserve">
          <source>This extension provides syntactic sugar for getting and setting elements for user-defined indexed types. For instance, we can define python-like dictionaries with</source>
          <target state="translated">この拡張機能は、ユーザー定義のインデックス付き型の要素を取得したり設定したりするための構文的な糖質を提供します。例えば、パイソンのような辞書を定義するには</target>
        </trans-unit>
        <trans-unit id="3ced06d009b619786712d80c35d7e9694c054e2d" translate="yes" xml:space="preserve">
          <source>This extension provides syntactic sugar for getting and setting elements in the arrays provided by the &lt;a href=&quot;libref/bigarray&quot;&gt;Bigarray&lt;/a&gt; module.</source>
          <target state="translated">この拡張機能は、&lt;a href=&quot;libref/bigarray&quot;&gt;Bigarray&lt;/a&gt;モジュールによって提供される配列内の要素を取得および設定するための構文糖衣構文を提供します。</target>
        </trans-unit>
        <trans-unit id="2b1d07b08e65aec904b4829d528dfb8d3dbc575e" translate="yes" xml:space="preserve">
          <source>This facility is currently available on all platforms supported by OCaml except Cygwin 64 bits.</source>
          <target state="translated">この機能は現在、Cygwin 64 ビットを除く OCaml でサポートされているすべてのプラットフォームで利用可能です。</target>
        </trans-unit>
        <trans-unit id="8aaa2dee7862002847ec215725a07465e9cee221" translate="yes" xml:space="preserve">
          <source>This filename can also be specified using the OCAML_EVENTLOG_PREFIX environment variable. The given path will be suffixed with {.PID}.eventlog.</source>
          <target state="translated">このファイル名は、環境変数OCAML_EVENTLOG_PREFIXを使って指定することもできます。与えられたパスには{.PID}.eventlogが接尾辞として付けられます。</target>
        </trans-unit>
        <trans-unit id="d118477856b3c7c25f93002b3254e61bdd8c9a57" translate="yes" xml:space="preserve">
          <source>This form of attributes can also be inserted after the `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; in polymorphic variant type expressions (&lt;a href=&quot;types#tag-spec-first&quot;&gt;tag-spec-first&lt;/a&gt;, &lt;a href=&quot;types#tag-spec&quot;&gt;tag-spec&lt;/a&gt;, &lt;a href=&quot;types#tag-spec-full&quot;&gt;tag-spec-full&lt;/a&gt;) or after the &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; in &lt;a href=&quot;types#method-type&quot;&gt;method-type&lt;/a&gt;.</source>
          <target state="translated">属性のこの形態はまた`の後に挿入することができる&lt;a href=&quot;names#tag-name&quot;&gt;タグ名&lt;/a&gt;多型バリアント型の式で（&lt;a href=&quot;types#tag-spec-first&quot;&gt;タグ・スペック最初&lt;/a&gt;、&lt;a href=&quot;types#tag-spec&quot;&gt;タグ・スペック&lt;/a&gt;、&lt;a href=&quot;types#tag-spec-full&quot;&gt;タグ・スペックフル&lt;/a&gt;）または後に&lt;a href=&quot;names#method-name&quot;&gt;メソッド名&lt;/a&gt;で&lt;a href=&quot;types#method-type&quot;&gt;メソッド型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ebb9471d9b8d494e18c82c68d8f753fc5a0fc194" translate="yes" xml:space="preserve">
          <source>This function can be applied to objects of type money or money2.</source>
          <target state="translated">この関数は、moneyまたはmoney2型のオブジェクトに適用することができます。</target>
        </trans-unit>
        <trans-unit id="45f742d762c2f337f9316533c0c01063fbc47ef8" translate="yes" xml:space="preserve">
          <source>This function conforms to the specification of POSIX.1-2008 for the &lt;code&gt;basename&lt;/code&gt; utility.</source>
          <target state="translated">この関数は、 &lt;code&gt;basename&lt;/code&gt; ユーティリティのPOSIX.1-2008の仕様に準拠しています。</target>
        </trans-unit>
        <trans-unit id="6687a7963ca256cf05cde1098887f34f0c554208" translate="yes" xml:space="preserve">
          <source>This function does not allocate memory, but tries to run the postponed callbacks for already allocated memory blocks (of course, these callbacks may allocate).</source>
          <target state="translated">この関数はメモリを確保しませんが、すでに確保されているメモリブロックに対して延期されたコールバックを実行しようとします(もちろん、これらのコールバックは確保される可能性があります)。</target>
        </trans-unit>
        <trans-unit id="68449acffb76876acb29d71c9df112633cbec2b0" translate="yes" xml:space="preserve">
          <source>This function does nothing in this implementation.</source>
          <target state="translated">この関数は、この実装では何もしません。</target>
        </trans-unit>
        <trans-unit id="3b93512b013a1d7422171a6bb6941e6102fbeb0a" translate="yes" xml:space="preserve">
          <source>This function is safe because the byte sequence &lt;code&gt;s&lt;/code&gt; will never be accessed or mutated after &lt;code&gt;unsafe_to_string&lt;/code&gt; is called. The &lt;code&gt;string_init&lt;/code&gt; code gives up ownership of &lt;code&gt;s&lt;/code&gt;, and returns the ownership of the resulting string to its caller.</source>
          <target state="translated">バイトシーケンスので、この機能は安全である &lt;code&gt;s&lt;/code&gt; 後にアクセスしたり、突然変異させることが決して &lt;code&gt;unsafe_to_string&lt;/code&gt; と呼ばれています。 &lt;code&gt;string_init&lt;/code&gt; のコードは、所有権放棄 &lt;code&gt;s&lt;/code&gt; 、その呼び出し元に結果の文字列の所有権を返します。</target>
        </trans-unit>
        <trans-unit id="1f9678c9920e8bd6fa3351bc87366633dae969b5" translate="yes" xml:space="preserve">
          <source>This function might be written like so:</source>
          <target state="translated">この関数は次のように書かれているかもしれません。</target>
        </trans-unit>
        <trans-unit id="c9cc7e820a82b580a34f0b2bb19198a32fb2d1dc" translate="yes" xml:space="preserve">
          <source>This function will erase non-string tag formatting functions.</source>
          <target state="translated">この関数は、文字列ではないタグの書式設定関数を消去します。</target>
        </trans-unit>
        <trans-unit id="2f8a6a2bcdafd5f49ba5cdcd976330cb7e69f76f" translate="yes" xml:space="preserve">
          <source>This functional, along with a number of other list and array functionals, is predefined because it is often useful, but there is nothing magic with it: it can easily be defined as follows.</source>
          <target state="translated">この関数は、他の多くのリスト関数や配列関数と一緒に、便利なことが多いので事前に定義されていますが、魔法のようなものは何もありません:以下のように簡単に定義できます。</target>
        </trans-unit>
        <trans-unit id="f98ed33477f247dffac90e7d27b65afcdf57df27" translate="yes" xml:space="preserve">
          <source>This generates a new type constructor and defines associated constructors or fields, through which values of that type can be directly built or inspected.</source>
          <target state="translated">これは新しい型のコンストラクタを生成し、関連するコンストラクタやフィールドを定義します。</target>
        </trans-unit>
        <trans-unit id="89ad557334e8e1d878c785f430b3e375436f8b96" translate="yes" xml:space="preserve">
          <source>This idiom can in turn be used to retrieve an object whose type has been weakened:</source>
          <target state="translated">このイディオムは、型が弱くなったオブジェクトを取得するために、順番に使用することができます。</target>
        </trans-unit>
        <trans-unit id="70991f0b7fe10b4796387e57d8f588f1325f5ec1" translate="yes" xml:space="preserve">
          <source>This idiom guarantees that Myset is compatible with Set, but allows it to represent sets internally in a different way.</source>
          <target state="translated">このイディオムは、MysetがSetと互換性があることを保証しますが、異なる方法で内部的に集合を表現することを可能にします。</target>
        </trans-unit>
        <trans-unit id="751a6509444b430d2b4388b31e1c9693d69713df" translate="yes" xml:space="preserve">
          <source>This is &lt;em&gt;not&lt;/em&gt; the semantics adopted by OCaml.</source>
          <target state="translated">これはOCamlで採用されているセマンティクスではあり&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="58da15a38848eb6e8733fd04e3d04f1485f3fce9" translate="yes" xml:space="preserve">
          <source>This is also available (since OCaml 4.06) for local opens in class expressions and class type expressions.</source>
          <target state="translated">これは、クラス式やクラス型式でのローカルオープンにも利用できます(OCaml 4.06以降)。</target>
        </trans-unit>
        <trans-unit id="9768346232217703b79f946958f318884f387d78" translate="yes" xml:space="preserve">
          <source>This is an experimental extension of OCaml: the class of recursive definitions accepted, as well as its dynamic semantics are not final and subject to change in future releases.</source>
          <target state="translated">これはOCamlの実験的な拡張です:受け入れられた再帰的な定義のクラスとその動的なセマンティクスは最終的なものではなく、将来のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="abf0eb306419907e3403ce9f96c3ef7450a9208f" translate="yes" xml:space="preserve">
          <source>This is another instance of friend functions as seen in section &lt;a href=&quot;objectexamples#s%3Afriends&quot;&gt;3.17&lt;/a&gt;. Indeed, this is the same mechanism used in the module Set in the absence of objects.</source>
          <target state="translated">これは、セクション&lt;a href=&quot;objectexamples#s%3Afriends&quot;&gt;3.17に&lt;/a&gt;見られるフレンド関数の別のインスタンスです。実際、これは、オブジェクトがない場合にモジュールSetで使用されるのと同じメカニズムです。</target>
        </trans-unit>
        <trans-unit id="6c683f5551fbf795dd6f0010c7e2c94e3d36bfd7" translate="yes" xml:space="preserve">
          <source>This is because Lazy.force memoizes the result of the forced expression. In other words, every subsequent call of Lazy.force on that expression returns the result of the first computation without recomputing the lazy expression. Let us force lazy_two once again.</source>
          <target state="translated">これは、Lazy.forceが強制式の結果を記憶するからです。言い換えれば、その式に対する後続の Lazy.force の呼び出しのたびに、レイジー式を再計算することなく、最初の計算結果が返されるということです。もう一度Lazy_twoを強制してみましょう。</target>
        </trans-unit>
        <trans-unit id="ad067981738b53b159d177a530e65b07049d0d76" translate="yes" xml:space="preserve">
          <source>This is by far the most common type error in programs. Type t&lt;sub&gt;1&lt;/sub&gt; is the type inferred for the expression (the part of the program that is displayed in the error message), by looking at the expression itself. Type t&lt;sub&gt;2&lt;/sub&gt; is the type expected by the context of the expression; it is deduced by looking at how the value of this expression is used in the rest of the program. If the two types t&lt;sub&gt;1&lt;/sub&gt; and t&lt;sub&gt;2&lt;/sub&gt; are not compatible, then the error above is produced.</source>
          <target state="translated">これは、プログラムで最も一般的なタイプエラーです。型T &lt;sub&gt;1は&lt;/sub&gt;式自体を見ることによって、式（エラーメッセージに表示されているプログラムの一部）のための推論タイプです。型T &lt;sub&gt;2は、&lt;/sub&gt;式の文脈が期待タイプです。これは、この式の値がプログラムの残りの部分でどのように使用されているかを調べることによって推測されます。T二種類の場合&lt;sub&gt;1&lt;/sub&gt;及びT &lt;sub&gt;2は&lt;/sub&gt;互換性がない場合、上記のエラーが生成されます。</target>
        </trans-unit>
        <trans-unit id="f82fc074dee53936731175b8537edb3c787511a9" translate="yes" xml:space="preserve">
          <source>This is done by forming judgements on the &lt;em&gt;effects&lt;/em&gt; and the &lt;em&gt;coeffects&lt;/em&gt; that might be performed were the expression to be executed. Effects talk about how the expression might affect the world; coeffects talk about how the world might affect the expression.</source>
          <target state="translated">これは、&lt;em&gt;効果&lt;/em&gt;に関する判断を形成することによって行われ、&lt;em&gt;実行さ&lt;/em&gt;れる可能性のある&lt;em&gt;共&lt;/em&gt;&lt;em&gt;効果&lt;/em&gt;は、実行される式でした。効果は、表現が世界にどのように影響するかについて話します。共効果は、世界が表現にどのように影響するかについて話します。</target>
        </trans-unit>
        <trans-unit id="e1b690baac19cb0582baf96deb9492b21952c740" translate="yes" xml:space="preserve">
          <source>This is done using first class modules (see chapter &lt;a href=&quot;firstclassmodules#s%3Afirst-class-modules&quot;&gt;8.5&lt;/a&gt;).</source>
          <target state="translated">これは、ファーストクラスのモジュールを使用して行われます（&lt;a href=&quot;firstclassmodules#s%3Afirst-class-modules&quot;&gt;8.5&lt;/a&gt;章を参照）。</target>
        </trans-unit>
        <trans-unit id="14b965549f63ae8efc2b10799321a123949f32e2" translate="yes" xml:space="preserve">
          <source>This is in any case a good practice for such global mutable variables. Otherwise, they will pick out the type of first use. If there is a mistake at this point, this can result in confusing type errors when later, correct uses are flagged as errors.</source>
          <target state="translated">これはいずれにしても、このようなグローバルな変異可能な変数のための良い練習です。そうでなければ、最初に使用された型を選択してしまいます。この時点で間違いがあると、後になって正しい使用がエラーとしてフラグを立てられたときに、混乱を招くような型のエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="da8a97ff5473940dbd5590e2ac55f520f156f175" translate="yes" xml:space="preserve">
          <source>This is the counterpart in signatures of class definitions. A class specification matches a class definition if they have the same type parameters and their types match.</source>
          <target state="translated">これは、クラス定義のシグネチャにおける対応するものです。クラス仕様は、同じ型パラメータを持ち、その型が一致している場合にクラス定義と一致します。</target>
        </trans-unit>
        <trans-unit id="4a2f273ae05987b14e1f15ae11bcc910f3cc8e34" translate="yes" xml:space="preserve">
          <source>This manual documents the release 4.11 of the OCaml system. It is organized as follows.</source>
          <target state="translated">このマニュアルは、OCamlシステムのリリース4.11について書かれています。以下のように構成されています。</target>
        </trans-unit>
        <trans-unit id="949db82cf2165881bb890405414754937b92c7a0" translate="yes" xml:space="preserve">
          <source>This manual is also available in &lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman.pdf&quot;&gt;PDF&lt;/a&gt;. &lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman.txt&quot;&gt;plain text&lt;/a&gt;, as a &lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman-html.tar.gz&quot;&gt;bundle of HTML files&lt;/a&gt;, and as a &lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman.info.tar.gz&quot;&gt;bundle of Emacs Info files&lt;/a&gt;.</source>
          <target state="translated">このマニュアルは&lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman.pdf&quot;&gt;PDF&lt;/a&gt;でも入手できます。&lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman.txt&quot;&gt;プレーンテキスト&lt;/a&gt;、&lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman-html.tar.gz&quot;&gt;HTMLファイルのバンドル&lt;/a&gt;、および&lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman.info.tar.gz&quot;&gt;EmacsInfoファイルのバンドル&lt;/a&gt;として。</target>
        </trans-unit>
        <trans-unit id="c6a463aa2621012fa84bb9173c52f8aacbca9587" translate="yes" xml:space="preserve">
          <source>This may require some care: if the scrutinee may return several different cases of the same pattern, or raise distinct instances of the same exception, you may need to modify your code to separate those several cases.</source>
          <target state="translated">これには注意が必要かもしれません:もし scrutinee が同じパターンの複数の異なるケースを返したり、同じ例外のインスタンスが発生したりする場合は、それらのケースを分離するようにコードを修正する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="e9e169cadd5567bf33a7c94a3b1845ac6d0d1577" translate="yes" xml:space="preserve">
          <source>This meta-module provides labelized version of the &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes&quot;&gt;&lt;code&gt;Bytes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; modules.</source>
          <target state="translated">このメタモジュールは、&lt;a href=&quot;array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;bytes&quot;&gt; &lt;code&gt;Bytes&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;モジュールのラベル付きバージョンを提供します。</target>
        </trans-unit>
        <trans-unit id="1cda004ff3f73690b7705e7353fdb4ee3d731450" translate="yes" xml:space="preserve">
          <source>This meta-module provides labelized version of the &lt;a href=&quot;hashtbl&quot;&gt;&lt;code&gt;Hashtbl&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt; modules.</source>
          <target state="translated">このメタモジュールは、&lt;a href=&quot;hashtbl&quot;&gt; &lt;code&gt;Hashtbl&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;set&quot;&gt; &lt;code&gt;Set&lt;/code&gt; &lt;/a&gt;モジュールのラベル付きバージョンを提供します。</target>
        </trans-unit>
        <trans-unit id="74b7b70a1b67a465fca03531e3e7ca988aa3c7a2" translate="yes" xml:space="preserve">
          <source>This method will be called with the list of analysed and possibly merged Odoc_info.t_module structures.</source>
          <target state="translated">このメソッドは、分析され、マージされた可能性のあるOdoc_info.t_module構造体のリストとともに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="17cfabd3ff7747a40d003c4e1ce49d8233fcae6d" translate="yes" xml:space="preserve">
          <source>This module allows OCaml values to be registered with the C runtime under a symbolic name, so that C code can later call back registered OCaml functions, or raise registered OCaml exceptions.</source>
          <target state="translated">このモジュールは、OCamlの値をシンボリック名でCランタイムに登録できるようにします。これにより、Cコードが後で登録されたOCaml関数を呼び出したり、登録されたOCaml例外を発生させたりすることができます。</target>
        </trans-unit>
        <trans-unit id="99f88a4ac39ab2683e26258770cfb0e2d8f5fd8c" translate="yes" xml:space="preserve">
          <source>This module allows to define a type &lt;code&gt;t&lt;/code&gt; with the &lt;code&gt;immediate64&lt;/code&gt; attribute. This attribute means that the type is immediate on 64 bit architectures. On other architectures, it might or might not be immediate.</source>
          <target state="translated">このモジュールを使用すると、 &lt;code&gt;immediate64&lt;/code&gt; 属性を使用してタイプ &lt;code&gt;t&lt;/code&gt; を定義できます。この属性は、64ビットアーキテクチャではタイプが即時であることを意味します。他のアーキテクチャでは、即時である場合とそうでない場合があります。</target>
        </trans-unit>
        <trans-unit id="9e533b385e01821d7ad15e0945c07d70b1844d76" translate="yes" xml:space="preserve">
          <source>This module implements a pretty-printing facility to format values within &lt;a href=&quot;format#boxes&quot;&gt;'pretty-printing boxes'&lt;/a&gt; and &lt;a href=&quot;format#tags&quot;&gt;'semantic tags'&lt;/a&gt; combined with a set of &lt;a href=&quot;format#fpp&quot;&gt;printf-like functions&lt;/a&gt;. The pretty-printer splits lines at specified &lt;a href=&quot;format#breaks&quot;&gt;break hints&lt;/a&gt;, and indents lines according to the box structure. Similarly, &lt;a href=&quot;format#tags&quot;&gt;semantic tags&lt;/a&gt; can be used to decouple text presentation from its contents.</source>
          <target state="translated">このモジュールは、&lt;a href=&quot;format#boxes&quot;&gt;「プリティプリントボックス」&lt;/a&gt;および&lt;a href=&quot;format#tags&quot;&gt;「セマンティックタグ」&lt;/a&gt;内の値を一連の&lt;a href=&quot;format#fpp&quot;&gt;printfのような関数&lt;/a&gt;と組み合わせてフォーマットするプリティプリント機能を実装します。プリティプリンターは、指定された&lt;a href=&quot;format#breaks&quot;&gt;ブレークヒント&lt;/a&gt;で行を分割し、ボックス構造に従って行をインデントします。同様に、&lt;a href=&quot;format#tags&quot;&gt;セマンティックタグ&lt;/a&gt;を使用して、テキスト表示をそのコンテンツから切り離すことができます。</target>
        </trans-unit>
        <trans-unit id="6fe9c1d1946f164dc7ea31e649282f17763c3950" translate="yes" xml:space="preserve">
          <source>This module implements a simple 'standard' lexical analyzer, presented as a function from character streams to token streams. It implements roughly the lexical conventions of OCaml, but is parameterized by the set of keywords of your language.</source>
          <target state="translated">このモジュールは、文字ストリームからトークンストリームまでの関数として提示されるシンプルな「標準的な」字句解析器を実装しています。OCaml の語彙規則をほぼ実装していますが、あなたの言語のキーワードのセットによってパラメータ化されています。</target>
        </trans-unit>
        <trans-unit id="9e0125fd89be5c0e10d0ed6d49f7e1879412755c" translate="yes" xml:space="preserve">
          <source>This module implements applicative association tables, also known as finite maps or dictionaries, given a total ordering function over the keys. All operations over maps are purely applicative (no side-effects). The implementation uses balanced binary trees, and therefore searching and insertion take time logarithmic in the size of the map.</source>
          <target state="translated">このモジュールは、有限マップや辞書としても知られる、応用的なアソシエーションテーブルを実装します。マップに対するすべての操作は純粋に応用的です(副作用はありません)。実装ではバランスのとれたバイナリツリーを使用しているため、検索と挿入にはマップのサイズの対数的な時間がかかります。</target>
        </trans-unit>
        <trans-unit id="ce89672c48fa1f9bec12d607d59af82b35753a53" translate="yes" xml:space="preserve">
          <source>This module implements buffers that automatically expand as necessary. It provides accumulative concatenation of strings in quasi-linear time (instead of quadratic time when strings are concatenated pairwise).</source>
          <target state="translated">このモジュールは、必要に応じて自動的に展開するバッファを実装しています。これは、文字列の累積的な連結を準線形時間で提供します (文字列をペアで連結する場合の二次時間ではなく)。</target>
        </trans-unit>
        <trans-unit id="da30f332376f7747f380e4c823a1b7a155244e7c" translate="yes" xml:space="preserve">
          <source>This module implements multi-dimensional arrays of integers and floating-point numbers, thereafter referred to as 'Bigarrays', to distinguish them from the standard OCaml arrays described in &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このモジュールは、整数と浮動小数点数の多次元配列を実装し、その後「Bigarrays」と呼び、&lt;a href=&quot;array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; で&lt;/a&gt;説明されている標準のOCaml配列と区別します。</target>
        </trans-unit>
        <trans-unit id="7c5803197dddf99e3ec90f036488d17a8b4740cf" translate="yes" xml:space="preserve">
          <source>This module implements queues (FIFOs), with in-place modification.</source>
          <target state="translated">このモジュールは、キュー (FIFO)を実装しています。</target>
        </trans-unit>
        <trans-unit id="fd2b395d2566d5b178c77d76600076510ec457a8" translate="yes" xml:space="preserve">
          <source>This module implements stacks (LIFOs), with in-place modification.</source>
          <target state="translated">このモジュールは、スタック(LIFO)をインプレースで修正して実装しています。</target>
        </trans-unit>
        <trans-unit id="b90dc1cefe04c048afd0453d62a3c51d515ce8d7" translate="yes" xml:space="preserve">
          <source>This module implements synchronous inter-thread communications over channels. As in John Reppy's Concurrent ML system, the communication events are first-class values: they can be built and combined independently before being offered for communication.</source>
          <target state="translated">このモジュールは、チャンネルを介したスレッド間の同期通信を実装しています。John ReppyのConcurrent MLシステムのように、通信イベントは一級品の値であり、通信のために提供される前に独立して構築したり、組み合わせたりすることができます。</target>
        </trans-unit>
        <trans-unit id="3849f273edf21565de6b4e420886d0b2f60b00cd" translate="yes" xml:space="preserve">
          <source>This module implements the set data structure, given a total ordering function over the set elements. All operations over sets are purely applicative (no side-effects). The implementation uses balanced binary trees, and is therefore reasonably efficient: insertion and membership take time logarithmic in the size of the set, for instance.</source>
          <target state="translated">このモジュールは、集合の要素に対する合計順序付け関数を与えられた集合データ構造を実装します。集合に対するすべての操作は純粋に応用的です(副作用はありません)。実装ではバランスのとれたバイナリツリーを使用しているため、合理的に効率的です:挿入とメンバーシップには、例えば、セットのサイズの対数的な時間がかかります。</target>
        </trans-unit>
        <trans-unit id="2729905361f7f59d504ab6ed9996768ff5460796" translate="yes" xml:space="preserve">
          <source>This module is automatically opened at the beginning of each compilation. All components of this module can therefore be referred by their short name, without prefixing them by &lt;code&gt;Stdlib&lt;/code&gt;.</source>
          <target state="translated">このモジュールは、各コンパイルの開始時に自動的に開かれます。したがって、このモジュールのすべてのコンポーネントは、 &lt;code&gt;Stdlib&lt;/code&gt; で接頭辞を付けることなく、短い名前で参照できます。</target>
        </trans-unit>
        <trans-unit id="0333c95ed68f95f7342e2b757b9f08ce6a149992" translate="yes" xml:space="preserve">
          <source>This module is intended to be used through &lt;a href=&quot;stdlabels&quot;&gt;&lt;code&gt;StdLabels&lt;/code&gt;&lt;/a&gt; which replaces &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes&quot;&gt;&lt;code&gt;Bytes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; with their labeled counterparts.</source>
          <target state="translated">このモジュールは、&lt;a href=&quot;array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;bytes&quot;&gt; &lt;code&gt;Bytes&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;をそれらのラベル付きの対応物に置き換える&lt;a href=&quot;stdlabels&quot;&gt; &lt;code&gt;StdLabels&lt;/code&gt; &lt;/a&gt;を介して使用することを目的としています。</target>
        </trans-unit>
        <trans-unit id="b0e122c356078f81e1beb90b2b6032029724c402" translate="yes" xml:space="preserve">
          <source>This module is intended to be used via &lt;a href=&quot;stdlabels&quot;&gt;&lt;code&gt;StdLabels&lt;/code&gt;&lt;/a&gt; which replaces &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes&quot;&gt;&lt;code&gt;Bytes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; with their labeled counterparts</source>
          <target state="translated">このモジュールは、&lt;a href=&quot;array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;bytes&quot;&gt; &lt;code&gt;Bytes&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;をラベル付きの対応するものに置き換える&lt;a href=&quot;stdlabels&quot;&gt; &lt;code&gt;StdLabels&lt;/code&gt; &lt;/a&gt;を介して使用することを目的としています。</target>
        </trans-unit>
        <trans-unit id="64267a0e80b390a500ec96cdaa100f7adf548198" translate="yes" xml:space="preserve">
          <source>This module provides a general mechanism for extracting options and arguments from the command line to the program.</source>
          <target state="translated">このモジュールは、コマンドラインからプログラムにオプションと引数を抽出するための一般的なメカニズムを提供します。</target>
        </trans-unit>
        <trans-unit id="b609722b91ba2b158610f696a1988788495b0d03" translate="yes" xml:space="preserve">
          <source>This module provides arithmetic operations on complex numbers. Complex numbers are represented by their real and imaginary parts (cartesian representation). Each part is represented by a double-precision floating-point number (type &lt;code&gt;float&lt;/code&gt;).</source>
          <target state="translated">このモジュールは、複素数の算術演算を提供します。複素数は、実数部と虚数部で表されます（デカルト表現）。各部分は倍精度浮動小数点数（ &lt;code&gt;float&lt;/code&gt; 型）で表されます。</target>
        </trans-unit>
        <trans-unit id="19a26eb45fe7af4a376a6ae294864852d297cbea" translate="yes" xml:space="preserve">
          <source>This module provides functions to compute 128-bit 'digests' of arbitrary-length strings or files. The digests are of cryptographic quality: it is very hard, given a digest, to forge a string having that digest. The algorithm used is MD5. This module should not be used for secure and sensitive cryptographic applications. For these kind of applications more recent and stronger cryptographic primitives should be used instead.</source>
          <target state="translated">このモジュールは、任意の長さの文字列やファイルの 128 ビットの「ダイジェスト」を計算する関数を提供します。ダイジェストが与えられた場合、そのダイジェストを持つ文字列を偽造することは非常に困難です。使用されるアルゴリズムは MD5 です。このモジュールは、安全で機密性の高い暗号化アプリケーションには使用しないでください。この種のアプリケーションでは、より最近のより強力な暗号プリミティブを代わりに使うべきです。</target>
        </trans-unit>
        <trans-unit id="fc7540f10133c093c21edec4564acef90adfe177" translate="yes" xml:space="preserve">
          <source>This module provides functions to encode arbitrary data structures as sequences of bytes, which can then be written on a file or sent over a pipe or network connection. The bytes can then be read back later, possibly in another process, and decoded back into a data structure. The format for the byte sequences is compatible across all machines for a given version of OCaml.</source>
          <target state="translated">このモジュールは、任意のデータ構造をバイト列としてエンコードする機能を提供します。このバイトは、後になって別のプロセスで読み返され、データ構造にデコードされます。バイトシーケンスのフォーマットは、OCamlの特定のバージョンのすべてのマシンで互換性があります。</target>
        </trans-unit>
        <trans-unit id="8bbb035f066ee24f4ebaaacb2368ebd643cd2d0c" translate="yes" xml:space="preserve">
          <source>This module provides operations on the type &lt;code&gt;int32&lt;/code&gt; of signed 32-bit integers. Unlike the built-in &lt;code&gt;int&lt;/code&gt; type, the type &lt;code&gt;int32&lt;/code&gt; is guaranteed to be exactly 32-bit wide on all platforms. All arithmetic operations over &lt;code&gt;int32&lt;/code&gt; are taken modulo 2&lt;sup&gt;32&lt;/sup&gt;.</source>
          <target state="translated">このモジュールは、符号付き32ビット整数の &lt;code&gt;int32&lt;/code&gt; 型に対する演算を提供します。組み込みの &lt;code&gt;int&lt;/code&gt; 型とは異なり、 &lt;code&gt;int32&lt;/code&gt; 型は、すべてのプラットフォームで正確に32ビット幅であることが保証されています。以上のすべての算術演算 &lt;code&gt;int32&lt;/code&gt; モジュロ2取られる&lt;sup&gt;32&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="d5e7fe24e618c6feb78fd56d32e5512c8633a081" translate="yes" xml:space="preserve">
          <source>This module provides operations on the type &lt;code&gt;int64&lt;/code&gt; of signed 64-bit integers. Unlike the built-in &lt;code&gt;int&lt;/code&gt; type, the type &lt;code&gt;int64&lt;/code&gt; is guaranteed to be exactly 64-bit wide on all platforms. All arithmetic operations over &lt;code&gt;int64&lt;/code&gt; are taken modulo 2&lt;sup&gt;64&lt;/sup&gt;</source>
          <target state="translated">このモジュールは、符号付き64ビット整数の &lt;code&gt;int64&lt;/code&gt; 型に対する操作を提供します。内蔵されたとは異なり &lt;code&gt;int&lt;/code&gt; 型タイプ、タイプ &lt;code&gt;int64&lt;/code&gt; 型は、すべてのプラットフォーム上で正確に64ビット幅であることが保証されます。以上のすべての算術演算 &lt;code&gt;int64&lt;/code&gt; モジュロ2取られる&lt;sup&gt;64&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="dd560eafa9bf44786fbe70e70e377b41d3ae81e2" translate="yes" xml:space="preserve">
          <source>This module provides operations on the type &lt;code&gt;nativeint&lt;/code&gt; of signed 32-bit integers (on 32-bit platforms) or signed 64-bit integers (on 64-bit platforms). This integer type has exactly the same width as that of a pointer type in the C compiler. All arithmetic operations over &lt;code&gt;nativeint&lt;/code&gt; are taken modulo 2&lt;sup&gt;32&lt;/sup&gt; or 2&lt;sup&gt;64&lt;/sup&gt; depending on the word size of the architecture.</source>
          <target state="translated">このモジュールは、符号付き32ビット整数（32ビットプラットフォームの場合）または符号付き64ビット整数（64ビットプラットフォームの場合）の &lt;code&gt;nativeint&lt;/code&gt; 型での操作を提供します。この整数型の幅は、Cコンパイラのポインタ型とまったく同じです。以上のすべての算術演算 &lt;code&gt;nativeint&lt;/code&gt; 型は、 2を法を取られる&lt;sup&gt;32&lt;/sup&gt;または2 &lt;sup&gt;64&lt;/sup&gt;アーキテクチャのワードサイズに応じ。</target>
        </trans-unit>
        <trans-unit id="288a280c92d0e752f41d14eee812057e14d86d83" translate="yes" xml:space="preserve">
          <source>This option has no effect.</source>
          <target state="translated">このオプションは何の効果もありません。</target>
        </trans-unit>
        <trans-unit id="a0fa776a935837d0195b8b526844f025d4e6ce93" translate="yes" xml:space="preserve">
          <source>This part of the manual is a tutorial introduction to the OCaml language. A good familiarity with programming in a conventional languages (say, C or Java) is assumed, but no prior exposure to functional languages is required. The present chapter introduces the core language. Chapter &lt;a href=&quot;moduleexamples#c%3Amoduleexamples&quot;&gt;2&lt;/a&gt; deals with the module system, chapter &lt;a href=&quot;objectexamples#c%3Aobjectexamples&quot;&gt;3&lt;/a&gt; with the object-oriented features, chapter &lt;a href=&quot;lablexamples#c%3Alabl-examples&quot;&gt;4&lt;/a&gt; with extensions to the core language (labeled arguments and polymorphic variants), and chapter &lt;a href=&quot;advexamples#c%3Aadvexamples&quot;&gt;6&lt;/a&gt; gives some advanced examples.</source>
          <target state="translated">マニュアルのこの部分は、OCaml言語のチュートリアル入門です。従来の言語（CやJavaなど）でのプログラミングに精通していることを前提としていますが、関数型言語に事前に触れる必要はありません。この章では、コア言語を紹介します。第&lt;a href=&quot;moduleexamples#c%3Amoduleexamples&quot;&gt;2&lt;/a&gt;章ではモジュールシステムを扱い、第&lt;a href=&quot;objectexamples#c%3Aobjectexamples&quot;&gt;3&lt;/a&gt;章ではオブジェクト指向機能を扱い、第&lt;a href=&quot;lablexamples#c%3Alabl-examples&quot;&gt;4&lt;/a&gt;章ではコア言語の拡張（ラベル付き引数とポリモーフィックバリアント）を扱い、第&lt;a href=&quot;advexamples#c%3Aadvexamples&quot;&gt;6&lt;/a&gt;章ではいくつかの高度な例を示します。</target>
        </trans-unit>
        <trans-unit id="dbc86cc4d49f38cd528229f18473c5150da317ea" translate="yes" xml:space="preserve">
          <source>This pretty-printing facility is implemented as an overlay on top of abstract &lt;a href=&quot;format#formatter&quot;&gt;formatters&lt;/a&gt; which provide basic output functions. Some formatters are predefined, notably:</source>
          <target state="translated">このプリティプリント機能は、基本的な出力機能を提供する抽象&lt;a href=&quot;format#formatter&quot;&gt;フォーマッターの&lt;/a&gt;上にオーバーレイとして実装されます。一部のフォーマッタは事前定義されています。特に、次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a85ed63830f1cbd46d61e59847fbdc4998afedf8" translate="yes" xml:space="preserve">
          <source>This principle also applies to functions of several arguments whose return type is a type variable, as long as the role of each argument is not ambiguous. Labeling such functions may lead to awkward error messages when one attempts to omit labels in an application, as we have seen with ListLabels.fold_left.</source>
          <target state="translated">この原則は、各引数の役割が曖昧でない限り、戻り値の型が型変数である複数の引数の関数にも適用されます。このような関数にラベルを付けると、アプリケーションでラベルを省略しようとしたときに、 ListLabels.fold_leftで見たように、厄介なエラーメッセージが表示されることがあります。</target>
        </trans-unit>
        <trans-unit id="672f5a8d2001e1947d29714c5e2ccca5133a964a" translate="yes" xml:space="preserve">
          <source>This provides a convenient way to introduce local names for types and modules when defining a signature:</source>
          <target state="translated">これは、シグネチャを定義する際に、型やモジュールのローカル名を導入する便利な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="93a45b4f1b855894d7e36f97483d0e12e2929c42" translate="yes" xml:space="preserve">
          <source>This reference is initially set to &lt;code&gt;false&lt;/code&gt; in standalone programs and to &lt;code&gt;true&lt;/code&gt; if the code is being executed under the interactive toplevel system &lt;code&gt;ocaml&lt;/code&gt;.</source>
          <target state="translated">この参照は、スタンドアロンプ​​ログラムでは最初は &lt;code&gt;false&lt;/code&gt; に設定され、コードがインタラクティブなトップレベルシステム &lt;code&gt;ocaml&lt;/code&gt; で実行されている場合は &lt;code&gt;true&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="5eb60a37765a751859069418a148aa8f84ee1892" translate="yes" xml:space="preserve">
          <source>This requires that programs to be tested are instrumented to communicate with afl-fuzz. The native-code compiler &amp;ldquo;ocamlopt&amp;rdquo; can generate such instrumentation, allowing afl-fuzz to be used against programs written in OCaml.</source>
          <target state="translated">これには、テストするプログラムがafl-fuzzと通信するように計測されている必要があります。ネイティブコードコンパイラ「ocamlopt」はそのようなインストルメンテーションを生成でき、OCamlで書かれたプログラムに対してafl-fuzzを使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="52dcd9a1729658eb0c6b106d0c414385be78c303" translate="yes" xml:space="preserve">
          <source>This result in the error message &amp;ldquo;expression C of type foo cannot be used with type foo&amp;rdquo;.</source>
          <target state="translated">これにより、「タイプfooの式Cはタイプfooでは使用できません」というエラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="c3a02fce90d5e7f7129963fee4236b9d584135a5" translate="yes" xml:space="preserve">
          <source>This script expect to receive as an argument the directory containing the trace file. It will then copy the &lt;em&gt;CTF&lt;/em&gt; metadata file to the trace&amp;rsquo;s directory, and then decode the trace, printing each event in the process.</source>
          <target state="translated">このスクリプトは、トレースファイルを含むディレクトリを引数として受け取ることを想定しています。次に、&lt;em&gt;CTF&lt;/em&gt;メタデータファイルをトレースのディレクトリにコピーし、トレースをデコードして、プロセス内の各イベントを出力します。</target>
        </trans-unit>
        <trans-unit id="ef9456a3c165c2c5114ee21374f6504d86e6983b" translate="yes" xml:space="preserve">
          <source>This second form also works for patterns:</source>
          <target state="translated">この第二形態は、パターンにも有効です。</target>
        </trans-unit>
        <trans-unit id="5fc3c124b4479b68cbf25dba521d9a1e132177df" translate="yes" xml:space="preserve">
          <source>This section contains some general guidelines for writing C stubs that use Windows Unicode APIs.</source>
          <target state="translated">このセクションでは、Windows Unicode API を使用する C スタブを書くための一般的なガイドラインをいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="2f394592ed3600793f95e1254fcf350cda70b82c" translate="yes" xml:space="preserve">
          <source>This section describe how to make calling C functions cheaper.</source>
          <target state="translated">ここでは、C言語の関数の呼び出しを安くする方法を説明します。</target>
        </trans-unit>
        <trans-unit id="d5d9e3857acf6ed9216da0ef8ec0aa252128e3aa" translate="yes" xml:space="preserve">
          <source>This section describes a tool that is not yet officially supported but may be found useful.</source>
          <target state="translated">ここでは、まだ正式にはサポートされていないが、便利なツールについて説明します。</target>
        </trans-unit>
        <trans-unit id="08aafc15cda9ee7ff87051d799ffe599afa951de" translate="yes" xml:space="preserve">
          <source>This section describes and explains in detail some warnings:</source>
          <target state="translated">ここでは、いくつかの警告について詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="ffca379ae7271c0783a4ac241e377936af555ed8" translate="yes" xml:space="preserve">
          <source>This section describes and explains the most frequently encountered error messages.</source>
          <target state="translated">ここでは、よくあるエラーメッセージについて説明します。</target>
        </trans-unit>
        <trans-unit id="31ad7ee467b01f5649ddd8facce322cfb81ef3ae" translate="yes" xml:space="preserve">
          <source>This section describes how OCaml data types are encoded in the value type.</source>
          <target state="translated">ここでは、OCamlのデータ型が値の型でどのようにエンコードされているかを説明します。</target>
        </trans-unit>
        <trans-unit id="01693577ebb54a11b677d93676f308db58f638a4" translate="yes" xml:space="preserve">
          <source>This section describes the kinds of values that are manipulated by OCaml programs.</source>
          <target state="translated">ここでは、OCamlプログラムで操作される値の種類について説明します。</target>
        </trans-unit>
        <trans-unit id="b36e7060d9bec0558c1823961541205abf1df8d6" translate="yes" xml:space="preserve">
          <source>This section describes unsafe, low-level conversion functions between &lt;code&gt;bytes&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt;. They do not copy the internal data; used improperly, they can break the immutability invariant on strings provided by the &lt;code&gt;-safe-string&lt;/code&gt; option. They are available for expert library authors, but for most purposes you should use the always-correct &lt;a href=&quot;bytes#VALto_string&quot;&gt;&lt;code&gt;Bytes.to_string&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;bytes#VALof_string&quot;&gt;&lt;code&gt;Bytes.of_string&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">このセクションでは、 &lt;code&gt;bytes&lt;/code&gt; と &lt;code&gt;string&lt;/code&gt; 間の安全でない低レベルの変換関数について説明します。内部データはコピーされません。不適切に使用すると、 &lt;code&gt;-safe-string&lt;/code&gt; オプションによって提供される文字列の不変性を破ることができます。これらはエキスパートライブラリの作成者が利用できますが、ほとんどの目的では、代わりに常に正しい&lt;a href=&quot;bytes#VALto_string&quot;&gt; &lt;code&gt;Bytes.to_string&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;bytes#VALof_string&quot;&gt; &lt;code&gt;Bytes.of_string&lt;/code&gt; &lt;/a&gt;を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="0a9f87ec885f096da88cc6ca28abd5b60c7d67fe" translate="yes" xml:space="preserve">
          <source>This section explains how C stub code that interfaces C or Fortran code with OCaml code can use Bigarrays.</source>
          <target state="translated">ここでは、CやFortranコードとOCamlコードをインターフェースするCのスタブコードでBigarraysを使用する方法を説明します。</target>
        </trans-unit>
        <trans-unit id="71cdd8bac2c7a5aeee310523309d1c53e8523783" translate="yes" xml:space="preserve">
          <source>This section illustrates the callback facilities described in section &lt;a href=&quot;#s%3Ac-callback&quot;&gt;20.7&lt;/a&gt;. We are going to package some OCaml functions in such a way that they can be linked with C code and called from C just like any C functions. The OCaml functions are defined in the following mod.ml OCaml source:</source>
          <target state="translated">このセクションでは、セクション&lt;a href=&quot;#s%3Ac-callback&quot;&gt;20.7で&lt;/a&gt;説明されているコールバック機能について説明します。他のC関数と同じように、Cコードとリンクして、Cから呼び出すことができるように、いくつかのOCaml関数をパッケージ化します。OCaml関数は、次のmod.mlOCamlソースで定義されています。</target>
        </trans-unit>
        <trans-unit id="903aefdf9956fc71e923a3df9d4dd16dd0134747" translate="yes" xml:space="preserve">
          <source>This section lists the known incompatibilities between the bytecode compiler and the native-code compiler. Except on those points, the two compilers should generate code that behave identically.</source>
          <target state="translated">このセクションでは、バイトコードコンパイラとネイティブコードコンパイラの間の既知の非互換性をリストアップします。これらの点を除いて、2 つのコンパイラは同じように動作するコードを生成しなければなりません。</target>
        </trans-unit>
        <trans-unit id="18b5904aff3b237cf95bcb17d1df036bc4ab134c" translate="yes" xml:space="preserve">
          <source>This section outlines how the functions from the Unix curses library can be made available to OCaml programs. First of all, here is the interface curses.ml that declares the curses primitives and data types:</source>
          <target state="translated">このセクションでは、Unix curses ライブラリの関数を OCaml プログラムで利用できるようにする方法を概説します。まず最初に、curses のプリミティブとデータ型を宣言するインターフェイス curses.ml です。</target>
        </trans-unit>
        <trans-unit id="254ed70371607b2c3851b67568dd926316b5ceae" translate="yes" xml:space="preserve">
          <source>This short notation for fields also works when constructing records:</source>
          <target state="translated">このフィールドの短い表記法は、レコードを構築する際にも機能します。</target>
        </trans-unit>
        <trans-unit id="b8e400965e58bbfd6200a8deb63c3134ffb7098b" translate="yes" xml:space="preserve">
          <source>This short section is intended to clarify the relationship between the names of the modules corresponding to compilation units and the names of the files that contain their compiled interface and compiled implementation.</source>
          <target state="translated">この短いセクションでは、コンパイル単位に対応するモジュールの名前と、そのコンパイルされたインタフェースとコンパイルされた実装を格納したファイルの名前の関係を明確にすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="24aa0094a26c8735b882dd7c464be2f2468ee6f8" translate="yes" xml:space="preserve">
          <source>This shows the use of modules to group several class definitions that can in fact be thought of as a single unit. This unit would be provided by a bank for both internal and external uses. This is implemented as a functor that abstracts over the currency so that the same code can be used to provide accounts in different currencies.</source>
          <target state="translated">これは、実際には 1 つのユニットとして考えることができる複数のクラス定義をグループ化するためにモジュールを使用していることを示しています。このユニットは、銀行が内部と外部の両方で使用するために提供するものです。これは、通貨を抽象化したファンクタとして実装されており、同じコードを使用して異なる通貨の口座を提供することができます。</target>
        </trans-unit>
        <trans-unit id="48666abb0d053a2e67948abc2515711d3c441749" translate="yes" xml:space="preserve">
          <source>This simplifies to:</source>
          <target state="translated">に単純化します。</target>
        </trans-unit>
        <trans-unit id="ddd8a59e7fc768a0f67909566216bc17b9fded83" translate="yes" xml:space="preserve">
          <source>This syntax can be very useful when defining recursive functions involving GADTs, see the section &lt;a href=&quot;gadts#s%3Agadts&quot;&gt;8.10&lt;/a&gt; for a more detailed explanation.</source>
          <target state="translated">この構文は、GADTを含む再帰関数を定義するときに非常に役立ちます。詳細については、セクション&lt;a href=&quot;gadts#s%3Agadts&quot;&gt;8.10&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="606749beda23122ec62e2057e7b85c14c94a4118" translate="yes" xml:space="preserve">
          <source>This transformation discovers closure variables that are known to be equal to specialised arguments. Such closure variables are replaced by the specialised arguments; the closure variables may then be removed by the &amp;ldquo;removal of unused closure variables&amp;rdquo; pass (see below).</source>
          <target state="translated">この変換により、特殊な引数に等しいことがわかっているクロージャー変数が検出されます。このようなクロージャー変数は、特殊な引数に置き換えられます。次に、クロージャー変数は、「未使用のクロージャー変数の削除」パスによって削除できます（以下を参照）。</target>
        </trans-unit>
        <trans-unit id="a3ca52136f921dd3470ad0eec8da036065e73e98" translate="yes" xml:space="preserve">
          <source>This transformation does not operate if it would cause the closure to contain more than twice as many closure variables as it did beforehand.</source>
          <target state="translated">この変換は、クロージャが、クロージャ変数の数が事前の2倍以上になるような場合には動作しません。</target>
        </trans-unit>
        <trans-unit id="6a28d09c6743f0d934bbb9ee805f4686f7ff260e" translate="yes" xml:space="preserve">
          <source>This transformation is &lt;em&gt;not&lt;/em&gt; enabled by default. It may be enabled using the -unbox-closures flag.</source>
          <target state="translated">この変換はデフォルトで&lt;em&gt;は&lt;/em&gt;有効になって&lt;em&gt;いません&lt;/em&gt;。-unbox-closuresフラグを使用して有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="4085b150ab05ea3b51f91b2bd36f0e92e0492fbb" translate="yes" xml:space="preserve">
          <source>This transformation is analogous to the removal of let-expressions whose defining expressions have no effects. It operates instead on symbol bindings, removing those that have no effects.</source>
          <target state="translated">この変換は、定義式が効果を持たない let-expression の削除に似ています。この変換は、代わりにシンボルバインディングに作用し、効果のないものを削除します。</target>
        </trans-unit>
        <trans-unit id="98eeafe0734234bf6e061a4b30996bb7f31b9996" translate="yes" xml:space="preserve">
          <source>This transformation is coherent with the intended semantics, including side-effects. That is, if the application of optional parameters shall produce side-effects, these are delayed until the received function is really applied to an argument.</source>
          <target state="translated">この変換は、副作用を含めて、意図されたセマンティクスと一貫しています。つまり、オプションのパラメータを適用した場合に副作用が発生する場合は、受信した関数が実際に引数に適用されるまで遅延されます。</target>
        </trans-unit>
        <trans-unit id="97f7301c5b5d5afefc26a2bd6bf09c3b5a77941d" translate="yes" xml:space="preserve">
          <source>This transformation is enabled unless -no-unbox-free-vars-of-closures is provided.</source>
          <target state="translated">この変換は、-no-unbox-free-vars-of-closuresが指定されていない限り有効になります。</target>
        </trans-unit>
        <trans-unit id="107da9a0de966e43ce271c3dfca90682878bece5" translate="yes" xml:space="preserve">
          <source>This transformation is enabled unless -no-unbox-specialised-args is provided.</source>
          <target state="translated">この変換は -no-unbox-specialised-args が指定されていない限り有効です。</target>
        </trans-unit>
        <trans-unit id="95f81958a03cd80819ec888b7dadbd9b19a9762f" translate="yes" xml:space="preserve">
          <source>This transformation is only enabled by default for specialised arguments. It may be enabled for all arguments using the -remove-unused-arguments flag.</source>
          <target state="translated">この変換はデフォルトでは特殊な引数に対してのみ有効です。これは -remove-unused-arguments フラグを使用してすべての引数に対して有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="f3540291a552cb80b3485979aeb16719df0b1d80" translate="yes" xml:space="preserve">
          <source>This transformation performs an analysis across the whole compilation unit to determine whether there exist closure variables that are never used. Such closure variables are then eliminated. (Note that this has to be a whole-unit analysis because a projection of a closure variable from some particular closure may have propagated to an arbitrary location within the code due to inlining.)</source>
          <target state="translated">この変換は、コンパイルユニット全体で分析を行い、決して使用されないクロージャ変数が存在するかどうかを判断します。そして、そのようなクロージャ変数は削除されます。(ある特定のクロージャからのクロージャ変数の投影が、インライン化によってコード内の任意の場所に伝搬している可能性があるため、これはユニット全体の解析でなければならないことに注意してください)。</target>
        </trans-unit>
        <trans-unit id="1e83b36cd0eeacff2b0fcd7e5886d6aedf97ee77" translate="yes" xml:space="preserve">
          <source>This type allows direct access to raw backtrace slots, without any conversion in an OCaml-usable data-structure.</source>
          <target state="translated">このタイプは、OCamlで使用可能なデータ構造体に変換することなく、生のバックトレーススロットに直接アクセスすることを可能にします。</target>
        </trans-unit>
        <trans-unit id="130aa34f2abb76bf60b32cca15d066255d4d8d30" translate="yes" xml:space="preserve">
          <source>This type allows direct access to raw backtrace slots, without any conversion in an OCaml-usable data-structure. Being process-specific, they must absolutely not be marshalled, and are unsafe to use for this reason (marshalling them may not fail, but un-marshalling and using the result will result in undefined behavior).</source>
          <target state="translated">このタイプは、OCamlで使用可能なデータ構造に変換することなく、生のバックトレーススロットに直接アクセスすることを可能にします。プロセス固有のものであるため、これらは絶対にマーシャルされてはいけないものであり、この理由から使用することは安全ではありません(マーシャルすることで失敗することはありませんが、マーシャルを解除して結果を使用すると未定義の動作になります)。</target>
        </trans-unit>
        <trans-unit id="a5f42130deca30ae8346b504b0eec48ca9c2365c" translate="yes" xml:space="preserve">
          <source>This type is particularly useful when defining function that can fail in common situations, for instance</source>
          <target state="translated">このタイプは、特に一般的な状況で失敗する可能性のある関数を定義する場合に便利です。</target>
        </trans-unit>
        <trans-unit id="37b107ea9cfcc09f2b2be2c72335ef153d3c3763" translate="yes" xml:space="preserve">
          <source>This type is used to implement the &lt;a href=&quot;libref/lazy&quot;&gt;Lazy&lt;/a&gt; module. It should not be used directly.</source>
          <target state="translated">このタイプは、&lt;a href=&quot;libref/lazy&quot;&gt;Lazy&lt;/a&gt;モジュールを実装するために使用されます。直接使用しないでください。</target>
        </trans-unit>
        <trans-unit id="f2322d3b9d09a7e2ff55273a1e7e1bf51ca59dec" translate="yes" xml:space="preserve">
          <source>This value controls the GC messages on standard error output. It is a sum of some of the following flags, to print messages on the corresponding events:</source>
          <target state="translated">この値は、標準エラー出力の GC 2011 のメッセージを制御します。これは、対応するイベントにメッセージを印刷するために、以下のフラグのいくつかの合計です。</target>
        </trans-unit>
        <trans-unit id="191b0eb7c35686bcb189014265a40f332069ddbd" translate="yes" xml:space="preserve">
          <source>This way, you can change the meaning of indentation (which can be something else than just printing space characters) and the meaning of new lines opening (which can be connected to any other action needed by the application at hand).</source>
          <target state="translated">このようにして、インデントの意味(これはスペース文字を印刷するだけではなく、他の何かになり得る)や改行の意味(これは手元のアプリケーションが必要とする他の任意のアクションに接続することができる)を変更することができます。</target>
        </trans-unit>
        <trans-unit id="ee3e48f0f7c49da9ec952c4fe9ffee5be36732e2" translate="yes" xml:space="preserve">
          <source>Those annotations are introduced in the format strings using the &lt;code&gt;@&lt;/code&gt; character. For instance, &lt;code&gt;@&amp;nbsp;&lt;/code&gt; means a space break, &lt;code&gt;@,&lt;/code&gt; means a cut, &lt;code&gt;@[&lt;/code&gt; opens a new box, and &lt;code&gt;@]&lt;/code&gt; closes the last open box.</source>
          <target state="translated">これらの注釈は、 &lt;code&gt;@&lt;/code&gt; 文字を使用したフォーマット文字列で導入されます。例えば、 &lt;code&gt;@&amp;nbsp;&lt;/code&gt; 手段スペースブレークは、 &lt;code&gt;@,&lt;/code&gt; 、カットを意味 &lt;code&gt;@[&lt;/code&gt; 新しいボックスを開き、 &lt;code&gt;@]&lt;/code&gt; は、最後に開いたボックスを閉じます。</target>
        </trans-unit>
        <trans-unit id="f0183ff3f98f4e87c7d8f00f861fde047cea5266" translate="yes" xml:space="preserve">
          <source>Those explicit type annotations can in fact be used anywhere. Most of the time they are unnecessary, but they are useful to guide disambiguation, to debug unexpected type errors, or combined with some of the more advanced features of OCaml described in later chapters.</source>
          <target state="translated">これらの明示的な型注釈は、実際にはどこでも使うことができます。ほとんどの場合、これらのアノテーションは不要ですが、曖昧性の解消や予期せぬ型エラーのデバッグに有用であり、また、後の章で説明するOCamlのより高度な機能と組み合わせることもできます。</target>
        </trans-unit>
        <trans-unit id="19021df6f2a2bbcef0c8a622652f87dbf2d6eed1" translate="yes" xml:space="preserve">
          <source>Though all examples so far were written in purely applicative style, OCaml is also equipped with full imperative features. This includes the usual while and for loops, as well as mutable data structures such as arrays. Arrays are either created by listing semicolon-separated element values between [| and |] brackets, or allocated and initialized with the Array.make function, then filled up later by assignments. For instance, the function below sums two vectors (represented as float arrays) componentwise.</source>
          <target state="translated">これまでのすべての例は純粋に応用的なスタイルで書かれていますが、OCamlは完全な命令型の機能も備えています。これには、通常のwhileループやforループの他に、配列のような変異可能なデータ構造が含まれます。配列は、セミコロンで区切られた要素の値を[|]と[|]カッコの間にリストアップすることで作成されるか、Array.make関数で割り当てられて初期化され、後に代入によって埋められます。例えば,以下の関数は,2 つのベクトル(float 配列として表される)をコンポーネントごとに合計しています.</target>
        </trans-unit>
        <trans-unit id="7863f7503e5377891a3b7452c7d6cc377d443fe7" translate="yes" xml:space="preserve">
          <source>Thread</source>
          <target state="translated">Thread</target>
        </trans-unit>
        <trans-unit id="442734960d3874aabb05e4c0f886a1d056b06211" translate="yes" xml:space="preserve">
          <source>Thread creation and termination</source>
          <target state="translated">スレッドの作成と終了</target>
        </trans-unit>
        <trans-unit id="12f5360fcdde9c0092d8683e0065551e707bd34e" translate="yes" xml:space="preserve">
          <source>Thread-compatible system calls.</source>
          <target state="translated">スレッド互換のシステムコール。</target>
        </trans-unit>
        <trans-unit id="2045ffa4a6ae2e8ac2ea21859b137e4ac2c45ee5" translate="yes" xml:space="preserve">
          <source>ThreadUnix</source>
          <target state="translated">ThreadUnix</target>
        </trans-unit>
        <trans-unit id="013b2a2d89313d1cae51597fa10d83179b049eb7" translate="yes" xml:space="preserve">
          <source>Three-dimensional arrays</source>
          <target state="translated">三次元配列</target>
        </trans-unit>
        <trans-unit id="eade1edda0a702cf28e0ef4fd84c23f49efcdfd9" translate="yes" xml:space="preserve">
          <source>Three-dimensional arrays.</source>
          <target state="translated">三次元配列。</target>
        </trans-unit>
        <trans-unit id="d763c9a3cec94432c50184761fc6f2428e98860e" translate="yes" xml:space="preserve">
          <source>Three-dimensional arrays. The &lt;code&gt;Array3&lt;/code&gt; structure provides operations similar to those of &lt;a href=&quot;bigarray.genarray&quot;&gt;&lt;code&gt;Bigarray.Genarray&lt;/code&gt;&lt;/a&gt;, but specialized to the case of three-dimensional arrays.</source>
          <target state="translated">三次元配列。 &lt;code&gt;Array3&lt;/code&gt; 構造と同様の動作を提供&lt;a href=&quot;bigarray.genarray&quot;&gt; &lt;code&gt;Bigarray.Genarray&lt;/code&gt; を&lt;/a&gt;するが、3次元配列の場合に特化しました。</target>
        </trans-unit>
        <trans-unit id="0398dff7b2f64839c1ab8aac932358f9c7ab5983" translate="yes" xml:space="preserve">
          <source>Thus, semantic tag handling is in some sense transparent to pretty-printing and does not interfere with usual indentation. Hence, a single pretty-printing routine can output both simple 'verbatim' material or richer decorated output depending on the treatment of tags. By default, tags are not active, hence the output is not decorated with tag information. Once &lt;code&gt;set_tags&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the pretty-printer engine honors tags and decorates the output accordingly.</source>
          <target state="translated">したがって、セマンティックタグの処理は、ある意味でプリティプリントに対して透過的であり、通常のインデントを妨げません。したがって、単一のプリティプリントルーチンは、タグの処理に応じて、単純な「逐語的」素材またはより豊かな装飾出力の両方を出力できます。デフォルトでは、タグはアクティブではないため、出力はタグ情報で装飾されません。いったん &lt;code&gt;set_tags&lt;/code&gt; に設定されている &lt;code&gt;true&lt;/code&gt; 、プリティプリンタエンジン名誉タグとそれに応じた出力を飾ります。</target>
        </trans-unit>
        <trans-unit id="6c82e6dd86807ee3db07e3c82bec1ae1ce00b08b" translate="yes" xml:space="preserve">
          <source>Time</source>
          <target state="translated">Time</target>
        </trans-unit>
        <trans-unit id="a6a4546fd81b122915404e74cff9ee54a97e6c89" translate="yes" xml:space="preserve">
          <source>Time functions</source>
          <target state="translated">時間関数</target>
        </trans-unit>
        <trans-unit id="d4c45de0fe64ac43c72a798c67faaadadfaa1b90" translate="yes" xml:space="preserve">
          <source>Timeout</source>
          <target state="translated">Timeout</target>
        </trans-unit>
        <trans-unit id="41bea1307711e3db755e8948c9ec2940bd8e5a31" translate="yes" xml:space="preserve">
          <source>Timeout for input operations</source>
          <target state="translated">入力操作のタイムアウト</target>
        </trans-unit>
        <trans-unit id="14a1cbb733d9363c6f97fb603ebe07c1187f0c4b" translate="yes" xml:space="preserve">
          <source>Timeout for output operations</source>
          <target state="translated">出力操作のタイムアウト</target>
        </trans-unit>
        <trans-unit id="79fb3076dc75c83c83101f40598cc392db271b82" translate="yes" xml:space="preserve">
          <source>Timeout in cpu time</source>
          <target state="translated">CPU時間のタイムアウト</target>
        </trans-unit>
        <trans-unit id="bab4ed36a26f207c2e296f6a9bb7588c6211437f" translate="yes" xml:space="preserve">
          <source>Timeout in virtual time</source>
          <target state="translated">仮想時間のタイムアウト</target>
        </trans-unit>
        <trans-unit id="088594bde4f110fe47b51096bee5193b9d4cffe2" translate="yes" xml:space="preserve">
          <source>To adjust automatically the dimensions of the Bigarray to the actual size of the file, the major dimension (that is, the first dimension for an array with C layout, and the last dimension for an array with Fortran layout) can be given as &lt;code&gt;-1&lt;/code&gt;. &lt;code&gt;Genarray.map_file&lt;/code&gt; then determines the major dimension from the size of the file. The file must contain an integral number of sub-arrays as determined by the non-major dimensions, otherwise &lt;code&gt;Failure&lt;/code&gt; is raised.</source>
          <target state="translated">Bigarrayの次元をファイルの実際のサイズに自動的に調整するには、主次元（つまり、Cレイアウトの配列の最初の次元とFortranレイアウトの配列の最後の次元）を &lt;code&gt;-1&lt;/code&gt; として指定できます。。次に、 &lt;code&gt;Genarray.map_file&lt;/code&gt; は、ファイルのサイズから主要な次元を決定します。ファイルには、非メジャーディメンションによって決定される整数個のサブ配列が含まれている必要があります。含まれていない場合、 &lt;code&gt;Failure&lt;/code&gt; が発生します。</target>
        </trans-unit>
        <trans-unit id="a0661a33ab380eb57561703bce19cb91f7cdd834" translate="yes" xml:space="preserve">
          <source>To allow splitting long string literals across lines, the sequence \newlinespaces-or-tabs (a backslash at the end of a line followed by any number of spaces and horizontal tabulations at the beginning of the next line) is ignored inside string literals.</source>
          <target state="translated">長い文字列リテラルを行をまたいで分割できるようにするために、文字列リテラルの中では、シーケンス \newlinespaces-or-tabs (行末にバックスラッシュ、次の行の先頭に任意の数のスペースと水平方向のタブが続く)は無視されます。</target>
        </trans-unit>
        <trans-unit id="307acf24c4315e13fca20cd97aee6950796edc41" translate="yes" xml:space="preserve">
          <source>To avoid ambiguities, naming labels in expressions cannot just be defined syntactically as the sequence of the three tokens ~, &lt;a href=&quot;#ident&quot;&gt;ident&lt;/a&gt; and :, and have to be defined at the lexical level.</source>
          <target state="translated">あいまいさを避けるために、式の名前付けラベルは、構文的に3つのトークン〜、&lt;a href=&quot;#ident&quot;&gt;ident&lt;/a&gt;、および：のシーケンスとして定義することはできず、字句レベルで定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="6e6b4ed52355b5293c6127fa5925601acaeaf11e" translate="yes" xml:space="preserve">
          <source>To build the whole program, just invoke the C compiler as follows:</source>
          <target state="translated">プログラム全体を構築するには、以下のようにCコンパイラを呼び出すだけです。</target>
        </trans-unit>
        <trans-unit id="c7c213abd6a15163ea6d392abe4c8d900d2d422d" translate="yes" xml:space="preserve">
          <source>To circumvent these dual difficulties, the type checker considers that any value returned by a function might rely on persistent mutable states behind the scene and should be given a weak type. This restriction on the type of mutable values and the results of function application is called the value restriction. Note that this value restriction is conservative: there are situations where the value restriction is too cautious and gives a weak type to a value that could be safely generalized to a polymorphic type:</source>
          <target state="translated">これらの二重の困難を回避するために、型チェッカーは、関数によって返される値は、シーンの背後にある永続的な変異可能な状態に依存している可能性があり、弱い型を与えるべきであると考えています。このような突然変異可能な値の型と関数適用の結果に対する制限を値制限と呼びます。この値の制限は保守的であることに注意してください:値の制限が慎重すぎて、安全に多相型に一般化できる値に弱い型を与える状況があります。</target>
        </trans-unit>
        <trans-unit id="0dfd9516db0a5f37b1ad909f49077e73f5c3d083" translate="yes" xml:space="preserve">
          <source>To compile and link this program, run:</source>
          <target state="translated">このプログラムをコンパイルしてリンクするには、実行してください。</target>
        </trans-unit>
        <trans-unit id="bde604309077235c564ef6bb992b73c29478ef2a" translate="yes" xml:space="preserve">
          <source>To compile everything, execute:</source>
          <target state="translated">すべてをコンパイルするには、実行します。</target>
        </trans-unit>
        <trans-unit id="463481e8191305706647c8346e602fd42723a3d3" translate="yes" xml:space="preserve">
          <source>To compile this interface:</source>
          <target state="translated">このインターフェイスをコンパイルするには</target>
        </trans-unit>
        <trans-unit id="32b3ccadf9cce9fa5117bc1b3bfac7cb3a873f7e" translate="yes" xml:space="preserve">
          <source>To define arithmetic operations for the number type, we use pattern-matching on the two numbers involved:</source>
          <target state="translated">数型の算術演算を定義するために、関係する2つの数のパターンマッチを使用します。</target>
        </trans-unit>
        <trans-unit id="327cad239718bab706e248d624ccb7ecb21c15f6" translate="yes" xml:space="preserve">
          <source>To dynamically link C code with OCaml code, the C code must first be compiled into a shared library (under Unix) or DLL (under Windows). This involves 1- compiling the C files with appropriate C compiler flags for producing position-independent code (when required by the operating system), and 2- building a shared library from the resulting object files. The resulting shared library or DLL file must be installed in a place where ocamlrun can find it later at program start-up time (see section &lt;a href=&quot;runtime#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;). Finally (step 3), execute the ocamlc command with</source>
          <target state="translated">CコードをOCamlコードと動的にリンクするには、最初にCコードを共有ライブラリ（Unixの場合）またはDLL（Windowsの場合）にコンパイルする必要があります。これには、1-位置に依存しないコードを生成するための適切なCコンパイラフラグを使用してCファイルをコンパイルすること（オペレーティングシステムで必要な場合）、および2-結果のオブジェクトファイルから共有ライブラリを構築することが含まれます。結果の共有ライブラリまたはDLLファイルは、後でプログラムの起動時にocamlrunが見つけられる場所にインストールする必要があります（セクション&lt;a href=&quot;runtime#s%3Aocamlrun-dllpath&quot;&gt;11.3を&lt;/a&gt;参照）。最後に（ステップ3）、ocamlcコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="fb4a49b6e92a580be3d1ce7213ac6573529cfb93" translate="yes" xml:space="preserve">
          <source>To each element kind is associated an OCaml type, which is the type of OCaml values that can be stored in the Bigarray or read back from it.</source>
          <target state="translated">各要素の種類には、Bigarrayに格納したり、Bigarrayから読み出すことができるOCamlの値の種類であるOCaml型が関連付けられています。</target>
        </trans-unit>
        <trans-unit id="a7902cf653d3b6806a962d736420aac3556c0af2" translate="yes" xml:space="preserve">
          <source>To each element kind is associated an OCaml type, which is the type of OCaml values that can be stored in the Bigarray or read back from it. This type is not necessarily the same as the type of the array elements proper: for instance, a Bigarray whose elements are of kind &lt;code&gt;float32_elt&lt;/code&gt; contains 32-bit single precision floats, but reading or writing one of its elements from OCaml uses the OCaml type &lt;code&gt;float&lt;/code&gt;, which is 64-bit double precision floats.</source>
          <target state="translated">各要素の種類には、OCamlタイプが関連付けられています。これは、Bigarrayに格納したり、Bigarrayから読み戻したりできるOCaml値のタイプです。このタイプは、必ずしも適切な配列要素のタイプと同じではありません。たとえば、float32_eltのような要素を持つ &lt;code&gt;float32_elt&lt;/code&gt; は32ビットの単精度浮動小数点数が含まれますが、OCamlからの要素の1つを読み書きするには、OCamlタイプの &lt;code&gt;float&lt;/code&gt; を使用します。、64ビットの倍精度浮動小数点数です。</target>
        </trans-unit>
        <trans-unit id="ec8d6d0f0d08a9fa9eb4faaf97e838ad337fba45" translate="yes" xml:space="preserve">
          <source>To facilitate interoperability with existing C and Fortran code, this library supports two different memory layouts for Bigarrays, one compatible with the C conventions, the other compatible with the Fortran conventions.</source>
          <target state="translated">既存のCおよびFortranコードとの相互運用性を促進するために、このライブラリはBigarrays用の2つの異なるメモリレイアウトをサポートしています。</target>
        </trans-unit>
        <trans-unit id="d9440719805fd4d3883c45311f6d371026f97469" translate="yes" xml:space="preserve">
          <source>To fuzz a large system without modifying build tools, OCaml&amp;rsquo;s configure script also accepts the afl-instrument option. If OCaml is configured with afl-instrument, then all programs compiled by ocamlopt will be instrumented.</source>
          <target state="translated">ビルドツールを変更せずに大規模なシステムをファズするために、OCamlのconfigureスクリプトはafl-instrumentオプションも受け入れます。OCamlがafl-instrumentで構成されている場合、ocamloptによってコンパイルされたすべてのプログラムがインストルメントされます。</target>
        </trans-unit>
        <trans-unit id="d49cf83522e4dd02edaed17398bc3794092a3e6c" translate="yes" xml:space="preserve">
          <source>To generate a bytecode executable that runs on this runtime system, do:</source>
          <target state="translated">このランタイムシステム上で実行されるバイトコード実行ファイルを生成するには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="a7d984b677b59e1ba119d9e288d010f2047bf07c" translate="yes" xml:space="preserve">
          <source>To handle custom tags, you need to define a custom generator, as explained in section &lt;a href=&quot;#ss%3Aocamldoc-handling-custom-tags&quot;&gt;16.3.2&lt;/a&gt;.</source>
          <target state="translated">カスタムタグを処理するには、セクション&lt;a href=&quot;#ss%3Aocamldoc-handling-custom-tags&quot;&gt;16.3.2で&lt;/a&gt;説明されているように、カスタムジェネレータを定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="a226b13d5aac9e91dcb364c97e1b727eb95a790b" translate="yes" xml:space="preserve">
          <source>To help you diagnose this error, run your program with the -v option to ocamlrun, or with the OCAMLRUNPARAM environment variable set to v=63. If it displays lots of &amp;ldquo;Growing stack&amp;hellip;&amp;rdquo; messages, this is probably a looping recursive function. If it displays lots of &amp;ldquo;Growing heap&amp;hellip;&amp;rdquo; messages, with the heap size growing slowly, this is probably an attempt to construct a data structure with too many (infinitely many?) cells. If it displays few &amp;ldquo;Growing heap&amp;hellip;&amp;rdquo; messages, but with a huge increment in the heap size, this is probably an attempt to build an excessively large array, string or byte sequence.</source>
          <target state="translated">このエラーの診断に役立てるために、ocamlrunの-vオプションを指定するか、OCAMLRUNPARAM環境変数をv = 63に設定してプログラムを実行してください。「Growingstack&amp;hellip;」メッセージがたくさん表示される場合、これはおそらくループ再帰関数です。ヒープサイズがゆっくりと大きくなる「Growingheap&amp;hellip;」メッセージが多数表示される場合、これはおそらく、セルが多すぎる（無限に多い？）データ構造を構築する試みです。「Growingheap&amp;hellip;」メッセージがほとんど表示されないが、ヒープサイズが大幅に増加している場合、これはおそらく、過度に大きな配列、文字列、またはバイトシーケンスを構築する試みです。</target>
        </trans-unit>
        <trans-unit id="e2372771b07a4d167928768e2a883bc383b6e0f5" translate="yes" xml:space="preserve">
          <source>To illustrate the rules above, here is a C function that builds and returns a list containing the two integers given as parameters. First, we write it using the simplified allocation functions:</source>
          <target state="translated">上記のルールを説明するために、パラメータとして与えられた2つの整数を含むリストを構築して返すC言語の関数を示します。まず、簡略化された割り当て関数を使って書きます。</target>
        </trans-unit>
        <trans-unit id="f9316bbb60ea8ce0b1c90bf6112d6e8ade80ba7a" translate="yes" xml:space="preserve">
          <source>To implement these functions, we just have to provide the stub code; the core functions are already implemented in the curses library. The stub code file, curses_stubs.c, looks like this:</source>
          <target state="translated">これらの関数を実装するには、スタブコードを提供するだけです。スタブコードファイル curses_stubs.c は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="b952e965e16326f8fe35cdcad00515932cf1d1ca" translate="yes" xml:space="preserve">
          <source>To keep the generated automata small, rewrite those definitions with only one general &amp;ldquo;identifier&amp;rdquo; rule, followed by a hashtable lookup to separate keywords from identifiers:</source>
          <target state="translated">生成されたオートマトンを小さく保つには、1つの一般的な「識別子」ルールのみを使用してこれらの定義を書き直し、続いてハッシュテーブルルックアップを実行してキーワードを識別子から分離します。</target>
        </trans-unit>
        <trans-unit id="a23cb4ea2cf58c9454eccc5177ac6f043e990101" translate="yes" xml:space="preserve">
          <source>To keep the relaxed value restriction, we need to declare the abstract type 'a COLLECTION.t as covariant in 'a:</source>
          <target state="translated">緩和された値の制限を維持するためには、抽象型'a COLLECTION.tを'a'の共変量として宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="b5d11a9162bbc283c3d1d5bcb248f5b1b6ede824" translate="yes" xml:space="preserve">
          <source>To keep track of operations, we extend the class with a mutable field history and a private method trace to add an operation in the log. Then each method to be traced is redefined.</source>
          <target state="translated">操作を追跡するために、操作をログに追加するために、変更可能なフィールドの履歴とプライベートメソッドのトレースでクラスを拡張します。そして、トレースする各メソッドを再定義します。</target>
        </trans-unit>
        <trans-unit id="48e8a007425ee0f5fee02a060cc2a2384efe46e2" translate="yes" xml:space="preserve">
          <source>To know which methods to override and/or which methods are available, have a look at the different base implementations, depending on the kind of generator you are extending :</source>
          <target state="translated">どのメソッドをオーバーライドするか、どのメソッドが利用可能かを知るためには、拡張しているジェネレータの種類に応じて、異なるベースの実装を見てください。</target>
        </trans-unit>
        <trans-unit id="bff8eee99072881c7dd4af3c5fa1af20b5deb63a" translate="yes" xml:space="preserve">
          <source>To link in &amp;ldquo;custom runtime&amp;rdquo; mode, execute the ocamlc command with:</source>
          <target state="translated">「カスタムランタイム」モードでリンクするには、次のコマンドを使用してocamlcコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="2dc12bb0039399b2211b5edf87b77c3207cbfd57" translate="yes" xml:space="preserve">
          <source>To make sure your programs can be compiled in profiling mode, avoid using any identifier that begins with __ocaml_prof.</source>
          <target state="translated">プログラムをプロファイリングモードでコンパイルできるようにするために、__ocaml_profで始まる識別子の使用は避けてください。</target>
        </trans-unit>
        <trans-unit id="1c8e4b280c7f58e4764b54d8abccf82639d2ae14" translate="yes" xml:space="preserve">
          <source>To make this even more comfortable, you may use type definitions as abbreviations for or-patterns. That is, if you have defined type myvariant = [`Tag1 of int | `Tag2 of bool], then the pattern #myvariant is equivalent to writing (`Tag1(_ : int) | `Tag2(_ : bool)).</source>
          <target state="translated">これをさらに快適にするために、型定義を or-pattern の略語として使うことができます。つまり、myvariant=[`Tag1 of int | `Tag2 of bool]という型を定義していれば、#myvariant というパターンは、(`Tag1(_:int)| `Tag2(_:bool)と書くのと同じことになります。)</target>
        </trans-unit>
        <trans-unit id="0a622ca9104700efc8eba27769d5e6eccf540e9b" translate="yes" xml:space="preserve">
          <source>To read the byte representation of a marshaled value into a byte sequence, the program needs to read first &lt;a href=&quot;marshal#VALheader_size&quot;&gt;&lt;code&gt;Marshal.header_size&lt;/code&gt;&lt;/a&gt; bytes into the sequence, then determine the length of the remainder of the representation using &lt;a href=&quot;marshal#VALdata_size&quot;&gt;&lt;code&gt;Marshal.data_size&lt;/code&gt;&lt;/a&gt;, make sure the sequence is large enough to hold the remaining data, then read it, and finally call &lt;a href=&quot;marshal#VALfrom_bytes&quot;&gt;&lt;code&gt;Marshal.from_bytes&lt;/code&gt;&lt;/a&gt; to unmarshal the value.</source>
          <target state="translated">マーシャリングされた値のバイト表現をバイトシーケンスに読み込むには、プログラムは最初に&lt;a href=&quot;marshal#VALheader_size&quot;&gt; &lt;code&gt;Marshal.header_size&lt;/code&gt; &lt;/a&gt;バイトをシーケンスに読み込み、次に&lt;a href=&quot;marshal#VALdata_size&quot;&gt; &lt;code&gt;Marshal.data_size&lt;/code&gt; &lt;/a&gt;を使用して表現の残りの長さを決定し、シーケンスが十分に大きいことを確認する必要があります。残りのデータを保持してから読み取り、最後に&lt;a href=&quot;marshal#VALfrom_bytes&quot;&gt; &lt;code&gt;Marshal.from_bytes&lt;/code&gt; &lt;/a&gt;を呼び出して値をアンマーシャリングします。</target>
        </trans-unit>
        <trans-unit id="c72d4392ca2173a1c9eef1f69d8ad84c58d851ec" translate="yes" xml:space="preserve">
          <source>To reason about the use of &lt;code&gt;unsafe_to_string&lt;/code&gt;, it is convenient to consider an &quot;ownership&quot; discipline. A piece of code that manipulates some data &quot;owns&quot; it; there are several disjoint ownership modes, including:</source>
          <target state="translated">&lt;code&gt;unsafe_to_string&lt;/code&gt; の使用について推論するには、「所有権」の規律を検討すると便利です。一部のデータを操作するコードは、そのデータを「所有」します。次のようないくつかの互いに素な所有権モードがあります。</target>
        </trans-unit>
        <trans-unit id="2a7157f5deddeacc7b51617138d7fd940b256e41" translate="yes" xml:space="preserve">
          <source>To solve our problem, we can therefore use either the record solution:</source>
          <target state="translated">問題を解決するためには、したがって、レコードソリューションのいずれかを使用することができます。</target>
        </trans-unit>
        <trans-unit id="f4019cbcbaea339fe27aab76ebea9127bab9094f" translate="yes" xml:space="preserve">
          <source>To solve this error, it is enough to add an explicit type annotation to specify the type at declaration time:</source>
          <target state="translated">このエラーを解決するには、宣言時に明示的な型アノテーションを追加して型を指定すれば十分です。</target>
        </trans-unit>
        <trans-unit id="f25f95dc627a388c949e54ad1e4876e37a5fdec0" translate="yes" xml:space="preserve">
          <source>To speak in an &amp;ldquo;object-oriented&amp;rdquo; way, one can consider that each function has a main argument, its &lt;em&gt;object&lt;/em&gt;, and other arguments related with its action, the &lt;em&gt;parameters&lt;/em&gt;. To permit the combination of functions through functionals in commuting label mode, the object will not be labeled. Its role is clear from the function itself. The parameters are labeled with names reminding of their nature or their role. The best labels combine nature and role. When this is not possible the role is to be preferred, since the nature will often be given by the type itself. Obscure abbreviations should be avoided.</source>
          <target state="translated">「オブジェクト指向」の方法で話すと、各関数には主引数、その&lt;em&gt;オブジェクト&lt;/em&gt;、およびそのアクションに関連する他の引数、&lt;em&gt;パラメーター&lt;/em&gt;があると考えることができ&lt;em&gt;ます&lt;/em&gt;。通勤ラベルモードの機能を介して機能の組み合わせを許可するために、オブジェクトにはラベルが付けられません。その役割は、関数自体から明らかです。パラメータには、その性質や役割を思い出させる名前が付けられています。最高のラベルは、性質と役割を兼ね備えています。これが不可能な場合は、タイプ自体によって性質が与えられることが多いため、役割が優先されます。あいまいな略語は避けてください。</target>
        </trans-unit>
        <trans-unit id="387ff33570962c3e8b5dedb0a388bccd5c1fb297" translate="yes" xml:space="preserve">
          <source>To use Spacetime it is necessary to use an OCaml compiler that was configured with the -spacetime option. It is not possible to select Spacetime on a per-source-file basis or for a subset of files in a project; all files involved in the executable being profiled must be built with the Spacetime compiler. Only native code compilation is supported (not bytecode).</source>
          <target state="translated">Spacetimeを使用するには、-spacetimeオプションで設定されたOCamlコンパイラを使用する必要があります。ソース・ファイルごとに Spacetime を選択したり、プロジェクト内のファイルのサブセットに対して Spacetime を選択したりすることはできません。ネイティブコードのコンパイルのみサポートされています(バイトコードはサポートされていません)。</target>
        </trans-unit>
        <trans-unit id="ed32f07860215af085ff436b7b7306a6815a9b78" translate="yes" xml:space="preserve">
          <source>To use the Flambda optimisers it is necessary to pass the -flambda option to the OCaml configure script. (There is no support for a single compiler that can operate in both Flambda and non-Flambda modes.) Code compiled with Flambda cannot be linked into the same program as code compiled without Flambda. Attempting to do this will result in a compiler error.</source>
          <target state="translated">Flambda オプティマイザーを使用するには、OCaml configure スクリプトに -flambda オプションを渡す必要があります。(Flambdaモードと非Flambdaモードの両方で動作する単一のコンパイラはサポートされていません)。Flambda でコンパイルされたコードを、Flambda なしでコンパイルされたコードと同じプログラムにリンクすることはできません。このようにしようとすると、コンパイラエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="25cebac05e12b33d1c5325eeaabd74f6b15cffcb" translate="yes" xml:space="preserve">
          <source>To use the functions in this module you must:</source>
          <target state="translated">このモジュールの機能を使用するには、以下のことが必要です。</target>
        </trans-unit>
        <trans-unit id="4a3b40c35ac9b4dbb1547ab6397d847d576919f6" translate="yes" xml:space="preserve">
          <source>To use this function, one can wrap the Set.Make functor:</source>
          <target state="translated">この関数を使用するには、Set.Make ファンクタをラップします。</target>
        </trans-unit>
        <trans-unit id="e279465e252c0b80c2d1a6c8e50d696d2db937f5" translate="yes" xml:space="preserve">
          <source>To write C code that operates on OCaml values, the following include files are provided:</source>
          <target state="translated">OCamlの値を操作するCコードを書くには、以下のインクルードファイルが用意されています。</target>
        </trans-unit>
        <trans-unit id="659d8a056102ffd377f0cdfc671961480711f61a" translate="yes" xml:space="preserve">
          <source>Together, the relaxed value restriction and type parameter covariance help to avoid eta-expansion in many situations.</source>
          <target state="translated">緩和された値制限と型パラメータの共分散は、多くの状況でエタ拡張を回避するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="56dbc78473450158f36bd54d125933d056ecd869" translate="yes" xml:space="preserve">
          <source>Tokens and rules have precedences. By default, the precedence of a rule is the precedence of its rightmost terminal. You can override this default by using the %prec directive in the rule.</source>
          <target state="translated">トークンとルールには優先順位があります。デフォルトでは、ルールの優先順位はその右端のターミナルの優先順位になります。このデフォルトを上書きするには、ルールの %prec ディレクティブを使用します。</target>
        </trans-unit>
        <trans-unit id="2e0d2eef3cc8719301cd02a8aeecb9e956e88cf1" translate="yes" xml:space="preserve">
          <source>Too many levels of symbolic links</source>
          <target state="translated">シンボリックリンクのレベルが高すぎる</target>
        </trans-unit>
        <trans-unit id="4113b4c9ebd053469430304ab17dc16ea1d01df9" translate="yes" xml:space="preserve">
          <source>Too many links</source>
          <target state="translated">リンクが多すぎる</target>
        </trans-unit>
        <trans-unit id="5736e6c11ff6d9830fab68fdeb2e9c96cdae31d6" translate="yes" xml:space="preserve">
          <source>Too many open files by the process</source>
          <target state="translated">プロセスによって開かれているファイルが多すぎる</target>
        </trans-unit>
        <trans-unit id="529311e8fdf6ab2db0e809d7fbb676ae1d82a50d" translate="yes" xml:space="preserve">
          <source>Too many open files in the system</source>
          <target state="translated">システムで開いているファイルが多すぎる</target>
        </trans-unit>
        <trans-unit id="282e2b703da2ac14021b09f04b30fd7f814e033a" translate="yes" xml:space="preserve">
          <source>Too many references: can't splice</source>
          <target state="translated">参照先が多すぎる:スプライスできない</target>
        </trans-unit>
        <trans-unit id="15521e66130383b230f739bb2fc49edfc0a24250" translate="yes" xml:space="preserve">
          <source>Toplevel</source>
          <target state="translated">Toplevel</target>
        </trans-unit>
        <trans-unit id="52271cb5a0a7ab67a42426df16b8f5309e544d7d" translate="yes" xml:space="preserve">
          <source>Toplevel let-expressions may be lifted to symbol bindings to ensure that the corresponding bound variables are not captured by closures. If the defining expression of a given binding is found to be constant, it is bound as such (the technical term is a &lt;em&gt;let-symbol&lt;/em&gt; binding).</source>
          <target state="translated">最上位のlet-expressionをシンボルバインディングに持ち上げて、対応するバインドされた変数がクロージャによってキャプチャされないようにすることができます。与えられたバインディングの定義式が一定であることがわかった場合、それはそのようにバインドされます（専門用語は&lt;em&gt;let-symbol&lt;/em&gt;バインディングです）。</target>
        </trans-unit>
        <trans-unit id="a44cf452ae377637373f10a091314197af5f0b33" translate="yes" xml:space="preserve">
          <source>Toplevel phrases can refer to identifiers defined in compilation units with the same mechanisms as for separately compiled units: either by using qualified names (Modulename.localname), or by using the open construct and unqualified names (see section &lt;a href=&quot;names#s%3Anames&quot;&gt;7.3&lt;/a&gt;).</source>
          <target state="translated">トップレベルのフレーズは、個別にコンパイルされたユニットと同じメカニズムでコンパイルユニットで定義された識別子を参照できます。修飾名（Modulename.localname）を使用するか、オープンコンストラクトと非修飾名を使用します（セクション&lt;a href=&quot;names#s%3Anames&quot;&gt;7.3を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="06d983275acca4ebd956f4ca99271a34f2702b6e" translate="yes" xml:space="preserve">
          <source>Total ordering between maps.</source>
          <target state="translated">地図間のトータルオーダー。</target>
        </trans-unit>
        <trans-unit id="0d503224bdd1f64388674e9ce0a963f9f4e37ff2" translate="yes" xml:space="preserve">
          <source>Total ordering between maps. The first argument is a total ordering used to compare data associated with equal keys in the two maps.</source>
          <target state="translated">マップ間の合計順序付け。最初の引数は、2 つのマップの等しいキーに関連付けられたデータを比較するために使用される合計順序です。</target>
        </trans-unit>
        <trans-unit id="b2d7c3d7b4f4e20c4b6494fc8ea71a5bcb4f2aaf" translate="yes" xml:space="preserve">
          <source>Total ordering between sets.</source>
          <target state="translated">セット間のトータルオーダー。</target>
        </trans-unit>
        <trans-unit id="4f44baf07265ef300d210f7ea6b516756e51c1c5" translate="yes" xml:space="preserve">
          <source>Total ordering between sets. Can be used as the ordering function for doing sets of sets.</source>
          <target state="translated">集合間の合計順序付け。集合の集合を行う際の順序付け関数として使用できる。</target>
        </trans-unit>
        <trans-unit id="34336f2b5f5540478a6b0046d27bf02690c7c02c" translate="yes" xml:space="preserve">
          <source>Total size of the major heap, in words.</source>
          <target state="translated">メジャーヒープの合計サイズ、言葉で言うと。</target>
        </trans-unit>
        <trans-unit id="75ce6b1a588e98221c2bce1023520067bc5af6c3" translate="yes" xml:space="preserve">
          <source>Trace/breakpoint trap</source>
          <target state="translated">トレース/ブレークポイントトラップ</target>
        </trans-unit>
        <trans-unit id="24d86e87d3b5c7cc8eaa531c471cc6fe6401e236" translate="yes" xml:space="preserve">
          <source>Traces generated by the instrumented runtime can be analyzed with tooling available outside of the OCaml distribution.</source>
          <target state="translated">インストルメント化されたランタイムによって生成されたトレースは、OCamlのディストリビューションの外で利用可能なツールを使って分析することができます。</target>
        </trans-unit>
        <trans-unit id="68c508431455ff22684105af9cb2ecc131f7e321" translate="yes" xml:space="preserve">
          <source>Tracing</source>
          <target state="translated">Tracing</target>
        </trans-unit>
        <trans-unit id="8a199b624500a34255a39172a77785f3c1196171" translate="yes" xml:space="preserve">
          <source>Transform a list of pairs into a pair of lists: &lt;code&gt;split&amp;nbsp;[(a1,b1);&amp;nbsp;...;&amp;nbsp;(an,bn)]&lt;/code&gt; is &lt;code&gt;([a1;&amp;nbsp;...;&amp;nbsp;an],&amp;nbsp;[b1;&amp;nbsp;...;&amp;nbsp;bn])&lt;/code&gt;.</source>
          <target state="translated">ペアのリストをリストのペアに変換します &lt;code&gt;split&amp;nbsp;[(a1,b1);&amp;nbsp;...;&amp;nbsp;(an,bn)]&lt;/code&gt; は &lt;code&gt;([a1;&amp;nbsp;...;&amp;nbsp;an],&amp;nbsp;[b1;&amp;nbsp;...;&amp;nbsp;bn])&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="32401d5fba7510cc4407d77e41ee1d2a4fb4a675" translate="yes" xml:space="preserve">
          <source>Transform a list of pairs into a pair of lists: &lt;code&gt;split&amp;nbsp;[(a1,b1);&amp;nbsp;...;&amp;nbsp;(an,bn)]&lt;/code&gt; is &lt;code&gt;([a1;&amp;nbsp;...;&amp;nbsp;an],&amp;nbsp;[b1;&amp;nbsp;...;&amp;nbsp;bn])&lt;/code&gt;. Not tail-recursive.</source>
          <target state="translated">ペアのリストをリストのペアに変換します &lt;code&gt;split&amp;nbsp;[(a1,b1);&amp;nbsp;...;&amp;nbsp;(an,bn)]&lt;/code&gt; は &lt;code&gt;([a1;&amp;nbsp;...;&amp;nbsp;an],&amp;nbsp;[b1;&amp;nbsp;...;&amp;nbsp;bn])&lt;/code&gt; です。末尾再帰ではありません。</target>
        </trans-unit>
        <trans-unit id="49a801d0a362583e8d49cf49a6efc625d6c92a83" translate="yes" xml:space="preserve">
          <source>Transform a pair of lists into a list of pairs: &lt;code&gt;combine&amp;nbsp;[a1;&amp;nbsp;...;&amp;nbsp;an]&amp;nbsp;[b1;&amp;nbsp;...;&amp;nbsp;bn]&lt;/code&gt; is &lt;code&gt;[(a1,b1);&amp;nbsp;...;&amp;nbsp;(an,bn)]&lt;/code&gt;.</source>
          <target state="translated">リストのペアをペアのリストに変換します &lt;code&gt;combine&amp;nbsp;[a1;&amp;nbsp;...;&amp;nbsp;an]&amp;nbsp;[b1;&amp;nbsp;...;&amp;nbsp;bn]&lt;/code&gt; は &lt;code&gt;[(a1,b1);&amp;nbsp;...;&amp;nbsp;(an,bn)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50dd5a15a0cecf0dd0826019c37ba6dc26f6bc64" translate="yes" xml:space="preserve">
          <source>Traverse the sequence from left to right, combining each element with the accumulator using the given function.</source>
          <target state="translated">与えられた関数を用いて,各要素をアキュムレータに結合して,左から右へシーケンスをトラバースします.</target>
        </trans-unit>
        <trans-unit id="4688d50f3f86cb62a80baee37bcad030269d2b74" translate="yes" xml:space="preserve">
          <source>Traverse the sequence from left to right, combining each element with the accumulator using the given function. The traversal happens immediately and will not terminate on infinite sequences.</source>
          <target state="translated">与えられた関数を使用して,各要素をアキュムレータに結合して,左から右へシーケンスをトラバースします.走査は直ちに行われ,無限シーケンスでは終了しません.</target>
        </trans-unit>
        <trans-unit id="5951a92d20e1af5270ceec7e9317847694484ddf" translate="yes" xml:space="preserve">
          <source>Treat Ocamldoc warnings as errors.</source>
          <target state="translated">Ocamldoc の警告をエラーとして扱う。</target>
        </trans-unit>
        <trans-unit id="417c217dcd227caf02540a67a10ab8cd2a50b328" translate="yes" xml:space="preserve">
          <source>Treat as errors the warnings enabled by the argument and as normal warnings the warnings disabled by the argument.</source>
          <target state="translated">引数で有効になっている警告をエラーとして扱い、引数で無効になっている警告を通常の警告として扱います。</target>
        </trans-unit>
        <trans-unit id="66debbd01f97db729dc454195e358bf429f9ece9" translate="yes" xml:space="preserve">
          <source>Trigger a minor collection.</source>
          <target state="translated">マイナーコレクションをトリガーに</target>
        </trans-unit>
        <trans-unit id="09b695cc0fd391daf36faf1963153e5b6cb4a3b9" translate="yes" xml:space="preserve">
          <source>Triggering finalization of allocated custom blocks (see section &lt;a href=&quot;#s%3Ac-custom&quot;&gt;20.9&lt;/a&gt;). For example, Stdlib.in_channel and Stdlib.out_channel are represented by custom blocks that enclose file descriptors, which are to be released.</source>
          <target state="translated">割り当てられたカスタムブロックのファイナライズをトリガーします（セクション&lt;a href=&quot;#s%3Ac-custom&quot;&gt;20.9を&lt;/a&gt;参照）。たとえば、Stdlib.in_channelとStdlib.out_channelは、リリースされるファイル記述子を囲むカスタムブロックによって表されます。</target>
        </trans-unit>
        <trans-unit id="e6e79023b8ee1b35da3de1efb771fce6d418e7dd" translate="yes" xml:space="preserve">
          <source>Triple the default</source>
          <target state="translated">デフォルトを3倍にする</target>
        </trans-unit>
        <trans-unit id="ed552aedd0ce3f370d321354a40788014425b26f" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;Sys.os_type&amp;nbsp;=&amp;nbsp;&quot;Cygwin&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Sys.os_type&amp;nbsp;=&amp;nbsp;&quot;Cygwin&quot;&lt;/code&gt; 場合はTrue 。</target>
        </trans-unit>
        <trans-unit id="d2e10371a9b7e6b5bec4cec1afb346e6fcf56c47" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;Sys.os_type&amp;nbsp;=&amp;nbsp;&quot;Unix&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Sys.os_type&amp;nbsp;=&amp;nbsp;&quot;Unix&quot;&lt;/code&gt; 場合はTrue 。</target>
        </trans-unit>
        <trans-unit id="2c18358e3f16eb9b759e71c30fca9e2c6ee55d3a" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;Sys.os_type&amp;nbsp;=&amp;nbsp;&quot;Win32&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Sys.os_type&amp;nbsp;=&amp;nbsp;&quot;Win32&quot;&lt;/code&gt; 場合はTrue 。</target>
        </trans-unit>
        <trans-unit id="532fe6ed68fa8e3a71fd02229c84119658bc5ab3" translate="yes" xml:space="preserve">
          <source>Truncate the given floating-point number to an integer.</source>
          <target state="translated">与えられた浮動小数点数を整数に切り捨てます。</target>
        </trans-unit>
        <trans-unit id="3a10351d651cbeb488e200041e184f6200f9b609" translate="yes" xml:space="preserve">
          <source>Truncate the given floating-point number to an integer. The result is unspecified if the argument is &lt;code&gt;nan&lt;/code&gt; or falls outside the range of representable integers.</source>
          <target state="translated">指定された浮動小数点数を整数に切り捨てます。引数が &lt;code&gt;nan&lt;/code&gt; の場合、または表現可能な整数の範囲外の場合、結果は指定されません。</target>
        </trans-unit>
        <trans-unit id="93981b89548137dc81009ceab881823b9341006a" translate="yes" xml:space="preserve">
          <source>Truncate to 0 length if existing</source>
          <target state="translated">既存の場合は長さ0に切り捨て</target>
        </trans-unit>
        <trans-unit id="7fed15abd46a43c683f271305b8f42f5b17141ef" translate="yes" xml:space="preserve">
          <source>Truncated bytecode file</source>
          <target state="translated">切り捨てられたバイトコードファイル</target>
        </trans-unit>
        <trans-unit id="5002c1234c7b95d88482d1369e0f6d0a4591c59b" translate="yes" xml:space="preserve">
          <source>Truncates the file corresponding to the given descriptor to the given size.</source>
          <target state="translated">指定されたディスクリプタに対応するファイルを指定されたサイズに切り詰めます。</target>
        </trans-unit>
        <trans-unit id="e0347bdb2507eb59f16d15ec102ff4098f3d5b35" translate="yes" xml:space="preserve">
          <source>Truncates the named file to the given size.</source>
          <target state="translated">指定されたファイルを指定されたサイズに切り詰めます。</target>
        </trans-unit>
        <trans-unit id="35c43375c1d65c34fdff7dac4166175da7ec333a" translate="yes" xml:space="preserve">
          <source>Tuples are represented by pointers to blocks, with tag 0.</source>
          <target state="translated">タプルは、タグ0のブロックへのポインタで表されます。</target>
        </trans-unit>
        <trans-unit id="4fb08f9372966ada62d75d5d7d46f41e9ec29633" translate="yes" xml:space="preserve">
          <source>Tuples of values are written (v&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;,v&lt;sub&gt;n&lt;/sub&gt;), standing for the n-tuple of values v&lt;sub&gt;1&lt;/sub&gt; to v&lt;sub&gt;n&lt;/sub&gt;. The current implementation supports tuple of up to 2&lt;sup&gt;22&lt;/sup&gt; &amp;minus; 1 elements (4194303 elements).</source>
          <target state="translated">値の組は、（V書かれている&lt;sub&gt;1&lt;/sub&gt;、...、Vの&lt;sub&gt;N&lt;/sub&gt;値のnタプル放置）V &lt;sub&gt;1&lt;/sub&gt;からV &lt;sub&gt;N&lt;/sub&gt;。現在の実装では、最大2 &lt;sup&gt;22&lt;/sup&gt; &amp;minus; 1要素（4194303要素）のタプルがサポートされています。</target>
        </trans-unit>
        <trans-unit id="ec1382e4b69cd24377b95330f6e9bb58114f7bac" translate="yes" xml:space="preserve">
          <source>Turn bound checking off for array and string accesses (the v.(i) and s.[i] constructs). Programs compiled with -unsafe are therefore faster, but unsafe: anything can happen if the program accesses an array or string outside of its bounds.</source>
          <target state="translated">配列や文字列へのアクセス (v.(i)および s.[i]構造体)の境界チェックをオフにしました。unsafeでコンパイルされたプログラムは高速ですが、安全ではありません:プログラムが境界外の配列や文字列にアクセスした場合、何が起こるかわかりません。</target>
        </trans-unit>
        <trans-unit id="c2a661500df8d1ec062b5d1e38538b3068fc8971" translate="yes" xml:space="preserve">
          <source>Turn bound checking off for array and string accesses (the v.(i) and s.[i] constructs). Programs compiled with -unsafe are therefore faster, but unsafe: anything can happen if the program accesses an array or string outside of its bounds. Additionally, turn off the check for zero divisor in integer division and modulus operations. With -unsafe, an integer division (or modulus) by zero can halt the program or continue with an unspecified result instead of raising a Division_by_zero exception.</source>
          <target state="translated">配列や文字列へのアクセス (v.(i)および s.[i]構造体)の境界チェックをオフにしました。unsafeでコンパイルされたプログラムは高速ですが、安全ではありません。さらに、整数除算とモジュラス演算におけるゼロ除数のチェックをオフにします。unsafeを使うと、ゼロによる整数除算(またはモジュラス)は、Division_by_zero例外を発生させる代わりに、プログラムを停止させたり、不特定の結果で続行させたりすることができます。</target>
        </trans-unit>
        <trans-unit id="9976aabbd5a9c1ab1aeea83f7f9166b0d664e3c3" translate="yes" xml:space="preserve">
          <source>Turn bound checking off for array and string accesses (the v.(i) and s.[i] constructs). Programs compiled with -unsafe are therefore slightly faster, but unsafe: anything can happen if the program accesses an array or string outside of its bounds. Additionally, turn off the check for zero divisor in integer division and modulus operations. With -unsafe, an integer division (or modulus) by zero can halt the program or continue with an unspecified result instead of raising a Division_by_zero exception.</source>
          <target state="translated">配列や文字列へのアクセス (v.(i)および s.[i]構造体)の境界チェックをオフにしました。unsafeを使用してコンパイルされたプログラムはわずかに高速になりますが、安全ではありません。さらに、整数除算とモジュラス演算におけるゼロ除数のチェックをオフにします。unsafeを使うと、ゼロによる整数除算(またはモジュラス)は、Division_by_zero例外を発生させる代わりに、プログラムを停止させたり、不特定の結果で続行させたりすることができます。</target>
        </trans-unit>
        <trans-unit id="711678e3efb5338f51272a8b5178317c676c89f3" translate="yes" xml:space="preserve">
          <source>Two class type definitions match if they have the same type parameters and they expand to matching types.</source>
          <target state="translated">2つのクラスの型定義が一致するのは、同じ型パラメータを持ち、一致する型に展開されている場合です。</target>
        </trans-unit>
        <trans-unit id="aa4a19d22a2815840c01d0e4fbe627ac1ec3b2ca" translate="yes" xml:space="preserve">
          <source>Two functions are provided to raise two standard exceptions:</source>
          <target state="translated">2つの標準的な例外を発生させるために、2つの関数が用意されています。</target>
        </trans-unit>
        <trans-unit id="1661242be978210d8d5a1f77691405122d60e821" translate="yes" xml:space="preserve">
          <source>Two implementations of the threads library are available, depending on the capabilities of the operating system:</source>
          <target state="translated">オペレーティングシステムの能力に応じて、スレッドライブラリの2つの実装が用意されています。</target>
        </trans-unit>
        <trans-unit id="a8cefc13e3d298c2bb25661b6f6aa2482f697297" translate="yes" xml:space="preserve">
          <source>Two labels or constructors of the same name are defined in two mutually recursive types.</source>
          <target state="translated">2つのラベルまたは同じ名前のコンストラクタは、2つの相互に再帰的な型で定義されます。</target>
        </trans-unit>
        <trans-unit id="48d9c23b1cb7383bf898c8101cacf467f4231973" translate="yes" xml:space="preserve">
          <source>Two parameters &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; are said to designate a valid range of &lt;code&gt;s&lt;/code&gt; if &lt;code&gt;len&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; and &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;start+len&lt;/code&gt; are valid positions in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;len&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; 、 &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;start+len&lt;/code&gt; が &lt;code&gt;s&lt;/code&gt; の有効な位置である場合、2つのパラメーター &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;len&lt;/code&gt; は &lt;code&gt;s&lt;/code&gt; の有効範囲を指定すると言われます。</target>
        </trans-unit>
        <trans-unit id="d67b45c324770bcbf92f640297940d5a30dc1257" translate="yes" xml:space="preserve">
          <source>Two parameters &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; are said to designate a valid substring of &lt;code&gt;s&lt;/code&gt; if &lt;code&gt;len&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; and &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;start+len&lt;/code&gt; are valid positions in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;len&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; 、 &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;start+len&lt;/code&gt; が &lt;code&gt;s&lt;/code&gt; の有効な位置である場合、2つのパラメータ &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;len&lt;/code&gt; は &lt;code&gt;s&lt;/code&gt; の有効な部分文字列を指定すると言われます。</target>
        </trans-unit>
        <trans-unit id="a1ad4c7ee77f98430fd3a05a3935346ecc6ed421" translate="yes" xml:space="preserve">
          <source>Two syntactic forms are provided to define functions. The first form is introduced by the keyword function:</source>
          <target state="translated">関数を定義するために、2 つの構文形式が用意されています。最初の形式はキーワード関数によって導入されます。</target>
        </trans-unit>
        <trans-unit id="019322ca2a87bdfa6e229ab6eaabec2277045691" translate="yes" xml:space="preserve">
          <source>Two-dimensional arrays</source>
          <target state="translated">二次元配列</target>
        </trans-unit>
        <trans-unit id="6efde7c3ec175b7e2cd302f767b8885955c43c8f" translate="yes" xml:space="preserve">
          <source>Two-dimensional arrays.</source>
          <target state="translated">二次元配列。</target>
        </trans-unit>
        <trans-unit id="ea97efc84b08c1dfa5507328a9a5eb75811c2159" translate="yes" xml:space="preserve">
          <source>Two-dimensional arrays. The &lt;code&gt;Array2&lt;/code&gt; structure provides operations similar to those of &lt;a href=&quot;bigarray.genarray&quot;&gt;&lt;code&gt;Bigarray.Genarray&lt;/code&gt;&lt;/a&gt;, but specialized to the case of two-dimensional arrays.</source>
          <target state="translated">2次元配列。 &lt;code&gt;Array2&lt;/code&gt; 構造と同様の動作を提供&lt;a href=&quot;bigarray.genarray&quot;&gt; &lt;code&gt;Bigarray.Genarray&lt;/code&gt; を&lt;/a&gt;、が、2次元配列の場合に特化しました。</target>
        </trans-unit>
        <trans-unit id="44a966b34064ea2bde71d174110a293dd3641eb6" translate="yes" xml:space="preserve">
          <source>Type abbreviation: an equation =&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;, no representation.</source>
          <target state="translated">タイプの省略形：方程式= &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;、表現なし。</target>
        </trans-unit>
        <trans-unit id="e9c2db94655456061e2fda2d94f1456bf5e6dcae" translate="yes" xml:space="preserve">
          <source>Type abbreviation: an equation, no representation.</source>
          <target state="translated">タイプの略語:式であり、表現がない。</target>
        </trans-unit>
        <trans-unit id="dbd26433f35fa9fba1fb5a1c64fd536c78f13267" translate="yes" xml:space="preserve">
          <source>Type abbreviations are not expanded when determining the arity of a primitive. For instance,</source>
          <target state="translated">プリミティブのアリティを決定する際には、型の省略形は展開されません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="6ce1ff79a0b7e3f45e08e886eab851d95ab4453e" translate="yes" xml:space="preserve">
          <source>Type argument &lt;code&gt;'b&lt;/code&gt; is also the type of the first argument given to user's defined printing functions for &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%t&lt;/code&gt; conversions, and user's defined reading functions for &lt;code&gt;%r&lt;/code&gt; conversion.</source>
          <target state="translated">タイプ引数 &lt;code&gt;'b&lt;/code&gt; は、 &lt;code&gt;%a&lt;/code&gt; および &lt;code&gt;%t&lt;/code&gt; 変換用のユーザー定義の印刷関数、および &lt;code&gt;%r&lt;/code&gt; 変換用のユーザー定義の読み取り関数に指定される最初の引数のタイプでもあります。</target>
        </trans-unit>
        <trans-unit id="ebbbc6fe5700486ef983078c89b775200e1dfb7c" translate="yes" xml:space="preserve">
          <source>Type constraint on GADT type declaration.</source>
          <target state="translated">GADT型宣言の型制約。</target>
        </trans-unit>
        <trans-unit id="d901f4220b65f3d70d012f9e484a31bb0b370e19" translate="yes" xml:space="preserve">
          <source>Type constructor application</source>
          <target state="translated">型コンストラクタアプリケーション</target>
        </trans-unit>
        <trans-unit id="644e74ab904e55997d610fce5e77162948201c5e" translate="yes" xml:space="preserve">
          <source>Type constructors</source>
          <target state="translated">型のコンストラクタ</target>
        </trans-unit>
        <trans-unit id="008b7ad7f73c68a43133ccff9ec196e28074c36f" translate="yes" xml:space="preserve">
          <source>Type constructors with no parameter, as in &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;, are type expressions.</source>
          <target state="translated">&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstrのように&lt;/a&gt;、パラメーターのない型コンストラクターは型式です。</target>
        </trans-unit>
        <trans-unit id="41e19918330a4b7e92b3dee85f135d9b90408d4a" translate="yes" xml:space="preserve">
          <source>Type declaration defining a new &amp;rsquo;()&amp;rsquo; constructor.</source>
          <target state="translated">新しい '（）'コンストラクターを定義する型宣言。</target>
        </trans-unit>
        <trans-unit id="383e22354516abb8dd98b4675030118fe6e23fbe" translate="yes" xml:space="preserve">
          <source>Type definitions are introduced by the type keyword, and consist in one or several simple definitions, possibly mutually recursive, separated by the and keyword. Each simple definition defines one type constructor.</source>
          <target state="translated">型定義は、type キーワードによって導入され、1 つまたは複数の単純な定義で構成されます。それぞれの単純な定義は、1 つの型のコンストラクタを定義します。</target>
        </trans-unit>
        <trans-unit id="80012d2e3c018c87cbaf804ec7fb6ccc51f86ae0" translate="yes" xml:space="preserve">
          <source>Type definitions bind type constructors to data types: either variant types, record types, type abbreviations, or abstract data types. They also bind the value constructors and record fields associated with the definition.</source>
          <target state="translated">型定義は、型コンストラクタをデータ型(バリアント型、レコード型、型の略語、または抽象データ型)にバインドします。また、定義に関連付けられた値コンストラクタとレコードフィールドもバインドします。</target>
        </trans-unit>
        <trans-unit id="7cad2e5ed527706c404fda008c0fbc43d1739bde" translate="yes" xml:space="preserve">
          <source>Type expressions denote types in definitions of data types as well as in type constraints over patterns and expressions.</source>
          <target state="translated">型式は、データ型の定義や、パターンや式に対する型制約の中の型を表します。</target>
        </trans-unit>
        <trans-unit id="7f54858a82ae6c361b165ee97f22098dea3856f8" translate="yes" xml:space="preserve">
          <source>Type inference for GADTs is notoriously hard. This is due to the fact some types may become ambiguous when escaping from a branch. For instance, in the Int case above, n could have either type int or a, and they are not equivalent outside of that branch. As a first approximation, type inference will always work if a pattern-matching is annotated with types containing no free type variables (both on the scrutinee and the return type). This is the case in the above example, thanks to the type annotation containing only locally abstract types.</source>
          <target state="translated">GADTの型推論は難しいことで知られています。これは、ブランチからエスケープするときに型が曖昧になることがあるからです。例えば、上のIntの場合、nはintかaのどちらかの型を持っている可能性があり、そのブランチの外ではそれらは等価ではありません。最初の近似として、パターンマッチングの型が自由な型変数を含まない型でアノテーションされている場合、型推論は常に機能します(スクルーティニーとリターン型の両方)。これは、局所的に抽象的な型のみを含む型アノテーションのおかげで、上の例のようになります。</target>
        </trans-unit>
        <trans-unit id="1c41d15644bc0e4699a63b1fcbb73b5b965f20ee" translate="yes" xml:space="preserve">
          <source>Type of formatted input functions</source>
          <target state="translated">書式化された入力機能の種類</target>
        </trans-unit>
        <trans-unit id="1cf6e53f9d2885b8ecaefaa805ee9c2e406ebfb7" translate="yes" xml:space="preserve">
          <source>Type representing a file that will hold a series of heap snapshots together with additional information required to interpret those snapshots.</source>
          <target state="translated">一連のヒープスナップショットと、それらのスナップショットを解釈するために必要な追加情報を保持するファイルを表すタイプ。</target>
        </trans-unit>
        <trans-unit id="6a1fb7e38670879b0890b7b24f14acf10d4a824d" translate="yes" xml:space="preserve">
          <source>Type variables ('a, 'b, &amp;hellip;) in a type t can be in either of two states: generalized (which means that the type t is valid for all possible instantiations of the variables) and not generalized (which means that the type t is valid only for one instantiation of the variables). In a let binding let name = expr, the type-checker normally generalizes as many type variables as possible in the type of expr. However, this leads to unsoundness (a well-typed program can crash) in conjunction with polymorphic mutable data structures. To avoid this, generalization is performed at let bindings only if the bound expression expr belongs to the class of &amp;ldquo;syntactic values&amp;rdquo;, which includes constants, identifiers, functions, tuples of syntactic values, etc. In all other cases (for instance, expr is a function application), a polymorphic mutable could have been created and generalization is therefore turned off for all variables occurring in contravariant or non-variant branches of the type. For instance, if the type of a non-value is 'a list the variable is generalizable (list is a covariant type constructor), but not in 'a list -&amp;gt; 'a list (the left branch of -&amp;gt; is contravariant) or 'a ref (ref is non-variant).</source>
          <target state="translated">タイプtのタイプ変数（ 'a、' b、&amp;hellip;）は、一般化（タイプtが変数のすべての可能なインスタンス化に対して有効であることを意味します）と一般化されていない（タイプを意味します）の2つの状態のいずれかになります。 tは、変数の1つのインスタンス化に対してのみ有効です）。 letバインディングletname = exprでは、タイプチェッカーは通常、exprのタイプで可能な限り多くのタイプ変数を一般化します。ただし、これにより、多態性の可変データ構造と組み合わせて、不健全になります（適切に型指定されたプログラムがクラッシュする可能性があります）。これを回避するために、一般化は、バインドされた式exprが定数、識別子、関数、構文値のタプルなどを含む「構文値」のクラスに属している場合にのみ、letバインディングで実行されます。他のすべての場合（たとえば、expr関数アプリケーションです）、多相可変が作成された可能性があるため、タイプの反変または非変分ブランチで発生するすべての変数の一般化がオフになります。たとえば、非値の型が 'リストの場合、変数は一般化可能です（リストは共変型コンストラクターです）が、'リスト-&amp;gt; 'リスト（-&amp;gt;の左側の分岐は反変です）または'a ref（refは非バリアントです）。</target>
        </trans-unit>
        <trans-unit id="6e3aef53774c7f5b428263ee8017835db5f94f3b" translate="yes" xml:space="preserve">
          <source>Type without principality.</source>
          <target state="translated">主体性のないタイプ。</target>
        </trans-unit>
        <trans-unit id="7abe567be65d268f3a2696a5729946c3839700c3" translate="yes" xml:space="preserve">
          <source>Type-checking polymorphic variants is a subtle thing, and some expressions may result in more complex type information.</source>
          <target state="translated">多型変種の型チェックは微妙なもので、表現によってはより複雑な型情報が得られることもあります。</target>
        </trans-unit>
        <trans-unit id="dd209f835b431620f2f7a16a1700ed3f687e554d" translate="yes" xml:space="preserve">
          <source>Type-level module aliases are used when checking module path equalities. That is, in a context where module name N is known to be an alias for P, not only these two module paths check as equal, but F (N) and F (P) are also recognized as equal. In the default compilation mode, this is the only difference with the previous approach of module aliases having just the same module type as the module they reference.</source>
          <target state="translated">タイプレベルのモジュール・エイリアスは、モジュール・パスの等しさをチェックするときに使用されます。つまり、モジュール名 N が P のエイリアスであることが知られているコンテキストでは、これら 2 つのモジュールパスが等しいとチェックされるだけでなく、F (N)と F (P)も等しいと認識されます。デフォルトのコンパイルモードでは、これが、モジュールエイリアスが参照するモジュールと同じモジュールタイプを持つという以前のアプローチとの唯一の違いです。</target>
        </trans-unit>
        <trans-unit id="482b5d3e58f932060fa84ae1f7437ed62a8c84a5" translate="yes" xml:space="preserve">
          <source>Typing an interrupt character (usually ctrl-C) will not exit the debugger, but will terminate the action of any debugger command that is in progress and return to the debugger command level.</source>
          <target state="translated">割り込み文字 (通常は ctrl-C)を入力してもデバッガは終了しませんが、進行中のデバッガコマンドの動作は終了し、デバッガのコマンドレベルに戻ります。</target>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="c285dbae8ad75c11cf03e8d284872209563d4ef3" translate="yes" xml:space="preserve">
          <source>Uchar</source>
          <target state="translated">Uchar</target>
        </trans-unit>
        <trans-unit id="b677e5fef1be6d058b58bf6826880d3b971e64ab" translate="yes" xml:space="preserve">
          <source>Unary addition.</source>
          <target state="translated">単項加算。</target>
        </trans-unit>
        <trans-unit id="f695fa2b2a0f97bac964e65828d440f3804af708" translate="yes" xml:space="preserve">
          <source>Unary addition. You can also write &lt;code&gt;+&amp;nbsp;e&lt;/code&gt; instead of &lt;code&gt;~+&amp;nbsp;e&lt;/code&gt;. Unary operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">単項加算。 &lt;code&gt;~+&amp;nbsp;e&lt;/code&gt; 代わりに &lt;code&gt;+&amp;nbsp;e&lt;/code&gt; 書くこともできます。単項演算子。詳細については、&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5f4484029bc001a1c51bfcd0596481e4db8652c6" translate="yes" xml:space="preserve">
          <source>Unary addition. You can also write &lt;code&gt;+.&amp;nbsp;e&lt;/code&gt; instead of &lt;code&gt;~+.&amp;nbsp;e&lt;/code&gt;. Unary operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">単項加算。 &lt;code&gt;+.&amp;nbsp;e&lt;/code&gt; 書くこともできます。 &lt;code&gt;~+.&amp;nbsp;e&lt;/code&gt; 代わりにe 。e。単項演算子。詳細については、&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="63b13d71007c4da2df4ac38a9e58dea596e4161f" translate="yes" xml:space="preserve">
          <source>Unary negation.</source>
          <target state="translated">単項否定。</target>
        </trans-unit>
        <trans-unit id="95141f64f4298daa6ecac13e37d4f744cc2fc09d" translate="yes" xml:space="preserve">
          <source>Unary negation. You can also write &lt;code&gt;-&amp;nbsp;e&lt;/code&gt; instead of &lt;code&gt;~-&amp;nbsp;e&lt;/code&gt;. Unary operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">単項否定。また、書くことができます &lt;code&gt;-&amp;nbsp;e&lt;/code&gt; の代わりに &lt;code&gt;~-&amp;nbsp;e&lt;/code&gt; 。単項演算子。詳細については、&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7a731455f59ced6b1f05e17234de09ab409ca508" translate="yes" xml:space="preserve">
          <source>Unary negation. You can also write &lt;code&gt;-.&amp;nbsp;e&lt;/code&gt; instead of &lt;code&gt;~-.&amp;nbsp;e&lt;/code&gt;. Unary operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">単項否定。 &lt;code&gt;-.&amp;nbsp;e&lt;/code&gt; 書くこともできます。〜-の代わりにe &lt;code&gt;~-.&amp;nbsp;e&lt;/code&gt; 。単項演算子。詳細については、&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="65bc523ce5f481e4e4e3e37f7a2972ec888003bf" translate="yes" xml:space="preserve">
          <source>Unboxable type in primitive declaration.</source>
          <target state="translated">プリミティブ宣言でのアンボックス可能な型。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
