<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="2df7fb2c193365ff646472a721e6b7dbe5bf63ae" translate="yes" xml:space="preserve">
          <source>The above function takes a strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; supposed to represent Base64 encoded data and the current decoding state. It writes the decoded bytes as the side-effect of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; and returns the new decoding state, if the decoding of all data in the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; was successful. The checking if the strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; represents Base64 encoded data and the actual decoding are fused. This makes the common case, where all data represents Base64 encoded data, more efficient. It also implies that all data must be decoded before the final decoding state can be returned. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are intended for implementing such fused checking and decoding/encoding, which is reflected in their strictness properties.</source>
          <target state="translated">上記の関数は、Base64エンコードされたデータと現在のデコード状態を表すことになっている厳密な &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; を取ります。デコードされたバイトを &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; の副作用として書き込み、 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 内のすべてのデータのデコードが成功した場合は、新しいデコード状態を返します。厳密な &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; がBase64でエンコードされたデータを表すかどうかのチェックと実際のデコードは融合されています。これにより、すべてのデータがBase64エンコードデータを表すという一般的なケースがより効率的になります。また、最終的なデコード状態を返す前に、すべてのデータをデコードする必要があることも意味します。 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; は、厳密性のプロパティに反映される、このような融合されたチェックとデコード/エンコードを実装することを目的としています。</target>
        </trans-unit>
        <trans-unit id="0308489ed1646a7d427f7b348942d76c9c0d5d69" translate="yes" xml:space="preserve">
          <source>The above informal specification is fine for simple situations, but matters can get complicated. In particular, it needs to be clear exactly when a key dies, so that any weak pointers that refer to it can be finalized. Suppose, for example, the value of one weak pointer refers to the key of another...does that keep the key alive?</source>
          <target state="translated">上記の非公式な仕様は単純な状況では問題ありませんが、問題は複雑になる可能性があります。特に、あるキーがいつ死ぬのかを正確に明確にする必要があり、それを参照している弱いポインターを最終的に確定することができます。例えば、ある弱いポインタの値が別のキーを参照していたとします。</target>
        </trans-unit>
        <trans-unit id="2361448fcf86f9607ed9aa3c2d047337ebd0125c" translate="yes" xml:space="preserve">
          <source>The above laws imply:</source>
          <target state="translated">上記の法律が暗示しています。</target>
        </trans-unit>
        <trans-unit id="6121e60b6f07d4583d6a2f3988fc1fab1e503635" translate="yes" xml:space="preserve">
          <source>The above will parse a string like &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt; and return a successful parse result &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt;. Compare against the below which will produce a result of &lt;code&gt;&quot;bbb&quot;&lt;/code&gt; for the same input:</source>
          <target state="translated">上記は &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt; のような文字列を解析し、正常な解析結果 &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt; を返します。同じ入力に対して &lt;code&gt;&quot;bbb&quot;&lt;/code&gt; 結果を生成する以下と比較してください。</target>
        </trans-unit>
        <trans-unit id="20d7c122429fa587037c0b158d78237d0e61f8fb" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">抽象データ型 &lt;code&gt;ParseError&lt;/code&gt; は解析エラーを表します。エラーのソース位置（ &lt;code&gt;&lt;a href=&quot;text-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ）とエラーメッセージのリスト（ &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ）を提供します。A &lt;code&gt;ParseError&lt;/code&gt; ですが、関数によって返されることができ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ParseError&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; クラスと &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; クラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="a0dc001d398ba43af02553419233d88958cb5682" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">抽象データ型 &lt;code&gt;ParseError&lt;/code&gt; は、解析エラーを表します。エラーのソース位置（ &lt;code&gt;&lt;a href=&quot;text-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ）とエラーメッセージのリスト（ &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ）を提供します。A &lt;code&gt;ParseError&lt;/code&gt; ですが、関数によって返されることができ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ParseError&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; クラスと &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; クラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="2860dda2765620cbf0f468a55ba7b993da164fe3" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">抽象データ型 &lt;code&gt;ParseError&lt;/code&gt; は解析エラーを表します。エラーのソース位置（ &lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ）とエラーメッセージのリスト（ &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ）を提供します。A &lt;code&gt;ParseError&lt;/code&gt; ですが、関数によって返されることができ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ParseError&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; クラスと &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; クラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="a16390824d4b63d5b034583c35efee2fa442421d" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">抽象データ型 &lt;code&gt;ParseError&lt;/code&gt; は、解析エラーを表します。エラーのソース位置（ &lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ）とエラーメッセージのリスト（ &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ）を提供します。A &lt;code&gt;ParseError&lt;/code&gt; ですが、関数によって返されることができ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ParseError&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; クラスと &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; クラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="aab9864f2e792b8ac699847b4dbdbb4a77ea80ac" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">抽象データ型 &lt;code&gt;ParseError&lt;/code&gt; は解析エラーを表します。エラーのソース位置（ &lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ）とエラーメッセージのリスト（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ）を提供します。A &lt;code&gt;ParseError&lt;/code&gt; ですが、関数によって返されることができ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ParseError&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; クラスと &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; クラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="bcac48e5c098987927b81058fb32ab48d7f41565" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">抽象データ型 &lt;code&gt;ParseError&lt;/code&gt; は、解析エラーを表します。エラーのソース位置（ &lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ）とエラーメッセージのリスト（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ）を提供します。A &lt;code&gt;ParseError&lt;/code&gt; ですが、関数によって返されることができ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ParseError&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; クラスと &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; クラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="510da1eb070dd00ee03ec16a47305698f8cacdd9" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">抽象データ型 &lt;code&gt;ParseError&lt;/code&gt; は解析エラーを表します。エラーのソース位置（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ）とエラーメッセージのリスト（ &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ）を提供します。A &lt;code&gt;ParseError&lt;/code&gt; ですが、関数によって返されることができ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ParseError&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; クラスと &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; クラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="c0cae1d0e9d25bf84bec3f0ea7979ae65c16dd54" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">抽象データ型 &lt;code&gt;ParseError&lt;/code&gt; は、解析エラーを表します。エラーのソース位置（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ）とエラーメッセージのリスト（ &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ）を提供します。A &lt;code&gt;ParseError&lt;/code&gt; ですが、関数によって返されることができ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ParseError&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; クラスと &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; クラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="de0533afad3f79319b3bf4b1fcb91b9bbdbc0565" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;SourcePos&lt;/code&gt; represents source positions. It contains the name of the source (i.e. file name), a line number and a column number. &lt;code&gt;SourcePos&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">抽象データ型 &lt;code&gt;SourcePos&lt;/code&gt; はソース位置を表します。ソースの名前（ファイル名）、行番号、列番号が含まれています。 &lt;code&gt;SourcePos&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; クラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="6a773f64dd31cf8cbcbf716ca186f3f80ceeb204" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;SourcePos&lt;/code&gt; represents source positions. It contains the name of the source (i.e. file name), a line number and a column number. &lt;code&gt;SourcePos&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">抽象データ型 &lt;code&gt;SourcePos&lt;/code&gt; は、ソースの位置を表します。これには、ソースの名前（つまり、ファイル名）、行番号、および列番号が含まれます。 &lt;code&gt;SourcePos&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; クラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="4896de6a97029ad3c503ab35de30ebe552f9de1c" translate="yes" xml:space="preserve">
          <source>The abstract type of documents. A Doc represents a &lt;em&gt;set&lt;/em&gt; of layouts. A Doc with no occurrences of Union or NoDoc represents just one layout.</source>
          <target state="translated">文書の抽象的なタイプ。Docは&lt;em&gt;一連&lt;/em&gt;のレイアウトを表します。UnionまたはNoDocの出現がないDocは、1つのレイアウトのみを表します。</target>
        </trans-unit>
        <trans-unit id="a80b0e5c19c356bd9ef420910831b319cf81af79" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; causes any items buffered for output in handle &lt;code&gt;hdl&lt;/code&gt; to be sent immediately to the operating system.</source>
          <target state="translated">アクション &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; により、ハンドル &lt;code&gt;hdl&lt;/code&gt; の出力用にバッファリングされたアイテムはすべて、オペレーティングシステムにすぐに送信されます。</target>
        </trans-unit>
        <trans-unit id="ee59ce1aebad5edf7e6e4aaef4677f21c7eefc31" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlushAll&quot;&gt;hFlushAll&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; flushes all buffered data in &lt;code&gt;hdl&lt;/code&gt;, including any buffered read data. Buffered read data is flushed by seeking the file position back to the point before the bufferred data was read, and hence only works if &lt;code&gt;hdl&lt;/code&gt; is seekable (see &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">アクション &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlushAll&quot;&gt;hFlushAll&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; は、バッファリングされた読み取りデータを含め、すべてのバッファリングされたデータを &lt;code&gt;hdl&lt;/code&gt; でフラッシュします。バッファリングされた読み取りデータは、バッファリングされたデータが読み取られる前のポイントにファイル位置をシークしてフラッシュされるため、 &lt;code&gt;hdl&lt;/code&gt; がシーク可能な場合にのみ機能します（ &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt; を参照）。</target>
        </trans-unit>
        <trans-unit id="a371db2521146387741275550e657dffca505303" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt;&lt;code&gt;encoding&lt;/code&gt; changes the text encoding for the handle &lt;code&gt;hdl&lt;/code&gt; to &lt;code&gt;encoding&lt;/code&gt;. The default encoding when a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is created is &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt;, namely the default encoding for the current locale.</source>
          <target state="translated">アクション &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; &lt;code&gt;encoding&lt;/code&gt; ハンドルのためのテキストエンコーディングに変更 &lt;code&gt;hdl&lt;/code&gt; への &lt;code&gt;encoding&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; が作成されたときのデフォルトのエンコーディングは &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; 、つまり現在のロケールのデフォルトのエンコーディングです。</target>
        </trans-unit>
        <trans-unit id="2e5909c7d1c1b470eac7ec2d2a3d5f1c7a3e6b23" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; causes any items buffered for output in handle &lt;code&gt;hdl&lt;/code&gt; to be sent immediately to the operating system.</source>
          <target state="translated">アクション &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; により、ハンドル &lt;code&gt;hdl&lt;/code&gt; の出力用にバッファリングされたアイテムはすべて、オペレーティングシステムにすぐに送信されます。</target>
        </trans-unit>
        <trans-unit id="30e8a3b807220ec41770ad1fcda8f8906a927d36" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;system-io#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; causes any items buffered for output in handle &lt;code&gt;hdl&lt;/code&gt; to be sent immediately to the operating system.</source>
          <target state="translated">アクション &lt;code&gt;&lt;a href=&quot;system-io#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; により、ハンドル &lt;code&gt;hdl&lt;/code&gt; の出力用にバッファリングされたアイテムはすべて、オペレーティングシステムにすぐに送信されます。</target>
        </trans-unit>
        <trans-unit id="9c8d6d26b1ac4ce2c7a317b47737557b2e637055" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt;&lt;code&gt;encoding&lt;/code&gt; changes the text encoding for the handle &lt;code&gt;hdl&lt;/code&gt; to &lt;code&gt;encoding&lt;/code&gt;. The default encoding when a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is created is &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt;, namely the default encoding for the current locale.</source>
          <target state="translated">アクション &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; &lt;code&gt;encoding&lt;/code&gt; ハンドルのためのテキストエンコーディングに変更 &lt;code&gt;hdl&lt;/code&gt; への &lt;code&gt;encoding&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; が作成されたときのデフォルトのエンコーディングは &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; 、つまり現在のロケールのデフォルトのエンコーディングです。</target>
        </trans-unit>
        <trans-unit id="576c394b164a6cc29cb4991bc6f5ba5ca7f6c771" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;g&lt;/code&gt; is called regardless of what occurs within &lt;code&gt;f&lt;/code&gt;, including async exceptions. Some monads allow &lt;code&gt;f&lt;/code&gt; to abort the computation via other effects than throwing an exception. For simplicity, we will consider aborting and throwing an exception to be two forms of &quot;throwing an error&quot;.</source>
          <target state="translated">アクション &lt;code&gt;g&lt;/code&gt; は、非同期例外を含め、 &lt;code&gt;f&lt;/code&gt; 内で何が発生したかに関係なく呼び出されます。一部のモナドでは、 &lt;code&gt;f&lt;/code&gt; が例外をスローする以外の効果を介して計算を中止できます。簡単にするために、例外の中止とスローは、「エラーのスロー」の2つの形式であると見なします。</target>
        </trans-unit>
        <trans-unit id="88ecb8776a874cfae1e583d670074ac14b0b3b9f" translate="yes" xml:space="preserve">
          <source>The action can handle the interrupt itself; a new &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt; exception will be thrown every time Ctrl-C is pressed.</source>
          <target state="translated">アクションは割り込み自体を処理できます。Ctrl-Cが押されるたびに、新しい &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt; 例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="7c560f66ad19d0c44deb93f325922bbfa7a14cb7" translate="yes" xml:space="preserve">
          <source>The actions to perform when a signal is received.</source>
          <target state="translated">信号を受信したときに実行する動作。</target>
        </trans-unit>
        <trans-unit id="17c5e604d289acc48a4aeb8ca32b75ead60baded" translate="yes" xml:space="preserve">
          <source>The actual command line arguments (presumably got from &lt;code&gt;&lt;a href=&quot;system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">実際のコマンドライン引数（おそらく &lt;code&gt;&lt;a href=&quot;system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; から取得）。</target>
        </trans-unit>
        <trans-unit id="51507a88f0049d4973537c6abea3ce2abf60b884" translate="yes" xml:space="preserve">
          <source>The actual meaning of the various columns in the output is:</source>
          <target state="translated">実際に出力されている様々な列の意味は</target>
        </trans-unit>
        <trans-unit id="8d600203b76ff6ccdd7956053fbe52659d549a35" translate="yes" xml:space="preserve">
          <source>The advantage of smaller stack chunks is that the garbage collector can avoid traversing stack chunks if they are known to be unmodified since the last collection, so reducing the chunk size means that the garbage collector can identify more stack as unmodified, and the GC overhead might be reduced. On the other hand, making stack chunks too small adds some overhead as there will be more overflow/underflow between chunks. The default setting of 32k appears to be a reasonable compromise in most cases.</source>
          <target state="translated">スタックチャンクを小さくする利点は、ガベージコレクタがスタックチャンクが最後のコレクション以降に変更されていないことが知られている場合、スタックチャンクをトラバースするのを避けることができることです。その一方で、スタックチャンクを小さくしすぎると、チャンク間でより多くのオーバーフロー/アンダーフローが発生するので、いくつかのオーバーヘッドが追加されます。32k のデフォルト設定は、ほとんどの場合、妥当な妥協点であるように見えます。</target>
        </trans-unit>
        <trans-unit id="351839425c4046d1ef3e16ab0a651854e611c6da" translate="yes" xml:space="preserve">
          <source>The advantage of this is that the key can be retrieved by &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; in addition to the value.</source>
          <target state="translated">これの利点は、値に加えて &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; によってキーを取得できることです。</target>
        </trans-unit>
        <trans-unit id="51801fd153e97264561ce8060f8815074cf0359c" translate="yes" xml:space="preserve">
          <source>The alarm timer</source>
          <target state="translated">アラームタイマー</target>
        </trans-unit>
        <trans-unit id="e9de65a28b0e1c87c6c42bf35a90ef7382160962" translate="yes" xml:space="preserve">
          <source>The algebraic data types</source>
          <target state="translated">代数データ型</target>
        </trans-unit>
        <trans-unit id="af0e67390188169e10bce1a919bdd538300c70aa" translate="yes" xml:space="preserve">
          <source>The algorithm for &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; is adapted from the &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; algorithm, but it generates definitions for &lt;code&gt;foldMap&lt;/code&gt;, &lt;code&gt;foldr&lt;/code&gt;, and &lt;code&gt;null&lt;/code&gt; instead of &lt;code&gt;fmap&lt;/code&gt;. In addition, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; filters out all constructor arguments on the RHS expression whose types do not mention the last type parameter, since those arguments do not need to be folded over.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;のアルゴリズムはDeriveFunctorアルゴリズムを採用して&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;ますが、 &lt;code&gt;fmap&lt;/code&gt; の代わりに &lt;code&gt;foldMap&lt;/code&gt; 、 &lt;code&gt;foldr&lt;/code&gt; 、および &lt;code&gt;null&lt;/code&gt; の定義を生成します。さらに、&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;は、型が最後の型パラメーターに言及していないRHS式のすべてのコンストラクター引数を除外します。これらの引数は折りたたむ必要がないためです。</target>
        </trans-unit>
        <trans-unit id="606c23fd4a39d6f5da98fdda576dd31c1413daef" translate="yes" xml:space="preserve">
          <source>The algorithm for &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; is adapted from the &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; algorithm, but it generates a definition for &lt;code&gt;traverse&lt;/code&gt; instead of &lt;code&gt;fmap&lt;/code&gt;. In addition, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; filters out all constructor arguments on the RHS expression whose types do not mention the last type parameter, since those arguments do not produce any effects in a traversal.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;のアルゴリズムはDeriveFunctorアルゴリズムを採用して&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;ますが、 &lt;code&gt;fmap&lt;/code&gt; ではなく &lt;code&gt;traverse&lt;/code&gt; の定義を生成します。さらに、&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;は、型が最後の型パラメーターに言及していないRHS式のすべてのコンストラクター引数をフィルターで除外します。これらの引数は、トラバーサルに影響を与えないためです。</target>
        </trans-unit>
        <trans-unit id="76b01a57a6338aab828a7c6e4ed1bf39e383096b" translate="yes" xml:space="preserve">
          <source>The allowed fields, with their types, are:</source>
          <target state="translated">許可されているフィールドとそのタイプは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="007ff1d2ad1a216037acaa14b7a1f3887c82c2b0" translate="yes" xml:space="preserve">
          <source>The alternative spelling &lt;code&gt;INLINEABLE&lt;/code&gt; is also accepted by GHC.</source>
          <target state="translated">代替スペル &lt;code&gt;INLINEABLE&lt;/code&gt; もGHCで受け入れられます。</target>
        </trans-unit>
        <trans-unit id="305a13d8f5f537b644a0383d8511ddbfd1c351ee" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map and &lt;em&gt;W&lt;/em&gt; referring to the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">償却実行時間は各操作に対して与えられ、&lt;em&gt;n&lt;/em&gt;はマップ内のエントリ数を指し、&lt;em&gt;W&lt;/em&gt;は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; （32または64）内のビット数を指します。</target>
        </trans-unit>
        <trans-unit id="4c5c6e2226b125e7f1dbe13dda91ec65df83b59c" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map and &lt;em&gt;W&lt;/em&gt; referring to the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">償却された実行時間は、操作ごとに示されます&lt;em&gt;。n&lt;/em&gt;はマップ内のエントリ数を示し、&lt;em&gt;W&lt;/em&gt;は &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; （32または64）内のビット数を示します。</target>
        </trans-unit>
        <trans-unit id="43383f5e57411cb28bfae33d1e0cb0912284dd35" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map and &lt;em&gt;W&lt;/em&gt; referring to the number of bits in an &lt;code&gt;Int&lt;/code&gt; (32 or 64).</source>
          <target state="translated">償却実行時間は各操作に対して与えられ、&lt;em&gt;n&lt;/em&gt;はマップ内のエントリ数を指し、&lt;em&gt;W&lt;/em&gt;は &lt;code&gt;Int&lt;/code&gt; （32または64）内のビット数を指します。</target>
        </trans-unit>
        <trans-unit id="9a366c01859c8d621928b2208d0c7ed30604c01f" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map.</source>
          <target state="translated">償却実行時間は各操作ごとに示され、&lt;em&gt;n&lt;/em&gt;はマップ内のエントリの数を示します。</target>
        </trans-unit>
        <trans-unit id="a8bc34451c62ea9fef00489d326317052195ef0d" translate="yes" xml:space="preserve">
          <source>The amount of CPU time and elapsed wall clock time while initialising the runtime system (INIT), running the program itself (MUT, the mutator), and garbage collecting (GC).</source>
          <target state="translated">ランタイムシステムの初期化(INIT)、プログラム自体の実行(MUT、ミューテータ)、ガベージコレクション(GC)を行っている間のCPU時間と経過したウォールクロック時間の量。</target>
        </trans-unit>
        <trans-unit id="324b96835c11121147eb9632d3d28270b6cd3cf5" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="translated">答えは「どちらかを投げるかもしれません」です 選択は非決定的です。何らかのタイプの例外をキャッチしている場合は、どちらかをキャッチできます。あなたが呼び出している場合は &lt;code&gt;catch&lt;/code&gt; タイプして &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; 、その後ハンドラがで実行されるかもしれません &lt;code&gt;DivideByZero&lt;/code&gt; 引数として、または &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; 例外がさらにアップをpropogatedすることができます。もう一度呼び出すと、逆の動作をする可能性があります。 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 計算であるため、これは問題ありません。</target>
        </trans-unit>
        <trans-unit id="fc2d971716bd2fe11fe8e65858d3f263f32451c4" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;ghc-io#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="translated">答えは「どちらかを投げるかもしれません」です 選択は非決定的です。何らかのタイプの例外をキャッチしている場合は、どちらかをキャッチできます。あなたが呼び出している場合は &lt;code&gt;catch&lt;/code&gt; タイプして &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; 、その後ハンドラがで実行されるかもしれません &lt;code&gt;DivideByZero&lt;/code&gt; 引数として、または &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; 例外がさらにアップをpropogatedすることができます。もう一度呼び出すと、逆の動作をする可能性があります。 &lt;code&gt;&lt;a href=&quot;ghc-io#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 計算であるため、これは問題ありません。</target>
        </trans-unit>
        <trans-unit id="6636ed331b405e67e4aa7a8f8c1f88ee4738daae" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="translated">答えは「どちらかを投げるかもしれません」です 選択は非決定的です。何らかのタイプの例外をキャッチしている場合は、どちらかをキャッチできます。あなたが呼び出している場合は &lt;code&gt;catch&lt;/code&gt; タイプして &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; 、その後ハンドラがで実行されるかもしれません &lt;code&gt;DivideByZero&lt;/code&gt; 引数として、または &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; 例外がさらにアップをpropogatedすることができます。もう一度呼び出すと、逆の動作をする可能性があります。 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 計算であるため、これは問題ありません。</target>
        </trans-unit>
        <trans-unit id="c111ce92793f7c8faf352718e7e5cd09fac00817" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="translated">答えは「どちらかを投げるかもしれない」です。選択は非決定論的です。何らかのタイプの例外をキャッチしている場合は、どちらかをキャッチする可能性があります。あなたが呼び出している場合は &lt;code&gt;catch&lt;/code&gt; タイプして &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; 、その後ハンドラがで実行されるかもしれません &lt;code&gt;DivideByZero&lt;/code&gt; 引数として、または &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; 例外がさらにアップをpropogatedすることができます。もう一度呼び出すと、逆の動作をする可能性があります。 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 計算であるため、これは問題ありません。</target>
        </trans-unit>
        <trans-unit id="215e7b52176702d87e95e2ce03acf7002f6125af" translate="yes" xml:space="preserve">
          <source>The approximate time when the program finished execution as a UNIX epoch timestamp.</source>
          <target state="translated">プログラムが実行を終了したおおよその時刻をUNIXのエポックタイムスタンプとして指定します。</target>
        </trans-unit>
        <trans-unit id="bba06a7c745bfe3d2d4d032c0a5307f863b5c408" translate="yes" xml:space="preserve">
          <source>The arbitrary-precision &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; number type.</source>
          <target state="translated">任意精度の &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 数型。</target>
        </trans-unit>
        <trans-unit id="77f549adbb8c3243a4f421f1caa3469b06d519cd" translate="yes" xml:space="preserve">
          <source>The arbitrary-precision &lt;code&gt;&lt;a href=&quot;numeric-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; number type.</source>
          <target state="translated">任意精度の &lt;code&gt;&lt;a href=&quot;numeric-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 数型。</target>
        </trans-unit>
        <trans-unit id="7e4663001ff64b0062c525758c18f678a0b593f7" translate="yes" xml:space="preserve">
          <source>The argument is usually the name of the application. Since it will be integrated into the path, it must consist of valid path characters.</source>
          <target state="translated">引数は通常、アプリケーションの名前です。これはパスに統合されるので、有効なパス文字でなければなりません。</target>
        </trans-unit>
        <trans-unit id="f7c4f0dc994aa251501707da51ab6248d1b7b620" translate="yes" xml:space="preserve">
          <source>The argument must be strictly positive, that condition is &lt;em&gt;not&lt;/em&gt; checked.</source>
          <target state="translated">引数は厳密に正でなければなら&lt;em&gt;ず&lt;/em&gt;、その条件はチェックされ&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="bfd85e788b1a4102dc5506f2821063aaee1859f8" translate="yes" xml:space="preserve">
          <source>The argument passed to &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is a function that takes as its argument another function, which can be used to restore the prevailing masking state within the context of the masked computation. For example, a common way to use &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is to protect the acquisition of a resource:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; に渡される引数は、引数として別の関数を使用する関数であり、マスクされた計算のコンテキスト内で一般的なマスク状態を復元するために使用できます。たとえば、 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; を使用する一般的な方法は、リソースの取得を保護することです。</target>
        </trans-unit>
        <trans-unit id="ec41714558fc08d08da55c62fab2fe097c6c6a18" translate="yes" xml:space="preserve">
          <source>The argument passed to &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is a function that takes as its argument another function, which can be used to restore the prevailing masking state within the context of the masked computation. For example, a common way to use &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is to protect the acquisition of a resource:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; に渡される引数は、引数として別の関数を使用する関数であり、マスクされた計算のコンテキスト内で一般的なマスク状態を復元するために使用できます。たとえば、 &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; を使用する一般的な方法は、リソースの取得を保護することです。</target>
        </trans-unit>
        <trans-unit id="f8b310556e765050dba6b8aa3221dbec61d539ee" translate="yes" xml:space="preserve">
          <source>The argument passed to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is a function that takes as its argument another function, which can be used to restore the prevailing masking state within the context of the masked computation. For example, a common way to use &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is to protect the acquisition of a resource:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; に渡される引数は、引数として別の関数を使用する関数であり、マスクされた計算のコンテキスト内で一般的なマスク状態を復元するために使用できます。たとえば、 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; を使用する一般的な方法は、リソースの取得を保護することです。</target>
        </trans-unit>
        <trans-unit id="3c1e08fffd8f2b265d44f0c771329303cef101fc" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;runGhc&lt;/code&gt; is a bit tricky. GHC needs this to find its libraries, so the argument must refer to the directory that is printed by &lt;code&gt;ghc --print-libdir&lt;/code&gt; for the same version of GHC that the program is being compiled with. Above we therefore use the &lt;code&gt;ghc-paths&lt;/code&gt; package which provides this for us.</source>
          <target state="translated">&lt;code&gt;runGhc&lt;/code&gt; への引数は少しトリッキーです。GHCはライブラリを見つけるためにこれを必要とするため、引数は、プログラムがコンパイルされているGHCと同じバージョンの &lt;code&gt;ghc --print-libdir&lt;/code&gt; によって出力されるディレクトリを参照する必要があります。したがって、上記では、これを提供する &lt;code&gt;ghc-paths&lt;/code&gt; パッケージを使用します。</target>
        </trans-unit>
        <trans-unit id="629bfd4051da2fa1a32d9993713c3423b906b41a" translate="yes" xml:space="preserve">
          <source>The arguments are:</source>
          <target state="translated">引数は</target>
        </trans-unit>
        <trans-unit id="af48f7ebb72df2bb8fd591d8c3756cf037769ab7" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; are in this order so that we can partially apply it, e.g.:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; への引数はこの順序になっているため、部分的に適用することができます。例：</target>
        </trans-unit>
        <trans-unit id="9ab336f12a087d2ee8f1cb00edb943f2a0db5354" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-getopt#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; の引数は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a6d74e6182495971a70d15c2958c5a641ef0bc47" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; are in this order so that we can partially apply it, e.g.:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; への引数はこの順序になっているため、部分的に適用することができます。例：</target>
        </trans-unit>
        <trans-unit id="bcf374949da96559812c28916c86dc0dd2c3b398" translate="yes" xml:space="preserve">
          <source>The arity can be specified using explicit binders and inline kind annotations:</source>
          <target state="translated">アリティは明示的なバインダーやインラインの親切アノテーションを使って指定することができます。</target>
        </trans-unit>
        <trans-unit id="ecd5594ea721a5c5b4964510fa025a0ba7161ee7" translate="yes" xml:space="preserve">
          <source>The array is undefined (i.e. bottom) if any index in the list is out of bounds. The Haskell 2010 Report further specifies that if any two associations in the list have the same index, the value at that index is undefined (i.e. bottom). However in GHC's implementation, the value at such an index is the value part of the last association with that index in the list.</source>
          <target state="translated">リスト内のいずれかのインデックスが範囲外の場合、配列は未定義(つまりボトム)になります。Haskell 2010レポートでは、リスト内の2つの関連付けが同じインデックスを持つ場合、そのインデックスの値は未定義(すなわち、ボトム)であることがさらに規定されています。しかし、GHCの実装では、そのようなインデックスの値は、リスト内のそのインデックスを持つ最後のアソシエーションの値の一部となります。</target>
        </trans-unit>
        <trans-unit id="44d43a4b5ab2e55067cf3b1a8adecaad475ca23d" translate="yes" xml:space="preserve">
          <source>The array type</source>
          <target state="translated">配列の型</target>
        </trans-unit>
        <trans-unit id="f14b40d222c3b195d28ca364c99460ad8aae96cd" translate="yes" xml:space="preserve">
          <source>The arrows web page at &lt;code&gt;http://www.haskell.org/arrows/&lt;/code&gt; &amp;lt;&lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt;&amp;gt;`__.</source>
          <target state="translated">矢印のWebページ（ &lt;code&gt;http://www.haskell.org/arrows/&lt;/code&gt; &amp;lt; &lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt; &amp;gt; `__）。</target>
        </trans-unit>
        <trans-unit id="5375e79ae4b0bd456d40500fcf8a53d9559263ad" translate="yes" xml:space="preserve">
          <source>The automatic loading of object files can sometimes lead to confusion, because non-exported top-level definitions of a module are only available for use in expressions at the prompt when the module is interpreted (see &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;). For this reason, you might sometimes want to force GHCi to load a module using the interpreter. This can be done by prefixing a &lt;code&gt;*&lt;/code&gt; to the module name or filename when using &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, for example</source>
          <target state="translated">エクスポートされていないモジュールのトップレベルの定義は、モジュールが解釈されたときにプロンプ​​トでの式でのみ使用できるため、オブジェクトファイルの自動読み込みは混乱を招く場合があります（&lt;a href=&quot;#ghci-scope&quot;&gt;プロンプトで実際にスコープにあるものを&lt;/a&gt;参照してください）。このため、GHCiにインタープリターを使用してモジュールを強制的にロードさせたい場合があります。これは、たとえば&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;を使用するときに、モジュール名またはファイル名の前に &lt;code&gt;*&lt;/code&gt; を付けることで実行できます。</target>
        </trans-unit>
        <trans-unit id="b8d9c5b3787a7ee0e2557b6cd2dbfe90790c68e2" translate="yes" xml:space="preserve">
          <source>The automatic specialisation of overloaded functions (with &lt;code&gt;-O&lt;/code&gt;) should take care of overloaded local and/or unexported functions.</source>
          <target state="translated">オーバーロードされた関数の自動特殊化（ &lt;code&gt;-O&lt;/code&gt; を使用）は、オーバーロードされたローカル関数やエクスポートされていない関数を処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="5b4889f9c5c10822085aef8616f19dbeeab3bf53" translate="yes" xml:space="preserve">
          <source>The available GHCi options are:</source>
          <target state="translated">利用可能なGHCiのオプションは</target>
        </trans-unit>
        <trans-unit id="320cabfd45dc56924b1a16a731023c186da51000" translate="yes" xml:space="preserve">
          <source>The available mode flags are:</source>
          <target state="translated">利用可能なモードフラグは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="7d80beedcca979af44b30619e5e06f25ee652ee4" translate="yes" xml:space="preserve">
          <source>The average and maximum &amp;ldquo;residency&amp;rdquo;, which is the amount of live data in bytes. The runtime can only determine the amount of live data during a major GC, which is why the number of samples corresponds to the number of major GCs (and is usually relatively small). To get a better picture of the heap profile of your program, use the &lt;a href=&quot;#rts-flag--hT&quot;&gt;&lt;code&gt;-hT&lt;/code&gt;&lt;/a&gt; RTS option (&lt;a href=&quot;#rts-profiling&quot;&gt;RTS options for profiling&lt;/a&gt;).</source>
          <target state="translated">平均および最大の「常駐」。これは、バイト単位のライブデータの量です。ランタイムはメジャーGC中のライブデータの量のみを決定できます。そのため、サンプルの数はメジャーGCの数に対応します（通常は比較的少ないです）。プログラムのヒーププロファイルをより正確に把握するには、&lt;a href=&quot;#rts-flag--hT&quot;&gt; &lt;code&gt;-hT&lt;/code&gt; &lt;/a&gt; RTSオプション（&lt;a href=&quot;#rts-profiling&quot;&gt;プロファイリングのRTSオプション&lt;/a&gt;）を使用します。</target>
        </trans-unit>
        <trans-unit id="a46eb9d9f0c06124eb5d61df6a1e2c54302d74ae" translate="yes" xml:space="preserve">
          <source>The avoided &amp;ldquo;dangerous&amp;rdquo; optimisations are those that can make runtime or space &lt;em&gt;worse&lt;/em&gt; if you&amp;rsquo;re unlucky. They are normally turned on or off individually.</source>
          <target state="translated">回避された「危険な」最適化とは、運が&lt;em&gt;悪いと&lt;/em&gt;ランタイムやスペースを&lt;em&gt;悪化さ&lt;/em&gt;せる可能性があるものです。通常は個別にオンまたはオフになります。</target>
        </trans-unit>
        <trans-unit id="eecb19b8afe1b4ff965ad37ca33e048b7e8a4fe6" translate="yes" xml:space="preserve">
          <source>The base must be greater than &lt;code&gt;1&lt;/code&gt;, the second argument, the number whose logarithm is sought, shall be positive, otherwise the result is meaningless.</source>
          <target state="translated">底は &lt;code&gt;1&lt;/code&gt; より大きい必要があります。2番目の引数、対数を求める数値は正でなければなりません。そうでない場合、結果は意味がありません。</target>
        </trans-unit>
        <trans-unit id="5bc476ce11547136a2a5b9c892017204522ab1a2" translate="yes" xml:space="preserve">
          <source>The basic algorithm for &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; walks the arguments of each constructor of a data type, applying a mapping function depending on the type of each argument. If a plain type variable is found that is syntactically equivalent to the last type parameter of the data type (&lt;code&gt;a&lt;/code&gt; in the above example), then we apply the function &lt;code&gt;f&lt;/code&gt; directly to it. If a type is encountered that is not syntactically equivalent to the last type parameter &lt;em&gt;but does mention&lt;/em&gt; the last type parameter somewhere in it, then a recursive call to &lt;code&gt;fmap&lt;/code&gt; is made. If a type is found which doesn&amp;rsquo;t mention the last type parameter at all, then it is left alone.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;の基本アルゴリズムは、データ型の各コンストラクターの引数をウォークし、各引数の型に応じてマッピング関数を適用します。データ型の最後の型パラメーター（上記の例では &lt;code&gt;a&lt;/code&gt; ）と構文的に等しいプレーン型変数が見つかった場合、関数 &lt;code&gt;f&lt;/code&gt; を直接それに適用します。構文的に最後の型パラメーターと同等ではない&lt;em&gt;が&lt;/em&gt;最後の型パラメーターのどこかに&lt;em&gt;言及して&lt;/em&gt;いる型が検出された場合、 &lt;code&gt;fmap&lt;/code&gt; の再帰呼び出しが行われます。最後の型パラメーターについてまったく言及していない型が見つかった場合、その型はそのままになります。</target>
        </trans-unit>
        <trans-unit id="3880ac769d164951235b5160f553818be744abe1" translate="yes" xml:space="preserve">
          <source>The basic arrow class.</source>
          <target state="translated">基本の矢印クラス。</target>
        </trans-unit>
        <trans-unit id="f8e6230ac47ed9f2f8c9e5c744ea8b38e5723913" translate="yes" xml:space="preserve">
          <source>The basic idea is as follows:</source>
          <target state="translated">基本的な考え方は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="ba3b2fdca46ebd4f364c251ed8663faaa8ea67c0" translate="yes" xml:space="preserve">
          <source>The basic idea is you render your structure in the form of this tree, and then use treeHtml to turn it into a Html object with the structure explicit.</source>
          <target state="translated">基本的な考え方は、このツリーの形で構造体をレンダリングし、 treeHtml を使って構造体を明示した Html オブジェクトに変換することです。</target>
        </trans-unit>
        <trans-unit id="1c047de532274bb72034a6627c348b88e9f40677" translate="yes" xml:space="preserve">
          <source>The basic principle is that all variables mentioned on the right hand side &lt;code&gt;&amp;lt;rhs&amp;gt;&lt;/code&gt; must be bound on the left hand side:</source>
          <target state="translated">基本的な原則は、右側の &lt;code&gt;&amp;lt;rhs&amp;gt;&lt;/code&gt; に記載されているすべての変数を左側にバインドする必要があるということです。</target>
        </trans-unit>
        <trans-unit id="ca1a1e0f9e4dd44a7cc3e7b636c0566990b56840" translate="yes" xml:space="preserve">
          <source>The basic syntax is that instead of specifying a package name P to the package flag &lt;code&gt;-package&lt;/code&gt;, instead we specify both a package name and a parenthesized, comma-separated list of module names to import. For example, &lt;code&gt;-package &quot;base (Data.List, Data.Bool)&quot;&lt;/code&gt; makes only &lt;code&gt;Data.List&lt;/code&gt; and &lt;code&gt;Data.Bool&lt;/code&gt; visible from package &lt;code&gt;base&lt;/code&gt;. We also support renaming of modules, in case you need to refer to both modules simultaneously; this is supporting by writing &lt;code&gt;OldModName as NewModName&lt;/code&gt;, e.g. &lt;code&gt;-package &quot;base (Data.Bool as Bool)&lt;/code&gt;. You can also write &lt;code&gt;-package &quot;base with (Data.Bool as Bool)&lt;/code&gt; to include all of the original bindings (e.g. the renaming is strictly additive). It&amp;rsquo;s important to specify quotes so that your shell passes the package name and thinning/renaming list as a single argument to GHC.</source>
          <target state="translated">基本的な構文は、パッケージ名Pをパッケージフラグ &lt;code&gt;-package&lt;/code&gt; に指定する代わりに、パッケージ名とインポートするモジュール名の括弧で囲まれたコンマ区切りのリストの両方を指定することです。たとえば、 &lt;code&gt;-package &quot;base (Data.List, Data.Bool)&quot;&lt;/code&gt; は、パッケージ &lt;code&gt;base&lt;/code&gt; から &lt;code&gt;Data.List&lt;/code&gt; と &lt;code&gt;Data.Bool&lt;/code&gt; のみを表示します。また、両方のモジュールを同時に参照する必要がある場合に備えて、モジュールの名前の変更もサポートしています。これは、書き込むことによってサポートされて &lt;code&gt;OldModName as NewModName&lt;/code&gt; 、例えば &lt;code&gt;-package &quot;base (Data.Bool as Bool)&lt;/code&gt; 。また、書くことができます &lt;code&gt;-package &quot;base with (Data.Bool as Bool)&lt;/code&gt; すべての元のバインディングを含める（たとえば、名前の変更は厳密に追加されます）。シェルがパッケージ名と間引き/名前変更リストを単一の引数としてGHCに渡すように、引用符を指定することが重要です。</target>
        </trans-unit>
        <trans-unit id="e4d64a56087518fa3e2214a7adad0a68d002b762" translate="yes" xml:space="preserve">
          <source>The batch compiler can be used alongside GHCi: compiled modules can be loaded into an interactive session and used in the same way as interpreted code, and in fact when using GHCi most of the library code will be pre-compiled. This means you get the best of both worlds: fast pre-compiled library code, and fast compile turnaround for the parts of your program being actively developed.</source>
          <target state="translated">バッチコンパイラはGHCiと一緒に使用することができます:コンパイルされたモジュールを対話型セッションにロードして、解釈されたコードと同じように使用することができます。これは、コンパイル済みのライブラリコードを高速に処理し、プログラムの開発中の部分を高速にコンパイルすることができるという、両方の利点を得ることができることを意味しています。</target>
        </trans-unit>
        <trans-unit id="8ef12a287f244edad57a058eca9787cf5ada079d" translate="yes" xml:space="preserve">
          <source>The behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; using the given search directories and testing each file for executable permissions. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この動作は、指定された検索ディレクトリを使用して各ファイルの実行権限をテストする &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; と同等です。詳細は &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; のドキュメントに記載されています。</target>
        </trans-unit>
        <trans-unit id="a37ab05f29aa8d1d66f30bee4471417ca0bbd0f1" translate="yes" xml:space="preserve">
          <source>The behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt;, returning only the first occurrence. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この動作は &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; と同等で、最初の発生のみを返します。詳細は &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; のドキュメントに記載されています。</target>
        </trans-unit>
        <trans-unit id="6c8e66257c1f95cca3356ee64f960b20dcb60818" translate="yes" xml:space="preserve">
          <source>The behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt;. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">動作は &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; と同等です。詳細は &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; のドキュメントに記載されています。</target>
        </trans-unit>
        <trans-unit id="eb1e1a3692688caa279ab0329a4e161ca0e7b861" translate="yes" xml:space="preserve">
          <source>The behaviour is simply this:</source>
          <target state="translated">振る舞いは単純にこれです。</target>
        </trans-unit>
        <trans-unit id="25a0b28ac23419d2d5d4b31eb8e82eaa74968d1a" translate="yes" xml:space="preserve">
          <source>The behaviour of parallel list comprehensions follows that of zip, in that the resulting list will have the same length as the shortest branch.</source>
          <target state="translated">並列リスト内包の振る舞いは、結果として得られるリストが最短のブランチと同じ長さになるという点で、zipのそれに似ています。</target>
        </trans-unit>
        <trans-unit id="4c2566b6e8b4d963d45c5f213c50828df28117fe" translate="yes" xml:space="preserve">
          <source>The benefit of including dependency information is that it allows us to define more general multiple parameter classes, without ambiguity problems, and with the benefit of more accurate types. To illustrate this, we return to the collection class example, and annotate the original definition of &lt;code&gt;Collects&lt;/code&gt; with a simple dependency:</source>
          <target state="translated">依存関係情報を含めることの利点は、あいまいさの問題がなく、より正確な型の利点を持つ、より一般的な複数のパラメータークラスを定義できることです。これを説明するために、コレクションクラスの例に戻り、単純な依存関係で &lt;code&gt;Collects&lt;/code&gt; の元の定義に注釈を付けます。</target>
        </trans-unit>
        <trans-unit id="947bc2cb4d922e45d67175db691e9955f759c4f5" translate="yes" xml:space="preserve">
          <source>The biconnected components of a graph. An undirected graph is biconnected if the deletion of any vertex leaves it connected.</source>
          <target state="translated">グラフの連結された構成要素。無向グラフは、いずれかの頂点が削除されると連結されたままになる場合、連結されています。</target>
        </trans-unit>
        <trans-unit id="fbd73ac6d922a5bdced0fb605663eb345d894008" translate="yes" xml:space="preserve">
          <source>The binder being annotated must be at the top level (i.e. no nested binders)</source>
          <target state="translated">注釈されるバインダーは最上位レベルでなければなりません(つまり、入れ子になっていないバインダーでなければなりません)。</target>
        </trans-unit>
        <trans-unit id="63969d96d060c4b503447fa167a99cc5d9a634d8" translate="yes" xml:space="preserve">
          <source>The binder being annotated must be declared in the current module</source>
          <target state="translated">アノテーションされるバインダーは、現在のモジュールで宣言されていなければなりません。</target>
        </trans-unit>
        <trans-unit id="7e1a540e18890acf0212904549c9082483047e09" translate="yes" xml:space="preserve">
          <source>The binding is lazy, but when either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is evaluated by &lt;code&gt;b&lt;/code&gt; the entire pattern is matched, including forcing the evaluation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">バインディングは遅延ですが、 &lt;code&gt;x&lt;/code&gt; または &lt;code&gt;y&lt;/code&gt; のいずれかが &lt;code&gt;b&lt;/code&gt; によって評価されると、 &lt;code&gt;x&lt;/code&gt; の評価の強制を含む、パターン全体が一致します。</target>
        </trans-unit>
        <trans-unit id="5313486dfdead25fb97fb53d215625b3a8e92cb9" translate="yes" xml:space="preserve">
          <source>The body &lt;code&gt;e&lt;/code&gt; of a &lt;code&gt;static e&lt;/code&gt; expression must be a closed expression. Where we say an expression is &lt;em&gt;closed&lt;/em&gt; when all of its free (type) variables are closed. And a variable is &lt;em&gt;closed&lt;/em&gt; if it is let-bound to a &lt;em&gt;closed&lt;/em&gt; expression and its type is &lt;em&gt;closed&lt;/em&gt; as well. And a type is &lt;em&gt;closed&lt;/em&gt; if it has no free variables.</source>
          <target state="translated">&lt;code&gt;static e&lt;/code&gt; 式の本体 &lt;code&gt;e&lt;/code&gt; は閉じた式でなければなりません。式は、その自由（タイプ）変数がすべて&lt;em&gt;閉じている&lt;/em&gt;ときに&lt;em&gt;閉じ&lt;/em&gt;ていると言います。そして、変数がされて&lt;em&gt;閉じられ&lt;/em&gt;、それが聞かせて結合されている場合&lt;em&gt;、閉じた&lt;/em&gt;表現とその型がされて&lt;em&gt;閉じて&lt;/em&gt;もよう。そして、自由変数がない場合、型は&lt;em&gt;閉じられ&lt;/em&gt;ます。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="592ada029a062869cce6e9bab58606be6defb777" translate="yes" xml:space="preserve">
          <source>The body of &lt;code&gt;f&lt;/code&gt; requires a &lt;code&gt;Num Int&lt;/code&gt; instance. We could solve this constraint from the context because we have &lt;code&gt;C Int b&lt;/code&gt; and that provides us a solution for &lt;code&gt;Num Int&lt;/code&gt;. However, we can often produce much better code by directly solving for an available &lt;code&gt;Num Int&lt;/code&gt; dictionary we might have at hand. This removes potentially many layers of indirection and crucially allows other optimisations to fire as the dictionary will be statically known and selector functions can be inlined.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; の本体には &lt;code&gt;Num Int&lt;/code&gt; インスタンスが必要です。 &lt;code&gt;C Int b&lt;/code&gt; があり、 &lt;code&gt;Num Int&lt;/code&gt; のソリューションを提供するため、この制約をコンテキストから解決できます。ただし、手元にある利用可能な &lt;code&gt;Num Int&lt;/code&gt; 辞書を直接解決することで、はるかに優れたコードを生成できることがよくあります。これにより、潜在的に多くの間接層が削除され、辞書が静的に認識され、セレクター関数をインライン化できるため、他の最適化を実行できるようになります。</target>
        </trans-unit>
        <trans-unit id="6d145adb9d3d5724f47490428e23e3c43d0c8235" translate="yes" xml:space="preserve">
          <source>The body of &lt;code&gt;h&lt;/code&gt;&lt;em&gt;can&lt;/em&gt; refer to the function &lt;code&gt;k&lt;/code&gt; appearing on the other side of the declaration quasiquoter, as quasiquoters do not cause a declaration group to be broken up.</source>
          <target state="translated">準引用符は宣言グループを分割しないため、 &lt;code&gt;h&lt;/code&gt; の本体は宣言準引用符の反対側にある関数 &lt;code&gt;k&lt;/code&gt; を参照&lt;em&gt;でき&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="8c2a782fcf9cc8cd32d7c6db0f011051b79d7285" translate="yes" xml:space="preserve">
          <source>The bound on the size of sequences of bytes generated by this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; によって生成されたバイトシーケンスのサイズの上限。</target>
        </trans-unit>
        <trans-unit id="efcab014d352f2160b0e056ce4481103488be8c8" translate="yes" xml:space="preserve">
          <source>The bounds are specified as a pair of the lowest and highest bounds in the array respectively. For example, a one-origin vector of length 10 has bounds (1,10), and a one-origin 10 by 10 matrix has bounds ((1,1),(10,10)).</source>
          <target state="translated">境界は,配列の中の最低境界と最高境界のペアとしてそれぞれ指定されます.例えば,長さ10の1オリジンベクトルは(1,10)の境界を持ち,10×10の1オリジン行列は((1,1),(10,10))の境界を持ちます.</target>
        </trans-unit>
        <trans-unit id="ba1cb6f6655a10a0c6294b458c9d83470571695d" translate="yes" xml:space="preserve">
          <source>The bounds of an &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Array&lt;/code&gt; の境界。</target>
        </trans-unit>
        <trans-unit id="55a1eeab90b32df97217b33a312a220ee3d8254d" translate="yes" xml:space="preserve">
          <source>The bounds of the array</source>
          <target state="translated">配列の境界</target>
        </trans-unit>
        <trans-unit id="5e0f777f52cc6d21bfe3b719f3991ded42b0a70a" translate="yes" xml:space="preserve">
          <source>The bounds with which an array was constructed.</source>
          <target state="translated">配列が構築された境界線.</target>
        </trans-unit>
        <trans-unit id="606c7ca088c78a3f35afe2ec49468115c18dfed0" translate="yes" xml:space="preserve">
          <source>The buffer is represented by a record, where the record contains the raw buffer and the start/end points of the filled portion. The buffer contents itself is mutable, but the rest of the record is immutable. This is a slightly odd mix, but it turns out to be quite practical: by making all the buffer metadata immutable, we can have operations on buffer metadata outside of the IO monad.</source>
          <target state="translated">バッファはレコードで表現され、レコードには生のバッファと埋められた部分の開始点と終了点が含まれています。バッファの内容自体は変更可能ですが、レコードの残りの部分は不変です。バッファのメタデータをすべて不変にすることで、IOモナドの外でバッファのメタデータを操作することができます。</target>
        </trans-unit>
        <trans-unit id="7e80cbba3a922b5261d972496342488e7c081b28" translate="yes" xml:space="preserve">
          <source>The bug tracker lists bugs that have been reported in GHC but not yet fixed: see the &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/&quot;&gt;GHC Trac&lt;/a&gt;. In addition to those, GHC also has the following known bugs or infelicities. These bugs are more permanent; it is unlikely that any of them will be fixed in the short term.</source>
          <target state="translated">参照：GHCで報告されたが、まだ修正されているバグトラッカーリストのバグ&lt;a href=&quot;http://ghc.haskell.org/trac/ghc/&quot;&gt;GHCのTracを&lt;/a&gt;。これらに加えて、GHCには以下の既知のバグまたは欠陥があります。これらのバグはより永続的です。それらのいずれかが短期的に修正される可能性は低いです。</target>
        </trans-unit>
        <trans-unit id="a911bbbc10fa83662b5cd864e984b17a1755dfc0" translate="yes" xml:space="preserve">
          <source>The bug tracker lists bugs that have been reported in GHC but not yet fixed: see the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues&quot;&gt;GHC issue tracker&lt;/a&gt;. In addition to those, GHC also has the following known bugs or infelicities. These bugs are more permanent; it is unlikely that any of them will be fixed in the short term.</source>
          <target state="translated">バグトラッカーには、GHCで報告されているが、まだ修正されていないバグが一覧表示されます&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues&quot;&gt;。GHC問題トラッカーを&lt;/a&gt;参照してください。これらに加えて、GHCには次の既知のバグまたは欠陥もあります。これらのバグはより永続的です。それらのいずれかが短期的に修正される可能性は低いです。</target>
        </trans-unit>
        <trans-unit id="7c15ff27610c2478bb9e4d3ab87096d2c276c0af" translate="yes" xml:space="preserve">
          <source>The byte ordering of the target machine.</source>
          <target state="translated">ターゲットマシンのバイト順。</target>
        </trans-unit>
        <trans-unit id="9d60877c7df977c480a2e8c741eba795e8186655" translate="yes" xml:space="preserve">
          <source>The byte-order-mark is strictly unnecessary in UTF-8, but is sometimes used to identify the encoding of a file.</source>
          <target state="translated">UTF-8ではバイトオーダマークは厳密には不要ですが、ファイルのエンコーディングを識別するために使用されることがあります。</target>
        </trans-unit>
        <trans-unit id="a1ef7711364b299ccecf0740fe399441352dee0d" translate="yes" xml:space="preserve">
          <source>The bytecode interpreter doesn&amp;rsquo;t support most uses of unboxed tuples or sums, so GHCi will automatically compile these modules, and all modules they depend on, to object code instead of bytecode.</source>
          <target state="translated">バイトコードインタープリターは、ボックス化されていないタプルまたは合計のほとんどの使用をサポートしていないため、GHCiは、これらのモジュールとそれらが依存するすべてのモジュールを、バイトコードではなくオブジェクトコードに自動的にコンパイルします。</target>
        </trans-unit>
        <trans-unit id="8e514a824a293915d542219870ba513432dcaf11" translate="yes" xml:space="preserve">
          <source>The bytes read, how many bytes were read.</source>
          <target state="translated">読まれたバイト数、何バイト読まれたか。</target>
        </trans-unit>
        <trans-unit id="b6a0060fcedfd8a68377b3d1eb2b5aba06d7d975" translate="yes" xml:space="preserve">
          <source>The call</source>
          <target state="translated">呼び出し</target>
        </trans-unit>
        <trans-unit id="39398c8eae38902a5e0ff83f99f6b2f202aad4e7" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;inline f&lt;/code&gt; arranges that &lt;code&gt;f&lt;/code&gt; is inlined, regardless of its size. More precisely, the call &lt;code&gt;inline f&lt;/code&gt; rewrites to the right-hand side of &lt;code&gt;f&lt;/code&gt;'s definition. This allows the programmer to control inlining from a particular call site rather than the definition site of the function (c.f. &lt;code&gt;INLINE&lt;/code&gt; pragmas).</source>
          <target state="translated">コール・ &lt;code&gt;inline f&lt;/code&gt; 並べ &lt;code&gt;f&lt;/code&gt; は関係なく、その大きさの、インライン化されます。より正確には、 &lt;code&gt;inline f&lt;/code&gt; の呼び出しは、 &lt;code&gt;f&lt;/code&gt; の定義の右側に書き直されます。これにより、プログラマーは、関数の定義サイトではなく、特定の呼び出しサイトからのインライン化を制御できます（ &lt;code&gt;INLINE&lt;/code&gt; プラグマを参照）。</target>
        </trans-unit>
        <trans-unit id="7b04d6b098bff47077a3361dce7c4b2060070b35" translate="yes" xml:space="preserve">
          <source>The call may block for a long time if a GC is in progress. We can&amp;rsquo;t use this method if the C API we&amp;rsquo;re calling doesn&amp;rsquo;t allow blocking in the callback.</source>
          <target state="translated">GCが進行中の場合、呼び出しが長時間ブロックされることがあります。呼び出しているC APIがコールバックでのブロックを許可していない場合、このメソッドは使用できません。</target>
        </trans-unit>
        <trans-unit id="0f662e8be9b1e8327dfadad6256f93b3102227e4" translate="yes" xml:space="preserve">
          <source>The call stack</source>
          <target state="translated">呼び出しスタック</target>
        </trans-unit>
        <trans-unit id="0b95e6d04b2d9db9df511faee23c172fb043db56" translate="yes" xml:space="preserve">
          <source>The call stack here consists of a single entry, pinpointing the source of the call to &lt;code&gt;error&lt;/code&gt;. However, by annotating several computations with &lt;code&gt;HasCallStack&lt;/code&gt;, figuring out the exact circumstances and sequences of calls that lead to a call to &lt;code&gt;error&lt;/code&gt; becomes a lot easier, as demonstrated with the simple example below.</source>
          <target state="translated">ここでの呼び出しスタックは、 &lt;code&gt;error&lt;/code&gt; への呼び出しのソースを特定する単一のエントリで構成されています。ただし、以下の簡単な例で示すように、 &lt;code&gt;HasCallStack&lt;/code&gt; を使用していくつかの計算に注釈を付けることにより、 &lt;code&gt;error&lt;/code&gt; 呼び出しにつながる正確な状況と呼び出しのシーケンスを理解することが非常に簡単になります。</target>
        </trans-unit>
        <trans-unit id="e65b75e639ba49f45b306162220bcb4b4e376b49" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;hs_init()&lt;/code&gt; initializes GHC&amp;rsquo;s runtime system. Do NOT try to invoke any Haskell functions before calling &lt;code&gt;hs_init()&lt;/code&gt;: bad things will undoubtedly happen.</source>
          <target state="translated">&lt;code&gt;hs_init()&lt;/code&gt; の呼び出しは、GHCのランタイムシステムを初期化します。 &lt;code&gt;hs_init()&lt;/code&gt; を呼び出す前にHaskell関数を呼び出そうとしないでください。間違いなく悪いことが起こります。</target>
        </trans-unit>
        <trans-unit id="b0d2f80290077bea927d89a134d957a184f32cc5" translate="yes" xml:space="preserve">
          <source>The calls &lt;code&gt;&lt;a href=&quot;ghc-enum#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-enum#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; should result in a runtime error.</source>
          <target state="translated">通話 &lt;code&gt;&lt;a href=&quot;ghc-enum#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;ghc-enum#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; 実行時エラーが発生しなければなりません。</target>
        </trans-unit>
        <trans-unit id="319dd86afb1a88f29e7d25a55be6766bfa4bbc86" translate="yes" xml:space="preserve">
          <source>The calls &lt;code&gt;&lt;a href=&quot;prelude#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; should result in a runtime error.</source>
          <target state="translated">通話 &lt;code&gt;&lt;a href=&quot;prelude#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;prelude#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; 実行時エラーが発生しなければなりません。</target>
        </trans-unit>
        <trans-unit id="82bb223904345033a341142d4c4dc792513b34b0" translate="yes" xml:space="preserve">
          <source>The case for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; is rather interesting. Here, we call the final function &lt;code&gt;encode&lt;/code&gt; that we yet have to define, recursively. We will use another type class &lt;code&gt;Encode&lt;/code&gt; for that function:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; のケースはかなり興味深いです。ここでは、再帰的に定義する必要がある最終的な関数 &lt;code&gt;encode&lt;/code&gt; を呼び出します。その関数には別の型クラス &lt;code&gt;Encode&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="dbeba971901c44630a87f3ab4af1926015f93dc7" translate="yes" xml:space="preserve">
          <source>The channels are implemented with &lt;code&gt;MVar&lt;/code&gt;s and therefore inherit all the caveats that apply to &lt;code&gt;MVar&lt;/code&gt;s (possibility of races, deadlocks etc). The stm (software transactional memory) library has a more robust implementation of channels called &lt;code&gt;TChan&lt;/code&gt;s.</source>
          <target state="translated">チャネルは、で実装され &lt;code&gt;MVar&lt;/code&gt; Sしたがってに適用されるすべての警告継承 &lt;code&gt;MVar&lt;/code&gt; S（レースの可能性、デッドロックなど）。stm（ソフトウェアトランザクションメモリ）ライブラリには、 &lt;code&gt;TChan&lt;/code&gt; と呼ばれるチャネルのより堅牢な実装があります。</target>
        </trans-unit>
        <trans-unit id="4069bea430852a057890df955f47a154334cab42" translate="yes" xml:space="preserve">
          <source>The character that is used to separate the entries in the $PATH environment variable.</source>
          <target state="translated">環境変数 $PATH のエントリを区切るために使用される文字。</target>
        </trans-unit>
        <trans-unit id="ba11d47bc9956242fbb3ca66e5d4200f63de5f8d" translate="yes" xml:space="preserve">
          <source>The character that separates directories. In the case where more than one character is possible, &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; is the 'ideal' one.</source>
          <target state="translated">ディレクトリを区切る文字。複数の文字が可能な場合、 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; は「理想的な」文字です。</target>
        </trans-unit>
        <trans-unit id="0adbd55b5e31c8dee6ffdd25e981917f83978616" translate="yes" xml:space="preserve">
          <source>The character that separates directories. In the case where more than one character is possible, &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; is the 'ideal' one.</source>
          <target state="translated">ディレクトリを区切る文字。複数の文字が可能な場合、 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; は「理想的な」文字です。</target>
        </trans-unit>
        <trans-unit id="3300c6070d1ff47cc64a9cd4f2a57598bed4fe49" translate="yes" xml:space="preserve">
          <source>The character type &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) code points (i.e. characters, see &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">文字タイプ &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; は、値がUnicode（または同等のISO / IEC 10646）コードポイントを表す列挙体です（つまり、文字。詳細については、&lt;a href=&quot;http://www.unicode.org/&quot;&gt;http：//www.unicode.org/&lt;/a&gt;を参照してください）。このセットは、ISO 8859-1（Latin-1）文字セット（最初の256文字）を拡張します。これは、それ自体がASCII文字セット（最初の128文字）の拡張です。Haskellの文字リテラルの型は &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a83bfe2a3131f5d1fa9053b377b2dd8ef00abbee" translate="yes" xml:space="preserve">
          <source>The character type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) code points (i.e. characters, see &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">文字タイプ &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; は、値がUnicode（または同等のISO / IEC 10646）コードポイントを表す列挙体です（つまり、文字。詳細については、&lt;a href=&quot;http://www.unicode.org/&quot;&gt;http：//www.unicode.org/&lt;/a&gt;を参照してください）。このセットは、ISO 8859-1（Latin-1）文字セット（最初の256文字）を拡張します。これは、それ自体がASCII文字セット（最初の128文字）の拡張です。Haskellの文字リテラルの型は &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e57b1fe87f343495401c4e61909f138148056d67" translate="yes" xml:space="preserve">
          <source>The character type &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) code points (i.e. characters, see &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">文字タイプ &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; は、値がUnicode（または同等のISO / IEC 10646）コードポイントを表す列挙体です（つまり、文字。詳細については、&lt;a href=&quot;http://www.unicode.org/&quot;&gt;http：//www.unicode.org/&lt;/a&gt;を参照してください）。このセットは、ISO 8859-1（Latin-1）文字セット（最初の256文字）を拡張します。これは、それ自体がASCII文字セット（最初の128文字）の拡張です。Haskellの文字リテラルの型は &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="47f8f2f2dc9e65ebc1b9adf566bdf62f3dc06201" translate="yes" xml:space="preserve">
          <source>The chunk size used for I/O. Currently set to 32k, less the memory management overhead</source>
          <target state="translated">I/Oに使用するチャンクサイズ。現在は32kに設定されています。</target>
        </trans-unit>
        <trans-unit id="c4ebe1e22516dcf7d377102ba02d7a72071fb54c" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; allows a concrete representation of a type to be calculated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; クラスを使用すると、タイプの具体的な表現を計算できます。</target>
        </trans-unit>
        <trans-unit id="26ec99c0bc5533ce5fa506bf5dd334d666afbabf" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; allows a concrete representation of a type to be calculated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; クラスを使用すると、タイプの具体的な表現を計算できます。</target>
        </trans-unit>
        <trans-unit id="95e5985c3bffdb6706bd6da87ba82bb2b1f9502b" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; allows a concrete representation of a type to be calculated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; クラスを使用すると、タイプの具体的な表現を計算できます。</target>
        </trans-unit>
        <trans-unit id="a0793307c198436ef6cbb2b38d12d842f11f5daa" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;IsLabel&lt;/code&gt; is defined as:</source>
          <target state="translated">&lt;code&gt;IsLabel&lt;/code&gt; クラスは次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="da702fa4f893f1ff84ab94ead774536cedcefc5d" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;IsString&lt;/code&gt; is defined as:</source>
          <target state="translated">&lt;code&gt;IsString&lt;/code&gt; クラスは次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="314c44e92114b49583eff2b98f5eb8171a7374ef" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;IsString&lt;/code&gt; is not in scope by default. If you want to mention it explicitly (for example, to give an instance declaration for it), you can import it from module &lt;code&gt;Data.String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;IsString&lt;/code&gt; クラスは、デフォルトではスコープ内にありません。明示的に言及したい場合（たとえば、インスタンスの宣言を与える場合）、モジュール &lt;code&gt;Data.String&lt;/code&gt; からインポートできます。</target>
        </trans-unit>
        <trans-unit id="66741f48f8c9a811c479be37c49092c2f5831600" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Lift&lt;/code&gt;, unlike other derivable classes, lives in &lt;code&gt;template-haskell&lt;/code&gt; instead of &lt;code&gt;base&lt;/code&gt;. Having a data type be an instance of &lt;code&gt;Lift&lt;/code&gt; permits its values to be promoted to Template Haskell expressions (of type &lt;code&gt;ExpQ&lt;/code&gt; and &lt;code&gt;TExpQ a&lt;/code&gt;), which can then be spliced into Haskell source code.</source>
          <target state="translated">クラス &lt;code&gt;Lift&lt;/code&gt; は、他の &lt;code&gt;template-haskell&lt;/code&gt; 可能なクラスとは異なり、 &lt;code&gt;base&lt;/code&gt; ではなくtemplate-haskellに存在します。データ型を &lt;code&gt;Lift&lt;/code&gt; のインスタンスにすると、その値をテンプレートHaskell式（タイプ &lt;code&gt;ExpQ&lt;/code&gt; および &lt;code&gt;TExpQ a&lt;/code&gt; ）にプロモートでき、Haskellソースコードにスプライスできます。</target>
        </trans-unit>
        <trans-unit id="46c25aa9d510e6dfd769a86618af627836e67d95" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Lift&lt;/code&gt;, unlike other derivable classes, lives in &lt;code&gt;template-haskell&lt;/code&gt; instead of &lt;code&gt;base&lt;/code&gt;. Having a data type be an instance of &lt;code&gt;Lift&lt;/code&gt; permits its values to be promoted to Template Haskell expressions (of type &lt;code&gt;ExpQ&lt;/code&gt;), which can then be spliced into Haskell source code.</source>
          <target state="translated">クラス &lt;code&gt;Lift&lt;/code&gt; は、他の &lt;code&gt;template-haskell&lt;/code&gt; クラスとは異なり、 &lt;code&gt;base&lt;/code&gt; ではなくtemplate-haskellにあります。データ型を &lt;code&gt;Lift&lt;/code&gt; のインスタンスにすることで、その値を（型 &lt;code&gt;ExpQ&lt;/code&gt; の）テンプレートHaskell式に昇格させ、Haskellソースコードにスプライスすることができます。</target>
        </trans-unit>
        <trans-unit id="cfedc7f27395d9e14f3b5dcae9116c684144dba3" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Typeable&lt;/code&gt; is very special:</source>
          <target state="translated">&lt;code&gt;Typeable&lt;/code&gt; クラスは非常に特別です。</target>
        </trans-unit>
        <trans-unit id="a352e3bea5c92259e258192deb3bd391cda34543" translate="yes" xml:space="preserve">
          <source>The class instances for sequences are all based very closely on those for lists.</source>
          <target state="translated">シーケンスのクラスインスタンスは、すべてリストのクラスインスタンスと非常に密接に関係しています。</target>
        </trans-unit>
        <trans-unit id="f29fdb13c7afe65c971d977ce119c943fb00e75f" translate="yes" xml:space="preserve">
          <source>The class of contravariant functors.</source>
          <target state="translated">反変ファンクタのクラス。</target>
        </trans-unit>
        <trans-unit id="15b84a81fb0f85cb419535a3a61b9ad1d3da02f7" translate="yes" xml:space="preserve">
          <source>The class of monad transformers.</source>
          <target state="translated">モナド変圧器のクラス。</target>
        </trans-unit>
        <trans-unit id="1aba4d36676a8723cc042f0ef18005b4207f229e" translate="yes" xml:space="preserve">
          <source>The class of monad transformers. Instances should satisfy the following laws, which state that &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; is a monad transformation:</source>
          <target state="translated">モナド変換子のクラス。インスタンスは、 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; はモナド変換であるとする次の法律を満たしている必要があります。</target>
        </trans-unit>
        <trans-unit id="968994db3d9c45181b57f61fe4736e2627f5c6a6" translate="yes" xml:space="preserve">
          <source>The class of monoids (types with an associative binary operation that has an identity). Instances should satisfy the following:</source>
          <target state="translated">モノイドのクラス(連想二項演算を持つ型で、同一性を持つもの)。インスタンスは以下の条件を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="80aae29c2b395ab518f6cbf2867e04f61aabbf53" translate="yes" xml:space="preserve">
          <source>The class of semigroups (types with an associative binary operation).</source>
          <target state="translated">半グループ(連想二項演算を持つ型)のクラス。</target>
        </trans-unit>
        <trans-unit id="ef50832e806510cb4bbe9f9aafa22744526d2ab1" translate="yes" xml:space="preserve">
          <source>The class of the instance declaration is not declared in &lt;code&gt;M&lt;/code&gt;, and</source>
          <target state="translated">インスタンス宣言のクラスが &lt;code&gt;M&lt;/code&gt; で宣言されていません。</target>
        </trans-unit>
        <trans-unit id="cc31daa90372a8a474d012704a661ac277d958aa" translate="yes" xml:space="preserve">
          <source>The class of types which can be parsed given a UNIX-style time format string.</source>
          <target state="translated">UNIXスタイルの時刻書式文字列を与えられたときに解析できる型のクラスです。</target>
        </trans-unit>
        <trans-unit id="380a9b6da5c050f1cf3fa8febdb6d2797a540fc9" translate="yes" xml:space="preserve">
          <source>The closure of the superclass relation over these local axioms : &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; and &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt;</source>
          <target state="translated">これらのローカル公理上のスーパークラス関係の閉鎖： &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; および &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0848f15a7a4cc86662e9097e3f0cf4b1532d9192" translate="yes" xml:space="preserve">
          <source>The code for the method in the instance declaration is typechecked against the type signature supplied in the instance declaration, as you would expect. So if the instance signature is more polymorphic than required, the code must be too.</source>
          <target state="translated">インスタンス宣言のメソッドのコードは、期待されるように、インスタンス宣言で与えられた型シグネチャに対して型チェックが行われます。そのため、インスタンスシグネチャが必要以上にポリモーフィックであれば、コードもポリモーフィックでなければなりません。</target>
        </trans-unit>
        <trans-unit id="e5001edd8f78114b36e24d8f0a44754ee90b2f4d" translate="yes" xml:space="preserve">
          <source>The code generator tries to generate as compact layout as possible for each unboxed sum. In the best case, size of an unboxed sum is size of its biggest alternative plus one word (for a tag). The algorithm for generating the memory layout for a sum type works like this:</source>
          <target state="translated">コードジェネレーターは、各アンボックス化された和に対して可能な限りコンパクトなレイアウトを生成しようとします。最良のケースでは、アンボックス化された合計のサイズは、最大の代替品のサイズに1ワード(タグの場合)を加えたものになります。和のタイプのメモリ・レイアウトを生成するアルゴリズムは次のように動作します。</target>
        </trans-unit>
        <trans-unit id="3837898dd791b811ea7932889c5130e161088d94" translate="yes" xml:space="preserve">
          <source>The code of the &quot;dominant&quot; language of the webpage.</source>
          <target state="translated">ウェブページの「支配的な」言語のコード。</target>
        </trans-unit>
        <trans-unit id="a45302a43608cfe9a77b37998c0a415b8fef0ffc" translate="yes" xml:space="preserve">
          <source>The code should be mostly self-explanatory. The slightly awkward syntax is because the combinators are written such that the size-bound of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; can be computed at compile time. We also explicitly inline the &lt;code&gt;fixed2&lt;/code&gt; primitive, which encodes a fixed tuple of characters, to ensure that the bound computation happens at compile time. When encoding the following list of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, the optimized implementation of &lt;code&gt;renderString&lt;/code&gt; is two times faster.</source>
          <target state="translated">コードは、ほとんどの場合自明です。構文が少しぎこちないのは、結果の &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; のサイズ制限がコンパイル時に計算できるようにコンビネータが記述されているためです。また、固定された文字のタプルをエンコードする &lt;code&gt;fixed2&lt;/code&gt; プリミティブを明示的にインライン化し、バインドされた計算がコンパイル時に行われるようにします。次の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; のリストをエンコードする場合、 &lt;code&gt;renderString&lt;/code&gt; の最適化された実装は2倍速くなります。</target>
        </trans-unit>
        <trans-unit id="93c66ed4ee1310bccd13dda5d5b0820443482dc4" translate="yes" xml:space="preserve">
          <source>The code should be mostly self-explanatory. The slightly awkward syntax is because the combinators are written such that the size-bound of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; can be computed at compile time. We also explicitly inline the &lt;code&gt;fixed2&lt;/code&gt; primitive, which encodes a fixed tuple of characters, to ensure that the bound computation happens at compile time. When encoding the following list of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, the optimized implementation of &lt;code&gt;renderString&lt;/code&gt; is two times faster.</source>
          <target state="translated">コードはほとんど自明である必要があります。少し厄介な構文は、結果の &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; のサイズ制限がコンパイル時に計算できるようにコンビネータが記述されているためです。また、固定タプルの文字をエンコードする &lt;code&gt;fixed2&lt;/code&gt; プリミティブを明示的にインライン化して、バインドされた計算がコンパイル時に行われるようにします。次の &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; のリストをエンコードする場合、 &lt;code&gt;renderString&lt;/code&gt; の最適化された実装は2倍高速です。</target>
        </trans-unit>
        <trans-unit id="4421b2e89d7c073b3eeabb7b626aa07e05c2b134" translate="yes" xml:space="preserve">
          <source>The combinators &lt;code&gt;&lt;a href=&quot;data-data#v:gmapT&quot;&gt;gmapT&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQ&quot;&gt;gmapQ&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-data#v:gmapM&quot;&gt;gmapM&lt;/a&gt;&lt;/code&gt;, etc are all provided with default definitions in terms of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt;, leaving open the opportunity to provide datatype-specific definitions. (The inclusion of the &lt;code&gt;gmap&lt;/code&gt; combinators as members of class &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; allows the programmer or the compiler to derive specialised, and maybe more efficient code per datatype. &lt;em&gt;Note&lt;/em&gt;: &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is more higher-order than the &lt;code&gt;gmap&lt;/code&gt; combinators. This is subject to ongoing benchmarking experiments. It might turn out that the &lt;code&gt;gmap&lt;/code&gt; combinators will be moved out of the class &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">コンビネータ &lt;code&gt;&lt;a href=&quot;data-data#v:gmapT&quot;&gt;gmapT&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQ&quot;&gt;gmapQ&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-data#v:gmapM&quot;&gt;gmapM&lt;/a&gt;&lt;/code&gt; などは、全ての面でデフォルトの定義が設けられている &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; データ型固有の定義を提供する機会を開いたままに、。 （クラス &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; のメンバーとして &lt;code&gt;gmap&lt;/code&gt; コンビネーターを含めることで、プログラマーまたはコンパイラーは、データ型ごとに特殊化された、おそらくより効率的なコードを導出できます。&lt;em&gt;注&lt;/em&gt;： &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;gmap&lt;/code&gt; コンビネーターよりも高次です。これは、継続的なベンチマーク実験の対象です。これは、ことをなるかもしれない &lt;code&gt;gmap&lt;/code&gt; コンビネータは、クラスの外に移動されます &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 。）&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d6f1f7c8a32c8db29cc4151cc5a6c27c5f31776" translate="yes" xml:space="preserve">
          <source>The combinators for &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;s are implemented such that the size of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; can be computed at compile time.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; のコンビネータは、結果の &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; のサイズをコンパイル時に計算できるように実装されています。</target>
        </trans-unit>
        <trans-unit id="b36fb23ba2c0fd5cf9cc5fbcaa48f3fa3936ed5b" translate="yes" xml:space="preserve">
          <source>The combinators for &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;s are implemented such that the &lt;code&gt;size&lt;/code&gt; of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; is computed at compile time.</source>
          <target state="translated">用コンビネータ &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; Sは、そのような実装されている &lt;code&gt;size&lt;/code&gt; 得られたの &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; は、コンパイル時に計算されます。</target>
        </trans-unit>
        <trans-unit id="2acc0788b34136669ccf2620396da51b7563e2c2" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt; will show a summary of which modules contribute to the top-level scope.</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; &lt;/a&gt;コマンドは、どのモジュールがトップレベルのスコープに貢献しているかの概要を表示します。</target>
        </trans-unit>
        <trans-unit id="5fdeb122c09642094fcfc48bef6bdcdff89e8605" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;#ghci-cmd-:step&quot;&gt;&lt;code&gt;:step expr&lt;/code&gt;&lt;/a&gt; begins the evaluation of ⟨expr⟩ in single-stepping mode. If ⟨expr⟩ is omitted, then it single-steps from the current breakpoint. &lt;a href=&quot;#ghci-cmd-:steplocal&quot;&gt;&lt;code&gt;:steplocal&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:stepmodule&quot;&gt;&lt;code&gt;:stepmodule&lt;/code&gt;&lt;/a&gt; commands work similarly.</source>
          <target state="translated">コマンド&lt;a href=&quot;#ghci-cmd-:step&quot;&gt; &lt;code&gt;:step expr&lt;/code&gt; &lt;/a&gt;は、シングルステップモードで「expr」の評価を開始します。「expr」を省略すると、現在のブレークポイントからシングルステップ実行されます。&lt;a href=&quot;#ghci-cmd-:steplocal&quot;&gt; &lt;code&gt;:steplocal&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#ghci-cmd-:stepmodule&quot;&gt; &lt;code&gt;:stepmodule&lt;/code&gt; &lt;/a&gt;コマンドは同様に機能します。</target>
        </trans-unit>
        <trans-unit id="a632ebd88f50b8ac78cacda34b5408a0be9ab51c" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;:break 2&lt;/code&gt; sets a breakpoint on line 2 of the most recently-loaded module, in this case &lt;code&gt;qsort.hs&lt;/code&gt;. Specifically, it picks the leftmost complete subexpression on that line on which to set the breakpoint, which in this case is the expression &lt;code&gt;(qsort left ++ [a] ++ qsort right)&lt;/code&gt;.</source>
          <target state="translated">コマンド &lt;code&gt;:break 2&lt;/code&gt; は、最後にロードされたモジュール、この場合は &lt;code&gt;qsort.hs&lt;/code&gt; の 2行目にブレークポイントを設定します。具体的には、ブレークポイントを設定する行の左端の完全な部分式 &lt;code&gt;(qsort left ++ [a] ++ qsort right)&lt;/code&gt; この場合は式（qsort left ++ [a] ++ qsort right））を選択します。</target>
        </trans-unit>
        <trans-unit id="e40dd230e05a9e07fe62ec45624d094d383aa421" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;:info!&lt;/code&gt; works in a similar fashion but it removes restriction (b), showing all instances that are in scope and mention ⟨name⟩ in their head.</source>
          <target state="translated">コマンド &lt;code&gt;:info!&lt;/code&gt; 同様の方法で機能しますが、制限（b）を削除し、スコープ内にあるすべてのインスタンスを表示し、「名前」を頭に挙げます。</target>
        </trans-unit>
        <trans-unit id="db3abb134ad672048db99caf88a85888bde3b864" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;fgrep -n END_SAMPLE FOO.hp&lt;/code&gt; finds the end of every complete sample in &lt;code&gt;FOO.hp&lt;/code&gt;, and labels each sample with its ending line number. We then select the line number of the last complete sample using &lt;strong&gt;tail&lt;/strong&gt; and &lt;strong&gt;cut&lt;/strong&gt;. This is used as a parameter to &lt;strong&gt;head&lt;/strong&gt;; the result is as if we deleted the final incomplete sample from &lt;code&gt;FOO.hp&lt;/code&gt;. This results in a properly-formatted .hp file which we feed directly to &lt;strong&gt;hp2ps&lt;/strong&gt;.</source>
          <target state="translated">コマンド &lt;code&gt;fgrep -n END_SAMPLE FOO.hp&lt;/code&gt; 内のすべての完全なサンプルの終わり見つけ &lt;code&gt;FOO.hp&lt;/code&gt; を、そしてその終了行番号で各サンプルにラベルを付けます。次に、&lt;strong&gt;tail&lt;/strong&gt;と&lt;strong&gt;cut&lt;/strong&gt;を使用して、最後の完全なサンプルの行番号を選択します。これは、&lt;strong&gt;headの&lt;/strong&gt;パラメータとして使用されます。結果は、 &lt;code&gt;FOO.hp&lt;/code&gt; から最後の不完全なサンプルを削除した場合と同じです。これにより、適切にフォーマットされた.hpファイルが&lt;strong&gt;生成&lt;/strong&gt;され、&lt;strong&gt;hp2psに&lt;/strong&gt;直接フィードされ&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="270408c21f336615635c1e2a2c6f2941c9ac84d6" translate="yes" xml:space="preserve">
          <source>The command line arguments passed to the program</source>
          <target state="translated">プログラムに渡されるコマンドライン引数</target>
        </trans-unit>
        <trans-unit id="e7e794e0f93c2fa925b60afdb7fbdedb64d80c09" translate="yes" xml:space="preserve">
          <source>The command line arguments passed to the runtime system</source>
          <target state="translated">ランタイムシステムに渡されるコマンドライン引数</target>
        </trans-unit>
        <trans-unit id="77b364d49a3dfa5e15b2ed62d447248ab845ef6f" translate="yes" xml:space="preserve">
          <source>The command to run, which must be in the $PATH, or an absolute or relative path</source>
          <target state="translated">実行するコマンドは $PATH にあるか、絶対パスか相対パスでなければなりません。</target>
        </trans-unit>
        <trans-unit id="a9eb0075b8efba5d950b353dc2ba8dd18856c0b6" translate="yes" xml:space="preserve">
          <source>The command versions of lambda abstraction and application are analogous to the expression versions. In particular, the beta and eta rules describe equivalences of commands. These three features (operators, lambda abstraction and application) are the core of the notation; everything else can be built using them, though the results would be somewhat clumsy. For example, we could simulate &lt;code&gt;do&lt;/code&gt;-notation by defining</source>
          <target state="translated">ラムダ抽象化およびアプリケーションのコマンドバージョンは、式バージョンに類似しています。特に、ベータとイータのルールはコマンドの同等性を記述します。これらの3つの機能（演算子、ラムダ抽象化、およびアプリケーション）は、表記法の中核です。他のものはすべてそれらを使用して構築できますが、結果はやや不格好になります。たとえば、次のように定義することにより、 &lt;code&gt;do&lt;/code&gt; 表記をシミュレートできます。</target>
        </trans-unit>
        <trans-unit id="69ed99fc3cead2f4b29389ab07a3549b66be32cf" translate="yes" xml:space="preserve">
          <source>The command-line arguments passed to the program</source>
          <target state="translated">プログラムに渡されるコマンドライン引数</target>
        </trans-unit>
        <trans-unit id="8a1e2c9e679e0ed25e609bb32dccdb1dffa31a77" translate="yes" xml:space="preserve">
          <source>The comparable symbols for other systems are: &lt;code&gt;__HUGS__&lt;/code&gt; for Hugs, &lt;code&gt;__NHC__&lt;/code&gt; for nhc98, and &lt;code&gt;__HBC__&lt;/code&gt; for hbc).</source>
          <target state="translated">他のシステムのための同等の記号は以下のとおりです。 &lt;code&gt;__HUGS__&lt;/code&gt; 抱擁、用 &lt;code&gt;__NHC__&lt;/code&gt; nhc98ため、および &lt;code&gt;__HBC__&lt;/code&gt; HBCのため）。</target>
        </trans-unit>
        <trans-unit id="b172d1caf74bb5840fcb833db8910b15eee4ccf4" translate="yes" xml:space="preserve">
          <source>The compiler does not overwrite an existing &lt;code&gt;.hi&lt;/code&gt; interface file if the new one is the same as the old one; this is friendly to &lt;strong&gt;make&lt;/strong&gt;. When an interface does change, it is often enlightening to be informed. The &lt;a href=&quot;#ghc-flag--ddump-hi-diffs&quot;&gt;&lt;code&gt;-ddump-hi-diffs&lt;/code&gt;&lt;/a&gt; option will make GHC report the differences between the old and new &lt;code&gt;.hi&lt;/code&gt; files.</source>
          <target state="translated">新しいファイルが古いファイルと同じ場合、コンパイラーは既存の &lt;code&gt;.hi&lt;/code&gt; インターフェースファイルを上書きしません。これは&lt;strong&gt;作り&lt;/strong&gt;やすいです。インターフェースが変更されると、多くの場合、通知を受けることが賢明です。&lt;a href=&quot;#ghc-flag--ddump-hi-diffs&quot;&gt; &lt;code&gt;-ddump-hi-diffs&lt;/code&gt; &lt;/a&gt;オプションでは、GHCは、新旧の間の違いを報告行います &lt;code&gt;.hi&lt;/code&gt; ファイルを。</target>
        </trans-unit>
        <trans-unit id="b50c4e0495b638bc78f832720f50e287f9de7a05" translate="yes" xml:space="preserve">
          <source>The compiler infers that the field is lazy, so it is tagged with &lt;code&gt;'DecidedLazy&lt;/code&gt;. Bear in mind that what the compiler decides may be quite different from what is written in the source. See &lt;code&gt;&lt;a href=&quot;ghc-generics#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; for a more detailed explanation.</source>
          <target state="translated">コンパイラーはフィールドが遅延であると推測するため、 &lt;code&gt;'DecidedLazy&lt;/code&gt; タグが付けられています。コンパイラが決定するものは、ソースに書かれているものとはかなり異なる可能性があることに注意してください。詳細については、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="9774a668aa7877058c555311f9fc25aa40959a13" translate="yes" xml:space="preserve">
          <source>The compiler version can be tested within compiled code with the &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; CPP macro (defined only when &lt;a href=&quot;phases#extension-CPP&quot;&gt;&lt;code&gt;-XCPP&lt;/code&gt;&lt;/a&gt; is used). See &lt;a href=&quot;phases#standard-cpp-macros&quot;&gt;Standard CPP macros&lt;/a&gt; for details.</source>
          <target state="translated">コンパイラー・バージョンは、 &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; CPPマクロ（&lt;a href=&quot;phases#extension-CPP&quot;&gt; &lt;code&gt;-XCPP&lt;/code&gt; &lt;/a&gt;が使用されている場合にのみ定義）を使用して、コンパイル済みコード内でテストできます。詳細については、&lt;a href=&quot;phases#standard-cpp-macros&quot;&gt;標準CPPマクロ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d8fd806e873a214570099da2d9771dbac6f16d96" translate="yes" xml:space="preserve">
          <source>The compiler version can be tested within compiled code with the &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; CPP macro (defined only when &lt;a href=&quot;phases#extension-CPP&quot;&gt;&lt;code&gt;CPP&lt;/code&gt;&lt;/a&gt; is used). See &lt;a href=&quot;phases#standard-cpp-macros&quot;&gt;Standard CPP macros&lt;/a&gt; for details.</source>
          <target state="translated">コンパイラのバージョンは、 &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; CPPマクロ（&lt;a href=&quot;phases#extension-CPP&quot;&gt; &lt;code&gt;CPP&lt;/code&gt; &lt;/a&gt;が使用されている場合にのみ定義）を使用して、コンパイルされたコード内でテストできます。詳細については、&lt;a href=&quot;phases#standard-cpp-macros&quot;&gt;標準CPPマクロ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d31425166e0b9b41d209465f54952b68c26f02ba" translate="yes" xml:space="preserve">
          <source>The compiler will avoid reboxing &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt; by inlining &lt;code&gt;+&lt;/code&gt; on floats, but only when &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">コンパイラーは、フロートに &lt;code&gt;+&lt;/code&gt; をインライン化することにより、 &lt;code&gt;f1&lt;/code&gt; および &lt;code&gt;f2&lt;/code&gt; の再ボックス化を回避しますが、&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;がオンの場合のみです。</target>
        </trans-unit>
        <trans-unit id="a57eab48089d44200f2aa63903639e1a99c72105" translate="yes" xml:space="preserve">
          <source>The compiler will warn here that the deriving clause doesn&amp;rsquo;t specify a strategy. If the warning is enabled, but &lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt; is not enabled, the compiler will suggest turning on the &lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt; extension. This option is not on by default, having to be turned on manually or with &lt;a href=&quot;#ghc-flag--Weverything&quot;&gt;&lt;code&gt;-Weverything&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">コンパイラはここで、派生句が戦略を指定していないことを警告します。警告が有効になっているが、&lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt; &lt;code&gt;DerivingStrategies&lt;/code&gt; &lt;/a&gt;が有効になっていない場合、コンパイラーは&lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt; &lt;code&gt;DerivingStrategies&lt;/code&gt; &lt;/a&gt;拡張機能を有効にすることを提案します。このオプションはデフォルトではオンになっていないため、手動または&lt;a href=&quot;#ghc-flag--Weverything&quot;&gt; &lt;code&gt;-Weverything&lt;/code&gt; &lt;/a&gt;でオンにする必要があります。</target>
        </trans-unit>
        <trans-unit id="364015fc14eeca9fb27fa97b755433aec50ba3bb" translate="yes" xml:space="preserve">
          <source>The compiler will warn when none of &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-Unsafe&quot;&gt;&lt;code&gt;Unsafe&lt;/code&gt;&lt;/a&gt; is specified. This option is off by default.</source>
          <target state="translated">&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#extension-Unsafe&quot;&gt; &lt;code&gt;Unsafe&lt;/code&gt; の&lt;/a&gt;いずれも指定されていない場合、コンパイラは警告を発します。このオプションはデフォルトでオフになっています。</target>
        </trans-unit>
        <trans-unit id="281ed5525515ea0993e70db30ed197e71b26abff" translate="yes" xml:space="preserve">
          <source>The complete user-supplied kind signature specifies the polymorphic kind for &lt;code&gt;T&lt;/code&gt;, and this signature is used for all the calls to &lt;code&gt;T&lt;/code&gt; including the recursive ones. In particular, the recursive use of &lt;code&gt;T&lt;/code&gt; is at kind &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">完全なユーザー指定の種類シグネチャは &lt;code&gt;T&lt;/code&gt; の多態的な種類を指定し、このシグネチャは再帰呼び出しを含む &lt;code&gt;T&lt;/code&gt; のすべての呼び出しに使用されます。特に、 &lt;code&gt;T&lt;/code&gt; の再帰的使用は種類 &lt;code&gt;Type&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f2bfd3d94f53069effc94df0d648f9c72f750ccc" translate="yes" xml:space="preserve">
          <source>The comprehension should typecheck when its desugaring would typecheck, except that (as discussed in &lt;a href=&quot;#generalised-list-comprehensions&quot;&gt;Generalised (SQL-like) List Comprehensions&lt;/a&gt;) in the &amp;ldquo;then &lt;code&gt;f&lt;/code&gt;&amp;rdquo; and &amp;ldquo;then group using &lt;code&gt;f&lt;/code&gt;&amp;rdquo; clauses, when the &amp;ldquo;by &lt;code&gt;b&lt;/code&gt;&amp;rdquo; qualifier is omitted, argument &lt;code&gt;f&lt;/code&gt; should have a polymorphic type. In particular, &amp;ldquo;then &lt;code&gt;Data.List.sort&lt;/code&gt;&amp;rdquo; and &amp;ldquo;then group using &lt;code&gt;Data.List.group&lt;/code&gt;&amp;rdquo; are insufficiently polymorphic.</source>
          <target state="translated">その脱糖はです。TypeCheckなるときに理解された（で説明したように除いて、です。TypeCheckなければならない&lt;a href=&quot;#generalised-list-comprehensions&quot;&gt;一般化（SQLのような）リスト内包&lt;/a&gt;）「次ににおける &lt;code&gt;f&lt;/code&gt; 」と「使用し、グループ &lt;code&gt;f&lt;/code&gt; は」によって句、「 &lt;code&gt;b&lt;/code&gt; 」修飾子が省略されています引数 &lt;code&gt;f&lt;/code&gt; は多相型でなければなりません。特に、「then &lt;code&gt;Data.List.sort&lt;/code&gt; 」と「then group using &lt;code&gt;Data.List.group&lt;/code&gt; 」は、多態性が不十分です。</target>
        </trans-unit>
        <trans-unit id="e59db8b8873fb6251bff5cd6dfad77bf9b5938cd" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; is identical to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;, except that it works only on &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">計算 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; は同じです &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; それは上でのみ動作することを除いて、 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cebda4e55c3afba7a9d7719124e3ada63e52bb27" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;prelude#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function appends the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">計算 &lt;code&gt;&lt;a href=&quot;prelude#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;file str&lt;/code&gt; 関数は、文字列 &lt;code&gt;str&lt;/code&gt; をファイル &lt;code&gt;file&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="46965f614145fd2e0bb961350e8543a37e0dd3ca" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;prelude#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function writes the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">計算 &lt;code&gt;&lt;a href=&quot;prelude#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;file str&lt;/code&gt; 関数は、文字列の書き込み &lt;code&gt;str&lt;/code&gt; ファイルに、 &lt;code&gt;file&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a4547aaf52f671ee4d0ac2c8d5630bfc87a6e62" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-cmd#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; runs the operating system command &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; in such a way that it receives as arguments the &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; strings exactly as given, with no funny escaping or shell meta-syntax expansion. It will therefore behave more portably between operating systems than &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">計算 &lt;code&gt;&lt;a href=&quot;system-cmd#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; は、指定されたとおりに &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; 文字列を引数として受け取るようにオペレーティングシステムコマンド &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; を実行します。面白いエスケープやシェルメタ構文の拡張はありません。したがって、 &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; よりもオペレーティングシステム間での移植性が高くなります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a9a90ff37849eb4211f81461b5303f42712fea0c" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exitfail&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;, where &lt;em&gt;exitfail&lt;/em&gt; is implementation-dependent.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; の計算は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt; &lt;em&gt; exitfail &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; と&lt;em&gt;同じ&lt;/em&gt;です&lt;em&gt;。exitfail&lt;/em&gt;は実装に依存します。</target>
        </trans-unit>
        <trans-unit id="36e8bf647c12299f893bf95551889fc682fcb895" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exitfail&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;, where &lt;em&gt;exitfail&lt;/em&gt; is implementation-dependent.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; の計算は、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt; &lt;em&gt; exitfail &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; と&lt;em&gt;同等&lt;/em&gt;です&lt;em&gt;。exitfail&lt;/em&gt;は実装に依存します。</target>
        </trans-unit>
        <trans-unit id="fc29dbc900c1c24c106776b04df9bca05e5cfe6e" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exitfail&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;, where &lt;em&gt;exitfail&lt;/em&gt; is implementation-dependent.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; の計算は、 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt; &lt;em&gt; exitfail &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; と&lt;em&gt;同じ&lt;/em&gt;です&lt;em&gt;。exitfail&lt;/em&gt;は実装に依存します。</target>
        </trans-unit>
        <trans-unit id="fb6d36ed658ece003695ded60aa84d344703fa74" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-exit#v:exitSuccess&quot;&gt;exitSuccess&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt;, It terminates the program successfully.</source>
          <target state="translated">計算 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitSuccess&quot;&gt;exitSuccess&lt;/a&gt;&lt;/code&gt; は同等です &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt; は、それはプログラムを正常に終了します。</target>
        </trans-unit>
        <trans-unit id="a4d04e67ce9ab76c0bbbdea2ad0f01cd7fcbeeb5" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-io#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function appends the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">計算 &lt;code&gt;&lt;a href=&quot;system-io#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;file str&lt;/code&gt; 関数は、文字列 &lt;code&gt;str&lt;/code&gt; をファイル &lt;code&gt;file&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="18d116851ac5689419eab11fff58738d4aba225b" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-io#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; is identical to &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;, except that it works only on &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">計算 &lt;code&gt;&lt;a href=&quot;system-io#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; は同じです &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; それは上でのみ動作することを除いて、 &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46ebfbedadd3b348e49908c00c7a136ae0a3b598" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-io#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function writes the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">計算 &lt;code&gt;&lt;a href=&quot;system-io#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;file str&lt;/code&gt; 関数は、文字列の書き込み &lt;code&gt;str&lt;/code&gt; ファイルに、 &lt;code&gt;file&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="beccc8e7666a74c9241e66c916390d713f7e9a28" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-process#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; runs the operating system command &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; in such a way that it receives as arguments the &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; strings exactly as given, with no funny escaping or shell meta-syntax expansion. It will therefore behave more portably between operating systems than &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">計算 &lt;code&gt;&lt;a href=&quot;system-process#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; は、指定されたとおりに &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; 文字列を引数として受け取るようにオペレーティングシステムコマンド &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; を実行します。面白いエスケープやシェルメタ構文の拡張はありません。したがって、 &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; よりもオペレーティングシステム間での移植性が高くなります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5f1a05335883c13dae3be1b4a36833b306a5efd1" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To ensure that the computation is performed only once, use &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">計算は、異なるスレッドによって、場合によっては同時に、複数回実行されることがあります。計算が1回だけ実行されるようにするには、代わりに &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="44b39b2d94fcf4d161bbbadc2ba27b97f45eae93" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To ensure that the computation is performed only once, use &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">計算は、異なるスレッドによって、場合によっては同時に、複数回実行されることがあります。計算が1回だけ実行されるようにするには、代わりに &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="add1c55634d2623f9699ebad8b5515dd2d17e5c6" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To prevent this, use &lt;code&gt;&lt;a href=&quot;control-monad-st-unsafe#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">計算は、異なるスレッドによって、場合によっては同時に、複数回実行されることがあります。これを防ぐには、代わりに &lt;code&gt;&lt;a href=&quot;control-monad-st-unsafe#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="07d17cfabe3f3fcfca85238e3259375c3de9c784" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To prevent this, use &lt;code&gt;&lt;a href=&quot;ghc-st#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">計算は、異なるスレッドによって、場合によっては同時に、複数回実行されることがあります。これを防ぐには、代わりに &lt;code&gt;&lt;a href=&quot;ghc-st#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="52f9695a125810fcb1729c58e4b509090979268c" translate="yes" xml:space="preserve">
          <source>The computation to run</source>
          <target state="translated">実行する計算</target>
        </trans-unit>
        <trans-unit id="7849b8b63ccfaa0ec4dad86a18080d47939b33fc" translate="yes" xml:space="preserve">
          <source>The concatenation of all the elements of a container of lists.</source>
          <target state="translated">リストのコンテナのすべての要素の連結。</target>
        </trans-unit>
        <trans-unit id="511dfe8f476504df65281a958ed6b2922f8e44b9" translate="yes" xml:space="preserve">
          <source>The concurrency extension for Haskell is described in the paper &lt;em&gt;Concurrent Haskell&lt;/em&gt;&lt;a href=&quot;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&lt;/a&gt;.</source>
          <target state="translated">Haskellの同時実行拡張機能は、&lt;em&gt;Concurrent Haskell&lt;/em&gt;のペーパー&lt;a href=&quot;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gzで&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="00393330d59cb21f77b62b7a951195b4749b08f5" translate="yes" xml:space="preserve">
          <source>The conjugate of a complex number.</source>
          <target state="translated">複素数の共役。</target>
        </trans-unit>
        <trans-unit id="7e61d83010032d16fcd6d96bc1ee67e74abc2ee7" translate="yes" xml:space="preserve">
          <source>The connected components of a graph. Two vertices are connected if there is a path between them, traversing edges in either direction.</source>
          <target state="translated">グラフの連結された構成要素。2つの頂点は、それらの間にパスがあり、どちらかの方向にエッジを横断している場合、接続されています。</target>
        </trans-unit>
        <trans-unit id="b5b6ceffe39d0d5eedc736955541b7ffa6430ede" translate="yes" xml:space="preserve">
          <source>The cons constructor (e.g &lt;code&gt;3:4:[]&lt;/code&gt;)</source>
          <target state="translated">短所コンストラクター（例 &lt;code&gt;3:4:[]&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="8ba3b2a290b55dc2fc0d0d6af5a22e45514ed39e" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">定数 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; には、有効なメモリロケーションに関連付けられていない &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; の識別値が含まれています。</target>
        </trans-unit>
        <trans-unit id="28d23ff9245e92f331af466af03ff314f5479be2" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">定数 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; には、有効なメモリ位置に関連付けられていない &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; の識別値が含まれています。</target>
        </trans-unit>
        <trans-unit id="9836a72bb97f8856c19c64a657d43deda4d232f2" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">定数 &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; には、有効なメモリロケーションに関連付けられていない &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; の識別値が含まれています。</target>
        </trans-unit>
        <trans-unit id="f76a0e137f54f18c3f7ac1708ea489f83a12cf45" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">定数 &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; には、有効なメモリ位置に関連付けられていない &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; の識別値が含まれています。</target>
        </trans-unit>
        <trans-unit id="86d0acfb8c600d07e3b3575390f9c70049148847" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">定数 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; には、有効なメモリ位置に関連付けられていない &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; の識別値が含まれています。</target>
        </trans-unit>
        <trans-unit id="aee9b6f259cc959b36e11590eea5cb4db85f0c33" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;system-win32-types#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">定数 &lt;code&gt;&lt;a href=&quot;system-win32-types#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; には、有効なメモリ位置に関連付けられていない &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; の識別値が含まれています。</target>
        </trans-unit>
        <trans-unit id="bde3669019f674519abd41b72eceb3038215dc5e" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;system-win32-types#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">定数 &lt;code&gt;&lt;a href=&quot;system-win32-types#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; には、有効なメモリ位置に関連付けられていない &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; の識別値が含まれています。</target>
        </trans-unit>
        <trans-unit id="799dc66320c38ca69a9441401db6bffcbf9eb360" translate="yes" xml:space="preserve">
          <source>The constant functor.</source>
          <target state="translated">定数ファンクタ。</target>
        </trans-unit>
        <trans-unit id="15ca88cd220e51ba407b106275a1029cb4b766e9" translate="yes" xml:space="preserve">
          <source>The constraint &lt;code&gt;Coercible t1 t2&lt;/code&gt; is similar to &lt;code&gt;t1 ~ t2&lt;/code&gt;, but denotes representational equality between &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt; in the sense of Roles (&lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;). It is exported by &lt;a href=&quot;../libraries/base-4.13.0.0/data-coerce&quot;&gt;Data.Coerce&lt;/a&gt;, which also contains the documentation. More details and discussion can be found in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf&quot;&gt;&amp;ldquo;Safe Coercions&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">制約 &lt;code&gt;Coercible t1 t2&lt;/code&gt; と同様である &lt;code&gt;t1 ~ t2&lt;/code&gt; 、しかし間表象平等表し &lt;code&gt;t1&lt;/code&gt; と &lt;code&gt;t2&lt;/code&gt; の役割（の意味での&lt;a href=&quot;#roles&quot;&gt;役割&lt;/a&gt;）。これは、ドキュメントも含む&lt;a href=&quot;../libraries/base-4.13.0.0/data-coerce&quot;&gt;Data.Coerce&lt;/a&gt;によってエクスポートされます。詳細と議論については、&lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf&quot;&gt;「Safe Coercions」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="cda43f4b9e044bd999f3ffb0d1982eddf1b3ad96" translate="yes" xml:space="preserve">
          <source>The constraint &lt;code&gt;Coercible t1 t2&lt;/code&gt; is similar to &lt;code&gt;t1 ~ t2&lt;/code&gt;, but denotes representational equality between &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt; in the sense of Roles (&lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;). It is exported by &lt;a href=&quot;../libraries/base-4.14.1.0/data-coerce&quot;&gt;Data.Coerce&lt;/a&gt;, which also contains the documentation. More details and discussion can be found in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf&quot;&gt;&amp;ldquo;Safe Coercions&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">制約 &lt;code&gt;Coercible t1 t2&lt;/code&gt; と同様である &lt;code&gt;t1 ~ t2&lt;/code&gt; 、しかし間表象平等表し &lt;code&gt;t1&lt;/code&gt; と &lt;code&gt;t2&lt;/code&gt; の役割（の意味での&lt;a href=&quot;#roles&quot;&gt;役割&lt;/a&gt;）。これは&lt;a href=&quot;../libraries/base-4.14.1.0/data-coerce&quot;&gt;Data.Coerce&lt;/a&gt;によってエクスポートされ、ドキュメントも含まれています。詳細と議論は、論文&lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf&quot;&gt;「SafeCoercions」にあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="9b45d0e4831d974f0b76095cef9bc4b87f2ec6bb" translate="yes" xml:space="preserve">
          <source>The constraint has fewer constructors and variables (taken together and counting repetitions) than the head</source>
          <target state="translated">制約は、ヘッドよりも少ないコンストラクタと変数(まとめて数え、繰り返しをカウントする)を持ちます。</target>
        </trans-unit>
        <trans-unit id="a50d755f429fad42bcff479620bc13360a0c4b46" translate="yes" xml:space="preserve">
          <source>The constraint mentions at least one type variable. So this is allowed:</source>
          <target state="translated">制約は少なくとも1つの型変数に言及しています。なので、これは許可されています。</target>
        </trans-unit>
        <trans-unit id="ce649c6fe844bb02501d53bdc8fcdcf10a388961" translate="yes" xml:space="preserve">
          <source>The constraint mentions no type functions. A type function application can in principle expand to a type of arbitrary size, and so are rejected out of hand</source>
          <target state="translated">制約は型関数について言及していません。型関数アプリケーションは,原則として,任意のサイズの型に拡張することができます。</target>
        </trans-unit>
        <trans-unit id="e1443e2e18615f60be07422db9598a6ab2679217" translate="yes" xml:space="preserve">
          <source>The constraints: &lt;code&gt;(C1, C2, ..)&lt;/code&gt;</source>
          <target state="translated">制約： &lt;code&gt;(C1, C2, ..)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="112775bf1168cc3582de7a46d153e201b0ce10f8" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt;&lt;code&gt;comp&lt;/code&gt; exposes IO errors which occur within a computation, and which are not fully handled.</source>
          <target state="translated">構成 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt; &lt;code&gt;comp&lt;/code&gt; は、計算内で発生し、完全には処理されないIOエラーを公開します。</target>
        </trans-unit>
        <trans-unit id="f2cbf6e1527ac15029debb90371be54661016768" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;&lt;a href=&quot;system-io-error#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt;&lt;code&gt;comp&lt;/code&gt; exposes IO errors which occur within a computation, and which are not fully handled.</source>
          <target state="translated">構成 &lt;code&gt;&lt;a href=&quot;system-io-error#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt; &lt;code&gt;comp&lt;/code&gt; は、計算内で発生し、完全には処理されないIOエラーを公開します。</target>
        </trans-unit>
        <trans-unit id="d9cb341bdfdb67d6c8abafd06a4a86c8917f60b5" translate="yes" xml:space="preserve">
          <source>The constructors for &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; can roughly be divided up into two categories: those for constructors with &quot;vanilla&quot; syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt;), and those for constructors with GADT syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt;). The &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; constructor, which quantifies additional type variables and class contexts, can surround either variety of constructor. However, the type variables that it quantifies are different depending on what constructor syntax is used:</source>
          <target state="translated">コンストラクタ &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; 「バニラ」構文（とコンストラクタのもの：大まかに二つのカテゴリーに分けることができる &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt; 、及び &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt; ）、及びGADT構文（とコンストラクタのもの &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt; ）。 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; の追加型変数やクラスのコンテキストを定量化コンストラクタは、コンストラクタのいずれかの様々なを囲むことができます。ただし、数値化される型変数は、使用されるコンストラクター構文によって異なります。</target>
        </trans-unit>
        <trans-unit id="96dfdfe1a048f1f49896be9e99d5931a975888f5" translate="yes" xml:space="preserve">
          <source>The constructors for &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; can roughly be divided up into two categories: those for constructors with &quot;vanilla&quot; syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt;), and those for constructors with GADT syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt;). The &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; constructor, which quantifies additional type variables and class contexts, can surround either variety of constructor. However, the type variables that it quantifies are different depending on what constructor syntax is used:</source>
          <target state="translated">コンストラクタ &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; 「バニラ」構文（とコンストラクタのもの：大まかに二つのカテゴリーに分けることができる &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt; 、及び &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt; ）、及びGADT構文（とコンストラクタのもの &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt; ）。 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; の追加型変数やクラスのコンテキストを定量化コンストラクタは、コンストラクタのいずれかの様々なを囲むことができます。ただし、数値化される型変数は、使用されるコンストラクター構文によって異なります。</target>
        </trans-unit>
        <trans-unit id="d2ef5f16504fcf65ef460021616315706e1e4d2a" translate="yes" xml:space="preserve">
          <source>The constructors have rank-2 types:</source>
          <target state="translated">コンストラクタにはランク2の型があります。</target>
        </trans-unit>
        <trans-unit id="f9e51adba83704f5afe34590e66e2249e5965154" translate="yes" xml:space="preserve">
          <source>The contents of &lt;code&gt;OPTIONS_GHC&lt;/code&gt; are appended to the command-line options, so options given in the source file override those given on the command-line.</source>
          <target state="translated">&lt;code&gt;OPTIONS_GHC&lt;/code&gt; の内容はコマンドラインオプションに追加されるため、ソースファイルで指定されたオプションは、コマンドラインで指定されたオプションをオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="dff9227ff63668c69518bca492a298e49c135a62" translate="yes" xml:space="preserve">
          <source>The contents of this module is liable to change, or disappear entirely. Please &lt;a href=&quot;https://github.com/haskell/time/issues/new&quot;&gt;let me know&lt;/a&gt; if you depend on anything here.</source>
          <target state="translated">このモジュールの内容は変更されるか、完全に消える傾向があります。ここで何かに依存し&lt;a href=&quot;https://github.com/haskell/time/issues/new&quot;&gt;ている&lt;/a&gt;場合はお知らせください。</target>
        </trans-unit>
        <trans-unit id="8a40246a3e18d1d7e41c15d6857dbf0b4d63fa72" translate="yes" xml:space="preserve">
          <source>The contents of this module may change &lt;strong&gt;in any way whatsoever&lt;/strong&gt; and &lt;strong&gt;without any warning&lt;/strong&gt; between minor versions of this package.</source>
          <target state="translated">このモジュールの内容は、このパッケージのマイナーバージョン間&lt;strong&gt;では、いかなる方法でも&lt;/strong&gt;、&lt;strong&gt;警告なしに&lt;/strong&gt;変更さ&lt;strong&gt;れる&lt;/strong&gt;可能性があります。</target>
        </trans-unit>
        <trans-unit id="bf37f21b6a3daad2c6c95d66502066032ad944e9" translate="yes" xml:space="preserve">
          <source>The continuation monad transformer. Can be used to add continuation handling to any type constructor: the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instance and most of the operations do not require &lt;code&gt;m&lt;/code&gt; to be a monad.</source>
          <target state="translated">継続モナド変換子。任意の型コンストラクタに継続処理を追加するために使用できます。 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; インスタンスとほとんどの操作では、 &lt;code&gt;m&lt;/code&gt; がモナドである必要はありません。</target>
        </trans-unit>
        <trans-unit id="30545a4e8f9d1b896fc755171a6a74c0b349be13" translate="yes" xml:space="preserve">
          <source>The continuation monad transformer. Can be used to add continuation handling to any type constructor: the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instance and most of the operations do not require &lt;code&gt;m&lt;/code&gt; to be a monad.</source>
          <target state="translated">継続モナド変換子。任意の型コンストラクターに継続処理を追加するために使用できます。 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; インスタンスとほとんどの操作では、 &lt;code&gt;m&lt;/code&gt; がモナドである必要はありません。</target>
        </trans-unit>
        <trans-unit id="f75193e312873c254935fbb8e4b2cdc1397df81b" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;code&gt;makeAbsolute&lt;/code&gt; function can be found in &lt;code&gt;System.Directory&lt;/code&gt;.</source>
          <target state="translated">対応する &lt;code&gt;makeAbsolute&lt;/code&gt; 関数は &lt;code&gt;System.Directory&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="fbffcb96186edf6acc0b855b93198f4a5cdf1151" translate="yes" xml:space="preserve">
          <source>The corresponding translation for an IO-typed &lt;code&gt;e&lt;/code&gt; is</source>
          <target state="translated">IOタイプの &lt;code&gt;e&lt;/code&gt; に対応する変換は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="86d8b09707b93cf768c10a7d141f2453f73455d0" translate="yes" xml:space="preserve">
          <source>The costs of all CAFs in a module are usually attributed to one &amp;ldquo;big&amp;rdquo; CAF cost-centre. With this option, all CAFs get their own cost-centre. An &amp;ldquo;if all else fails&amp;rdquo; option&amp;hellip;</source>
          <target state="translated">モジュール内のすべてのCAFのコストは、通常、1つの「大きな」CAFコストセンターに起因します。このオプションを使用すると、すべてのCAFが独自のコスト中心を取得します。「他のすべてが失敗した場合」オプション&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="7cf65e46a7de9baa89f7b3eb6db073c4649dd328" translate="yes" xml:space="preserve">
          <source>The cumulative allocations of the program in bytes.</source>
          <target state="translated">プログラムの累積割り当て量をバイト単位で表示します。</target>
        </trans-unit>
        <trans-unit id="7a3b930a34c98c0e41a7bef5730a3bbf42841f7f" translate="yes" xml:space="preserve">
          <source>The current implementation of the &lt;code&gt;OverloadedLists&lt;/code&gt; extension can be improved by handling the lists that are only populated with literals in a special way. More specifically, the compiler could allocate such lists statically using a compact representation and allow &lt;code&gt;IsList&lt;/code&gt; instances to take advantage of the compact representation. Equipped with this capability the &lt;code&gt;OverloadedLists&lt;/code&gt; extension will be in a good position to subsume the &lt;code&gt;OverloadedStrings&lt;/code&gt; extension (currently, as a special case, string literals benefit from statically allocated compact representation).</source>
          <target state="translated">&lt;code&gt;OverloadedLists&lt;/code&gt; 拡張機能の現在の実装は、リテラルのみが設定されたリストを特別な方法で処理することで改善できます。より具体的には、コンパイラーはコンパクトな表現を使用してそのようなリストを静的に割り当て、 &lt;code&gt;IsList&lt;/code&gt; インスタンスがコンパクトな表現を利用できるようにします。この能力が装備 &lt;code&gt;OverloadedLists&lt;/code&gt; 拡張が包摂するための良い位置になり &lt;code&gt;OverloadedStrings&lt;/code&gt; の拡張を（現在、特別な場合として、文字列リテラルは、静的に割り当てられたコンパクトな表現から利益を得ます）。</target>
        </trans-unit>
        <trans-unit id="1ad91c37c3debcd3611b7e9c0f27ffd87d2d02eb" translate="yes" xml:space="preserve">
          <source>The current notion of when two view pattern expressions are &amp;ldquo;the same&amp;rdquo; is very restricted: it is not even full syntactic equality. However, it does include variables, literals, applications, and tuples; e.g., two instances of &lt;code&gt;view (&quot;hi&quot;, &quot;there&quot;)&lt;/code&gt; will be collected. However, the current implementation does not compare up to alpha-equivalence, so two instances of &lt;code&gt;(x, view x -&amp;gt; y)&lt;/code&gt; will not be coalesced.</source>
          <target state="translated">2つのビューパターン式が「同じ」であるという現在の概念は非常に制限されています。完全な構文上の同等性でさえありません。ただし、変数、リテラル、アプリケーション、およびタプルは含まれます。たとえば、 &lt;code&gt;view (&quot;hi&quot;, &quot;there&quot;)&lt;/code&gt; 2つのインスタンス（ &quot;hi&quot;、 &quot;there&quot;）が収集されます。ただし、現在の実装ではアルファ相当までは比較されないため、 &lt;code&gt;(x, view x -&amp;gt; y)&lt;/code&gt; 2つのインスタンスは結合されません。</target>
        </trans-unit>
        <trans-unit id="2a1a29ae3433386a16c919320319cfdd85da4c46" translate="yes" xml:space="preserve">
          <source>The current status of a thread</source>
          <target state="translated">スレッドの現在の状態</target>
        </trans-unit>
        <trans-unit id="82c826fe4c2ec0dd5e2b6732f42c3a1009fa7e05" translate="yes" xml:space="preserve">
          <source>The current thread's stack exceeded its limit. Since an exception has been raised, the thread's stack will certainly be below its limit again, but the programmer should take remedial action immediately.</source>
          <target state="translated">現在のスレッドのスタックが限界を超えました。例外が発生したので、スレッドのスタックは確実に再び限界を下回ることになりますが、プログラマはすぐに改善策をとるべきです。</target>
        </trans-unit>
        <trans-unit id="ed3b026bad78c443d4533994012a8c4a2846cb3c" translate="yes" xml:space="preserve">
          <source>The current value of the &lt;code&gt;-N&lt;/code&gt; option is available to the Haskell program via &lt;code&gt;Control.Concurrent.getNumCapabilities&lt;/code&gt;, and it may be changed while the program is running by calling &lt;code&gt;Control.Concurrent.setNumCapabilities&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-N&lt;/code&gt; オプションの現在の値は、Haskellプログラムで &lt;code&gt;Control.Concurrent.getNumCapabilities&lt;/code&gt; を介して使用できます。また、プログラムの実行中に &lt;code&gt;Control.Concurrent.setNumCapabilities&lt;/code&gt; を呼び出すことで変更できます。</target>
        </trans-unit>
        <trans-unit id="9ec8f77a94455e151e4c1a9e7ec7c517542a0b66" translate="yes" xml:space="preserve">
          <source>The cut-down Haskell lexer, used by Text.Read</source>
          <target state="translated">Text.Read で使用されるカットダウンされた Haskell レキサー</target>
        </trans-unit>
        <trans-unit id="00bd3d9662d83ac9ec53f0ae935356d4eabc4566" translate="yes" xml:space="preserve">
          <source>The data family &lt;code&gt;URec&lt;/code&gt; is provided to enable generic programming over datatypes with certain unlifted arguments. There are six instances corresponding to common unlifted types:</source>
          <target state="translated">データファミリー &lt;code&gt;URec&lt;/code&gt; は、特定のリフトされていない引数を持つデータ型に対する一般的なプログラミングを可能にするために提供されています。一般的なリフトされていないタイプに対応する6つのインスタンスがあります。</target>
        </trans-unit>
        <trans-unit id="7cc312cbbdd186a59028317a6d6a5545651161f0" translate="yes" xml:space="preserve">
          <source>The data or type family instance for an associated type must follow the rule that the type indexes corresponding to class parameters must have precisely the same as type given in the instance head. For example:</source>
          <target state="translated">関連する型のデータまたは型ファミリのインスタンスは、クラス・パラメータに対応する型インデックスが、インスタンス・ヘッドで指定された型と正確に同じでなければならないというルールに従わなければなりません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="5c9753438fba7e9bfbfa96374f6632d59b89893a" translate="yes" xml:space="preserve">
          <source>The data type &lt;code&gt;Foo&lt;/code&gt; has two constructors with types:</source>
          <target state="translated">データ型 &lt;code&gt;Foo&lt;/code&gt; には、型を持つ2つのコンストラクタがあります。</target>
        </trans-unit>
        <trans-unit id="e622f9e9a73471a6364b9efb8251bd756d0f5650" translate="yes" xml:space="preserve">
          <source>The data type invariant for lazy &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;: Every &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; or consists of non-null &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s. All functions must preserve this, and the QC properties must check this.</source>
          <target state="translated">遅延 &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; のデータ型不変：すべての &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; か、null以外の &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 構成されています。すべての関数はこれを保持する必要があり、QCプロパティはこれをチェックする必要があります。</target>
        </trans-unit>
        <trans-unit id="5d0441bbee470c2143c8f36a2d1679d26b7e70ba" translate="yes" xml:space="preserve">
          <source>The data type invariant: Every ByteString is either &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; or consists of non-null &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. All functions must preserve this, and the QC properties must check this.</source>
          <target state="translated">データ型不変：すべてのByteStringは &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; か、null &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; のByteStringで構成されます。すべての関数はこれを保持する必要があり、QCプロパティはこれをチェックする必要があります。</target>
        </trans-unit>
        <trans-unit id="7d85f04588f07b22aadb87552b730e4cf6174d81" translate="yes" xml:space="preserve">
          <source>The data types and monadic constructor functions for Template Haskell are in the library &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt;.</source>
          <target state="translated">テンプレートHaskellのデータ型とモナディックコンストラクター関数は、 &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt; ライブラリにあります。</target>
        </trans-unit>
        <trans-unit id="65cb9fa712c4ef1743587a031048fc3377115bf6" translate="yes" xml:space="preserve">
          <source>The datatype below derives the &lt;code&gt;Eq&lt;/code&gt; typeclass, but doesn&amp;rsquo;t specify a strategy. When &lt;a href=&quot;#ghc-flag--Wmissing-deriving-strategies&quot;&gt;&lt;code&gt;-Wmissing-deriving-strategies&lt;/code&gt;&lt;/a&gt; is enabled, the compiler will emit a warning about this.</source>
          <target state="translated">以下のデータ型は &lt;code&gt;Eq&lt;/code&gt; タイプクラスを派生させていますが、戦略を指定していません。とき&lt;a href=&quot;#ghc-flag--Wmissing-deriving-strategies&quot;&gt; &lt;code&gt;-Wmissing-deriving-strategies&lt;/code&gt; &lt;/a&gt;有効になっていると、コンパイラはこれについて警告を発します。</target>
        </trans-unit>
        <trans-unit id="09ea5a667a11159497b7db70c8ac2393a6a6a569" translate="yes" xml:space="preserve">
          <source>The day of the epoch of &lt;code&gt;&lt;a href=&quot;data-time-clock-system#t:SystemTime&quot;&gt;SystemTime&lt;/a&gt;&lt;/code&gt;, 1970-01-01</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-clock-system#t:SystemTime&quot;&gt;SystemTime&lt;/a&gt;&lt;/code&gt; のエポックの日、1970-01-01</target>
        </trans-unit>
        <trans-unit id="425505b50ca94bcb223c9489d59b624f0fd02138" translate="yes" xml:space="preserve">
          <source>The debugger provides the following:</source>
          <target state="translated">デバッガは以下の機能を提供します。</target>
        </trans-unit>
        <trans-unit id="d008597f45a1f7e417f2daa3afa26ed473de0e47" translate="yes" xml:space="preserve">
          <source>The debugging options &lt;code&gt;-Dx&lt;/code&gt; also generate events which are logged using the tracing framework. By default those events are dumped as text to stdout (&lt;code&gt;-Dx&lt;/code&gt; implies &lt;code&gt;-v&lt;/code&gt;), but they may instead be stored in the binary eventlog file by using the &lt;code&gt;-l&lt;/code&gt; option.</source>
          <target state="translated">デバッグオプション &lt;code&gt;-Dx&lt;/code&gt; は、トレースフレームワークを使用してログに記録されるイベントも生成します。デフォルトでは、これらのイベントはテキストとしてstdoutにダンプされます（ &lt;code&gt;-Dx&lt;/code&gt; は &lt;code&gt;-v&lt;/code&gt; を意味します）が、 &lt;code&gt;-l&lt;/code&gt; オプションを使用してバイナリイベントログファイルに保存することもできます。</target>
        </trans-unit>
        <trans-unit id="8dbf33fb940a3d9f2a5b57f121f6732a25396c40" translate="yes" xml:space="preserve">
          <source>The declaration</source>
          <target state="translated">宣言</target>
        </trans-unit>
        <trans-unit id="61598f72e2c92204906e453b4899d9c4f265e7a4" translate="yes" xml:space="preserve">
          <source>The declaration for &lt;code&gt;HCons&lt;/code&gt; also requires &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt; because of infix type operator &lt;code&gt;(':)&lt;/code&gt;</source>
          <target state="translated">中置型演算子 &lt;code&gt;(':)&lt;/code&gt; のため、 &lt;code&gt;HCons&lt;/code&gt; の宣言にはTypeOperatorsも必要&lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e4404a7232bfc86c4b3054c2503dd6ddca4de51d" translate="yes" xml:space="preserve">
          <source>The declaration group containing &lt;code&gt;D&lt;/code&gt; is terminated by the empty top-level declaration splice &lt;code&gt;$(return [])&lt;/code&gt; (recall, &lt;code&gt;Q&lt;/code&gt; is a Monad, so we may simply &lt;code&gt;return&lt;/code&gt; the empty list of declarations).</source>
          <target state="translated">&lt;code&gt;D&lt;/code&gt; を含む宣言グループは、空のトップレベルの宣言スプライス &lt;code&gt;$(return [])&lt;/code&gt; で終了します（ &lt;code&gt;Q&lt;/code&gt; はモナドなので、空の宣言リストを &lt;code&gt;return&lt;/code&gt; だけです）。</target>
        </trans-unit>
        <trans-unit id="c3ea4ce42435200f8c7550076521012105fc2dd4" translate="yes" xml:space="preserve">
          <source>The declarations above are accepted. However, if we add &lt;code&gt;MkOther :: T Int&lt;/code&gt;, we get an error that the equality constraint is not satisfied; &lt;code&gt;Int&lt;/code&gt; is not a type literal. Note that explicitly quantifying with &lt;code&gt;forall a&lt;/code&gt; is necessary in order for &lt;code&gt;T&lt;/code&gt; to typecheck (see &lt;a href=&quot;#complete-kind-signatures&quot;&gt;Complete user-supplied kind signatures and polymorphic recursion&lt;/a&gt;).</source>
          <target state="translated">上記の宣言は受け入れられます。ただし、 &lt;code&gt;MkOther :: T Int&lt;/code&gt; を追加すると、等式制約が満たされていないというエラーが発生します。 &lt;code&gt;Int&lt;/code&gt; は型リテラルではありません。 &lt;code&gt;T&lt;/code&gt; が&lt;a href=&quot;#complete-kind-signatures&quot;&gt;タイプ&lt;/a&gt;チェックを行うには、 &lt;code&gt;forall a&lt;/code&gt; を使用して明示的に定量化する必要があることに注意してください（完全なユーザー指定の種類の署名と多態性の再帰を参照）。</target>
        </trans-unit>
        <trans-unit id="4f3eb1e20a19137970a20b350de0e993090c5f42" translate="yes" xml:space="preserve">
          <source>The declarations and types from signatures of dependencies that will be merged in are not in scope when type checking an &lt;code&gt;hsig&lt;/code&gt; file. To refer to any such type, you must declare it yourself:</source>
          <target state="translated">マージされる依存関係のシグネチャからの宣言と型は、 &lt;code&gt;hsig&lt;/code&gt; ファイルの型チェック時にスコープに含まれません。そのような型を参照するには、自分で宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="28bc248b719a26880d510c50487bc9904247476f" translate="yes" xml:space="preserve">
          <source>The decoder has consumed the available input and needs more to continue. Provide &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; if more input is available and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; otherwise, and you will get a new &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">デコーダーは使用可能な入力を消費したため、続行するにはさらに多くのものが必要です。提供 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; より多くの入力が可能とされた場合に &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; そうでないと、あなたが新しい取得する &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17837e6c81e48bb3e926bbb5320107b945f00a06" translate="yes" xml:space="preserve">
          <source>The decoder has consumed the available input and needs more to continue. Provide &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; if more input is available and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; otherwise, and you will get a new &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">デコーダーは使用可能な入力を消費しており、続行するにはさらに多くの情報が必要です。提供 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; より多くの入力が可能とされた場合に &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; そうでないと、あなたが新しい取得する &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7be60721ea4767c773d4ff5809e621bbad6d744b" translate="yes" xml:space="preserve">
          <source>The decoder has successfully finished. Except for the output value you also get any unused input as well as the number of bytes consumed.</source>
          <target state="translated">デコーダは正常に終了しました。出力値以外に、未使用の入力や消費されたバイト数も取得できます。</target>
        </trans-unit>
        <trans-unit id="c50453020b64e1b5897a128e6a4b8f6fd0ce71b8" translate="yes" xml:space="preserve">
          <source>The decoder ran into an error. The decoder either used &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; or was not provided enough input. Contains any unconsumed input and the number of bytes consumed.</source>
          <target state="translated">デコーダでエラーが発生しました。デコーダーが &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; か、入力が不十分でした。未使用の入力と消費されたバイト数が含まれます。</target>
        </trans-unit>
        <trans-unit id="c501f9a41e6b7b39a369772921e2a14165d1beb5" translate="yes" xml:space="preserve">
          <source>The decoder ran into an error. The decoder either used &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; or was not provided enough input. Contains any unconsumed input and the number of bytes consumed.</source>
          <target state="translated">デコーダーでエラーが発生しました。使用されたデコーダーが &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; か、十分な入力が提供されませんでした。未消費の入力と消費されたバイト数が含まれます。</target>
        </trans-unit>
        <trans-unit id="1106af4463a8221ffa09eb5ef1181409ca7b66ab" translate="yes" xml:space="preserve">
          <source>The decoder to isolate</source>
          <target state="translated">分離するためのデコーダ</target>
        </trans-unit>
        <trans-unit id="81c283366c767d1de7c06c6bf075b9bb441a10c1" translate="yes" xml:space="preserve">
          <source>The deduction (via generativity) that if &lt;code&gt;g x :~: g y&lt;/code&gt; then &lt;code&gt;x :~: y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;g x :~: g y&lt;/code&gt; 場合は &lt;code&gt;x :~: y&lt;/code&gt; という（生殖性による）推論。</target>
        </trans-unit>
        <trans-unit id="9109ffd32c6c50a2b3bbde42b4613b2367726367" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; for a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:nativeNewlineMode&quot;&gt;nativeNewlineMode&lt;/a&gt;&lt;/code&gt;, which does no translation on Unix systems, but translates &lt;code&gt;'\r\n'&lt;/code&gt; to &lt;code&gt;'\n'&lt;/code&gt; and back on Windows.</source>
          <target state="translated">デフォルト &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; ための &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; ある &lt;code&gt;&lt;a href=&quot;system-io#v:nativeNewlineMode&quot;&gt;nativeNewlineMode&lt;/a&gt;&lt;/code&gt; Unixシステムには翻訳しません、が、翻訳 &lt;code&gt;'\r\n'&lt;/code&gt; する &lt;code&gt;'\n'&lt;/code&gt; し、Windows上でバック。</target>
        </trans-unit>
        <trans-unit id="e1abf9eda04f648cec0d055b085fe295d921786f" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is the same as the default encoding on your system, which is also available as &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt;. (GHC note: on Windows, we currently do not support double-byte encodings; if the console's code page is unsupported, then &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; will be &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">デフォルトの &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; は、システムのデフォルトのエンコーディングと同じであり、 &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; としても使用できます。（GHC注：Windowsでは、現在2バイトエンコーディングはサポートされていません。コンソールのコードページがサポートされていない場合、 &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; になります。）</target>
        </trans-unit>
        <trans-unit id="1f7510baab521b5948629307f9f6f4dc19cd4a03" translate="yes" xml:space="preserve">
          <source>The default backend for GHC. It is a native code generator, compiling Cmm all the way to assembly code. It is the fastest backend and generally produces good performance code. It has the best support for compiling shared libraries. Select it with the &lt;code&gt;-fasm&lt;/code&gt; flag.</source>
          <target state="translated">GHCのデフォルトのバックエンド。これはネイティブコードジェネレーターであり、Cmmをアセンブリコードまでコンパイルします。これは最速のバックエンドであり、一般に優れたパフォーマンスコードを生成します。共有ライブラリのコンパイルに最適です。 &lt;code&gt;-fasm&lt;/code&gt; フラグで選択します。</target>
        </trans-unit>
        <trans-unit id="372a76ca948e47b638039a6cfbc912e969dc50c4" translate="yes" xml:space="preserve">
          <source>The default buffering mode is different in GHCi to GHC.</source>
          <target state="translated">GHCiとGHCではデフォルトのバッファリングモードが異なります。</target>
        </trans-unit>
        <trans-unit id="612f5aad425db1f69a9dbdbaaa3947648f24e8cc" translate="yes" xml:space="preserve">
          <source>The default buffering mode when a handle is opened is implementation-dependent and may depend on the file system object which is attached to that handle. For most implementations, physical files will normally be block-buffered and terminals will normally be line-buffered.</source>
          <target state="translated">ハンドルが開かれたときのデフォルトのバッファリングモードは、実装に依存しており、そのハンドルにアタッチされているファイルシステムオブジェクトに依存します。ほとんどの実装では、物理ファイルは通常ブロックバッファリングされ、ターミナルは通常ラインバッファリングされます。</target>
        </trans-unit>
        <trans-unit id="0961e4a3376f291925aa422749fabd42ce25f975" translate="yes" xml:space="preserve">
          <source>The default declaration must mention only type &lt;em&gt;variables&lt;/em&gt; on the left hand side, and the right hand side must mention only type variables that are explicitly bound on the left hand side. This restriction is relaxed for &lt;em&gt;kind&lt;/em&gt; variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound on the left hand side.</source>
          <target state="translated">デフォルトの宣言では、左側の型&lt;em&gt;変数&lt;/em&gt;のみを言及する必要があり、右側は、左側で明示的にバインドされている型変数のみを言及する必要があります。ただし、右側には左側で暗黙的にバインドされている種類の変数に言及することが許可されているため、この制限は&lt;em&gt;種類&lt;/em&gt;変数に対して緩和されています。</target>
        </trans-unit>
        <trans-unit id="c6f838e51c0c9ed9fe723da0d1493d400aae5e3d" translate="yes" xml:space="preserve">
          <source>The default declaration must mention only type &lt;em&gt;variables&lt;/em&gt; on the left hand side, and type variables may not be repeated on the left-hand side. The right hand side must mention only type variables that are explicitly bound on the left hand side. This restriction is relaxed for &lt;em&gt;kind&lt;/em&gt; variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound on the left hand side.</source>
          <target state="translated">デフォルトの宣言では、左側の型&lt;em&gt;変数&lt;/em&gt;のみに言及する必要があり、型&lt;em&gt;変数&lt;/em&gt;を左側で繰り返すことはできません。右側には、左側に明示的にバインドされている型変数のみを記載する必要があります。ただし、右側では、左側に暗黙的にバインドされている種類変数について言及できるため、この制限は&lt;em&gt;種類&lt;/em&gt;変数に対して緩和されます。</target>
        </trans-unit>
        <trans-unit id="e629035dab4042ca2e3774c6dd02fa07a19ca5ba" translate="yes" xml:space="preserve">
          <source>The default definition for &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt;, which is suitable for abstract datatypes with no substructures.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; のデフォルトの定義は &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; です。これは、部分構造のない抽象データ型に適しています。</target>
        </trans-unit>
        <trans-unit id="b37307a1a8b5c8a76936f7e75a2ac6d6c53b888a" translate="yes" xml:space="preserve">
          <source>The default definition instantiates the type constructor &lt;code&gt;c&lt;/code&gt; in the type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; to an identity datatype constructor, using the isomorphism pair as injection and projection.</source>
          <target state="translated">デフォルトの定義では、注入と射影として同型ペアを使用して、 &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; の型の型コンストラクター &lt;code&gt;c&lt;/code&gt; をIDデータ型コンストラクターにインスタンス化します。</target>
        </trans-unit>
        <trans-unit id="0ebc5859a93e62be528328f3201553481af2edf0" translate="yes" xml:space="preserve">
          <source>The default definition instantiates the type constructor &lt;code&gt;c&lt;/code&gt; in the type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; to the monad datatype constructor, defining injection and projection using &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">デフォルトの定義では、 &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; の型の型コンストラクタ &lt;code&gt;c&lt;/code&gt; をモナドデータ型コンストラクタにインスタンス化し、 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; を使用して注入と射影を定義します。</target>
        </trans-unit>
        <trans-unit id="4bd4056577869d6ffa3c25c8d2085ea54f8f3b3d" translate="yes" xml:space="preserve">
          <source>The default definition is</source>
          <target state="translated">デフォルトの定義は</target>
        </trans-unit>
        <trans-unit id="0c68a975cf82f38a807abb27f8056b694f43e039" translate="yes" xml:space="preserve">
          <source>The default definition is &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, which is appropriate for instances of other forms.</source>
          <target state="translated">デフォルトの定義は &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; で、他の形式のインスタンスに適しています。</target>
        </trans-unit>
        <trans-unit id="aa9945acbeccb98293938a8f8c707927dd353e5f" translate="yes" xml:space="preserve">
          <source>The default definition may be overridden with a more efficient version if desired.</source>
          <target state="translated">デフォルトの定義は、必要に応じてより効率的なバージョンで上書きすることができます。</target>
        </trans-unit>
        <trans-unit id="71589b344fdce3f6d3065162df2b93817e514841" translate="yes" xml:space="preserve">
          <source>The default definition should be sufficient, but this can be overridden for efficiency.</source>
          <target state="translated">デフォルトの定義は十分であるべきですが、効率化のためにオーバーライドすることができます。</target>
        </trans-unit>
        <trans-unit id="b230bf83d4661530a10d60a3a4832bae81967728" translate="yes" xml:space="preserve">
          <source>The default definition uses &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList&quot;&gt;liftReadList&lt;/a&gt;&lt;/code&gt;. Instances that define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; should also define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrecDefault&quot;&gt;liftReadListPrecDefault&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">デフォルトの定義では &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList&quot;&gt;liftReadList&lt;/a&gt;&lt;/code&gt; を使用します。定義インスタンス &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; はまた、定義する必要があり &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; を通り &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrecDefault&quot;&gt;liftReadListPrecDefault&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b8f0470f58f998c4d12f0e8356a21d2ca7b5de3" translate="yes" xml:space="preserve">
          <source>The default definition uses &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList2&quot;&gt;liftReadList2&lt;/a&gt;&lt;/code&gt;. Instances that define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; should also define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2Default&quot;&gt;liftReadListPrec2Default&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">デフォルトの定義では &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList2&quot;&gt;liftReadList2&lt;/a&gt;&lt;/code&gt; を使用します。定義インスタンス &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; はまた、定義する必要があり &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; を通り &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2Default&quot;&gt;liftReadListPrec2Default&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c58343eea6290f399d2ab6ad1cadcd380e922e3" translate="yes" xml:space="preserve">
          <source>The default definitions of the &lt;code&gt;&lt;a href=&quot;ghc-real#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-real#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; functions are in terms of &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-real#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-real#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-real#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;ghc-real#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; 関数のデフォルトの定義は、 &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; に関するものです。</target>
        </trans-unit>
        <trans-unit id="ec66529839a9863362b72c24581910fe9d869109" translate="yes" xml:space="preserve">
          <source>The default definitions of the &lt;code&gt;&lt;a href=&quot;prelude#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; functions are in terms of &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;prelude#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; 関数のデフォルトの定義は、 &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; に関するものです。</target>
        </trans-unit>
        <trans-unit id="491d8a12b5fa1e7b0bec380645e2c6e813fe0eda" translate="yes" xml:space="preserve">
          <source>The default method definitions in the &lt;code&gt;Exception&lt;/code&gt; class do what we need in this case. You can now throw and catch &lt;code&gt;ThisException&lt;/code&gt; and &lt;code&gt;ThatException&lt;/code&gt; as exceptions:</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; クラスのデフォルトのメソッド定義は、この場合に必要なことを行います。 &lt;code&gt;ThisException&lt;/code&gt; と &lt;code&gt;ThatException&lt;/code&gt; を例外としてスローおよびキャッチできるようになりました。</target>
        </trans-unit>
        <trans-unit id="06f71be64b1eace75a4676b9f81b6631fa302e4c" translate="yes" xml:space="preserve">
          <source>The default method for &lt;code&gt;put&lt;/code&gt; is then used, corresponding to the generic implementation of serialization. If you are using &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, the same instance is generated by simply attaching a &lt;code&gt;deriving Serialize&lt;/code&gt; clause to the &lt;code&gt;UserTree&lt;/code&gt; datatype declaration. For more examples of generic functions please refer to the &lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;generic-deriving&lt;/a&gt; package on Hackage.</source>
          <target state="translated">次に、シリアル化の一般的な実装に対応する、デフォルトの &lt;code&gt;put&lt;/code&gt; メソッドが使用されます。&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;を使用している場合、 &lt;code&gt;deriving Serialize&lt;/code&gt; インスタンスのSerialize句を &lt;code&gt;UserTree&lt;/code&gt; データ型宣言に添付するだけで、同じインスタンスが生成されます。ジェネリック関数のその他の例については、Hackageの&lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;ジェネリック派生&lt;/a&gt;パッケージを参照してください。</target>
        </trans-unit>
        <trans-unit id="84a8076800f1a94cd466a3ca2cb82ca67bed6590" translate="yes" xml:space="preserve">
          <source>The default parallel GC settings are usually suitable for parallel programs (i.e. those using &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-conc#v:par&quot;&gt;GHC.Conc.par&lt;/a&gt;, Strategies, or with multiple threads). However, it is sometimes beneficial to enable the parallel GC for a single-threaded sequential program too, especially if the program has a large amount of heap data and GC is a significant fraction of runtime. To use the parallel GC in a sequential program, enable the parallel runtime with a suitable &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option, and additionally it might be beneficial to restrict parallel GC to the old generation with &lt;code&gt;-qg1&lt;/code&gt;.</source>
          <target state="translated">デフォルトの並列GC設定は通常、並列プログラム（つまり、&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-conc#v:par&quot;&gt;GHC.Conc.par&lt;/a&gt;を使用するもの、戦略、または複数のスレッドを使用するもの）に適しています。ただし、特にプログラムに大量のヒープデータがあり、GCが実行時間のかなりの部分を占める場合は、シングルスレッドのシーケンシャルプログラムでも並列GCを有効にすると便利な場合があります。逐次プログラムで並列GCを使用するには、適切な &lt;code&gt;-N ⟨x⟩&lt;/code&gt; オプションを使用して並列ランタイムを有効にします。さらに、-qg1を使用して並列GCを古い世代に制限すると &lt;code&gt;-qg1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8b8f4457b131cbd6a076f86c5f337a8e72b95e39" translate="yes" xml:space="preserve">
          <source>The default parallel GC settings are usually suitable for parallel programs (i.e. those using &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-conc#v:par&quot;&gt;GHC.Conc.par&lt;/a&gt;, Strategies, or with multiple threads). However, it is sometimes beneficial to enable the parallel GC for a single-threaded sequential program too, especially if the program has a large amount of heap data and GC is a significant fraction of runtime. To use the parallel GC in a sequential program, enable the parallel runtime with a suitable &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option, and additionally it might be beneficial to restrict parallel GC to the old generation with &lt;code&gt;-qg1&lt;/code&gt;.</source>
          <target state="translated">デフォルトの並列GC設定は、通常、並列プログラム（つまり、&lt;a href=&quot;../libraries/base-4.14.1.0/ghc-conc#v:par&quot;&gt;GHC.Conc.par&lt;/a&gt;、Strategies、または複数のスレッドを使用するプログラム）に適しています。ただし、特にプログラムに大量のヒープデータがあり、GCが実行時間のかなりの部分を占める場合は、シングルスレッドシーケンシャルプログラムでも並列GCを有効にすると便利な場合があります。シーケンシャルプログラムで並列GCを使用するには、適切な &lt;code&gt;-N ⟨x⟩&lt;/code&gt; オプションを使用して並列ランタイムを有効にします。さらに、-qg1を使用して並列GCを旧世代に制限すると &lt;code&gt;-qg1&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="1c469f1e0fe0a399e3c8b4ab9c90096159140285" translate="yes" xml:space="preserve">
          <source>The default preferences which may be overwritten in the &lt;code&gt;.haskeline&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;.haskeline&lt;/code&gt; ファイルで上書きされるデフォルトの設定。</target>
        </trans-unit>
        <trans-unit id="2646b613e6eb1c1c85aa64b66ff2f7d3602d210c" translate="yes" xml:space="preserve">
          <source>The default role for abstract datatype parameters is now representational. (An abstract datatype is one with no constructors listed.) To get another role, use a role annotation. (See &lt;a href=&quot;glasgow_exts#roles&quot;&gt;Roles&lt;/a&gt;.)</source>
          <target state="translated">抽象データ型パラメーターのデフォルトの役割が表現になりました。（抽象データ型は、コンストラクターがリストされていないデータ型です。）別のロールを取得するには、ロール注釈を使用します。（&lt;a href=&quot;glasgow_exts#roles&quot;&gt;役割を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="60620248a38bdba79e7fcf67abe638e2752d6a16" translate="yes" xml:space="preserve">
          <source>The default seems to work well here. If you have plenty of memory, it is usually better to use &lt;code&gt;-H ⟨size⟩&lt;/code&gt; (see &lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-H [⟨size⟩]&lt;/code&gt;&lt;/a&gt;) than to increase &lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt;&lt;code&gt;-F ⟨factor⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ここではデフォルトがうまく機能するようです。メモリが十分にある場合は、通常、&lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; &lt;/a&gt;を増やすよりも、 &lt;code&gt;-H ⟨size⟩&lt;/code&gt; （-H [⟨size⟩]を参照）を使用することをお&lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt; &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; &lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="3395f0bc00fd88ab55e5b4f27b7ed6fe2e944e0a" translate="yes" xml:space="preserve">
          <source>The default style (&lt;code&gt;mode=PageMode, lineLength=100, ribbonsPerLine=1.5&lt;/code&gt;).</source>
          <target state="translated">デフォルトのスタイル（ &lt;code&gt;mode=PageMode, lineLength=100, ribbonsPerLine=1.5&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="af2102e497ed3634f45c2fd75b234c6748ca55b8" translate="yes" xml:space="preserve">
          <source>The definition (of a function, variable, struct or typedef) is written to the C file, and its prototype or extern declaration to the C header. Inline functions are handled correctly. struct definitions and typedefs are written to the C program too. The &lt;code&gt;inline&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;typedef&lt;/code&gt; keyword must come just after &lt;code&gt;def&lt;/code&gt;.</source>
          <target state="translated">（関数、変数、構造体、またはtypedefの）定義はCファイルに書き込まれ、そのプロトタイプまたはextern宣言はCヘッダーに書き込まれます。インライン関数は正しく処理されます。構造体の定義とtypedefもCプログラムに書き込まれます。 &lt;code&gt;inline&lt;/code&gt; 、 &lt;code&gt;struct&lt;/code&gt; または &lt;code&gt;typedef&lt;/code&gt; のキーワードが直後に来なければならない &lt;code&gt;def&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c8661345439bef92de6f21733c68492b49b19b5" translate="yes" xml:space="preserve">
          <source>The definition for &amp;ldquo;compatible&amp;rdquo; uses a notion of &amp;ldquo;apart&amp;rdquo;, whose definition in turn relies on type family reduction. This condition of &amp;ldquo;apartness&amp;rdquo;, as stated, is impossible to check, so we use this conservative approximation: two types are considered to be apart when the two types cannot be unified, even by a potentially infinite unifier. Allowing the unifier to be infinite disallows the following pair of instances:</source>
          <target state="translated">「互換性のある」の定義では、「apart」の概念を使用しています。その定義は、タイプファミリーの削減に依存しています。述べたように、この「アパート」の状態はチェックすることが不可能であるため、この控えめな近似を使用します。2つのタイプは、潜在的に無限のユニファイアによっても統合できない場合、離れていると見なされます。unifierが無限であることを許可すると、次のインスタンスのペアが許可されなくなります。</target>
        </trans-unit>
        <trans-unit id="70f33fa7b9f96d835ab103c50be5ec10b816d10e" translate="yes" xml:space="preserve">
          <source>The definition is syntactic:</source>
          <target state="translated">定義は構文的なものです。</target>
        </trans-unit>
        <trans-unit id="df390321900febf5a604611d2971ac50e861f17b" translate="yes" xml:space="preserve">
          <source>The definition of &quot;math symbol&quot; may be a little counter-intuitive depending on one's background:</source>
          <target state="translated">数学記号」の定義は、その人のバックグラウンドによっては少し逆効果になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="9142eae3b3df142878b925196063f3a19a7bf511" translate="yes" xml:space="preserve">
          <source>The definition of (say) &lt;code&gt;build&lt;/code&gt; in &lt;code&gt;GHC/Base.hs&lt;/code&gt; looks like this:</source>
          <target state="translated">（言う）の定義 &lt;code&gt;build&lt;/code&gt; で &lt;code&gt;GHC/Base.hs&lt;/code&gt; は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="c2ee65e9c75aa9258dca0f16a6b10f4fd9a759a9" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;foo&lt;/code&gt; is rejected because one would have to instantiate &lt;code&gt;id&lt;/code&gt;&amp;lsquo;s type with &lt;code&gt;b := (forall s. ST s a) -&amp;gt; a&lt;/code&gt;, and that is not allowed. Instantiating polymorphic type variables with polymorphic types is called &lt;em&gt;impredicative polymorphism&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; の定義は、 &lt;code&gt;b := (forall s. ST s a) -&amp;gt; a&lt;/code&gt; で &lt;code&gt;id&lt;/code&gt; の型をインスタンス化する必要があるため拒否されますが、これは許可されていません。ポリモーフィック型を使用してポリモーフィック型変数をインスタンス化することを、&lt;em&gt;予測的ポリモーフィズム&lt;/em&gt;といいます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="771404ab6f98868990a30122c2e2669c9b6b0a26" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;foo&lt;/code&gt; is rejected because one would have to instantiate &lt;code&gt;id&lt;/code&gt;&amp;rsquo;s type with &lt;code&gt;b := (forall s. ST s a) -&amp;gt; a&lt;/code&gt;, and that is not allowed. Instantiating polymorphic type variables with polymorphic types is called &lt;em&gt;impredicative polymorphism&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; の型を &lt;code&gt;b := (forall s. ST s a) -&amp;gt; a&lt;/code&gt; でインスタンス化する必要があるため、 &lt;code&gt;foo&lt;/code&gt; の定義は拒否されますが、これは許可されていません。ポリモーフィック型を使用してポリモーフィック型変数をインスタンス化することは、非&lt;em&gt;叙述的ポリモーフィズム&lt;/em&gt;と呼ばれます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed024c34bd63c1441cb3695b992556af082202b2" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;inst&lt;/code&gt; is unchanged from the Haskell Report (roughly, just a type). The &lt;code&gt;context =&amp;gt;&lt;/code&gt; part is optional. That is the only syntactic change to the language.</source>
          <target state="translated">&lt;code&gt;inst&lt;/code&gt; の定義は、Haskell Reportから変更されていません（大まかに、タイプのみ）。 &lt;code&gt;context =&amp;gt;&lt;/code&gt; の部分はオプションです。これが言語の唯一の構文変更です。</target>
        </trans-unit>
        <trans-unit id="0bfdf9f8e4b0cf4d6ac3380a527908a80562e1fe" translate="yes" xml:space="preserve">
          <source>The definition of retainers is designed to reflect a common cause of space leaks: a large structure is retained by an unevaluated computation, and will be released once the computation is forced. A good example is looking up a value in a finite map, where unless the lookup is forced in a timely manner the unevaluated lookup will cause the whole mapping to be retained. These kind of space leaks can often be eliminated by forcing the relevant computations to be performed eagerly, using &lt;code&gt;seq&lt;/code&gt; or strictness annotations on data constructor fields.</source>
          <target state="translated">リテーナの定義は、スペースリークの一般的な原因を反映するように設計されています。大きな構造は、評価されていない計算によって保持され、計算が強制されると解放されます。良い例は、有限マップで値を検索することです。この場合、検索がタイムリーに強制されない限り、未評価の検索によってマッピング全体が保持されます。これらの種類のスペースリークは、データコンストラクターフィールドに &lt;code&gt;seq&lt;/code&gt; またはstrictnessアノテーションを使用して、関連する計算を熱心に実行させることにより、解消することができます。</target>
        </trans-unit>
        <trans-unit id="0a4d062a38697a5c692b5c4d00fce9e23429e7b4" translate="yes" xml:space="preserve">
          <source>The delayed RSS update can confuse programmers debugging memory issues, production memory monitoring tools, and end users who may complain about undue memory usage shown in reporting tools, so with this flag it can be turned off.</source>
          <target state="translated">RSSの更新が遅れると、メモリ問題をデバッグしているプログラマや本番のメモリ監視ツール、レポートツールに表示される不当なメモリ使用量に文句を言うエンドユーザを混乱させる可能性があるため、このフラグをオフにすることができます。</target>
        </trans-unit>
        <trans-unit id="f9455c27066e060f9c4ed319a5e6f962fe125ba2" translate="yes" xml:space="preserve">
          <source>The dependency &lt;code&gt;ce -&amp;gt; e&lt;/code&gt; here specifies that the type &lt;code&gt;e&lt;/code&gt; of elements is uniquely determined by the type of the collection &lt;code&gt;ce&lt;/code&gt;. Note that both parameters of Collects are of kind &lt;code&gt;Type&lt;/code&gt;; there are no constructor classes here. Note too that all of the instances of &lt;code&gt;Collects&lt;/code&gt; that we gave earlier can be used together with this new definition.</source>
          <target state="translated">ここで、依存関係 &lt;code&gt;ce -&amp;gt; e&lt;/code&gt; は、要素のタイプ &lt;code&gt;e&lt;/code&gt; がコレクション &lt;code&gt;ce&lt;/code&gt; のタイプによって一意に決定されることを指定します。Collectsのパラメータは両方とも &lt;code&gt;Type&lt;/code&gt; であることに注意してください。ここにはコンストラクタークラスはありません。前述の &lt;code&gt;Collects&lt;/code&gt; のすべてのインスタンスは、この新しい定義と一緒に使用できることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="0ed435c3cbe535cb6b31533a151482c8d2a49765" translate="yes" xml:space="preserve">
          <source>The dependency generation phase of GHC can take some additional options, which you may find useful. The options which affect dependency generation are:</source>
          <target state="translated">GHC の依存関係生成フェーズでは、便利なオプションがいくつか追加されています。依存関係の生成に影響を与えるオプションは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="b14601aa73f99ec94b5c907467d51ea631241fb4" translate="yes" xml:space="preserve">
          <source>The dependency is based on file content, not a modification time</source>
          <target state="translated">依存関係はファイルの内容に基づいており、修正時間ではありません。</target>
        </trans-unit>
        <trans-unit id="3c358c9fef1903c6b809a8b35e1f6f1eb8d8555a" translate="yes" xml:space="preserve">
          <source>The derivation mechanism can be used separately from the data type declaration, using the &lt;a href=&quot;#stand-alone-deriving&quot;&gt;standalone deriving mechanism&lt;/a&gt;.</source>
          <target state="translated">派生メカニズムは、&lt;a href=&quot;#stand-alone-deriving&quot;&gt;スタンドアロンの派生メカニズム&lt;/a&gt;を使用して、データ型宣言とは別に使用できます。</target>
        </trans-unit>
        <trans-unit id="adeb50d906769008b71fc1da461a1b88d5c5394a" translate="yes" xml:space="preserve">
          <source>The derivation mechanism can be used separtely from the data type declaration, using the &lt;a href=&quot;#stand-alone-deriving&quot;&gt;standalone deriving mechanism&lt;/a&gt;.</source>
          <target state="translated">派生メカニズムは、&lt;a href=&quot;#stand-alone-deriving&quot;&gt;スタンドアロンの派生メカニズム&lt;/a&gt;を使用して、データ型宣言とは別に使用できます。</target>
        </trans-unit>
        <trans-unit id="b7b9b515a6b382dc8b30446310290e049039607a" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance allows arbitrary Haskell whitespace between tokens of the input string. Extra parentheses are also allowed.</source>
          <target state="translated">派生した &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスは、入力文字列のトークン間に任意のHaskell空白を許可します。余分な括弧も使用できます。</target>
        </trans-unit>
        <trans-unit id="0df45d847dca83db9351f4d864dd9921bcab85be" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance allows arbitrary Haskell whitespace between tokens of the input string. Extra parentheses are also allowed.</source>
          <target state="translated">派生した &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスは、入力文字列のトークン間に任意のHaskell空白を許可します。余分な括弧も使用できます。</target>
        </trans-unit>
        <trans-unit id="827987dc4d21c55f29757d61b2ead342246251b4" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance allows arbitrary Haskell whitespace between tokens of the input string. Extra parentheses are also allowed.</source>
          <target state="translated">派生した &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスは、入力文字列のトークン間に任意のHaskell空白を許可します。余分な括弧も使用できます。</target>
        </trans-unit>
        <trans-unit id="181a26c0ac10388c1c28e3a4a0bb2c744983c69d" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;HasRing&lt;/code&gt; instance would look like</source>
          <target state="translated">派生した &lt;code&gt;HasRing&lt;/code&gt; インスタンスは次のようになります</target>
        </trans-unit>
        <trans-unit id="4744374c6426f29a0ece90c5038f8bb5efa3725d" translate="yes" xml:space="preserve">
          <source>The derived instance in GHC is equivalent to</source>
          <target state="translated">GHCでの派生インスタンスは</target>
        </trans-unit>
        <trans-unit id="2aa9649e650abb1ccfd00ab90d331d7948d62cc4" translate="yes" xml:space="preserve">
          <source>The derived instance is obtained by completing the application of the class to the new type:</source>
          <target state="translated">派生インスタンスは、新しい型へのクラスの適用を完了することで取得されます。</target>
        </trans-unit>
        <trans-unit id="75901f130a621087c5df4e3c7ff2bcd908627e72" translate="yes" xml:space="preserve">
          <source>The design also relies on &lt;code&gt;Danger&lt;/code&gt; not being able to access the &lt;code&gt;UnsafeRIO&lt;/code&gt; constructor. Unfortunately Template Haskell can be used to subvert module boundaries and so could be used to gain access to this constructor.</source>
          <target state="translated">この設計は、 &lt;code&gt;Danger&lt;/code&gt; が &lt;code&gt;UnsafeRIO&lt;/code&gt; コンストラクターにアクセスできないことにも依存しています。残念ながら、テンプレートハスケルはモジュールの境界を破壊するために使用できるため、このコンストラクタへのアクセスに使用される可能性があります。</target>
        </trans-unit>
        <trans-unit id="49cc72101ca9237972311dd03a0fd606151e4195" translate="yes" xml:space="preserve">
          <source>The design attempts to restrict the operations that &lt;code&gt;Danger&lt;/code&gt; can perform by using types, specifically the &lt;code&gt;RIO&lt;/code&gt; type wrapper around &lt;code&gt;IO&lt;/code&gt; . The author of &lt;code&gt;Danger&lt;/code&gt; can subvert this though by simply writing arbitrary &lt;code&gt;IO&lt;/code&gt; actions and using &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; to execute them as pure functions.</source>
          <target state="translated">この設計では、型、特に &lt;code&gt;IO&lt;/code&gt; の &lt;code&gt;RIO&lt;/code&gt; タイプラッパーを使用して、 &lt;code&gt;Danger&lt;/code&gt; が実行できる操作を制限しようとしています。 &lt;code&gt;Danger&lt;/code&gt; の作者は、任意の &lt;code&gt;IO&lt;/code&gt; アクションを作成し、 &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; を使用してそれらを純粋な関数として実行することで、これを覆すことができます。</target>
        </trans-unit>
        <trans-unit id="cd2da32dc935177290030f66437b8442e648de85" translate="yes" xml:space="preserve">
          <source>The design follows the following principles</source>
          <target state="translated">設計は以下の原則に従います。</target>
        </trans-unit>
        <trans-unit id="8290c7ce1697900c8e40df8ad0fc8ee4040a8ead" translate="yes" xml:space="preserve">
          <source>The design of Safe Haskell covers the following aspects:</source>
          <target state="translated">Safe Haskellの設計では、以下の点をカバーしています。</target>
        </trans-unit>
        <trans-unit id="db9668c7f3a96172360c5f50287354a3f36ed64a" translate="yes" xml:space="preserve">
          <source>The design of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; monoid is optimized such that</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; モノイドの設計は、</target>
        </trans-unit>
        <trans-unit id="d69ade52bf3d6bc1c9e9d54294cef3da66243040" translate="yes" xml:space="preserve">
          <source>The design of this combinator was guided by the objective that &lt;code&gt;timeout n f&lt;/code&gt; should behave exactly the same as &lt;code&gt;f&lt;/code&gt; as long as &lt;code&gt;f&lt;/code&gt; doesn't time out. This means that &lt;code&gt;f&lt;/code&gt; has the same &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; it would have without the timeout wrapper. Any exceptions &lt;code&gt;f&lt;/code&gt; might throw cancel the timeout and propagate further up. It also possible for &lt;code&gt;f&lt;/code&gt; to receive exceptions thrown to it by another thread.</source>
          <target state="translated">このコンビネータの設計をすることを目的に導かれた &lt;code&gt;timeout n f&lt;/code&gt; 正確に同じように振る舞うべき &lt;code&gt;f&lt;/code&gt; 限りとして、 &lt;code&gt;f&lt;/code&gt; はタイムアウトしません。これは、 &lt;code&gt;f&lt;/code&gt; に、タイムアウトラッパーがない場合と同じ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; があることを意味します。例外 &lt;code&gt;f&lt;/code&gt; がスローされると、タイムアウトがキャンセルされ、さらに上に伝播する場合があります。また、 &lt;code&gt;f&lt;/code&gt; は別のスレッドからスローされた例外を受け取ることもできます。</target>
        </trans-unit>
        <trans-unit id="8a12fd0294a8f0c5a36accd7b8d8d788bbce4f21" translate="yes" xml:space="preserve">
          <source>The design of this combinator was guided by the objective that &lt;code&gt;timeout n f&lt;/code&gt; should behave exactly the same as &lt;code&gt;f&lt;/code&gt; as long as &lt;code&gt;f&lt;/code&gt; doesn't time out. This means that &lt;code&gt;f&lt;/code&gt; has the same &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; it would have without the timeout wrapper. Any exceptions &lt;code&gt;f&lt;/code&gt; might throw cancel the timeout and propagate further up. It also possible for &lt;code&gt;f&lt;/code&gt; to receive exceptions thrown to it by another thread.</source>
          <target state="translated">このコンビネータの設計をすることを目的に導かれた &lt;code&gt;timeout n f&lt;/code&gt; 正確に同じように振る舞うべき &lt;code&gt;f&lt;/code&gt; 限りとして、 &lt;code&gt;f&lt;/code&gt; はタイムアウトしません。これは、 &lt;code&gt;f&lt;/code&gt; がタイムアウトラッパーなしの場合と同じ &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; を持っていることを意味します。すべての例外の &lt;code&gt;f&lt;/code&gt; はタイムアウトをキャンセルし、さらにアップを伝播投げるかもしれません。 &lt;code&gt;f&lt;/code&gt; が別のスレッドによってスローされた例外を受け取ることも可能です。</target>
        </trans-unit>
        <trans-unit id="ddf2c08a7e7a13b99ab3673124ddb5f1ed0a8e6e" translate="yes" xml:space="preserve">
          <source>The design of this combinator was guided by the objective that &lt;code&gt;timeout n f&lt;/code&gt; should behave exactly the same as &lt;code&gt;f&lt;/code&gt; as long as &lt;code&gt;f&lt;/code&gt; doesn't time out. This means that &lt;code&gt;f&lt;/code&gt; has the same &lt;code&gt;&lt;a href=&quot;control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; it would have without the timeout wrapper. Any exceptions &lt;code&gt;f&lt;/code&gt; might throw cancel the timeout and propagate further up. It also possible for &lt;code&gt;f&lt;/code&gt; to receive exceptions thrown to it by another thread.</source>
          <target state="translated">このコンビネータの設計をすることを目的に導かれた &lt;code&gt;timeout n f&lt;/code&gt; 正確に同じように振る舞うべき &lt;code&gt;f&lt;/code&gt; 限りとして、 &lt;code&gt;f&lt;/code&gt; はタイムアウトしません。これは、 &lt;code&gt;f&lt;/code&gt; に、タイムアウトラッパーがない場合と同じ &lt;code&gt;&lt;a href=&quot;control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; があることを意味します。例外 &lt;code&gt;f&lt;/code&gt; がスローされると、タイムアウトがキャンセルされ、さらに上に伝播する場合があります。また、 &lt;code&gt;f&lt;/code&gt; は別のスレッドからスローされた例外を受け取ることもできます。</target>
        </trans-unit>
        <trans-unit id="069d6b594d5ec9b69dd4d93d8ec6094f3feb0544" translate="yes" xml:space="preserve">
          <source>The details of how to create the process are passed in the &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; record. To make it easier to construct a &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt;, the functions &lt;code&gt;&lt;a href=&quot;system-process#v:proc&quot;&gt;proc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-process#v:shell&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; are supplied that fill in the fields with default values which can be overriden as needed.</source>
          <target state="translated">プロセスの作成方法の詳細は、 &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; レコードで渡されます。 &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; の構築を簡単にするために、必要に応じてオーバーライドできるデフォルト値をフィールドに入力する関数 &lt;code&gt;&lt;a href=&quot;system-process#v:proc&quot;&gt;proc&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;system-process#v:shell&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; が提供されています。</target>
        </trans-unit>
        <trans-unit id="4faba3c52f5f6f8ccfc588aad8cbbfccac6eb185" translate="yes" xml:space="preserve">
          <source>The detection of CUSKs is enabled by the &lt;a href=&quot;#extension-CUSKs&quot;&gt;&lt;code&gt;CUSKs&lt;/code&gt;&lt;/a&gt; flag, which is switched on by default. This extension is scheduled for deprecation to be replaced with &lt;a href=&quot;#extension-StandaloneKindSignatures&quot;&gt;&lt;code&gt;StandaloneKindSignatures&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">CUSKの検出は、デフォルトでオンになっている&lt;a href=&quot;#extension-CUSKs&quot;&gt; &lt;code&gt;CUSKs&lt;/code&gt; &lt;/a&gt;フラグによって有効になります。この拡張機能は、非推奨が&lt;a href=&quot;#extension-StandaloneKindSignatures&quot;&gt; &lt;code&gt;StandaloneKindSignatures&lt;/code&gt; &lt;/a&gt;に置き換えられる予定です。</target>
        </trans-unit>
        <trans-unit id="ed02330a1fbdda98a3ba7bccd58b777f6e21c2c1" translate="yes" xml:space="preserve">
          <source>The developer knows that a monad transformer takes a monad &lt;code&gt;m&lt;/code&gt; into a new monad &lt;code&gt;t m&lt;/code&gt;. But this property is not formally specified in the above declaration. This omission becomes an issue when defining monad transformer composition:</source>
          <target state="translated">開発者は、モナド変換器がモナド &lt;code&gt;m&lt;/code&gt; を新しいモナド &lt;code&gt;t m&lt;/code&gt; 変換することを知っています。ただし、このプロパティは上記の宣言では正式に指定されていません。この省略は、モナド変換器の構成を定義するときに問題になります。</target>
        </trans-unit>
        <trans-unit id="baaf6bdd8fde5eba43c6847cbbb88e9af95ebd7b" translate="yes" xml:space="preserve">
          <source>The difference between this and &lt;a href=&quot;#ghc-flag--funfolding-creation-threshold=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-funfolding-creation-threshold=⟨n⟩&lt;/code&gt;&lt;/a&gt; is that this one determines if a function definition will be inlined &lt;em&gt;at a call site&lt;/em&gt;. The other option determines if a function definition will be kept around at all for potential inlining.</source>
          <target state="translated">これと&lt;a href=&quot;#ghc-flag--funfolding-creation-threshold=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-funfolding-creation-threshold=⟨n⟩&lt;/code&gt; &lt;/a&gt;は、関数定義が&lt;em&gt;呼び出しサイトで&lt;/em&gt;インライン化されるかどうかを決定することです。もう1つのオプションは、潜在的なインライン化のために関数定義を保持するかどうかを決定します。</target>
        </trans-unit>
        <trans-unit id="7ce598ae08dc7d0d31f3dc6c209cf1408d599371" translate="yes" xml:space="preserve">
          <source>The difference between using &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; for recovery is that in &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; the handler is inside an implicit &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; (see &quot;Asynchronous Exceptions&quot;) which is important when catching asynchronous exceptions, but when catching other kinds of exception it is unnecessary. Furthermore it is possible to accidentally stay inside the implicit &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; by tail-calling rather than returning from the handler, which is why we recommend using &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; for ordinary exception recovery.</source>
          <target state="translated">リカバリーに &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; を使用する場合の違いは、 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; ではハンドラーが暗黙の &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; （「非同期例外」を参照）内にあることです。これは非同期例外をキャッチするときに重要ですが、他の種類の例外をキャッチするときは不要です。さらに、ハンドラーから戻るのではなく、末尾呼び出しによって暗黙の &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 内に誤って留まる可能性があります。そのため、通常の例外の回復には、 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; ではなく &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; の使用をお勧めします。</target>
        </trans-unit>
        <trans-unit id="7baf36ea1c4b3f790ba00b9fa8c653d9d8edc0dc" translate="yes" xml:space="preserve">
          <source>The difference involves the placement of the last type parameter, &lt;code&gt;a&lt;/code&gt;. In the &lt;code&gt;Right&lt;/code&gt; case, &lt;code&gt;a&lt;/code&gt; occurs within the type &lt;code&gt;Either Int a&lt;/code&gt;, and moreover, it appears as the last type argument of &lt;code&gt;Either&lt;/code&gt;. In the &lt;code&gt;Wrong&lt;/code&gt; case, however, &lt;code&gt;a&lt;/code&gt; is not the last type argument to &lt;code&gt;Either&lt;/code&gt;; rather, &lt;code&gt;Int&lt;/code&gt; is.</source>
          <target state="translated">違いは、最後の型パラメーター &lt;code&gt;a&lt;/code&gt; の配置です。で &lt;code&gt;Right&lt;/code&gt; 場合、タイプ内で起こる &lt;code&gt;Either Int a&lt;/code&gt; 、しかも、それが最後の型引数として表示されます &lt;code&gt;Either&lt;/code&gt; 。 &lt;code&gt;Wrong&lt;/code&gt; 場合、ただし、最後型引数はない &lt;code&gt;Either&lt;/code&gt; 。むしろ、 &lt;code&gt;Int&lt;/code&gt; です。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b237dd43561a7048051c81d4534c2c8653cc063" translate="yes" xml:space="preserve">
          <source>The directory returned is expected to be writable by the current user, but note that it isn't generally considered good practice to store application-specific data here; use &lt;code&gt;&lt;a href=&quot;system-directory#v:getXdgDirectory&quot;&gt;getXdgDirectory&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-directory#v:getAppUserDataDirectory&quot;&gt;getAppUserDataDirectory&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">返されるディレクトリは、現在のユーザーが書き込み可能であることが期待されていますが、アプリケーション固有のデータをここに格納することは、一般的には良い方法とは見なされないことに注意してください。代わりに &lt;code&gt;&lt;a href=&quot;system-directory#v:getXdgDirectory&quot;&gt;getXdgDirectory&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-directory#v:getAppUserDataDirectory&quot;&gt;getAppUserDataDirectory&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="d678522b8fbe1bfba9bfaea6f20349fc6c790192" translate="yes" xml:space="preserve">
          <source>The do-notation of Haskell 98 does not allow &lt;em&gt;recursive bindings&lt;/em&gt;, that is, the variables bound in a do-expression are visible only in the textually following code block. Compare this to a let-expression, where bound variables are visible in the entire binding group.</source>
          <target state="translated">Haskell 98のdo表記では、&lt;em&gt;再帰的なバインディング&lt;/em&gt;は許可されていません。つまり、do式にバインドされた変数は、テキストの後に続くコードブロックでのみ表示されます。これを、バインドされた変数がバインディンググループ全体に表示されるlet式と比較してください。</target>
        </trans-unit>
        <trans-unit id="ed0761a6931cceb4a4d7abb1349cfebd091b9cae" translate="yes" xml:space="preserve">
          <source>The document type</source>
          <target state="translated">ドキュメントタイプ</target>
        </trans-unit>
        <trans-unit id="b44ad1035675a222470b757eea4beb20cf50c47b" translate="yes" xml:space="preserve">
          <source>The document.</source>
          <target state="translated">ドキュメントです。</target>
        </trans-unit>
        <trans-unit id="f1cdc66d16588511d035499d8789d0de0a61455f" translate="yes" xml:space="preserve">
          <source>The documentation here describes the realisation of Template Haskell in GHC. It is not detailed enough to understand Template Haskell; see the &lt;a href=&quot;http://haskell.org/haskellwiki/Template_Haskell&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="translated">ここのドキュメントは、GHCでのテンプレートHaskellの実現について説明しています。テンプレートHaskellを理解するのに十分詳細ではありません。&lt;a href=&quot;http://haskell.org/haskellwiki/Template_Haskell&quot;&gt;Wikiページを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="5d161d8e5801d84e4bc6cb6d1ba3399418931f1f" translate="yes" xml:space="preserve">
          <source>The down-side is that, if the boilerplate code fails to typecheck, you will get an error message about that code, which you did not write. Whereas, with a &lt;code&gt;deriving&lt;/code&gt; clause the side-conditions are necessarily more conservative, but any error message may be more comprehensible.</source>
          <target state="translated">欠点は、ボイラープレートコードのタイプチェックに失敗した場合、そのコードに関するエラーメッセージが表示されますが、これはユーザーが作成したものではありません。一方、 &lt;code&gt;deriving&lt;/code&gt; 句を使用すると、サイドコンディションはより保守的になりますが、エラーメッセージはよりわかりやすくなります。</target>
        </trans-unit>
        <trans-unit id="0d40a85296a889e2235c05d3e594413e6271c9b0" translate="yes" xml:space="preserve">
          <source>The downside of having lightweight threads is that only one can run at a time, so if one thread blocks in a foreign call, for example, the other threads cannot continue. The GHC runtime works around this by making use of full OS threads where necessary. When the program is built with the &lt;code&gt;-threaded&lt;/code&gt; option (to link against the multithreaded version of the runtime), a thread making a &lt;code&gt;safe&lt;/code&gt; foreign call will not block the other threads in the system; another OS thread will take over running Haskell threads until the original call returns. The runtime maintains a pool of these &lt;em&gt;worker&lt;/em&gt; threads so that multiple Haskell threads can be involved in external calls simultaneously.</source>
          <target state="translated">軽量スレッドの欠点は、一度に1つしか実行できないため、たとえば、あるスレッドが外部呼び出しでブロックされた場合、他のスレッドは続行できないということです。 GHCランタイムは、必要に応じて完全なOSスレッドを利用することにより、この問題を回避します。プログラムが &lt;code&gt;-threaded&lt;/code&gt; オプション（ランタイムのマルチスレッドバージョンに対してリンクする）を使用してビルドされている場合、 &lt;code&gt;safe&lt;/code&gt; 外部呼び出しを行うスレッドは、システム内の他のスレッドをブロックしません。元の呼び出しが戻るまで、別のOSスレッドが実行中のHaskellスレッドを引き継ぎます。ランタイムはこれらの&lt;em&gt;ワーカー&lt;/em&gt;スレッドのプールを維持するため、複数のHaskellスレッドが同時に外部呼び出しに関与できます。</target>
        </trans-unit>
        <trans-unit id="7e1ca2d2eeb59a37201caba0870b3b617ae2b6e7" translate="yes" xml:space="preserve">
          <source>The drag stage, which lasts from the final use until the last reference to the object is dropped.</source>
          <target state="translated">最後に使用してから、オブジェクトへの最後の参照が落とされるまで続くドラッグステージ。</target>
        </trans-unit>
        <trans-unit id="5112337835e0aaa1f4501d77e936abde1e9f5833" translate="yes" xml:space="preserve">
          <source>The dual of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;, obtained by swapping the arguments of &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; の双対 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; の引数を交換することによって取得されます。</target>
        </trans-unit>
        <trans-unit id="7fab6e06621905edcea476fea0795c21d73fe816" translate="yes" xml:space="preserve">
          <source>The dynamic binding constraints are just a new form of predicate in the type class system.</source>
          <target state="translated">動的結合制約は、型クラスシステムにおける新しい形の述語にすぎません。</target>
        </trans-unit>
        <trans-unit id="c9658faad340c4e37684884e4b4de1d55529e10f" translate="yes" xml:space="preserve">
          <source>The easiest way to see what &lt;code&gt;-O&lt;/code&gt; (etc.) &amp;ldquo;really mean&amp;rdquo; is to run with &lt;a href=&quot;using#ghc-flag--v&quot;&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/a&gt;, then stand back in amazement.</source>
          <target state="translated">&lt;code&gt;-O&lt;/code&gt; （など）が「本当に」意味することを確認する最も簡単な方法は、&lt;a href=&quot;using#ghc-flag--v&quot;&gt; &lt;code&gt;-v&lt;/code&gt; &lt;/a&gt;を指定して実行し、驚いて立ち戻ることです。</target>
        </trans-unit>
        <trans-unit id="9d5eb6a79829c0b2ad6433410a38b38fee844c58" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">空の &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ac8593ee22b444a0803d2615c08c3ad783eddab" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">空の &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffb10a0d9ca8c58bdee511053f10bf4fc11e9fd3" translate="yes" xml:space="preserve">
          <source>The empty document, with no height and no width. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is the identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt;, and anywhere in the argument list for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; etc.</source>
          <target state="translated">高さと幅のない空のドキュメント。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt; 、hcat、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; などの引数リストの任意の場所です。</target>
        </trans-unit>
        <trans-unit id="c38333a804d1c05d76e22c031e0de30532f2b0b2" translate="yes" xml:space="preserve">
          <source>The empty document, with no height and no width. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is the identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt;, and anywhere in the argument list for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; etc.</source>
          <target state="translated">高さと幅のない空のドキュメント。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt; 、hcat、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; などの引数リストの任意の場所です。</target>
        </trans-unit>
        <trans-unit id="57055327e0a4ff0414ff005dc9f2d958097b63a1" translate="yes" xml:space="preserve">
          <source>The empty document, with no height and no width. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is the identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt;, and anywhere in the argument list for &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; etc.</source>
          <target state="translated">高さと幅のない空のドキュメント。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt; 、hcat、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; などの引数リストの任意の場所です。</target>
        </trans-unit>
        <trans-unit id="322d102fb89074ac997d55fe8155256f83635242" translate="yes" xml:space="preserve">
          <source>The empty stream.</source>
          <target state="translated">空の流れ。</target>
        </trans-unit>
        <trans-unit id="aaade1a4c344a06009213d97ea6d90338497c9b0" translate="yes" xml:space="preserve">
          <source>The entire string prior to the &lt;em&gt;k&lt;/em&gt;th match (i.e. the prefix)</source>
          <target state="translated">&lt;em&gt;k&lt;/em&gt;番目に一致する前の文字列全体（つまり、プレフィックス）</target>
        </trans-unit>
        <trans-unit id="7e6880e4680eabaf9b865ccc3e11f4776c77ad73" translate="yes" xml:space="preserve">
          <source>The environment variable can also be set to the magical values &lt;code&gt;never&lt;/code&gt; or &lt;code&gt;always&lt;/code&gt;, which is equivalent to setting the corresponding &lt;code&gt;-fdiagnostics-color&lt;/code&gt; flag but with lower precedence.</source>
          <target state="translated">環境変数は、魔法の値 &lt;code&gt;never&lt;/code&gt; または &lt;code&gt;always&lt;/code&gt; に設定することもできます。これは、対応する &lt;code&gt;-fdiagnostics-color&lt;/code&gt; フラグを設定することと同等ですが、優先順位は低くなります。</target>
        </trans-unit>
        <trans-unit id="e95be2fe9b83d12508c00e4a3f425f900f860572" translate="yes" xml:space="preserve">
          <source>The environment variable name/value pairs. (TODO: encoding?)</source>
          <target state="translated">環境変数名/値のペア。(TODO:エンコード?)</target>
        </trans-unit>
        <trans-unit id="a78af08f35ea577d78dded305fcc5c4e9509b316" translate="yes" xml:space="preserve">
          <source>The epoch of TAI, which is 1858-11-17 00:00:00 TAI.</source>
          <target state="translated">1858-11-17 00:00:00 TAIのエポック。</target>
        </trans-unit>
        <trans-unit id="81943c20c210a66a07a8f11e6429a84649f3e7b2" translate="yes" xml:space="preserve">
          <source>The equality test in an overloaded numeric pattern uses whatever &lt;code&gt;(==)&lt;/code&gt; is in scope.</source>
          <target state="translated">オーバーロードされた数値パターンの等価テストでは、スコープ内にあるもの &lt;code&gt;(==)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="afd1105a178de8acf9d4f7264289cbff2eca2561" translate="yes" xml:space="preserve">
          <source>The equality types</source>
          <target state="translated">等価タイプ</target>
        </trans-unit>
        <trans-unit id="c36adceaaf4799a94ea7ebf3aee8bed0bb6f61c1" translate="yes" xml:space="preserve">
          <source>The equations are numbered starting from 0, and the comment after each equation refers to all preceding equations it is incompatible with.</source>
          <target state="translated">方程式には0から始まる番号が付けられており、各方程式の後のコメントは、それが互換性のない先行方程式をすべて参照しています。</target>
        </trans-unit>
        <trans-unit id="1199dfc965e5955380e63499fadc65f9cbd20ac3" translate="yes" xml:space="preserve">
          <source>The equivalent REPL example is:</source>
          <target state="translated">これに相当するREPLの例は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="7d39f7dfb145cb81010fc146adcc072a6753c454" translate="yes" xml:space="preserve">
          <source>The error message contains some clues as to the transformation happening internally.</source>
          <target state="translated">エラーメッセージには、内部で発生している変換に関するいくつかの手がかりが含まれています。</target>
        </trans-unit>
        <trans-unit id="59e467fc1987c039f09f1829c27318997a022a9d" translate="yes" xml:space="preserve">
          <source>The error monad transformer. It can be used to add error handling to other monads.</source>
          <target state="translated">エラーモナドの変換器です。他のモナドにエラー処理を追加するために使用できます。</target>
        </trans-unit>
        <trans-unit id="584676bca032e15cb39d4d01b07dc527b1765a4e" translate="yes" xml:space="preserve">
          <source>The errors that can be deferred are:</source>
          <target state="translated">延期できるエラーは</target>
        </trans-unit>
        <trans-unit id="53caa6a4eadedbc6b469bff64565461d1ccdfebf" translate="yes" xml:space="preserve">
          <source>The event manager state.</source>
          <target state="translated">イベントマネージャー状態。</target>
        </trans-unit>
        <trans-unit id="2743b97e9374251f3952bb86a616a8b6b2d9cbac" translate="yes" xml:space="preserve">
          <source>The event-log stream begins with a header describing the event types present in the file. The header is followed by the event records themselves, each of which consist of a 64-bit timestamp</source>
          <target state="translated">イベントログストリームは、ファイル内に存在するイベントタイプを記述するヘッダで始まる。ヘッダの後にイベントレコードが続き、それぞれのイベントレコードは64ビットのタイムスタンプ</target>
        </trans-unit>
        <trans-unit id="5f9ab52fbe55b01321892b7fd29ab1a98bb7681d" translate="yes" xml:space="preserve">
          <source>The example below shows quasi-quotation in action. The quoter &lt;code&gt;expr&lt;/code&gt; is bound to a value of type &lt;code&gt;QuasiQuoter&lt;/code&gt; defined in module &lt;code&gt;Expr&lt;/code&gt;. The example makes use of an antiquoted variable &lt;code&gt;n&lt;/code&gt;, indicated by the syntax &lt;code&gt;'int:n&lt;/code&gt; (this syntax for anti-quotation was defined by the parser&amp;rsquo;s author, &lt;em&gt;not&lt;/em&gt; by GHC). This binds &lt;code&gt;n&lt;/code&gt; to the integer value argument of the constructor &lt;code&gt;IntExpr&lt;/code&gt; when pattern matching. Please see the referenced paper for further details regarding anti-quotation as well as the description of a technique that uses SYB to leverage a single parser of type &lt;code&gt;String -&amp;gt; a&lt;/code&gt; to generate both an expression parser that returns a value of type &lt;code&gt;Q Exp&lt;/code&gt; and a pattern parser that returns a value of type &lt;code&gt;Q Pat&lt;/code&gt;.</source>
          <target state="translated">以下の例は、実際の準見積を示しています。クォータ &lt;code&gt;expr&lt;/code&gt; の型の値にバインドされ &lt;code&gt;QuasiQuoter&lt;/code&gt; はモジュールで定義された &lt;code&gt;Expr&lt;/code&gt; に。この例では、引用符で囲まれて&lt;em&gt;いない&lt;/em&gt;変数 &lt;code&gt;n&lt;/code&gt; を使用します。これは、構文 &lt;code&gt;'int:n&lt;/code&gt; （引用符を引用しないこの構文&lt;em&gt;は&lt;/em&gt;、GHC では&lt;em&gt;なく&lt;/em&gt;パーサーの作成者が定義したものです）によって&lt;em&gt;示さ&lt;/em&gt;れます。これは、パターンマッチング時に &lt;code&gt;n&lt;/code&gt; をコンストラクタ &lt;code&gt;IntExpr&lt;/code&gt; の整数値引数にバインドします。引用防止に関する詳細、およびSYBを使用して &lt;code&gt;String -&amp;gt; a&lt;/code&gt; 型の単一のパーサーを利用する手法の説明については、参考文献を参照してください-&amp;gt; aタイプ &lt;code&gt;Q Exp&lt;/code&gt; の値を返す式パーサーとタイプ &lt;code&gt;Q Pat&lt;/code&gt; の値を返すパターンパーサーの両方を生成します。</target>
        </trans-unit>
        <trans-unit id="e130d4a858cd5958b963d63c7fe21940f766b4ef" translate="yes" xml:space="preserve">
          <source>The exception itself is bound to a new variable, &lt;code&gt;_exception&lt;/code&gt;.</source>
          <target state="translated">例外自体は、新しい変数 &lt;code&gt;_exception&lt;/code&gt; にバインドされています。</target>
        </trans-unit>
        <trans-unit id="988d36edf500c18480e248b3ba03ea83da4d2cbf" translate="yes" xml:space="preserve">
          <source>The exception masking state of the executed action is inherited (c.f. &lt;code&gt;forkIO&lt;/code&gt;), see also &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; (&lt;em&gt;since: 2.7.0.0&lt;/em&gt;).</source>
          <target state="translated">実行されたアクションの例外マスキング状態は継承されます（ &lt;code&gt;forkIO&lt;/code&gt; を参照） &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; も参照してください（&lt;em&gt;以降：2.7.0.0&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="cc8f732aa9ca323261d4591444f25b148d16268f" translate="yes" xml:space="preserve">
          <source>The exception masking state of the executed action is inherited (c.f. &lt;code&gt;forkIO&lt;/code&gt;), see also &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; (&lt;em&gt;since: 2.7.0.0&lt;/em&gt;).</source>
          <target state="translated">実行されたアクションの例外マスキング状態は継承されます（ &lt;code&gt;forkIO&lt;/code&gt; を参照） &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; も参照してください（&lt;em&gt;以降：2.7.0.0&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="ebf03146e8f23e21eb8275358c982d6013264e4c" translate="yes" xml:space="preserve">
          <source>The exception thrown by &quot;fail&quot; in the GHCiQ monad</source>
          <target state="translated">GHCiQモナドの &quot;fail &quot;でスローされる例外</target>
        </trans-unit>
        <trans-unit id="ceefa01748ad0dcbb4f9adc6b0c343de52816f7c" translate="yes" xml:space="preserve">
          <source>The exception thrown when an infinite cycle is detected in &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; で無限サイクルが検出されたときにスローされる例外。</target>
        </trans-unit>
        <trans-unit id="e73e797f0aaf19c29e3a38b80b61adffd05c8530" translate="yes" xml:space="preserve">
          <source>The exception to this rule is that the context of a standalone deriving declaration can infer its context when a single, extra-wildcards constraint is used as the context, such as in:</source>
          <target state="translated">この規則の例外は、スタンドアロン導出宣言のコンテキストは、例えば in のように単一のエキストラワイルドカード制約がコンテキストとして使用されている場合に、そのコンテキストを推論することができます。</target>
        </trans-unit>
        <trans-unit id="2a9b0765cdd57857b495fa1668f0cbcf42055c10" translate="yes" xml:space="preserve">
          <source>The execution continued at the point it previously stopped, and has now stopped at the breakpoint for a second time.</source>
          <target state="translated">以前に停止したポイントで実行が継続され、現在は2回目のブレークポイントで停止しています。</target>
        </trans-unit>
        <trans-unit id="11953fb00b8ad70bb93132200530ed5421e8c22b" translate="yes" xml:space="preserve">
          <source>The exit status of a process</source>
          <target state="translated">プロセスの終了ステータス</target>
        </trans-unit>
        <trans-unit id="927dcdbea9e7b5ba6ac39897b83ff1c61f46b2d3" translate="yes" xml:space="preserve">
          <source>The expansion is purely syntactic, so the expanded right-hand side expression refers to the nearest enclosing variable that is spelled the same as the field name.</source>
          <target state="translated">展開は純粋に構文的なものなので、展開された右辺の式は、フィールド名と同じスペルの最も近い囲み変数を参照します。</target>
        </trans-unit>
        <trans-unit id="0bb43782d3d91d6c0cfe9ab486e0facf443af806" translate="yes" xml:space="preserve">
          <source>The expansion is purely syntactic, so the record wildcard expression refers to the nearest enclosing variables that are spelled the same as the omitted field names.</source>
          <target state="translated">展開は純粋に構文的なものなので、レコードのワイルドカード式は、省略されたフィールド名と同じスペルの最も近い囲み変数を参照します。</target>
        </trans-unit>
        <trans-unit id="6fa2123bab4a96fc3dff4e1405c75b76df70f413" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;(x `par` y)&lt;/code&gt;&lt;em&gt;sparks&lt;/em&gt; the evaluation of &lt;code&gt;x&lt;/code&gt; (to weak head normal form) and returns &lt;code&gt;y&lt;/code&gt;. Sparks are queued for execution in FIFO order, but are not executed immediately. If the runtime detects that there is an idle CPU, then it may convert a spark into a real thread, and run the new thread on the idle CPU. In this way the available parallelism is spread amongst the real CPUs.</source>
          <target state="translated">式 &lt;code&gt;(x `par` y)&lt;/code&gt; &lt;em&gt;火花&lt;/em&gt;の評価 &lt;code&gt;x&lt;/code&gt; （弱頭部正規形に）戻ると &lt;code&gt;y&lt;/code&gt; 。スパークはFIFO順に実行するためにキューに入れられますが、すぐには実行されません。ランタイムがアイドルCPUがあることを検出すると、スパークを実際のスレッドに変換し、アイドルCPUで新しいスレッドを実行します。このようにして、利用可能な並列処理が実際のCPUに分散されます。</target>
        </trans-unit>
        <trans-unit id="60035052d2f9f9dbcb2234d0c35b5862aef3671d" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;encodeUtf8CSV table&lt;/code&gt; results in the following lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;encodeUtf8CSV table&lt;/code&gt; は、次の遅延 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="5ec7656c8e0e128b3c718fea844b6924e7c9db92" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; creates a fresh permutation parser consisting of parser &lt;code&gt;p&lt;/code&gt;. The the final result of the permutation parser is the function &lt;code&gt;f&lt;/code&gt; applied to the return value of &lt;code&gt;p&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead.</source>
          <target state="translated">式 &lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; は、パーサー &lt;code&gt;p&lt;/code&gt; で構成される新しい順列パーサーを作成します。置換パーサーの最終結果は、 &lt;code&gt;p&lt;/code&gt; の戻り値に適用される関数 &lt;code&gt;f&lt;/code&gt; です。パーサー &lt;code&gt;p&lt;/code&gt; は空の入力を受け入れることができません- 代わりにオプションのコンビネーター（ &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）を使用してください。</target>
        </trans-unit>
        <trans-unit id="688562a46f3c26c92c14ba3e2ae41abc13cf015e" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; creates a fresh permutation parser consisting of parser &lt;code&gt;p&lt;/code&gt;. The the final result of the permutation parser is the function &lt;code&gt;f&lt;/code&gt; applied to the return value of &lt;code&gt;p&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead.</source>
          <target state="translated">式 &lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; は、パーサー &lt;code&gt;p&lt;/code&gt; で構成される新しい順列パーサーを作成します。置換パーサーの最終結果は、 &lt;code&gt;p&lt;/code&gt; の戻り値に適用される関数 &lt;code&gt;f&lt;/code&gt; です。パーサー &lt;code&gt;p&lt;/code&gt; は空の入力を受け入れることができません- 代わりにオプションのコンビネーター（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）を使用してください。</target>
        </trans-unit>
        <trans-unit id="133ce73b1396f38f1c484e835e97b17e44814c41" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;f &amp;lt;$?&amp;gt; (x,p)&lt;/code&gt; creates a fresh permutation parser consisting of parser &lt;code&gt;p&lt;/code&gt;. The the final result of the permutation parser is the function &lt;code&gt;f&lt;/code&gt; applied to the return value of &lt;code&gt;p&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is optional - if it can not be applied, the default value &lt;code&gt;x&lt;/code&gt; will be used instead.</source>
          <target state="translated">式 &lt;code&gt;f &amp;lt;$?&amp;gt; (x,p)&lt;/code&gt; は、パーサー &lt;code&gt;p&lt;/code&gt; で構成される新しい順列パーサーを作成します。順列パーサーの最終結果は、 &lt;code&gt;p&lt;/code&gt; の戻り値に適用される関数 &lt;code&gt;f&lt;/code&gt; です。パーサー &lt;code&gt;p&lt;/code&gt; はオプションです。適用できない場合は、代わりにデフォルト値 &lt;code&gt;x&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="8fb79b3e4e6a014a406705b86fa9c5b9e188c8b4" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;makeTokenParser language&lt;/code&gt; creates a &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; record that contains lexical parsers that are defined using the definitions in the &lt;code&gt;language&lt;/code&gt; record.</source>
          <target state="translated">式 &lt;code&gt;makeTokenParser language&lt;/code&gt; は、 &lt;code&gt;language&lt;/code&gt; レコードの定義を使用して定義された字句パーサーを含む &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; レコードを作成します。</target>
        </trans-unit>
        <trans-unit id="d2c369052f3c05736ed3d0aa835e5b9167fa8ef9" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;makeTokenParser language&lt;/code&gt; creates a &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; record that contains lexical parsers that are defined using the definitions in the &lt;code&gt;language&lt;/code&gt; record.</source>
          <target state="translated">式 &lt;code&gt;makeTokenParser language&lt;/code&gt; は、 &lt;code&gt;language&lt;/code&gt; レコードの定義を使用して定義された字句パーサーを含む &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; レコードを作成します。</target>
        </trans-unit>
        <trans-unit id="8b086207ac432a47ad80161d4b4db423c87b1bcf" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;parseTest p input&lt;/code&gt; applies a parser &lt;code&gt;p&lt;/code&gt; against input &lt;code&gt;input&lt;/code&gt; and prints the result to stdout. Used for testing parsers.</source>
          <target state="translated">式 &lt;code&gt;parseTest p input&lt;/code&gt; パーサ適用 &lt;code&gt;p&lt;/code&gt; 入力に対する &lt;code&gt;input&lt;/code&gt; と標準出力に結果を出力します。パーサーのテストに使用されます。</target>
        </trans-unit>
        <trans-unit id="7d09630aef55bc10a1cc5f993e20aa9d2c8fa633" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;perm &amp;lt;||&amp;gt; (x,p)&lt;/code&gt; adds parser &lt;code&gt;p&lt;/code&gt; to the permutation parser &lt;code&gt;perm&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is optional - if it can not be applied, the default value &lt;code&gt;x&lt;/code&gt; will be used instead. Returns a new permutation parser that includes the optional parser &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;perm &amp;lt;||&amp;gt; (x,p)&lt;/code&gt; は、パーサー &lt;code&gt;p&lt;/code&gt; を置換パーサー &lt;code&gt;perm&lt;/code&gt; に追加します。パーサー &lt;code&gt;p&lt;/code&gt; はオプションです。適用できない場合は、代わりにデフォルト値 &lt;code&gt;x&lt;/code&gt; が使用されます。オプションのパーサー &lt;code&gt;p&lt;/code&gt; を含む新しい順列パーサーを返します。</target>
        </trans-unit>
        <trans-unit id="9774c66620e8ebb6dc4947bd7a30ad32d4083961" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; adds parser &lt;code&gt;p&lt;/code&gt; to the permutation parser &lt;code&gt;perm&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead. Returns a new permutation parser that includes &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; は、パーサー &lt;code&gt;p&lt;/code&gt; を置換パーサー &lt;code&gt;perm&lt;/code&gt; に追加します。パーサー &lt;code&gt;p&lt;/code&gt; は空の入力を受け入れることができません- 代わりにオプションのコンビネーター（ &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）を使用してください。 &lt;code&gt;p&lt;/code&gt; を含む新しい置換パーサーを返します。</target>
        </trans-unit>
        <trans-unit id="c1eff7acfdc904aa55b95ecd8fd5d523b792b889" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; adds parser &lt;code&gt;p&lt;/code&gt; to the permutation parser &lt;code&gt;perm&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead. Returns a new permutation parser that includes &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; は、パーサー &lt;code&gt;p&lt;/code&gt; を置換パーサー &lt;code&gt;perm&lt;/code&gt; に追加します。パーサー &lt;code&gt;p&lt;/code&gt; は空の入力を受け入れることができません- 代わりにオプションのコンビネーター（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）を使用してください。 &lt;code&gt;p&lt;/code&gt; を含む新しい置換パーサーを返します。</target>
        </trans-unit>
        <trans-unit id="5b91ada54b3ba346f8466cd7a2f1f8bea7674bcd" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;s (t xs)&lt;/code&gt; does not match the rule &lt;code&gt;&quot;map/map&quot;&lt;/code&gt;, but GHC will substitute for &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt;, giving an expression which does match. If &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;t&lt;/code&gt; was (a) used more than once, and (b) large or a redex, then it would not be substituted, and the rule would not fire.</source>
          <target state="translated">式 &lt;code&gt;s (t xs)&lt;/code&gt; はルール &lt;code&gt;&quot;map/map&quot;&lt;/code&gt; と一致しませんが、GHCは &lt;code&gt;s&lt;/code&gt; と &lt;code&gt;t&lt;/code&gt; を置き換え、一致する式を提供します。場合は &lt;code&gt;s&lt;/code&gt; または &lt;code&gt;t&lt;/code&gt; （）複数回使用、及び（b）は、大規模または可約式た、それは置換されていない、および規則は火ではないであろう。</target>
        </trans-unit>
        <trans-unit id="efeb52340545b81120b442152fbbc21924dfa6d1" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;updatePosString pos s&lt;/code&gt; updates the source position &lt;code&gt;pos&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;text-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; on every character in &lt;code&gt;s&lt;/code&gt;, ie. &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;updatePosString pos s&lt;/code&gt; は、 &lt;code&gt;s&lt;/code&gt; のすべての文字で &lt;code&gt;&lt;a href=&quot;text-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; を呼び出すことにより、ソース位置 &lt;code&gt;pos&lt;/code&gt; を更新します。 &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a46b242264f8f265b934b320d1ad118b5d5d70f9" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;updatePosString pos s&lt;/code&gt; updates the source position &lt;code&gt;pos&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; on every character in &lt;code&gt;s&lt;/code&gt;, ie. &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;updatePosString pos s&lt;/code&gt; は、 &lt;code&gt;s&lt;/code&gt; のすべての文字で &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; を呼び出すことにより、ソース位置 &lt;code&gt;pos&lt;/code&gt; を更新します。 &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5483b1f876b299153ecdf0ce5e6d8239b22dcf61" translate="yes" xml:space="preserve">
          <source>The expression must be convertible to &lt;code&gt;long&lt;/code&gt; or &lt;code&gt;unsigned long&lt;/code&gt;. Its value (literal or negated literal) will be output.</source>
          <target state="translated">式は &lt;code&gt;long&lt;/code&gt; または &lt;code&gt;unsigned long&lt;/code&gt; に変換可能でなければなりません。その値（リテラルまたは否定されたリテラル）が出力されます。</target>
        </trans-unit>
        <trans-unit id="820e3f9e6884aadccb720549e1d4a6de8381de85" translate="yes" xml:space="preserve">
          <source>The expression must be convertible to const char pointer. Its value (string literal) will be output.</source>
          <target state="translated">式は const char ポインタに変換可能でなければなりません。その値(文字列リテラル)が出力されます。</target>
        </trans-unit>
        <trans-unit id="0a5b6e32463e5a84d94f6198a0b148bf41758e64" translate="yes" xml:space="preserve">
          <source>The expression you are annotating with must have a type with &lt;code&gt;Typeable&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; instances</source>
          <target state="translated">注釈を付ける式には、 &lt;code&gt;Typeable&lt;/code&gt; および &lt;code&gt;Data&lt;/code&gt; インスタンスを持つ型が必要です</target>
        </trans-unit>
        <trans-unit id="6a2b1973077b8ad117174952fdf79b72f3549905" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt;&lt;code&gt;ExplicitNamespaces&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt; and (for some reason) by &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">拡張&lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt; &lt;code&gt;ExplicitNamespaces&lt;/code&gt; &lt;/a&gt;は、&lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt;および（何らかの理由で）&lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt;によって暗黙的に指定されます。</target>
        </trans-unit>
        <trans-unit id="c2c1dd16b1be083ccd27c6c41c6082833199d042" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. You can switch it off again with &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;NoMonoLocalBinds&lt;/code&gt;&lt;/a&gt; but type inference becomes less predictable if you do so. (Read the papers!)</source>
          <target state="translated">拡張&lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; &lt;/a&gt;は、&lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;によって暗示されます。&lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;NoMonoLocalBinds&lt;/code&gt; を使用&lt;/a&gt;して再度オフにすることができますが、そうすると、型推論の予測が難しくなります。 （論文を読んでください！）</target>
        </trans-unit>
        <trans-unit id="56045ff1bf81ad580973e6c5e5797cb6699258d1" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. You can switch it off again with &lt;code&gt;NoMonoLocalBinds&lt;/code&gt; but type inference becomes less predictable if you do so. (Read the papers!)</source>
          <target state="translated">拡張&lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;によって暗示されています。 &lt;code&gt;NoMonoLocalBinds&lt;/code&gt; を使用して再度オフにすることができますが、そうすると、型の推論の予測が難しくなります。（論文を読んでください！）</target>
        </trans-unit>
        <trans-unit id="6edfbf43884f0659ca2c3eed2dacc284530ca4be" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-QuantifiedConstraints&quot;&gt;&lt;code&gt;QuantifiedConstraints&lt;/code&gt;&lt;/a&gt; introduces &lt;strong&gt;quantified constraints&lt;/strong&gt;, which give a new level of expressiveness in constraints. For example, consider</source>
          <target state="translated">拡張&lt;a href=&quot;#extension-QuantifiedConstraints&quot;&gt; &lt;code&gt;QuantifiedConstraints&lt;/code&gt; は、数量化&lt;/a&gt;さ&lt;strong&gt;れた制約を&lt;/strong&gt;導入します。これ&lt;strong&gt;により&lt;/strong&gt;、&lt;strong&gt;制約&lt;/strong&gt;に新しいレベルの表現力が与えられます。たとえば、</target>
        </trans-unit>
        <trans-unit id="5a1fbd6833d7bf7f6b464ba5557bf0f418ef8516" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-RecursiveDo&quot;&gt;&lt;code&gt;RecursiveDo&lt;/code&gt;&lt;/a&gt; also introduces a new keyword &lt;code&gt;rec&lt;/code&gt;, which wraps a mutually-recursive group of monadic statements inside a &lt;code&gt;do&lt;/code&gt; expression, producing a single statement. Similar to a &lt;code&gt;let&lt;/code&gt; statement inside a &lt;code&gt;do&lt;/code&gt;, variables bound in the &lt;code&gt;rec&lt;/code&gt; are visible throughout the &lt;code&gt;rec&lt;/code&gt; group, and below it. For example, compare</source>
          <target state="translated">拡張&lt;a href=&quot;#extension-RecursiveDo&quot;&gt; &lt;code&gt;RecursiveDo&lt;/code&gt; &lt;/a&gt;には、新しいキーワード &lt;code&gt;rec&lt;/code&gt; も導入されています。これは、相互再帰的なモナディックステートメントのグループを &lt;code&gt;do&lt;/code&gt; 式内にラップして、単一のステートメントを生成します。 &lt;code&gt;do&lt;/code&gt; 内の &lt;code&gt;let&lt;/code&gt; ステートメントと同様に、 &lt;code&gt;rec&lt;/code&gt; にバインドされた変数は、 &lt;code&gt;rec&lt;/code&gt; グループ全体とその下に表示されます。たとえば、比較</target>
        </trans-unit>
        <trans-unit id="2340bd5004afb06c66885f9f37fdc1ab908eab6d" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-TypeInType&quot;&gt;&lt;code&gt;TypeInType&lt;/code&gt;&lt;/a&gt; is now deprecated: its sole effect is to switch on &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; (and hence &lt;a href=&quot;#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;) and &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">拡張&lt;a href=&quot;#extension-TypeInType&quot;&gt; &lt;code&gt;TypeInType&lt;/code&gt; &lt;/a&gt;は非推奨になりました。その唯一の効果は、&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;（したがって&lt;a href=&quot;#extension-KindSignatures&quot;&gt; &lt;code&gt;KindSignatures&lt;/code&gt; &lt;/a&gt;）と&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; をオンにすること&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="5d7aee131ad6d19c93d8e0e5cef004d81b83103a" translate="yes" xml:space="preserve">
          <source>The extension adds a new kind of expression for defining arrows:</source>
          <target state="translated">この拡張機能では、矢印を定義するための新しい種類の式が追加されました。</target>
        </trans-unit>
        <trans-unit id="68fc04e40e72e9a26d6e832da587e68cf89dce71" translate="yes" xml:space="preserve">
          <source>The extension does not extend to the left-hand side of function definitions; you must define such a function in prefix form.</source>
          <target state="translated">この拡張機能は関数定義の左側には適用されません。</target>
        </trans-unit>
        <trans-unit id="ad6ad2707106caf932a9bcc6bc55d2c587ffc598" translate="yes" xml:space="preserve">
          <source>The extension is enabled with the extension &lt;a href=&quot;#extension-TransformListComp&quot;&gt;&lt;code&gt;TransformListComp&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">拡張は、拡張&lt;a href=&quot;#extension-TransformListComp&quot;&gt; &lt;code&gt;TransformListComp&lt;/code&gt; で&lt;/a&gt;有効になります。</target>
        </trans-unit>
        <trans-unit id="592f0075b3be7dea40fca2f7b78b5f78b8bee1db" translate="yes" xml:space="preserve">
          <source>The extension only affects definitions in this module.</source>
          <target state="translated">この拡張機能は、このモジュール内の定義にのみ影響を与えます。</target>
        </trans-unit>
        <trans-unit id="dbed722a20b0c81708629361d2e36ddb255e740e" translate="yes" xml:space="preserve">
          <source>The fact that as many elements as possible are translated is used by the IO library in order to report translation errors at the point they actually occur, rather than when the buffer is translated.</source>
          <target state="translated">できるだけ多くの要素が翻訳されているという事実は、バッファが翻訳されたときではなく、実際に発生した時点で翻訳エラーを報告するために IO ライブラリによって使用されます。</target>
        </trans-unit>
        <trans-unit id="c9688a61970d69ede4ef28783b4cdd7a6fa982ec" translate="yes" xml:space="preserve">
          <source>The field width is a minimum, not a maximum: it will be expanded as needed to avoid mutilating a value.</source>
          <target state="translated">フ ィ ール ド 幅は最小値であ り 、 最大値ではあ り ません。</target>
        </trans-unit>
        <trans-unit id="766dc6dc2e472365cee52e53c97df5ee0cb680d9" translate="yes" xml:space="preserve">
          <source>The fields in &lt;code&gt;Trade&lt;/code&gt; are marked as strict (using &lt;code&gt;!&lt;/code&gt;) since we don't need laziness here. In practise, you would probably consider using the UNPACK pragma as well. &lt;a href=&quot;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&quot;&gt;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&lt;/a&gt;</source>
          <target state="translated">ここでは遅延を必要としないため、 &lt;code&gt;Trade&lt;/code&gt; のフィールドは（ &lt;code&gt;!&lt;/code&gt; を使用して）厳格としてマークされています。実際には、おそらくUNPACKプラグマの使用も検討するでしょう。&lt;a href=&quot;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&quot;&gt;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5972e4dbbb1da0195c707d37fda525d476ee44e9" translate="yes" xml:space="preserve">
          <source>The fields of &lt;code&gt;ExampleConstructor&lt;/code&gt; have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceStrictness&quot;&gt;NoSourceStrictness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceLazy&quot;&gt;SourceLazy&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceStrict&quot;&gt;SourceStrict&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">分野 &lt;code&gt;ExampleConstructor&lt;/code&gt; は持って &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceStrictness&quot;&gt;NoSourceStrictness&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceLazy&quot;&gt;SourceLazy&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceStrict&quot;&gt;SourceStrict&lt;/a&gt;&lt;/code&gt; をそれぞれ。</target>
        </trans-unit>
        <trans-unit id="90aff6649fd9e503bb0cd5dab7faab1470bbcfc9" translate="yes" xml:space="preserve">
          <source>The fields of &lt;code&gt;ExampleConstructor&lt;/code&gt; have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceUnpackedness&quot;&gt;NoSourceUnpackedness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceNoUnpack&quot;&gt;SourceNoUnpack&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceUnpack&quot;&gt;SourceUnpack&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">分野 &lt;code&gt;ExampleConstructor&lt;/code&gt; は持って &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceUnpackedness&quot;&gt;NoSourceUnpackedness&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceNoUnpack&quot;&gt;SourceNoUnpack&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceUnpack&quot;&gt;SourceUnpack&lt;/a&gt;&lt;/code&gt; をそれぞれ。</target>
        </trans-unit>
        <trans-unit id="867052d71989ead15b5268bf62e49c7c19eae92d" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;A.hs-boot&lt;/code&gt; is a programmer-written source file. It must live in the same directory as its parent source file &lt;code&gt;A.hs&lt;/code&gt;. Currently, if you use a literate source file &lt;code&gt;A.lhs&lt;/code&gt; you must also use a literate boot file, &lt;code&gt;A.lhs-boot&lt;/code&gt;; and vice versa.</source>
          <target state="translated">ファイル &lt;code&gt;A.hs-boot&lt;/code&gt; は、プログラマーが作成したソースファイルです。親ソースファイル &lt;code&gt;A.hs&lt;/code&gt; と同じディレクトリに存在する必要があります。現在、 &lt;code&gt;A.lhs&lt;/code&gt; なソースファイルA.lhsを使用する場合は、 &lt;code&gt;A.lhs-boot&lt;/code&gt; なブートファイルA.lhs-bootも使用する必要があります。およびその逆。</target>
        </trans-unit>
        <trans-unit id="9a674c835d28bfb6d72a5275286859913c1e00bf" translate="yes" xml:space="preserve">
          <source>The file contains package IDs and optionally package databases, one directive per line:</source>
          <target state="translated">このファイルには、パッケージ ID と、オプションでパッケージデータベースが含まれており、1 行に 1 つのディレクティブが含まれています。</target>
        </trans-unit>
        <trans-unit id="d3dad592ba2c56d2ff45ef3e10379f2cd7056cb1" translate="yes" xml:space="preserve">
          <source>The file descriptor is ready to accept a write.</source>
          <target state="translated">ファイルディスクリプタは書き込みを受け付ける準備ができています。</target>
        </trans-unit>
        <trans-unit id="0a87aafdf7c80c25cee8605761116960c822dc15" translate="yes" xml:space="preserve">
          <source>The file is created with permissions such that only the current user can read/write it.</source>
          <target state="translated">ファイルは、現在のユーザーのみが読み書きできるようなパーミッションで作成されています。</target>
        </trans-unit>
        <trans-unit id="cfb39651c9d8c9724affb75edf0166a16b2ab2da" translate="yes" xml:space="preserve">
          <source>The file-header pragmas are: &lt;code&gt;{-# LANGUAGE #-}&lt;/code&gt;, &lt;code&gt;{-# OPTIONS_GHC #-}&lt;/code&gt;, and &lt;code&gt;{-# INCLUDE #-}&lt;/code&gt;.</source>
          <target state="translated">ファイルヘッダープラグマは、 &lt;code&gt;{-# LANGUAGE #-}&lt;/code&gt; 、 &lt;code&gt;{-# OPTIONS_GHC #-}&lt;/code&gt; 、および &lt;code&gt;{-# INCLUDE #-}&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6ce398b5e4e0b12caa271926c6711a527e411174" translate="yes" xml:space="preserve">
          <source>The final build step that returns the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; signal.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; 信号を返す最後のビルドステップ。</target>
        </trans-unit>
        <trans-unit id="87005632e427f20e49e6f8bedc0a39a36ece9f40" translate="yes" xml:space="preserve">
          <source>The final bullet (about unifiying instances) makes GHC conservative about committing to an overlapping instance. For example:</source>
          <target state="translated">最後の箇条書き(インスタンスの単一化について)では、重複するインスタンスにコミットすることについてGHCを保守的にしています。例えば</target>
        </trans-unit>
        <trans-unit id="1913f6cc3ff526a515670ed4f1b49aa9b4f8a2bf" translate="yes" xml:space="preserve">
          <source>The final form is just what we want: a simple case expression.</source>
          <target state="translated">最終的な形は、私たちが求めているもの、つまりシンプルな大文字小文字の表現です。</target>
        </trans-unit>
        <trans-unit id="f7d925c1be71fce63599be5c5644561348c21d6e" translate="yes" xml:space="preserve">
          <source>The final layout will be something like</source>
          <target state="translated">最終的なレイアウトは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="509bc33604e7ee8a244ab55cc215005d17244214" translate="yes" xml:space="preserve">
          <source>The finalizer is given the local type environment at the splice point. Thus &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reify&quot;&gt;reify&lt;/a&gt;&lt;/code&gt; is able to find the local definitions when executed inside the finalizer.</source>
          <target state="translated">ファイナライザには、スプライスポイントでローカルタイプ環境が与えられます。したがって、ファイナライザ内で実行すると、 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reify&quot;&gt;reify&lt;/a&gt;&lt;/code&gt; はローカル定義を見つけることができます。</target>
        </trans-unit>
        <trans-unit id="147a1899cc99c9241165663b9d1797441102fedd" translate="yes" xml:space="preserve">
          <source>The finalizer, and the relationship between the key and the value, exist regardless of whether the program keeps a reference to the &lt;code&gt;&lt;a href=&quot;ghc-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; object or not.</source>
          <target state="translated">ファイナライザ、およびキーと値の関係は、プログラムが &lt;code&gt;&lt;a href=&quot;ghc-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; オブジェクトへの参照を保持するかどうかに関係なく存在します。</target>
        </trans-unit>
        <trans-unit id="d9f13e14cac52cb8d1ac6c69d4a111452644d3b2" translate="yes" xml:space="preserve">
          <source>The finalizer, and the relationship between the key and the value, exist regardless of whether the program keeps a reference to the &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; object or not.</source>
          <target state="translated">ファイナライザ、およびキーと値の関係は、プログラムが &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; オブジェクトへの参照を保持するかどうかに関係なく存在します。</target>
        </trans-unit>
        <trans-unit id="deaaee000865e026093bdaeb2c9fc2020dfc3055" translate="yes" xml:space="preserve">
          <source>The fine distinction between different kinds of parse errors allows the system to generate quite good error messages for the user. It also allows error messages that are formatted in different languages. Each kind of message is generated by different combinators:</source>
          <target state="translated">異なる種類のパースエラーを細かく区別することで、システムはユーザーにとって非常に良いエラーメッセージを生成することができます。また、異なる言語でフォーマットされたエラーメッセージを生成することもできます。それぞれの種類のメッセージは、異なるコンビネータによって生成されます。</target>
        </trans-unit>
        <trans-unit id="c672354048c81f22453abece53dcb4410b87ec06" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; argument is the contents of the line to the left of the cursor, reversed. The second &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; argument is the contents of the line to the right of the cursor.</source>
          <target state="translated">最初の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 引数は、カーソルの左側の行の内容を逆にしたものです。2番目の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 引数は、カーソルの右側の行の内容です。</target>
        </trans-unit>
        <trans-unit id="d34b4a39f6372f80e7ab6dab2763aad3974a8747" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; argument is the contents of the line to the left of the cursor, reversed. The second &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; argument is the contents of the line to the right of the cursor.</source>
          <target state="translated">最初の &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 引数は、カーソルの左側の行の内容を逆にしたものです。2番目の &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 引数は、カーソルの右側の行の内容です。</target>
        </trans-unit>
        <trans-unit id="e20d358fcdcc868c8bd11a6755028db0bb2e37f3" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;Int32&lt;/code&gt; is for the tag. There are two &lt;code&gt;Float32&lt;/code&gt; fields because floating point types can&amp;rsquo;t overlap with other types, because of limitations of the code generator that we&amp;rsquo;re hoping to overcome in the future. The second alternative needs two &lt;code&gt;Float32&lt;/code&gt; fields: The &lt;code&gt;Word32&lt;/code&gt; field is for the &lt;code&gt;Word32#&lt;/code&gt; in the first alternative. The &lt;code&gt;Pointer&lt;/code&gt; field is shared between &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Maybe Int&lt;/code&gt; values of the alternatives.</source>
          <target state="translated">最初の &lt;code&gt;Int32&lt;/code&gt; はタグ用です。浮動小数点型は他の型と重複できないため、2つの &lt;code&gt;Float32&lt;/code&gt; フィールドがあります。これは、将来克服したいコードジェネレーターの制限のためです。2番目の選択肢には2つの &lt;code&gt;Float32&lt;/code&gt; フィールドが必要です &lt;code&gt;Word32&lt;/code&gt; フィールドは、最初の選択肢の &lt;code&gt;Word32#&lt;/code&gt; 用です。 &lt;code&gt;Pointer&lt;/code&gt; フィールドが間で共有される &lt;code&gt;String&lt;/code&gt; と &lt;code&gt;Maybe Int&lt;/code&gt; 選択肢の値。</target>
        </trans-unit>
        <trans-unit id="349930f2f6ac001a1f1d9bc41ac40db08cbf14ec" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;(l,u)&lt;/code&gt; of each of these operations is a pair specifying the lower and upper bounds of a contiguous subrange of values.</source>
          <target state="translated">これらの各演算の最初の引数 &lt;code&gt;(l,u)&lt;/code&gt; は、値の連続する部分範囲の下限と上限を指定するペアです。</target>
        </trans-unit>
        <trans-unit id="da354ca0b85aa26c68bc2b60c29e2527cd434859" translate="yes" xml:space="preserve">
          <source>The first bullet simply means that the dependency must be well-scoped. The second bullet concerns GHC&amp;rsquo;s ability to infer dependency. Inferring this dependency is difficult, and GHC currently requires the dependency to be made explicit, meaning that &lt;code&gt;k&lt;/code&gt; must appear in the kind of a type variable, making it obvious to GHC that dependency is intended. For example:</source>
          <target state="translated">最初の箇条書きは、依存関係が適切にスコープされている必要があることを単に意味します。2番目の箇条書きは、依存性を推論するGHCの機能に関係しています。この依存関係を推測することは困難であり、GHCは現在、依存関係を明示的にする必要があります。つまり、 &lt;code&gt;k&lt;/code&gt; は型変数の種類に出現する必要があり、依存関係が意図されていることをGHCに明らかにします。例えば：</target>
        </trans-unit>
        <trans-unit id="5990c2111448ff95032208b84313c09eb4e8e7c7" translate="yes" xml:space="preserve">
          <source>The first clause of &amp;ldquo;compatible&amp;rdquo; is the more straightforward one. It says that the patterns of two distinct type family instances cannot overlap. For example, the following is disallowed:</source>
          <target state="translated">「互換性」の最初の条項は、より簡単なものです。これは、2つの異なるタイプファミリーインスタンスのパターンは重複できないことを示しています。たとえば、以下は許可されていません。</target>
        </trans-unit>
        <trans-unit id="0d05ff555d4b0984db447de192b3bf9a34809e33" translate="yes" xml:space="preserve">
          <source>The first component of &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt;, scaled to lie in the open interval (&lt;code&gt;-1&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt;), either &lt;code&gt;0.0&lt;/code&gt; or of absolute value &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix. The behaviour is unspecified on infinite or &lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">第一の成分 &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; 開区間（に位置するようにスケーリングされ、 &lt;code&gt;-1&lt;/code&gt; 、 &lt;code&gt;1&lt;/code&gt; のいずれか）、 &lt;code&gt;0.0&lt;/code&gt; または絶対値の &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 浮動小数点基数です。動作は、無限または &lt;code&gt;NaN&lt;/code&gt; 値では指定されていません。</target>
        </trans-unit>
        <trans-unit id="f4f7b2948c8c1ae005bcea73d45f0bbfbc9162d6" translate="yes" xml:space="preserve">
          <source>The first component of &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt;, scaled to lie in the open interval (&lt;code&gt;-1&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt;), either &lt;code&gt;0.0&lt;/code&gt; or of absolute value &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix. The behaviour is unspecified on infinite or &lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">第一の成分 &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; 開区間（に位置するようにスケーリングされ、 &lt;code&gt;-1&lt;/code&gt; 、 &lt;code&gt;1&lt;/code&gt; のいずれか）、 &lt;code&gt;0.0&lt;/code&gt; または絶対値の &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 浮動小数点基数です。動作は、無限または &lt;code&gt;NaN&lt;/code&gt; 値では指定されていません。</target>
        </trans-unit>
        <trans-unit id="7a78b840c5ec7a8bd0522ac73f6d9db7e7f7c6e2" translate="yes" xml:space="preserve">
          <source>The first constructor consists of a single field, which is the parameter &lt;code&gt;a&lt;/code&gt;. This is represented as &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; a&lt;/code&gt;.</source>
          <target state="translated">最初のコンストラクタは、パラメータ &lt;code&gt;a&lt;/code&gt; である単一のフィールドで構成されています。これは &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; a&lt;/code&gt; として表されます。</target>
        </trans-unit>
        <trans-unit id="a491a7e0c75f57c1c82c6779842a217b78376985" translate="yes" xml:space="preserve">
          <source>The first element of the returned tuple is the prefix of &lt;code&gt;haystack&lt;/code&gt; up to and including the last match of &lt;code&gt;needle&lt;/code&gt;. The second is the remainder of &lt;code&gt;haystack&lt;/code&gt;, following the match.</source>
          <target state="translated">返されるタプルの最初の要素は、 &lt;code&gt;needle&lt;/code&gt; の最後の一致までの &lt;code&gt;haystack&lt;/code&gt; のプレフィックスです。2番目は、マッチに続く &lt;code&gt;haystack&lt;/code&gt; の残りの部分です。</target>
        </trans-unit>
        <trans-unit id="d48cef11152d7e2e71a8b3fb779c57c59642ed57" translate="yes" xml:space="preserve">
          <source>The first example from that paper is set out below (&lt;a href=&quot;#th-example&quot;&gt;A Template Haskell Worked Example&lt;/a&gt;) as a worked example to help get you started.</source>
          <target state="translated">その論文の最初の例は、あなたが始めるのに役立つ&lt;a href=&quot;#th-example&quot;&gt;実用的な例&lt;/a&gt;として以下に示されています（テンプレートHaskellの実用的な例）。</target>
        </trans-unit>
        <trans-unit id="9f5e8571c06e192e03c26745db1bf9e5167e5bff" translate="yes" xml:space="preserve">
          <source>The first example is a parser monad in the style of</source>
          <target state="translated">最初の例は</target>
        </trans-unit>
        <trans-unit id="0db21633e5e7584a4e85ed5e4b67955d4a3ea721" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">最初の例では例外 &lt;code&gt;e&lt;/code&gt; が発生しますが、2番目の例では発生しません。実際、 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナド内で使用された場合にのみ例外を発生させます。 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; の変異体はに優先して使用する必要があります &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 以内に例外を発生させる &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; のそれが他方に対して順序を保証しているためモナド &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; の操作に対し、 &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; しません。</target>
        </trans-unit>
        <trans-unit id="00faf7d78a638c92e98de0c4bd577d041551012a" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">最初の例では例外 &lt;code&gt;e&lt;/code&gt; が発生しますが、2番目の例では発生しません。実際、 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; モナド内で使用された場合にのみ例外を発生させます。 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; の変異体はに優先して使用する必要があります &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 以内に例外を発生させる &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; それが他方に対して順序を保証しているためモナド &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; の操作に対し、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; しません。</target>
        </trans-unit>
        <trans-unit id="7a9264a11b232afb865bd5a70544aaa9c229ee38" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">最初の例では例外 &lt;code&gt;e&lt;/code&gt; が発生しますが、2番目の例では発生しません。実際、 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; モナド内で使用された場合にのみ例外を発生させます。 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; の変異体はに優先して使用する必要があります &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 以内に例外を発生させる &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; それが他方に対して順序を保証しているためモナド &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; の操作に対し、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; しません。</target>
        </trans-unit>
        <trans-unit id="8f3e5d2c79d3a07179c61145b801c7f34f1307d5" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">最初の例では例外 &lt;code&gt;e&lt;/code&gt; が発生しますが、2番目の例では発生しません。実際、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; モナド内で使用された場合にのみ例外を発生させます。 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; の変異体はに優先して使用する必要があります &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 以内に例外を発生させる &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; それが他方に対して順序を保証しているためモナド &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; の操作に対し、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; しません。</target>
        </trans-unit>
        <trans-unit id="00088afbc5cbb44faba064e52d1c85ccc7ca138f" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">最初の例では例外 &lt;code&gt;e&lt;/code&gt; が発生しますが、2番目の例では発生しません。実際、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; モナド内で使用された場合にのみ例外を発生させます。 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; の変異体はに優先して使用する必要があります &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 以内に例外を発生させる &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; それが他方に対して順序を保証しているためモナド &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; の操作に対し、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; しません。</target>
        </trans-unit>
        <trans-unit id="7ed74d4567fdb2bf2c77234153b706fdcff07852" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">最初の例では例外 &lt;code&gt;e&lt;/code&gt; が発生しますが、2番目の例では発生しません。実際、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; モナド内で使用された場合にのみ例外を発生させます。 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; の変異体はに優先して使用する必要があります &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 以内に例外を発生させる &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; それが他方に対して順序を保証しているためモナド &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; の操作に対し、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; しません。</target>
        </trans-unit>
        <trans-unit id="d99c86cee59c7b0e9addd7c9710d9c1d2d607961" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">最初の例では例外 &lt;code&gt;e&lt;/code&gt; が発生しますが、2番目の例では発生しません。実際、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; モナド内で使用された場合にのみ例外を発生させます。 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; の変異体はに優先して使用する必要があります &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 以内に例外を発生させる &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; それが他方に対して順序を保証しているためモナド &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; の操作に対し、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; しません。</target>
        </trans-unit>
        <trans-unit id="61f2b73f50ebef4a57359acc8a1b5ae0989d7aec" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">最初の例では例外 &lt;code&gt;e&lt;/code&gt; が発生しますが、2番目の例では発生しません。実際、 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナド内で使用された場合にのみ例外を発生させます。 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; の変異体はに優先して使用する必要があります &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 以内に例外を発生させる &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; のそれが他方に対して順序を保証しているためモナド &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; の操作に対し、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; しません。</target>
        </trans-unit>
        <trans-unit id="b34efd21f2daa7d49fe1224a63934d829e838b06" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">最初の例では例外 &lt;code&gt;e&lt;/code&gt; が発生しますが、2番目の例では発生しません。実際、 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナド内で使用された場合にのみ例外を発生させます。 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; の変異体はに優先して使用する必要があります &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 以内に例外を発生させる &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; のそれが他方に対して順序を保証しているためモナド &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; の操作に対し、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; しません。</target>
        </trans-unit>
        <trans-unit id="c46e0719305fcb7afbedd529b28ef7ed1317a3e9" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">最初の例では例外 &lt;code&gt;e&lt;/code&gt; が発生しますが、2番目の例では発生しません。実際、 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナド内で使用された場合にのみ例外を発生させます。 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; の変異体はに優先して使用する必要があります &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 以内に例外を発生させる &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; のそれが他方に対して順序を保証しているためモナド &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; の操作に対し、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; しません。</target>
        </trans-unit>
        <trans-unit id="2d90a57ad5eaafaf589120d5639047d2ad20009e" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">最初の例では例外 &lt;code&gt;e&lt;/code&gt; が発生しますが、2番目の例では発生しません。実際、 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナド内で使用された場合にのみ例外を発生させます。 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; の変異体はに優先して使用する必要があります &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 以内に例外を発生させる &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; のそれが他方に対して順序を保証しているためモナド &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; の操作に対し、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; しません。</target>
        </trans-unit>
        <trans-unit id="8377e7f947ca82c2d03b9e96804a9cc74da945a8" translate="yes" xml:space="preserve">
          <source>The first form declares that &lt;code&gt;f&lt;/code&gt; is a (pure) C function that takes no arguments and returns a pointer to a C function with type &lt;code&gt;t&lt;/code&gt;, whereas the second form declares that &lt;code&gt;f&lt;/code&gt; itself is a C function with type &lt;code&gt;t&lt;/code&gt;. The first declaration is usually a mistake, and one that is hard to debug because it results in a crash, hence this warning.</source>
          <target state="translated">最初の形式は、 &lt;code&gt;f&lt;/code&gt; が引数を取らず、 &lt;code&gt;t&lt;/code&gt; 型のC関数へのポインターを返す（純粋な）C関数であることを宣言し、2番目の形式は、 &lt;code&gt;f&lt;/code&gt; 自体が &lt;code&gt;t&lt;/code&gt; 型のC関数であることを宣言します。最初の宣言は通常は間違いであり、クラッシュを引き起こすためデバッグが難しいため、この警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="b437c04b578dcbe34c5b61a20dafa47889b4aaf9" translate="yes" xml:space="preserve">
          <source>The first four lines (&lt;code&gt;JOB&lt;/code&gt;, &lt;code&gt;DATE&lt;/code&gt;, &lt;code&gt;SAMPLE_UNIT&lt;/code&gt;, &lt;code&gt;VALUE_UNIT&lt;/code&gt;) form a header. Each block of lines starting with &lt;code&gt;BEGIN_SAMPLE&lt;/code&gt; and ending with &lt;code&gt;END_SAMPLE&lt;/code&gt; forms a single sample (you can think of this as a vertical slice of your heap profile). The hp2ps utility should accept any input with a properly-formatted header followed by a series of &lt;em&gt;complete&lt;/em&gt; samples.</source>
          <target state="translated">最初の4行（ &lt;code&gt;JOB&lt;/code&gt; 、 &lt;code&gt;DATE&lt;/code&gt; 、 &lt;code&gt;SAMPLE_UNIT&lt;/code&gt; 、 &lt;code&gt;VALUE_UNIT&lt;/code&gt; ）はヘッダーを形成します。行で始まるの各ブロック &lt;code&gt;BEGIN_SAMPLE&lt;/code&gt; で終わる &lt;code&gt;END_SAMPLE&lt;/code&gt; は（あなたがあなたのヒーププロファイルの垂直スライスと考えることができます）単一のサンプルを形成しています。 hp2psユーティリティは、適切にフォーマットされたヘッダーとそれに続く一連の&lt;em&gt;完全な&lt;/em&gt;サンプルを含むすべての入力を受け入れる必要があります。</target>
        </trans-unit>
        <trans-unit id="c2b82a03029ef67f0b50718409c503eea389a692" translate="yes" xml:space="preserve">
          <source>The first letter of the input is converted to title case, as is every subsequent letter that immediately follows a non-letter. Every letter that immediately follows another letter is converted to lower case.</source>
          <target state="translated">入力の最初の文字はタイトルケースに変換され、それ以外の文字の直後に続くすべての文字はタイトルケースに変換されます。他の文字の直後に続く文字はすべて小文字に変換されます。</target>
        </trans-unit>
        <trans-unit id="63efb85344c0aa9c20ebac363da48aba559537ad" translate="yes" xml:space="preserve">
          <source>The first matching axiom we encounter while entailing &lt;code&gt;C a&lt;/code&gt;, is &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt;. We have a local axiom &lt;code&gt;B a&lt;/code&gt; available, so now the program is suddenly accepted. This behaviour, where the ordering of an instance context determines whether or not the program is accepted, seems rather confusing for the developer.</source>
          <target state="translated">&lt;code&gt;C a&lt;/code&gt; を伴うときに最初に一致する公理は、 &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt; です。ローカル公理 &lt;code&gt;B a&lt;/code&gt; があるので、プログラムは突然受け入れられました。インスタンスコンテキストの順序がプログラムを受け入れるかどうかを決定するこの動作は、開発者を混乱させます。</target>
        </trans-unit>
        <trans-unit id="0123b61d2574afe7df7113981a9973c5d86d2592" translate="yes" xml:space="preserve">
          <source>The first most common step is the concatenation of two &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. Internally, concatenation corresponds to function composition. (Note that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s can be seen as difference-lists of buffer-filling functions; cf. &lt;a href=&quot;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&quot;&gt;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&lt;/a&gt;. ) Function composition is a fast O(1) operation. However, we can use bounded primitives to remove some of these function compositions altogether, which is more efficient.</source>
          <target state="translated">最初の最も一般的な手順は、2つの &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; を連結することです。内部的には、連結は関数構成に対応します。（ &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; は、バッファーを埋める関数の差分リストと見なすことができることに注意して&lt;a href=&quot;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&quot;&gt;ください。http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlistを&lt;/a&gt;参照してください。）関数構成は高速O（ 1）操作。ただし、制限付きプリミティブを使用して、これらの関数構成の一部を完全に削除できます。これはより効率的です。</target>
        </trans-unit>
        <trans-unit id="2b6aa4f035d3b73aa4ab4041c788e09ed98100cf" translate="yes" xml:space="preserve">
          <source>The first of the &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; operations, &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ask&quot;&gt;ask&lt;/a&gt;&lt;/code&gt;, is a simple action, so we can lift it through &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;InterpM&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; の最初の操作である &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ask&quot;&gt;ask&lt;/a&gt;&lt;/code&gt; は単純なアクションなので、 &lt;code&gt;InterpM&lt;/code&gt; を使用して &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; からInterpMに &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="2faac1fc5843e8344edfa39159393215c540048a" translate="yes" xml:space="preserve">
          <source>The first of these is obviously fine. The second is still fine, although less obviously. The third is not Haskell 98, and risks losing termination of instances.</source>
          <target state="translated">最初のものは明らかに問題ない。2つ目は、明らかではないが、まだ大丈夫です。3つ目はHaskell 98ではなく、インスタンスの終端を失うリスクがあります。</target>
        </trans-unit>
        <trans-unit id="a23c2d18f54a6700ee1bddf4a4ced9e452ae0f90" translate="yes" xml:space="preserve">
          <source>The first option is to compile the program twice:</source>
          <target state="translated">最初のオプションは、プログラムを2回コンパイルすることです。</target>
        </trans-unit>
        <trans-unit id="abf1dca0b44a86f075342cd32443de5cb6266cb1" translate="yes" xml:space="preserve">
          <source>The first parameter (path) must be a file path and not a module name. The type of this path is dependent on how the module was loaded into GHCi: If the module was loaded by name, then the path name calculated by GHCi as described in &lt;a href=&quot;#ghci-modules-filenames&quot;&gt;Modules vs. filenames&lt;/a&gt; must be used. If the module was loaded with an absolute or a relative path, then the same path must be specified.</source>
          <target state="translated">最初のパラメーター（パス）は、モジュール名ではなくファイルパスである必要があります。このパスのタイプは、モジュールがGHCiにロードされた方法によって異なります。モジュールが名前でロードされた場合は、&lt;a href=&quot;#ghci-modules-filenames&quot;&gt;モジュールとファイル名の&lt;/a&gt;説明に従ってGHCiによって計算されたパス名を使用する必要があります。モジュールに絶対パスまたは相対パスがロードされている場合は、同じパスを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="b7637c081a47d73b9bc11cd583b13a110b93646f" translate="yes" xml:space="preserve">
          <source>The first part of the file gives the program name and options, and the total time and total memory allocation measured during the run of the program (note that the total memory allocation figure isn&amp;rsquo;t the same as the amount of &lt;em&gt;live&lt;/em&gt; memory needed by the program at any one time; the latter can be determined using heap profiling, which we will describe later in &lt;a href=&quot;#prof-heap&quot;&gt;Profiling memory usage&lt;/a&gt;).</source>
          <target state="translated">ファイルの最初の部分は、プログラム名とオプションを与え、合計時間と総メモリの割り当ては、総メモリ割り当ての図は、量と同じではないことをプログラム（ノートの実行中に測定された&lt;em&gt;ライブ&lt;/em&gt;で必要なメモリプログラムはいつでも実行できます。後者はヒーププロファイリングを使用して決定できます。これについては、&lt;a href=&quot;#prof-heap&quot;&gt;メモリ使用量のプロファイリングで&lt;/a&gt;後述します）。</target>
        </trans-unit>
        <trans-unit id="fef3e13957b592e13b7450a30e6df7cd6f143a71" translate="yes" xml:space="preserve">
          <source>The first phase to run is determined by each input-file suffix, and the last phase is determined by a flag. If no relevant flag is present, then go all the way through to linking. This table summarises:</source>
          <target state="translated">最初に実行されるフェーズは各入力ファイルのサフィックスによって決定され、最後のフェーズはフラグによって決定される。関連するフラグが存在しない場合は、リンクするまでのすべての段階を実行する。この表にまとめます。</target>
        </trans-unit>
        <trans-unit id="145ee321d09d8f6c8d70bccf9d36b9f9aa7af807" translate="yes" xml:space="preserve">
          <source>The first thing we need is generic representations. The &lt;code&gt;GHC.Generics&lt;/code&gt; module defines a couple of primitive types that are used to represent Haskell datatypes:</source>
          <target state="translated">最初に必要なのは、一般的な表現です。 &lt;code&gt;GHC.Generics&lt;/code&gt; のモジュールはHaskellのデータ型を表すために使用されるプリミティブ型のいくつかを定義します。</target>
        </trans-unit>
        <trans-unit id="4a1ecb3ae40da3aae2e8c25cd4cee41373d627e8" translate="yes" xml:space="preserve">
          <source>The fixed point of a monadic computation. &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; executes the action &lt;code&gt;f&lt;/code&gt; only once, with the eventual output fed back as the input. Hence &lt;code&gt;f&lt;/code&gt; should not be strict, for then &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; would diverge.</source>
          <target state="translated">モナディック計算の固定小数点。 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; はアクション &lt;code&gt;f&lt;/code&gt; を 1回だけ実行し、最終的な出力は入力としてフィードバックされます。したがって &lt;code&gt;f&lt;/code&gt; はその後のために、厳密であるべきではない &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; 発散なります。</target>
        </trans-unit>
        <trans-unit id="3b861bc9465ad5c567e33d3c5ea5e7f4fe10fe04" translate="yes" xml:space="preserve">
          <source>The fixity of a type operator may be set using the usual fixity declarations but, as in &lt;a href=&quot;#infix-tycons&quot;&gt;Infix type constructors, classes, and type variables&lt;/a&gt;, the function and type constructor share a single fixity.</source>
          <target state="translated">型演算子の固定性は通常の固定性宣言を使用して設定できますが、&lt;a href=&quot;#infix-tycons&quot;&gt;Infix型コンストラクター、クラス、および型変数と&lt;/a&gt;同様に、関数と型コンストラクターは単一の固定性を共有します。</target>
        </trans-unit>
        <trans-unit id="397ad5d952fd5d1bd350537f1bb34e2a9d3464c7" translate="yes" xml:space="preserve">
          <source>The fixity of the constructor</source>
          <target state="translated">コンストラクタの固定性</target>
        </trans-unit>
        <trans-unit id="0127191c720e27284ab5a66b202e3464fd573afd" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; also lifts the corresponding restriction on class declarations (&lt;a href=&quot;#superclass-rules&quot;&gt;The superclasses of a class declaration&lt;/a&gt;) and instance declarations (&lt;a href=&quot;#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;).</source>
          <target state="translated">フラグ&lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt;は、クラス宣言（クラス宣言&lt;a href=&quot;#superclass-rules&quot;&gt;のスーパークラス&lt;/a&gt;）およびインスタンス宣言（&lt;a href=&quot;#instance-rules&quot;&gt;インスタンスコンテキストの緩和ルール）に対する&lt;/a&gt;対応する制限も解除します。</target>
        </trans-unit>
        <trans-unit id="680d808c4989476cdf108f73531ac73891762a24" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;#ghc-flag--Wincomplete-uni-patterns&quot;&gt;&lt;code&gt;-Wincomplete-uni-patterns&lt;/code&gt;&lt;/a&gt; is similar to &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt;, except that it applies only to lambda-expressions and pattern bindings, constructs that only allow a single pattern:</source>
          <target state="translated">フラグ&lt;a href=&quot;#ghc-flag--Wincomplete-uni-patterns&quot;&gt; &lt;code&gt;-Wincomplete-uni-patterns&lt;/code&gt; &lt;/a&gt;は、ラムダ式とパターンバインディングにのみ適用されることを除いて、&lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; に&lt;/a&gt;似ています。</target>
        </trans-unit>
        <trans-unit id="0b79e0ee85c7165a369baa04cb9639b641623921" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Worphans&lt;/code&gt;&lt;/a&gt; warns about user-written orphan rules or instances.</source>
          <target state="translated">フラグ&lt;a href=&quot;#ghc-flag--Worphans&quot;&gt; &lt;code&gt;-Worphans&lt;/code&gt; は&lt;/a&gt;、ユーザーが作成した孤立ルールまたはインスタンスについて警告します。</target>
        </trans-unit>
        <trans-unit id="6444f39733d8014ca144750cd7ba00423630703d" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;#ghc-flag--fprint-evld-with-show&quot;&gt;&lt;code&gt;-fprint-evld-with-show&lt;/code&gt;&lt;/a&gt; instructs &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; to reuse available &lt;code&gt;Show&lt;/code&gt; instances when possible. This happens only when the contents of the variable being inspected are completely evaluated.</source>
          <target state="translated">フラグ&lt;a href=&quot;#ghc-flag--fprint-evld-with-show&quot;&gt; &lt;code&gt;-fprint-evld-with-show&lt;/code&gt; は&lt;/a&gt;、可能な場合に使用可能な &lt;code&gt;Show&lt;/code&gt; インスタンスを再利用するように&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;に指示します。これは、検査対象の変数の内容が完全に評価された場合にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="47cb0b5fb9b4f5cbc05ae1ed28f5f328bb28aed6" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt;&lt;code&gt;-ddump-splices&lt;/code&gt;&lt;/a&gt; shows the expansion of all top-level declaration splices, both typed and untyped, as they happen. As with all dump flags, the default is for this output to be sent to stdout. For a non-trivial program, you may be interested in combining this with the &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt; flag (see &lt;a href=&quot;debugging#dumping-output&quot;&gt;Dumping out compiler intermediate structures&lt;/a&gt;. For each file using Template Haskell, this will show the output in a &lt;code&gt;.dump-splices&lt;/code&gt; file.</source>
          <target state="translated">フラグ&lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt; &lt;code&gt;-ddump-splices&lt;/code&gt; &lt;/a&gt;は、型付きと型なしの両方の最上位の宣言スプライスの展開を示します。すべてのダンプフラグと同様に、デフォルトでは、この出力はstdoutに送信されます。重要なプログラムの場合、これを&lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt;フラグと組み合わせることに興味があるかもしれません（&lt;a href=&quot;debugging#dumping-output&quot;&gt;コンパイラの中間構造のダンプアウトを&lt;/a&gt;参照してください。テンプレートHaskellを使用する各ファイルについて、これは &lt;code&gt;.dump-splices&lt;/code&gt; ファイルに出力を表示します。</target>
        </trans-unit>
        <trans-unit id="4495b2a19abefc172f62863056de3aa383544711" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;debugging#ghc-flag--dth-dec-file&quot;&gt;&lt;code&gt;-dth-dec-file&lt;/code&gt;&lt;/a&gt; dumps the expansions of all top-level TH declaration splices, both typed and untyped, in the file &lt;code&gt;M.th.hs&lt;/code&gt; for each module &lt;code&gt;M&lt;/code&gt; being compiled. Note that other types of splices (expressions, types, and patterns) are not shown. Application developers can check this into their repository so that they can grep for identifiers that were defined in Template Haskell. This is similar to using &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt;&lt;code&gt;-ddump-splices&lt;/code&gt;&lt;/a&gt; but it always generates a file instead of being coupled to &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt;. The format is also different: it does not show code from the original file, instead it only shows generated code and has a comment for the splice location of the original file.</source>
          <target state="translated">フラグ&lt;a href=&quot;debugging#ghc-flag--dth-dec-file&quot;&gt; &lt;code&gt;-dth-dec-file&lt;/code&gt; &lt;/a&gt;は、コンパイルされている各モジュール &lt;code&gt;M&lt;/code&gt; のファイル &lt;code&gt;M.th.hs&lt;/code&gt; に、型付きと型なしの両方のすべての最上位TH宣言スプライスの展開をダンプします。他のタイプのスプライス（式、タイプ、およびパターン）は表示されないことに注意してください。アプリケーション開発者はこれをリポジトリにチェックインして、テンプレートHaskellで定義された識別子をgrepできるようにします。これは、&lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt;を&lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt; &lt;code&gt;-ddump-splices&lt;/code&gt; &lt;/a&gt;と共に使用するのと似ていますが、-ddump-to-fileに結合されるのではなく、常にファイルを生成し&lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt;。形式も異なります。元のファイルのコードは表示されず、生成されたコードのみが表示され、元のファイルのスプライスの場所に関するコメントが含まれます。</target>
        </trans-unit>
        <trans-unit id="956cfa095b764303bb3df255e599d046113e1e5f" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; controls whether type errors are deferred to runtime. Type errors will still be emitted as warnings, but will not prevent compilation. You can use &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt;&lt;code&gt;-Wno-deferred-type-errors&lt;/code&gt;&lt;/a&gt; to suppress these warnings.</source>
          <target state="translated">フラグ&lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;は、タイプエラーを実行時に延期するかどうかを制御します。タイプエラーは引き続き警告として出力されますが、コンパイルを妨げることはありません。あなたは使用することができます&lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt; &lt;code&gt;-Wno-deferred-type-errors&lt;/code&gt; &lt;/a&gt;これらの警告を抑制します。</target>
        </trans-unit>
        <trans-unit id="b93b2c7d1b9eda88e393a8f5e74873331f11d482" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; controls whether type errors are deferred to runtime. Type errors will still be emitted as warnings, but will not prevent compilation. You can use &lt;code&gt;-Wno-type-errors&lt;/code&gt; to suppress these warnings.</source>
          <target state="translated">フラグ&lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;は、型エラーをランタイムに延期するかどうかを制御します。タイプエラーは警告として出力されますが、コンパイルを妨げることはありません。 &lt;code&gt;-Wno-type-errors&lt;/code&gt; を使用して、これらの警告を抑制することができます。</target>
        </trans-unit>
        <trans-unit id="1b3baa03b1de2ae2d10fcb9504c97b6f24d46a7f" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; works in GHCi as well, with one exception: for &amp;ldquo;naked&amp;rdquo; expressions typed at the prompt, type errors don&amp;rsquo;t get delayed, so for example:</source>
          <target state="translated">フラグ&lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;は、GHCiでも機能しますが、1つの例外があります。プロンプトで入力された「裸の」式の場合、タイプエラーは遅延しません。たとえば、次のようになります。</target>
        </trans-unit>
        <trans-unit id="7bc71daa56ee822998e1d64f92a7832d0f7badec" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;-fglasgow-exts&lt;/code&gt; is equivalent to enabling the following extensions:</source>
          <target state="translated">フラグ &lt;code&gt;-fglasgow-exts&lt;/code&gt; は、以下の拡張機能を有効にすることと同等です。</target>
        </trans-unit>
        <trans-unit id="bfe7b59eddf66920c11dffff433c9395a1cc1d4e" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;-fprint-evld-with-show&lt;/code&gt; instructs &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; to reuse available &lt;code&gt;Show&lt;/code&gt; instances when possible. This happens only when the contents of the variable being inspected are completely evaluated.</source>
          <target state="translated">フラグ &lt;code&gt;-fprint-evld-with-show&lt;/code&gt; は、可能な場合、使用可能な &lt;code&gt;Show&lt;/code&gt; インスタンスを再利用するように&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;に指示します。これは、検査される変数の内容が完全に評価された場合にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="d43a045f4632b27bf091372de67333d21d36a1ae" translate="yes" xml:space="preserve">
          <source>The flag reference tables (&lt;a href=&quot;flags#flag-reference&quot;&gt;Flag reference&lt;/a&gt;) lists the status of each flag.</source>
          <target state="translated">フラグリファレンスの表（&lt;a href=&quot;flags#flag-reference&quot;&gt;フラグリファレンス&lt;/a&gt;）には、各フラグのステータスがリストされています。</target>
        </trans-unit>
        <trans-unit id="960b0cead1ab39ce475efd50a401951d0d90317c" translate="yes" xml:space="preserve">
          <source>The flags &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--static&quot;&gt;&lt;code&gt;-static&lt;/code&gt;&lt;/a&gt; control whether the resulting shared object links statically or dynamically to Haskell package libraries given as &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; option. Non-Haskell libraries are linked as gcc would regularly link it on your system, e.g. on most ELF system the linker uses the dynamic libraries when found.</source>
          <target state="translated">フラグ&lt;a href=&quot;#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#ghc-flag--static&quot;&gt; &lt;code&gt;-static&lt;/code&gt; &lt;/a&gt;は、結果の共有オブジェクトが &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; オプションとして指定されたHaskellパッケージライブラリに静的または動的にリンクするかどうかを制御します。Haccell以外のライブラリは、gccがシステム上で定期的にリンクするようにリンクされます。たとえば、ほとんどのELFシステムでは、リンカは動的ライブラリを検出すると使用します。</target>
        </trans-unit>
        <trans-unit id="7668d5e6fe85390adb7a3ecf19db212413e1eebc" translate="yes" xml:space="preserve">
          <source>The flags &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt;&lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;&lt;/a&gt; have no effect when used with &lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;, because they are implemented by changing the definition of &lt;code&gt;main&lt;/code&gt; that GHC generates. See &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Using your own main()&lt;/a&gt; for how to get the effect of &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt;&lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;&lt;/a&gt; when using your own &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">フラグ&lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt; &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; &lt;/a&gt;は、&lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt;と一緒に使用した場合、 &lt;code&gt;main&lt;/code&gt; の定義を変更することで実装されるため、効果がありませんGHCが生成する。参照してください&lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;）（あなた自身のメインを使用して&lt;/a&gt;の効果を得る方法については&lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; &lt;/a&gt;し、&lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt; &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; &lt;/a&gt;あなた自身の使用する際 &lt;code&gt;main&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe514827a2bc8cfeb3427c13cc2ba47f6aba7300" translate="yes" xml:space="preserve">
          <source>The flags are:</source>
          <target state="translated">旗は</target>
        </trans-unit>
        <trans-unit id="bcad0a34c93b0b86bbc687fc84b1ffd20b52d6a1" translate="yes" xml:space="preserve">
          <source>The floating-point environment is not saved over a normal thread context-switch. So if you modify the floating-point state in one thread, those changes may be visible in other threads. Furthermore, testing the exception state is not reliable, because a context switch may change it. If you need to modify or test the floating point state and use threads, then you must use bound threads (&lt;code&gt;Control.Concurrent.forkOS&lt;/code&gt;), because a bound thread has its own OS thread, and OS threads do save and restore the floating-point state.</source>
          <target state="translated">浮動小数点環境は、通常のスレッドのコンテキスト切り替えでは保存されません。したがって、1つのスレッドで浮動小数点の状態を変更すると、それらの変更が他のスレッドで表示される可能性があります。さらに、コンテキストスイッチが例外状態を変更する可能性があるため、例外状態のテストは信頼できません。浮動小数点の状態を変更またはテストしてスレッドを使用する必要がある場合は、バインドされたスレッド（ &lt;code&gt;Control.Concurrent.forkOS&lt;/code&gt; ）を使用する必要があります。バインドされたスレッドには独自のOSスレッドがあり、OSスレッドは浮動小数点を保存および復元するためです。状態。</target>
        </trans-unit>
        <trans-unit id="d84e5b1b19c72a9f2f8e38f56f6835541ed5d999" translate="yes" xml:space="preserve">
          <source>The following RTS option(s) affect the behaviour of Concurrent Haskell programs:</source>
          <target state="translated">以下のRTSオプションは、並行Haskellプログラムの動作に影響を与えます。</target>
        </trans-unit>
        <trans-unit id="52952117f68d88486d7181f97f7977ad0131a484" translate="yes" xml:space="preserve">
          <source>The following are QuickCheck specifications of what the combinators do. These can be seen as formal specifications of the behavior of the combinators.</source>
          <target state="translated">以下は、コンビネータが何をするかをクイックチェックする仕様です。これらは、組合せ器の動作の形式的な仕様と見ることができます。</target>
        </trans-unit>
        <trans-unit id="880afa09746074737763ff34c90d8a824dfb1e1a" translate="yes" xml:space="preserve">
          <source>The following are definitions for &quot;merge&quot; for each of the heaps above. Each takes a comparison function which is used to order the elements.</source>
          <target state="translated">上記の各ヒープの &quot;merge &quot;の定義を以下に示します。それぞれのヒープは、要素の順序付けに使用される比較関数を取ります。</target>
        </trans-unit>
        <trans-unit id="9031e690866836bd079eb18cd7f2cf6f4a7c0278" translate="yes" xml:space="preserve">
          <source>The following are definitions for &lt;code&gt;popMin&lt;/code&gt;, a function which constructs a stateful action which pops the smallest element from the queue, where &quot;smallest&quot; is according to the supplied comparison function.</source>
          <target state="translated">以下は、キューから最小の要素をポップするステートフルアクションを構築する関数 &lt;code&gt;popMin&lt;/code&gt; の定義です。ここで、「最小」は、指定された比較関数に従います。</target>
        </trans-unit>
        <trans-unit id="853c1b2416dd00409c8f94cbaaab4d500ad921b0" translate="yes" xml:space="preserve">
          <source>The following are definitions for functions to build queues, given a comparison function.</source>
          <target state="translated">比較関数を与えられたキューを構築する関数の定義を以下に示します。</target>
        </trans-unit>
        <trans-unit id="00e5f1459a91351f85b76ba47f587250af056d92" translate="yes" xml:space="preserve">
          <source>The following are definitions for various specialized pairing heaps.</source>
          <target state="translated">以下に、様々な特殊なペアリングヒープの定義を示します。</target>
        </trans-unit>
        <trans-unit id="bcfac859b1b4efae75f25f72bc0530006c88e6e1" translate="yes" xml:space="preserve">
          <source>The following are good consumers:</source>
          <target state="translated">以下は優良消費者です。</target>
        </trans-unit>
        <trans-unit id="415fb3cf16155d23aebc101af30f40f1175a4761" translate="yes" xml:space="preserve">
          <source>The following are good producers:</source>
          <target state="translated">以下は良い生産者です。</target>
        </trans-unit>
        <trans-unit id="fc2c73f87b7ae21e5d1bff7544c615fae9cb5d03" translate="yes" xml:space="preserve">
          <source>The following behaves as expected:</source>
          <target state="translated">以下は期待通りの動作をします。</target>
        </trans-unit>
        <trans-unit id="0f147698ae3534209b092f6955e20175ff56a36f" translate="yes" xml:space="preserve">
          <source>The following command works to load new packages into a running GHCi:</source>
          <target state="translated">以下のコマンドは、実行中のGHCiに新しいパッケージをロードするために動作します。</target>
        </trans-unit>
        <trans-unit id="e7ad1243df876884047bbd1cfa2abad6fc2f257e" translate="yes" xml:space="preserve">
          <source>The following commands turn the keypad on/off (&lt;code&gt;smkx&lt;/code&gt; and &lt;code&gt;rmkx&lt;/code&gt;). They have no effect if those capabilities are not defined. For portability between terminals, the keypad should be explicitly turned on before accepting user key input.</source>
          <target state="translated">次のコマンドは、キーパッドをオン/オフにします（ &lt;code&gt;smkx&lt;/code&gt; および &lt;code&gt;rmkx&lt;/code&gt; ）。これらの機能が定義されていない場合、効果はありません。端末間の移植性のために、ユーザーのキー入力を受け入れる前に、キーパッドを明示的にオンにする必要があります。</target>
        </trans-unit>
        <trans-unit id="25f14bebf678b2e0c7df12fa6531f8bc946288ab" translate="yes" xml:space="preserve">
          <source>The following definition is available to C programs inter-operating with Haskell code when including the header &lt;code&gt;HsFFI.h&lt;/code&gt;.</source>
          <target state="translated">次の定義は、ヘッダー &lt;code&gt;HsFFI.h&lt;/code&gt; をインクルードするときにHaskellコードと相互運用するCプログラムで使用できます。</target>
        </trans-unit>
        <trans-unit id="e6d695a5cf6d19ccd0a26b89aff9c95dd12f497b" translate="yes" xml:space="preserve">
          <source>The following description of the motivation and use of functional dependencies is taken from the Hugs user manual, reproduced here (with minor changes) by kind permission of Mark Jones.</source>
          <target state="translated">機能依存性の動機と使用方法についての以下の説明は、Hugs のユーザーマニュアルから引用したもので、Mark Jones の親切な許可を得てここに転載しています(マイナーチェンジを加えています)。</target>
        </trans-unit>
        <trans-unit id="255eb2a60233998edc485b972b2b920903f06efc" translate="yes" xml:space="preserve">
          <source>The following equation relates &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">次の方程式は、 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; に関連しています。</target>
        </trans-unit>
        <trans-unit id="713d7c0768135036f33a7e1109e709b8e968874e" translate="yes" xml:space="preserve">
          <source>The following equation relates &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">次の方程式は、 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; に関連しています。</target>
        </trans-unit>
        <trans-unit id="dbc7d38cb4fbd659d01d9a4ef580cbd8a454bdc2" translate="yes" xml:space="preserve">
          <source>The following extra instances are defined:</source>
          <target state="translated">以下の追加インスタンスが定義されています。</target>
        </trans-unit>
        <trans-unit id="219485ecc6b675dce37eba80ce2494e945235236" translate="yes" xml:space="preserve">
          <source>The following flags are simple ways to select standard &amp;ldquo;packages&amp;rdquo; of warnings:</source>
          <target state="translated">次のフラグは、警告の標準的な「パッケージ」を選択する簡単な方法です。</target>
        </trans-unit>
        <trans-unit id="9e8f2bd1d4e584f03bc71486665d6449cff997d8" translate="yes" xml:space="preserve">
          <source>The following flags control the way in which GHC displays types in error messages and in GHCi:</source>
          <target state="translated">以下のフラグは、エラーメッセージやGHCiでの型の表示方法を制御します。</target>
        </trans-unit>
        <trans-unit id="369fd24532366a269db0dd996324b5e45dfd6c9e" translate="yes" xml:space="preserve">
          <source>The following functions allow a thread to control delivery of asynchronous exceptions during a critical region.</source>
          <target state="translated">以下の関数は、スレッドがクリティカル領域の間に非同期例外の配信を制御することを可能にします。</target>
        </trans-unit>
        <trans-unit id="cf919ec9ecd009bd434b357d75af7e1bf8279715" translate="yes" xml:space="preserve">
          <source>The following functions enable cross-platform output of text that may contain Unicode characters.</source>
          <target state="translated">以下の関数は、Unicode キ ャ ラ ク タ を含む可能性のあ る テ キ ス ト をプ ラ ッ ト フ ォーム間で出力す る こ と を可能に し ます。</target>
        </trans-unit>
        <trans-unit id="38af53e84d563801f65a6120a4900e75bb8e39ff" translate="yes" xml:space="preserve">
          <source>The following functions for cursor movement will combine the more primitive capabilities. For example, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:moveDown&quot;&gt;moveDown&lt;/a&gt;&lt;/code&gt; may use either &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown&quot;&gt;cursorDown&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown1&quot;&gt;cursorDown1&lt;/a&gt;&lt;/code&gt; depending on the parameter and which of &lt;code&gt;cud&lt;/code&gt; and &lt;code&gt;cud1&lt;/code&gt; are defined.</source>
          <target state="translated">次のカーソル移動機能は、より基本的な機能を組み合わせたものです。例えば、 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:moveDown&quot;&gt;moveDown&lt;/a&gt;&lt;/code&gt; のいずれかを使用してもよい &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown&quot;&gt;cursorDown&lt;/a&gt;&lt;/code&gt; 又は &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown1&quot;&gt;cursorDown1&lt;/a&gt;&lt;/code&gt; をパラメータとするかに応じ &lt;code&gt;cud&lt;/code&gt; と &lt;code&gt;cud1&lt;/code&gt; 定義されます。</target>
        </trans-unit>
        <trans-unit id="0b7bd1ee8d2490e346b323a061ee5d6bf4bd98aa" translate="yes" xml:space="preserve">
          <source>The following functions read one line or character of input from the user.</source>
          <target state="translated">以下の機能は、ユーザから入力された1行または1文字を読み取る機能です。</target>
        </trans-unit>
        <trans-unit id="defeb72fa9fc8defce3095a722d77cd56b0b0897" translate="yes" xml:space="preserve">
          <source>The following holds:</source>
          <target state="translated">以下はホールドしています。</target>
        </trans-unit>
        <trans-unit id="0e843336042b652d443e731d806dae137491a142" translate="yes" xml:space="preserve">
          <source>The following instances of &lt;code&gt;MonadFix&lt;/code&gt; are automatically provided: List, Maybe, IO. Furthermore, the &lt;code&gt;Control.Monad.ST&lt;/code&gt; and &lt;code&gt;Control.Monad.ST.Lazy&lt;/code&gt; modules provide the instances of the &lt;code&gt;MonadFix&lt;/code&gt; class for Haskell&amp;rsquo;s internal state monad (strict and lazy, respectively).</source>
          <target state="translated">&lt;code&gt;MonadFix&lt;/code&gt; の次のインスタンスが自動的に提供されます：リスト、たぶん、IO。さらに、 &lt;code&gt;Control.Monad.ST&lt;/code&gt; および &lt;code&gt;Control.Monad.ST.Lazy&lt;/code&gt; モジュールは、Haskellの内部状態モナド（それぞれ厳密および遅延）の &lt;code&gt;MonadFix&lt;/code&gt; クラスのインスタンスを提供します。</target>
        </trans-unit>
        <trans-unit id="974f2bea79592d4497c7bb6f1878062d29b69e35" translate="yes" xml:space="preserve">
          <source>The following laws ought to hold (for all valid bit indices &lt;code&gt;&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;):</source>
          <target state="translated">以下の法律が成立するはずです（すべての有効なビットインデックス &lt;code&gt;&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; に対して）。</target>
        </trans-unit>
        <trans-unit id="3bc96821c04daf88673e5973fb7e13baaeb66bc4" translate="yes" xml:space="preserve">
          <source>The following operations are guaranteed not to be interruptible:</source>
          <target state="translated">以下の操作は、割り込みができないことが保証されています。</target>
        </trans-unit>
        <trans-unit id="740d5fed1fd466547dd8bedbd7c0b84313346d32" translate="yes" xml:space="preserve">
          <source>The following options affect the way the runtime schedules threads on CPUs:</source>
          <target state="translated">以下のオプションは、ランタイムがCPU上でスレッドをスケジュールする方法に影響を与えます。</target>
        </trans-unit>
        <trans-unit id="2b8d3fdea7e46b30a4c9898c10dbf48da92a4aa0" translate="yes" xml:space="preserve">
          <source>The following options are useful for keeping (or not keeping) certain intermediate files around, when normally GHC would throw these away after compilation:</source>
          <target state="translated">以下のオプションは、通常はコンパイル後にGHCが捨ててしまうような中間ファイルを保持する(保持しない)のに便利です。</target>
        </trans-unit>
        <trans-unit id="4b91e9673e3ffcbc96d29b28282cb41f8f1d21ce" translate="yes" xml:space="preserve">
          <source>The following plugins allows users to limit the search for valid hole fits to certain modules, to sort the hole fits by where they originated (in ascending or descending order), as well as allowing users to put a limit on how much time is spent on searching for valid hole fits, after which new searches are aborted.</source>
          <target state="translated">以下のプラグインでは、ユーザーが有効なホールフィットの検索を特定のモジュールに制限したり、ホールフィットを発生場所でソートしたり(昇順または降順)、有効なホールフィットの検索に費やす時間を制限したり、新しい検索を中止したりすることができます。</target>
        </trans-unit>
        <trans-unit id="38c3f1cd516a144b167f804cbad9091a110d7738" translate="yes" xml:space="preserve">
          <source>The following property holds</source>
          <target state="translated">以下のプロパティを保持しています。</target>
        </trans-unit>
        <trans-unit id="c4d20004308e57029d6af08f5d4d162927106726" translate="yes" xml:space="preserve">
          <source>The following relationships hold:</source>
          <target state="translated">以下のような関係が続いています。</target>
        </trans-unit>
        <trans-unit id="78400d597f1cd2c8bbeafc9eb8299b783cc0473e" translate="yes" xml:space="preserve">
          <source>The following sections also give some hints and tips on the use of the foreign function interface in GHC.</source>
          <target state="translated">また、以下のセクションでは、GHCの外部関数インタフェースを使用する際のヒントやヒントも紹介しています。</target>
        </trans-unit>
        <trans-unit id="f17c609e8f1c6b37d3130d2dff0e1652b3175021" translate="yes" xml:space="preserve">
          <source>The following should work, since both &lt;code&gt;'1'&lt;/code&gt; and &lt;code&gt;'2'&lt;/code&gt; can be parsed as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;'1'&lt;/code&gt; と &lt;code&gt;'2'&lt;/code&gt; はどちらも &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; として解析できるため、次のように機能します。</target>
        </trans-unit>
        <trans-unit id="1f604ae57c21e961a4347d16a255de560a7918fb" translate="yes" xml:space="preserve">
          <source>The following should work, since both &lt;code&gt;'1'&lt;/code&gt; and &lt;code&gt;'2'&lt;/code&gt; can be parsed as &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;'1'&lt;/code&gt; と &lt;code&gt;'2'&lt;/code&gt; はどちらも &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; として解析できるため、次のように機能します。</target>
        </trans-unit>
        <trans-unit id="f68ed3cdb6c1e1e040a389af1a8ea7b8ca3ea19d" translate="yes" xml:space="preserve">
          <source>The following syntax is stolen:</source>
          <target state="translated">以下の構文が盗まれています。</target>
        </trans-unit>
        <trans-unit id="f24a325a1df690e88417cf55ef160f4f9b155bda" translate="yes" xml:space="preserve">
          <source>The following unboxed types may be used as basic foreign types (see FFI Chapter, Section 8.6): &lt;code&gt;Int#&lt;/code&gt;, &lt;code&gt;Word#&lt;/code&gt;, &lt;code&gt;Char#&lt;/code&gt;, &lt;code&gt;Float#&lt;/code&gt;, &lt;code&gt;Double#&lt;/code&gt;, &lt;code&gt;Addr#&lt;/code&gt;, &lt;code&gt;StablePtr# a&lt;/code&gt;, &lt;code&gt;MutableByteArray#&lt;/code&gt;, &lt;code&gt;ForeignObj#&lt;/code&gt;, and &lt;code&gt;ByteArray#&lt;/code&gt;.</source>
          <target state="translated">次のボックス化されていない型は、基本的な外部型として使用できます（FFIの章、セクション8.6を参照）： &lt;code&gt;Int#&lt;/code&gt; 、 &lt;code&gt;Word#&lt;/code&gt; 、 &lt;code&gt;Char#&lt;/code&gt; 、 &lt;code&gt;Float#&lt;/code&gt; 、 &lt;code&gt;Double#&lt;/code&gt; 、 &lt;code&gt;Addr#&lt;/code&gt; 、 &lt;code&gt;StablePtr# a&lt;/code&gt; 、 &lt;code&gt;MutableByteArray#&lt;/code&gt; 、 &lt;code&gt;ForeignObj#&lt;/code&gt; 、および &lt;code&gt;ByteArray#&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a390fae09d9d59559fad6e009bd1023970f06a76" translate="yes" xml:space="preserve">
          <source>The following unlifted unboxed types may be used as basic foreign types (see FFI Chapter, Section 8.6) for both &lt;code&gt;safe&lt;/code&gt; and &lt;code&gt;unsafe&lt;/code&gt; foreign calls: &lt;code&gt;Int#&lt;/code&gt;, &lt;code&gt;Word#&lt;/code&gt;, &lt;code&gt;Char#&lt;/code&gt;, &lt;code&gt;Float#&lt;/code&gt;, &lt;code&gt;Double#&lt;/code&gt;, &lt;code&gt;Addr#&lt;/code&gt;, and &lt;code&gt;StablePtr# a&lt;/code&gt;. Several unlifted boxed types may be used as arguments to FFI calls, subject to these restrictions:</source>
          <target state="translated">The following unlifted unboxed types may be used as basic foreign types (see FFI Chapter, Section 8.6) for both &lt;code&gt;safe&lt;/code&gt; and &lt;code&gt;unsafe&lt;/code&gt; foreign calls: &lt;code&gt;Int#&lt;/code&gt; , &lt;code&gt;Word#&lt;/code&gt; , &lt;code&gt;Char#&lt;/code&gt; , &lt;code&gt;Float#&lt;/code&gt; , &lt;code&gt;Double#&lt;/code&gt; , &lt;code&gt;Addr#&lt;/code&gt; , and &lt;code&gt;StablePtr# a&lt;/code&gt; . Several unlifted boxed types may be used as arguments to FFI calls, subject to these restrictions:</target>
        </trans-unit>
        <trans-unit id="bc89363b3d736091da072542a570e3138b391d30" translate="yes" xml:space="preserve">
          <source>The following uses of &lt;code&gt;unsafeCoerce#&lt;/code&gt; are supposed to work (i.e. not lead to spurious compile-time or run-time crashes):</source>
          <target state="translated">&lt;code&gt;unsafeCoerce#&lt;/code&gt; の次の使用は機能するはずです（つまり、誤ったコンパイル時または実行時のクラッシュにつながりません）。</target>
        </trans-unit>
        <trans-unit id="1c72fa99c47cb70fcbd686ee80df427b2899a75e" translate="yes" xml:space="preserve">
          <source>The following will fail with an &amp;ldquo;Illegal unboxed tuple&amp;rdquo; error, since the derived instance produced by the compiler makes use of unboxed tuple syntax,</source>
          <target state="translated">コンパイラーによって生成された派生インスタンスはボックス化されていないタプル構文を使用するため、以下は「無効なボックス化されていないタプル」エラーで失敗します。</target>
        </trans-unit>
        <trans-unit id="bbe044a46ef1c2c19252cc897f6025061c027f6f" translate="yes" xml:space="preserve">
          <source>The followup discussion that changed the behavior of &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is archived here: &lt;a href=&quot;http://markmail.org/message/trovdc6zkphyi3cr#query:+page:1+mid:a46der3iacwjcf6n+state:results&quot;&gt;Proposal: Allow gunfold for Data.Map, ...&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; の動作を変更したフォローアップディスカッションはここにアーカイブされています：&lt;a href=&quot;http://markmail.org/message/trovdc6zkphyi3cr#query:+page:1+mid:a46der3iacwjcf6n+state:results&quot;&gt;提案：Data.Mapのガンフォールドを許可...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cee1c36106928daf538418e53cc5b65ec5381bc2" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;C(..)&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; is a class, names the class &lt;code&gt;C&lt;/code&gt; and all its methods &lt;em&gt;and associated types&lt;/em&gt;.</source>
          <target state="translated">フォーム &lt;code&gt;C(..)&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; はクラス、名前のクラスである &lt;code&gt;C&lt;/code&gt; およびそのすべての方法&lt;em&gt;および関連するタイプ&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="16df0b26ad83c27523378eaf1216ddacafe4cfa5" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;C(.., mi, .., type Tj, ..)&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; is a class, names the class &lt;code&gt;C&lt;/code&gt;, and the specified methods &lt;code&gt;mi&lt;/code&gt; and associated types &lt;code&gt;Tj&lt;/code&gt;. The types need a keyword &amp;ldquo;&lt;code&gt;type&lt;/code&gt;&amp;rdquo; to distinguish them from data constructors.</source>
          <target state="translated">フォーム &lt;code&gt;C(.., mi, .., type Tj, ..)&lt;/code&gt; 、ここで &lt;code&gt;C&lt;/code&gt; はクラスであり、クラス &lt;code&gt;C&lt;/code&gt; に名前を付け、指定されたメソッド &lt;code&gt;mi&lt;/code&gt; および関連する型 &lt;code&gt;Tj&lt;/code&gt; に名前を付けます。タイプには、データコンストラクターと区別するためのキーワード「 &lt;code&gt;type&lt;/code&gt; 」が必要です。</target>
        </trans-unit>
        <trans-unit id="54deed429c05521fb5fa3d0bb8ceb609130a547f" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;T(..)&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a data family, names the family &lt;code&gt;T&lt;/code&gt; and all the in-scope constructors (whether in scope qualified or unqualified) that are data instances of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">フォーム &lt;code&gt;T(..)&lt;/code&gt; 、 &lt;code&gt;T&lt;/code&gt; はデータファミリー名ファミリーである &lt;code&gt;T&lt;/code&gt; とのデータのインスタンスであるすべてのスコープ内のコンストラクタ（範囲における修飾または非修飾するかどうか） &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="784438eaf0aa44838a323a050c855ee268899421" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;T(.., ci, .., fj, ..)&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a data family, names &lt;code&gt;T&lt;/code&gt; and the specified constructors &lt;code&gt;ci&lt;/code&gt; and fields &lt;code&gt;fj&lt;/code&gt; as usual. The constructors and field names must belong to some data instance of &lt;code&gt;T&lt;/code&gt;, but are not required to belong to the &lt;em&gt;same&lt;/em&gt; instance.</source>
          <target state="translated">&lt;code&gt;T(.., ci, .., fj, ..)&lt;/code&gt; の形式で、 &lt;code&gt;T&lt;/code&gt; はデータファミリーであり、通常どおり &lt;code&gt;T&lt;/code&gt; に名前を付け、指定したコンストラクター &lt;code&gt;ci&lt;/code&gt; およびフィールド &lt;code&gt;fj&lt;/code&gt; に名前を付けます。コンストラクターとフィールド名は &lt;code&gt;T&lt;/code&gt; のデータインスタンスに属している必要がありますが、&lt;em&gt;同じ&lt;/em&gt;インスタンスに属している必要はありません。</target>
        </trans-unit>
        <trans-unit id="e19f785765e870b264c7a6f5303ec2d2e122f27d" translate="yes" xml:space="preserve">
          <source>The form is called a &amp;ldquo;GADT-style declaration&amp;rdquo; because Generalised Algebraic Data Types, described in &lt;a href=&quot;#gadt&quot;&gt;Generalised Algebraic Data Types (GADTs)&lt;/a&gt;, can only be declared using this form.</source>
          <target state="translated">&lt;a href=&quot;#gadt&quot;&gt;一般化代数データ型（GADT）&lt;/a&gt;で説明されている一般化代数データ型はこのフォームを使用してのみ宣言できるため、このフォームは「GADTスタイル宣言」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="ccb8198ff02595b7c5252294cca08712b727694b" translate="yes" xml:space="preserve">
          <source>The form with a type variable at the head allows this:</source>
          <target state="translated">先頭に型変数を持つフォームではこれが可能です。</target>
        </trans-unit>
        <trans-unit id="33fa9d40a30aa7e6dce906a9649768430ce7ca3a" translate="yes" xml:space="preserve">
          <source>The format character &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; was invoked with. &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; should fail unless this character matches the type. It is normal to handle many different format characters for a single type.</source>
          <target state="translated">フォーマット文字 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; が呼び出されました。この文字がタイプと一致しない限り、 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; は失敗するはずです。単一のタイプに対して多くの異なるフォーマット文字を処理するのは通常のことです。</target>
        </trans-unit>
        <trans-unit id="3b0d06acd5997423d85afc8f840323a4c6b86ed5" translate="yes" xml:space="preserve">
          <source>The format in which GHC currently stores its typechecked AST, makes it costly to collect the types for some expressions nodes. For the sake of performance, GHC currently chooses to skip over these, so not all expression nodes should be expected to have type information on them. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/16233&quot;&gt;#16233&lt;/a&gt; for more.</source>
          <target state="translated">The format in which GHC currently stores its typechecked AST, makes it costly to collect the types for some expressions nodes. For the sake of performance, GHC currently chooses to skip over these, so not all expression nodes should be expected to have type information on them. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/16233&quot;&gt;#16233&lt;/a&gt; for more.</target>
        </trans-unit>
        <trans-unit id="2d9a19d4aec50fa6639cb12bdd8357cf823eed22" translate="yes" xml:space="preserve">
          <source>The format in which GHC currently stores its typechecked AST, makes it costly to collect the types for some expressions nodes. For the sake of performance, GHC currently chooses to skip over these, so not all expression nodes should be expected to have type information on them. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/16233&quot;&gt;Issue #16233&lt;/a&gt; for more.</source>
          <target state="translated">GHCが型チェックされたASTを現在格納している形式では、一部の式ノードの型を収集するのにコストがかかります。パフォーマンスのために、GHCは現在これらをスキップすることを選択しているため、すべての式ノードが型情報を持っているとは限りません。詳しくは、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/16233&quot;&gt;問題＃16233&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="77eb958799ae389fcdbbcf943703d169a775084b" translate="yes" xml:space="preserve">
          <source>The format is endian-independent: all values are represented in big-endian order.</source>
          <target state="translated">フォーマットはエンディアンに依存しません:すべての値はビッグエンディアン順で表されます。</target>
        </trans-unit>
        <trans-unit id="52265627b3cdf75e5930faf68e8602be59d016e4" translate="yes" xml:space="preserve">
          <source>The format is extensible:</source>
          <target state="translated">フォーマットは拡張可能です。</target>
        </trans-unit>
        <trans-unit id="8d12d8f748fe76f6f798cf8384f400dd6e25b26a" translate="yes" xml:space="preserve">
          <source>The format of the log file is described by the header &lt;code&gt;EventLogFormat.h&lt;/code&gt; that comes with GHC, and it can be parsed in Haskell using the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; library. To dump the contents of a &lt;code&gt;.eventlog&lt;/code&gt; file as text, use the tool &lt;code&gt;ghc-events show&lt;/code&gt; that comes with the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; package.</source>
          <target state="translated">ログファイルの形式は、GHCに付属するヘッダー &lt;code&gt;EventLogFormat.h&lt;/code&gt; によって記述され、&lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt;ライブラリを使用してHaskellで解析できます。 &lt;code&gt;.eventlog&lt;/code&gt; ファイルの内容をテキストとしてダンプするには、&lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt;パッケージに付属の &lt;code&gt;ghc-events show&lt;/code&gt; ツールを使用します。</target>
        </trans-unit>
        <trans-unit id="5a21a934d4a700fb3b992b87fb1cc1e6e5af3937" translate="yes" xml:space="preserve">
          <source>The format of the log file is described in this users guide in &lt;a href=&quot;eventlog-formats#eventlog-encodings&quot;&gt;Eventlog encodings&lt;/a&gt; It can be parsed in Haskell using the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; library. To dump the contents of a &lt;code&gt;.eventlog&lt;/code&gt; file as text, use the tool &lt;code&gt;ghc-events show&lt;/code&gt; that comes with the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; package.</source>
          <target state="translated">The format of the log file is described in this users guide in &lt;a href=&quot;eventlog-formats#eventlog-encodings&quot;&gt;Eventlog encodings&lt;/a&gt; It can be parsed in Haskell using the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; library. To dump the contents of a &lt;code&gt;.eventlog&lt;/code&gt; file as text, use the tool &lt;code&gt;ghc-events show&lt;/code&gt; that comes with the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; package.</target>
        </trans-unit>
        <trans-unit id="be4698f989f63506bf7e347d2e60a53dbb0e6400" translate="yes" xml:space="preserve">
          <source>The format string consists of ordinary characters and &lt;em&gt;conversion specifications&lt;/em&gt;, which specify how to format one of the arguments to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; in the output string. A format specification is introduced by the &lt;code&gt;%&lt;/code&gt; character; this character can be self-escaped into the format string using &lt;code&gt;%%&lt;/code&gt;. A format specification ends with a &lt;em&gt;format character&lt;/em&gt; that provides the primary information about how to format the value. The rest of the conversion specification is optional. In order, one may have flag characters, a width specifier, a precision specifier, and type-specific modifier characters.</source>
          <target state="translated">フォーマット文字列は、通常の文字と&lt;em&gt;変換指定&lt;/em&gt;で構成され、出力文字列で &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; の引数の1つをフォーマットする方法を指定します。フォーマット指定は &lt;code&gt;%&lt;/code&gt; 文字によって導入されます。この文字は、 &lt;code&gt;%%&lt;/code&gt; を使用してフォーマット文字列に自己エスケープできます。フォーマット指定は、値のフォーマット方法に関する主要な情報を提供する&lt;em&gt;フォーマット文字&lt;/em&gt;で終わります。残りの変換指定はオプションです。順番に、フラグ文字、幅指定子、精度指定子、およびタイプ固有の修飾子文字を含めることができます。</target>
        </trans-unit>
        <trans-unit id="25e09c7cb4393ecfca8f299ffa2b0d2ecb753a77" translate="yes" xml:space="preserve">
          <source>The former will result in far better code.</source>
          <target state="translated">前者の方がはるかに良いコードになります。</target>
        </trans-unit>
        <trans-unit id="64194ba26d3825d046086abae5391759fabeb498" translate="yes" xml:space="preserve">
          <source>The full Haskell import syntax is supported, including &lt;code&gt;hiding&lt;/code&gt; and &lt;code&gt;as&lt;/code&gt; clauses. The prompt shows the modules that are currently imported, but it omits details about &lt;code&gt;hiding&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, and so on. To see the full story, use &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">非表示や &lt;code&gt;as&lt;/code&gt; 句など、Haskellの完全なインポート構文がサポートされ &lt;code&gt;hiding&lt;/code&gt; ます。プロンプトを示し、現在インポートされたモジュールが、それは詳細について省略 &lt;code&gt;hiding&lt;/code&gt; 、 &lt;code&gt;as&lt;/code&gt; などを。ストーリー全体を表示するには、&lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="6d2ba0a02591100122d7720b515c37aa08242448" translate="yes" xml:space="preserve">
          <source>The full set of warning options is described below. To turn off any warning, simply give the corresponding &lt;code&gt;-Wno-...&lt;/code&gt; option on the command line. For backwards compatibility with GHC versions prior to 8.0, all these warnings can still be controlled with &lt;code&gt;-f(no-)warn-*&lt;/code&gt; instead of &lt;code&gt;-W(no-)*&lt;/code&gt;.</source>
          <target state="translated">警告オプションの完全なセットを以下に説明します。警告をオフにするには、コマンドラインで対応する &lt;code&gt;-Wno-...&lt;/code&gt; オプションを指定します。8.0より前のGHCバージョンとの下位互換性のために、これらすべての警告は、 &lt;code&gt;-W(no-)*&lt;/code&gt; ではなく &lt;code&gt;-f(no-)warn-*&lt;/code&gt; で引き続き制御できます。</target>
        </trans-unit>
        <trans-unit id="dc028589c7596178a298d55a5adc62737995f4c1" translate="yes" xml:space="preserve">
          <source>The fully-qualified name of the module where the type is declared</source>
          <target state="translated">型が宣言されているモジュールの完全修飾名</target>
        </trans-unit>
        <trans-unit id="a1840c040d0f137dff3d86a1c41a473b6f4799b8" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; is like &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;, but it takes an extra argument which is an &lt;em&gt;exception predicate&lt;/em&gt;, a function which selects which type of exceptions we're interested in.</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; に似ていますが、&lt;em&gt;例外の述語&lt;/em&gt;である追加の引数を受け取ります。これは、対象となる&lt;em&gt;例外の&lt;/em&gt;タイプを選択する関数です。</target>
        </trans-unit>
        <trans-unit id="6c24fa3787eba0e6f28035b825969cadbe339326" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;data-complex#v:polar&quot;&gt;polar&lt;/a&gt;&lt;/code&gt; takes a complex number and returns a (magnitude, phase) pair in canonical form: the magnitude is nonnegative, and the phase in the range &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt;; if the magnitude is zero, then so is the phase.</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;data-complex#v:polar&quot;&gt;polar&lt;/a&gt;&lt;/code&gt; は複素数を取り、（大きさ、位相）のペアを正準形式で返します：大きさは負ではなく、範囲 &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt; の位相です。大きさがゼロの場合、位相も同様です。</target>
        </trans-unit>
        <trans-unit id="d424b407dc86bdf0a0767c07efa10515030815a2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; applied to a real floating-point number returns the significand expressed as an &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; and an appropriately scaled exponent (an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;). If &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; yields &lt;code&gt;(m,n)&lt;/code&gt;, then &lt;code&gt;x&lt;/code&gt; is equal in value to &lt;code&gt;m*b^^n&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix, and furthermore, either &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are both zero or else &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt;, where &lt;code&gt;d&lt;/code&gt; is the value of &lt;code&gt;&lt;a href=&quot;ghc-float#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt;. In particular, &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt;. If the type contains a negative zero, also &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt;. &lt;em&gt;The result of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is unspecified if either of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-float#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;or&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-float#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">実数の浮動小数点数に適用された関数 &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; および適切にスケーリングされた指数（ &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ）として表現された仮数を返します。 &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; が &lt;code&gt;(m,n)&lt;/code&gt; 生成する場合、 &lt;code&gt;x&lt;/code&gt; の値は &lt;code&gt;m*b^^n&lt;/code&gt; に等しく、 &lt;code&gt;b&lt;/code&gt; は浮動小数点の基数であり、さらに、 &lt;code&gt;m&lt;/code&gt; と &lt;code&gt;n&lt;/code&gt; の両方がゼロか、 &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt; 、ここで &lt;code&gt;d&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ghc-float#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt; の値です。特に、 &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt; 。タイプに負のゼロが含まれている場合は、 &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt; も返します。 &lt;code&gt;&lt;a href=&quot;ghc-float#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt; x &lt;em&gt;または&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;ghc-float#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt; xの&lt;em&gt;いずれか&lt;/em&gt;&lt;em&gt;が&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; の&lt;em&gt;場合&lt;/em&gt;&lt;em&gt;、&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; &lt;em&gt;の結果&lt;/em&gt;&lt;em&gt;は不定です&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fe262135e4b1d91cb57eb1b81744970db71313a5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; takes a real fractional number &lt;code&gt;x&lt;/code&gt; and returns a pair &lt;code&gt;(n,f)&lt;/code&gt; such that &lt;code&gt;x = n+f&lt;/code&gt;, and:</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; は、実数の小数 &lt;code&gt;x&lt;/code&gt; を取り、 &lt;code&gt;x = n+f&lt;/code&gt; ようなペア &lt;code&gt;(n,f)&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="afbc2bb6bd9e243f694f4d3b3dece0b75ced87dd" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; applied to a real floating-point number returns the significand expressed as an &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; and an appropriately scaled exponent (an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;). If &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; yields &lt;code&gt;(m,n)&lt;/code&gt;, then &lt;code&gt;x&lt;/code&gt; is equal in value to &lt;code&gt;m*b^^n&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix, and furthermore, either &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are both zero or else &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt;, where &lt;code&gt;d&lt;/code&gt; is the value of &lt;code&gt;&lt;a href=&quot;prelude#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt;. In particular, &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt;. If the type contains a negative zero, also &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt;. &lt;em&gt;The result of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is unspecified if either of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;or&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">実数の浮動小数点数に適用された関数 &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; および適切にスケーリングされた指数（ &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ）として表現された仮数を返します。場合 &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; 収率 &lt;code&gt;(m,n)&lt;/code&gt; 、次に &lt;code&gt;x&lt;/code&gt; に値が等しい &lt;code&gt;m*b^^n&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 浮動小数点基数であり、さらに、いずれかの &lt;code&gt;m&lt;/code&gt; 及び &lt;code&gt;n&lt;/code&gt; 、ゼロあるいはその両方である &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt; 、ここで &lt;code&gt;d&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;prelude#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt; の値です。特に、 &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt; 。タイプに負のゼロが含まれている場合は、 &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt; も返します。 &lt;code&gt;&lt;a href=&quot;prelude#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt; x &lt;em&gt;または&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt; xの&lt;em&gt;いずれか&lt;/em&gt;&lt;em&gt;が&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; の&lt;em&gt;場合&lt;/em&gt;&lt;em&gt;、&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; &lt;em&gt;の結果&lt;/em&gt;&lt;em&gt;は不定です&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="079629951658e63a1aceb4ed5c824cc91a0b5d86" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; takes a real fractional number &lt;code&gt;x&lt;/code&gt; and returns a pair &lt;code&gt;(n,f)&lt;/code&gt; such that &lt;code&gt;x = n+f&lt;/code&gt;, and:</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; は、実数の小数 &lt;code&gt;x&lt;/code&gt; を取り、 &lt;code&gt;x = n+f&lt;/code&gt; ようなペア &lt;code&gt;(n,f)&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="88f909330278d9f82a3312e25ef59ec6d2186b36" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;coerce&lt;/code&gt; allows you to safely convert between values of types that have the same representation with no run-time overhead. In the simplest case you can use it instead of a newtype constructor, to go from the newtype's concrete type to the abstract type. But it also works in more complicated settings, e.g. converting a list of newtypes to a list of concrete types.</source>
          <target state="translated">関数 &lt;code&gt;coerce&lt;/code&gt; を使用すると、ランタイムオーバーヘッドのない同じ表現を持つ型の値間で安全に変換できます。最も単純なケースでは、newtypeコンストラクタの代わりにそれを使用して、newtypeの具象型から抽象型に移動できます。しかし、それはより複雑な設定でも機能します。例えば、newtypesのリストを具象型のリストに変換します。</target>
        </trans-unit>
        <trans-unit id="a9426870a71de06c1f556cf879bcdaf0553394f4" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f3&lt;/code&gt; has a rank-3 type; it has rank-2 types on the left of a function arrow.</source>
          <target state="translated">関数 &lt;code&gt;f3&lt;/code&gt; には、ランク3タイプがあります。関数矢印の左側にランク2タイプがあります。</target>
        </trans-unit>
        <trans-unit id="4bebe5f1a75a0eddf8839f635c3decbffc5557dc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f&lt;/code&gt; below will fail when applied to &lt;code&gt;Bar&lt;/code&gt;, so the compiler will emit a warning about this when &lt;a href=&quot;#ghc-flag--Wincomplete-record-updates&quot;&gt;&lt;code&gt;-Wincomplete-record-updates&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">以下の関数 &lt;code&gt;f&lt;/code&gt; は、 &lt;code&gt;Bar&lt;/code&gt; に適用すると失敗するため、&lt;a href=&quot;#ghc-flag--Wincomplete-record-updates&quot;&gt; &lt;code&gt;-Wincomplete-record-updates&lt;/code&gt; &lt;/a&gt;が有効になっている場合、コンパイラーはこれについて警告を発します。</target>
        </trans-unit>
        <trans-unit id="782d3d59f72773f7952ce1ebae2822b75b04a8b7" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f&lt;/code&gt; from the previous section has a more accurate type:</source>
          <target state="translated">前のセクションの関数 &lt;code&gt;f&lt;/code&gt; には、より正確なタイプがあります。</target>
        </trans-unit>
        <trans-unit id="7ec7041ec2658984f17f499a66ced25885c4a3a1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fromList&lt;/code&gt; constructs the structure &lt;code&gt;l&lt;/code&gt; from the given list of &lt;code&gt;Item l&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;fromList&lt;/code&gt; は、与えられた &lt;code&gt;Item l&lt;/code&gt; のリストから構造 &lt;code&gt;l&lt;/code&gt; を構築します。</target>
        </trans-unit>
        <trans-unit id="53dd445850b902910cfbc7105e43df3c60dfa18d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fromListN&lt;/code&gt; takes the input list&amp;rsquo;s length as a hint. Its behaviour should be equivalent to &lt;code&gt;fromList&lt;/code&gt;. The hint can be used for more efficient construction of the structure &lt;code&gt;l&lt;/code&gt; compared to &lt;code&gt;fromList&lt;/code&gt;. If the given hint is not equal to the input list&amp;rsquo;s length the behaviour of &lt;code&gt;fromListN&lt;/code&gt; is not specified.</source>
          <target state="translated">関数 &lt;code&gt;fromListN&lt;/code&gt; は、入力リストの長さをヒントとして受け取ります。その動作は &lt;code&gt;fromList&lt;/code&gt; と同等でなければなりません。ヒントは、構造体 &lt;code&gt;l&lt;/code&gt; を &lt;code&gt;fromList&lt;/code&gt; と比較してより効率的に構築するために使用できます。指定されたヒントが入力リストの長さに等しくない場合、 &lt;code&gt;fromListN&lt;/code&gt; の動作は指定されません。</target>
        </trans-unit>
        <trans-unit id="b2c51e1ae6a25019f5b8dcb68c7e1cc6360380a0" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;g&lt;/code&gt; from the previous section is now rejected with a type error as we would hope because the type of &lt;code&gt;f&lt;/code&gt; does not allow the two arguments to have different types. This, then, is an example of a multiple parameter class that does actually work quite well in practice, without ambiguity problems. There is, however, a catch. This version of the &lt;code&gt;Collects&lt;/code&gt; class is nowhere near as general as the original class seemed to be: only one of the four instances for &lt;code&gt;Collects&lt;/code&gt; given above can be used with this version of Collects because only one of them&amp;mdash;the instance for lists&amp;mdash;has a collection type that can be written in the form &lt;code&gt;c
e&lt;/code&gt;, for some type constructor &lt;code&gt;c&lt;/code&gt;, and element type &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">前のセクションの関数 &lt;code&gt;g&lt;/code&gt; は、 &lt;code&gt;f&lt;/code&gt; の型では2つの引数に異なる型を指定できないため、期待どおりに型エラーで拒否されます。これは、実際にはあいまいさの問題がなく、実際には非常にうまく機能する複数のパラメータークラスの例です。ただし、落とし穴があります。このバージョンの &lt;code&gt;Collects&lt;/code&gt; クラスは、元のクラスのように一般的ではありません。上記の &lt;code&gt;Collects&lt;/code&gt; の4つのインスタンスのうち1つだけがこのバージョンのCollectsで使用できます。型コンストラクター &lt;code&gt;c&lt;/code&gt; の &lt;code&gt;c e&lt;/code&gt; の形式で記述できるコレクション型、および要素型 &lt;code&gt;e&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e1caf69d4b138be614d3615769e3ef6ea6617e4" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;toList&lt;/code&gt; should be the inverse of &lt;code&gt;fromList&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;toList&lt;/code&gt; の逆でなければなりません &lt;code&gt;fromList&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3f8ca21e6067d938666eb5fad69ffc6307e5c9d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;unsafeCoerce#&lt;/code&gt; allows you to side-step the typechecker entirely. That is, it allows you to coerce any type into any other type. If you use this function, you had better get it right, otherwise segmentation faults await. It is generally used when you want to write a program that you know is well-typed, but where Haskell's type system is not expressive enough to prove that it is well typed.</source>
          <target state="translated">関数 &lt;code&gt;unsafeCoerce#&lt;/code&gt; を使用すると、タイプチェッカーを完全に回避できます。つまり、任意のタイプを他のタイプに強制変換できます。この関数を使用する場合は、正しく設定することをお勧めします。そうしないと、セグメンテーション違反が発生します。よく型付けされていることがわかっているプログラムを作成したいが、Haskellの型システムが十分に型付けされていることを証明するのに十分な表現力がない場合に、一般的に使用されます。</target>
        </trans-unit>
        <trans-unit id="4078d840830c2b32e85bca92ef57e0c6f82bd822" translate="yes" xml:space="preserve">
          <source>The function also returns two new handles: * an I/O Completion Port handle on which events will be signaled. * a Job handle which can be used to kill all running processes.</source>
          <target state="translated">この関数は、2つの新しいハンドルも返します。*イベントがシグナルされるI/O完了ポートハンドル。*実行中のプロセスをすべて終了させるために使用できるジョブハンドル。</target>
        </trans-unit>
        <trans-unit id="f6e72213f9f513b34bc27c803b9c687fb47fd6c8" translate="yes" xml:space="preserve">
          <source>The function arrow &lt;code&gt;-&amp;gt;&lt;/code&gt; is &lt;code&gt;infixr&lt;/code&gt; with fixity -1.</source>
          <target state="translated">関数 &lt;code&gt;infixr&lt;/code&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; は、固定度-1のinfixrです。</target>
        </trans-unit>
        <trans-unit id="54424bef429db403f4735db658be9ddb164137b0" translate="yes" xml:space="preserve">
          <source>The function creates a temporary file in ReadWrite mode. The created file isn't deleted automatically, so you need to delete it manually.</source>
          <target state="translated">この関数は、ReadWrite モードで一時ファイルを作成します。作成されたファイルは自動的には削除されないので、手動で削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="4d31db636076141a2d374629e18c022c852ebef1" translate="yes" xml:space="preserve">
          <source>The function doesn't verify whether the path exists.</source>
          <target state="translated">この関数はパスが存在するかどうかを検証しません。</target>
        </trans-unit>
        <trans-unit id="add6d8a8d14a017a7abdc22d6a499ce254500df6" translate="yes" xml:space="preserve">
          <source>The function is assumed to define a total ordering.</source>
          <target state="translated">この関数は、全体の順序を定義することを前提としています。</target>
        </trans-unit>
        <trans-unit id="8c87908085624472ff4238bfb948223b787875d2" translate="yes" xml:space="preserve">
          <source>The function that applies a parser must now unwrap each of the monad transformers in turn:</source>
          <target state="translated">パーサを適用する関数は、モナド変換器を順番にアンラップしていく必要があります。</target>
        </trans-unit>
        <trans-unit id="83dbb4039dba1fe07aa4bcd8c6ba58bf457a2ec1" translate="yes" xml:space="preserve">
          <source>The function to modify the environment.</source>
          <target state="translated">環境を修正する機能です。</target>
        </trans-unit>
        <trans-unit id="1ccbf33c88dc57758ba1b802fb4f53d665b9edec" translate="yes" xml:space="preserve">
          <source>The function type constructor.</source>
          <target state="translated">関数型のコンストラクタです。</target>
        </trans-unit>
        <trans-unit id="f0f44ae6963080cf76e0ebf83f004dc8df761919" translate="yes" xml:space="preserve">
          <source>The function will return the corresponding value as &lt;code&gt;(&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; value)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the key isn't in the map.</source>
          <target state="translated">この関数は、対応する値を返します &lt;code&gt;(&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; value)&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; キーがマップにない場合。</target>
        </trans-unit>
        <trans-unit id="2928b1b30db8e1f8656b8116560fcb94973556a2" translate="yes" xml:space="preserve">
          <source>The function will return the corresponding value as &lt;code&gt;(&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; value)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the key isn't in the map.</source>
          <target state="translated">The function will return the corresponding value as &lt;code&gt;(&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; value)&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the key isn't in the map.</target>
        </trans-unit>
        <trans-unit id="ce3cf6b1fb41916c15598ef7c7a2316d0affe736" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to a comparison function, but the more general type ensures that the implementation uses it to compare elements of the first container with elements of the second.</source>
          <target state="translated">この関数は通常は比較関数に適用されますが、より一般的な型は、実装が第1のコンテナの要素と第2のコンテナの要素を比較するためにそれを使用することを保証します。</target>
        </trans-unit>
        <trans-unit id="57722a7fa81914229dcd7f438a467425fc2444d4" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to an equality function, but the more general type ensures that the implementation uses it to compare elements of the first container with elements of the second.</source>
          <target state="translated">この関数は通常は平等関数に適用されますが、より一般的な型は、実装が第1のコンテナの要素と第2のコンテナの要素を比較するためにそれを使用することを保証します。</target>
        </trans-unit>
        <trans-unit id="a2f33e33f25cc5b116bd53d1e8871c737f431f0f" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to comparison functions, but the more general type ensures that the implementation uses them to compare elements of the first container with elements of the second.</source>
          <target state="translated">この関数は通常比較関数に適用されますが、より一般的な型は、実装が第1のコンテナの要素と第2のコンテナの要素を比較するためにそれらを使用することを保証します。</target>
        </trans-unit>
        <trans-unit id="4fea0a18b8df51f28201953f3c7f75703eb47939" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to equality functions, but the more general type ensures that the implementation uses them to compare elements of the first container with elements of the second.</source>
          <target state="translated">この関数は通常は等値関数に適用されますが、より一般的な型は、実装が第1のコンテナの要素と第2のコンテナの要素を比較するためにそれらを使用することを保証します。</target>
        </trans-unit>
        <trans-unit id="6b6bc4aeee7f2323c64ee51bd60f90b62c365dcb" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;f2&lt;/code&gt; and &lt;code&gt;g2&lt;/code&gt; have rank-2 types; the &lt;code&gt;forall&lt;/code&gt; is on the left of a function arrow. As &lt;code&gt;g2&lt;/code&gt; shows, the polymorphic type on the left of the function arrow can be overloaded.</source>
          <target state="translated">関数 &lt;code&gt;f2&lt;/code&gt; および &lt;code&gt;g2&lt;/code&gt; には、ランク2タイプがあります。 &lt;code&gt;forall&lt;/code&gt; 、関数矢印の左側にあります。 &lt;code&gt;g2&lt;/code&gt; に示すように、関数矢印の左側の多型のタイプは、オーバーロードすることができます。</target>
        </trans-unit>
        <trans-unit id="436e2ff4e3f10ce06692935420d28156ccb98ad6" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; have the same body, but only &lt;code&gt;f&lt;/code&gt; is given a type signature. When GHC is figuring out how to process a visible type application, it must know what variable to instantiate. It thus must be able to provide an ordering to the type variables in a function&amp;rsquo;s type.</source>
          <target state="translated">関数 &lt;code&gt;f&lt;/code&gt; と &lt;code&gt;g&lt;/code&gt; の本体は同じですが、型シグネチャが与えられるのは &lt;code&gt;f&lt;/code&gt; だけです。GHCが可視型アプリケーションの処理方法を理解するとき、インスタンス化する変数を知っている必要があります。したがって、関数の型の型変数に順序を提供できる必要があります。</target>
        </trans-unit>
        <trans-unit id="709a35f15e3b44bedbeb0d4b4dddb4664dc2f475" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;g5&lt;/code&gt; and &lt;code&gt;g6&lt;/code&gt; mean exactly the same thing. But &lt;code&gt;g7&lt;/code&gt; evaluates &lt;code&gt;(f x)&lt;/code&gt;, binds &lt;code&gt;y&lt;/code&gt; to the result, and then evaluates &lt;code&gt;body&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;g5&lt;/code&gt; と &lt;code&gt;g6&lt;/code&gt; はまったく同じ意味です。しかし、 &lt;code&gt;g7&lt;/code&gt; は &lt;code&gt;(f x)&lt;/code&gt; 評価し、 &lt;code&gt;y&lt;/code&gt; を結果にバインドしてから、 &lt;code&gt;body&lt;/code&gt; を評価します。</target>
        </trans-unit>
        <trans-unit id="0b19b31f5cbfb6277d7255768c1a9509164d5a55" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt; are careful to force values before installing them in an &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;. This is usually more efficient in cases where laziness is not essential. The functions in this module do not do so.</source>
          <target state="translated">関数&lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strictは&lt;/a&gt;、それらをインストールする前に値を強制的に注意を払っている &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 。これは通常、怠惰が必須ではない場合により効率的です。このモジュールの関数はそうしません。</target>
        </trans-unit>
        <trans-unit id="670d1298e5cb7a4e8403b208919c4f9aa9e19f28" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;data-map-strict&quot;&gt;Data.Map.Strict&lt;/a&gt; are careful to force values before installing them in a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;. This is usually more efficient in cases where laziness is not essential. The functions in this module do not do so.</source>
          <target state="translated">&lt;a href=&quot;data-map-strict&quot;&gt;Data.Map.Strict&lt;/a&gt;の関数は、 &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; にインストールする前に値を強制するように注意しています。これは通常、怠惰が必須ではない場合により効率的です。このモジュールの関数はそうしません。</target>
        </trans-unit>
        <trans-unit id="d7ac968071ec3d6db992b2e9189f08e304a943fb" translate="yes" xml:space="preserve">
          <source>The functions in this library use the following naming conventions:</source>
          <target state="translated">このライブラリの関数は、以下の命名規則を使用しています。</target>
        </trans-unit>
        <trans-unit id="4d771bd73e07b4943d9ccd53e1231da21d4a47f0" translate="yes" xml:space="preserve">
          <source>The functions in this module obey the runtime system's locale, character set encoding, and line ending conversion settings.</source>
          <target state="translated">このモジュールの関数は、ランタイムシステムのロケール、文字セットのエンコーディング、行末変換の設定に従います。</target>
        </trans-unit>
        <trans-unit id="d0245bbfde5cb4645880f74fa8998ab54478221f" translate="yes" xml:space="preserve">
          <source>The general form is &lt;code&gt;%&amp;lt;modifier&amp;gt;&amp;lt;width&amp;gt;&amp;lt;alternate&amp;gt;&amp;lt;specifier&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;modifier&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;alternate&amp;gt;&lt;/code&gt; are optional.</source>
          <target state="translated">一般的な形式は &lt;code&gt;%&amp;lt;modifier&amp;gt;&amp;lt;width&amp;gt;&amp;lt;alternate&amp;gt;&amp;lt;specifier&amp;gt;&lt;/code&gt; です。ここで、 &lt;code&gt;&amp;lt;modifier&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;lt;alternate&amp;gt;&lt;/code&gt; はオプションです。</target>
        </trans-unit>
        <trans-unit id="d87f5dd37c519e3511a8db8b010d4f7ff96c2337" translate="yes" xml:space="preserve">
          <source>The general interface</source>
          <target state="translated">一般的なインターフェイス</target>
        </trans-unit>
        <trans-unit id="ec767503aee97b2532b6ed4020896fc0a3c857b5" translate="yes" xml:space="preserve">
          <source>The general principle is this:</source>
          <target state="translated">一般的な原則はこれです。</target>
        </trans-unit>
        <trans-unit id="63fa8f01398fe9d9b6a5c91481c5c9f9c693d55d" translate="yes" xml:space="preserve">
          <source>The general rendering interface, supporting annotations. Please refer to the &lt;code&gt;Style&lt;/code&gt; and &lt;code&gt;Mode&lt;/code&gt; types for a description of rendering mode, line length and ribbons.</source>
          <target state="translated">アノテーションをサポートする一般的なレンダリングインターフェイス。レンダリングモード、線の長さ、リボンの説明については、 &lt;code&gt;Style&lt;/code&gt; と &lt;code&gt;Mode&lt;/code&gt; タイプを参照してください。</target>
        </trans-unit>
        <trans-unit id="443a3115347a69de80f7eab2e438bb5e78262ac7" translate="yes" xml:space="preserve">
          <source>The general rendering interface. Please refer to the &lt;code&gt;Style&lt;/code&gt; and &lt;code&gt;Mode&lt;/code&gt; types for a description of rendering mode, line length and ribbons.</source>
          <target state="translated">一般的なレンダリングインターフェイス。レンダリングモード、線の長さ、リボンの説明については、 &lt;code&gt;Style&lt;/code&gt; と &lt;code&gt;Mode&lt;/code&gt; タイプを参照してください。</target>
        </trans-unit>
        <trans-unit id="2c8107939525836136417ba263c01627df220ab0" translate="yes" xml:space="preserve">
          <source>The generated code for the &lt;code&gt;Functor Wrong&lt;/code&gt; instance would look exactly the same, except with &lt;code&gt;Wrong&lt;/code&gt; replacing every occurrence of &lt;code&gt;Right&lt;/code&gt;. The problem is now that &lt;code&gt;fmap&lt;/code&gt; is being applied recursively to a value of type &lt;code&gt;Either a Int&lt;/code&gt;. This cannot possibly produce a value of type &lt;code&gt;Either b Int&lt;/code&gt;, as &lt;code&gt;fmap&lt;/code&gt; can only change the last type parameter! This causes the generated code to be ill-typed.</source>
          <target state="translated">以下のために生成されたコード &lt;code&gt;Functor Wrong&lt;/code&gt; インスタンスはして除き、まったく同じになります &lt;code&gt;Wrong&lt;/code&gt; のすべての出現置き換える &lt;code&gt;Right&lt;/code&gt; 。問題は、 &lt;code&gt;fmap&lt;/code&gt; が &lt;code&gt;Either a Int&lt;/code&gt; 型の値に再帰的に適用されていることです。これは、おそらく型の値を生成することができない &lt;code&gt;Either b Int&lt;/code&gt; 通り、 &lt;code&gt;fmap&lt;/code&gt; のみ最後の型パラメータを変更することができます！これにより、生成されたコードの型が不適切になります。</target>
        </trans-unit>
        <trans-unit id="32903708d002dac9c0ac078342e2e27cabf0d2dd" translate="yes" xml:space="preserve">
          <source>The generation number of this GC</source>
          <target state="translated">このGCの世代番号</target>
        </trans-unit>
        <trans-unit id="878b032694848adb77a2b859c02bd1b95a7bae5c" translate="yes" xml:space="preserve">
          <source>The goal here is to &lt;code&gt;lift&lt;/code&gt; from monad &lt;code&gt;m&lt;/code&gt; to &lt;code&gt;t2 m&lt;/code&gt; and then &lt;code&gt;lift&lt;/code&gt; this again into &lt;code&gt;t1 (t2 m)&lt;/code&gt;. However, this second &lt;code&gt;lift&lt;/code&gt; can only be accepted when &lt;code&gt;(t2 m)&lt;/code&gt; is a monad and there is no way of establishing that this fact universally holds.</source>
          <target state="translated">ここでの目標は、である &lt;code&gt;lift&lt;/code&gt; モナドから &lt;code&gt;m&lt;/code&gt; まで &lt;code&gt;t2 m&lt;/code&gt; 、その後、 &lt;code&gt;lift&lt;/code&gt; に再びこれを &lt;code&gt;t1 (t2 m)&lt;/code&gt; 。ただし、この2番目の &lt;code&gt;lift&lt;/code&gt; は、 &lt;code&gt;(t2 m)&lt;/code&gt; がモナドである場合にのみ受け入れることができ、この事実が普遍的に当てはまることを確立する方法はありません。</target>
        </trans-unit>
        <trans-unit id="cbfa1f88a3966514e5f590037e0742d3e33e28f3" translate="yes" xml:space="preserve">
          <source>The goal is to preserve the meaning of paths better than &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:normalise&quot;&gt;normalise&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">目標は、 &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:normalise&quot;&gt;normalise&lt;/a&gt;&lt;/code&gt; よりもパスの意味を維持することです。</target>
        </trans-unit>
        <trans-unit id="4e6155b86f48a01b347dfb545d9546dfe24b006f" translate="yes" xml:space="preserve">
          <source>The goal of the roles system is to track when two types have the same underlying representation. In the example above, &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; have the same representation. But, the corresponding instances of &lt;code&gt;BadIdea&lt;/code&gt; would &lt;em&gt;not&lt;/em&gt; have the same representation, because the types of the implementations of &lt;code&gt;bad&lt;/code&gt; would be different.</source>
          <target state="translated">役割システムの目標は、2つのタイプの基礎となる表現が同じである場合を追跡することです。上記の例では、 &lt;code&gt;Age&lt;/code&gt; と &lt;code&gt;Int&lt;/code&gt; は同じ表現を持っています。ただし、 &lt;code&gt;bad&lt;/code&gt; の実装のタイプが異なるため、 &lt;code&gt;BadIdea&lt;/code&gt; の対応するインスタンスは同じ表現にはなり&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="ae5a7fa8ebdfcbe0b2302748233617b3ca55c26a" translate="yes" xml:space="preserve">
          <source>The goal of typed holes is to help with writing Haskell code rather than to change the type system. Typed holes can be used to obtain extra information from the type checker, which might otherwise be hard to get. Normally, using GHCi, users can inspect the (inferred) type signatures of all top-level bindings. However, this method is less convenient with terms that are not defined on top-level or inside complex expressions. Holes allow the user to check the type of the term they are about to write.</source>
          <target state="translated">型付き穴の目的は、型システムを変更することではなく、Haskellのコードを書くのを助けることです。型付き穴は、型チェッカーから余分な情報を得るために使用することができます。通常、GHCiを使うと、ユーザはすべてのトップレベルバインディングの(推測される)型シグネチャを検査することができます。しかし、この方法はトップレベルで定義されていない用語や複雑な式の内部ではあまり便利ではありません。穴を使うと、ユーザーはこれから書こうとしている用語の型をチェックすることができます。</target>
        </trans-unit>
        <trans-unit id="0cbbcd933189820e27a73038da6c88d11c5e0b90" translate="yes" xml:space="preserve">
          <source>The gory details:</source>
          <target state="translated">ゴリゴリのディテール。</target>
        </trans-unit>
        <trans-unit id="19256158b7bc99497456b028690add2697259def" translate="yes" xml:space="preserve">
          <source>The grammar is ambiguous regarding the extent of lambda abstractions, let expressions, and conditionals. The ambiguity is resolved by the meta-rule that each of these constructs extends as far to the right as possible.</source>
          <target state="translated">文法はラムダ抽象、let式、条件式の範囲に関して曖昧です。この曖昧さは、これらの構文のそれぞれが可能な限り右に伸びるというメタルールによって解決されています。</target>
        </trans-unit>
        <trans-unit id="13bcdca0f47d6db8faa9273bbcc3a3514eb3a812" translate="yes" xml:space="preserve">
          <source>The graph obtained by reversing all edges.</source>
          <target state="translated">すべての辺を反転させて得られるグラフ。</target>
        </trans-unit>
        <trans-unit id="84d579939cacc525ddd770c640be60c5f760cbb9" translate="yes" xml:space="preserve">
          <source>The graph: a list of nodes uniquely identified by keys, with a list of keys of nodes this node has edges to. The out-list may contain keys that don't correspond to nodes of the graph; such edges are ignored.</source>
          <target state="translated">グラフ:キーによって一意に識別されるノードのリスト.アウトリストには,グラフのノードに対応しないキーが含まれている場合があり,そのようなエッジは無視されます.</target>
        </trans-unit>
        <trans-unit id="19a77ba5e8a6424783c2bacf9d044768e5056e5e" translate="yes" xml:space="preserve">
          <source>The group database</source>
          <target state="translated">グループデータベース</target>
        </trans-unit>
        <trans-unit id="f37dce2ec9ac848392eba760bfa9b2a8e001c3e2" translate="yes" xml:space="preserve">
          <source>The hash sign does not change semantics at all. We tend to use variable names ending in &amp;ldquo;#&amp;rdquo; for unboxed values or types (e.g. &lt;code&gt;Int#&lt;/code&gt;), but there is no requirement to do so; they are just plain ordinary variables. Nor does the &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension bring anything into scope. For example, to bring &lt;code&gt;Int#&lt;/code&gt; into scope you must import &lt;code&gt;GHC.Prim&lt;/code&gt; (see &lt;a href=&quot;#primitives&quot;&gt;Unboxed types and primitive operations&lt;/a&gt;); the &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension then allows you to &lt;em&gt;refer&lt;/em&gt; to the &lt;code&gt;Int#&lt;/code&gt; that is now in scope. Note that with this option, the meaning of &lt;code&gt;x#y = 0&lt;/code&gt; is changed: it defines a function &lt;code&gt;x#&lt;/code&gt; taking a single argument &lt;code&gt;y&lt;/code&gt;; to define the operator &lt;code&gt;#&lt;/code&gt;, put a space: &lt;code&gt;x # y = 0&lt;/code&gt;.</source>
          <target state="translated">ハッシュ記号はセマンティクスをまったく変更しません。ボックス化されていない値または型（たとえば &lt;code&gt;Int#&lt;/code&gt; ）には、「＃」で終わる変数名を使用する傾向がありますが、そうする必要はありません。それらは単なる普通の変数です。また、&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt;拡張機能は何も対象外とします。たとえば、 &lt;code&gt;Int#&lt;/code&gt; をスコープに &lt;code&gt;GHC.Prim&lt;/code&gt; インポートする必要があります（&lt;a href=&quot;#primitives&quot;&gt;ボックス&lt;/a&gt;化されていない型とプリミティブ操作を参照）。&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; の&lt;/a&gt;拡張子は、あなたがすることができます&lt;em&gt;参照してください&lt;/em&gt;に &lt;code&gt;Int#&lt;/code&gt; スコープになりました。このオプションを使用すると、 &lt;code&gt;x#y = 0&lt;/code&gt; 意味が変更されることに注意してください。単一の引数を取る関数 &lt;code&gt;x#&lt;/code&gt; を定義します。 &lt;code&gt;y&lt;/code&gt; ; 演算子 &lt;code&gt;#&lt;/code&gt; を定義するには、スペースを入れます： &lt;code&gt;x # y = 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5774d0c554fe343baa60ffa9eae14d57f8ade00" translate="yes" xml:space="preserve">
          <source>The header describes each event type and its length. Tools that don&amp;rsquo;t recognise a particular event type can skip those events.</source>
          <target state="translated">The header describes each event type and its length. Tools that don&amp;rsquo;t recognise a particular event type can skip those events.</target>
        </trans-unit>
        <trans-unit id="2210882c0ad0919709f59e7db6b4f28dc98cefd9" translate="yes" xml:space="preserve">
          <source>The header line is followed by ⟨l⟩ lines each containing one completion candidate encoded as (quoted) string literal. Here are some example invocations showing the various cases:</source>
          <target state="translated">ヘッダー行の後には、(引用符で囲まれた)文字列リテラルとしてエンコードされた1つの補完候補を含む⟨l⟩行が続きます。ここでは、様々なケースを示すいくつかの呼び出し例を示します。</target>
        </trans-unit>
        <trans-unit id="de913877c8fa30a91fa438399fb16f39f34a7e00" translate="yes" xml:space="preserve">
          <source>The header of a signature is &lt;code&gt;signature A where ...&lt;/code&gt; (instead of the usual &lt;code&gt;module A where ...&lt;/code&gt;).</source>
          <target state="translated">署名のヘッダーは、署名 &lt;code&gt;signature A where ...&lt;/code&gt; （通常の &lt;code&gt;module A where ...&lt;/code&gt; 代わり）です。</target>
        </trans-unit>
        <trans-unit id="78e62bbf377912fb128bb2f1870fb9fa408d92d9" translate="yes" xml:space="preserve">
          <source>The heap profiler can produce output to GHC&amp;rsquo;s event log, allowing samples to be correlated with other event log events over the program&amp;rsquo;s lifecycle.</source>
          <target state="translated">ヒーププロファイラーは、GHCのイベントログに出力を生成できるため、プログラムのライフサイクル全体でサンプルを他のイベントログイベントと関連付けることができます。</target>
        </trans-unit>
        <trans-unit id="5cd522d72de3dbc3a1ac632468d70b83c0446184" translate="yes" xml:space="preserve">
          <source>The heap-overflow message.</source>
          <target state="translated">ヒープオーバーフローメッセージ。</target>
        </trans-unit>
        <trans-unit id="baec639ab942341375f18c11aa4da668c27baef2" translate="yes" xml:space="preserve">
          <source>The hexadecimal notation for floating point literals is useful when you need to specify floating point constants precisely, as the literal notation corresponds closely to the underlying bit-encoding of the number.</source>
          <target state="translated">浮動小数点リテラルの16進数表記は、浮動小数点定数を正確に指定する必要がある場合に便利です。</target>
        </trans-unit>
        <trans-unit id="0542015ab0e10f3b338b694e109bbc36d0e1ca73" translate="yes" xml:space="preserve">
          <source>The history is only available when using &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt;; the reason for this is we found that logging each breakpoint in the history cuts performance by a factor of 2 or more.</source>
          <target state="translated">履歴は&lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; を&lt;/a&gt;使用している場合にのみ利用できます。これは、履歴の各ブレークポイントをログに記録すると、パフォーマンスが2倍以上低下することがわかったためです。</target>
        </trans-unit>
        <trans-unit id="8e8742e7091ac952b2100b44f6fcab38011c36c7" translate="yes" xml:space="preserve">
          <source>The hpc command has several sub-commands:</source>
          <target state="translated">hpcコマンドにはいくつかのサブコマンドがあります。</target>
        </trans-unit>
        <trans-unit id="cd85d2b986388d0386fde70a80e9bce5adc09ca4" translate="yes" xml:space="preserve">
          <source>The hpc tool assumes you are in the top-level directory of the location where you built your application, and the &lt;code&gt;.tix&lt;/code&gt; file is in the same top-level directory. You can use the flag &lt;code&gt;--srcdir&lt;/code&gt; to use &lt;code&gt;hpc&lt;/code&gt; for any other directory, and use &lt;code&gt;--srcdir&lt;/code&gt; multiple times to analyse programs compiled from difference locations, as is typical for packages.</source>
          <target state="translated">hpcツールは、アプリケーションをビルドした場所の最上位ディレクトリにいること、および &lt;code&gt;.tix&lt;/code&gt; ファイルが同じ最上位ディレクトリにあることを前提としています。フラグ &lt;code&gt;--srcdir&lt;/code&gt; を使用して、他のディレクトリに &lt;code&gt;hpc&lt;/code&gt; を使用し、 &lt;code&gt;--srcdir&lt;/code&gt; 複数回使用して、パッケージの典型的なように、異なる場所からコンパイルされたプログラムを分析できます。</target>
        </trans-unit>
        <trans-unit id="ae95e293d652aa6b2e442077a87caf492f54c808" translate="yes" xml:space="preserve">
          <source>The idea is that &lt;code&gt;a&lt;/code&gt; should really be a representational parameter, but role inference assigns it to phantom. This makes some level of sense: a pointer to an &lt;code&gt;Int&lt;/code&gt; really is representationally the same as a pointer to a &lt;code&gt;Bool&lt;/code&gt;. But, that&amp;rsquo;s not at all how we want to use &lt;code&gt;Ptr&lt;/code&gt;s! So, we want to be able to say</source>
          <target state="translated">考えは、 &lt;code&gt;a&lt;/code&gt; は実際には表現パラメータであるべきだということですが、役割の推論はそれをファントムに割り当てます。これは感覚のいくつかのレベルを行いますへのポインタ &lt;code&gt;Int&lt;/code&gt; 本当にrepresentationallyへのポインタと同じである &lt;code&gt;Bool&lt;/code&gt; 。しかし、それは &lt;code&gt;Ptr&lt;/code&gt; をどのように使用したいかではありません！だから、私たちは言うことができるようにしたいです</target>
        </trans-unit>
        <trans-unit id="e9b8ad3e3c7027edac335bae313b7046d76ae478" translate="yes" xml:space="preserve">
          <source>The idea is that we can then use &lt;code&gt;Point&lt;/code&gt; just as if we had defined a new datatype &lt;code&gt;MyPoint&lt;/code&gt; with two fields &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">これで、2つのフィールド &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; で新しいデータ型 &lt;code&gt;MyPoint&lt;/code&gt; を定義した場合と同じように、 &lt;code&gt;Point&lt;/code&gt; を使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="b5577da026d4ae923963655859a7950c0d959c92" translate="yes" xml:space="preserve">
          <source>The idea is that we have a new fundamental type constant &lt;code&gt;TYPE&lt;/code&gt;, which is parameterised by a &lt;code&gt;RuntimeRep&lt;/code&gt;. We thus get &lt;code&gt;Int# :: TYPE 'IntRep&lt;/code&gt; and &lt;code&gt;Bool :: TYPE 'LiftedRep&lt;/code&gt;. Anything with a type of the form &lt;code&gt;TYPE x&lt;/code&gt; can appear to either side of a function arrow &lt;code&gt;-&amp;gt;&lt;/code&gt;. We can thus say that &lt;code&gt;-&amp;gt;&lt;/code&gt; has type &lt;code&gt;TYPE r1 -&amp;gt; TYPE r2 -&amp;gt; TYPE 'LiftedRep&lt;/code&gt;. The result is always lifted because all functions are lifted in GHC.</source>
          <target state="translated">これは、 &lt;code&gt;RuntimeRep&lt;/code&gt; によってパラメーター化される新しい基本型定数 &lt;code&gt;TYPE&lt;/code&gt; があるという考え方です。したがって、 &lt;code&gt;Int# :: TYPE 'IntRep&lt;/code&gt; および &lt;code&gt;Bool :: TYPE 'LiftedRep&lt;/code&gt; ます。 &lt;code&gt;TYPE x&lt;/code&gt; の形式のタイプを持つものはすべて、関数矢印 &lt;code&gt;-&amp;gt;&lt;/code&gt; のどちらの側にも表示できます。したがって、 &lt;code&gt;-&amp;gt;&lt;/code&gt; の型は &lt;code&gt;TYPE r1 -&amp;gt; TYPE r2 -&amp;gt; TYPE 'LiftedRep&lt;/code&gt; ます。GHCではすべての機能が解除されるため、結果は常に解除されます。</target>
        </trans-unit>
        <trans-unit id="fa2009e07206ad049abebf85b239bfe1d707aee1" translate="yes" xml:space="preserve">
          <source>The idea is there can be no legal calls to &lt;code&gt;f&lt;/code&gt; because every call will give rise to an ambiguous constraint. Indeed, the &lt;em&gt;only&lt;/em&gt; purpose of the ambiguity check is to report functions that cannot possibly be called. We could soundly omit the ambiguity check on type signatures entirely, at the expense of delaying ambiguity errors to call sites. Indeed, the language extension &lt;a href=&quot;#extension-AllowAmbiguousTypes&quot;&gt;&lt;code&gt;AllowAmbiguousTypes&lt;/code&gt;&lt;/a&gt; switches off the ambiguity check.</source>
          <target state="translated">すべての呼び出しはあいまいな制約を引き起こすため、 &lt;code&gt;f&lt;/code&gt; への正当な呼び出しはあり得ないという考えです。実際、あいまいさチェックの&lt;em&gt;唯一の&lt;/em&gt;目的は、呼び出すことができない可能性のある関数を報告することです。型のシグネチャのあいまいさチェックを完全に省略することができますが、呼び出しサイトへのあいまいさエラーを遅らせます。実際、言語拡張&lt;a href=&quot;#extension-AllowAmbiguousTypes&quot;&gt; &lt;code&gt;AllowAmbiguousTypes&lt;/code&gt; &lt;/a&gt;は、あいまいさチェックをオフにします。</target>
        </trans-unit>
        <trans-unit id="9edc673edb982c2282b649a46c26961301e8081f" translate="yes" xml:space="preserve">
          <source>The idea of using existential quantification in data type declarations was suggested by Perry, and implemented in Hope+ (Nigel Perry, &lt;em&gt;The Implementation of Practical Functional Programming Languages&lt;/em&gt;, PhD Thesis, University of London, 1991). It was later formalised by Laufer and Odersky (&lt;em&gt;Polymorphic type inference and abstract data types&lt;/em&gt;, TOPLAS, 16(5), pp. 1411-1430, 1994). It&amp;rsquo;s been in Lennart Augustsson&amp;rsquo;s &lt;code&gt;hbc&lt;/code&gt; Haskell compiler for several years, and proved very useful. Here&amp;rsquo;s the idea. Consider the declaration:</source>
          <target state="translated">データ型宣言で実存定量化を使用するアイデアは、Perryによって提案され、Hope +で実装されました（Nigel Perry、&lt;em&gt;実践的な関数型プログラミング言語の実装&lt;/em&gt;、博士論文、ロンドン大学、1991）。それは後にLauferとOdersky によって形式化されました（&lt;em&gt;ポリモーフィック型推論と抽象データ型&lt;/em&gt;、TOPLAS、16（5）、pp。1411-1430、1994）。これは数年前からLennart Augustssonの &lt;code&gt;hbc&lt;/code&gt; Haskellコンパイラにあり、非常に有用であることが証明されています。これがアイデアです。宣言を検討してください：</target>
        </trans-unit>
        <trans-unit id="f61001cad70bbaad44a625a79404312846844b51" translate="yes" xml:space="preserve">
          <source>The identity arrow, which plays the role of &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in arrow notation.</source>
          <target state="translated">矢印の表記法で &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; の役割を果たすアイデンティティー矢印。</target>
        </trans-unit>
        <trans-unit id="d797741d4a3ad156d7b9784f618a05a1d311a057" translate="yes" xml:space="preserve">
          <source>The identity functor and monad.</source>
          <target state="translated">アイデンティティファンクタとモナド。</target>
        </trans-unit>
        <trans-unit id="7c8b0e59b588b67f3edbe61854791ee47cfe12bb" translate="yes" xml:space="preserve">
          <source>The identity monad transformer</source>
          <target state="translated">アイデンティティモナド変換器</target>
        </trans-unit>
        <trans-unit id="54f9712c13de60b181bae26ad1f4c1f7a1f328db" translate="yes" xml:space="preserve">
          <source>The identity monad transformer.</source>
          <target state="translated">アイデンティティモナド変換器。</target>
        </trans-unit>
        <trans-unit id="bf1cafdec594d8369ed303bb1c662b40aaf0daff" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; のアイデンティティ</target>
        </trans-unit>
        <trans-unit id="a4ceda1c87510537b203d25ca80c04c39b54cdf6" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt;. It should also satisfy the equations</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; のアイデンティティ。また、方程式を満たしている必要があります</target>
        </trans-unit>
        <trans-unit id="deee9983cee920e92095b678fac9a903e0f11845" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; のアイデンティティ</target>
        </trans-unit>
        <trans-unit id="034960daf8bea9c51407ed94a1c25464ed2788bc" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;ghc-base#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt;. It should also satisfy the equations</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; のアイデンティティ。また、方程式を満たしている必要があります</target>
        </trans-unit>
        <trans-unit id="5dbaaef3597110434c54ae1a2138fb5629731bbb" translate="yes" xml:space="preserve">
          <source>The implementation does not support system calls.</source>
          <target state="translated">実装はシステムコールをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="7512c5f22af2e468e091d738afee317bd6f3ab0c" translate="yes" xml:space="preserve">
          <source>The implementation is based on</source>
          <target state="translated">に基づいて実装されています。</target>
        </trans-unit>
        <trans-unit id="4406a52eaac6bbe886c15f95aa7c9a4f4887ba65" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. Additionally, benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">実装は&lt;em&gt;ビッグエンディアンパトリシアツリーに&lt;/em&gt;基づいてい&lt;em&gt;ます&lt;/em&gt;。このデータ構造は、 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; のようなバイナリ演算で特によく機能します。さらに、ベンチマークは、一般的なサイズ&lt;a href=&quot;data-map&quot;&gt;調整&lt;/a&gt;されたマップ実装と比較した場合、挿入と削除が（はるかに）高速であることも示しています（Data.Mapを参照）。</target>
        </trans-unit>
        <trans-unit id="42cee383ad635f6c8d6a1715e198b017fcd560b8" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. Additionally, benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">実装は&lt;em&gt;ビッグエンディアンパトリシアツリーに&lt;/em&gt;基づいてい&lt;em&gt;ます&lt;/em&gt;。このデータ構造は、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; のようなバイナリ演算で特によく機能します。さらに、ベンチマークは、一般的なサイズ&lt;a href=&quot;data-map&quot;&gt;調整&lt;/a&gt;されたマップ実装と比較した場合、挿入と削除が（はるかに）高速であることも示しています（Data.Mapを参照）。</target>
        </trans-unit>
        <trans-unit id="5899bda78d1b99406df43306b7f1534696819133" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. Additionally, benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">実装は&lt;em&gt;ビッグエンディアンパトリシアツリーに&lt;/em&gt;基づいてい&lt;em&gt;ます&lt;/em&gt;。このデータ構造は、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; のようなバイナリ演算で特によく機能します。さらに、ベンチマークは、一般的なサイズ&lt;a href=&quot;data-map&quot;&gt;調整&lt;/a&gt;されたマップ実装と比較した場合、挿入と削除が（はるかに）高速であることも示しています（Data.Mapを参照）。</target>
        </trans-unit>
        <trans-unit id="78d8c8ee898c5c545e70528f4e14f986552f2ded" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. However, my benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">実装は&lt;em&gt;ビッグエンディアンパトリシアツリーに&lt;/em&gt;基づいてい&lt;em&gt;ます&lt;/em&gt;。このデータ構造は、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; のようなバイナリ演算で特によく機能します。ただし、私のベンチマークは、一般的なサイズのバランスのとれたマップ実装と比較した場合（&lt;a href=&quot;data-map&quot;&gt;Data.Mapを&lt;/a&gt;参照）、挿入と削除が（はるかに）速いことを示しています。</target>
        </trans-unit>
        <trans-unit id="24c8616bf917dc1c69eac297bc08b786fe0c06a6" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intset#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intset#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. However, my benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced set implementation (see &lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;).</source>
          <target state="translated">実装は&lt;em&gt;ビッグエンディアンパトリシアツリーに&lt;/em&gt;基づいてい&lt;em&gt;ます&lt;/em&gt;。このデータ構造は、 &lt;code&gt;&lt;a href=&quot;data-intset#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;data-intset#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; のようなバイナリ演算で特によく機能します。ただし、私のベンチマークは、一般的なサイズのバランスのとれたセットの実装（&lt;a href=&quot;data-set&quot;&gt;Data.Setを&lt;/a&gt;参照）と比較すると、挿入と削除が（はるかに）高速であることを示しています。</target>
        </trans-unit>
        <trans-unit id="55fccc3b15937a9358c0161b537d1afd44dfe908" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. However, my benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced set implementation (see &lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;).</source>
          <target state="translated">実装は&lt;em&gt;ビッグエンディアンパトリシアツリーに&lt;/em&gt;基づいてい&lt;em&gt;ます&lt;/em&gt;。このデータ構造は、 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; のようなバイナリ演算で特によく機能します。ただし、私のベンチマークは、一般的なサイズのバランスのとれたセットの実装（&lt;a href=&quot;data-set&quot;&gt;Data.Setを&lt;/a&gt;参照）と比較すると、挿入と削除が（はるかに）高速であることを示しています。</target>
        </trans-unit>
        <trans-unit id="178e58b7fb96bd95fd580401e99f441f886cc770" translate="yes" xml:space="preserve">
          <source>The implementation is based on the traditional purely-functional queue representation that uses two lists to obtain amortised O(1) enqueue and dequeue operations.</source>
          <target state="translated">実装は、償却されたO(1)のenqueueとdequeue操作を得るために2つのリストを使用する伝統的な純粋に機能的なキュー表現に基づいています。</target>
        </trans-unit>
        <trans-unit id="4463036bd69024477097c960a434a6af09c8061f" translate="yes" xml:space="preserve">
          <source>The implementation is required to ensure that reordering of memory operations cannot cause type-correct code to go wrong. In particular, when inspecting the value read from an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;, the memory writes that created that value must have occurred from the point of view of the current thread.</source>
          <target state="translated">実装は、メモリ操作の並べ替えによってタイプが正しいコードが正しく実行されないようにするために必要です。特に、 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; から読み取られた値を検査する場合、その値を作成したメモリへの書き込みは、現在のスレッドの観点から発生している必要があります。</target>
        </trans-unit>
        <trans-unit id="2265bbdfb2325f3d1ecc971e928ff3e80fe406dd" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;. If the function passed to &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; inspects its argument, the resulting action will throw &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:FixIOException&quot;&gt;FixIOException&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">実装 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt;&lt;/code&gt; のための &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; に渡された関数がその引数を検査する場合、結果のアクションは &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:FixIOException&quot;&gt;FixIOException&lt;/a&gt;&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="fb8ec445b14ea757e9282327414d673b0305ee28" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;. If the function passed to &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; inspects its argument, the resulting action will throw &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:FixIOException&quot;&gt;FixIOException&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">実装 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt;&lt;/code&gt; のための &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; に渡された関数がその引数を検査する場合、結果のアクションは &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:FixIOException&quot;&gt;FixIOException&lt;/a&gt;&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="10f5d1702e3170c14a64676532aebf2fd23b667a" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is based on &lt;em&gt;size balanced&lt;/em&gt; binary trees (or trees of &lt;em&gt;bounded balance&lt;/em&gt;) as described by:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; の実装は、以下で説明するように、&lt;em&gt;サイズがバランスのとれた&lt;/em&gt;バイナリツリー（または&lt;em&gt;有界バランスの&lt;/em&gt;ツリー）に基づいてい&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f3594b695ff2e4cfc4a3fffda3940bb5f4b15f6c" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is based on &lt;em&gt;size balanced&lt;/em&gt; binary trees (or trees of &lt;em&gt;bounded balance&lt;/em&gt;) as described by:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; の実装は、以下で説明するように、&lt;em&gt;サイズがバランスのとれた&lt;/em&gt;バイナリツリー（または&lt;em&gt;有界バランスの&lt;/em&gt;ツリー）に基づいてい&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f3ded865df489185e9f39c1a5890fb3ac2d0d16a" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; is based on &lt;em&gt;size balanced&lt;/em&gt; binary trees (or trees of &lt;em&gt;bounded balance&lt;/em&gt;) as described by:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; の実装は、以下で説明するように、&lt;em&gt;サイズがバランスのとれた&lt;/em&gt;バイナリツリー（または&lt;em&gt;有界バランスの&lt;/em&gt;ツリー）に基づいてい&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="2eb1e65a073f89d353d1b82491d0d335135d9d69" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;code&gt;&lt;a href=&quot;ghci-message#v:RunTH&quot;&gt;RunTH&lt;/a&gt;&lt;/code&gt; message</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-message#v:RunTH&quot;&gt;RunTH&lt;/a&gt;&lt;/code&gt; メッセージの実装</target>
        </trans-unit>
        <trans-unit id="0444f9d8082237d5b98f84df587436a9614cf1ab" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;code&gt;&lt;a href=&quot;ghci-message#v:StartTH&quot;&gt;StartTH&lt;/a&gt;&lt;/code&gt; message: create a new IORef QState, and return a RemoteRef to it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-message#v:StartTH&quot;&gt;StartTH&lt;/a&gt;&lt;/code&gt; メッセージの実装：新しいIORef QStateを作成し、それにRemoteRefを返します。</target>
        </trans-unit>
        <trans-unit id="6bc3fa0b81755563203b0ca242878725420112c8" translate="yes" xml:space="preserve">
          <source>The implementation uses 2-3 finger trees annotated with sizes, as described in section 4.2 of</source>
          <target state="translated">の 4.2 節で説明されているように、実装ではサイズでアノテーションされた 2-3 本のフィンガーツリーを使用しています。</target>
        </trans-unit>
        <trans-unit id="a87c4ceafe0cd86c1c0f98a96d0e26cff7b08cc5" translate="yes" xml:space="preserve">
          <source>The implementation uses the call-stack simulation maintained by the profiler, so it only works if the program was compiled with &lt;code&gt;-prof&lt;/code&gt; and contains suitable SCC annotations (e.g. by using &lt;code&gt;-fprof-auto&lt;/code&gt;). Otherwise, the list returned is likely to be empty or uninformative.</source>
          <target state="translated">実装はプロファイラによって維持されるコールスタックシミュレーションを使用するため、プログラムが &lt;code&gt;-prof&lt;/code&gt; でコンパイルされ、適切なSCC注釈が含まれている場合にのみ機能します（たとえば、 &lt;code&gt;-fprof-auto&lt;/code&gt; を使用して）。そうでない場合、返されるリストは空であるか、情報がない可能性があります。</target>
        </trans-unit>
        <trans-unit id="b6788a58c1982f00220dd59a9ac7e8fe15617f19" translate="yes" xml:space="preserve">
          <source>The incoming &lt;code&gt;x&lt;/code&gt; is converted using &lt;code&gt;&lt;a href=&quot;ghc-generics#v:from&quot;&gt;from&lt;/a&gt;&lt;/code&gt;, then we dispatch to the generic instances using &lt;code&gt;encode'&lt;/code&gt;. We use this as a default definition for &lt;code&gt;encode&lt;/code&gt;. We need the &lt;code&gt;default encode&lt;/code&gt; signature because ordinary Haskell default methods must not introduce additional class constraints, but our generic default does.</source>
          <target state="translated">入力 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ghc-generics#v:from&quot;&gt;from&lt;/a&gt;&lt;/code&gt; を使用して変換され、次に &lt;code&gt;encode'&lt;/code&gt; を使用して汎用インスタンスにディスパッチします。これを &lt;code&gt;encode&lt;/code&gt; のデフォルト定義として使用します。通常のHaskellのデフォルトメソッドでは追加のクラス制約を導入してはならないため、 &lt;code&gt;default encode&lt;/code&gt; シグネチャが必要ですが、一般的なデフォルトではそれを導入しています。</target>
        </trans-unit>
        <trans-unit id="2cdd8c06c5214198e849b6d05981aab3d32d8114" translate="yes" xml:space="preserve">
          <source>The incremental input interface</source>
          <target state="translated">インクリメンタル入力インターフェース</target>
        </trans-unit>
        <trans-unit id="982c0c54fd891b5bd49cff179145ac54d3aa5b07" translate="yes" xml:space="preserve">
          <source>The incremental interface consumes a strict &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; at a time, each being part of the total amount of input. If your decoder needs more input to finish it will return a &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Partial&quot;&gt;Partial&lt;/a&gt;&lt;/code&gt; with a continuation. If there is no more input, provide it &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">インクリメンタルインターフェイスは、厳密な &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; を一度に消費します。それぞれが入力の合計量の一部です。デコーダーが終了するためにより多くの入力を必要とする場合は、継続を伴う &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Partial&quot;&gt;Partial&lt;/a&gt;&lt;/code&gt; を返します。これ以上入力がない場合は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を指定してください。</target>
        </trans-unit>
        <trans-unit id="f5fa1eaf98cc1d03c60771d063de7bc0a8c7e802" translate="yes" xml:space="preserve">
          <source>The incremental interface consumes a strict &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; at a time, each being part of the total amount of input. If your decoder needs more input to finish it will return a &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Partial&quot;&gt;Partial&lt;/a&gt;&lt;/code&gt; with a continuation. If there is no more input, provide it &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">インクリメンタルインターフェイスは、 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; に厳密なByteStringを消費し、それぞれが入力の合計量の一部になります。デコーダーが終了するためにより多くの入力が必要な場合は、継続して &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Partial&quot;&gt;Partial&lt;/a&gt;&lt;/code&gt; を返します。これ以上入力がない場合は、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を指定します。</target>
        </trans-unit>
        <trans-unit id="b3146e319b6642665d719ade7d912bb954ff2d63" translate="yes" xml:space="preserve">
          <source>The incremental interface gives you more control over how input is provided during parsing. This lets you e.g. interleave parsing and I/O.</source>
          <target state="translated">インクリメンタルインターフェースを使用すると、解析中に入力がどのように提供されるかをより制御することができます。これにより、例えばパースやI/Oをインターリーブすることができます。</target>
        </trans-unit>
        <trans-unit id="a6d79c63965b8db6183932a4864f6bc6a68ec9ed" translate="yes" xml:space="preserve">
          <source>The indicated thread has been been woken up on another capability.</source>
          <target state="translated">表示されたスレッドは別の能力で起動されています。</target>
        </trans-unit>
        <trans-unit id="3fe6927713a0d567bb5595e1921afdf920aea86e" translate="yes" xml:space="preserve">
          <source>The indicated thread has been given a label (e.g. with &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:setThreadLabel&quot;&gt;Control.Concurrent.setThreadLabel&lt;/a&gt;).</source>
          <target state="translated">The indicated thread has been given a label (e.g. with &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:setThreadLabel&quot;&gt;Control.Concurrent.setThreadLabel&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="d766deb37652756438446d85435fb842af7f7ec5" translate="yes" xml:space="preserve">
          <source>The indicated thread has been migrated to a new capability.</source>
          <target state="translated">表示されているスレッドは新しい機能に移行されました。</target>
        </trans-unit>
        <trans-unit id="3ee679cea0bd8e5594a77998bcffe40595e2bc90" translate="yes" xml:space="preserve">
          <source>The indicated thread has started running.</source>
          <target state="translated">表示されているスレッドが動き出しました。</target>
        </trans-unit>
        <trans-unit id="01836651ef18a2e66ee3afe13febce95aa0f2625" translate="yes" xml:space="preserve">
          <source>The indicated thread has stopped running for the reason given by &lt;code&gt;status&lt;/code&gt;.</source>
          <target state="translated">The indicated thread has stopped running for the reason given by &lt;code&gt;status&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c157bc7e4dea489c9b0115c1f05cad2ef0e188e" translate="yes" xml:space="preserve">
          <source>The indicated thread is has been marked as ready to run.</source>
          <target state="translated">表示されているスレッドは、実行準備ができているとマークされています。</target>
        </trans-unit>
        <trans-unit id="5e10db54e6f002a3c2b9a12ba3b2e1c228bc85a6" translate="yes" xml:space="preserve">
          <source>The inferred status is volatile: if an unsafe import is added to the module &lt;code&gt;B&lt;/code&gt;, it will cause compilation error of &lt;code&gt;A&lt;/code&gt;. When &lt;a href=&quot;#ghc-flag--Winferred-safe-imports&quot;&gt;&lt;code&gt;-Winferred-safe-imports&lt;/code&gt;&lt;/a&gt; is enabled, the compiler will emit a warning about this. This option is off by default.</source>
          <target state="translated">The inferred status is volatile: if an unsafe import is added to the module &lt;code&gt;B&lt;/code&gt; , it will cause compilation error of &lt;code&gt;A&lt;/code&gt; . When &lt;a href=&quot;#ghc-flag--Winferred-safe-imports&quot;&gt; &lt;code&gt;-Winferred-safe-imports&lt;/code&gt; &lt;/a&gt; is enabled, the compiler will emit a warning about this. This option is off by default.</target>
        </trans-unit>
        <trans-unit id="c051b888dc5371d4c7a1728cceef03c9f9b40699" translate="yes" xml:space="preserve">
          <source>The information is formatted such that it can be read as a of type &lt;code&gt;[(String, String)]&lt;/code&gt;. Currently the following fields are present:</source>
          <target state="translated">情報は、タイプ &lt;code&gt;[(String, String)]&lt;/code&gt; として読み取ることができるようにフォーマットされます。現在、次のフィールドがあります。</target>
        </trans-unit>
        <trans-unit id="5a76a6fe1392f713b6ebeea929ebb56029f377be" translate="yes" xml:space="preserve">
          <source>The initial counter value can be negative which denotes a resource &quot;debt&quot; that requires a respective amount of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:signalTSem&quot;&gt;signalTSem&lt;/a&gt;&lt;/code&gt; operations to counter-balance.</source>
          <target state="translated">カウンターの初期値は、カウンターバランスするためにそれぞれの量の &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:signalTSem&quot;&gt;signalTSem&lt;/a&gt;&lt;/code&gt; 操作を必要とするリソースの「負債」を示す負の値にすることができます。</target>
        </trans-unit>
        <trans-unit id="2dec26d2e77fa146664e92628931f0bd402a7a5d" translate="yes" xml:space="preserve">
          <source>The initial value left and right of the cursor</source>
          <target state="translated">カーソルの左右の初期値</target>
        </trans-unit>
        <trans-unit id="c7b64e8e48e54908c3b727b4c3f0042b5289f865" translate="yes" xml:space="preserve">
          <source>The initialisation routine, &lt;code&gt;mylib_init&lt;/code&gt;, calls &lt;code&gt;hs_init()&lt;/code&gt; as normal to initialise the Haskell runtime, and the corresponding deinitialisation function &lt;code&gt;mylib_end()&lt;/code&gt; calls &lt;code&gt;hs_exit()&lt;/code&gt; to shut down the runtime.</source>
          <target state="translated">初期化ルーチン &lt;code&gt;mylib_init&lt;/code&gt; は通常どおり &lt;code&gt;hs_init()&lt;/code&gt; を呼び出してHaskellランタイムを初期化し、対応する非初期化関数 &lt;code&gt;mylib_end()&lt;/code&gt; は &lt;code&gt;hs_exit()&lt;/code&gt; を呼び出してランタイムをシャットダウンします。</target>
        </trans-unit>
        <trans-unit id="77a4bde453187e4123c0b62e7f8a1460d7c946e4" translate="yes" xml:space="preserve">
          <source>The injectivity annotation is added after the type family head and consists of two parts:</source>
          <target state="translated">インジェクションアノテーションは、タイプ・ファミリー・ヘッドの後に追加され、2つの部分から構成されています。</target>
        </trans-unit>
        <trans-unit id="74ecac49867880c39edcc9122f73fce73221a98f" translate="yes" xml:space="preserve">
          <source>The input file should end with .hsc (it should be plain Haskell source only; literate Haskell is not supported at the moment). Output files by default get names with the &lt;code&gt;.hsc&lt;/code&gt; suffix replaced:</source>
          <target state="translated">入力ファイルは.hscで終わる必要があります（これはプレーンなHaskellソースのみである必要があります。現時点では、読み書き可能なHaskellはサポートされていません）。デフォルトでは、出力ファイルは &lt;code&gt;.hsc&lt;/code&gt; サフィックスが置き換えられた名前を取得します。</target>
        </trans-unit>
        <trans-unit id="54a5800cd273f30522c8241f5237a75f5ea6ce1e" translate="yes" xml:space="preserve">
          <source>The input lines stored in the history (newest first)</source>
          <target state="translated">履歴に格納されている入力行(新しい順</target>
        </trans-unit>
        <trans-unit id="6c739498395288f23756ffacf049c5d728041bb8" translate="yes" xml:space="preserve">
          <source>The input prompt</source>
          <target state="translated">入力プロンプト</target>
        </trans-unit>
        <trans-unit id="57092b7ab7c2a987bc9c90336b0ad9cdf5249eb0" translate="yes" xml:space="preserve">
          <source>The input value that caused the error. If the error arose because the end of input was reached or could not be identified precisely, this value will be &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">エラーの原因となった入力値。入力の終わりに達したか、正確に識別できなかったためにエラーが発生した場合、この値は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="c829e8dd6d64c1ce230cecb6f9d190426f2f0af1" translate="yes" xml:space="preserve">
          <source>The input value that caused the error. If the error arose because the end of input was reached or could not be identified precisely, this value will be &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">エラーの原因となった入力値。入力の終わりに達したため、または正確に識別できなかったためにエラーが発生した場合、この値は &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="194fbc6c8e32f5966df1c8df3ba5f34c6b050d18" translate="yes" xml:space="preserve">
          <source>The installer that installs GHC on Win32 also sets up the file-suffix associations for &amp;ldquo;.hs&amp;rdquo; and &amp;ldquo;.lhs&amp;rdquo; files so that double-clicking them starts &lt;code&gt;ghci&lt;/code&gt;.</source>
          <target state="translated">The installer that installs GHC on Win32 also sets up the file-suffix associations for &amp;ldquo;.hs&amp;rdquo; and &amp;ldquo;.lhs&amp;rdquo; files so that double-clicking them starts &lt;code&gt;ghci&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38d4405c8eebc2938893eeda1606e7e5691e0dd1" translate="yes" xml:space="preserve">
          <source>The installer that installs GHC on Win32 also sets up the file-suffix associations for &amp;rdquo;.hs&amp;rdquo; and &amp;rdquo;.lhs&amp;rdquo; files so that double-clicking them starts &lt;code&gt;ghci&lt;/code&gt;.</source>
          <target state="translated">Win32にGHCをインストールするインストーラーは、「。hs」および「.lhs」ファイルのファイルサフィックスの関連付けも設定するため、それらをダブルクリックすると &lt;code&gt;ghci&lt;/code&gt; が起動します。</target>
        </trans-unit>
        <trans-unit id="aeaab7d9918fe1175bfdf3172a8ff60d6d574ffa" translate="yes" xml:space="preserve">
          <source>The instance axioms : &lt;code&gt;(B a, D a, E a) =&amp;gt; F a&lt;/code&gt;</source>
          <target state="translated">インスタンスの公理： &lt;code&gt;(B a, D a, E a) =&amp;gt; F a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf7d82e643d691468293fcd6f5135cfe7a24d9a1" translate="yes" xml:space="preserve">
          <source>The instance context is determined by the type signatures of the derived class&amp;rsquo;s methods. For instance, if the class is:</source>
          <target state="translated">インスタンスコンテキストは、派生クラスのメソッドの型シグネチャによって決定されます。たとえば、クラスが次の場合：</target>
        </trans-unit>
        <trans-unit id="ead7524ad446883d4bbd99873e64016bb63c69da" translate="yes" xml:space="preserve">
          <source>The instance declaration is only relevant if the type &lt;code&gt;T&lt;/code&gt; is in use, and if so, GHC will have visited &lt;code&gt;A&lt;/code&gt;&amp;lsquo;s interface file to find &lt;code&gt;T&lt;/code&gt;&amp;lsquo;s definition.</source>
          <target state="translated">インスタンス宣言は、タイプ &lt;code&gt;T&lt;/code&gt; が使用されている場合にのみ関連します。使用されている場合、GHCは &lt;code&gt;A&lt;/code&gt; のインターフェースファイルにアクセスして &lt;code&gt;T&lt;/code&gt; の定義を検索します。</target>
        </trans-unit>
        <trans-unit id="a7c74af4802b1ad145c9277583e68f6f35a7769d" translate="yes" xml:space="preserve">
          <source>The instance declaration is only relevant if the type &lt;code&gt;T&lt;/code&gt; is in use, and if so, GHC will have visited &lt;code&gt;A&lt;/code&gt;&amp;rsquo;s interface file to find &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s definition.</source>
          <target state="translated">The instance declaration is only relevant if the type &lt;code&gt;T&lt;/code&gt; is in use, and if so, GHC will have visited &lt;code&gt;A&lt;/code&gt; &amp;rsquo;s interface file to find &lt;code&gt;T&lt;/code&gt; &amp;rsquo;s definition.</target>
        </trans-unit>
        <trans-unit id="c7c21710f81c09d49133c941cdff45d1b58bd4f0" translate="yes" xml:space="preserve">
          <source>The instance declarations of a data family used in a single program may not overlap at all, independent of whether they are associated or not. In contrast to type class instances, this is not only a matter of consistency, but one of type safety.</source>
          <target state="translated">一つのプログラムで使用されるデータファミリのインスタンス宣言は、それらが関連付けられているかどうかに関係なく、全く重ならないことがあります。型クラスのインスタンスとは対照的に、これは一貫性の問題だけでなく、型の安全性の問題でもあります。</target>
        </trans-unit>
        <trans-unit id="8cc7dac373c8ecc1b365857145ddad40214eea96" translate="yes" xml:space="preserve">
          <source>The instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; is slightly awkward (but also rarely used):</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; のインスタンスは少し厄介です（ただし、ほとんど使用されません）。</target>
        </trans-unit>
        <trans-unit id="289b8b3ebc33cd2f4157166d16a368f79f089f26" translate="yes" xml:space="preserve">
          <source>The instance for an associated type can be omitted in class instances. In that case, unless there is a default instance (see &lt;a href=&quot;#assoc-decl-defs&quot;&gt;Associated type synonym defaults&lt;/a&gt;), the corresponding instance type is not inhabited; i.e., only diverging expressions, such as &lt;code&gt;undefined&lt;/code&gt;, can assume the type.</source>
          <target state="translated">関連する型のインスタンスは、クラスインスタンスでは省略できます。その場合、デフォルトのインスタンスがない限り（&lt;a href=&quot;#assoc-decl-defs&quot;&gt;関連するタイプのシノニムのデフォルトを&lt;/a&gt;参照）、対応するインスタンスタイプは存在しません。つまり、 &lt;code&gt;undefined&lt;/code&gt; などの発散式のみが型を想定できます。</target>
        </trans-unit>
        <trans-unit id="59904cb0ab2fe8f19f68bd984f2b517b8091cc17" translate="yes" xml:space="preserve">
          <source>The instances of &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; for lists, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; defined in the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; satisfy these laws.</source>
          <target state="translated">&lt;a href=&quot;prelude&quot;&gt;プレリュードで&lt;/a&gt;定義されたリスト、 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; のインスタンスは、これらの法律を満たしています。</target>
        </trans-unit>
        <trans-unit id="585199a1b65eac2628d79ac97b369b88ce05f950" translate="yes" xml:space="preserve">
          <source>The instances of &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; for lists, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; defined in the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; satisfy these laws.</source>
          <target state="translated">&lt;a href=&quot;prelude&quot;&gt;プレリュードで&lt;/a&gt;定義されたリスト、 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; のインスタンスは、これらの法律を満たしています。</target>
        </trans-unit>
        <trans-unit id="1581053810276ec21d30df3978e3008a7ff9fc55" translate="yes" xml:space="preserve">
          <source>The instances of &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; for lists, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; defined in the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; satisfy these laws.</source>
          <target state="translated">&lt;a href=&quot;prelude&quot;&gt;プレリュードで&lt;/a&gt;定義されたリスト、 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; のインスタンスは、これらの法律を満たしています。</target>
        </trans-unit>
        <trans-unit id="1a017b052435df19797d88fb110f1e8782d90594" translate="yes" xml:space="preserve">
          <source>The instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; for lists, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; defined in the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; satisfy these laws.</source>
          <target state="translated">&lt;a href=&quot;prelude&quot;&gt;プレリュードで&lt;/a&gt;定義されたリスト、 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; のインスタンスは、これらの法律を満たしています。</target>
        </trans-unit>
        <trans-unit id="f9f0c8e6289e586cc5baeea5fcfbbbe115d5e7f6" translate="yes" xml:space="preserve">
          <source>The intention is for &lt;code&gt;IsLabel&lt;/code&gt; to be used to support overloaded record fields and perhaps anonymous records. Thus, it may be given instances for base datatypes (in particular &lt;code&gt;(-&amp;gt;)&lt;/code&gt;) in the future.</source>
          <target state="translated">意図は、 &lt;code&gt;IsLabel&lt;/code&gt; がオーバーロードされたレコードフィールドおよびおそらく匿名レコードをサポートするために使用されることです。したがって、将来、基本データ型（特に &lt;code&gt;(-&amp;gt;)&lt;/code&gt; ）のインスタンスが与えられる可能性があります。</target>
        </trans-unit>
        <trans-unit id="26b1329858bfddb7f19887db1797b6a20a449184" translate="yes" xml:space="preserve">
          <source>The interact function takes a function of type &lt;code&gt;ByteString -&amp;gt; ByteString&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">対話関数は、引数として &lt;code&gt;ByteString -&amp;gt; ByteString&lt;/code&gt; 型の関数を取ります。標準入力デバイスからの入力全体が引数としてこの関数に渡され、結果の文字列が標準出力デバイスに出力されます。</target>
        </trans-unit>
        <trans-unit id="28bb27e789e236bd63cc99925076154513d01eb7" translate="yes" xml:space="preserve">
          <source>The interactive classes (only relevant when &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt;&lt;code&gt;ExtendedDefaultRules&lt;/code&gt;&lt;/a&gt; is in effect) are: any numeric class, &lt;code&gt;Show&lt;/code&gt;, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Foldable&lt;/code&gt; or &lt;code&gt;Traversable&lt;/code&gt;.</source>
          <target state="translated">対話型クラス（&lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt; &lt;code&gt;ExtendedDefaultRules&lt;/code&gt; &lt;/a&gt;が有効な場合にのみ関連）は、数値クラス、 &lt;code&gt;Show&lt;/code&gt; 、 &lt;code&gt;Eq&lt;/code&gt; 、 &lt;code&gt;Ord&lt;/code&gt; 、 &lt;code&gt;Foldable&lt;/code&gt; または &lt;code&gt;Traversable&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0c15d5fb52d82aa70762f462a28f7dddcf408ca0" translate="yes" xml:space="preserve">
          <source>The interface file, which normally ends in a &lt;code&gt;.hi&lt;/code&gt; suffix, contains the information that GHC needs in order to compile further modules that depend on this module. It contains things like the types of exported functions, definitions of data types, and so on. It is stored in a binary format, so don&amp;rsquo;t try to read one; use the &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; option instead (see &lt;a href=&quot;#hi-options&quot;&gt;Other options related to interface files&lt;/a&gt;).</source>
          <target state="translated">通常は &lt;code&gt;.hi&lt;/code&gt; サフィックスで終わるインターフェースファイルには、このモジュールに依存するモジュールをさらにコンパイルするためにGHCが必要とする情報が含まれています。これには、エクスポートされた関数のタイプ、データタイプの定義などが含まれます。バイナリ形式で格納されているため、読み取らないでください。使用 &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; オプションが（参照代わりに&lt;a href=&quot;#hi-options&quot;&gt;インタフェースファイルに関連するその他のオプションを&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="01f926777c79e4e6d52fb1a2cf6afecc0a8b7f65" translate="yes" xml:space="preserve">
          <source>The interface output may be directed to another file &lt;code&gt;bar2/Wurble.iface&lt;/code&gt; with the option &lt;code&gt;-ohi bar2/Wurble.iface&lt;/code&gt; (not recommended).</source>
          <target state="translated">インターフェース出力は、オプション &lt;code&gt;-ohi bar2/Wurble.iface&lt;/code&gt; を &lt;code&gt;bar2/Wurble.iface&lt;/code&gt; して、別のファイルbar2 / Wurble.ifaceに送信できます（非推奨）。</target>
        </trans-unit>
        <trans-unit id="d422eff6b38b54b7b01cf3f23285761f3009b5be" translate="yes" xml:space="preserve">
          <source>The interface provides &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt;, a type representation which can be safely decomposed and composed. See &lt;a href=&quot;data-dynamic&quot;&gt;Data.Dynamic&lt;/a&gt; for an example of this.</source>
          <target state="translated">このインターフェースは &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; を提供します。これは、安全に分解および構成できる型表現です。この例については、&lt;a href=&quot;data-dynamic&quot;&gt;Data.Dynamic&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7525fed411a95f2aba1be67c722e982ae098165e" translate="yes" xml:space="preserve">
          <source>The interpreter can&amp;rsquo;t load modules with foreign export declarations!</source>
          <target state="translated">インタープリターは、モジュールを外部エクスポート宣言でロードできません！</target>
        </trans-unit>
        <trans-unit id="c6f1b29cc56478e029057e80fde7617996385c3a" translate="yes" xml:space="preserve">
          <source>The interpreter doesn&amp;rsquo;t support unboxed tuples, so GHCi will automatically compile these modules, and all modules they depend on, to object code instead of bytecode.</source>
          <target state="translated">インタープリターはボックス化されていないタプルをサポートしないため、GHCiはこれらのモジュールおよびそれらが依存するすべてのモジュールをバイトコードではなくオブジェクトコードに自動的にコンパイルします。</target>
        </trans-unit>
        <trans-unit id="bcc96915fbf058774c86b1ad6764191d649fe219" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; の逆です。</target>
        </trans-unit>
        <trans-unit id="960baabb94ec6d41e7f419f3f0516ce7cfa51827" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-trans-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; の逆です。</target>
        </trans-unit>
        <trans-unit id="25e108698be586db7ffe3f616a94bfc73b7ee1a2" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;data-time-calendar-ordinaldate#v:mondayStartWeek&quot;&gt;mondayStartWeek&lt;/a&gt;&lt;/code&gt;. Get a &lt;code&gt;&lt;a href=&quot;data-time-calendar#t:Day&quot;&gt;Day&lt;/a&gt;&lt;/code&gt; given the year, the number of the Monday-starting week, and the day of the week. The first Monday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%W&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-calendar-ordinaldate#v:mondayStartWeek&quot;&gt;mondayStartWeek&lt;/a&gt;&lt;/code&gt; の逆です。年、月曜日から始まる週の数、および &lt;code&gt;&lt;a href=&quot;data-time-calendar#t:Day&quot;&gt;Day&lt;/a&gt;&lt;/code&gt; 指定して日を取得します。最初の月曜日は週1の最初の日で、年のいずれかの早い日は週0です（として &lt;code&gt;%W&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2617db8ad5e573ea343c5794cabc4dfe2b8d32ba" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;data-time-calendar-ordinaldate#v:sundayStartWeek&quot;&gt;sundayStartWeek&lt;/a&gt;&lt;/code&gt;. Get a &lt;code&gt;&lt;a href=&quot;data-time-calendar#t:Day&quot;&gt;Day&lt;/a&gt;&lt;/code&gt; given the year and the number of the day of a Sunday-starting week. The first Sunday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%U&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-calendar-ordinaldate#v:sundayStartWeek&quot;&gt;sundayStartWeek&lt;/a&gt;&lt;/code&gt; の逆です。取得 &lt;code&gt;&lt;a href=&quot;data-time-calendar#t:Day&quot;&gt;Day&lt;/a&gt;&lt;/code&gt; 年与えられたと日曜日開始曜日の数を。最初の日曜日は、年のいずれかの早い日（として週0で週1の最初の日である &lt;code&gt;%U&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8e1d7169fde4f120c1aa4f3ece9ee57253f95f60" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:castStablePtrToPtr&quot;&gt;castStablePtrToPtr&lt;/a&gt;&lt;/code&gt;, i.e., we have the identity</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:castStablePtrToPtr&quot;&gt;castStablePtrToPtr&lt;/a&gt;&lt;/code&gt; の逆です。つまり、アイデンティティがあります。</target>
        </trans-unit>
        <trans-unit id="085f4b1b3304279a7c72a59a48e1ceb8b934a83e" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;ghc-stable#v:castStablePtrToPtr&quot;&gt;castStablePtrToPtr&lt;/a&gt;&lt;/code&gt;, i.e., we have the identity</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stable#v:castStablePtrToPtr&quot;&gt;castStablePtrToPtr&lt;/a&gt;&lt;/code&gt; の逆です。つまり、アイデンティティがあります。</target>
        </trans-unit>
        <trans-unit id="bdd2cce8158f1320bcd058983fb015f9d2fa4781" translate="yes" xml:space="preserve">
          <source>The key component of a typechecker plugin is a function of type &lt;code&gt;TcPluginSolver&lt;/code&gt;, like this:</source>
          <target state="translated">タイプ &lt;code&gt;TcPluginSolver&lt;/code&gt; プラグインの主要なコンポーネントは、次のようにTcPluginSolverタイプの関数です。</target>
        </trans-unit>
        <trans-unit id="50146b4ed40e4fdb3a0f98772092c373b41b7b82" translate="yes" xml:space="preserve">
          <source>The key difference here is that we abstract over the type constructor &lt;code&gt;c&lt;/code&gt; that is used to form the collection type &lt;code&gt;c e&lt;/code&gt;, and not over that collection type itself, represented by &lt;code&gt;ce&lt;/code&gt; in the original class declaration. This avoids the immediate problems that we mentioned above: empty has type &lt;code&gt;Collects e c =&amp;gt; c e&lt;/code&gt;, which is not ambiguous.</source>
          <target state="translated">ここでの主な違いは、元のクラス宣言で &lt;code&gt;ce&lt;/code&gt; によって表されるコレクション型自体ではなく、コレクション型 &lt;code&gt;c e&lt;/code&gt; を形成するために使用される型コンストラクタ &lt;code&gt;c&lt;/code&gt; を抽象化することです。これにより、前述の直接的な問題が回避されます。空の型は &lt;code&gt;Collects e c =&amp;gt; c e&lt;/code&gt; であり、あいまいではありません。</target>
        </trans-unit>
        <trans-unit id="d931654af7b546e8d6ff7d64be51ee7d51eed95b" translate="yes" xml:space="preserve">
          <source>The key point about GADTs is that &lt;em&gt;pattern matching causes type refinement&lt;/em&gt;. For example, in the right hand side of the equation</source>
          <target state="translated">GADTの重要な点は、&lt;em&gt;パターンマッチングにより型が改良されること&lt;/em&gt;です。たとえば、方程式の右辺</target>
        </trans-unit>
        <trans-unit id="1c6ccf2ae2f2b690d9a1832c4814300edcd715a9" translate="yes" xml:space="preserve">
          <source>The key to defining your own datatype-generic functions is to understand how to represent datatypes using the given set of type constructors.</source>
          <target state="translated">独自のデータ型ジェネリック関数を定義する鍵は、指定された型コンストラクタのセットを使用してデータ型を表現する方法を理解することです。</target>
        </trans-unit>
        <trans-unit id="101f96a1728772ac592ac70565bf2d4fd3554ddc" translate="yes" xml:space="preserve">
          <source>The key tool to use in making your Haskell program run faster are GHC&amp;rsquo;s profiling facilities, described separately in &lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;. There is &lt;em&gt;no substitute&lt;/em&gt; for finding where your program&amp;rsquo;s time/space is &lt;em&gt;really&lt;/em&gt; going, as opposed to where you imagine it is going.</source>
          <target state="translated">より速くあなたのHaskellのプログラムの実行を製造する際に使用する重要なツールは、に分けて説明したGHCのプロファイリング施設、ある&lt;a href=&quot;profiling#profiling&quot;&gt;プロファイリング&lt;/a&gt;。プログラムの時間/空間が&lt;em&gt;実際に&lt;/em&gt;どこに向かっているのかを想像するのではなく、どこに行くの&lt;em&gt;か&lt;/em&gt;を見つける&lt;em&gt;のに代わるもの&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="52cd9e5fb65950d32847b984e9879cffe2f00ec9" translate="yes" xml:space="preserve">
          <source>The keypad</source>
          <target state="translated">キーパッド</target>
        </trans-unit>
        <trans-unit id="89852fc3a3f80fb4cacd31fc13b712715ce5683a" translate="yes" xml:space="preserve">
          <source>The kind &lt;code&gt;Type&lt;/code&gt; (imported from &lt;code&gt;Data.Kind&lt;/code&gt;) classifies ordinary types. With &lt;a href=&quot;#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt; (currently enabled by default), &lt;code&gt;*&lt;/code&gt; is desugared to &lt;code&gt;Type&lt;/code&gt;, but using this legacy syntax is not recommended due to conflicts with &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt;. This also applies to &lt;code&gt;★&lt;/code&gt;, the Unicode variant of &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">種類 &lt;code&gt;Type&lt;/code&gt; （ &lt;code&gt;Data.Kind&lt;/code&gt; からインポート）は、通常の型を分類します。&lt;a href=&quot;#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; &lt;/a&gt;（現在はデフォルトでは有効）、 &lt;code&gt;*&lt;/code&gt; に脱糖される &lt;code&gt;Type&lt;/code&gt; が、このレガシー構文を使用して、との競合が原因推奨されていません&lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt;。これは、 &lt;code&gt;*&lt;/code&gt; の Unicode版である &lt;code&gt;★&lt;/code&gt; にも適用されます。</target>
        </trans-unit>
        <trans-unit id="0cd808c3a0aa47774f7ee55994f44b345c1912bc" translate="yes" xml:space="preserve">
          <source>The kind of &lt;code&gt;Foo&lt;/code&gt;&amp;lsquo;s parameter is &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt;, but the kind of &lt;code&gt;Proxy&lt;/code&gt; is &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt;, where &lt;code&gt;{k}&lt;/code&gt; denotes that the kind variable &lt;code&gt;k&lt;/code&gt; is to be inferred, not specified by the user. (See &lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt; for more discussion on the inferred-specified distinction). GHC does not consider &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; and &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; to be equal at the kind level, and thus rejects &lt;code&gt;Foo Proxy&lt;/code&gt; as ill-kinded.</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; のパラメータの種類は &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; ですが、 &lt;code&gt;Proxy&lt;/code&gt; の種類は &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; 、ここで &lt;code&gt;{k}&lt;/code&gt; は、ユーザーによって指定されていない種類変数 &lt;code&gt;k&lt;/code&gt; が推論されることを示します。 （推論された指定の区別の詳細については、&lt;a href=&quot;#visible-type-application&quot;&gt;Visibleタイプのアプリケーション&lt;/a&gt;を参照してください）。 GHCは &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; 考慮しません。 k-&amp;gt;タイプと &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; は種類レベルで等しくなるため、 &lt;code&gt;Foo Proxy&lt;/code&gt; を不適切なものとして拒否します。</target>
        </trans-unit>
        <trans-unit id="0ade0b3069a9704ce4a195f04a058eddb6e7d6c9" translate="yes" xml:space="preserve">
          <source>The kind of &lt;code&gt;Foo&lt;/code&gt;&amp;rsquo;s parameter is &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt;, but the kind of &lt;code&gt;Proxy&lt;/code&gt; is &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt;, where &lt;code&gt;{k}&lt;/code&gt; denotes that the kind variable &lt;code&gt;k&lt;/code&gt; is to be inferred, not specified by the user. (See &lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt; for more discussion on the inferred-specified distinction). GHC does not consider &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; and &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; to be equal at the kind level, and thus rejects &lt;code&gt;Foo Proxy&lt;/code&gt; as ill-kinded.</source>
          <target state="translated">The kind of &lt;code&gt;Foo&lt;/code&gt; &amp;rsquo;s parameter is &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; , but the kind of &lt;code&gt;Proxy&lt;/code&gt; is &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; , where &lt;code&gt;{k}&lt;/code&gt; denotes that the kind variable &lt;code&gt;k&lt;/code&gt; is to be inferred, not specified by the user. (See &lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt; for more discussion on the inferred-specified distinction). GHC does not consider &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; and &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; to be equal at the kind level, and thus rejects &lt;code&gt;Foo Proxy&lt;/code&gt; as ill-kinded.</target>
        </trans-unit>
        <trans-unit id="d650258dfa554e9a0a612c8d7a0289cda5964e46" translate="yes" xml:space="preserve">
          <source>The kind of &lt;code&gt;Vec&lt;/code&gt; is &lt;code&gt;Type -&amp;gt; Type -&amp;gt; Type&lt;/code&gt;. This means that, e.g., &lt;code&gt;Vec Int Char&lt;/code&gt; is a well-kinded type, even though this is not what we intend when defining length-indexed vectors.</source>
          <target state="translated">一種 &lt;code&gt;Vec&lt;/code&gt; とは、ある &lt;code&gt;Type -&amp;gt; Type -&amp;gt; Type&lt;/code&gt; 。これは、たとえば、長さインデックス付きのベクトルを定義するときに意図したものではありませんが、 &lt;code&gt;Vec Int Char&lt;/code&gt; は種類が適切であることを意味します。</target>
        </trans-unit>
        <trans-unit id="6bdcf0025de5c2355bf036fb20350561d0e1ffc4" translate="yes" xml:space="preserve">
          <source>The kind of constraints, like &lt;code&gt;Show a&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Show a&lt;/code&gt; ような制約の種類</target>
        </trans-unit>
        <trans-unit id="edcdb1e98f798994b974989fbcf928e872ca0cb5" translate="yes" xml:space="preserve">
          <source>The kind of types with lifted values. For example &lt;code&gt;Int :: Type&lt;/code&gt;.</source>
          <target state="translated">値が持ち上げられたタイプの種類。たとえば、 &lt;code&gt;Int :: Type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3970d2a390e8339e6194fae0a800fd7ee383f1f3" translate="yes" xml:space="preserve">
          <source>The kind of types with values. For example &lt;code&gt;Int :: Type&lt;/code&gt;.</source>
          <target state="translated">値を持つタイプの種類。たとえば、 &lt;code&gt;Int :: Type&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0a2ff1eafaf2cf50aa099b7bed39cd8ce178efc2" translate="yes" xml:space="preserve">
          <source>The kind-polymorphism from the class declaration makes &lt;code&gt;D1&lt;/code&gt; kind-polymorphic, but not so &lt;code&gt;D2&lt;/code&gt;; and similarly &lt;code&gt;F1&lt;/code&gt;, &lt;code&gt;F1&lt;/code&gt;.</source>
          <target state="translated">クラス宣言の種類ポリモーフィズムは &lt;code&gt;D1&lt;/code&gt; を種類ポリモーフィックにしますが、 &lt;code&gt;D2&lt;/code&gt; はそうしません。同様に &lt;code&gt;F1&lt;/code&gt; 、 &lt;code&gt;F1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="142a287b02ca78aabf16196f308cd74692a41234" translate="yes" xml:space="preserve">
          <source>The kinds of the literals and all other low-level operations for this feature are defined in module &lt;code&gt;GHC.TypeLits&lt;/code&gt;. Note that the module defines some type-level operators that clash with their value-level counterparts (e.g. &lt;code&gt;(+)&lt;/code&gt;). Import and export declarations referring to these operators require an explicit namespace annotation (see &lt;a href=&quot;#explicit-namespaces&quot;&gt;Explicit namespaces in import/export&lt;/a&gt;).</source>
          <target state="translated">この機能のリテラルの種類と他のすべての低レベル操作は、モジュール &lt;code&gt;GHC.TypeLits&lt;/code&gt; で定義されています。このモジュールは、値レベルの対応物（たとえば &lt;code&gt;(+)&lt;/code&gt; ）と競合するいくつかのタイプレベルの演算子を定義していることに注意してください。これらの演算子を参照するインポートおよびエクスポート宣言には、明示的な名前空間注釈が必要です（&lt;a href=&quot;#explicit-namespaces&quot;&gt;import / exportの明示的な名前空間を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="f14aa2c065169defb0f47595c9265ce4ba5857e8" translate="yes" xml:space="preserve">
          <source>The lag stage, which is the time between creation and the first use of the object,</source>
          <target state="translated">オブジェクトの作成から最初の使用までの時間であるラグステージ。</target>
        </trans-unit>
        <trans-unit id="67f729cc5793b907e6283b32042b3a6379b975b3" translate="yes" xml:space="preserve">
          <source>The language &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt; changes this behaviour:</source>
          <target state="translated">&lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt;言語はこの動作を変更します。</target>
        </trans-unit>
        <trans-unit id="96eef94888750b6bf04df904c79af345e5cf88c6" translate="yes" xml:space="preserve">
          <source>The language definition for the Haskell language.</source>
          <target state="translated">Haskell言語の言語定義。</target>
        </trans-unit>
        <trans-unit id="f35e66eca43d1117d42cef793c6da9da1b53ea98" translate="yes" xml:space="preserve">
          <source>The language definition for the language Mondrian.</source>
          <target state="translated">モンドリアンという言葉の定義。</target>
        </trans-unit>
        <trans-unit id="c6db1b982530559c016310cc1374654d4e113cec" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-BinaryLiterals&quot;&gt;&lt;code&gt;BinaryLiterals&lt;/code&gt;&lt;/a&gt; adds support for expressing integer literals in binary notation with the prefix &lt;code&gt;0b&lt;/code&gt; or &lt;code&gt;0B&lt;/code&gt;. For instance, the binary integer literal &lt;code&gt;0b11001001&lt;/code&gt; will be desugared into &lt;code&gt;fromInteger 201&lt;/code&gt; when &lt;a href=&quot;#extension-BinaryLiterals&quot;&gt;&lt;code&gt;BinaryLiterals&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">言語拡張&lt;a href=&quot;#extension-BinaryLiterals&quot;&gt; &lt;code&gt;BinaryLiterals&lt;/code&gt; &lt;/a&gt;は、接頭辞 &lt;code&gt;0b&lt;/code&gt; または &lt;code&gt;0B&lt;/code&gt; を付けた整数表記をバイナリ表記で表現するためのサポートを追加します。たとえば、&lt;a href=&quot;#extension-BinaryLiterals&quot;&gt; &lt;code&gt;BinaryLiterals&lt;/code&gt; &lt;/a&gt;が有効になっている場合、バイナリ整数リテラル &lt;code&gt;0b11001001&lt;/code&gt; は &lt;code&gt;fromInteger 201&lt;/code&gt; に変換されます。</target>
        </trans-unit>
        <trans-unit id="2aa01e6792de69a814fc51631fa469117dc53520" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; allows &lt;code&gt;#&lt;/code&gt; as a postfix modifier to identifiers. Thus, &lt;code&gt;x#&lt;/code&gt; is a valid variable, and &lt;code&gt;T#&lt;/code&gt; is a valid type constructor or data constructor.</source>
          <target state="translated">言語拡張&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt;では、識別子の &lt;code&gt;#&lt;/code&gt; の後置修飾子として使用できます。したがって、 &lt;code&gt;x#&lt;/code&gt; は有効な変数であり、 &lt;code&gt;T#&lt;/code&gt; は有効な型コンストラクターまたはデータコンストラクターです。</target>
        </trans-unit>
        <trans-unit id="482fac3caa33dc4889f02993b124d842b7fc23c8" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-NumDecimals&quot;&gt;&lt;code&gt;NumDecimals&lt;/code&gt;&lt;/a&gt; allows you to also use the floating literal syntax for instances of &lt;code&gt;Integral&lt;/code&gt;, and have values like &lt;code&gt;(1.2e6 :: Num a =&amp;gt; a)&lt;/code&gt;</source>
          <target state="translated">言語拡張&lt;a href=&quot;#extension-NumDecimals&quot;&gt; &lt;code&gt;NumDecimals&lt;/code&gt; を&lt;/a&gt;使用すると、 &lt;code&gt;Integral&lt;/code&gt; のインスタンスに浮動リテラル構文も使用でき、 &lt;code&gt;(1.2e6 :: Num a =&amp;gt; a)&lt;/code&gt; ような値を持つことができます。</target>
        </trans-unit>
        <trans-unit id="5cdb57723b585621c77843b2adc5f3dd7c9046be" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt;&lt;code&gt;NumericUnderscores&lt;/code&gt;&lt;/a&gt; adds support for expressing underscores in numeric literals. For instance, the numeric literal &lt;code&gt;1_000_000&lt;/code&gt; will be parsed into &lt;code&gt;1000000&lt;/code&gt; when &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt;&lt;code&gt;NumericUnderscores&lt;/code&gt;&lt;/a&gt; is enabled. That is, underscores in numeric literals are ignored when &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt;&lt;code&gt;NumericUnderscores&lt;/code&gt;&lt;/a&gt; is enabled. See also &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14473&quot;&gt;#14473&lt;/a&gt;.</source>
          <target state="translated">The language extension &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt; &lt;code&gt;NumericUnderscores&lt;/code&gt; &lt;/a&gt; adds support for expressing underscores in numeric literals. For instance, the numeric literal &lt;code&gt;1_000_000&lt;/code&gt; will be parsed into &lt;code&gt;1000000&lt;/code&gt; when &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt; &lt;code&gt;NumericUnderscores&lt;/code&gt; &lt;/a&gt; is enabled. That is, underscores in numeric literals are ignored when &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt; &lt;code&gt;NumericUnderscores&lt;/code&gt; &lt;/a&gt; is enabled. See also &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14473&quot;&gt;#14473&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="7301f20dd6642c45e1a8ac269b635e38af928e05" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt;&lt;code&gt;NumericUnderscores&lt;/code&gt;&lt;/a&gt; adds support for expressing underscores in numeric literals. For instance, the numeric literal &lt;code&gt;1_000_000&lt;/code&gt; will be parsed into &lt;code&gt;1000000&lt;/code&gt; when &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt;&lt;code&gt;NumericUnderscores&lt;/code&gt;&lt;/a&gt; is enabled. That is, underscores in numeric literals are ignored when &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt;&lt;code&gt;NumericUnderscores&lt;/code&gt;&lt;/a&gt; is enabled. See also &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14473&quot;&gt;Issue #14473&lt;/a&gt;.</source>
          <target state="translated">言語拡張&lt;a href=&quot;#extension-NumericUnderscores&quot;&gt; &lt;code&gt;NumericUnderscores&lt;/code&gt; &lt;/a&gt;は、数値リテラルでアンダースコアを表現するためのサポートを追加します。たとえば、&lt;a href=&quot;#extension-NumericUnderscores&quot;&gt; &lt;code&gt;NumericUnderscores&lt;/code&gt; &lt;/a&gt;が有効な場合、数値リテラル &lt;code&gt;1_000_000&lt;/code&gt; は &lt;code&gt;1000000&lt;/code&gt; に解析されます。つまり、&lt;a href=&quot;#extension-NumericUnderscores&quot;&gt; &lt;code&gt;NumericUnderscores&lt;/code&gt; &lt;/a&gt;が有効になっている場合、数値リテラルのアンダースコアは無視されます。&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14473&quot;&gt;Issue＃14473&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="1df0d3ed5fc3e05e0b2f091352293e402f435759" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-StaticPointers&quot;&gt;&lt;code&gt;StaticPointers&lt;/code&gt;&lt;/a&gt; adds a new syntactic form &lt;code&gt;static e&lt;/code&gt;, which stands for a reference to the closed expression ⟨e⟩. This reference is stable and portable, in the sense that it remains valid across different processes on possibly different machines. Thus, a process can create a reference and send it to another process that can resolve it to ⟨e⟩.</source>
          <target state="translated">言語拡張&lt;a href=&quot;#extension-StaticPointers&quot;&gt; &lt;code&gt;StaticPointers&lt;/code&gt; &lt;/a&gt;は、閉じた式「 &lt;code&gt;static e&lt;/code&gt; 」への参照を表す新しい構文形式static eを追加します。この参照は、おそらく異なるマシンの異なるプロセス全体で有効なままであるという意味で、安定して移植可能です。したがって、プロセスは参照を作成し、それを「e」に解決できる別のプロセスに送信できます。</target>
        </trans-unit>
        <trans-unit id="1164d109e3a8912c2bd8dbd337b1bd95e59931eb" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt;&lt;code&gt;UndecidableSuperClasses&lt;/code&gt;&lt;/a&gt; allows much more flexible constraints in superclasses.</source>
          <target state="translated">言語拡張&lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt; &lt;code&gt;UndecidableSuperClasses&lt;/code&gt; を&lt;/a&gt;使用すると、スーパークラスではるかに柔軟な制約を設定できます。</target>
        </trans-unit>
        <trans-unit id="a23afb63a5225acfa62366c99fa9002b8bd272d4" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt; enables Unicode characters to be used to stand for certain ASCII character sequences. The following alternatives are provided:</source>
          <target state="translated">言語拡張&lt;a href=&quot;#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;UnicodeSyntax&lt;/code&gt; を&lt;/a&gt;使用すると、Unicode文字を使用して特定のASCII文字シーケンスを表すことができます。以下の代替案が提供されています。</target>
        </trans-unit>
        <trans-unit id="0f020db4c2779c8a84447ac375908f8cf1851cd7" translate="yes" xml:space="preserve">
          <source>The language extensions control what variation of the language are permitted.</source>
          <target state="translated">言語拡張機能は、どのような言語のバリエーションが許可されているかを制御します。</target>
        </trans-unit>
        <trans-unit id="1e3e7e5b927ef3a07b1708c8234ccb8fab69c087" translate="yes" xml:space="preserve">
          <source>The language extensions known to GHC.</source>
          <target state="translated">GHCで知られている言語拡張。</target>
        </trans-unit>
        <trans-unit id="47f8be94c2ca864c563003d6cd62e96954c9f6b8" translate="yes" xml:space="preserve">
          <source>The language option &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt; enables an alternative translation for the do-notation, which uses the operators &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;, along with &lt;code&gt;join&lt;/code&gt; as far as possible. There are two main reasons for wanting to do this:</source>
          <target state="translated">言語オプション&lt;a href=&quot;#extension-ApplicativeDo&quot;&gt; &lt;code&gt;ApplicativeDo&lt;/code&gt; &lt;/a&gt;を使用すると、演算子 &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; 、および可能な限り &lt;code&gt;join&lt;/code&gt; を使用するdo表記の代替翻訳が可能になります。これを実行する主な理由は2つあります。</target>
        </trans-unit>
        <trans-unit id="6758c18bb77d5105f15261fc6f768c32b1ac1a54" translate="yes" xml:space="preserve">
          <source>The language option &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; (which implies &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt;) enables higher-rank types. That is, you can nest &lt;code&gt;forall&lt;/code&gt;s arbitrarily deep in function arrows. For example, a forall-type (also called a &amp;ldquo;type scheme&amp;rdquo;), including a type-class context, is legal:</source>
          <target state="translated">言語オプション&lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;を意味する）は、上位の型を有効にします。つまり、関数の矢印の中で &lt;code&gt;forall&lt;/code&gt; を任意にネストすることができます。たとえば、型クラスコンテキストを含むforall型（「型スキーム」とも呼ばれます）は有効です。</target>
        </trans-unit>
        <trans-unit id="e43581d03051421db388e53bc00c80ed362d21f6" translate="yes" xml:space="preserve">
          <source>The largest element of a non-empty structure with respect to the given comparison function.</source>
          <target state="translated">与えられた比較関数に関して,空でない構造体の最大の要素.</target>
        </trans-unit>
        <trans-unit id="a09e69c04a0fae36b18bfad0cec44eb5b7dac599" translate="yes" xml:space="preserve">
          <source>The largest element of a non-empty structure.</source>
          <target state="translated">空ではない構造の最大の要素。</target>
        </trans-unit>
        <trans-unit id="1c3c62ef7c501b737425bd024e6b97dd8602a4d0" translate="yes" xml:space="preserve">
          <source>The last of these examples will generate a RULE with a somewhat-complex left-hand side (try it yourself), so it might not fire very well. If you use this kind of specialisation, let us know how well it works.</source>
          <target state="translated">最後の例では、やや複雑な左辺を持つruleが生成されるので(自分で試してみてください)、あまりうまく発火しないかもしれません。このような特殊化を使った場合、どの程度の効果があるのか教えてください。</target>
        </trans-unit>
        <trans-unit id="c09c37300640da9fa5a1e825531f7baf46e4a4a9" translate="yes" xml:space="preserve">
          <source>The last point means that, for example, this program:</source>
          <target state="translated">最後のポイントというのは、例えばこのプログラム。</target>
        </trans-unit>
        <trans-unit id="c7b0fe0f98d69788b12fc3fe8961316784922da5" translate="yes" xml:space="preserve">
          <source>The last string parameter is useful for when the span is out of date, i.e. the file changed and the code has moved. In which case &lt;a href=&quot;#ghci-cmd-:type-at&quot;&gt;&lt;code&gt;:type-at&lt;/code&gt;&lt;/a&gt; falls back to a general &lt;a href=&quot;#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; like lookup.</source>
          <target state="translated">最後の文字列パラメータは、スパンが古い場合、つまりファイルが変更され、コードが移動した場合に役立ちます。その場合、&lt;a href=&quot;#ghci-cmd-:type-at&quot;&gt; &lt;code&gt;:type-at&lt;/code&gt; &lt;/a&gt;は検索のような一般的な&lt;a href=&quot;#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; に&lt;/a&gt;フォールバックします。</target>
        </trans-unit>
        <trans-unit id="74662c9c171e1f11f6d4c17936e04e8cfc73a0a4" translate="yes" xml:space="preserve">
          <source>The last time we looked, this bug still wasn&amp;rsquo;t fixed in the BFD codebase, and there wasn&amp;rsquo;t any noticeable interest in fixing it when we reported the bug back in 2001 or so.</source>
          <target state="translated">前回確認したとき、このバグはBFDコードベースではまだ修正されておらず、2001年頃にバグを報告したときに、修正することに目立った関心はありませんでした。</target>
        </trans-unit>
        <trans-unit id="cc178347052a701ca8893682ca3efb8b74c8a5b7" translate="yes" xml:space="preserve">
          <source>The latter two extensions are simply a way to avoid littering high-performance code with bang patterns, making it harder to read.</source>
          <target state="translated">後者の2つの拡張は、単に高性能なコードにバングパターンを散りばめて読みにくくするのを避けるためのものです。</target>
        </trans-unit>
        <trans-unit id="83ef67ff9e0acbd2b46b885ad1e2b9746fa12727" translate="yes" xml:space="preserve">
          <source>The layout rule applies in a pragma. Currently no new indentation level is set, so if you put several rules in single &lt;code&gt;RULES&lt;/code&gt; pragma and wish to use layout to separate them, you must lay out the starting in the same column as the enclosing definitions.</source>
          <target state="translated">レイアウト規則はプラグマに適用されます。現在、新しいインデントレベルは設定されていないため、単一の &lt;code&gt;RULES&lt;/code&gt; プラグマにいくつかのルールを配置し、レイアウトを使用してそれらを分離する場合は、開始を囲んでいる定義と同じ列に配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="d2d17886ee9122e995c736b68557cda7950811bf" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt; monad.
 The ST monad allows for destructive updates, but is escapable (unlike IO).
 A computation of type &lt;/code&gt;&lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; s a&lt;code&gt; returns a value of type &lt;/code&gt;a&lt;code&gt;, and
 execute in &quot;thread&quot; &lt;/code&gt;s&lt;code&gt;. The &lt;/code&gt;s@ parameter is either</source>
          <target state="translated">怠惰な &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt; monad. The ST monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; SA &lt;code&gt; returns a value of type &lt;/code&gt; A &lt;code&gt;, and execute in &quot;thread&quot; &lt;/code&gt; S &lt;code&gt;. The &lt;/code&gt; S @パラメータのいずれかであります</target>
        </trans-unit>
        <trans-unit id="cb5e3600ef521edc02534f8316cf1842086384c6" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt; monad.
 The ST monad allows for destructive updates, but is escapable (unlike IO).
 A computation of type &lt;/code&gt;&lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; s a&lt;code&gt; returns a value of type &lt;/code&gt;a&lt;code&gt;, and
 execute in &quot;thread&quot; &lt;/code&gt;s&lt;code&gt;. The &lt;/code&gt;s@ parameter is either</source>
          <target state="translated">怠惰な &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt; monad. The ST monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; SA &lt;code&gt; returns a value of type &lt;/code&gt; A &lt;code&gt;, and execute in &quot;thread&quot; &lt;/code&gt; S &lt;code&gt;. The &lt;/code&gt; S @パラメータのいずれかであります</target>
        </trans-unit>
        <trans-unit id="40d868f620139062b248b76538a36b443a676fd8" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#t:AccumT&quot;&gt;AccumT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds accumulation capabilities (such as declarations or document patches) to a given monad.</source>
          <target state="translated">レイジー &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#t:AccumT&quot;&gt;AccumT&lt;/a&gt;&lt;/code&gt; モナド変換子。指定されたモナドに累積機能（宣言やドキュメントパッチなど）を追加します。</target>
        </trans-unit>
        <trans-unit id="0148fab25056e7d25108af73020e1e1fd6b568bc" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds collection of outputs (such as a count or string output) to a given monad.</source>
          <target state="translated">レイジー &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; モナド変換プログラム。指定されたモナドに出力（カウントや文字列出力など）のコレクションを追加します。</target>
        </trans-unit>
        <trans-unit id="460dbda305fa0fdf243ff4aaca3b36cbface9176" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;ByteString&lt;/code&gt; type and representation</source>
          <target state="translated">遅延 &lt;code&gt;ByteString&lt;/code&gt; タイプと表現</target>
        </trans-unit>
        <trans-unit id="cd66658dbdbc20cd277316b5f47a31d85a5a657d" translate="yes" xml:space="preserve">
          <source>The lazy ByteString that results from &lt;code&gt;&lt;a href=&quot;data-binary#v:encode&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; can be written to disk, and read from disk using Data.ByteString.Lazy IO functions, such as hPutStr or writeFile:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary#v:encode&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; 結果として生じる遅延ByteStringはディスクに書き込み、Data.ByteString.Lazy IO関数（hPutStrやwriteFileなど）を使用してディスクから読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="81b4ea9d6659ffec90b8a98fd916cb7519cdd284" translate="yes" xml:space="preserve">
          <source>The lazy input interface</source>
          <target state="translated">遅延入力インターフェース</target>
        </trans-unit>
        <trans-unit id="18194b6ea93e37e29c30dcb32e97e5e2850d4eab" translate="yes" xml:space="preserve">
          <source>The lazy interface consumes a single lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It's the easiest interface to get started with, but it doesn't support interleaving I/O and parsing, unless lazy I/O is used.</source>
          <target state="translated">遅延インターフェイスは、単一の遅延 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; を消費します。開始するのが最も簡単なインターフェイスですが、遅延I / Oが使用されない限り、インターリーブI / Oと解析はサポートされません。</target>
        </trans-unit>
        <trans-unit id="d0f94810b2d4d1d107dde9a11881d98fcdccae35" translate="yes" xml:space="preserve">
          <source>The least element of a non-empty structure with respect to the given comparison function.</source>
          <target state="translated">与えられた比較関数に関して、空ではない構造体の最小要素。</target>
        </trans-unit>
        <trans-unit id="07d9943e6fdf33ee01fbdf7cd0db14fb536c6243" translate="yes" xml:space="preserve">
          <source>The least element of a non-empty structure.</source>
          <target state="translated">空でない構造体の最小要素。</target>
        </trans-unit>
        <trans-unit id="0e70192fc1725fb44e6261baa525bb34fe0d8271" translate="yes" xml:space="preserve">
          <source>The left hand side of a rule must consist of a top-level variable applied to arbitrary expressions. For example, this is &lt;em&gt;not&lt;/em&gt; OK:</source>
          <target state="translated">ルールの左側は、任意の式に適用されるトップレベルの変数で構成されている必要があります。たとえば、これは&lt;em&gt;問題&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="9bbc16e1c3670ac6be9b561d2b10f00b7e4c905c" translate="yes" xml:space="preserve">
          <source>The length of a given month in the Gregorian or Julian calendars. First arg is leap year flag.</source>
          <target state="translated">グレゴリオ暦やユリウス暦の月の長さ。第一引数はうるう年フラグ。</target>
        </trans-unit>
        <trans-unit id="02862fec4929a80083ca47de3fabc777823d03ea" translate="yes" xml:space="preserve">
          <source>The lexeme parser &lt;code&gt;reserved name&lt;/code&gt; parses &lt;code&gt;symbol
 name&lt;/code&gt;, but it also checks that the &lt;code&gt;name&lt;/code&gt; is not a prefix of a valid identifier. A &lt;code&gt;reserved&lt;/code&gt; word is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">語彙素パーサーの &lt;code&gt;reserved name&lt;/code&gt; は &lt;code&gt;symbol name&lt;/code&gt; 名を解析しますが、 &lt;code&gt;name&lt;/code&gt; が有効な識別子の接頭辞でないことも確認します。 &lt;code&gt;reserved&lt;/code&gt; 語は使用して単一のトークンとして扱われる &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12483176ac2649de2ec04abe4c197ebb522e5167" translate="yes" xml:space="preserve">
          <source>The lexeme parser &lt;code&gt;reservedOp name&lt;/code&gt; parses &lt;code&gt;symbol
 name&lt;/code&gt;, but it also checks that the &lt;code&gt;name&lt;/code&gt; is not a prefix of a valid operator. A &lt;code&gt;reservedOp&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">語彙素パーサー &lt;code&gt;reservedOp name&lt;/code&gt; は、 &lt;code&gt;symbol name&lt;/code&gt; nameを解析しますが、 &lt;code&gt;name&lt;/code&gt; が有効な演算子の接頭辞でないこともチェックします。A &lt;code&gt;reservedOp&lt;/code&gt; を使用して、単一のトークンとして扱われる &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6fe325967df8e680315725cbc04cfb4a0cda946a" translate="yes" xml:space="preserve">
          <source>The libraries listed in &lt;code&gt;extra-libraries&lt;/code&gt; may be any libraries supported by your system&amp;rsquo;s linker, including dynamic libraries (&lt;code&gt;.so&lt;/code&gt; on Unix, &lt;code&gt;.DLL&lt;/code&gt; on Windows).</source>
          <target state="translated">&lt;code&gt;extra-libraries&lt;/code&gt; librariesにリストされているライブラリーは、動的ライブラリー（UNIXの場合は &lt;code&gt;.so&lt;/code&gt; 、Windowsの場合は &lt;code&gt;.DLL&lt;/code&gt; ）を含め、システムのリンカーによってサポートされているライブラリーのいずれかです。</target>
        </trans-unit>
        <trans-unit id="177074a86a1a2bfb7162db93da0c7658d94219a2" translate="yes" xml:space="preserve">
          <source>The lifetime of an event registration.</source>
          <target state="translated">イベント登録の寿命。</target>
        </trans-unit>
        <trans-unit id="abc2a96639fca06ac1cbe729983e770d28dcf330" translate="yes" xml:space="preserve">
          <source>The limitations here are listed in Haskell Report order (roughly).</source>
          <target state="translated">ここでの制限事項は、Haskellレポート順に(大まかに)記載しています。</target>
        </trans-unit>
        <trans-unit id="d2f24eb430e5f7113d1bb42457d3209f32c4782e" translate="yes" xml:space="preserve">
          <source>The linker standard library search can also be overriden on some systems using the &lt;code id=&quot;index-20&quot;&gt;LIBRARY_PATH&lt;/code&gt; environment variable. Because of some implementation detail on Windows, setting &lt;code&gt;LIBRARY_PATH&lt;/code&gt; will also extend the system loader path for any library it finds. So often setting &lt;code id=&quot;index-21&quot;&gt;LIBRARY_PATH&lt;/code&gt; is enough.</source>
          <target state="translated">一部のシステムでは、 &lt;code id=&quot;index-20&quot;&gt;LIBRARY_PATH&lt;/code&gt; 環境変数を使用して、リンカー標準ライブラリ検索をオーバーライドすることもできます。Windowsでの実装の詳細のため、 &lt;code&gt;LIBRARY_PATH&lt;/code&gt; を設定すると、見つかったライブラリのシステムローダーパスも拡張されます。したがって、多くの場合、 &lt;code id=&quot;index-21&quot;&gt;LIBRARY_PATH&lt;/code&gt; を設定するだけで十分です。</target>
        </trans-unit>
        <trans-unit id="35439bfe005709a8b0e917ffb02271e76a64cd30" translate="yes" xml:space="preserve">
          <source>The linker to use (default: &lt;code&gt;gcc&lt;/code&gt;).</source>
          <target state="translated">使用するリンカ（デフォルト： &lt;code&gt;gcc&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="eeafbb95d04ce25f7a78da969fb894e2ec069b3e" translate="yes" xml:space="preserve">
          <source>The list is ordered by most recent call.</source>
          <target state="translated">リストは、最近の呼び出しが多い順に表示されます。</target>
        </trans-unit>
        <trans-unit id="1f523c49a9fa8705bc3372a7af5bd59d5259f47e" translate="yes" xml:space="preserve">
          <source>The list must be finite.</source>
          <target state="translated">リストは有限でなければならない。</target>
        </trans-unit>
        <trans-unit id="95bb9fda3d0750b05641de34c2d4bc742e5f26cc" translate="yes" xml:space="preserve">
          <source>The list of all possible separators.</source>
          <target state="translated">可能なすべての分離器のリストです。</target>
        </trans-unit>
        <trans-unit id="140110a0fe6147ee6523b90cc08f34ea3d3d7870" translate="yes" xml:space="preserve">
          <source>The list of associations of an array in index order.</source>
          <target state="translated">配列の関連付けのリストをインデックス順に表示します。</target>
        </trans-unit>
        <trans-unit id="3ae1f93402e7c384b257cee551dcd23931311c1e" translate="yes" xml:space="preserve">
          <source>The list of breakpoints currently defined can be displayed using &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt;&lt;code&gt;:show breaks&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">The list of breakpoints currently defined can be displayed using &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt; &lt;code&gt;:show breaks&lt;/code&gt; &lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="4db5b3fb0ce028bd2eb08c3da0fe9c3bade145e2" translate="yes" xml:space="preserve">
          <source>The list of breakpoints currently enabled can be displayed using &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt;&lt;code&gt;:show breaks&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">現在有効になっているブレークポイントのリストは、&lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt; &lt;code&gt;:show breaks&lt;/code&gt; &lt;/a&gt;を使用して表示できます。</target>
        </trans-unit>
        <trans-unit id="6840298fc1ff7b758a2385cba92227fe7cb9d802" translate="yes" xml:space="preserve">
          <source>The list of elements of an array in index order.</source>
          <target state="translated">配列の要素をインデックス順に並べたリスト。</target>
        </trans-unit>
        <trans-unit id="920d0464cfa124351a5c124482bb76f7bb005ea6" translate="yes" xml:space="preserve">
          <source>The list of indices of an array in ascending order.</source>
          <target state="translated">配列のインデックスの昇順のリスト。</target>
        </trans-unit>
        <trans-unit id="c272635afded4d839339a1be1f84abe89e36c500" translate="yes" xml:space="preserve">
          <source>The list of paths is split using &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath#v:searchPathSeparator&quot;&gt;searchPathSeparator&lt;/a&gt;&lt;/code&gt;, which on Windows is a semicolon.</source>
          <target state="translated">パスのリストは、Windowsではセミコロンである &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath#v:searchPathSeparator&quot;&gt;searchPathSeparator&lt;/a&gt;&lt;/code&gt; を使用して分割されます。</target>
        </trans-unit>
        <trans-unit id="dc809c8f4a7b8427301c5f620413f00381ab3112" translate="yes" xml:space="preserve">
          <source>The list of possible &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt;s in the API documentation is not exhaustive. The full list may vary by platform and/or evolve over time.</source>
          <target state="translated">APIドキュメントで考えられる &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; のリストは完全ではありません。完全なリストは、プラットフォームによって異なる場合や、時間の経過とともに変化する場合があります。</target>
        </trans-unit>
        <trans-unit id="c6f1b33fdad02db727e19018a482ecf607406289" translate="yes" xml:space="preserve">
          <source>The list of reserved identifiers.</source>
          <target state="translated">予約された識別子のリスト。</target>
        </trans-unit>
        <trans-unit id="91edba8a3a46eed84d044f0b039fdf7160f70fd8" translate="yes" xml:space="preserve">
          <source>The list of reserved operators.</source>
          <target state="translated">予約された演算子のリストです。</target>
        </trans-unit>
        <trans-unit id="c39f3749d7b0f0a59a29e12553ad09d0740f4541" translate="yes" xml:space="preserve">
          <source>The list of valid hole fits is found by checking which bindings in scope would fit into the hole. As an example, compiling the following module with GHC:</source>
          <target state="translated">有効なホールフィットのリストは、スコープ内のどのバインディングがホールに収まるかを確認することで見つけられます。例として、以下のモジュールをGHCでコンパイルします。</target>
        </trans-unit>
        <trans-unit id="2438a0705dcb689373167d3061da6964ec71e04e" translate="yes" xml:space="preserve">
          <source>The list of valid hole fits is limited by displaying up to 6 hole fits per hole. The number of hole fits shown can be set by this flag. Turning the limit off with &lt;a href=&quot;#ghc-flag--fmax-valid-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-fno-max-valid-hole-fits&lt;/code&gt;&lt;/a&gt; displays all found hole fits.</source>
          <target state="translated">The list of valid hole fits is limited by displaying up to 6 hole fits per hole. The number of hole fits shown can be set by this flag. Turning the limit off with &lt;a href=&quot;#ghc-flag--fmax-valid-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-fno-max-valid-hole-fits&lt;/code&gt; &lt;/a&gt; displays all found hole fits.</target>
        </trans-unit>
        <trans-unit id="a1d5e76811a70379851fd0870f7be2601a8c80c1" translate="yes" xml:space="preserve">
          <source>The list of valid hole fits is limited by displaying up to 6 hole fits per hole. The number of hole fits shown can be set by this flag. Turning the limit off with &lt;code&gt;-fno-max-valid-hole-fits&lt;/code&gt; displays all found hole fits.</source>
          <target state="translated">有効な穴あけのリストは、穴ごとに最大6つの穴あてを表示することによって制限されます。表示される穴ばめの数は、このフラグで設定できます。 &lt;code&gt;-fno-max-valid-hole-fits&lt;/code&gt; で制限をオフにすると、見つかったすべての穴あけが表示されます。</target>
        </trans-unit>
        <trans-unit id="d8490f70aa9b2cb5e8e7f8af8e97ea93b083ee94" translate="yes" xml:space="preserve">
          <source>The list of valid refinement hole fits is generated by considering hole fits with a varying amount of additional holes. The amount of holes in a refinement can be set by this flag. If the flag is set to 0 or not set at all, no valid refinement hole fits will be suggested.</source>
          <target state="translated">有効なリファインメントの穴フィットのリストは、追加の穴の量が変化する穴フィットを考慮して生成されます。絞り込みの穴の量は、このフラグで設定できます。フラグが0に設定されているか、まったく設定されていない場合は、有効な絞り込みホールフィットは提案されません。</target>
        </trans-unit>
        <trans-unit id="ca3a8b64a43dcccb6d83962220ef2222dedc1fab" translate="yes" xml:space="preserve">
          <source>The list of valid refinement hole fits is limited by displaying up to 6 hole fits per hole. The number of hole fits shown can be set by this flag. Turning the limit off with &lt;a href=&quot;#ghc-flag--fmax-refinement-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-fno-max-refinement-hole-fits&lt;/code&gt;&lt;/a&gt; displays all found hole fits.</source>
          <target state="translated">The list of valid refinement hole fits is limited by displaying up to 6 hole fits per hole. The number of hole fits shown can be set by this flag. Turning the limit off with &lt;a href=&quot;#ghc-flag--fmax-refinement-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-fno-max-refinement-hole-fits&lt;/code&gt; &lt;/a&gt; displays all found hole fits.</target>
        </trans-unit>
        <trans-unit id="0e9c3cb541a9f4b1ef3a2b89a4f5da3c5f2f0b80" translate="yes" xml:space="preserve">
          <source>The list of valid refinement hole fits is limited by displaying up to 6 hole fits per hole. The number of hole fits shown can be set by this flag. Turning the limit off with &lt;code&gt;-fno-max-refinement-hole-fits&lt;/code&gt; displays all found hole fits.</source>
          <target state="translated">有効な絞り込み穴あてのリストは、穴ごとに最大6つの穴あてを表示することにより制限されます。表示される穴ばめの数は、このフラグで設定できます。 &lt;code&gt;-fno-max-refinement-hole-fits&lt;/code&gt; で制限をオフにすると、見つかったすべての穴あてが表示されます。</target>
        </trans-unit>
        <trans-unit id="b86a88a2e8b5e2bcc9593f30db6f5ffae5340c3d" translate="yes" xml:space="preserve">
          <source>The list of values in the subrange defined by a bounding pair.</source>
          <target state="translated">バウンディングペアで定義されたサブレンジ内の値のリスト。</target>
        </trans-unit>
        <trans-unit id="c06dff0a9cb5a38686c70f9512cbd43e5942e7dc" translate="yes" xml:space="preserve">
          <source>The literal &lt;code&gt;-123&lt;/code&gt; is, according to Haskell98 and Haskell 2010, desugared as &lt;code&gt;negate (fromInteger 123)&lt;/code&gt;. The language extension &lt;a href=&quot;#extension-NegativeLiterals&quot;&gt;&lt;code&gt;NegativeLiterals&lt;/code&gt;&lt;/a&gt; means that it is instead desugared as &lt;code&gt;fromInteger (-123)&lt;/code&gt;.</source>
          <target state="translated">リテラル &lt;code&gt;-123&lt;/code&gt; は、Haskell98およびHaskell 2010によると、 &lt;code&gt;negate (fromInteger 123)&lt;/code&gt; として脱糖化されています。言語拡張&lt;a href=&quot;#extension-NegativeLiterals&quot;&gt; &lt;code&gt;NegativeLiterals&lt;/code&gt; &lt;/a&gt;は、代わりに &lt;code&gt;fromInteger (-123)&lt;/code&gt; として脱糖化されることを意味します。</target>
        </trans-unit>
        <trans-unit id="0e4c18eaf2be8a9b015eed5cef929f88b0717761" translate="yes" xml:space="preserve">
          <source>The local axioms from the instance context : &lt;code&gt;B a&lt;/code&gt;, &lt;code&gt;D a&lt;/code&gt; and &lt;code&gt;E a&lt;/code&gt;</source>
          <target state="translated">インスタンスコンテキストからのローカル公理： &lt;code&gt;B a&lt;/code&gt; 、 &lt;code&gt;D a&lt;/code&gt; および &lt;code&gt;E a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47ffc1a6bb0aa38dfc306316588a7559300ef95b" translate="yes" xml:space="preserve">
          <source>The location at which this computation is spliced.</source>
          <target state="translated">この計算が接続されている場所。</target>
        </trans-unit>
        <trans-unit id="f36139e3c6bbb05207907f6e241b4c98c08b0d8a" translate="yes" xml:space="preserve">
          <source>The log format is designed to be extensible: old tools should be able to parse (but not necessarily understand all of) new versions of the format, and new tools will be able to understand old log files.</source>
          <target state="translated">ログフォーマットは拡張可能なように設計されています:古いツールは新しいバージョンのフォーマットを解析できなければなりません(すべてを理解する必要はありません)。</target>
        </trans-unit>
        <trans-unit id="eeb6dd18dd0c7cd9fc57a8f2ff6c2bb37bc4af79" translate="yes" xml:space="preserve">
          <source>The lowercase versions (&lt;em&gt;syntax operators&lt;/em&gt;) of these constructors are preferred to these constructors, since they compose better with quotations (&lt;code&gt;[| |]&lt;/code&gt;) and splices (&lt;code&gt;$( ... )&lt;/code&gt;)</source>
          <target state="translated">これらのコンストラクターの小文字バージョン（&lt;em&gt;構文演算子&lt;/em&gt;）は、引用符（ &lt;code&gt;[| |]&lt;/code&gt; ）とスプライス（ &lt;code&gt;$( ... )&lt;/code&gt; ）で構成するため、これらのコンストラクターよりも推奨されます。</target>
        </trans-unit>
        <trans-unit id="abe92315667ac8537af92643ee70ab06a908884e" translate="yes" xml:space="preserve">
          <source>The machine architecture on which the program is running.</source>
          <target state="translated">プログラムが実行されているマシンアーキテクチャ。</target>
        </trans-unit>
        <trans-unit id="32815c54d6aac2d0c3f3ab1768e3826958371ab4" translate="yes" xml:space="preserve">
          <source>The main advantages to using &lt;code&gt;ghc --make&lt;/code&gt; over traditional &lt;code&gt;Makefile&lt;/code&gt;s are:</source>
          <target state="translated">従来の &lt;code&gt;Makefile&lt;/code&gt; よりも &lt;code&gt;ghc --make&lt;/code&gt; を使用する主な利点は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="8f8b11338657365b7972c69ff46bf6811e5d4123" translate="yes" xml:space="preserve">
          <source>The main idea is to add a single new production to the syntax of patterns:</source>
          <target state="translated">パターンの構文に新たに1つのプロダクションを追加するのが主な考え方です。</target>
        </trans-unit>
        <trans-unit id="fb265d0d99b20462c3bedd36be578770dd2b3955" translate="yes" xml:space="preserve">
          <source>The main library you need to use is the &lt;a href=&quot;http://hackage.haskell.org/package/stm&quot;&gt;stm library&lt;/a&gt;. The main features supported are these:</source>
          <target state="translated">使用する必要があるメインライブラリは&lt;a href=&quot;http://hackage.haskell.org/package/stm&quot;&gt;stmライブラリ&lt;/a&gt;です。サポートされている主な機能は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="5e1d49c28d217785350db1f824835b79bff3fc25" translate="yes" xml:space="preserve">
          <source>The main reason for using phase control on specialisations is so that you can write optimisation RULES that fire early in the compilation pipeline, and only &lt;em&gt;then&lt;/em&gt; specialise the calls to the function. If specialisation is done too early, the optimisation rules might fail to fire.</source>
          <target state="translated">特殊化でフェーズ制御を使用する主な理由は、コンパイルパイプラインの早い段階で起動する最適化ルールを記述し、&lt;em&gt;その後で&lt;/em&gt;関数の呼び出しを特殊化できるようにするためです。専門化が早すぎると、最適化ルールが起動しない可能性があります。</target>
        </trans-unit>
        <trans-unit id="bd99fbab8c2a96e5d1994f5a584841ebedd4fc5c" translate="yes" xml:space="preserve">
          <source>The main requirement here is that the runtime needs to be initialized before any Haskell code can be called, so your library should provide initialisation and deinitialisation entry points, implemented in C or C++. For example:</source>
          <target state="translated">ここでの主な要件は、Haskellコードを呼び出す前にランタイムを初期化する必要があることで、ライブラリはCまたはC++で実装された初期化と初期化解除のエントリポイントを提供する必要があります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="a36b3b528156f09407c2aa49bd251573cb91ec76" translate="yes" xml:space="preserve">
          <source>The main thread principle also applies to calls to Haskell from outside, using &lt;code&gt;foreign export&lt;/code&gt;. When the &lt;code&gt;foreign export&lt;/code&gt;ed function is invoked, it starts a new main thread, and it returns when this main thread terminates. If the call causes new threads to be forked, they may remain in the system after the &lt;code&gt;foreign export&lt;/code&gt;ed function has returned.</source>
          <target state="translated">メインスレッドの原則は、 &lt;code&gt;foreign export&lt;/code&gt; を使用した、外部からのHaskellの呼び出しにも適用されます。ときに &lt;code&gt;foreign export&lt;/code&gt; ED関数が呼び出され、それが新しいメインスレッドを開始し、それはときに、このメインスレッドの終了を返します。呼び出しによって新しいスレッドがフォークされる場合、 &lt;code&gt;foreign export&lt;/code&gt; ed関数が返された後、それらはシステムに残っている可能性があります。</target>
        </trans-unit>
        <trans-unit id="a8aa707c2a5513daf094974e7984d291b1194cb2" translate="yes" xml:space="preserve">
          <source>The maintainers are glad to accept patches for further standard encodings of standard Haskell values.</source>
          <target state="translated">メンテナは、Haskellの標準値をさらに標準的にエンコーディングするためのパッチを喜んで受け入れます。</target>
        </trans-unit>
        <trans-unit id="744ef2d7aabc6bab260fc29bb9d92f2367435b58" translate="yes" xml:space="preserve">
          <source>The major effect of an &lt;code&gt;INLINE&lt;/code&gt; pragma is to declare a function&amp;rsquo;s &amp;ldquo;cost&amp;rdquo; to be very low. The normal unfolding machinery will then be very keen to inline it. However, an &lt;code&gt;INLINE&lt;/code&gt; pragma for a function &amp;ldquo;&lt;code&gt;f&lt;/code&gt;&amp;rdquo; has a number of other effects:</source>
          <target state="translated">&lt;code&gt;INLINE&lt;/code&gt; プラグマの主な効果は、関数の「コスト」を非常に低く宣言することです。通常の展開機械は、インライン化に非常に熱心です。ただし、関数「 &lt;code&gt;f&lt;/code&gt; 」の &lt;code&gt;INLINE&lt;/code&gt; プラグマには、他にもいくつかの効果があります。</target>
        </trans-unit>
        <trans-unit id="1159d0b17e1c60d7b892bb9301ccde55977e5feb" translate="yes" xml:space="preserve">
          <source>The manifest file that GHC generates when linking a binary on Windows is also embedded in the executable itself, by default. This means that the binary can be distributed without having to supply the manifest file too. The embedding is done by running &lt;strong&gt;windres&lt;/strong&gt;; to see exactly what GHC does to embed the manifest, use the &lt;a href=&quot;using#ghc-flag--v&quot;&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/a&gt; flag. A GHC installation comes with its own copy of &lt;code&gt;windres&lt;/code&gt; for this reason.</source>
          <target state="translated">WindowsでバイナリをリンクするときにGHCが生成するマニフェストファイルも、デフォルトで実行可能ファイル自体に埋め込まれています。これは、マニフェストファイルを提供しなくてもバイナリを配布できることを意味します。埋め込みは、&lt;strong&gt;windres&lt;/strong&gt;を実行することによって行われます。マニフェストを埋め込むためにGHCが行うことを正確に確認するには、&lt;a href=&quot;using#ghc-flag--v&quot;&gt; &lt;code&gt;-v&lt;/code&gt; &lt;/a&gt;フラグを使用します。このため、GHCのインストールには独自の &lt;code&gt;windres&lt;/code&gt; のコピーが付属しています。</target>
        </trans-unit>
        <trans-unit id="3378e6fba41b187d6615b43817c87aba7dfb73d6" translate="yes" xml:space="preserve">
          <source>The marshalling converts each Haskell character, representing a Unicode code point, to one or more bytes in a manner that, by default, is determined by the current locale. As a consequence, no guarantees can be made about the relative length of a Haskell string and its corresponding C string, and therefore all the marshalling routines include memory allocation. The translation between Unicode and the encoding of the current locale may be lossy.</source>
          <target state="translated">マシャリングは、Unicodeコードポイントを表す各Haskell文字を、デフォルトでは現在のロケールによって決定される方法で、1バイト以上のバイトに変換します。その結果、Haskell 文字列とそれに対応する C 文字列の相対的な長さを保証することはできません。Unicodeと現在のロケールのエンコーディングとの間の変換は、損失を伴う可能性があります。</target>
        </trans-unit>
        <trans-unit id="ce3ddf92b0204346524d60c5ce7d32e072cd0d54" translate="yes" xml:space="preserve">
          <source>The matching behaviour is also influenced by two module-level language extension flags: &lt;a href=&quot;#extension-OverlappingInstances&quot;&gt;&lt;code&gt;OverlappingInstances&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt;. These extensions are now deprecated (since GHC 7.10) in favour of the fine-grained per-instance pragmas.</source>
          <target state="translated">マッチング動作は、2つのモジュールレベルの言語拡張フラグ（&lt;a href=&quot;#extension-OverlappingInstances&quot;&gt; &lt;code&gt;OverlappingInstances&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#extension-IncoherentInstances&quot;&gt; &lt;code&gt;IncoherentInstances&lt;/code&gt; &lt;/a&gt;）にも影響されます。これらの拡張機能は、（GHC 7.10以降）非推奨になり、インスタンスごとの細かいプラグマが優先されます。</target>
        </trans-unit>
        <trans-unit id="e2ff7a2e018dbc48e22ad18efcef13edd8c486f6" translate="yes" xml:space="preserve">
          <source>The matrix of platforms that:</source>
          <target state="translated">そのプラットフォームのマトリクス。</target>
        </trans-unit>
        <trans-unit id="07015c741417849721502853df57df8b2fae7145" translate="yes" xml:space="preserve">
          <source>The maximal prefix of &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; that could be decoded from the given input.</source>
          <target state="translated">指定された入力からデコードできる &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; の最大プレフィックス。</target>
        </trans-unit>
        <trans-unit id="aa2a714293d353e1ff3212bd761cfba481644c07" translate="yes" xml:space="preserve">
          <source>The maximal size of a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that is copied. &lt;code&gt;2 * &lt;a href=&quot;data-bytestring-builder-internal#v:smallChunkSize&quot;&gt;smallChunkSize&lt;/a&gt;&lt;/code&gt; to guarantee that on average a chunk is of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:smallChunkSize&quot;&gt;smallChunkSize&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">コピーされる &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; の最大サイズ。 &lt;code&gt;2 * &lt;a href=&quot;data-bytestring-builder-internal#v:smallChunkSize&quot;&gt;smallChunkSize&lt;/a&gt;&lt;/code&gt; 平均でチャンクがであることを保証する &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:smallChunkSize&quot;&gt;smallChunkSize&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d1640b5c03c6ca6aaac14f9e05c39afaa8e1c64" translate="yes" xml:space="preserve">
          <source>The maximum heap size also affects other garbage collection parameters: when the amount of live data in the heap exceeds a certain fraction of the maximum heap size, compacting collection will be automatically enabled for the oldest generation, and the &lt;code&gt;-F&lt;/code&gt; parameter will be reduced in order to avoid exceeding the maximum heap size.</source>
          <target state="translated">最大ヒープサイズは、他のガベージコレクションパラメータにも影響します。ヒープ内のライブデータの量が最大ヒープサイズの特定の割合を超えると、圧縮コレクションは最も古い世代に対して自動的に有効になり、 &lt;code&gt;-F&lt;/code&gt; パラメータが減少します。最大ヒープサイズを超えないようにするため。</target>
        </trans-unit>
        <trans-unit id="7deac0bbef1cce9de070bc6eff250887dc27e012" translate="yes" xml:space="preserve">
          <source>The maximum number of lines stored in the history. If &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the history storage is unlimited.</source>
          <target state="translated">履歴に保存される最大行数。場合は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 、履歴記憶は無制限です。</target>
        </trans-unit>
        <trans-unit id="926742977d518fd000b685af89eeb0e0f46e5036" translate="yes" xml:space="preserve">
          <source>The maximum number of lines stored in the history. If &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the history storage is unlimited.</source>
          <target state="translated">履歴に保存される行の最大数。場合は &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 、履歴記憶は無制限です。</target>
        </trans-unit>
        <trans-unit id="d734e50598efc9c9203e0509468ba84ba10e6429" translate="yes" xml:space="preserve">
          <source>The maximum number of of colors on the screen.</source>
          <target state="translated">画面に表示される最大の色数です。</target>
        </trans-unit>
        <trans-unit id="b7d459650a2ba9b1231e79e180aceb1bd015d81c" translate="yes" xml:space="preserve">
          <source>The maximum space actually used by your program is the &amp;ldquo;bytes maximum residency&amp;rdquo; figure. This is only checked during major garbage collections, so it is only an approximation; the number of samples tells you how many times it is checked.</source>
          <target state="translated">プログラムで実際に使用される最大スペースは、「バイトの最大常駐」の数値です。これは主要なガベージコレクション中にのみチェックされるため、概算にすぎません。サンプル数は、何回チェックされたかを示します。</target>
        </trans-unit>
        <trans-unit id="16877d3133192b7596dd9edb65bc59d15909dfa6" translate="yes" xml:space="preserve">
          <source>The maximum time elapsed during the post-mark pause phase of the concurrent nonmoving GC.</source>
          <target state="translated">同時進行非可動GCのマーク後一時停止段階での最大経過時間。</target>
        </trans-unit>
        <trans-unit id="8b43db138dc3a233b97e08a96f2e5508bd7bc2ca" translate="yes" xml:space="preserve">
          <source>The maximum tuple size</source>
          <target state="translated">最大タプルサイズ</target>
        </trans-unit>
        <trans-unit id="3c1ae6c029d2317f8ba5fb3110e02abfdbf30bfa" translate="yes" xml:space="preserve">
          <source>The meaning of the shortened &lt;a href=&quot;#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt; is dependent on whether your program was compiled for profiling. (See &lt;a href=&quot;profiling#rts-options-heap-prof&quot;&gt;RTS options for heap profiling&lt;/a&gt; for details.)</source>
          <target state="translated">短縮された&lt;a href=&quot;#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt;の意味は、プログラムがプロファイル用にコンパイルされたかどうかによって異なります。（詳細については&lt;a href=&quot;profiling#rts-options-heap-prof&quot;&gt;、ヒーププロファイリングのRTSオプションを&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="d87c8b0eb65b8cb788e02129482e2e2b711668c6" translate="yes" xml:space="preserve">
          <source>The meaning of the shortened &lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt; is dependent on whether your program was compiled for profiling. When compiled for profiling, &lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt; is equivalent to &lt;a href=&quot;#rts-flag--hc&quot;&gt;&lt;code&gt;-hc&lt;/code&gt;&lt;/a&gt;, but otherwise is equivalent to &lt;a href=&quot;runtime_control#rts-flag--hT&quot;&gt;&lt;code&gt;-hT&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;runtime_control#rts-profiling&quot;&gt;RTS options for profiling&lt;/a&gt;).</source>
          <target state="translated">短縮された&lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt;の意味は、プログラムがプロファイル用にコンパイルされたかどうかによって異なります。プロファイリング用にコンパイルされた場合、&lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;#rts-flag--hc&quot;&gt; &lt;code&gt;-hc&lt;/code&gt; &lt;/a&gt;と同等ですが、それ以外は&lt;a href=&quot;runtime_control#rts-flag--hT&quot;&gt; &lt;code&gt;-hT&lt;/code&gt; &lt;/a&gt;と同等です（&lt;a href=&quot;runtime_control#rts-profiling&quot;&gt;プロファイリングのRTSオプションを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2c90c10f5a199858ea71a07e1f9c65a1b0281964" translate="yes" xml:space="preserve">
          <source>The mechanism is simple: whenever the program evaluates an expression with an SCC annotation, &lt;code&gt;{-# SCC c -#} E&lt;/code&gt;, the cost centre &lt;code&gt;c&lt;/code&gt; is pushed on the current stack, and the entry count for this stack is incremented by one. The stack also sometimes has to be saved and restored; in particular when the program creates a thunk (a lazy suspension), the current cost-centre stack is stored in the thunk, and restored when the thunk is evaluated. In this way, the cost-centre stack is independent of the actual evaluation order used by GHC at runtime.</source>
          <target state="translated">メカニズムは単純です。プログラムがSCC注釈 &lt;code&gt;{-# SCC c -#} E&lt;/code&gt; を使用して式を評価するたびに、コストセンター &lt;code&gt;c&lt;/code&gt; が現在のスタックにプッシュされ、このスタックのエントリカウントが1ずつ増加します。スタックも保存して復元する必要がある場合があります。特に、プログラムがサンクを作成する場合（レイジーサスペンション）、現在のコストセンタースタックはサンクに格納され、サンクが評価されるときに復元されます。このように、コストセンタースタックは、実行時にGHCによって使用される実際の評価順序とは無関係です。</target>
        </trans-unit>
        <trans-unit id="f7c0a3feb5345a104be8d4a49924286ed63663fa" translate="yes" xml:space="preserve">
          <source>The member functions of this class facilitate writing values of primitive types to raw memory (which may have been allocated with the above mentioned routines) and reading values from blocks of raw memory. The class, furthermore, includes support for computing the storage requirements and alignment restrictions of storable types.</source>
          <target state="translated">このクラスのメンバ関数は、原始型の値を生メモリ(上述のルーチンで割り当てられている可能性がある)に書き込むことと、生メモリのブロックから値を読み出すことを容易にする。このクラスは,さらに,格納可能な型の格納要件と整列制限を計算するためのサポートを含む.</target>
        </trans-unit>
        <trans-unit id="cba31954fa26087a15e99fd14a2e8df87f705a4d" translate="yes" xml:space="preserve">
          <source>The members &lt;code&gt;&lt;a href=&quot;foreign-storable#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-storable#v:poke&quot;&gt;poke&lt;/a&gt;&lt;/code&gt; of the &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; class map all values of &lt;code&gt;CT&lt;/code&gt; to the corresponding value of &lt;code&gt;t&lt;/code&gt; and vice versa.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; クラスのメンバー &lt;code&gt;&lt;a href=&quot;foreign-storable#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-storable#v:poke&quot;&gt;poke&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;CT&lt;/code&gt; のすべての値を対応する &lt;code&gt;t&lt;/code&gt; の値に、またはその逆にマップします。</target>
        </trans-unit>
        <trans-unit id="723dfa6d14019cdcb7ea8b493daa172324f5d5cf" translate="yes" xml:space="preserve">
          <source>The memory is freed when &lt;code&gt;f&lt;/code&gt; terminates (either normally or via an exception), so the pointer passed to &lt;code&gt;f&lt;/code&gt; must &lt;em&gt;not&lt;/em&gt; be used after this.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が終了すると（通常または例外を介して）メモリが解放されるため、 &lt;code&gt;f&lt;/code&gt; に渡されたポインタをこの後に使用し&lt;em&gt;ない&lt;/em&gt;でください。</target>
        </trans-unit>
        <trans-unit id="30cdd2b8067e97ef326db4b7a7649ae2a1d70b50" translate="yes" xml:space="preserve">
          <source>The memory management overhead. Currently this is tuned for GHC only.</source>
          <target state="translated">メモリ管理のオーバーヘッドです。現在はGHCのみにチューニングされています。</target>
        </trans-unit>
        <trans-unit id="296145d71ce1908abeb930aa215c007de95d6dac" translate="yes" xml:space="preserve">
          <source>The memory may be deallocated using &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:finalizerFree&quot;&gt;finalizerFree&lt;/a&gt;&lt;/code&gt; when no longer required.</source>
          <target state="translated">メモリは、不要になっ &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:finalizerFree&quot;&gt;finalizerFree&lt;/a&gt;&lt;/code&gt; ときに &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; またはfinalizerFreeを使用して割り当て解除できます。</target>
        </trans-unit>
        <trans-unit id="b7786c976f2ff7540d0a6e4b59833c22c599315f" translate="yes" xml:space="preserve">
          <source>The memory may freed at any point after the subcomputation terminates, so the pointer to the storage must *not* be used after this.</source>
          <target state="translated">メモリは、サブ計算終了後の任意の時点で解放される可能性があるので、この後にストレージへのポインタは*使用されてはなりません。</target>
        </trans-unit>
        <trans-unit id="51295ee3cd81001e8a30ec8543497b0e8c877217" translate="yes" xml:space="preserve">
          <source>The merit of this is that you can derive instances for GADTs and other exotic data types, providing only that the boilerplate code does indeed typecheck. For example:</source>
          <target state="translated">これのメリットは、GADTやその他のエキゾチックなデータ型のインスタンスを導出することができることです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="706d394f30bc5168ee0ad023e79bd99ae56018eb" translate="yes" xml:space="preserve">
          <source>The message</source>
          <target state="translated">メッセージ</target>
        </trans-unit>
        <trans-unit id="09ce093d9b8936752c951269f1ca598cad553080" translate="yes" xml:space="preserve">
          <source>The message printed if &lt;code&gt;malloc&lt;/code&gt; fails.</source>
          <target state="translated">&lt;code&gt;malloc&lt;/code&gt; が失敗した場合に出力されるメッセージ。</target>
        </trans-unit>
        <trans-unit id="7c55c4a564eeb697e2553fd6d32d12eec12c5af2" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of parsing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be are expected to use double quotes, rather than square brackets.</source>
          <target state="translated">メソッド &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; は、プログラマが値のリストを解析する特殊な方法を提供できるようにするために提供されています。たとえば、これは &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 型の事前定義された &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスによって使用されます。この場合、 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 型の値には角括弧ではなく二重引用符を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="2bb9dae247f1417713fe2e3ff89e568a58dd2064" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;ghc-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of showing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be shown in double quotes, rather than between square brackets.</source>
          <target state="translated">メソッド &lt;code&gt;&lt;a href=&quot;ghc-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; は、プログラマが値のリストを表示する特別な方法を提供できるようにするために提供されています。たとえば、これは &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 型の事前定義された &lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; インスタンスで使用されます。この場合、型 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; の値は角括弧の代わりに二重引用符で表示されます。</target>
        </trans-unit>
        <trans-unit id="9b206e34c8564a26770cfb63266e92dafdef2f00" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;prelude#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of parsing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be are expected to use double quotes, rather than square brackets.</source>
          <target state="translated">メソッド &lt;code&gt;&lt;a href=&quot;prelude#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; は、プログラマが値のリストを解析する特殊な方法を提供できるようにするために提供されています。たとえば、これは &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 型の事前定義された &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスによって使用されます。この場合、 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 型の値には角括弧ではなく二重引用符を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="0b9ba8a954c2ae61c20aa36e469332d7313c7d48" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;prelude#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of showing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be shown in double quotes, rather than between square brackets.</source>
          <target state="translated">メソッド &lt;code&gt;&lt;a href=&quot;prelude#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; は、プログラマが値のリストを表示する特別な方法を提供できるようにするために提供されています。たとえば、これは &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 型の事前定義された &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; インスタンスで使用されます。この場合、型 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; の値は角括弧の代わりに二重引用符で表示されます。</target>
        </trans-unit>
        <trans-unit id="332ed4acf796a389b61681f06e5d3b89101d146a" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of parsing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be are expected to use double quotes, rather than square brackets.</source>
          <target state="translated">メソッド &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; は、プログラマが値のリストを解析する特殊な方法を提供できるようにするために提供されています。たとえば、これは &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 型の事前定義された &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスによって使用されます。この場合、 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 型の値には角括弧ではなく二重引用符を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="1e8a0b574789d1de5cf8d746837c55989fd9ec8f" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;text-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of showing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be shown in double quotes, rather than between square brackets.</source>
          <target state="translated">メソッド &lt;code&gt;&lt;a href=&quot;text-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; は、プログラマが値のリストを表示する特別な方法を提供できるようにするために提供されています。たとえば、これは &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 型の事前定義された &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; インスタンスで使用されます。この場合、型 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; の値は角括弧の代わりに二重引用符で表示されます。</target>
        </trans-unit>
        <trans-unit id="a55e07264dbb157af3468bbfef9f673d9ed1c760" translate="yes" xml:space="preserve">
          <source>The method names refer to the monoid of lists under concatenation, but there are many other instances.</source>
          <target state="translated">メソッド名は連結下のリストのモノイドを参照していますが、他にもたくさんのインスタンスがあります。</target>
        </trans-unit>
        <trans-unit id="14f5aff046cf43c34ac7e373b3ac53e710239001" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-records&quot;&gt;GHC.Records&lt;/a&gt; defines the following:</source>
          <target state="translated">モジュール&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-records&quot;&gt;GHC.Records&lt;/a&gt;は以下を定義します：</target>
        </trans-unit>
        <trans-unit id="5f6effa84fa526911a5bc26f168d26945f6ee5ab" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-records&quot;&gt;GHC.Records&lt;/a&gt; defines the following:</source>
          <target state="translated">The module &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-records&quot;&gt;GHC.Records&lt;/a&gt; defines the following:</target>
        </trans-unit>
        <trans-unit id="6fe9f2287d708875ff918672eee840079c919130" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;foreign-marshal-alloc&quot;&gt;Foreign.Marshal.Alloc&lt;/a&gt; provides operations to allocate and deallocate blocks of raw memory (i.e., unstructured chunks of memory outside of the area maintained by the Haskell storage manager). These memory blocks are commonly used to pass compound data structures to foreign functions or to provide space in which compound result values are obtained from foreign functions.</source>
          <target state="translated">モジュール&lt;a href=&quot;foreign-marshal-alloc&quot;&gt;Foreign.Marshal.Alloc&lt;/a&gt;は、生のメモリのブロック（つまり、Haskellストレージマネージャーによって管理されている領域外の構造化されていないメモリのチャンク）を割り当てたり割り当て解除したりする操作を提供します。これらのメモリブロックは、複合データ構造を外部関数に渡すため、または外部関数から複合結果値が取得されるスペースを提供するために一般的に使用されます。</target>
        </trans-unit>
        <trans-unit id="0aaac35805022709131420c56844a405405859b9" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;foreign-marshal-safe&quot;&gt;Foreign.Marshal.Safe&lt;/a&gt; re-exports the other modules in the &lt;code&gt;Foreign.Marshal&lt;/code&gt; hierarchy (except for &lt;code&gt;Foreign.Marshal.Unsafe&lt;/code&gt;):</source>
          <target state="translated">モジュール&lt;a href=&quot;foreign-marshal-safe&quot;&gt;Foreign.Marshal.Safe&lt;/a&gt;は、 &lt;code&gt;Foreign.Marshal&lt;/code&gt; 階層の他のモジュールを再エクスポートします（ &lt;code&gt;Foreign.Marshal.Unsafe&lt;/code&gt; を除く）：</target>
        </trans-unit>
        <trans-unit id="b1df10bb69bf2b89bf3830cfbd382b7d65aa4ba2" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;foreign-marshal-safe&quot;&gt;Foreign.Marshal.Safe&lt;/a&gt; re-exports the other modules in the &lt;code&gt;Foreign.Marshal&lt;/code&gt; hierarchy:</source>
          <target state="translated">モジュール&lt;a href=&quot;foreign-marshal-safe&quot;&gt;Foreign.Marshal.Safe&lt;/a&gt;は、 &lt;code&gt;Foreign.Marshal&lt;/code&gt; 階層内の他のモジュールを再エクスポートします。</target>
        </trans-unit>
        <trans-unit id="28a8a8e9077c7af6ee0166e9bad843be62034b8c" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;foreign-storable&quot;&gt;Foreign.Storable&lt;/a&gt; provides most elementary support for marshalling and is part of the language-independent portion of the Foreign Function Interface (FFI), and will normally be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">モジュール&lt;a href=&quot;foreign-storable&quot;&gt;Foreign.Storable&lt;/a&gt;は、マーシャリングの最も基本的なサポートを提供し、Foreign Function Interface（FFI）の言語に依存しない部分の一部であり、通常は&lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt;モジュールを介してインポートされます。</target>
        </trans-unit>
        <trans-unit id="c4efc02d68c3af490556f0b55e2f290168abc177" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;A&lt;/code&gt; below is annotated to be explictly &lt;code&gt;Safe&lt;/code&gt;, but it imports &lt;code&gt;Safe-Inferred&lt;/code&gt; module.</source>
          <target state="translated">The module &lt;code&gt;A&lt;/code&gt; below is annotated to be explictly &lt;code&gt;Safe&lt;/code&gt; , but it imports &lt;code&gt;Safe-Inferred&lt;/code&gt; module.</target>
        </trans-unit>
        <trans-unit id="7b7c64247943d5ed0c07fe913e3a4cc1b0d102fc" translate="yes" xml:space="preserve">
          <source>The module header (including the export list), and import statements, are exactly as in Haskell, and so are the scoping rules. Hence, to mention a non-Prelude type or class, you must import it.</source>
          <target state="translated">モジュールヘッダ(エクスポートリストを含む)とインポート文は、Haskellと全く同じであり、スコープルールも同様です。したがって、Prelude以外の型やクラスを言及するには、それをインポートしなければなりません。</target>
        </trans-unit>
        <trans-unit id="4ce45cb81b574e7a52ecde45d4ee5f41764d49db" translate="yes" xml:space="preserve">
          <source>The module must import &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;.</source>
          <target state="translated">モジュールは&lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrowを&lt;/a&gt;インポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="d0567f67de5a3f399a53df0817cedcf626bf1864" translate="yes" xml:space="preserve">
          <source>The module must import &lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;.</source>
          <target state="translated">The module must import &lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="271abdd5800add2d2a429d3960db113d446e207f" translate="yes" xml:space="preserve">
          <source>The module was compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">モジュールは&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;でコンパイルされました</target>
        </trans-unit>
        <trans-unit id="61f9fc1e39c23939a82e428406225578b440fb61" translate="yes" xml:space="preserve">
          <source>The module was compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">モジュールは&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;でコンパイルされました</target>
        </trans-unit>
        <trans-unit id="8638db98256357d4532755afc9c9f9aac9ff4038" translate="yes" xml:space="preserve">
          <source>The monad and its operations</source>
          <target state="translated">モナドとその運用</target>
        </trans-unit>
        <trans-unit id="da5e8905606683d3d0ad467ab40cd56a8717786c" translate="yes" xml:space="preserve">
          <source>The monoid of endomorphisms under composition.</source>
          <target state="translated">構成中の同形体のモノイド。</target>
        </trans-unit>
        <trans-unit id="e9ccf96ea16ca69c701719763f3afb8aa9f150cf" translate="yes" xml:space="preserve">
          <source>The most common usage of &lt;code&gt;COMPLETE&lt;/code&gt; pragmas is with &lt;a href=&quot;#pattern-synonyms&quot;&gt;Pattern synonyms&lt;/a&gt;. On its own, the checker is very naive and assumes that any match involving a pattern synonym will fail. As a result, any pattern match on a pattern synonym is regarded as incomplete unless the user adds a catch-all case.</source>
          <target state="translated">&lt;code&gt;COMPLETE&lt;/code&gt; プラグマの最も一般的な使用法は、&lt;a href=&quot;#pattern-synonyms&quot;&gt;パターン同義語での使用&lt;/a&gt;です。それ自体、チェッカーは非常に単純であり、パターンの同義語を含むすべての一致が失敗すると想定しています。その結果、ユーザーがキャッチオールケースを追加しない限り、パターンシノニムでのパターンマッチは不完全と見なされます。</target>
        </trans-unit>
        <trans-unit id="063a9618d36844f08d6ef94989127397ea9b9b40" translate="yes" xml:space="preserve">
          <source>The most common way this can happen is when you&amp;rsquo;re evaluating a CAF (e.g. main), stop at a breakpoint, and ask for the value of the CAF at the prompt again.</source>
          <target state="translated">これが発生する最も一般的な方法は、CAF（メインなど）を評価し、ブレークポイントで停止し、プロンプトでCAFの値を再度要求する場合です。</target>
        </trans-unit>
        <trans-unit id="75340b8409f86aba60aed6656112aab745923bcd" translate="yes" xml:space="preserve">
          <source>The most commonly used ISO 8601 format for this type.</source>
          <target state="translated">このタイプで最も一般的に使用されているISO 8601フォーマット。</target>
        </trans-unit>
        <trans-unit id="bfe39e2ecd43cfd563f91e4eca3de1502694fa6f" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser over the Identity monad. &lt;code&gt;runParser p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns either a &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Identityモナドでパーサーを実行する最も一般的な方法。 &lt;code&gt;runParser p state filePath input&lt;/code&gt; は、ソース &lt;code&gt;filePath&lt;/code&gt; から取得したトークン &lt;code&gt;input&lt;/code&gt; の入力リストでパーサー &lt;code&gt;p&lt;/code&gt; を初期ユーザー状態 &lt;code&gt;st&lt;/code&gt; で実行します。 &lt;code&gt;filePath&lt;/code&gt; には、エラーメッセージだけで使用され、空の文字列かもしれません。 &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ）またはタイプ &lt;code&gt;a&lt;/code&gt; の値（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ）を返します。</target>
        </trans-unit>
        <trans-unit id="543b04448bf8e6b461926178ee2dbfc4a06a930b" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser over the Identity monad. &lt;code&gt;runParser p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns either a &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">The most general way to run a parser over the Identity monad. &lt;code&gt;runParser p state filePath input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt; , obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt; . The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns either a &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ) or a value of type &lt;code&gt;a&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="aeb3d7e2ffb679903cf3a78fe1e8a43f4f5df8ed" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser over the Identity monad. &lt;code&gt;runParser p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns either a &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Identityモナドでパーサーを実行する最も一般的な方法。 &lt;code&gt;runParser p state filePath input&lt;/code&gt; は、ソース &lt;code&gt;filePath&lt;/code&gt; から取得したトークン &lt;code&gt;input&lt;/code&gt; の入力リストでパーサー &lt;code&gt;p&lt;/code&gt; を初期ユーザー状態 &lt;code&gt;st&lt;/code&gt; で実行します。 &lt;code&gt;filePath&lt;/code&gt; には、エラーメッセージだけで使用され、空の文字列かもしれません。 &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ）またはタイプ &lt;code&gt;a&lt;/code&gt; の値（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ）を返します。</target>
        </trans-unit>
        <trans-unit id="c81f5972096e036f48bc7e8b9d08264ff1cf03cf" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser over the Identity monad. &lt;code&gt;runParser p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns either a &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">The most general way to run a parser over the Identity monad. &lt;code&gt;runParser p state filePath input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt; , obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt; . The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns either a &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ) or a value of type &lt;code&gt;a&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2c5053914782286bf569d388ab06bfb0dd58462e" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser. &lt;code&gt;runParserT p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns a computation in the underlying monad &lt;code&gt;m&lt;/code&gt; that return either a &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">パーサーを実行する最も一般的な方法。 &lt;code&gt;runParserT p state filePath input&lt;/code&gt; は、トークンuser inputの入力リストでパーサー &lt;code&gt;p&lt;/code&gt; を実行し &lt;code&gt;input&lt;/code&gt; 。これは、ソース &lt;code&gt;filePath&lt;/code&gt; から初期ユーザー状態 &lt;code&gt;st&lt;/code&gt; で取得されます。 &lt;code&gt;filePath&lt;/code&gt; には、エラーメッセージだけで使用され、空の文字列かもしれません。 &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ）またはタイプ &lt;code&gt;a&lt;/code&gt; の値（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ）を返す、基礎となるモナド &lt;code&gt;m&lt;/code&gt; の計算を返します。</target>
        </trans-unit>
        <trans-unit id="f9e6c38470342e612c5ecfc863c68e581e87f551" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser. &lt;code&gt;runParserT p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns a computation in the underlying monad &lt;code&gt;m&lt;/code&gt; that return either a &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">The most general way to run a parser. &lt;code&gt;runParserT p state filePath input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt; , obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt; . The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns a computation in the underlying monad &lt;code&gt;m&lt;/code&gt; that return either a &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ) or a value of type &lt;code&gt;a&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0c6a5560b83d86896cc9662f87720adba5507322" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser. &lt;code&gt;runParserT p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns a computation in the underlying monad &lt;code&gt;m&lt;/code&gt; that return either a &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">パーサーを実行する最も一般的な方法。 &lt;code&gt;runParserT p state filePath input&lt;/code&gt; は、トークンuser inputの入力リストでパーサー &lt;code&gt;p&lt;/code&gt; を実行し &lt;code&gt;input&lt;/code&gt; 。これは、ソース &lt;code&gt;filePath&lt;/code&gt; から初期ユーザー状態 &lt;code&gt;st&lt;/code&gt; で取得されます。 &lt;code&gt;filePath&lt;/code&gt; には、エラーメッセージだけで使用され、空の文字列かもしれません。 &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ）またはタイプ &lt;code&gt;a&lt;/code&gt; の値（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ）を返す、基礎となるモナド &lt;code&gt;m&lt;/code&gt; の計算を返します。</target>
        </trans-unit>
        <trans-unit id="5191e620570ba9224bf45cd4aebb8c9b695aafc1" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser. &lt;code&gt;runParserT p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns a computation in the underlying monad &lt;code&gt;m&lt;/code&gt; that return either a &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">The most general way to run a parser. &lt;code&gt;runParserT p state filePath input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt; , obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt; . The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns a computation in the underlying monad &lt;code&gt;m&lt;/code&gt; that return either a &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ) or a value of type &lt;code&gt;a&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b5be00a95c813a0dae9db110b897e76b924717d2" translate="yes" xml:space="preserve">
          <source>The motivation for the change is that it means &lt;code&gt;IO a&lt;/code&gt; actions default to &lt;code&gt;IO ()&lt;/code&gt;, which in turn means that ghci won&amp;rsquo;t try to print a result when running them. This is particularly important for &lt;code&gt;printf&lt;/code&gt;, which has an instance that returns &lt;code&gt;IO a&lt;/code&gt;. However, it is only able to return &lt;code&gt;undefined&lt;/code&gt; (the reason for the instance having this type is so that printf doesn&amp;rsquo;t require extensions to the class system), so if the type defaults to &lt;code&gt;Integer&lt;/code&gt; then ghci gives an error when running a printf.</source>
          <target state="translated">変更の動機は、それが &lt;code&gt;IO a&lt;/code&gt; アクションのデフォルトが &lt;code&gt;IO ()&lt;/code&gt; であることを意味します。これは、順番にghciが実行時に結果を出力しようとしないことを意味します。これは、 &lt;code&gt;IO a&lt;/code&gt; を返すインスタンスを持つ &lt;code&gt;printf&lt;/code&gt; にとって特に重要です。ただし、 &lt;code&gt;undefined&lt;/code&gt; を返すことしかできません（このタイプのインスタンスが存在する理由は、printfがクラスシステムへの拡張を必要としないためです）。そのため、タイプのデフォルトが &lt;code&gt;Integer&lt;/code&gt; の場合、ghciはprintfの実行時にエラーを出します。</target>
        </trans-unit>
        <trans-unit id="959ea0490110e05809c000a4c38196ada4c3c8cf" translate="yes" xml:space="preserve">
          <source>The mtl style typeclass</source>
          <target state="translated">mtl スタイルの型クラス</target>
        </trans-unit>
        <trans-unit id="c736836da3c61a5b28a8e40cd26c58ac3671ca42" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; is used to illustrate the relationship to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt;: where &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; is shallow in the sense that it only evaluates the top level of its argument, &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; traverses the entire data structure evaluating it completely.</source>
          <target state="translated">名前 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; は、との関係説明するために使用される &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; ：ここで、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; それだけで、その引数のトップレベルを評価するという意味で浅い &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; トラバースそれを完全に評価する全体のデータ構造。</target>
        </trans-unit>
        <trans-unit id="c8c9046bcf066fa425b4dcc4d07e5da4b61485a0" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; is used to illustrate the relationship to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt;: where &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; is shallow in the sense that it only evaluates the top level of its argument, &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; traverses the entire data structure evaluating it completely.</source>
          <target state="translated">The name &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; is used to illustrate the relationship to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; : where &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; is shallow in the sense that it only evaluates the top level of its argument, &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; traverses the entire data structure evaluating it completely.</target>
        </trans-unit>
        <trans-unit id="ecfeb2264bf3f2219dcf11640cc5f23d975957a1" translate="yes" xml:space="preserve">
          <source>The name of an executable with a list of arguments</source>
          <target state="translated">引数のリストを持つ実行可能ファイルの名前</target>
        </trans-unit>
        <trans-unit id="e05e238891a0e5d7a1ad5addb5acbfa1d828b57f" translate="yes" xml:space="preserve">
          <source>The name of the constructor</source>
          <target state="translated">コンストラクタの名前</target>
        </trans-unit>
        <trans-unit id="2372d4365121c955cf759525401a9a51abda2da3" translate="yes" xml:space="preserve">
          <source>The name of the datatype (unqualified)</source>
          <target state="translated">データ型の名前 (unqualified)</target>
        </trans-unit>
        <trans-unit id="4ad137cef439e5cbd9d31d951cbeeb39fa772cfe" translate="yes" xml:space="preserve">
          <source>The name of the dynamic library on Windows systems (optional).</source>
          <target state="translated">Windows システム上の動的ライブラリの名前(オプション)。</target>
        </trans-unit>
        <trans-unit id="a75d937e0b98713b032f66a0d3ddc12a66577a2c" translate="yes" xml:space="preserve">
          <source>The name of the interface file is derived using the same rules, except that the suffix is ⟨hisuf⟩ (&lt;code&gt;.hi&lt;/code&gt; by default) instead of ⟨osuf⟩, and the relevant options are &lt;a href=&quot;#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-hidir ⟨dir⟩&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--hisuf%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt;&lt;code&gt;-hisuf ⟨suffix⟩&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-odir ⟨dir⟩&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--osuf%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt;&lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt;&lt;/a&gt; respectively.</source>
          <target state="translated">インタフェースファイルの名前は接尾辞が⟨hisuf⟩（であることを除いて、同じルールを使用して導出される &lt;code&gt;.hi&lt;/code&gt; デフォルト）の代わりに、⟨osuf⟩、および関連するオプションがあり&lt;a href=&quot;#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-hidir ⟨dir⟩&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#ghc-flag--hisuf%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt; &lt;code&gt;-hisuf ⟨suffix⟩&lt;/code&gt; &lt;/a&gt;代わりに、&lt;a href=&quot;#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-odir ⟨dir⟩&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#ghc-flag--osuf%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt; &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; &lt;/a&gt;それぞれ。</target>
        </trans-unit>
        <trans-unit id="6453686e83ae95972b7e17f3b926e084c57ab74f" translate="yes" xml:space="preserve">
          <source>The name of the library on Unix and Windows (mingw) systems. Note that we don&amp;rsquo;t support building dynamic libraries of Haskell code on Unix systems.</source>
          <target state="translated">UnixおよびWindows（mingw）システムでのライブラリの名前。UnixシステムでのHaskellコードの動的ライブラリの構築はサポートされていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d0f5dc8321c09ce84049b074ac570bfbec19828a" translate="yes" xml:space="preserve">
          <source>The name of the object file generated by GHC is derived according to the following rules, where ⟨osuf⟩ is the object-file suffix (this can be changed with the &lt;code&gt;-osuf&lt;/code&gt; option).</source>
          <target state="translated">GHCによって生成されるオブジェクトファイルの名前は、次のルールに従って導出されます。ここで、「osuf」はオブジェクトファイルのサフィックスです（これは &lt;code&gt;-osuf&lt;/code&gt; オプションで変更できます）。</target>
        </trans-unit>
        <trans-unit id="6861c4770b27354d7d4cfab408a9a6ca379e4807" translate="yes" xml:space="preserve">
          <source>The name of the pattern synonym is in the same namespace as proper data constructors. Like normal data constructors, pattern synonyms can be imported and exported through association with a type constructor or independently.</source>
          <target state="translated">パターン同義語の名前は、適切なデータ・コンストラクタと同じ名前空間にあります。通常のデータコンストラクタと同様に、パターン同義語は、型コンストラクタとの関連付けによって、または独立してインポートおよびエクスポートすることができます。</target>
        </trans-unit>
        <trans-unit id="1be799bf296167235ebb2ca091eee552b142616f" translate="yes" xml:space="preserve">
          <source>The name of the program</source>
          <target state="translated">プログラム名</target>
        </trans-unit>
        <trans-unit id="39a42659e6043aff3532b0014c5b4fae37244931" translate="yes" xml:space="preserve">
          <source>The name of the selector</source>
          <target state="translated">セレクタの名前</target>
        </trans-unit>
        <trans-unit id="7c51ecee2db2e110dbf3d1d2d9420bc2a5044c61" translate="yes" xml:space="preserve">
          <source>The name of the zone, typically a three- or four-letter acronym.</source>
          <target state="translated">ゾーンの名前で、通常は3文字または4文字の頭文字をとったものです。</target>
        </trans-unit>
        <trans-unit id="4e49908da6a172e68a423a7eb23e95b552938d75" translate="yes" xml:space="preserve">
          <source>The name of this group (gr_name)</source>
          <target state="translated">このグループの名前 (gr_name)</target>
        </trans-unit>
        <trans-unit id="fae25b47526c2bd90bbb6d0b312e7136e668661b" translate="yes" xml:space="preserve">
          <source>The name of this operator is an allusion to &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt;. Note the similarities between their types:</source>
          <target state="translated">この演算子の名前は &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; の暗示です。それらのタイプの類似点に注意してください：</target>
        </trans-unit>
        <trans-unit id="3bffd90620f4f0f826e5aaf337b1fe1334e782e4" translate="yes" xml:space="preserve">
          <source>The name without its module prefix.</source>
          <target state="translated">モジュールの接頭辞を除いた名前。</target>
        </trans-unit>
        <trans-unit id="646f96f37bb735ef8278fbc57b542fce8c940d51" translate="yes" xml:space="preserve">
          <source>The named wildcard forces the argument and result types to be the same. Lacking a signature, GHC would have inferred &lt;code&gt;forall a b. (Char, a) -&amp;gt; (Char, b)&lt;/code&gt;. A named wildcard can be mentioned in constraints, provided it also occurs in the monotype part of the type signature to make sure that it unifies with something:</source>
          <target state="translated">名前付きワイルドカードは、引数と結果の型が同じになるように強制します。署名がなければ、GHCは &lt;code&gt;forall a b. (Char, a) -&amp;gt; (Char, b)&lt;/code&gt; を推測したでしょう。（Char、a）-&amp;gt;（Char、b）。名前付きワイルドカードは、型シグネチャのモノタイプ部分にも出現することを条件に、制約で言及できます。</target>
        </trans-unit>
        <trans-unit id="1eb6c48a77c3ff916d6d31d64741779306bc02b7" translate="yes" xml:space="preserve">
          <source>The names in this module resemble those in the &lt;code&gt;&lt;a href=&quot;data#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; family of modules, but are shorter due to the assumption of qualified naming.</source>
          <target state="translated">このモジュールの名前は、モジュールの &lt;code&gt;&lt;a href=&quot;data#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; ファミリの名前に似ていますが、修飾された名前を想定しているため、短くなっています。</target>
        </trans-unit>
        <trans-unit id="2a298a889af18ee73428f1b23010db1d461094d5" translate="yes" xml:space="preserve">
          <source>The namespaces are:</source>
          <target state="translated">名前空間は</target>
        </trans-unit>
        <trans-unit id="c41bfe70547efc280b4b232c6db8795351037886" translate="yes" xml:space="preserve">
          <source>The naming scheme may look a bit weird, but it has the purpose of allowing the co-existence of import libraries with ordinary static libraries (e.g., &lt;code&gt;libHSfoo.a&lt;/code&gt; and &lt;code&gt;libHSfoo.dll.a&lt;/code&gt;. Additionally, when the compiler driver is linking in non-static mode, it will rewrite occurrence of &lt;code&gt;-lHSfoo&lt;/code&gt; on the command line to &lt;code&gt;-lHSfoo.dll&lt;/code&gt;. By doing this for you, switching from non-static to static linking is simply a question of adding &lt;code&gt;-static&lt;/code&gt; to your command line.</source>
          <target state="translated">命名スキームは少し奇妙に見えるかもしれませんが、インポートライブラリと通常の静的ライブラリ（たとえば &lt;code&gt;libHSfoo.a&lt;/code&gt; および &lt;code&gt;libHSfoo.dll.a&lt;/code&gt; )の共存を許可する目的があります。さらに、コンパイラドライバが非-staticモード、それが発生書き換えます &lt;code&gt;-lHSfoo&lt;/code&gt; にコマンドラインで &lt;code&gt;-lHSfoo.dll&lt;/code&gt; を。静的リンクに非静的からの切り替え、あなたのためにこれを行うことにより、単純に追加の質問です &lt;code&gt;-static&lt;/code&gt; をコマンド・ラインに。</target>
        </trans-unit>
        <trans-unit id="db2b10aabaace6cc9d2b20bf6478500589166faa" translate="yes" xml:space="preserve">
          <source>The native code-generator can either dump binary blobs (e.g. string literals) into the assembly file (by using &amp;ldquo;.asciz&amp;rdquo; or &amp;ldquo;.string&amp;rdquo; assembler directives) or it can dump them as binary data into a temporary file which is then included by the assembler (using the &amp;ldquo;.incbin&amp;rdquo; assembler directive).</source>
          <target state="translated">The native code-generator can either dump binary blobs (e.g. string literals) into the assembly file (by using &amp;ldquo;.asciz&amp;rdquo; or &amp;ldquo;.string&amp;rdquo; assembler directives) or it can dump them as binary data into a temporary file which is then included by the assembler (using the &amp;ldquo;.incbin&amp;rdquo; assembler directive).</target>
        </trans-unit>
        <trans-unit id="a0044db577b12199ca68313af424ef55cbf96d30" translate="yes" xml:space="preserve">
          <source>The native newline representation for the current platform: &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; on Unix systems, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; on Windows.</source>
          <target state="translated">現在のプラットフォームのネイティブ改行表現：Unixシステムでは &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; 、Windows では &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17286b53488467d11ce996bb67e9ac72d58ccc97" translate="yes" xml:space="preserve">
          <source>The native newline representation for the current platform: &lt;code&gt;&lt;a href=&quot;ghc-io-handle-types#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; on Unix systems, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-types#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; on Windows.</source>
          <target state="translated">現在のプラットフォームのネイティブ改行表現：Unixシステムでは &lt;code&gt;&lt;a href=&quot;ghc-io-handle-types#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; 、Windows では &lt;code&gt;&lt;a href=&quot;ghc-io-handle-types#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78f21582e0027e530ef578f9b561481600ae0181" translate="yes" xml:space="preserve">
          <source>The native newline representation for the current platform: &lt;code&gt;&lt;a href=&quot;system-io#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; on Unix systems, &lt;code&gt;&lt;a href=&quot;system-io#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; on Windows.</source>
          <target state="translated">現在のプラットフォームのネイティブ改行表現：Unixシステムでは &lt;code&gt;&lt;a href=&quot;system-io#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; 、Windows では &lt;code&gt;&lt;a href=&quot;system-io#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f38af79343aeda66e3c105c4d632b98dde240785" translate="yes" xml:space="preserve">
          <source>The natural generated &lt;code&gt;Eq&lt;/code&gt; code would result in these instance declarations:</source>
          <target state="translated">自然に生成された &lt;code&gt;Eq&lt;/code&gt; コードは、これらのインスタンス宣言になります。</target>
        </trans-unit>
        <trans-unit id="2aa75ff914d05468b9b141013cb484ac0d26b5d2" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; shares the finalizer of the original, equivalent from a finalization standpoint to just creating another reference to the original. That is, the finalizer will not be called before the new &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is unreachable, nor will it be called an additional time due to this call, and the finalizer will be called with the same address that it would have had this call not happened, *not* the new address.</source>
          <target state="translated">新しい &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; はオリジナルのファイナライザを共有します。これは、ファイナライズの観点から、オリジナルへの別の参照を作成することと同等です。つまり、ファイナライザは、新しい &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; が到達不能になる前に呼び出されることはなく、この呼び出しにより追加の時間で呼び出されることもありません。また、ファイナライザは、この呼び出しが行われなかった場合と同じアドレスで呼び出されます。*新しいアドレスではありません*。</target>
        </trans-unit>
        <trans-unit id="d537ecc2a0a7273339bdcd281e6203980acce3cf" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; shares the finalizer of the original, equivalent from a finalization standpoint to just creating another reference to the original. That is, the finalizer will not be called before the new &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is unreachable, nor will it be called an additional time due to this call, and the finalizer will be called with the same address that it would have had this call not happened, *not* the new address.</source>
          <target state="translated">新しい &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; はオリジナルのファイナライザを共有します。これは、ファイナライズの観点から、オリジナルへの別の参照を作成することと同等です。つまり、ファイナライザは、新しい &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; が到達不能になる前に呼び出されることはなく、この呼び出しにより追加の時間で呼び出されることもありません。また、ファイナライザは、この呼び出しが行われなかった場合と同じアドレスで呼び出されます。*新しいアドレスではありません*。</target>
        </trans-unit>
        <trans-unit id="9565bf7af2fc32661af4296e391a5a4f73420f53" translate="yes" xml:space="preserve">
          <source>The new algorithm considers all outgoing edges of a basic blocks for code layout instead of only the last jump instruction. It also builds a control flow graph for functions, tries to find hot code paths and place them sequentially leading to better cache utilization and performance.</source>
          <target state="translated">新しいアルゴリズムは、コードレイアウトのために、最後のジャンプ命令のみではなく、基本ブロックのすべての出て行くエッジを考慮します。また、関数の制御フローグラフを構築し、ホットなコードパスを見つけて順次配置することで、キャッシュ利用率とパフォーマンスを向上させています。</target>
        </trans-unit>
        <trans-unit id="0e6b6e161e08547e4c2e84b69fc3ce69fd7fe2bd" translate="yes" xml:space="preserve">
          <source>The new prompt is &lt;code&gt;*Main&lt;/code&gt;, which indicates that we are typing expressions in the context of the top-level of the &lt;code&gt;Main&lt;/code&gt; module. Everything that is in scope at the top-level in the module &lt;code&gt;Main&lt;/code&gt; we just loaded is also in scope at the prompt (probably including &lt;code&gt;Prelude&lt;/code&gt;, as long as &lt;code&gt;Main&lt;/code&gt; doesn&amp;rsquo;t explicitly hide it).</source>
          <target state="translated">新しいプロンプトは &lt;code&gt;*Main&lt;/code&gt; &lt;code&gt;Main&lt;/code&gt; です。これは、メインモジュールのトップレベルのコンテキストで式を入力していることを示します。ロードしたばかりのモジュール &lt;code&gt;Main&lt;/code&gt; のトップレベルのスコープにあるすべてのものは、プロンプトでもスコープにあります（ &lt;code&gt;Main&lt;/code&gt; が明示的に非表示にしない限り、おそらく &lt;code&gt;Prelude&lt;/code&gt; を含みます）。</target>
        </trans-unit>
        <trans-unit id="53f5b2e47a4b9ae427e19c9dbf1f618026a18fe1" translate="yes" xml:space="preserve">
          <source>The new thread inherits the &lt;em&gt;masked&lt;/em&gt; state of the parent (see &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">新しいスレッドは、親の&lt;em&gt;マスクされた&lt;/em&gt;状態を継承します（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; を参照）。</target>
        </trans-unit>
        <trans-unit id="b2c4fdfc801aad37935508fdd942cd092c0f04c2" translate="yes" xml:space="preserve">
          <source>The new thread inherits the &lt;em&gt;masked&lt;/em&gt; state of the parent (see &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">The new thread inherits the &lt;em&gt;masked&lt;/em&gt; state of the parent (see &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8d318f738e712b9a7c49deddbf087cc0b4b1ac85" translate="yes" xml:space="preserve">
          <source>The new thread inherits the &lt;em&gt;masked&lt;/em&gt; state of the parent (see &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">新しいスレッドは、親の&lt;em&gt;マスクされた&lt;/em&gt;状態を継承します（ &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; を参照）。</target>
        </trans-unit>
        <trans-unit id="f49ffa4a3cda912cfa43024b34a8d1f99a2d6f8d" translate="yes" xml:space="preserve">
          <source>The new thread will be a lightweight, &lt;em&gt;unbound&lt;/em&gt; thread. Foreign calls made by this thread are not guaranteed to be made by any particular OS thread; if you need foreign calls to be made by a particular OS thread, then use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">新しいスレッドは軽量の&lt;em&gt;バインドされていない&lt;/em&gt;スレッドになります。このスレッドによって行われる外部呼び出しは、特定のOSスレッドによって行われるとは限りません。特定のOSスレッドで外部呼び出しを行う必要がある場合は、代わりに &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="8fbb6e9f1289a8fa68ffdbef26f7af463547a02e" translate="yes" xml:space="preserve">
          <source>The new thread will be a lightweight, &lt;em&gt;unbound&lt;/em&gt; thread. Foreign calls made by this thread are not guaranteed to be made by any particular OS thread; if you need foreign calls to be made by a particular OS thread, then use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">The new thread will be a lightweight, &lt;em&gt;unbound&lt;/em&gt; thread. Foreign calls made by this thread are not guaranteed to be made by any particular OS thread; if you need foreign calls to be made by a particular OS thread, then use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead.</target>
        </trans-unit>
        <trans-unit id="d79262bf7af143e8fe77bde10bec763c9abf1332" translate="yes" xml:space="preserve">
          <source>The new thread will be a lightweight, &lt;em&gt;unbound&lt;/em&gt; thread. Foreign calls made by this thread are not guaranteed to be made by any particular OS thread; if you need foreign calls to be made by a particular OS thread, then use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">新しいスレッドは軽量の&lt;em&gt;バインドされていない&lt;/em&gt;スレッドになります。このスレッドによって行われる外部呼び出しは、特定のOSスレッドによって行われるとは限りません。特定のOSスレッドで外部呼び出しを行う必要がある場合は、代わりに &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="5b442e2a2732ad1aadc2d2333cde267e32b0b385" translate="yes" xml:space="preserve">
          <source>The newly created thread has an exception handler that discards the exceptions &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt;, and passes all other exceptions to the uncaught exception handler.</source>
          <target state="translated">The newly created thread has an exception handler that discards the exceptions &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; , and passes all other exceptions to the uncaught exception handler.</target>
        </trans-unit>
        <trans-unit id="bc43222cc5f22f48444dca9a33addd84a41162b9" translate="yes" xml:space="preserve">
          <source>The newly created thread has an exception handler that discards the exceptions &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt;, and passes all other exceptions to the uncaught exception handler.</source>
          <target state="translated">新しく作成されたスレッドには、例外 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; を破棄する例外ハンドラーがあり、他のすべての例外をキャッチされなかった例外ハンドラーに渡します。</target>
        </trans-unit>
        <trans-unit id="06467093ec13b99be21e49f501d476baef2995e0" translate="yes" xml:space="preserve">
          <source>The next Sunday strictly after a given day.</source>
          <target state="translated">与えられた日の後の次の日曜日は厳密には</target>
        </trans-unit>
        <trans-unit id="00554018ca7c76296e2e972dcf6e4032903f571e" translate="yes" xml:space="preserve">
          <source>The non-copying implementation is supported between certain pairs of array types only; one constraint is that the array types must have identical representations. In GHC, The following pairs of array types have a non-copying O(1) implementation of &lt;code&gt;&lt;a href=&quot;data-array-unsafe#v:unsafeFreeze&quot;&gt;unsafeFreeze&lt;/a&gt;&lt;/code&gt;. Because the optimised versions are enabled by specialisations, you will need to compile with optimisation (-O) to get them.</source>
          <target state="translated">非コピー実装は、配列タイプの特定のペア間でのみサポートされています。1つの制約は、配列の型が同じ表現でなければならないということです。GHCでは、次の配列型のペアに &lt;code&gt;&lt;a href=&quot;data-array-unsafe#v:unsafeFreeze&quot;&gt;unsafeFreeze&lt;/a&gt;&lt;/code&gt; の非コピーO（1）実装があります。最適化されたバージョンは特殊化によって有効になるため、最適化（-O）でコンパイルして取得する必要があります。</target>
        </trans-unit>
        <trans-unit id="a17dd35e1a788245fc2675b10d198269467558f5" translate="yes" xml:space="preserve">
          <source>The non-copying implementation is supported between certain pairs of array types only; one constraint is that the array types must have identical representations. In GHC, The following pairs of array types have a non-copying O(1) implementation of &lt;code&gt;&lt;a href=&quot;data-array-unsafe#v:unsafeThaw&quot;&gt;unsafeThaw&lt;/a&gt;&lt;/code&gt;. Because the optimised versions are enabled by specialisations, you will need to compile with optimisation (-O) to get them.</source>
          <target state="translated">非コピー実装は、配列タイプの特定のペア間でのみサポートされています。1つの制約は、配列の型が同じ表現でなければならないということです。GHCでは、次の配列型のペアに &lt;code&gt;&lt;a href=&quot;data-array-unsafe#v:unsafeThaw&quot;&gt;unsafeThaw&lt;/a&gt;&lt;/code&gt; の非コピーO（1）実装があります。最適化されたバージョンは特殊化によって有効になるため、最適化（-O）でコンパイルして取得する必要があります。</target>
        </trans-unit>
        <trans-unit id="25b29270e30e332a1316f0fc53e01b19e55849c5" translate="yes" xml:space="preserve">
          <source>The non-moving heap census events (enabled with the &lt;code&gt;+RTS -ln&lt;/code&gt; event-set) are intended to provide insight into fragmentation of the non-moving heap.</source>
          <target state="translated">The non-moving heap census events (enabled with the &lt;code&gt;+RTS -ln&lt;/code&gt; event-set) are intended to provide insight into fragmentation of the non-moving heap.</target>
        </trans-unit>
        <trans-unit id="4065cd5ff81b5cc613fc73a9059855b99c8be0cc" translate="yes" xml:space="preserve">
          <source>The non-termination is reported like this:</source>
          <target state="translated">非解約はこのように報告されています。</target>
        </trans-unit>
        <trans-unit id="7d6d02244fcddd7ae83db06c2e068263589664bf" translate="yes" xml:space="preserve">
          <source>The nonnegative magnitude of a complex number.</source>
          <target state="translated">複素数の非負の大きさ。</target>
        </trans-unit>
        <trans-unit id="2ff00bf6c0c197af17057ab64282dcdcec685b3e" translate="yes" xml:space="preserve">
          <source>The normal &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; function with right associativity instead of left.</source>
          <target state="translated">通常の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 関数は、左ではなく右の関連性を備えています。</target>
        </trans-unit>
        <trans-unit id="2a0c86a118296186481a0035095ac01fc1c9459b" translate="yes" xml:space="preserve">
          <source>The normal &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; function with right associativity instead of left.</source>
          <target state="translated">左ではなく右の結合性を持つ通常の &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 関数。</target>
        </trans-unit>
        <trans-unit id="e8ea10bfd840fdd3f1f9ba01648e552adcfe5390" translate="yes" xml:space="preserve">
          <source>The normal rule in Haskell is that your program must supply a &lt;code&gt;main&lt;/code&gt; function in module &lt;code&gt;Main&lt;/code&gt;. When testing, it is often convenient to change which function is the &amp;ldquo;main&amp;rdquo; one, and the &lt;code&gt;-main-is&lt;/code&gt; flag allows you to do so. The ⟨thing⟩ can be one of:</source>
          <target state="translated">Haskellの通常のルールは、プログラムがモジュール &lt;code&gt;Main&lt;/code&gt; で &lt;code&gt;main&lt;/code&gt; 関数を提供する必要があるということです。テストするとき、どの関数が「メイン」関数であるかを変更すると便利なことがよくあります。 &lt;code&gt;-main-is&lt;/code&gt; フラグを使用すると、そうすることができます。「もの」は次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="8565c7cc336e9d2bc02ea4c1cab0de9e55beac01" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;a -&amp;gt; b&lt;/code&gt; used here between the &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;where&lt;/code&gt; symbols &amp;mdash; not to be confused with a function type &amp;mdash; indicates that the &lt;code&gt;a&lt;/code&gt; parameter uniquely determines the &lt;code&gt;b&lt;/code&gt; parameter, and might be read as &amp;ldquo;&lt;code&gt;a&lt;/code&gt; determines &lt;code&gt;b&lt;/code&gt;.&amp;rdquo; Thus &lt;code&gt;D&lt;/code&gt; is not just a relation, but actually a (partial) function. Similarly, from the two dependencies that are included in the definition of &lt;code&gt;E&lt;/code&gt;, we can see that &lt;code&gt;E&lt;/code&gt; represents a (partial) one-to-one mapping between types.</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; の間でここで使用されている表記a- &lt;code&gt;a -&amp;gt; b&lt;/code&gt; また &lt;code&gt;where&lt;/code&gt; 記号（関数タイプと混同しないでください）は、 &lt;code&gt;b&lt;/code&gt; パラメーターがbパラメーターを一意に決定 &lt;code&gt;a&lt;/code&gt; ことを示し、「 &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;b&lt;/code&gt; を決定する」と解釈される場合があります。したがって、 &lt;code&gt;D&lt;/code&gt; は単なる関係ではなく、実際には（部分的な）関数です。同様に、 &lt;code&gt;E&lt;/code&gt; の定義に含まれている2つの依存関係から、 &lt;code&gt;E&lt;/code&gt; がタイプ間の（部分的な）1対1のマッピングを表していることがわかります。</target>
        </trans-unit>
        <trans-unit id="65e0f3cb1cdca573b0a31816dea29f6e08943a92" translate="yes" xml:space="preserve">
          <source>The null address.</source>
          <target state="translated">ヌルアドレスです。</target>
        </trans-unit>
        <trans-unit id="6f24da5886263ef92cea0da538817aecc2d6f529" translate="yes" xml:space="preserve">
          <source>The number of bytes that must be consumed</source>
          <target state="translated">消費するバイト数</target>
        </trans-unit>
        <trans-unit id="ca0f126d79cabf7e2c5e95757d200444f569118d" translate="yes" xml:space="preserve">
          <source>The number of days in a given month according to the proleptic Gregorian calendar. First argument is year, second is month.</source>
          <target state="translated">プロレプティック・グレゴリオ暦による月の日数。第一引数は年、第二引数は月。</target>
        </trans-unit>
        <trans-unit id="9391d34aef57b18832247680a9bb961c2cb802e0" translate="yes" xml:space="preserve">
          <source>The number of days in a given month according to the proleptic Julian calendar. First argument is year, second is month.</source>
          <target state="translated">プロレプティック・ユリウス暦による月の日数。第一引数は年、第二引数は月。</target>
        </trans-unit>
        <trans-unit id="0419481cf5884d86b99e61181cced8b51e95c26d" translate="yes" xml:space="preserve">
          <source>The number of elements in the array.</source>
          <target state="translated">配列の要素数。</target>
        </trans-unit>
        <trans-unit id="43d9d47c41193f72155e7e7c1d8d822460113e6b" translate="yes" xml:space="preserve">
          <source>The number of minutes offset from UTC. Positive means local time will be later in the day than UTC.</source>
          <target state="translated">UTCからのオフセット分数。正の値は、現地時間がUTCよりも遅くなることを意味します。</target>
        </trans-unit>
        <trans-unit id="69b816c0ec0e62c60a64cad0412b6307fc8984cc" translate="yes" xml:space="preserve">
          <source>The number of times this particular point in the call tree was entered.</source>
          <target state="translated">コールツリーのこの特定のポイントが入力された回数。</target>
        </trans-unit>
        <trans-unit id="d0ef27c2e92d99ce3709f3c8cd8149198afbb479" translate="yes" xml:space="preserve">
          <source>The numeric branch for this version. This reflects the fact that most software versions are tree-structured; there is a main trunk which is tagged with versions at various points (1,2,3...), and the first branch off the trunk after version 3 is 3.1, the second branch off the trunk after version 3 is 3.2, and so on. The tree can be branched arbitrarily, just by adding more digits.</source>
          <target state="translated">このバージョンの数字のブランチ。これは、ほとんどのソフトウェアのバージョンがツリー構造になっているという事実を反映しています。ツリーは桁数を増やすだけで、任意に分岐させることができます。</target>
        </trans-unit>
        <trans-unit id="4f31d4347cd14b9ff9a95c759d4f40a65f6f736b" translate="yes" xml:space="preserve">
          <source>The object file, which normally ends in a &lt;code&gt;.o&lt;/code&gt; suffix, contains the compiled code for the module.</source>
          <target state="translated">通常、 &lt;code&gt;.o&lt;/code&gt; サフィックスで終わるオブジェクトファイルには、モジュールのコンパイル済みコードが含まれています。</target>
        </trans-unit>
        <trans-unit id="805b61067737cd38cfcd7f8a184e0af8d81d4642" translate="yes" xml:space="preserve">
          <source>The object files, &lt;code&gt;Foo.o&lt;/code&gt;, &lt;code&gt;Bar.o&lt;/code&gt;, and &lt;code&gt;Bumble.o&lt;/code&gt; would be put into a subdirectory named after the architecture of the executing machine (&lt;code&gt;x86&lt;/code&gt;, &lt;code&gt;mips&lt;/code&gt;, etc).</source>
          <target state="translated">オブジェクトファイル、 &lt;code&gt;Foo.o&lt;/code&gt; 、 &lt;code&gt;Bar.o&lt;/code&gt; 、および &lt;code&gt;Bumble.o&lt;/code&gt; は、実行マシン（のアーキテクチャにちなんで名付けられたサブディレクトリに置かれる &lt;code&gt;x86&lt;/code&gt; 、 &lt;code&gt;mips&lt;/code&gt; 、など）。</target>
        </trans-unit>
        <trans-unit id="75f3688b610f29c49c2454cfe45bd0a8cb6e12b0" translate="yes" xml:space="preserve">
          <source>The object version of the library used by GHCi.</source>
          <target state="translated">GHCiが使用しているライブラリのオブジェクト版です。</target>
        </trans-unit>
        <trans-unit id="403a24f2ec97b5832764d3f75bef5030d88d4c2e" translate="yes" xml:space="preserve">
          <source>The obsolete language option &lt;a href=&quot;#extension-Rank2Types&quot;&gt;&lt;code&gt;Rank2Types&lt;/code&gt;&lt;/a&gt; is a synonym for &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt;. They used to specify finer distinctions that GHC no longer makes.</source>
          <target state="translated">The obsolete language option &lt;a href=&quot;#extension-Rank2Types&quot;&gt; &lt;code&gt;Rank2Types&lt;/code&gt; &lt;/a&gt; is a synonym for &lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt;. They used to specify finer distinctions that GHC no longer makes.</target>
        </trans-unit>
        <trans-unit id="838855ecfc9a22622038d43b1adcde548a91e7ce" translate="yes" xml:space="preserve">
          <source>The obsolete language options &lt;code&gt;PolymorphicComponents&lt;/code&gt; and &lt;a href=&quot;#extension-Rank2Types&quot;&gt;&lt;code&gt;Rank2Types&lt;/code&gt;&lt;/a&gt; are synonyms for &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt;. They used to specify finer distinctions that GHC no longer makes. (They should really elicit a deprecation warning, but they don&amp;rsquo;t, purely to avoid the need to library authors to change their old flags specifications.)</source>
          <target state="translated">廃止された言語オプションの &lt;code&gt;PolymorphicComponents&lt;/code&gt; と&lt;a href=&quot;#extension-Rank2Types&quot;&gt; &lt;code&gt;Rank2Types&lt;/code&gt; は&lt;/a&gt;同義語です&lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt;。彼らはかつてGHCがもはや行わないより細かい区別を指定していました。（非推奨の警告を実際に引き出す必要がありますが、ライブラリの作成者が古いフラグの仕様を変更する必要を完全に回避するために、警告は引き出されません。）</target>
        </trans-unit>
        <trans-unit id="de0046d717353b2193c161124220232a1d8fd82e" translate="yes" xml:space="preserve">
          <source>The old, shadowed, version of &lt;code&gt;T&lt;/code&gt; is displayed as &lt;code&gt;main::Interactive.T&lt;/code&gt; by GHCi in an attempt to distinguish it from the new &lt;code&gt;T&lt;/code&gt;, which is displayed as simply &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">古い、影付きのバージョンの &lt;code&gt;T&lt;/code&gt; は、単に &lt;code&gt;T&lt;/code&gt; として表示される新しい &lt;code&gt;T&lt;/code&gt; と区別するために、GHCiによって &lt;code&gt;main::Interactive.T&lt;/code&gt; として表示されます。</target>
        </trans-unit>
        <trans-unit id="c88cd7b17fb54593c249863957ba4ed3bfbb9b4a" translate="yes" xml:space="preserve">
          <source>The one exception to this rule is &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, since deriving an instance via &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; simply generates an empty instance declaration, which does not require the use of any constructors. See the &lt;a href=&quot;#derive-any-class&quot;&gt;deriving any class&lt;/a&gt; section for more details.</source>
          <target state="translated">このルールの唯一の例外はある&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; を&lt;/a&gt;介してインスタンスを導出するため&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;単に任意のコンストラクタの使用を必要としない空のインスタンス宣言を生成します。詳細については、「&lt;a href=&quot;#derive-any-class&quot;&gt;クラス&lt;/a&gt;の派生」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="0268dcd59bf97b0cda9fb2201599f6e5dff9ca67" translate="yes" xml:space="preserve">
          <source>The only IO operations allowed in the IO action passed to &lt;code&gt;unsafeLocalState&lt;/code&gt; are (a) local allocation (&lt;code&gt;alloca&lt;/code&gt;, &lt;code&gt;allocaBytes&lt;/code&gt; and derived operations such as &lt;code&gt;withArray&lt;/code&gt; and &lt;code&gt;withCString&lt;/code&gt;), and (b) pointer operations (&lt;code&gt;Foreign.Storable&lt;/code&gt; and &lt;code&gt;Foreign.Ptr&lt;/code&gt;) on the pointers to local storage, and (c) foreign functions whose only observable effect is to read and/or write the locally allocated memory. Passing an IO operation that does not obey these rules results in undefined behaviour.</source>
          <target state="translated">IOアクションで許可のみIOオペレーションは渡さ &lt;code&gt;unsafeLocalState&lt;/code&gt; ある（）は、ローカルの割り当てを（ &lt;code&gt;alloca&lt;/code&gt; を、 &lt;code&gt;allocaBytes&lt;/code&gt; そのように誘導された操作 &lt;code&gt;withArray&lt;/code&gt; と &lt;code&gt;withCString&lt;/code&gt; ）、および（b）ポインタ操作（ &lt;code&gt;Foreign.Storable&lt;/code&gt; と &lt;code&gt;Foreign.Ptr&lt;/code&gt; ポインタ上の）ローカル記憶域、および（c）観察可能な効果のみがローカルに割り当てられたメモリの読み取りおよび/または書き込みである外部関数。これらのルールに従わないIO操作を渡すと、未定義の動作が発生します。</target>
        </trans-unit>
        <trans-unit id="e9a1db195c814668311158eb1709c1054c413cfc" translate="yes" xml:space="preserve">
          <source>The only difference between the two groups is that in the second group &lt;code&gt;len_acc&lt;/code&gt; is given a type signature. In the former case, &lt;code&gt;len_acc1&lt;/code&gt; is monomorphic in its own right-hand side, so the implicit parameter &lt;code&gt;?acc&lt;/code&gt; is not passed to the recursive call. In the latter case, because &lt;code&gt;len_acc2&lt;/code&gt; has a type signature, the recursive call is made to the &lt;em&gt;polymorphic&lt;/em&gt; version, which takes &lt;code&gt;?acc&lt;/code&gt; as an implicit parameter. So we get the following results in GHCi:</source>
          <target state="translated">2つのグループの唯一の違いは、2番目のグループでは &lt;code&gt;len_acc&lt;/code&gt; に型シグネチャが与えられていることです。前者の場合、 &lt;code&gt;len_acc1&lt;/code&gt; はそれ自体右側が単相であるため、暗黙的なパラメーター &lt;code&gt;?acc&lt;/code&gt; は再帰呼び出しに渡されません。後者の場合、 &lt;code&gt;len_acc2&lt;/code&gt; には型シグニチャーがあるため、 &lt;code&gt;?acc&lt;/code&gt; を暗黙的なパラメーターとして取る&lt;em&gt;多態性&lt;/em&gt;バージョンに対して再帰呼び出しが行われます。したがって、GHCiで次の結果が得られます。</target>
        </trans-unit>
        <trans-unit id="9990b4df29d87745ac325e522dbe79968c7bc35e" translate="yes" xml:space="preserve">
          <source>The only effect which is intentionally not incorporated in the &lt;code&gt;release&lt;/code&gt; action is the effect of throwing an error. In that case, the error must be re-thrown. One subtlety which is easy to miss is that in the case in which &lt;code&gt;use&lt;/code&gt; and &lt;code&gt;release&lt;/code&gt; both throw an error, the error from &lt;code&gt;release&lt;/code&gt; should take priority. Here is an implementation for &lt;code&gt;ExceptT&lt;/code&gt; which demonstrates how to do this.</source>
          <target state="translated">&lt;code&gt;release&lt;/code&gt; アクションに意図的に組み込まれていない唯一の効果は、エラーをスローする効果です。その場合、エラーを再スローする必要があります。ミスに簡単です一つ微妙にした場合にはということです &lt;code&gt;use&lt;/code&gt; し、 &lt;code&gt;release&lt;/code&gt; の両方がエラーをスローし、エラーからの &lt;code&gt;release&lt;/code&gt; 優先順位を取る必要があります。これを行う方法を示す &lt;code&gt;ExceptT&lt;/code&gt; の実装を次に示します。</target>
        </trans-unit>
        <trans-unit id="ac6054b6f6b6ca4251de8b08424a09d5460a4c6c" translate="yes" xml:space="preserve">
          <source>The only permissible implementation of such a signature is a module which reexports precisely the same entity:</source>
          <target state="translated">このようなシグネチャの唯一の許容される実装は、正確に同じエンティティを再エキスポートするモジュールです。</target>
        </trans-unit>
        <trans-unit id="99f45ecbd145f7b28b73197352d367ab369881f7" translate="yes" xml:space="preserve">
          <source>The only point where the &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; parser should be called explicitly is the start of the main parser in order to skip any leading white space.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; パーサーを明示的に呼び出す必要がある唯一のポイントは、先頭の空白をスキップするためのメインパーサーの開始です。</target>
        </trans-unit>
        <trans-unit id="0d17721b8d0f0086bd5ec1ab600c24a5629c442f" translate="yes" xml:space="preserve">
          <source>The only point where the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; parser should be called explicitly is the start of the main parser in order to skip any leading white space.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; パーサーを明示的に呼び出す必要がある唯一のポイントは、先頭の空白をスキップするためのメインパーサーの開始です。</target>
        </trans-unit>
        <trans-unit id="bb632a82c8eebfabcb7f6f7ed3c1cccfca2ac4bd" translate="yes" xml:space="preserve">
          <source>The only predefined instance is the obvious one that does nothing:</source>
          <target state="translated">定義済みのインスタンスだけが何もしない明らかなものです。</target>
        </trans-unit>
        <trans-unit id="b74e3ab63478dc88412921dd78460cac468112a4" translate="yes" xml:space="preserve">
          <source>The only predefined instance is the obvious one to make strings work as usual:</source>
          <target state="translated">文字列を通常通りに動作させるためには、事前に定義されたインスタンスしかないのは明白です。</target>
        </trans-unit>
        <trans-unit id="225b573fdeb899c7024573c1625d7b7bcfcbe5a0" translate="yes" xml:space="preserve">
          <source>The only problem comes when a module contains an instance declaration and GHC has no other reason for visiting the module. Example:</source>
          <target state="translated">唯一の問題は、モジュールにインスタンス宣言が含まれており、GHCがモジュールを訪問する他の理由がない場合に発生します。例を挙げてみます。</target>
        </trans-unit>
        <trans-unit id="a77af1dde4bfd3f080f8a163fea93aea7a444506" translate="yes" xml:space="preserve">
          <source>The only thing left to do now is to define a &amp;ldquo;front-end&amp;rdquo; class, which is exposed to the user:</source>
          <target state="translated">あとは、ユーザーに公開される「フロントエンド」クラスを定義するだけです。</target>
        </trans-unit>
        <trans-unit id="4957a1ff0c6373e596985963e968abbd42fa8755" translate="yes" xml:space="preserve">
          <source>The only use for the &lt;code&gt;Unused&lt;/code&gt; constructor was to force the correct kind for the type variable &lt;code&gt;cxt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Unused&lt;/code&gt; コンストラクターの唯一の用途は、型変数 &lt;code&gt;cxt&lt;/code&gt; の正しい種類を強制することでした。</target>
        </trans-unit>
        <trans-unit id="69d170600f85b05b40716ccd35bcd4f06954e076" translate="yes" xml:space="preserve">
          <source>The operating system on which the program is running.</source>
          <target state="translated">プログラムが実行されているオペレーティングシステム。</target>
        </trans-unit>
        <trans-unit id="34731bb0d80073cd13a1f4f0433438861e603be9" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is either a directory or a symbolic link to a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">操作 &lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; は返す &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; の引数のファイルが存在し、ディレクトリまたはディレクトリへのシンボリックリンク、およびいずれかの場合 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; そうでありません。</target>
        </trans-unit>
        <trans-unit id="8332f5125e87dd009d7bdddc38f1192739ced75f" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is either a directory or a symbolic link to a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is either a directory or a symbolic link to a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</target>
        </trans-unit>
        <trans-unit id="abe2bcec36d3cfe98f8b3b771acf0e3cbe03a0c1" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is not a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">オペレーション &lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; は、引数ファイルが存在し、ディレクトリでない場合は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; を返し、そうでない場合は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="9a53f211f831c07b35860c179c1095eecd331bca" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is not a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is not a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</target>
        </trans-unit>
        <trans-unit id="c1014ad70a94098ad03145dbaaa5e10a46dcfeb3" translate="yes" xml:space="preserve">
          <source>The operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:setCurrentDirectory&quot;&gt;setCurrentDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">操作は、 &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;system-directory#v:setCurrentDirectory&quot;&gt;setCurrentDirectory&lt;/a&gt;&lt;/code&gt; と同じ例外で失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d1a77a11f3e83e3fc7cb291c25444400219866a2" translate="yes" xml:space="preserve">
          <source>The operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; と同じ例外で操作が失敗する場合があります。</target>
        </trans-unit>
        <trans-unit id="ec1e5f517351d98a1317840aae7a3f6d64c13a50" translate="yes" xml:space="preserve">
          <source>The operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:listDirectory&quot;&gt;listDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">操作は、 &lt;code&gt;&lt;a href=&quot;system-directory#v:listDirectory&quot;&gt;listDirectory&lt;/a&gt;&lt;/code&gt; と同じ例外で失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="b0c5c7f2e239edbf825df9ce2a38beea0ba143ba" translate="yes" xml:space="preserve">
          <source>The operation may fail with:</source>
          <target state="translated">で操作に失敗することがあります。</target>
        </trans-unit>
        <trans-unit id="8c066a4952b72a09ccd45c4c56e69a302b836518" translate="yes" xml:space="preserve">
          <source>The operations on strings are similar.</source>
          <target state="translated">文字列に対する操作は似ています。</target>
        </trans-unit>
        <trans-unit id="d278879460916dc24a386ba29fcbbca12720c53d" translate="yes" xml:space="preserve">
          <source>The operator section is treated like function application of an undefined function, while the lambda form is in WHNF that contains an application of an undefined function.</source>
          <target state="translated">演算子部分は未定義関数の関数適用のように扱われ、ラムダ形式は未定義関数の適用を含むWHNFにある。</target>
        </trans-unit>
        <trans-unit id="90d2b833a3ae58e36d089e36990a3439898a2cf2" translate="yes" xml:space="preserve">
          <source>The optimisation also works for GADTs which bind dictionaries. If we statically know which class dictionary we need then we will solve it directly rather than indirectly using the one passed in at run time.</source>
          <target state="translated">この最適化は、辞書をバインドするGADTに対しても動作します。どのクラスの辞書が必要かを静的に知っていれば、実行時に渡された辞書を間接的に使うのではなく、直接解くことができます。</target>
        </trans-unit>
        <trans-unit id="560d5fd1f4bc4b620b6067d2806fe1c21df3d911" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--C&quot;&gt;&lt;code&gt;-C&lt;/code&gt;&lt;/a&gt; is only available when GHC is built in unregisterised mode. See &lt;a href=&quot;codegens#unreg&quot;&gt;Unregisterised compilation&lt;/a&gt; for more details.</source>
          <target state="translated">オプション&lt;a href=&quot;#ghc-flag--C&quot;&gt; &lt;code&gt;-C&lt;/code&gt; &lt;/a&gt;は、GHCが未登録モードでビルドされている場合にのみ使用できます。詳細については、&lt;a href=&quot;codegens#unreg&quot;&gt;未登録コンパイル&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="00a060100430958f91df26ba43eebf619fa4ae0a" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--E&quot;&gt;&lt;code&gt;-E&lt;/code&gt;&lt;/a&gt; runs just the pre-processing passes of the compiler, dumping the result in a file.</source>
          <target state="translated">オプション&lt;a href=&quot;#ghc-flag--E&quot;&gt; &lt;code&gt;-E&lt;/code&gt; &lt;/a&gt;は、コンパイラーの前処理パスのみを実行し、結果をファイルにダンプします。</target>
        </trans-unit>
        <trans-unit id="0964a10be81d642da333713be7237fbcfb02fa70" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; warns about places where a pattern-match might fail at runtime. The function &lt;code&gt;g&lt;/code&gt; below will fail when applied to non-empty lists, so the compiler will emit a warning about this when &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">オプション&lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt;は、実行時にパターンマッチが失敗する可能性がある場所について警告します。空でないリストに適用すると、以下の関数 &lt;code&gt;g&lt;/code&gt; が失敗するため、&lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt;が有効になっている場合、コンパイラーはこれについて警告を出します。</target>
        </trans-unit>
        <trans-unit id="ccd337cf3edfdd4e01711e8e069283d6a4d19280" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt;&lt;code&gt;-Wpartial-fields&lt;/code&gt;&lt;/a&gt; warns about record fields that could fail when accessed via a lacking constructor. The function &lt;code&gt;f&lt;/code&gt; below will fail when applied to &lt;code&gt;Bar&lt;/code&gt;, so the compiler will emit a warning at its definition when &lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt;&lt;code&gt;-Wpartial-fields&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">オプション&lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt; &lt;code&gt;-Wpartial-fields&lt;/code&gt; は&lt;/a&gt;、不足しているコンストラクターを介してアクセスすると失敗する可能性があるレコードフィールドについて警告します。以下の関数 &lt;code&gt;f&lt;/code&gt; は、 &lt;code&gt;Bar&lt;/code&gt; に適用されると失敗するため、&lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt; &lt;code&gt;-Wpartial-fields&lt;/code&gt; &lt;/a&gt;が有効になっている場合、コンパイラーはその定義時に警告を発します。</target>
        </trans-unit>
        <trans-unit id="b08d390b9c785654fe869c3d6ad222e20f07d378" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--Wunused-packages&quot;&gt;&lt;code&gt;-Wunused-packages&lt;/code&gt;&lt;/a&gt; warns about packages, specified on command line via &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; or &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt;, but were not loaded during compication. Usually it means that you have an unused dependency.</source>
          <target state="translated">The option &lt;a href=&quot;#ghc-flag--Wunused-packages&quot;&gt; &lt;code&gt;-Wunused-packages&lt;/code&gt; &lt;/a&gt; warns about packages, specified on command line via &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; or &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; , but were not loaded during compication. Usually it means that you have an unused dependency.</target>
        </trans-unit>
        <trans-unit id="f50424482bd3ed523aa1fb5ace8902d19e5c6938" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt;&lt;code&gt;-feager-blackholing&lt;/code&gt;&lt;/a&gt; causes each thunk to be blackholed as soon as evaluation begins. The default is &amp;ldquo;lazy blackholing&amp;rdquo;, whereby thunks are only marked as being under evaluation when a thread is paused for some reason. Lazy blackholing is typically more efficient (by 1-2% or so), because most thunks don&amp;rsquo;t need to be blackholed. However, eager blackholing can avoid more repeated computation in a parallel program, and this often turns out to be important for parallelism.</source>
          <target state="translated">オプション&lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt; &lt;code&gt;-feager-blackholing&lt;/code&gt; &lt;/a&gt;を指定すると、評価が開始するとすぐに各サンクがブラックホール化されます。デフォルトは「レイジーブラックホール」で、サンクは、何らかの理由でスレッドが一時停止したときにのみ評価中としてマークされます。ほとんどのサンクをブラックホール化する必要がないため、通常、レイジーブラックホールはより効率的です（1〜2％程度）。ただし、熱心なブラックホール化は並列プログラムでの計算の繰り返しを避けることができ、これはしばしば並列処理にとって重要であることが判明します。</target>
        </trans-unit>
        <trans-unit id="dc3e0ec3b48b83ee97a18d535f56695193e4148b" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;-XExtendedDefaultRules&lt;/code&gt; is enabled, in order to apply special defaulting rules to expressions typed at the prompt (see &lt;a href=&quot;#extended-default-rules&quot;&gt;Type defaulting in GHCi&lt;/a&gt;).</source>
          <target state="translated">プロンプトで入力された式に特別なデフォルトルールを適用するために、オプション &lt;code&gt;-XExtendedDefaultRules&lt;/code&gt; が有効になっています（&lt;a href=&quot;#extended-default-rules&quot;&gt;GHCiでのデフォルトのタイプを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="a172fb76c6f9f556ecc7ed1e53e547b76840fe25" translate="yes" xml:space="preserve">
          <source>The option descriptions (see &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:OptDescr&quot;&gt;OptDescr&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">オプションの説明（ &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:OptDescr&quot;&gt;OptDescr&lt;/a&gt;&lt;/code&gt; を参照）</target>
        </trans-unit>
        <trans-unit id="90c51e481e3ef85be23988058a9d8ffbfe523dad" translate="yes" xml:space="preserve">
          <source>The order requirements (see &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:ArgOrder&quot;&gt;ArgOrder&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">注文要件（ &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:ArgOrder&quot;&gt;ArgOrder&lt;/a&gt;&lt;/code&gt; を参照）</target>
        </trans-unit>
        <trans-unit id="a48428e93cda469aec76c5bbf3a45a3d1d4c0eca" translate="yes" xml:space="preserve">
          <source>The original discussion is archived here: &lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2010-January/072379.html&quot;&gt;could we get a Data instance for Data.Text.Text?&lt;/a&gt;</source>
          <target state="translated">元のディスカッションはここにアーカイブされてい&lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2010-January/072379.html&quot;&gt;ます。Data.Text.TextのDataインスタンスを取得できますか？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3f3ab7a20ae1158bd257f4656d1c486a0bcb46f" translate="yes" xml:space="preserve">
          <source>The original program is just plain wrong. Here&amp;rsquo;s another sort of error</source>
          <target state="translated">元のプログラムは明らかに間違っています。ここに別の種類のエラーがあります</target>
        </trans-unit>
        <trans-unit id="6a36573f2a76f839bf0ccfbddc9a2d1af4b0c55c" translate="yes" xml:space="preserve">
          <source>The original set of data constructors for &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; の元のデータコンストラクターのセット</target>
        </trans-unit>
        <trans-unit id="026c8d8f9302a24eb8eb077091c8693319be6e8f" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; operation, &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;, has a suitable type for lifting using &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:mapStateT&quot;&gt;mapStateT&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">もう1つの &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; 操作である &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; には、 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:mapStateT&quot;&gt;mapStateT&lt;/a&gt;&lt;/code&gt; を使用して持ち上げるのに適したタイプがあります。</target>
        </trans-unit>
        <trans-unit id="1421877ede54d6e7f4dbd61b5345c2c064b769f8" translate="yes" xml:space="preserve">
          <source>The other combinators have sensible default definitions, which may be overridden for efficiency.</source>
          <target state="translated">他のコンビネータは、効率化のためにオーバーライドされても良いような、賢明なデフォルト定義を持っています。</target>
        </trans-unit>
        <trans-unit id="ab98415919b10ecc3cc9f0ce7f01d77f22a18942" translate="yes" xml:space="preserve">
          <source>The other methods have the following default definitions, which may be overridden with equivalent specialized implementations:</source>
          <target state="translated">他のメソッドは以下のデフォルト定義を持っており、同等の特殊な実装で上書きすることができます。</target>
        </trans-unit>
        <trans-unit id="1ac58fe3cbf02ef4899da15f0408247b3325cf81" translate="yes" xml:space="preserve">
          <source>The other place where role annotations may be necessary are in &lt;code&gt;hs-boot&lt;/code&gt; files (&lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;), where the right-hand sides of definitions can be omitted. As usual, the types/classes declared in an &lt;code&gt;hs-boot&lt;/code&gt; file must match up with the definitions in the &lt;code&gt;hs&lt;/code&gt; file, including down to the roles. The default role for datatypes is representational in &lt;code&gt;hs-boot&lt;/code&gt; files, corresponding to the common use case.</source>
          <target state="translated">ロールの注釈が必要になる可能性があるもう1つの場所は &lt;code&gt;hs-boot&lt;/code&gt; です。ファイル（&lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;相互再帰モジュールをコンパイルする方法&lt;/a&gt;）です。ここでは、定義の右側を省略できます。いつものように、 &lt;code&gt;hs-boot&lt;/code&gt; ファイルで宣言されたタイプ/クラスは、ロールまで含めて、 &lt;code&gt;hs&lt;/code&gt; ファイルの定義と一致する必要があります。データ型のデフォルトの役割は、一般的な使用例に対応する &lt;code&gt;hs-boot&lt;/code&gt; ファイルでの表現です。</target>
        </trans-unit>
        <trans-unit id="ce2fa55812a38ce84cedcaac2cdc1ef31b6202dc" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">以下の他の戦術は、特殊な場合の &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; の最適化または単純化です。最も重要なこと、</target>
        </trans-unit>
        <trans-unit id="3063f59fc82d5bcf9d848a0f374f0dfb94c93aae" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">以下の他の戦術は、特別な場合の &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; の最適化または単純化です。最も重要なこと、</target>
        </trans-unit>
        <trans-unit id="ac62773ad5362997c71d7ab264fe5c75fd2faaf0" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">以下の他の戦術は、特殊な場合の &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; の最適化または単純化です。最も重要なこと、</target>
        </trans-unit>
        <trans-unit id="b158418f40f40b703534feba48e0a39163932604" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">以下の他の戦術は、特別な場合の &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; の最適化または単純化です。最も重要なこと、</target>
        </trans-unit>
        <trans-unit id="dd0ae12fb273623c47053fb946e9734ec1504f3d" translate="yes" xml:space="preserve">
          <source>The other time when &lt;code&gt;ghc-pkg recache&lt;/code&gt; is useful is for registering packages manually: it is possible to register a package by simply putting the appropriate file in the package database directory and invoking &lt;code&gt;ghc-pkg recache&lt;/code&gt; to update the cache. This method of registering packages may be more convenient for automated packaging systems.</source>
          <target state="translated">他のとき &lt;code&gt;ghc-pkg recache&lt;/code&gt; が役立つは、パッケージを手動で登録する場合です。パッケージデータベースディレクトリに適切なファイルを配置し、 &lt;code&gt;ghc-pkg recache&lt;/code&gt; を呼び出してキャッシュを更新するだけで、パッケージを登録できます。パッケージを登録するこの方法は、自動化されたパッケージシステムにとってより便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="0861b9b6f0ebfe21a1fd22a4af5949eaf3c859aa" translate="yes" xml:space="preserve">
          <source>The outer type constructor of the type</source>
          <target state="translated">型の外側の型のコンストラクタ</target>
        </trans-unit>
        <trans-unit id="e52891e976f0923c9c450c24bf9a613b4e6090fe" translate="yes" xml:space="preserve">
          <source>The outermost pattern of all pattern matches gets an implicit bang, unless disabled with &lt;code&gt;~&lt;/code&gt;. This applies to case expressions, patterns in lambda, do-notation, list comprehension, and so on. For example</source>
          <target state="translated">すべてのパターンマッチの最も外側のパターンは、 &lt;code&gt;~&lt;/code&gt; 。これは、ケース式、ラムダのパターン、do記法、リスト内包などに適用されます。例えば</target>
        </trans-unit>
        <trans-unit id="50fd86f2281248d9b015c6814bb25ce010f3a96e" translate="yes" xml:space="preserve">
          <source>The output &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; is the unused portion of the left half of the line, reversed.</source>
          <target state="translated">出力 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; は、行の左半分の未使用部分を逆にしたものです。</target>
        </trans-unit>
        <trans-unit id="64559f0045cf50a2584ac0f3b554b1497f350498" translate="yes" xml:space="preserve">
          <source>The output &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; is the unused portion of the left half of the line, reversed.</source>
          <target state="translated">出力 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; は、行の左半分の未使用部分であり、逆になっています。</target>
        </trans-unit>
        <trans-unit id="cb7e26fd34291e2acd5790d7394332a842bf49bb" translate="yes" xml:space="preserve">
          <source>The output contains one report for each exception raised in the program (the program might raise and catch several exceptions during its execution), where each report looks something like this:</source>
          <target state="translated">出力には、プログラムで発生した各例外(プログラムは実行中にいくつかの例外を発生させたりキャッチしたりすることがあります)についてのレポートが含まれており、各レポートは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="2c2e5b9a77507c6a8b08d76dc41ae952b97f0397" translate="yes" xml:space="preserve">
          <source>The output is a listing of all matching instances, simplified and instantiated as much as possible.</source>
          <target state="translated">出力されるのは、可能な限り簡略化してインスタンス化した、すべてのマッチするインスタンスのリストです。</target>
        </trans-unit>
        <trans-unit id="e1647f08fd0d03cfed6027ec69a028632d0edcfe" translate="yes" xml:space="preserve">
          <source>The output is as follows:</source>
          <target state="translated">出力は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="05194572a5381678c8a688228784f26b016a976f" translate="yes" xml:space="preserve">
          <source>The output is buffered using the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s associated buffer. If this buffer is too small to execute one step of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; action, then it is replaced with a large enough buffer.</source>
          <target state="translated">出力は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; に関連付けられたバッファを使用してバッファリングされます。このバッファが小さすぎて1ステップを実行できない場合 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; アクションの十分な大きさのバッファーに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="5fe80f6940b0232944b7b1dd6f17ef4e130eec5a" translate="yes" xml:space="preserve">
          <source>The output is buffered using the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s associated buffer. If this buffer is too small to execute one step of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; action, then it is replaced with a large enough buffer.</source>
          <target state="translated">The output is buffered using the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; s associated buffer. If this buffer is too small to execute one step of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; action, then it is replaced with a large enough buffer.</target>
        </trans-unit>
        <trans-unit id="0c8e73b419eae441e273e393df1e5bc3d4c312e7" translate="yes" xml:space="preserve">
          <source>The output is placed in ⟨file⟩. If ⟨file⟩ is omitted, then the output is sent to &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">出力は「ファイル」に配置されます。「ファイル」を省略すると、出力は &lt;code&gt;stderr&lt;/code&gt; にます。</target>
        </trans-unit>
        <trans-unit id="c175e78b8f75a38f3457e0b934e42a19295ad3d3" translate="yes" xml:space="preserve">
          <source>The output of &lt;a href=&quot;#ghci-cmd-:complete&quot;&gt;&lt;code&gt;:complete&lt;/code&gt;&lt;/a&gt; begins with a header line containing three space-delimited fields:</source>
          <target state="translated">の出力 &lt;a href=&quot;#ghci-cmd-:complete&quot;&gt; &lt;code&gt;:complete&lt;/code&gt; &lt;/a&gt;スペースで区切られた3つのフィールドを含むヘッダー行で始まります。</target>
        </trans-unit>
        <trans-unit id="28802857a982ea85a85714f0425defb468c55946" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;+RTS -s&lt;/code&gt; tells you how many &amp;ldquo;sparks&amp;rdquo; were created and executed during the run of the program (see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;), which will give you an idea how well your &lt;code&gt;par&lt;/code&gt; annotations are working.</source>
          <target state="translated">&lt;code&gt;+RTS -s&lt;/code&gt; の出力は、プログラムの実行中に作成および実行された「スパーク」の数を示し&lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;ます&lt;/a&gt;（ガベージコレクターを制御するためのRTSオプションを参照）。これにより、 &lt;code&gt;par&lt;/code&gt; アノテーションが。</target>
        </trans-unit>
        <trans-unit id="5ec2bae52b2cc3a473ad80eff58c4a7008471d7a" translate="yes" xml:space="preserve">
          <source>The output of this program:</source>
          <target state="translated">このプログラムの出力。</target>
        </trans-unit>
        <trans-unit id="2446a2868a9a29723ecfffcf757a87c6d61bb061" translate="yes" xml:space="preserve">
          <source>The overloaded immutable array interface</source>
          <target state="translated">オーバーロードされた不変配列インタフェース</target>
        </trans-unit>
        <trans-unit id="1e0e89b8710fb95ffae85a663ed5283ed9621513" translate="yes" xml:space="preserve">
          <source>The package name of the module where the type is declared</source>
          <target state="translated">型が宣言されているモジュールのパッケージ名</target>
        </trans-unit>
        <trans-unit id="48d90d755f55a500041350382bef98a10e9d0ca5" translate="yes" xml:space="preserve">
          <source>The package specification must be a package that isn&amp;rsquo;t already installed.</source>
          <target state="translated">パッケージ仕様は、まだインストールされていないパッケージでなければなりません。</target>
        </trans-unit>
        <trans-unit id="f92b41996d348be77128232f9506df91b9529223" translate="yes" xml:space="preserve">
          <source>The pair returned by &lt;code&gt;&lt;a href=&quot;data-either#v:partitionEithers&quot;&gt;partitionEithers&lt;/a&gt; x&lt;/code&gt; should be the same pair as &lt;code&gt;(&lt;a href=&quot;data-either#v:lefts&quot;&gt;lefts&lt;/a&gt; x, &lt;a href=&quot;data-either#v:rights&quot;&gt;rights&lt;/a&gt; x)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#v:partitionEithers&quot;&gt;partitionEithers&lt;/a&gt; x&lt;/code&gt; によって返されるペアは、 &lt;code&gt;(&lt;a href=&quot;data-either#v:lefts&quot;&gt;lefts&lt;/a&gt; x, &lt;a href=&quot;data-either#v:rights&quot;&gt;rights&lt;/a&gt; x)&lt;/code&gt; &lt;a href=&quot;data-either#v:lefts&quot;&gt;lefts&lt;/a&gt; x、&lt;a href=&quot;data-either#v:rights&quot;&gt;rights&lt;/a&gt; x）と同じペアである必要があります。</target>
        </trans-unit>
        <trans-unit id="87fe52a309c7ffdc572bfe5a6172b7ecd3b52888" translate="yes" xml:space="preserve">
          <source>The paper &lt;a href=&quot;http://i.cs.hku.hk/~bruno//papers/hs2017.pdf&quot;&gt;Quantified class constraints&lt;/a&gt; (by Bottu, Karachalias, Schrijvers, Oliveira, Wadler, Haskell Symposium 2017) describes this feature in technical detail, with examples, and so is a primary reference source for this proposal.</source>
          <target state="translated">紙の&lt;a href=&quot;http://i.cs.hku.hk/~bruno//papers/hs2017.pdf&quot;&gt;量化クラス制約&lt;/a&gt;（Bottu、Karachalias、Schrijvers、Oliveira、Wadler、Haskell Symposium 2017）は、この機能を例とともに技術的詳細で説明しているため、この提案の主要な参照ソースです。</target>
        </trans-unit>
        <trans-unit id="9a39d25846fddc558c23b85ab30760213efefaf3" translate="yes" xml:space="preserve">
          <source>The paper &lt;a href=&quot;https://homepages.inf.ed.ac.uk/wadler/papers/quantcc/quantcc.pdf&quot;&gt;Quantified class constraints&lt;/a&gt; (by Bottu, Karachalias, Schrijvers, Oliveira, Wadler, Haskell Symposium 2017) describes this feature in technical detail, with examples, and so is a primary reference source for this feature.</source>
          <target state="translated">The paper &lt;a href=&quot;https://homepages.inf.ed.ac.uk/wadler/papers/quantcc/quantcc.pdf&quot;&gt;Quantified class constraints&lt;/a&gt; (by Bottu, Karachalias, Schrijvers, Oliveira, Wadler, Haskell Symposium 2017) describes this feature in technical detail, with examples, and so is a primary reference source for this feature.</target>
        </trans-unit>
        <trans-unit id="dced94497d68754bb216a7cf6251afa8e9bde139" translate="yes" xml:space="preserve">
          <source>The parameterizable exception monad.</source>
          <target state="translated">パラメタライズ可能な例外モナド。</target>
        </trans-unit>
        <trans-unit id="b8f1d6b1bf477c0c166957c6d1222206673e1984" translate="yes" xml:space="preserve">
          <source>The parameterizable maybe monad, obtained by composing an arbitrary monad with the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">パラメータ化可能な多分モナド、任意のモナドを &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; で構成することによって取得モナド。モナドます。</target>
        </trans-unit>
        <trans-unit id="6b9fb54cd437f1b7ff93722b920d2899ccc3176a" translate="yes" xml:space="preserve">
          <source>The parameterizable maybe monad, obtained by composing an arbitrary monad with the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">The parameterizable maybe monad, obtained by composing an arbitrary monad with the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; monad.</target>
        </trans-unit>
        <trans-unit id="74b1844d5fa42c50cd76f5db0bf9f59ef141a0c6" translate="yes" xml:space="preserve">
          <source>The parameterizable reader monad.</source>
          <target state="translated">パラメタライズ可能なリーダーモナド。</target>
        </trans-unit>
        <trans-unit id="6146efa10903bbbf156fa5c26b4d5e4f6606ce79" translate="yes" xml:space="preserve">
          <source>The parentheses are required.</source>
          <target state="translated">括弧は必須です。</target>
        </trans-unit>
        <trans-unit id="397c15a9095569645dd284901afa170c9778710f" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;anyToken&lt;/code&gt; accepts any kind of token. It is for example used to implement &lt;code&gt;&lt;a href=&quot;text-parsec#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt;. Returns the accepted token.</source>
          <target state="translated">パーサー &lt;code&gt;anyToken&lt;/code&gt; は、あらゆる種類のトークンを受け入れます。たとえば、 &lt;code&gt;&lt;a href=&quot;text-parsec#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; の実装に使用されます。受け入れられたトークンを返します。</target>
        </trans-unit>
        <trans-unit id="70b77746def41feea7c0cc0c441ef8e1338f1075" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;anyToken&lt;/code&gt; accepts any kind of token. It is for example used to implement &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt;. Returns the accepted token.</source>
          <target state="translated">パーサー &lt;code&gt;anyToken&lt;/code&gt; は、あらゆる種類のトークンを受け入れます。たとえば、 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; の実装に使用されます。受け入れられたトークンを返します。</target>
        </trans-unit>
        <trans-unit id="959f106f98eb9f3ad1febb52797880e72fcf614c" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;anyToken&lt;/code&gt; accepts any kind of token. It is for example used to implement &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt;. Returns the accepted token.</source>
          <target state="translated">パーサー &lt;code&gt;anyToken&lt;/code&gt; は、あらゆる種類のトークンを受け入れます。たとえば、 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; の実装に使用されます。受け入れられたトークンを返します。</target>
        </trans-unit>
        <trans-unit id="032f4f1c69665e22c5b13c0fd126547d28a038f1" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;p &amp;lt;?&amp;gt; msg&lt;/code&gt; behaves as parser &lt;code&gt;p&lt;/code&gt;, but whenever the parser &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, it replaces expect error messages with the expect error message &lt;code&gt;msg&lt;/code&gt;.</source>
          <target state="translated">パーサー &lt;code&gt;p &amp;lt;?&amp;gt; msg&lt;/code&gt; はパーサー &lt;code&gt;p&lt;/code&gt; として動作しますが、パーサー &lt;code&gt;p&lt;/code&gt; が&lt;em&gt;入力を消費せずに&lt;/em&gt;失敗すると、期待エラーメッセージが期待エラーメッセージ &lt;code&gt;msg&lt;/code&gt; に置き換えられます。。</target>
        </trans-unit>
        <trans-unit id="a8f1cafb19ba2c6dd478998d4b66d545fc48222e" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;permute perm&lt;/code&gt; parses a permutation of parser described by &lt;code&gt;perm&lt;/code&gt;. For example, suppose we want to parse a permutation of: an optional string of &lt;code&gt;a&lt;/code&gt;'s, the character &lt;code&gt;b&lt;/code&gt; and an optional &lt;code&gt;c&lt;/code&gt;. This can be described by:</source>
          <target state="translated">パーサー &lt;code&gt;permute perm&lt;/code&gt; は、 &lt;code&gt;perm&lt;/code&gt; で記述されたパーサーの順列を解析します。オプションの文字列：たとえば、私たちはの順列解析したいとの、文字 &lt;code&gt;b&lt;/code&gt; とオプションの &lt;code&gt;c&lt;/code&gt; 。これは次のように説明できます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8e254f70fe9adf4383093f8ce0d95f1c2bcda2e8" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;satisfy f&lt;/code&gt; succeeds for any character for which the supplied function &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;. Returns the character that is actually parsed.</source>
          <target state="translated">パーサーは、指定された関数 &lt;code&gt;f&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; を返す任意の文字について、 &lt;code&gt;satisfy f&lt;/code&gt; が成功することを満たします。。実際に解析される文字を返します。</target>
        </trans-unit>
        <trans-unit id="3da61c1f215262075e23c68ae9974f2a60c3aee3" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;satisfy f&lt;/code&gt; succeeds for any character for which the supplied function &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;. Returns the character that is actually parsed.</source>
          <target state="translated">The parser &lt;code&gt;satisfy f&lt;/code&gt; succeeds for any character for which the supplied function &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; . Returns the character that is actually parsed.</target>
        </trans-unit>
        <trans-unit id="1bfb2b49655a713a162727e182fda358189b4c0f" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The source position of the &lt;code&gt;t&lt;/code&gt; should be returned by &lt;code&gt;posFromTok t&lt;/code&gt; and the token can be shown using &lt;code&gt;showTok t&lt;/code&gt;.</source>
          <target state="translated">パーサー &lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; は、関数 &lt;code&gt;testTok t&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; xを返すときに、結果 &lt;code&gt;x&lt;/code&gt; のトークン &lt;code&gt;t&lt;/code&gt; を受け入れます。 &lt;code&gt;t&lt;/code&gt; のソース位置は &lt;code&gt;posFromTok t&lt;/code&gt; によって返され、トークンは &lt;code&gt;showTok t&lt;/code&gt; を使用して表示できます。</target>
        </trans-unit>
        <trans-unit id="c8d4044987606d17ffa84d47bfdcb30cc0f2b4ab" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The source position of the &lt;code&gt;t&lt;/code&gt; should be returned by &lt;code&gt;posFromTok t&lt;/code&gt; and the token can be shown using &lt;code&gt;showTok t&lt;/code&gt;.</source>
          <target state="translated">The parser &lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; . The source position of the &lt;code&gt;t&lt;/code&gt; should be returned by &lt;code&gt;posFromTok t&lt;/code&gt; and the token can be shown using &lt;code&gt;showTok t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8a05309fd4e0b7bbf92681d8e8ae0f5ce9a9e73" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The token can be shown using &lt;code&gt;showTok t&lt;/code&gt;. The position of the &lt;em&gt;next&lt;/em&gt; token should be returned when &lt;code&gt;nextPos&lt;/code&gt; is called with the current source position &lt;code&gt;pos&lt;/code&gt;, the current token &lt;code&gt;t&lt;/code&gt; and the rest of the tokens &lt;code&gt;toks&lt;/code&gt;, &lt;code&gt;nextPos pos t toks&lt;/code&gt;.</source>
          <target state="translated">パーサー &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; は、関数 &lt;code&gt;testTok t&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; xを返すときに、結果 &lt;code&gt;x&lt;/code&gt; のトークン &lt;code&gt;t&lt;/code&gt; を受け入れます。トークンは &lt;code&gt;showTok t&lt;/code&gt; を使用して表示できます。&lt;em&gt;次の&lt;/em&gt;トークンの位置は、現在のソース位置 &lt;code&gt;pos&lt;/code&gt; 、現在のトークン &lt;code&gt;t&lt;/code&gt; 、および残りのトークン &lt;code&gt;toks&lt;/code&gt; 、 &lt;code&gt;nextPos pos t toks&lt;/code&gt; で &lt;code&gt;nextPos&lt;/code&gt; が呼び出されたときに返される必要があります。&lt;em&gt;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="21e2fe8d4e41cdd8a83bf46968df27727c4731ed" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The token can be shown using &lt;code&gt;showTok t&lt;/code&gt;. The position of the &lt;em&gt;next&lt;/em&gt; token should be returned when &lt;code&gt;nextPos&lt;/code&gt; is called with the current source position &lt;code&gt;pos&lt;/code&gt;, the current token &lt;code&gt;t&lt;/code&gt; and the rest of the tokens &lt;code&gt;toks&lt;/code&gt;, &lt;code&gt;nextPos pos t toks&lt;/code&gt;.</source>
          <target state="translated">The parser &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; . The token can be shown using &lt;code&gt;showTok t&lt;/code&gt; . The position of the &lt;em&gt;next&lt;/em&gt; token should be returned when &lt;code&gt;nextPos&lt;/code&gt; is called with the current source position &lt;code&gt;pos&lt;/code&gt; , the current token &lt;code&gt;t&lt;/code&gt; and the rest of the tokens &lt;code&gt;toks&lt;/code&gt; , &lt;code&gt;nextPos pos t toks&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="284e02f9430552d71dd41595aab5dc530d4b9da6" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;try p&lt;/code&gt; behaves like parser &lt;code&gt;p&lt;/code&gt;, except that it pretends that it hasn't consumed any input when an error occurs.</source>
          <target state="translated">パーサー &lt;code&gt;try p&lt;/code&gt; はパーサー &lt;code&gt;p&lt;/code&gt; のように動作します、エラーが発生したときに入力を消費していないふりをすることを除いて、とます。</target>
        </trans-unit>
        <trans-unit id="d3107597af9e1ca4d6874447085190c38569263b" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;unexpected msg&lt;/code&gt; always fails with an unexpected error message &lt;code&gt;msg&lt;/code&gt; without consuming any input.</source>
          <target state="translated">パーサ &lt;code&gt;unexpected msg&lt;/code&gt; 常に予期しないエラーメッセージで失敗し &lt;code&gt;msg&lt;/code&gt; 任意の入力を消費せず。</target>
        </trans-unit>
        <trans-unit id="248c447e9af3733e32f0c2f859f725b0237051c8" translate="yes" xml:space="preserve">
          <source>The parser is called &lt;em&gt;predictive&lt;/em&gt; since &lt;code&gt;q&lt;/code&gt; is only tried when parser &lt;code&gt;p&lt;/code&gt; didn't consume any input (i.e.. the look ahead is 1). This non-backtracking behaviour allows for both an efficient implementation of the parser combinators and the generation of good error messages.</source>
          <target state="translated">パーサー &lt;code&gt;p&lt;/code&gt; が入力を消費しなかった場合にのみ &lt;code&gt;q&lt;/code&gt; が試行されるため、パーサーは&lt;em&gt;予測型&lt;/em&gt;と呼ばれます（つまり、先読みは1です）。この非バックトラッキング動作により、パーサーコンビネーターの効率的な実装と適切なエラーメッセージの生成の両方が可能になります。</target>
        </trans-unit>
        <trans-unit id="c654c33ff97b96ae7e18c028c030987b14161463" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">パーサーは &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; し（ &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）、 &lt;code&gt;unexpected&lt;/code&gt; エラーメッセージの生成に使用される3つのパーサーです。これらのうち、一般的に使用されるのは（ &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）だけです。 &lt;code&gt;unexpected&lt;/code&gt; の使用例については、 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; の定義を参照してください。</target>
        </trans-unit>
        <trans-unit id="5368ea498695499b712c681c0cc89fba27b8d208" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">パーサーは &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; し（ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）、 &lt;code&gt;unexpected&lt;/code&gt; エラーメッセージの生成に使用される3つのパーサーです。これらのうち、一般的に使用されるのは（ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）だけです。 &lt;code&gt;unexpected&lt;/code&gt; の使用例については、 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; の定義を参照してください。</target>
        </trans-unit>
        <trans-unit id="128ec374e35c570797eef5701a7459bc72bdf064" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">パーサーは &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; し（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）、 &lt;code&gt;unexpected&lt;/code&gt; エラーメッセージの生成に使用される3つのパーサーです。これらのうち、一般的に使用されるのは（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）だけです。 &lt;code&gt;unexpected&lt;/code&gt; の使用例については、 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; の定義を参照してください。。</target>
        </trans-unit>
        <trans-unit id="e7ee59d681c70376770b1fac8def196e60a6b828" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The parsers &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; , ( &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only ( &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt; , see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd849bb3016a66d8c098cc0703e43bfaab55d628" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The parsers &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; , ( &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only ( &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt; , see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3eada09e683e23c6ff49ebfe7467394ea90bede" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The parsers &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; , ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt; , see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4818ed8827f047325509f05e7e58db632c0a9b1" translate="yes" xml:space="preserve">
          <source>The part before the &amp;ldquo;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;rdquo; is the &lt;em&gt;context&lt;/em&gt;, while the part after the &amp;ldquo;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;rdquo; is the &lt;em&gt;head&lt;/em&gt; of the instance declaration.</source>
          <target state="translated">「 &lt;code&gt;=&amp;gt;&lt;/code&gt; 」の前の部分が&lt;em&gt;コンテキスト&lt;/em&gt;、「 &lt;code&gt;=&amp;gt;&lt;/code&gt; 」の後の部分がインスタンス宣言の&lt;em&gt;先頭&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="8c4af47c225f8bda2b21acfa7343627c8d8e9119" translate="yes" xml:space="preserve">
          <source>The partially filled last buffer together with the result.</source>
          <target state="translated">最後のバッファを部分的に埋めたものを結果と一緒に表示します。</target>
        </trans-unit>
        <trans-unit id="76555f01f592b0a2cdc627f47763c8dfacb0c6f2" translate="yes" xml:space="preserve">
          <source>The password for this group (gr_passwd)</source>
          <target state="translated">このグループのパスワード (gr_passwd)</target>
        </trans-unit>
        <trans-unit id="2d3745d1a12b2bebf51e7faab541e80ec1f0a40f" translate="yes" xml:space="preserve">
          <source>The path returned by &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt; name&lt;/code&gt; corresponds to the program that would be executed by &lt;code&gt;&lt;a href=&quot;http://hackage.haskell.org/package/process/docs/System-Process.html#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; when passed the same string (as a &lt;code&gt;RawCommand&lt;/code&gt;, not a &lt;code&gt;ShellCommand&lt;/code&gt;), provided that &lt;code&gt;name&lt;/code&gt; is not a relative path with more than one segment.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt; name&lt;/code&gt; によって返されるパスは、同じ文字列が渡されたときに（ &lt;code&gt;ShellCommand&lt;/code&gt; ではなく &lt;code&gt;RawCommand&lt;/code&gt; として） &lt;code&gt;&lt;a href=&quot;http://hackage.haskell.org/package/process/docs/System-Process.html#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; によって実行されるプログラムに対応します。ただし、 &lt;code&gt;name&lt;/code&gt; が複数のセグメントを持つ相対パスではないます。</target>
        </trans-unit>
        <trans-unit id="9dcaa800bf3364bc2f0c84de7ea08da5a42f3563" translate="yes" xml:space="preserve">
          <source>The path to the directory you want to make</source>
          <target state="translated">作成したいディレクトリへのパス</target>
        </trans-unit>
        <trans-unit id="1e9c6b10b0fdf62a37b5bb885fce58f3a72f52f0" translate="yes" xml:space="preserve">
          <source>The pattern</source>
          <target state="translated">パターン</target>
        </trans-unit>
        <trans-unit id="315acf3488874c225ec06af4616c6846812ce4e8" translate="yes" xml:space="preserve">
          <source>The pattern match checker works by assigning symbolic values to each pattern. We call each such assignment a &amp;lsquo;model&amp;rsquo;. Now, each pattern match clause leads to potentially multiple splits of that model, encoding different ways for the pattern match to fail. For example, when matching &lt;code&gt;x&lt;/code&gt; against &lt;code&gt;Just 4&lt;/code&gt;, we split each incoming matching model into two uncovered sub-models: One where &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;Nothing&lt;/code&gt; and one where &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;Just y&lt;/code&gt; but &lt;code&gt;y&lt;/code&gt; is not &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">The pattern match checker works by assigning symbolic values to each pattern. We call each such assignment a &amp;lsquo;model&amp;rsquo;. Now, each pattern match clause leads to potentially multiple splits of that model, encoding different ways for the pattern match to fail. For example, when matching &lt;code&gt;x&lt;/code&gt; against &lt;code&gt;Just 4&lt;/code&gt; , we split each incoming matching model into two uncovered sub-models: One where &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;Nothing&lt;/code&gt; and one where &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;Just y&lt;/code&gt; but &lt;code&gt;y&lt;/code&gt; is not &lt;code&gt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80e42327db0e35402f1cf71bace675478feffb85" translate="yes" xml:space="preserve">
          <source>The pattern syntax reflects the term syntax:</source>
          <target state="translated">パターン構文は用語構文を反映しています。</target>
        </trans-unit>
        <trans-unit id="1c7f40f56c74434aacb6e8837492766e4ad8a9e2" translate="yes" xml:space="preserve">
          <source>The pattern type signature makes the type variable available on the right-hand side of the equation.</source>
          <target state="translated">パターン型シグネチャは、式の右側で型変数を利用できるようにします。</target>
        </trans-unit>
        <trans-unit id="64cba4adeb973c40ed7ade97bdcc25e2ee42d42d" translate="yes" xml:space="preserve">
          <source>The peak memory the RTS has allocated from the OS.</source>
          <target state="translated">RTSがOSから割り当てたピークメモリ。</target>
        </trans-unit>
        <trans-unit id="22eefa908237bf9e53141f656837f953dc52cd51" translate="yes" xml:space="preserve">
          <source>The percentage of the total memory allocations (excluding profiling overheads) of the program made by this call and all of its sub-calls.</source>
          <target state="translated">この呼び出しとそのすべてのサブコールによって行われたプログラムの総メモリ割り当て (プロファイリング・オーバーヘッドを除く)のパーセンテージ。</target>
        </trans-unit>
        <trans-unit id="65fb5b8744f0d8b0724f16ce7115e8c2ec9bf85b" translate="yes" xml:space="preserve">
          <source>The percentage of the total memory allocations (excluding profiling overheads) of the program made by this call.</source>
          <target state="translated">この呼び出しによって行われたプログラムの総メモリ割り当て (プロファイリング・オーバーヘッドを除く)の割合。</target>
        </trans-unit>
        <trans-unit id="068fb517248f218c1fba65bf915d364e543e8fec" translate="yes" xml:space="preserve">
          <source>The percentage of the total run time of the program spent at this point in the call tree.</source>
          <target state="translated">呼び出しツリーのこの時点で費やしたプログラムの総実行時間のパーセンテージ。</target>
        </trans-unit>
        <trans-unit id="7c2cbfcc5414f5b7bbe22870e814c3e36aa5a19a" translate="yes" xml:space="preserve">
          <source>The percentage of the total run time of the program spent below this point in the call tree.</source>
          <target state="translated">プログラムの総実行時間のうち、コールツリーのこのポイント以下に費やされた時間の割合。</target>
        </trans-unit>
        <trans-unit id="6d1e32ad3dc0bf0fc541838e24bd7ba405c901ce" translate="yes" xml:space="preserve">
          <source>The phase of a complex number, in the range &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt;. If the magnitude is zero, then so is the phase.</source>
          <target state="translated">範囲 &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt; &lt;a href=&quot;numeric#v:pi&quot;&gt;-pi&lt;/a&gt;、&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;）の複素数の位相。振幅がゼロの場合、位相も同様です。</target>
        </trans-unit>
        <trans-unit id="5ec5d9e6ba55f7a9e7cb0eba6a8d8b520103da78" translate="yes" xml:space="preserve">
          <source>The platform specific type for a process identifier.</source>
          <target state="translated">プロセス識別子のプラットフォーム固有の型。</target>
        </trans-unit>
        <trans-unit id="8463d6555430125aabc768a8bec2859b4a17a9f0" translate="yes" xml:space="preserve">
          <source>The plugin is then defined as by providing a value for the &lt;code&gt;holeFitPlugin&lt;/code&gt; field, a function that takes the &lt;code&gt;CommandLineOption&lt;/code&gt; strings that are passed to the compiler using the &lt;a href=&quot;#ghc-flag--fplugin-opt=%E2%9F%A8module%E2%9F%A9:%E2%9F%A8args%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin-opt=⟨module⟩:⟨args⟩&lt;/code&gt;&lt;/a&gt; flags and returns a &lt;code&gt;HoleFitPluginR&lt;/code&gt;. This function can be used to pass the &lt;code&gt;CommandLineOption&lt;/code&gt; strings along to the candidate and fit plugins respectively.</source>
          <target state="translated">The plugin is then defined as by providing a value for the &lt;code&gt;holeFitPlugin&lt;/code&gt; field, a function that takes the &lt;code&gt;CommandLineOption&lt;/code&gt; strings that are passed to the compiler using the &lt;a href=&quot;#ghc-flag--fplugin-opt=%E2%9F%A8module%E2%9F%A9:%E2%9F%A8args%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin-opt=⟨module⟩:⟨args⟩&lt;/code&gt; &lt;/a&gt; flags and returns a &lt;code&gt;HoleFitPluginR&lt;/code&gt; . This function can be used to pass the &lt;code&gt;CommandLineOption&lt;/code&gt; strings along to the candidate and fit plugins respectively.</target>
        </trans-unit>
        <trans-unit id="05ce8c49af72e9c0812629a99bef4d7bdcd57f07" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">配列の内容へのポインタは &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; によって取得されます。考え方は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; （ここで内部的に使用）に似ています。ポインタは、 &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; に引数として渡された関数によって返された &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションの実行中にのみ使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="cc771d773e26b800fb99dc3f19db0ff5b4824d1c" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; . The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f752177391a2368cd5aff90c60b692550ec7f6f2" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">配列の内容へのポインタは &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; によって取得されます。考え方は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; （ここで内部的に使用）に似ています。ポインタは、 &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; に引数として渡された関数によって返された &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションの実行中にのみ使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="fc94f03827f8d452b7fbe2b08e32fe79424476a7" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; . The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b20c9f030aa51113089e5842b41d705c082ffe5" translate="yes" xml:space="preserve">
          <source>The polymorphic kind of this type allows it to be used in several settings. For instance, it can be used as a constraint, e.g. to provide a better error message for a non-existent instance,</source>
          <target state="translated">このタイプの多相型は、いくつかの設定で使用することができます。例えば、存在しないインスタンスに対してより良いエラーメッセージを提供するなど、制約として使用することができます。</target>
        </trans-unit>
        <trans-unit id="7dd3eeff891b51deab88c6a4902ae766c6f21033" translate="yes" xml:space="preserve">
          <source>The position of a subscript in the subrange.</source>
          <target state="translated">サブレンジ内の添え字の位置。</target>
        </trans-unit>
        <trans-unit id="559ede6970ff4191905ab3f6622d825b5bd8500d" translate="yes" xml:space="preserve">
          <source>The practical implication of this difference is that due to the &lt;em&gt;imprecise exceptions&lt;/em&gt; semantics,</source>
          <target state="translated">この違いの実際的な影響は、&lt;em&gt;不正確な例外&lt;/em&gt;セマンティクスのために、</target>
        </trans-unit>
        <trans-unit id="8190358d9c4e04dbcfc369855323f1dc1ed11104" translate="yes" xml:space="preserve">
          <source>The pragma must occur inside the &lt;code&gt;where&lt;/code&gt; part of the instance declaration.</source>
          <target state="translated">プラグマは、インスタンス宣言の &lt;code&gt;where&lt;/code&gt; 部分の内部で発生する必要があります。</target>
        </trans-unit>
        <trans-unit id="031c8f6ef621f154509b2aed1694bc1a7e8c617f" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;code&gt;OVERLAPPING&lt;/code&gt;, &lt;code&gt;OVERLAPPABLE&lt;/code&gt;, &lt;code&gt;OVERLAPS&lt;/code&gt;, &lt;code&gt;INCOHERENT&lt;/code&gt; are used to specify the overlap behavior for individual instances, as described in Section &lt;a href=&quot;#instance-overlap&quot;&gt;Overlapping instances&lt;/a&gt;. The pragmas are written immediately after the &lt;code&gt;instance&lt;/code&gt; keyword, like this:</source>
          <target state="translated">セクション&lt;a href=&quot;#instance-overlap&quot;&gt;重複インスタンスで&lt;/a&gt;説明されているように、プラグマ &lt;code&gt;OVERLAPPING&lt;/code&gt; 、 &lt;code&gt;OVERLAPPABLE&lt;/code&gt; 、 &lt;code&gt;OVERLAPS&lt;/code&gt; 、 &lt;code&gt;INCOHERENT&lt;/code&gt; を使用して、個々のインスタンスの重複動作を指定します。プラグマは、次のように、 &lt;code&gt;instance&lt;/code&gt; キーワードの直後に書き込まれます。</target>
        </trans-unit>
        <trans-unit id="80dd1dde937515d8dba7eb30a62ee2aee1dbce22" translate="yes" xml:space="preserve">
          <source>The pre-processor is run just before the Haskell compiler proper processes the Haskell input, but after the literate markup has been stripped away and (possibly) the C pre-processor has washed the Haskell input.</source>
          <target state="translated">プリプロセッサは、HaskellコンパイラがHaskell入力を適切に処理する直前に実行されますが、リテラルマークアップが取り除かれた後、(おそらく)CプリプロセッサがHaskell入力を洗浄した後に実行されます。</target>
        </trans-unit>
        <trans-unit id="3b0af5d5c36b657cc7d9ed4c1b41c0833ec4e287" translate="yes" xml:space="preserve">
          <source>The precise color scheme is controlled by the environment variable &lt;code&gt;GHC_COLORS&lt;/code&gt; (or &lt;code&gt;GHC_COLOURS&lt;/code&gt;). This can be set to colon-separated list of &lt;code&gt;key=value&lt;/code&gt; pairs. These are the default settings:</source>
          <target state="translated">正確な配色は、環境変数 &lt;code&gt;GHC_COLORS&lt;/code&gt; （または &lt;code&gt;GHC_COLOURS&lt;/code&gt; ）によって制御されます。これは、 &lt;code&gt;key=value&lt;/code&gt; ペアのコロンで区切られたリストに設定できます。これらはデフォルト設定です：</target>
        </trans-unit>
        <trans-unit id="2fc32854b4e2e98d1d21502bcb28d7b8e12f08ad" translate="yes" xml:space="preserve">
          <source>The precision for Integral types is accomplished by zero-padding. If both precision and zero-pad are given for an Integral field, the zero-pad is ignored.</source>
          <target state="translated">積分型の精度は、ゼロパッドによって達成されます。積分フィールドに精度とゼロパッドの両方が与えられた場合、ゼロパッドは無視されます。</target>
        </trans-unit>
        <trans-unit id="6427936fd3378899feeb71f267643f93c076799f" translate="yes" xml:space="preserve">
          <source>The predicate is assumed to define an equivalence.</source>
          <target state="translated">述語は同値を定義することを前提としています。</target>
        </trans-unit>
        <trans-unit id="97c46e75defc42b19335cc4acd7f7b8d23b0ab48" translate="yes" xml:space="preserve">
          <source>The prefix `&lt;code&gt;generic&lt;/code&gt;' indicates an overloaded function that is a generalized version of a &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; function.</source>
          <target state="translated">接頭辞「 &lt;code&gt;generic&lt;/code&gt; 」は、&lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;関数の一般化されたバージョンであるオーバーロードされた関数を示します。</target>
        </trans-unit>
        <trans-unit id="4e5998474098f5954e11b07869ce4b965aab5cd3" translate="yes" xml:space="preserve">
          <source>The preprocessor cannot cope with other Haskell extensions. These would have to go in separate modules.</source>
          <target state="translated">プリプロセッサは他の Haskell 拡張機能には対応できません。これらは別のモジュールに入れなければなりません。</target>
        </trans-unit>
        <trans-unit id="48cdcef6c8bba47873b2657cefbebf9a582e8376" translate="yes" xml:space="preserve">
          <source>The primary difficulty with managing shared libraries is arranging things such that programs can find the libraries they need at runtime. The details of how this works varies between platforms, in particular the three major systems: Unix ELF platforms, Windows and Mac OS X.</source>
          <target state="translated">共有ライブラリを管理する上で一番難しいのは、プログラムが実行時に必要なライブラリを見つけられるように配置することです。これがどのように動作するかの詳細はプラットフォームによって異なり、特に3つの主要なシステムがあります。Unix ELFプラットフォーム、Windows、Mac OS Xです。</target>
        </trans-unit>
        <trans-unit id="1b94ab7b19971d0143cb6a1dc0aaaa9d62aab435" translate="yes" xml:space="preserve">
          <source>The primary source of asynchronous exceptions, however, is &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">ただし、非同期例外の主な原因は &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="db2ba14a4921403cf0313fa72d18649bbc679eef" translate="yes" xml:space="preserve">
          <source>The primitive parser combinators.</source>
          <target state="translated">原始的なパーサーの組み合わせ。</target>
        </trans-unit>
        <trans-unit id="f13d852fb55e7d4ce977dd12fee90d0bc1dc9fe0" translate="yes" xml:space="preserve">
          <source>The primops make extensive use of &lt;a href=&quot;#glasgow-unboxed&quot;&gt;unboxed types&lt;/a&gt; and &lt;a href=&quot;#unboxed-tuples&quot;&gt;unboxed tuples&lt;/a&gt;, which we briefly summarise here.</source>
          <target state="translated">プリモップは、&lt;a href=&quot;#glasgow-unboxed&quot;&gt;ボックス化されていないタイプ&lt;/a&gt;と&lt;a href=&quot;#unboxed-tuples&quot;&gt;ボックス化されていないタプル&lt;/a&gt;を広範囲に使用します。</target>
        </trans-unit>
        <trans-unit id="17617bbcaecd4caffa758995817fc1d0e3af127e" translate="yes" xml:space="preserve">
          <source>The problem here is that this instance would allow one particular choice of &lt;code&gt;[a]&lt;/code&gt; to be associated with more than one choice for &lt;code&gt;b&lt;/code&gt;, which contradicts the dependency specified in the definition of &lt;code&gt;D&lt;/code&gt;. More generally, this means that, in any instance of the form:</source>
          <target state="translated">ここでの問題は、このインスタンスが &lt;code&gt;[a]&lt;/code&gt; の特定の1つの選択肢を &lt;code&gt;b&lt;/code&gt; の複数の選択肢と関連付けることを可能にすることです。これは、 &lt;code&gt;D&lt;/code&gt; の定義で指定された依存関係と矛盾します。より一般的には、これは、フォームのどのインスタンスでも次のことを意味します。</target>
        </trans-unit>
        <trans-unit id="e0f5743627f2c13906299b1a7e64c44a8ec050dd" translate="yes" xml:space="preserve">
          <source>The problem is that it is not possible in general to interrupt a foreign call safely. However, GHC does provide a way to interrupt blocking system calls which works for most system calls on both Unix and Windows. When the &lt;code&gt;InterruptibleFFI&lt;/code&gt; extension is enabled, a foreign call can be annotated with &lt;code&gt;interruptible&lt;/code&gt; instead of &lt;code&gt;safe&lt;/code&gt; or &lt;code&gt;unsafe&lt;/code&gt;:</source>
          <target state="translated">問題は、一般的に外部呼び出しを安全に中断することができないことです。ただし、GHCは、UnixとWindowsの両方のほとんどのシステムコールで機能するブロッキングシステムコールを中断する方法を提供します。とき &lt;code&gt;InterruptibleFFI&lt;/code&gt; の拡張機能が有効になっている、外国通話がで注釈を付けることができ &lt;code&gt;interruptible&lt;/code&gt; の代わりに、 &lt;code&gt;safe&lt;/code&gt; か &lt;code&gt;unsafe&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3d34cc9fd2e90a4c7e190d8e316ee751917d80db" translate="yes" xml:space="preserve">
          <source>The problem with using &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChan&quot;&gt;newTChan&lt;/a&gt;&lt;/code&gt; to create the broadcast channel is that if it is only written to and never read, items will pile up in memory. By using &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChan&quot;&gt;newBroadcastTChan&lt;/a&gt;&lt;/code&gt; to create the broadcast channel, items can be garbage collected after clients have seen them.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChan&quot;&gt;newTChan&lt;/a&gt;&lt;/code&gt; を使用してブロードキャストチャネルを作成する場合の問題は、書き込みのみが行われ、読み取られない場合、アイテムがメモリに蓄積されることです。 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChan&quot;&gt;newBroadcastTChan&lt;/a&gt;&lt;/code&gt; を使用してブロードキャストチャネルを作成することにより、クライアントが見た後にアイテムをガベージコレクションすることができます。</target>
        </trans-unit>
        <trans-unit id="abc76e2f497ab466ec7ca65dcd335b801b282966" translate="yes" xml:space="preserve">
          <source>The procedure to check if a module is trusted or not depends on if the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag is present. The check is similar in both cases with the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag enabling an extra requirement for trustworthy modules to be regarded as trusted.</source>
          <target state="translated">モジュールが信頼できるかどうかを確認する手順は、&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;フラグが存在するかどうかによって異なります。チェックが有する両方の場合に類似している&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;信頼できるとみなされるべき信頼できるモジュールの余分な要求を許可フラグ。</target>
        </trans-unit>
        <trans-unit id="ada084bff7147867e37d2b21221c961521d29596" translate="yes" xml:space="preserve">
          <source>The process has insufficient privileges to perform the operation.</source>
          <target state="translated">そのプロセスには、操作を実行するための十分な権限がありません。</target>
        </trans-unit>
        <trans-unit id="58c80733d659717ab91216ecfc11c90f2165a6c0" translate="yes" xml:space="preserve">
          <source>The process is slightly complicated when the binding is polymorphic. We show the process by means of an example. To keep things simple, we will use the well known &lt;code&gt;map&lt;/code&gt; function:</source>
          <target state="translated">バインディングがポリモーフィックである場合、プロセスは少し複雑になります。例を使用してプロセスを示します。簡単にするために、よく知られている &lt;code&gt;map&lt;/code&gt; 関数を使用します。</target>
        </trans-unit>
        <trans-unit id="355fc82b6533b2538478ddb7b7f9868d90ea5c2a" translate="yes" xml:space="preserve">
          <source>The process signal mask</source>
          <target state="translated">プロセス信号マスク</target>
        </trans-unit>
        <trans-unit id="505d4ae162b670335f91963acc1d97b4cead190f" translate="yes" xml:space="preserve">
          <source>The profile data itself is described by the &lt;code&gt;profile&lt;/code&gt; field, which contains a tree-like object (which we&amp;rsquo;ll call a &amp;ldquo;cost-centre stack&amp;rdquo; here) with the following properties,</source>
          <target state="translated">プロファイルデータ自体は、次のプロパティを持つツリーのようなオブジェクト（ここでは「コストセンタースタック」と呼びます）を含む &lt;code&gt;profile&lt;/code&gt; フィールドによって記述されます。</target>
        </trans-unit>
        <trans-unit id="60512792acedb21616d84dd583523fdb5bfdbd7f" translate="yes" xml:space="preserve">
          <source>The profile tree itself</source>
          <target state="translated">プロファイルツリー自体</target>
        </trans-unit>
        <trans-unit id="73c7e4bcf702d08f9fbe508aab53b3b722fac243" translate="yes" xml:space="preserve">
          <source>The program &lt;strong&gt;hp2ps&lt;/strong&gt; program converts a &lt;code&gt;.hp&lt;/code&gt; file produced by the &lt;code&gt;-h&amp;lt;break-down&amp;gt;&lt;/code&gt; runtime option into a PostScript graph of the heap profile. By convention, the file to be processed by &lt;strong&gt;hp2ps&lt;/strong&gt; has a &lt;code&gt;.hp&lt;/code&gt; extension. The PostScript output is written to &lt;code&gt;&lt;em&gt;file&lt;/em&gt;@.ps&lt;/code&gt;. If &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; is omitted entirely, then the program behaves as a filter.</source>
          <target state="translated">プログラム&lt;strong&gt;hp2ps&lt;/strong&gt;プログラムは、 &lt;code&gt;-h&amp;lt;break-down&amp;gt;&lt;/code&gt; ランタイムオプションによって生成された &lt;code&gt;.hp&lt;/code&gt; ファイルをヒーププロファイルのPostScriptグラフに変換します。慣例により、によって処理されるファイル&lt;strong&gt;hp2psは&lt;/strong&gt;持っている &lt;code&gt;.hp&lt;/code&gt; の拡張子を。PostScript出力は &lt;code&gt;&lt;em&gt;file&lt;/em&gt;@.ps&lt;/code&gt; @ .psに書き込まれ&lt;em&gt;ます&lt;/em&gt;。場合は &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; 完全に省略され、その後、プログラムはフィルタとして動作します。&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="146c7ee2b2dbd1e6430b6a92386c207342ed1810" translate="yes" xml:space="preserve">
          <source>The program text itself, the C stack, any non-heap data (e.g. data allocated by foreign libraries, and data allocated by the RTS), and &lt;code&gt;mmap()&lt;/code&gt;&amp;lsquo;d memory are not counted in the heap profile.</source>
          <target state="translated">プログラムテキスト自体、Cスタック、非ヒープデータ（外部ライブラリによって割り当てられたデータ、RTSによって割り当てられたデータなど）、および &lt;code&gt;mmap()&lt;/code&gt; のメモリは、ヒーププロファイルではカウントされません。</target>
        </trans-unit>
        <trans-unit id="477940d98b5481ae904ea922ab7dabd1f651a748" translate="yes" xml:space="preserve">
          <source>The program text itself, the C stack, any non-heap data (e.g. data allocated by foreign libraries, and data allocated by the RTS), and &lt;code&gt;mmap()&lt;/code&gt;&amp;rsquo;d memory are not counted in the heap profile.</source>
          <target state="translated">The program text itself, the C stack, any non-heap data (e.g. data allocated by foreign libraries, and data allocated by the RTS), and &lt;code&gt;mmap()&lt;/code&gt; &amp;rsquo;d memory are not counted in the heap profile.</target>
        </trans-unit>
        <trans-unit id="608f29767e628bc3908a6f9a3b5c8447d29874fc" translate="yes" xml:space="preserve">
          <source>The program's heap is reaching its limit, and the program should take action to reduce the amount of live data it has. Notes:</source>
          <target state="translated">プログラムのヒープが限界に達しているので、プログラムが持っているライブデータの量を減らすための措置を取る必要があります。注意事項。</target>
        </trans-unit>
        <trans-unit id="42403ff8e7d02a582ef311693ed3c81d360f6281" translate="yes" xml:space="preserve">
          <source>The programmer can specify rewrite rules as part of the source program (in a pragma). Here is an example:</source>
          <target state="translated">プログラマーは、ソースプログラムの一部として書き換えルールを指定することができます(pragmaで)。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="7913df84bb2ae3b02dcb56dbc5ad5cfcbd49b3ac" translate="yes" xml:space="preserve">
          <source>The pseudo-object file &lt;code&gt;A.o-boot&lt;/code&gt; is empty (don&amp;rsquo;t link it!), but it is very useful when using a Makefile, to record when the &lt;code&gt;A.hi-boot&lt;/code&gt; was last brought up to date (see &lt;a href=&quot;#using-make&quot;&gt;Using make&lt;/a&gt;).</source>
          <target state="translated">疑似オブジェクトファイル &lt;code&gt;A.o-boot&lt;/code&gt; は空です（リンクしないでください！）が、Makefileを使用する場合、 &lt;code&gt;A.hi-boot&lt;/code&gt; が最後に更新された日時を記録することは非常に便利です（&lt;a href=&quot;#using-make&quot;&gt;makeの使用を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="db524ce2791037ca05d5828a71f6846facf22e65" translate="yes" xml:space="preserve">
          <source>The public face of Template Haskell</source>
          <target state="translated">テンプレートHaskellの公開顔</target>
        </trans-unit>
        <trans-unit id="23463757868e42fe8367dadcedc764a10dfe3e71" translate="yes" xml:space="preserve">
          <source>The purpose of &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; is to provide a common interface for I/O devices that can read and write data through a buffer. Devices that implement &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; include ordinary files, memory-mapped files, and bytestrings. The underlying device implementing a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; must provide &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; の目的は、バッファーを介してデータを読み書きできるI / Oデバイスに共通のインターフェイスを提供することです。 &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; を実装するデバイスには、通常のファイル、メモリマップファイル、およびバイト文字列が含まれます。 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; を実装する基になるデバイスは、 &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="dd5d324fb68ef0a9578edac19d7cc075670db732" translate="yes" xml:space="preserve">
          <source>The purpose of the installed package ID is to detect problems caused by re-installing a package without also recompiling the packages that depend on it. Recompiling dependencies is necessary, because the newly compiled package may have a different ABI (Application Binary Interface) than the previous version, even if both packages were built from the same source code using the same compiler. With installed package IDs, a recompiled package will have a different installed package ID from the previous version, so packages that depended on the previous version are now orphaned - one of their dependencies is not satisfied. Packages that are broken in this way are shown in the &lt;code&gt;ghc-pkg list&lt;/code&gt; output either in red (if possible) or otherwise surrounded by braces. In the following example, we have recompiled and reinstalled the &lt;code&gt;filepath&lt;/code&gt; package, and this has caused various dependencies including &lt;code&gt;Cabal&lt;/code&gt; to break:</source>
          <target state="translated">インストール済みパッケージIDの目的は、パッケージに依存するパッケージを再コンパイルせずに、パッケージの再インストールによって引き起こされる問題を検出することです。両方のパッケージが同じコンパイラを使用して同じソースコードからビルドされた場合でも、新しくコンパイルされたパッケージは以前のバージョンとは異なるABI（アプリケーションバイナリインターフェース）を持つ可能性があるため、依存関係の再コンパイルが必要です。インストール済みのパッケージIDを使用すると、再コンパイルされたパッケージには以前のバージョンとは異なるインストール済みパッケージIDが含まれるため、以前のバージョンに依存していたパッケージは孤立し、依存関係の1つが満たされなくなります。この方法で壊れたパッケージは、 &lt;code&gt;ghc-pkg list&lt;/code&gt; 赤（可能な場合）またはブレースで囲まれた出力。次の例では、 &lt;code&gt;filepath&lt;/code&gt; パッケージを再コンパイルして再インストールしました。これにより、 &lt;code&gt;Cabal&lt;/code&gt; を含むさまざまな依存関係が壊れました。</target>
        </trans-unit>
        <trans-unit id="61845a19ad288b45ffb2fcd9525a2a7e4ba4eab7" translate="yes" xml:space="preserve">
          <source>The purpose of using builder primitives is to improve the performance of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. These improvements stem from making the two most common steps performed by a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; more efficient. We explain these two steps in turn.</source>
          <target state="translated">Builderプリミティブを使用する目的は、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; のパフォーマンスを向上させることです。これらの改善は、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; によって実行される最も一般的な2つのステップをより効率的にすることから生じています。これらの2つのステップを順に説明します。</target>
        </trans-unit>
        <trans-unit id="457568e28e80e66fe1efa03405736fd1dd831161" translate="yes" xml:space="preserve">
          <source>The quantification in &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s type signature is explicit. For example:</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; の型シグネチャの数量化は明示的です。例えば：</target>
        </trans-unit>
        <trans-unit id="5b448f586c824562f03a97bce628eeed77c6e2ff" translate="yes" xml:space="preserve">
          <source>The quantification in &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s type signature is explicit. For example:</source>
          <target state="translated">The quantification in &lt;code&gt;f&lt;/code&gt; &amp;rsquo;s type signature is explicit. For example:</target>
        </trans-unit>
        <trans-unit id="b2a0aea25ac8727b745c955a5b510d60c52345ef" translate="yes" xml:space="preserve">
          <source>The quoted ⟨string⟩ can be arbitrary, and may contain newlines.</source>
          <target state="translated">引用された ⟨string⟩ は任意であり、改行を含む場合があります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
