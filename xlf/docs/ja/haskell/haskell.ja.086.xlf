<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="3f1a7d74333974f609c76b0ab40dd62ceeaf6cfb" translate="yes" xml:space="preserve">
          <source>This change only applies to the main module. Other modules will still export &lt;code&gt;main&lt;/code&gt; from a default export list, regardless of the &lt;code&gt;-main-is&lt;/code&gt; flag. This allows use of &lt;code&gt;-main-is&lt;/code&gt; with existing modules that export &lt;code&gt;main&lt;/code&gt; via a default export list, even when &lt;code&gt;-main-is&lt;/code&gt; points to a different entry point, as in this example (compiled with &lt;code&gt;-main-is MainWrapper.program&lt;/code&gt;).</source>
          <target state="translated">この変更は、メインモジュールにのみ適用されます。他のモジュールは、 &lt;code&gt;-main-is&lt;/code&gt; フラグに関係なく、デフォルトのエクスポートリストから &lt;code&gt;main&lt;/code&gt; をエクスポートします。これは、使用可能 &lt;code&gt;-main-is&lt;/code&gt; エクスポート既存のモジュールと &lt;code&gt;main&lt;/code&gt; 場合でも、デフォルトのエクスポートリストを介し &lt;code&gt;-main-is&lt;/code&gt; （でコンパイルこの例のように、異なるエントリ・ポイントにポイント &lt;code&gt;-main-is MainWrapper.program&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="01542d372736818f19cef9c2f686e2c378bf0120" translate="yes" xml:space="preserve">
          <source>This class contains types where you can learn the equality of two types from information contained in &lt;em&gt;terms&lt;/em&gt;. Typically, only singleton types should inhabit this class.</source>
          <target state="translated">このクラスには、&lt;em&gt;用語に&lt;/em&gt;含まれる情報から2つの型の等価性を学習できる型が含まれてい&lt;em&gt;ます&lt;/em&gt;。通常、このクラスにはシングルトンタイプのみを含める必要があります。</target>
        </trans-unit>
        <trans-unit id="7d25d36771e3335063cfda8a370569be262e46f9" translate="yes" xml:space="preserve">
          <source>This class gives the integer associated with a type-level natural. There are instances of the class for every concrete literal: 0, 1, 2, etc.</source>
          <target state="translated">このクラスは,型レベルの自然数に関連付けられた整数を与えます.0,1,2 などの具象リテラルごとにこのクラスのインスタンスが存在します。</target>
        </trans-unit>
        <trans-unit id="6cd7c40ac16e5fc8bee6ac08be5d6891bedfd9f7" translate="yes" xml:space="preserve">
          <source>This class gives the string associated with a type-level symbol. There are instances of the class for every concrete literal: &quot;hello&quot;, etc.</source>
          <target state="translated">このクラスは,型レベルのシンボルに関連付けられた文字列を与えます.具象リテラルごとにこのクラスのインスタンスが存在します。&quot;hello&quot; などです。</target>
        </trans-unit>
        <trans-unit id="4bb95279b9a76f4eb7b8bef88cb4f615842b9abb" translate="yes" xml:space="preserve">
          <source>This class is needed as a Haskell98 compatibility workaround for the lack of FlexibleInstances.</source>
          <target state="translated">このクラスは、Haskell98互換性のために必要とされるもので、FlexibleInstancesの欠如を回避するためのものです。</target>
        </trans-unit>
        <trans-unit id="8618fe865486683e2da5d2b5c39277afb92c383b" translate="yes" xml:space="preserve">
          <source>This class is used in the translation of the recursive &lt;code&gt;do&lt;/code&gt; notation supported by GHC and Hugs.</source>
          <target state="translated">このクラスは、GHCとHugsでサポートされている再帰的 &lt;code&gt;do&lt;/code&gt; 表記の変換で使用されます。</target>
        </trans-unit>
        <trans-unit id="ea1509b29993b854979a76c88a19d8658f8c383f" translate="yes" xml:space="preserve">
          <source>This class, with only the one instance, is used as a workaround for the fact that &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, as a concrete type, is not allowable as a typeclass instance. &lt;code&gt;&lt;a href=&quot;text-printf#t:IsChar&quot;&gt;IsChar&lt;/a&gt;&lt;/code&gt; is exported for backward-compatibility.</source>
          <target state="translated">このクラスは、インスタンスが1つだけなので、具象型としての &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; がタイプクラスインスタンスとして許可されないという事実の回避策として使用されます。 &lt;code&gt;&lt;a href=&quot;text-printf#t:IsChar&quot;&gt;IsChar&lt;/a&gt;&lt;/code&gt; は、下位互換性のためにエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="3d0cfa10f6122f9ea4569e9917dc09cd908362b9" translate="yes" xml:space="preserve">
          <source>This code fragment should elicit a fatal error, but it does not:</source>
          <target state="translated">このコードは致命的なエラーを発生させるはずですが、そうではありません。</target>
        </trans-unit>
        <trans-unit id="307c94db0a4948761aff0e27f917047627954f03" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">このコードは、重要な部分の非同期例外をマスクすることにより、 &lt;code&gt;acquire&lt;/code&gt; が &lt;code&gt;release&lt;/code&gt; とペアになることを保証します。（このコードを自分で書くのではなく、一般的なパターンを抽象化する &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; を使用する方が良いでしょう）。</target>
        </trans-unit>
        <trans-unit id="83010be07376269d9080bf541aef5e0b9bd24515" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">このコードは、重要な部分の非同期例外をマスクすることにより、 &lt;code&gt;acquire&lt;/code&gt; が &lt;code&gt;release&lt;/code&gt; とペアになっていることを保証します。（このコードを自分で書くよりも、一般的なパターンを抽象化する &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; を使用する方がよいでしょう）。</target>
        </trans-unit>
        <trans-unit id="0ed92185c6cf0333916ffd9559563724620e4e31" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">このコードは、重要な部分の非同期例外をマスクすることにより、 &lt;code&gt;acquire&lt;/code&gt; が &lt;code&gt;release&lt;/code&gt; とペアになることを保証します。（このコードを自分で書くのではなく、一般的なパターンを抽象化する &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; を使用する方が良いでしょう）。</target>
        </trans-unit>
        <trans-unit id="fd2a2c6d2e7fd86b8c1811514153b5f08f749cfb" translate="yes" xml:space="preserve">
          <source>This combinator implements choice. The parser &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; first applies &lt;code&gt;p&lt;/code&gt;. If it succeeds, the value of &lt;code&gt;p&lt;/code&gt; is returned. If &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, parser &lt;code&gt;q&lt;/code&gt; is tried. This combinator is defined equal to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; member of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; class and the (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) member of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このコンビネータは選択を実装します。パーサー &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; 最初に &lt;code&gt;p&lt;/code&gt; を適用します。成功した場合、 &lt;code&gt;p&lt;/code&gt; の値が返されます。&lt;em&gt;入力を消費せずに&lt;/em&gt; &lt;code&gt;p&lt;/code&gt; が失敗した場合、パーサー &lt;code&gt;q&lt;/code&gt; が試行されます。このコンビネータは、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; クラスの &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; メンバーおよび &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; の（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）メンバーと同等に定義されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="05f82f2ce2fd9bc7ef8dc6adbbe8bab553e349cc" translate="yes" xml:space="preserve">
          <source>This combinator implements choice. The parser &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; first applies &lt;code&gt;p&lt;/code&gt;. If it succeeds, the value of &lt;code&gt;p&lt;/code&gt; is returned. If &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, parser &lt;code&gt;q&lt;/code&gt; is tried. This combinator is defined equal to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; member of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; class and the (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) member of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このコンビネータは選択を実装します。パーサー &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; 最初に &lt;code&gt;p&lt;/code&gt; を適用します。成功すると、 &lt;code&gt;p&lt;/code&gt; の値が返されます。&lt;em&gt;入力を消費せずに&lt;/em&gt; &lt;code&gt;p&lt;/code&gt; が失敗した場合、パーサー &lt;code&gt;q&lt;/code&gt; が試行されます。このコンビネータは、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; クラスの &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; メンバーおよび &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; の（ &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）メンバーと等しく定義されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0f3ee763a42040e9ccebad9a7f214fbd1d7c3467" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">このコンビネータは、 &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; で表現されます。ユーザー定義のトークンストリームを受け入れるために使用されます。たとえば、ソース位置がタプルされた基本トークンのストリームがあるとします。次に、単一のトークンを受け入れるパーサーを次のように定義できます。</target>
        </trans-unit>
        <trans-unit id="14c01988af41cdde7e895b21be33747a7bdbcf4f" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">このコンビネータは、 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; で表現されます。ユーザー定義のトークンストリームを受け入れるために使用されます。たとえば、ソース位置がタプルされた基本トークンのストリームがあるとします。次に、単一のトークンを受け入れるパーサーを次のように定義できます。</target>
        </trans-unit>
        <trans-unit id="89de4bf966a367ce5c9388562fe4c9b4408f046d" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">このコンビネータは、 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; で表現されます。ユーザー定義のトークンストリームを受け入れるために使用されます。たとえば、ソース位置がタプルされた基本トークンのストリームがあるとします。次に、単一のトークンを受け入れるパーサーを次のように定義できます。</target>
        </trans-unit>
        <trans-unit id="1e5ad5170254164643045a2e82513b691609b5d4" translate="yes" xml:space="preserve">
          <source>This combinator is used whenever arbitrary look ahead is needed. Since it pretends that it hasn't consumed any input when &lt;code&gt;p&lt;/code&gt; fails, the (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator will try its second alternative even when the first parser failed while consuming input.</source>
          <target state="translated">このコンビネータは、任意の先読みが必要な場合に使用されます。 &lt;code&gt;p&lt;/code&gt; が失敗したときに入力を消費していないふりをしているため、（ &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）コンビネーターは、最初のパーサーが入力の消費中に失敗した場合でも、2番目の選択肢を試します。</target>
        </trans-unit>
        <trans-unit id="333f51ec0b70600290728e38bbadbef215e2a2e6" translate="yes" xml:space="preserve">
          <source>This combinator is used whenever arbitrary look ahead is needed. Since it pretends that it hasn't consumed any input when &lt;code&gt;p&lt;/code&gt; fails, the (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator will try its second alternative even when the first parser failed while consuming input.</source>
          <target state="translated">このコンビネータは、任意の先読みが必要な場合に使用されます。 &lt;code&gt;p&lt;/code&gt; が失敗したときに入力を消費していないふりをしているため、（ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）コンビネーターは、最初のパーサーが入力の消費中に失敗した場合でも、2番目の選択肢を試します。</target>
        </trans-unit>
        <trans-unit id="28f1613af5414b6dfb871503c19a4aa1ba30ec6d" translate="yes" xml:space="preserve">
          <source>This command allows to request command completions from GHCi even when interacting over a pipe instead of a proper terminal and is designed for integrating GHCi&amp;rsquo;s completion with text editors and IDEs.</source>
          <target state="translated">このコマンドを使用すると、適切な端末ではなくパイプを介して対話する場合でも、GHCiにコマンドの完了を要求でき、GHCiの完了をテキストエディターやIDEと統合するように設計されています。</target>
        </trans-unit>
        <trans-unit id="2c0c68fd4f51cfec53bb7b1385354a15a0e4ce3f" translate="yes" xml:space="preserve">
          <source>This command is useful for highlighting and navigating all uses of an identifier in editors and IDEs.</source>
          <target state="translated">このコマンドは、エディタや IDE で識別子のすべての用途をハイライトしてナビゲートするのに便利です。</target>
        </trans-unit>
        <trans-unit id="7b545a39643db7cee8ec309e9e67a7d52b03abd6" translate="yes" xml:space="preserve">
          <source>This command is useful when integrating GHCi with text editors and IDEs for providing a goto-definition facility.</source>
          <target state="translated">このコマンドは、GHCiをテキストエディタやIDEと統合して、ゴト定義機能を提供する場合に便利です。</target>
        </trans-unit>
        <trans-unit id="2eacd64caa5b6273684b41b06c7d8af5e0723ce8" translate="yes" xml:space="preserve">
          <source>This command is useful when integrating GHCi with text editors and IDEs for providing a show-type-under-point facility.</source>
          <target state="translated">このコマンドは、GHCiとテキストエディタやIDEを統合して、show-type-under-point機能を提供する場合に便利です。</target>
        </trans-unit>
        <trans-unit id="d47d493f7e230cc635856f431e77061767e3368c" translate="yes" xml:space="preserve">
          <source>This computation may fail with one of the following &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; exceptions:</source>
          <target state="translated">この計算は、次の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; 例外のいずれかで失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8b19a2ae0aec8ddd136b17fb7f698c57606d4262" translate="yes" xml:space="preserve">
          <source>This computation may fail with:</source>
          <target state="translated">この計算が失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="a67c6a10dac4821f810551e23532552de30c4f14" translate="yes" xml:space="preserve">
          <source>This concerns the interaction of foreign calls with &lt;code&gt;Control.Concurrent.throwTo&lt;/code&gt;. Normally when the target of a &lt;code&gt;throwTo&lt;/code&gt; is involved in a foreign call, the exception is not raised until the call returns, and in the meantime the caller is blocked. This can result in unresponsiveness, which is particularly undesirable in the case of user interrupt (e.g. Control-C). The default behaviour when a Control-C signal is received (&lt;code&gt;SIGINT&lt;/code&gt; on Unix) is to raise the &lt;code&gt;UserInterrupt&lt;/code&gt; exception in the main thread; if the main thread is blocked in a foreign call at the time, then the program will not respond to the user interrupt.</source>
          <target state="translated">これは、外部呼び出しと &lt;code&gt;Control.Concurrent.throwTo&lt;/code&gt; の相互作用に関係しています。通常、 &lt;code&gt;throwTo&lt;/code&gt; のターゲットが外部呼び出しに関与している場合、呼び出しが戻るまで例外は発生せず、その間、呼び出し元はブロックされます。これにより応答がなくなる可能性があり、ユーザーによる割り込み（例：Control-C）の場合は特に望ましくありません。 Control-C信号を受信したときのデフォルトの動作（UNIXでは &lt;code&gt;SIGINT&lt;/code&gt; ）は、メインスレッドで &lt;code&gt;UserInterrupt&lt;/code&gt; 例外を発生させることです。メインスレッドがその時点で外部呼び出しでブロックされている場合、プログラムはユーザーの割り込みに応答しません。</target>
        </trans-unit>
        <trans-unit id="5007b6d693d171da9771256dfe1ecb2e1e3b194d" translate="yes" xml:space="preserve">
          <source>This condition is not checked by the types. You must ensure that the supplied values are valid total orderings yourself.</source>
          <target state="translated">この条件はタイプによってチェックされません。提供された値が有効な合計注文数であることを自分で確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="0e7153ef74e9b4f2ea52b3a0b09f27ad6452a548" translate="yes" xml:space="preserve">
          <source>This converts a string, but keeps spaces as non-line-breakable, and adds line breaks between each of the strings in the input list.</source>
          <target state="translated">これは文字列を変換しますが、スペースは改行不可として保持し、入力リストの各文字列の間に改行を追加します。</target>
        </trans-unit>
        <trans-unit id="c8e81237f627f581509f60a710986526096f03c3" translate="yes" xml:space="preserve">
          <source>This converts a string, but keeps spaces as non-line-breakable.</source>
          <target state="translated">これは文字列を変換しますが、スペースは改行不可として保持します。</target>
        </trans-unit>
        <trans-unit id="20813c69f6fd04e90a0e74330c0f84f24f6a5905" translate="yes" xml:space="preserve">
          <source>This corresponds to the &lt;code&gt;show{E,F,G}Float&lt;/code&gt; operations provided by &lt;code&gt;base&lt;/code&gt;'s &lt;a href=&quot;../base-4.13.0.0/numeric&quot;&gt;Numeric&lt;/a&gt; module.</source>
          <target state="translated">これは、 &lt;code&gt;base&lt;/code&gt; の&lt;a href=&quot;../base-4.13.0.0/numeric&quot;&gt;数値&lt;/a&gt;モジュールによって提供される &lt;code&gt;show{E,F,G}Float&lt;/code&gt; 操作に対応します。</target>
        </trans-unit>
        <trans-unit id="307f56846d6abe441d853a9f036164d709972336" translate="yes" xml:space="preserve">
          <source>This currently enables</source>
          <target state="translated">これにより、現在では</target>
        </trans-unit>
        <trans-unit id="c40cef262ba41e4930517342a01fdf1bf324d546" translate="yes" xml:space="preserve">
          <source>This data type represents an equivalence relation.</source>
          <target state="translated">このデータ型は、等価関係を表します。</target>
        </trans-unit>
        <trans-unit id="403740310732ed8ffbeeeb04a65618a78cfc1a3e" translate="yes" xml:space="preserve">
          <source>This data type specifies operators that work on values of type &lt;code&gt;a&lt;/code&gt;. An operator is either binary infix or unary prefix or postfix. A binary operator has also an associated associativity.</source>
          <target state="translated">このデータ型は &lt;code&gt;a&lt;/code&gt; 型の値を処理する演算子を指定します。演算子は、バイナリのインフィックスまたは単項のプレフィックスまたはポストフィックスです。二項演算子には関連性も関連付けられています。</target>
        </trans-unit>
        <trans-unit id="854ccb088ba1be0b06f8e075236eff1e9da46cb3" translate="yes" xml:space="preserve">
          <source>This data type specifies the associativity of operators: left, right or none.</source>
          <target state="translated">このデータ型は、演算子の連想性を指定します。</target>
        </trans-unit>
        <trans-unit id="fd2eec063b807dbd9460c324b818af96f45fa26c" translate="yes" xml:space="preserve">
          <source>This data type witnesses the lifting of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; into an &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; pointwise.</source>
          <target state="translated">このデータ型は、 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; にポイントごとに持ち上がるのを目撃しています。</target>
        </trans-unit>
        <trans-unit id="5d9cbd7fa738ca0ed212ab2c49dfe0d0e34fe8be" translate="yes" xml:space="preserve">
          <source>This datatype &lt;code&gt;G&lt;/code&gt; is GADT-like in both its kind and its type. Suppose you have &lt;code&gt;g :: G a&lt;/code&gt;, where &lt;code&gt;a :: k&lt;/code&gt;. Then pattern matching to discover that &lt;code&gt;g&lt;/code&gt; is in fact &lt;code&gt;GMaybe&lt;/code&gt; tells you both that &lt;code&gt;k ~ (Type -&amp;gt; Type)&lt;/code&gt; and &lt;code&gt;a ~ Maybe&lt;/code&gt;. The definition for &lt;code&gt;G&lt;/code&gt; requires that &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; be in effect, but pattern-matching on &lt;code&gt;G&lt;/code&gt; requires no extension beyond &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. That this works is actually a straightforward extension of regular GADTs and a consequence of the fact that kinds and types are the same.</source>
          <target state="translated">このデータ型 &lt;code&gt;G&lt;/code&gt; は、種類も種類もGADTに似ています。 &lt;code&gt;g :: G a&lt;/code&gt; があるとします。ここで &lt;code&gt;a :: k&lt;/code&gt; です。そして、それを発見するためのパターンマッチング &lt;code&gt;g&lt;/code&gt; 実際にされ &lt;code&gt;GMaybe&lt;/code&gt; はあなたにその両方伝えます &lt;code&gt;k ~ (Type -&amp;gt; Type)&lt;/code&gt; と &lt;code&gt;a ~ Maybe&lt;/code&gt; 。 &lt;code&gt;G&lt;/code&gt; の定義では、&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;が有効である必要がありますが、 &lt;code&gt;G&lt;/code&gt; でのパターンマッチングには、&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;以外の拡張は必要ありません。これが機能することは、実際には通常のGADTの単純な拡張であり、種類と型が同じであるという事実の結果です。</target>
        </trans-unit>
        <trans-unit id="fddbbdd897e55b76318f9d1cca047654361c5bf3" translate="yes" xml:space="preserve">
          <source>This datatype serves as the common interface for the buffer-by-buffer execution of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:buildStepToCIOS&quot;&gt;buildStepToCIOS&lt;/a&gt;&lt;/code&gt;. Typical users of this interface are &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:ciosToLazyByteString&quot;&gt;ciosToLazyByteString&lt;/a&gt;&lt;/code&gt; or iteratee-style libraries like &lt;code&gt;enumerator&lt;/code&gt;.</source>
          <target state="translated">このデータ型は、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; よる &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:buildStepToCIOS&quot;&gt;buildStepToCIOS&lt;/a&gt;&lt;/code&gt; バッファごとの実行の共通インターフェースとして機能します。このインタフェースの典型的なユーザーがいる &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:ciosToLazyByteString&quot;&gt;ciosToLazyByteString&lt;/a&gt;&lt;/code&gt; などiterateeスタイルライブラリ &lt;code&gt;enumerator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56687acac81b9ead68435c4a4dee9d86beae2f2f" translate="yes" xml:space="preserve">
          <source>This decoder has the downside that it will need to read all the input before it can return. On the other hand, it will not return anything until it knows it could decode without any decoder errors.</source>
          <target state="translated">このデコーダには、返す前にすべての入力を読み込む必要があるという欠点があります。一方で、デコーダエラーなしでデコードできることがわかるまでは、何も返しません。</target>
        </trans-unit>
        <trans-unit id="f05d3a9d17ae615893a0ee3e31137b4c35f2e2de" translate="yes" xml:space="preserve">
          <source>This define allows conditional compilation based on the Operating System, where⟨os⟩ is the name of the current Operating System (eg. &lt;code&gt;linux&lt;/code&gt;, &lt;code&gt;mingw32&lt;/code&gt; for Windows, &lt;code&gt;solaris&lt;/code&gt;, etc.).</source>
          <target state="translated">この定義により、オペレーティングシステムに基づいた条件付きコンパイルが可能になります。ここで、「os」は現在のオペレーティングシステムの名前です（例： &lt;code&gt;linux&lt;/code&gt; 、Windowsの &lt;code&gt;mingw32&lt;/code&gt; 、 &lt;code&gt;solaris&lt;/code&gt; など）。</target>
        </trans-unit>
        <trans-unit id="b4bacbb553c9e44a0d9bbcbb895a594cbb329d2a" translate="yes" xml:space="preserve">
          <source>This define allows conditional compilation based on the host architecture, where⟨arch⟩ is the name of the current architecture (eg. &lt;code&gt;i386&lt;/code&gt;, &lt;code&gt;x86_64&lt;/code&gt;, &lt;code&gt;powerpc&lt;/code&gt;, &lt;code&gt;sparc&lt;/code&gt;, etc.).</source>
          <target state="translated">この定義により、ホストアーキテクチャに基づく条件付きコンパイルが可能になります。ここで、「arch」は現在のアーキテクチャの名前です（たとえば、 &lt;code&gt;i386&lt;/code&gt; 、 &lt;code&gt;x86_64&lt;/code&gt; 、 &lt;code&gt;powerpc&lt;/code&gt; 、 &lt;code&gt;sparc&lt;/code&gt; など）。</target>
        </trans-unit>
        <trans-unit id="8da376069bf24510d754fbbf6944b4e0d8d617a3" translate="yes" xml:space="preserve">
          <source>This definition makes &lt;code&gt;f1&lt;/code&gt; is strict in &lt;code&gt;x&lt;/code&gt;, whereas without the bang it would be lazy. Bang patterns can be nested of course:</source>
          <target state="translated">この定義により、 &lt;code&gt;f1&lt;/code&gt; は &lt;code&gt;x&lt;/code&gt; で厳密になりますが、強打がなければ、遅延になります。もちろん、Bangパターンはネストすることができます：</target>
        </trans-unit>
        <trans-unit id="7f1aeb089f33575b8e31f8c208c2176e6aae7a5d" translate="yes" xml:space="preserve">
          <source>This denotes a derived &lt;code&gt;Eq (Foo a)&lt;/code&gt; instance where the context is inferred, in much the same way that ordinary &lt;code&gt;deriving&lt;/code&gt; clauses do. Any other use of wildcards in a standalone &lt;code&gt;deriving&lt;/code&gt; declaration is prohibited.</source>
          <target state="translated">これは、通常の &lt;code&gt;deriving&lt;/code&gt; 句と同じように、コンテキストが推測される派生 &lt;code&gt;Eq (Foo a)&lt;/code&gt; インスタンスを示します。スタンドアロンの &lt;code&gt;deriving&lt;/code&gt; 宣言でのワイルドカードのその他の使用は禁止されています。</target>
        </trans-unit>
        <trans-unit id="f318c04181cccb638a071c5edca74556bdc192e3" translate="yes" xml:space="preserve">
          <source>This design gives the implementation of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; full access to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Therefore, utmost care has to be taken to not overwrite anything outside the given &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s. Moreover, further care has to be taken to ensure that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are referentially transparent. See the comments of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; functions for further information. Note that there are &lt;em&gt;no safety belts&lt;/em&gt; at all, when implementing a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; using an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action: you are writing code that might enable the next buffer-overflow attack on a Haskell server!</source>
          <target state="translated">この設計は、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; の実装に &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドへの完全なアクセスを提供します。したがって、指定された &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; の外側にあるものを上書きしないように細心の注意を払う必要があります。さらに、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; が参照透過であることを保証するために、さらに注意が必要です。詳細については、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 関数のコメントを参照してください。 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションを使用して &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; を実装する場合、&lt;em&gt;安全ベルト&lt;/em&gt;は&lt;em&gt;まったくない&lt;/em&gt;ことに注意してください。Haskellサーバーでの次のバッファーオーバーフロー攻撃を可能にする可能性のあるコードを記述しています！</target>
        </trans-unit>
        <trans-unit id="9424f4d941d065861400a0aac7eda9e8e5e684ee" translate="yes" xml:space="preserve">
          <source>This design gives the implementation of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; full access to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Therefore, utmost care has to be taken to not overwrite anything outside the given &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s. Moreover, further care has to be taken to ensure that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are referentially transparent. See the comments of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; functions for further information. Note that there are &lt;em&gt;no safety belts&lt;/em&gt; at all, when implementing a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; using an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action: you are writing code that might enable the next buffer-overflow attack on a Haskell server!</source>
          <target state="translated">この設計により、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; の実装に &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドへのフルアクセスが提供されます。したがって、指定された &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; の外側にあるものを上書きしないように細心の注意を払う必要があります。さらに、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; が参照透過性になるようにさらに注意を払う必要があります。詳細については、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; のコメントと &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 関数を参照してください。 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションを使用して &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; を実装する場合、&lt;em&gt;安全ベルト&lt;/em&gt;は&lt;em&gt;まったくない&lt;/em&gt;ことに注意してください。Haskellサーバーで次のバッファオーバーフロー攻撃を可能にする可能性のあるコードを記述しています。</target>
        </trans-unit>
        <trans-unit id="b6e67cc35f8aec8824496322b8ea64c460e216a8" translate="yes" xml:space="preserve">
          <source>This distinction is important because of the way &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; works. The derived &lt;code&gt;Functor Right&lt;/code&gt; instance would be:</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; の&lt;/a&gt;動作方法のため、この区別は重要です。派生 &lt;code&gt;Functor Right&lt;/code&gt; インスタンスは次のようになります。</target>
        </trans-unit>
        <trans-unit id="e419b1a95765157bd22e384184d54ccedeb6347e" translate="yes" xml:space="preserve">
          <source>This does not embed any runtime paths. It relies on the shared libraries being available in a standard location or in a directory given by the &lt;code id=&quot;index-3&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">これはランタイムパスを埋め込みません。これは、標準の場所または &lt;code id=&quot;index-3&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; 環境変数で指定されたディレクトリで使用可能な共有ライブラリに依存しています。</target>
        </trans-unit>
        <trans-unit id="5cb3f563b2d6d060f313310954206b9eb4d91af0" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t work any more. Suppose module &lt;code&gt;C&lt;/code&gt; imports module &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;B&lt;/code&gt; imports module &lt;code&gt;A&lt;/code&gt;. So changes to module &lt;code&gt;A&lt;/code&gt; might require module &lt;code&gt;C&lt;/code&gt; to be recompiled, and hence when &lt;code&gt;A.hi&lt;/code&gt; changes we should check whether &lt;code&gt;C&lt;/code&gt; should be recompiled. However, the dependencies of &lt;code&gt;C&lt;/code&gt; will only list &lt;code&gt;B.hi&lt;/code&gt;, not &lt;code&gt;A.hi&lt;/code&gt;, and some changes to &lt;code&gt;A&lt;/code&gt; (changing the definition of a function that appears in an inlining of a function exported by &lt;code&gt;B&lt;/code&gt;, say) may conceivably not change &lt;code&gt;B.hi&lt;/code&gt; one jot. So now&amp;hellip;</source>
          <target state="translated">これはもう機能しません。モジュールと仮定 &lt;code&gt;C&lt;/code&gt; の輸入をモジュール &lt;code&gt;B&lt;/code&gt; を、及び &lt;code&gt;B&lt;/code&gt; の輸入は、モジュール &lt;code&gt;A&lt;/code&gt; を。だから、モジュールに変更 &lt;code&gt;A&lt;/code&gt; はモジュールが必要な場合があります &lt;code&gt;C&lt;/code&gt; の再コンパイルする、とするとき、したがって &lt;code&gt;A.hi&lt;/code&gt; が変化し、我々は、かどうかを確認する必要があります &lt;code&gt;C&lt;/code&gt; は、再コンパイルする必要があります。ただし、 &lt;code&gt;C&lt;/code&gt; の依存関係は &lt;code&gt;B.hi&lt;/code&gt; ではなく &lt;code&gt;A.hi&lt;/code&gt; のみをリストし、 &lt;code&gt;A&lt;/code&gt; への一部の変更（ &lt;code&gt;B&lt;/code&gt; によってエクスポートされた関数のインラインに表示される関数の定義を変更するなど）は &lt;code&gt;B.hi&lt;/code&gt; 変更しない可能性があります。こんにちは。だから今&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="7bfd4c3de51cf005d444a055edf0fb4db0a787bb" translate="yes" xml:space="preserve">
          <source>This eliminates &lt;code&gt;bad&lt;/code&gt; because the variable &lt;code&gt;x&lt;/code&gt; would have a representation-polymorphic type.</source>
          <target state="translated">この排除の &lt;code&gt;bad&lt;/code&gt; 変数ので、 &lt;code&gt;x&lt;/code&gt; が表現多型タイプを持っているでしょう。</target>
        </trans-unit>
        <trans-unit id="e073b87018c69ace3578175d2672805f9075ec44" translate="yes" xml:space="preserve">
          <source>This enables shortcutting at the assembly stage of the code generator. In simpler terms shortcutting means if a block of instructions A only consists of a unconditionally jump, we replace all jumps to A by jumps to the successor of A.</source>
          <target state="translated">これにより、コード生成器のアセンブリ段階でのショートカットが可能になります。簡単に言えば、ショートカットとは、命令ブロックAが無条件にジャンプだけで構成されている場合、AへのジャンプをすべてAの後継へのジャンプで置き換えることを意味します。</target>
        </trans-unit>
        <trans-unit id="165be7ce8b109bfbd86d5610feedbc506b067e28" translate="yes" xml:space="preserve">
          <source>This encoding never fails in either direction. However, encoding discards information, so encode followed by decode is not the identity.</source>
          <target state="translated">このエンコードはどちらの方向に行っても失敗することはありません。しかし、符号化は情報を破棄するので、encodeに続いてdecodeもアイデンティティではありません。</target>
        </trans-unit>
        <trans-unit id="a1d32279f371041a8dc0b3cfd88d94711705ab4d" translate="yes" xml:space="preserve">
          <source>This encoding uses the byte sequence &quot;xc0x80&quot; to represent NUL, and the string is NUL-terminated.</source>
          <target state="translated">このエンコーディングでは、NUL を表すためにバイト列 &quot;xc0x80&quot; を使用し、文字列は NUL で終端する。</target>
        </trans-unit>
        <trans-unit id="c979726ef060735bb7539760a55f4154c415c6fd" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the bifold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite structure to a single, monolithic result (e.g., &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bilength&quot;&gt;bilength&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">これにより、バイフォールドの各ステップが適用される前に弱いヘッドノーマルフォームに強制され、そうでなければ発生するサンクのコレクションが回避されます。これは、有限構造を厳密に1つのモノリシックな結果（たとえば、 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bilength&quot;&gt;bilength&lt;/a&gt;&lt;/code&gt; ）に厳密に削減したい場合です。</target>
        </trans-unit>
        <trans-unit id="2d4057c16cbbf5083f061bdfcc0ac611c77fa920" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the fold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite list to a single, monolithic result (e.g. &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">これにより、適用される前に、折り畳みの各ステップが弱いヘッドの通常の形式に強制され、そうでなければ発生するサンクのコレクションが回避されます。これは多くの場合、有限リストを1つのモノリシックな結果（ &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; ）に厳密に減らしたいものです。</target>
        </trans-unit>
        <trans-unit id="b511b54734619f44cd095a6055d529fe732da6b9" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the fold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite list to a single, monolithic result (e.g. &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">これにより、適用される前に、折り畳みの各ステップが弱いヘッドの通常の形式に強制され、そうでなければ発生するサンクのコレクションが回避されます。これは多くの場合、有限リストを1つのモノリシックな結果（ &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; ）に厳密に減らしたいものです。</target>
        </trans-unit>
        <trans-unit id="4d5075d0d48f60bf2df55fbf25ddfe3d362f68e5" translate="yes" xml:space="preserve">
          <source>This error message:</source>
          <target state="translated">このエラーメッセージ。</target>
        </trans-unit>
        <trans-unit id="d57971845f914fc8e7952a0c50d5f61958617a4b" translate="yes" xml:space="preserve">
          <source>This establishes that the module is trusted, but the guarantee is provided by the module&amp;rsquo;s author. A client of this module then specifies that they trust the module author by specifying they trust the package containing the module. &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t restrict the module to the safe language. It does however restrict the resolution of overlapping instances to only allow &lt;a href=&quot;#safe-overlapping-instances&quot;&gt;safe overlapping instances&lt;/a&gt;. It also allows the use of the safe import keyword.</source>
          <target state="translated">これにより、モジュールが信頼されていることが確認されますが、保証はモジュールの作成者によって提供されます。次に、このモジュールのクライアントは、モジュールを含むパッケージを信頼することを指定して、モジュールの作成者を信頼することを指定します。&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;はモジュールを安全な言語に制限しません。ただし、重複するインスタンスの解決を制限して、&lt;a href=&quot;#safe-overlapping-instances&quot;&gt;安全な重複インスタンス&lt;/a&gt;のみを許可します。また、safe importキーワードを使用できます。</target>
        </trans-unit>
        <trans-unit id="098bdcff45c78b22c043ada54d082f7fb8d47c1f" translate="yes" xml:space="preserve">
          <source>This example gives a taste of how escape continuations work, shows a typical pattern for their usage.</source>
          <target state="translated">この例では、エスケープの連続がどのように動作するかを説明し、その使用方法の典型的なパターンを示しています。</target>
        </trans-unit>
        <trans-unit id="84fa0b5a218eb5e7191af54121c7d7b565fbc4a1" translate="yes" xml:space="preserve">
          <source>This example is a cut-down version of the one in</source>
          <target state="translated">この例は</target>
        </trans-unit>
        <trans-unit id="506546e36bb8f56d349ab946238c7fb79ce340a0" translate="yes" xml:space="preserve">
          <source>This example is equivalent to the much more complicated construction if we had directly used the &lt;code&gt;Type&lt;/code&gt; constructors.</source>
          <target state="translated">この例は、 &lt;code&gt;Type&lt;/code&gt; コンストラクターを直接使用した場合のより複雑な構成に相当します。</target>
        </trans-unit>
        <trans-unit id="6c043be7b75a2841250a60e497debd443150f6b5" translate="yes" xml:space="preserve">
          <source>This example only requires &lt;code&gt;Functor&lt;/code&gt;, because it is translated into &lt;code&gt;(\x -&amp;gt;
not x) &amp;lt;$&amp;gt; m&lt;/code&gt;. A more complex example requires &lt;code&gt;Applicative&lt;/code&gt;,</source>
          <target state="translated">この例は &lt;code&gt;(\x -&amp;gt; not x) &amp;lt;$&amp;gt; m&lt;/code&gt; 変換されるため、 &lt;code&gt;Functor&lt;/code&gt; のみが必要です。より複雑な例では &lt;code&gt;Applicative&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="a94eb0f120e8bdc111cd5385f435ab44e125aa39" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; might be used to avoid pattern matching when one does not care about the value contained in the constructor:</source>
          <target state="translated">次の例は、コンストラクターに含まれる値を気にしない場合に、 &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; を使用してパターンマッチングを回避する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="0c94687d5da90e34bfb3927839e9bbd9388dc2fe" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; might be used to avoid pattern matching when one does not care about the value contained in the constructor:</source>
          <target state="translated">次の例は、コンストラクターに含まれる値を気にしない場合に、 &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; を使用してパターンマッチングを回避する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="62177d27a7a3e8ceeabacc9aa7dc05774276f074" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;Document_Open&lt;/code&gt;/&lt;code&gt;Close&lt;/code&gt; functions of Microsoft Word, but provided &lt;code&gt;HsStart&lt;/code&gt; is called before the first function, and &lt;code&gt;HsEnd&lt;/code&gt; after the last, then it will work fine.</source>
          <target state="translated">この例では、Microsoft Word の &lt;code&gt;Document_Open&lt;/code&gt; / &lt;code&gt;Close&lt;/code&gt; 関数を使用していますが、最初の関数の前に &lt;code&gt;HsStart&lt;/code&gt; が呼び出され、最後の関数の後にHsEndが呼び出された場合、 &lt;code&gt;HsEnd&lt;/code&gt; に機能します。</target>
        </trans-unit>
        <trans-unit id="3f669b13481ffa255adda9955123bc437e201059" translate="yes" xml:space="preserve">
          <source>This example was adapted from the original Concurrent Haskell paper. For more examples of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s being used to build higher-level synchronization primitives, see &lt;code&gt;&lt;a href=&quot;control-concurrent#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent#v:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この例は、オリジナルのConcurrent Haskell論文から改変されました。より高レベルの同期プリミティブを構築するために使用される &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; のその他の例については、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;control-concurrent#v:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="0dc923a7a79fc9be19231d8ba524edadbe4be72c" translate="yes" xml:space="preserve">
          <source>This exception doesn&amp;rsquo;t apply to statements, as the following example demonstrates:</source>
          <target state="translated">次の例に示すように、この例外はステートメントには適用されません。</target>
        </trans-unit>
        <trans-unit id="9cc4ef0f0e328db3ea146385deedff51e66652da" translate="yes" xml:space="preserve">
          <source>This exception is raised by another thread calling &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt;, or by the system if it needs to terminate the thread for some reason.</source>
          <target state="translated">この例外は、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt; を呼び出す別のスレッドによって、または何らかの理由でスレッドを終了する必要がある場合はシステムによって発生します。</target>
        </trans-unit>
        <trans-unit id="88b1b0d0ae7fe196ea09d9cc1c250ca0eba66f4e" translate="yes" xml:space="preserve">
          <source>This exception is raised by default in the main thread of the program when the user requests to terminate the program via the usual mechanism(s) (e.g. Control-C in the console).</source>
          <target state="translated">この例外は、ユーザが通常のメカニズム(コンソールのControl-Cなど)を使ってプログラムを終了するように要求した場合、プログラムのメインスレッドでデフォルトで発生します。</target>
        </trans-unit>
        <trans-unit id="eebf4adb6b800334ed146e927debde78229a6d82" translate="yes" xml:space="preserve">
          <source>This extension allows programmers to use the list notation for construction of structures like: &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;IntMap&lt;/code&gt;, &lt;code&gt;Vector&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt;. The following code listing gives a few examples:</source>
          <target state="translated">この拡張機能により、プログラマはリスト表記法を使用して、 &lt;code&gt;Set&lt;/code&gt; 、 &lt;code&gt;Map&lt;/code&gt; 、 &lt;code&gt;IntMap&lt;/code&gt; 、 &lt;code&gt;Vector&lt;/code&gt; 、 &lt;code&gt;Text&lt;/code&gt; 、 &lt;code&gt;Array&lt;/code&gt; などの構造を構築できます。次のコードリストは、いくつかの例を示しています。</target>
        </trans-unit>
        <trans-unit id="63b44c441eed758583d814d0941c5ed9943a1a63" translate="yes" xml:space="preserve">
          <source>This extension allows us to write constraints of the form &lt;code&gt;forall b. Eq b =&amp;gt;
Eq (f b)&lt;/code&gt;, which is needed to solve the &lt;code&gt;Eq (f (Rose f x))&lt;/code&gt; constraint arising from the second usage of the &lt;code&gt;(==)&lt;/code&gt; method.</source>
          <target state="translated">この拡張により、フォーム &lt;code&gt;forall b. Eq b =&amp;gt; Eq (f b)&lt;/code&gt; 制約を書き込むことができます。Eq b =&amp;gt; Eq（fb）、これは &lt;code&gt;(==)&lt;/code&gt; メソッドの2番目の使用法から生じる &lt;code&gt;Eq (f (Rose f x))&lt;/code&gt; 制約を解決するために必要です。</target>
        </trans-unit>
        <trans-unit id="b0185c0a43dd28be6c507c23e1072cce8239ed47" translate="yes" xml:space="preserve">
          <source>This extension also enables explicit quantification of type and kind variables in &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;, &lt;a href=&quot;#type-instance-declarations&quot;&gt;Type instance declarations&lt;/a&gt;, &lt;a href=&quot;#closed-type-families&quot;&gt;Closed type families&lt;/a&gt;, &lt;a href=&quot;#assoc-inst&quot;&gt;Associated instances&lt;/a&gt;, and &lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;.</source>
          <target state="translated">この拡張機能により、&lt;a href=&quot;#data-instance-declarations&quot;&gt;Dataインスタンス宣言&lt;/a&gt;、&lt;a href=&quot;#type-instance-declarations&quot;&gt;Typeインスタンス宣言&lt;/a&gt;、&lt;a href=&quot;#closed-type-families&quot;&gt;Closed型ファミリー&lt;/a&gt;、&lt;a href=&quot;#assoc-inst&quot;&gt;関連インスタンス&lt;/a&gt;、および&lt;a href=&quot;#rewrite-rules&quot;&gt;Rewriteルール&lt;/a&gt;での型変数とkind変数の明示的な数量化も可能になります。</target>
        </trans-unit>
        <trans-unit id="0f49ba4e744c9be271237eb0c498b43e818d8451" translate="yes" xml:space="preserve">
          <source>This extension also relaxes some of the restrictions around data family instances. In particular, &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; permits a &lt;code&gt;newtype instance&lt;/code&gt; to be given a return kind of &lt;code&gt;TYPE r&lt;/code&gt;, not just &lt;code&gt;Type&lt;/code&gt;. For example, the following &lt;code&gt;newtype instance&lt;/code&gt; declarations would be permitted:</source>
          <target state="translated">この拡張機能は、データファミリインスタンスに関するいくつかの制限も緩和します。特に、&lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; を&lt;/a&gt;使用すると、 &lt;code&gt;newtype instance&lt;/code&gt; に、 &lt;code&gt;Type&lt;/code&gt; だけでなく、 &lt;code&gt;TYPE r&lt;/code&gt; 戻り種類を指定できます。たとえば、次の &lt;code&gt;newtype instance&lt;/code&gt; 宣言が許可されます。</target>
        </trans-unit>
        <trans-unit id="f57565b543c045853c70ad6371daaf2f3c3e748c" translate="yes" xml:space="preserve">
          <source>This extension enables kind signatures in the following places:</source>
          <target state="translated">この拡張機能により、以下の場所での親切署名が可能になります。</target>
        </trans-unit>
        <trans-unit id="0b01b463ed5cbb063609e83a7f4a0cd2c9f0773a" translate="yes" xml:space="preserve">
          <source>This extension generalizes &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;. To derive &lt;code&gt;Num Unicode&lt;/code&gt; with GND (&lt;code&gt;deriving newtype Num&lt;/code&gt;) it must reuse the &lt;code&gt;Num Int&lt;/code&gt; instance. With &lt;code&gt;DerivingVia&lt;/code&gt;, we can explicitly specify the representation type &lt;code&gt;Int&lt;/code&gt;:</source>
          <target state="translated">この拡張は&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; を&lt;/a&gt;一般化します。GND を使用して &lt;code&gt;Num Unicode&lt;/code&gt; を導出するには（ &lt;code&gt;deriving newtype Num&lt;/code&gt; ）、 &lt;code&gt;Num Int&lt;/code&gt; インスタンスを再利用する必要があります。 &lt;code&gt;DerivingVia&lt;/code&gt; 、我々は明示的に表現タイプを指定することができ &lt;code&gt;Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6100b971f8f1c7a7cc634cc306d12a82af5c029a" translate="yes" xml:space="preserve">
          <source>This extension impacts the determination of whether or not a newtype has a Complete User-Specified Kind Signature (CUSK). The exact impact is specified &lt;a href=&quot;#complete-kind-signatures&quot;&gt;the section on CUSKs&lt;/a&gt;.</source>
          <target state="translated">この拡張機能は、newtypeに完全なユーザー指定の種類の署名（CUSK）があるかどうかの判断に影響を与えます。正確な影響は&lt;a href=&quot;#complete-kind-signatures&quot;&gt;、CUSKのセクションで&lt;/a&gt;指定されています。</target>
        </trans-unit>
        <trans-unit id="9ff362e6ce2b0d8092c35b1a623732b4842ee02e" translate="yes" xml:space="preserve">
          <source>This extension is enabled by default since GHC 8.6.1, under the &lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail Proposal (MFP)&lt;/a&gt;.</source>
          <target state="translated">この拡張機能は、GHC 8.6.1以降、&lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail Proposal（MFP）の&lt;/a&gt;下でデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="db2c878062f2c6f99bf839e6b59f2f657c40d838" translate="yes" xml:space="preserve">
          <source>This extension is temporary, and will be deprecated in a future release.</source>
          <target state="translated">この拡張機能は一時的なもので、将来のリリースでは非推奨となります。</target>
        </trans-unit>
        <trans-unit id="51aed31ab5dc37f8c4c608df090d56016afc9279" translate="yes" xml:space="preserve">
          <source>This feature is experimental in GHC 8.0.x, but it may become the default in future releases.</source>
          <target state="translated">この機能はGHC 8.0.xでは実験的なものですが、今後のリリースではデフォルトになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="248986ebd9528e7c25e52eb6e4b4dede26b21415" translate="yes" xml:space="preserve">
          <source>This feature is no longer in GHC, but rewrite rules let you do the same thing:</source>
          <target state="translated">この機能はもうGHCにはありませんが、ルールを書き換えることで同じことができます。</target>
        </trans-unit>
        <trans-unit id="53f2d728a4138ae527fa096fa51af75f94d85b2c" translate="yes" xml:space="preserve">
          <source>This feature is not intended for use outside of the core libraries that come with GHC. For more details see the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/PrimOps&quot;&gt;GHC developer wiki&lt;/a&gt;.</source>
          <target state="translated">この機能は、GHCに付属するコアライブラリ以外での使用を目的としていません。詳細については、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/PrimOps&quot;&gt;GHC開発者wikiを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9ee160906b857c67fe57bb11a964fcfc779b0e3a" translate="yes" xml:space="preserve">
          <source>This feature is not intended for use outside of the core libraries that come with GHC. For more details see the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/prim-ops&quot;&gt;GHC developer wiki&lt;/a&gt;.</source>
          <target state="translated">この機能は、GHCに付属するコアライブラリの外部での使用を目的としたものではありません。詳細については、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/prim-ops&quot;&gt;GHC開発者ウィキを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a2a0010dea23f4d2c3a5e18529c4edce4ab678e9" translate="yes" xml:space="preserve">
          <source>This feature was added in GHC 7.4.1.</source>
          <target state="translated">この機能はGHC 7.4.1で追加されました。</target>
        </trans-unit>
        <trans-unit id="55b7950f0dfe4e76a8ae330af2ece8c8a531dce2" translate="yes" xml:space="preserve">
          <source>This flag also enables the printing of &lt;em&gt;inferred&lt;/em&gt; type variables inside braces. See &lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;Inferred vs. specified type variables&lt;/a&gt;.</source>
          <target state="translated">このフラグは、中括弧内の&lt;em&gt;推定&lt;/em&gt;型変数の出力も有効にします。&lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;推定型変数と指定された型変数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b07b2f670bc045df573c1ececcdcb07736068e4d" translate="yes" xml:space="preserve">
          <source>This flag appends a colon-separated list of &lt;code&gt;dirs&lt;/code&gt; to the search path.</source>
          <target state="translated">このフラグは、コロンで区切ったリスト追加 &lt;code&gt;dirs&lt;/code&gt; 検索パスに。</target>
        </trans-unit>
        <trans-unit id="b10d8784b554d32814d37717727898e2e17029f6" translate="yes" xml:space="preserve">
          <source>This flag can be enabled to override any declared safety property of the module (Safe, Unsafe, Trustworthy) so compilation proceeds as if none of these flags were specified. This is particularly useful when compiling using plugins, which usually results in the compiled modules being marked as unsafe.</source>
          <target state="translated">このフラグを有効にすると、モジュールの宣言された安全プロパティ (Safe,Unsafe,Trustworthy)を上書きして、これらのフラグが何も指定されていないかのようにコンパイルを進めることができます。これは特にプラグインを使ってコンパイルする場合に便利で、 通常はコンパイルされたモジュールが安全ではないとマークされます。</target>
        </trans-unit>
        <trans-unit id="24dac7bf8e47224079c398a6d277a8612ab70ec9" translate="yes" xml:space="preserve">
          <source>This flag can be toggled to decrease the verbosity of the valid hole fit suggestions by not showing the provenance nor type application of the suggestions.</source>
          <target state="translated">こ のフラグは、 有効なホールはめ込み提案の冗長性を減少させるために切り替え る こ と がで き 、 提案の出自や型の適用を表示 し ない よ う にす る こ と がで き ます。</target>
        </trans-unit>
        <trans-unit id="65ce608eee3aba6eebf0d253b9eec2e8fe86f19e" translate="yes" xml:space="preserve">
          <source>This flag can be toggled to turn off the display of valid hole fits entirely.</source>
          <target state="translated">このフラグは、有効なホールフィットの表示を完全にオフにするかどうかを切り替えることができます。</target>
        </trans-unit>
        <trans-unit id="090f73c78c09543d9d38b2c5a37d696699bd497f" translate="yes" xml:space="preserve">
          <source>This flag implies the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; flags, which enables this behaviour for &lt;a href=&quot;#typed-holes&quot;&gt;typed holes&lt;/a&gt; and variables. Should you so wish, it is possible to enable &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; without enabling &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;, by explicitly specifying &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fno-defer-typed-holes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fno-defer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; on the command-line after the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">このフラグは、&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt;フラグと&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;フラグを暗黙&lt;a href=&quot;#typed-holes&quot;&gt;指定し&lt;/a&gt;、型付きの穴と変数に対してこの動作を有効にします。必要に応じて、&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fno-defer-typed-holes&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fno-defer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;明示的に指定することにより、&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;を有効にせずに&lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;を有効にすることができます。-fdefer- &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;フラグの後のコマンドラインの-defer-out-of-scope-variables</target>
        </trans-unit>
        <trans-unit id="8a419a9746c4cf7f690ae762b4c975fdd0783957" translate="yes" xml:space="preserve">
          <source>This flag is hacker territory. The main purpose of this flag is to make it easy to debug and tune the new code layout algorithm. There is no guarantee that values giving better results now won&amp;rsquo;t be worse with the next release.</source>
          <target state="translated">この旗はハッカーの領土です。このフラグの主な目的は、新しいコードレイアウトアルゴリズムのデバッグと調整を簡単にすることです。より良い結果を与える値が次のリリースで悪化しないという保証はありません。</target>
        </trans-unit>
        <trans-unit id="4f00c8bb7e27cc51ca8b0f0d3dba471e43e3c711" translate="yes" xml:space="preserve">
          <source>This flag is useful for debugging why a definition is not inlined.</source>
          <target state="translated">このフラグは、定義がインライン化されていない理由をデバッグするのに便利です。</target>
        </trans-unit>
        <trans-unit id="259f9f5ba8da11cbb10f0d1540dcc3a2d81b3b63" translate="yes" xml:space="preserve">
          <source>This flag is useful for debugging why a rule you expect to be firing isn&amp;rsquo;t.</source>
          <target state="translated">このフラグは、起動するはずのルールが起動しない理由をデバッグするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="913346e87539751c35ed9c7fbbe9dacd336e394e" translate="yes" xml:space="preserve">
          <source>This flag offers a workaround, albeit a slightly convoluted one. To be able to load an object file outside of the low 2Gb, the object code needs to be compiled with &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt;. When the &lt;code&gt;+RTS -xp&lt;/code&gt; flag is passed, the linker will assume that all object files were compiled with &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt; and load them anywhere in the address space. It&amp;rsquo;s up to you to arrange that the object files you load (including all packages) were compiled in the right way. If this is not the case for an object, the linker will probably fail with an error message when the problem is detected.</source>
          <target state="translated">このフラグは、少し複雑なものですが、回避策を提供します。低2Gbの外部でオブジェクトファイルをロードできるようにするには、オブジェクトコードを &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt; でコンパイルする必要があります。場合は &lt;code&gt;+RTS -xp&lt;/code&gt; フラグが渡され、リンカは、すべてのオブジェクトファイルがコンパイルされたと仮定します &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt; とアドレス空間の任意の場所にそれらをロードします。ロードするオブジェクトファイル（すべてのパッケージを含む）が正しい方法でコンパイルされるように調整するのはあなた次第です。これがオブジェクトに当てはまらない場合、問題が検出されたときにリンカーがエラーメッセージで失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="0d8510f05be6657462af6908558e01f9535cc7df" translate="yes" xml:space="preserve">
          <source>This flag passes &lt;code&gt;-Wundef&lt;/code&gt; to the C pre-processor (if its being used) which causes the pre-processor to warn on uses of the &lt;code&gt;#if&lt;/code&gt; directive on undefined identifiers.</source>
          <target state="translated">このフラグは、 &lt;code&gt;-Wundef&lt;/code&gt; をCプリプロセッサに（使用されている場合）渡し、プリプロセッサが未定義の識別子に対する &lt;code&gt;#if&lt;/code&gt; ディレクティブの使用を警告するようにします。</target>
        </trans-unit>
        <trans-unit id="1da039cc7b4dc5b7877656e448f679fa2aaf620b" translate="yes" xml:space="preserve">
          <source>This flag selects one of a number of modes for finding shared libraries at runtime. See &lt;a href=&quot;shared_libs#finding-shared-libs&quot;&gt;Finding shared libraries at runtime&lt;/a&gt; for a description of each mode.</source>
          <target state="translated">このフラグは、実行時に共有ライブラリを検索するためのいくつかのモードの1つを選択します。各モードの説明については&lt;a href=&quot;shared_libs#finding-shared-libs&quot;&gt;、実行時の共有ライブラリの検索を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="707ef7038c152a9d95c30f93e519ab392f0434e0" translate="yes" xml:space="preserve">
          <source>This flag sets the size (in bytes) threshold above which the second approach is used. You can disable the second approach entirely by setting the threshold to 0.</source>
          <target state="translated">このフラグは、2 番目のアプローチが使用されるサイズ(バイト数)のしきい値を設定します。しきい値を 0 に設定することで、2 番目のアプローチを完全に無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="fd5e5d63941b332238370339bd4abcd493f7faf1" translate="yes" xml:space="preserve">
          <source>This flag specifies that a backspace at column 0 wraps the cursor to the last column of the previous line.</source>
          <target state="translated">このフラグは、0列目のバックスペースがカーソルを前の行の最後の列に折り返すことを指定します。</target>
        </trans-unit>
        <trans-unit id="03626a7094edacd615db3da035980eaa87b66cfc" translate="yes" xml:space="preserve">
          <source>This flag specifies that the cursor wraps automatically from the last column of one line to the first column of the next.</source>
          <target state="translated">このフラグは、カーソルがある行の最後の列から次の行の最初の列へと自動的に折り返されることを指定します。</target>
        </trans-unit>
        <trans-unit id="152fd56bf497fbd287fadf04927a68a1b45161ca" translate="yes" xml:space="preserve">
          <source>This flag specifies that the terminal does not perform &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:autoRightMargin&quot;&gt;autoRightMargin&lt;/a&gt;&lt;/code&gt;-style wrapping when the character which would cause the wraparound is a control character. This is also known as the &quot;newline glitch&quot; or &quot;magic wrap&quot;.</source>
          <target state="translated">このフラグは、折り返しの原因となる文字が制御文字である場合に、端末が &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:autoRightMargin&quot;&gt;autoRightMargin&lt;/a&gt;&lt;/code&gt; スタイルの折り返しを実行しないことを指定します。これは「ニューライングリッチ」または「マジックラップ」とも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="237ea7657c0749769ad0460f79b1ebe14776910d" translate="yes" xml:space="preserve">
          <source>This flag tells GHC to link against shared Haskell libraries. This flag only affects the selection of dependent libraries, not the form of the current target (see -shared). See &lt;a href=&quot;shared_libs#using-shared-libs&quot;&gt;Using shared libraries&lt;/a&gt; on how to create them.</source>
          <target state="translated">このフラグは、共有されたHaskellライブラリに対してリンクするようGHCに指示します。このフラグは依存ライブラリの選択にのみ影響し、現在のターゲットの形式には影響しません（-sharedを参照）。&lt;a href=&quot;shared_libs#using-shared-libs&quot;&gt;共有ライブラリの&lt;/a&gt;作成方法については、共有ライブラリの使用を参照してください。</target>
        </trans-unit>
        <trans-unit id="548eff16b1f921e7136ec0c8b1d05c12f1aee8db" translate="yes" xml:space="preserve">
          <source>This flag used to be simply &lt;code&gt;-k&lt;/code&gt;, but was renamed to &lt;code&gt;-ki&lt;/code&gt; in GHC 7.2.1. The old name is still accepted for backwards compatibility, but that may be removed in a future version.</source>
          <target state="translated">このフラグは以前は単に &lt;code&gt;-k&lt;/code&gt; でしたが、GHC 7.2.1では &lt;code&gt;-ki&lt;/code&gt; に名前が変更されました。古い名前は下位互換性のために引き続き受け入れられますが、将来のバージョンでは削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="132a6f0fb187f19db841ab54e53adaeca2ba441f" translate="yes" xml:space="preserve">
          <source>This flag warns if you declare a module without declaring an explicit export list. For example</source>
          <target state="translated">このフラグは、明示的なエクスポートリストを宣言せずにモジュールを宣言した場合に警告します。例えば</target>
        </trans-unit>
        <trans-unit id="c9662da7b45b17a0a6428b9dfe5bd157c250c8da" translate="yes" xml:space="preserve">
          <source>This flag warns if you use an unqualified &lt;code&gt;import&lt;/code&gt; declaration that does not explicitly list the entities brought into scope. For example</source>
          <target state="translated">このフラグは、スコープに入れられたエンティティーを明示的にリストしない修飾されていない &lt;code&gt;import&lt;/code&gt; 宣言を使用すると警告します。例えば</target>
        </trans-unit>
        <trans-unit id="164c1b4e302cfd37b98b634159b85132a613d2b3" translate="yes" xml:space="preserve">
          <source>This flag warns whenever you write a pattern that binds a variable whose type is unlifted, and yet the pattern is not a bang pattern nor a bare variable. See &lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt; for information about unlifted types.</source>
          <target state="translated">このフラグは、型が持ち上げられていない変数をバインドするパターンを書き込むときに警告を発しますが、パターンはbangパターンでもベア変数でもありません。unlifted型については、unboxed &lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;型&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="cae0b42613ae5635daabfb73c1fd1a6fde87c094" translate="yes" xml:space="preserve">
          <source>This flag was not implemented correctly and is now deprecated. It will be removed in a later version of GHC.</source>
          <target state="translated">このフラグは正しく実装されておらず、現在は非推奨となっています。これは GHC の後のバージョンでは削除される予定です。</target>
        </trans-unit>
        <trans-unit id="a0c3352dc95a1207a9c6e17148992da28a73903b" translate="yes" xml:space="preserve">
          <source>This form is intended to catch cases where an imported function that is marked as &lt;code&gt;INLINABLE&lt;/code&gt; (presumably to enable specialisation) cannot be specialised as it calls other functions that are themselves not specialised.</source>
          <target state="translated">このフォームは、 &lt;code&gt;INLINABLE&lt;/code&gt; （おそらく特殊化を有効にする）としてマークされたインポートされた関数が、それ自体は特殊化されていない他の関数を呼び出すために特殊化できない場合をキャッチすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="05bd3fd9bbf23e07af768726368e949e8e01172d" translate="yes" xml:space="preserve">
          <source>This form is similar to the previous one, but allows you to create a function which will be passed as the first argument to f. As a consequence f must have the type &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt;. As you can see from the type, this function lets f &amp;ldquo;project out&amp;rdquo; some information from the elements of the list it is transforming.</source>
          <target state="translated">この形式は前の形式と似ていますが、fの最初の引数として渡される関数を作成できます。結果として、fはタイプ &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt; 持つ必要があります。（a-&amp;gt; t）-&amp;gt; [a]-&amp;gt; [a]。タイプからわかるように、この関数は、変換しているリストの要素からいくつかの情報を「投影」します。</target>
        </trans-unit>
        <trans-unit id="b210b3ae2d9ae56e35b1c184f6366fb5e908d874" translate="yes" xml:space="preserve">
          <source>This function accepts an optional leading sign character, followed by at least one decimal digit. The syntax similar to that accepted by the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function, with the exception that a trailing &lt;code&gt;'.'&lt;/code&gt; or &lt;code&gt;'e'&lt;/code&gt;&lt;em&gt;not&lt;/em&gt; followed by a number is not consumed.</source>
          <target state="translated">この関数は、オプションの先行符号文字と、それに続く少なくとも1つの10進数字を受け入れます。末尾の &lt;code&gt;'.'&lt;/code&gt; 除いて、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 関数で受け入れられるものと同様の構文。または &lt;code&gt;'e'&lt;/code&gt; &lt;em&gt;ではない&lt;/em&gt;数字が続くが消費されません。</target>
        </trans-unit>
        <trans-unit id="a796cd8e434fa9169ce349d782e3ca0927d44d88" translate="yes" xml:space="preserve">
          <source>This function adds a finalizer to the given &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. The finalizer will run &lt;em&gt;before&lt;/em&gt; all other finalizers for the same object which have already been registered.</source>
          <target state="translated">この関数は、指定された &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; にファイナライザを追加します。ファイナライザは、すでに登録されている同じオブジェクトの他のすべてのファイナライザの&lt;em&gt;前&lt;/em&gt;に実行されます。</target>
        </trans-unit>
        <trans-unit id="2c44cb1ccf0b7e4784ceeb306a067bdfeb7b206c" translate="yes" xml:space="preserve">
          <source>This function adds a finalizer to the given &lt;code&gt;ForeignPtr&lt;/code&gt;. The finalizer will run &lt;em&gt;before&lt;/em&gt; all other finalizers for the same object which have already been registered.</source>
          <target state="translated">この関数は、指定された &lt;code&gt;ForeignPtr&lt;/code&gt; にファイナライザを追加します。ファイナライザは、すでに登録されている同じオブジェクトの他のすべてのファイナライザの&lt;em&gt;前&lt;/em&gt;に実行されます。</target>
        </trans-unit>
        <trans-unit id="f425649d9029247ad78fad40decd5202c4bc27eb" translate="yes" xml:space="preserve">
          <source>This function adds a finalizer to the given foreign object. The finalizer will run &lt;em&gt;before&lt;/em&gt; all other finalizers for the same object which have already been registered.</source>
          <target state="translated">この関数は、指定された外部オブジェクトにファイナライザを追加します。ファイナライザは、すでに登録されている同じオブジェクトの他のすべてのファイナライザの&lt;em&gt;前&lt;/em&gt;に実行されます。</target>
        </trans-unit>
        <trans-unit id="f81d22635890e3a218f1ce58339b1c6ca6b2b5e3" translate="yes" xml:space="preserve">
          <source>This function always returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the current thread's event manager when using the threaded RTS and &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">この関数は常に返し &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; RTSとねじ使用した場合、現在のスレッドのイベントマネージャを &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; そう。</target>
        </trans-unit>
        <trans-unit id="1a7ca54d1ebb1f65a298f3f5394187b62319bd58" translate="yes" xml:space="preserve">
          <source>This function behaves as though it was defined as follows:</source>
          <target state="translated">この関数は、以下のように定義されているかのように動作します。</target>
        </trans-unit>
        <trans-unit id="a19a74c60710c427c9a8983f923cfe3116f4e33e" translate="yes" xml:space="preserve">
          <source>This function behaves in the exact same manner as &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getInputLine&quot;&gt;getInputLine&lt;/a&gt;&lt;/code&gt;, except that it pre-populates the input area. The text that resides in the input area is given as a 2-tuple with two &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The string on the left of the tuple (obtained by calling &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;) is what will appear to the left of the cursor and the string on the right (obtained by calling &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:snd&quot;&gt;snd&lt;/a&gt;&lt;/code&gt;) is what will appear to the right of the cursor.</source>
          <target state="translated">この関数は、入力領域に事前入力することを除いて、 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getInputLine&quot;&gt;getInputLine&lt;/a&gt;&lt;/code&gt; とまったく同じように動作します。入力領域にあるテキストは、2つの &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; を持つ2タプルとして指定されます。タプルの左側の文字列（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; を呼び出すことによって取得される）はカーソルの左側に表示されるものであり、右側の文字列（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:snd&quot;&gt;snd&lt;/a&gt;&lt;/code&gt; を呼び出すことによって取得される）はカーソルの右側に表示されるものです。</target>
        </trans-unit>
        <trans-unit id="ccadaf8449c87b756fcca9de3051eea76595bb20" translate="yes" xml:space="preserve">
          <source>This function blocks only if there is no data available, and EOF has not yet been reached. Once EOF is reached, this function returns an empty string instead of throwing an exception.</source>
          <target state="translated">この関数は、利用可能なデータがなく、EOFに達していない場合にのみブロックします。EOFに到達すると、この関数は例外を発生させずに空の文字列を返します。</target>
        </trans-unit>
        <trans-unit id="3727686d1f0656f78fbd676216e6218bba0d8f05" translate="yes" xml:space="preserve">
          <source>This function can be more predictable than &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt;, especially if the filename might itself contain &lt;code&gt;.&lt;/code&gt; characters.</source>
          <target state="translated">この関数は、特にファイル名自体に含まれる可能性がある場合、 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt; よりも予測可能です &lt;code&gt;.&lt;/code&gt; 文字。</target>
        </trans-unit>
        <trans-unit id="95f9843654954e98c26a755ad5eb70155e80d09e" translate="yes" xml:space="preserve">
          <source>This function can be more predictable than &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt;, especially if the filename might itself contain &lt;code&gt;.&lt;/code&gt; characters.</source>
          <target state="translated">この関数は、特にファイル名自体に含まれる可能性がある場合、 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt; よりも予測可能です &lt;code&gt;.&lt;/code&gt; 文字。</target>
        </trans-unit>
        <trans-unit id="6370e62b7224731eb33323a61cd0cd0212bd73ab" translate="yes" xml:space="preserve">
          <source>This function can be used to parse commandline arguments and return the split up arguments as elements in a list.</source>
          <target state="translated">この関数は、コマンドライン引数を解析し、分割された引数をリストの要素として返すために使用することができます。</target>
        </trans-unit>
        <trans-unit id="7b011ec479c4f18015f65a01a6cb42ad6c894e37" translate="yes" xml:space="preserve">
          <source>This function casts a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; parameterised by one type into another type.</source>
          <target state="translated">この関数は、あるタイプによってパラメーター化された &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; を別のタイプにキャストします。</target>
        </trans-unit>
        <trans-unit id="8455333cef6a211c11d46770009f2e17b149dc91" translate="yes" xml:space="preserve">
          <source>This function casts a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; parameterised by one type into another type.</source>
          <target state="translated">この関数は、あるタイプによってパラメーター化された &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; を別のタイプにキャストします。</target>
        </trans-unit>
        <trans-unit id="4c95a06b11246310d156afc3703af8aa75228ea4" translate="yes" xml:space="preserve">
          <source>This function casts a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; parameterised by one type into another type.</source>
          <target state="translated">この関数は、あるタイプによってパラメーター化された &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; を別のタイプにキャストします。</target>
        </trans-unit>
        <trans-unit id="bae8bc388aa8fda5c095416ea7ccdf604e21a4b9" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は、先行符号文字を処理しません。符号付き入力を処理する必要がある場合は、 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; 使用してください。</target>
        </trans-unit>
        <trans-unit id="e3b38848479394206747ac44eca6fc387251ec91" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は、先行符号文字を処理しません。符号付き入力を処理する必要がある場合は、 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 使用してください。</target>
        </trans-unit>
        <trans-unit id="5db91917bf331211a29772aa52154e422f3f1d5b" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は、先行符号文字を処理しません。符号付き入力を処理する必要がある場合は、 &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; 使用してください。</target>
        </trans-unit>
        <trans-unit id="519eb4a4b4c327867fd23f6eab3128242f48c9bb" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は、先行符号文字を処理しません。符号付き入力を処理する必要がある場合は、 &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 使用してください。</target>
        </trans-unit>
        <trans-unit id="857206c786beb79b34c3684c023645a579f1bf0a" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt; in two ways:</source>
          <target state="translated">この関数はゼロコピーを実行し、 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; をラップ解除して &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; として表示します。次の2つの点で&lt;em&gt;安全&lt;/em&gt;ではあり&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="0c2f12c1f574e8470c8cd228760ee018fd8aa95d" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt;:</source>
          <target state="translated">この関数は、ゼロコピーを行い、単にアンラップ &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; として表示する &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; を。&lt;em&gt;安全&lt;/em&gt;ではあり&lt;em&gt;ません&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="a47c3f2d7d39a2c3b063895b58a717924193e65c" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt; in two ways:</source>
          <target state="translated">この関数はゼロコピーを実行し、 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; をアンラップして &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; として表示するだけです。それは2つの点で&lt;em&gt;安全&lt;/em&gt;ではあり&lt;em&gt;ません&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="c7536fe5974322621a8dd1f75ea634bfbda36cef" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt;:</source>
          <target state="translated">この関数はゼロコピーを実行し、 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; をアンラップしてCStringLenとして表示する &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; です。&lt;em&gt;安全&lt;/em&gt;ではあり&lt;em&gt;ません&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="f085bd357a8ba52ec5bf8ea2e8098bb00f21c4f3" translate="yes" xml:space="preserve">
          <source>This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions. In particular &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; after it executes the user action.</source>
          <target state="translated">この関数は、問題の外部オブジェクトがIOアクションのシーケンスの特定の場所で生きていることを保証します。特に &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; はtouchForeignPtrを実行し &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 、それがユーザーのアクションを実行した後。</target>
        </trans-unit>
        <trans-unit id="fb2f540bf09969c8d0c8f8908ba854010bd23f1b" translate="yes" xml:space="preserve">
          <source>This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions. In particular &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; after it executes the user action.</source>
          <target state="translated">この関数は、問題の外部オブジェクトがIOアクションのシーケンスの特定の場所で生きていることを保証します。特に &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; はtouchForeignPtrを実行し &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 、それがユーザーのアクションを実行した後。</target>
        </trans-unit>
        <trans-unit id="2149a9af262bcc49b7038b2f4d5b65dcac58accb" translate="yes" xml:space="preserve">
          <source>This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions. In particular &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; after it executes the user action.</source>
          <target state="translated">この関数は、問題の外部オブジェクトがIOアクションのシーケンスの特定の場所で生きていることを保証します。特に &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; はtouchForeignPtrを実行し &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 、それがユーザーのアクションを実行した後。</target>
        </trans-unit>
        <trans-unit id="56e6ded1b8cebed967e3f67bfe07578a6914f462" translate="yes" xml:space="preserve">
          <source>This function extracts the pointer component of a foreign pointer. This is a potentially dangerous operations, as if the argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; is the last usage occurrence of the given foreign pointer, then its finalizer(s) will be run, which potentially invalidates the plain pointer just obtained. Hence, &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; must be used wherever it has to be guaranteed that the pointer lives on - i.e., has another usage occurrence.</source>
          <target state="translated">この関数は、外部ポインターのポインターコンポーネントを抽出します。これは、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; への引数が特定の外部ポインターの最後の使用オカレンスであるかのように、潜在的に危険な操作です。そのファイナライザーが実行され、取得したプレーンポインターが無効になる可能性があります。したがって、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; が存在していることが保証されている必要がある場合、つまり別の使用状況が発生している場合は、touchForeignPtrを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="49a9ef9954f7355cd3182b557ae76bf73f873f39" translate="yes" xml:space="preserve">
          <source>This function extracts the pointer component of a foreign pointer. This is a potentially dangerous operations, as if the argument to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; is the last usage occurrence of the given foreign pointer, then its finalizer(s) will be run, which potentially invalidates the plain pointer just obtained. Hence, &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; must be used wherever it has to be guaranteed that the pointer lives on - i.e., has another usage occurrence.</source>
          <target state="translated">この関数は、外部ポインターのポインターコンポーネントを抽出します。これは、 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; への引数が特定の外部ポインターの最後の使用オカレンスであるかのように、潜在的に危険な操作です。そのファイナライザーが実行され、取得したプレーンポインターが無効になる可能性があります。したがって、 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; が存在していることが保証されている必要がある場合、つまり別の使用状況が発生している場合は、touchForeignPtrを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="297ce1fcde50c3e64b2e180ca7a8295dfe927277" translate="yes" xml:space="preserve">
          <source>This function gives the same answer as comparing against the result of &lt;code&gt;&lt;a href=&quot;data-text#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;, but can short circuit if the count of characters is greater than the number, and hence be more efficient.</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;a href=&quot;data-text#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; の結果と比較するのと同じ答えを返しますますが、文字数が数値よりも多い場合は短絡する可能性があるため、より効率的です。</target>
        </trans-unit>
        <trans-unit id="b9bfe488bf922598761ef0e89e23f74a82ced08d" translate="yes" xml:space="preserve">
          <source>This function gives the same answer as comparing against the result of &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:lengthI&quot;&gt;lengthI&lt;/a&gt;&lt;/code&gt;, but can short circuit if the count of characters is greater than the number or if the stream can't possibly be as long as the number supplied, and hence be more efficient.</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:lengthI&quot;&gt;lengthI&lt;/a&gt;&lt;/code&gt; の結果と比較するのと同じ答えを返しますますが、文字数が数値よりも大きい場合、またはストリームが指定された数ほど長くなることができない場合は短絡する可能性があるため、より効率的です。</target>
        </trans-unit>
        <trans-unit id="84c6fa989d414314e9aa49500aecc381f432a513" translate="yes" xml:space="preserve">
          <source>This function gives the same answer as comparing against the result of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;, but can short circuit if the count of characters is greater than the number, and hence be more efficient.</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; の結果と比較するのと同じ答えを返しますますが、文字数が数値よりも多い場合は短絡する可能性があるため、より効率的です。</target>
        </trans-unit>
        <trans-unit id="afb23fb6497a24d6ecb9c3763d5c34edba9c40d0" translate="yes" xml:space="preserve">
          <source>This function has been available from the &lt;a href=&quot;system-process-internals&quot;&gt;System.Process.Internals&lt;/a&gt; module for some time, and is part of the &lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt; module since version 1.2.1.0.</source>
          <target state="translated">この機能は、より利用されている&lt;a href=&quot;system-process-internals&quot;&gt;System.Process.Internalsの&lt;/a&gt;いくつかの時間のためのモジュール、およびの一部であり、&lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt;、バージョン1.2.1.0以降モジュールの。</target>
        </trans-unit>
        <trans-unit id="a6e9d76dad212825f2ce225dc9cdac55e8d4e959" translate="yes" xml:space="preserve">
          <source>This function has moved to &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTree&quot;&gt;showTree&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTree&quot;&gt;showTree&lt;/a&gt;&lt;/code&gt; に移動しました。</target>
        </trans-unit>
        <trans-unit id="be411b927981a56314a00c20ba75fa59b5652a67" translate="yes" xml:space="preserve">
          <source>This function has moved to &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt;&lt;/code&gt; に移動しました。</target>
        </trans-unit>
        <trans-unit id="2c2e5206205cd6b75d161fb7bfc7299c5bdb8abf" translate="yes" xml:space="preserve">
          <source>This function has no effect on a frozen &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数はフリーズした &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; には影響しません。</target>
        </trans-unit>
        <trans-unit id="1be0ffbb5619ad9aa9e30d9508745c85fb811ff4" translate="yes" xml:space="preserve">
          <source>This function has no effect on a frozen &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数はフリーズした &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; には影響しません。</target>
        </trans-unit>
        <trans-unit id="36afc198b9f7118549c1b6104d61dadd4fcd1cd4" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt; in two ways:</source>
          <target state="translated">この機能は&lt;em&gt;安全で&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt; 2つの点でで。</target>
        </trans-unit>
        <trans-unit id="e2a132e2c97ab0ed1a1b3a90355bbe48b412b6f7" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;, as there may be other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s referring to the same underlying pages. If you use this, you need to have a proof of some kind that all &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s ever generated from the underlying byte array are no longer live.</source>
          <target state="translated">同じ基本ページを参照している他の &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; が存在する可能性があるため、この関数は&lt;em&gt;安全&lt;/em&gt;ではありません。これを使用する場合は、すべての &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; があることを証明する必要があります。、基礎となるバイト配列から生成されたがもはや存在しないです。</target>
        </trans-unit>
        <trans-unit id="bf420b59471bce124dbbd8b697170ee16a0713d7" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;, it is possible to break referential transparency by modifying the underlying buffer pointed to by the first argument. Any changes to the original buffer will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は&lt;em&gt;安全&lt;/em&gt;ではあり&lt;em&gt;ません&lt;/em&gt;。最初の引数によってポイントされた基礎となるバッファを変更することにより、参照の透過性を壊すことが可能です。元のバッファーへの変更は、結果の &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; に反映されますます。</target>
        </trans-unit>
        <trans-unit id="3455262f8a39897a50aa39230052cbe6dba0d568" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">この機能は&lt;em&gt;安全で&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; が後で変更された場合、この変更は結果の &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; に反映されます参照の透過性がます。</target>
        </trans-unit>
        <trans-unit id="1834d9d84b56bb752c51f02a1d644b2b93d96323" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">この機能は&lt;em&gt;安全で&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; が後で変更された場合、この変更は結果の &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; に反映され、参照透過性が失われます。</target>
        </trans-unit>
        <trans-unit id="e2747e624978d112ce90afa471f172dfb2b9cd31" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">この機能は&lt;em&gt;安全で&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。元の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; が後で変更された場合、この変更は結果の &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; に反映されます参照の透過性がます。</target>
        </trans-unit>
        <trans-unit id="f0382305dc3450f3e698022f8c72e2ed93bc7c33" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">この機能は&lt;em&gt;安全で&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。元の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; が後で変更された場合、この変更は結果の &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; に反映されます参照の透過性がます。</target>
        </trans-unit>
        <trans-unit id="f349071f25d8991d866f99530006dd7090d11a0c" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">この機能は&lt;em&gt;安全で&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。元の &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; が後で変更された場合、この変更は結果の &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; に反映され、参照透過性が失われます。</target>
        </trans-unit>
        <trans-unit id="e7b49b304d9d1b37bde4bfa9bfeb7383e8f4a58d" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">この機能は&lt;em&gt;安全で&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。元の &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; が後で変更された場合、この変更は結果の &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; に反映され、参照透過性が失われます。</target>
        </trans-unit>
        <trans-unit id="4a191d5e90e0d3c89ab168efaec7413d2cd0acb4" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If you modify the buffer pointed to by the original &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; this modification will be reflected in the resulting &lt;code&gt;ByteString&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">この機能は&lt;em&gt;安全で&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。元の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; が指すバッファーを変更すると、この変更は結果の &lt;code&gt;ByteString&lt;/code&gt; に反映されます。参照の透過性がます。</target>
        </trans-unit>
        <trans-unit id="ce62a4da0ca7ff6594e5735e96a49ced57bae709" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If you modify the buffer pointed to by the original &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; this modification will be reflected in the resulting &lt;code&gt;ByteString&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">この機能は&lt;em&gt;安全で&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。元の &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; が指すバッファーを変更すると、この変更は結果の &lt;code&gt;ByteString&lt;/code&gt; に反映され、参照透過性が失われます。</target>
        </trans-unit>
        <trans-unit id="c9bb19123a210482015c0eb529407c8c92bd8a9d" translate="yes" xml:space="preserve">
          <source>This function is almost identical to &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt;. The only differences are:</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; とほとんど同じです。唯一の違いは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="127b48d0ce942f2e91014031d7ba1b7c2f584c47" translate="yes" xml:space="preserve">
          <source>This function is also unsafe if you call its finalizer twice, which will result in a &lt;em&gt;double free&lt;/em&gt; error, or if you pass it a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; not allocated with &lt;code&gt;malloc&lt;/code&gt;.</source>
          <target state="translated">この関数は、ファイナライザを2回呼び出して&lt;em&gt;二重解放&lt;/em&gt;エラーが発生する場合、または &lt;code&gt;malloc&lt;/code&gt; で割り当てられていない &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; を渡す場合にも安全ではありません。。</target>
        </trans-unit>
        <trans-unit id="725d98580cd2d533b5eb08b0b83d5983bcb4d0b9" translate="yes" xml:space="preserve">
          <source>This function is also unsafe if you call its finalizer twice, which will result in a &lt;em&gt;double free&lt;/em&gt; error, or if you pass it a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; not allocated with &lt;code&gt;malloc&lt;/code&gt;.</source>
          <target state="translated">この関数は、ファイナライザーを2回呼び出すと、&lt;em&gt;ダブルフリー&lt;/em&gt;エラーが発生する場合や、 &lt;code&gt;malloc&lt;/code&gt; で割り当てられていない &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; を渡す場合にも安全ではありません。</target>
        </trans-unit>
        <trans-unit id="a1352738c1dd68227a434686b430958d3c19705e" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">この機能は削除され、使用できなくなりました。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt; を使用する</target>
        </trans-unit>
        <trans-unit id="3624112a91081c7d0092b5f7cbbb5f82d405f7c9" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この機能は削除され、使用できなくなりました。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt; を使用する。</target>
        </trans-unit>
        <trans-unit id="b637539c4592b1c460f40d32f474fe342dccfe09" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この機能は削除され、使用できなくなりました。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 使用ます。</target>
        </trans-unit>
        <trans-unit id="e297580fc2021dc8c611b1cab7ef8ab0b1a171b6" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この機能は削除され、使用できなくなりました。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="d928e0ca94addd99cca4a82d7c03710b0e1ff8e8" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この機能は削除され、使用できなくなりました。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="8a7dbf169335c01f89eb6a63ed0156362fcda8c5" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この機能は削除され、使用できなくなりました。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="c431a15b17f66529ec0971f021718a3de7606559" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この機能は削除され、使用できなくなりました。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="78dce4476ccaf3b80909ed078582168f3c380495" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この機能は削除され、使用できなくなりました。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="0be1b4711ed0b36e7147869439e2d34b0cf4d927" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この機能は削除され、使用できなくなりました。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="13a1297dbe50a5705a1a7b087e24f8f8c0611b79" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputTBehavior&quot;&gt;runInputTBehavior&lt;/a&gt; &lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt;. It uses terminal-style interaction if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is connected to a terminal and has echoing enabled. Otherwise (e.g., if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is a pipe), it uses file-style interaction.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputTBehavior&quot;&gt;runInputTBehavior&lt;/a&gt; &lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt; と同等です。 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; が端末に接続され、エコーが有効になっている場合は、端末スタイルの対話を使用します。それ以外の場合（たとえば、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; がパイプの場合）、ファイル形式の相互作用を使用します。</target>
        </trans-unit>
        <trans-unit id="74b22623dc818147f2c6f57929328997d17b3b24" translate="yes" xml:space="preserve">
          <source>This function is identical to the normal unsafeInterleaveST, but is inlined and hence faster.</source>
          <target state="translated">この関数は通常の unsafeInterleaveST と同じですが、インライン化されているので高速です。</target>
        </trans-unit>
        <trans-unit id="3df65f8bec8d8ab7b43b6ab0ab2e82da15c0ef13" translate="yes" xml:space="preserve">
          <source>This function is inlined despite its heavy code-size to allow fusing with the allocation strategy. For example, the default &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; execution function &lt;code&gt;toLazyByteString&lt;/code&gt; is defined as follows.</source>
          <target state="translated">この関数は、割り当て戦略との融合を可能にするために、コードサイズが重いにもかかわらずインライン化されています。たとえば、デフォルトの &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 実行関数 &lt;code&gt;toLazyByteString&lt;/code&gt; は次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="235b6b044bd31212b9719a4b1325277577dea428" translate="yes" xml:space="preserve">
          <source>This function is inlined despite its heavy code-size to allow fusing with the allocation strategy. For example, the default &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; execution function &lt;code&gt;toLazyByteString&lt;/code&gt; is defined as follows.</source>
          <target state="translated">この関数は、割り当て戦略との融合を可能にするために、コードサイズが重いにもかかわらずインライン化されています。たとえば、デフォルトの &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 実行関数 &lt;code&gt;toLazyByteString&lt;/code&gt; は次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="5e260df7d73e67cac6b68c2a311d7baa6dc73777" translate="yes" xml:space="preserve">
          <source>This function is mainly useful for performing caseless (also known as case insensitive) string comparisons.</source>
          <target state="translated">この関数は、主に大文字小文字を区別しない(大文字小文字を区別しない)文字列比較を行うのに便利です。</target>
        </trans-unit>
        <trans-unit id="982fe52bf42753f9c092c03c7dda6cf3ea3642ac" translate="yes" xml:space="preserve">
          <source>This function is mainly useful for performing caseless (or case insensitive) string comparisons.</source>
          <target state="translated">この関数は、主に大文字小文字を区別しない文字列比較を行うのに便利です。</target>
        </trans-unit>
        <trans-unit id="88a949c7c5b9a60ae7e9844db387f3275f199bc9" translate="yes" xml:space="preserve">
          <source>This function is meant to be invoked from any application level cleanup handler. It terminates the process, and closes any &lt;code&gt;&lt;a href=&quot;system-process#v:CreatePipe&quot;&gt;CreatePipe&lt;/a&gt;&lt;/code&gt;&lt;code&gt;handle&lt;/code&gt;s.</source>
          <target state="translated">この関数は、アプリケーションレベルのクリーンアップハンドラーから呼び出されることを想定しています。プロセスを終了し、 &lt;code&gt;&lt;a href=&quot;system-process#v:CreatePipe&quot;&gt;CreatePipe&lt;/a&gt;&lt;/code&gt; &lt;code&gt;handle&lt;/code&gt; すべて閉じます。</target>
        </trans-unit>
        <trans-unit id="00b26bf5c664293ce811e9f9293ca81ecc310513" translate="yes" xml:space="preserve">
          <source>This function is more efficient than &lt;code&gt;hPut . &lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; because in many cases no buffer allocation has to be done. Moreover, the results of several executions of short &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are concatenated in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s buffer, therefore avoiding unnecessary buffer flushes.</source>
          <target state="translated">この関数は &lt;code&gt;hPut . &lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; よりも効率的です。多くの場合、バッファの割り当てを行う必要がないため、toLazyByteString。さらに、短い &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; のいくつかの実行の結果は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; バッファーに連結されるため、不要なバッファーのフラッシュが回避されます。</target>
        </trans-unit>
        <trans-unit id="af91de3226aaac03a1110fced423ab247dd1f835" translate="yes" xml:space="preserve">
          <source>This function is more efficient than &lt;code&gt;hPut . &lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; because in many cases no buffer allocation has to be done. Moreover, the results of several executions of short &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are concatenated in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s buffer, therefore avoiding unnecessary buffer flushes.</source>
          <target state="translated">この関数は &lt;code&gt;hPut . &lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; よりも効率的です。多くの場合、バッファ割り当てを行う必要がないため、toLazyByteString。さらに、短い &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; の複数の実行の結果は、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; のバッファーに連結されるため、不要なバッファーのフラッシュを回避できます。</target>
        </trans-unit>
        <trans-unit id="81cef0e8688cdc48d9b9ff9c39a55f003fae9595" translate="yes" xml:space="preserve">
          <source>This function is normally used for marshalling data to or from the object pointed to by the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;, using the operations from the &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">この関数は通常、 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; クラスの操作を使用して、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; が指すオブジェクトとの間でデータをマーシャリングするために使用されます。</target>
        </trans-unit>
        <trans-unit id="dcc8eee9cef2591d3719a4001c66eea308bb00b1" translate="yes" xml:space="preserve">
          <source>This function is normally used for marshalling data to or from the object pointed to by the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;, using the operations from the &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">この関数は通常、 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; クラスの操作を使用して、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; が指すオブジェクトとの間でデータをマーシャリングするために使用されます。</target>
        </trans-unit>
        <trans-unit id="f40048a5f3caebc5fe300ab653bf30f1e2b70070" translate="yes" xml:space="preserve">
          <source>This function is only defined if &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;gt;= 2#&lt;/code&gt; and &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 256#&lt;/code&gt; (Note: the documentation claims that only &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 62#&lt;/code&gt; is supported, however the actual implementation supports up to base 256).</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;gt;= 2#&lt;/code&gt; および &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 256#&lt;/code&gt; 場合にのみ定義されます（注：ドキュメントでは、 &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 62#&lt;/code&gt; のみがサポートされていると主張していますが、実際の実装では最大256をサポートしています）。</target>
        </trans-unit>
        <trans-unit id="213dcd0849e6345864ca5752cd6d03ec515775cd" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, except that the size of the memory required is given explicitly as a number of bytes.</source>
          <target state="translated">この関数は、必要なメモリのサイズがバイト数として明示的に指定されることを除いて、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; に似ています。</target>
        </trans-unit>
        <trans-unit id="7180b41a302c7c04e8da7fd8f83d119c939f7280" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, except that the size of the memory required is given explicitly as a number of bytes.</source>
          <target state="translated">この関数は、必要なメモリのサイズがバイト数として明示的に指定されることを除いて、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; に似ています。</target>
        </trans-unit>
        <trans-unit id="5f63596c51e12b4f409448cb34c60a65c7a9ca0d" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt; に似ていますが、メモリ領域を解放するファイナライザがアタッチされたメモリ領域を生成します。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; と同様に、メモリブロックが &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; によって割り当てられたことは保証されません。</target>
        </trans-unit>
        <trans-unit id="4083768355a45fdb0a42de16aa51a3af8c228c66" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt; に似ていますが、メモリ領域を解放するファイナライザがアタッチされたメモリ領域を生成します。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; と同様に、メモリブロックが &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; によって割り当てられたことは保証されません。</target>
        </trans-unit>
        <trans-unit id="6b1d46b44ea9232c55a861a5d882fa3688f6cd96" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt; に似ていますが、メモリ領域を解放するファイナライザがアタッチされたメモリ領域を生成します。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; と同様に、メモリブロックが &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; によって割り当てられたことは保証されません。</target>
        </trans-unit>
        <trans-unit id="7672c2399ed76b968a47b4291c113d59075f7990" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt; に似ていますが、メモリ領域を解放するファイナライザがアタッチされたメモリ領域を生成します。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; と同様に、メモリブロックが &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; によって割り当てられたことは保証されません。</target>
        </trans-unit>
        <trans-unit id="7ff12ee367a6fdd15f0645b4e1ebf055ffe60727" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, except that the size of the memory required is given explicitly as a number of bytes.</source>
          <target state="translated">この関数は、必要なメモリのサイズがバイト数として明示的に指定されることを除いて、 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; に似ています。</target>
        </trans-unit>
        <trans-unit id="b6c52e12f35a2275476d84741c02f0045857af05" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrAlignedBytes&quot;&gt;mallocForeignPtrAlignedBytes&lt;/a&gt;&lt;/code&gt;, except that the internally an optimised ForeignPtr representation with no finalizer is used. Attempts to add a finalizer will cause an exception to be thrown.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrAlignedBytes&quot;&gt;mallocForeignPtrAlignedBytes&lt;/a&gt;&lt;/code&gt; に似ていますに、ファイナライザのない内部的に最適化されたForeignPtr表現が使用される点が異なります。ファイナライザを追加しようとすると、例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="e8bb381fc113886f37459f57bc0e517e18d58f74" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt;, except that the internally an optimised ForeignPtr representation with no finalizer is used. Attempts to add a finalizer will cause an exception to be thrown.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt; に似ていますが、ファイナライザを使用せずに内部的に最適化されたForeignPtr表現が使用される点が異なります。ファイナライザを追加しようとすると、例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="3d6f8324541e76c432236c537e2a380f498fdc16" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt;, except that the size and alignment of the memory required is given explicitly as numbers of bytes.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt; に似ていますが、必要なメモリのサイズと配置がバイト数として明示的に指定される点が異なります。</target>
        </trans-unit>
        <trans-unit id="c6266d7b17854517fbd86bf34d982e2073442b47" translate="yes" xml:space="preserve">
          <source>This function is strict in &lt;code&gt;needle&lt;/code&gt;, and lazy (as far as possible) in the chunks of &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">この関数は、 &lt;code&gt;needle&lt;/code&gt; では厳密であり、 &lt;code&gt;haystack&lt;/code&gt; のチャンクでは（可能な限り）レイジーです。</target>
        </trans-unit>
        <trans-unit id="f216683cc82aa64de779d88daeaba4d1152d651d" translate="yes" xml:space="preserve">
          <source>This function is strict in its first argument, and lazy in its second.</source>
          <target state="translated">この関数は第一引数が厳密で、第二引数が怠惰です。</target>
        </trans-unit>
        <trans-unit id="b0b32655d3a8d92812d81f5285c18f655d5a3859" translate="yes" xml:space="preserve">
          <source>This function is strict in the computed result and lazy in the writing of the bytes. For example, given</source>
          <target state="translated">この関数は,計算結果には厳密に,バイトの書き込みには怠惰になります.例えば、与えられた</target>
        </trans-unit>
        <trans-unit id="d42e669b72fdf00ca69c1146fbc6cd4f7fd2b0e3" translate="yes" xml:space="preserve">
          <source>This function is suitable for use in pure code. In an IO context use &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">この関数は、純粋なコードでの使用に適しています。IOコンテキストでは &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; を使用します代わりにを。</target>
        </trans-unit>
        <trans-unit id="f3b80efc4be65cc4f7d016d8e9df62478b06cdd3" translate="yes" xml:space="preserve">
          <source>This function is unsafe because the program behavior is undefined if the type of the returned &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; does not match the expected one.</source>
          <target state="translated">返された &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; のタイプが期待されるタイプと一致しない場合、プログラムの動作は未定義であるため、この関数は安全ではありません。</target>
        </trans-unit>
        <trans-unit id="d0ef53dc671c66eb4f726f95bfbceabd2738d518" translate="yes" xml:space="preserve">
          <source>This function is used by GHC for constructing &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; literals.</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; リテラルを構築するためにGHCによって使用されます。</target>
        </trans-unit>
        <trans-unit id="5abca3b3eff9479232b2f8880d6591a9960af27b" translate="yes" xml:space="preserve">
          <source>This function is used by GHC for constructing &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; literals.</source>
          <target state="translated">この関数は、GHCが &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; リテラルを構築するために使用します。</target>
        </trans-unit>
        <trans-unit id="a76dc2ebb647a8a46428d99317295ae5c89ee276" translate="yes" xml:space="preserve">
          <source>This function is useful for informing the parent when a child terminates, for example.</source>
          <target state="translated">この機能は、例えば子の終了時に親に通知するのに便利です。</target>
        </trans-unit>
        <trans-unit id="d5042b5be97cdd0d8f13f55579035132f9596b0e" translate="yes" xml:space="preserve">
          <source>This function is useful for using &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; in a safe way in a multithreaded program. If you only have one &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;, then using &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; to access and modify it will prevent race conditions.</source>
          <target state="translated">この関数は、マルチスレッドプログラムで &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; を安全に使用するのに役立ちます。 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; が1つしかない場合、 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; を使用してアクセスおよび変更すると、競合状態が回避されます。</target>
        </trans-unit>
        <trans-unit id="78f182126e093e425fc7c58b56f7052d3cc81fd2" translate="yes" xml:space="preserve">
          <source>This function isn't suitable when we want to set the cTRL_C_EVENT handler. If you want to set the cTRL_C_EVENT handler, use &lt;code&gt;&lt;a href=&quot;system-win32-console-ctrlhandler#v:c_SetConsoleCtrlHandler&quot;&gt;c_SetConsoleCtrlHandler&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">この関数は、cTRL_C_EVENTハンドラーを設定する場合には適していません。cTRL_C_EVENTハンドラを設定する場合は、c_SetConsoleCtrlHandlerを使用し &lt;code&gt;&lt;a href=&quot;system-win32-console-ctrlhandler#v:c_SetConsoleCtrlHandler&quot;&gt;c_SetConsoleCtrlHandler&lt;/a&gt;&lt;/code&gt; 代わりにを。</target>
        </trans-unit>
        <trans-unit id="9871f6366cef22e329fca1bc704e039bd6520451" translate="yes" xml:space="preserve">
          <source>This function maps one exception into another as proposed in the paper &quot;A semantics for imprecise exceptions&quot;.</source>
          <target state="translated">この関数は、論文 &quot;A semantics for imprecise exceptions &quot;で提案されているように、ある例外を別の例外にマッピングします。</target>
        </trans-unit>
        <trans-unit id="1a5ff8da6eff5ff073f1ef4ac1e4757b5f92be33" translate="yes" xml:space="preserve">
          <source>This function may be used as a value for &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">この関数は、の値として使用することができる &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; インスタンス。</target>
        </trans-unit>
        <trans-unit id="626e558e3754f72bcf94652b857bc1fadf635831" translate="yes" xml:space="preserve">
          <source>This function may be used as a value for &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, provided that &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; is defined. (Using &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; with a &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instance defined only by &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; will result in infinite recursion.)</source>
          <target state="translated">この関数は、の値として使用することができる &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; ことを条件とする、インスタンス &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 定義されています。 （ &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; を、 &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; によってのみ定義された &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; インスタンスで使用すると、無限再帰が発生します。）</target>
        </trans-unit>
        <trans-unit id="e58338f4629941ddeb6081adb1d67e46144c1a35" translate="yes" xml:space="preserve">
          <source>This function must be referentially transparent; i.e., calling it multiple times with equally sized &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s must result in the same sequence of bytes being written and the same value being computed. If you need mutable state, then you must allocate it anew upon each call of this function. Moroever, this function must call the continuation once its done. Otherwise, monadic sequencing of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s does not work. Finally, this function must write to all bytes that it claims it has written. Otherwise, the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; is not guaranteed to be referentially transparent and sensitive data might leak.</source>
          <target state="translated">この関数は参照透過的でなければなりません。つまり、同じサイズの &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; で複数回呼び出すと、同じバイトシーケンスが書き込まれ、同じ値が計算される必要があります。変更可能な状態が必要な場合は、この関数を呼び出すたびに変更可能な状態を割り当てる必要があります。 Moroever、この関数は、一度完了したら継続を呼び出す必要があります。そうでない場合、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; のモナディックシーケンスは機能しません。最後に、この関数は、書き込んだと主張するすべてのバイトに書き込む必要があります。それ以外の場合、結果の &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; は参照透過性が保証されず、機密データが漏洩する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d45d9a503757dbc2e079e55bb2d136d8ac259338" translate="yes" xml:space="preserve">
          <source>This function must be referentially transparent; i.e., calling it multiple times with equally sized &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s must result in the same sequence of bytes being written. If you need mutable state, then you must allocate it anew upon each call of this function. Moroever, this function must call the continuation once its done. Otherwise, concatenation of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s does not work. Finally, this function must write to all bytes that it claims it has written. Otherwise, the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is not guaranteed to be referentially transparent and sensitive data might leak.</source>
          <target state="translated">この関数は参照透過的でなければなりません。つまり、同じサイズの &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; で複数回呼び出すと、同じバイトシーケンスが書き込まれます。変更可能な状態が必要な場合は、この関数を呼び出すたびに変更可能な状態を割り当てる必要があります。Moroever、この関数は、完了したら継続を呼び出す必要があります。そうでない場合、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; の連結は機能しません。最後に、この関数は、書き込んだと主張するすべてのバイトに書き込む必要があります。それ以外の場合、結果の &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; は参照透過性が保証されず、機密データが漏洩する可能性があります。</target>
        </trans-unit>
        <trans-unit id="f8b24ee1d1129f69b81aa438d99f4c55ce18780e" translate="yes" xml:space="preserve">
          <source>This function reads chunks at a time, increasing the chunk size on each read. The final string is then reallocated to the appropriate size. For files &amp;gt; half of available memory, this may lead to memory exhaustion. Consider using &lt;code&gt;&lt;a href=&quot;data-bytestring#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; in this case.</source>
          <target state="translated">この関数は、一度にチャンクを読み取り、読み取りごとにチャンクサイズを増やします。次に、最終的な文字列が適切なサイズに再割り当てされます。利用可能なメモリの半分を超えるファイルの場合、これによりメモリが使い果たされる可能性があります。 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; の使用を検討してくださいこの場合は、。</target>
        </trans-unit>
        <trans-unit id="bb38f0c0e138df73f1bb18283100e26479279ef9" translate="yes" xml:space="preserve">
          <source>This function reads chunks at a time, increasing the chunk size on each read. The final string is then reallocated to the appropriate size. For files &amp;gt; half of available memory, this may lead to memory exhaustion. Consider using &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; in this case.</source>
          <target state="translated">この関数は、一度にチャンクを読み取り、読み取りごとにチャンクサイズを増やします。次に、最終的な文字列が適切なサイズに再割り当てされます。利用可能なメモリの半分を超えるファイルの場合、これによりメモリが使い果たされる可能性があります。この場合は、 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; の使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="b96182eaae363b6548da5c4708f3fee19d0eba44" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if its argument has one of the following &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;s, or &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise:</source>
          <target state="translated">この関数は、引数に次の &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; のいずれかがある場合は &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; を返し、そうでない場合は &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="08b901589b02acf03fdb2c4330ddaefe06ce9626" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if its argument has one of the following &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;s, or &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise:</source>
          <target state="translated">この関数は、引数に次の &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; のいずれかがある場合は &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; を返し、そうでない場合は &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="829c7b2049bce335518e8e6987f223cd44774ac1" translate="yes" xml:space="preserve">
          <source>This function should not be called on a closed or cancelled &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は、クローズまたはキャンセルされた &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt; で呼び出すことはできません。</target>
        </trans-unit>
        <trans-unit id="4becc58728105fc63f4543e724ceed3d0b38faa9" translate="yes" xml:space="preserve">
          <source>This function takes an adjacency list representing a graph with vertices of type &lt;code&gt;key&lt;/code&gt; labeled by values of type &lt;code&gt;node&lt;/code&gt; and produces a &lt;code&gt;Graph&lt;/code&gt;-based representation of that list. The &lt;code&gt;Graph&lt;/code&gt; result represents the &lt;em&gt;shape&lt;/em&gt; of the graph, and the functions describe a) how to retrieve the label and adjacent vertices of a given vertex, and b) how to retrive a vertex given a key.</source>
          <target state="translated">この関数は、 &lt;code&gt;node&lt;/code&gt; タイプの値でラベル付けされた &lt;code&gt;key&lt;/code&gt; タイプの頂点を持つグラフを表す隣接リストを取り、そのリストの &lt;code&gt;Graph&lt;/code&gt; ベースの表現を生成します。 &lt;code&gt;Graph&lt;/code&gt; 結果が表す&lt;em&gt;形状を&lt;/em&gt;&lt;em&gt;&lt;/em&gt;所与の頂点のラベルと隣接する頂点を取得するために、およびb）どのキー与えられた頂点をretriveする方法）グラフの、および機能が記載されています。</target>
        </trans-unit>
        <trans-unit id="6070795d0875a01577e4829d564fa22e24b1b00c" translate="yes" xml:space="preserve">
          <source>This function takes an extra &lt;code&gt;String&lt;/code&gt; argument to be used in creating error messages.</source>
          <target state="translated">この関数は、エラーメッセージの作成に使用する追加の &lt;code&gt;String&lt;/code&gt; 引数を取ります。</target>
        </trans-unit>
        <trans-unit id="7f0c1ada42e597613fc7e7e6786e2387ef148b77" translate="yes" xml:space="preserve">
          <source>This function throws an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the process &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; is anything other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt;. If instead you want to get the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; then use &lt;code&gt;&lt;a href=&quot;system-process#v:readProcessWithExitCode&quot;&gt;readProcessWithExitCode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">プロセス &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt; 以外の場合、この関数は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; をスローします。代わりに &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; を取得したい場合は、readProcessWithExitCodeを使用し &lt;code&gt;&lt;a href=&quot;system-process#v:readProcessWithExitCode&quot;&gt;readProcessWithExitCode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12b8c3042780b1688ac6a3ee1fab2256e1f014dd" translate="yes" xml:space="preserve">
          <source>This function will be invoked at two points in the constraint solving process: after simplification of given constraints, and after unflattening of wanted constraints. The two phases can be distinguished because the deriveds and wanteds will be empty in the first case. In each case, the plugin should either</source>
          <target state="translated">この関数は、与えられた制約の単純化の後と、欲しい制約のフラット化を解除した後の2つの時点で呼び出されます。2つのフェーズは、最初のケースでは導出された制約と欲しい制約が空になるため、区別できます。それぞれのケースで、プラグインは以下のいずれかを実行します。</target>
        </trans-unit>
        <trans-unit id="6467a527fa88959e8823896b96be26bf195128c1" translate="yes" xml:space="preserve">
          <source>This function wraps &lt;code&gt;mpz_sizeinbase()&lt;/code&gt; which has some implementation pecularities to take into account:</source>
          <target state="translated">この関数は、考慮すべきいくつかの実装特性を持つ &lt;code&gt;mpz_sizeinbase()&lt;/code&gt; をラップします。</target>
        </trans-unit>
        <trans-unit id="80485bdbfd7c212c63fd29a0333499c58e82d6b5" translate="yes" xml:space="preserve">
          <source>This function, like &lt;code&gt;&lt;a href=&quot;ghc-stack#v:pushCallStack&quot;&gt;pushCallStack&lt;/a&gt;&lt;/code&gt;, has no effect on a frozen &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この機能は、同じよう &lt;code&gt;&lt;a href=&quot;ghc-stack#v:pushCallStack&quot;&gt;pushCallStack&lt;/a&gt;&lt;/code&gt; 、冷凍には影響ありません &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="842a68272f46af66e4862fdc0bc066609f64b0e0" translate="yes" xml:space="preserve">
          <source>This generalizes the list-based &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">これにより、リストベースの &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 機能が一般化されます。</target>
        </trans-unit>
        <trans-unit id="b2ff47cfc567ef028dcfe716cd26e468cb33a9de" translate="yes" xml:space="preserve">
          <source>This generates one file per Haskell module, and 4 index files, &lt;code&gt;hpc_index.html&lt;/code&gt;, &lt;code&gt;hpc_index_alt.html&lt;/code&gt;, &lt;code&gt;hpc_index_exp.html&lt;/code&gt;, &lt;code&gt;hpc_index_fun.html&lt;/code&gt;.</source>
          <target state="translated">これにより、Haskellモジュールごとに1つのファイルと、4つのインデックスファイル、 &lt;code&gt;hpc_index.html&lt;/code&gt; 、 &lt;code&gt;hpc_index_alt.html&lt;/code&gt; 、 &lt;code&gt;hpc_index_exp.html&lt;/code&gt; 、 &lt;code&gt;hpc_index_fun.html&lt;/code&gt; が生成されます。</target>
        </trans-unit>
        <trans-unit id="c5344bdf0cc9457503d3d92a9eb3e0f2cb07653d" translate="yes" xml:space="preserve">
          <source>This greatly constrains library authors since it implies that it is not safe to pass any heap object reference to a &lt;code&gt;safe&lt;/code&gt; foreign function call. For instance, it is often desirable to pass an &lt;a href=&quot;#pinned-byte-arrays&quot;&gt;unpinned&lt;/a&gt;&lt;code&gt;ByteArray#&lt;/code&gt;s directly to native code to avoid making an otherwise-unnecessary copy. However, this can only be done safely if the array is guaranteed not to be moved by the garbage collector in the middle of the call.</source>
          <target state="translated">これは、ヒープオブジェクト参照を &lt;code&gt;safe&lt;/code&gt; 外部関数呼び出しに渡すことが安全ではないことを意味するため、ライブラリの作成者を大幅に制約します。たとえば、&lt;a href=&quot;#pinned-byte-arrays&quot;&gt;固定されていない&lt;/a&gt; &lt;code&gt;ByteArray#&lt;/code&gt; をネイティブコードに直接渡して、不要なコピーを作成しないようにすることが望ましい場合がよくあります。ただし、これは、呼び出しの途中でガベージコレクターによって配列が移動されないことが保証されている場合にのみ安全に実行できます。</target>
        </trans-unit>
        <trans-unit id="7c64c30705c50c32c9be3389ffedce10aebc7f56" translate="yes" xml:space="preserve">
          <source>This greatly constrains library authors since it implies that it is not safe to pass any heap object reference to a &lt;code&gt;safe&lt;/code&gt; foreign function call. For instance, it is often desirable to pass an unpinned &lt;code&gt;ByteArray#&lt;/code&gt;s directly to native code to avoid making an otherwise-unnecessary copy. However, this can only be done safely if the array is guaranteed not to be moved by the garbage collector in the middle of the call.</source>
          <target state="translated">これは、ヒープオブジェクト参照を &lt;code&gt;safe&lt;/code&gt; 外部関数呼び出しに渡すことが安全ではないことを意味するため、ライブラリの作成者を大幅に制約します。たとえば、固定されていない &lt;code&gt;ByteArray#&lt;/code&gt; をネイティブコードに直接渡して、それ以外は不要なコピーが作成されないようにすることが望ましい場合がよくあります。ただし、これは、呼び出しの途中でガベージコレクターによって配列が移動されないことが保証されている場合にのみ安全に実行できます。</target>
        </trans-unit>
        <trans-unit id="41834e436d1719d30cabcc4b9b9f363c58c43156" translate="yes" xml:space="preserve">
          <source>This has the same effect as calling &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt;, together with &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、呼び出したのと同じ効果がある &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; をして &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt; とともに、 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="6ae7b2e29f0249e038dc6f2d5f144f9852f9724a" translate="yes" xml:space="preserve">
          <source>This has the same effect as calling &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;system-io#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt;, together with &lt;code&gt;&lt;a href=&quot;system-io#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;system-io#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、呼び出したのと同じ効果がある &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; をして &lt;code&gt;&lt;a href=&quot;system-io#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt; とともに、 &lt;code&gt;&lt;a href=&quot;system-io#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;system-io#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="74c85cbe0088849b70271ff6b2b4f90df21c84ea" translate="yes" xml:space="preserve">
          <source>This has two effects. The first is to compile the code in such a way that it can be linked against shared library versions of Haskell packages (such as base). The second is when linking, to link against the shared versions of the packages&amp;rsquo; libraries rather than the static versions. Obviously this requires that the packages were built with shared libraries. On supported platforms GHC comes with shared libraries for all the core packages, but if you install extra packages (e.g. with Cabal) then they would also have to be built with shared libraries (&lt;code&gt;--enable-shared&lt;/code&gt; for Cabal).</source>
          <target state="translated">これには2つの効果があります。1つ目は、Haskellパッケージの共有ライブラリバージョン（ベースなど）に対してリンクできるようにコードをコンパイルすることです。2つ目は、リンク時、静的バージョンではなく、パッケージのライブラリの共有バージョンに対してリンクする場合です。明らかに、これにはパッケージが共有ライブラリでビルドされていることが必要です。サポートされているプラ​​ットフォームでは、GHCにはすべてのコアパッケージの共有ライブラリが付属していますが、追加のパッケージをインストールする場合（たとえば、Cabalを使用）、共有ライブラリを使用してビルドする必要があります（Cabalの場合は &lt;code&gt;--enable-shared&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="548fc7aaea96607acee200e9ba71f5d0c6b166be" translate="yes" xml:space="preserve">
          <source>This idea is very old; see Seciton 7 of &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/derivable-type-classes/&quot;&gt;Derivable type classes&lt;/a&gt;.</source>
          <target state="translated">このアイデアは非常に古いものです。&lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/derivable-type-classes/&quot;&gt;Derivable型クラスの&lt;/a&gt; Seciton 7を参照してください。</target>
        </trans-unit>
        <trans-unit id="9630590333acefa1eb165b1fdb491f1028f3c007" translate="yes" xml:space="preserve">
          <source>This implemenation uses &lt;code&gt;memset(3)&lt;/code&gt;</source>
          <target state="translated">この実装は &lt;code&gt;memset(3)&lt;/code&gt; を使用します</target>
        </trans-unit>
        <trans-unit id="884b09618f3fa095f6ec125ed96fbbf8ccd437a1" translate="yes" xml:space="preserve">
          <source>This implementation is intentionally naive. Instances are expected to provide an optimized implementation for their size.</source>
          <target state="translated">この実装は意図的にナイーブです。インスタンスは、そのサイズに最適化された実装を提供することが期待されています。</target>
        </trans-unit>
        <trans-unit id="621e9b697c58fe612c7eaaea244ee764c09bb5f3" translate="yes" xml:space="preserve">
          <source>This implies flushing the output buffer, even if it contains just a single byte. You should therefore use &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; only for large (&lt;code&gt;&amp;gt; 8kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. Otherwise, the generated chunks are too fragmented to be processed efficiently afterwards.</source>
          <target state="translated">これは、たとえ1バイトしか含まれていない場合でも、出力バッファーをフラッシュすることを意味します。したがって、大きな（ &lt;code&gt;&amp;gt; 8kb&lt;/code&gt; ） &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; に対してのみ &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; を使用する必要があります。そうでない場合、生成されたチャンクは断片化されすぎて、後で効率的に処理できません。</target>
        </trans-unit>
        <trans-unit id="ec6a5f5a381024ce57d5b678b6cb847a23f169c1" translate="yes" xml:space="preserve">
          <source>This implies flushing the output buffer, even if it contains just a single byte. You should therefore use &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; only for large (&lt;code&gt;&amp;gt; 8kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. Otherwise, the generated chunks are too fragmented to be processed efficiently afterwards.</source>
          <target state="translated">これは、たとえ1バイトしか含まれていない場合でも、出力バッファーをフラッシュすることを意味します。したがって、大きな（ &lt;code&gt;&amp;gt; 8kb&lt;/code&gt; ） &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; に対してのみ &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; を使用する必要があります。そうでない場合、生成されたチャンクは断片化されすぎて、後で効率的に処理できません。</target>
        </trans-unit>
        <trans-unit id="0f03bf2766810922713f86acfde0e9c886b0e80e" translate="yes" xml:space="preserve">
          <source>This improves efficiency slightly but significantly for most programs, and is bad for only a few. To suppress this bogus &amp;ldquo;optimisation&amp;rdquo; use &lt;code&gt;-fpedantic-bottoms&lt;/code&gt;.</source>
          <target state="translated">これにより、効率はわずかに向上しますが、ほとんどのプログラムで大幅に向上し、ごく一部のプログラムでは問題があります。この偽の「最適化」を抑制するには、 &lt;code&gt;-fpedantic-bottoms&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="0c3ae98027814be110bac171a0407c5649c80296" translate="yes" xml:space="preserve">
          <source>This includes the main thread, so using &lt;a href=&quot;#rts-flag--xt&quot;&gt;&lt;code&gt;-xt&lt;/code&gt;&lt;/a&gt; is a good way to see how much stack space the program is using.</source>
          <target state="translated">これにはメインスレッドが含まれるため、&lt;a href=&quot;#rts-flag--xt&quot;&gt; &lt;code&gt;-xt&lt;/code&gt; &lt;/a&gt;を使用すると、プログラムが使用しているスタックスペースの量を確認できます。</target>
        </trans-unit>
        <trans-unit id="d6a0e9f59821fc6a5f78b81c882c88a9ce445a90" translate="yes" xml:space="preserve">
          <source>This indicates that there may be more data to write. It gives you the next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action. You should call that action with an appropriate buffer. The int indicates the &lt;em&gt;minimum&lt;/em&gt; buffer size required by the next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action. That is, if you call the next action you &lt;em&gt;must&lt;/em&gt; supply it with a buffer length of at least this size.</source>
          <target state="translated">これは、書き込むデータがまだある可能性があることを示しています。次の &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; アクションを提供します。そのアクションは適切なバッファーで呼び出す必要があります。 intは、次の &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; アクションで必要な&lt;em&gt;最小&lt;/em&gt;バッファーサイズを示します。つまり、次のアクションを呼び出す場合は、少なくともこのサイズのバッファー長を指定する&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12dc46ef50110e91a94e6d325a61778b34facf10" translate="yes" xml:space="preserve">
          <source>This inlining occurs regardless of the argument to the call or the size of &lt;code&gt;f&lt;/code&gt;'s definition; it is unconditional. The main caveat is that &lt;code&gt;f&lt;/code&gt;'s definition must be visible to the compiler; it is therefore recommended to mark the function with an &lt;code&gt;INLINABLE&lt;/code&gt; pragma at its definition so that GHC guarantees to record its unfolding regardless of size.</source>
          <target state="translated">このインライン化は、呼び出しの引数や &lt;code&gt;f&lt;/code&gt; の定義のサイズに関係なく行われます。無条件です。主な注意点は、 &lt;code&gt;f&lt;/code&gt; の定義がコンパイラーから見える必要があることです。したがって、GHCがサイズに関係なく展開を記録することを保証できるように、その定義で関数を &lt;code&gt;INLINABLE&lt;/code&gt; プラグマでマークすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="1ef01da60f8e50833762de51e88f6f38500b8529" translate="yes" xml:space="preserve">
          <source>This inserts the plugin as a core-to-core pass. Unlike &lt;code&gt;-fplugin=(module)&lt;/code&gt;, the plugin module can&amp;rsquo;t reside in the same package as the module calling &lt;a href=&quot;../libraries/template-haskell-2.15.0.0/language-haskell-th-syntax#v:addCorePlugin&quot;&gt;Language.Haskell.TH.Syntax.addCorePlugin&lt;/a&gt;. This way, the implementation can expect the plugin to be built by the time it is needed.</source>
          <target state="translated">これにより、コアからコアへのパスとしてプラグインが挿入されます。 &lt;code&gt;-fplugin=(module)&lt;/code&gt; とは異なり、プラグインモジュールは、&lt;a href=&quot;../libraries/template-haskell-2.15.0.0/language-haskell-th-syntax#v:addCorePlugin&quot;&gt;Language.Haskell.TH.Syntax.addCorePluginを&lt;/a&gt;呼び出すモジュールと同じパッケージに置くことはできません。このようにして、実装は必要なときにプラグインがビルドされることを期待できます。</target>
        </trans-unit>
        <trans-unit id="5ff50fa3f4d1717b720187c6141e26cd711cc26f" translate="yes" xml:space="preserve">
          <source>This inserts the plugin as a core-to-core pass. Unlike &lt;code&gt;-fplugin=(module)&lt;/code&gt;, the plugin module can&amp;rsquo;t reside in the same package as the module calling &lt;a href=&quot;../libraries/template-haskell-2.16.0.0/language-haskell-th-syntax#v:addCorePlugin&quot;&gt;Language.Haskell.TH.Syntax.addCorePlugin&lt;/a&gt;. This way, the implementation can expect the plugin to be built by the time it is needed.</source>
          <target state="translated">これにより、プラグインがコアツーコアパスとして挿入されます。 &lt;code&gt;-fplugin=(module)&lt;/code&gt; とは異なり、プラグインモジュールは、&lt;a href=&quot;../libraries/template-haskell-2.16.0.0/language-haskell-th-syntax#v:addCorePlugin&quot;&gt;Language.Haskell.TH.Syntax.addCorePluginを&lt;/a&gt;呼び出すモジュールと同じパッケージに常駐することはできません。このようにして、実装はプラグインが必要になるまでにビルドされることを期待できます。</target>
        </trans-unit>
        <trans-unit id="c72aeeca496ff034d5ed0f5d68c44678b8f30bdc" translate="yes" xml:space="preserve">
          <source>This instance has similar considerations to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instance: it preserves abstraction at the cost of inefficiency.</source>
          <target state="translated">このインスタンスには、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; インスタンスと同様の考慮事項があります。非効率性を犠牲にして抽象化を維持します。</target>
        </trans-unit>
        <trans-unit id="f4e5c9cc750ce5f88a69b78165e5f0f4d42bcbfe" translate="yes" xml:space="preserve">
          <source>This instance is for convenience and consistency with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt;. This assumes that WHNF is equivalent to NF for functions.</source>
          <target state="translated">このインスタンスは、利便性と &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; との一貫性のためです。これは、WHNFが関数のNFと同等であることを前提としています。</target>
        </trans-unit>
        <trans-unit id="0eaa2be703bfed5db1962bf2e87d773ccbf9e44d" translate="yes" xml:space="preserve">
          <source>This instance is for convenience and consistency with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt;. This assumes that WHNF is equivalent to NF for functions.</source>
          <target state="translated">このインスタンスは、便宜上、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; との一貫性を保つためのものです。これは、WHNFが関数のNFと同等であることを前提としています。</target>
        </trans-unit>
        <trans-unit id="292d6bb24eb4520bb3e5e03c32ef914fb200aaac" translate="yes" xml:space="preserve">
          <source>This instance is only usable if the constructor &lt;code&gt;MkNT&lt;/code&gt; is in scope.</source>
          <target state="translated">このインスタンスは、コンストラクター &lt;code&gt;MkNT&lt;/code&gt; がスコープ内にある場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="f66688755fda8b6fa988624af4229d29f0758a6a" translate="yes" xml:space="preserve">
          <source>This instance preserves data abstraction at the cost of inefficiency. We omit reflection services for the sake of data abstraction.</source>
          <target state="translated">このインスタンスは、非効率性を犠牲にしてもデータの抽象化を維持します。データの抽象化のためにリフレクションサービスを省略しています。</target>
        </trans-unit>
        <trans-unit id="6b584a1a609b62c189a035f58e1f74d23dc48f4f" translate="yes" xml:space="preserve">
          <source>This instance was created by copying the updated behavior of &lt;code&gt;&lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;.&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;.&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;. If you feel a mistake has been made, please feel free to submit improvements.</source>
          <target state="translated">このインスタンスは、 &lt;code&gt;&lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;.&lt;/code&gt; 更新された動作をコピーして作成されました。 &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;.&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 。間違いがあると思われる場合は、遠慮なく改善を送信してください。</target>
        </trans-unit>
        <trans-unit id="cebbf89c2d62c75612dfe9b00700d435728a9709" translate="yes" xml:space="preserve">
          <source>This instance was created by copying the updated behavior of &lt;code&gt;&lt;a href=&quot;data-text&quot;&gt;Data.Text&lt;/a&gt;.&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-text#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">このインスタンスは、 &lt;code&gt;&lt;a href=&quot;data-text&quot;&gt;Data.Text&lt;/a&gt;.&lt;/code&gt; 更新された動作をコピーして作成されました。 &lt;code&gt;&lt;a href=&quot;data-text#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa9547a346372e77b8a94a20c518fb263a9e88db" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;control-applicative#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;control-applicative#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="translated">このインスタンスは、 &lt;code&gt;&lt;a href=&quot;control-applicative#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; フィールドが削除された場合、 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtypeの派生インスタンスと同等になります。</target>
        </trans-unit>
        <trans-unit id="9d8b5c5a18b4eafeeabf6e2ae459cf6f977e8e46" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;data-functor-const#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="translated">このインスタンスは、 &lt;code&gt;&lt;a href=&quot;data-functor-const#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; フィールドが削除された場合、 &lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtypeの派生インスタンスと同等になります。</target>
        </trans-unit>
        <trans-unit id="8f442041027e514839d6c7dbd7ef45f00a4ededa" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;data-functor-identity#v:runIdentity&quot;&gt;runIdentity&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="translated">このインスタンスは、 &lt;code&gt;&lt;a href=&quot;data-functor-identity#v:runIdentity&quot;&gt;runIdentity&lt;/a&gt;&lt;/code&gt; フィールドが削除された場合、 &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; newtypeの派生インスタンスと同等になります。</target>
        </trans-unit>
        <trans-unit id="04b4bf75fa251a6d79ae490ffe498133e416deeb" translate="yes" xml:space="preserve">
          <source>This instructs the linker to add all symbols, not only used ones, to the dynamic symbol table. Currently Linux and Windows/MinGW32 only. This is equivalent to using &lt;code&gt;-optl -rdynamic&lt;/code&gt; on Linux, and &lt;code&gt;-optl -export-all-symbols&lt;/code&gt; on Windows.</source>
          <target state="translated">これは、使用中のシンボルだけでなく、すべてのシンボルを動的シンボルテーブルに追加するようにリンカーに指示します。現在、LinuxおよびWindows / MinGW32のみ。これは、Linuxでは &lt;code&gt;-optl -rdynamic&lt;/code&gt; 、Windowsでは &lt;code&gt;-optl -export-all-symbols&lt;/code&gt; を使用するのと同じです。</target>
        </trans-unit>
        <trans-unit id="d93a8b76f0ddcde6fb04d1a2d2bc4ce8187928c7" translate="yes" xml:space="preserve">
          <source>This instructs the linker to produce a position-independent executable. This flag is only valid while producing executables and all object code being linked must have been produced with &lt;a href=&quot;#ghc-flag--fPIE&quot;&gt;&lt;code&gt;-fPIE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、位置に依存しない実行可能ファイルを生成するようにリンカーに指示します。このフラグは、実行可能ファイルを生成している間のみ有効であり、リンクされるすべてのオブジェクトコードは&lt;a href=&quot;#ghc-flag--fPIE&quot;&gt; &lt;code&gt;-fPIE&lt;/code&gt; で&lt;/a&gt;生成されている必要があります。</target>
        </trans-unit>
        <trans-unit id="1f3eb5f30b0cea2845a0034105f6b2f42741738e" translate="yes" xml:space="preserve">
          <source>This interface was introduced for parsers by Niklas R&amp;ouml;jemo, because it admits more sharing than the monadic interface. The names here are mostly based on parsing work by Doaitse Swierstra.</source>
          <target state="translated">このインターフェイスは、モナディックインターフェイスよりも多くの共有を許可するため、NiklasR&amp;ouml;jemoによってパーサーのために導入されました。ここでの名前は、ほとんどがDoaitse Swierstraによる解析作業に基づいています。</target>
        </trans-unit>
        <trans-unit id="2193f86cf24477bc6ea98a7a666bf4f097144114" translate="yes" xml:space="preserve">
          <source>This is &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:-62--36-&quot;&gt;&amp;gt;$&lt;/a&gt;&lt;/code&gt; with its arguments flipped.</source>
          <target state="translated">これは &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:-62--36-&quot;&gt;&amp;gt;$&lt;/a&gt;&lt;/code&gt; であり、引数は反転されています。</target>
        </trans-unit>
        <trans-unit id="853ad3fece6dfad54dfa810a5f259b18c1ca92df" translate="yes" xml:space="preserve">
          <source>This is a &quot;secure&quot; variant of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;mpz_powm_sec()&lt;/code&gt; function which is designed to be resilient to side channel attacks and is therefore intended for cryptographic applications.</source>
          <target state="translated">これは、「安全な」変異体である &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;mpz_powm_sec()&lt;/code&gt; サイドチャネル攻撃に弾力的であるように設計され、したがって、暗号アプリケーションのために意図されている機能。</target>
        </trans-unit>
        <trans-unit id="206d2c688e36d3f91786f4ad10d32b3bbd76f245" translate="yes" xml:space="preserve">
          <source>This is a change in behaviour relative to 6.2 and earlier.</source>
          <target state="translated">6.2以前との相対的な行動の変化です。</target>
        </trans-unit>
        <trans-unit id="00558cc92150447e28cfde519a9ac027ba98b199" translate="yes" xml:space="preserve">
          <source>This is a combination of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt;; ie. it takes the value from the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, puts it back, and also returns it.</source>
          <target state="translated">これは &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; の組み合わせです。すなわち。 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; から値を受け取り、元に戻し、それを返します。</target>
        </trans-unit>
        <trans-unit id="d6388ad09499896ee48a8e46a65f919073bd630f" translate="yes" xml:space="preserve">
          <source>This is a consequence of the requirement that all applications of a type family must be fully saturated with respect to their arity.</source>
          <target state="translated">これは、型ファミリーのすべてのアプリケーションが、そのアリティに関して完全に飽和していなければならないという要件の結果です。</target>
        </trans-unit>
        <trans-unit id="5cf7cdffdf7f677c3d65b226f0158c81eb00adc8" translate="yes" xml:space="preserve">
          <source>This is a good alternative to &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:addForeignSource&quot;&gt;addForeignSource&lt;/a&gt;&lt;/code&gt; when you are trying to directly link in an object file.</source>
          <target state="translated">これは、オブジェクトファイルに直接リンクする場合に、 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:addForeignSource&quot;&gt;addForeignSource&lt;/a&gt;&lt;/code&gt; に代わる優れた方法です。</target>
        </trans-unit>
        <trans-unit id="085ff8e3a0f8a72b0a54eeb21ca799400340b070" translate="yes" xml:space="preserve">
          <source>This is a good way to insulate your program from differences in the globally exposed packages, and being explicit about package dependencies is a Good Thing. Cabal always passes the &lt;code&gt;-hide-all-packages&lt;/code&gt; flag to GHC, for exactly this reason.</source>
          <target state="translated">これは、プログラムをグローバルに公開されたパッケージの違いから隔離する良い方法であり、パッケージの依存関係を明示することは良いことです。Cabalは常にこの理由で、常に &lt;code&gt;-hide-all-packages&lt;/code&gt; フラグをGHCに渡します。</target>
        </trans-unit>
        <trans-unit id="8027c0b11e662d6e52978de63e39356d25b88d32" translate="yes" xml:space="preserve">
          <source>This is a guide to using the Glasgow Haskell Compiler (GHC): an interactive and batch compilation system for the &lt;a href=&quot;http://www.haskell.org/&quot;&gt;Haskell 2010&lt;/a&gt; language.</source>
          <target state="translated">これは、グラスゴーのHaskellコンパイラ（GHC）を使用するためのガイドです&lt;a href=&quot;http://www.haskell.org/&quot;&gt;。Haskell2010&lt;/a&gt;言語用のインタラクティブなバッチコンパイルシステムです。</target>
        </trans-unit>
        <trans-unit id="c43f1cd29cf3fbfdaab28a7b865c723e0177f5eb" translate="yes" xml:space="preserve">
          <source>This is a length of time, as measured by UTC. It has a precision of 10^-12 s.</source>
          <target state="translated">これはUTCで測定した時間の長さです。10^-12秒の精度を持っています。</target>
        </trans-unit>
        <trans-unit id="b188ac0ba94d5b91f8dbb5c660aa1046ae2821a3" translate="yes" xml:space="preserve">
          <source>This is a length of time, as measured by a clock. Conversion functions will treat it as seconds. It has a precision of 10^-12 s.</source>
          <target state="translated">これは時計で測った時間の長さです。変換関数では秒として扱われます。精度は10^-12秒です。</target>
        </trans-unit>
        <trans-unit id="b931fc8ba0422aa66c49ca99c7502e98ce5770ff" translate="yes" xml:space="preserve">
          <source>This is a library of parser combinators, originally written by Koen Claessen. It parses all alternatives in parallel, so it never keeps hold of the beginning of the input string, a common source of space leaks with other parsers. The &lt;code&gt;(&lt;a href=&quot;text-parsercombinators-readp#v:-43--43--43-&quot;&gt;+++&lt;/a&gt;)&lt;/code&gt; choice combinator is genuinely commutative; it makes no difference which branch is &quot;shorter&quot;.</source>
          <target state="translated">これは、もともとKoen Claessenによって書かれたパーサコンビネータのライブラリです。すべての選択肢を並行して解析するため、他のパーサーとのスペースリークの一般的な原因である入力文字列の先頭を保持することはありません。 &lt;code&gt;(&lt;a href=&quot;text-parsercombinators-readp#v:-43--43--43-&quot;&gt;+++&lt;/a&gt;)&lt;/code&gt; 選択コンビネータは純粋に可換です。どのブランチが「短い」かは関係ありません。</target>
        </trans-unit>
        <trans-unit id="e42801ec302676ba22f8d444806417ba897f7527" translate="yes" xml:space="preserve">
          <source>This is a lot of information! However, most of it is actually merely meta-information that makes names of datatypes and constructors and more available on the type level.</source>
          <target state="translated">これはたくさんの情報です! しかし、実際にはそのほとんどが、データ型やコンストラクタなどの名前を型レベルで利用可能にするメタ情報にすぎません。</target>
        </trans-unit>
        <trans-unit id="80f7c821c90cd714f631d4e0a4b9d09aa6b02e5d" translate="yes" xml:space="preserve">
          <source>This is a minimal token definition for Haskell style languages. It defines the style of comments, valid identifiers and case sensitivity. It does not define any reserved words or operators.</source>
          <target state="translated">これはHaskellスタイル言語のための最小のトークン定義です。コメントのスタイル、有効な識別子、大文字小文字の区別を定義します。予約語や演算子は定義していません。</target>
        </trans-unit>
        <trans-unit id="7695f0f91603fc6b7578c654d8c907922e492b31" translate="yes" xml:space="preserve">
          <source>This is a minimal token definition for Java style languages. It defines the style of comments, valid identifiers and case sensitivity. It does not define any reserved words or operators.</source>
          <target state="translated">これはJavaスタイル言語のための最小限のトークン定義です。コメントのスタイル、有効な識別子、大文字小文字の区別を定義します。予約語や演算子は定義しない。</target>
        </trans-unit>
        <trans-unit id="fa0a32456a663556dc4c0ba610d08c21985dc005" translate="yes" xml:space="preserve">
          <source>This is a module for efficient stack traces. This stack trace implementation is considered low overhead. Basic usage looks like this:</source>
          <target state="translated">効率的なスタックトレースのためのモジュールです。このスタックトレースの実装は低オーバーヘッドと考えられています。基本的な使い方は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="d8d7e87f49a4a49c2284947686e2481c865a646c" translate="yes" xml:space="preserve">
          <source>This is a non-blocking version of &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt;. If the process is still running, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; is returned. If the process has exited, then &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; e&lt;/code&gt; is returned where &lt;code&gt;e&lt;/code&gt; is the exit code of the process.</source>
          <target state="translated">これは、 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; の非ブロッキングバージョンです。プロセスがまだ実行中の場合、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; も返されません。プロセスが終了した場合、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; e&lt;/code&gt; が返されます &lt;code&gt;e&lt;/code&gt; はプロセスの終了コードです。</target>
        </trans-unit>
        <trans-unit id="5bdec4fb766d4e0ba04b6cea6e7ffd45bb020610" translate="yes" xml:space="preserve">
          <source>This is a rather fragile arrangement, as generally a programmer expects &lt;code&gt;(*) a b&lt;/code&gt; to be equivalent to &lt;code&gt;a * b&lt;/code&gt;. With &lt;a href=&quot;#ghc-flag--Wstar-binder&quot;&gt;&lt;code&gt;-Wstar-binder&lt;/code&gt;&lt;/a&gt; we warn when this special treatment of &lt;code&gt;(*)&lt;/code&gt; takes place.</source>
          <target state="translated">これはかなり脆弱な配置であり、一般にプログラマーは &lt;code&gt;(*) a b&lt;/code&gt; が &lt;code&gt;a * b&lt;/code&gt; と同等であることを期待します。&lt;a href=&quot;#ghc-flag--Wstar-binder&quot;&gt; &lt;code&gt;-Wstar-binder&lt;/code&gt; &lt;/a&gt;のこの特別な処理するとき、私たちは警告する &lt;code&gt;(*)&lt;/code&gt; が行われます。</target>
        </trans-unit>
        <trans-unit id="bfbddac5a335e3a88e1f9114ff2652333aff0d5e" translate="yes" xml:space="preserve">
          <source>This is a slightly involved heuristic, but captures the situation of an imported module &lt;code&gt;N&lt;/code&gt; changing the behaviour of existing code. For example, if the second condition isn&amp;rsquo;t violated, then the module author &lt;code&gt;M&lt;/code&gt; must depend either on a type-class or type defined in &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">これは少し複雑なヒューリスティックですが、インポートされたモジュール &lt;code&gt;N&lt;/code&gt; が既存のコードの動作を変更する状況をキャプチャします。たとえば、2番目の条件に違反していない場合、モジュール作成者 &lt;code&gt;M&lt;/code&gt; は、型クラスまたは &lt;code&gt;N&lt;/code&gt; で定義された型に依存する必要があります。</target>
        </trans-unit>
        <trans-unit id="4721594427df43592a87eef3fe9a7c319440d2ac" translate="yes" xml:space="preserve">
          <source>This is a suitable definition for an &lt;code&gt;mtimes&lt;/code&gt; member of &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、適した定義である &lt;code&gt;mtimes&lt;/code&gt; のメンバー &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d950f78f6594d495d879d450f50f2aaabfabc86" translate="yes" xml:space="preserve">
          <source>This is a valid definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; for a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは有効な定義です &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; ため &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f7c8d617e149468fb4914e042ce1964608c94f4" translate="yes" xml:space="preserve">
          <source>This is a valid definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; for an idempotent &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、べき等 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; 有効な定義です。</target>
        </trans-unit>
        <trans-unit id="85d5215128cc4957be290b7930eb2a5cf73d213f" translate="yes" xml:space="preserve">
          <source>This is a valid definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; for an idempotent &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、べき等 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; 有効な定義です。</target>
        </trans-unit>
        <trans-unit id="172ab78ae87f58f1be94549d14a2e6f93c70f4c1" translate="yes" xml:space="preserve">
          <source>This is a variant of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;, where the finalizer is an arbitrary &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action. When it is invoked, the finalizer will run in a new thread.</source>
          <target state="translated">これは &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; の変形で、ファイナライザは任意の &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションです。呼び出されると、ファイナライザは新しいスレッドで実行されます。</target>
        </trans-unit>
        <trans-unit id="b4e325aa9ef040b927e3fb7ef2baa5b6a0f1b819" translate="yes" xml:space="preserve">
          <source>This is a variant of &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt;, where the finalizer is an arbitrary &lt;code&gt;IO&lt;/code&gt; action. When it is invoked, the finalizer will run in a new thread.</source>
          <target state="translated">これは &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt; の変形で、ファイナライザは任意の &lt;code&gt;IO&lt;/code&gt; アクションです。呼び出されると、ファイナライザは新しいスレッドで実行されます。</target>
        </trans-unit>
        <trans-unit id="371673f71c58c2e9cdb85387820977d33c4caf49" translate="yes" xml:space="preserve">
          <source>This is a way to look at the pointer living inside a foreign object. This function takes a function which is applied to that pointer. The resulting &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action is then executed. The foreign object is kept alive at least during the whole action, even if it is not used directly inside. Note that it is not safe to return the pointer from the action and use it after the action completes. All uses of the pointer should be inside the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; bracket. The reason for this unsafeness is the same as for &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; below: the finalizer may run earlier than expected, because the compiler can only track usage of the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; object, not a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; object made from it.</source>
          <target state="translated">これは、異物の中にあるポインタを見る方法です。この関数は、そのポインターに適用される関数を取ります。次に、結果の &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションが実行されます。異物は、内部で直接使用されていなくても、少なくともアクション全体を通して存続します。アクションからポインタを返して、アクションの完了後に使用することは安全ではないことに注意してください。ポインターのすべての使用は、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; ブラケット内にある必要があります。このunsafeness理由はと同じです &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; コンパイラのみの使用を追跡することができますので、ファイナライザは、予想よりも早く実行することがあります。以下 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; のオブジェクト、いない &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; それから作られたオブジェクトを。</target>
        </trans-unit>
        <trans-unit id="1bf47a6eebbbeb1a3756083812189988818bf7bb" translate="yes" xml:space="preserve">
          <source>This is a way to look at the pointer living inside a foreign object. This function takes a function which is applied to that pointer. The resulting &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action is then executed. The foreign object is kept alive at least during the whole action, even if it is not used directly inside. Note that it is not safe to return the pointer from the action and use it after the action completes. All uses of the pointer should be inside the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; bracket. The reason for this unsafeness is the same as for &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; below: the finalizer may run earlier than expected, because the compiler can only track usage of the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; object, not a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; object made from it.</source>
          <target state="translated">これは、異物の中にあるポインタを見る方法です。この関数は、そのポインターに適用される関数を取ります。次に、結果の &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションが実行されます。異物は、内部で直接使用されていなくても、少なくともアクション全体を通して存続します。アクションからポインタを返して、アクションの完了後に使用することは安全ではないことに注意してください。ポインターのすべての使用は、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; ブラケット内にある必要があります。このunsafeness理由はと同じです &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; コンパイラのみの使用を追跡することができますので、ファイナライザは、予想よりも早く実行することがあります。以下 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; のオブジェクト、いない &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; それから作られたオブジェクトを。</target>
        </trans-unit>
        <trans-unit id="0f341bdd202c5cbf36cfc8ae95ca15781837c676" translate="yes" xml:space="preserve">
          <source>This is a workaround for poor optimisation in GHC 6.8.2. It fails to notice constant-width shifts, and adds a test and branch to every shift. This imposes about a 10% performance hit.</source>
          <target state="translated">これは、GHC 6.8.2 の最適化が不十分な場合の回避策です。これは定数幅のシフトに気づかず、シフトごとにテストとブランチを追加します。これは約 10% のパフォーマンスの低下をもたらします。</target>
        </trans-unit>
        <trans-unit id="8c2b599fbba068d2e3306d55e3da89a6dea9c30d" translate="yes" xml:space="preserve">
          <source>This is almost the same as &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt;, but returns a quadruple consisting of the option arguments, a list of non-options, a list of unrecognized options, and a list of error messages.</source>
          <target state="translated">これは、 &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt; とほぼ同じですが、オプション引数、非オプションのリスト、認識されないオプションのリスト、およびエラーメッセージのリストで構成される4つの要素を返します。</target>
        </trans-unit>
        <trans-unit id="d0e2442d2a5176acfea0d861dcdf4c526699f651" translate="yes" xml:space="preserve">
          <source>This is almost the same as &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt;, except that &lt;code&gt;ghc-pkg dump&lt;/code&gt; is intended for use by tools that parse the results, so for example where &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt; will emit an error if it can&amp;rsquo;t find any packages that match the pattern, &lt;code&gt;ghc-pkg dump&lt;/code&gt; will simply emit nothing.</source>
          <target state="translated">これは &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt; とほぼ同じですが、 &lt;code&gt;ghc-pkg dump&lt;/code&gt; は結果を解析するツールによる使用を意図しているため、たとえば &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt; が可能な場合にエラーを出力します。 tパターンに一致するパッケージを見つけると、 &lt;code&gt;ghc-pkg dump&lt;/code&gt; は何も出力しません。</target>
        </trans-unit>
        <trans-unit id="7792587286beb0c2340a33dbd540974a7aa95716" translate="yes" xml:space="preserve">
          <source>This is also known as the catamorphism on trees.</source>
          <target state="translated">これは、木の上のカタモルフィズムとも呼ばれています。</target>
        </trans-unit>
        <trans-unit id="c1f05073a7db37870040709ee8825ace5ad9e27b" translate="yes" xml:space="preserve">
          <source>This is also the number of threads that will participate in parallel garbage collection. It is strongly recommended that the number of capabilities is not set larger than the number of physical processor cores, and it may often be beneficial to leave one or more cores free to avoid contention with other processes in the machine.</source>
          <target state="translated">これは、並列ガベージコレクションに参加するスレッドの数でもあります。能力の数は物理プロセッサのコア数よりも大きく設定しないことが強く推奨され、マシン内の他のプロセスとの競合を避けるために、1つ以上のコアを空けておくことが有益な場合もあります。</target>
        </trans-unit>
        <trans-unit id="beec198333c6e916a71dc2007f654bbfb496d115" translate="yes" xml:space="preserve">
          <source>This is always an integral type. Width and signedness are platform specific.</source>
          <target state="translated">これは常に積分型です。幅と符号付きはプラットフォーム固有のものです。</target>
        </trans-unit>
        <trans-unit id="2c94c1e0eafc78c19212557dee894b114bd63e4b" translate="yes" xml:space="preserve">
          <source>This is an alternative backend that uses the &lt;a href=&quot;http://llvm.org&quot;&gt;LLVM&lt;/a&gt; compiler to produce executable code. It generally produces code as with performance as good as the native code generator but for some cases can produce much faster code. This is especially true for numeric, array heavy code using packages like vector. The penalty is a significant increase in compilation times. Select the LLVM backend with the &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">これは、&lt;a href=&quot;http://llvm.org&quot;&gt;LLVM&lt;/a&gt;コンパイラを使用して実行可能コードを生成する代替バックエンドです。通常、ネイティブコードジェネレーターと同等のパフォーマンスでコードを生成しますが、場合によってははるかに高速なコードを生成できます。これは、ベクトルのようなパッケージを使用した、数値の配列が多いコードに特に当てはまります。ペナルティは、コンパイル時間の大幅な増加です。&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt;フラグを使用してLLVMバックエンドを選択します。</target>
        </trans-unit>
        <trans-unit id="b07234aad669def52b50175f945aeebcd045d700" translate="yes" xml:space="preserve">
          <source>This is an experimental feature, please let us know if it causes problems and/or could benefit from further tuning.</source>
          <target state="translated">これは実験的な機能ですので、問題が発生した場合や、さらなるチューニングが必要な場合はお知らせください。</target>
        </trans-unit>
        <trans-unit id="d518bb2db084fc2424d01684cf81e93ef233a006" translate="yes" xml:space="preserve">
          <source>This is an infix alias for &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; のインフィックスエイリアスです。</target>
        </trans-unit>
        <trans-unit id="101923d23a1c0936899b25445ac34361e56b2129" translate="yes" xml:space="preserve">
          <source>This is an infix version of &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; with the arguments flipped.</source>
          <target state="translated">これは、引数が反転した &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; のインフィックスバージョンです。</target>
        </trans-unit>
        <trans-unit id="58c0c8b3a56848782113a6355b13f876cdde90db" translate="yes" xml:space="preserve">
          <source>This is because &lt;code&gt;qsort&lt;/code&gt; is a polymorphic function, and because GHCi does not carry type information at runtime, it cannot determine the runtime types of free variables that involve type variables. Hence, when you ask to display &lt;code&gt;left&lt;/code&gt; at the prompt, GHCi can&amp;rsquo;t figure out which instance of &lt;code&gt;Show&lt;/code&gt; to use, so it emits the type error above.</source>
          <target state="translated">これは、 &lt;code&gt;qsort&lt;/code&gt; がポリモーフィック関数であり、GHCiは実行時に型情報を保持しないため、型変数が関係する自由変数の実行時型を判別できないためです。したがって、プロンプトで &lt;code&gt;left&lt;/code&gt; に表示するように要求すると、GHCiは使用する &lt;code&gt;Show&lt;/code&gt; のインスタンスを判別できないため、上記のタイプエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="31f122da1e52003fb749b42feb286b289a499229" translate="yes" xml:space="preserve">
          <source>This is common type used by &lt;code&gt;Natural&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;. As this type consists of a single constructor wrapping a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; it can be unpacked.</source>
          <target state="translated">これは、 &lt;code&gt;Natural&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; で使用される一般的なタイプです。この型は &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; をラップする単一のコンストラクターで構成されるため、アンパックできます。</target>
        </trans-unit>
        <trans-unit id="e46c9188c411a7574791b7db9d68e4a5ba400984" translate="yes" xml:space="preserve">
          <source>This is crucial to preserve correctness. Entities defined in other modules might rely on laziness for correctness (whether functional or performance).</source>
          <target state="translated">これは正しさを維持するために非常に重要です。他のモジュールで定義されているエンティティは、(機能的にも性能的にも)正しさのために怠惰に依存している可能性があります。</target>
        </trans-unit>
        <trans-unit id="ed31266df50c8047adeba9f8ad5ed4814f624b36" translate="yes" xml:space="preserve">
          <source>This is currently only returned by the following operations:</source>
          <target state="translated">これは現在のところ、以下の操作によってのみ返されます。</target>
        </trans-unit>
        <trans-unit id="69022b713a9a3be30ce145d8a3fa9a46d52862c0" translate="yes" xml:space="preserve">
          <source>This is dangerous territory, however. Here, for example, is a program that would make the typechecker loop:</source>
          <target state="translated">しかし、これは危険な領域です。例えば、ここではタイプチェッカをループさせるプログラムを紹介します。</target>
        </trans-unit>
        <trans-unit id="8bef230a1b33fc363b0b8397f3ec27a17fff06b4" translate="yes" xml:space="preserve">
          <source>This is definitely caused by a bug in GHC. Please report it (see &lt;a href=&quot;intro#bug-reporting&quot;&gt;Reporting bugs in GHC&lt;/a&gt;).</source>
          <target state="translated">これは間違いなくGHCのバグが原因です。報告してください（&lt;a href=&quot;intro#bug-reporting&quot;&gt;GHCのバグの報告を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="50509e11fe7ca6ff18f57510c20c4165a78570ab" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;if p then y else x&lt;/code&gt;; that is, one can think of it as an if-then-else construct with its arguments reordered.</source>
          <target state="translated">これは、 &lt;code&gt;if p then y else x&lt;/code&gt; と同じです。つまり、引数を並べ替えたif-then-else構文と考えることができます。</target>
        </trans-unit>
        <trans-unit id="ac94cb7c266f7957cc925f86fcff5b3aa8d29a4c" translate="yes" xml:space="preserve">
          <source>This is essentially a more performant version of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; that always returns the first result, if any. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは基本的に、より最初の結果を常に返す &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; のより高性能なバージョンです。詳細は &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; のドキュメントに記載されています。</target>
        </trans-unit>
        <trans-unit id="62b9a042aea0816af6e299c00f387f0402dcd3d1" translate="yes" xml:space="preserve">
          <source>This is essentially the same as if you had written &lt;code&gt;deriving Eq&lt;/code&gt; after the declaration for &lt;code&gt;data Foo a&lt;/code&gt;. Using this feature requires the use of &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;).</source>
          <target state="translated">これは基本的に、 &lt;code&gt;data Foo a&lt;/code&gt; 宣言後に &lt;code&gt;deriving Eq&lt;/code&gt; 記述した場合と同じです。この機能を使用するには、&lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;）を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="9595725d43f98726f370669a781ee6935055f745" translate="yes" xml:space="preserve">
          <source>This is essentially the same as if you had written &lt;code&gt;deriving Foo&lt;/code&gt; after the declaration for &lt;code&gt;data Foo a&lt;/code&gt;. Using this feature requires the use of &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;).</source>
          <target state="translated">これは、 &lt;code&gt;data Foo a&lt;/code&gt; 宣言後に &lt;code&gt;deriving Foo&lt;/code&gt; 記述した場合と本質的に同じです。この機能を使用するには、&lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;）を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="6d6cf1a68093409280369c1b6acf1d281e7ce24d" translate="yes" xml:space="preserve">
          <source>This is expected to improve performance on average, but actual performance difference can vary.</source>
          <target state="translated">平均的な性能向上が期待できますが、実際の性能差は様々です。</target>
        </trans-unit>
        <trans-unit id="9ac537ddcd723a43b8f01589d4e737eed3f70681" translate="yes" xml:space="preserve">
          <source>This is exposed solely for people writing GHC rewrite rules.</source>
          <target state="translated">これはGHCの書き換えルールを書いている人だけが晒されています。</target>
        </trans-unit>
        <trans-unit id="8f87cd084e7f91046e80a5ffa06a25dbafabc73f" translate="yes" xml:space="preserve">
          <source>This is for specialist applications that may require symbols defined in these Haskell libraries at runtime even though they aren&amp;rsquo;t referenced by any other code linked into the executable. If you&amp;rsquo;re using &lt;code&gt;-fwhole-archive-hs-libs&lt;/code&gt;, you probably also want &lt;code&gt;-rdynamic&lt;/code&gt;.</source>
          <target state="translated">これは、実行可能ファイルにリンクされた他のコードによって参照されていなくても、実行時にこれらのHaskellライブラリで定義されたシンボルを必要とする可能性のある専門的なアプリケーション用です。 &lt;code&gt;-fwhole-archive-hs-libs&lt;/code&gt; を使用している場合は、おそらく &lt;code&gt;-rdynamic&lt;/code&gt; も必要です。</target>
        </trans-unit>
        <trans-unit id="bb0b93f1aaeb2183a73344bfad7f37c373c52776" translate="yes" xml:space="preserve">
          <source>This is how to define &lt;code&gt;insertLookup&lt;/code&gt; using &lt;code&gt;insertLookupWithKey&lt;/code&gt;:</source>
          <target state="translated">これは、 &lt;code&gt;insertLookup&lt;/code&gt; WithKeyを使用して &lt;code&gt;insertLookupWithKey&lt;/code&gt; を定義する方法です。</target>
        </trans-unit>
        <trans-unit id="f42e6638d71ed609c1ebc5bfa4f5a4bdde5aa067" translate="yes" xml:space="preserve">
          <source>This is illegal because the use of &lt;a href=&quot;#extension-BangPatterns&quot;&gt;&lt;code&gt;BangPatterns&lt;/code&gt;&lt;/a&gt; on the right-hand sides prevents it from being a well formed expression. However, constructing a strict pattern synonym is quite possible with an explicitly bidirectional pattern synonym:</source>
          <target state="translated">右側に&lt;a href=&quot;#extension-BangPatterns&quot;&gt; &lt;code&gt;BangPatterns&lt;/code&gt; &lt;/a&gt;を使用すると、正しい形式にすることができなくなるため、これは違法です。ただし、厳密なパターンシノニムを構築することは、明示的に双方向のパターンシノニムを使用すると非常に可能です。</target>
        </trans-unit>
        <trans-unit id="8c0c93b41bba3d3d671093acebd3b256b511ac64" translate="yes" xml:space="preserve">
          <source>This is internally implemented as count-leading-zeros machine instruction.</source>
          <target state="translated">内部的には、カウント先頭ゼロのマシン命令として実装されています。</target>
        </trans-unit>
        <trans-unit id="852b04a3b6aa2150c763c2710aeb536c17bc4e95" translate="yes" xml:space="preserve">
          <source>This is just a convenience function, it's defined simply as:</source>
          <target state="translated">これはただの便利な機能で、単純に定義されています。</target>
        </trans-unit>
        <trans-unit id="e45e37056992d6af3645dca1e73531419ebe8cab" translate="yes" xml:space="preserve">
          <source>This is mostly done during Cmm passes. However this can miss corner cases. So at -O2 we run the pass again at the asm stage to catch these.</source>
          <target state="translated">これは主にCmmパスの時に行われます。しかし、これはコーナーケースを見逃してしまう可能性があります。そこで、-O2では、これらを捕捉するために、ASMの段階で再度パスを実行します。</target>
        </trans-unit>
        <trans-unit id="a5b597ca7719e3d8708a1e507512f84a11523c7d" translate="yes" xml:space="preserve">
          <source>This is normally used at the end of a set alternatives where we want to return an error message in terms of a higher level construct rather than returning all possible characters. For example, if the &lt;code&gt;expr&lt;/code&gt; parser from the &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; example would fail, the error message is: '...: expecting expression'. Without the &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; combinator, the message would be like '...: expecting &quot;let&quot; or letter', which is less friendly.</source>
          <target state="translated">これは通常、可能なすべての文字を返すのではなく、上位レベルの構成体に関してエラーメッセージを返したい代替セットの最後に使用されます。たとえば、 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; の例の &lt;code&gt;expr&lt;/code&gt; パーサーが失敗すると、エラーメッセージは次のようになります。なければ &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; あまりフレンドリーである、「『せ』期待や手紙...」コンビネータ、メッセージは次のようになります。</target>
        </trans-unit>
        <trans-unit id="39a3eeed9577807a13413d7d9a4747103d4ba578" translate="yes" xml:space="preserve">
          <source>This is normally used at the end of a set alternatives where we want to return an error message in terms of a higher level construct rather than returning all possible characters. For example, if the &lt;code&gt;expr&lt;/code&gt; parser from the &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; example would fail, the error message is: '...: expecting expression'. Without the &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; combinator, the message would be like '...: expecting &quot;let&quot; or letter', which is less friendly.</source>
          <target state="translated">これは通常、可能なすべての文字を返すのではなく、上位レベルの構成体に関してエラーメッセージを返したい代替セットの最後に使用されます。たとえば、 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; の例の &lt;code&gt;expr&lt;/code&gt; パーサーが失敗すると、エラーメッセージは次のようになります。なければ &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; あまりフレンドリーである、「『せ』期待や手紙...」コンビネータ、メッセージは次のようになります。</target>
        </trans-unit>
        <trans-unit id="c67587857810fc437f5fd2889f14753f716a50b7" translate="yes" xml:space="preserve">
          <source>This is not ideal in certain cases, like when the output is long, or contains strings with non-ascii characters.</source>
          <target state="translated">これは、出力が長い場合や、非 ASCII 文字を含む文字列を含む場合など、特定のケースでは理想的ではありません。</target>
        </trans-unit>
        <trans-unit id="19107584e7f459839bffc5515c49619c3a279acc" translate="yes" xml:space="preserve">
          <source>This is not processed for special chars. use stringToHtml or lineToHtml instead, for user strings, because they understand special chars, like &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#v:-60-&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは特殊文字の場合は処理されません。 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#v:-60-&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; のような特別な文字を理解するため、ユーザー文字列には代わりにstringToHtmlまたはlineToHtmlを使用してください。</target>
        </trans-unit>
        <trans-unit id="9eee7f5de1930e679b3ff1bf2b45247aa3e4891d" translate="yes" xml:space="preserve">
          <source>This is not processed for special chars. use stringToHtml or lineToHtml instead, for user strings, because they understand special chars, like &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#v:-60-&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは特別な文字では処理されません。ユーザー文字列には、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#v:-60-&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; などの特殊な文字を理解するため、代わりにstringToHtmlまたはlineToHtmlを使用してください。</target>
        </trans-unit>
        <trans-unit id="e7fa5f45c008c43283961b6bf73fec56028cc02f" translate="yes" xml:space="preserve">
          <source>This is particularly useful in conjunction with larger &lt;code&gt;-A&lt;/code&gt; values, for example &lt;code&gt;-A64m -n4m&lt;/code&gt; is a useful combination on larger core counts (8+).</source>
          <target state="translated">これは特に、より大きな &lt;code&gt;-A&lt;/code&gt; 値と組み合わせて使用​​すると便利です。たとえば、 &lt;code&gt;-A64m -n4m&lt;/code&gt; は、より大きなコア数（8+）での便利な組み合わせです。</target>
        </trans-unit>
        <trans-unit id="9eda36a1c5f71327f9a1ce36f39f69ceebc7a2ca" translate="yes" xml:space="preserve">
          <source>This is particularly useful with the &lt;code&gt;ViewPatterns&lt;/code&gt; extension to GHC, as follows:</source>
          <target state="translated">これは、次のように、GHC の &lt;code&gt;ViewPatterns&lt;/code&gt; 拡張機能で特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="f9953554c74c35663186a90c0246462e6382fb5f" translate="yes" xml:space="preserve">
          <source>This is rather similar to the class &lt;code&gt;IsString&lt;/code&gt; (see &lt;a href=&quot;#overloaded-strings&quot;&gt;Overloaded string literals&lt;/a&gt;), but with an additional type parameter that makes the text of the label available as a type-level string (see &lt;a href=&quot;#type-level-literals&quot;&gt;Type-Level Literals&lt;/a&gt;). Note that &lt;code&gt;fromLabel&lt;/code&gt; had an extra &lt;code&gt;Proxy# x&lt;/code&gt; argument in GHC 8.0, but this was removed in GHC 8.2 as a type application (see &lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;) can be used instead.</source>
          <target state="translated">これはクラス &lt;code&gt;IsString&lt;/code&gt; に似ていますが（&lt;a href=&quot;#overloaded-strings&quot;&gt;オーバーロードされた文字列リテラルを&lt;/a&gt;参照）、ラベルのテキストをタイプレベルの文字列として使用できるようにする追加のタイプパラメーターがあります（&lt;a href=&quot;#type-level-literals&quot;&gt;タイプレベルリテラルを&lt;/a&gt;参照）。注こと &lt;code&gt;fromLabel&lt;/code&gt; は余分だった &lt;code&gt;Proxy# x&lt;/code&gt; GHC 8.0で引数を、これは（参照型アプリケーションとしてGHC 8.2で削除された&lt;a href=&quot;#visible-type-application&quot;&gt;可視型アプリケーションを&lt;/a&gt;代わりに使用することができます）。</target>
        </trans-unit>
        <trans-unit id="275797ad44149a221def0ee243441fcab463f9bc" translate="yes" xml:space="preserve">
          <source>This is rejected because there is no &amp;ldquo;outermost level&amp;rdquo; for the types on the RHS (it would obviously be terrible to add extra parameters to &lt;code&gt;PackMap&lt;/code&gt;), so no implicit quantification happens, and the declaration is rejected (with &amp;ldquo;&lt;code&gt;f&lt;/code&gt; is out of scope&amp;rdquo;). Solution: use an explicit &lt;code&gt;forall&lt;/code&gt;:</source>
          <target state="translated">これは拒否されます &lt;code&gt;PackMap&lt;/code&gt; の型には「最外レベル」がないためです（PackMapにパラメーターを追加するのは明らかにひどいでしょう）。暗黙的な数量化は行われず、宣言は拒否されます（「 &lt;code&gt;f&lt;/code&gt; はスコープ外です」」）。解決策：明示的な &lt;code&gt;forall&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="965462ce779e5c5398c7b7c8822c6fe46cd11f7e" translate="yes" xml:space="preserve">
          <source>This is rejected by Haskell 98, but under Jones&amp;rsquo;s scheme the definition for &lt;code&gt;g&lt;/code&gt; is typechecked first, separately from that for &lt;code&gt;f&lt;/code&gt;, because the reference to &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s right hand side is ignored by the dependency analysis. Then &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s type is generalised, to get</source>
          <target state="translated">これはHaskell 98では拒否されていますが、ジョーンズのスキームでは、 &lt;code&gt;g&lt;/code&gt; の右側の &lt;code&gt;f&lt;/code&gt; への参照が依存関係分析によって無視されるため、 &lt;code&gt;f&lt;/code&gt; の定義とは別に、 &lt;code&gt;g&lt;/code&gt; の定義が最初にタイプチェックされます。次に &lt;code&gt;g&lt;/code&gt; の型を一般化して、</target>
        </trans-unit>
        <trans-unit id="af9e5e6b5a1471403ba13a39e6cf598e61cc7f1f" translate="yes" xml:space="preserve">
          <source>This is rejected by Haskell 98, but under Jones&amp;rsquo;s scheme the definition for &lt;code&gt;g&lt;/code&gt; is typechecked first, separately from that for &lt;code&gt;f&lt;/code&gt;, because the reference to &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s right hand side is ignored by the dependency analysis. Then &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s type is generalised, to get</source>
          <target state="translated">これはハスケル98によって拒絶されるが、ジョーンズのスキームの下での定義 &lt;code&gt;g&lt;/code&gt; をするための第1の型検査され、別々にそれから &lt;code&gt;f&lt;/code&gt; を参照するために、 &lt;code&gt;f&lt;/code&gt; で &lt;code&gt;g&lt;/code&gt; 「の右手側は、依存関係分析では無視されます。次に、 &lt;code&gt;g&lt;/code&gt; のタイプを一般化して、</target>
        </trans-unit>
        <trans-unit id="173eae666fe7062188303aaed7c3e9e91b4501ad" translate="yes" xml:space="preserve">
          <source>This is set to &lt;code&gt;1&lt;/code&gt; when the compiler supports Template Haskell, and to &lt;code&gt;0&lt;/code&gt; when not. The latter is the case for a stage-1 compiler during bootstrapping, or on architectures where the interpreter is not available.</source>
          <target state="translated">コンパイラがテンプレートHaskellをサポートしている場合は &lt;code&gt;1&lt;/code&gt; に設定され、サポートしていない場合は &lt;code&gt;0&lt;/code&gt; に設定されます。後者は、ブートストラップ中のステージ1コンパイラーの場合、またはインタープリターが使用できないアーキテクチャーの場合です。</target>
        </trans-unit>
        <trans-unit id="e2a9fd34e0777a91dc7abb06fe3e0b3098e9ec74" translate="yes" xml:space="preserve">
          <source>This is suitable even for abstract types, as the laws for &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; imply a form of associativity.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; の法則は結合性の形式を意味するため、これは抽象型にも適しています。</target>
        </trans-unit>
        <trans-unit id="e5265ef186d0fe504d07549453be769b06cb5de9" translate="yes" xml:space="preserve">
          <source>This is suitable even for abstract types, as the laws for &lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; imply a form of associativity.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; の法則は結合性の形式を意味するため、これは抽象型にも適しています。</target>
        </trans-unit>
        <trans-unit id="886cde162909e5053a7382858de7970df163c591" translate="yes" xml:space="preserve">
          <source>This is suitable even for abstract types, as the monoid is assumed to satisfy the monoid laws. Alternatively, one could define &lt;code&gt;foldr&lt;/code&gt;:</source>
          <target state="translated">モノイドはモノイドの法則を満たすと想定されるため、これは抽象型にも適しています。あるいは、 &lt;code&gt;foldr&lt;/code&gt; を定義することもできます。</target>
        </trans-unit>
        <trans-unit id="bbe2ee805fe872cdfa9dad562a94abbdd44ba100" translate="yes" xml:space="preserve">
          <source>This is suitable for datatypes that are exported transparently.</source>
          <target state="translated">透過的にエクスポートされるデータ型に適しています。</target>
        </trans-unit>
        <trans-unit id="fb6774461de6668cb4c86bcd9b2d0f93d1213ac5" translate="yes" xml:space="preserve">
          <source>This is the &quot;back door&quot; into the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad, allowing &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to be performed at any time. For this to be safe, the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation should be free of side effects and independent of its environment.</source>
          <target state="translated">これは &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドへの「バックドア」であり、いつでも &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 計算を実行できます。これを安全に行うには、 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 計算に副作用がなく、その環境に依存しないようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="e076e79d373c95008b4305220e373d648e1a35dc" translate="yes" xml:space="preserve">
          <source>This is the &quot;back door&quot; into the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad, allowing &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to be performed at any time. For this to be safe, the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation should be free of side effects and independent of its environment.</source>
          <target state="translated">これは &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドへの「バックドア」であり、いつでも &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 計算を実行できます。これを安全に行うには、 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 計算に副作用がなく、その環境に依存しないようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="fbf56641bd07ddb82df111a846a14d313459064a" translate="yes" xml:space="preserve">
          <source>This is the analogue of the &lt;code&gt;LINE&lt;/code&gt; pragma and is likewise intended for use in automatically generated Haskell code. It lets you specify the column number of the original code; for example</source>
          <target state="translated">これは &lt;code&gt;LINE&lt;/code&gt; プラグマに類似しており、同様に自動生成されたHaskellコードでの使用を目的としています。元のコードの列番号を指定できます。例えば</target>
        </trans-unit>
        <trans-unit id="5c9cf33d55e8504f25f0586b2ca2f9cf2d7a74c1" translate="yes" xml:space="preserve">
          <source>This is the defined behaviour of &lt;code&gt;getContents&lt;/code&gt;: it puts the stdin Handle in a state known as semi-closed, wherein any further I/O operations on it are forbidden. Because I/O state is retained between computations, the semi-closed state persists until the next &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">これは &lt;code&gt;getContents&lt;/code&gt; の定義された動作です。stdinHandleをセミクローズと呼ばれる状態にします。この状態でのそれ以上のI / O操作は禁止されます。I / O状態は計算間で保持されるため、セミクローズ状態は次の&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt;コマンドまで持続します。</target>
        </trans-unit>
        <trans-unit id="d59a26993924ddd4622ca180b22b28d96a32273b" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">これは、 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; の基本的な戦術です。</target>
        </trans-unit>
        <trans-unit id="a8cafe2ab0917d4201e6879d83ae5338339737b2" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">これは、 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; の基本的な戦術です。</target>
        </trans-unit>
        <trans-unit id="f6167f3d89f3a57f13ddc1cfc30ba818a1c14f35" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">これは、 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; の基本的な戦術です。</target>
        </trans-unit>
        <trans-unit id="1d382c742dccd9be34f30f4a4585a36c280b6334" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">これは、 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; の基本的な戦術です。</target>
        </trans-unit>
        <trans-unit id="cbc6595af04522c2fde6302bbc4d97ab2ecf3276" translate="yes" xml:space="preserve">
          <source>This is the initial locale encoding: if it has been subsequently changed by &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:setLocaleEncoding&quot;&gt;setLocaleEncoding&lt;/a&gt;&lt;/code&gt; this value will not reflect that change.</source>
          <target state="translated">これは初期ロケールエンコーディングです。その後 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:setLocaleEncoding&quot;&gt;setLocaleEncoding&lt;/a&gt;&lt;/code&gt; によって変更された場合、この値はその変更を反映しません。</target>
        </trans-unit>
        <trans-unit id="abd17a970d52fd304b594c189a551764634555bd" translate="yes" xml:space="preserve">
          <source>This is the magic cut-off figure for unfolding (aka inlining): below this size, a function definition will be unfolded at the call-site, any bigger and it won&amp;rsquo;t. The size computed for a function depends on two things: the actual size of the expression minus any discounts that apply depending on the context into which the expression is to be inlined.</source>
          <target state="translated">これは展開（つまりインライン化）の魔法のカットオフ図です。このサイズより下では、関数定義は呼び出しサイトで展開されますが、それより大きくても展開されません。関数に対して計算されるサイズは、2つの要素に依存します。式の実際のサイズから、式がインライン化されるコンテキストに応じて適用される割引を差し引いたものです。</target>
        </trans-unit>
        <trans-unit id="67b68027f5d62fd3f61a1b54666f56f7507aeca1" translate="yes" xml:space="preserve">
          <source>This is the most basic way to make your program go faster. Compilation time will be slower, especially with &lt;code&gt;-O2&lt;/code&gt;.</source>
          <target state="translated">これは、プログラムを高速化する最も基本的な方法です。特に &lt;code&gt;-O2&lt;/code&gt; を使用すると、コンパイル時間が遅くなります。</target>
        </trans-unit>
        <trans-unit id="da3c5884261af5d6c5ce2a2fefd25b97aeda4835" translate="yes" xml:space="preserve">
          <source>This is the most general interface for building a weak pointer.</source>
          <target state="translated">これは、弱いポインタを構築するための最も一般的なインタフェースです。</target>
        </trans-unit>
        <trans-unit id="5dbbb7f4bd171d6e5fe3f02c892e785922548729" translate="yes" xml:space="preserve">
          <source>This is the most general of the grouping-type statements. In this form, f is required to have type &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [[a]]&lt;/code&gt;. As with the &lt;code&gt;then f by e&lt;/code&gt; case above, the first argument is a function supplied to f by the compiler which lets it compute e on every element of the list being transformed. However, unlike the non-grouping case, f additionally partitions the list into a number of sublists: this means that at every point after this statement, binders occurring before it in the comprehension refer to &lt;em&gt;lists&lt;/em&gt; of possible values, not single values. To help understand this, let&amp;rsquo;s look at an example:</source>
          <target state="translated">これは、最も一般的なグループ化タイプのステートメントです。この形式では、fには &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [[a]]&lt;/code&gt; 型が必要です。（a-&amp;gt; t）-&amp;gt; [a]-&amp;gt; [[a]]。上記の &lt;code&gt;then f by e&lt;/code&gt; の場合と同様に、最初の引数は、変換されるリストのすべての要素でeを計算できるようにするコンパイラーによってfに提供される関数です。ただし、非グループ化の場合とは異なり、fはリストをいくつかのサブリストにさらに分割します。つまり、このステートメントの後のすべての時点で、内包でその前に現れるバインダーは、単一の値ではなく、可能な値の&lt;em&gt;リスト&lt;/em&gt;を参照し&lt;em&gt;ます&lt;/em&gt;。これを理解するために、例を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="97cacebb8a50334f0aa10455086684215843c90c" translate="yes" xml:space="preserve">
          <source>This is the most general way to spawn an external process. The process can be a command line to be executed by a shell or a raw command with a list of arguments. The stdin, stdout, and stderr streams of the new process may individually be attached to new pipes, to existing &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s, or just inherited from the parent (the default.)</source>
          <target state="translated">これは、外部プロセスを生成する最も一般的な方法です。プロセスは、シェルによって実行されるコマンドライン、または引数のリストを含むrawコマンドです。新しいプロセスのstdin、stdout、およびstderrストリームは、新しいパイプ、既存の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; に個別に接続するか、または親から継承することができます（デフォルト）。</target>
        </trans-unit>
        <trans-unit id="17c6bc999a6e66cdf70760668583b194f94060fb" translate="yes" xml:space="preserve">
          <source>This is the most minimal token definition. It is recommended to use this definition as the basis for other definitions. &lt;code&gt;emptyDef&lt;/code&gt; has no reserved names or operators, is case sensitive and doesn't accept comments, identifiers or operators.</source>
          <target state="translated">これは最小のトークン定義です。この定義を他の定義の基礎として使用することをお勧めします。 &lt;code&gt;emptyDef&lt;/code&gt; には予約名や演算子はなく、大文字と小文字が区別され、コメント、識別子、または演算子を受け入れません。</target>
        </trans-unit>
        <trans-unit id="28714170914c36c5937fb4d6795c7183bf135afa" translate="yes" xml:space="preserve">
          <source>This is the most primitive combinator for accepting tokens. For example, the &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:char&quot;&gt;char&lt;/a&gt;&lt;/code&gt; parser could be implemented as:</source>
          <target state="translated">これは、トークンを受け入れるための最も原始的なコンビネーターです。たとえば、 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:char&quot;&gt;char&lt;/a&gt;&lt;/code&gt; パーサーは次のように実装できます。</target>
        </trans-unit>
        <trans-unit id="c028e89a3d3ce63ac917bdfc38f641c5b46ea80a" translate="yes" xml:space="preserve">
          <source>This is the oldest code generator in GHC and is generally not included any more having been deprecated around GHC 7.0. Select it with the &lt;a href=&quot;#ghc-flag--fvia-C&quot;&gt;&lt;code&gt;-fvia-C&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">これはGHCで最も古いコードジェネレーターであり、GHC 7.0で廃止されたため、通常は含まれていません。&lt;a href=&quot;#ghc-flag--fvia-C&quot;&gt; &lt;code&gt;-fvia-C&lt;/code&gt; &lt;/a&gt;フラグを付けて選択します。</target>
        </trans-unit>
        <trans-unit id="6b5e00d2ed34cf00eb62f197974c932b271f59b3" translate="yes" xml:space="preserve">
          <source>This is the oldest code generator in GHC and is generally not included any more having been deprecated around GHC 7.0. Select it with the &lt;code&gt;-fvia-C&lt;/code&gt; flag.</source>
          <target state="translated">これはGHCで最も古いコードジェネレーターであり、GHC 7.0で非推奨になったため、通常は含まれていません。 &lt;code&gt;-fvia-C&lt;/code&gt; フラグで選択します。</target>
        </trans-unit>
        <trans-unit id="3ef0a3e02d26e1de4897c94f804fb945f14b00c6" translate="yes" xml:space="preserve">
          <source>This is the simplest of the exception-catching functions. It takes a single argument, runs it, and if an exception is raised the &quot;handler&quot; is executed, with the value of the exception passed as an argument. Otherwise, the result is returned as normal. For example:</source>
          <target state="translated">これは例外キャッチ関数の中で最もシンプルなものです。1つの引数を受け取って実行し、例外が発生した場合には、例外の値を引数として渡した「ハンドラ」が実行されます。そうでなければ、結果は通常通りに返されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="709bbf178e88d31284082a439684f263fe4c4cba" translate="yes" xml:space="preserve">
          <source>This is the simplest representation of UTC. It consists of the day number, and a time offset from midnight. Note that if a day has a leap second added to it, it will have 86401 seconds.</source>
          <target state="translated">これはUTCの最も単純な表現です。これは、日番号と真夜中からの時間オフセットで構成されています。日にうるう秒が追加された場合、86401秒になることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e4dbe9128e5734a5df9b1f11da3e326916a92167" translate="yes" xml:space="preserve">
          <source>This is the traditional batch-compiler mode, in which GHC can compile source files one at a time, or link objects together into an executable. See &lt;a href=&quot;#options-order&quot;&gt;Batch compiler mode&lt;/a&gt;.</source>
          <target state="translated">これは従来のバッチコンパイラモードで、GHCはソースファイルを一度に1つずつコンパイルしたり、オブジェクトをリンクして実行可能ファイルにしたりできます。&lt;a href=&quot;#options-order&quot;&gt;バッチコンパイラモードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="63579352bd238619f1e8291119e93600ef4a9cde" translate="yes" xml:space="preserve">
          <source>This is the type of a field formatter reified over its argument.</source>
          <target state="translated">これは、フィールドフォーマッタがその引数の上に再定義されたタイプです。</target>
        </trans-unit>
        <trans-unit id="e04da25499a8419831fe5bf0581bda0dfaf2d2e9" translate="yes" xml:space="preserve">
          <source>This is thrown when the user calls &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;. The first &lt;code&gt;String&lt;/code&gt; is the argument given to &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;, second &lt;code&gt;String&lt;/code&gt; is the location.</source>
          <target state="translated">これは、ユーザーが &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; を呼び出したときにスローされます。最初の &lt;code&gt;String&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; に与えられた引数で、2番目の &lt;code&gt;String&lt;/code&gt; は場所です。</target>
        </trans-unit>
        <trans-unit id="a3b52992dd96200ef77ecde2d026b069e2b12589" translate="yes" xml:space="preserve">
          <source>This is used for holes or unresolved identifiers in AST quotes. Note that it could either have a variable name or constructor name.</source>
          <target state="translated">これは、ASTの引用符に穴が開いていたり、解決されていない識別子がある場合に使用します。変数名かコンストラクタ名のどちらかを指定することに注意してください。</target>
        </trans-unit>
        <trans-unit id="328c1fbc5f4cd720ec3ec26821113be04b4a5990" translate="yes" xml:space="preserve">
          <source>This is used to import functions written in Cmm code that follow an internal GHC calling convention. The arguments and results must be unboxed types, except that an argument may be of type &lt;code&gt;Any&lt;/code&gt; (by way of &lt;code&gt;unsafeCoerce#&lt;/code&gt;) and the result type is allowed to be an unboxed tuple or the type &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">これは、内部GHC呼び出し規約に従うCmmコードで記述された関数をインポートするために使用されます。引数と結果はボックス化されていない型である必要があります。ただし、引数の型は（ &lt;code&gt;unsafeCoerce#&lt;/code&gt; によって） &lt;code&gt;Any&lt;/code&gt; であり、結果の型はボックス化されていないタプルまたは &lt;code&gt;Any&lt;/code&gt; 型にすることができます。</target>
        </trans-unit>
        <trans-unit id="8b782ef95535f2b46a643a86d5559d4d59530093" translate="yes" xml:space="preserve">
          <source>This is useful for functions parameterized by a monad transformer.</source>
          <target state="translated">これは、モナド変換器によってパラメータ化された関数に便利です。</target>
        </trans-unit>
        <trans-unit id="191eaf7a7c1efa9d12f4d0ead171eac959ffb8bd" translate="yes" xml:space="preserve">
          <source>This is useful in combination with &lt;a href=&quot;#ghc-flag--dinitial-unique=%E2%9F%A8s%E2%9F%A9&quot;&gt;&lt;code&gt;-dinitial-unique=⟨s⟩&lt;/code&gt;&lt;/a&gt; to test if the generated files depend on the order of &lt;code&gt;Unique&lt;/code&gt;&amp;lsquo;s.</source>
          <target state="translated">これは&lt;a href=&quot;#ghc-flag--dinitial-unique=%E2%9F%A8s%E2%9F%A9&quot;&gt; &lt;code&gt;-dinitial-unique=⟨s⟩&lt;/code&gt; &lt;/a&gt;と組み合わせて使用すると、生成されたファイルが &lt;code&gt;Unique&lt;/code&gt; の順序に依存しているかどうかをテストするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="eb2802e19e3cc64605ff63d36592512d32cabe42" translate="yes" xml:space="preserve">
          <source>This is useful in combination with &lt;a href=&quot;#ghc-flag--dinitial-unique=%E2%9F%A8s%E2%9F%A9&quot;&gt;&lt;code&gt;-dinitial-unique=⟨s⟩&lt;/code&gt;&lt;/a&gt; to test if the generated files depend on the order of &lt;code&gt;Unique&lt;/code&gt;&amp;rsquo;s.</source>
          <target state="translated">これは、&lt;a href=&quot;#ghc-flag--dinitial-unique=%E2%9F%A8s%E2%9F%A9&quot;&gt; &lt;code&gt;-dinitial-unique=⟨s⟩&lt;/code&gt; &lt;/a&gt;と組み合わせて、生成されたファイルが &lt;code&gt;Unique&lt;/code&gt; の順序に依存しているかどうかをテストするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="d104180869342bc19c17c8e3619b3cc9055aa1fa" translate="yes" xml:space="preserve">
          <source>This is why the RIO module is compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;&amp;gt;, to allow the &lt;code&gt;Danger&lt;/code&gt; module to import it. The &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; flag doesn&amp;rsquo;t place any restrictions on the module like &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; does (expect to restrict overlapping instances to &lt;a href=&quot;#safe-overlapping-instances&quot;&gt;safe overlapping instances&lt;/a&gt;). Instead the module author claims that while code may use unsafe features internally, it only exposes an API that can used in a safe manner.</source>
          <target state="translated">これが、 &lt;code&gt;Danger&lt;/code&gt; モジュールがインポートできるように、RIOモジュールが&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; &amp;gt;でコンパイルされている理由です。&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;旗のようなモジュール上の任意の制限をかけない&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;（にインスタンスの重複制限するために期待しない&lt;a href=&quot;#safe-overlapping-instances&quot;&gt;安全なオーバーラップインスタンス&lt;/a&gt;）。代わりに、モジュールの作成者は、コードが内部的に安全でない機能を使用する可能性がある一方で、安全な方法で使用できるAPIしか公開しないと主張しています。</target>
        </trans-unit>
        <trans-unit id="b712b2b82446ae28f73908890d2ef7531e15ac14" translate="yes" xml:space="preserve">
          <source>This is widely considered a misfeature, and is going to be removed from the language. In GHC, it is controlled by the deprecated extension &lt;code&gt;DatatypeContexts&lt;/code&gt;.</source>
          <target state="translated">これは広く誤用と見なされ、言語から削除されます。GHCでは、非推奨の拡張 &lt;code&gt;DatatypeContexts&lt;/code&gt; によって制御されます。</target>
        </trans-unit>
        <trans-unit id="6778bfd500940c8e2d9a62565cee855196c0bd56" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t particularly enlightening. What happened is that &lt;code&gt;left&lt;/code&gt; is bound to an unevaluated computation (a suspension, or thunk), and &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; does not force any evaluation. The idea is that &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; can be used to inspect values at a breakpoint without any unfortunate side effects. It won&amp;rsquo;t force any evaluation, which could cause the program to give a different answer than it would normally, and hence it won&amp;rsquo;t cause any exceptions to be raised, infinite loops, or further breakpoints to be triggered (see &lt;a href=&quot;#nested-breakpoints&quot;&gt;Nested breakpoints&lt;/a&gt;). Rather than forcing thunks, &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; binds each thunk to a fresh variable beginning with an underscore, in this case &lt;code&gt;_t1&lt;/code&gt;.</source>
          <target state="translated">これは特に賢明ではありません。何が起こったかというと、 &lt;code&gt;left&lt;/code&gt; は評価されていない計算（一時停止、またはサンク）にバインドされており、&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;は評価を強制しません。アイデアは、&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;を使用して、不幸な副作用なしにブレークポイントで値を検査できることです。これは、プログラムに通常とは異なる答えを与える原因となる可能性がある評価を強制しません。したがって、例外が発生したり、無限ループが発生したり、さらにブレークポイントがトリガーされたりしません（&lt;a href=&quot;#nested-breakpoints&quot;&gt;ネストされたブレークポイントを&lt;/a&gt;参照）。 。サンクを強制するのではなく、&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;は各サンクをアンダースコアで始まる新しい変数（この場合は &lt;code&gt;_t1&lt;/code&gt; )にバインドします。</target>
        </trans-unit>
        <trans-unit id="a27ce07dfb7b638358503a182b9e384fb7c6d870" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the whole story: GHC also looks for modules in pre-compiled libraries, known as packages. See the section on packages (&lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;) for details.</source>
          <target state="translated">これだけではありません。GHCは、パッケージと呼ばれるコンパイル済みライブラリ内のモジュールも検索します。詳細については、パッケージ（&lt;a href=&quot;packages#packages&quot;&gt;パッケージ&lt;/a&gt;）のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="e058359ab2e82e0cac7dd3d00a96ceff57c41dfb" translate="yes" xml:space="preserve">
          <source>This kind is similar to the kind of &lt;code&gt;ProxyKInvis&lt;/code&gt;, but with a key difference: the type variables quantified by the &lt;code&gt;forall&lt;/code&gt; are followed by an arrow (&lt;code&gt;-&amp;gt;&lt;/code&gt;), not a dot (&lt;code&gt;.&lt;/code&gt;). This is a visible, dependent quantifier. It is visible in that it the user must pass in a type for &lt;code&gt;k&lt;/code&gt; explicitly, and it is dependent in the sense that &lt;code&gt;k&lt;/code&gt; appears later in the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;. As a counterpart, the &lt;code&gt;k&lt;/code&gt; binder in &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; can be thought of as an &lt;em&gt;invisible&lt;/em&gt;, dependent quantifier.</source>
          <target state="translated">この種のようなものに似ている &lt;code&gt;ProxyKInvis&lt;/code&gt; が、重要な違いで：によって定量化型変数 &lt;code&gt;forall&lt;/code&gt; 矢印が続く（ &lt;code&gt;-&amp;gt;&lt;/code&gt; ）ではなく、ドット（ &lt;code&gt;.&lt;/code&gt; ）。これは、目に見える、依存する数量詞です。ユーザーが &lt;code&gt;k&lt;/code&gt; の型を明示的に渡す必要があることは明らかであり、 &lt;code&gt;k&lt;/code&gt; が後で &lt;code&gt;ProxyKVis&lt;/code&gt; の種類で表示されるという意味で依存しています。カウンターパートとして、 &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; &lt;code&gt;k&lt;/code&gt; バインダー。 k-&amp;gt;タイプは、&lt;em&gt;目に見えない&lt;/em&gt;従属数量詞と考えることができます。</target>
        </trans-unit>
        <trans-unit id="a1decd194e9db593e0098385b29579f07d63ab43" translate="yes" xml:space="preserve">
          <source>This lack of kind inference is simply an engineering problem within GHC, but getting it to work would make a substantial change to the inference infrastructure, and it&amp;rsquo;s not clear the payoff is worth it. If you want to restrict &lt;code&gt;b&lt;/code&gt;&amp;lsquo;s kind in the instance above, just use a kind signature in the instance head.</source>
          <target state="translated">この種の推論の欠如は、GHC内のエンジニアリングの問題にすぎませんが、それを機能させると、推論インフラストラクチャに大幅な変更が加えられ、その見返りが価値があるかどうかは不明です。上記のインスタンスで &lt;code&gt;b&lt;/code&gt; の種類を制限する場合は、インスタンスヘッドで種類シグネチャを使用します。</target>
        </trans-unit>
        <trans-unit id="35e744da89ea652776d7de1d49ded5a0e6370630" translate="yes" xml:space="preserve">
          <source>This lack of kind inference is simply an engineering problem within GHC, but getting it to work would make a substantial change to the inference infrastructure, and it&amp;rsquo;s not clear the payoff is worth it. If you want to restrict &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s kind in the instance above, just use a kind signature in the instance head.</source>
          <target state="translated">この種類の推論の欠如は、GHC内のエンジニアリングの問題にすぎませんが、それを機能させると、推論インフラストラクチャに大幅な変更が加えられ、その見返りに価値があるかどうかは明らかではありません。上記のインスタンスで &lt;code&gt;b&lt;/code&gt; の種類を制限する場合は、インスタンスヘッドで種類の署名を使用するだけです。</target>
        </trans-unit>
        <trans-unit id="9700917da64757c5e788e69e5482f32627c03338" translate="yes" xml:space="preserve">
          <source>This legacy module provides access to the list-specialised operations of &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;. This module may go away again in future GHC versions and is provided as transitional tool to access some of the list-specialised operations that had to be generalised due to the implementation of the &lt;a href=&quot;https://wiki.haskell.org/Foldable_Traversable_In_Prelude&quot;&gt;Foldable/Traversable-in-Prelude Proposal (FTP)&lt;/a&gt;.</source>
          <target state="translated">このレガシーモジュールは、&lt;a href=&quot;data-list&quot;&gt;Data.Listの&lt;/a&gt;リスト専用の操作へのアクセスを提供します。このモジュールは将来のGHCバージョンで再びなくなる可能性があり、&lt;a href=&quot;https://wiki.haskell.org/Foldable_Traversable_In_Prelude&quot;&gt;Foldable / Traversable-in-Prelude Proposal（FTP）&lt;/a&gt;の実装のために一般化する必要があったリスト専用の操作にアクセスするための移行ツールとして提供されます。</target>
        </trans-unit>
        <trans-unit id="e36c09f207f2c815a09c379dd1fb2c4090b7e037" translate="yes" xml:space="preserve">
          <source>This lets you use a difference list of a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; as a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これにより、 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 差分リストを &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; として使用できます。</target>
        </trans-unit>
        <trans-unit id="9ae93c187283325d394ffe8b8fa3d56bccb015c1" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a floating point value. Returns the value of the number. The number is parsed according to the grammar rules defined in the Haskell report.</source>
          <target state="translated">この字句解析器は、浮動小数点値を解析します。数値の値を返します。数値は、Haskellレポートで定義されている文法ルールに従って解析されます。</target>
        </trans-unit>
        <trans-unit id="527289d10a300c5f304dffa89904edeb2b163f3d" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal identifier. Returns the identifier string. This parser will fail on identifiers that are reserved words. Legal identifier (start) characters and reserved words are defined in the &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;identifier&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この語彙素パーサーは、正当な識別子を解析します。識別子文字列を返します。このパーサーは、予約語である識別子では失敗します。法的識別子（開始）文字と予約語は、 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; に渡される &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; で定義されます。 &lt;code&gt;identifier&lt;/code&gt; 使用して単一のトークンとして扱われる &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="163be1f77c7bb2337562a94b4777b7e5c72dc90c" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal identifier. Returns the identifier string. This parser will fail on identifiers that are reserved words. Legal identifier (start) characters and reserved words are defined in the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;identifier&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この語彙素パーサーは、正当な識別子を解析します。識別子文字列を返します。このパーサーは、予約語である識別子では失敗します。法的識別子（開始）文字と予約語は、 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; に渡される &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; で定義されます。 &lt;code&gt;identifier&lt;/code&gt; 使用して単一のトークンとして扱われる &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7bd0992deca5f231a8e4bc4885419bb1a6bfcba7" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal operator. Returns the name of the operator. This parser will fail on any operators that are reserved operators. Legal operator (start) characters and reserved operators are defined in the &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;operator&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この語彙素パーサーは、合法的な演算子を解析します。演算子の名前を返します。このパーサーは、予約済みの演算子である場合は失敗します。 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 演算子（開始）文字と予約済み演算子は、makeTokenParserに渡される &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; で定義されます。 &lt;code&gt;operator&lt;/code&gt; 使用して単一のトークンとして扱われる &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="76e90133adb94e7c3876b0dc934a4c349e00e9fd" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal operator. Returns the name of the operator. This parser will fail on any operators that are reserved operators. Legal operator (start) characters and reserved operators are defined in the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;operator&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この語彙素パーサーは、合法的な演算子を解析します。演算子の名前を返します。このパーサーは、予約済みの演算子である場合は失敗します。 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 演算子（開始）文字と予約済み演算子は、makeTokenParserに渡される &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; で定義されます。 &lt;code&gt;operator&lt;/code&gt; 使用して単一のトークンとして扱われる &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4009cc9448509a74e6a8d7bad513db7193f58fd" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a literal string. Returns the literal string value. This parsers deals correctly with escape sequences and gaps. The literal string is parsed according to the grammar rules defined in the Haskell report (which matches most programming languages quite closely).</source>
          <target state="translated">この字句解析器は、リテラル文字列を解析します。リテラル文字列の値を返します。このパーサはエスケープシーケンスやギャップを正しく処理します。リテラル文字列は、Haskellレポートで定義されている文法規則に従って解析されます(ほとんどのプログラミング言語と非常に密接に一致しています)。</target>
        </trans-unit>
        <trans-unit id="5e7e07a35842fb9e4e49f081c6500aa5f24d9520" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a natural number (a positive whole number). Returns the value of the number. The number can be specified in &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt;. The number is parsed according to the grammar rules in the Haskell report.</source>
          <target state="translated">この語彙素パーサーは、自然数（正の整数）を解析します。数値の値を返します。数値は、 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 数、または &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt; 数で指定できます。数値は、Haskellレポートの文法規則に従って解析されます。</target>
        </trans-unit>
        <trans-unit id="ace0ef235b44c04e9847cae55d4c39fc3655ea48" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a natural number (a positive whole number). Returns the value of the number. The number can be specified in &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt;. The number is parsed according to the grammar rules in the Haskell report.</source>
          <target state="translated">この語彙素パーサーは、自然数（正の整数）を解析します。数値の値を返します。数値は、 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 数、または &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt; 数で指定できます。数値は、Haskellレポートの文法規則に従って解析されます。</target>
        </trans-unit>
        <trans-unit id="5b51da9dfdc6deacb56625f72d3743f1f276426c" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a single literal character. Returns the literal character value. This parsers deals correctly with escape sequences. The literal character is parsed according to the grammar rules defined in the Haskell report (which matches most programming languages quite closely).</source>
          <target state="translated">この字句解析器は、単一のリテラル文字を解析します。リテラル文字の値を返します。このパーサはエスケープシーケンスを正しく処理します。リテラル文字は、Haskellレポートで定義されている文法規則に従って解析されます(ほとんどのプログラミング言語と非常に密接に一致しています)。</target>
        </trans-unit>
        <trans-unit id="df49a67e0891da13df2aeac391d3a61690541ebd" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses an integer (a whole number). This parser is like &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; except that it can be prefixed with sign (i.e. '-' or '+'). Returns the value of the number. The number can be specified in &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt;. The number is parsed according to the grammar rules in the Haskell report.</source>
          <target state="translated">この語彙素パーサーは、整数（整数）を解析します。このパーサーは、接頭辞に符号（つまり、「-」または「+」）を付けることができることを除いて、 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; 似ています。数値の値を返します。数値は、 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 数、または &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt; 数で指定できます。数値は、Haskellレポートの文法規則に従って解析されます。</target>
        </trans-unit>
        <trans-unit id="ca0065c43e88f0ea0be37c852f441cefb8de14a7" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses an integer (a whole number). This parser is like &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; except that it can be prefixed with sign (i.e. '-' or '+'). Returns the value of the number. The number can be specified in &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt;. The number is parsed according to the grammar rules in the Haskell report.</source>
          <target state="translated">この語彙素パーサーは、整数（整数）を解析します。このパーサーは、接頭辞に符号（つまり、「-」または「+」）を付けることができることを除いて、 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; 似ています。数値の値を返します。数値は、 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 数、または &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt; 数で指定できます。数値は、Haskellレポートの文法規則に従って解析されます。</target>
        </trans-unit>
        <trans-unit id="bf7d3fe039b607009e325c09fadc027724bbba18" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses either &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:float&quot;&gt;float&lt;/a&gt;&lt;/code&gt;. Returns the value of the number. This parsers deals with any overlap in the grammar rules for naturals and floats. The number is parsed according to the grammar rules defined in the Haskell report.</source>
          <target state="translated">この語彙素パーサーは、 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:float&quot;&gt;float&lt;/a&gt;&lt;/code&gt; のいずれかを解析します。数値の値を返します。このパーサーは、Naturalsとfloatの文法規則の重複を扱います。数値は、Haskellレポートで定義されている文法規則に従って解析されます。</target>
        </trans-unit>
        <trans-unit id="4cc0de1ff1da25f44b1ba64f4600fc6b2f58174a" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses either &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:float&quot;&gt;float&lt;/a&gt;&lt;/code&gt;. Returns the value of the number. This parsers deals with any overlap in the grammar rules for naturals and floats. The number is parsed according to the grammar rules defined in the Haskell report.</source>
          <target state="translated">この語彙素パーサーは、 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:float&quot;&gt;float&lt;/a&gt;&lt;/code&gt; のいずれかを解析します。数値の値を返します。このパーサーは、Naturalsとfloatの文法規則の重複を扱います。数値は、Haskellレポートで定義されている文法規則に従って解析されます。</target>
        </trans-unit>
        <trans-unit id="8b3e538648d90a568eed7b3e4b7980db877318e7" translate="yes" xml:space="preserve">
          <source>This lexer is not completely faithful to the Haskell lexical syntax in the following respects:</source>
          <target state="translated">この辞書は、以下の点でHaskellの辞書構文に完全には忠実ではありません。</target>
        </trans-unit>
        <trans-unit id="ba0c905e7229e2d42cfbc9060686e3e8b51c3edc" translate="yes" xml:space="preserve">
          <source>This library defines parser combinators for precedence parsing.</source>
          <target state="translated">このライブラリは、優先順位解析のためのパーサ・コンビネータを定義します。</target>
        </trans-unit>
        <trans-unit id="26d58c3f8313372fb9a5712eb67174707d34b82e" translate="yes" xml:space="preserve">
          <source>This library provides facilities for parsing the command-line options in a standalone program. It is essentially a Haskell port of the GNU &lt;code&gt;getopt&lt;/code&gt; library.</source>
          <target state="translated">このライブラリは、スタンドアロンプ​​ログラムでコマンドラインオプションを解析する機能を提供します。これは本質的にGNU &lt;code&gt;getopt&lt;/code&gt; ライブラリのHaskell移植版です。</target>
        </trans-unit>
        <trans-unit id="dd805dfecd7f77257c432c66329c165e81f0fc28" translate="yes" xml:space="preserve">
          <source>This library provides support for &lt;em&gt;strict&lt;/em&gt; state threads, as described in the PLDI '94 paper by John Launchbury and Simon Peyton Jones &lt;em&gt;Lazy Functional State Threads&lt;/em&gt;.</source>
          <target state="translated">このライブラリは、John LaunchburyとSimon Peyton Jones &lt;em&gt;Lazy Functional State Threadsに&lt;/em&gt;よるPLDI '94ペーパーで説明されているように、&lt;em&gt;厳密な&lt;/em&gt;状態のスレッドをサポートします。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8126030a0db08f6efcbf327884b71cf1e6318582" translate="yes" xml:space="preserve">
          <source>This limitation is easily subvertible, so please ask if you get stuck on it.</source>
          <target state="translated">この制限は簡単にサブバーされてしまうので、引っかかったら聞いてみてください。</target>
        </trans-unit>
        <trans-unit id="21a515f07e3c656c64c893fcd677dfba412563b8" translate="yes" xml:space="preserve">
          <source>This list could readily be extended; if there are Prelude functions that you use a lot which are not included, please tell us.</source>
          <target state="translated">このリストは簡単に拡張することができます。もし、あなたがよく使っているプレリュード関数の中に含まれていないものがあれば、教えてください。</target>
        </trans-unit>
        <trans-unit id="c9d77f7a9ab7e1d50b50bd600bb71a7967ecbbfb" translate="yes" xml:space="preserve">
          <source>This list is for GHC users to chat among themselves. If you have a specific question about GHC, please check the &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/FAQ&quot;&gt;FAQ&lt;/a&gt; first.</source>
          <target state="translated">このリストは、GHCユーザー同士がチャットするためのものです。GHCについて具体的な質問がある場合は、まず&lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/FAQ&quot;&gt;FAQ&lt;/a&gt;を確認してください。</target>
        </trans-unit>
        <trans-unit id="29a814259d6babfac9ea76d85ac921a5f02baa19" translate="yes" xml:space="preserve">
          <source>This macro is available starting GHC 8.0. It is defined for every exposed package. This macro expands to a string recording the version of &lt;code&gt;pkgname&lt;/code&gt; that is exposed for module import. It is identical in behavior to the &lt;code&gt;VERSION_pkgname&lt;/code&gt; macros that Cabal defines.</source>
          <target state="translated">このマクロはGHC 8.0以降で使用できます。すべての公開パッケージに対して定義されています。このマクロは、モジュールのインポート用に公開されている &lt;code&gt;pkgname&lt;/code&gt; のバージョンを記録する文字列に展開されます。Cabalが定義する &lt;code&gt;VERSION_pkgname&lt;/code&gt; マクロと動作は同じです。</target>
        </trans-unit>
        <trans-unit id="a74c45d8cbbb98f3219b81a76db9cbe9b302bc7d" translate="yes" xml:space="preserve">
          <source>This macro is available starting GHC 8.0. It is defined for every exposed package. This macro is provided for convenience to write CPP conditionals testing if a package version is &lt;code&gt;x.y.z&lt;/code&gt; or later. It is identical in behavior to the &lt;code&gt;MIN_VERSION_pkgname&lt;/code&gt; macros that Cabal defines.</source>
          <target state="translated">このマクロはGHC 8.0以降で使用できます。すべての公開パッケージに対して定義されています。このマクロは、パッケージのバージョンが &lt;code&gt;x.y.z&lt;/code&gt; 以降の場合にCPP条件付きテストを作成するために提供されています。これは、Cabalが定義する &lt;code&gt;MIN_VERSION_pkgname&lt;/code&gt; マクロと動作が同じです。</target>
        </trans-unit>
        <trans-unit id="369c31dee13e7ebf7250f99f560cae58a6ec67ab" translate="yes" xml:space="preserve">
          <source>This macro is available starting with GHC 7.10.1.</source>
          <target state="translated">このマクロはGHC 7.10.1から利用可能です。</target>
        </trans-unit>
        <trans-unit id="78b70fd2d98680d3ba8f51b750ceee956a98a51c" translate="yes" xml:space="preserve">
          <source>This macro is provided for convenience to write CPP conditionals testing whether the GHC version used is version &lt;code&gt;x.y.z.z'&lt;/code&gt; or later.</source>
          <target state="translated">このマクロは、使用されるGHCバージョンがバージョン &lt;code&gt;x.y.z.z'&lt;/code&gt; 以降であるかどうかをテストするCPP条件を記述するために提供されています。</target>
        </trans-unit>
        <trans-unit id="9ccb8c1a1ef41b359721ee50eeb5b0ffe5456b94" translate="yes" xml:space="preserve">
          <source>This macro is set when pre-processing both Haskell source and C source, including the C source generated from a Haskell module (i.e. &lt;code&gt;.hs&lt;/code&gt;, &lt;code&gt;.lhs&lt;/code&gt;, &lt;code&gt;.c&lt;/code&gt; and &lt;code&gt;.hc&lt;/code&gt; files).</source>
          <target state="translated">このマクロは、Haskellモジュールから生成されたCソース（つまり、 &lt;code&gt;.hs&lt;/code&gt; 、 &lt;code&gt;.lhs&lt;/code&gt; 、 &lt;code&gt;.c&lt;/code&gt; 、および &lt;code&gt;.hc&lt;/code&gt; ファイル）を含む、HaskellソースとCソースの両方を前処理するときに設定されます。</target>
        </trans-unit>
        <trans-unit id="126816cfbceb17265259c1bfd692cfa851e88117" translate="yes" xml:space="preserve">
          <source>This makes a copy, so does not retain the input string.</source>
          <target state="translated">これはコピーを作成するので、入力文字列を保持しません。</target>
        </trans-unit>
        <trans-unit id="409b9c14a753a56835750678eec0ceed50896009" translate="yes" xml:space="preserve">
          <source>This makes it convenient for printing the values of interesting variables or expressions inside a function. For example here we print the value of the variables &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;:</source>
          <target state="translated">これは、関数内の興味深い変数または式の値を出力するのに便利です。たとえば、ここでは変数 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の値を出力します。</target>
        </trans-unit>
        <trans-unit id="d154b682a58894f927011c8dcf1525090a6bca45" translate="yes" xml:space="preserve">
          <source>This may take real work, but&amp;hellip; There exist piles of massively-tuned library code, and the best thing is not to compete with it, but link with it.</source>
          <target state="translated">これには実際の作業が必要な場合がありますが&amp;hellip;大規模に調整されたライブラリコードの山が存在します。最善のことは、競合するのではなく、リンクすることです。</target>
        </trans-unit>
        <trans-unit id="8e305a9c2249a611331558008a6864ebdcc9df92" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has better performance than &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;f&lt;/code&gt; が個別の元のキーを個別の結果キーにマッピングすることを意味します。この関数は、 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; よりもパフォーマンスが優れています。</target>
        </trans-unit>
        <trans-unit id="a2f7283b2f57776282bb867fc6a49c83c2f23c8b" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has better performance than &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;f&lt;/code&gt; が個別の元のキーを個別の結果キーにマッピングすることを意味します。この関数は、 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; よりもパフォーマンスが優れています。</target>
        </trans-unit>
        <trans-unit id="1d65304cb52af71023e15bd45422c06447d534f9" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has slightly better performance than &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;f&lt;/code&gt; が個別の元のキーを個別の結果キーにマッピングすることを意味します。この関数のパフォーマンスは、 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; よりもわずかに優れています。</target>
        </trans-unit>
        <trans-unit id="9f79e70de4e10cc28ee0029d0a6a35c1bbea2e78" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has slightly better performance than &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;f&lt;/code&gt; が個別の元のキーを個別の結果キーにマッピングすることを意味します。この関数のパフォーマンスは、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; よりもわずかに優れています。</target>
        </trans-unit>
        <trans-unit id="5f2b22c1be27f1ee28d05bb2aade303875940243" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has slightly better performance than &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;f&lt;/code&gt; が個別の元のキーを個別の結果キーにマッピングすることを意味します。この関数のパフォーマンスは、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; よりもわずかに優れています。</target>
        </trans-unit>
        <trans-unit id="9c92fe3388c138613ddb9738050b4232a8c3e292" translate="yes" xml:space="preserve">
          <source>This means that if you need to make a foreign call to a function that takes a long time or blocks indefinitely, then you should mark it &lt;code&gt;safe&lt;/code&gt; and use &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;. Some library functions make such calls internally; their documentation should indicate when this is the case.</source>
          <target state="translated">つまり、長時間かかる関数や無期限にブロックする関数を外部から呼び出す必要がある場合は、 &lt;code&gt;safe&lt;/code&gt; とマークし、&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;を使用する必要があります。一部のライブラリ関数は、そのような呼び出しを内部で行います。彼らのドキュメントは、これが事実であるときを示すべきです。</target>
        </trans-unit>
        <trans-unit id="c345f7d8502440fe1972767e0230a2d484f96fc3" translate="yes" xml:space="preserve">
          <source>This means that many operations on sequences are stricter than those on lists. For example,</source>
          <target state="translated">これは、配列に対する多くの操作が、リスト上の操作よりも厳密であることを意味します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="512d8c4339c4e152167f7ed6529861156bdd0ce2" translate="yes" xml:space="preserve">
          <source>This means that the usual string syntax can be used, e.g., for &lt;code&gt;ByteString&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt;, and other variations of string like types. String literals behave very much like integer literals, i.e., they can be used in both expressions and patterns. If used in a pattern the literal will be replaced by an equality test, in the same way as an integer literal is.</source>
          <target state="translated">これは、通常の文字列構文を使用できることを意味します。たとえば、 &lt;code&gt;ByteString&lt;/code&gt; 、 &lt;code&gt;Text&lt;/code&gt; 、およびタイプのような文字列の他のバリエーションです。文字列リテラルは整数リテラルと非常によく似ています。つまり、式とパターンの両方で使用できます。パターンで使用すると、リテラルは整数リテラルと同じように等価テストに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="6e84b7b55ab4e53c7918a9eed0f0386ae7086f12" translate="yes" xml:space="preserve">
          <source>This means we're all done. All the builder data has now been written.</source>
          <target state="translated">これで全て終了です。これで全てのビルダーデータが書き込まれました。</target>
        </trans-unit>
        <trans-unit id="a699a362a2564a3c76496bfcaced4dda0fd71569" translate="yes" xml:space="preserve">
          <source>This mechanism makes use of GHC's efficient built-in generics support.</source>
          <target state="translated">このメカニズムは、GHCの効率的な組み込みジェネリックサポートを利用しています。</target>
        </trans-unit>
        <trans-unit id="ed8ed8da55dd83a0ef130774f673009214846879" translate="yes" xml:space="preserve">
          <source>This method is surprisingly useful. Where both instances exist and are lawful we have the following laws:</source>
          <target state="translated">この方法は意外と便利です。両方のインスタンスが存在し、合法である場合、我々は次のような法律を持っています。</target>
        </trans-unit>
        <trans-unit id="917ff2b24c3401ef265e4f82c89c8ae89e4dbe83" translate="yes" xml:space="preserve">
          <source>This method uses &lt;code&gt;&lt;a href=&quot;data-bits#v:clearBit&quot;&gt;clearBit&lt;/a&gt; (&lt;a href=&quot;data-bits#v:bit&quot;&gt;bit&lt;/a&gt; 0) 0&lt;/code&gt; as its default implementation (which ought to be equivalent to &lt;code&gt;&lt;a href=&quot;data-bits#v:zeroBits&quot;&gt;zeroBits&lt;/a&gt;&lt;/code&gt; for types which possess a 0th bit).</source>
          <target state="translated">このメソッドは、デフォルトの実装として &lt;code&gt;&lt;a href=&quot;data-bits#v:clearBit&quot;&gt;clearBit&lt;/a&gt; (&lt;a href=&quot;data-bits#v:bit&quot;&gt;bit&lt;/a&gt; 0) 0&lt;/code&gt; を使用します（0番目のビットを持つ型の &lt;code&gt;&lt;a href=&quot;data-bits#v:zeroBits&quot;&gt;zeroBits&lt;/a&gt;&lt;/code&gt; と同等である必要があります）。</target>
        </trans-unit>
        <trans-unit id="a56c576252b7c2f659be8b6306ca50d283138678" translate="yes" xml:space="preserve">
          <source>This mode is the default if there are any Haskell source files mentioned on the command line, and in this case the &lt;a href=&quot;#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; option can be omitted.</source>
          <target state="translated">コマンドラインで言及されたHaskellソースファイルがある場合、このモードがデフォルトです。この場合、&lt;a href=&quot;#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;オプションは省略できます。</target>
        </trans-unit>
        <trans-unit id="5aa78e5fdb695de8a1ddc90859fa15ef056bc6c5" translate="yes" xml:space="preserve">
          <source>This mode is very similar to interactive mode, except that there is a single expression to evaluate which is specified on the command line as an argument to the &lt;code&gt;-e&lt;/code&gt; option:</source>
          <target state="translated">このモードは、 &lt;code&gt;-e&lt;/code&gt; オプションの引数としてコマンドラインで指定される評価する単一の式があることを除いて、インタラクティブモードに非常に似ています。</target>
        </trans-unit>
        <trans-unit id="c36679dee1440f17c5d2fe66c1ebdd875fd933fe" translate="yes" xml:space="preserve">
          <source>This module also contains generalisations of &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;prelude#v:divMod&quot;&gt;divMod&lt;/a&gt;&lt;/code&gt; to work with any &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">このモジュールには、 &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; インスタンスを &lt;code&gt;&lt;a href=&quot;prelude#v:divMod&quot;&gt;divMod&lt;/a&gt;&lt;/code&gt; するための &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; 、およびdivModの一般化も含まれています。</target>
        </trans-unit>
        <trans-unit id="f4d1e1a6706fb58eb88829be1d42c2470d6cd3f3" translate="yes" xml:space="preserve">
          <source>This module can be imported for defining forward compatible &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; instances:</source>
          <target state="translated">このモジュールは、上位互換性のある &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; インスタンスを定義するためにインポートできます。</target>
        </trans-unit>
        <trans-unit id="6e27f3d7a593111ec01d1dd70cd801444f3e1d34" translate="yes" xml:space="preserve">
          <source>This module contains platform specific information about types. __/As such the types presented on this page reflect the platform on which the documentation was generated and may not coincide with the types on your platform./__</source>
          <target state="translated">このモジュールには、型に関するプラットフォーム固有の情報が含まれています。このページで提示されている型は、ドキュメントが生成されたプラットフォームを反映したものであり、あなたのプラットフォームの型とは一致しないかもしれません。</target>
        </trans-unit>
        <trans-unit id="69fea24c1770ed9b0390c085efc99817f8d87553" translate="yes" xml:space="preserve">
          <source>This module contains support for pooled memory management. Under this scheme, (re-)allocations belong to a given pool, and everything in a pool is deallocated when the pool itself is deallocated. This is useful when &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; with its implicit allocation and deallocation is not flexible enough, but explicit uses of &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; are too awkward.</source>
          <target state="translated">このモジュールには、プールされたメモリ管理のサポートが含まれています。このスキームでは、（再）割り当ては特定のプールに属し、プール自体が割り当て解除されると、プール内のすべてが割り当て解除されます。これは、暗黙的な割り当てと割り当て解除を伴う &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; が十分に柔軟ではないが、 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; の明示的な使用が厄介である場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="13d5f93e40c79a18376dc00ca5c87434053f0a7f" translate="yes" xml:space="preserve">
          <source>This module currently does not expose functions that require the special properties of fixed-size primitives. They are useful for prefixing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s with their size or for implementing chunked encodings. We will expose the corresponding functions in future releases of this library.</source>
          <target state="translated">このモジュールは現在、固定サイズのプリミティブの特別なプロパティを必要とする関数を公開していません。これらは、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; のサイズにプレフィックスを付ける場合、またはチャンクエンコーディングを実装する場合に役立ちます。このライブラリの今後のリリースで、対応する関数を公開します。</target>
        </trans-unit>
        <trans-unit id="5142c08054d9871661f7f0d130cb3d6fdd9407d3" translate="yes" xml:space="preserve">
          <source>This module defines a &quot;Fixed&quot; type for fixed-precision arithmetic. The parameter to &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; is any type that's an instance of &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; has a single method that gives the resolution of the &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">このモジュールは、固定精度演算の「固定」タイプを定義します。 &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; のパラメーターは、 &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; のインスタンスである任意のタイプです。 &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; には、 &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; 型の解決を提供する単一のメソッドがあります。</target>
        </trans-unit>
        <trans-unit id="c812190315e834b8c95ed3f2997592b7564b3fdf" translate="yes" xml:space="preserve">
          <source>This module defines an API for writing functions that merge two maps. The key functions are &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;. Each of these can be used with several different &quot;merge tactics&quot;.</source>
          <target state="translated">このモジュールは、2つのマップをマージする関数を作成するためのAPIを定義します。主な機能は、 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; です。これらはそれぞれ、いくつかの異なる「マージ戦術」で使用できます。</target>
        </trans-unit>
        <trans-unit id="748c4571f3ce28ef125886641fac7bef9890107e" translate="yes" xml:space="preserve">
          <source>This module defines an API for writing functions that merge two maps. The key functions are &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;. Each of these can be used with several different &quot;merge tactics&quot;.</source>
          <target state="translated">このモジュールは、2つのマップをマージする関数を作成するためのAPIを定義します。主な機能は、 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; です。これらはそれぞれ、いくつかの異なる「マージ戦術」で使用できます。</target>
        </trans-unit>
        <trans-unit id="75f0e64e356523d1a0c9eb699ad805d54ab82048" translate="yes" xml:space="preserve">
          <source>This module defines an API for writing functions that merge two maps. The key functions are &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;. Each of these can be used with several different &quot;merge tactics&quot;.</source>
          <target state="translated">このモジュールは、2つのマップをマージする関数を作成するためのAPIを定義します。主な機能は、 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; です。これらはそれぞれ、いくつかの異なる「マージ戦術」で使用できます。</target>
        </trans-unit>
        <trans-unit id="a495bc59840aa160735fbc988dd7aa12e8ba85b8" translate="yes" xml:space="preserve">
          <source>This module defines an API for writing functions that merge two maps. The key functions are &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;. Each of these can be used with several different &quot;merge tactics&quot;.</source>
          <target state="translated">このモジュールは、2つのマップをマージする関数を作成するためのAPIを定義します。主な機能は、 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; です。これらはそれぞれ、いくつかの異なる「マージ戦術」で使用できます。</target>
        </trans-unit>
        <trans-unit id="af9c5e66541cb60627fc011c4ff85f664b7cc4ed" translate="yes" xml:space="preserve">
          <source>This module defines bitwise operations for signed and unsigned integers. Instances of the class &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; types are available from this module, and instances for explicitly sized integral types are available from the &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt; and &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt; modules.</source>
          <target state="translated">このモジュールは、符号付きおよび符号なし整数のビットごとの演算を定義します。クラスのインスタンス &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; のため &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 及び &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; タイプは、このモジュールから入手可能であり、明示的なサイズの一体型タイプのインスタンスがから入手可能である&lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt;と&lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;モジュール。</target>
        </trans-unit>
        <trans-unit id="64cded15389022e2237acadfc2c3eed972bdb24d" translate="yes" xml:space="preserve">
          <source>This module defines the &lt;code&gt;&lt;a href=&quot;ghc-records#t:HasField&quot;&gt;HasField&lt;/a&gt;&lt;/code&gt; class used by the &lt;code&gt;OverloadedRecordFields&lt;/code&gt; extension. See the &amp;lt;&lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields&quot;&gt;https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields&lt;/a&gt; wiki page&amp;gt; for more details.</source>
          <target state="translated">このモジュールは、 &lt;code&gt;OverloadedRecordFields&lt;/code&gt; 拡張機能で使用される &lt;code&gt;&lt;a href=&quot;ghc-records#t:HasField&quot;&gt;HasField&lt;/a&gt;&lt;/code&gt; クラスを定義します。詳細については、&amp;lt; &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields&quot;&gt;https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields&lt;/a&gt; wiki page&amp;gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ec6eb416164cb4715d4e03695cde3fb980e473a9" translate="yes" xml:space="preserve">
          <source>This module defines the basic operations on I/O &quot;handles&quot;. All of the operations defined here are independent of the underlying device.</source>
          <target state="translated">このモジュールは、I/O「ハンドル」の基本操作を定義します。ここで定義されている操作はすべて、基礎となるデバイスから独立しています。</target>
        </trans-unit>
        <trans-unit id="d59bda9eaeaf5c1e3a36e9b88b617c773901fa3b" translate="yes" xml:space="preserve">
          <source>This module describes a structure intermediate between a functor and a monad (technically, a strong lax monoidal functor). Compared with monads, this interface lacks the full power of the binding operation &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;, but</source>
          <target state="translated">このモジュールでは、ファンクタとモナド（技術的には、強力な緩いモノイドのファンクタ）の中間の構造について説明します。モナドと比べて、このインタフェースは、結合動作のフルパワーを欠い &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 、しかし</target>
        </trans-unit>
        <trans-unit id="6da3e730b43c82c0b85f8ebac281848e3fc9fe3b" translate="yes" xml:space="preserve">
          <source>This module exports exactly the same API as &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt;, except that all file paths and environment strings are represented by &lt;code&gt;ByteString&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. The &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt; API implicitly translates all file paths and environment strings using the locale encoding, whereas this version of the API does no encoding or decoding and works directly in terms of raw bytes.</source>
          <target state="translated">このモジュールは、すべてのファイルパスと環境文字列が &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ではなく &lt;code&gt;ByteString&lt;/code&gt; で表されることを除いて、&lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt;とまったく同じAPIをエクスポートします。&lt;a href=&quot;system-posix&quot;&gt;System.Posixの&lt;/a&gt; APIのこのバージョンは何のエンコーディングを行わないか、復号して生のバイトの面で直接動作するのに対し、APIは暗黙のうちに、ロケールのエンコーディングを使用して、すべてのファイルパスと環境文字列を変換します。</target>
        </trans-unit>
        <trans-unit id="432a06fcd12fe64c315d994b347ca09ea56e286d" translate="yes" xml:space="preserve">
          <source>This module exports exactly the same API as &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt;, except that all file paths and environment strings are represented by &lt;code&gt;ByteString&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. The &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt; API implicitly translates all file paths and environment strings using the locale encoding, whereas this version of the API does no encoding or decoding and works directly in terms of raw bytes.</source>
          <target state="translated">このモジュールは、すべてのファイルパスと環境文字列が &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ではなく &lt;code&gt;ByteString&lt;/code&gt; で表されることを除いて、&lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt;とまったく同じAPIをエクスポートします。&lt;a href=&quot;system-posix&quot;&gt;System.Posixの&lt;/a&gt;APIのこのバージョンは何のエンコーディングを行わないか、復号して生のバイトの面で直接動作するのに対し、APIは暗黙のうちに、ロケールのエンコーディングを使用して、すべてのファイルパスと環境文字列を変換します。</target>
        </trans-unit>
        <trans-unit id="ae57a29c16b708a5f862b98209ca33ec88b9833b" translate="yes" xml:space="preserve">
          <source>This module exposes the &lt;em&gt;portable&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; API. See &lt;a href=&quot;ghc-integer-gmp-internals&quot;&gt;GHC.Integer.GMP.Internals&lt;/a&gt; for the &lt;code&gt;integer-gmp&lt;/code&gt;-specific internal representation of &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; as well as optimized GMP-specific operations.</source>
          <target state="translated">このモジュールは、&lt;em&gt;移植可能な&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; APIを公開します。 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;integer-gmp&lt;/code&gt; 固有の内部表現および最適化されたGMP固有の操作については、&lt;a href=&quot;ghc-integer-gmp-internals&quot;&gt;GHC.Integer.GMP.Internals&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3a94829165fdca15372f0126fd78a0b495ce0522" translate="yes" xml:space="preserve">
          <source>This module implements permutation parsers. The algorithm used is fairly complex since we push the type system to its limits :-) The algorithm is described in:</source>
          <target state="translated">このモジュールは、並べ替えパーサを実装しています。型システムをその限界まで押し上げているので、使用されているアルゴリズムはかなり複雑です :-)アルゴリズムについては</target>
        </trans-unit>
        <trans-unit id="c272683515777617630ed062550e54f1e41af5ba" translate="yes" xml:space="preserve">
          <source>This module includes GHC rewrite rules to optimize &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; functors. In general, these rules improve performance. The sole exception is that when using &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, deleting a key that is already absent takes longer than it would without the rules. If you expect this to occur a very large fraction of the time, you might consider using a private copy of the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">このモジュールには、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; ファンクタの &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; を最適化するGHC書き換えルールが含まれています。一般に、これらのルールはパフォーマンスを向上させます。唯一の例外は、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; を使用する場合、既に存在しないキーを削除すると、ルールがない場合よりも時間がかかることです。これが非常に大きな時間で発生すると予想される場合は、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; タイプのプライベートコピーの使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="96caa6e7405bbcf705758c402e5dc69c91123112" translate="yes" xml:space="preserve">
          <source>This module includes GHC rewrite rules to optimize &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; functors. In general, these rules improve performance. The sole exception is that when using &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, deleting a key that is already absent takes longer than it would without the rules. If you expect this to occur a very large fraction of the time, you might consider using a private copy of the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">このモジュールには、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; ファンクターの &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; を最適化するためのGHC書き換えルールが含まれています。一般に、これらのルールはパフォーマンスを向上させます。唯一の例外は、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; を使用する場合、すでに存在しないキーの削除には、ルールがない場合よりも時間がかかることです。これが非常に大きな時間で発生すると予想される場合は、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; タイプのプライベートコピーの使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="480d93e68fd6dc10a57cdf9aae6e88c254901353" translate="yes" xml:space="preserve">
          <source>This module includes GHC rewrite rules to optimize &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; functors. In general, these rules improve performance. The sole exception is that when using &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, deleting a key that is already absent takes longer than it would without the rules. If you expect this to occur a very large fraction of the time, you might consider using a private copy of the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">このモジュールには、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; ファンクタの &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; を最適化するGHC書き換えルールが含まれています。一般に、これらのルールはパフォーマンスを向上させます。唯一の例外は、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; を使用する場合、既に存在しないキーを削除すると、ルールがない場合よりも時間がかかることです。これが非常に大きな時間で発生すると予想される場合は、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; タイプのプライベートコピーの使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="824034cfb4513aba4aa1c338187313dac84e67aa" translate="yes" xml:space="preserve">
          <source>This module includes GHC rewrite rules to optimize &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; functors. In general, these rules improve performance. The sole exception is that when using &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, deleting a key that is already absent takes longer than it would without the rules. If you expect this to occur a very large fraction of the time, you might consider using a private copy of the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">このモジュールには、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; ファンクターの &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; を最適化するためのGHC書き換えルールが含まれています。一般に、これらのルールはパフォーマンスを向上させます。唯一の例外は、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; を使用する場合、すでに存在しないキーの削除には、ルールがない場合よりも時間がかかることです。これが非常に大きな時間で発生すると予想される場合は、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; タイプのプライベートコピーの使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="7db164d6a986565222e119d577ff5c229ba8b29b" translate="yes" xml:space="preserve">
          <source>This module includes everything you need to get started writing a parser.</source>
          <target state="translated">このモジュールには、パーサを書き始めるために必要なものがすべて含まれています。</target>
        </trans-unit>
        <trans-unit id="0e0f68392cbf21d07cf104e09ea0593872ccee43" translate="yes" xml:space="preserve">
          <source>This module is GHC-only and should not be considered portable.</source>
          <target state="translated">このモジュールはGHCのみであり、ポータブルではないと考えてください。</target>
        </trans-unit>
        <trans-unit id="84656ba40cd08703f7a3e8f512a38792e056d9c4" translate="yes" xml:space="preserve">
          <source>This module is an internal GHC module. It declares the constants used in the implementation of type-level natural numbers. The programmer interface for working with type-level naturals should be defined in a separate library.</source>
          <target state="translated">このモジュールはGHCの内部モジュールです。型レベルの自然数の実装で使用される定数を宣言します。型レベルの自然数を扱うためのプログラマインタフェースは,別のライブラリで定義されている必要があります.</target>
        </trans-unit>
        <trans-unit id="d3afde49cd7420849dc0a50c7430aa7753bf402f" translate="yes" xml:space="preserve">
          <source>This module is considered &lt;strong&gt;internal&lt;/strong&gt;.</source>
          <target state="translated">このモジュールは&lt;strong&gt;内部&lt;/strong&gt;と見なされます。</target>
        </trans-unit>
        <trans-unit id="32342dd868ac356dff4bac50bb615e44b16dffd8" translate="yes" xml:space="preserve">
          <source>This module is inspired by the paper &lt;em&gt;Functional Programming with Overloading and Higher-Order Polymorphism&lt;/em&gt;, Mark P Jones (&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt;) Advanced School of Functional Programming, 1995.</source>
          <target state="translated">このモジュールは&lt;em&gt;、オーバーロードと高次の多型&lt;/em&gt;を使用した関数型プログラミング、Mark P Jones（&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt;）、1995年の関数型プログラミングの高度な学校に触発されました。</target>
        </trans-unit>
        <trans-unit id="7096f5bf81e4fc89257ced2d74b5c3eaad60b08c" translate="yes" xml:space="preserve">
          <source>This module is intended to be imported &lt;code&gt;qualified&lt;/code&gt;, to avoid name clashes with &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions, e.g.</source>
          <target state="translated">このモジュールは、&lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt;関数との名前の衝突を回避するために、 &lt;code&gt;qualified&lt;/code&gt; されてインポ​​ートされることを意図しています。</target>
        </trans-unit>
        <trans-unit id="eee7efdf6521c2a0678812a45bb80ea8d0fd2ac6" translate="yes" xml:space="preserve">
          <source>This module is intended to be imported &lt;code&gt;qualified&lt;/code&gt;, to avoid name clashes with &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions. eg.</source>
          <target state="translated">このモジュールは、&lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt;関数との名前の衝突を避けるために、 &lt;code&gt;qualified&lt;/code&gt; されてインポ​​ートされることを意図しています。例えば。</target>
        </trans-unit>
        <trans-unit id="ed3534379c86106e1fb6aab32dbe9ba4e8065b07" translate="yes" xml:space="preserve">
          <source>This module is intended to be imported &lt;code&gt;qualified&lt;/code&gt;, to avoid name clashes with &lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions. eg.</source>
          <target state="translated">このモジュールは、&lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;プレリュード&lt;/a&gt;関数との名前の衝突を避けるために、 &lt;code&gt;qualified&lt;/code&gt; された状態でインポートすることを目的としています。例えば。</target>
        </trans-unit>
        <trans-unit id="93e00704b6043d91bc0b1a65e596b7ceb43c33c8" translate="yes" xml:space="preserve">
          <source>This module is intended to be imported qualified, to avoid name clashes with Prelude functions:</source>
          <target state="translated">このモジュールは、Prelude関数との名前の衝突を避けるために、修飾された状態でインポートされることを意図しています。</target>
        </trans-unit>
        <trans-unit id="c97f8a3f89d9890b95b69a48863882918e86fa8c" translate="yes" xml:space="preserve">
          <source>This module is part of the Foreign Function Interface (FFI) and will usually be imported via the module &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt;.</source>
          <target state="translated">このモジュールは、Foreign Function Interface（FFI）の一部であり、通常はモジュール&lt;a href=&quot;foreign&quot;&gt;Foreignを&lt;/a&gt;介してインポートされます。</target>
        </trans-unit>
        <trans-unit id="461f2e382a01bf00f47b644a6f12f006c2e2728e" translate="yes" xml:space="preserve">
          <source>This module only defines the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad; you probably want to import &lt;a href=&quot;control-concurrent-stm&quot;&gt;Control.Concurrent.STM&lt;/a&gt; (which exports &lt;a href=&quot;control-monad-stm&quot;&gt;Control.Monad.STM&lt;/a&gt;).</source>
          <target state="translated">このモジュールは &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; モナドのみを定義します。おそらく&lt;a href=&quot;control-concurrent-stm&quot;&gt;Control.Concurrent.STM&lt;/a&gt;（これは&lt;a href=&quot;control-monad-stm&quot;&gt;Control.Monad.STM&lt;/a&gt;をエクスポートします）をインポートしたいでしょう。</target>
        </trans-unit>
        <trans-unit id="fcaff35e4331afea7bccc306685504864f4b033e" translate="yes" xml:space="preserve">
          <source>This module presents an identical interface to &lt;a href=&quot;control-monad-st&quot;&gt;Control.Monad.ST&lt;/a&gt;, except that the monad delays evaluation of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; operations until a value depending on them is required.</source>
          <target state="translated">このモジュールは&lt;a href=&quot;control-monad-st&quot;&gt;Control.Monad.ST&lt;/a&gt;と同一のインターフェースを提供しますが、モナドは &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 操作の評価を、それらに依存する値が必要になるまで遅延させます。</target>
        </trans-unit>
        <trans-unit id="785b925d63da4b41979c13438250f723b3f36584" translate="yes" xml:space="preserve">
          <source>This module presents an identical interface to &lt;a href=&quot;control-monad-st&quot;&gt;Control.Monad.ST&lt;/a&gt;, except that the monad delays evaluation of state operations until a value depending on them is required.</source>
          <target state="translated">このモジュールは&lt;a href=&quot;control-monad-st&quot;&gt;Control.Monad.ST&lt;/a&gt;と同一のインターフェースを提供しますが、モナドはそれらに依存する値が必要になるまで状態操作の評価を遅らせます。</target>
        </trans-unit>
        <trans-unit id="5d29751e61c6eafcb5fbfdc53fe9336d12c4e225" translate="yes" xml:space="preserve">
          <source>This module provides &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;&lt;em&gt;primitives&lt;/em&gt;, which are lower level building blocks for constructing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. You don't need to go down to this level but it can be slightly faster.</source>
          <target state="translated">このモジュールは、提供 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; の&lt;em&gt;プリミティブ&lt;/em&gt;構築するためのより低いレベルの構築ブロックで、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 秒。このレベルまで下げる必要はありませんが、少し速くなることがあります。</target>
        </trans-unit>
        <trans-unit id="6e4ed2fc38393aca2df37326ba9f3afba3af1d5c" translate="yes" xml:space="preserve">
          <source>This module provides a low-level API to the line history stored in the &lt;code&gt;InputT&lt;/code&gt; monad transformer.</source>
          <target state="translated">このモジュールは、 &lt;code&gt;InputT&lt;/code&gt; モナドトランスフォーマーに格納されたライン履歴への低レベルAPIを提供します。</target>
        </trans-unit>
        <trans-unit id="f1d3e88a44dc84dd2e2655daf9dcf215e0055df4" translate="yes" xml:space="preserve">
          <source>This module provides a low-level interface to the C functions of the terminfo library.</source>
          <target state="translated">このモジュールは terminfo ライブラリの C 関数への低レベルなインターフェースを提供します。</target>
        </trans-unit>
        <trans-unit id="dcfa8281ead615b485cbc67a44a0d67023dd3214" translate="yes" xml:space="preserve">
          <source>This module provides a simple interface for executing external commands. For a more complex, but more powerful, interface, see the &lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt; module.</source>
          <target state="translated">このモジュールは、外部コマンドを実行するためのシンプルなインターフェースを提供します。より複雑で強力なインターフェイスについては、&lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="a90fd78951dfe7db7ffb984d132da2184a51611f" translate="yes" xml:space="preserve">
          <source>This module provides a stateful, IO-based interface to Haskeline, which may be easier to integrate into some existing programs or libraries.</source>
          <target state="translated">このモジュールはHaskelineへのステートフルなIOベースのインターフェイスを提供します。</target>
        </trans-unit>
        <trans-unit id="7665bb8888c593637beee8ce6f79ca4404cc5473" translate="yes" xml:space="preserve">
          <source>This module provides a version of pretty that allows for annotations to be attached to documents. Annotations are arbitrary pieces of metadata that can be attached to sub-documents.</source>
          <target state="translated">このモジュールは、ドキュメントにアノテーションを添付できるようにする pretty のバージョンを提供します。アノテーションは、サブドキュメントにアタッチできるメタデータの任意の部分です。</target>
        </trans-unit>
        <trans-unit id="c1a38449e4b89f12a5a25525a42c36b9312c0f84" translate="yes" xml:space="preserve">
          <source>This module provides access to internal garbage collection and memory usage statistics. These statistics are not available unless a program is run with the &lt;code&gt;-T&lt;/code&gt; RTS flag.</source>
          <target state="translated">このモジュールは、内部のガベージコレクションとメモリ使用統計へのアクセスを提供します。これらの統計は、 &lt;code&gt;-T&lt;/code&gt; RTSフラグを指定してプログラムを実行しない限り使用できません。</target>
        </trans-unit>
        <trans-unit id="9f3add7a2fb1719164d2ace74420d665a5258e75" translate="yes" xml:space="preserve">
          <source>This module provides capabilities for moving the cursor on the terminal.</source>
          <target state="translated">このモジュールは、ターミナル上でカーソルを移動する機能を提供します。</target>
        </trans-unit>
        <trans-unit id="e18030012ebf6800ca52122e711e5ae7b02da7e6" translate="yes" xml:space="preserve">
          <source>This module provides efficient containers-based functions on the list type.</source>
          <target state="translated">このモジュールは、リスト型の効率的なコンテナベースの関数を提供します。</target>
        </trans-unit>
        <trans-unit id="1f668197932586f66f5efc5d3fb7ae4c036d630e" translate="yes" xml:space="preserve">
          <source>This module provides overloaded functions, such as &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt;, for fully evaluating data structures (that is, evaluating to &quot;Normal Form&quot;).</source>
          <target state="translated">このモジュールは、データ構造を完全に評価する（つまり、「通常の形式」に評価する）ために、 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; などのオーバーロードされた関数を提供します。</target>
        </trans-unit>
        <trans-unit id="582a828ee9bdf70b77d17ebec335ad7850fb4e35" translate="yes" xml:space="preserve">
          <source>This module provides scalable event notification for file descriptors and timeouts.</source>
          <target state="translated">このモジュールは、ファイルディスクリプタとタイムアウトのためのスケーラブルなイベント通知を提供します。</target>
        </trans-unit>
        <trans-unit id="854a2eebed7e5e3bcde5ed1dde2b3bcda6e0ef76" translate="yes" xml:space="preserve">
          <source>This module provides support for raising and catching both built-in and user-defined exceptions.</source>
          <target state="translated">このモジュールは、組み込みの例外とユーザー定義の例外の発生とキャッチをサポートします。</target>
        </trans-unit>
        <trans-unit id="779b1cd1a00e8f21b85e9635dbc10c2617ea3dc3" translate="yes" xml:space="preserve">
          <source>This module provides text encoding/decoding using iconv</source>
          <target state="translated">このモジュールは iconv を使ったテキストエンコーディング/デコーディングを提供します。</target>
        </trans-unit>
        <trans-unit id="bd39e9a11c79866d26b9bd27b7ee858d0e154873" translate="yes" xml:space="preserve">
          <source>This module provides the various sorting implementations for &lt;a href=&quot;data-sequence&quot;&gt;Data.Sequence&lt;/a&gt;. Further notes are available in the file sorting.md (in this directory).</source>
          <target state="translated">このモジュールは、&lt;a href=&quot;data-sequence&quot;&gt;Data.Sequenceの&lt;/a&gt;さまざまなソート実装を提供します。詳細については、sorting.mdファイル（このディレクトリ内）を参照してください。</target>
        </trans-unit>
        <trans-unit id="c752cac235dedd97d14389620cb23346095a0f16" translate="yes" xml:space="preserve">
          <source>This module provides typed pointers to foreign data. It is part of the Foreign Function Interface (FFI) and will normally be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">このモジュールは、外部データへの型付きポインターを提供します。これは、Foreign Function Interface（FFI）の一部であり、通常は、&lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt;モジュールを介してインポートされます。</target>
        </trans-unit>
        <trans-unit id="8127ca85318ff1824be538551fa1fd1e340e9ab9" translate="yes" xml:space="preserve">
          <source>This module re-exports &lt;a href=&quot;text-xhtml-transitional&quot;&gt;Text.XHtml.Transitional&lt;/a&gt;, which produces XHTML 1.0 Transitional. Use &lt;a href=&quot;text-xhtml-strict&quot;&gt;Text.XHtml.Strict&lt;/a&gt; if you want XHTML 1.0 Strict, and &lt;a href=&quot;text-xhtml-frameset&quot;&gt;Text.XHtml.Frameset&lt;/a&gt; if you want to produce XHTML 1.0 Frameset.</source>
          <target state="translated">このモジュールは、XHTML 1.0 Transitionalを生成する&lt;a href=&quot;text-xhtml-transitional&quot;&gt;Text.XHtml.Transitionalを&lt;/a&gt;再エクスポートします。使用&lt;a href=&quot;text-xhtml-strict&quot;&gt;Text.XHtml.Strict&lt;/a&gt;あなたはXHTML 1.0は、厳格な、としたい場合&lt;a href=&quot;text-xhtml-frameset&quot;&gt;Text.XHtml.Frameset&lt;/a&gt;あなたはXHTML 1.0フレームセットを作成したい場合。</target>
        </trans-unit>
        <trans-unit id="d8ec7f9f123682eb0cc274e7c52cca0f3a5f423e" translate="yes" xml:space="preserve">
          <source>This module re-exports the value lazy &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; API, plus several deprecated value strict functions. Please note that these functions have different strictness properties than those in &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;: they only evaluate the result of the combining function. For example, the default value to &lt;code&gt;&lt;a href=&quot;data-intmap#v:insertWith-39-&quot;&gt;insertWith'&lt;/a&gt;&lt;/code&gt; is only evaluated if the combining function is called and uses it.</source>
          <target state="translated">このモジュールは、値レイジー&lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; APIに加えて、いくつかの非推奨の値厳格な関数を再エクスポートします。これらの関数には、&lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strictと&lt;/a&gt;は異なる厳密性プロパティがあることに注意してください。これらは、結合関数の結果のみを評価します。たとえば、 &lt;code&gt;&lt;a href=&quot;data-intmap#v:insertWith-39-&quot;&gt;insertWith'&lt;/a&gt;&lt;/code&gt; デフォルト値は、結合関数が呼び出されて使用される場合にのみ評価されます。</target>
        </trans-unit>
        <trans-unit id="652efe48d7f69bcc3c5490c01c5c8cb0efb0564b" translate="yes" xml:space="preserve">
          <source>This module redefines some of the functions in &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; to work for more general monads built on top of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このモジュールは &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; の上に構築されたより一般的なモナドで機能するように&lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exceptionの&lt;/a&gt;一部の関数を再定義します。</target>
        </trans-unit>
        <trans-unit id="3f6ca5d2535d9794227136b6b0c705ce4e24c48c" translate="yes" xml:space="preserve">
          <source>This module satisfies the following strictness property:</source>
          <target state="translated">このモジュールは、以下の厳密性を満たしています。</target>
        </trans-unit>
        <trans-unit id="d8eb2deb7a56d67d9c957df553d23a112baecc39" translate="yes" xml:space="preserve">
          <source>This module should be considered GHC internal.</source>
          <target state="translated">このモジュールはGHC内部と考えてください。</target>
        </trans-unit>
        <trans-unit id="29e73688c548bf0c2243628b3c05e4e5e0b07e48" translate="yes" xml:space="preserve">
          <source>This module should be used as opposed to the &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; module. Both are equivalent though as this module simply re-exports the other.</source>
          <target state="translated">このモジュールは、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; モジュールではなく使用する必要があります。ただし、このモジュールはもう一方を再エクスポートするだけなので、どちらも同等です。</target>
        </trans-unit>
        <trans-unit id="59ad027c5fc678b3f6724e2d8a2c3619f02ad834" translate="yes" xml:space="preserve">
          <source>This modules provides access to the &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; constructors and exposes some highly optimized GMP-operations.</source>
          <target state="translated">このモジュールは、 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; コンストラクターへのアクセスを提供し、高度に最適化されたいくつかのGMP操作を公開します。</target>
        </trans-unit>
        <trans-unit id="1130e146d0ff983a031a0a8522c8725e170d0829" translate="yes" xml:space="preserve">
          <source>This monad transformer adds the ability to fail or throw exceptions to a monad.</source>
          <target state="translated">このモナド変換器は、モナドに失敗や例外を投げる機能を追加します。</target>
        </trans-unit>
        <trans-unit id="2a98bbb5afc9600bb6b74cc7f447cb8e1866b15b" translate="yes" xml:space="preserve">
          <source>This monad transformer extends a monad with the ability to throw exceptions.</source>
          <target state="translated">このモナド変換器は、例外を投げる機能を持つモナドを拡張します。</target>
        </trans-unit>
        <trans-unit id="bba2acb7a712203bd9458987272d1dea78c2f000" translate="yes" xml:space="preserve">
          <source>This monad transformer is similar to both state and writer monad transformers. Thus it can be seen as</source>
          <target state="translated">このモナド変圧器は、ステート・モナド変圧器とライター・モナド変圧器の両方に似ています。したがって、次のように見ることができます。</target>
        </trans-unit>
        <trans-unit id="7f2bb8a9d0620b88f4451a6324781ede4a2121a7" translate="yes" xml:space="preserve">
          <source>This monad transformer provides append-only accumulation during the computation. For more general access, use &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt; instead.</source>
          <target state="translated">このモナド変換子は、計算中に追加のみの累積を提供します。より一般的なアクセスについては、代わりに&lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.Stateを&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="7c53c5e051f564d4139a6d22099093a9506011e0" translate="yes" xml:space="preserve">
          <source>This monad transformer provides only limited access to the output during the computation. For more general access, use &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt; instead.</source>
          <target state="translated">このモナドトランスフォーマーは、計算中に出力へのアクセスを制限します。より一般的なアクセスについては、代わりに&lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.Stateを&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="e64b48298e57e04598190a3e73a7a420ac326928" translate="yes" xml:space="preserve">
          <source>This now re-exports &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#v:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これで &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#v:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; が再エクスポートされます。</target>
        </trans-unit>
        <trans-unit id="48569d17cf06edd49e682678e1dd43b354e7266d" translate="yes" xml:space="preserve">
          <source>This only happens if:</source>
          <target state="translated">これは以下の場合にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="6c0b5dda6372d83897c8a1df104f5345b0b4220f" translate="yes" xml:space="preserve">
          <source>This only shows the time zone name, or offset if the name is empty.</source>
          <target state="translated">これはタイムゾーン名のみを表示し、名前が空の場合はオフセットを表示します。</target>
        </trans-unit>
        <trans-unit id="48af544d61c79afa3a39e1cd49eb4f6213f4528d" translate="yes" xml:space="preserve">
          <source>This only stands a chance of working for an encoding which is an ASCII superset, as for security reasons we refuse to escape any bytes smaller than 128. Many encodings of interest are ASCII supersets (in particular, you can assume that the locale encoding is an ASCII superset) but many (such as UTF-16) are not.</source>
          <target state="translated">これは、セキュリティ上の理由から 128 より小さいバイトはエスケープしないようにしているため、ASCII スーパーセットのエンコーディングでしか使えません。興味のあるエンコーディングの多くは ASCII スーパーセットですが (特に、ロケールエンコーディングは ASCII スーパーセットであると仮定することができます)、多くのエンコーディング (UTF-16 など)はそうではありません。</target>
        </trans-unit>
        <trans-unit id="a6ecf6dcbeadf01a7014b13f5a368ef88d650353" translate="yes" xml:space="preserve">
          <source>This only works for &lt;code&gt;&amp;plusmn;HHMM&lt;/code&gt; format, single-letter military time-zones, and these time-zones: &quot;UTC&quot;, &quot;UT&quot;, &quot;GMT&quot;, &quot;EST&quot;, &quot;EDT&quot;, &quot;CST&quot;, &quot;CDT&quot;, &quot;MST&quot;, &quot;MDT&quot;, &quot;PST&quot;, &quot;PDT&quot;.</source>
          <target state="translated">これは、 &lt;code&gt;&amp;plusmn;HHMM&lt;/code&gt; 形式、1文字のミリタリータイムゾーン、および「UTC」、「UT」、「GMT」、「EST」、「EDT」、「CST」、「CDT」、 「MST」、「MDT」、「PST」、「PDT」。</target>
        </trans-unit>
        <trans-unit id="d7c1d4016c14da3ba1514123886da29a32443086" translate="yes" xml:space="preserve">
          <source>This only works for a &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeZone&quot;&gt;zonedTimeZone&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&amp;plusmn;HHMM&lt;/code&gt; format, single-letter military time-zones, and these time-zones: &quot;UTC&quot;, &quot;UT&quot;, &quot;GMT&quot;, &quot;EST&quot;, &quot;EDT&quot;, &quot;CST&quot;, &quot;CDT&quot;, &quot;MST&quot;, &quot;MDT&quot;, &quot;PST&quot;, &quot;PDT&quot;.</source>
          <target state="translated">これだけのために働く &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeZone&quot;&gt;zonedTimeZone&lt;/a&gt;&lt;/code&gt; で &lt;code&gt;&amp;plusmn;HHMM&lt;/code&gt; の形式で、1文字の軍用タイムゾーン、およびこれらのタイムゾーン：「UTC」、「UT」、「GMT」、「EST」、「EDT」、「CST」、「 CDT」、「MST」、「MDT」、「PST」、「PDT」。</target>
        </trans-unit>
        <trans-unit id="23816db6dd8bea367310677e3bfbcb17ade64070" translate="yes" xml:space="preserve">
          <source>This operation acquires a unit from the semaphore (i.e. decreases the internal counter) and blocks (via &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;) if no units are available (i.e. if the counter is &lt;em&gt;not&lt;/em&gt; positive).</source>
          <target state="translated">この操作は、セマフォからユニットを取得し（つまり、内部カウンターを減らします）、使用可能なユニットがない場合（つまり、カウンターが正で&lt;em&gt;ない&lt;/em&gt;場合）に（ &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; を介して）ブロックします。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7014f780887d062aecc25cade39318f1f4267c3d" translate="yes" xml:space="preserve">
          <source>This operation adds/releases a unit back to the semaphore (i.e. increments the internal counter).</source>
          <target state="translated">この操作は、セマフォにユニットを追加・解除します(内部カウンタをインクリメントします)。</target>
        </trans-unit>
        <trans-unit id="bbef804c0feb5706c138bd85cf6a98a3ae663039" translate="yes" xml:space="preserve">
          <source>This operation adds/releases multiple units back to the semaphore (i.e. increments the internal counter).</source>
          <target state="translated">この操作は、セマフォに複数のユニットを追加・解除します(内部カウンタをインクリメントします)。</target>
        </trans-unit>
        <trans-unit id="23431b855341eca76cdc24f413dd7563b100983c" translate="yes" xml:space="preserve">
          <source>This operation is mostly useful for test-suites and/or code which constructs &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values directly.</source>
          <target state="translated">この操作は、ほとんどの場合、テストスイートや &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 値を直接作成するコードに役立ちます。</target>
        </trans-unit>
        <trans-unit id="49d93c809fbddf9cf81dbda4c05507ecf14db03e" translate="yes" xml:space="preserve">
          <source>This operation is mostly useful for test-suites and/or code which constructs &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values directly.</source>
          <target state="translated">この操作は、ほとんどの場合、テストスイートや &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 値を直接作成するコードに役立ちます。</target>
        </trans-unit>
        <trans-unit id="6a3297c146519190d66c5419366b511b5ce250ad" translate="yes" xml:space="preserve">
          <source>This operation is used in the definition of &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to prevent the IO action from being executed multiple times, which is usually undesirable.</source>
          <target state="translated">この操作は、 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; の定義で使用され、IOアクションが複数回実行されるのを防ぎます。これは通常望ましくありません。</target>
        </trans-unit>
        <trans-unit id="c2f6053c6fe980d3303ab7779a6c30bf3b23e441" translate="yes" xml:space="preserve">
          <source>This operation is used in the definition of &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to prevent the IO action from being executed multiple times, which is usually undesirable.</source>
          <target state="translated">この操作は、 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; の定義で使用され、IOアクションが複数回実行されるのを防ぎます。これは通常望ましくありません。</target>
        </trans-unit>
        <trans-unit id="8ee46adec231f99964d238f6075b76987a604b31" translate="yes" xml:space="preserve">
          <source>This operation may fail with:</source>
          <target state="translated">でこの操作に失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="a481371f0ca2e52248cb4d557f65d6db3c681c94" translate="yes" xml:space="preserve">
          <source>This optimisation isn&amp;rsquo;t always beneficial though (so GHC applies some heuristics to decide when to apply it). The details get complicated but a simple example is that it is often beneficial to move let bindings outwards so that multiple let bindings can be grouped into a larger single let binding, effectively batching their allocation and helping the garbage collector and allocator.</source>
          <target state="translated">ただし、この最適化が常に有益であるとは限りません（そのため、GHCはヒューリスティックを適用して、いつ適用するかを決定します）。詳細は複雑になりますが、単純な例として、letバインディングを外側に移動すると、複数のletバインディングをより大きな単一のletバインディングにグループ化でき、それらの割り当てを効率的にバッチ処理し、ガベージコレクターとアロケーターを支援できることがよくあります。</target>
        </trans-unit>
        <trans-unit id="daf337b821cabcc31b64cb93551eb620a65ef97d" translate="yes" xml:space="preserve">
          <source>This optimisation moves let bindings closer to their use site. The benefit here is that this may avoid unnecessary allocation if the branch the let is now on is never executed. It also enables other optimisation passes to work more effectively as they have more information locally.</source>
          <target state="translated">この最適化は、let のバインディングを使用サイトの近くに移動させます。ここでの利点は、現在のブランチが実行されない場合に不必要な割り当てを避けることができるということです。また、他の最適化パスがより多くの情報をローカルに持っているため、より効果的に動作するようになります。</target>
        </trans-unit>
        <trans-unit id="7bc0b111503fc7f964b8ba8ae4f63543b67f459b" translate="yes" xml:space="preserve">
          <source>This optimisation specializes recursive functions according to their argument &amp;ldquo;shapes&amp;rdquo;. This is best explained by example so consider:</source>
          <target state="translated">この最適化は、引数「形状」に従って再帰関数を専門化します。これは例で説明するのが最善です。</target>
        </trans-unit>
        <trans-unit id="3fa5960caadfa09849470cf6386b6072cc3ffa4f" translate="yes" xml:space="preserve">
          <source>This option affects the processing of RTS control options given either on the command line or via the &lt;a href=&quot;runtime_control#envvar-GHCRTS&quot; id=&quot;index-16&quot;&gt;&lt;code&gt;GHCRTS&lt;/code&gt;&lt;/a&gt; environment variable. There are three possibilities:</source>
          <target state="translated">このオプションは、コマンドラインまたは&lt;a href=&quot;runtime_control#envvar-GHCRTS&quot; id=&quot;index-16&quot;&gt; &lt;code&gt;GHCRTS&lt;/code&gt; &lt;/a&gt;環境変数を介して指定されたRTS制御オプションの処理に影響します。3つの可能性があります。</target>
        </trans-unit>
        <trans-unit id="65f85a6ef1d8626265a37c882bf54d7b55e6bccf" translate="yes" xml:space="preserve">
          <source>This option allows you to set the default RTS options at link-time. For example, &lt;code&gt;-with-rtsopts=&quot;-H128m&quot;&lt;/code&gt; sets the default heap size to 128MB. This will always be the default heap size for this program, unless the user overrides it. (Depending on the setting of the &lt;code&gt;-rtsopts&lt;/code&gt; option, the user might not have the ability to change RTS options at run-time, in which case &lt;code&gt;-with-rtsopts&lt;/code&gt; would be the &lt;em&gt;only&lt;/em&gt; way to set them.)</source>
          <target state="translated">このオプションを使用すると、リンク時にデフォルトのRTSオプションを設定できます。たとえば、 &lt;code&gt;-with-rtsopts=&quot;-H128m&quot;&lt;/code&gt; はデフォルトのヒープサイズを128MBに設定します。ユーザーが上書きしない限り、これは常にこのプログラムのデフォルトのヒープサイズになります。 （ &lt;code&gt;-rtsopts&lt;/code&gt; オプションの設定によっては、ユーザーが実行時にRTSオプションを変更できない場合があります。その場合、 &lt;code&gt;-with-rtsopts&lt;/code&gt; が&lt;em&gt;唯一の&lt;/em&gt;設定方法です。）</target>
        </trans-unit>
        <trans-unit id="f91f71cb98fa24b36d5d90d1dbeb3041d935c33b" translate="yes" xml:space="preserve">
          <source>This option causes a warning to be emitted whenever an inner-scope value has the same name as an outer-scope value, i.e. the inner value shadows the outer one. This can catch typographical errors that turn into hard-to-find bugs, e.g., in the inadvertent capture of what would be a recursive call in &lt;code&gt;f = ... let f = id in ... f ...&lt;/code&gt;.</source>
          <target state="translated">このオプションを使用すると、内部スコープの値が外部スコープの値と同じ名前を持つ場合、つまり内部スコープの値が外部スコープの値をシャドウするたびに警告が発行されます。これは、たとえば、 &lt;code&gt;f = ... let f = id in ... f ...&lt;/code&gt; 再帰呼び出しの不注意によるキャプチャなど、見つけにくいバグに変わる誤植をキャッチできます。</target>
        </trans-unit>
        <trans-unit id="ed96edbbc25b6f1208ec75b666dd489af6409055" translate="yes" xml:space="preserve">
          <source>This option causes all constructor fields which are marked strict (i.e. &amp;ldquo;!&amp;rdquo;) and which representation is smaller or equal to the size of a pointer to be unpacked, if possible. It is equivalent to adding an &lt;code&gt;UNPACK&lt;/code&gt; pragma (see &lt;a href=&quot;glasgow_exts#unpack-pragma&quot;&gt;UNPACK pragma&lt;/a&gt;) to every strict constructor field that fulfils the size restriction.</source>
          <target state="translated">このオプションを使用すると、厳密にマークされた（つまり、「！」）コンストラクターフィールドと、可能な場合はポインターのサイズ以下の表現がアンパックされます。これは、追加に相当する &lt;code&gt;UNPACK&lt;/code&gt; プラグマ（参照&lt;a href=&quot;glasgow_exts#unpack-pragma&quot;&gt;UNPACKプラグマを&lt;/a&gt;サイズ制限を満たすすべての厳密なコンストラクタのフィールドに）。</target>
        </trans-unit>
        <trans-unit id="e2cd4133d01d71e89460c606007690e42b1fcee7" translate="yes" xml:space="preserve">
          <source>This option causes all constructor fields which are marked strict (i.e. &lt;code&gt;!&lt;/code&gt;) to be unpacked if possible. It is equivalent to adding an &lt;code&gt;UNPACK&lt;/code&gt; pragma to every strict constructor field (see &lt;a href=&quot;glasgow_exts#unpack-pragma&quot;&gt;UNPACK pragma&lt;/a&gt;).</source>
          <target state="translated">このオプションを使用すると、strict（つまり &lt;code&gt;!&lt;/code&gt; ）とマークされているすべてのコンストラクタフィールドが、可能であればアンパックされます。これは、すべての厳密なコンストラクターフィールドに &lt;code&gt;UNPACK&lt;/code&gt; プラグマを追加することと同じです（&lt;a href=&quot;glasgow_exts#unpack-pragma&quot;&gt;UNPACKプラグマを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="fc09848f730f75b415b16f985abe5f3c3b0d4c17" translate="yes" xml:space="preserve">
          <source>This option causes the install package ⟨pkg⟩ to be both exposed and distrusted by GHC. This command functions in a very similar way to the &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; command but in addition sets the selected packages to be distrusted by GHC, regardless of the contents of the package database. (see &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;).</source>
          <target state="translated">このオプションにより、インストールパッケージ「pkg」がGHCによって公開され、信頼されなくなります。このコマンドは、&lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt;コマンドと非常によく似ていますが、パッケージデータベースの内容に関係なく、選択したパッケージをGHCによって信頼されないように設定します。（&lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskellを&lt;/a&gt;参照してください）。</target>
        </trans-unit>
        <trans-unit id="e900a6603015890af3c88ede22e351087bcb2f4c" translate="yes" xml:space="preserve">
          <source>This option causes the install package ⟨pkg⟩ to be both exposed and trusted by GHC. This command functions in a very similar way to the &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; command but in addition sets the selected packages to be trusted by GHC, regardless of the contents of the package database. (see &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;).</source>
          <target state="translated">このオプションにより、インストールパッケージ「pkg」がGHCによって公開され、信頼されます。このコマンドは&lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt;コマンドと非常によく似ていますが、パッケージデータベースの内容に関係なく、選択したパッケージをGHCによって信頼されるように設定します。 （&lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskellを&lt;/a&gt;参照してください）。</target>
        </trans-unit>
        <trans-unit id="d7d9bf3c24fe2f83f01a2a1fe6e2465277d625b8" translate="yes" xml:space="preserve">
          <source>This option causes the installed package ⟨pkg⟩ to be exposed for plugins, such as &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;&lt;/a&gt;. The package ⟨pkg⟩ can be specified in full with its version number (e.g. &lt;code&gt;network-1.0&lt;/code&gt;) or the version number can be omitted if there is only one version of the package installed. If there are multiple versions of ⟨pkg⟩ installed and &lt;a href=&quot;#ghc-flag--hide-all-plugin-packages&quot;&gt;&lt;code&gt;-hide-all-plugin-packages&lt;/code&gt;&lt;/a&gt; was not specified, then all other versions will become hidden. &lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; supports thinning and renaming described in &lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt;.</source>
          <target state="translated">このオプションにより、インストールされたパッケージ「pkg」が&lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt; &lt;/a&gt;などのプラグインに公開されます。パッケージ「pkg」は、バージョン番号（例： &lt;code&gt;network-1.0&lt;/code&gt; ）で完全に指定できます。または、インストールされているパッケージのバージョンが1つだけの場合は、バージョン番号を省略できます。 「pkg」の複数のバージョンがインストールされており、&lt;a href=&quot;#ghc-flag--hide-all-plugin-packages&quot;&gt; &lt;code&gt;-hide-all-plugin-packages&lt;/code&gt; &lt;/a&gt;が指定されていない場合、他のすべてのバージョンは非表示になります。&lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;、モジュールの間引きと名前&lt;/a&gt;変更で説明されている間引きと名前変更をサポートします。</target>
        </trans-unit>
        <trans-unit id="8ef5788126155cc03138f5109c85138baa08f3cb" translate="yes" xml:space="preserve">
          <source>This option causes the installed package ⟨pkg⟩ to be exposed. The package ⟨pkg⟩ can be specified in full with its version number (e.g. &lt;code&gt;network-1.0&lt;/code&gt;) or the version number can be omitted in which case GHC will automatically expose the latest non-broken version from the installed versions of the package.</source>
          <target state="translated">このオプションにより、インストールされたパッケージ「pkg」が公開されます。パッケージ「pkg」は、バージョン番号（例： &lt;code&gt;network-1.0&lt;/code&gt; ）で完全に指定することも、バージョン番号を省略することもできます。その場合、GHCはパッケージのインストール済みバージョンから最新の破損していないバージョンを自動的に公開します。</target>
        </trans-unit>
        <trans-unit id="a0e41ab6d83305de686a095b3332cab6407d1ce0" translate="yes" xml:space="preserve">
          <source>This option causes the runtime to print out the current cost-centre stack whenever an exception is raised. This can be particularly useful for debugging the location of exceptions, such as the notorious &lt;code&gt;Prelude.head: empty list&lt;/code&gt; error. See &lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;RTS options for hackers, debuggers, and over-interested souls&lt;/a&gt;.</source>
          <target state="translated">このオプションを使用すると、例外が発生するたびに、ランタイムは現在のコストセンタースタックを出力します。これは、悪名高い &lt;code&gt;Prelude.head: empty list&lt;/code&gt; エラーなどの例外の場所をデバッグするのに特に役立ちます。&lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;ハッカー、デバッガー、および関心の高い魂のためのRTSオプションを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b57872a61028ef8c64baf35e07feb3f3f77cf233" translate="yes" xml:space="preserve">
          <source>This option controls the amount of memory reserved for the older generations (and in the case of a two space collector the size of the allocation area) as a factor of the amount of live data. For example, if there was 2M of live data in the oldest generation when we last collected it, then by default we&amp;rsquo;ll wait until it grows to 4M before collecting it again.</source>
          <target state="translated">このオプションは、ライブデータの量の要素として、古い世代（および2つのスペースコレクターの場合は割り当て領域のサイズ）に予約されるメモリの量を制御します。たとえば、最後に収集したときに最も古い世代に2Mのライブデータがあった場合、デフォルトでは4Mになるまで待ってから再度収集します。</target>
        </trans-unit>
        <trans-unit id="fb38d77df4357efae92d504cd6786c9d8c4e6bf3" translate="yes" xml:space="preserve">
          <source>This option disables RTS suggestions about linking with &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt;&lt;/a&gt; when they are not available. These suggestions would be unhelpful if the users have installed Haskell programs through their package managers. With this option enabled, these suggestions will not appear. It is recommended for people distributing binaries to build with either &lt;code&gt;-rtsopts&lt;/code&gt; or &lt;code&gt;-no-rtsopts-suggestions&lt;/code&gt;.</source>
          <target state="translated">このオプションは、&lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; &lt;/a&gt;とのリンクに関するRTS提案が使用できない場合にそれらを無効にします。ユーザーがパッケージマネージャーを介してHaskellプログラムをインストールした場合、これらの提案は役に立ちません。このオプションを有効にすると、これらの提案は表示されません。バイナリを配布する人は、 &lt;code&gt;-rtsopts&lt;/code&gt; または &lt;code&gt;-no-rtsopts-suggestions&lt;/code&gt; を使用してビルドすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="956ede657ecee5ab5112379453aca532a83df0ab" translate="yes" xml:space="preserve">
          <source>This option displays the currently installed packages, for each of the databases known to &lt;code&gt;ghc-pkg&lt;/code&gt;. That includes the global database, the user&amp;rsquo;s local database, and any further files specified using the &lt;code&gt;-f&lt;/code&gt; option on the command line.</source>
          <target state="translated">このオプションは、 &lt;code&gt;ghc-pkg&lt;/code&gt; が認識しているデータベースごとに、現在インストールされているパッケージを表示します。これには、グローバルデータベース、ユーザーのローカルデータベース、およびコマンドラインで &lt;code&gt;-f&lt;/code&gt; オプションを使用して指定されたその他のファイルが含まれます。</target>
        </trans-unit>
        <trans-unit id="a08204879e3c5670124e4d3fa4df08f09c2c5827" translate="yes" xml:space="preserve">
          <source>This option does not put a &lt;em&gt;limit&lt;/em&gt; on the heap size: the heap may grow beyond the given size as usual.</source>
          <target state="translated">このオプションでは、ヒープサイズに&lt;em&gt;制限&lt;/em&gt;はありません。ヒープは通常どおり指定されたサイズを超えて大きくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="177e417c340a66f0470d8511743420a60bcc5fbb" translate="yes" xml:space="preserve">
          <source>This option does the opposite of &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt;: it causes the specified package to be hidden, which means that none of its modules will be available for import by Haskell &lt;code&gt;import&lt;/code&gt; directives.</source>
          <target state="translated">このオプションは、&lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt;の逆を行います。これにより、指定されたパッケージが非表示になります。つまり、Haskell &lt;code&gt;import&lt;/code&gt; ディレクティブによるインポートに使用できるモジュールはありません。</target>
        </trans-unit>
        <trans-unit id="1560370f0ba5d1fdfc6dfeeacc2a54b30787c270" translate="yes" xml:space="preserve">
          <source>This option is a bit of a sledgehammer: it might sometimes make things worse. Selectively unboxing fields by using &lt;code&gt;UNPACK&lt;/code&gt; pragmas might be better. An alternative is to use &lt;code&gt;-funbox-strict-fields&lt;/code&gt; to turn on unboxing by default but disable it for certain constructor fields using the &lt;code&gt;NOUNPACK&lt;/code&gt; pragma (see &lt;a href=&quot;glasgow_exts#nounpack-pragma&quot;&gt;NOUNPACK pragma&lt;/a&gt;).</source>
          <target state="translated">このオプションは少し大槌です：それは時々事態を悪化させるかもしれません。 &lt;code&gt;UNPACK&lt;/code&gt; プラグマを使用してフィールドを選択的にボックス化解除することをお勧めします。別の方法として、 &lt;code&gt;-funbox-strict-fields&lt;/code&gt; を使用してデフォルトでボックス化解除をオンにするが、 &lt;code&gt;NOUNPACK&lt;/code&gt; プラグマを使用する特定のコンストラクターフィールドでは無効化する（&lt;a href=&quot;glasgow_exts#nounpack-pragma&quot;&gt;NOUNPACKプラグマを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="3c07ac232f23724b3889cefd06b22eb4683d2f7a" translate="yes" xml:space="preserve">
          <source>This option is for working around memory allocation problems only. Do not use unless GHCi fails with a message like &amp;ldquo;&lt;code&gt;failed to mmap() memory below 2Gb&lt;/code&gt;&amp;rdquo;. Consider recompiling the objects with &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt; and using the &lt;code&gt;-xp&lt;/code&gt; flag instead. If you need to use this option to get GHCi working on your machine, please file a bug.</source>
          <target state="translated">このオプションは、メモリ割り当ての問題を回避するためだけのものです。「 &lt;code&gt;failed to mmap() memory below 2Gb&lt;/code&gt; 」などのメッセージでGHCiが失敗しない限り、使用しないでください。 &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt; を使用してオブジェクトを再コンパイルし、代わりに &lt;code&gt;-xp&lt;/code&gt; フラグを使用することを検討してください。このオプションを使用してGHCiをマシンで動作させる必要がある場合は、バグを報告してください。</target>
        </trans-unit>
        <trans-unit id="0ac262cc50deac3cfae652d65a7a869356b40b86" translate="yes" xml:space="preserve">
          <source>This option is for working around memory allocation problems only. Do not use unless GHCi fails with a message like &amp;ldquo;&lt;code&gt;failed to mmap() memory below 2Gb&lt;/code&gt;&amp;rdquo;. If you need to use this option to get GHCi working on your machine, please file a bug.</source>
          <target state="translated">このオプションは、メモリ割り当ての問題のみを回避するためのものです。GHCiが「 &lt;code&gt;failed to mmap() memory below 2Gb&lt;/code&gt; 」のようなメッセージで失敗しない限り、使用しないでください。このオプションを使用してGHCiをマシンで動作させる必要がある場合は、バグを報告してください。</target>
        </trans-unit>
        <trans-unit id="1c1ed9c302993c8a254ff902df0dbce38b594005" translate="yes" xml:space="preserve">
          <source>This option is less of a sledgehammer than &lt;code&gt;-funbox-strict-fields&lt;/code&gt;: it should rarely make things worse. If you use &lt;code&gt;-funbox-small-strict-fields&lt;/code&gt; to turn on unboxing by default you can disable it for certain constructor fields using the &lt;code&gt;NOUNPACK&lt;/code&gt; pragma (see &lt;a href=&quot;glasgow_exts#nounpack-pragma&quot;&gt;NOUNPACK pragma&lt;/a&gt;).</source>
          <target state="translated">このオプションは、 &lt;code&gt;-funbox-strict-fields&lt;/code&gt; よりもハンマーではありません。事態を悪化させることはめったにありません。 &lt;code&gt;-funbox-small-strict-fields&lt;/code&gt; を使用してデフォルトでボックス化解除をオンにする場合は、 &lt;code&gt;NOUNPACK&lt;/code&gt; プラグマを使用して、特定のコンストラクターフィールドに対してボックス化を無効にすることができます（&lt;a href=&quot;glasgow_exts#nounpack-pragma&quot;&gt;NOUNPACKプラグマを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2fd49d1f76860f1c44d6c219e62e7f40bc9c2382" translate="yes" xml:space="preserve">
          <source>This option is most often used when creating an executable file, to set the filename of the executable. For example:</source>
          <target state="translated">このオプションは、実行ファイルを作成する際に最もよく使われ、実行ファイルのファイル名を設定します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="2ec4e8819778435da9e1806c3a1ad92e747cbb70" translate="yes" xml:space="preserve">
          <source>This option is now deprecated in favour of &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt;&lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このオプションは、&lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt; &lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt; の&lt;/a&gt;ために廃止されました。</target>
        </trans-unit>
        <trans-unit id="267371a5e841319f6a790d155fb592c269a41960" translate="yes" xml:space="preserve">
          <source>This option is now deprecated in favour of &lt;a href=&quot;#ghc-flag--Wmissing-local-signatures&quot;&gt;&lt;code&gt;-Wmissing-local-signatures&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このオプションは、&lt;a href=&quot;#ghc-flag--Wmissing-local-signatures&quot;&gt; &lt;code&gt;-Wmissing-local-signatures&lt;/code&gt; の&lt;/a&gt;ために廃止されました。</target>
        </trans-unit>
        <trans-unit id="0235b6cb10974ea14ea0574ec14232194a831212" translate="yes" xml:space="preserve">
          <source>This option is now deprecated in favour of &lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt;&lt;code&gt;-Wredundant-constraints&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このオプションは、&lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt; &lt;code&gt;-Wredundant-constraints&lt;/code&gt; を&lt;/a&gt;支持して廃止されました。</target>
        </trans-unit>
        <trans-unit id="d62299c9dde524b1ef3bb3933973aa22ff0ff398" translate="yes" xml:space="preserve">
          <source>This option is off by default.</source>
          <target state="translated">このオプションはデフォルトではオフになっています。</target>
        </trans-unit>
        <trans-unit id="4293e9fab7792eac1853c48400535b8a8b77123a" translate="yes" xml:space="preserve">
          <source>This option is on by default, and warns you whenever an instance declaration is missing one or more methods, and the corresponding class declaration has no default declaration for them.</source>
          <target state="translated">このオプションはデフォルトでオンになっており、インスタンス宣言に1つ以上のメソッドがなく、対応するクラス宣言にそれらのメソッドのデフォルト宣言がない場合に警告を発します。</target>
        </trans-unit>
        <trans-unit id="aeda602ded05cab94ca86a41b88530e26ba7b489" translate="yes" xml:space="preserve">
          <source>This option is on by default, and warns you whenever the construction of a labelled field constructor isn&amp;rsquo;t complete, missing initialisers for one or more fields. While not an error (the missing fields are initialised with bottoms), it is often an indication of a programmer error.</source>
          <target state="translated">このオプションはデフォルトでオンになっており、ラベル付きフィールドコンストラクターの構築が完了していないときに警告を表示し、1つ以上のフィールドの初期化子が欠落しています。エラーではありませんが（欠落しているフィールドはボトムスで初期化されています）、多くの場合、プログラマーのエラーを示しています。</target>
        </trans-unit>
        <trans-unit id="aa97f50ca584638ac24325128130ef5efe4b2fbf" translate="yes" xml:space="preserve">
          <source>This option is on by default.</source>
          <target state="translated">このオプションはデフォルトでオンになっています。</target>
        </trans-unit>
        <trans-unit id="9d2fe70b27b67051a789b82f4eb4f639ee630173" translate="yes" xml:space="preserve">
          <source>This option is on by default. As usual you can suppress it on a per-module basis with &lt;a href=&quot;#ghc-flag--Wsimplifiable-class-constraints&quot;&gt;&lt;code&gt;-Wno-simplifiable-class-constraints&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このオプションはデフォルトでオンになっています。いつものように、&lt;a href=&quot;#ghc-flag--Wsimplifiable-class-constraints&quot;&gt; &lt;code&gt;-Wno-simplifiable-class-constraints&lt;/code&gt; を使用して&lt;/a&gt;モジュールごとに抑制することができます。</target>
        </trans-unit>
        <trans-unit id="ccde2620c81cc8f927379b68565101df835bced2" translate="yes" xml:space="preserve">
          <source>This option is only useful when running in parallel (&lt;code&gt;-N2&lt;/code&gt; or greater). It allows the processor cores to make better use of the available allocation area, even when cores are allocating at different rates. Without &lt;code&gt;-n&lt;/code&gt;, each core gets a fixed-size allocation area specified by the &lt;code&gt;-A&lt;/code&gt;, and the first core to exhaust its allocation area triggers a GC across all the cores. This can result in a collection happening when the allocation areas of some cores are only partially full, so the purpose of the &lt;code&gt;-n&lt;/code&gt; is to allow cores that are allocating faster to get more of the allocation area. This means less frequent GC, leading a lower GC overhead for the same heap size.</source>
          <target state="translated">このオプションは、並列実行（ &lt;code&gt;-N2&lt;/code&gt; 以上）の場合にのみ役立ちます。これにより、コアが異なるレートで割り当てられている場合でも、プロセッサコアは利用可能な割り当て領域をより有効に活用できます。 &lt;code&gt;-n&lt;/code&gt; がない場合、各コアは &lt;code&gt;-A&lt;/code&gt; で指定された固定サイズの割り当て領域を取得し、その割り当て領域を使い果たした最初のコアがすべてのコアにわたってGCをトリガーします。これにより、一部のコアの割り当て領域が部分的にしか満たされていない場合にコレクションが発生する可能性があるため、 &lt;code&gt;-n&lt;/code&gt; の目的は、より高速に割り当てられているコアがより多くの割り当て領域を取得できるようにすることです。つまり、GCの頻度が少なくなり、同じヒープサイズのGCオーバーヘッドが低くなります。</target>
        </trans-unit>
        <trans-unit id="8d9c254d7b78a3a3ecbc5027783e6457d1d482ef" translate="yes" xml:space="preserve">
          <source>This option is probably only of use for concurrent programs that explicitly schedule threads onto CPUs with &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:forkOn&quot;&gt;Control.Concurrent.forkOn&lt;/a&gt;.</source>
          <target state="translated">このオプションは、おそらく&lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:forkOn&quot;&gt;Control.Concurrent.forkOnを&lt;/a&gt;使用してCPUにスレッドを明示的にスケジュールする並行プログラムでのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="95f6bdd8b0e33deb9f64ace0ba5f278fa7702c9e" translate="yes" xml:space="preserve">
          <source>This option is probably only of use for concurrent programs that explicitly schedule threads onto CPUs with &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:forkOn&quot;&gt;Control.Concurrent.forkOn&lt;/a&gt;.</source>
          <target state="translated">このオプションは、&lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:forkOn&quot;&gt;Control.Concurrent.forkOnを&lt;/a&gt;使用してCPUへのスレッドを明示的にスケジュールする並行プログラムにのみ使用される可能性があります。</target>
        </trans-unit>
        <trans-unit id="f35434e6bd52920e5c48189b8cfc8e504aad6697" translate="yes" xml:space="preserve">
          <source>This option is there mainly to stop the program eating up all the available memory in the machine if it gets into an infinite loop.</source>
          <target state="translated">このオプションは主に、プログラムが無限ループに陥った場合に、マシン内の利用可能なメモリをすべて食い尽くすのを止めるために存在します。</target>
        </trans-unit>
        <trans-unit id="57d29d5e7df4da4169fdb64e362ca3677dd89e06" translate="yes" xml:space="preserve">
          <source>This option isn&amp;rsquo;t enabled by default because it can be a bit noisy, and it doesn&amp;rsquo;t always indicate a bug in the program. However, it&amp;rsquo;s generally considered good practice to cover all the cases in your functions, and it is switched on by &lt;a href=&quot;#ghc-flag--W&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このオプションは少しうるさい可能性があるため、デフォルトでは有効になっていません。また、常にプログラムのバグを示しているとは限りません。ただし、関数のすべてのケースをカバーすることは一般的には良い習慣と考えられており、&lt;a href=&quot;#ghc-flag--W&quot;&gt; &lt;code&gt;-W&lt;/code&gt; &lt;/a&gt;によってオンに切り替えられます。</target>
        </trans-unit>
        <trans-unit id="9f98751831a4a39977803e9637f7e77e2e14db0e" translate="yes" xml:space="preserve">
          <source>This option isn&amp;rsquo;t enabled by default because it can be very noisy, and it often doesn&amp;rsquo;t indicate a bug in the program.</source>
          <target state="translated">このオプションは、非常にうるさく、プログラムのバグを示していないことが多いため、デフォルトでは有効になっていません。</target>
        </trans-unit>
        <trans-unit id="674da51224e4596bdb3744f26e1f9a1fbcb8b81f" translate="yes" xml:space="preserve">
          <source>This option lists registered packages exposing module ⟨M⟩. Examples:</source>
          <target state="translated">このオプションは、モジュールを公開している登録済みパッケージの一覧を表示します。例。</target>
        </trans-unit>
        <trans-unit id="c794703287cedcb0e1c47b116ac501bee05de960" translate="yes" xml:space="preserve">
          <source>This option may help if the evaluated top-level expressions are consuming large amounts of space, or if you need repeatable performance measurements.</source>
          <target state="translated">このオプションは、評価されたトップレベル式が大量のスペースを消費する場合や、再現性のあるパフォーマンス測定が必要な場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="b7ff2c217eff8117af9178fc8b3897c5316f401a" translate="yes" xml:space="preserve">
          <source>This option provides a &amp;ldquo;suggested heap size&amp;rdquo; for the garbage collector. Think of &lt;code&gt;-Hsize&lt;/code&gt; as a variable &lt;a href=&quot;#rts-flag--A%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-A ⟨size⟩&lt;/code&gt;&lt;/a&gt; option. It says: I want to use at least ⟨size⟩ bytes, so use whatever is left over to increase the &lt;code&gt;-A&lt;/code&gt; value.</source>
          <target state="translated">このオプションは、ガベージコレクターに「推奨されるヒープサイズ」を提供します。 &lt;code&gt;-Hsize&lt;/code&gt; を可変の&lt;a href=&quot;#rts-flag--A%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-A ⟨size⟩&lt;/code&gt; &lt;/a&gt;オプションと考えてください。それは言う：私は少なくとも「サイズ」バイトを使用したいので、残っているものを使用して &lt;code&gt;-A&lt;/code&gt; 値を増やします。</target>
        </trans-unit>
        <trans-unit id="8853a9d72e715d15e409a53251078ae18153a456" translate="yes" xml:space="preserve">
          <source>This option relates to allocation limits; for more about this see &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-conc#v:enableAllocationLimit&quot;&gt;GHC.Conc.enableAllocationLimit&lt;/a&gt;. When a thread hits its allocation limit, the RTS throws an exception to the thread, and the thread gets an additional quota of allocation before the exception is raised again, the idea being so that the thread can execute its exception handlers. The &lt;code&gt;-xq&lt;/code&gt; controls the size of this additional quota.</source>
          <target state="translated">このオプションは割り当て制限に関連しています。詳細については、&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-conc#v:enableAllocationLimit&quot;&gt;GHC.Conc.enableAllocationLimitを&lt;/a&gt;参照してください。スレッドが割り当て制限に達すると、RTSはスレッドに例外をスローし、スレッドは例外が再度発生する前に、割り当ての追加割り当てを取得します。これは、スレッドが例外ハンドラーを実行できるようにするためです。 &lt;code&gt;-xq&lt;/code&gt; は、この追加のクォータのサイズを制御します。</target>
        </trans-unit>
        <trans-unit id="5d0cb54597e16fb360f23cd6c09d2b5b66dd5dd4" translate="yes" xml:space="preserve">
          <source>This option relates to allocation limits; for more about this see &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-conc#v:enableAllocationLimit&quot;&gt;GHC.Conc.enableAllocationLimit&lt;/a&gt;. When a thread hits its allocation limit, the RTS throws an exception to the thread, and the thread gets an additional quota of allocation before the exception is raised again, the idea being so that the thread can execute its exception handlers. The &lt;code&gt;-xq&lt;/code&gt; controls the size of this additional quota.</source>
          <target state="translated">このオプションは、割り当て制限に関連しています。これについて詳しくは、&lt;a href=&quot;../libraries/base-4.14.1.0/ghc-conc#v:enableAllocationLimit&quot;&gt;GHC.Conc.enableAllocationLimitを&lt;/a&gt;参照してください。スレッドが割り当て制限に達すると、RTSはスレッドに例外をスローし、例外が再度発生する前にスレッドは割り当ての追加クォータを取得します。これは、スレッドが例外ハンドラーを実行できるようにするためです。 &lt;code&gt;-xq&lt;/code&gt; は、この追加のクォータのサイズを制御します。</target>
        </trans-unit>
        <trans-unit id="1ea918ac03fd189d0258f1a47317cf8c206c5d32" translate="yes" xml:space="preserve">
          <source>This output shows that, in the context of the current session (ie in the scope of &lt;code&gt;Prelude&lt;/code&gt;), the first group of items from &lt;code&gt;Data.Maybe&lt;/code&gt; are not in scope (although they are available in fully qualified form in the GHCi session - see &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;), whereas the second group of items are in scope (via &lt;code&gt;Prelude&lt;/code&gt;) and are therefore available either unqualified, or with a &lt;code&gt;Prelude.&lt;/code&gt; qualifier.</source>
          <target state="translated">この出力は、現在のセッションのコンテキスト（つまり、 &lt;code&gt;Prelude&lt;/code&gt; のスコープ内）で、 &lt;code&gt;Data.Maybe&lt;/code&gt; の最初のアイテムグループがスコープ内にないことを示しています（ただし、GHCiセッションでは完全修飾形式で利用できます-「&lt;a href=&quot;#ghci-scope&quot;&gt;What's&lt;/a&gt;」を参照してください）プロンプトで実際にスコープ内にありますか？）、一方、アイテムの2番目のグループは（ &lt;code&gt;Prelude&lt;/code&gt; を介して）スコープ内にあるため、修飾されていないか、 &lt;code&gt;Prelude.&lt;/code&gt; 使用できます。修飾子。</target>
        </trans-unit>
        <trans-unit id="363c890a3de72dcec771b7f4c76b67f54a27050f" translate="yes" xml:space="preserve">
          <source>This output shows that, in the context of the current session (ie in the scope of &lt;code&gt;Prelude&lt;/code&gt;), the first group of items from &lt;code&gt;Data.Maybe&lt;/code&gt; are not in scope (althought they are available in fully qualified form in the GHCi session - see &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;), whereas the second group of items are in scope (via &lt;code&gt;Prelude&lt;/code&gt;) and are therefore available either unqualified, or with a &lt;code&gt;Prelude.&lt;/code&gt; qualifier.</source>
          <target state="translated">この出力は、現在のセッションのコンテキスト（つまり、 &lt;code&gt;Prelude&lt;/code&gt; のスコープ）で、 &lt;code&gt;Data.Maybe&lt;/code&gt; の最初のアイテムグループがスコープにないことを示しています（ただし、GHCiセッションでは完全修飾形式で利用できますが、「&lt;a href=&quot;#ghci-scope&quot;&gt;What's実際プロンプト範囲内？&lt;/a&gt;）、アイテムの第二群は、ビアスコープ（内にあるのに対し、 &lt;code&gt;Prelude&lt;/code&gt; ）、したがって修飾されていない、またはのいずれかで利用可能である &lt;code&gt;Prelude.&lt;/code&gt; 修飾子。</target>
        </trans-unit>
        <trans-unit id="d32fd0e1a9f5bf7e2d98a725ace2312b41fff634" translate="yes" xml:space="preserve">
          <source>This package provides both strict and lazy &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; types. The strict type is provided by the &lt;a href=&quot;data-text&quot;&gt;Data.Text&lt;/a&gt; module, while the lazy type is provided by the &lt;a href=&quot;data-text-lazy&quot;&gt;Data.Text.Lazy&lt;/a&gt; module. Internally, the lazy &lt;code&gt;Text&lt;/code&gt; type consists of a list of strict chunks.</source>
          <target state="translated">このパッケージは、厳密な &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; タイプと遅延テキストタイプの両方を提供します。厳密な型は&lt;a href=&quot;data-text&quot;&gt;Data.Text&lt;/a&gt;モジュールによって提供され、遅延型は&lt;a href=&quot;data-text-lazy&quot;&gt;Data.Text.Lazy&lt;/a&gt;モジュールによって提供されます。内部的には、レイジー &lt;code&gt;Text&lt;/code&gt; タイプは、厳密なチャンクのリストで構成されています。</target>
        </trans-unit>
        <trans-unit id="5c301e63fdee476a49263ba8163281e72adf6b96" translate="yes" xml:space="preserve">
          <source>This package uses the term &lt;em&gt;character&lt;/em&gt; to denote Unicode &lt;em&gt;code points&lt;/em&gt;.</source>
          <target state="translated">このパッケージでは、&lt;em&gt;文字&lt;/em&gt;という用語を使用してUnicode &lt;em&gt;コードポイント&lt;/em&gt;を示します。</target>
        </trans-unit>
        <trans-unit id="aae5addb116c887a46f27acc513b2117c6d86f14" translate="yes" xml:space="preserve">
          <source>This parameter is reserved. You should pass just &lt;em&gt;nullPtr&lt;/em&gt;.</source>
          <target state="translated">このパラメータは予約されています。&lt;em&gt;nullPtr&lt;/em&gt;だけを渡す必要があり&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="15f0fa32e677164a596a3b41ef5acc2c4991ec87" translate="yes" xml:space="preserve">
          <source>This parameter requires to use Windows 7 or later.</source>
          <target state="translated">このパラメータは、Windows 7 以降で使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="2b0fc7a248b7324fafef584b213680e79287e0c9" translate="yes" xml:space="preserve">
          <source>This parser only succeeds at the end of the input. This is not a primitive parser but it is defined using &lt;code&gt;&lt;a href=&quot;text-parsec#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このパーサーは、入力の最後でのみ成功します。これはプリミティブパーサーではありませんが、 &lt;code&gt;&lt;a href=&quot;text-parsec#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; を使用して定義されます。</target>
        </trans-unit>
        <trans-unit id="6b70e45e4186d009ec916862fca7c137404104fc" translate="yes" xml:space="preserve">
          <source>This parser only succeeds at the end of the input. This is not a primitive parser but it is defined using &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このパーサーは、入力の最後でのみ成功します。これはプリミティブパーサーではありませんが、 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; を使用して定義されます。</target>
        </trans-unit>
        <trans-unit id="4dfbf340dce50dc9038b479329f38e8ec299cf61" translate="yes" xml:space="preserve">
          <source>This parser only succeeds at the end of the input. This is not a primitive parser but it is defined using &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このパーサーは、入力の最後でのみ成功します。これはプリミティブパーサーではありませんが、 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; を使用して定義されます。</target>
        </trans-unit>
        <trans-unit id="9300de657d2872adc67fa41e5ab353e07ce88a2d" translate="yes" xml:space="preserve">
          <source>This parser should accept any legal tail characters of identifiers. For example &lt;code&gt;alphaNum &amp;lt;|&amp;gt; char '_'&lt;/code&gt;.</source>
          <target state="translated">このパーサーは、識別子の正当な末尾文字を受け入れる必要があります。たとえば &lt;code&gt;alphaNum &amp;lt;|&amp;gt; char '_'&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f8528eebabb9825d0176f24d442e7c8b026df63e" translate="yes" xml:space="preserve">
          <source>This parser should accept any legal tail characters of operators. Note that this parser should even be defined if the language doesn't support user-defined operators, or otherwise the &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:reservedOp&quot;&gt;reservedOp&lt;/a&gt;&lt;/code&gt; parser won't work correctly.</source>
          <target state="translated">このパーサーは、演算子の正当な末尾文字を受け入れる必要があります。このパーサーは、言語がユーザー定義の演算子をサポートしていない場合でも定義する必要があります。そうでない場合、 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:reservedOp&quot;&gt;reservedOp&lt;/a&gt;&lt;/code&gt; パーサーは正しく機能しません。</target>
        </trans-unit>
        <trans-unit id="00d8c7a0c04c027e82791e73a94a73041f724be2" translate="yes" xml:space="preserve">
          <source>This parser should accept any legal tail characters of operators. Note that this parser should even be defined if the language doesn't support user-defined operators, or otherwise the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:reservedOp&quot;&gt;reservedOp&lt;/a&gt;&lt;/code&gt; parser won't work correctly.</source>
          <target state="translated">このパーサーは、演算子の正当な末尾文字を受け入れる必要があります。このパーサーは、言語がユーザー定義の演算子をサポートしていない場合でも定義する必要があります。そうでない場合、 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:reservedOp&quot;&gt;reservedOp&lt;/a&gt;&lt;/code&gt; パーサーは正しく機能しません。</target>
        </trans-unit>
        <trans-unit id="d983e2b71ccf1f3a26f0aff85466bf1e651e9beb" translate="yes" xml:space="preserve">
          <source>This parser should accept any start characters of identifiers. For example &lt;code&gt;letter &amp;lt;|&amp;gt; char '_'&lt;/code&gt;.</source>
          <target state="translated">このパーサーは、識別子の開始文字を受け入れる必要があります。たとえば、 &lt;code&gt;letter &amp;lt;|&amp;gt; char '_'&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7b9eeef0a0daf3a30997aca44251904a3bc4ace8" translate="yes" xml:space="preserve">
          <source>This parser should accept any start characters of operators. For example &lt;code&gt;oneOf &quot;:!#$%&amp;amp;*+./&amp;lt;=&amp;gt;?@\\^|-~&quot;&lt;/code&gt;</source>
          <target state="translated">このパーサーは、演算子の任意の開始文字を受け入れる必要があります。たとえば、 &lt;code&gt;oneOf &quot;:!#$%&amp;amp;*+./&amp;lt;=&amp;gt;?@\\^|-~&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9db4088868263aaafdfa869a0f8e2314217323d7" translate="yes" xml:space="preserve">
          <source>This parser succeeds for any character. Returns the parsed character.</source>
          <target state="translated">このパーサは、任意の文字に対して成功します。解析された文字を返します。</target>
        </trans-unit>
        <trans-unit id="a306a889dc9a52a42b11381f826b2d7630214d4b" translate="yes" xml:space="preserve">
          <source>This pragma is similar to C&amp;rsquo;s &lt;code&gt;#line&lt;/code&gt; pragma, and is mainly for use in automatically generated Haskell code. It lets you specify the line number and filename of the original code; for example</source>
          <target state="translated">このプラグマはCの &lt;code&gt;#line&lt;/code&gt; プラグマに似ており、主に自動生成されたHaskellコードで使用されます。元のコードの行番号とファイル名を指定できます。例えば</target>
        </trans-unit>
        <trans-unit id="ca88c24656a8d8661c565a0c56d31be0ec21660f" translate="yes" xml:space="preserve">
          <source>This primitive is only available when the underlying GMP library supports it (GMP &amp;gt;= 5). Otherwise, it internally falls back to &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt;, and a warning will be emitted when used.</source>
          <target state="translated">このプリミティブは、基礎となるGMPライブラリがサポートしている場合にのみ使用できます（GMP&amp;gt; = 5）。それ以外の場合は、内部的に &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; にフォールバックし、使用すると警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="dceb51efdb1a52e7502aaf8f2f6a2f14168bc8e4" translate="yes" xml:space="preserve">
          <source>This problem doesn&amp;rsquo;t just affect GHCi, it affects any GHC-compiled program that wants to catch console events. See the &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-consolehandler&quot;&gt;GHC.ConsoleHandler&lt;/a&gt; module.</source>
          <target state="translated">この問題は、GHCiだけでなく、コンソールイベントをキャッチしようとするGHCコンパイル済みプログラムにも影響します。&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-consolehandler&quot;&gt;GHC.ConsoleHandler&lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="0a497560db9bd41df0e1b95425a2c75d218c8ec8" translate="yes" xml:space="preserve">
          <source>This problem doesn&amp;rsquo;t just affect GHCi, it affects any GHC-compiled program that wants to catch console events. See the &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-consolehandler&quot;&gt;GHC.ConsoleHandler&lt;/a&gt; module.</source>
          <target state="translated">この問題はGHCiだけでなく、コンソールイベントをキャッチしたいGHCコンパイル済みプログラムにも影響します。&lt;a href=&quot;../libraries/base-4.14.1.0/ghc-consolehandler&quot;&gt;GHC.ConsoleHandler&lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="c277562015915ae2718208c757d99e3c4a5c2ea5" translate="yes" xml:space="preserve">
          <source>This produces a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; for each key:</source>
          <target state="translated">これにより、キーごとに &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; が生成されます。</target>
        </trans-unit>
        <trans-unit id="520ac415055f1c0bf4aa6e9c1ae9d27830756102" translate="yes" xml:space="preserve">
          <source>This produces a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; for each key:</source>
          <target state="translated">これにより、キーごとに &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; が生成されます。</target>
        </trans-unit>
        <trans-unit id="d113cd0a06b95adde252febb8a83dc6d268b9573" translate="yes" xml:space="preserve">
          <source>This program will be rejected as ambiguous because GHC will not unify the type variables &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">GHCは型変数 &lt;code&gt;j&lt;/code&gt; と &lt;code&gt;i&lt;/code&gt; を統合しないため、このプログラムはあいまいとして拒否されます。</target>
        </trans-unit>
        <trans-unit id="e24c8bfbcd524c9aaee115418d115977f5d18a8a" translate="yes" xml:space="preserve">
          <source>This program will be rejected, because &amp;ldquo;&lt;code&gt;a&lt;/code&gt;&amp;rdquo; does not scope over the definition of &amp;ldquo;&lt;code&gt;g&lt;/code&gt;&amp;rdquo;, so &amp;ldquo;&lt;code&gt;x::a&lt;/code&gt;&amp;rdquo; means &amp;ldquo;&lt;code&gt;x::forall a. a&lt;/code&gt;&amp;rdquo; by Haskell&amp;rsquo;s usual implicit quantification rules.</source>
          <target state="translated">「 &lt;code&gt;a&lt;/code&gt; 」は「 &lt;code&gt;g&lt;/code&gt; 」の定義にスコープしないため、このプログラムは拒否されます。したがって、「 &lt;code&gt;x::a&lt;/code&gt; 」は「 &lt;code&gt;x::forall a. a&lt;/code&gt; 」を意味します。Haskellの通常の暗黙の定量化規則によります」。</target>
        </trans-unit>
        <trans-unit id="d583e97443b28f0723fcc05e1353f50d62ca3ee1" translate="yes" xml:space="preserve">
          <source>This program will core dump. This problem with polymorphic references is well known in the ML community, and does not arise with normal monadic use of references. There is no easy way to make it impossible once you use &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. Indeed, it is possible to write &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; with the help of &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. So be careful!</source>
          <target state="translated">このプログラムはコアダンプします。ポリモーフィック参照に関するこの問題は、MLコミュニティではよく知られており、参照の通常のモナド使用では発生しません。 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; を使用すると、それを不可能にする簡単な方法はありません。実際、 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; の助けを借りて、coerce &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; a- &amp;gt; bと書くことが可能です。ので注意してください！</target>
        </trans-unit>
        <trans-unit id="39080170230fd9e748e118da55a46cb1b209f144" translate="yes" xml:space="preserve">
          <source>This program will core dump. This problem with polymorphic references is well known in the ML community, and does not arise with normal monadic use of references. There is no easy way to make it impossible once you use &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. Indeed, it is possible to write &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; with the help of &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. So be careful!</source>
          <target state="translated">このプログラムはコアダンプします。ポリモーフィック参照に関するこの問題は、MLコミュニティではよく知られており、参照の通常のモナド使用では発生しません。 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; を使用すると、それを不可能にする簡単な方法はありません。実際、 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; の助けを借りて、coerce &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; a- &amp;gt; bと書くことが可能です。ので注意してください！</target>
        </trans-unit>
        <trans-unit id="8c3070f1819b5144ee0019a42b9364d5b62ac534" translate="yes" xml:space="preserve">
          <source>This program will core dump. This problem with polymorphic references is well known in the ML community, and does not arise with normal monadic use of references. There is no easy way to make it impossible once you use &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. Indeed, it is possible to write &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; with the help of &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. So be careful!</source>
          <target state="translated">このプログラムはコアダンプします。ポリモーフィック参照に関するこの問題は、MLコミュニティではよく知られており、参照の通常のモナド使用では発生しません。 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; を使用すると、それを不可能にする簡単な方法はありません。実際、 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; の助けを借りて、coerce &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; a- &amp;gt; bと書くことが可能です。ので注意してください！</target>
        </trans-unit>
        <trans-unit id="8edf15b81edbb17eae494e16b7d0533a271e50da" translate="yes" xml:space="preserve">
          <source>This provides a type-indexed type representation mechanism, similar to that described by,</source>
          <target state="translated">によって記述されているのと同様の、型インデックス付きの型表現メカニズムを提供します。</target>
        </trans-unit>
        <trans-unit id="77d3447bc17b046a19fec0f3cc3c7ab330fb5b15" translate="yes" xml:space="preserve">
          <source>This reduces the allocation and trimming overhead, as all generated &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s fit into the first buffer and there is no trimming required, if more than 64 bytes and less than 128 bytes are written.</source>
          <target state="translated">これにより、生成されたすべての &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; が最初のバッファーに収まり、64バイトを超え128バイト未満が書き込まれる場合はトリミングが不要になるため、割り当てとトリミングのオーバーヘッドが削減されます。</target>
        </trans-unit>
        <trans-unit id="79b2e379cd0f1eaf600da24618a21f3bffdedc96" translate="yes" xml:space="preserve">
          <source>This relative path technique can be used with either of the two &lt;code&gt;-dynload&lt;/code&gt; modes, though it makes most sense with the &lt;code&gt;deploy&lt;/code&gt; mode. The difference is that with the &lt;code&gt;deploy&lt;/code&gt; mode, the above example will end up with an ELF &lt;code&gt;RUNPATH&lt;/code&gt; of just &lt;code&gt;$ORIGIN&lt;/code&gt; while with the &lt;code&gt;sysdep&lt;/code&gt; mode the &lt;code&gt;RUNPATH&lt;/code&gt; will be &lt;code&gt;$ORIGIN&lt;/code&gt; followed by all the library directories of all the packages that the program depends on (e.g. &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;rts&lt;/code&gt; packages etc.) which are typically absolute paths. The unix tool &lt;code&gt;readelf --dynamic&lt;/code&gt; is handy for inspecting the &lt;code&gt;RPATH&lt;/code&gt;/&lt;code&gt;RUNPATH&lt;/code&gt; entries in ELF shared libraries and executables.</source>
          <target state="translated">この相対パス手法は、2つの &lt;code&gt;-dynload&lt;/code&gt; モードのどちらでも使用できますが、 &lt;code&gt;deploy&lt;/code&gt; モードでは最も理にかなっています。違いは、 &lt;code&gt;deploy&lt;/code&gt; モードでは、上記の例はELF &lt;code&gt;RUNPATH&lt;/code&gt; が &lt;code&gt;$ORIGIN&lt;/code&gt; になるだけであり、 &lt;code&gt;sysdep&lt;/code&gt; モードでは、 &lt;code&gt;RUNPATH&lt;/code&gt; が &lt;code&gt;$ORIGIN&lt;/code&gt; その後にプログラムが依存するすべてのパッケージのすべてのライブラリディレクトリが続くことです（たとえば、 &lt;code&gt;base&lt;/code&gt; および &lt;code&gt;rts&lt;/code&gt; パッケージなど）。これは通常、絶対パスです。 UNIXツール &lt;code&gt;readelf --dynamic&lt;/code&gt; は、 &lt;code&gt;RPATH&lt;/code&gt; の検査に便利です/ &lt;code&gt;RUNPATH&lt;/code&gt; ELF共有ライブラリおよび実行可能ファイルのRUNPATHエントリ。</target>
        </trans-unit>
        <trans-unit id="370040cae2bc778368a6b92c807c4b5827ecb99e" translate="yes" xml:space="preserve">
          <source>This representation is generated automatically if a &lt;code&gt;deriving Generic&lt;/code&gt; clause is attached to the datatype. &lt;a href=&quot;#stand-alone-deriving&quot;&gt;Standalone deriving&lt;/a&gt; can also be used.</source>
          <target state="translated">この表現は、 &lt;code&gt;deriving Generic&lt;/code&gt; 句がデータ型にアタッチされている場合に自動的に生成されます。&lt;a href=&quot;#stand-alone-deriving&quot;&gt;スタンドアロン導出&lt;/a&gt;も使用できます。</target>
        </trans-unit>
        <trans-unit id="30dd0b304103583a22935853ab5fa131cea21cbe" translate="yes" xml:space="preserve">
          <source>This representation is very generic in that no types are given special treatment. However, some functions might need to handle some known types specially, for example the following two functions collect all argument types of (nested) arrow types, and recognize the &lt;code&gt;Int&lt;/code&gt; type, respectively:</source>
          <target state="translated">この表現は、型が特別な扱いを受けないという点で非常に一般的です。ただし、一部の関数は、いくつかの既知の型を特別に処理する必要がある場合があります。たとえば、次の2つの関数は、（ネストされた）矢印型のすべての引数型を収集し、それぞれ &lt;code&gt;Int&lt;/code&gt; 型を認識します。</target>
        </trans-unit>
        <trans-unit id="54c505cd157188eeaeea208a88996c170f20c5ef" translate="yes" xml:space="preserve">
          <source>This resembles the wildcards that can be used in &lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;. However, there are some differences. No error messages reporting the inferred types are generated, nor does the extension &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; have any effect.</source>
          <target state="translated">これは、&lt;a href=&quot;#partial-type-signatures&quot;&gt;部分型シグネチャで&lt;/a&gt;使用できるワイルドカードに似ています。ただし、いくつかの違いがあります。推論された型を報告するエラーメッセージは生成されません。また、拡張&lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt;も影響しません。</target>
        </trans-unit>
        <trans-unit id="05658b8ed19f8a18e37b401843f9f1390a5fc067" translate="yes" xml:space="preserve">
          <source>This results in the variable &lt;code&gt;output&lt;/code&gt; taking on the value below:</source>
          <target state="translated">これにより、変数の &lt;code&gt;output&lt;/code&gt; は以下の値になります。</target>
        </trans-unit>
        <trans-unit id="faeb3724827d317e7530a6953ccd1a741efde90d" translate="yes" xml:space="preserve">
          <source>This rule applies in datatype declarations, too. For example, if we have &lt;code&gt;data Proxy a = Proxy&lt;/code&gt; (and &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; is enabled), then &lt;code&gt;a&lt;/code&gt; will be assigned kind &lt;code&gt;k&lt;/code&gt;, where &lt;code&gt;k&lt;/code&gt; is a fresh kind variable. Because &lt;code&gt;k&lt;/code&gt; was not written by the user, it will be unavailable for type application in the type of the constructor &lt;code&gt;Proxy&lt;/code&gt;; only the &lt;code&gt;a&lt;/code&gt; will be available.</source>
          <target state="translated">このルールは、データ型宣言にも適用されます。たとえば、 &lt;code&gt;data Proxy a = Proxy&lt;/code&gt; （そして&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;が有効になっている）場合、 &lt;code&gt;a&lt;/code&gt; には種類 &lt;code&gt;k&lt;/code&gt; が割り当てられます。ここで、 &lt;code&gt;k&lt;/code&gt; は新しい種類の変数です。 &lt;code&gt;k&lt;/code&gt; はユーザーによって作成されたものではないため、コンストラクター &lt;code&gt;Proxy&lt;/code&gt; の型の型アプリケーションでは使用できません。 &lt;code&gt;a&lt;/code&gt; のみが利用可能になります。</target>
        </trans-unit>
        <trans-unit id="7ab2f281f7fbf2bff47d327fa4cfe489acb61e45" translate="yes" xml:space="preserve">
          <source>This rule has occasionally-surprising consequences (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10132&quot;&gt;#10132&lt;/a&gt;).</source>
          <target state="translated">このルールは時折驚くべき結果をもたらします（&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10132&quot;&gt;＃10132を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="0dae13ecc0c945a796e78580e4456aee9006b862" translate="yes" xml:space="preserve">
          <source>This rule has occasionally-surprising consequences (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10132&quot;&gt;Issue #10132&lt;/a&gt;.</source>
          <target state="translated">このルールは時々驚くべき結果をもたらします（&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10132&quot;&gt;Issue＃10132を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="f8a75e7f4aae139decf4dbddc8f92f07f78b73ed" translate="yes" xml:space="preserve">
          <source>This rule is applied regardless of flags. If you want a more exotic context, you can write it yourself, using the &lt;a href=&quot;#stand-alone-deriving&quot;&gt;standalone deriving mechanism&lt;/a&gt;.</source>
          <target state="translated">このルールはフラグに関係なく適用されます。よりエキゾチックなコンテキストが必要な場合は、&lt;a href=&quot;#stand-alone-deriving&quot;&gt;スタンドアロンの派生メカニズム&lt;/a&gt;を使用して自分で作成できます。</target>
        </trans-unit>
        <trans-unit id="d9ad35ca09458fcaf673d419d014807d6053c2a9" translate="yes" xml:space="preserve">
          <source>This rule will cause the compiler to go into an infinite loop.</source>
          <target state="translated">このルールは、コンパイラが無限ループに陥る原因となります。</target>
        </trans-unit>
        <trans-unit id="2d325df582f925494ea658de7dc04323c3323bae" translate="yes" xml:space="preserve">
          <source>This rule works for any concrete type constructor, including type constructors with polymorphic kinds. The only restriction is that if the type constructor has a polymorphic kind, then it has to be applied to all of its kinds parameters, and these kinds need to be concrete (i.e., they cannot mention kind variables).</source>
          <target state="translated">このルールは、多相型を持つ型コンストラクタを含め、すべての具象型コンストラクタで動作します。唯一の制限は、型コンストラクタが多相型を持つ場合、その型コンストラクタのすべての型パラメータに適用されなければならないということです。</target>
        </trans-unit>
        <trans-unit id="012cf785712f9f58baa44a19777eaca31580d1fc" translate="yes" xml:space="preserve">
          <source>This runs the interpreted code in a separate process (see &lt;a href=&quot;#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;) and runs it in profiling mode to collect call stack information. Note that because we&amp;rsquo;re running the interpreted code in profiling mode, all packages that you use must be compiled for profiling. The &lt;code&gt;-prof&lt;/code&gt; flag to GHCi only works in conjunction with &lt;code&gt;-fexternal-interpreter&lt;/code&gt;.</source>
          <target state="translated">これにより、インタープリターコードが別のプロセスで実行され（「別のプロセスで&lt;a href=&quot;#external-interpreter&quot;&gt;インタープリター&lt;/a&gt;を実行する」を参照）、プロファイリングモードで実行されて、コールスタック情報が収集されます。インタープリターコードはプロファイリングモードで実行しているため、使用するすべてのパッケージはプロファイリング用にコンパイルする必要があります。GHCi の &lt;code&gt;-prof&lt;/code&gt; フラグは、 &lt;code&gt;-fexternal-interpreter&lt;/code&gt; と組み合わせた場合にのみ機能します。</target>
        </trans-unit>
        <trans-unit id="0e7a2ad40c566ce0f6643ee923a3e30a05545bee" translate="yes" xml:space="preserve">
          <source>This says that &lt;code&gt;modify (+1)&lt;/code&gt; acts over any Monad that is a member of the &lt;code&gt;MonadState&lt;/code&gt; class, with an &lt;code&gt;Int&lt;/code&gt; state.</source>
          <target state="translated">このことは言う &lt;code&gt;modify (+1)&lt;/code&gt; のメンバーである任意のモナド上に作用する &lt;code&gt;MonadState&lt;/code&gt; すると、クラス &lt;code&gt;Int&lt;/code&gt; 状態。</target>
        </trans-unit>
        <trans-unit id="aeefc346ad248407772de61eb44c91ebc62b1dff" translate="yes" xml:space="preserve">
          <source>This section defines the layout of these events. The &lt;code&gt;String&lt;/code&gt; type below is defined to be a UTF-8 encoded NUL-terminated string.</source>
          <target state="translated">このセクションでは、これらのイベントのレイアウトを定義します。以下の &lt;code&gt;String&lt;/code&gt; 型は、UTF-8でエンコードされたNULで終了する文字列として定義されています。</target>
        </trans-unit>
        <trans-unit id="426477ffd0f3109ffb983e296577e866ad83653a" translate="yes" xml:space="preserve">
          <source>This section describes &lt;em&gt;data type promotion&lt;/em&gt;, an extension to the kind system that complements kind polymorphism. It is enabled by &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, and described in more detail in the paper &lt;a href=&quot;http://dreixel.net/research/pdf/ghp.pdf&quot;&gt;Giving Haskell a Promotion&lt;/a&gt;, which appeared at TLDI 2012.</source>
          <target state="translated">このセクションでは、種類ポリモーフィズムを補完する種類システムの拡張である&lt;em&gt;データ型の昇格&lt;/em&gt;について説明し&lt;em&gt;ます&lt;/em&gt;。これは&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt;によって有効化され、TLDI 2012に掲載されたペーパー&lt;a href=&quot;http://dreixel.net/research/pdf/ghp.pdf&quot;&gt;Giving Haskell a Promotion&lt;/a&gt;でより詳細に説明されています。</target>
        </trans-unit>
        <trans-unit id="cb974cf5a36706fbeb443061b653e868010df89d" translate="yes" xml:space="preserve">
          <source>This section describes GHC&amp;rsquo;s kind system, as it appears in version 8.0 and beyond. The kind system as described here is always in effect, with or without extensions, although it is a conservative extension beyond standard Haskell. The extensions above simply enable syntax and tweak the inference algorithm to allow users to take advantage of the extra expressiveness of GHC&amp;rsquo;s kind system.</source>
          <target state="translated">このセクションでは、バージョン8.0以降に登場するGHCの親切なシステムについて説明します。ここで説明する親切なシステムは、拡張機能の有無にかかわらず常に有効ですが、標準のHaskellを超えた保守的な拡張機能です。上記の拡張機能は、シンタックスを有効にし、推論アルゴリズムを微調整するだけで、GHCの類のシステムの特別な表現力を利用できるようにします。</target>
        </trans-unit>
        <trans-unit id="d4d58a26ba3b02f1db1fe2de0ac14aa3d6a048b5" translate="yes" xml:space="preserve">
          <source>This section describes features specific to GHC's implementation of Concurrent Haskell.</source>
          <target state="translated">このセクションでは、GHCのConcurrent Haskellの実装に特有の機能について説明します。</target>
        </trans-unit>
        <trans-unit id="bdd49ffb73a3731ac6d967fc14496c16e1567101" translate="yes" xml:space="preserve">
          <source>This section describes how to create DLLs to be called from other languages, such as Visual Basic or C++. This is a special case of &lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;Making a Haskell library that can be called from foreign code&lt;/a&gt;; we&amp;rsquo;ll deal with the DLL-specific issues that arise below. Here&amp;rsquo;s an example:</source>
          <target state="translated">このセクションでは、Visual BasicやC ++などの他の言語から呼び出されるDLLを作成する方法について説明します。これは、&lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;外部コードから呼び出すことができるHaskellライブラリを作成&lt;/a&gt;する特別なケースです。以下で発生するDLL固有の問題に対処します。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="c716f59912a3ade4c8a600a747406892f16105cd" translate="yes" xml:space="preserve">
          <source>This section describes other program(s) which we distribute, that help with the Great Haskell Programming Task.</source>
          <target state="translated">このセクションでは、Great Haskell Programming Taskを支援するために配布している他のプログラムについて説明します。</target>
        </trans-unit>
        <trans-unit id="cd9343002ee7f20ea72481ff97c75ea4a9503720" translate="yes" xml:space="preserve">
          <source>This section describes what files GHC expects to find, what files it creates, where these files are stored, and what options affect this behaviour.</source>
          <target state="translated">このセクションでは、GHC がどのようなファイルを見つけることを期待しているのか、どのようなファイルを作成しているのか、これらのファイルがどこに保存されているのか、そしてこの動作に影響を与えるオプションについて説明します。</target>
        </trans-unit>
        <trans-unit id="f1c1c7aa4c4b76ef9244f133c648760bb4ada19e" translate="yes" xml:space="preserve">
          <source>This section documents GHC&amp;rsquo;s take on various issues that are left undefined or implementation specific in Haskell 98.</source>
          <target state="translated">このセクションでは、Haskell 98で未定義または実装固有のさまざまな問題に対するGHCの取り組みについて説明します。</target>
        </trans-unit>
        <trans-unit id="d1b5cee4b5290696273cb8636327d9703229eadc" translate="yes" xml:space="preserve">
          <source>This section documents the encodings of the events emitted to GHC&amp;rsquo;s &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;event log&lt;/a&gt;. These events can include information about the thread scheduling events, garbage collection statistics, profiling information, user-defined tracing events.</source>
          <target state="translated">このセクションでは、GHCの&lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;イベントログに出力&lt;/a&gt;されるイベントのエンコーディングについて説明します。これらのイベントには、スレッドスケジューリングイベント、ガベージコレクション統計、プロファイリング情報、ユーザー定義のトレースイベントに関する情報を含めることができます。</target>
        </trans-unit>
        <trans-unit id="b978b97b7476bee1ad03a8af2ae4346819b8abd7" translate="yes" xml:space="preserve">
          <source>This section is a quick-reference for GHC&amp;rsquo;s command-line flags. For each flag, we also list its mode/dynamic status (see &lt;a href=&quot;using#mode-dynamic-flags&quot;&gt;Dynamic and Mode options&lt;/a&gt;), and the flag&amp;rsquo;s opposite (if available).</source>
          <target state="translated">このセクションは、GHCのコマンドラインフラグのクイックリファレンスです。各フラグについて、そのモード/動的ステータス（「&lt;a href=&quot;using#mode-dynamic-flags&quot;&gt;動的」および「モード」オプションを&lt;/a&gt;参照）、およびフラグの反対（使用可能な場合）もリストします。</target>
        </trans-unit>
        <trans-unit id="e5d224e7441e3fb869faddf4a0821bffaff71c9b" translate="yes" xml:space="preserve">
          <source>This section is intended for implementors of tooling which consume these events.</source>
          <target state="translated">このセクションは、これらのイベントを消費するツールの実装者を対象としています。</target>
        </trans-unit>
        <trans-unit id="2631d568425721367141e5ca16a0dc349ee46597" translate="yes" xml:space="preserve">
          <source>This section is intended for implementors of tooling which consume these events. GHC ships with a C header file (&lt;code&gt;EventlogFormat.h&lt;/code&gt;) which provides symbolic names for the event type IDs described in this file.</source>
          <target state="translated">このセクションは、これらのイベントを消費するツールの実装者を対象としています。 GHCには、このファイルに記述されているイベントタイプIDの記号名を提供するCヘッダーファイル（ &lt;code&gt;EventlogFormat.h&lt;/code&gt; ）が付属しています。</target>
        </trans-unit>
        <trans-unit id="4793c1dfb931aabba357e67757e80e8fe4a49b96" translate="yes" xml:space="preserve">
          <source>This section lists Glasgow Haskell infelicities in its implementation of Haskell 98 and Haskell 2010. See also the &amp;ldquo;when things go wrong&amp;rdquo; section (&lt;a href=&quot;gone_wrong#wrong&quot;&gt;What to do when something goes wrong&lt;/a&gt;) for information about crashes, space leaks, and other undesirable phenomena.</source>
          <target state="translated">Haskellの98とHaskellの2010年の実装でこのセクションでグラスゴーHaskellのinfelicitiesも参照してください「物事がうまくいかないとき」セクション（&lt;a href=&quot;gone_wrong#wrong&quot;&gt;何かがうまくいかないときに何をすべきか&lt;/a&gt;がクラッシュ、スペースリーク、および他の望ましくない現象の詳細については）。</target>
        </trans-unit>
        <trans-unit id="9d329579f2386fca40f0668d94a24284cae13ec1" translate="yes" xml:space="preserve">
          <source>This section, and the next one, documents GHC&amp;rsquo;s type-class extensions. There&amp;rsquo;s lots of background in the paper &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/type-class-design-space/&quot;&gt;Type classes: exploring the design space&lt;/a&gt; (Simon Peyton Jones, Mark Jones, Erik Meijer).</source>
          <target state="translated">このセクションと次のセクションでは、GHCの型クラス拡張について説明します。紙の&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/type-class-design-space/&quot;&gt;Typeクラス&lt;/a&gt;には多くの背景があります。デザイン空間の探索（Simon Peyton Jones、Mark Jones、Erik Meijer）。</target>
        </trans-unit>
        <trans-unit id="2b1a90dce5c453c0f69c1639a0cce7223844a1ff" translate="yes" xml:space="preserve">
          <source>This seems like a generalisation of the standard &lt;code&gt;$&lt;/code&gt; operator. If we think about compiling this to runnable code, though, problems appear. In particular, when we call &lt;code&gt;bad&lt;/code&gt;, we must somehow pass &lt;code&gt;x&lt;/code&gt; into &lt;code&gt;bad&lt;/code&gt;. How wide (that is, how many bits) is &lt;code&gt;x&lt;/code&gt;? Is it a pointer? What kind of register (floating-point or integral) should &lt;code&gt;x&lt;/code&gt; go in? It&amp;rsquo;s all impossible to say, because &lt;code&gt;x&lt;/code&gt;&amp;lsquo;s type, &lt;code&gt;a :: TYPE r1&lt;/code&gt; is levity polymorphic. We thus forbid such constructions, via the following straightforward rule:</source>
          <target state="translated">これは、標準の &lt;code&gt;$&lt;/code&gt; 演算子の一般化のようです。しかし、これを実行可能なコードにコンパイルすることを考えた場合、問題が発生します。特に、 &lt;code&gt;bad&lt;/code&gt; を呼び出す場合、 &lt;code&gt;x&lt;/code&gt; を &lt;code&gt;bad&lt;/code&gt; に渡す必要があります。 &lt;code&gt;x&lt;/code&gt; の幅（ビット数）はどれくらいですか？ポインタですか？ &lt;code&gt;x&lt;/code&gt; はどの種類のレジスタ（浮動小数点または整数）に入れるべきですか？ &lt;code&gt;x&lt;/code&gt; の型、 &lt;code&gt;a :: TYPE r1&lt;/code&gt; はレヴィの多型であるため、すべてを言うのは不可能です。したがって、次のような簡単なルールを使用して、このような構造を禁止します。</target>
        </trans-unit>
        <trans-unit id="36e8a4554348a6c067a922b4fe362601f76eb118" translate="yes" xml:space="preserve">
          <source>This seems like a generalisation of the standard &lt;code&gt;$&lt;/code&gt; operator. If we think about compiling this to runnable code, though, problems appear. In particular, when we call &lt;code&gt;bad&lt;/code&gt;, we must somehow pass &lt;code&gt;x&lt;/code&gt; into &lt;code&gt;bad&lt;/code&gt;. How wide (that is, how many bits) is &lt;code&gt;x&lt;/code&gt;? Is it a pointer? What kind of register (floating-point or integral) should &lt;code&gt;x&lt;/code&gt; go in? It&amp;rsquo;s all impossible to say, because &lt;code&gt;x&lt;/code&gt;&amp;rsquo;s type, &lt;code&gt;a :: TYPE r1&lt;/code&gt; is levity polymorphic. We thus forbid such constructions, via the following straightforward rule:</source>
          <target state="translated">これは、標準の &lt;code&gt;$&lt;/code&gt; 演算子の一般化のようです。ただし、これを実行可能なコードにコンパイルすることを考えると、問題が発生します。特に、 &lt;code&gt;bad&lt;/code&gt; と呼ぶときは、どういうわけか &lt;code&gt;x&lt;/code&gt; を &lt;code&gt;bad&lt;/code&gt; に渡さなければなりません。 &lt;code&gt;x&lt;/code&gt; の幅（つまり、ビット数）はどれくらいですか？ポインタですか？ &lt;code&gt;x&lt;/code&gt; はどのような種類のレジスタ（浮動小数点または積分）に入れる必要がありますか？ &lt;code&gt;x&lt;/code&gt; の型、 &lt;code&gt;a :: TYPE r1&lt;/code&gt; はレビティ多型であるため、言うことはすべて不可能です。したがって、次の簡単なルールにより、このような構造を禁止します。</target>
        </trans-unit>
        <trans-unit id="c863740ea2de0c5a648f81c5a1a438b882986762" translate="yes" xml:space="preserve">
          <source>This seems the most intuitive and transparent approach towards the developer, who no longer needs to concern himself with the fact that his code might contain overlapping axioms or with the ordering of his instance contexts. But backtracking would apply equally to ordinary instance selection (in the presence of overlapping instances), so it is a much more pervasive change, with substantial consequences for the type inference engine.</source>
          <target state="translated">これは開発者にとって最も直感的で透明性の高いアプローチであり、コードに重複する公理が含まれているかもしれないという事実や、インスタンスコンテキストの順序を気にする必要はありません。しかし、バックトラッキングは通常のインスタンス選択(インスタンスが重複している場合)にも同様に適用されるので、型推論エンジンに大きな影響を与える、より広範囲な変更です。</target>
        </trans-unit>
        <trans-unit id="91bbd3a27d52a3a851dbfdab4b9ab18c81125223" translate="yes" xml:space="preserve">
          <source>This should call &lt;code&gt;error&lt;/code&gt; but actually prints &lt;code&gt;True&lt;/code&gt;. Reason: GHC eta-expands &lt;code&gt;f&lt;/code&gt; to</source>
          <target state="translated">これは &lt;code&gt;error&lt;/code&gt; を呼び出すはずですが、実際には &lt;code&gt;True&lt;/code&gt; を出力します。理由：GHCは &lt;code&gt;f&lt;/code&gt; をeta-expands</target>
        </trans-unit>
        <trans-unit id="7ab63a2693cd6c7a45c1f790143037cd6507bc64" translate="yes" xml:space="preserve">
          <source>This should produce a file named &lt;code&gt;fib.dSYM&lt;/code&gt;.</source>
          <target state="translated">これにより、 &lt;code&gt;fib.dSYM&lt;/code&gt; という名前のファイルが生成されます。</target>
        </trans-unit>
        <trans-unit id="739e32040ecc4d2911d13031c9ae018167e3429f" translate="yes" xml:space="preserve">
          <source>This should work, as long as your GHCi was built with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; switch, which is the default. Consult whoever supplied your GHCi installation.</source>
          <target state="translated">これは、GHCiが&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;スイッチ（デフォルト）でビルドされている限り機能します。GHCiインストールを提供した人に相談してください。</target>
        </trans-unit>
        <trans-unit id="58d6ca6d530436d6559c489e7dd370e9564a3d34" translate="yes" xml:space="preserve">
          <source>This simple plugin takes over the execution of Template Haskell code, replacing any expression splice it encounters by &lt;code&gt;0&lt;/code&gt; (at type &lt;code&gt;Int&lt;/code&gt;), and errors out on any other type of splice.</source>
          <target state="translated">この単純なプラグインは、Template Haskellコードの実行を引き継ぎ、検出した式のスプライスを &lt;code&gt;0&lt;/code&gt; （タイプ &lt;code&gt;Int&lt;/code&gt; ）に置き換え、他のタイプのスプライスではエラーになります。</target>
        </trans-unit>
        <trans-unit id="689b2645ac8c6757ff69fc4ca6accdc5ec8ea0cb" translate="yes" xml:space="preserve">
          <source>This slightly odd-looking rule instructs GHC to replace &lt;code&gt;genericLookup&lt;/code&gt; by &lt;code&gt;intLookup&lt;/code&gt;&lt;em&gt;whenever the types match&lt;/em&gt;. What is more, this rule does not need to be in the same file as &lt;code&gt;genericLookup&lt;/code&gt;, unlike the &lt;code&gt;SPECIALIZE&lt;/code&gt; pragmas which currently do (so that they have an original definition available to specialise).</source>
          <target state="translated">この少し奇妙に見えるルールは、GHCに&lt;em&gt;、型が一致するときは常に&lt;/em&gt; &lt;code&gt;genericLookup&lt;/code&gt; を &lt;code&gt;intLookup&lt;/code&gt; に置き換えるように指示&lt;em&gt;します&lt;/em&gt;。さらに、このルールは、現在機能している &lt;code&gt;SPECIALIZE&lt;/code&gt; プラグマとは異なり、 &lt;code&gt;genericLookup&lt;/code&gt; と同じファイルにある必要はありません（そのため、特殊化に使用できる元の定義があります）。</target>
        </trans-unit>
        <trans-unit id="074a31f4d9e16cb86e220f5f40a063ee59b833fe" translate="yes" xml:space="preserve">
          <source>This stack structure means that the order of &lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-package-db ⟨file⟩&lt;/code&gt;&lt;/a&gt; flags or &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-3&quot;&gt;&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;&lt;/a&gt; is important. Each substack of the stack must be well formed (packages in databases on top of the stack can refer to packages below, but not vice versa).</source>
          <target state="translated">このスタック構造は、&lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;-package-db ⟨file⟩&lt;/code&gt; &lt;/a&gt;フラグまたは&lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-3&quot;&gt; &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; の順序&lt;/a&gt;が重要であることを意味します。スタックの各サブスタックは適切に形成されている必要があります（スタックの上にあるデータベース内のパッケージは、下のパッケージを参照できますが、その逆はできません）。</target>
        </trans-unit>
        <trans-unit id="e66c29e8f81778a2aa9684e85767a00ebb262ce6" translate="yes" xml:space="preserve">
          <source>This statement requires that f have the type forall a. [a] -&amp;gt; [a] . You can see an example of its use in the motivating example, as this form is used to apply take 5 .</source>
          <target state="translated">このステートメントでは、fの型がforall aである必要があります。[a]-&amp;gt; [a]。このフォームはテイク5を適用するために使用されるので、動機付けの例でその使用例を見ることができます。</target>
        </trans-unit>
        <trans-unit id="61c78a7e665855a92db9c5e9ffaec8226aba79b6" translate="yes" xml:space="preserve">
          <source>This strategy is as follows: GHC keeps a list of directories called the search path. For each of these directories, it tries appending &lt;code&gt;⟨basename⟩.⟨extension⟩&lt;/code&gt; to the directory, and checks whether the file exists. The value of ⟨basename⟩ is the module name with dots replaced by the directory separator (&amp;ldquo;&lt;code&gt;/&lt;/code&gt;&amp;rdquo; or &amp;ldquo;&lt;code&gt;\\&quot;&lt;/code&gt;, depending on the system), and ⟨extension⟩ is a source extension (&lt;code&gt;hs&lt;/code&gt;, &lt;code&gt;lhs&lt;/code&gt;) if we are in &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode or GHCi, or ⟨hisuf⟩ otherwise.</source>
          <target state="translated">この戦略は次のとおりです。GHCは、検索パスと呼ばれるディレクトリのリストを保持します。これらの各ディレクトリについて、「 &lt;code&gt;⟨basename⟩.⟨extension⟩&lt;/code&gt; をディレクトリに追加しようとし、ファイルが存在するかどうかを確認します。「basename」の値は、ディレクトリの区切り文字（「 &lt;code&gt;/&lt;/code&gt; 」または「 &lt;code&gt;\\&quot;&lt;/code&gt; 、システムによって異なります）でドットが置き換えられたモジュール名です。「extension」は、ソース拡張（ &lt;code&gt;hs&lt;/code&gt; 、 &lt;code&gt;lhs&lt;/code&gt; ）です。&lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;モードまたはGHCi、またはそれ以外の場合は「hisuf」。</target>
        </trans-unit>
        <trans-unit id="11ed97c596e1d0bcc228efb8114c48f030b93b3b" translate="yes" xml:space="preserve">
          <source>This tells you:</source>
          <target state="translated">これが教えてくれます。</target>
        </trans-unit>
        <trans-unit id="07d8f00faa3ae75b40703b0528f229ea480038a2" translate="yes" xml:space="preserve">
          <source>This thread has exceeded its allocation limit. See &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このスレッドは割り当て制限を超えました。 &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="c243ec7e03c31ba25363993635c259a833d99359" translate="yes" xml:space="preserve">
          <source>This translates to:</source>
          <target state="translated">と訳されています。</target>
        </trans-unit>
        <trans-unit id="e21f274a51f9949f29f1cc84b56dc845f3250ad2" translate="yes" xml:space="preserve">
          <source>This trick isn&amp;rsquo;t foolproof, because there might be other &lt;code&gt;B&lt;/code&gt; closures in the heap which aren&amp;rsquo;t the retainers we are interested in, but we&amp;rsquo;ve found this to be a useful technique in most cases.</source>
          <target state="translated">このトリックは、私たちが関心を持っているリテーナではない他の &lt;code&gt;B&lt;/code&gt; クロージャーがヒープ内にある可能性があるため、絶対に確実なわけではありませんが、ほとんどの場合、これは有用なテクニックであることがわかりました。</target>
        </trans-unit>
        <trans-unit id="7eedf2bab1365e54cbd4693945639257ad4fb0f2" translate="yes" xml:space="preserve">
          <source>This trivial type constructor serves two purposes:</source>
          <target state="translated">このトリビアルな型コンストラクタは2つの目的を果たします。</target>
        </trans-unit>
        <trans-unit id="628155b5f0687904716807bcd6409248a6482468" translate="yes" xml:space="preserve">
          <source>This two stage process is required because GHC cannot currently profile using both biographical and retainer information simultaneously.</source>
          <target state="translated">現在、GHCでは伝記情報とリテイナー情報を同時に利用したプロファイリングができないため、この2段階のプロセスが必要とされています。</target>
        </trans-unit>
        <trans-unit id="da64adf134879e08323ed89e3b1e4948df137364" translate="yes" xml:space="preserve">
          <source>This type represents unknown type-level natural numbers.</source>
          <target state="translated">この型は、未知の型レベルの自然数を表します。</target>
        </trans-unit>
        <trans-unit id="63e71d7f0b07e2f8017ecf6cb7990bb372b6c369" translate="yes" xml:space="preserve">
          <source>This type represents unknown type-level symbols.</source>
          <target state="translated">このタイプは、未知のタイプレベルのシンボルを表します。</target>
        </trans-unit>
        <trans-unit id="dc9fd430c3e406e9bfda4395aaf8dea448b92e37" translate="yes" xml:space="preserve">
          <source>This type signature contains a kind error which cannot be deferred.</source>
          <target state="translated">この型署名には、延期できない種類のエラーが含まれています。</target>
        </trans-unit>
        <trans-unit id="d1458226daed690560f642a2591b54664bcd7099" translate="yes" xml:space="preserve">
          <source>This use of underscore for wildcard in a type pattern is exactly like pattern matching in the term language, but is rather different to the use of a underscore in a partial type signature (see &lt;a href=&quot;#type-wildcards&quot;&gt;Type Wildcards&lt;/a&gt;).</source>
          <target state="translated">タイプパターンでのワイルドカードのアンダースコアの使用は、言語という用語のパターンマッチングとまったく同じですが、部分的な型シグネチャでのアンダースコアの使用とはかなり異なります（&lt;a href=&quot;#type-wildcards&quot;&gt;タイプワイルドカードを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="843b161d44b1dbfe532489a8737416458e734625" translate="yes" xml:space="preserve">
          <source>This uses the above tree rendering function, and displays the Html as a tree structure, allowing debugging of what is actually getting produced.</source>
          <target state="translated">これは上記のツリーレンダリング機能を利用して、Htmlをツリー構造として表示し、実際に生成されたものをデバッグすることができます。</target>
        </trans-unit>
        <trans-unit id="115cfdee365c54682223fbca3e4f895eb1f6e102" translate="yes" xml:space="preserve">
          <source>This uses the fact that Haskell&amp;rsquo;s &lt;code&gt;let&lt;/code&gt; introduces recursive bindings. We can rewrite this definition using &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">これは、Haskellの &lt;code&gt;let&lt;/code&gt; が再帰的なバインディングを導入するという事実を利用しています。 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; を使用してこの定義を書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="c1be3ce1530bcdc820d6c90501be79827a35abad" translate="yes" xml:space="preserve">
          <source>This uses the fact that Haskell&amp;rsquo;s &lt;code&gt;let&lt;/code&gt; introduces recursive bindings. We can rewrite this definition using &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">これは、Haskellの &lt;code&gt;let&lt;/code&gt; が再帰的なバインディングを導入するという事実を利用しています。 &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; を使用してこの定義を書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="7f88835ef04d1f3754243e8cd078d29d91f94c0a" translate="yes" xml:space="preserve">
          <source>This usually isn&amp;rsquo;t a problem, and it allows the GHC runtime system to make efficient use of OS thread resources. However, there are cases where it is useful to have more control over which OS thread is used, for example when calling foreign code that makes use of thread-local state. For cases like this, we provide &lt;em&gt;bound threads&lt;/em&gt;, which are Haskell threads tied to a particular OS thread. For information on bound threads, see the documentation for the &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; module.</source>
          <target state="translated">これは通常問題ではなく、GHCランタイムシステムがOSスレッドリソースを効率的に使用できるようにします。ただし、たとえば、スレッドローカルな状態を利用する外部コードを呼び出す場合など、使用するOSスレッドをより詳細に制御できると便利な場合があります。このような場合のために、特定のOSスレッドに関連付けられたHaskellスレッドである&lt;em&gt;バインドされたスレッド&lt;/em&gt;を提供します。バインドされたスレッドの詳細については、&lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;モジュールのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="d1160e9ee24dc05017fdb7f0fab69b46a37237f1" translate="yes" xml:space="preserve">
          <source>This usually isn&amp;rsquo;t a problem, and it allows the GHC runtime system to make efficient use of OS thread resources. However, there are cases where it is useful to have more control over which OS thread is used, for example when calling foreign code that makes use of thread-local state. For cases like this, we provide &lt;em&gt;bound threads&lt;/em&gt;, which are Haskell threads tied to a particular OS thread. For information on bound threads, see the documentation for the &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; module.</source>
          <target state="translated">これは通常問題ではなく、GHCランタイムシステムがOSスレッドリソースを効率的に利用できるようにします。ただし、スレッドローカル状態を利用する外部コードを呼び出す場合など、使用するOSスレッドをより細かく制御すると便利な場合があります。このような場合のために、特定のOSスレッドに関連付けられたHaskellスレッドである&lt;em&gt;バインドされたスレッド&lt;/em&gt;を提供します。バインドされたスレッドの詳細については、&lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;モジュールのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="a6fe6c899f31bf735023aed7edade5c845bb20c4" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; adds a finalizer that expects an environment in addition to the finalized pointer. The environment that will be passed to the finalizer is fixed by the second argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtrEnv&quot;&gt;newForeignPtrEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; のバリアントは、ファイナライズされたポインターに加えて、環境を期待するファイナライザーを追加します。ファイナライザに渡される環境は、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtrEnv&quot;&gt;newForeignPtrEnv&lt;/a&gt;&lt;/code&gt; の 2番目の引数によって修正されます。</target>
        </trans-unit>
        <trans-unit id="73272fcd0ad868eb9d7204167149b902a10e97d9" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; adds a finalizer that expects an environment in addition to the finalized pointer. The environment that will be passed to the finalizer is fixed by the second argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:newForeignPtrEnv&quot;&gt;newForeignPtrEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; のバリアントは、ファイナライズされたポインターに加えて、環境を期待するファイナライザーを追加します。ファイナライザに渡される環境は、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:newForeignPtrEnv&quot;&gt;newForeignPtrEnv&lt;/a&gt;&lt;/code&gt; の 2番目の引数によって修正されます。</target>
        </trans-unit>
        <trans-unit id="9448bed87d0380afdfc5a0e85ab115284bc4a12f" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; appears at the type level.</source>
          <target state="translated">この &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; のバリアントは、型レベルで表示されます。</target>
        </trans-unit>
        <trans-unit id="d456ce198372e2f1c13a10638b827f2a19ffc595" translate="yes" xml:space="preserve">
          <source>This version builds its output lazily; for a constant-space version with almost the same interface, see &lt;a href=&quot;control-monad-trans-writer-cps&quot;&gt;Control.Monad.Trans.Writer.CPS&lt;/a&gt;.</source>
          <target state="translated">このバージョンは出力を遅延してビルドします。ほぼ同じインターフェイスを持つ定数空間バージョンについては、&lt;a href=&quot;control-monad-trans-writer-cps&quot;&gt;Control.Monad.Trans.Writer.CPSを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4bbca1b395d2fc0bccc520c78f768d92dd9c439e" translate="yes" xml:space="preserve">
          <source>This version builds its output strictly and uses continuation-passing-style to achieve constant space usage. This transformer can be used as a drop-in replacement for &lt;a href=&quot;control-monad-trans-writer-strict&quot;&gt;Control.Monad.Trans.Writer.Strict&lt;/a&gt;.</source>
          <target state="translated">このバージョンは出力を厳密に構築し、継続渡しスタイルを使用して一定のスペース使用を実現します。このトランスフォーマーは、&lt;a href=&quot;control-monad-trans-writer-strict&quot;&gt;Control.Monad.Trans.Writer.Strictの&lt;/a&gt;ドロップイン代替として使用できます。</target>
        </trans-unit>
        <trans-unit id="930ffaae31f052ddd842b0cc0750e75bde4d30d4" translate="yes" xml:space="preserve">
          <source>This version builds its output strictly; for a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-writer-lazy&quot;&gt;Control.Monad.Trans.Writer.Lazy&lt;/a&gt;. Although the output is built strictly, it is not possible to achieve constant space behaviour with this transformer: for that, use &lt;a href=&quot;control-monad-trans-writer-cps&quot;&gt;Control.Monad.Trans.Writer.CPS&lt;/a&gt; instead.</source>
          <target state="translated">このバージョンは出力を厳密に構築します。同じインターフェースを持つ遅延バージョンについては、&lt;a href=&quot;control-monad-trans-writer-lazy&quot;&gt;Control.Monad.Trans.Writer.Lazyを&lt;/a&gt;参照してください。出力は厳密に構築されていますが、このトランスフォーマーで一定の空間動作を実現することはできません。そのためには、代わりに&lt;a href=&quot;control-monad-trans-writer-cps&quot;&gt;Control.Monad.Trans.Writer.CPSを&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="c43334581b0313064f9793791ae64d3cd9cb11bb" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このバージョンの &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; は、IOが単一のスレッドによってのみ実行されていることのチェックを省略しているため、より効率的です。したがって、 &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; を使用する場合、IOアクションが複数回（マルチプロセッサで）実行される可能性があるため、毎回同じ結果が得られるようにする必要があります。複製されたIOアクションの1つが部分的にのみ実行され、例外が発生することなく途中で中断されることさえあります。したがって、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ような関数は &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 内では安全に使用できません。</target>
        </trans-unit>
        <trans-unit id="5b59dda432be30bd0d16af2bacfdfe2d0f94c9cd" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このバージョンの &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; は、IOが単一のスレッドによってのみ実行されていることのチェックを省略しているため、より効率的です。したがって、 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; を使用する場合、IOアクションが複数回（マルチプロセッサで）実行される可能性があるため、毎回同じ結果が得られるようにする必要があります。複製されたIOアクションの1つが部分的にのみ実行され、例外が発生することなく途中で中断されることさえあります。したがって、 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ような関数は &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 内では安全に使用できません。</target>
        </trans-unit>
        <trans-unit id="f67494c6dd16fe58429c914e2600fd861b46bc50" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このバージョンの &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; は、IOが単一のスレッドによってのみ実行されていることのチェックを省略しているため、より効率的です。したがって、 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; を使用する場合、IOアクションが複数回（マルチプロセッサで）実行される可能性があるため、毎回同じ結果が得られるようにする必要があります。複製されたIOアクションの1つが部分的にのみ実行され、例外が発生することなく途中で中断されることさえあります。したがって、 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ような関数は &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 内では安全に使用できません。</target>
        </trans-unit>
        <trans-unit id="67c8e6fa4d8cd33fa64562f0db26d801a347a4eb" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このバージョンの &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; は、IOが単一のスレッドによってのみ実行されていることのチェックを省略しているため、より効率的です。したがって、 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; を使用する場合、IOアクションが複数回（マルチプロセッサで）実行される可能性があるため、毎回同じ結果が得られるようにする必要があります。複製されたIOアクションの1つが部分的にのみ実行され、例外が発生することなく途中で中断されることさえあります。したがって、 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ような関数は &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 内では安全に使用できません。</target>
        </trans-unit>
        <trans-unit id="c4d88c16a70afcd9d0a8c3fb7463a254c46bdefe" translate="yes" xml:space="preserve">
          <source>This version requires going through &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;, which can be inefficient. However, &lt;code&gt;toIntegralSized&lt;/code&gt; is optimized to allow GHC to statically determine the relative type sizes (as measured by &lt;code&gt;&lt;a href=&quot;data-bits#v:bitSizeMaybe&quot;&gt;bitSizeMaybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bits#v:isSigned&quot;&gt;isSigned&lt;/a&gt;&lt;/code&gt;) and avoid going through &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; for many types. (The implementation uses &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt;, which is itself optimized with rules for &lt;code&gt;base&lt;/code&gt; types but may go through &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; for some type pairs.)</source>
          <target state="translated">このバージョンは &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; を経由する必要があり、非効率的です。ただし、 &lt;code&gt;toIntegralSized&lt;/code&gt; は、GHCが相対的な型サイズ（ &lt;code&gt;&lt;a href=&quot;data-bits#v:bitSizeMaybe&quot;&gt;bitSizeMaybe&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-bits#v:isSigned&quot;&gt;isSigned&lt;/a&gt;&lt;/code&gt; で測定）を静的に決定できるように最適化されており、多くの型で &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; を通過しないようにしています。（実装は &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt; を使用します。それ自体は &lt;code&gt;base&lt;/code&gt; 型のルールで最適化されていますが、一部の型のペアでは &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; を通過する場合があります。）</target>
        </trans-unit>
        <trans-unit id="1713051baed32864f550a4d0ea48ed3f725fb1d1" translate="yes" xml:space="preserve">
          <source>This warning allows to detect such uses of &lt;code&gt;*&lt;/code&gt; before the actual breaking change takes place. The recommended fix is to replace &lt;code&gt;*&lt;/code&gt; with &lt;code&gt;Type&lt;/code&gt; imported from &lt;code&gt;Data.Kind&lt;/code&gt;.</source>
          <target state="translated">この警告により、実際の重大な変更が行われる前に、このような &lt;code&gt;*&lt;/code&gt; の使用を検出できます。推奨される修正は、 &lt;code&gt;*&lt;/code&gt; を &lt;code&gt;Data.Kind&lt;/code&gt; からインポートされた &lt;code&gt;Type&lt;/code&gt; で置き換えることです。</target>
        </trans-unit>
        <trans-unit id="e8dcf8302d1086b7ab10e1c70ed396a42e5a77b9" translate="yes" xml:space="preserve">
          <source>This warning can be addressed by either adding an explicit import list or using a &lt;code&gt;qualified&lt;/code&gt; import.</source>
          <target state="translated">この警告は、明示的なインポートリストを追加するか、 &lt;code&gt;qualified&lt;/code&gt; インポートを使用することで対処できます。</target>
        </trans-unit>
        <trans-unit id="78b29ba7cfb3d2918f39c1441e99d9f4ce1287c2" translate="yes" xml:space="preserve">
          <source>This warning can be turned off with the flag &lt;a href=&quot;using-warnings#ghc-flag--Wmissing-methods&quot;&gt;&lt;code&gt;-Wno-missing-methods&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この警告は、フラグ&lt;a href=&quot;using-warnings#ghc-flag--Wmissing-methods&quot;&gt; &lt;code&gt;-Wno-missing-methods&lt;/code&gt; で&lt;/a&gt;オフにできます。</target>
        </trans-unit>
        <trans-unit id="f18c523e2627209783834547bda765478c64d4a5" translate="yes" xml:space="preserve">
          <source>This warning is enabled by default in &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; mode.</source>
          <target state="translated">この警告は&lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt;モードではデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="72dcfecc8d5494d290ee1b21677961cb5175c2ed" translate="yes" xml:space="preserve">
          <source>This warning is off by default.</source>
          <target state="translated">この警告はデフォルトではオフになっています。</target>
        </trans-unit>
        <trans-unit id="8e25d5e92b85c829fac2f9477e4538faeeb61aa6" translate="yes" xml:space="preserve">
          <source>This warning is off by default. However, it is part of the &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group.</source>
          <target state="translated">この警告はデフォルトでオフになっています。ただし、これは&lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt;オプショングループの一部です。</target>
        </trans-unit>
        <trans-unit id="6ab34268e22349a8e7d47871cb222ede5f058bf5" translate="yes" xml:space="preserve">
          <source>This warning is off by default. However, it is part of the &lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group.</source>
          <target state="translated">この警告はデフォルトでオフになっています。ただし、これは&lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt;オプショングループの一部です。</target>
        </trans-unit>
        <trans-unit id="90f45b839bbf6248dce6eb6cd816c8aef78b200f" translate="yes" xml:space="preserve">
          <source>This warning is on by default.</source>
          <target state="translated">この警告はデフォルトでオンになっています。</target>
        </trans-unit>
        <trans-unit id="85a4aecbf183fdb5c42584066dc8c58f74eb0df7" translate="yes" xml:space="preserve">
          <source>This warning message:</source>
          <target state="translated">この警告メッセージ。</target>
        </trans-unit>
        <trans-unit id="f2d8282f3131ab448c2e8fe1cea01afde1138b09" translate="yes" xml:space="preserve">
          <source>This will be translated to:</source>
          <target state="translated">と訳されます。</target>
        </trans-unit>
        <trans-unit id="67139a4dd79ac7320ecf17b1941945dc01b22766" translate="yes" xml:space="preserve">
          <source>This will generate a derived instance for &lt;code&gt;(Foo [a])&lt;/code&gt; and &lt;code&gt;(Foo (Maybe a))&lt;/code&gt;, but other types such as &lt;code&gt;(Foo (Int,Bool))&lt;/code&gt; will not be an instance of &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">これにより、 &lt;code&gt;(Foo [a])&lt;/code&gt; および &lt;code&gt;(Foo (Maybe a))&lt;/code&gt; 派生インスタンスが生成されますが、 &lt;code&gt;(Foo (Int,Bool))&lt;/code&gt; などの他のタイプは &lt;code&gt;Eq&lt;/code&gt; のインスタンスにはなりません。</target>
        </trans-unit>
        <trans-unit id="a8f28dc06b16f7d92df21079a2ca982f57eeedb1" translate="yes" xml:space="preserve">
          <source>This will generate code to the effect of:</source>
          <target state="translated">という効果のあるコードが生成されます。</target>
        </trans-unit>
        <trans-unit id="c07dbdd03a5f971eb5b11d111347c944fa4be0b3" translate="yes" xml:space="preserve">
          <source>This will generate the derived instance:</source>
          <target state="translated">これで派生インスタンスが生成されます。</target>
        </trans-unit>
        <trans-unit id="bd17e4450ac723145ea38f572707911ae4592ad5" translate="yes" xml:space="preserve">
          <source>This will not actually evaluate &lt;code&gt;[|1|]&lt;/code&gt;, but instead replace it with the &lt;code&gt;0 :: Int&lt;/code&gt; literal.</source>
          <target state="translated">これは実際には &lt;code&gt;[|1|]&lt;/code&gt; 評価しませんが、代わりに &lt;code&gt;0 :: Int&lt;/code&gt; リテラルに置き換えます。</target>
        </trans-unit>
        <trans-unit id="2f9635805f734d6a6ddee1819b851b9ba1e60653" translate="yes" xml:space="preserve">
          <source>This will sometimes exit with &quot;interrupted&quot; and code 0, because the main thread is given a chance to shut down when the child thread calls safeExit. There is a race to shut down between the main and child threads.</source>
          <target state="translated">これは、子スレッドが safeExit を呼び出したときにメインスレッドにシャットダウンのチャンスが与えられているため、「中断された」とコード 0 で終了することがあります。メインスレッドと子スレッドの間には、シャットダウンするための競争があります。</target>
        </trans-unit>
        <trans-unit id="e043ff52775ea24499678e808e45c2c181b6a4d7" translate="yes" xml:space="preserve">
          <source>This will take &lt;code&gt;1 + 1 + 3&lt;/code&gt; words (the &lt;code&gt;ThingId&lt;/code&gt; constructor + unpacked &lt;code&gt;Int&lt;/code&gt; + unpacked &lt;code&gt;ShortByteString&lt;/code&gt;), plus the words for the string data.</source>
          <target state="translated">これには、 &lt;code&gt;1 + 1 + 3&lt;/code&gt; ワード（ &lt;code&gt;ThingId&lt;/code&gt; コンストラクター+アンパックされた &lt;code&gt;Int&lt;/code&gt; +アンパックされた &lt;code&gt;ShortByteString&lt;/code&gt; ）と、文字列データのワードが必要です。</target>
        </trans-unit>
        <trans-unit id="ffb0c676449de8bbdd669f772c381c5dd02a2d1b" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このスレッドがブロックされている間にファイル記述子が閉じられた場合、これは &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; をスローします。 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; で使用されたファイル記述子を安全に閉じるには、closeFdWithを使用し &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00447b8aa68db10f55c7e645117a8e9f6fffe839" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このスレッドがブロックされている間にファイル記述子が閉じられた場合、これは &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; をスローします。 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; で使用されたファイル記述子を安全に閉じるには、closeFdWithを使用し &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53fc96ce3bb24d77dd77c6af32ec3bc111b921f5" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このスレッドがブロックされている間にファイル記述子が閉じられた場合、これは &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; をスローします。 &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; で使用されたファイル記述子を安全に閉じるには、closeFdWithを使用し &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bf6f8f26d3df6178377eb2f4bcb17017279b918" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このスレッドがブロックされている間にファイル記述子が閉じられた場合、これは &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; をスローします。 &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; で使用されたファイル記述子を安全に閉じるには、closeFdWithを使用し &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1fa41044d20ae1ba84ba01e6410c48a361f0588d" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;control-concurrent#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このスレッドがブロックされている間にファイル記述子が閉じられた場合、これは &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; をスローします。 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; で使用されたファイル記述子を安全に閉じるには、closeFdWithを使用し &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07a6c139763138b599cb7bbf37ebd6c6563d7c63" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;control-concurrent#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このスレッドがブロックされている間にファイル記述子が閉じられた場合、これは &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; をスローします。 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; で使用されたファイル記述子を安全に閉じるには、closeFdWithを使用し &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="434dd08be079cc0bd5826173db52237398cf0bd7" translate="yes" xml:space="preserve">
          <source>This will yield a list containing every prefix of the word &amp;ldquo;hello&amp;rdquo; written out 5 times:</source>
          <target state="translated">これにより、「hello」という単語のすべてのプレフィックスを含むリストが5回書き出されます。</target>
        </trans-unit>
        <trans-unit id="5b7edf0cfa8817128eb97357c0b339d3968afe03" translate="yes" xml:space="preserve">
          <source>This works even if the type of the expression is more general, provided it can be &lt;em&gt;instantiated&lt;/em&gt; to &lt;code&gt;IO a&lt;/code&gt;. For example</source>
          <target state="translated">これは、式の型は、それができて、より一般的であったとしても働く&lt;em&gt;インスタンス化&lt;/em&gt;に &lt;code&gt;IO a&lt;/code&gt; 。例えば</target>
        </trans-unit>
        <trans-unit id="8a8c5448116287ce4d1ddb842a2e4bddd7bd26ff" translate="yes" xml:space="preserve">
          <source>This would generate the following instances:</source>
          <target state="translated">これにより、以下のようなインスタンスが生成されます。</target>
        </trans-unit>
        <trans-unit id="cb8b2e3b821f17047f04dce70c983fcb5b75e25f" translate="yes" xml:space="preserve">
          <source>Thread stacks (including the main thread&amp;rsquo;s stack) live on the heap. As the stack grows, new stack chunks are added as required; if the stack shrinks again, these extra stack chunks are reclaimed by the garbage collector. The default initial stack size is deliberately small, in order to keep the time and space overhead for thread creation to a minimum, and to make it practical to spawn threads for even tiny pieces of work.</source>
          <target state="translated">スレッドスタック（メインスレッドのスタックを含む）はヒープ上に存在します。スタックが大きくなると、必要に応じて新しいスタックチャンクが追加されます。スタックが再び縮小すると、これらの余分なスタックチャンクはガベージコレクターによって回収されます。スレッド作成の時間とスペースのオーバーヘッドを最小限に抑え、小さな作業でもスレッドを生成することを実用的にするために、デフォルトの初期スタックサイズは意図的に小さくなっています。</target>
        </trans-unit>
        <trans-unit id="afb01736a569cf800957c75c764e7b08e4d42882" translate="yes" xml:space="preserve">
          <source>ThreadDied</source>
          <target state="translated">ThreadDied</target>
        </trans-unit>
        <trans-unit id="b5249abe5125d8129b1f6094e27ca24e5dfd7b53" translate="yes" xml:space="preserve">
          <source>ThreadFinished</source>
          <target state="translated">ThreadFinished</target>
        </trans-unit>
        <trans-unit id="cd1b87b64abdd5b00fbed5a0cf0c46e8cabde3e0" translate="yes" xml:space="preserve">
          <source>ThreadId</source>
          <target state="translated">ThreadId</target>
        </trans-unit>
        <trans-unit id="cbacd9f0811868fee2692211c0f50253994d843c" translate="yes" xml:space="preserve">
          <source>ThreadId#</source>
          <target state="translated">ThreadId#</target>
        </trans-unit>
        <trans-unit id="210277f1f5be789fa38d99bf66d700f891a72b7b" translate="yes" xml:space="preserve">
          <source>ThreadKilled</source>
          <target state="translated">ThreadKilled</target>
        </trans-unit>
        <trans-unit id="1aacc5025242586267973269d42242e70a03c918" translate="yes" xml:space="preserve">
          <source>ThreadRunning</source>
          <target state="translated">ThreadRunning</target>
        </trans-unit>
        <trans-unit id="03539ff112c319a9993d65dc00b7fc1e80ba7832" translate="yes" xml:space="preserve">
          <source>ThreadStatus</source>
          <target state="translated">ThreadStatus</target>
        </trans-unit>
        <trans-unit id="c415b82d91d35c84fcc4655fc993abc0a3ab34c8" translate="yes" xml:space="preserve">
          <source>Threads created by &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; inherit the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; from the parent; that is, to start a thread in the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; state, use &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt;. This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received. To create a new thread in an unmasked state use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">作成されたスレッド &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; は継承 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; を親から。つまり、スレッドを &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; 状態で開始するには、 &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt; 使用します。これは、非同期例外が受信される前にフォークされたスレッドで例外ハンドラーを確立する必要がある場合に特に便利です。マスクされていない状態で新しいスレッドを作成するには、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="ca92e3299d152bebbdb5564f0db2b030aafcd93c" translate="yes" xml:space="preserve">
          <source>Threads created by &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; inherit the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; from the parent; that is, to start a thread in the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; state, use &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt;. This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received. To create a new thread in an unmasked state use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">作成されたスレッド &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; は継承 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; を親から。つまり、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; 状態でスレッドを開始するには、 &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt; 使用します。これは、非同期例外を受信する前に、フォークされたスレッドで例外ハンドラーを確立する必要がある場合に特に役立ちます。マスクされていない状態で新しいスレッドを作成するには、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="41a5f845685a6adcb61487ea721a7c03d396057a" translate="yes" xml:space="preserve">
          <source>Threads created by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; inherit the &lt;code&gt;&lt;a href=&quot;control-exception#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; from the parent; that is, to start a thread in the &lt;code&gt;&lt;a href=&quot;control-exception#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; state, use &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt;. This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received. To create a new thread in an unmasked state use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">作成されたスレッド &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; は継承 &lt;code&gt;&lt;a href=&quot;control-exception#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; を親から。つまり、スレッドを &lt;code&gt;&lt;a href=&quot;control-exception#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; 状態で開始するには、 &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt; 使用します。これは、非同期例外が受信される前にフォークされたスレッドで例外ハンドラーを確立する必要がある場合に特に便利です。マスクされていない状態で新しいスレッドを作成するには、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="02ddbb9a27e7d4b8d61317f07ad835b30faeee84" translate="yes" xml:space="preserve">
          <source>Threads created by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; inherit the &lt;code&gt;&lt;a href=&quot;ghc-io#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; from the parent; that is, to start a thread in the &lt;code&gt;&lt;a href=&quot;ghc-io#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; state, use &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt;. This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received. To create a new thread in an unmasked state use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">作成されたスレッド &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; は継承 &lt;code&gt;&lt;a href=&quot;ghc-io#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; を親から。つまり、スレッドを &lt;code&gt;&lt;a href=&quot;ghc-io#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; 状態で開始するには、 &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt; 使用します。これは、非同期例外が受信される前にフォークされたスレッドで例外ハンドラーを確立する必要がある場合に特に便利です。マスクされていない状態で新しいスレッドを作成するには、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="581562d7fdd77f3436334b5a7259e674b4960049" translate="yes" xml:space="preserve">
          <source>Threads with affinity</source>
          <target state="translated">親和性のあるスレッド</target>
        </trans-unit>
        <trans-unit id="1831f9d9a0a484604033e790590c1ca2132ad8fe" translate="yes" xml:space="preserve">
          <source>Three handles are allocated during program initialisation, and are initially open.</source>
          <target state="translated">プログラムの初期化時に3つのハンドルが割り当てられ、初期状態ではオープンになっています。</target>
        </trans-unit>
        <trans-unit id="3cfb69dc1eee67ef7ef938e002c1dcccfc372df6" translate="yes" xml:space="preserve">
          <source>Three kinds of buffering are supported: line-buffering, block-buffering or no-buffering. These modes have the following effects. For output, items are written out, or &lt;em&gt;flushed&lt;/em&gt;, from the internal buffer according to the buffer mode:</source>
          <target state="translated">3種類のバッファリングがサポートされています：ラインバッファリング、ブロックバッファリング、または非バッファリング。これらのモードには次の効果があります。出力の場合、アイテムは、バッファーモードに従って内部バッファーから書き出されるか、&lt;em&gt;フラッシュされ&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="67de4025637fbb0de0ee6f5d57e06c1db2d37ad2" translate="yes" xml:space="preserve">
          <source>Throw a &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:UnicodeException&quot;&gt;UnicodeException&lt;/a&gt;&lt;/code&gt; if decoding fails.</source>
          <target state="translated">デコードが失敗した場合、 &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:UnicodeException&quot;&gt;UnicodeException&lt;/a&gt;&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="530bb7b54f06bf2237068556f8b41935da4566c0" translate="yes" xml:space="preserve">
          <source>Throw a &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:UnicodeException&quot;&gt;UnicodeException&lt;/a&gt;&lt;/code&gt; if encoding fails.</source>
          <target state="translated">エンコーディングが失敗した場合、 &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:UnicodeException&quot;&gt;UnicodeException&lt;/a&gt;&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="a88939f2bc16a79d5911956081588d78806af274" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションが &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; を返した場合、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; の現在の値に対応する &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="c86385b37440a2c4d1929356fdf6fd642b72d158" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションが &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; を返す場合、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; の現在の値に対応する &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="5653f6b091b3b56dbab455fefe64b2589e61e727" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;, but retry in case of an interrupted operation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションが &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; を返した場合は &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; の現在の値に対応する &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; をスローしますが、操作が中断された場合は再試行します。</target>
        </trans-unit>
        <trans-unit id="34d7cc6341315d979ebf0a280e2812fcea684005" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションが &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; を返した場合、 &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; の現在の値に対応する &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="79cea3439c030b18b5417d5220cf8e7402498869" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns a result of &lt;code&gt;-1&lt;/code&gt;, but retries in case of an interrupted operation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションが &lt;code&gt;-1&lt;/code&gt; の結果を返した場合、 &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; の現在の値に対応する &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; をスローしますが、操作が中断された場合は再試行します。</target>
        </trans-unit>
        <trans-unit id="4caf9e3403704122998dcd2e56f9c103bccc209c" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns a result of &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションが &lt;code&gt;-1&lt;/code&gt; の結果を返す場合、 &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; の現在の値に対応する &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="036abf121e52aab2f60490c26b79ff2ead7c1e41" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the result value of the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action meets the given predicate.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションの結果値が指定された述語と一致する場合、 &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; の現在の値に対応する &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="64aa8ce5d4c7d3f7f49e076896c60b8c7ef43c89" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; の現在の値に対応する &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="6a07ee5048c29ff28ddf4e5f424d1fa111508ece" translate="yes" xml:space="preserve">
          <source>Throw an error when an illegal sequence is encountered</source>
          <target state="translated">不正なシーケンスに遭遇した場合にエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="4479756108b443a98b7354d085dbc835dc21aeb8" translate="yes" xml:space="preserve">
          <source>Throw an exception. Exceptions may be thrown from purely functional code, but may only be caught within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">例外をスローします。例外は純粋に機能的なコードからスローされますが、 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナド内でのみキャッチされます。</target>
        </trans-unit>
        <trans-unit id="fe9dd6f4bbcbd9abdc92b3911d6713b369a19e14" translate="yes" xml:space="preserve">
          <source>Throwing an exception in &lt;code&gt;STM&lt;/code&gt; aborts the transaction and propagates the exception. If the exception is caught via &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt;, only the changes enclosed by the catch are rolled back; changes made outside of &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; persist.</source>
          <target state="translated">&lt;code&gt;STM&lt;/code&gt; で例外をスローすると、トランザクションが中止され、例外が伝播します。 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; を介して例外がキャッチされた場合、catchで囲まれた変更のみがロールバックされます。 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; の外部で行われた変更は保持されます。</target>
        </trans-unit>
        <trans-unit id="2e15244ee40229604b0e667942ba71e6efbddfe9" translate="yes" xml:space="preserve">
          <source>Throwing an exception in &lt;code&gt;STM&lt;/code&gt; aborts the transaction and propagates the exception. If the exception is caught via &lt;code&gt;&lt;a href=&quot;ghc-conc#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt;, only the changes enclosed by the catch are rolled back; changes made outside of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; persist.</source>
          <target state="translated">&lt;code&gt;STM&lt;/code&gt; で例外をスローすると、トランザクションが中止され、例外が伝播します。 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; を介して例外がキャッチされた場合、catchで囲まれた変更のみがロールバックされます。 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; の外部で行われた変更は保持されます。</target>
        </trans-unit>
        <trans-unit id="62d516dc1db40b86d1546ce065ac2b133fff005a" translate="yes" xml:space="preserve">
          <source>Throwing an exception in &lt;code&gt;STM&lt;/code&gt; aborts the transaction and propagates the exception. If the exception is caught via &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt;, only the changes enclosed by the catch are rolled back; changes made outside of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; persist.</source>
          <target state="translated">&lt;code&gt;STM&lt;/code&gt; で例外をスローすると、トランザクションが中止され、例外が伝播します。 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; を介して例外がキャッチされた場合、catchで囲まれた変更のみがロールバックされます。 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; の外部で行われた変更は保持されます。</target>
        </trans-unit>
        <trans-unit id="3c57924c9d0ac14d868ac4b1686bc50ff51630e3" translate="yes" xml:space="preserve">
          <source>Throwing and catching I/O errors</source>
          <target state="translated">I/Oエラーのスローとキャッチ</target>
        </trans-unit>
        <trans-unit id="7506d1dc91f2739ca014aacfd180c12f7a3cf7ce" translate="yes" xml:space="preserve">
          <source>Throwing exceptions</source>
          <target state="translated">例外を投げる</target>
        </trans-unit>
        <trans-unit id="7f06faf78ca599a5c5c8ba7a35902fe72d473ba2" translate="yes" xml:space="preserve">
          <source>Thrown when the program attempts to call &lt;code&gt;atomically&lt;/code&gt;, from the &lt;code&gt;stm&lt;/code&gt; package, inside another call to &lt;code&gt;atomically&lt;/code&gt;.</source>
          <target state="translated">プログラムが &lt;code&gt;stm&lt;/code&gt; パッケージから &lt;code&gt;atomically&lt;/code&gt; 別の呼び出し内で &lt;code&gt;atomically&lt;/code&gt; に呼び出そうとするとスローされます。</target>
        </trans-unit>
        <trans-unit id="153488b4e16cb9e06414f6864aee37a111104fae" translate="yes" xml:space="preserve">
          <source>Thrown when the runtime system detects that the computation is guaranteed not to terminate. Note that there is no guarantee that the runtime system will notice whether any given computation is guaranteed to terminate or not.</source>
          <target state="translated">ランタイムシステムが計算が終了しないことが保証されていることを検出した場合にスローされます。ランタイムシステムが、任意の計算が終了することが保証されているかどうかに気づく保証はないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="e18cad06fc314dbe98850c48826dae1e000f1a31" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;ctermid(3)&lt;/code&gt; (use &lt;code&gt;#if HAVE_CTERMID&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">例外 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; プラットフォームが提供されない場合（「サポートされていない操作は」） &lt;code&gt;ctermid(3)&lt;/code&gt; （使用 &lt;code&gt;#if HAVE_CTERMID&lt;/code&gt; 可用性を検出するCPPガードを）。</target>
        </trans-unit>
        <trans-unit id="63e549a9e7a930bc1cd82834decb9a2bd163ce62" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;fdatasync(2)&lt;/code&gt; (use &lt;code&gt;#if HAVE_FDATASYNC&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">例外 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; プラットフォームが提供されない場合（「サポートされていない操作は」） &lt;code&gt;fdatasync(2)&lt;/code&gt; （使用 &lt;code&gt;#if HAVE_FDATASYNC&lt;/code&gt; 可用性を検出するCPPガードを）。</target>
        </trans-unit>
        <trans-unit id="b4fc88eb1e2da00b43f2c50a60cc44995e0823b9" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;fsync(2)&lt;/code&gt; (use &lt;code&gt;#if HAVE_FSYNC&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">例外 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; プラットフォームが提供されない場合（「サポートされていない操作は」） &lt;code&gt;fsync(2)&lt;/code&gt; （使用 &lt;code&gt;#if HAVE_FSYNC&lt;/code&gt; 可用性を検出するCPPガードを）。</target>
        </trans-unit>
        <trans-unit id="a9d629909206eee0dbcf9f3ef3c94be04cfef1d6" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;posix_fallocate(2)&lt;/code&gt;.</source>
          <target state="translated">例外 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; （「サポートされていない操作」）プラットフォームが提供されない場合 &lt;code&gt;posix_fallocate(2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6e500df7fdd7f0b1291a3902735fde41700da58" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;tcdrain(3)&lt;/code&gt; (use &lt;code&gt;#if HAVE_TCDRAIN&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">例外 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; プラットフォームが提供されない場合（「サポートされていない操作は」） &lt;code&gt;tcdrain(3)&lt;/code&gt; （使用 &lt;code&gt;#if HAVE_TCDRAIN&lt;/code&gt; 可用性を検出するCPPガードを）。</target>
        </trans-unit>
        <trans-unit id="9e328518c0ae7f5df305277a12db24a54f0d6efe" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;ctermid(3)&lt;/code&gt; (use &lt;code&gt;#if HAVE_CTERMID&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">例外 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; プラットフォームが提供されない場合（「サポートされていない操作は」） &lt;code&gt;ctermid(3)&lt;/code&gt; （使用 &lt;code&gt;#if HAVE_CTERMID&lt;/code&gt; 可用性を検出するCPPガードを）。</target>
        </trans-unit>
        <trans-unit id="c41ac56fe434c624b1c17bcefea186ed1bdc1b6f" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;fdatasync(2)&lt;/code&gt; (use &lt;code&gt;#if HAVE_FDATASYNC&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">例外 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; プラットフォームが提供されない場合（「サポートされていない操作は」） &lt;code&gt;fdatasync(2)&lt;/code&gt; （使用 &lt;code&gt;#if HAVE_FDATASYNC&lt;/code&gt; 可用性を検出するCPPガードを）。</target>
        </trans-unit>
        <trans-unit id="c4e26076fb50ee8c52870cfd73b0440602f666fd" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;fsync(2)&lt;/code&gt; (use &lt;code&gt;#if HAVE_FSYNC&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">例外 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; プラットフォームが提供されない場合（「サポートされていない操作は」） &lt;code&gt;fsync(2)&lt;/code&gt; （使用 &lt;code&gt;#if HAVE_FSYNC&lt;/code&gt; 可用性を検出するCPPガードを）。</target>
        </trans-unit>
        <trans-unit id="12e34fcbe929eb8dbb817a0cb66109a820af381c" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;posix_fallocate(2)&lt;/code&gt;.</source>
          <target state="translated">例外 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; （「サポートされていない操作」）プラットフォームが提供されない場合 &lt;code&gt;posix_fallocate(2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eec30f6587d00e8236ddbc556fd0ce8c29324a9f" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;tcdrain(3)&lt;/code&gt; (use &lt;code&gt;#if HAVE_TCDRAIN&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">例外 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; プラットフォームが提供されない場合（「サポートされていない操作は」） &lt;code&gt;tcdrain(3)&lt;/code&gt; （使用 &lt;code&gt;#if HAVE_TCDRAIN&lt;/code&gt; 可用性を検出するCPPガードを）。</target>
        </trans-unit>
        <trans-unit id="da37849b4252a8c8814bc0fdc57bbfa1e662b4c6" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;control-exception#v:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; when the channel is empty and no other thread holds a reference to the channel.</source>
          <target state="translated">スロー &lt;code&gt;&lt;a href=&quot;control-exception#v:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; は、チャネルが空であり、他のスレッドがチャネルへの参照を保持しない場合。</target>
        </trans-unit>
        <trans-unit id="26e7a0586580fb90b1858fbd0f15fd38c47f7010" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;control-exception#v:IOException&quot;&gt;IOException&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;name&lt;/code&gt; is the empty string or contains an equals sign.</source>
          <target state="translated">例外 &lt;code&gt;&lt;a href=&quot;control-exception#v:IOException&quot;&gt;IOException&lt;/a&gt;&lt;/code&gt; があれば &lt;code&gt;name&lt;/code&gt; 空の文字列であるか、等号が含まれています。</target>
        </trans-unit>
        <trans-unit id="88ad0dcfc452814fa2ec2a379a00e78d0cb0ada8" translate="yes" xml:space="preserve">
          <source>Throws a &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:SetupTermError&quot;&gt;SetupTermError&lt;/a&gt;&lt;/code&gt; if the terminfo database could not be read.</source>
          <target state="translated">terminfoデータベースを読み取れなかった場合は、 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:SetupTermError&quot;&gt;SetupTermError&lt;/a&gt;&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="76031ddf92450ba52c1e3945097079807a9065c2" translate="yes" xml:space="preserve">
          <source>Thursday</source>
          <target state="translated">Thursday</target>
        </trans-unit>
        <trans-unit id="cef8354a2187206dae84b0978cfa2cac783fc184" translate="yes" xml:space="preserve">
          <source>Thus &lt;code&gt;&lt;a href=&quot;data-list#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; contains at least as many elements as newlines in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">したがって、 &lt;code&gt;&lt;a href=&quot;data-list#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; は、少なくとも &lt;code&gt;s&lt;/code&gt; の改行と同じ数の要素が含まれます。</target>
        </trans-unit>
        <trans-unit id="29f4111a9574afc73ad4fb9aa2d80eb12106046f" translate="yes" xml:space="preserve">
          <source>Thus &lt;code&gt;&lt;a href=&quot;data-string#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; contains at least as many elements as newlines in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">したがって、 &lt;code&gt;&lt;a href=&quot;data-string#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; は、少なくとも &lt;code&gt;s&lt;/code&gt; の改行と同じ数の要素が含まれます。</target>
        </trans-unit>
        <trans-unit id="e20ffe6f7fbe373d959e03833b11abe8e7b589cd" translate="yes" xml:space="preserve">
          <source>Thus &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; contains at least as many elements as newlines in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">したがって、 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; は、少なくとも &lt;code&gt;s&lt;/code&gt; の改行と同じ数の要素が含まれます。</target>
        </trans-unit>
        <trans-unit id="0c7038c652bd8ef014d4a0872642e6726ba19bc5" translate="yes" xml:space="preserve">
          <source>Thus &lt;code&gt;&lt;a href=&quot;prelude#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; contains at least as many elements as newlines in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">したがって、 &lt;code&gt;&lt;a href=&quot;prelude#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; は、少なくとも &lt;code&gt;s&lt;/code&gt; の改行と同じ数の要素が含まれます。</target>
        </trans-unit>
        <trans-unit id="57e24cd4910ef566d3177761fb96a3a2e10793cb" translate="yes" xml:space="preserve">
          <source>Thus rule applies in datatype declarations, too. For example, if we have &lt;code&gt;data Proxy a = Proxy&lt;/code&gt; (and &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; is enabled), then &lt;code&gt;a&lt;/code&gt; will be assigned kind &lt;code&gt;k&lt;/code&gt;, where &lt;code&gt;k&lt;/code&gt; is a fresh kind variable. Because &lt;code&gt;k&lt;/code&gt; was not written by the user, it will be unavailable for type application in the type of the constructor &lt;code&gt;Proxy&lt;/code&gt;; only the &lt;code&gt;a&lt;/code&gt; will be available.</source>
          <target state="translated">したがって、ルールはデータ型宣言にも適用されます。たとえば、 &lt;code&gt;data Proxy a = Proxy&lt;/code&gt; （および&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;が有効になっている）がある場合、 &lt;code&gt;a&lt;/code&gt; には種類 &lt;code&gt;k&lt;/code&gt; が割り当てられます。ここで、 &lt;code&gt;k&lt;/code&gt; は新しい種類の変数です。 &lt;code&gt;k&lt;/code&gt; はユーザーが作成したものではないため、コンストラクタ &lt;code&gt;Proxy&lt;/code&gt; のタイプのタイプapplicationには使用できません。 &lt;code&gt;a&lt;/code&gt; のみが使用可能になります。</target>
        </trans-unit>
        <trans-unit id="fe1b4b67a9b45e5176c700a1accff9ef1d36429d" translate="yes" xml:space="preserve">
          <source>Thus, a common invocation would be:</source>
          <target state="translated">したがって、一般的な呼び出しは次のようになります。</target>
        </trans-unit>
        <trans-unit id="10617fc5bcf1b09fbc9f71f965511f582f11805a" translate="yes" xml:space="preserve">
          <source>Thus, if we call &lt;code&gt;putStrLnWithCallStack&lt;/code&gt; we will get a formatted call-stack alongside our string.</source>
          <target state="translated">したがって、 &lt;code&gt;putStrLnWithCallStack&lt;/code&gt; を呼び出すと、文字列とともにフォーマットされた呼び出しスタックが取得されます。</target>
        </trans-unit>
        <trans-unit id="e5c7ac32fac38f64112fb32061b44ba48e48877f" translate="yes" xml:space="preserve">
          <source>Thus, the chief benefit of kind polymorphism is that we can now infer these most general kinds and use &lt;code&gt;App&lt;/code&gt; at a variety of kinds:</source>
          <target state="translated">したがって、種類ポリモーフィズムの主な利点は、これらの最も一般的な種類を推測し、さまざまな種類で &lt;code&gt;App&lt;/code&gt; を使用できることです。</target>
        </trans-unit>
        <trans-unit id="78f6be9afb4189596518c56574c13c30720db0d1" translate="yes" xml:space="preserve">
          <source>Thus, the instance triggers only when the implicit parameter to &lt;code&gt;UnEx&lt;/code&gt; matches the implicit parameter to &lt;code&gt;MkEx&lt;/code&gt;. Because &lt;code&gt;k&lt;/code&gt; is actually a parameter to &lt;code&gt;UnEx&lt;/code&gt;, the kind is not escaping the existential, and the above code is valid.</source>
          <target state="translated">したがって、インスタンスは、 &lt;code&gt;UnEx&lt;/code&gt; への暗黙的なパラメーターがMkExへの暗黙的なパラメーターと一致する場合にのみトリガーされ &lt;code&gt;MkEx&lt;/code&gt; 。ので &lt;code&gt;k&lt;/code&gt; 、実際のパラメータである &lt;code&gt;UnEx&lt;/code&gt; 、種類は実存をエスケープされていない、と上記のコードは有効です。</target>
        </trans-unit>
        <trans-unit id="96728018a51a18d78a6c7c7a21bb29d195c725bd" translate="yes" xml:space="preserve">
          <source>TickyFlags</source>
          <target state="translated">TickyFlags</target>
        </trans-unit>
        <trans-unit id="e426b9f760c1a38c2bacbad2f64c53212cc3ffbf" translate="yes" xml:space="preserve">
          <source>Time as measured by the Earth.</source>
          <target state="translated">地球が計測した時間。</target>
        </trans-unit>
        <trans-unit id="de35e180cbf98fcc51757a7d0eeb7aa8703d0daf" translate="yes" xml:space="preserve">
          <source>Time locale.</source>
          <target state="translated">時間ロケール。</target>
        </trans-unit>
        <trans-unit id="6a48c0a81754a0e5cd402f2b5b7b65e0802b3ae0" translate="yes" xml:space="preserve">
          <source>Time of day</source>
          <target state="translated">時間帯</target>
        </trans-unit>
        <trans-unit id="311ad74f1246fe76fb5e13a02593b243dfa01e4b" translate="yes" xml:space="preserve">
          <source>Time of day as represented in hour, minute and second (with picoseconds), typically used to express local time of day.</source>
          <target state="translated">時、分、秒(ピコ秒を含む)で表される一日の時間で、一般的に一日のローカル時間を表現するために使用されます。</target>
        </trans-unit>
        <trans-unit id="674eca31894fe11111cc9e95a912f546b20cfa4c" translate="yes" xml:space="preserve">
          <source>Time of last access in sub-second resolution.</source>
          <target state="translated">最後にアクセスした時刻をサブ秒単位で表示します。</target>
        </trans-unit>
        <trans-unit id="bf5b7ea4cfe40f929342452c57b6445e307ff98f" translate="yes" xml:space="preserve">
          <source>Time of last access.</source>
          <target state="translated">最後にアクセスした時間。</target>
        </trans-unit>
        <trans-unit id="dd0e25f4fa1eea55d5c7dc261f690719e80e92b5" translate="yes" xml:space="preserve">
          <source>Time of last modification in sub-second resolution.</source>
          <target state="translated">サブ秒単位の分解能での最終修正時刻。</target>
        </trans-unit>
        <trans-unit id="d3ed1832d868c8126249a2fb407fc69507dfb189" translate="yes" xml:space="preserve">
          <source>Time of last modification.</source>
          <target state="translated">最終更新時刻。</target>
        </trans-unit>
        <trans-unit id="8a1b24f9546d48f74a1fc1f2be79cc16e32ce4b8" translate="yes" xml:space="preserve">
          <source>Time of last status change (i.e. owner, group, link count, mode, etc.) in sub-second resolution.</source>
          <target state="translated">最後にステータスが変更された時刻(所有者、グループ、リンク数、モードなど)を秒単位で表示します。</target>
        </trans-unit>
        <trans-unit id="de40af977c44da7ce142082cfbcc26c6ffe0cb65" translate="yes" xml:space="preserve">
          <source>Time of last status change (i.e. owner, group, link count, mode, etc.).</source>
          <target state="translated">最後にステータスが変更された時刻(所有者、グループ、リンク数、モードなど)。</target>
        </trans-unit>
        <trans-unit id="37cc2e4553f3b7c4572077f6ce8dcd7260d2fd48" translate="yes" xml:space="preserve">
          <source>Time values from the RTS, using a fixed resolution of nanoseconds.</source>
          <target state="translated">ナノ秒の固定分解能を使用したRTSの時間値。</target>
        </trans-unit>
        <trans-unit id="fa9aac4028931969e4e43d5926f21c1c02b03737" translate="yes" xml:space="preserve">
          <source>Time zones</source>
          <target state="translated">タイムゾーン</target>
        </trans-unit>
        <trans-unit id="3694fd8d8502573c050c12c21dfc64202808f47a" translate="yes" xml:space="preserve">
          <source>TimeExpired</source>
          <target state="translated">TimeExpired</target>
        </trans-unit>
        <trans-unit id="54ca8d2ae2173c38ac3276efe44835c04bf7b464" translate="yes" xml:space="preserve">
          <source>TimeLocale</source>
          <target state="translated">TimeLocale</target>
        </trans-unit>
        <trans-unit id="3a383c209c07d7ddd4a20a832e5e3183c6735122" translate="yes" xml:space="preserve">
          <source>TimeOfDay</source>
          <target state="translated">TimeOfDay</target>
        </trans-unit>
        <trans-unit id="a4208dd784207f8d84ef4fa31bd30bdd2b432c1d" translate="yes" xml:space="preserve">
          <source>TimeZone</source>
          <target state="translated">TimeZone</target>
        </trans-unit>
        <trans-unit id="30a4ddc2d1e47c72524d2ae1195d49334429ec48" translate="yes" xml:space="preserve">
          <source>TimeoutCallback</source>
          <target state="translated">TimeoutCallback</target>
        </trans-unit>
        <trans-unit id="03a9149686779469a820b3f21f5f3096edd2e773" translate="yes" xml:space="preserve">
          <source>TimeoutKey</source>
          <target state="translated">TimeoutKey</target>
        </trans-unit>
        <trans-unit id="554c6dbe0800fb90ce862ee9b17611f1be40e742" translate="yes" xml:space="preserve">
          <source>TimerManager</source>
          <target state="translated">TimerManager</target>
        </trans-unit>
        <trans-unit id="c04ed1238a14de2b02d7fd14a7e9605bb1b10b96" translate="yes" xml:space="preserve">
          <source>Timestamps</source>
          <target state="translated">Timestamps</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="e0f0bc7f2e5196ca0e12562d2fea3c45abb35a55" translate="yes" xml:space="preserve">
          <source>TitlecaseLetter</source>
          <target state="translated">TitlecaseLetter</target>
        </trans-unit>
        <trans-unit id="2234a4a2c47c8ff0b64637496c3e6c3bfefcacba" translate="yes" xml:space="preserve">
          <source>Tix</source>
          <target state="translated">Tix</target>
        </trans-unit>
        <trans-unit id="a74eb4584cb5c18ee809ed00eb188fdec5bb579c" translate="yes" xml:space="preserve">
          <source>TixModule</source>
          <target state="translated">TixModule</target>
        </trans-unit>
        <trans-unit id="fe0563e640d1279bce1fac48bf8a1b5e02bcb7ab" translate="yes" xml:space="preserve">
          <source>To a foreign library, the bound thread will look exactly like an ordinary operating system thread created using OS functions like &lt;code&gt;pthread_create&lt;/code&gt; or &lt;code&gt;CreateThread&lt;/code&gt;.</source>
          <target state="translated">外部ライブラリにとって、バインドされたスレッドは、 &lt;code&gt;pthread_create&lt;/code&gt; や &lt;code&gt;CreateThread&lt;/code&gt; などのOS関数を使用して作成された通常のオペレーティングシステムスレッドとまったく同じように見えます。</target>
        </trans-unit>
        <trans-unit id="ff80debaf5b64e3919c264f8e4e883f22ace9ad9" translate="yes" xml:space="preserve">
          <source>To abandon the current evaluation, use &lt;a href=&quot;#ghci-cmd-:abandon&quot;&gt;&lt;code&gt;:abandon&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">現在の評価を中止するには、&lt;a href=&quot;#ghci-cmd-:abandon&quot;&gt; &lt;code&gt;:abandon&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="d87be1eb54b07a48c8e89e1267bd4da7830b639e" translate="yes" xml:space="preserve">
          <source>To accumulate a value without using it on the way, see &lt;a href=&quot;control-monad-trans-writer&quot;&gt;Control.Monad.Trans.Writer&lt;/a&gt;.</source>
          <target state="translated">途中で使用せずに値を累積するには、&lt;a href=&quot;control-monad-trans-writer&quot;&gt;Control.Monad.Trans.Writerを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3e5f8467c41adb6b14b429081219eab2c60a0901" translate="yes" xml:space="preserve">
          <source>To achieve these properties, in the safe language dialect we disable completely the following features:</source>
          <target state="translated">これらの特性を達成するために、安全な言語の方言では以下の機能を完全に無効にしています。</target>
        </trans-unit>
        <trans-unit id="2aa92551218d14a1f44f24fb7177ce7a2bf713bc" translate="yes" xml:space="preserve">
          <source>To add modules to the scope, use ordinary Haskell &lt;code&gt;import&lt;/code&gt; syntax:</source>
          <target state="translated">スコープにモジュールを追加するには、通常のHaskell &lt;code&gt;import&lt;/code&gt; 構文を使用します。</target>
        </trans-unit>
        <trans-unit id="e2f3886d316e1e619156706746a8dfbb48e79115" translate="yes" xml:space="preserve">
          <source>To alleviate this issue, GHCi commands can be split over multiple lines, by wrapping them in &lt;code&gt;:{&lt;/code&gt; and &lt;code&gt;:}&lt;/code&gt; (each on a single line of its own):</source>
          <target state="translated">この問題を軽減するために、GHCiコマンドを &lt;code&gt;:{&lt;/code&gt; および &lt;code&gt;:}&lt;/code&gt; でラップすることにより、複数行に分割できます（それぞれ1行に1行ずつ）：</target>
        </trans-unit>
        <trans-unit id="de30b4286a2929bfdff88d5ee52a322ecb634497" translate="yes" xml:space="preserve">
          <source>To allow for such an instance, we would have to define &lt;code&gt;(:~~:)&lt;/code&gt; as follows:</source>
          <target state="translated">このようなインスタンスを許可するには、次のように &lt;code&gt;(:~~:)&lt;/code&gt; を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="14c677f99c3ebfb083d5ba45347b3df00c07e009" translate="yes" xml:space="preserve">
          <source>To also set the directory in which to run &lt;code&gt;ls&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ls&lt;/code&gt; を実行するディレクトリも設定するには：</target>
        </trans-unit>
        <trans-unit id="4ef0b5766dccbebaac045d8e4e6bded46db835a3" translate="yes" xml:space="preserve">
          <source>To always compile everything to object code and never use the interpreter, use the &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;#ghci-obj&quot;&gt;Compiling to object code inside GHCi&lt;/a&gt;).</source>
          <target state="translated">すべてを常にオブジェクトコードにコンパイルし、インタープリターを使用しないようにするには、&lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; &lt;/a&gt;オプションを使用します（&lt;a href=&quot;#ghci-obj&quot;&gt;GHCi内のオブジェクトコードへのコンパイルを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="5df8df6d3cdb1b8cf45eb7ff8b8e9438a9330317" translate="yes" xml:space="preserve">
          <source>To avoid duplication between kinds and types, they are defined to be the same. Naturally, you would never have a type be &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:StarT&quot;&gt;StarT&lt;/a&gt;&lt;/code&gt; and you would never have a kind be &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:SigT&quot;&gt;SigT&lt;/a&gt;&lt;/code&gt;, but many of the other constructors are shared. Note that the kind &lt;code&gt;Bool&lt;/code&gt; is denoted with &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ConT&quot;&gt;ConT&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PromotedT&quot;&gt;PromotedT&lt;/a&gt;&lt;/code&gt;. Similarly, tuple kinds are made with &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:TupleT&quot;&gt;TupleT&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PromotedTupleT&quot;&gt;PromotedTupleT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">種類と型の間の重複を避けるために、それらは同じであると定義されています。当然、 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:StarT&quot;&gt;StarT&lt;/a&gt;&lt;/code&gt; の型や &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:SigT&quot;&gt;SigT&lt;/a&gt;&lt;/code&gt; の種類はありませんが、他のコンストラクタの多くは共有されています。一種ことに注意してください &lt;code&gt;Bool&lt;/code&gt; で示され &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ConT&quot;&gt;ConT&lt;/a&gt;&lt;/code&gt; 、ない &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PromotedT&quot;&gt;PromotedT&lt;/a&gt;&lt;/code&gt; 。同様に、タプル種類で作られて &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:TupleT&quot;&gt;TupleT&lt;/a&gt;&lt;/code&gt; 、ない &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PromotedTupleT&quot;&gt;PromotedTupleT&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bbefb7d7331de5a028c9b6fdc70e6d980c4f650" translate="yes" xml:space="preserve">
          <source>To avoid duplication between kinds and types, they are defined to be the same. Naturally, you would never have a type be &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:StarT&quot;&gt;StarT&lt;/a&gt;&lt;/code&gt; and you would never have a kind be &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:SigT&quot;&gt;SigT&lt;/a&gt;&lt;/code&gt;, but many of the other constructors are shared. Note that the kind &lt;code&gt;Bool&lt;/code&gt; is denoted with &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ConT&quot;&gt;ConT&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PromotedT&quot;&gt;PromotedT&lt;/a&gt;&lt;/code&gt;. Similarly, tuple kinds are made with &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:TupleT&quot;&gt;TupleT&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PromotedTupleT&quot;&gt;PromotedTupleT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">種類と型の間の重複を避けるために、それらは同じであると定義されています。当然、 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:StarT&quot;&gt;StarT&lt;/a&gt;&lt;/code&gt; の型や &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:SigT&quot;&gt;SigT&lt;/a&gt;&lt;/code&gt; の種類はありませんが、他のコンストラクタの多くは共有されています。一種ことに注意してください &lt;code&gt;Bool&lt;/code&gt; で示され &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ConT&quot;&gt;ConT&lt;/a&gt;&lt;/code&gt; 、ない &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PromotedT&quot;&gt;PromotedT&lt;/a&gt;&lt;/code&gt; 。同様に、タプル種類で作られて &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:TupleT&quot;&gt;TupleT&lt;/a&gt;&lt;/code&gt; 、ない &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PromotedTupleT&quot;&gt;PromotedTupleT&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6771efdf3a686f294db18bd2d14bac4e3dba651" translate="yes" xml:space="preserve">
          <source>To avoid generating an interface at all, you could use this option to redirect the interface into the bit bucket: &lt;code&gt;-ohi /dev/null&lt;/code&gt;, for example.</source>
          <target state="translated">インターフェイスをまったく生成しないようにするには、このオプションを使用して、インターフェイスをビットバケットにリダイレクトできます。たとえば、 &lt;code&gt;-ohi /dev/null&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7aaccb0bd8d229ee1d19d9e75f8795d4cf2370af" translate="yes" xml:space="preserve">
          <source>To avoid subtle coding errors, hand written marshalling code should preferably use &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; rather than combinations of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt;. However, the latter routines are occasionally preferred in tool generated marshalling code.</source>
          <target state="translated">微妙なコーディングエラーを回避するために、手書きのマーシャリングコードでは、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; の組み合わせではなく、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; を使用することをお勧めします。ただし、ツールで生成されたマーシャリングコードでは、後者のルーチンが好まれる場合があります。</target>
        </trans-unit>
        <trans-unit id="fa34733b5e19e7e6a87e5c91b392ff0b0780aa0b" translate="yes" xml:space="preserve">
          <source>To avoid subtle coding errors, hand written marshalling code should preferably use &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; rather than combinations of &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt;. However, the latter routines are occasionally preferred in tool generated marshalling code.</source>
          <target state="translated">微妙なコーディングエラーを回避するために、手書きのマーシャリングコードでは、 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; の組み合わせではなく、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; を使用することをお勧めします。ただし、ツールで生成されたマーシャリングコードでは、後者のルーチンが好まれる場合があります。</target>
        </trans-unit>
        <trans-unit id="b35e7282d157dcf47660cd59431c4a8fca882cba" translate="yes" xml:space="preserve">
          <source>To avoid this problem, use &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef-39-&quot;&gt;modifyIORef'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">この問題を回避するには、代わりに &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef-39-&quot;&gt;modifyIORef'&lt;/a&gt;&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="93dbcc0e48dafb4a864c6c8fc82578cf9d42f26f" translate="yes" xml:space="preserve">
          <source>To avoid this problem, use &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef-39-&quot;&gt;modifySTRef'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">この問題を回避するには、代わりに &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef-39-&quot;&gt;modifySTRef'&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="68c0704d5dd80ea4a49e31c8c21b3410ffa34f67" translate="yes" xml:space="preserve">
          <source>To avoid undefined behaviour, the original &lt;code&gt;MutableByteArray#&lt;/code&gt; shall not be accessed anymore after a &lt;code&gt;resizeMutableByteArray#&lt;/code&gt; has been performed. Moreover, no reference to the old one should be kept in order to allow garbage collection of the original &lt;code&gt;MutableByteArray#&lt;/code&gt; in case a new &lt;code&gt;MutableByteArray#&lt;/code&gt; had to be allocated.</source>
          <target state="translated">未定義の動作を回避するために、 &lt;code&gt;resizeMutableByteArray#&lt;/code&gt; が実行された後は、元の &lt;code&gt;MutableByteArray#&lt;/code&gt; にアクセスできなくなります。さらに、新しい &lt;code&gt;MutableByteArray#&lt;/code&gt; を割り当てる必要がある場合に備えて、元の &lt;code&gt;MutableByteArray#&lt;/code&gt; のガベージコレクションを可能にするために、古いものへの参照を保持してはなりません。</target>
        </trans-unit>
        <trans-unit id="d1d67bfc1538ab33d21305009ebcc630714c1858" translate="yes" xml:space="preserve">
          <source>To be precise, if the class being derived is of the form</source>
          <target state="translated">正確には、派生されるクラスが</target>
        </trans-unit>
        <trans-unit id="c0d9f8d6315eb7cbdcbf50a9f874b3aee61aa5d5" translate="yes" xml:space="preserve">
          <source>To be precise, the annotation &lt;code&gt;{-# ANN x e #-}&lt;/code&gt; is well staged if and only if &lt;code&gt;$(e)&lt;/code&gt; would be (disregarding the usual type restrictions of the splice syntax, and the usual restriction on splicing inside a splice - &lt;code&gt;$([|1|])&lt;/code&gt; is fine as an annotation, albeit redundant).</source>
          <target state="translated">正確には、注釈 &lt;code&gt;{-# ANN x e #-}&lt;/code&gt; は、 &lt;code&gt;$(e)&lt;/code&gt; がそうである場合にのみ適切にステージングされます（スプライス構文の通常のタイプ制限、およびスプライス内のスプライシングに関する通常の制限- &lt;code&gt;$([|1|])&lt;/code&gt; は注釈としては問題ありませんが、冗長です）。</target>
        </trans-unit>
        <trans-unit id="28876308b2232e888282a46a9f2647185f20da23" translate="yes" xml:space="preserve">
          <source>To build Haskell modules that export a C API into a shared library use the &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; flags:</source>
          <target state="translated">C APIを共有ライブラリにエクスポートするHaskellモジュールをビルドするには、&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt; &lt;code&gt;-fPIC&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;phases#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt;フラグを使用します。</target>
        </trans-unit>
        <trans-unit id="99edfbf2248bb2a627dfdcc360ffdb881b08cb4d" translate="yes" xml:space="preserve">
          <source>To build a simple program and have it use shared libraries for the runtime system and the base libraries use the &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; flag:</source>
          <target state="translated">単純なプログラムをビルドして、ランタイムシステムの共有ライブラリとベースライブラリを使用させるには、&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;フラグを使用します。</target>
        </trans-unit>
        <trans-unit id="007ba52a2d8fb965e0b5df4e486442e39607c309" translate="yes" xml:space="preserve">
          <source>To bundle a pattern synonym with a type constructor, we list the pattern synonym in the export list of a module which exports the type constructor. For example, to bundle &lt;code&gt;Zero&lt;/code&gt; with &lt;code&gt;MyNum&lt;/code&gt; we could write the following:</source>
          <target state="translated">パターンシノニムを型コンストラクターにバンドルするには、型コンストラクターをエクスポートするモジュールのエクスポートリストにパターンシノニムをリストします。たとえば、 &lt;code&gt;Zero&lt;/code&gt; を &lt;code&gt;MyNum&lt;/code&gt; にバンドルするには、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="b5aae458adadd6ea36810e5833a7811c73bd6831" translate="yes" xml:space="preserve">
          <source>To check whether your &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; setting is doing the right thing, &lt;code&gt;ghc-pkg list&lt;/code&gt; will list all the databases in use, in the reverse order they are searched.</source>
          <target state="translated">&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; 設定が正しいことを確認するために、 &lt;code&gt;ghc-pkg list&lt;/code&gt; は使用中のすべてのデータベースを、検索された順序とは逆の順序で一覧表示します。</target>
        </trans-unit>
        <trans-unit id="d99b230674f283901189e80464c11bff12827985" translate="yes" xml:space="preserve">
          <source>To compile a module which is to be part of a new package, use the &lt;code&gt;-package-name&lt;/code&gt; (to identify the name of the package) and &lt;code&gt;-library-name&lt;/code&gt; (to identify the version and the version hashes of its identities.) options (&lt;a href=&quot;#using-packages&quot;&gt;Using Packages&lt;/a&gt;). Failure to use these options when compiling a package will probably result in disaster, but you will only discover later when you attempt to import modules from the package. At this point GHC will complain that the package name it was expecting the module to come from is not the same as the package name stored in the &lt;code&gt;.hi&lt;/code&gt; file.</source>
          <target state="translated">新しいパッケージの一部となるモジュールをコンパイルするには、 &lt;code&gt;-package-name&lt;/code&gt; （パッケージの名前を識別する）と &lt;code&gt;-library-name&lt;/code&gt; （バージョンとそのIDのバージョンハッシュを識別する）オプションを使用します（&lt;a href=&quot;#using-packages&quot;&gt;パッケージの使用&lt;/a&gt;）。パッケージのコンパイル時にこれらのオプションを使用しないと、おそらく災害が発生しますが、後でパッケージからモジュールをインポートしようとしたときに初めて発見できます。この時点で、GHCは、モジュールの &lt;code&gt;.hi&lt;/code&gt; として期待されていたパッケージ名が、.hiファイルに格納されているパッケージ名と同じではないと不平を言うでしょう。</target>
        </trans-unit>
        <trans-unit id="12fd6ddf28c5285fa1983ff47d370bb4e33b05da" translate="yes" xml:space="preserve">
          <source>To compile the program, use GHC like this:</source>
          <target state="translated">プログラムをコンパイルするには、このようにGHCを使います。</target>
        </trans-unit>
        <trans-unit id="485c5e401e6a134f4abe73897df6824e3409a20e" translate="yes" xml:space="preserve">
          <source>To compile these three files, issue the following commands:</source>
          <target state="translated">これら3つのファイルをコンパイルするには、以下のコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="8a91e9bb879d47c785fc61c253926f7398d2eae9" translate="yes" xml:space="preserve">
          <source>To control the choice of instance, it is possible to specify the overlap behavior for individual instances with a pragma, written immediately after the &lt;code&gt;instance&lt;/code&gt; keyword. The pragma may be one of: &lt;code&gt;{-# OVERLAPPING #-}&lt;/code&gt;, &lt;code&gt;{-# OVERLAPPABLE #-}&lt;/code&gt;, &lt;code&gt;{-# OVERLAPS #-}&lt;/code&gt;, or &lt;code&gt;{-# INCOHERENT #-}&lt;/code&gt;.</source>
          <target state="translated">インスタンスの選択を制御するには、 &lt;code&gt;instance&lt;/code&gt; キーワードの直後に記述されたプラグマを使用して、個々のインスタンスのオーバーラップ動作を指定できます。プラグマは、 &lt;code&gt;{-# OVERLAPPING #-}&lt;/code&gt; 、 &lt;code&gt;{-# OVERLAPPABLE #-}&lt;/code&gt; 、 &lt;code&gt;{-# OVERLAPS #-}&lt;/code&gt; 、または &lt;code&gt;{-# INCOHERENT #-}&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0dc0d1e2f710041d917fa9128128d16f4e0b579c" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;data-time#v:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt;, use the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;data-time#v:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; に変換するには、以下を使用します。</target>
        </trans-unit>
        <trans-unit id="1c0964746ae7b2a2f00992a848001548495aecef" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; values to corresponding Haskell functions, one can define a &lt;em&gt;dynamic&lt;/em&gt; stub for the specific foreign type, e.g.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 値を対応するHaskell関数に変換するには、特定の外部型の&lt;em&gt;動的&lt;/em&gt;スタブを定義できます。</target>
        </trans-unit>
        <trans-unit id="5d067decf6925ff18738730cccec299d546abf35" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; values to corresponding Haskell functions, one can define a &lt;em&gt;dynamic&lt;/em&gt; stub for the specific foreign type, e.g.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 値を対応するHaskell関数に変換するには、特定の外部型の&lt;em&gt;動的&lt;/em&gt;スタブを定義できます。</target>
        </trans-unit>
        <trans-unit id="fea7f792e37393718cca4a9b6921cb08aba10fa5" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; values to corresponding Haskell functions, one can define a &lt;em&gt;dynamic&lt;/em&gt; stub for the specific foreign type, e.g.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 値を対応するHaskell関数に変換するには、特定の外部型の&lt;em&gt;動的&lt;/em&gt;スタブを定義できます。</target>
        </trans-unit>
        <trans-unit id="2acaa5dea000cc74154c0f402c3febbfb83f1a58" translate="yes" xml:space="preserve">
          <source>To convert a &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to or from the corresponding &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; value defined by Unicode, use &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class respectively (or equivalently &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">変換する &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 対応するか、から &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 、Unicodeで定義された値を使用 &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; をより &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; それぞれクラス（または同等に &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="786657e4c88a725db3968f98b13dce85d65db23b" translate="yes" xml:space="preserve">
          <source>To convert a &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to or from the corresponding &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; value defined by Unicode, use &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class respectively (or equivalently &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">変換する &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 対応するか、から &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 、Unicodeで定義された値を使用 &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; をより &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; それぞれクラス（または同等に &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d7130a3be670709f03cd81a58cb2b61282e0d6dd" translate="yes" xml:space="preserve">
          <source>To convert a &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to or from the corresponding &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; value defined by Unicode, use &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class respectively (or equivalently &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">変換する &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 対応するか、から &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 、Unicodeで定義された値を使用 &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; をより &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; それぞれクラス（または同等に &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="13a465a9773b015ffc884872ada910d6f797abb7" translate="yes" xml:space="preserve">
          <source>To convert from a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-types#v:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;System.Posix.EpochTime&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:realToFrac&quot;&gt;realToFrac&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-types#v:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;System.Posix.EpochTime&lt;/code&gt; から変換するには、realToFracを使用し &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:realToFrac&quot;&gt;realToFrac&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e3196791a7a1592e7daa80285f0558ede2e0d6d" translate="yes" xml:space="preserve">
          <source>To convert from a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#v:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;System.Posix.EpochTime&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:realToFrac&quot;&gt;realToFrac&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#v:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;System.Posix.EpochTime&lt;/code&gt; から変換するには、realToFracを使用し &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:realToFrac&quot;&gt;realToFrac&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1659f84a77c9a2443a59423cc658f61a338f3abe" translate="yes" xml:space="preserve">
          <source>To create a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; with no encoding at all, use &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt;. To stop further encoding or decoding on an existing &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">エンコーディングなしの &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; を作成するには、 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; を使用します。既存の &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; でのエンコードまたはデコードを停止するには、 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="f153e244215130d9c4edb53cdcbba15630d42840" translate="yes" xml:space="preserve">
          <source>To create a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; with no encoding at all, use &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt;. To stop further encoding or decoding on an existing &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">エンコーディングなしの &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; を作成するには、 &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; を使用します。既存の &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; でのエンコードまたはデコードを停止するには、 &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="1171deb859f0f29f6aacadc46ea52378fb28f5f8" translate="yes" xml:space="preserve">
          <source>To create a pipe from which to read the output of &lt;code&gt;ls&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ls&lt;/code&gt; の出力を読み取るパイプを作成するには：</target>
        </trans-unit>
        <trans-unit id="96af4537bfd12fadb83763899a123cc096a36017" translate="yes" xml:space="preserve">
          <source>To define the &lt;code&gt;item&lt;/code&gt; parser, we need to lift the &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; operations through the &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; transformer.</source>
          <target state="translated">定義するには &lt;code&gt;item&lt;/code&gt; パーサを、我々は持ち上げる必要 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; の通過操作を &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; の変圧器。</target>
        </trans-unit>
        <trans-unit id="61b1e6de56b01e5140d8cba3ed36c3acb9b257dc" translate="yes" xml:space="preserve">
          <source>To delete a breakpoint, use the &lt;a href=&quot;#ghci-cmd-:delete&quot;&gt;&lt;code&gt;:delete&lt;/code&gt;&lt;/a&gt; command with the number given in the output from &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt;&lt;code&gt;:show breaks&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">ブレークポイントを削除するには、&lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt; &lt;code&gt;:show breaks&lt;/code&gt; &lt;/a&gt;からの出力で指定された番号を指定して&lt;a href=&quot;#ghci-cmd-:delete&quot;&gt; &lt;code&gt;:delete&lt;/code&gt; &lt;/a&gt;コマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="ea8e294886bade8bd7cc5b83aa9ec115d1403bbc" translate="yes" xml:space="preserve">
          <source>To delete all breakpoints at once, use &lt;code&gt;:delete *&lt;/code&gt;.</source>
          <target state="translated">すべてのブレークポイントを一度に &lt;code&gt;:delete *&lt;/code&gt; は、：delete *を使用します。</target>
        </trans-unit>
        <trans-unit id="20c69ea8d7a8119ee63218b8c507949aacadde61" translate="yes" xml:space="preserve">
          <source>To derive &lt;code&gt;Eq&lt;/code&gt; in the standard way we would need to have equality between the single component of two &lt;code&gt;MkT&lt;/code&gt; constructors:</source>
          <target state="translated">&lt;code&gt;Eq&lt;/code&gt; を標準的な方法で導出するには、2つの &lt;code&gt;MkT&lt;/code&gt; コンストラクターの単一のコンポーネントを同等にする必要があります。</target>
        </trans-unit>
        <trans-unit id="7f0219713c4b957a1c6e5e311515abfddd97e7be" translate="yes" xml:space="preserve">
          <source>To disable one or several defined breakpoint, use the &lt;a href=&quot;#ghci-cmd-:disable&quot;&gt;&lt;code&gt;:disable&lt;/code&gt;&lt;/a&gt; command with one or several blank separated numbers given in the output from &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt;&lt;code&gt;:show breaks&lt;/code&gt;&lt;/a&gt;:. To disable all breakpoints at once, use &lt;code&gt;:disable *&lt;/code&gt;.</source>
          <target state="translated">1つまたは複数の定義済みブレークポイントを無効にするには、&lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt; &lt;code&gt;:show breaks&lt;/code&gt; &lt;/a&gt;：からの出力で指定された1つまたは複数の空白の区切り番号を指定して&lt;a href=&quot;#ghci-cmd-:disable&quot;&gt; &lt;code&gt;:disable&lt;/code&gt; &lt;/a&gt;コマンドを使用します。すべてのブレークポイントを一度に &lt;code&gt;:disable *&lt;/code&gt; は、：disable *を使用します。</target>
        </trans-unit>
        <trans-unit id="9be5e62141d987ac491830af48130b4bb8a0121e" translate="yes" xml:space="preserve">
          <source>To examine one of the steps in the history, use &lt;a href=&quot;#ghci-cmd-:back&quot;&gt;&lt;code&gt;:back&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">履歴のステップの1つを調べるには、&lt;a href=&quot;#ghci-cmd-:back&quot;&gt; &lt;code&gt;:back&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="66eef0e4ec6c04a45dd59938c23022bba82ff967" translate="yes" xml:space="preserve">
          <source>To export them on their own, in an export or import specification, you must prefix pattern names with the &lt;code&gt;pattern&lt;/code&gt; keyword, e.g.:</source>
          <target state="translated">それらを独自にエクスポートするには、エクスポートまたはインポート仕様で、パターン名の前に &lt;code&gt;pattern&lt;/code&gt; キーワードを付ける必要があります。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="059e3de99f2d80caf2d89e7201f6c7c557017928" translate="yes" xml:space="preserve">
          <source>To figure out what exactly they do, the least bad way is to grep the rts/ directory in the ghc code for macros like &lt;code&gt;DEBUG(scheduler&lt;/code&gt; or &lt;code&gt;DEBUG_scheduler&lt;/code&gt;.</source>
          <target state="translated">それらが正確に何をするかを理解するために、最も悪い方法は、 &lt;code&gt;DEBUG(scheduler&lt;/code&gt; または &lt;code&gt;DEBUG_scheduler&lt;/code&gt; )のようなマクロのghcコードでrts /ディレクトリをgrepすることです。</target>
        </trans-unit>
        <trans-unit id="373832b60bccf6816963a2a722042fdc637fe0c9" translate="yes" xml:space="preserve">
          <source>To figure out which part of the compiler is badly behaved, the &lt;code&gt;-v2&lt;/code&gt; option is your friend.</source>
          <target state="translated">コンパイラーのどの部分が &lt;code&gt;-v2&lt;/code&gt; 動作しないかを調べるには、-v2オプションが便利です。</target>
        </trans-unit>
        <trans-unit id="617e8f413888e2a59390516c4594fefa6467d4c8" translate="yes" xml:space="preserve">
          <source>To fix the problem, you need to recompile the broken packages against the new dependencies. The easiest way to do this is to use &lt;code&gt;cabal-install&lt;/code&gt;, or download the packages from &lt;a href=&quot;http://hackage.haskell.org/packages/hackage.html&quot;&gt;HackageDB&lt;/a&gt; and build and install them as normal.</source>
          <target state="translated">問題を解決するには、壊れたパッケージを新しい依存関係に対して再コンパイルする必要があります。これを行う最も簡単な方法は、 &lt;code&gt;cabal-install&lt;/code&gt; を使用するか、&lt;a href=&quot;http://hackage.haskell.org/packages/hackage.html&quot;&gt;HackageDB&lt;/a&gt;からパッケージをダウンロードして、通常どおりビルドしてインストールすることです。</target>
        </trans-unit>
        <trans-unit id="d1fadbae3a14577a0f008fefc32f335b95527ef3" translate="yes" xml:space="preserve">
          <source>To further explain this example, the right-hand side of the default type signature for &lt;code&gt;bar&lt;/code&gt; must be something that is alpha-equivalent to &lt;code&gt;forall b. a -&amp;gt; b -&amp;gt; b&lt;/code&gt; (where &lt;code&gt;a&lt;/code&gt; is bound by the class itself, and is thus free in the methods&amp;rsquo; type signatures). So this would also be an acceptable default type signature:</source>
          <target state="translated">この例をさらに説明するには、 &lt;code&gt;bar&lt;/code&gt; のデフォルトの型シグニチャーの右側は、 &lt;code&gt;forall b. a -&amp;gt; b -&amp;gt; b&lt;/code&gt; とアルファ相当のものでなければなりません。A - &amp;gt; B - &amp;gt; B（ここで、クラス自体によって結合し、したがってメソッドの型シグネチャにフリーです）。したがって、これも受け入れ可能なデフォルトの型シグニチャーになります。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e54d546d02ad4863886b9ee73d1e131e1c71a9f" translate="yes" xml:space="preserve">
          <source>To gain access to a much larger family of encodings, use the &lt;a href=&quot;http://hackage.haskell.org/package/text-icu&quot;&gt;text-icu package&lt;/a&gt;.</source>
          <target state="translated">より大きなエンコーディングファミリにアクセスするには、&lt;a href=&quot;http://hackage.haskell.org/package/text-icu&quot;&gt;text-icuパッケージを&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="a7552595f3e9f52aba2ce1ac4224b4fd08998d77" translate="yes" xml:space="preserve">
          <source>To generate a heap profile from your program:</source>
          <target state="translated">プログラムからヒーププロファイルを生成するには</target>
        </trans-unit>
        <trans-unit id="5c213d8e1ad0bf625f6921a8437f98eeb3f4a1b0" translate="yes" xml:space="preserve">
          <source>To generate a time and allocation profile, give one of the following RTS options to the compiled program when you run it (RTS options should be enclosed between &lt;code&gt;+RTS ... -RTS&lt;/code&gt; as usual):</source>
          <target state="translated">時間と割り当てのプロファイルを生成するには、実行時にコンパイル済みプログラムに次のRTSオプションのいずれかを指定します（RTSオプションは通常どおり &lt;code&gt;+RTS ... -RTS&lt;/code&gt; 囲む必要があります）。</target>
        </trans-unit>
        <trans-unit id="34cea9b35b2bfd8b0bd668c0b07e2825a95e1c3d" translate="yes" xml:space="preserve">
          <source>To get a list of the bindings currently in scope, use the &lt;a href=&quot;#ghci-cmd-:show%20bindings&quot;&gt;&lt;code&gt;:show bindings&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">現在スコープ内にあるバインディングのリストを取得するには、&lt;a href=&quot;#ghci-cmd-:show%20bindings&quot;&gt; &lt;code&gt;:show bindings&lt;/code&gt; &lt;/a&gt;コマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="584aacfb52fdd9de92b4db69f120bc255bd58b9a" translate="yes" xml:space="preserve">
          <source>To get a more useful version of the &lt;code&gt;Collects&lt;/code&gt; class, GHC provides a mechanism that allows programmers to specify dependencies between the parameters of a multiple parameter class (For readers with an interest in theoretical foundations and previous work: The use of dependency information can be seen both as a generalisation of the proposal for &amp;ldquo;parametric type classes&amp;rdquo; that was put forward by Chen, Hudak, and Odersky, or as a special case of Mark Jones&amp;rsquo;s later framework for &amp;ldquo;improvement&amp;rdquo; of qualified types. The underlying ideas are also discussed in a more theoretical and abstract setting in a manuscript &lt;a href=&quot;#jones1999&quot; id=&quot;id31&quot;&gt;[Jones1999]&lt;/a&gt;, where they are identified as one point in a general design space for systems of implicit parameterisation). To start with an abstract example, consider a declaration such as:</source>
          <target state="translated">&lt;code&gt;Collects&lt;/code&gt; クラスのより有用なバージョンを取得するために、GHCはプログラマーが複数のパラメータークラスのパラメーター間の依存関係を指定できるメカニズムを提供します（理論的な基礎と以前の研究に関心のある読者向け：依存関係情報の使用を見ることができますChen、Hudak、およびOderskyによって提唱された「パラメトリックタイプクラス」の提案の一般化として、またはマークジョーンズの後期の修飾されたタイプの「改善」のためのフレームワークの特別なケースとして。原稿のより理論的で抽象的な設定&lt;a href=&quot;#jones1999&quot; id=&quot;id31&quot;&gt;[Jones1999]&lt;/a&gt;、それらは暗黙的なパラメータ化のシステムのための一般的な設計空間の1つのポイントとして識別されます）。抽象的な例から始めるには、次のような宣言を考えてください。</target>
        </trans-unit>
        <trans-unit id="3b643a5f53fe92a51d4d6cc04833d6658ab9e142" translate="yes" xml:space="preserve">
          <source>To get a more useful version of the &lt;code&gt;Collects&lt;/code&gt; class, GHC provides a mechanism that allows programmers to specify dependencies between the parameters of a multiple parameter class (For readers with an interest in theoretical foundations and previous work: The use of dependency information can be seen both as a generalisation of the proposal for &amp;ldquo;parametric type classes&amp;rdquo; that was put forward by Chen, Hudak, and Odersky, or as a special case of Mark Jones&amp;rsquo;s later framework for &amp;ldquo;improvement&amp;rdquo; of qualified types. The underlying ideas are also discussed in a more theoretical and abstract setting in a manuscript &lt;a href=&quot;#jones1999&quot; id=&quot;id32&quot;&gt;[Jones1999]&lt;/a&gt;, where they are identified as one point in a general design space for systems of implicit parameterisation). To start with an abstract example, consider a declaration such as:</source>
          <target state="translated">&lt;code&gt;Collects&lt;/code&gt; クラスのより便利なバージョンを取得するために、GHCは、プログラマーが複数のパラメータークラスのパラメーター間の依存関係を指定できるメカニズムを提供します（理論的基礎と以前の作業に関心のある読者の場合：依存関係情報の使用を見ることができます） Chen、Hudak、およびOderskyによって提案された「パラメトリック型クラス」の提案の一般化として、または修飾型の「改善」のためのMark Jonesの後のフレームワークの特殊なケースとして、両方の基礎となるアイデアについても説明します。原稿のより理論的で抽象的な設定&lt;a href=&quot;#jones1999&quot; id=&quot;id32&quot;&gt;[Jones1999]&lt;/a&gt;、暗黙的なパラメータ化のシステムの一般的な設計空間の1つのポイントとして識別されます）。抽象的な例から始めるために、次のような宣言について考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="2dd4283dabd7adbbf3b3fa6217759a91e02bf006" translate="yes" xml:space="preserve">
          <source>To get better errors, it is recommended to use #line pragmas when emitting C files, e.g.</source>
          <target state="translated">より良いエラーを得るためには、C ファイルを出力する際に #line pragma を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="c4c508962468a9bf469857dfae6ad15a1e12b86c" translate="yes" xml:space="preserve">
          <source>To get maximum performance when building lazy &lt;code&gt;Text&lt;/code&gt; values using a builder, associate &lt;code&gt;mappend&lt;/code&gt; calls to the right. For example, prefer</source>
          <target state="translated">ビルダーを使用して遅延 &lt;code&gt;Text&lt;/code&gt; 値を作成するときに最大のパフォーマンスを得るには、 &lt;code&gt;mappend&lt;/code&gt; 呼び出しを右側に関連付けます。たとえば、好む</target>
        </trans-unit>
        <trans-unit id="e54b5b21677328842d1e9a6b9afb2745752f58b5" translate="yes" xml:space="preserve">
          <source>To get the annotations of a single binder, you can use &lt;code&gt;getAnnotations&lt;/code&gt; and specify the proper type. Here&amp;rsquo;s an example that will print out the name of any top-level non-recursive binding with the &lt;code&gt;SomeAnn&lt;/code&gt; annotation:</source>
          <target state="translated">単一のバインダーの注釈を取得するには、 &lt;code&gt;getAnnotations&lt;/code&gt; を使用して適切なタイプを指定できます。以下は、 &lt;code&gt;SomeAnn&lt;/code&gt; アノテーションを使用したトップレベルの非再帰的バインディングの名前を出力する例です。</target>
        </trans-unit>
        <trans-unit id="427028b92998e9d2972ad20dfdc92870e2d3c450" translate="yes" xml:space="preserve">
          <source>To help understand the use of these functions, consider the Unicode string &lt;code&gt;&quot;hi ☃&quot;&lt;/code&gt;. If encoded as UTF-8, this becomes &lt;code&gt;&quot;hi
 \xe2\x98\x83&quot;&lt;/code&gt;; the final &lt;code&gt;'☃'&lt;/code&gt; is encoded as 3 bytes.</source>
          <target state="translated">これらの関数の使用法を理解するのに役立つように、Unicode文字列 &lt;code&gt;&quot;hi ☃&quot;&lt;/code&gt; 考えてみましょう。UTF-8としてエンコードされている場合、これは &lt;code&gt;&quot;hi \xe2\x98\x83&quot;&lt;/code&gt; ます。最後の &lt;code&gt;'☃'&lt;/code&gt; は3バイトとしてエンコードされます。</target>
        </trans-unit>
        <trans-unit id="99872510dc191d4452db56bf22957570e23b92b9" translate="yes" xml:space="preserve">
          <source>To help you get over the confidence barrier, try out this skeletal worked example. First cut and paste the two modules below into &lt;code&gt;Main.hs&lt;/code&gt; and &lt;code&gt;Printf.hs&lt;/code&gt;:</source>
          <target state="translated">信頼の壁を乗り越えるのに役立つように、この骨組みの例を試してみてください。まず、以下の2つのモジュールをカットして &lt;code&gt;Main.hs&lt;/code&gt; と &lt;code&gt;Printf.hs&lt;/code&gt; に貼り付けます。</target>
        </trans-unit>
        <trans-unit id="48b1aabf0c4a191f672c0b44cca67c4f38a6d577" translate="yes" xml:space="preserve">
          <source>To hopefully illuminate the role of the different data structures, here are the command-line options for a (very simple) compiler, done in two different ways. The difference arises because the type of &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt; is parameterized by the type of values derived from flags.</source>
          <target state="translated">うまくいけば、さまざまなデータ構造の役割を明らかにするために、2つの異なる方法で実行される（非常に単純な）コンパイラのコマンドラインオプションを次に示します。 &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt; のタイプは、フラグから派生した値のタイプによってパラメーター化されるため、違いが生じます。</target>
        </trans-unit>
        <trans-unit id="d8ae72f545b1ce82b2cfe09ab991783beb655542" translate="yes" xml:space="preserve">
          <source>To implement &lt;code&gt;find&lt;/code&gt; or &lt;code&gt;findLast&lt;/code&gt; on any &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">実現するために、 &lt;code&gt;find&lt;/code&gt; や &lt;code&gt;findLast&lt;/code&gt; を任意の上 &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="458751b9fab299d8f4e8789e1128f4827ef9c961" translate="yes" xml:space="preserve">
          <source>To import a qualified module usually you must specify &lt;code&gt;qualified&lt;/code&gt; in prepositive position : &lt;code&gt;import qualified M&lt;/code&gt;. This often leads to a &amp;ldquo;hanging indent&amp;rdquo; (which is automatically inserted by some autoformatters and common in many code bases. For example:</source>
          <target state="translated">修飾されたモジュールをインポートするには、通常、前向きの位置で &lt;code&gt;qualified&lt;/code&gt; れたものを指定する必要があります： &lt;code&gt;import qualified M&lt;/code&gt; ます。これにより、「ぶら下がりインデント」が発生することがよくあります（これは、一部のオートフォーマッターによって自動的に挿入され、多くのコードベースで一般的です。例：</target>
        </trans-unit>
        <trans-unit id="2c7c52e770ffa8a6b97378d2c5e459f4d2e43a4e" translate="yes" xml:space="preserve">
          <source>To install LLVM and Clang:</source>
          <target state="translated">LLVMとClangをインストールします。</target>
        </trans-unit>
        <trans-unit id="f4755fa59e195e04ee11ff89504edf74eae51201" translate="yes" xml:space="preserve">
          <source>To invoke &lt;code&gt;foo()&lt;/code&gt; from C, just &lt;code&gt;#include &quot;Foo_stub.h&quot;&lt;/code&gt; and call &lt;code&gt;foo()&lt;/code&gt;.</source>
          <target state="translated">Cから &lt;code&gt;foo()&lt;/code&gt; を呼び出すには、 &lt;code&gt;#include &quot;Foo_stub.h&quot;&lt;/code&gt; を呼び出して &lt;code&gt;foo()&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="67c620f61de0b4e8243389340a761b127a5420c3" translate="yes" xml:space="preserve">
          <source>To learn more about this decision and the design of GHC under the hood please see the &lt;a href=&quot;http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf&quot;&gt;paper&lt;/a&gt; introducing this kind system to GHC/Haskell.</source>
          <target state="translated">この決定と内部でのGHCの設計の詳細については、この種のシステムをGHC / Haskellに紹介する&lt;a href=&quot;http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf&quot;&gt;論文&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="aae76ecf649e9d0d8a82065b74e94e13fc57f2d4" translate="yes" xml:space="preserve">
          <source>To load a Haskell source file into GHCi, use the &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">HaskellソースファイルをGHCiに&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;するには、：loadコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="84282ca7b4af31d8f72f41e5b0309bfeef77e8b2" translate="yes" xml:space="preserve">
          <source>To load a package &lt;code&gt;foo&lt;/code&gt;, GHCi can load its &lt;code&gt;libHSfoo.a&lt;/code&gt; library directly, but it can also load a package in the form of a single &lt;code&gt;HSfoo.o&lt;/code&gt; file that has been pre-linked. Loading the &lt;code&gt;.o&lt;/code&gt; file is slightly quicker, but at the expense of having another copy of the compiled package. The rule of thumb is that if the modules of the package were compiled with &lt;a href=&quot;phases#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt; then building the &lt;code&gt;HSfoo.o&lt;/code&gt; is worthwhile because it saves time when loading the package into GHCi. Without &lt;a href=&quot;phases#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt;, there is not much difference in load time between the &lt;code&gt;.o&lt;/code&gt; and &lt;code&gt;.a&lt;/code&gt; libraries, so it is better to save the disk space and only keep the &lt;code&gt;.a&lt;/code&gt; around. In a GHC distribution we provide &lt;code&gt;.o&lt;/code&gt; files for most packages except the GHC package itself.</source>
          <target state="translated">パッケージ &lt;code&gt;foo&lt;/code&gt; をロードするために、GHCiは &lt;code&gt;libHSfoo.a&lt;/code&gt; ライブラリーを直接ロードできますが、事前にリンクされた単一の &lt;code&gt;HSfoo.o&lt;/code&gt; ファイルの形式でパッケージをロードすることもできます。 &lt;code&gt;.o&lt;/code&gt; ファイルのロードは少し速くなりますが、コンパイル済みパッケージの別のコピーが必要になります。経験則では、パッケージのモジュールがコンパイルされた場合ということである&lt;a href=&quot;phases#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; &lt;/a&gt;その後、建物 &lt;code&gt;HSfoo.o&lt;/code&gt; を GHCiのにパッケージをロードするとき、それは時間を節約するために価値があります。なしで&lt;a href=&quot;phases#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; &lt;/a&gt;、間のロード時間があまり違いがない &lt;code&gt;.o&lt;/code&gt; と &lt;code&gt;.a&lt;/code&gt; ということは、ディスク・スペースを節約だけ維持する方が良いので、ライブラリは、 &lt;code&gt;.a&lt;/code&gt; 周り。GHCディストリビューションでは、GHCパッケージ自体を除くほとんどのパッケージに &lt;code&gt;.o&lt;/code&gt; ファイルを提供しています。</target>
        </trans-unit>
        <trans-unit id="ab99b40605f7da9e4eebad8eb504404bd0faa1f0" translate="yes" xml:space="preserve">
          <source>To load a package &lt;code&gt;foo&lt;/code&gt;, GHCi can load its &lt;code&gt;libHSfoo.a&lt;/code&gt; library directly, but it can also load a package in the form of a single &lt;code&gt;HSfoo.o&lt;/code&gt; file that has been pre-linked. Loading the &lt;code&gt;.o&lt;/code&gt; file is slightly quicker, but at the expense of having another copy of the compiled package. The rule of thumb is that if the modules of the package were compiled with &lt;a href=&quot;phases#ghc-flag--split-sections&quot;&gt;&lt;code&gt;-split-sections&lt;/code&gt;&lt;/a&gt; then building the &lt;code&gt;HSfoo.o&lt;/code&gt; is worthwhile because it saves time when loading the package into GHCi. Without &lt;a href=&quot;phases#ghc-flag--split-sections&quot;&gt;&lt;code&gt;-split-sections&lt;/code&gt;&lt;/a&gt;, there is not much difference in load time between the &lt;code&gt;.o&lt;/code&gt; and &lt;code&gt;.a&lt;/code&gt; libraries, so it is better to save the disk space and only keep the &lt;code&gt;.a&lt;/code&gt; around. In a GHC distribution we provide &lt;code&gt;.o&lt;/code&gt; files for most packages except the GHC package itself.</source>
          <target state="translated">パッケージ &lt;code&gt;foo&lt;/code&gt; をロードするために、GHCiはその &lt;code&gt;libHSfoo.a&lt;/code&gt; ライブラリを直接ロードできますが、事前にリンクされた単一の &lt;code&gt;HSfoo.o&lt;/code&gt; ファイルの形式でパッケージをロードすることもできます。 &lt;code&gt;.o&lt;/code&gt; ファイルの読み込みは少し速くなりますが、コンパイルされたパッケージの別のコピーが必要になります。経験則では、パッケージのモジュールがコンパイルされた場合ということである&lt;a href=&quot;phases#ghc-flag--split-sections&quot;&gt; &lt;code&gt;-split-sections&lt;/code&gt; &lt;/a&gt;その後、建物 &lt;code&gt;HSfoo.o&lt;/code&gt; をGHCiのにパッケージをロードするとき、それは時間を節約するために価値があります。なしで&lt;a href=&quot;phases#ghc-flag--split-sections&quot;&gt; &lt;code&gt;-split-sections&lt;/code&gt; &lt;/a&gt;、間のロード時間があまり違いがない &lt;code&gt;.o&lt;/code&gt; と &lt;code&gt;.a&lt;/code&gt; のは、ライブラリなので、ディスクスペースを節約し、 &lt;code&gt;.a&lt;/code&gt; のみを保持することをお勧めします。GHCディストリビューションでは、GHCパッケージ自体を除くほとんどのパッケージに &lt;code&gt;.o&lt;/code&gt; ファイルを提供しています。</target>
        </trans-unit>
        <trans-unit id="d2e3260144403e14ad423568ae3ce8f12c1a164c" translate="yes" xml:space="preserve">
          <source>To make an executable program, the GHC system compiles your code and then links it with a non-trivial runtime system (RTS), which handles storage management, thread scheduling, profiling, and so on.</source>
          <target state="translated">実行可能なプログラムを作るために、GHCシステムはコードをコンパイルし、ストレージ管理、スレッドスケジューリング、プロファイリングなどを行う非自明のランタイムシステム(RTS)とリンクさせます。</target>
        </trans-unit>
        <trans-unit id="409b50b71b1cf04f14989a6bebb5d1b08c15a045" translate="yes" xml:space="preserve">
          <source>To make life slightly easier, the GHCi prompt also behaves as if there is an implicit &lt;code&gt;import qualified&lt;/code&gt; declaration for every module in every package, and every module currently loaded into GHCi. This behaviour can be disabled with the &lt;code&gt;-fno-implicit-import-qualified&lt;/code&gt; flag.</source>
          <target state="translated">生活を少し楽にするために、GHCiプロンプトは、すべてのパッケージのすべてのモジュール、および現在GHCiにロードされているすべてのモジュールに対して暗黙の &lt;code&gt;import qualified&lt;/code&gt; 宣言があるかのように動作します。この動作は、 &lt;code&gt;-fno-implicit-import-qualified&lt;/code&gt; フラグで無効にできます。</target>
        </trans-unit>
        <trans-unit id="f3811e1546e787ed220aa8285f2fd305ece22386" translate="yes" xml:space="preserve">
          <source>To make this more robust, GHC has a notion of deriving strategies, which allow the user to explicitly request which approach to use when deriving an instance. To enable this feature, one must enable the &lt;a href=&quot;#extension-DerivingStrategies&quot;&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt; language extension. A deriving strategy can be specified in a deriving clause</source>
          <target state="translated">これをより堅牢にするために、GHCには、ユーザーがインスタンスの派生時に使用するアプローチを明示的に要求できるようにする派生戦略の概念があります。この機能を有効にするには、&lt;a href=&quot;#extension-DerivingStrategies&quot;&gt; &lt;code&gt;DerivingStrategies&lt;/code&gt; &lt;/a&gt;言語拡張を有効にする必要があります。導出戦略は、導出句で指定できます</target>
        </trans-unit>
        <trans-unit id="b64615441fb8a751e6636d849ab82db0727aa6e0" translate="yes" xml:space="preserve">
          <source>To make use of the profiling system &lt;em&gt;all&lt;/em&gt; modules must be compiled and linked with the &lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option. Any &lt;code&gt;SCC&lt;/code&gt; annotations you&amp;rsquo;ve put in your source will spring to life.</source>
          <target state="translated">プロファイリングシステムを利用するには、&lt;em&gt;すべての&lt;/em&gt;モジュールをコンパイルして、&lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;オプションでリンクする必要があります。どれ &lt;code&gt;SCC&lt;/code&gt; のあなたがあなたの元に置かれている注釈は、生活に春ます。</target>
        </trans-unit>
        <trans-unit id="cadd792349a4de388974151ed3334973779b0aae" translate="yes" xml:space="preserve">
          <source>To make use of these hidden fields, we need to create some helper functions:</source>
          <target state="translated">これらの非表示フィールドを利用するには、いくつかのヘルパー関数を作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="8a354e65731baf61d210fdcef00d7fcaebe03d2c" translate="yes" xml:space="preserve">
          <source>To provide more control over the compiler&amp;rsquo;s verbosity, the &lt;code&gt;-v&lt;/code&gt; flag takes an optional numeric argument. Specifying &lt;code&gt;-v&lt;/code&gt; on its own is equivalent to &lt;code&gt;-v3&lt;/code&gt;, and the other levels have the following meanings:</source>
          <target state="translated">コンパイラーの冗長性をさらに制御するために、 &lt;code&gt;-v&lt;/code&gt; フラグはオプションの数値引数を取ります。 &lt;code&gt;-v&lt;/code&gt; を単独で指定することは &lt;code&gt;-v3&lt;/code&gt; と同等であり、他のレベルには次の意味があります。</target>
        </trans-unit>
        <trans-unit id="e09a1d373d13bfd1fe833239f80a4362b6548f69" translate="yes" xml:space="preserve">
          <source>To recover after an exception and do something else, the best choice is to use one of the &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; family.</source>
          <target state="translated">例外の後で回復して別のことを行うには、 &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; ファミリーの1つを使用するのが最善の選択です。</target>
        </trans-unit>
        <trans-unit id="14e26ca731fed1a65d734c4805ba32c05da97880" translate="yes" xml:space="preserve">
          <source>To remove an existing directory symbolic link, use &lt;code&gt;&lt;a href=&quot;system-directory#v:removeDirectoryLink&quot;&gt;removeDirectoryLink&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">既存のディレクトリシンボリックリンクを削除するには、 &lt;code&gt;&lt;a href=&quot;system-directory#v:removeDirectoryLink&quot;&gt;removeDirectoryLink&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="902b5e7fc39d15c95b3964399bd08b53ff7a117f" translate="yes" xml:space="preserve">
          <source>To remove an existing file symbolic link, use &lt;code&gt;&lt;a href=&quot;system-directory#v:removeFile&quot;&gt;removeFile&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">既存のファイルシンボリックリンクを削除するには、 &lt;code&gt;&lt;a href=&quot;system-directory#v:removeFile&quot;&gt;removeFile&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="0eb5610465d9a35f189f4445a996d1ae11b587c8" translate="yes" xml:space="preserve">
          <source>To safely use this API you must either extract the list of vertices directly from the graph or first call &lt;code&gt;vertexFromKey k&lt;/code&gt; to check if a vertex corresponds to the key &lt;code&gt;k&lt;/code&gt;. Once it is known that a vertex exists you can use &lt;code&gt;nodeFromVertex&lt;/code&gt; to access the labelled node and adjacent vertices. See below for examples.</source>
          <target state="translated">このAPIを安全に使用するには、グラフから頂点のリストを直接抽出するか、最初に &lt;code&gt;vertexFromKey k&lt;/code&gt; を呼び出して、頂点がキー &lt;code&gt;k&lt;/code&gt; に対応するかどうかを確認する必要があります。頂点が存在することがわかったら、 &lt;code&gt;nodeFromVertex&lt;/code&gt; を使用して、ラベル付けされたノードと隣接する頂点にアクセスできます。例については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="a5e1113a1ceca8ac3b9f3aacd5ed4c7c86f2fc6d" translate="yes" xml:space="preserve">
          <source>To see whether you&amp;rsquo;re making good use of all the memory reseverd for the allocation area (&lt;code&gt;-A&lt;/code&gt; times &lt;code&gt;-N&lt;/code&gt;), look at the output of &lt;code&gt;+RTS -S&lt;/code&gt; and check whether the amount of memory allocated between GCs is equal to &lt;code&gt;-A&lt;/code&gt; times &lt;code&gt;-N&lt;/code&gt;. If not, there are two possible remedies: use &lt;code&gt;-n&lt;/code&gt; to set a nursery chunk size, or use &lt;code&gt;-AL&lt;/code&gt; to increase the limit for large objects.</source>
          <target state="translated">あなたは（アロケーションエリアのすべてのメモリreseverdを駆使しているかどうかを確認するには &lt;code&gt;-A&lt;/code&gt; 時間が &lt;code&gt;-N&lt;/code&gt; の出力で、）を見て &lt;code&gt;+RTS -S&lt;/code&gt; とGCの間で割り当てられたメモリの量が等しいかどうかをチェック &lt;code&gt;-A&lt;/code&gt; 回 &lt;code&gt;-N&lt;/code&gt; 。そうでない場合、2つの解決策があります。 &lt;code&gt;-n&lt;/code&gt; を使用して &lt;code&gt;-AL&lt;/code&gt; チャンクサイズを設定するか、-ALを使用してラージオブジェクトの制限を増やします。</target>
        </trans-unit>
        <trans-unit id="7f2b1743b3c15e52d49c7a46f47317e7b211afa8" translate="yes" xml:space="preserve">
          <source>To see which modules are provided by a package use the &lt;code&gt;ghc-pkg&lt;/code&gt; command (see &lt;a href=&quot;#package-management&quot;&gt;Package management (the ghc-pkg command)&lt;/a&gt;):</source>
          <target state="translated">パッケージによって提供されるモジュールを確認するには、 &lt;code&gt;ghc-pkg&lt;/code&gt; コマンドを使用します（&lt;a href=&quot;#package-management&quot;&gt;パッケージ管理（ghc-pkgコマンド）を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="0d20768e5351c559b7b7519dd0d6001dcac049eb" translate="yes" xml:space="preserve">
          <source>To see which packages are currently available, use the &lt;code&gt;ghc-pkg list&lt;/code&gt; command:</source>
          <target state="translated">現在利用可能なパッケージを確認するには、 &lt;code&gt;ghc-pkg list&lt;/code&gt; コマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="a70566dabf5a41f2019632020db79dab54902519" translate="yes" xml:space="preserve">
          <source>To see why a data type with a contravariant occurrence of its last type parameter cannot have a derived &lt;code&gt;Functor&lt;/code&gt; instance, let&amp;rsquo;s suppose that a &lt;code&gt;Functor ContraFun1&lt;/code&gt; instance exists. The implementation would look something like this:</source>
          <target state="translated">最後の型パラメーターが反変であるデータ型が派生 &lt;code&gt;Functor&lt;/code&gt; インスタンスを持つことができない理由を確認するために、 &lt;code&gt;Functor ContraFun1&lt;/code&gt; インスタンスが存在するとします。実装は次のようになります。</target>
        </trans-unit>
        <trans-unit id="1dd1e599c7b99d0ef6415d16c2b63820670b8ef4" translate="yes" xml:space="preserve">
          <source>To serialise a custom type, an instance of Binary for that type is required. For example, suppose we have a data structure:</source>
          <target state="translated">カスタム型をシリアライズするには、その型のBinaryのインスタンスが必要です。例えば、データ構造体があるとします。</target>
        </trans-unit>
        <trans-unit id="ec5ac163ebb0f97a307be294a6581754c5f32393" translate="yes" xml:space="preserve">
          <source>To serialise this to a bytestring, we use &lt;code&gt;&lt;a href=&quot;data-binary#v:encode&quot;&gt;encode&lt;/a&gt;&lt;/code&gt;, which packs the data structure into a binary format, in a lazy bytestring</source>
          <target state="translated">これをバイト文字列にシリアル &lt;code&gt;&lt;a href=&quot;data-binary#v:encode&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; には、データ構造をバイナリ形式にパックするエンコードを遅延バイト文字列に使用します</target>
        </trans-unit>
        <trans-unit id="8c4bb74fa2bda9539f0db58684ace13bfcd04704" translate="yes" xml:space="preserve">
          <source>To set a package&amp;rsquo;s trust property in the package database please refer to &lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;.</source>
          <target state="translated">パッケージデータベースにパッケージの信頼プロパティを設定するにはを参照してください&lt;a href=&quot;packages#packages&quot;&gt;パッケージ&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a25ac21c6d3b62631dd08b42b9fae80c8727be0" translate="yes" xml:space="preserve">
          <source>To skip to the first occurence of a string:</source>
          <target state="translated">文字列の最初の出現位置にスキップします。</target>
        </trans-unit>
        <trans-unit id="edb758d0d6990d34bd2a170aea31bb2ebe72017b" translate="yes" xml:space="preserve">
          <source>To solve such concern, the references provided by this module offer a key that can be used to locate the values on each process. Each process maintains a global table of references which can be looked up with a given key. This table is known as the Static Pointer Table. The reference can then be dereferenced to obtain the value.</source>
          <target state="translated">このような懸念を解決するために、このモジュールによって提供される参照は、各プロセスの値を見つけるために使用できるキーを提供します。各プロセスは、与えられたキーで検索できる参照のグローバルテーブルを保持しています。このテーブルはスタティック・ポインタ・テーブルとして知られています。そして、参照を参照して値を取得することができます。</target>
        </trans-unit>
        <trans-unit id="f9c68944d2e59e0a66846b50f57d32b2ca1f9acb" translate="yes" xml:space="preserve">
          <source>To solve this, GHC provides a single type-level function,</source>
          <target state="translated">これを解決するために、GHCは単一の型レベル関数を提供しています。</target>
        </trans-unit>
        <trans-unit id="bf25b9f1720e9ac7d0d7fdd7aee2f1ed9e0566fe" translate="yes" xml:space="preserve">
          <source>To start with an example, suppose you had a module &lt;code&gt;A&lt;/code&gt; which made use of some string operations. Using normal module imports, you would only be able to pick a particular implementation of strings:</source>
          <target state="translated">例から始めるために、いくつかの文字列操作を利用するモジュール &lt;code&gt;A&lt;/code&gt; があるとします。通常のモジュールインポートを使用すると、文字列の特定の実装のみを選択できます。</target>
        </trans-unit>
        <trans-unit id="89c4479e20c71a25f4dfb43028231f4a734bfcce" translate="yes" xml:space="preserve">
          <source>To take the parts of a string before a delimiter:</source>
          <target state="translated">区切り文字の前の文字列の部分を取る。</target>
        </trans-unit>
        <trans-unit id="e0c0e5556db2e9b3b7a23b8b7d2d49b51aa44349" translate="yes" xml:space="preserve">
          <source>To the programmer, Concurrent Haskell introduces no new language constructs; rather, it appears simply as a library, &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. The functions exported by this library include:</source>
          <target state="translated">プログラマーにとって、Concurrent Haskellは新しい言語構造を導入していません。むしろ、単純にライブラリ&lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrentの&lt;/a&gt;ように見えます。このライブラリーによってエクスポートされる関数には、次のものがあります。</target>
        </trans-unit>
        <trans-unit id="6bfc70e59567edf696404769885739682f80dcc8" translate="yes" xml:space="preserve">
          <source>To the programmer, Concurrent Haskell introduces no new language constructs; rather, it appears simply as a library, &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. The functions exported by this library include:</source>
          <target state="translated">プログラマーにとって、ConcurrentHaskellは新しい言語構造を導入していません。むしろ、それは単にライブラリ&lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;として表示されます。このライブラリによってエクスポートされる関数は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="6c62456e79e21d498915acbcba13f52cb41593ec" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;+RTS&lt;/code&gt; flags with &lt;code&gt;hs_init()&lt;/code&gt;, we have to modify the example slightly. By default, GHC&amp;rsquo;s RTS will only accept &amp;ldquo;safe&amp;rdquo; &lt;code&gt;+RTS&lt;/code&gt; flags (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), and the &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; link-time flag overrides this. However, &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; has no effect when &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt; is in use (and the same goes for &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;). To set these options we have to call a GHC-specific API instead of &lt;code&gt;hs_init()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;hs_init()&lt;/code&gt; で &lt;code&gt;+RTS&lt;/code&gt; フラグを使用するには、例を少し変更する必要があります。デフォルトでは、GHCのRTSは「安全な」 &lt;code&gt;+RTS&lt;/code&gt; フラグのみを受け入れ（&lt;a href=&quot;phases#options-linker&quot;&gt;リンクに影響するオプションを&lt;/a&gt;参照）、- &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; リンクタイムフラグがこれをオーバーライドします。ただし、 &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt;が使用されている場合、-rtsopts [=⟨none| some | all | ignore |ignoreAll⟩]は効果がありません（ &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; についても同じことが言えます）。これらのオプションを設定するには、 &lt;code&gt;hs_init()&lt;/code&gt; の代わりにGHC固有のAPIを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="23874375ac3170d79af0c71d4f8ee2bec3a32884" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;+RTS&lt;/code&gt; flags with &lt;code&gt;hs_init()&lt;/code&gt;, we have to modify the example slightly. By default, GHC&amp;rsquo;s RTS will only accept &amp;ldquo;safe&amp;rdquo; &lt;code&gt;+RTS&lt;/code&gt; flags (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), and the &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; link-time flag overrides this. However, &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; has no effect when &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt; is in use (and the same goes for &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;). To set these options we have to call a GHC-specific API instead of &lt;code&gt;hs_init()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;+RTS&lt;/code&gt; フラグを &lt;code&gt;hs_init()&lt;/code&gt; で使用するには、例を少し変更する必要があります。デフォルトでは、GHCのRTSは「安全な」 &lt;code&gt;+RTS&lt;/code&gt; フラグのみを受け入れ（&lt;a href=&quot;phases#options-linker&quot;&gt;リンクに影響するオプションを&lt;/a&gt;参照）、- &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; リンク時フラグがこれを上書きします。ただし、&lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt;が使用されている場合、 &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; は効果がありません（ &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; についても同様です）。これらのオプションを設定するには、 &lt;code&gt;hs_init()&lt;/code&gt; の代わりにGHC固有のAPIを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="58ce08b9cab583ec1630da790acaeb1e4504d015" translate="yes" xml:space="preserve">
          <source>To use an &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt; the RTS API provides the following functions:</source>
          <target state="translated">&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt;を使用するために、RTSAPIは次の関数を提供します。</target>
        </trans-unit>
        <trans-unit id="c832a5995effff9df59220a2bd9f7e56cfb4614f" translate="yes" xml:space="preserve">
          <source>To use an extended and very rich family of functions for working with Unicode text (including normalization, regular expressions, non-standard encodings, text breaking, and locales), see the &lt;a href=&quot;http://hackage.haskell.org/package/text-icu&quot;&gt;text-icu package&lt;/a&gt;.</source>
          <target state="translated">Unicodeテキストを操作するための拡張された非常に豊富な関数ファミリー（正規化、正規表現、非標準エンコーディング、テキスト分割、ロケールなど）を使用するには、&lt;a href=&quot;http://hackage.haskell.org/package/text-icu&quot;&gt;text-icuパッケージを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b96ac2af089bcd3267331bb1501aa1e1d197309c" translate="yes" xml:space="preserve">
          <source>To use relative paths for dependent libraries on Linux and Solaris you can pass a suitable &lt;code&gt;-rpath&lt;/code&gt; flag to the linker:</source>
          <target state="translated">LinuxおよびSolarisで依存ライブラリの相対パスを使用するには、適切な &lt;code&gt;-rpath&lt;/code&gt; フラグをリンカーに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="7f309e398fff568b18e392785bde202981de0be5" translate="yes" xml:space="preserve">
          <source>To use this equality in practice, pattern-match on the &lt;code&gt;Coercion a b&lt;/code&gt; to get out the &lt;code&gt;Coercible a b&lt;/code&gt; instance, and then use &lt;code&gt;&lt;a href=&quot;data-coerce#v:coerce&quot;&gt;coerce&lt;/a&gt;&lt;/code&gt; to apply it.</source>
          <target state="translated">実際には、この等式を使用するには、上のパターンマッチ &lt;code&gt;Coercion a b&lt;/code&gt; 出て取得する &lt;code&gt;Coercible a b&lt;/code&gt; インスタンスを、次に使用 &lt;code&gt;&lt;a href=&quot;data-coerce#v:coerce&quot;&gt;coerce&lt;/a&gt;&lt;/code&gt; 、それを適用します。</target>
        </trans-unit>
        <trans-unit id="3aa17a9e79c9dcc3ca39fe2b79ee583cccf33fc4" translate="yes" xml:space="preserve">
          <source>To use tracing, evaluate an expression with the &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt; command. For example, if we set a breakpoint on the base case of &lt;code&gt;qsort&lt;/code&gt;:</source>
          <target state="translated">トレースを使用するには、&lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt;コマンドで式を評価します。たとえば、 &lt;code&gt;qsort&lt;/code&gt; の基本ケースにブレークポイントを設定すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="efc675a1383ace97e3c2b8987f540eb58b6ceef5" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the documentation of the valid hole fits in the output.</source>
          <target state="translated">有効なホールフィットの文書を出力に表示するかどうかをトグルします。</target>
        </trans-unit>
        <trans-unit id="332b4115b5fb01dc68e2b60acec1f7d2ed0f11c6" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the provenance of the valid hole fits in the output.</source>
          <target state="translated">有効なホールフィットの実績を出力に表示するかどうかを切り替えます。</target>
        </trans-unit>
        <trans-unit id="a7f408bf113ca084f529db4badbce821ff390f15" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the type application of the valid hole fits in the output.</source>
          <target state="translated">有効なホールフィットのタイプアプリケーションを出力に表示するかどうかをトグルします。</target>
        </trans-unit>
        <trans-unit id="2c4d22b7c838a1ecfb6276f53708bb0e679bc1f9" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the type of the additional holes in refinement hole fits.</source>
          <target state="translated">絞り穴フィットの追加穴の種類を表示するかどうかをトグルします。</target>
        </trans-unit>
        <trans-unit id="04756312abbe3334230e9fe9c79fe06f08cf1ef4" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the type of the valid hole fits in the output.</source>
          <target state="translated">有効なホールフィットのタイプを出力に表示するかどうかをトグルします。</target>
        </trans-unit>
        <trans-unit id="f88544b7c345be9bc6286319d7234499cb7a2281" translate="yes" xml:space="preserve">
          <source>Toggles whether to show what type each quantified variable takes in a valid hole fit.</source>
          <target state="translated">有効なホールフィットにおいて、各定量化変数がどのような型を取るかを表示するかどうかを切り替えます。</target>
        </trans-unit>
        <trans-unit id="8d4022d64adedc28fae75a3f895c4e8da81cd40c" translate="yes" xml:space="preserve">
          <source>Token pretty-printing function.</source>
          <target state="translated">トークンのプリティ印刷機能。</target>
        </trans-unit>
        <trans-unit id="daef2147e79571af8d5a4f376f29fb535295e66d" translate="yes" xml:space="preserve">
          <source>TokenParser</source>
          <target state="translated">TokenParser</target>
        </trans-unit>
        <trans-unit id="de9a588a8ad015eb8d4acc3d2eccb5cd88ff7637" translate="yes" xml:space="preserve">
          <source>Top-level declaration splices break up a source file into &lt;em&gt;declaration groups&lt;/em&gt;. A &lt;em&gt;declaration group&lt;/em&gt; is the group of declarations created by a top-level declaration splice, plus those following it, down to but not including the next top-level declaration splice. N.B. only top-level splices delimit declaration groups, not expression splices. The first declaration group in a module includes all top-level definitions down to but not including the first top-level declaration splice.</source>
          <target state="translated">トップレベルの宣言スプライスは、ソースファイルを&lt;em&gt;宣言グループに&lt;/em&gt;分割し&lt;em&gt;ます&lt;/em&gt;。&lt;em&gt;宣言基は、&lt;/em&gt;トップレベルの宣言スプライスによって作成された宣言の基であり、プラスのものまで、それに続くが、次のトップレベルの宣言スプライスを含みません。NB宣言グループを区切るのはトップレベルのスプライスのみであり、式のスプライスは区切りません。モジュールの最初の宣言グループには、最初のトップレベルの宣言スプライスまでのすべてのトップレベルの定義が含まれます。</target>
        </trans-unit>
        <trans-unit id="64e70a05233381ae9b755ec9cdc13f4a77ee5cb1" translate="yes" xml:space="preserve">
          <source>Total CPU time (at the previous GC)</source>
          <target state="translated">総CPU時間(前回GC時</target>
        </trans-unit>
        <trans-unit id="8386f73231e1e92e73f6b519f210511ca9193151" translate="yes" xml:space="preserve">
          <source>Total CPU time used by the GC</source>
          <target state="translated">GC 2011 で使用された総 CPU 時間</target>
        </trans-unit>
        <trans-unit id="042e7e784ddb44e360a337daa72b2ae8ba023cf1" translate="yes" xml:space="preserve">
          <source>Total CPU time used by the init phase @since 4.12.0.0</source>
          <target state="translated">4.12.0.0.0以降のinitフェーズで使用された総CPU時間</target>
        </trans-unit>
        <trans-unit id="d2dd5d438fb3dcc8fdc1f04bf55f6d2c501879d3" translate="yes" xml:space="preserve">
          <source>Total CPU time used by the mutator</source>
          <target state="translated">ミューテータが使用した総CPU時間</target>
        </trans-unit>
        <trans-unit id="cd8f3ebd1cb51ba0810348d6c47b2fdc351d6519" translate="yes" xml:space="preserve">
          <source>Total amount of data copied during this GC</source>
          <target state="translated">今回のGC期間中にコピーされたデータの総量</target>
        </trans-unit>
        <trans-unit id="9735e288f821d32fcba71a1a70c14b5cdc350199" translate="yes" xml:space="preserve">
          <source>Total amount of live data in compact regions</source>
          <target state="translated">コンパクトな地域のライブデータの総量</target>
        </trans-unit>
        <trans-unit id="490b2f80ac8821885d90f86d57b7974bbf2682ad" translate="yes" xml:space="preserve">
          <source>Total amount of live data in large objects</source>
          <target state="translated">ラージオブジェクトのライブデータの総量</target>
        </trans-unit>
        <trans-unit id="e6b177b175f265fd062fef05a1277c622c233454" translate="yes" xml:space="preserve">
          <source>Total amount of live data in the heap (incliudes large + compact data). Updated after every GC. Data in uncollected generations (in minor GCs) are considered live.</source>
          <target state="translated">ヒープ内のライブデータの総量(ラージデータ+コンパクトデータを含む)。GC 毎に更新される。収集されていない世代(マイナーGC)のデータはライブデータとみなされる。</target>
        </trans-unit>
        <trans-unit id="2439e747cf079533fc119f7f3372deeb2e6b3e0c" translate="yes" xml:space="preserve">
          <source>Total amount of memory in use by the RTS</source>
          <target state="translated">RTSが使用しているメモリの総量</target>
        </trans-unit>
        <trans-unit id="ae1cf3a5225a7fa4703cee57bd8a99cfbdc1fa37" translate="yes" xml:space="preserve">
          <source>Total amount of slop (wasted memory)</source>
          <target state="translated">スロップの総量(メモリの無駄遣い</target>
        </trans-unit>
        <trans-unit id="381d3d3026564b15b98332086f85db8c9c5116c1" translate="yes" xml:space="preserve">
          <source>Total bytes allocated</source>
          <target state="translated">割り当てられた総バイト数</target>
        </trans-unit>
        <trans-unit id="7ddb5932284e85cdb998a88ee61c45b3fb084550" translate="yes" xml:space="preserve">
          <source>Total elapsed time (at the previous GC)</source>
          <target state="translated">総経過時間(前回GC時</target>
        </trans-unit>
        <trans-unit id="5176bda3a891825313e991007cfcf6a2dfe321e1" translate="yes" xml:space="preserve">
          <source>Total elapsed time used by the GC</source>
          <target state="translated">GCで使用した総経過時間</target>
        </trans-unit>
        <trans-unit id="a76b13b30e1f96d1561f8aba9418764cdf896ec9" translate="yes" xml:space="preserve">
          <source>Total elapsed time used by the init phase @since 4.12.0.0</source>
          <target state="translated">4.12.0.0.0以降のinitフェーズで使用された総経過時間</target>
        </trans-unit>
        <trans-unit id="f8dffa4e4bface78bbc47de7cc9c4f635615fd39" translate="yes" xml:space="preserve">
          <source>Total elapsed time used by the mutator</source>
          <target state="translated">突然変異体が使用した総経過時間</target>
        </trans-unit>
        <trans-unit id="c702e8f0d2bf491124a83b3aba7ca49be01b7437" translate="yes" xml:space="preserve">
          <source>Total number of GCs</source>
          <target state="translated">GCの総数</target>
        </trans-unit>
        <trans-unit id="f31fc901ada0fd73f4d6d8746668c45f8b841486" translate="yes" xml:space="preserve">
          <source>Total number of major (oldest generation) GCs</source>
          <target state="translated">主要(旧世代)GCの総数</target>
        </trans-unit>
        <trans-unit id="5d0fb43e49fcfea4980958defc073241b65ca7be" translate="yes" xml:space="preserve">
          <source>Total width of the field.</source>
          <target state="translated">フィールドの全幅。</target>
        </trans-unit>
        <trans-unit id="2f38169a712e499b917900e244feafc980a814f4" translate="yes" xml:space="preserve">
          <source>Trace</source>
          <target state="translated">Trace</target>
        </trans-unit>
        <trans-unit id="26f445c1d8b2f4e101fdf56e72eb92189d409de2" translate="yes" xml:space="preserve">
          <source>Trace exhaustiveness checker</source>
          <target state="translated">トレース網羅性チェッカ</target>
        </trans-unit>
        <trans-unit id="8d94ec6e077733db6938cd196aa7260c918b123b" translate="yes" xml:space="preserve">
          <source>Trace interface files</source>
          <target state="translated">インタフェースファイルをトレースする</target>
        </trans-unit>
        <trans-unit id="fdbe7d47032190e46bbad6a5b35e468fcdd74e5e" translate="yes" xml:space="preserve">
          <source>Trace renamer</source>
          <target state="translated">トレースリナマー</target>
        </trans-unit>
        <trans-unit id="b6912fb740cfa5def4327273bd86af0baeb5f9b4" translate="yes" xml:space="preserve">
          <source>Trace runtime type inference</source>
          <target state="translated">トレース実行時の型推論</target>
        </trans-unit>
        <trans-unit id="ea97ebbaf9290aacc9db9230d7d8410a1b17dde1" translate="yes" xml:space="preserve">
          <source>Trace runtime type inference done by various interpreter commands.</source>
          <target state="translated">各種インタプリタコマンドで実行時の型推論をトレースします。</target>
        </trans-unit>
        <trans-unit id="918226cc8c88c96d88772b200fb277ce2462c0b2" translate="yes" xml:space="preserve">
          <source>Trace typechecker</source>
          <target state="translated">タイペチェッカートレース</target>
        </trans-unit>
        <trans-unit id="cac5cce622b33dcb41c89b31f1cab4a7d79e4ee1" translate="yes" xml:space="preserve">
          <source>Trace.Hpc.Mix</source>
          <target state="translated">Trace.Hpc.Mix</target>
        </trans-unit>
        <trans-unit id="4dc37d38ccb40ad731bd6b735a3d79a901047644" translate="yes" xml:space="preserve">
          <source>Trace.Hpc.Tix</source>
          <target state="translated">Trace.Hpc.Tix</target>
        </trans-unit>
        <trans-unit id="b9911dc4ca5e0e643713d12b25be14491d441daa" translate="yes" xml:space="preserve">
          <source>Trace.Hpc.Util</source>
          <target state="translated">Trace.Hpc.Util</target>
        </trans-unit>
        <trans-unit id="0ce5cee6755ef940551826d010c5c2ba3528d3db" translate="yes" xml:space="preserve">
          <source>TraceEventLog</source>
          <target state="translated">TraceEventLog</target>
        </trans-unit>
        <trans-unit id="8255bba6a712a935f53931169349c3bf3667e4e7" translate="yes" xml:space="preserve">
          <source>TraceFlags</source>
          <target state="translated">TraceFlags</target>
        </trans-unit>
        <trans-unit id="f45cd5da920597cccb919c43b85883e95c0eb5ba" translate="yes" xml:space="preserve">
          <source>TraceNone</source>
          <target state="translated">TraceNone</target>
        </trans-unit>
        <trans-unit id="95797df6040c41d1f62d4c30f5d575a3fde2b6e0" translate="yes" xml:space="preserve">
          <source>TraceStderr</source>
          <target state="translated">TraceStderr</target>
        </trans-unit>
        <trans-unit id="68c508431455ff22684105af9cb2ecc131f7e321" translate="yes" xml:space="preserve">
          <source>Tracing</source>
          <target state="translated">Tracing</target>
        </trans-unit>
        <trans-unit id="ee76b0788bcc9e4d134c6e63c0f905595d53f415" translate="yes" xml:space="preserve">
          <source>Traditional record syntax, such as &lt;code&gt;C {f = x}&lt;/code&gt;, is enabled by default. To disable it, you can use the &lt;a href=&quot;#extension-NoTraditionalRecordSyntax&quot;&gt;&lt;code&gt;NoTraditionalRecordSyntax&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="translated">&lt;code&gt;C {f = x}&lt;/code&gt; などの従来のレコード構文は、デフォルトで有効になっています。これを無効にするには、&lt;a href=&quot;#extension-NoTraditionalRecordSyntax&quot;&gt; &lt;code&gt;NoTraditionalRecordSyntax&lt;/code&gt; &lt;/a&gt;拡張機能を使用できます。</target>
        </trans-unit>
        <trans-unit id="e945a1a9931ffbae11e35d8dc13f62ffcd7e4996" translate="yes" xml:space="preserve">
          <source>TraditionalRecordSyntax</source>
          <target state="translated">TraditionalRecordSyntax</target>
        </trans-unit>
        <trans-unit id="07d54591052808d7665525ab9d03e9a8e6047941" translate="yes" xml:space="preserve">
          <source>Trailing slash functions</source>
          <target state="translated">後続スラッシュ関数</target>
        </trans-unit>
        <trans-unit id="5a701b108c7ddd010bd4e5e1046abd3e059fbfcd" translate="yes" xml:space="preserve">
          <source>Transactional variables.</source>
          <target state="translated">トランザクション変数。</target>
        </trans-unit>
        <trans-unit id="c6bd77f69d4cdf801791ad51b3a5613597cd452f" translate="yes" xml:space="preserve">
          <source>Transform any exceptions thrown by the computation using the given function (a specialization of &lt;code&gt;&lt;a href=&quot;control-monad-except#v:withExceptT&quot;&gt;withExceptT&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">指定された関数を使用して、計算によってスローされたすべての例外を変換します（ &lt;code&gt;&lt;a href=&quot;control-monad-except#v:withExceptT&quot;&gt;withExceptT&lt;/a&gt;&lt;/code&gt; の特殊化）。</target>
        </trans-unit>
        <trans-unit id="aefaf0cd8aa07449321af97629ce4b3770e62358" translate="yes" xml:space="preserve">
          <source>Transform any exceptions thrown by the computation using the given function (a specialization of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:withExceptT&quot;&gt;withExceptT&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">指定された関数を使用して、計算によってスローされたすべての例外を変換します（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:withExceptT&quot;&gt;withExceptT&lt;/a&gt;&lt;/code&gt; の特殊化）。</target>
        </trans-unit>
        <trans-unit id="a4e682fcac2a4512b74e3dc63612d9586743f8e8" translate="yes" xml:space="preserve">
          <source>Transform any exceptions thrown by the computation using the given function.</source>
          <target state="translated">与えられた関数を使用して計算によってスローされた例外を変換します。</target>
        </trans-unit>
        <trans-unit id="4578ae8d733586d0310337c8b520cee638a41571" translate="yes" xml:space="preserve">
          <source>Transform comprehensions</source>
          <target state="translated">理解力の変換</target>
        </trans-unit>
        <trans-unit id="6d9379f1a17e7f9d27b049266346529304db629e" translate="yes" xml:space="preserve">
          <source>Transform statements (as with &lt;a href=&quot;#extension-TransformListComp&quot;&gt;&lt;code&gt;TransformListComp&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">（と同じように文を変換&lt;a href=&quot;#extension-TransformListComp&quot;&gt; &lt;code&gt;TransformListComp&lt;/code&gt; &lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="34bbbf0593112d8021164739182249451cd348ed" translate="yes" xml:space="preserve">
          <source>Transform the computation inside a &lt;code&gt;MaybeT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MaybeT&lt;/code&gt; 内の計算を変換します。</target>
        </trans-unit>
        <trans-unit id="8e3add4bdcd20865c3718142bc9551385a370674" translate="yes" xml:space="preserve">
          <source>Transform the computation inside a &lt;code&gt;ReaderT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ReaderT&lt;/code&gt; 内の計算を変換します。</target>
        </trans-unit>
        <trans-unit id="d94f891243caad66af3028997e36082e6d8dd8dc" translate="yes" xml:space="preserve">
          <source>Transform the value returned by a &lt;code&gt;Reader&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Reader&lt;/code&gt; から返された値を変換します。</target>
        </trans-unit>
        <trans-unit id="529ddea17b3a6fb911dfd08011006b0a6dba6150" translate="yes" xml:space="preserve">
          <source>TransformListComp</source>
          <target state="translated">TransformListComp</target>
        </trans-unit>
        <trans-unit id="28382f411cec0cea1fa0d72a330aaf42ace1a9fe" translate="yes" xml:space="preserve">
          <source>Transformation of at least one immediate subterm does not fail</source>
          <target state="translated">少なくとも1つの即時サブタームの変換は失敗しません。</target>
        </trans-unit>
        <trans-unit id="6553c0c77ccd33d074aee1942550fc0f472cd3f4" translate="yes" xml:space="preserve">
          <source>Transformation of one immediate subterm with success</source>
          <target state="translated">成功すると1つの即席サブタームの変換</target>
        </trans-unit>
        <trans-unit id="d685ad7c59aeb1945ef867b52857539b62c1b81c" translate="yes" xml:space="preserve">
          <source>Transformations</source>
          <target state="translated">Transformations</target>
        </trans-unit>
        <trans-unit id="bc40fc64b9787d7dac7665e7c80ced3be2f64e6a" translate="yes" xml:space="preserve">
          <source>Transformer class</source>
          <target state="translated">トランスクラス</target>
        </trans-unit>
        <trans-unit id="12656556988bc57237e887a0b3bd66131be270a9" translate="yes" xml:space="preserve">
          <source>Transforming ByteStrings</source>
          <target state="translated">ByteStringsの変換</target>
        </trans-unit>
        <trans-unit id="64733f4060672520e5c156055aa404b5a2fff0ad" translate="yes" xml:space="preserve">
          <source>Transforms a parser into one that does the same, but in addition returns the exact characters read. IMPORTANT NOTE: &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:gather&quot;&gt;gather&lt;/a&gt;&lt;/code&gt; gives a runtime error if its first argument is built using any occurrences of readS_to_P.</source>
          <target state="translated">パーサーを同じ処理を行うパーサーに変換しますが、さらに、読み取られた正確な文字を返します。重要な注意：最初の引数がreadS_to_Pの発生を使用して構築されている場合、 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:gather&quot;&gt;gather&lt;/a&gt;&lt;/code&gt; は実行時エラーを発生させます。</target>
        </trans-unit>
        <trans-unit id="8f321ea579e546977788ec7503fb201f9808151b" translate="yes" xml:space="preserve">
          <source>Transitional module providing the &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; class and primitive instances.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; クラスとプリミティブインスタンスを提供する移行モジュール。</target>
        </trans-unit>
        <trans-unit id="cf6c281c3321c220a2860f225e26547c6663a008" translate="yes" xml:space="preserve">
          <source>Transitivity</source>
          <target state="translated">Transitivity</target>
        </trans-unit>
        <trans-unit id="7bd7baf126db335320e85434af814c47329f4fb9" translate="yes" xml:space="preserve">
          <source>Transitivity of equality</source>
          <target state="translated">平等性の推移</target>
        </trans-unit>
        <trans-unit id="ee21a36234c54ae6acecacce32dde8221553c2ab" translate="yes" xml:space="preserve">
          <source>Transitivity of representational equality</source>
          <target state="translated">表現上の平等性の推移</target>
        </trans-unit>
        <trans-unit id="e98e003d090d824a54f132e10d2d3a1b2abb08a4" translate="yes" xml:space="preserve">
          <source>TransliterateCodingFailure</source>
          <target state="translated">TransliterateCodingFailure</target>
        </trans-unit>
        <trans-unit id="9dcc95f8a9883fb6fa511276e0d2f0bd822f6472" translate="yes" xml:space="preserve">
          <source>TransmitStart</source>
          <target state="translated">TransmitStart</target>
        </trans-unit>
        <trans-unit id="d2cf87c31932f3da157ec8f3b86b864b9e7f88fd" translate="yes" xml:space="preserve">
          <source>TransmitStop</source>
          <target state="translated">TransmitStop</target>
        </trans-unit>
        <trans-unit id="59ababde52e8e86da31349f66a50ec3bb7819a93" translate="yes" xml:space="preserve">
          <source>Travel back ⟨n⟩ steps in the history. ⟨n⟩ is one if omitted. See &lt;a href=&quot;#tracing&quot;&gt;Tracing and history&lt;/a&gt; for more about GHCi&amp;rsquo;s debugging facilities. See also: &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:history&quot;&gt;&lt;code&gt;:history&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:forward&quot;&gt;&lt;code&gt;:forward&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">歴史の「n」歩を遡ります。省略した場合、「n」は1です。GHCiのデバッグ機能の詳細については、&lt;a href=&quot;#tracing&quot;&gt;トレースと履歴&lt;/a&gt;を参照してください。&lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#ghci-cmd-:history&quot;&gt; &lt;code&gt;:history&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#ghci-cmd-:forward&quot;&gt; &lt;code&gt;:forward&lt;/code&gt; &lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="b795f17232474b10e4eb05eb081a307e9d9dfa5d" translate="yes" xml:space="preserve">
          <source>Traversable</source>
          <target state="translated">Traversable</target>
        </trans-unit>
        <trans-unit id="9c8ab9d8f52e3cebde865983061e92e1572d8906" translate="yes" xml:space="preserve">
          <source>Traversal</source>
          <target state="translated">Traversal</target>
        </trans-unit>
        <trans-unit id="7b1817a217845dfc3e24c8c230b82767b4c56356" translate="yes" xml:space="preserve">
          <source>Traverse from right to left.</source>
          <target state="translated">右から左にトラバース。</target>
        </trans-unit>
        <trans-unit id="977ae6d655ca9f1978129e8ccbfa10a6559b3561" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">他のマップからキーが欠落しているエントリーをトラバースし、オプションで結果に含める値を生成します。これは最も強力な &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 戦術ですが、他の方が通常はより効率的です。</target>
        </trans-unit>
        <trans-unit id="5e48e3b92b1820252cbfde816e12e1a271b17cb1" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">他のマップからキーが欠落しているエントリーをトラバースし、オプションで結果に含める値を生成します。これは最も強力な &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 戦術ですが、他の方が通常はより効率的です。</target>
        </trans-unit>
        <trans-unit id="b18e053b42f93b44a5abf294af55c3136c4f408d" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">他のマップからキーが欠落しているエントリーをトラバースし、オプションで結果に含める値を生成します。これは最も強力な &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 戦術ですが、他の方が通常はより効率的です。</target>
        </trans-unit>
        <trans-unit id="7200db17563eaefb9847d8db2d6e8155f2a4676c" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">他のマップからキーが欠落しているエントリーをトラバースし、オプションで結果に含める値を生成します。これは最も強力な &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 戦術ですが、他の方が通常はより効率的です。</target>
        </trans-unit>
        <trans-unit id="d03af00b13b95140684e72553fba4a01106b42c9" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map.</source>
          <target state="translated">他のマップからキーが見つからないエントリの上を移動します。</target>
        </trans-unit>
        <trans-unit id="30dc152103c6133db322f634f929327d30f349a1" translate="yes" xml:space="preserve">
          <source>Traverses in order of increasing key.</source>
          <target state="translated">キーの高い順にトラバースします。</target>
        </trans-unit>
        <trans-unit id="7e92b229a11c1c4e925555ecc443d546f7203f39" translate="yes" xml:space="preserve">
          <source>Treat &lt;code&gt;*&lt;/code&gt; as &lt;code&gt;Data.Kind.Type&lt;/code&gt;.</source>
          <target state="translated">トリート &lt;code&gt;*&lt;/code&gt; として &lt;code&gt;Data.Kind.Type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd46d6f300df9c79faeae4e756e06e57fe755cd8" translate="yes" xml:space="preserve">
          <source>Treat the unqualified uses of the &lt;code&gt;*&lt;/code&gt; type operator as nullary and desugar to &lt;code&gt;Data.Kind.Type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 型演算子の修飾されていない使用をnullとして扱い、Data.Kind.Typeを &lt;code&gt;Data.Kind.Type&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="99f5ff6378a0b48f815677894306b090ee036726" translate="yes" xml:space="preserve">
          <source>Tree</source>
          <target state="translated">Tree</target>
        </trans-unit>
        <trans-unit id="1e7081d736f43ad30574ac906d26acdd03c38ed9" translate="yes" xml:space="preserve">
          <source>Trees</source>
          <target state="translated">Trees</target>
        </trans-unit>
        <trans-unit id="d6ebaccbb7b2994140dcf46fc8cbd5a71b52292c" translate="yes" xml:space="preserve">
          <source>Trees and Forests</source>
          <target state="translated">樹木と森林</target>
        </trans-unit>
        <trans-unit id="d1f88855d73f9050543090a479c62b476a835f18" translate="yes" xml:space="preserve">
          <source>Tried to encode a character that could not be represented under the given encoding, or ran out of input in mid-encode.</source>
          <target state="translated">与えられたエンコーディングで表現できない文字をエンコードしようとしたか、エンコードの途中で入力がなくなった。</target>
        </trans-unit>
        <trans-unit id="dcf41f4658aee61513347d3d72256ba068f1cb3d" translate="yes" xml:space="preserve">
          <source>Tries to find the definition site of the name at the given source-code span, e.g.:</source>
          <target state="translated">指定されたソースコードスパンで名前の定義サイトを探します。</target>
        </trans-unit>
        <trans-unit id="6d6761d1d070e2158059fdae1344762916cfe5cd" translate="yes" xml:space="preserve">
          <source>Triggers an immediate major garbage collection.</source>
          <target state="translated">すぐにメジャーなゴミ収集をトリガします。</target>
        </trans-unit>
        <trans-unit id="5211c258ae504b8bbd5a65143e1ffaccbfaf5d21" translate="yes" xml:space="preserve">
          <source>Triggers an immediate minor garbage collection.</source>
          <target state="translated">すぐにマイナーなゴミ収集をトリガします。</target>
        </trans-unit>
        <trans-unit id="97bfbacf53c224ce01bb87815c2b91e603df8ea4" translate="yes" xml:space="preserve">
          <source>Trigonometric and hyperbolic functions and related functions.</source>
          <target state="translated">三角関数・双曲線関数とその関連関数。</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">True</target>
        </trans-unit>
        <trans-unit id="6842273367fb0a7314d3db77e80a4246de4d0209" translate="yes" xml:space="preserve">
          <source>True &lt;a href=&quot;=&quot;&gt;=&lt;/a&gt; &quot;compact all the time&quot;</source>
          <target state="translated">True &lt;a href=&quot;=&quot;&gt;=&lt;/a&gt;「常にコンパクト」</target>
        </trans-unit>
        <trans-unit id="ff0a01862c74c77c6757cf7463f92a3698aca6ec" translate="yes" xml:space="preserve">
          <source>Truncate the destination file and then copy the contents of the source file to the destination file. If the destination file already exists, its attributes shall remain unchanged. Otherwise, its attributes are reset to the defaults.</source>
          <target state="translated">宛先ファイルを切り捨て、ソースファイルの内容を宛先ファイルにコピーする。コピー先のファイルが既に存在する場合、その属性は変更されない。そうでない場合は、その属性はデフォルトにリセットされる。</target>
        </trans-unit>
        <trans-unit id="b645724bb0724739a37a0f389e05496a29a993a0" translate="yes" xml:space="preserve">
          <source>Truncates &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; to least-significant &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; を最下位の整数に切り捨てます &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4191815c130347968d06550006d8bef069d5483" translate="yes" xml:space="preserve">
          <source>Truncates a &lt;code&gt;Double#&lt;/code&gt; value to the nearest &lt;code&gt;Int#&lt;/code&gt;. Results are undefined if the truncation if truncation yields a value outside the range of &lt;code&gt;Int#&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Double#&lt;/code&gt; 値を最も近い &lt;code&gt;Int#&lt;/code&gt; に切り捨てます。切り捨てにより &lt;code&gt;Int#&lt;/code&gt; の範囲外の値が生成される場合、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="7f6d495ffdebdce795d559dc7a00814f02a9ed4a" translate="yes" xml:space="preserve">
          <source>Truncates a &lt;code&gt;Float#&lt;/code&gt; value to the nearest &lt;code&gt;Int#&lt;/code&gt;. Results are undefined if the truncation if truncation yields a value outside the range of &lt;code&gt;Int#&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Float#&lt;/code&gt; 値を最も近い &lt;code&gt;Int#&lt;/code&gt; に切り捨てます。切り捨てにより &lt;code&gt;Int#&lt;/code&gt; の範囲外の値が生成される場合、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="c24171999adb97c4a8f884ec45a305760feb8353" translate="yes" xml:space="preserve">
          <source>Truncates the file down to the specified length. If the file was larger than the given length before this operation was performed the extra is lost.</source>
          <target state="translated">ファイルを指定した長さまで切り詰めます。この操作が実行される前にファイルの長さが指定された長さよりも大きかった場合、余分なものは失われます。</target>
        </trans-unit>
        <trans-unit id="e5062783e7bc3741e7a3f6f2e923c1f2ca0f5891" translate="yes" xml:space="preserve">
          <source>Trust the used plugins and no longer mark the compiled module as unsafe</source>
          <target state="translated">使用されているプラグインを信頼し、コンパイルされたモジュールを安全でないものとしてマークしないようにする</target>
        </trans-unit>
        <trans-unit id="4bc4bdf5385df47149206feaa36c849748d83b64" translate="yes" xml:space="preserve">
          <source>Trustworthy</source>
          <target state="translated">Trustworthy</target>
        </trans-unit>
        <trans-unit id="c3d3c6266583689c8044755f6755946b22e2e727" translate="yes" xml:space="preserve">
          <source>Try alternatives in the same order as &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; と同じ順序で代替案を試してください。</target>
        </trans-unit>
        <trans-unit id="649615639f9b9c6ba5bc23c5c62fdf483263edda" translate="yes" xml:space="preserve">
          <source>Try downcasting &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; value. Returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if value doesn't fit in &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 値にダウンキャストしてみてください。値が &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; に適合しない場合は &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="9f32a8bcb3ae56ab6fee54ca560a7075df79e35e" translate="yes" xml:space="preserve">
          <source>Try to use local disks when linking:</source>
          <target state="translated">リンクするときはローカルディスクを使うようにしましょう。</target>
        </trans-unit>
        <trans-unit id="42e43b612a5dfae57ddf5929f0fb945ae83cbf61" translate="yes" xml:space="preserve">
          <source>Tuesday</source>
          <target state="translated">Tuesday</target>
        </trans-unit>
        <trans-unit id="0fae6c283b56ecb589a1f52cbd69ed8461516cd4" translate="yes" xml:space="preserve">
          <source>Tuple data constructor</source>
          <target state="translated">タプルデータコンストラクタ</target>
        </trans-unit>
        <trans-unit id="fe995f3be3d2ff04b4539a5c33f7f5265c5ec905" translate="yes" xml:space="preserve">
          <source>Tuple type constructor</source>
          <target state="translated">タプル型コンストラクタ</target>
        </trans-unit>
        <trans-unit id="f3571e8acb567c55596ec89e11c3c7590fcd1efb" translate="yes" xml:space="preserve">
          <source>Tuple types. When a non-unit tuple is used on the right-hand side of a data declaration, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; treats it as a product of distinct types. In other words, the following code:</source>
          <target state="translated">タプルのタイプ。非ユニットタプルがデータ宣言の右側で使用されると、&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;はそれを特殊タイプの積として扱います。つまり、次のコードです。</target>
        </trans-unit>
        <trans-unit id="07bc188bc9976952fc0cc95ef067281f658cb805" translate="yes" xml:space="preserve">
          <source>TupleSections</source>
          <target state="translated">TupleSections</target>
        </trans-unit>
        <trans-unit id="538a8ce3fbdcaee00a14353bd57bcf3600c6e0d0" translate="yes" xml:space="preserve">
          <source>Tuples</source>
          <target state="translated">Tuples</target>
        </trans-unit>
        <trans-unit id="0090b6abe499cb5c3a21cf4b91f82b1dc060fb8b" translate="yes" xml:space="preserve">
          <source>Tuples are currently limited to size 100. However, standard instances for tuples (&lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt;) are available &lt;em&gt;only&lt;/em&gt; up to 16-tuples.</source>
          <target state="translated">現在、タプルのサイズは100に制限されています。ただし、タプルの標準インスタンス（ &lt;code&gt;Eq&lt;/code&gt; 、 &lt;code&gt;Ord&lt;/code&gt; 、 &lt;code&gt;Bounded&lt;/code&gt; 、 &lt;code&gt;Ix&lt;/code&gt; 、 &lt;code&gt;Read&lt;/code&gt; 、および &lt;code&gt;Show&lt;/code&gt; ）は&lt;em&gt;、&lt;/em&gt;最大16タプルで&lt;em&gt;のみ&lt;/em&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="eb72a46d788e7aaf184a3a1b039183884ebc8ddf" translate="yes" xml:space="preserve">
          <source>Tuples, all of whose component types have kind &lt;code&gt;Constraint&lt;/code&gt;. So for example the type &lt;code&gt;(Show a, Ord a)&lt;/code&gt; is of kind &lt;code&gt;Constraint&lt;/code&gt;.</source>
          <target state="translated">タプル。すべてのコンポーネントタイプの種類は &lt;code&gt;Constraint&lt;/code&gt; です。たとえば、タイプ &lt;code&gt;(Show a, Ord a)&lt;/code&gt; の種類は &lt;code&gt;Constraint&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="208297b00f068e5585208c000785f0fce4f36c23" translate="yes" xml:space="preserve">
          <source>Tuples, lists, &lt;code&gt;Maybe&lt;/code&gt;, and all the other types from &lt;code&gt;Prelude&lt;/code&gt; continue to have their existing, lazy, semantics.</source>
          <target state="translated">タプル、リスト、 &lt;code&gt;Maybe&lt;/code&gt; 、および &lt;code&gt;Prelude&lt;/code&gt; の他のすべてのタイプは、既存の遅延したセマンティクスを持ち続けます。</target>
        </trans-unit>
        <trans-unit id="253a3d85a1beb3288a473dc352f001b3960133ba" translate="yes" xml:space="preserve">
          <source>Turn &lt;em&gt;off&lt;/em&gt; &amp;ldquo;update-frame squeezing&amp;rdquo; at garbage-collection time. (There&amp;rsquo;s no particularly good reason to turn it off, except to ensure the accuracy of certain data collected regarding thunk entry counts.)</source>
          <target state="translated">ターン&lt;em&gt;オフ&lt;/em&gt;ガベージコレクション時に「更新フレームの絞りを」。（サンクエントリ数に関して収集された特定のデータの正確さを保証する場合を除いて、これをオフにする特別な理由はありません。）</target>
        </trans-unit>
        <trans-unit id="275633f17b4e4cf83d036cacf3592d3d73e3ed05" translate="yes" xml:space="preserve">
          <source>Turn &lt;em&gt;off&lt;/em&gt; update frame squeezing on context switch. (There&amp;rsquo;s no particularly good reason to turn it off, except to ensure the accuracy of certain data collected regarding thunk entry counts.)</source>
          <target state="translated">ターン&lt;em&gt;オフ&lt;/em&gt;コンテキストスイッチに絞る更新フレームを。（サンクエントリ数に関して収集された特定のデータの正確性を確保する場合を除いて、オフにする理由は特にありません。）</target>
        </trans-unit>
        <trans-unit id="46ed6208974a650db0bd1f82cc0c70d6411a0c0e" translate="yes" xml:space="preserve">
          <source>Turn a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; into its initial &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">ターン &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; をその初期に &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; のアクション。</target>
        </trans-unit>
        <trans-unit id="99920f5c3b939caebceea45731d8b9d3427458f2" translate="yes" xml:space="preserve">
          <source>Turn a value into a Template Haskell expression, suitable for use in a splice.</source>
          <target state="translated">スプライスでの使用に適した値をHaskell式に変換します。</target>
        </trans-unit>
        <trans-unit id="18c10b159949d028b9e59ba53a57b08c8fed29bf" translate="yes" xml:space="preserve">
          <source>Turn an existing Handle into a file descriptor. This function throws an IOError if the Handle does not reference a file descriptor.</source>
          <target state="translated">既存のHandleをファイルディスクリプタに変換します。この関数は、Handleがファイル記述子を参照していない場合にIOErrorをスローします。</target>
        </trans-unit>
        <trans-unit id="ff88efd554e6e2bbf0d6b57ed109bd14bff32a19" translate="yes" xml:space="preserve">
          <source>Turn an existing file descriptor into a Handle. This is used by various external libraries to make Handles.</source>
          <target state="translated">既存のファイル記述子をハンドルにします。これは、様々な外部ライブラリでハンドルを作るために使用されます。</target>
        </trans-unit>
        <trans-unit id="af1ea6cee0d8a6d561bf79d4ae3fe34c934b40bb" translate="yes" xml:space="preserve">
          <source>Turn off pre-inlining</source>
          <target state="translated">プリインラインをオフにする</target>
        </trans-unit>
        <trans-unit id="d635f6906b908f74109d28ae4ecba3d5b4cf43a2" translate="yes" xml:space="preserve">
          <source>Turn off pre-inlining.</source>
          <target state="translated">プリインラインをオフにします。</target>
        </trans-unit>
        <trans-unit id="17471888502443f29d90093ff7b1d13417c48663" translate="yes" xml:space="preserve">
          <source>Turn off recompilation checking (which is on by default). Recompilation checking normally stops compilation early, leaving an existing &lt;code&gt;.o&lt;/code&gt; file in place, if it can be determined that the module does not need to be recompiled.</source>
          <target state="translated">再コンパイルチェックをオフにします（デフォルトでオンになっています）。モジュールを再コンパイルする必要がないと判断できる場合、通常、再コンパイルチェックはコンパイルを早期に停止し、既存の &lt;code&gt;.o&lt;/code&gt; ファイルを残します。</target>
        </trans-unit>
        <trans-unit id="d295e654c968e0d4b5d4ef28970645ceb9c359bd" translate="yes" xml:space="preserve">
          <source>Turn off recompilation checking. This is implied by any &lt;code&gt;-ddump-X&lt;/code&gt; option when compiling a single file (i.e. when using &lt;a href=&quot;using#ghc-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">再コンパイルチェックをオフにします。これは、単一のファイルをコンパイルするとき（つまり&lt;a href=&quot;using#ghc-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt;を使用するとき）の &lt;code&gt;-ddump-X&lt;/code&gt; オプションによって暗示されます。</target>
        </trans-unit>
        <trans-unit id="2df7c8ae29045092a74a14419fbf30ce0ab66412" translate="yes" xml:space="preserve">
          <source>Turn off the &amp;ldquo;state hack&amp;rdquo; whereby any lambda with a &lt;code&gt;State#&lt;/code&gt; token as argument is considered to be single-entry, hence it is considered okay to inline things inside it. This can improve performance of IO and ST monad code, but it runs the risk of reducing sharing.</source>
          <target state="translated">「ステートハック」をオフにします。これにより、引数として &lt;code&gt;State#&lt;/code&gt; トークンを持つラムダは単一エントリと見なされるため、その中にインライン化しても問題ありません。これにより、IOおよびSTモナドコードのパフォーマンスが向上しますが、共有が減少するリスクがあります。</target>
        </trans-unit>
        <trans-unit id="2ac1f9d019e52ced1d3ffee3e78447b7c0abfbb4" translate="yes" xml:space="preserve">
          <source>Turn off the coercion optimiser</source>
          <target state="translated">強制オプティマイザーをオフにする</target>
        </trans-unit>
        <trans-unit id="950c5d36c7c13101044e5055d34314b1e36c7cb9" translate="yes" xml:space="preserve">
          <source>Turn off the coercion optimiser.</source>
          <target state="translated">強制オプティマイザーをオフにしてください。</target>
        </trans-unit>
        <trans-unit id="617258e85d1cdd0cc36e433c788af7fa7395a65e" translate="yes" xml:space="preserve">
          <source>Turn off the state hackwhereby any lambda with a real-world state token as argument is considered to be single-entry. Hence OK to inline things inside it.</source>
          <target state="translated">実世界の状態トークンを引数に持つラムダはシングルエントリとみなされるため、状態ハックをオフにします。したがって、その中でインライン化しても問題ありません。</target>
        </trans-unit>
        <trans-unit id="3910a508b92e090f15ab64efed4ef9b97e05635f" translate="yes" xml:space="preserve">
          <source>Turn on &lt;a href=&quot;using-concurrent#parallel-compile-options&quot;&gt;eager blackholing&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;using-concurrent#parallel-compile-options&quot;&gt;熱心なブラックホールを&lt;/a&gt;オンにする</target>
        </trans-unit>
        <trans-unit id="f3be189c27f12c1b88373ff10bdc50133feda7a8" translate="yes" xml:space="preserve">
          <source>Turn on CPR analysis in the demand analyser.</source>
          <target state="translated">デマンドアナライザーでCPR分析をオンにします。</target>
        </trans-unit>
        <trans-unit id="d6936ee375b84ce60a7c7670433d5b9d7fb09f4d" translate="yes" xml:space="preserve">
          <source>Turn on CPR analysis in the demand analyser. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">デマンドアナライザーでCPR分析をオンにします。&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;によって暗示されます。</target>
        </trans-unit>
        <trans-unit id="6d2e6cfb361c36aed029affd07ffbc2b96c57b78" translate="yes" xml:space="preserve">
          <source>Turn on Haskell program coverage instrumentation</source>
          <target state="translated">Haskellプログラムのカバレッジ・インスツルメンテーションをオンにする</target>
        </trans-unit>
        <trans-unit id="ce336f3c3e1aa6fd90aca25447fdfc1e39c9de85" translate="yes" xml:space="preserve">
          <source>Turn on call-pattern specialisation; see &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/&quot;&gt;Call-pattern specialisation for Haskell programs&lt;/a&gt;.</source>
          <target state="translated">コールパターンの特殊化をオンにします。&lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/&quot;&gt;Haskellプログラムの呼び出しパターン特殊化を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c3a81a31f22fa4db1bc744fd067f81bd449e3b8f" translate="yes" xml:space="preserve">
          <source>Turn on debug printing (more verbose)</source>
          <target state="translated">デバッグ印刷をオンにする (詳細)</target>
        </trans-unit>
        <trans-unit id="296a0a179df472eb6abcb19de05eba23c2498ece" translate="yes" xml:space="preserve">
          <source>Turn on full laziness (floating bindings outwards). Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">完全な遅延をオンにします（バインディングを外側にフローティング）。&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;によって暗示されます。</target>
        </trans-unit>
        <trans-unit id="f318a6585e141f90a1614408fbe30c3ca88279fb" translate="yes" xml:space="preserve">
          <source>Turn on heavyweight intra-pass sanity-checking within GHC, at Core level. (It checks GHC&amp;rsquo;s sanity, not yours.)</source>
          <target state="translated">コアレベルで、GHC内のヘビーウェイトパス内サニティチェックをオンにします。（それはあなたのものではなくGHCの健全性をチェックします。）</target>
        </trans-unit>
        <trans-unit id="52b6e6db9093fbc620c1a86c60865336318286e8" translate="yes" xml:space="preserve">
          <source>Turn on internal sanity checking</source>
          <target state="translated">内部のサニティーチェックをオンにする</target>
        </trans-unit>
        <trans-unit id="83e49945c7e486aba50532474cfbb4c69f3506a7" translate="yes" xml:space="preserve">
          <source>Turn on printing of binding results in GHCi</source>
          <target state="translated">GHCiでの製本結果の印刷をオンにする</target>
        </trans-unit>
        <trans-unit id="95372a11f5d63bb2a5025a48e0b268c2ee7024be" translate="yes" xml:space="preserve">
          <source>Turn on profiling</source>
          <target state="translated">プロファイリングをオンにする</target>
        </trans-unit>
        <trans-unit id="9421cedd7efa973140e929983d758551f8869384" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions imported from other modules.</source>
          <target state="translated">他のモジュールからインポートしたオーバーロードされた関数の特殊化をオンにします。</target>
        </trans-unit>
        <trans-unit id="9a9361d3a422b8fd47b8bd6454e69dd2f06a3548" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions regardless of size, if unfolding is available</source>
          <target state="translated">アンフォールディングが可能な場合は、サイズに関係なくオーバーロードされた関数の特殊化をオンにします。</target>
        </trans-unit>
        <trans-unit id="50eb8d530729d72c17cbfb2d67f874f147b28848" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">オーバーロードされた関数の特殊化をオンにします。&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;によって暗示されます。</target>
        </trans-unit>
        <trans-unit id="186b5bba16e6ae8eb15a9abb5dd5b71128ae5773" translate="yes" xml:space="preserve">
          <source>Turn on strictness analysis. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;. Implies &lt;a href=&quot;using-optimisation#ghc-flag--fworker-wrapper&quot;&gt;&lt;code&gt;-fworker-wrapper&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">厳密性分析をオンにします。&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;によって暗示されます。意味&lt;a href=&quot;using-optimisation#ghc-flag--fworker-wrapper&quot;&gt; &lt;code&gt;-fworker-wrapper&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="83a88e24251094dd90ca7dd2a835cbafb1a5d02f" translate="yes" xml:space="preserve">
          <source>Turn on strictness analysis. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;. Implies &lt;code&gt;-fworker-wrapper&lt;/code&gt;</source>
          <target state="translated">厳密性分析をオンにします。&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;によって暗示されます。意味 &lt;code&gt;-fworker-wrapper&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3bbbce33819b3dde8561126caccd5c72c407adf7" translate="yes" xml:space="preserve">
          <source>Turn on the SpecConstr transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">SpecConstr変換をオンにします。&lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; &lt;/a&gt;によって暗示されます。</target>
        </trans-unit>
        <trans-unit id="2038c3131169ea1c711764a9caf8887658d5490a" translate="yes" xml:space="preserve">
          <source>Turn on the float-in transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">フロートイン変換をオンにします。&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;によって暗示されます。</target>
        </trans-unit>
        <trans-unit id="a3195d91b0f7c5107fbf8a4f3b68e117c0058d5a" translate="yes" xml:space="preserve">
          <source>Turn on the liberate-case transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">解放ケース変換をオンにします。&lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; &lt;/a&gt;によって暗示されます。</target>
        </trans-unit>
        <trans-unit id="d30dd0cd5415e1587f4f817ef17c1bfca9d1f69b" translate="yes" xml:space="preserve">
          <source>Turn on the liberate-case transformation. This unrolls recursive function once in its own RHS, to avoid repeated case analysis of free variables. It&amp;rsquo;s a bit like the call-pattern specialiser (&lt;a href=&quot;#ghc-flag--fspec-constr&quot;&gt;&lt;code&gt;-fspec-constr&lt;/code&gt;&lt;/a&gt;) but for free variables rather than arguments.</source>
          <target state="translated">解放ケース変換をオンにします。これは、それ自体のRHSで再帰関数を1回アンロールして、自由変数のケース分析が繰り返されるのを防ぎます。これは、呼び出しパターンの特殊化（&lt;a href=&quot;#ghc-flag--fspec-constr&quot;&gt; &lt;code&gt;-fspec-constr&lt;/code&gt; &lt;/a&gt;）に少し似ていますが、引数ではなく自由変数用です。</target>
        </trans-unit>
        <trans-unit id="fc206b146090aaae3538416928bdb40d73f8e572" translate="yes" xml:space="preserve">
          <source>Turn on the static argument transformation, which turns a recursive function into a non-recursive one with a local recursive loop. See Chapter 7 of &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/compilation-transformation-non-strict-functional-languages/&quot;&gt;Andre Santos&amp;rsquo;s PhD thesis&lt;/a&gt;.</source>
          <target state="translated">静的引数変換をオンにします。これは、再帰関数をローカルの再帰ループを持つ非再帰関数に変換します。&lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/compilation-transformation-non-strict-functional-languages/&quot;&gt;Andre Santosの博士論文の&lt;/a&gt;第7章を参照してください。</target>
        </trans-unit>
        <trans-unit id="97962db7cd6430dc4d9f003ab15c722eda521246" translate="yes" xml:space="preserve">
          <source>Turn on the static argument transformation.</source>
          <target state="translated">静的な引数変換をオンにします。</target>
        </trans-unit>
        <trans-unit id="c01e89e1f152c4c360440816f0458dd2cbcfd270" translate="yes" xml:space="preserve">
          <source>Turn on ticky-ticky profiling</source>
          <target state="translated">チクチクするプロファイリングをオンにする</target>
        </trans-unit>
        <trans-unit id="ce8a7e7e94d11356acccaca235f0a9548a974afc" translate="yes" xml:space="preserve">
          <source>Turn saturated self-recursive tail-calls into local jumps in the generated assembly. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">飽和した自己再帰末尾呼び出しを、生成されたアセンブリのローカルジャンプに変換します。&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;によって暗示されます。</target>
        </trans-unit>
        <trans-unit id="eafe423d4f61be7ed8a9e1ce23539a233dbf9f89" translate="yes" xml:space="preserve">
          <source>Turn type errors into warnings, &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;deferring the error until runtime&lt;/a&gt;. Implies &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt;&lt;code&gt;-Wdeferred-type-errors&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">タイプエラーを警告に変換し、&lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;実行時までエラーを延期します&lt;/a&gt;。意味&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt; &lt;code&gt;-Wdeferred-type-errors&lt;/code&gt; &lt;/a&gt;も参照してください</target>
        </trans-unit>
        <trans-unit id="325282e86f95818411656427e91d140f8bec6af3" translate="yes" xml:space="preserve">
          <source>Turning on an option that enables special syntax &lt;em&gt;might&lt;/em&gt; cause working Haskell 98 code to fail to compile, perhaps because it uses a variable name which has become a reserved word. This section lists the syntax that is &amp;ldquo;stolen&amp;rdquo; by language extensions. We use notation and nonterminal names from the Haskell 98 lexical syntax (see the Haskell 98 Report). We only list syntax changes here that might affect existing working programs (i.e. &amp;ldquo;stolen&amp;rdquo; syntax). Many of these extensions will also enable new context-free syntax, but in all cases programs written to use the new syntax would not be compilable without the option enabled.</source>
          <target state="translated">特別な構文を有効にするオプションをオンにすると、おそらく予約語になった変数名を使用しているために、機能しているHaskell 98コードのコンパイルが失敗する&lt;em&gt;可能性が&lt;/em&gt;あります。このセクションでは、言語拡張機能によって「盗まれる」構文をリストします。Haskell 98字句構文の表記法と非終端名を使用します（Haskell 98レポートを参照）。ここでは、既存の作業プログラムに影響を与える可能性のある構文の変更（つまり、「盗まれた」構文）のみをリストします。これらの拡張機能の多くは、新しいコンテキストフリー構文も有効にしますが、すべてのケースで、新しい構文を使用するように作成されたプログラムは、オプションを有効にしないとコンパイルできません。</target>
        </trans-unit>
        <trans-unit id="8c434400de1c5aa027fbd3740ce12b2df9419a40" translate="yes" xml:space="preserve">
          <source>Turning patterns into irrefutable ones requires &lt;code&gt;~(~p)&lt;/code&gt; or &lt;code&gt;(~ ~p)&lt;/code&gt; when &lt;code&gt;Strict&lt;/code&gt; is enabled.</source>
          <target state="translated">&lt;code&gt;Strict&lt;/code&gt; が有効になっている場合、パターンを反駁できないパターンに変換するには、 &lt;code&gt;~(~p)&lt;/code&gt; 〜p ）または &lt;code&gt;(~ ~p)&lt;/code&gt; 〜〜p）が必要です。</target>
        </trans-unit>
        <trans-unit id="08265f8e8519574753252d41f723fe67031d627d" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign object by associating a finalizer - given by the monadic operation - with the reference. The storage manager will start the finalizer, in a separate thread, some time after the last reference to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is dropped. There is no guarantee of promptness, and in fact there is no guarantee that the finalizer will eventually run at all.</source>
          <target state="translated">モナド演算によって与えられるファイナライザを参照に関連付けることにより、プレーンメモリ参照を外部オブジェクトに変換します。ストレージマネージャは、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; への最後の参照が削除されてからしばらくして、別のスレッドでファイナライザを開始します。迅速性の保証はなく、実際にはファイナライザーが最終的に実行される保証はありません。</target>
        </trans-unit>
        <trans-unit id="85564766611b55469be06dd366f3dfa26505bdd0" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign object by associating a finalizer - given by the monadic operation - with the reference. The storage manager will start the finalizer, in a separate thread, some time after the last reference to the &lt;code&gt;ForeignPtr&lt;/code&gt; is dropped. There is no guarantee of promptness, and in fact there is no guarantee that the finalizer will eventually run at all.</source>
          <target state="translated">モナド演算によって与えられるファイナライザを参照に関連付けることにより、プレーンメモリ参照を外部オブジェクトに変換します。ストレージマネージャは、 &lt;code&gt;ForeignPtr&lt;/code&gt; への最後の参照が削除されてからしばらくして、別のスレッドでファイナライザを開始します。迅速性の保証はなく、実際にはファイナライザーが最終的に実行される保証はありません。</target>
        </trans-unit>
        <trans-unit id="95d2eed85fb1f7986550657f2021b39f736f81e1" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">単純なメモリ参照を、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; を使用してファイナライザに関連付けることができる外部ポインタに変換します。</target>
        </trans-unit>
        <trans-unit id="607285583b9c293196a605c10473335ddbf1efa2" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">単純なメモリ参照を、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; を使用してファイナライザに関連付けることができる外部ポインタに変換します。</target>
        </trans-unit>
        <trans-unit id="b845b225e753bbeac9cefa8b2735a44df5615e44" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">単純なメモリ参照を、 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; を使用してファイナライザに関連付けることができる外部ポインタに変換します。</target>
        </trans-unit>
        <trans-unit id="209630eaf62c67416b251c558b35f54523d48fcd" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer, and associates a finalizer with the reference. The finalizer will be executed after the last reference to the foreign object is dropped. There is no guarantee of promptness, however the finalizer will be executed before the program exits.</source>
          <target state="translated">プレーンメモリ参照を外部ポインタに変換し、その参照にファイナライザを関連付けます。ファイナライザは、外部オブジェクトへの最後の参照が削除された後に実行されます。プロンプト性は保証されていませんが、プログラムが終了する前にファイナライザが実行されます。</target>
        </trans-unit>
        <trans-unit id="ebb6fb066f262607e7123212328b1299f8b3dfb9" translate="yes" xml:space="preserve">
          <source>Turns off all text attributes. This capability will always succeed, but it has no effect in terminals which do not support text attributes.</source>
          <target state="translated">すべてのテキスト属性をオフにする。この能力は常に成功しますが、テキスト属性をサポートしていない端末では効果がありません。</target>
        </trans-unit>
        <trans-unit id="862d4af3a0d0cf7e5a018fc476f97e10f1a9c942" translate="yes" xml:space="preserve">
          <source>Turns off all warnings, including the standard ones and those that &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t enable.</source>
          <target state="translated">標準のものと&lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt;が有効にしていないものを含むすべての警告をオフにします。</target>
        </trans-unit>
        <trans-unit id="c120f254c274d83af220fb98a2c7a05760369ad8" translate="yes" xml:space="preserve">
          <source>Turns on all warning options that indicate potentially suspicious code. The warnings that are &lt;em&gt;not&lt;/em&gt; enabled by &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; are</source>
          <target state="translated">潜在的に疑わしいコードを示すすべての警告オプションをオンにします。&lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; で&lt;/a&gt;有効になって&lt;em&gt;いない&lt;/em&gt;警告は、</target>
        </trans-unit>
        <trans-unit id="40f733631bb72a22e027222a199f94b3ab0cd6c2" translate="yes" xml:space="preserve">
          <source>Turns on bold mode before outputting the given text, and then turns all attributes off.</source>
          <target state="translated">与えられたテキストを出力する前に太字モードをオンにし、その後すべての属性をオフにします。</target>
        </trans-unit>
        <trans-unit id="67813ec19f0d115e1f945fcce60a3304e9742d7a" translate="yes" xml:space="preserve">
          <source>Turns on every single warning supported by the compiler.</source>
          <target state="translated">コンパイラがサポートするすべての警告をオンにします。</target>
        </trans-unit>
        <trans-unit id="712aa51fce57b7ec3c57639065bf9341454f6830" translate="yes" xml:space="preserve">
          <source>Turns on standout mode before outputting the given text, and then turns it off.</source>
          <target state="translated">与えられたテキストを出力する前にスタンドアウトモードをオンにし、その後オフにします。</target>
        </trans-unit>
        <trans-unit id="0e6f331bebb9604aed3b96d3a3c3888598136b3d" translate="yes" xml:space="preserve">
          <source>Turns on underline mode before outputting the given text, and then turns it off.</source>
          <target state="translated">与えられたテキストを出力する前にアンダーラインモードをオンにし、その後オフにします。</target>
        </trans-unit>
        <trans-unit id="86118d2f9d660a289256f279c1a5b872d4f80d3f" translate="yes" xml:space="preserve">
          <source>Turns on warnings that will be enabled by default in the future, but remain off in normal compilations for the time being. This allows library authors eager to make their code future compatible to adapt to new features before they even generate warnings.</source>
          <target state="translated">将来的にデフォルトで有効になりますが、通常のコンパイルでは当面オフのままの警告をオンにします。これにより、コードを将来的に互換性のあるものにしたいと考えているライブラリの作者は、警告を生成する前に新しい機能に適応することができます。</target>
        </trans-unit>
        <trans-unit id="ff28cc42f8a053998e917744dabc2b0418bf805a" translate="yes" xml:space="preserve">
          <source>Two command-line options control whether the startup files files are read:</source>
          <target state="translated">2つのコマンドラインオプションは、起動ファイルを読み込むかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="1ef6d52a2b612fed2aed21ed859ad1b8d21ad23d" translate="yes" xml:space="preserve">
          <source>Two things to watch out for:</source>
          <target state="translated">気をつけるべき2つのこと</target>
        </trans-unit>
        <trans-unit id="734286508752def272446ebf258e9a3edb931b88" translate="yes" xml:space="preserve">
          <source>Two types are considered apart if, for all possible substitutions, the types cannot reduce to a common reduct.</source>
          <target state="translated">2つのタイプは、すべての可能な置換について、そのタイプが共通の還元体に還元できない場合、離れているとみなされます。</target>
        </trans-unit>
        <trans-unit id="65740d677d61ed4bde9d4c583395253b786ef4c4" translate="yes" xml:space="preserve">
          <source>Two types of messages are produced: Those beginning with &lt;code&gt;***&lt;/code&gt; do denote the beginning of a compilation phase whereas those starting with &lt;code&gt;!!!&lt;/code&gt; mark the end of a pass and are accompanied by allocation and runtime statistics.</source>
          <target state="translated">2つのタイプのメッセージが生成されます。 &lt;code&gt;***&lt;/code&gt; で始まるメッセージはコンパイル段階の始まりを示しますが、 &lt;code&gt;!!!&lt;/code&gt; で始まるメッセージは!!! パスの終了をマークし、割り当てと実行時の統計を伴います。</target>
        </trans-unit>
        <trans-unit id="2abaa8beec76b5d77b798c536fa4b1107e5f57b3" translate="yes" xml:space="preserve">
          <source>TwoStopBits</source>
          <target state="translated">TwoStopBits</target>
        </trans-unit>
        <trans-unit id="d3ed034a0f2ac469546d42366627fbcd92794ceb" translate="yes" xml:space="preserve">
          <source>TyCon</source>
          <target state="translated">TyCon</target>
        </trans-unit>
        <trans-unit id="f54b069f499e1f9490d2d00a694470c28524dd84" translate="yes" xml:space="preserve">
          <source>TyLit</source>
          <target state="translated">TyLit</target>
        </trans-unit>
        <trans-unit id="f8f994fcfb248f32e675f0f4fa05671284ab679c" translate="yes" xml:space="preserve">
          <source>TyLitQ</source>
          <target state="translated">TyLitQ</target>
        </trans-unit>
        <trans-unit id="b3a7f451591028e9f2464430caf92564d0da6cb9" translate="yes" xml:space="preserve">
          <source>TySynEqn</source>
          <target state="translated">TySynEqn</target>
        </trans-unit>
        <trans-unit id="40dbe9290e904fbafc0107b863075e7c03c4405f" translate="yes" xml:space="preserve">
          <source>TySynEqnQ</source>
          <target state="translated">TySynEqnQ</target>
        </trans-unit>
        <trans-unit id="8e498318f3d478f740d1ba3b3f9b862f396efd9b" translate="yes" xml:space="preserve">
          <source>TyVarBndr</source>
          <target state="translated">TyVarBndr</target>
        </trans-unit>
        <trans-unit id="8935a387193b0a5a816a4c66481c8d7c932e5d95" translate="yes" xml:space="preserve">
          <source>TyVarBndrQ</source>
          <target state="translated">TyVarBndrQ</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="01dbe869b73c807b8d1e0423661fe63c6667b4be" translate="yes" xml:space="preserve">
          <source>Type Literals</source>
          <target state="translated">タイプリテラル</target>
        </trans-unit>
        <trans-unit id="683905a8f5337d0ba4784f351b463bf3f6346eb7" translate="yes" xml:space="preserve">
          <source>Type arguments can be replaced with underscores (&lt;code&gt;_&lt;/code&gt;) if the names of the arguments don&amp;rsquo;t matter. This is the same as writing type variables with unique names. Unused type arguments can be replaced or prefixed with underscores to avoid warnings when the &lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; flag is enabled. The same rules apply as for &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;.</source>
          <target state="translated">引数の名前が​​重要でない場合は、型引数をアンダースコア（ &lt;code&gt;_&lt;/code&gt; ）に置き換えることができます。これは、一意の名前で型変数を書き込むのと同じです。&lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt;フラグが有効になっている場合、警告を回避するために、未使用の型引数をアンダースコアで置き換えるか、プレフィックスを付けることができます。&lt;a href=&quot;#data-instance-declarations&quot;&gt;Dataインスタンス宣言&lt;/a&gt;と同じ規則が適用されます。</target>
        </trans-unit>
        <trans-unit id="9659950f117d747675f9b331917067539bfad472" translate="yes" xml:space="preserve">
          <source>Type checker will allow inferred types for holes.</source>
          <target state="translated">タイプチェッカーでは、穴のタイプを推測することができます。</target>
        </trans-unit>
        <trans-unit id="15f12c9fab92008565db5b57cde29394bdb8c86c" translate="yes" xml:space="preserve">
          <source>Type classes for I/O providers.</source>
          <target state="translated">I/O プロバイダの型クラス。</target>
        </trans-unit>
        <trans-unit id="e7b44aa8869034215edcaae12677a88e93b094f6" translate="yes" xml:space="preserve">
          <source>Type classes which require their own extensions to be enabled to be derived, such as &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;-XDeriveFunctor&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#deriving-extra&quot;&gt;Deriving instances of extra classes (Data, etc.)&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;-XDeriveFunctor&lt;/code&gt; &lt;/a&gt;など、独自の拡張機能の派生を有効にする必要がある型クラス（&lt;a href=&quot;#deriving-extra&quot;&gt;追加クラスのインスタンスの派生（データなど）を&lt;/a&gt;参照）</target>
        </trans-unit>
        <trans-unit id="926bf298afdb2d507c3bd7a1413520e17a01edb6" translate="yes" xml:space="preserve">
          <source>Type classes which require their own extensions to be enabled to be derived, such as &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#deriving-extra&quot;&gt;Deriving instances of extra classes (Data, etc.)&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;など、独自の拡張機能を派生させる必要がある型クラス（&lt;a href=&quot;#deriving-extra&quot;&gt;追加クラス（データなど）のインスタンスの派生を&lt;/a&gt;参照）</target>
        </trans-unit>
        <trans-unit id="8c9a4e5cab1cfa60793ccf4274a928c742c6b4aa" translate="yes" xml:space="preserve">
          <source>Type constructor applied to a type involving for-alls (if &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt;&lt;code&gt;ImpredicativeTypes&lt;/code&gt;&lt;/a&gt; is off)</source>
          <target state="translated">for- &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt; &lt;code&gt;ImpredicativeTypes&lt;/code&gt; &lt;/a&gt;含む型に適用される型コンストラクター（ImpredicativeTypesがオフの場合）</target>
        </trans-unit>
        <trans-unit id="644e74ab904e55997d610fce5e77162948201c5e" translate="yes" xml:space="preserve">
          <source>Type constructors</source>
          <target state="translated">型のコンストラクタ</target>
        </trans-unit>
        <trans-unit id="36b5ccdef806edc695be3db5ad16383dfcdb2c19" translate="yes" xml:space="preserve">
          <source>Type constructors and classes; Haskell has them in the same name space for now.</source>
          <target state="translated">型のコンストラクタとクラス;Haskellでは、今のところ同じ名前の空間にそれらを置いています。</target>
        </trans-unit>
        <trans-unit id="f4cb9160c66acee90d4523d170727eb5eabf6f68" translate="yes" xml:space="preserve">
          <source>Type equalities under a forall cannot be deferred (c.f. #14605).</source>
          <target state="translated">フォーオールの下での型の均等性は延期できません(c.f.#14605)。</target>
        </trans-unit>
        <trans-unit id="1e26c6647efeb9930ae7b1b903c5e593169df277" translate="yes" xml:space="preserve">
          <source>Type equalities under a forall cannot be deferred (c.f. Trac #14605).</source>
          <target state="translated">フォアオールの下でのタイプの均等性は延期できません(cf.Trac #14605)。</target>
        </trans-unit>
        <trans-unit id="705eb0947010d2f2d419bb724e3d94cb8a2e7780" translate="yes" xml:space="preserve">
          <source>Type equality</source>
          <target state="translated">タイプの平等</target>
        </trans-unit>
        <trans-unit id="36ea2932c958e42745f275dfbcdd59e4d26efb2e" translate="yes" xml:space="preserve">
          <source>Type families appear in three flavours: (1) they can be defined as open families on the toplevel, (2) they can be defined as closed families on the toplevel, or (3) they can appear inside type classes (in which case they are known as associated type synonyms). Toplevel families are more general, as they lack the requirement for the type-indexes to coincide with the class parameters. However, associated type synonyms can lead to more clearly structured code and compiler warnings if some type instances were - possibly accidentally - omitted. In the following, we always discuss the general toplevel forms first and then cover the additional constraints placed on associated types. Note that closed associated type synonyms do not exist.</source>
          <target state="translated">型ファミリーには、3 つの種類があります。(1)トップレベル上でオープン・ファミリーとして定義すること、(2)トップレベル上でクローズド・ファミリーとして定義すること、(3)タイプ・クラスの内部に出現すること(この場合、関連するタイプ・シノニムとして知られています)です。トップレベル・ファミリーは、型インデックスがクラス・パラメータと一致している必要がないため、より一般的なものです。しかし、関連付けられた型同義語を使用すると、コードの構造がより明確になり、型インスタンスが誤って省略された場合にコンパイラが警告を出すことがあります。以下では、常に最初に一般的なトップレベル型について説明し、次に関連型に課せられる追加の制約について説明します。閉じた関連型の同義語は存在しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a0217e7f7c0552b806a549d26e49045593d48ebc" translate="yes" xml:space="preserve">
          <source>Type families are enabled by the language extension &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;. Additional information on the use of type families in GHC is available on &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;the Haskell wiki page on type families&lt;/a&gt;.</source>
          <target state="translated">タイプファミリーは、言語拡張&lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt;によって有効になります。GHCでのタイプファミリーの使用に関する追加情報は、タイプファミリー&lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;のHaskell wikiページにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d1cc718ce378b49b47bdbdb12d9dfc708c706bb3" translate="yes" xml:space="preserve">
          <source>Type families require us to extend the rules for the form of instance heads, which are given in &lt;a href=&quot;#flexible-instance-head&quot;&gt;Relaxed rules for the instance head&lt;/a&gt;. Specifically:</source>
          <target state="translated">タイプファミリーでは、インスタンスヘッドの形式のルールを拡張する必要があります。これは&lt;a href=&quot;#flexible-instance-head&quot;&gt;、インスタンスヘッドのリラックスルールで&lt;/a&gt;指定されています。具体的には：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
