<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="ef2cf419db4400f92d4c16bda25b7b49de7c246f" translate="yes" xml:space="preserve">
          <source>Evaluate the argument to weak head normal form.</source>
          <target state="translated">弱頭通常形への議論を評価する。</target>
        </trans-unit>
        <trans-unit id="6060f4f46d5f080bbe6d3a4e15ea7e03aae4d623" translate="yes" xml:space="preserve">
          <source>Evaluates the given expression (or from the last breakpoint if no expression is given), and additionally logs the evaluation steps for later inspection using &lt;a href=&quot;#ghci-cmd-:history&quot;&gt;&lt;code&gt;:history&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#tracing&quot;&gt;Tracing and history&lt;/a&gt;.</source>
          <target state="translated">指定された式を評価し（または式が指定されていない場合は最後のブレークポイントから）、さらに&lt;a href=&quot;#ghci-cmd-:history&quot;&gt; &lt;code&gt;:history&lt;/code&gt; &lt;/a&gt;を使用して後で検査するために評価手順をログに記録します。&lt;a href=&quot;#tracing&quot;&gt;トレースと履歴を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7bc4cf67d5d67cdacfaa5ff060fb29cd523c09db" translate="yes" xml:space="preserve">
          <source>Evaluates the relevant functions at each element in the structure, running the action, and builds a new structure with the same shape, using the results produced from sequencing the actions.</source>
          <target state="translated">構造体の各要素で関連する機能を評価し、アクションを実行し、アクションを順次実行した結果を利用して、同じ形状の新しい構造体を構築します。</target>
        </trans-unit>
        <trans-unit id="5600c714a91cbc3264f491ad475c86811b22d09a" translate="yes" xml:space="preserve">
          <source>Evaluating &lt;code&gt;f&lt;/code&gt; directly shows a call stack with a single entry, while evaluating &lt;code&gt;g&lt;/code&gt;, which also requests its call-site, shows two entries, one for each computation &amp;ldquo;annotated&amp;rdquo; with &lt;code&gt;HasCallStack&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; を評価すると、単一のエントリを持つ呼び出しスタックが直接表示されますが、呼び出しサイトも要求する &lt;code&gt;g&lt;/code&gt; を評価すると、 &lt;code&gt;HasCallStack&lt;/code&gt; で「注釈が付けられた」各計算に1つずつ、2つのエントリが表示されます。</target>
        </trans-unit>
        <trans-unit id="6de480eeff47d7212d5e046acac48253bd022e55" translate="yes" xml:space="preserve">
          <source>Evaluating the \( i \)th prefix takes \( O(\log(\min(i, n-i))) \), but evaluating every prefix in the sequence takes \( O(n) \) due to sharing.</source>
          <target state="translated">順番に評価していくと、共有のため、O(orig(i,n-i))という時間がかかります。</target>
        </trans-unit>
        <trans-unit id="6396b8883a4c5c234f705d6f1fbf827f38a7835a" translate="yes" xml:space="preserve">
          <source>Evaluating the \( i \)th suffix takes \( O(\log(\min(i, n-i))) \), but evaluating every suffix in the sequence takes \( O(n) \) due to sharing.</source>
          <target state="translated">\(i )th suffixを評価するには、共有のため、O(O(\log(i,n-i)))が必要だけど、順番に全てのsuffixを評価するには、O(n)が必要なんだ。</target>
        </trans-unit>
        <trans-unit id="ea09e351bce3db4c6389ffff16dcaf057265f37f" translate="yes" xml:space="preserve">
          <source>Evaluation has started on a spark.</source>
          <target state="translated">評価は火花を散らしてスタートしました。</target>
        </trans-unit>
        <trans-unit id="bcce67319f3801a5d8320bd2ddeb26734158769d" translate="yes" xml:space="preserve">
          <source>Even if data families are defined as toplevel declarations, functions that perform different computations for different family instances may still need to be defined as methods of type classes. In particular, the following is not possible:</source>
          <target state="translated">データファミリがトップレベル宣言として定義されている場合でも、異なるファミリインスタンスに対して異なる計算を行う関数は、型クラスのメソッドとして定義する必要がある場合があります。特に、次のようなことはできません。</target>
        </trans-unit>
        <trans-unit id="712f436fb09e995690fe8d40968566162f8678b8" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;a&lt;/code&gt; is ill-typed, it is not used in the end, so if all that we&amp;rsquo;re interested in is &lt;code&gt;main&lt;/code&gt; it can be useful to be able to ignore the problems in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">にもかかわらず悪い型付けされ、我々が興味を持っているすべてのことならばそうです、最後に使用されていない &lt;code&gt;main&lt;/code&gt; 上の問題を無視することができることは便利です。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c423833e7459f388f7a025deca957c83022894ae" translate="yes" xml:space="preserve">
          <source>Even though a field label is duplicated in its defining module, it may be possible to use the selector unambiguously elsewhere. For example, another module could import &lt;code&gt;S(x)&lt;/code&gt; but not &lt;code&gt;T(x)&lt;/code&gt;, and then use &lt;code&gt;x&lt;/code&gt; unambiguously.</source>
          <target state="translated">定義モジュールでフィールドラベルが重複していても、セレクタを他の場所で明確に使用できる場合があります。たとえば、別のモジュールが &lt;code&gt;S(x)&lt;/code&gt; をインポートできても &lt;code&gt;T(x)&lt;/code&gt; はインポートできず、 &lt;code&gt;x&lt;/code&gt; を明確に使用できます。</target>
        </trans-unit>
        <trans-unit id="852a6172c09d70538bebcbe548e6b3e70b6d5e28" translate="yes" xml:space="preserve">
          <source>Even though most of these examples are using the list monad, monad comprehensions work for any monad. The &lt;code&gt;base&lt;/code&gt; package offers all necessary instances for lists, which make &lt;a href=&quot;#extension-MonadComprehensions&quot;&gt;&lt;code&gt;MonadComprehensions&lt;/code&gt;&lt;/a&gt; backward compatible to built-in, transform and parallel list comprehensions.</source>
          <target state="translated">これらの例のほとんどはリストモナドを使用していますが、モナド内包表記はどのモナドでも機能します。 &lt;code&gt;base&lt;/code&gt; パッケージの提供作るリストに必要なすべてのインスタンス、&lt;a href=&quot;#extension-MonadComprehensions&quot;&gt; &lt;code&gt;MonadComprehensions&lt;/code&gt; は&lt;/a&gt;変換、組み込みのと並行リスト内包への下位互換性。</target>
        </trans-unit>
        <trans-unit id="1e2fd9aaf66af88d1fa27ea41b45f571960a585c" translate="yes" xml:space="preserve">
          <source>Even though the shift-amount is expressed as &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;, the result is undefined for negative shift-amounts.</source>
          <target state="translated">シフト量は &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; として表されますが、負のシフト量の結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="7a5f2b0889226d76221df5eba41dfdfd027c049a" translate="yes" xml:space="preserve">
          <source>Even though the shift-amount is expressed as &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;, the result is undefined for negative shift-amounts.</source>
          <target state="translated">シフト量は &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; として表されますが、負のシフト量の結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="8a98b3fabc4357473affe9eff5dad04c75f7f6eb" translate="yes" xml:space="preserve">
          <source>Even though there are two &lt;code&gt;x&lt;/code&gt;&amp;lsquo;s in scope, it is clear that the &lt;code&gt;x&lt;/code&gt; in the pattern in the definition of &lt;code&gt;ok1&lt;/code&gt; can only mean the field &lt;code&gt;x&lt;/code&gt; from type &lt;code&gt;S&lt;/code&gt;. Similarly for the function &lt;code&gt;ok2&lt;/code&gt;. However, in the record update in &lt;code&gt;bad1&lt;/code&gt; and the record selection in &lt;code&gt;bad2&lt;/code&gt; it is not clear which of the two types is intended.</source>
          <target state="translated">2があるにもかかわらず &lt;code&gt;x&lt;/code&gt; さんがスコープ内に、あることは明らかである &lt;code&gt;x&lt;/code&gt; の定義におけるパターンで &lt;code&gt;ok1&lt;/code&gt; 唯一のフィールドの意味することができ &lt;code&gt;x&lt;/code&gt; 型から &lt;code&gt;S&lt;/code&gt; を。関数 &lt;code&gt;ok2&lt;/code&gt; についても同様です。しかし、レコードの更新に &lt;code&gt;bad1&lt;/code&gt; で、レコードの選択 &lt;code&gt;bad2&lt;/code&gt; 意図される2種類のかが明確ではありません。</target>
        </trans-unit>
        <trans-unit id="4622930c8ec60ffdcb4687bdfc5e61a4075cdba8" translate="yes" xml:space="preserve">
          <source>Even though there are two &lt;code&gt;x&lt;/code&gt;&amp;rsquo;s in scope, it is clear that the &lt;code&gt;x&lt;/code&gt; in the pattern in the definition of &lt;code&gt;ok1&lt;/code&gt; can only mean the field &lt;code&gt;x&lt;/code&gt; from type &lt;code&gt;S&lt;/code&gt;. Similarly for the function &lt;code&gt;ok2&lt;/code&gt;. However, in the record update in &lt;code&gt;bad1&lt;/code&gt; and the record selection in &lt;code&gt;bad2&lt;/code&gt; it is not clear which of the two types is intended.</source>
          <target state="translated">スコープに2つの &lt;code&gt;x&lt;/code&gt; がありますが、 &lt;code&gt;ok1&lt;/code&gt; の定義のパターンの &lt;code&gt;x&lt;/code&gt; は、タイプ &lt;code&gt;S&lt;/code&gt; のフィールド &lt;code&gt;x&lt;/code&gt; のみを意味することは明らかです。関数 &lt;code&gt;ok2&lt;/code&gt; についても同様です。しかし、レコードの更新に &lt;code&gt;bad1&lt;/code&gt; で、レコードの選択 &lt;code&gt;bad2&lt;/code&gt; 意図される2種類のかが明確ではありません。</target>
        </trans-unit>
        <trans-unit id="2711d7494e1ded0fd3622ca6129c265f52351d7e" translate="yes" xml:space="preserve">
          <source>Even when set to &lt;code&gt;ignore&lt;/code&gt;, a local script will still be processed if given by &lt;a href=&quot;#ghc-flag--ghci-script&quot;&gt;&lt;code&gt;-ghci-script&lt;/code&gt;&lt;/a&gt; on the command line, or sourced via &lt;a href=&quot;#ghci-cmd-:script&quot;&gt;&lt;code&gt;:script&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ignore&lt;/code&gt; に設定されている場合でも、コマンドラインで&lt;a href=&quot;#ghc-flag--ghci-script&quot;&gt; &lt;code&gt;-ghci-script&lt;/code&gt; &lt;/a&gt;を指定するか、&lt;a href=&quot;#ghci-cmd-:script&quot;&gt; &lt;code&gt;:script&lt;/code&gt; を&lt;/a&gt;介してソースを指定すると、ローカルスクリプトが処理されます。</target>
        </trans-unit>
        <trans-unit id="28e0cceb61d9188b63cc75de845a0be5868e83b8" translate="yes" xml:space="preserve">
          <source>Even with the flags &lt;a href=&quot;../using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, the field of the constructor &lt;code&gt;T&lt;/code&gt; is not unpacked.</source>
          <target state="translated">フラグ&lt;a href=&quot;../using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;を使用しても、コンストラクター &lt;code&gt;T&lt;/code&gt; のフィールドは解凍されません。</target>
        </trans-unit>
        <trans-unit id="73d7a0d774535278c1215097572fe0930f17dd2b" translate="yes" xml:space="preserve">
          <source>Even with the flags &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, the field of the constructor &lt;code&gt;T&lt;/code&gt; is not unpacked.</source>
          <target state="translated">フラグ&lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;を使用しても、コンストラクター &lt;code&gt;T&lt;/code&gt; のフィールドはアンパックされません。</target>
        </trans-unit>
        <trans-unit id="ad8919ace091b14011c6439cfd5e1707b58f5abd" translate="yes" xml:space="preserve">
          <source>Event</source>
          <target state="translated">Event</target>
        </trans-unit>
        <trans-unit id="0c619c8d6ba2035f81d9f010c08ec0b1177929e5" translate="yes" xml:space="preserve">
          <source>Event logging</source>
          <target state="translated">イベントロギング</target>
        </trans-unit>
        <trans-unit id="913641e09266e8cb48d5e95316fd86cbe16755ba" translate="yes" xml:space="preserve">
          <source>EventManager</source>
          <target state="translated">EventManager</target>
        </trans-unit>
        <trans-unit id="ff23fd7f42569a5bfa090dd486d103be85fd0164" translate="yes" xml:space="preserve">
          <source>Eventlog tracing</source>
          <target state="translated">イベントログのトレース</target>
        </trans-unit>
        <trans-unit id="c19ae7eba2908ba6569d481309090a0fda383fe3" translate="yes" xml:space="preserve">
          <source>Eventlog tracing is a performance profiling system. These functions emit extra events into the eventlog. In combination with eventlog profiling tools these functions can be used for monitoring execution and investigating performance problems.</source>
          <target state="translated">イベントログトレースはパフォーマンスプロファイリングシステムです。これらの関数は、イベントログに追加のイベントを出力します。イベントログプロファイリングツールと組み合わせることで、これらの関数は実行の監視やパフォーマンス問題の調査に使用することができます。</target>
        </trans-unit>
        <trans-unit id="9202d6978f7b6c56daee6dab6c663c232e9764fd" translate="yes" xml:space="preserve">
          <source>Events can have extra information added, but existing fields cannot be changed. Tools should ignore extra fields at the end of the event record.</source>
          <target state="translated">イベントには追加情報を追加できますが、既存のフィールドを変更することはできません。ツールは、イベントレコードの最後にある余分なフィールドを無視する必要があります。</target>
        </trans-unit>
        <trans-unit id="82d16de768c1684f419fe23bd359b377e6758d1e" translate="yes" xml:space="preserve">
          <source>Every complete Haskell program must define &lt;code&gt;main&lt;/code&gt; in module &lt;code&gt;Main&lt;/code&gt; in package &lt;code&gt;main&lt;/code&gt;. Omitting the &lt;a href=&quot;#ghc-flag--this-unit-id%20%E2%9F%A8unit-id%E2%9F%A9&quot;&gt;&lt;code&gt;-this-unit-id ⟨unit-id⟩&lt;/code&gt;&lt;/a&gt; flag compiles code for package &lt;code&gt;main&lt;/code&gt;. Failure to do so leads to a somewhat obscure link-time error of the form:</source>
          <target state="translated">すべての完全なHaskellプログラムは、パッケージ &lt;code&gt;main&lt;/code&gt; のモジュール &lt;code&gt;Main&lt;/code&gt; で &lt;code&gt;main&lt;/code&gt; を定義する必要があります。&lt;a href=&quot;#ghc-flag--this-unit-id%20%E2%9F%A8unit-id%E2%9F%A9&quot;&gt; &lt;code&gt;-this-unit-id ⟨unit-id⟩&lt;/code&gt; &lt;/a&gt;フラグを省略すると、パッケージ &lt;code&gt;main&lt;/code&gt; のコードがコンパイルされます。そうしないと、次の形式のリンク時エラーがややあいまいになります。</target>
        </trans-unit>
        <trans-unit id="d0912fd6d2a0271d302c52a4acaff179b0c6995b" translate="yes" xml:space="preserve">
          <source>Every cycle in the module import graph must be broken by a &lt;code&gt;hs-boot&lt;/code&gt; file. Suppose that modules &lt;code&gt;A.hs&lt;/code&gt; and &lt;code&gt;B.hs&lt;/code&gt; are Haskell source files, thus:</source>
          <target state="translated">モジュールインポートグラフのすべてのサイクルは、 &lt;code&gt;hs-boot&lt;/code&gt; ファイルによって壊れている必要があります。モジュール &lt;code&gt;A.hs&lt;/code&gt; および &lt;code&gt;B.hs&lt;/code&gt; がHaskellソースファイルであるとすると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="33d86826edcd97dcbde5f7c16a0f10d7e8256a5b" translate="yes" xml:space="preserve">
          <source>Every language extension can also be turned into a command-line flag by prefixing it with &amp;ldquo;&lt;code&gt;-X&lt;/code&gt;&amp;rdquo;; for example &lt;code&gt;-XForeignFunctionInterface&lt;/code&gt;. (Similarly, all &amp;ldquo;&lt;code&gt;-X&lt;/code&gt;&amp;rdquo; flags can be written as &lt;code&gt;LANGUAGE&lt;/code&gt; pragmas.)</source>
          <target state="translated">すべての言語拡張は、「- &lt;code&gt;-X&lt;/code&gt; 」を前に付けることでコマンドラインフラグに変換することもできます。たとえば &lt;code&gt;-XForeignFunctionInterface&lt;/code&gt; です。（同様に、すべての「 &lt;code&gt;-X&lt;/code&gt; 」フラグは &lt;code&gt;LANGUAGE&lt;/code&gt; プラグマとして書き込むことができます。）</target>
        </trans-unit>
        <trans-unit id="3b078eee456a9f087a6cc6922257a7666e3223df" translate="yes" xml:space="preserve">
          <source>Every language extension can be switched on by a command-line flag &amp;ldquo;&lt;code&gt;-X...&lt;/code&gt;&amp;rdquo; (e.g. &lt;code&gt;-XTemplateHaskell&lt;/code&gt;), and switched off by the flag &amp;ldquo;&lt;code&gt;-XNo...&lt;/code&gt;&amp;rdquo;; (e.g. &lt;code&gt;-XNoTemplateHaskell&lt;/code&gt;).</source>
          <target state="translated">すべての言語拡張機能は、コマンドラインフラグ「 &lt;code&gt;-X...&lt;/code&gt; 」（例： &lt;code&gt;-XTemplateHaskell&lt;/code&gt; ）でオンに切り替え、フラグ「 &lt;code&gt;-XNo...&lt;/code&gt; 」でオフに切り替えることができます。（例： &lt;code&gt;-XNoTemplateHaskell&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="89191834b0668388b7f06081ebe85c6fc7aa3ea9" translate="yes" xml:space="preserve">
          <source>Every language option can switched on by a command-line flag &amp;ldquo;&lt;code&gt;-X...&lt;/code&gt;&amp;rdquo; (e.g. &lt;code&gt;-XTemplateHaskell&lt;/code&gt;), and switched off by the flag &amp;ldquo;&lt;code&gt;-XNo...&lt;/code&gt;&amp;rdquo;; (e.g. &lt;code&gt;-XNoTemplateHaskell&lt;/code&gt;).</source>
          <target state="translated">すべての言語オプションは、コマンドラインフラグ「 &lt;code&gt;-X...&lt;/code&gt; 」（例 &lt;code&gt;-XTemplateHaskell&lt;/code&gt; ）でオンにでき、フラグ「 &lt;code&gt;-XNo...&lt;/code&gt; 」でオフにできます。（例 &lt;code&gt;-XNoTemplateHaskell&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c21e6f680a01c2f8b28c8d60711b7527a58afada" translate="yes" xml:space="preserve">
          <source>Every module has a &lt;em&gt;module name&lt;/em&gt; defined in its source code (&lt;code&gt;module A.B.C where ...&lt;/code&gt;).</source>
          <target state="translated">すべてのモジュールには、ソースコードで定義された&lt;em&gt;モジュール名&lt;/em&gt;があり&lt;em&gt;ます&lt;/em&gt;（ &lt;code&gt;module A.B.C where ...&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b9fd929db55af9188984a5b1f15ada92d9684dba" translate="yes" xml:space="preserve">
          <source>Every new binding shadows any existing bindings of the same name, including entities that are in scope in the current module context.</source>
          <target state="translated">すべての新しいバインディングは、現在のモジュールコンテキストのスコープ内にあるエンティティを含む、同名の既存のバインディングのすべてをシャドーにします。</target>
        </trans-unit>
        <trans-unit id="f7098378d870c69a4432ef9315748f42a7c6f2be" translate="yes" xml:space="preserve">
          <source>Every thread has an allocation counter that tracks how much memory has been allocated by the thread. The counter is initialized to zero, and &lt;code&gt;&lt;a href=&quot;ghc-conc#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; sets the current value. The allocation counter counts *down*, so in the absence of a call to &lt;code&gt;&lt;a href=&quot;ghc-conc#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; its value is the negation of the number of bytes of memory allocated by the thread.</source>
          <target state="translated">すべてのスレッドには、スレッドによって割り当てられたメモリの量を追跡する割り当てカウンターがあります。カウンターはゼロに初期化され、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; が現在の値を設定します。割り当てカウンターは*ダウン*カウントするため、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; への呼び出しがない場合、その値はスレッドによって割り当てられたメモリのバイト数の否定です。</target>
        </trans-unit>
        <trans-unit id="87fea7be991371f64729bc8780fc11210c633480" translate="yes" xml:space="preserve">
          <source>Every thread has an allocation counter that tracks how much memory has been allocated by the thread. The counter is initialized to zero, and &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; sets the current value. The allocation counter counts *down*, so in the absence of a call to &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; its value is the negation of the number of bytes of memory allocated by the thread.</source>
          <target state="translated">すべてのスレッドには、スレッドによって割り当てられたメモリの量を追跡する割り当てカウンターがあります。カウンターはゼロに初期化され、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; が現在の値を設定します。割り当てカウンターは*ダウン*カウントするため、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; への呼び出しがない場合、その値はスレッドによって割り当てられたメモリのバイト数の否定です。</target>
        </trans-unit>
        <trans-unit id="abfc0f0b13db0da312949b88776c9010f5397cef" translate="yes" xml:space="preserve">
          <source>Every thread has an allocation counter that tracks how much memory has been allocated by the thread. The counter is initialized to zero, and &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; sets the current value. The allocation counter counts *down*, so in the absence of a call to &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; its value is the negation of the number of bytes of memory allocated by the thread.</source>
          <target state="translated">すべてのスレッドには、スレッドによって割り当てられたメモリの量を追跡する割り当てカウンターがあります。カウンターはゼロに初期化され、 &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; が現在の値を設定します。割り当てカウンターは*ダウン*カウントするため、 &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; への呼び出しがない場合、その値はスレッドによって割り当てられたメモリのバイト数の否定です。</target>
        </trans-unit>
        <trans-unit id="2cdcb7a5f8b0e5da9d82d98917b19bde316858e5" translate="yes" xml:space="preserve">
          <source>Exactly the same reasoning applies to &lt;code&gt;ExNumPat&lt;/code&gt;: matching against &lt;code&gt;ExNumPat&lt;/code&gt;&lt;em&gt;requires&lt;/em&gt; the constraints &lt;code&gt;(Num a, Eq a)&lt;/code&gt;, and &lt;em&gt;provides&lt;/em&gt; the constraint &lt;code&gt;(Show b)&lt;/code&gt;.</source>
          <target state="translated">まったく同じ理由が &lt;code&gt;ExNumPat&lt;/code&gt; にも当てはまります &lt;code&gt;ExNumPat&lt;/code&gt; &lt;em&gt;と&lt;/em&gt;の照合には制約 &lt;code&gt;(Num a, Eq a)&lt;/code&gt; であり、制約 &lt;code&gt;(Show b)&lt;/code&gt; を&lt;em&gt;提供&lt;/em&gt;します。</target>
        </trans-unit>
        <trans-unit id="9b96d27d4acb5d7b08b44caf941f831bab1b616f" translate="yes" xml:space="preserve">
          <source>Exactly the same situation can arise in instance declarations themselves. Suppose we have</source>
          <target state="translated">インスタンス宣言自体にも全く同じ状況が発生する可能性があります。以下のような場合を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="fe669a2e98268a4e3f1914eea2b10b28c27678b1" translate="yes" xml:space="preserve">
          <source>Examine the generated profiling information, use the information to optimise your program, and repeat as necessary.</source>
          <target state="translated">生成されたプロファイリング情報を調べ、その情報を使用してプログラムを最適化し、必要に応じて繰り返します。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="5ab5c95eb13c56a3fee4135ddda2d5191c14c8f0" translate="yes" xml:space="preserve">
          <source>Example 1: Custom Error Data Type</source>
          <target state="translated">例1:カスタムエラーデータタイプ</target>
        </trans-unit>
        <trans-unit id="9341e16e31da6f2a70822dbce4c15a6563123345" translate="yes" xml:space="preserve">
          <source>Example 1: Simple Continuation Usage</source>
          <target state="translated">例1:簡単な継続の使い方</target>
        </trans-unit>
        <trans-unit id="65d8343070f8245126756e9e6474efdb37e4866c" translate="yes" xml:space="preserve">
          <source>Example 1: Simple Reader Usage</source>
          <target state="translated">例1:シンプルなリーダーの使い方</target>
        </trans-unit>
        <trans-unit id="e7b57a0dcf99e0a81e45002d7fa9585327408c44" translate="yes" xml:space="preserve">
          <source>Example 2: Modifying Reader Content With &lt;code&gt;local&lt;/code&gt;</source>
          <target state="translated">例2： &lt;code&gt;local&lt;/code&gt; リーダーコンテンツを変更する</target>
        </trans-unit>
        <trans-unit id="b7af5856636b2b3dd64495544e0d58ec7921152b" translate="yes" xml:space="preserve">
          <source>Example 2: Using &lt;code&gt;callCC&lt;/code&gt;</source>
          <target state="translated">例2： &lt;code&gt;callCC&lt;/code&gt; の使用</target>
        </trans-unit>
        <trans-unit id="3f1f4d7e09a4ce050bc861cd17fcfb325ccd1802" translate="yes" xml:space="preserve">
          <source>Example 2: Using ErrorT Monad Transformer</source>
          <target state="translated">例2:ErrorTモナドトランスの使用</target>
        </trans-unit>
        <trans-unit id="49670fce677705355449a0491c747c92f53b6377" translate="yes" xml:space="preserve">
          <source>Example 2: Using ExceptT Monad Transformer</source>
          <target state="translated">例 2:ExceptT モナドトランスの使用</target>
        </trans-unit>
        <trans-unit id="3b38bf4f99b69316fc2cabc16fe8efbc23e17cdb" translate="yes" xml:space="preserve">
          <source>Example 3: &lt;code&gt;ReaderT&lt;/code&gt; Monad Transformer</source>
          <target state="translated">例3： &lt;code&gt;ReaderT&lt;/code&gt; Monad Transformer</target>
        </trans-unit>
        <trans-unit id="2f4dd83523e08d239122d5d7b82fdc40b87078e4" translate="yes" xml:space="preserve">
          <source>Example 3: Using &lt;code&gt;ContT&lt;/code&gt; Monad Transformer</source>
          <target state="translated">例3： &lt;code&gt;ContT&lt;/code&gt; モナド変換を使用する</target>
        </trans-unit>
        <trans-unit id="589c32b6f4517cdf800a8b3876ce51a0178b7a54" translate="yes" xml:space="preserve">
          <source>Example type:</source>
          <target state="translated">タイプの例。</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">使用例。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="fa37f54302b03973bfbf2aa3fb535779d3383bb4" translate="yes" xml:space="preserve">
          <source>Examples (with behaviour identical to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">例（動作は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; と同じ）：</target>
        </trans-unit>
        <trans-unit id="790f2b42181ca616b7c127aef6e902fd9e8081ef" translate="yes" xml:space="preserve">
          <source>Examples (with behaviour identical to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">例（ &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; と同じ動作）：</target>
        </trans-unit>
        <trans-unit id="d081741e630d4cf15f0c6ba49848ab7e7fafe785" translate="yes" xml:space="preserve">
          <source>Examples (with behaviour identical to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">例（ &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; と同じ動作）：</target>
        </trans-unit>
        <trans-unit id="65ef181bf5a5a0563ded8a2fc63cfcae3d45812a" translate="yes" xml:space="preserve">
          <source>Examples of differences from &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; との違いの例：</target>
        </trans-unit>
        <trans-unit id="80e96827fe2478980a86e49ef7458c4629812185" translate="yes" xml:space="preserve">
          <source>Examples of differences from &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; との違いの例：</target>
        </trans-unit>
        <trans-unit id="ddfe2a057d0d4bd32c75bee00a3afd1b7f3cd6fd" translate="yes" xml:space="preserve">
          <source>Examples of differences from &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; との違いの例：</target>
        </trans-unit>
        <trans-unit id="3e6a1dcd0a3510c1fa35b2c9952fa51f9d56da66" translate="yes" xml:space="preserve">
          <source>Examples of short-cicuit reduction include various boolean predicates that test whether some or all the elements of a structure satisfy a given condition. Because these don't necessarily consume the entire list, they typically employ &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; with an operator that is conditionally strict in its second argument. Once the termination condition is met the second argument (tail of the input structure) is ignored. No result is returned until that happens.</source>
          <target state="translated">短期間の削減の例には、構造の一部またはすべての要素が特定の条件を満たすかどうかをテストするさまざまなブール述語が含まれます。これらは必ずしもリスト全体を消費するわけではないため、通常、2番目の引数で条件付きで厳密な演算子を使用して &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; を使用します。終了条件が満たされると、2番目の引数（入力構造の末尾）は無視されます。それが発生するまで、結果は返されません。</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="498245f3f1e8f9b6f80d7ed20c13e42f043f24d9" translate="yes" xml:space="preserve">
          <source>Except</source>
          <target state="translated">Except</target>
        </trans-unit>
        <trans-unit id="150f49a28cd9890f5d74255011dd9ae13178dd32" translate="yes" xml:space="preserve">
          <source>ExceptT</source>
          <target state="translated">ExceptT</target>
        </trans-unit>
        <trans-unit id="20049bc069b0a04404c23d571b5e0b56f0660c02" translate="yes" xml:space="preserve">
          <source>Exception</source>
          <target state="translated">Exception</target>
        </trans-unit>
        <trans-unit id="53a706616e11935ca633fadc1928372183e733d2" translate="yes" xml:space="preserve">
          <source>Exception delivery synchronizes between the source and target thread: &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</source>
          <target state="translated">例外の配信は、ソーススレッドとターゲットスレッド間で同期されます &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は、ターゲットスレッドで例外が発生するまで戻りません。したがって、呼び出しスレッドは、ターゲットスレッドが例外を受け取ったことを確認できます。例外の配信は、他の例外に関してもアトミックです。原子性は、競合状態を処理するときに役立つプロパティです。たとえば、相互に強制終了できる2つのスレッドがある場合、一方のスレッドだけが他方を強制終了することが保証されます。</target>
        </trans-unit>
        <trans-unit id="6b1c0dab2d59aa101f6c17d2f3c37c8dbb32aef4" translate="yes" xml:space="preserve">
          <source>Exception delivery synchronizes between the source and target thread: &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</source>
          <target state="translated">例外の配信は、ソーススレッドとターゲットスレッド間で同期されます &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は、ターゲットスレッドで例外が発生するまで戻りません。したがって、呼び出しスレッドは、ターゲットスレッドが例外を受け取ったことを確認できます。例外の配信は、他の例外に関してもアトミックです。原子性は、競合状態を処理するときに役立つプロパティです。たとえば、相互に強制終了できる2つのスレッドがある場合、一方のスレッドだけが他方を強制終了することが保証されます。</target>
        </trans-unit>
        <trans-unit id="f9ca0b055b03c1b83f5d783045937b6b971fc2c7" translate="yes" xml:space="preserve">
          <source>Exception delivery synchronizes between the source and target thread: &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</source>
          <target state="translated">例外の配信は、ソーススレッドとターゲットスレッド間で同期されます &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は、ターゲットスレッドで例外が発生するまで戻りません。したがって、呼び出しスレッドは、ターゲットスレッドが例外を受け取ったことを確認できます。例外の配信は、他の例外に関してもアトミックです。原子性は、競合状態を処理するときに役立つプロパティです。たとえば、相互に強制終了できる2つのスレッドがある場合、一方のスレッドだけが他方を強制終了することが保証されます。</target>
        </trans-unit>
        <trans-unit id="63b8e6291d3f08aeaec124c66c6cff001d6c6ea4" translate="yes" xml:space="preserve">
          <source>Exception delivery synchronizes between the source and target thread: &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</source>
          <target state="translated">例外の配信は、ソーススレッドとターゲットスレッド間で同期されます &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は、ターゲットスレッドで例外が発生するまで戻りません。したがって、呼び出しスレッドは、ターゲットスレッドが例外を受け取ったことを確認できます。例外の配信は、他の例外に関してもアトミックです。原子性は、競合状態を処理するときに役立つプロパティです。たとえば、相互に強制終了できる2つのスレッドがある場合、一方のスレッドだけが他方を強制終了することが保証されます。</target>
        </trans-unit>
        <trans-unit id="e0356c4346732233d71d4ad17145a3a7d64d539e" translate="yes" xml:space="preserve">
          <source>Exception handling in the I/O monad</source>
          <target state="translated">I/Oモナドでの例外処理</target>
        </trans-unit>
        <trans-unit id="4aba3643c6de6f96be69c3234f88f2d7abee91b2" translate="yes" xml:space="preserve">
          <source>Exception handling within STM actions.</source>
          <target state="translated">STMアクション内での例外処理。</target>
        </trans-unit>
        <trans-unit id="eda52cb4b163a3d91ebc6efd255a35eb5c788dd0" translate="yes" xml:space="preserve">
          <source>Exception operations</source>
          <target state="translated">例外的な操作</target>
        </trans-unit>
        <trans-unit id="1e0456156d2599fba71e66665c8effe9eb0cdf9b" translate="yes" xml:space="preserve">
          <source>Exception thrown by &lt;code&gt;&lt;a href=&quot;ghc-io-handle-lock#v:hLock&quot;&gt;hLock&lt;/a&gt;&lt;/code&gt; on non-Windows platforms that don't support &lt;code&gt;flock&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;flock&lt;/code&gt; をサポートしないWindows以外のプラットフォームで &lt;code&gt;&lt;a href=&quot;ghc-io-handle-lock#v:hLock&quot;&gt;hLock&lt;/a&gt;&lt;/code&gt; によってスローされる例外。</target>
        </trans-unit>
        <trans-unit id="ab0e1caad4d21b7759b69123f35074bf121ac468" translate="yes" xml:space="preserve">
          <source>Exception thrown by &lt;code&gt;hLock&lt;/code&gt; on non-Windows platforms that don't support &lt;code&gt;flock&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;flock&lt;/code&gt; をサポートしていないWindows以外のプラットフォームで &lt;code&gt;hLock&lt;/code&gt; によってスローされる例外。</target>
        </trans-unit>
        <trans-unit id="8bcbec4a21f1200ac1b10210e0b80c9fa92ae9e7" translate="yes" xml:space="preserve">
          <source>Exceptions (e.g. pattern matching failure and &lt;code&gt;error&lt;/code&gt;) can be treated as breakpoints, to help locate the source of an exception in the program.</source>
          <target state="translated">例外（パターンマッチングの失敗や &lt;code&gt;error&lt;/code&gt; ）は、プログラム内の例外の原因を特定するのに役立つブレークポイントとして扱うことができます。</target>
        </trans-unit>
        <trans-unit id="19252ae3666000a0b6f93913a391be3ee8a0b825" translate="yes" xml:space="preserve">
          <source>Exceptions and exception-handling functions.</source>
          <target state="translated">例外と例外処理機能。</target>
        </trans-unit>
        <trans-unit id="581d67742f82ff9913666449de206cda75556316" translate="yes" xml:space="preserve">
          <source>Exceptions generated by array operations</source>
          <target state="translated">配列操作で発生する例外</target>
        </trans-unit>
        <trans-unit id="934839970d31235dc74d44785440bb7587cc9762" translate="yes" xml:space="preserve">
          <source>Exceptions that occur in the &lt;code&gt;IO&lt;/code&gt; monad. An &lt;code&gt;IOException&lt;/code&gt; records a more specific error type, a descriptive string and maybe the handle that was used when the error was flagged.</source>
          <target state="translated">&lt;code&gt;IO&lt;/code&gt; モナドで発生する例外。アン &lt;code&gt;IOException&lt;/code&gt; が多分、より具体的なエラーの種類、説明的な文字列とエラーがフラグを立てたときに使用されたハンドルを記録します。</target>
        </trans-unit>
        <trans-unit id="08dd9b4521175f2b7645b6d05dd66e3f5d1e5a7a" translate="yes" xml:space="preserve">
          <source>ExclusiveLock</source>
          <target state="translated">ExclusiveLock</target>
        </trans-unit>
        <trans-unit id="a9e5edeee4b6bddbc59b5bc41ce4029d4ec4727e" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">実行可能ファイル＆引数、またはシェルコマンド。 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; の場合、現在の作業ディレクトリを基準にして相対パスが解決されます。 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; が指定されている場合、相対パスが &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; または現在の作業ディレクトリに関して解決されるかどうかは実装に依存するため、絶対パスを使用して移植性を確保する必要があります。</target>
        </trans-unit>
        <trans-unit id="42e1121c05300716bc1e0f10a008032170bf3cee" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">実行可能ファイルと引数、またはシェルコマンド。 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; の場合、相対パスは現在の作業ディレクトリに対して解決されます。 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; が提供されている場合、相対パスが &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; または現在の作業ディレクトリに関して解決されるかどうかは実装に依存するため、移植性を確保するために絶対パスを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="0d633fda1eda86ee2dbe83ca841bdba34c00b7fb" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">実行可能ファイルと引数、またはシェルコマンド。 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; の場合、相対パスは現在の作業ディレクトリに対して解決されます。 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; が提供されている場合、相対パスが &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; または現在の作業ディレクトリに関して解決されるかどうかは実装に依存するため、移植性を確保するために絶対パスを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="da49c4c138af06cdc6e4ed0555a2d722ce3bbf8b" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">実行可能ファイル＆引数、またはシェルコマンド。 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; の場合、現在の作業ディレクトリを基準にして相対パスが解決されます。 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; が指定されている場合、相対パスが &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; または現在の作業ディレクトリに関して解決されるかどうかは実装に依存するため、絶対パスを使用して移植性を確保する必要があります。</target>
        </trans-unit>
        <trans-unit id="fbbcf8ab79fd69b3cdf42660517413d00119f401" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">実行可能ファイルと引数、またはシェルコマンド。 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; の場合、相対パスは現在の作業ディレクトリに対して解決されます。 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; が提供されている場合、相対パスが &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; または現在の作業ディレクトリに関して解決されるかどうかは実装に依存するため、移植性を確保するために絶対パスを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="08446105cf0896c803b6a80b50cd0e07cfad78bd" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">実行可能ファイルと引数、またはシェルコマンド。 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; の場合、相対パスは現在の作業ディレクトリに対して解決されます。 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; が提供されている場合、相対パスが &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; または現在の作業ディレクトリに関して解決されるかどうかは実装に依存するため、移植性を確保するために絶対パスを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="82e45ade933abb2dbef129bbe667e5f06567379e" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-binary-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; and return the generated chunks as a lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The work is performed lazy, i.e., only when a chunk of the lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is forced.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; を実行し、生成されたチャンクを遅延 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; として返します。作業は遅延実行されます。つまり、遅延 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; のチャンクが強制された場合のみです。</target>
        </trans-unit>
        <trans-unit id="bbdca60aa1528cc59e2424298bc2fbc065b117a6" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-binary-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; and return the generated chunks as a lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The work is performed lazy, i.e., only when a chunk of the lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is forced.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; を実行し、生成されたチャンクを遅延 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; として返します。作業はレイジーで実行されます。つまり、レイジー &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; のチャンクが強制された場合にのみ実行されます。</target>
        </trans-unit>
        <trans-unit id="44cef8606c2d8d69b084ef725295c455661c70d1" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; and return the generated chunks as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The work is performed lazy, i.e., only when a chunk of the lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is forced.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; を実行し、生成されたチャンクを遅延 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; として返します。作業は遅延実行されます。つまり、遅延 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; のチャンクが強制された場合のみです。</target>
        </trans-unit>
        <trans-unit id="2d4c37228081ad690471866bfb49855698ac1573" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; and return the computed result and the bytes written during the computation as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; を実行し、計算結果と、計算中に書き込まれたバイトを遅延 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; として返します。</target>
        </trans-unit>
        <trans-unit id="0a91780a4fbc0b4b5a96ff84d0f2ad27c4390b00" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; with a buffer-allocation strategy and a continuation. For example, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:putToLazyByteString&quot;&gt;putToLazyByteString&lt;/a&gt;&lt;/code&gt; is implemented as follows.</source>
          <target state="translated">バッファ割り当て戦略と継続を使用して &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; を実行します。たとえば、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:putToLazyByteString&quot;&gt;putToLazyByteString&lt;/a&gt;&lt;/code&gt; は次のように実装されます。</target>
        </trans-unit>
        <trans-unit id="34b863a511860977e79077de7a231a7aecf1ada7" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment</source>
          <target state="translated">変更された環境で計算を実行する</target>
        </trans-unit>
        <trans-unit id="9074ee855e6397968c72ac1444df19911eaa577a" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment (a more general version of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">変更された環境で計算を実行します（ &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; のより一般的なバージョン）。</target>
        </trans-unit>
        <trans-unit id="9bad7ac26cf07893f9cefd43f5bb9c7a61a20d5d" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment (a more general version of &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">変更された環境で計算を実行します（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; のより一般的なバージョン）。</target>
        </trans-unit>
        <trans-unit id="1c369096a8c214ef9f4515d93a67dbb9c70e723b" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment (a specialization of &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:withReaderT&quot;&gt;withReaderT&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">変更された環境で計算を実行します（ &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:withReaderT&quot;&gt;withReaderT&lt;/a&gt;&lt;/code&gt; の特殊化）。</target>
        </trans-unit>
        <trans-unit id="e148fe739f9c54b1accabc69b62a9d19fee91018" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment (a specialization of &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:withReaderT&quot;&gt;withReaderT&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">変更された環境で計算を実行します（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:withReaderT&quot;&gt;withReaderT&lt;/a&gt;&lt;/code&gt; の特殊化）。</target>
        </trans-unit>
        <trans-unit id="53f59c8f15736e3200571bde489e9c2748a0204d" translate="yes" xml:space="preserve">
          <source>Execute an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action, throwing a &lt;code&gt;&lt;a href=&quot;system-io-error#v:userError&quot;&gt;userError&lt;/a&gt;&lt;/code&gt; if the predicate yields &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to the result returned by the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action. If no exception is raised, return the result of the computation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションを実行し、述語が &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションによって返された結果に適用されたときに &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; を生成した場合に &lt;code&gt;&lt;a href=&quot;system-io-error#v:userError&quot;&gt;userError&lt;/a&gt;&lt;/code&gt; をスローします。例外が発生しない場合は、計算結果を返します。</target>
        </trans-unit>
        <trans-unit id="42c77fe8561e333489414079969807a39fd1e151" translate="yes" xml:space="preserve">
          <source>Execute an action with a fresh memory pool, which gets automatically deallocated (including its contents) after the action has finished.</source>
          <target state="translated">新鮮なメモリプールを使用してアクションを実行し、アクションが終了した後に自動的に(その内容も含めて)解放されます。</target>
        </trans-unit>
        <trans-unit id="1262c3e03a483c6a9341f4b12dfc5bd8ac87a7c4" translate="yes" xml:space="preserve">
          <source>Executes a computation in a modified environment.</source>
          <target state="translated">変更された環境で計算を実行します。</target>
        </trans-unit>
        <trans-unit id="8210b4609b3b832c81bcd8b6f74a6b3190413ae8" translate="yes" xml:space="preserve">
          <source>Executes an IO computation with asynchronous exceptions &lt;em&gt;masked&lt;/em&gt;. That is, any thread which attempts to raise an exception in the current thread with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will be blocked until asynchronous exceptions are unmasked again.</source>
          <target state="translated">非同期例外を&lt;em&gt;マスク&lt;/em&gt;してIO計算を実行します。つまり、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; を使用して現在のスレッドで例外を発生させようとするスレッドは、非同期例外が再びマスク解除されるまでブロックされます。</target>
        </trans-unit>
        <trans-unit id="46ec0e1cddb9075cc884b834b53f50ddc817ddcc" translate="yes" xml:space="preserve">
          <source>Executes an IO computation with asynchronous exceptions &lt;em&gt;masked&lt;/em&gt;. That is, any thread which attempts to raise an exception in the current thread with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will be blocked until asynchronous exceptions are unmasked again.</source>
          <target state="translated">非同期例外を&lt;em&gt;マスク&lt;/em&gt;してIO計算を実行します。つまり、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; を使用して現在のスレッドで例外を発生させようとするスレッドは、非同期例外が再びマスク解除されるまでブロックされます。</target>
        </trans-unit>
        <trans-unit id="60c9626b83b84fd2f338afec521f991b9505634c" translate="yes" xml:space="preserve">
          <source>Executes an IO computation with asynchronous exceptions &lt;em&gt;masked&lt;/em&gt;. That is, any thread which attempts to raise an exception in the current thread with &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will be blocked until asynchronous exceptions are unmasked again.</source>
          <target state="translated">非同期例外を&lt;em&gt;マスク&lt;/em&gt;してIO計算を実行します。つまり、 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; を使用して現在のスレッドで例外を発生させようとするスレッドは、非同期例外が再びマスク解除されるまでブロックされます。</target>
        </trans-unit>
        <trans-unit id="778dbd9e9bf309d9af09860bc9150a182f094e04" translate="yes" xml:space="preserve">
          <source>Executes an IO computation with asynchronous exceptions &lt;em&gt;masked&lt;/em&gt;. That is, any thread which attempts to raise an exception in the current thread with &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will be blocked until asynchronous exceptions are unmasked again.</source>
          <target state="translated">非同期例外を&lt;em&gt;マスク&lt;/em&gt;してIO計算を実行します。つまり、 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; を使用して現在のスレッドで例外を発生させようとするスレッドは、非同期例外が再びマスク解除されるまでブロックされます。</target>
        </trans-unit>
        <trans-unit id="a7ed1222c5da10b5796d9be8df9484fce7ea06e0" translate="yes" xml:space="preserve">
          <source>Executes the GHCi built-in command (e.g. &lt;code&gt;::type 3&lt;/code&gt;). That is, look up on the list of builtin commands, excluding defined macros. See also: &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHCi組み込みコマンド（例 &lt;code&gt;::type 3&lt;/code&gt; ）を実行します。つまり、定義済みのマクロを除いて、組み込みコマンドのリストを検索します。参照&lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fbee69c7c6cc3983066537c6b9014eb13e8768e2" translate="yes" xml:space="preserve">
          <source>Executes the lines of a file as a series of GHCi commands. The syntax for file-name arguments respects shell quoting rules, i.e., file names containing spaces can be enclosed in double quotes or with spaces escaped with a backslash. This command is compatible with multiline statements as set by &lt;a href=&quot;#ghci-cmd-:set%20+m&quot;&gt;&lt;code&gt;:set +m&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">ファイルの行を一連のGHCiコマンドとして実行します。ファイル名引数の構文は、シェルの引用符規則を尊重します。つまり、スペースを含むファイル名は、二重引用符で囲むか、スペースを円記号で区切ることができます。このコマンドは、&lt;a href=&quot;#ghci-cmd-:set%20+m&quot;&gt; &lt;code&gt;:set +m&lt;/code&gt; &lt;/a&gt;設定された複数行のステートメントと互換性があります</target>
        </trans-unit>
        <trans-unit id="f33de9056690f98ecc8c217e510931ae85b64fa5" translate="yes" xml:space="preserve">
          <source>Executes the lines of a file as a series of GHCi commands. This command is compatible with multiline statements as set by &lt;a href=&quot;#ghci-cmd-:set%20+m&quot;&gt;&lt;code&gt;:set +m&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">ファイルの行を一連のGHCiコマンドとして実行します。このコマンドは、&lt;a href=&quot;#ghci-cmd-:set%20+m&quot;&gt; &lt;code&gt;:set +m&lt;/code&gt; &lt;/a&gt;設定された複数行ステートメントと互換性があります</target>
        </trans-unit>
        <trans-unit id="88c84a00bbe497217dba4b84e9db2cf8c6f33404" translate="yes" xml:space="preserve">
          <source>Executes the shell command ⟨command⟩.</source>
          <target state="translated">シェルコマンド ⟨command⟩ を実行します。</target>
        </trans-unit>
        <trans-unit id="130a9408743cf5a376559c419e05f9b8d8b461ba" translate="yes" xml:space="preserve">
          <source>Executes ⟨expr⟩ as a computation of type &lt;code&gt;IO String&lt;/code&gt;, and then executes the resulting string as a list of GHCi commands. Multiple commands are separated by newlines. The &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt;&lt;code&gt;:cmd&lt;/code&gt;&lt;/a&gt; command is useful with &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt;&lt;code&gt;:set stop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">「expr」を &lt;code&gt;IO String&lt;/code&gt; 型の計算として実行し、結果の文字列をGHCiコマンドのリストとして実行します。複数のコマンドは改行で区切られます。&lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt; &lt;code&gt;:cmd&lt;/code&gt; &lt;/a&gt;コマンドはと便利です&lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt; &lt;code&gt;:set stop&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="df5c4bfe66f918bc7c61afbbe38d05d87f6b7882" translate="yes" xml:space="preserve">
          <source>Executing Builders</source>
          <target state="translated">ビルダーの実行</target>
        </trans-unit>
        <trans-unit id="520995e98a5bbbbf4ce95c15e55e45c660e4b3b8" translate="yes" xml:space="preserve">
          <source>Executing an external command.</source>
          <target state="translated">外部コマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="6d525b71568c2d982f46feb96b332bedcdc6e4a0" translate="yes" xml:space="preserve">
          <source>Execution</source>
          <target state="translated">Execution</target>
        </trans-unit>
        <trans-unit id="b0b8748c9d02d8c4d95223629ecf3c2f6ccc5b43" translate="yes" xml:space="preserve">
          <source>Execution can be single-stepped: the evaluator will suspend execution approximately after every reduction, allowing local variables to be inspected. This is equivalent to setting a breakpoint at every point in the program.</source>
          <target state="translated">実行はシングルステップで行うことができます。評価器は、各削減の後に約一旦実行を中断し、ローカル変数を検査できるようにします。これは、プログラムの各ポイントにブレークポイントを設定することと同等です。</target>
        </trans-unit>
        <trans-unit id="52ff4dea904274d587ed05e7bceeb9003bc66ab2" translate="yes" xml:space="preserve">
          <source>Execution can take place in tracing mode, in which the evaluator remembers each evaluation step as it happens, but doesn&amp;rsquo;t suspend execution until an actual breakpoint is reached. When this happens, the history of evaluation steps can be inspected.</source>
          <target state="translated">実行はトレースモードで実行できます。このモードでは、エバリュエーターは各評価ステップを発生時に記憶しますが、実際のブレークポイントに達するまで実行を中断しません。これが発生すると、評価ステップの履歴を検査できます。</target>
        </trans-unit>
        <trans-unit id="d4a32174885111edde7b30c063a41b35b8521952" translate="yes" xml:space="preserve">
          <source>Execution has stopped at the breakpoint. The prompt has changed to indicate that we are currently stopped at a breakpoint, and the location: &lt;code&gt;[qsort.hs:2:15-46]&lt;/code&gt;. To further clarify the location, we can use the &lt;a href=&quot;#ghci-cmd-:list&quot;&gt;&lt;code&gt;:list&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">ブレークポイントで実行が停止しました。プロンプトは現在、ブレークポイントで停止していることを示すように変更されており、場所は &lt;code&gt;[qsort.hs:2:15-46]&lt;/code&gt; です。場所をさらに明確にするために、&lt;a href=&quot;#ghci-cmd-:list&quot;&gt; &lt;code&gt;:list&lt;/code&gt; &lt;/a&gt;コマンドを使用できます。</target>
        </trans-unit>
        <trans-unit id="b38d4aa4381d31a400e67cc71ccd460974a035c6" translate="yes" xml:space="preserve">
          <source>Execution phase markers</source>
          <target state="translated">実行フェーズマーカー</target>
        </trans-unit>
        <trans-unit id="b6a16f53ed00195637e6e17e5494787580135e59" translate="yes" xml:space="preserve">
          <source>Execution strategies</source>
          <target state="translated">実行戦略</target>
        </trans-unit>
        <trans-unit id="cadc56108302cd7d8880934930f927b8c99fbe2b" translate="yes" xml:space="preserve">
          <source>Existence tests</source>
          <target state="translated">存在テスト</target>
        </trans-unit>
        <trans-unit id="5e7584235c55bf0269fd90b3b4973495fe948001" translate="yes" xml:space="preserve">
          <source>ExistentialQuantification</source>
          <target state="translated">ExistentialQuantification</target>
        </trans-unit>
        <trans-unit id="e47aae11b0445849d13a157318e577826b351212" translate="yes" xml:space="preserve">
          <source>Exit the iserv process</source>
          <target state="translated">iservプロセスを終了します。</target>
        </trans-unit>
        <trans-unit id="cb193431524e4fae58710e9d90f4bc84b69056c1" translate="yes" xml:space="preserve">
          <source>ExitCaseAbort</source>
          <target state="translated">ExitCaseAbort</target>
        </trans-unit>
        <trans-unit id="0ff1b7133e455e31a96b40324f51f574297a78d9" translate="yes" xml:space="preserve">
          <source>ExitCode</source>
          <target state="translated">ExitCode</target>
        </trans-unit>
        <trans-unit id="9627d6dbece3ab140288e68f186ca8a53c5850a2" translate="yes" xml:space="preserve">
          <source>ExitSuccess</source>
          <target state="translated">ExitSuccess</target>
        </trans-unit>
        <trans-unit id="85e8ee4560b4d8b0a12df383127ad6ef2e825d1e" translate="yes" xml:space="preserve">
          <source>Exiting</source>
          <target state="translated">Exiting</target>
        </trans-unit>
        <trans-unit id="c80dbce7b21ef649a1c74b9ef8ebe0514f23c1e1" translate="yes" xml:space="preserve">
          <source>Exiting the program.</source>
          <target state="translated">プログラムを終了します。</target>
        </trans-unit>
        <trans-unit id="5871b8d86fba0af13c05dc83a5e5933bb7903327" translate="yes" xml:space="preserve">
          <source>Exp</source>
          <target state="translated">Exp</target>
        </trans-unit>
        <trans-unit id="78e98755476e343b08d10ea6578596f90d796f0c" translate="yes" xml:space="preserve">
          <source>ExpQ</source>
          <target state="translated">ExpQ</target>
        </trans-unit>
        <trans-unit id="9869e506c38f643f1fe985347c015deace6baa22" translate="yes" xml:space="preserve">
          <source>Expand</source>
          <target state="translated">Expand</target>
        </trans-unit>
        <trans-unit id="8f96935efd9a006ac921c7dacf0d186433812322" translate="yes" xml:space="preserve">
          <source>Expects an absolute file path.</source>
          <target state="translated">ファイルの絶対パスを期待します。</target>
        </trans-unit>
        <trans-unit id="51dd39f18dcb2e2562fb241ac2f6aeea3606be0c" translate="yes" xml:space="preserve">
          <source>Explicit &lt;code&gt;forall&lt;/code&gt; is not always required &amp;ndash; see &lt;a href=&quot;#pattern-equiv-form&quot;&gt;pattern signature equivalent&lt;/a&gt; for the example in this section, or &lt;a href=&quot;#pattern-type-sigs&quot;&gt;Pattern type signatures&lt;/a&gt;.</source>
          <target state="translated">明示的な &lt;code&gt;forall&lt;/code&gt; は必ずしも必要ではありません。このセクションの例と&lt;a href=&quot;#pattern-equiv-form&quot;&gt;同等のパターンシグネチャ&lt;/a&gt;、または&lt;a href=&quot;#pattern-type-sigs&quot;&gt;パターンタイプシグネチャを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6fa2778c6121e57a5aad745d718637106bc0e5c3" translate="yes" xml:space="preserve">
          <source>Explicit braces and semicolons can be used instead of layout:</source>
          <target state="translated">明示的な中括弧やセミコロンをレイアウトの代わりに使うことができます。</target>
        </trans-unit>
        <trans-unit id="5cda5ab7163622c96737f0b582eb504bee024916" translate="yes" xml:space="preserve">
          <source>Explicit lists (e.g. &lt;code&gt;[True, False]&lt;/code&gt;)</source>
          <target state="translated">明示的なリスト（例： &lt;code&gt;[True, False]&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="9833c09c86535a2d945ed19a1102c3bdf82ae3e8" translate="yes" xml:space="preserve">
          <source>ExplicitForAll</source>
          <target state="translated">ExplicitForAll</target>
        </trans-unit>
        <trans-unit id="8d15960eecc2d5f40b4acc3f555b51fa8aaf3c23" translate="yes" xml:space="preserve">
          <source>ExplicitNamespaces</source>
          <target state="translated">ExplicitNamespaces</target>
        </trans-unit>
        <trans-unit id="02890a2e735d14626c63f3129c86c7cdabb1bec5" translate="yes" xml:space="preserve">
          <source>Explicitly Bidirectional</source>
          <target state="translated">明示的に双方向性</target>
        </trans-unit>
        <trans-unit id="2d4285ba133d39020951d187ad418ec009ca8997" translate="yes" xml:space="preserve">
          <source>Explicitly bidirectional pattern synonyms offer greater flexibility than implicitly bidirectional ones in terms of the syntax that is permitted. For instance, the following is not a legal implicitly bidirectional pattern synonym:</source>
          <target state="translated">明示的に双方向性のパターン同義語は、暗黙的に双方向性のパターン同義語よりも、許可されている構文の点で柔軟性が高い。例えば、次のようなものは、合法的な暗黙の双方向性パターン同義語ではありません。</target>
        </trans-unit>
        <trans-unit id="ef7581dde501937e3e482f6cd7c00557b65093e7" translate="yes" xml:space="preserve">
          <source>Explicitly run the finaliser associated with a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. References to this value after finalisation may generate invalid memory references.</source>
          <target state="translated">ByteStringに関連付けられた &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ライザーを明示的に実行します。ファイナライズ後にこの値を参照すると、無効なメモリ参照が生成される場合があります。</target>
        </trans-unit>
        <trans-unit id="e9b873f46071db66ba372c05baac4fdf01be75c1" translate="yes" xml:space="preserve">
          <source>Exponent</source>
          <target state="translated">Exponent</target>
        </trans-unit>
        <trans-unit id="877e2989e6c895bad022c9991582cbad6570c551" translate="yes" xml:space="preserve">
          <source>Exponentiation of type-level naturals.</source>
          <target state="translated">タイプレベルの自然数の指数化。</target>
        </trans-unit>
        <trans-unit id="00626a4a235bb8c7d8a4523a50b2711b29b68253" translate="yes" xml:space="preserve">
          <source>Exponentiation.</source>
          <target state="translated">Exponentiation.</target>
        </trans-unit>
        <trans-unit id="f3e4fadb9e370a1e2c0c622c01fc8c77daf93a2c" translate="yes" xml:space="preserve">
          <source>Export</source>
          <target state="translated">Export</target>
        </trans-unit>
        <trans-unit id="e32d807a50078398a9f45631a08c1c50a2f61bc8" translate="yes" xml:space="preserve">
          <source>Exports just the class name.</source>
          <target state="translated">クラス名だけをエクスポートします。</target>
        </trans-unit>
        <trans-unit id="3fc8d12d849fbc12100a92378eb6aae4e19b9f4a" translate="yes" xml:space="preserve">
          <source>Exports the class, the associated type &lt;code&gt;GMap&lt;/code&gt; and the member functions &lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;lookup&lt;/code&gt;, and &lt;code&gt;insert&lt;/code&gt;. The data constructors of &lt;code&gt;GMap&lt;/code&gt; (in this case &lt;code&gt;GMapEither&lt;/code&gt;) are not exported.</source>
          <target state="translated">クラス、関連する型 &lt;code&gt;GMap&lt;/code&gt; 、メンバー関数 &lt;code&gt;empty&lt;/code&gt; 、 &lt;code&gt;lookup&lt;/code&gt; 、および &lt;code&gt;insert&lt;/code&gt; をエクスポートします。 &lt;code&gt;GMap&lt;/code&gt; のデータコンストラクター（この場合は &lt;code&gt;GMapEither&lt;/code&gt; ）はエクスポートされません。</target>
        </trans-unit>
        <trans-unit id="96d97ba437aa14160758958471b9ae9dd5fd0d5d" translate="yes" xml:space="preserve">
          <source>Expose all unfoldings, even for very large or recursive functions.</source>
          <target state="translated">非常に大きな関数や再帰的な関数であっても、すべての展開を公開します。</target>
        </trans-unit>
        <trans-unit id="97a05c5e3c535062788e96f9df6b2c9df3c0c670" translate="yes" xml:space="preserve">
          <source>Expose package by id ⟨unit-id⟩</source>
          <target state="translated">パッケージを ID ⟨unit-id ⟩ で公開します。</target>
        </trans-unit>
        <trans-unit id="37688778d1dbdfb3378a202fe8582b76a44a828a" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩</source>
          <target state="translated">パッケージを公開 ⟨pkg⟩</target>
        </trans-unit>
        <trans-unit id="81f3b1cdb0761f66a9a464a1c7c58d8507de68a8" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩ and set it to be distrusted. See &lt;a href=&quot;exts/safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;.</source>
          <target state="translated">パッケージ⟨pkg⟩を公開し、信頼できないように設定します。&lt;a href=&quot;exts/safe_haskell#safe-haskell&quot;&gt;SafeHaskellを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e8c2973c3230c9855092c9a09e0ad4f1866c0b24" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩ and set it to be distrusted. See &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;.</source>
          <target state="translated">パッケージ「pkg」を公開し、信頼できないように設定します。&lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskellを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="11e656340a6337a3a218f8e6e5a6343ef2676dc0" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩ and set it to be trusted. See &lt;a href=&quot;exts/safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;.</source>
          <target state="translated">パッケージ⟨pkg⟩を公開し、信頼できるように設定します。&lt;a href=&quot;exts/safe_haskell#safe-haskell&quot;&gt;SafeHaskellを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="80e66e14fce5ee7a55e29cdb00dc7373ae77bc67" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩ and set it to be trusted. See &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;.</source>
          <target state="translated">パッケージ「pkg」を公開し、信頼できるように設定します。&lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskellを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0a89902d15adce30fd9f53b376aa347621678477" translate="yes" xml:space="preserve">
          <source>Expose ⟨pkg-id⟩ for plugins</source>
          <target state="translated">プラグインのために⟨pkg-id⟩を公開する</target>
        </trans-unit>
        <trans-unit id="0d375bc2563394c46196316fad7e222d95093011" translate="yes" xml:space="preserve">
          <source>Expose ⟨pkg⟩ for plugins</source>
          <target state="translated">プラグインのために⟨pkg⟩を公開します。</target>
        </trans-unit>
        <trans-unit id="31273b92a37ac408e2bf693485bae87890959943" translate="yes" xml:space="preserve">
          <source>Exposes a package in the plugin namespace like &lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package
⟨pkg⟩&lt;/code&gt;&lt;/a&gt;, but the package is named by its installed package ID rather than by name. This is a more robust way to name packages, and can be used to select packages that would otherwise be shadowed. Cabal passes &lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt;&lt;/a&gt; flags to GHC. &lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt;&lt;/a&gt; supports thinning and renaming described in &lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt;ように、プラグイン名前空間でパッケージを公開しますが、パッケージの名前は、名前ではなく、インストールされているパッケージIDです。これは、パッケージに名前を付けるためのより堅牢な方法であり、他の方法ではシャドウされるパッケージを選択するために使用できます。 Cabalは&lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt; &lt;/a&gt;フラグをGHCに渡します。&lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt; &lt;/a&gt;は、「&lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;モジュールの間引きと名前&lt;/a&gt;変更」で説明されている間引きと名前変更をサポートします。</target>
        </trans-unit>
        <trans-unit id="7282a9f671014a5a12b95db9b6e9d0017367cafb" translate="yes" xml:space="preserve">
          <source>Exposes a package like &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt;, but the package is named by its unit ID (i.e. the value of &lt;code&gt;id&lt;/code&gt; in its entry in the installed package database, also previously known as an installed package ID) rather than by name. This is a more robust way to name packages, and can be used to select packages that would otherwise be shadowed. Cabal passes &lt;code&gt;-package-id&lt;/code&gt; flags to GHC. &lt;code&gt;-package-id&lt;/code&gt; supports thinning and renaming described in &lt;a href=&quot;#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt;ようなパッケージを公開しますが、パッケージは、名前ではなく、ユニットID（つまり、インストール済みパッケージデータベースのエントリの &lt;code&gt;id&lt;/code&gt; の値、以前はインストール済みパッケージIDとも呼ばれていました）によって名前が付けられます。これは、パッケージに名前を付けるためのより堅牢な方法であり、他の方法ではシャドウされるパッケージを選択するために使用できます。Cabalは &lt;code&gt;-package-id&lt;/code&gt; フラグをGHCに渡します。 &lt;code&gt;-package-id&lt;/code&gt; は&lt;a href=&quot;#package-thinning-and-renaming&quot;&gt;、モジュールの間引きと名前&lt;/a&gt;変更で説明されている間引きと名前変更をサポートします。</target>
        </trans-unit>
        <trans-unit id="eba39a9246ec8d3133e56adef9502fd5768f6301" translate="yes" xml:space="preserve">
          <source>Exposes package ⟨pkg⟩ if it was hidden and considers it a trusted package regardless of the package database.</source>
          <target state="translated">パッケージが隠されていた場合には、パッケージを公開し、パッケージデータベースに関係なく信頼されたパッケージとみなします。</target>
        </trans-unit>
        <trans-unit id="1863c0103a35229fbd10f03c71eaa9dfd10d3726" translate="yes" xml:space="preserve">
          <source>Exposes package ⟨pkg⟩ if it was hidden and considers it an untrusted package regardless of the package database.</source>
          <target state="translated">パッケージが隠されていた場合、パッケージデータベースに関係なく信頼されないパッケージとみなして、パッケージを公開します。</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="b4b58a3bd3bca39250be0caf31bc3f191c3d3f5c" translate="yes" xml:space="preserve">
          <source>Expression quotations accept most Haskell language constructs. However, there are some GHC-specific extensions which expression quotations currently do not support, including</source>
          <target state="translated">式引用符はほとんどのHaskell言語の構文を受け入れます。しかし、式引用符が現在サポートしていないいくつかのGHC固有の拡張があります。</target>
        </trans-unit>
        <trans-unit id="776e1ed70ff53446d3e23e14206d1868975984de" translate="yes" xml:space="preserve">
          <source>Expression splices: anonymous and named wildcards can be used in expression signatures. Extra-constraints wildcards are not supported, just like in regular expression signatures.</source>
          <target state="translated">式のスプライス:匿名ワイルドカードと名前付きワイルドカードは式署名で使用できます。通常の式署名と同様に、余分な制約のあるワイルドカードはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="4c356f5e7e4d5da3fa92f3a447cf549c220408dd" translate="yes" xml:space="preserve">
          <source>Expression type annotations</source>
          <target state="translated">表現形式のアノテーション</target>
        </trans-unit>
        <trans-unit id="3da441768abbdbc67e62f834d5dc1520b1d2404c" translate="yes" xml:space="preserve">
          <source>Expression-evaluation mode. This is very similar to interactive mode, except that there is a single expression to evaluate (⟨expr⟩) which is given on the command line. See &lt;a href=&quot;#eval-mode&quot;&gt;Expression evaluation mode&lt;/a&gt; for more details.</source>
          <target state="translated">式評価モード。これはインタラクティブモードと非常に似ていますが、コマンドラインで指定する単一の式（ &quot;expr&quot;）が評価される点が異なります。詳細については、&lt;a href=&quot;#eval-mode&quot;&gt;式評価モード&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="275a91a95ab556ed8f4f58810f3754cc004740c4" translate="yes" xml:space="preserve">
          <source>Exquisitely unsafe.</source>
          <target state="translated">絶妙に安全ではない。</target>
        </trans-unit>
        <trans-unit id="f20ecbb0b8def6d6be9c1c1d5504d4aa8e121b40" translate="yes" xml:space="preserve">
          <source>Extended euclidean algorithm.</source>
          <target state="translated">拡張ユークリッドアルゴリズム。</target>
        </trans-unit>
        <trans-unit id="1376ee00053aa4b8f335d718cd6b32eade0d6b7b" translate="yes" xml:space="preserve">
          <source>Extended version of &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt; の拡張バージョン</target>
        </trans-unit>
        <trans-unit id="2fde66be8f0b7d74100f58661df4304a6a4125c1" translate="yes" xml:space="preserve">
          <source>ExtendedDefaultRules</source>
          <target state="translated">ExtendedDefaultRules</target>
        </trans-unit>
        <trans-unit id="a5fe846d7930403bb12925a53f1812f6d7b386f3" translate="yes" xml:space="preserve">
          <source>ExtendedFormat</source>
          <target state="translated">ExtendedFormat</target>
        </trans-unit>
        <trans-unit id="d297572cdf75e0fc69b0851ecb181ba44e9e43c3" translate="yes" xml:space="preserve">
          <source>ExtendedFunctions</source>
          <target state="translated">ExtendedFunctions</target>
        </trans-unit>
        <trans-unit id="19831f202245d7d2e8594d815d8ec9b0ca11a673" translate="yes" xml:space="preserve">
          <source>Extending To New Types</source>
          <target state="translated">新しいタイプへの拡張</target>
        </trans-unit>
        <trans-unit id="d9d7e1571d0f21e76efd77f308d22979ff95823f" translate="yes" xml:space="preserve">
          <source>Extending the atomicity to multiple &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;s is problematic, so it is recommended that if you need to do anything more complicated then using &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; instead is a good idea.</source>
          <target state="translated">原子性を複数の &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; に拡張することは問題が多いため、複雑なことを行う必要がある場合は、代わりに &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="32e045360ba1cab276fc39bb4d35f14e0162488f" translate="yes" xml:space="preserve">
          <source>Extensible Exceptions</source>
          <target state="translated">拡張可能な例外</target>
        </trans-unit>
        <trans-unit id="659087d3ca23db6ae11e0a43579b5f4a260dda11" translate="yes" xml:space="preserve">
          <source>Extension</source>
          <target state="translated">Extension</target>
        </trans-unit>
        <trans-unit id="0508e77219f46be972ce3c02c3d431e8dfa41ced" translate="yes" xml:space="preserve">
          <source>Extension functions</source>
          <target state="translated">拡張機能</target>
        </trans-unit>
        <trans-unit id="b548c2c0e4fdd3a3b443d1717032aa1c37d0f158" translate="yes" xml:space="preserve">
          <source>External API for GHC's Handle implementation</source>
          <target state="translated">GHCのハンドル実装のための外部API</target>
        </trans-unit>
        <trans-unit id="16bb88e5a699d082f65df34dff99c2cc562f221d" translate="yes" xml:space="preserve">
          <source>Extra attributes in XHTML Frameset</source>
          <target state="translated">XHTML フレームセットの追加属性</target>
        </trans-unit>
        <trans-unit id="f69729e705bc5ed85ac415d6b079562cec0ad227" translate="yes" xml:space="preserve">
          <source>Extra attributes in XHTML Transitional</source>
          <target state="translated">XHTML Transitional の追加属性</target>
        </trans-unit>
        <trans-unit id="553906fce6304e8619f26f965d66b3c128e56184" translate="yes" xml:space="preserve">
          <source>Extra elements in XHTML Frameset</source>
          <target state="translated">XHTML フレームセットの追加要素</target>
        </trans-unit>
        <trans-unit id="26b12138ed5c4f776e03e07094f229d75bf93c68" translate="yes" xml:space="preserve">
          <source>Extra elements in XHTML Transitional</source>
          <target state="translated">XHTMLの余分な要素</target>
        </trans-unit>
        <trans-unit id="da60db19e688c9d65306dbe01f15f0fdb2f70b5e" translate="yes" xml:space="preserve">
          <source>Extra functions for creating and executing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. They are intended for application-specific fine-tuning the performance of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; を作成および実行するための追加機能。これらは、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; のパフォーマンスをアプリケーション固有に微調整することを目的としています。</target>
        </trans-unit>
        <trans-unit id="376098e515a5a7a4ad09f15cc26f6f580a3f3f98" translate="yes" xml:space="preserve">
          <source>Extra instances</source>
          <target state="translated">追加インスタンス</target>
        </trans-unit>
        <trans-unit id="9007458c8fef52cf2dfc82ca45560435a502b151" translate="yes" xml:space="preserve">
          <source>Extra libraries may be specified on the command line using the normal &lt;code&gt;-llib&lt;/code&gt; option. (The term &lt;em&gt;library&lt;/em&gt; here refers to libraries of foreign object code; for using libraries of Haskell source code, see &lt;a href=&quot;#ghci-modules-filenames&quot;&gt;Modules vs. filenames&lt;/a&gt;.) For example, to load the &amp;ldquo;m&amp;rdquo; library:</source>
          <target state="translated">通常の &lt;code&gt;-llib&lt;/code&gt; オプションを使用して、コマンドラインで追加のライブラリを指定できます。（ここでの&lt;em&gt;ライブラリ&lt;/em&gt;という用語は、外部オブジェクトコードのライブラリを指します。Haskellソースコードのライブラリを使用するには、「&lt;a href=&quot;#ghci-modules-filenames&quot;&gt;モジュールとファイル名の比較&lt;/a&gt;」を参照してください。）たとえば、「m」ライブラリをロードするには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="94db6ab5b7a358912d06ebf314fa45afb8a5bfbb" translate="yes" xml:space="preserve">
          <source>Extra-constraints wildcards cannot be named.</source>
          <target state="translated">余分な制約のワイルドカードは名前を付けることができません。</target>
        </trans-unit>
        <trans-unit id="85204331cdc5a5234455094d82f670148ee95ebf" translate="yes" xml:space="preserve">
          <source>Extract &lt;em&gt;n&lt;/em&gt;-th (0-based) limb in &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;. &lt;em&gt;n&lt;/em&gt; must be less than size as reported by &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeofBigNat-35-&quot;&gt;sizeofBigNat#&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">抽出&lt;em&gt;N&lt;/em&gt;番目（0系）における四肢 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 。&lt;em&gt;n&lt;/em&gt;は &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeofBigNat-35-&quot;&gt;sizeofBigNat#&lt;/a&gt;&lt;/code&gt; によって報告されるサイズより小さくなければなりません。</target>
        </trans-unit>
        <trans-unit id="83cd2d2591e39909edf59b0149e6f118b65261cb" translate="yes" xml:space="preserve">
          <source>Extract a Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; from a Haskell &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and perform an action on it.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; からWindows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; を抽出し、それに対してアクションを実行します。</target>
        </trans-unit>
        <trans-unit id="8caedd806eb75a1dd1593915008b003746bd2766" translate="yes" xml:space="preserve">
          <source>Extract a Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; from a Haskell &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and perform an action on it.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; からWindows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; を抽出し、アクションを実行します。</target>
        </trans-unit>
        <trans-unit id="e1fa28e22bcf37a9620ff9632c0178f62249b64b" translate="yes" xml:space="preserve">
          <source>Extract a Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; from a Haskell &lt;code&gt;&lt;a href=&quot;../base/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and perform an action on it.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;../base/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; からWindows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; を抽出し、アクションを実行します。</target>
        </trans-unit>
        <trans-unit id="19459f6f6029b9562ac7b8bae42f2d17949ad995" translate="yes" xml:space="preserve">
          <source>Extract a list of call-sites from the &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; から呼び出しサイトのリストを抽出します。</target>
        </trans-unit>
        <trans-unit id="dac372cf1e3a7a31e848e034a3e801d7adfa82f1" translate="yes" xml:space="preserve">
          <source>Extract a list of call-sites from the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; から呼び出しサイトのリストを抽出します。</target>
        </trans-unit>
        <trans-unit id="15320bf99294a6713c984fb7ea9afb23bf9f7574" translate="yes" xml:space="preserve">
          <source>Extract a list of call-sites from the &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; から呼び出しサイトのリストを抽出します。</target>
        </trans-unit>
        <trans-unit id="b3c94be241aef7a388442a14750ccab2863f4fb0" translate="yes" xml:space="preserve">
          <source>Extract a witness of equality of two types</source>
          <target state="translated">2種類の平等の証人を抽出</target>
        </trans-unit>
        <trans-unit id="1c9f2b2fd473a09dd65773f2fc4162151096161e" translate="yes" xml:space="preserve">
          <source>Extract bits from a word at locations specified by a mask.</source>
          <target state="translated">マスクで指定された位置にあるワードからビットを抽出します。</target>
        </trans-unit>
        <trans-unit id="f3c5f3c2ea4a5cd70d10527f67daa863bccf6943" translate="yes" xml:space="preserve">
          <source>Extract bits from lower 16 bits of a word at locations specified by a mask.</source>
          <target state="translated">マスクで指定された位置のワードの下位16ビットからビットを抽出します。</target>
        </trans-unit>
        <trans-unit id="c24c9008df295389591cc7deb4f2a2d68e7c6b1c" translate="yes" xml:space="preserve">
          <source>Extract bits from lower 32 bits of a word at locations specified by a mask.</source>
          <target state="translated">マスクで指定された位置のワードの下位32ビットからビットを抽出します。</target>
        </trans-unit>
        <trans-unit id="f2cc34ff176f2175e6e34bb0cdc8cd7517e09bd6" translate="yes" xml:space="preserve">
          <source>Extract bits from lower 8 bits of a word at locations specified by a mask.</source>
          <target state="translated">マスクで指定された位置のワードの下位8ビットからビットを抽出します。</target>
        </trans-unit>
        <trans-unit id="f1857d7fa6cd46609ec91ad030bedb1462ff8de3" translate="yes" xml:space="preserve">
          <source>Extract equality of the arguments from an equality of applied types</source>
          <target state="translated">適用型の等式から引数の等式を抽出する</target>
        </trans-unit>
        <trans-unit id="a99a8380cb42a1ba110471522ef91ef98bfe57c8" translate="yes" xml:space="preserve">
          <source>Extract equality of type constructors from an equality of applied types</source>
          <target state="translated">適用された型の等質性から型の等質性のコンストラクタを抽出する</target>
        </trans-unit>
        <trans-unit id="209b131507b67783064eca27720c5bbe3fbc4b1e" translate="yes" xml:space="preserve">
          <source>Extract everything except the last element of the stream.</source>
          <target state="translated">ストリームの最後の要素以外をすべて抽出します。</target>
        </trans-unit>
        <trans-unit id="e6da9a2e3b63f515594693602b689849079aaa62" translate="yes" xml:space="preserve">
          <source>Extract the denominator of the ratio in reduced form: the numerator and denominator have no common factor and the denominator is positive.</source>
          <target state="translated">比率の分母を縮小形で抽出する:分子と分母には共通因子がなく、分母は正である。</target>
        </trans-unit>
        <trans-unit id="faa5733bddece05d48a2d5fab4a6b5d19927ff0f" translate="yes" xml:space="preserve">
          <source>Extract the first component of a pair.</source>
          <target state="translated">ペアの最初の成分を抽出します。</target>
        </trans-unit>
        <trans-unit id="8e1431bbaba37fcca3d788ca32422f37c47e0f53" translate="yes" xml:space="preserve">
          <source>Extract the first element of the stream.</source>
          <target state="translated">ストリームの最初の要素を抽出します。</target>
        </trans-unit>
        <trans-unit id="74dba7610acef8dde9eb95e9dcdd115a56c67e63" translate="yes" xml:space="preserve">
          <source>Extract the last element of the stream.</source>
          <target state="translated">ストリームの最後の要素を抽出します。</target>
        </trans-unit>
        <trans-unit id="71672882a12f0371a79613a5b2a1896e09a4aea8" translate="yes" xml:space="preserve">
          <source>Extract the message string from an error message</source>
          <target state="translated">エラーメッセージからメッセージ文字列を抽出</target>
        </trans-unit>
        <trans-unit id="0627b6c102c0812e00a5765ad3ea478aeb42dc0d" translate="yes" xml:space="preserve">
          <source>Extract the numerator of the ratio in reduced form: the numerator and denominator have no common factor and the denominator is positive.</source>
          <target state="translated">比率の分子を縮小形で抽出する:分子と分母には共通因子がなく、分母は正である。</target>
        </trans-unit>
        <trans-unit id="ccae588e4f18a0d7150f16e84a2466cf53e67121" translate="yes" xml:space="preserve">
          <source>Extract the output from a writer computation.</source>
          <target state="translated">ライタ計算から出力を抽出します。</target>
        </trans-unit>
        <trans-unit id="e13a7d27f5717a8051ad34044b84ac3c322dad08" translate="yes" xml:space="preserve">
          <source>Extract the output from an accumulation computation.</source>
          <target state="translated">累積計算から出力を抽出します。</target>
        </trans-unit>
        <trans-unit id="9b59da5a9fb1822fe3838decbce6b18c7bb10353" translate="yes" xml:space="preserve">
          <source>Extract the possibly-empty tail of the stream.</source>
          <target state="translated">空の可能性のあるストリームのテールを抽出します。</target>
        </trans-unit>
        <trans-unit id="c80d49f20d5312d630bb4c89de7be96ba635eeb8" translate="yes" xml:space="preserve">
          <source>Extract the second component of a pair.</source>
          <target state="translated">ペアの第二成分を抽出します。</target>
        </trans-unit>
        <trans-unit id="048e8268764c5263423031088d1cd0a66e5df985" translate="yes" xml:space="preserve">
          <source>Extract the untyped representation from the typed representation</source>
          <target state="translated">型付けされた表現から型付けされていない表現を抽出する</target>
        </trans-unit>
        <trans-unit id="f87182d58b2e5c3b8ac01884cc785fccbf6f2e02" translate="yes" xml:space="preserve">
          <source>Extracting components of fractions.</source>
          <target state="translated">分画の成分を抽出します。</target>
        </trans-unit>
        <trans-unit id="66c1d08c125187599a1f446de72b7b3934ea1356" translate="yes" xml:space="preserve">
          <source>Extracting sublists</source>
          <target state="translated">サブリストの抽出</target>
        </trans-unit>
        <trans-unit id="1e06f8844a90f3392493e9ddf149b5c480a88612" translate="yes" xml:space="preserve">
          <source>Extractor for computations in the exception monad. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">例外モナドでの計算のためのエクストラクター。（ &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt; の逆）。</target>
        </trans-unit>
        <trans-unit id="f6f7a3f48fe2a36a8d1f4f84df1cff70314fddb2" translate="yes" xml:space="preserve">
          <source>Extractor for computations in the exception monad. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">例外モナドでの計算のためのエクストラクター。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt; の逆）。</target>
        </trans-unit>
        <trans-unit id="3aca5f828a77e707fa46ed0c55a1b00b856836a4" translate="yes" xml:space="preserve">
          <source>Extractor for computations with accumulating errors.</source>
          <target state="translated">累積エラーを伴う計算のための抽出器です。</target>
        </trans-unit>
        <trans-unit id="e2053668b7ebb2019a802842e9789436a8c0f771" translate="yes" xml:space="preserve">
          <source>Extracts from a list of &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; all the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; elements. All the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; elements are extracted in order.</source>
          <target state="translated">リストからの抽出物 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 、すべての &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 要素。すべての &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 要素が順番に抽出されます。</target>
        </trans-unit>
        <trans-unit id="23593562fd69e1de66ae4e632731e63b67f94b89" translate="yes" xml:space="preserve">
          <source>Extracts from a list of &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; all the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; elements. All the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; elements are extracted in order.</source>
          <target state="translated">リストからの抽出物 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; のすべての &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; の要素。すべての &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 要素が順番に抽出されます。</target>
        </trans-unit>
        <trans-unit id="47765e86c15d457b99a9254fc457aec3171dfef3" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This function has the side effect of closing the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and flushing its write buffer, if necessary.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; から &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; を抽出します。この関数には、必要に応じて、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; を閉じ、書き込みバッファーをフラッシュするという副作用があります。</target>
        </trans-unit>
        <trans-unit id="56cd8ea295a261029ef6e0001e10564c02952e69" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This function has the side effect of closing the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and flushing its write buffer, if necessary.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; から &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; を抽出します。この関数には、必要に応じて、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; を閉じて書き込みバッファをフラッシュするという副作用があります。</target>
        </trans-unit>
        <trans-unit id="12df19590e3fea55c64fb5d4077a86cd9854c08f" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This function has the side effect of closing the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and flushing its write buffer, if necessary.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; から &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; を抽出します。この関数には、必要に応じて、 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; を閉じて書き込みバッファをフラッシュするという副作用があります。</target>
        </trans-unit>
        <trans-unit id="d37c14699604a03fd4d86810b3d7950f2e52cc77" translate="yes" xml:space="preserve">
          <source>Extracts the bounds of an immutable array</source>
          <target state="translated">不変配列の境界を抽出します.</target>
        </trans-unit>
        <trans-unit id="3927ad512fc6801a8c448cfc25e6c4a5aa1e6fdc" translate="yes" xml:space="preserve">
          <source>Extracts the column number from a source position.</source>
          <target state="translated">ソースの位置から列番号を抽出します。</target>
        </trans-unit>
        <trans-unit id="f98a98ccf1f30629f52ac9fd6ceee04b851c3cb8" translate="yes" xml:space="preserve">
          <source>Extracts the imaginary part of a complex number.</source>
          <target state="translated">複素数の虚数部を抽出します。</target>
        </trans-unit>
        <trans-unit id="72b735a2e8cc21e50312444f0be2cba46269cdb2" translate="yes" xml:space="preserve">
          <source>Extracts the line number from a source position.</source>
          <target state="translated">ソースの位置から行番号を抽出します。</target>
        </trans-unit>
        <trans-unit id="5aa85df9b78b3e81e43bd5f3eef197d388f12497" translate="yes" xml:space="preserve">
          <source>Extracts the list of error messages from the parse error</source>
          <target state="translated">パースエラーからエラーメッセージのリストを抽出します。</target>
        </trans-unit>
        <trans-unit id="1d52fc67cbb595042e4bfe8748fe75b10e3bfaf9" translate="yes" xml:space="preserve">
          <source>Extracts the name of the source from a source position.</source>
          <target state="translated">ソースの位置からソースの名前を抽出します。</target>
        </trans-unit>
        <trans-unit id="fa7820eeb9c8d1f0372901d7c48b937c85bd82cf" translate="yes" xml:space="preserve">
          <source>Extracts the real part of a complex number.</source>
          <target state="translated">複素数の実数部分を抽出します。</target>
        </trans-unit>
        <trans-unit id="1463e681d793be66e7fe209521155ad317d859f8" translate="yes" xml:space="preserve">
          <source>Extracts the source position from the parse error</source>
          <target state="translated">パースエラーからソース位置を抽出します。</target>
        </trans-unit>
        <trans-unit id="3b729075855fa307e52f7a82b9acfe92bcb6b2c8" translate="yes" xml:space="preserve">
          <source>F. Lundh: The Fast Search Algorithm. &lt;a href=&quot;http://effbot.org/zone/stringlib.htm&quot;&gt;http://effbot.org/zone/stringlib.htm&lt;/a&gt; (2006)</source>
          <target state="translated">F. Lundh：高速検索アルゴリズム。&lt;a href=&quot;http://effbot.org/zone/stringlib.htm&quot;&gt;http://effbot.org/zone/stringlib.htm（2006&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="280c80844f01a9db84ec5402a6bd821338a8cfbf" translate="yes" xml:space="preserve">
          <source>FD</source>
          <target state="translated">FD</target>
        </trans-unit>
        <trans-unit id="07e3e68b1daed47acfe17b62cf16a3642bb89af6" translate="yes" xml:space="preserve">
          <source>FD_CLOEXEC</source>
          <target state="translated">FD_CLOEXEC</target>
        </trans-unit>
        <trans-unit id="6f76a711154e10c8b7d9ded2ab1414e67e29bdbc" translate="yes" xml:space="preserve">
          <source>FFExponent</source>
          <target state="translated">FFExponent</target>
        </trans-unit>
        <trans-unit id="9aa9cec1f34d9fa7339b6f9c8dfdf9bf6e52e0d8" translate="yes" xml:space="preserve">
          <source>FFFixed</source>
          <target state="translated">FFFixed</target>
        </trans-unit>
        <trans-unit id="de69c96e4288f9614d0d84273990ab542079c11c" translate="yes" xml:space="preserve">
          <source>FFFormat</source>
          <target state="translated">FFFormat</target>
        </trans-unit>
        <trans-unit id="b3876baa83fd86b2878e18b0db680254a946fea2" translate="yes" xml:space="preserve">
          <source>FFGeneric</source>
          <target state="translated">FFGeneric</target>
        </trans-unit>
        <trans-unit id="62b8d6cc22c479012823c38f9f1c4e6a0ca2ec3f" translate="yes" xml:space="preserve">
          <source>FFI datatypes and operations that use or require concurrency (GHC only).</source>
          <target state="translated">同時実行を使用する、または必要とする FFI データ型と操作(GHC のみ)。</target>
        </trans-unit>
        <trans-unit id="72ef38f5a65a645f475c68f4dff976400453ed6a" translate="yes" xml:space="preserve">
          <source>FFI support is enabled by default, but can be enabled or disabled explicitly with the &lt;a href=&quot;#extension-ForeignFunctionInterface&quot;&gt;&lt;code&gt;ForeignFunctionInterface&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">FFIサポートはデフォルトで有効になっていますが、&lt;a href=&quot;#extension-ForeignFunctionInterface&quot;&gt; &lt;code&gt;ForeignFunctionInterface&lt;/code&gt; &lt;/a&gt;フラグを使用して明示的に有効または無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="e54402f59eaf0ee8458f6bec4af7033bf2817f96" translate="yes" xml:space="preserve">
          <source>FFI-bindings to interact with SimpleMAPI</source>
          <target state="translated">SimpleMAPIと対話するためのFFIバインディング</target>
        </trans-unit>
        <trans-unit id="d9f5ec79f6b4ceeadbaeb6e44d31fab891b6c294" translate="yes" xml:space="preserve">
          <source>FFI-bindings to interact with Win32 Security</source>
          <target state="translated">Win32 セキュリティと対話するための FFI バインディング</target>
        </trans-unit>
        <trans-unit id="cd98ae36981ee80a267c314ec60000c7f9d30870" translate="yes" xml:space="preserve">
          <source>FLOAT</source>
          <target state="translated">FLOAT</target>
        </trans-unit>
        <trans-unit id="b5842d158a0ef95bb05982b944ce15a5f0702019" translate="yes" xml:space="preserve">
          <source>FOR ALL</source>
          <target state="translated">フォーオール</target>
        </trans-unit>
        <trans-unit id="cc069309a71a6b082f46a01f71efc1df948b1806" translate="yes" xml:space="preserve">
          <source>FORCE</source>
          <target state="translated">FORCE</target>
        </trans-unit>
        <trans-unit id="e7c189bd9105436a22b6dc9c0118398b753dc2ec" translate="yes" xml:space="preserve">
          <source>FPFormat</source>
          <target state="translated">FPFormat</target>
        </trans-unit>
        <trans-unit id="b332cee2f39f6c7203f896ba88110e82aff15a68" translate="yes" xml:space="preserve">
          <source>Faced with the problems described above, some Haskell programmers might be tempted to use something like the following version of the class declaration:</source>
          <target state="translated">上記の問題に直面すると、一部のHaskellプログラマーはクラス宣言の以下のバージョンのようなものを使いたくなるかもしれません。</target>
        </trans-unit>
        <trans-unit id="dae896f141aeb2a67159098fa3c417c9d9c6e0ef" translate="yes" xml:space="preserve">
          <source>Failure records information about the cause/location of the failure. Failure values bypass the bound function, other values are used as inputs to the bound function.</source>
          <target state="translated">失敗は、失敗の原因や場所に関する情報を記録します。失敗の値はバウンド関数をバイパスし、他の値はバウンド関数の入力として使用されます。</target>
        </trans-unit>
        <trans-unit id="9a507f0e5168c6ed30b03a96ee64617f5b05c7fe" translate="yes" xml:space="preserve">
          <source>Fairness</source>
          <target state="translated">Fairness</target>
        </trans-unit>
        <trans-unit id="97cdbdc7feff827efb082a6b6dd2727237cd49fd" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="translated">False</target>
        </trans-unit>
        <trans-unit id="93d46a9da7001524df4cde3ca05b775fe0b85bf2" translate="yes" xml:space="preserve">
          <source>Family instances are implicitly exported, just like class instances. However, this applies only to the heads of instances, not to the data constructors an instance defines.</source>
          <target state="translated">ファミリー・インスタンスは、クラス・インスタンスと同様に暗黙のうちにエクスポートされます。しかし、これはインスタンスのヘッドにのみ適用され、インスタンスが定義するデータ・コンストラクタには適用されません。</target>
        </trans-unit>
        <trans-unit id="7c03cfd18e7c0aa33fb0869c7db1ce2c71a9f1e4" translate="yes" xml:space="preserve">
          <source>FamilyResultSig</source>
          <target state="translated">FamilyResultSig</target>
        </trans-unit>
        <trans-unit id="5709a3aacba98eb7dab9b3ec1486beeceefdb838" translate="yes" xml:space="preserve">
          <source>FamilyResultSigQ</source>
          <target state="translated">FamilyResultSigQ</target>
        </trans-unit>
        <trans-unit id="6ee40b96a43fdbccb9bc7964f655f965fe647da5" translate="yes" xml:space="preserve">
          <source>Fanin: Split the input between the two argument arrows and merge their outputs.</source>
          <target state="translated">Fanin:2つの引数の矢印の間で入力を分割し、その出力をマージします。</target>
        </trans-unit>
        <trans-unit id="3d081b433b8a30d7f41b2cdd2ab22d0c446b40a8" translate="yes" xml:space="preserve">
          <source>Fanout: send the input to both argument arrows and combine their output.</source>
          <target state="translated">Fanout:両引数の矢印に入力を送り、その出力を結合します。</target>
        </trans-unit>
        <trans-unit id="a1448d14f32031abf80a6b03dd5aed71399356a2" translate="yes" xml:space="preserve">
          <source>Fast &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; logarithms to base 2. &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:wordLog2-35-&quot;&gt;wordLog2#&lt;/a&gt;&lt;/code&gt; are of general usefulness, the others are only needed for a fast implementation of &lt;code&gt;fromRational&lt;/code&gt;. Since they are needed in &lt;a href=&quot;ghc-float&quot;&gt;GHC.Float&lt;/a&gt;, we must expose this module, but it should not show up in the docs.</source>
          <target state="translated">2を底とする高速 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 対数 &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:wordLog2-35-&quot;&gt;wordLog2#&lt;/a&gt;&lt;/code&gt; は一般的に役立ちますが、その他は &lt;code&gt;fromRational&lt;/code&gt; の高速実装にのみ必要です。これらは&lt;a href=&quot;ghc-float&quot;&gt;GHC.Float&lt;/a&gt;で必要なので、このモジュールを公開する必要がありますが、ドキュメントには表示されません。</target>
        </trans-unit>
        <trans-unit id="604c30fffeb97fca92cde7e102ee6fa4c46126b4" translate="yes" xml:space="preserve">
          <source>Fast access to the system clock.</source>
          <target state="translated">システムクロックへの高速アクセス。</target>
        </trans-unit>
        <trans-unit id="dd750b3188ada6606559e5e05cd316edbb060aa4" translate="yes" xml:space="preserve">
          <source>Fast character manipulation functions.</source>
          <target state="translated">高速な文字操作機能</target>
        </trans-unit>
        <trans-unit id="a12096fc3f71f15571f0bdb559c8a630fd59e216" translate="yes" xml:space="preserve">
          <source>Fast substring search for &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, based on work by Boyer, Moore, Horspool, Sunday, and Lundh.</source>
          <target state="translated">Boyer、Moore、Horspool、Sunday、およびLundhの研究に基づく、 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; の部分文字列の高速検索。</target>
        </trans-unit>
        <trans-unit id="ff1949d07a3568ece3a1b271a32199c64e456437" translate="yes" xml:space="preserve">
          <source>Fast substring search for lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, based on work by Boyer, Moore, Horspool, Sunday, and Lundh. Adapted from the strict implementation.</source>
          <target state="translated">Boyer、Moore、Horspool、Sunday、およびLundhの研究に基づいた、レイジー &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 高速部分文字列検索。厳格な実装から適応。</target>
        </trans-unit>
        <trans-unit id="d5053d7cd5f1b006c98595f6bd4ac62f10f404ea" translate="yes" xml:space="preserve">
          <source>Fast, unchecked bit shifting functions.</source>
          <target state="translated">高速でチェックなしのビットシフト機能。</target>
        </trans-unit>
        <trans-unit id="6ce335ee3b25f9d7b908119c787dacbffab32155" translate="yes" xml:space="preserve">
          <source>Fd</source>
          <target state="translated">Fd</target>
        </trans-unit>
        <trans-unit id="f4e08a048eae08fd45b1d7080137ccedd2e9a232" translate="yes" xml:space="preserve">
          <source>FdKey</source>
          <target state="translated">FdKey</target>
        </trans-unit>
        <trans-unit id="9075ca9a523e56d968e61c7fa9bd0c125d3dbaa9" translate="yes" xml:space="preserve">
          <source>FdOption</source>
          <target state="translated">FdOption</target>
        </trans-unit>
        <trans-unit id="ff381dc1fa65f2d09b763ebd9d555902bb4b8aa8" translate="yes" xml:space="preserve">
          <source>Feed a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; with more input. If the &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; it will add the input to &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; of unconsumed input.</source>
          <target state="translated">より多くの入力を &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 供給します。 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; の場合、 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; の入力のByteStringに入力が追加されます。</target>
        </trans-unit>
        <trans-unit id="4e9b2c02289e4857fb2ab57f2809114796555b9f" translate="yes" xml:space="preserve">
          <source>Feed a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; with more input. If the &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; it will add the input to &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; of unconsumed input.</source>
          <target state="translated">より多くの入力を &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 供給します。 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; の場合、 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; の入力のByteStringに入力が追加されます。</target>
        </trans-unit>
        <trans-unit id="69e3b2b59aa4aebef05a2ee1ed5b935914ea9021" translate="yes" xml:space="preserve">
          <source>Feed a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; with more input. If the &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; it will add the input to &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; of unconsumed input.</source>
          <target state="translated">より多くの入力を &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 供給します。 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; した場合、 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 消費の入力のByteStringに入力が追加されます。</target>
        </trans-unit>
        <trans-unit id="99b4648ed500c37b8a76ac1f7c07fc6a62b9d886" translate="yes" xml:space="preserve">
          <source>Feed a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; with more input. If the &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; it will add the input to &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; of unconsumed input.</source>
          <target state="translated">より多くの入力を &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 供給します。 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; した場合、 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 消費の入力のByteStringに入力が追加されます。</target>
        </trans-unit>
        <trans-unit id="7bd5bf737c14ded7353e41c04daecd9804c7b9d6" translate="yes" xml:space="preserve">
          <source>Feed marked inputs through the argument arrow, passing the rest through unchanged to the output.</source>
          <target state="translated">マークのついた入力を引数の矢印に通し、残りの部分を変更せずに出力に渡します。</target>
        </trans-unit>
        <trans-unit id="c8d7677e19495f21da984fe4e2829b7ca91b27c7" translate="yes" xml:space="preserve">
          <source>Feedback</source>
          <target state="translated">Feedback</target>
        </trans-unit>
        <trans-unit id="b1673adba303c1f23dda58f316aeab11e438ee50" translate="yes" xml:space="preserve">
          <source>Fetch the current value of the state within the monad.</source>
          <target state="translated">モナド内の状態の現在値を取得します。</target>
        </trans-unit>
        <trans-unit id="9655bb220d4cd1a7d2999eacc755e15eb55c9e74" translate="yes" xml:space="preserve">
          <source>Fetch the value of the environment.</source>
          <target state="translated">環境の値を取得します。</target>
        </trans-unit>
        <trans-unit id="c251e678b25c081d063a5d28ed8182955bdb81eb" translate="yes" xml:space="preserve">
          <source>Fewest inaccessible clauses</source>
          <target state="translated">最もアクセスできない節の数が少ない</target>
        </trans-unit>
        <trans-unit id="7e2728111a7fab96f0d3a4080311c545fe9cc7bf" translate="yes" xml:space="preserve">
          <source>Fewest redundant clauses</source>
          <target state="translated">最小限の冗長節</target>
        </trans-unit>
        <trans-unit id="d6b6429e633d85c9027c14440388d087da532ae3" translate="yes" xml:space="preserve">
          <source>Fewest uncovered clauses</source>
          <target state="translated">カバーされていない節の数が最も少ない</target>
        </trans-unit>
        <trans-unit id="28f549c52b7931248dae14989071407da27552c4" translate="yes" xml:space="preserve">
          <source>Field CapNo</source>
          <target state="translated">フィールドキャップNo.</target>
        </trans-unit>
        <trans-unit id="03ded020bc6474da975890833ccd8f148e8a07d9" translate="yes" xml:space="preserve">
          <source>Field CapNo:</source>
          <target state="translated">Field CapNo:</target>
        </trans-unit>
        <trans-unit id="b4fe29f979583aef741d1f90e93bfaa345f64333" translate="yes" xml:space="preserve">
          <source>Field CapSetId</source>
          <target state="translated">フィールドCapSetId</target>
        </trans-unit>
        <trans-unit id="fac78598db657aa0c38e0a7b064e261405764b90" translate="yes" xml:space="preserve">
          <source>Field CapSetId:</source>
          <target state="translated">フィールド CapSetId:</target>
        </trans-unit>
        <trans-unit id="3d376a5f188ba09d0575c030e75276555ef3037b" translate="yes" xml:space="preserve">
          <source>Field String</source>
          <target state="translated">フィールド文字列</target>
        </trans-unit>
        <trans-unit id="a62e5ff1d5e101aeed17e5d052a10aaa3017be5b" translate="yes" xml:space="preserve">
          <source>Field String:</source>
          <target state="translated">フィールド文字列。</target>
        </trans-unit>
        <trans-unit id="5e33298c696fedbed9fc0116f43829e5721d9f07" translate="yes" xml:space="preserve">
          <source>Field TaskId</source>
          <target state="translated">フィールド タスクID</target>
        </trans-unit>
        <trans-unit id="a3803a8cbdbe813e945dd95bbdc4dffab8ccbfd7" translate="yes" xml:space="preserve">
          <source>Field TaskId:</source>
          <target state="translated">フィールド TaskId:</target>
        </trans-unit>
        <trans-unit id="6ee11d3a290e704407e05db1631372bf1b3dbe72" translate="yes" xml:space="preserve">
          <source>Field ThreadId</source>
          <target state="translated">フィールドのスレッド ID</target>
        </trans-unit>
        <trans-unit id="c3a47467c208f9af64bcfa1d0225564748d7312c" translate="yes" xml:space="preserve">
          <source>Field ThreadId:</source>
          <target state="translated">フィールド ThreadId:</target>
        </trans-unit>
        <trans-unit id="033928db92181f79852ddc994a0c003ec14b17e1" translate="yes" xml:space="preserve">
          <source>Field Word16</source>
          <target state="translated">フィールドワード16</target>
        </trans-unit>
        <trans-unit id="cbcfd83bc4c9e590b27d81c7a0808713eab58ee9" translate="yes" xml:space="preserve">
          <source>Field Word16:</source>
          <target state="translated">フィールド Word16。</target>
        </trans-unit>
        <trans-unit id="46e5a07512e61c7eb3e794df15878325a5e53713" translate="yes" xml:space="preserve">
          <source>Field Word32</source>
          <target state="translated">フィールドワード32</target>
        </trans-unit>
        <trans-unit id="42f1a115395af35bce115c6c82b59e4a4a5087fa" translate="yes" xml:space="preserve">
          <source>Field Word32:</source>
          <target state="translated">フィールド Word32。</target>
        </trans-unit>
        <trans-unit id="e0536b1c8eb0eeac80c4b4a595b342d8367bd6a0" translate="yes" xml:space="preserve">
          <source>Field Word32[]</source>
          <target state="translated">フィールドWord32[]</target>
        </trans-unit>
        <trans-unit id="e59e9060dc4635660cb6bfaff4355ba8a486745a" translate="yes" xml:space="preserve">
          <source>Field Word32[]:</source>
          <target state="translated">フィールド Word32[]:</target>
        </trans-unit>
        <trans-unit id="727d70feadcbb92b2fc2f2668935aa3272996214" translate="yes" xml:space="preserve">
          <source>Field Word64</source>
          <target state="translated">フィールドワード64</target>
        </trans-unit>
        <trans-unit id="7cbbdf7e0b7dfdebe7dfe21d03bf00d60a18f320" translate="yes" xml:space="preserve">
          <source>Field Word64:</source>
          <target state="translated">Field Word64です。</target>
        </trans-unit>
        <trans-unit id="a846bfa3518bf3d88d0ce3066df98c589343374a" translate="yes" xml:space="preserve">
          <source>Field Word8</source>
          <target state="translated">フィールドワード8</target>
        </trans-unit>
        <trans-unit id="bb7b88f825a8de27b63373e28f7a77a5b201a208" translate="yes" xml:space="preserve">
          <source>Field Word8:</source>
          <target state="translated">フィールドワード8。</target>
        </trans-unit>
        <trans-unit id="038766ad89a5656bc1a23b0e43bb712d94a7a368" translate="yes" xml:space="preserve">
          <source>Field [String]</source>
          <target state="translated">フィールド [文字列]</target>
        </trans-unit>
        <trans-unit id="2a2dd2f21d7d7ea1bc52b694a50f6bf5a257e793" translate="yes" xml:space="preserve">
          <source>Field [String]:</source>
          <target state="translated">フィールド [String]:</target>
        </trans-unit>
        <trans-unit id="bb83d98e1af99f389ea1d7d36d6591ca3c321b0c" translate="yes" xml:space="preserve">
          <source>Field disambiguation can be combined with punning (see &lt;a href=&quot;#record-puns&quot;&gt;Record puns&lt;/a&gt;). For example:</source>
          <target state="translated">フィールドの明確化は、パンニングと組み合わせることができます（&lt;a href=&quot;#record-puns&quot;&gt;レコード&lt;/a&gt;パンを参照）。例えば：</target>
        </trans-unit>
        <trans-unit id="6f697941f4e61d5357bc8e695debb7df5928ebe4" translate="yes" xml:space="preserve">
          <source>Field disambiguation can be combined with punning (see &lt;a href=&quot;record_puns#record-puns&quot;&gt;Record puns&lt;/a&gt;). For example:</source>
          <target state="translated">フィールドの曖昧性解消は、しゃれと組み合わせることができます（しゃれの&lt;a href=&quot;record_puns#record-puns&quot;&gt;記録を&lt;/a&gt;参照）。例えば：</target>
        </trans-unit>
        <trans-unit id="8ba709dee54d841422d5cda9c86dc36f0733a53e" translate="yes" xml:space="preserve">
          <source>Field names used as selector functions or in record updates must be unambiguous, either because there is only one such field in scope, or because a type signature is supplied, as described in the following sections.</source>
          <target state="translated">セレクタ関数として使用されるフィールド名やレコード更新で使用されるフィールド名は、スコープ内にそのようなフィールドが1つしかない場合や、以下のセクションで説明するように型署名が与えられている場合のいずれかの理由で、曖昧さがないものでなければなりません。</target>
        </trans-unit>
        <trans-unit id="9a36bac12f2598c38413b503ceea750d14ea1043" translate="yes" xml:space="preserve">
          <source>Field selectors can be used in conjunction with &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt;, as described in &lt;a href=&quot;type_applications#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;. The type of a field selector is constructed by using the surrounding definition as context. This section provides a specification for how this construction works. We will explain it by considering three different forms of field selector, each of which is a minor variation of the same general theme.</source>
          <target state="translated">フィールドセレクターは、&lt;a href=&quot;type_applications#visible-type-application&quot;&gt;Visibleタイプアプリケーションで&lt;/a&gt;説明されているように、&lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt;と組み合わせて使用​​できます。フィールドセレクターのタイプは、周囲の定義をコンテキストとして使用して構築されます。このセクションでは、この構造がどのように機能するかについての仕様を提供します。同じ一般的なテーマのマイナーなバリエーションである、3つの異なる形式のフィールドセレクターを検討して説明します。</target>
        </trans-unit>
        <trans-unit id="ebd7785607bbf364d54013deccebdf1687696229" translate="yes" xml:space="preserve">
          <source>Field selectors for GADT constructors (&lt;a href=&quot;gadt_syntax#gadt-style&quot;&gt;Declaring data types with explicit constructor signatures&lt;/a&gt;) are slightly more involved. Consider the following example:</source>
          <target state="translated">GADTコンストラクターのフィールドセレクター（&lt;a href=&quot;gadt_syntax#gadt-style&quot;&gt;明示的なコンストラクター署名を使用したデータ型の宣言&lt;/a&gt;）は、もう少し複雑です。次の例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="553b7393804c0c51c21d68612ff28deebee6c2a3" translate="yes" xml:space="preserve">
          <source>FieldExp</source>
          <target state="translated">FieldExp</target>
        </trans-unit>
        <trans-unit id="96c72c07ebaaebcb224edc3159fd04027f378cf3" translate="yes" xml:space="preserve">
          <source>FieldExpQ</source>
          <target state="translated">FieldExpQ</target>
        </trans-unit>
        <trans-unit id="52cf3a69b95afcaef5b9552017ab1d7a46942649" translate="yes" xml:space="preserve">
          <source>FieldFormat</source>
          <target state="translated">FieldFormat</target>
        </trans-unit>
        <trans-unit id="ab3ea29114e079d7ead09ebd02437860e63f295e" translate="yes" xml:space="preserve">
          <source>FieldFormatter</source>
          <target state="translated">FieldFormatter</target>
        </trans-unit>
        <trans-unit id="9056803e7437f22b8f8eb0183fd8d5b6660b20fa" translate="yes" xml:space="preserve">
          <source>FieldPat</source>
          <target state="translated">FieldPat</target>
        </trans-unit>
        <trans-unit id="99b0c84f03868d4e48b3119185190cb080d238ad" translate="yes" xml:space="preserve">
          <source>FieldPatQ</source>
          <target state="translated">FieldPatQ</target>
        </trans-unit>
        <trans-unit id="e8b685271238adf161cffed3c91f54d97023262b" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Fields</target>
        </trans-unit>
        <trans-unit id="6047eeaf6d96600fc3b89f57d9a82133eebd5fc4" translate="yes" xml:space="preserve">
          <source>Fields may be used as selector functions only if they are unambiguous, so this is still not allowed if both &lt;code&gt;S(x)&lt;/code&gt; and &lt;code&gt;T(x)&lt;/code&gt; are in scope:</source>
          <target state="translated">フィールドは明確な場合にのみセレクター関数として使用できます。そのため、 &lt;code&gt;S(x)&lt;/code&gt; と &lt;code&gt;T(x)&lt;/code&gt; の両方がスコープ内にある場合、これはまだ許可されていません。</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="7ab560f3cbaa2fc5f6b6fc34d0cb745e71f21f9f" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;$HOME/.ghc/arch-os-version/environments/default&lt;/code&gt; if it exists.</source>
          <target state="translated">ファイル &lt;code&gt;$HOME/.ghc/arch-os-version/environments/default&lt;/code&gt; が存在する場合。</target>
        </trans-unit>
        <trans-unit id="a167c672375de2f34928b4566c71bf22a7ede991" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; if the environment variable &lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-8&quot;&gt;&lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt;&lt;/a&gt; is set to ⟨name⟩.</source>
          <target state="translated">環境変数&lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-8&quot;&gt; &lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt; &lt;/a&gt;が「name」に設定されている場合は、ファイル &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a01ef2357593bcb0e4fedb3c673c8bc39be504e" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; if you pass the option &lt;code&gt;-package-env ⟨name⟩&lt;/code&gt;.</source>
          <target state="translated">オプション &lt;code&gt;-package-env ⟨name⟩&lt;/code&gt; を渡す場合、ファイル &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d06905a4f43f7d68d079a1292926a4fcdc15ef19" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;.ghc.environment.arch-os-version&lt;/code&gt; if it exists in the current directory or any parent directory (but not the user&amp;rsquo;s home directory).</source>
          <target state="translated">ファイル &lt;code&gt;.ghc.environment.arch-os-version&lt;/code&gt; が現在のディレクトリまたは親ディレクトリ（ユーザーのホームディレクトリではない）に存在する場合。</target>
        </trans-unit>
        <trans-unit id="47f3e4a191350f85b1fb6c184e322e3d2487d97a" translate="yes" xml:space="preserve">
          <source>File allocation</source>
          <target state="translated">ファイルの割り当て</target>
        </trans-unit>
        <trans-unit id="d5a78f8cfc23c487b733c48af2524d1ee745f3b1" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">ファイル名とディレクトリ名は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 型の値であり、正確な意味はオペレーティングシステムに依存します。ファイルを開いて、そのファイルのコンテンツを操作するために使用できるハンドルを生成できます。</target>
        </trans-unit>
        <trans-unit id="838ab5322e72167e410c8392a44814f02f10e077" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">ファイル名とディレクトリ名は &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 型の値であり、その正確な意味はオペレーティングシステムによって異なります。ファイルを開くと、そのファイルの内容を操作するために使用できるハンドルが生成されます。</target>
        </trans-unit>
        <trans-unit id="bd52e06d55d1bf7bfbc10d5c00841d3fab42c29d" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">ファイル名とディレクトリ名は &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 型の値であり、その正確な意味はオペレーティングシステムによって異なります。ファイルを開くと、そのファイルの内容を操作するために使用できるハンドルが生成されます。</target>
        </trans-unit>
        <trans-unit id="effea5a9629c10713fe758f268aee8fd6abebbd6" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">ファイル名とディレクトリ名は &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 型の値であり、正確な意味はオペレーティングシステムに依存します。ファイルを開いて、そのファイルのコンテンツを操作するために使用できるハンドルを生成できます。</target>
        </trans-unit>
        <trans-unit id="3d0b0e37f272404afcc389cc877def43f90e9575" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">ファイル名とディレクトリ名は &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 型の値であり、正確な意味はオペレーティングシステムに依存します。ファイルを開いて、そのファイルのコンテンツを操作するために使用できるハンドルを生成できます。</target>
        </trans-unit>
        <trans-unit id="f47bb7024cb7d59562a12c46b66ef954ecbf1490" translate="yes" xml:space="preserve">
          <source>File descriptor to close.</source>
          <target state="translated">ファイルディスクリプタを閉じます。</target>
        </trans-unit>
        <trans-unit id="b66bde9fc5bb83fdf4ea939e331fb8664459ca24" translate="yes" xml:space="preserve">
          <source>File extension character</source>
          <target state="translated">ファイル拡張子文字</target>
        </trans-unit>
        <trans-unit id="1c0021e329eb90f6a7b2780c57945209da61a258" translate="yes" xml:space="preserve">
          <source>File locking</source>
          <target state="translated">ファイルロック</target>
        </trans-unit>
        <trans-unit id="0c722e113405e21abbf91991823e490fd909ebc5" translate="yes" xml:space="preserve">
          <source>File mode (such as permissions).</source>
          <target state="translated">ファイルモード(パーミッションなど)。</target>
        </trans-unit>
        <trans-unit id="44351e19bb95196b5909f0387569e8792f24a314" translate="yes" xml:space="preserve">
          <source>File modes</source>
          <target state="translated">ファイルモード</target>
        </trans-unit>
        <trans-unit id="79327cb41236e902d5cca2599b9eff800842dc2d" translate="yes" xml:space="preserve">
          <source>File name manipulations</source>
          <target state="translated">ファイル名の操作</target>
        </trans-unit>
        <trans-unit id="e5ec2bfca476afbb5e2e6543807ac3bfb533a1ec" translate="yes" xml:space="preserve">
          <source>File name template. If the template is &quot;foo.ext&quot; then the created file will be &quot;fooXXX.ext&quot; where XXX is some random number. Note that this should not contain any path separator characters.</source>
          <target state="translated">ファイル名のテンプレート。テンプレートが &quot;foo.ext&quot; の場合、作成されるファイルは &quot;fooXXX.ext&quot; となります。これはパスの区切り文字を含んではいけないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="8cdd2b3998531feb2e79d752bcd3196891becba3" translate="yes" xml:space="preserve">
          <source>File names with &amp;ldquo;meaningful&amp;rdquo; suffixes (e.g., &lt;code&gt;.lhs&lt;/code&gt; or &lt;code&gt;.o&lt;/code&gt;) cause the &amp;ldquo;right thing&amp;rdquo; to happen to those files.</source>
          <target state="translated">「意味のある」サフィックスが付いたファイル名（たとえば、 &lt;code&gt;.lhs&lt;/code&gt; または &lt;code&gt;.o&lt;/code&gt; ）は、それらのファイルに「正しいこと」を起こさせます。</target>
        </trans-unit>
        <trans-unit id="50384c5cc1d9206b4a0bea9f93b399ae83f9025e" translate="yes" xml:space="preserve">
          <source>File options</source>
          <target state="translated">ファイルオプション</target>
        </trans-unit>
        <trans-unit id="23d0dc8812f4ca4c291d107ca6848e74d92c16dd" translate="yes" xml:space="preserve">
          <source>File status</source>
          <target state="translated">ファイルの状態</target>
        </trans-unit>
        <trans-unit id="af9774e2bc6c59627690a0dedee37b68e10ba597" translate="yes" xml:space="preserve">
          <source>File synchronisation</source>
          <target state="translated">同期ファイル</target>
        </trans-unit>
        <trans-unit id="0d3da9368089813c88f07b933bfd9982df74058a" translate="yes" xml:space="preserve">
          <source>File ⟨file⟩ if the environment variable &lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-7&quot;&gt;&lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt;&lt;/a&gt; is set to ⟨file⟩.</source>
          <target state="translated">環境変数&lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-7&quot;&gt; &lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt; &lt;/a&gt;が「ファイル」に設定されている場合は、ファイル「ファイル」。</target>
        </trans-unit>
        <trans-unit id="b068141256755be393e8c5f4ab9d5a23cddf020c" translate="yes" xml:space="preserve">
          <source>File ⟨file⟩ if you pass the option &lt;a href=&quot;#ghc-flag--package-env%20%E2%9F%A8file%E2%9F%A9%7C%E2%9F%A8name%E2%9F%A9&quot;&gt;&lt;code&gt;-package-env ⟨file⟩|⟨name⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">オプション&lt;a href=&quot;#ghc-flag--package-env%20%E2%9F%A8file%E2%9F%A9%7C%E2%9F%A8name%E2%9F%A9&quot;&gt; &lt;code&gt;-package-env ⟨file⟩|⟨name⟩&lt;/code&gt; &lt;/a&gt;を渡した場合は、ファイル「file」。</target>
        </trans-unit>
        <trans-unit id="e845ec2f1dbe4ebb6bd5b44fdbd30e02fb4fa0b5" translate="yes" xml:space="preserve">
          <source>File-header pragmas are read once only, before pre-processing the file (e.g. with cpp).</source>
          <target state="translated">ファイルヘッダープラグマは、ファイルの前処理を行う前に一度だけ読み込まれます(例:cpp)。</target>
        </trans-unit>
        <trans-unit id="67f0fd4191e0b800a67e17dea08cd79d328c985d" translate="yes" xml:space="preserve">
          <source>FileAttributeOrFlag</source>
          <target state="translated">FileAttributeOrFlag</target>
        </trans-unit>
        <trans-unit id="419fb1d579fa24f7d06409a1560297bf55604fcb" translate="yes" xml:space="preserve">
          <source>FileID</source>
          <target state="translated">FileID</target>
        </trans-unit>
        <trans-unit id="5f8df2e8132fa7064ada28629c5b3817e3b4756e" translate="yes" xml:space="preserve">
          <source>FileLock</source>
          <target state="translated">FileLock</target>
        </trans-unit>
        <trans-unit id="80805853ea06d36fa4fd830be6185f04c78d62c7" translate="yes" xml:space="preserve">
          <source>FileLockingNotSupported</source>
          <target state="translated">FileLockingNotSupported</target>
        </trans-unit>
        <trans-unit id="a85de67499f0473cd81c3a219d6d486f9eeb80fa" translate="yes" xml:space="preserve">
          <source>FileMapAccess</source>
          <target state="translated">FileMapAccess</target>
        </trans-unit>
        <trans-unit id="0b25eeca51a2e908f97898c9ef3aefb4ac120d01" translate="yes" xml:space="preserve">
          <source>FileMode</source>
          <target state="translated">FileMode</target>
        </trans-unit>
        <trans-unit id="96e38f15ed4165180f2f72b882ad922453b8f857" translate="yes" xml:space="preserve">
          <source>FileNameLimit</source>
          <target state="translated">FileNameLimit</target>
        </trans-unit>
        <trans-unit id="cf5d49897833b10ad5a74c57196b79bf6729d833" translate="yes" xml:space="preserve">
          <source>FileNamesAreNotTruncated</source>
          <target state="translated">FileNamesAreNotTruncated</target>
        </trans-unit>
        <trans-unit id="d680e5e98dcdbf2c7c4f9799336719546329a1dd" translate="yes" xml:space="preserve">
          <source>FileNotificationFlag</source>
          <target state="translated">FileNotificationFlag</target>
        </trans-unit>
        <trans-unit id="2ee875689c41837c399f4d2c32f5259de761b9de" translate="yes" xml:space="preserve">
          <source>FileOffset</source>
          <target state="translated">FileOffset</target>
        </trans-unit>
        <trans-unit id="6c82ffd5741d0c27e25cc781899c3fe7b6f8fa63" translate="yes" xml:space="preserve">
          <source>FilePath</source>
          <target state="translated">FilePath</target>
        </trans-unit>
        <trans-unit id="c3604acc9cca295c426ebae9f7a5c570e9e3927d" translate="yes" xml:space="preserve">
          <source>FilePtrDirection</source>
          <target state="translated">FilePtrDirection</target>
        </trans-unit>
        <trans-unit id="3b19d1904d22317055740540571508037b9e04a5" translate="yes" xml:space="preserve">
          <source>FileSizeBits</source>
          <target state="translated">FileSizeBits</target>
        </trans-unit>
        <trans-unit id="15bb173707cc00113315f136acf915560a27f60c" translate="yes" xml:space="preserve">
          <source>FileStatus</source>
          <target state="translated">FileStatus</target>
        </trans-unit>
        <trans-unit id="6774947837a99235d0bd2076b121b3dd3a43aa95" translate="yes" xml:space="preserve">
          <source>FileTag</source>
          <target state="translated">FileTag</target>
        </trans-unit>
        <trans-unit id="1baa34e6560f1522cca6ce9d9df461092e8ec59b" translate="yes" xml:space="preserve">
          <source>FileType</source>
          <target state="translated">FileType</target>
        </trans-unit>
        <trans-unit id="4324ba3b44136bad26f9c65258416f168b463786" translate="yes" xml:space="preserve">
          <source>Filename completion</source>
          <target state="translated">ファイル名の補完</target>
        </trans-unit>
        <trans-unit id="2ebfcb3969f0ba497b6130046dbc6f62106ac185" translate="yes" xml:space="preserve">
          <source>Filename extension for executable files (including the dot if any) (usually &lt;code&gt;&quot;&quot;&lt;/code&gt; on POSIX systems and &lt;code&gt;&quot;.exe&quot;&lt;/code&gt; on Windows or OS/2).</source>
          <target state="translated">（ドットを含むもしあれば）実行可能ファイルのファイル名の拡張子（通常は &lt;code&gt;&quot;&quot;&lt;/code&gt; POSIXシステムとの &lt;code&gt;&quot;.exe&quot;&lt;/code&gt; WindowsまたはOS / 2上）。</target>
        </trans-unit>
        <trans-unit id="430a7fb7f4eedabcec0ba92367e6b4e3cc37cb65" translate="yes" xml:space="preserve">
          <source>Filename of the executable (see &lt;code&gt;&lt;a href=&quot;system-process#v:RawCommand&quot;&gt;RawCommand&lt;/a&gt;&lt;/code&gt; for details)</source>
          <target state="translated">実行ファイルのファイル名（詳細は &lt;code&gt;&lt;a href=&quot;system-process#v:RawCommand&quot;&gt;RawCommand&lt;/a&gt;&lt;/code&gt; を参照）</target>
        </trans-unit>
        <trans-unit id="c1e5594cbcf5d29cd4606ef3b29742013aa676d3" translate="yes" xml:space="preserve">
          <source>Filename/directory functions</source>
          <target state="translated">ファイル名/ディレクトリ機能</target>
        </trans-unit>
        <trans-unit id="6ce6c512ea433a7fc5c8841628e7696cd0ff7f2b" translate="yes" xml:space="preserve">
          <source>Files</source>
          <target state="translated">Files</target>
        </trans-unit>
        <trans-unit id="1d68fcbcaa9e6c0596bd77cd85d8ef1430e2e255" translate="yes" xml:space="preserve">
          <source>Files and handles</source>
          <target state="translated">ファイルとハンドル</target>
        </trans-unit>
        <trans-unit id="8c12ce59fd07366870c4918986c036d5b1718b2d" translate="yes" xml:space="preserve">
          <source>Files with other suffixes (or without suffixes) are passed straight to the linker.</source>
          <target state="translated">他のサフィックスを持つ (またはサフィックスを持たない)ファイルは、そのままリンカに渡されます。</target>
        </trans-unit>
        <trans-unit id="0bcfe196150a905d9689e141f80a3a2ecefe16ce" translate="yes" xml:space="preserve">
          <source>Fill a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; using a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">塗りつぶし &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="74e773234ce1275af1c68adf87a3b4bc236bada9" translate="yes" xml:space="preserve">
          <source>Fill a given number of bytes in memory area with a byte value.</source>
          <target state="translated">メモリ領域の指定されたバイト数をバイト値で埋めます。</target>
        </trans-unit>
        <trans-unit id="cd4d3d8bc69124ec20ace02425021dd9178e5281" translate="yes" xml:space="preserve">
          <source>Filling up memory area with required values</source>
          <target state="translated">メモリ領域を必要な値で埋め尽くす</target>
        </trans-unit>
        <trans-unit id="d7decf1aa22b02ae8abf9a96849ee423eee838e4" translate="yes" xml:space="preserve">
          <source>Filter</source>
          <target state="translated">Filter</target>
        </trans-unit>
        <trans-unit id="8022a4851f7324da6865a694a01b0bcaab7a2f99" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map using some &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">いくつかの &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; アクションを使用して、他のマップからキーが欠落しているエントリーをフィルタリングします。</target>
        </trans-unit>
        <trans-unit id="ee2b47e5e988f9baa37856993c9dc8cd3c328a52" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map using some &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">いくつかの &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; アクションを使用して、キーが他のマップから欠落しているエントリをフィルタリングします。</target>
        </trans-unit>
        <trans-unit id="296c67f523b9ac6e28bfc4ebfa4d796103625519" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map using some &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">いくつかの &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; アクションを使用して、キーが他のマップから欠落しているエントリをフィルタリングします。</target>
        </trans-unit>
        <trans-unit id="787c541edc37e7915b5310e8847885791e0e7bf2" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map.</source>
          <target state="translated">他のマップからキーが見つからないエントリをフィルタリングします。</target>
        </trans-unit>
        <trans-unit id="86fec396e3e13493b2a91cd89771fd664be0f9b3" translate="yes" xml:space="preserve">
          <source>FinalPtr</source>
          <target state="translated">FinalPtr</target>
        </trans-unit>
        <trans-unit id="65039e687d346fc2cb3b9e4ba3fdebf8936d6f9e" translate="yes" xml:space="preserve">
          <source>FinalQuote</source>
          <target state="translated">FinalQuote</target>
        </trans-unit>
        <trans-unit id="e068667dac3c14788401a6fb7eba398f0213b990" translate="yes" xml:space="preserve">
          <source>Finalised data pointers</source>
          <target state="translated">最終的なデータポインタ</target>
        </trans-unit>
        <trans-unit id="4654b2a5f2578ac85eb620c7f87d7844f6e0bb05" translate="yes" xml:space="preserve">
          <source>Finalization</source>
          <target state="translated">Finalization</target>
        </trans-unit>
        <trans-unit id="4bf1c69e4a67738c229264f62b72b00175b94776" translate="yes" xml:space="preserve">
          <source>Finalization means (a) arrange that subsequent calls to &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; return &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;; and (b) run the finalizer.</source>
          <target state="translated">ファイナライズとは、（a）後続の &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; の呼び出しで &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; が返されるようにすることです。（b）ファイナライザを実行します。</target>
        </trans-unit>
        <trans-unit id="4f4bcb977484412c1a687b2717df3db42e0223d6" translate="yes" xml:space="preserve">
          <source>Finalize a weak pointer. The return value is an unboxed tuple containing the new state of the world and an &quot;unboxed Maybe&quot;, represented by an &lt;code&gt;Int#&lt;/code&gt; and a (possibly invalid) finalization action. An &lt;code&gt;Int#&lt;/code&gt; of &lt;code&gt;1&lt;/code&gt; indicates that the finalizer is valid. The return value &lt;code&gt;b&lt;/code&gt; from the finalizer should be ignored.</source>
          <target state="translated">弱いポインタを確定します。戻り値は、世界の新しい状態と「ボックス化されていない可能性のある」を含むボックス化されていないタプルであり、 &lt;code&gt;Int#&lt;/code&gt; と（おそらく無効な）ファイナライズアクションによって表されます。 &lt;code&gt;Int#&lt;/code&gt; の &lt;code&gt;1&lt;/code&gt; は、ファイナライザが有効であることを示しています。ファイナライザからの戻り値 &lt;code&gt;b&lt;/code&gt; は無視する必要があります。</target>
        </trans-unit>
        <trans-unit id="f43bcd35f75b6b03cc41d4b7b36c9671eee326a4" translate="yes" xml:space="preserve">
          <source>FinalizerEnvPtr</source>
          <target state="translated">FinalizerEnvPtr</target>
        </trans-unit>
        <trans-unit id="b1542ae832d41717b2363b38f917247984d58f95" translate="yes" xml:space="preserve">
          <source>FinalizerPtr</source>
          <target state="translated">FinalizerPtr</target>
        </trans-unit>
        <trans-unit id="86d2d2c2528b5945d0ddc3f7f67ee4046606e5af" translate="yes" xml:space="preserve">
          <source>Finalizers &lt;em&gt;can&lt;/em&gt; be used reliably for types that are created explicitly and have identity, such as &lt;code&gt;IORef&lt;/code&gt; and &lt;code&gt;MVar&lt;/code&gt;. However, to place a finalizer on one of these types, you should use the specific operation provided for that type, e.g. &lt;code&gt;mkWeakIORef&lt;/code&gt; and &lt;code&gt;addMVarFinalizer&lt;/code&gt; respectively (the non-uniformity is accidental). These operations attach the finalizer to the primitive object inside the box (e.g. &lt;code&gt;MutVar#&lt;/code&gt; in the case of &lt;code&gt;IORef&lt;/code&gt;), because attaching the finalizer to the box itself fails when the outer box is optimised away by the compiler.</source>
          <target state="translated">ファイナライザ&lt;em&gt;は&lt;/em&gt;、 &lt;code&gt;IORef&lt;/code&gt; や &lt;code&gt;MVar&lt;/code&gt; など、明示的に作成されてIDを持つタイプに対して確実に使用&lt;em&gt;でき&lt;/em&gt;ます。ただし、これらのタイプの1つにファイナライザーを配置するには、そのタイプに提供されている特定の操作を使用する必要があります。たとえば、それぞれ &lt;code&gt;mkWeakIORef&lt;/code&gt; と &lt;code&gt;addMVarFinalizer&lt;/code&gt; です（不均一は偶発的です）。これらの操作は、ファイナライザをボックス内のプリミティブオブジェクトにアタッチします（たとえば、 &lt;code&gt;MutVar#&lt;/code&gt; の場合は &lt;code&gt;IORef&lt;/code&gt; ＃）。これは、コンパイラによって外側のボックスが最適化されるとファイナライザをボックス自体にアタッチできないためです。</target>
        </trans-unit>
        <trans-unit id="521c7faf6958e48a574367992f9c07725b55b76b" translate="yes" xml:space="preserve">
          <source>Finalizers are all C functions.</source>
          <target state="translated">ファイナライザはすべてC関数です。</target>
        </trans-unit>
        <trans-unit id="ce238574b6a6dbcd2a65c4596886dabb147b08b1" translate="yes" xml:space="preserve">
          <source>Finalizers are all Haskell functions.</source>
          <target state="translated">ファイナライザはすべてHaskellの関数です。</target>
        </trans-unit>
        <trans-unit id="d549824ec075b07eaad0c57b8862f0cccdfc5850" translate="yes" xml:space="preserve">
          <source>Finally, GHC calls &lt;code&gt;tcPluginStop&lt;/code&gt; after constraint solving is finished, allowing the plugin to dispose of any resources it has allocated (e.g. terminating the SMT solver process).</source>
          <target state="translated">最後に、制約の解決が完了した後、GHCは &lt;code&gt;tcPluginStop&lt;/code&gt; を呼び出し、プラグインが割り当てたリソースを破棄できるようにします（たとえば、SMTソルバープロセスを終了します）。</target>
        </trans-unit>
        <trans-unit id="cc10bc2ea70467315012d5ca45b95d793b626303" translate="yes" xml:space="preserve">
          <source>Finally, after the &lt;code&gt;interruptible&lt;/code&gt; foreign call returns into Haskell, the Haskell code should allow exceptions to be raised (&lt;code&gt;Control.Exception&lt;/code&gt;&amp;lsquo;s &lt;code&gt;allowInterrupt&lt;/code&gt;, or &lt;code&gt;interruptible yield&lt;/code&gt; for non-&lt;code&gt;-threaded&lt;/code&gt;, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/8684&quot;&gt;https://gitlab.haskell.org/ghc/ghc/issues/8684&lt;/a&gt;), and implement the &lt;code&gt;EINTR&lt;/code&gt;-retrying in Haskell (e.g. using e.g. &lt;a href=&quot;../../libraries/base-4.15.0.0/foreign-c-error#v:throwErrnoIfMinus1Retry&quot;&gt;Foreign.C.Error.throwErrnoIfMinus1Retry&lt;/a&gt;).</source>
          <target state="translated">最後に、 &lt;code&gt;interruptible&lt;/code&gt; 外部呼び出しがHaskellに戻った後、Haskellコードは例外の発生を許可する必要があります（ &lt;code&gt;Control.Exception&lt;/code&gt; の &lt;code&gt;allowInterrupt&lt;/code&gt; 、またはスレッド化 &lt;code&gt;interruptible yield&lt;/code&gt; いない場合の割り込み可能なyield、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/8684&quot;&gt;https：&lt;/a&gt; &lt;code&gt;-threaded&lt;/code&gt; を参照） ghc / issues / 8684）、Haskellで &lt;code&gt;EINTR&lt;/code&gt; 再試行を実装します（たとえば、&lt;a href=&quot;../../libraries/base-4.15.0.0/foreign-c-error#v:throwErrnoIfMinus1Retry&quot;&gt;Foreign.C.Error.throwErrnoIfMinus1Retry&lt;/a&gt;を使用します）。</target>
        </trans-unit>
        <trans-unit id="3cd050ec35a76e1f6b5c1338ce2268aeea42675b" translate="yes" xml:space="preserve">
          <source>Finally, here's an exception safe variant of the &lt;code&gt;readFile'&lt;/code&gt; example:</source>
          <target state="translated">最後に、 &lt;code&gt;readFile'&lt;/code&gt; 例の例外セーフバリアントを次に示します。</target>
        </trans-unit>
        <trans-unit id="17da083d84fc49d2631cf9ff7d2f3b4b5c95891b" translate="yes" xml:space="preserve">
          <source>Finally, other functions can be called, either with the &lt;code&gt;-main-is&lt;/code&gt; flag or the &lt;a href=&quot;#ghci-cmd-:run&quot;&gt;&lt;code&gt;:run&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">最後に、 &lt;code&gt;-main-is&lt;/code&gt; フラグまたは&lt;a href=&quot;#ghci-cmd-:run&quot;&gt; &lt;code&gt;:run&lt;/code&gt; &lt;/a&gt;コマンドを使用して、他の関数を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="17193f32610866d1f4357bb64bd6417d7a0e85e0" translate="yes" xml:space="preserve">
          <source>Finally, since those &lt;code&gt;DynFlags&lt;/code&gt; updates happen after the plugins are loaded, you cannot from a &lt;code&gt;DynFlags&lt;/code&gt; plugin register other plugins by just adding them to the &lt;code&gt;plugins&lt;/code&gt; field of &lt;code&gt;DynFlags&lt;/code&gt;. In order to achieve this, you would have to load them yourself and store the result into the &lt;code&gt;cachedPlugins&lt;/code&gt; field of &lt;code&gt;DynFlags&lt;/code&gt;.</source>
          <target state="translated">最後に、これらの &lt;code&gt;DynFlags&lt;/code&gt; の更新はプラグインのロード後に行われるため、 &lt;code&gt;DynFlags&lt;/code&gt; プラグインから他のプラグインを &lt;code&gt;DynFlags&lt;/code&gt; の &lt;code&gt;plugins&lt;/code&gt; フィールドに追加するだけで登録することはできません。これを実現するには、それらを自分でロードし、結果を &lt;code&gt;cachedPlugins&lt;/code&gt; フィールドに &lt;code&gt;DynFlags&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="c467715713120e1ab32f93515b00b2a5a923fdd5" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;Just&lt;/code&gt; results are collected into a map:</source>
          <target state="translated">最後に、 &lt;code&gt;Just&lt;/code&gt; の結果がマップに収集されます。</target>
        </trans-unit>
        <trans-unit id="3ed43b18c0eb498b61dd7767854552765f4cd553" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;m&lt;/code&gt; implementation of &lt;code&gt;generalBracket&lt;/code&gt; returns the pairs &lt;code&gt;(b, s)&lt;/code&gt; and &lt;code&gt;(c, s)&lt;/code&gt;. For monad transformers other than &lt;code&gt;StateT&lt;/code&gt;, this will be some other type representing the effects and values performed and returned by the &lt;code&gt;use&lt;/code&gt; and &lt;code&gt;release&lt;/code&gt; actions. The effect part of the &lt;code&gt;use&lt;/code&gt; result, in this case &lt;code&gt;_s2&lt;/code&gt;, usually needs to be discarded, since those effects have already been incorporated in the &lt;code&gt;release&lt;/code&gt; action.</source>
          <target state="translated">最後に、 &lt;code&gt;generalBracket&lt;/code&gt; の &lt;code&gt;m&lt;/code&gt; 実装は、ペア &lt;code&gt;(b, s)&lt;/code&gt; と &lt;code&gt;(c, s)&lt;/code&gt; 返します。 &lt;code&gt;StateT&lt;/code&gt; 以外のモナド変換子の場合、これは、 &lt;code&gt;use&lt;/code&gt; アクションと &lt;code&gt;release&lt;/code&gt; アクションによって実行および返される効果と値を表す他のタイプになります。 &lt;code&gt;use&lt;/code&gt; 結果のエフェクト部分（この場合は &lt;code&gt;_s2&lt;/code&gt; ）は、 &lt;code&gt;release&lt;/code&gt; アクションにすでに組み込まれているため、通常は破棄する必要があります。</target>
        </trans-unit>
        <trans-unit id="d6c8dcc229ec5ccc377436c171a4012c21910c22" translate="yes" xml:space="preserve">
          <source>Finally, the option &lt;code&gt;-hcsuf&lt;/code&gt; ⟨suffix⟩ will change the &lt;code&gt;.hc&lt;/code&gt; file suffix for compiler-generated intermediate C files.</source>
          <target state="translated">最後に、オプション &lt;code&gt;-hcsuf&lt;/code&gt; ⟨suffix⟩は、コンパイラが生成した中間Cファイルの &lt;code&gt;.hc&lt;/code&gt; ファイルサフィックスを変更します。</target>
        </trans-unit>
        <trans-unit id="5463d0aeddf364c8fd3a47a2799ef56cd3b82670" translate="yes" xml:space="preserve">
          <source>Finally, there's one more special case, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldlM&quot;&gt;foldlM&lt;/a&gt;&lt;/code&gt;, which can short-circuit when the monad &lt;code&gt;m&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;, and the operator invokes &lt;code&gt;&lt;a href=&quot;control-monad#v:mzero&quot;&gt;mzero&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">最後に、もう1つの特殊なケースである &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldlM&quot;&gt;foldlM&lt;/a&gt;&lt;/code&gt; があります。これは、モナド &lt;code&gt;m&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; であり、演算子が &lt;code&gt;&lt;a href=&quot;control-monad#v:mzero&quot;&gt;mzero&lt;/a&gt;&lt;/code&gt; を呼び出すと短絡する可能性があります。</target>
        </trans-unit>
        <trans-unit id="fc21bc943ef04af59cbece2a0d2f3e7aa3c249b5" translate="yes" xml:space="preserve">
          <source>Finally, we can continue the current execution:</source>
          <target state="translated">最後に、現在の実行を続けることができます。</target>
        </trans-unit>
        <trans-unit id="824e9c7851504a7db73de275ca7092aca8efe89b" translate="yes" xml:space="preserve">
          <source>Finally, we need a primitive parser that matches a single character, from which arbitrarily complex parsers may be constructed:</source>
          <target state="translated">最後に、1つの文字にマッチするプリミティブパーサが必要で、そこから任意の複雑なパーサを構築することができます。</target>
        </trans-unit>
        <trans-unit id="15a842f146978f80ebeda74728fb6bdd46209f69" translate="yes" xml:space="preserve">
          <source>Finally, we run the decoder:</source>
          <target state="translated">最後にデコーダを実行します。</target>
        </trans-unit>
        <trans-unit id="58b7317f6459da4bc2d4c53f36913a47893253c7" translate="yes" xml:space="preserve">
          <source>Find all instances \(I\) that &lt;em&gt;match&lt;/em&gt; the target constraint; that is, the target constraint is a substitution instance of \(I\). These instance declarations are the &lt;em&gt;candidates&lt;/em&gt;.</source>
          <target state="translated">ターゲット制約に&lt;em&gt;一致&lt;/em&gt;するすべてのインスタンス\（I \）を検索します。つまり、ターゲット制約は\（I \）の置換インスタンスです。これらのインスタンス宣言は&lt;em&gt;候補&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="a7248c9b5f73c1345281963f4418269f1f39c210" translate="yes" xml:space="preserve">
          <source>Find all the unsolved constraints. Then:</source>
          <target state="translated">すべての未解決の制約を見つけます。それから</target>
        </trans-unit>
        <trans-unit id="2ba0bc35b28ca786d80a16baa1ce7be74e4b397c" translate="yes" xml:space="preserve">
          <source>Find depth of the tree; i.e. the number of branches from the root of the tree to the furthest leaf:</source>
          <target state="translated">木の根元から一番遠い葉までの枝の数を求めます。</target>
        </trans-unit>
        <trans-unit id="f29c9313754b1cc2ec832d12ee7fe9edac95906b" translate="yes" xml:space="preserve">
          <source>Find system-specific limits for a file</source>
          <target state="translated">ファイルのシステム固有の制限値を検索する</target>
        </trans-unit>
        <trans-unit id="386219c63f990092e910133ace2da72816782f7e" translate="yes" xml:space="preserve">
          <source>Find the indexes of all (possibly overlapping) occurences of a substring in a string.</source>
          <target state="translated">文字列中の部分文字列のすべての(重複する可能性のある)出現位置のインデックスを見つけます。</target>
        </trans-unit>
        <trans-unit id="113e5a7f7ef4741af748a8e459880c7c315f837d" translate="yes" xml:space="preserve">
          <source>Find the indices of all non-overlapping occurences of a substring in a string.</source>
          <target state="translated">文字列の中で、ある部分文字列が重ならないように出現するすべてのインデックスを見つける。</target>
        </trans-unit>
        <trans-unit id="d2e1b44278f49d501705a64e05bbba0c134de2fb" translate="yes" xml:space="preserve">
          <source>Find the maximum value in the tree:</source>
          <target state="translated">ツリー内の最大値を求めます。</target>
        </trans-unit>
        <trans-unit id="d1f6a92389a4b52704904fd8094536f941eee60f" translate="yes" xml:space="preserve">
          <source>Find those that are of form &lt;code&gt;(C a)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is a type variable, and partition those constraints into groups that share a common type variable &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; が型変数である &lt;code&gt;(C a)&lt;/code&gt; 形式の制約を見つけ、それらの制約を共通の型変数 &lt;code&gt;a&lt;/code&gt; を共有するグループに分割します。</target>
        </trans-unit>
        <trans-unit id="f82c18b0ef12da1e73963f388a45c81ada40f595" translate="yes" xml:space="preserve">
          <source>FindData</source>
          <target state="translated">FindData</target>
        </trans-unit>
        <trans-unit id="9cebb52c73ccfc1577160b27a264b7adee7d64e0" translate="yes" xml:space="preserve">
          <source>Finding the length</source>
          <target state="translated">長さを探す</target>
        </trans-unit>
        <trans-unit id="fed4c9053d8c85c9d95957c6e01431c7805f793d" translate="yes" xml:space="preserve">
          <source>Fingerprint</source>
          <target state="translated">Fingerprint</target>
        </trans-unit>
        <trans-unit id="3e9225380b48c0d61062495100edfad871bc3253" translate="yes" xml:space="preserve">
          <source>Finish and clean up the line-oriented user interaction session. Blocks on an existing call to &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ライン指向のユーザーインタラクションセッションを終了してクリーンアップします。 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; への既存の呼び出しをブロックします。</target>
        </trans-unit>
        <trans-unit id="fec3922ffd4b25efcef1a899d1768f35b7868ec0" translate="yes" xml:space="preserve">
          <source>Finite Graphs</source>
          <target state="translated">有限グラフ</target>
        </trans-unit>
        <trans-unit id="522d06d1d6ea9ca0805eab7331127be7478e7382" translate="yes" xml:space="preserve">
          <source>Finite Int Maps (lazy interface)</source>
          <target state="translated">有限整数マップ (遅延インターフェース)</target>
        </trans-unit>
        <trans-unit id="747317a4e3d40d7a20e3837df1cd88296c1c8b01" translate="yes" xml:space="preserve">
          <source>Finite Int Maps (strict interface)</source>
          <target state="translated">有限整数マップ (厳密なインターフェイス)</target>
        </trans-unit>
        <trans-unit id="4d744986315c5e9c1268a1c78b68b2bbeb84e7e9" translate="yes" xml:space="preserve">
          <source>Finite Int Sets</source>
          <target state="translated">有限整数集合</target>
        </trans-unit>
        <trans-unit id="29c95a33910ced5bead65681b4bd0706727df804" translate="yes" xml:space="preserve">
          <source>Finite Maps (lazy interface)</source>
          <target state="translated">有限マップ (遅延インターフェース)</target>
        </trans-unit>
        <trans-unit id="f94c42dd95ea5ef128c8b03aa31efa72d11ac882" translate="yes" xml:space="preserve">
          <source>Finite Maps (strict interface)</source>
          <target state="translated">有限マップ (厳密なインターフェース)</target>
        </trans-unit>
        <trans-unit id="215000a5770bdb612d30ff0a9cffc3c9f4c807d0" translate="yes" xml:space="preserve">
          <source>Finite Sets</source>
          <target state="translated">有限集合</target>
        </trans-unit>
        <trans-unit id="5e413d7374fdcec7f72bf32287ef8fde5eb28ea8" translate="yes" xml:space="preserve">
          <source>Finite sequences</source>
          <target state="translated">有限シーケンス</target>
        </trans-unit>
        <trans-unit id="90b6286ad1ab4887e55ec1d1c65eee759a111435" translate="yes" xml:space="preserve">
          <source>FiniteBits</source>
          <target state="translated">FiniteBits</target>
        </trans-unit>
        <trans-unit id="916a78d701ded328cd66da58a97ef8cd28a99e84" translate="yes" xml:space="preserve">
          <source>First</source>
          <target state="translated">First</target>
        </trans-unit>
        <trans-unit id="6f8344a8752e429a8925c432e27736350eeb7113" translate="yes" xml:space="preserve">
          <source>First arg is whether to chop off trailing zeros</source>
          <target state="translated">最初の引数は、末尾のゼロを切り取るかどうかです。</target>
        </trans-unit>
        <trans-unit id="b8249d53487d925c0152bda624de2b210dac99de" translate="yes" xml:space="preserve">
          <source>First component of result is &lt;code&gt;log2 n&lt;/code&gt;, second is &lt;code&gt;0#&lt;/code&gt; iff &lt;em&gt;n&lt;/em&gt; is a power of two.</source>
          <target state="translated">結果の最初のコンポーネントは &lt;code&gt;log2 n&lt;/code&gt; 、2番目は &lt;code&gt;0#&lt;/code&gt; の場合&lt;em&gt;n&lt;/em&gt;は2の累乗です。</target>
        </trans-unit>
        <trans-unit id="a9cad0415018d8c69517c0334ce25bcce363662a" translate="yes" xml:space="preserve">
          <source>First offset in destination &lt;em&gt;not&lt;/em&gt; to copy (i.e. &lt;em&gt;not&lt;/em&gt; length)</source>
          <target state="translated">コピーし&lt;em&gt;ない&lt;/em&gt;宛先の最初のオフセット（つまり&lt;em&gt;、&lt;/em&gt;長さで&lt;em&gt;はありません&lt;/em&gt;）</target>
        </trans-unit>
        <trans-unit id="39654ea89be5465e22c967a1c060f3374651a48d" translate="yes" xml:space="preserve">
          <source>First see if there is a given un-quantified constraint &lt;code&gt;C t&lt;/code&gt;. If so, use it to solve the constraint.</source>
          <target state="translated">まず、与えられた定量化されていない制約 &lt;code&gt;C t&lt;/code&gt; があるかどうかを確認します。その場合は、それを使用して制約を解決します。</target>
        </trans-unit>
        <trans-unit id="8529e6d22ea6c668f307a8a09698c6b3be2a8a1c" translate="yes" xml:space="preserve">
          <source>First, &lt;code&gt;M&lt;/code&gt; imports &lt;code&gt;System.IO.Unsafe&lt;/code&gt;. This is an unsafe module, however &lt;code&gt;M&lt;/code&gt; was compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; , so &lt;code&gt;P&lt;/code&gt;&amp;lsquo;s author takes responsibility for that import. &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;P&lt;/code&gt;&amp;lsquo;s author, so this import is fine.</source>
          <target state="translated">最初に、 &lt;code&gt;M&lt;/code&gt; は &lt;code&gt;System.IO.Unsafe&lt;/code&gt; をインポートします。これは安全ではないモジュールですが、 &lt;code&gt;M&lt;/code&gt; は&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;でコンパイルされているため、 &lt;code&gt;P&lt;/code&gt; の作成者がそのインポートを担当します。 &lt;code&gt;C&lt;/code&gt; は &lt;code&gt;P&lt;/code&gt; の作成者を信頼しているため、このインポートは問題ありません。</target>
        </trans-unit>
        <trans-unit id="3ce8d182339545e607fa71963b2eed8264ebafc8" translate="yes" xml:space="preserve">
          <source>First, &lt;code&gt;M&lt;/code&gt; imports &lt;code&gt;System.IO.Unsafe&lt;/code&gt;. This is an unsafe module, however &lt;code&gt;M&lt;/code&gt; was compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; , so &lt;code&gt;P&lt;/code&gt;&amp;rsquo;s author takes responsibility for that import. &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;P&lt;/code&gt;&amp;rsquo;s author, so this import is fine.</source>
          <target state="translated">まず、 &lt;code&gt;M&lt;/code&gt; は &lt;code&gt;System.IO.Unsafe&lt;/code&gt; をインポートします。これは安全でないモジュールですが、 &lt;code&gt;M&lt;/code&gt; は&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;でコンパイルされているため、 &lt;code&gt;P&lt;/code&gt; の作成者がそのインポートの責任を負います。 &lt;code&gt;C&lt;/code&gt; は &lt;code&gt;P&lt;/code&gt; の作成者を信頼しているため、このインポートは問題ありません。</target>
        </trans-unit>
        <trans-unit id="5b49ba602a9142b1d175089fed4f6f1f4747d3e6" translate="yes" xml:space="preserve">
          <source>First, load the module into GHCi:</source>
          <target state="translated">まず、GHCiにモジュールをロードします。</target>
        </trans-unit>
        <trans-unit id="a26ce7d1c9ec3e2375b176ca79a824e47e99e926" translate="yes" xml:space="preserve">
          <source>First, look up an exact match on the name from the defined macros.</source>
          <target state="translated">まず、定義されているマクロから名前の完全一致を探します。</target>
        </trans-unit>
        <trans-unit id="72664d951135405f560298e2723cacf7238281f9" translate="yes" xml:space="preserve">
          <source>Firstly, they enable terminating resolution where this was not possible before. Consider for instance the following instance declaration for the general rose datatype</source>
          <target state="translated">第一に、以前は不可能だった解決の終了が可能になります。例えば、一般的なバラのデータ型の以下のインスタンス宣言を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="b6ac73901d489c6617642d5ff6f615191248b174" translate="yes" xml:space="preserve">
          <source>FixIOException</source>
          <target state="translated">FixIOException</target>
        </trans-unit>
        <trans-unit id="ab98f5b85764b8561cacbb055a963cd334928cba" translate="yes" xml:space="preserve">
          <source>Fixed</source>
          <target state="translated">Fixed</target>
        </trans-unit>
        <trans-unit id="a9ea98de04db18cc178f8c2aef76ded13d01953b" translate="yes" xml:space="preserve">
          <source>Fixed-size builder primitives</source>
          <target state="translated">固定サイズのビルダープリミティブ</target>
        </trans-unit>
        <trans-unit id="183fb4772d6165cb8789b4e327df15e3ac4d66f2" translate="yes" xml:space="preserve">
          <source>Fixed-size primitives</source>
          <target state="translated">固定サイズのプリミティブ</target>
        </trans-unit>
        <trans-unit id="7fb4ae59c760325c298601ab13e509f25fc37166" translate="yes" xml:space="preserve">
          <source>Fixed-width hexadecimal numbers</source>
          <target state="translated">固定幅16進数</target>
        </trans-unit>
        <trans-unit id="9b5b062b987d276248796f56a62721479458d294" translate="yes" xml:space="preserve">
          <source>FixedPrim</source>
          <target state="translated">FixedPrim</target>
        </trans-unit>
        <trans-unit id="094a567c1926190b7bfd7c0b37606606648002d4" translate="yes" xml:space="preserve">
          <source>Fixities may be declared for type constructors, or classes, just as for data constructors. However, one cannot distinguish between the two in a fixity declaration; a fixity declaration sets the fixity for a data constructor and the corresponding type constructor. For example:</source>
          <target state="translated">データコンストラクタと同様に、型コンストラクタやクラスに対しても固定性を宣言することができます。しかし、固定性宣言では両者を区別することはできません。固定性宣言はデータコンストラクタと対応する型コンストラクタの固定性を設定します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="2b82bbf7b0c566bd4539bf8810f46c5179f626f4" translate="yes" xml:space="preserve">
          <source>Fixity</source>
          <target state="translated">Fixity</target>
        </trans-unit>
        <trans-unit id="57d494452eec64b65e5dc39ee592c4fe9616d8e2" translate="yes" xml:space="preserve">
          <source>Fixity declarations are exactly as in Haskell.</source>
          <target state="translated">固定性の宣言はHaskellと全く同じです。</target>
        </trans-unit>
        <trans-unit id="eb3a8c37524386d27f7d07ee18bd0c65f631fe49" translate="yes" xml:space="preserve">
          <source>Fixity lookup</source>
          <target state="translated">フィクシティルックアップ</target>
        </trans-unit>
        <trans-unit id="ff8a94000f86e8a577cd0b25a42fc9985d6fd243" translate="yes" xml:space="preserve">
          <source>Fixity of constructors</source>
          <target state="translated">コンストラクタの固定性</target>
        </trans-unit>
        <trans-unit id="3b3ce8c52db6806c8b912790bee2abcfa0095fad" translate="yes" xml:space="preserve">
          <source>Fixity, type synonym, open type/data family declarations are permitted as in normal Haskell.</source>
          <target state="translated">固定性、型同義語、オープン型/データファミリ宣言は通常のHaskellと同様に許可されています。</target>
        </trans-unit>
        <trans-unit id="88b3259b4db22b3078551b6bfb8b24795404727c" translate="yes" xml:space="preserve">
          <source>FixityDirection</source>
          <target state="translated">FixityDirection</target>
        </trans-unit>
        <trans-unit id="ce8b7e3c9475365f4009091caff86162598e45a6" translate="yes" xml:space="preserve">
          <source>FixityI</source>
          <target state="translated">FixityI</target>
        </trans-unit>
        <trans-unit id="a774409a00c21de377cf8ed5c6a56b8547973042" translate="yes" xml:space="preserve">
          <source>Flag</source>
          <target state="translated">Flag</target>
        </trans-unit>
        <trans-unit id="97377a994fd4b8ac108223fa55cd48065f0287d8" translate="yes" xml:space="preserve">
          <source>Flag saying &amp;ldquo;stop after&amp;rdquo;</source>
          <target state="translated">「後に停止」と言っている旗</target>
        </trans-unit>
        <trans-unit id="c79a88ff731c8edaa92ba0e1a888148cff60ea92" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlopen&quot;&gt;dlopen&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlopen&quot;&gt;dlopen&lt;/a&gt;&lt;/code&gt; のフラグ。</target>
        </trans-unit>
        <trans-unit id="aea2c8ec1977d6e31bcb021cb1dabebaa2c6f4b8" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;&lt;a href=&quot;system-posix#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; might not be available on your particular platform! Use &lt;code&gt;&lt;a href=&quot;system-posix#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt; のフラグ。特定のプラットフォームでは &lt;code&gt;&lt;a href=&quot;system-posix#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; が使用できない場合があることに注意してください。 &lt;code&gt;&lt;a href=&quot;system-posix#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="68646c4bfdfb2b77627104cc76a37fdf802fe2ab" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; might not be available on your particular platform! Use &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt; のフラグ。特定のプラットフォームでは &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; が使用できない場合があることに注意してください。 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="43b5985213e56988275f428db4afd1aca092b76c" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; might not be available on your particular platform! Use &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt; のフラグ。特定のプラットフォームでは &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; が使用できない場合があることに注意してください。 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="6604408a39b5823a2d8caf9d995d09a15ce36fdd" translate="yes" xml:space="preserve">
          <source>Flags to control debugging output &amp;amp; extra checking in various subsystems.</source>
          <target state="translated">さまざまなサブシステムでのデバッグ出力と追加のチェックを制御するフラグ。</target>
        </trans-unit>
        <trans-unit id="953fe397d4a88b2eb7a202d8c11d1d4f2b2605c7" translate="yes" xml:space="preserve">
          <source>Flatten strict constructor fields</source>
          <target state="translated">厳密なコンストラクタのフィールドを平坦化する</target>
        </trans-unit>
        <trans-unit id="32ce3a4131c78ef5b3006aaff0098352e801ebfd" translate="yes" xml:space="preserve">
          <source>Flatten strict constructor fields with a pointer-sized representation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ポインタサイズの表現を使用して、厳密なコンストラクタフィールドをフラット化します。&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;によって暗示されます。</target>
        </trans-unit>
        <trans-unit id="50dc207a02ef3d6c64feba0eb22a156d325327b3" translate="yes" xml:space="preserve">
          <source>FlexibleContexts</source>
          <target state="translated">FlexibleContexts</target>
        </trans-unit>
        <trans-unit id="dcec06754c91ecfff545b2f2cce80146b795726a" translate="yes" xml:space="preserve">
          <source>FlexibleInstances</source>
          <target state="translated">FlexibleInstances</target>
        </trans-unit>
        <trans-unit id="e4ccb090ca696917e5de23363132c4238087f15c" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">フリップ &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 。&lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;の &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="5aa9a79151c09f2b1c44f8f5b45f86e26536f4e8" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">フリップ &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 。&lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;の &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="12167983d0afff206c046e1d6d922143291d5f3e" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchAll&quot;&gt;catchAll&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">反転した &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchAll&quot;&gt;catchAll&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd78f746eff5d069a4c69da8e38598e4dcbf4a4c" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">反転した &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a015af1d71e496c444ce3c462d153241cce86f16" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIf&quot;&gt;catchIf&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">反転した &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIf&quot;&gt;catchIf&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0dafc2e8e7144d1472eedd451318a1d1537aeb13" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:handleJust&quot;&gt;handleJust&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">フリップ &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; 。&lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;の &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:handleJust&quot;&gt;handleJust&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="8f081d19b6a1634db731d6fc797a0dd377b306de" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:handleJust&quot;&gt;handleJust&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">フリップ &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; 。&lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;の &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:handleJust&quot;&gt;handleJust&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="5f4b18a46cb894bc45a39a5999838fa58714fd24" translate="yes" xml:space="preserve">
          <source>Flipped version of &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt; の反転バージョン。</target>
        </trans-unit>
        <trans-unit id="fb11700d163e40830d0bae242266c3294e9edd3a" translate="yes" xml:space="preserve">
          <source>Flipped version of &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; の反転バージョン。</target>
        </trans-unit>
        <trans-unit id="64435fd82de7b1d614dfb9844848a48b14c6cd2c" translate="yes" xml:space="preserve">
          <source>Float</source>
          <target state="translated">Float</target>
        </trans-unit>
        <trans-unit id="11c392eaf9a273578cddca36e05784e7ec0207b3" translate="yes" xml:space="preserve">
          <source>Float let-bindings inwards, nearer their binding site. See &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;Let-floating: moving bindings to give faster programs (ICFP&amp;lsquo;96)&lt;/a&gt;.</source>
          <target state="translated">letバインディングを内側に、それらのバインディングサイトの近くにフロートします。&lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;Let-floating：バインディングを移動してプログラムを高速化する（ICFP'96）を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="5e0526b9852afffdf9689fa74f06581b7f3b3784" translate="yes" xml:space="preserve">
          <source>Float let-bindings inwards, nearer their binding site. See &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;Let-floating: moving bindings to give faster programs (ICFP&amp;rsquo;96)&lt;/a&gt;.</source>
          <target state="translated">結合部位の近くで、レット結合を内側に浮かせます。&lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;Let-floating：バインディングを移動してより高速なプログラムを提供する（ICFP'96）を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a99a789a6440d2e0783c52c14f1b895aa85ee6da" translate="yes" xml:space="preserve">
          <source>Float methods</source>
          <target state="translated">フロート法</target>
        </trans-unit>
        <trans-unit id="03c6a3d4a620ad6a95690d9257e6602cfa12ec6b" translate="yes" xml:space="preserve">
          <source>Float#</source>
          <target state="translated">Float#</target>
        </trans-unit>
        <trans-unit id="e84ef7c494482d98641252e0399d1dd94c8bfe32" translate="yes" xml:space="preserve">
          <source>Float/Int conversions, wrapped primops</source>
          <target state="translated">フロート/整数変換、ラップされたプリモプス</target>
        </trans-unit>
        <trans-unit id="471bcd60035338d11d9230973a397e8b65fdb767" translate="yes" xml:space="preserve">
          <source>FloatElemRep</source>
          <target state="translated">FloatElemRep</target>
        </trans-unit>
        <trans-unit id="89b3a61017b0b9614ae8ccc16d0818a913c0e924" translate="yes" xml:space="preserve">
          <source>FloatRep</source>
          <target state="translated">FloatRep</target>
        </trans-unit>
        <trans-unit id="a653d15a4777ec0f86a07afd7ce540d8514fe97b" translate="yes" xml:space="preserve">
          <source>FloatX16#</source>
          <target state="translated">FloatX16#</target>
        </trans-unit>
        <trans-unit id="11e6eacae4a18d2e4bd76e48d4a57fa313675caf" translate="yes" xml:space="preserve">
          <source>FloatX4#</source>
          <target state="translated">FloatX4#</target>
        </trans-unit>
        <trans-unit id="29c459076fc63798f4132325e3f3f308a1e5b6f4" translate="yes" xml:space="preserve">
          <source>FloatX8#</source>
          <target state="translated">FloatX8#</target>
        </trans-unit>
        <trans-unit id="ab224b51965363d31db26ddc6738fa145bb46562" translate="yes" xml:space="preserve">
          <source>Floating</source>
          <target state="translated">Floating</target>
        </trans-unit>
        <trans-unit id="26f84222b978702da534998cccf7e093da992898" translate="yes" xml:space="preserve">
          <source>Floating types</source>
          <target state="translated">浮動型</target>
        </trans-unit>
        <trans-unit id="450e2ff7d08682a58ebee70fca61dbfb6a6e7063" translate="yes" xml:space="preserve">
          <source>FlowAction</source>
          <target state="translated">FlowAction</target>
        </trans-unit>
        <trans-unit id="6e5ef5487191e4dd22398274011cf12de9a91e94" translate="yes" xml:space="preserve">
          <source>Flush all the data from the supplied write buffer out to the device. The returned buffer should be empty, and ready for writing.</source>
          <target state="translated">供給された書き込みバッファからすべてのデータをデバイスにフラッシュアウトします。返されたバッファは空で、書き込み可能な状態でなければなりません。</target>
        </trans-unit>
        <trans-unit id="bf6064155984dcdefe2820b834eb03fc5450e184" translate="yes" xml:space="preserve">
          <source>Flush buffers (if any) of your custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;. This can be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">カスタム&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; の&lt;/a&gt;バッファ（存在する場合）をフラッシュします。これは &lt;code&gt;NULL&lt;/code&gt; にすることができます。</target>
        </trans-unit>
        <trans-unit id="358b7b4736340628089a578a4f127145e9f86637" translate="yes" xml:space="preserve">
          <source>Flush data from the supplied write buffer out to the device without blocking. Returns the number of bytes written and the remaining buffer.</source>
          <target state="translated">供給された書き込みバッファから、ブロックせずにデバイスにデータをフラッシュアウトします。書き込まれたバイト数とバッファの残量を返します。</target>
        </trans-unit>
        <trans-unit id="cd61c8c15dd02466359a4d4a7b35cb820213dbe9" translate="yes" xml:space="preserve">
          <source>Flush the current buffer. This introduces a chunk boundary.</source>
          <target state="translated">現在のバッファをフラッシュします。これはチャンク境界を導入します。</target>
        </trans-unit>
        <trans-unit id="8f2757271a40ce096379108294905c1babb07ac2" translate="yes" xml:space="preserve">
          <source>Flushing the buffer state</source>
          <target state="translated">バッファの状態をフラッシュする</target>
        </trans-unit>
        <trans-unit id="245ac1ca610984dee51983b1a19924096b479a7d" translate="yes" xml:space="preserve">
          <source>Flushing the implicit parse state</source>
          <target state="translated">暗黙の構文解析状態をフラッシュする</target>
        </trans-unit>
        <trans-unit id="2374f7905efdc0f4f714c25a7472902042311cdf" translate="yes" xml:space="preserve">
          <source>Fold a list using the monoid.</source>
          <target state="translated">モノイドを使ってリストを折りたたむ。</target>
        </trans-unit>
        <trans-unit id="0a7cc99c934753ce6e6950e7c43626ab6fa6d2f5" translate="yes" xml:space="preserve">
          <source>Fold a tree into a &quot;summary&quot; value in depth-first order.</source>
          <target state="translated">ツリーを深さ優先で「まとめ」の値に折りたたむ。</target>
        </trans-unit>
        <trans-unit id="f67973842ff2d508f50cd5451a0e67d4a63ae01e" translate="yes" xml:space="preserve">
          <source>Fold an &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; case-wise, just like &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; ように、 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; ケースごとに折りたたみます。</target>
        </trans-unit>
        <trans-unit id="5f671e4bd34a867cbf0e6b25023adc640a86e3db" translate="yes" xml:space="preserve">
          <source>Fold from right to left.</source>
          <target state="translated">右から左に折ります。</target>
        </trans-unit>
        <trans-unit id="8b610be124aa3a40ce1b39d37fc11b0b04c6263e" translate="yes" xml:space="preserve">
          <source>Foldable</source>
          <target state="translated">Foldable</target>
        </trans-unit>
        <trans-unit id="37d91c80ee36726ccf43b2e7f00be807a7045256" translate="yes" xml:space="preserve">
          <source>Foldable structures are reduced to a summary value by accumulating contributions to the result one element at a time.</source>
          <target state="translated">折りたたみ式の構造体は、結果への貢献度を要素ごとに蓄積することで、要約値に還元されます。</target>
        </trans-unit>
        <trans-unit id="6b84829350dde1e376868f53c48ad67c4112eee6" translate="yes" xml:space="preserve">
          <source>Folding actions</source>
          <target state="translated">折りたたみ動作</target>
        </trans-unit>
        <trans-unit id="2d8b815138c38106cf926a1dd7d970d8c84885c4" translate="yes" xml:space="preserve">
          <source>Folds</source>
          <target state="translated">Folds</target>
        </trans-unit>
        <trans-unit id="c88897f7a995c31a2d98d1a61bd0b6af136abc63" translate="yes" xml:space="preserve">
          <source>Folds and traversals</source>
          <target state="translated">折り目とトラバース</target>
        </trans-unit>
        <trans-unit id="2186e55af17afc5fa2144b8775a49f1290a3d33b" translate="yes" xml:space="preserve">
          <source>Folds in order of increasing key.</source>
          <target state="translated">キーの多い順に折りたたむ。</target>
        </trans-unit>
        <trans-unit id="8bd6a5b4641abf50c3fa996016c263fddb09d728" translate="yes" xml:space="preserve">
          <source>Folds of unbounded structures do not terminate when the monoid's &lt;code&gt;(&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; operator is strict:</source>
          <target state="translated">モノイドの &lt;code&gt;(&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; 演算子が厳密な場合、非有界構造体のフォールドは終了しません。</target>
        </trans-unit>
        <trans-unit id="d57295c01bef2c30b4729669a29577172c281ea3" translate="yes" xml:space="preserve">
          <source>Following a suggestion of Mark Jones, in his paper &lt;a href=&quot;https://web.cecs.pdx.edu/~mpj/thih/&quot;&gt;Typing Haskell in Haskell&lt;/a&gt;, GHC implements a more general scheme. In GHC &lt;em&gt;the dependency analysis ignores references to variables that have an explicit type signature&lt;/em&gt;. As a result of this refined dependency analysis, the dependency groups are smaller, and more bindings will typecheck. For example, consider:</source>
          <target state="translated">Mark Jonesの提案に従って、GHC は彼の論文&lt;a href=&quot;https://web.cecs.pdx.edu/~mpj/thih/&quot;&gt;Typing Haskell in Haskell&lt;/a&gt;で、より一般的なスキームを実装しています。GHC &lt;em&gt;では、依存関係分析は明示的な型シグネチャを持つ変数への参照を無視します&lt;/em&gt;。この洗練された依存関係分析の結果、依存関係グループは小さくなり、より多くのバインディングでタイプチェックが行われます。たとえば、次のことを考慮してください。</target>
        </trans-unit>
        <trans-unit id="5cb7231f65ffda9aaf11e030c71a231be4c4e62b" translate="yes" xml:space="preserve">
          <source>Following the ISO-10646 standard, &lt;code&gt;maxBound :: Char&lt;/code&gt; in GHC is &lt;code&gt;0x10FFFF&lt;/code&gt;.</source>
          <target state="translated">ISO-10646標準に従い、GHCの &lt;code&gt;maxBound :: Char&lt;/code&gt; は &lt;code&gt;0x10FFFF&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="683450681a094431fa846533675f44d1e8b059fa" translate="yes" xml:space="preserve">
          <source>Follows the recommendations in &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&lt;/a&gt;の推奨事項に従います</target>
        </trans-unit>
        <trans-unit id="24f8eb6fedbc854f6eb4756da6cd5c7a8c568aea" translate="yes" xml:space="preserve">
          <source>Follows the recommendations in &lt;a href=&quot;https://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&lt;/a&gt;の推奨事項に従います</target>
        </trans-unit>
        <trans-unit id="31d946127399c2228b066615f8fa0d54aa0a373b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt;, the &lt;em&gt;non-deterministic&lt;/em&gt; behaviour of &lt;code&gt;List&lt;/code&gt; is most easily seen in the case of a list of lists (of elements of some common fixed type). The result is a cross-product of all the sublists:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; 、&lt;em&gt;非決定論&lt;/em&gt;の行動 &lt;code&gt;List&lt;/code&gt; 最も簡単に（いくつかの一般的な固定型の要素の）リストのリストの場合に見られます。結果は、すべてのサブリストの外積です。</target>
        </trans-unit>
        <trans-unit id="7e8a1a6a78e6e0c64059181cdc137c3f13446688" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;/code&gt; and &lt;code&gt;&lt;em&gt;b&lt;/em&gt;&lt;/code&gt;, compute their greatest common divisor &lt;code&gt;&lt;em&gt;g&lt;/em&gt;&lt;/code&gt; and the coefficient &lt;code&gt;&lt;em&gt;s&lt;/em&gt;&lt;/code&gt; satisfying &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;s&lt;/em&gt; + &lt;em&gt;b&lt;/em&gt;&lt;em&gt;t&lt;/em&gt; = &lt;em&gt;g&lt;/em&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;/code&gt; と &lt;code&gt;&lt;em&gt;b&lt;/em&gt;&lt;/code&gt; について&lt;em&gt;、&lt;/em&gt;最大公約数 &lt;code&gt;&lt;em&gt;g&lt;/em&gt;&lt;/code&gt; と &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;s&lt;/em&gt; + &lt;em&gt;b&lt;/em&gt;&lt;em&gt;t&lt;/em&gt; = &lt;em&gt;g&lt;/em&gt;&lt;/code&gt; &lt;em&gt;s&lt;/em&gt; + &lt;em&gt;b &lt;/em&gt;&lt;em&gt;t&lt;/em&gt; = &lt;em&gt;g&lt;/em&gt;を満たす係数 &lt;code&gt;&lt;em&gt;s&lt;/em&gt;&lt;/code&gt; を計算します。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="438754bee88837ce49606e1c3c4cb154a8fdc138" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;CalendarDiffDays&lt;/code&gt; (and &lt;code&gt;CalendarDiffTime&lt;/code&gt;):</source>
          <target state="translated">以下のための &lt;code&gt;CalendarDiffDays&lt;/code&gt; （および &lt;code&gt;CalendarDiffTime&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="38c17a34f43461761882cc425a0ecd3ab0e949ec" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;CalendarDiffTime&lt;/code&gt;:</source>
          <target state="translated">以下のための &lt;code&gt;CalendarDiffTime&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1c0143b791c012f113a8232c3ab197fb3753fd36" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Day&lt;/code&gt; (and &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">以下のため &lt;code&gt;Day&lt;/code&gt; （と &lt;code&gt;LocalTime&lt;/code&gt; と &lt;code&gt;ZonedTime&lt;/code&gt; と &lt;code&gt;UTCTime&lt;/code&gt; と &lt;code&gt;UniversalTime&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="20a7a91f2f957f2a10870727acfcfa4a35d3973b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DayOfWeek&lt;/code&gt; (and &lt;code&gt;Day&lt;/code&gt; and &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">以下のため &lt;code&gt;DayOfWeek&lt;/code&gt; （および &lt;code&gt;Day&lt;/code&gt; と &lt;code&gt;LocalTime&lt;/code&gt; と &lt;code&gt;ZonedTime&lt;/code&gt; と &lt;code&gt;UTCTime&lt;/code&gt; と &lt;code&gt;UniversalTime&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="72a84ee2f0f4c4168eef092af153fed065cacbf6" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;LocalTime&lt;/code&gt; (and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">以下のため &lt;code&gt;LocalTime&lt;/code&gt; （および &lt;code&gt;ZonedTime&lt;/code&gt; と &lt;code&gt;UTCTime&lt;/code&gt; と &lt;code&gt;UniversalTime&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="43312a6d64a5882430cc27d6c5bcaff6112fd683" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;NominalDiffTime&lt;/code&gt; and &lt;code&gt;DiffTime&lt;/code&gt;:</source>
          <target state="translated">以下のための &lt;code&gt;NominalDiffTime&lt;/code&gt; と &lt;code&gt;DiffTime&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="58ae54bfb7d2d0244bc285d96a987c748a014820" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;TimeOfDay&lt;/code&gt; (and &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">以下のための &lt;code&gt;TimeOfDay&lt;/code&gt; （と &lt;code&gt;LocalTime&lt;/code&gt; と &lt;code&gt;ZonedTime&lt;/code&gt; と &lt;code&gt;UTCTime&lt;/code&gt; と &lt;code&gt;UniversalTime&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="de676cebc1b71a848f33653aed6cf2c30d41ec6c" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;TimeZone&lt;/code&gt; (and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt;):</source>
          <target state="translated">以下のための &lt;code&gt;TimeZone&lt;/code&gt; （および &lt;code&gt;ZonedTime&lt;/code&gt; と &lt;code&gt;UTCTime&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="780610a5f5cec081a6e5e8e4fd872022d4b9ccd3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt;:</source>
          <target state="translated">以下のための &lt;code&gt;UTCTime&lt;/code&gt; と &lt;code&gt;ZonedTime&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="41f6ee1958af63054f1e2c3d4dd9c1a48d13ac68" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;base &amp;gt;= 4.8.0&lt;/code&gt; and &lt;code&gt;containers &amp;gt;= 0.5.11&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; is a synonym for &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateA&quot;&gt;replicateA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以下のために &lt;code&gt;base &amp;gt;= 4.8.0&lt;/code&gt; と &lt;code&gt;containers &amp;gt;= 0.5.11&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; は同義語である &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateA&quot;&gt;replicateA&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc47e5122f21703f2a3de45263a7aaf0eac1316f" translate="yes" xml:space="preserve">
          <source>For POSIX users, this is equivalent to &lt;code&gt;&lt;a href=&quot;../unix-2.7.2.2/system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">POSIXユーザーの場合、これは &lt;code&gt;&lt;a href=&quot;../unix-2.7.2.2/system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="c17acddc624fd77e3cb189ccd12fd6ee29107023" translate="yes" xml:space="preserve">
          <source>For POSIX users, this is equivalent to &lt;code&gt;&lt;a href=&quot;system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">POSIXユーザーの場合、これは &lt;code&gt;&lt;a href=&quot;system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="12834118955436c30a4e545201bc91502d57a5e3" translate="yes" xml:space="preserve">
          <source>For a bidirectional pattern synonym, a use of the pattern synonym as an expression has the type</source>
          <target state="translated">双方向パターン同義語の場合、パターン同義語を式として使用する場合、型は</target>
        </trans-unit>
        <trans-unit id="68e1aba695e3ce91a31fd34537a2f0dd4c81abe3" translate="yes" xml:space="preserve">
          <source>For a class, every type variable must be annotated with a kind.</source>
          <target state="translated">クラスでは、すべての型変数に kind をアノテーションしなければなりません。</target>
        </trans-unit>
        <trans-unit id="8fe53f9ccf4406924e6b6d736fa635a1f07be35e" translate="yes" xml:space="preserve">
          <source>For a complex number &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; z&lt;/code&gt; is a number with the magnitude of &lt;code&gt;z&lt;/code&gt;, but oriented in the positive real direction, whereas &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt; z&lt;/code&gt; has the phase of &lt;code&gt;z&lt;/code&gt;, but unit magnitude.</source>
          <target state="translated">複素数のための &lt;code&gt;z&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; z&lt;/code&gt; の大きさと数であり &lt;code&gt;z&lt;/code&gt; が、一方、正の実方向に配向 &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt; z&lt;/code&gt; 位相有し &lt;code&gt;z&lt;/code&gt; が、単位の大きさ。</target>
        </trans-unit>
        <trans-unit id="bde3bc31dcf2451837a45deb22082c15149b6c7b" translate="yes" xml:space="preserve">
          <source>For a comprehensive listing of supported platforms, please refer to &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/-/wikis/platforms&quot;&gt;https://gitlab.haskell.org/ghc/ghc/-/wikis/platforms&lt;/a&gt;</source>
          <target state="translated">サポートされているプラ​​ットフォームの包括的なリストについては、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/-/wikis/platforms&quot;&gt;https：//gitlab.haskell.org/ghc/ghc/-/wikis/platforms&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="381187e4f3ff0b6bc5d10ac5d2f67f7b97f7590a" translate="yes" xml:space="preserve">
          <source>For a datatype with a top-level &lt;code&gt;::&lt;/code&gt;: all kind variables introduced after the &lt;code&gt;::&lt;/code&gt; must be explicitly quantified.</source>
          <target state="translated">トップレベルでのデータ型について &lt;code&gt;::&lt;/code&gt; ：後に導入されたすべての種類の変数 &lt;code&gt;::&lt;/code&gt; 明示的に定量化する必要があります。</target>
        </trans-unit>
        <trans-unit id="ee774f603ab065899ff7fb5a9bcaeae920fd5a55" translate="yes" xml:space="preserve">
          <source>For a datatype, every type variable must be annotated with a kind. In a GADT-style declaration, there may also be a kind signature (with a top-level &lt;code&gt;::&lt;/code&gt; in the header), but the presence or absence of this annotation does not affect whether or not the declaration has a complete signature.</source>
          <target state="translated">データ型の場合、すべての型変数に種類の注釈を付ける必要があります。GADTスタイルの宣言では、種類のシグネチャもある場合があります（トップレベルの &lt;code&gt;::&lt;/code&gt; ヘッダーにが、このアノテーションの有無は、宣言に完全なシグネチャがあるかどうかには影響しません。</target>
        </trans-unit>
        <trans-unit id="7c12c8fb4a7f215c82a05683a5710f3a85d7f1fd" translate="yes" xml:space="preserve">
          <source>For a detailed discussion, see Levent Erkok's thesis, &lt;em&gt;Value Recursion in Monadic Computations&lt;/em&gt;, Oregon Graduate Institute, 2002.</source>
          <target state="translated">詳細な議論については、レベント・エルコクの論文、モナディック&lt;em&gt;計算における価値再帰&lt;/em&gt;、オレゴン大学院、2002年を参照。</target>
        </trans-unit>
        <trans-unit id="ff2aa12fcb0881466720f2e80b4f0d096c83a123" translate="yes" xml:space="preserve">
          <source>For a full specification of the algorithms used in &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Compiler/DeriveFunctor&quot;&gt;this wiki page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;で使用されるアルゴリズムの完全な仕様については、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Compiler/DeriveFunctor&quot;&gt;このWikiページを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aa43273cfde854c1384910a8e3bf21706a4937f0" translate="yes" xml:space="preserve">
          <source>For a full specification of the algorithms used in &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/derive-functor&quot;&gt;this wiki page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;で使用されるアルゴリズムの完全な仕様については、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/derive-functor&quot;&gt;このwikiページを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f753874b80e6283217fbd2405e5d7bb6c4151408" translate="yes" xml:space="preserve">
          <source>For a fully working example, see &lt;code&gt;testsuite/tests/concurrent/should_run/hs_try_putmvar001.hs&lt;/code&gt; in the GHC source tree.</source>
          <target state="translated">完全に機能する例については、GHCソースツリーの &lt;code&gt;testsuite/tests/concurrent/should_run/hs_try_putmvar001.hs&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="b02bfdafd93af69d743b0ce3c0a4317ebee1f2be" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to,</source>
          <target state="translated">一般的な &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 構造のこれは意味的に同じである必要があります。</target>
        </trans-unit>
        <trans-unit id="f4c2f154344db246f733b27e08b4fac32576674c" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to:</source>
          <target state="translated">一般的な &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 構造の場合、これは意味的に次のようになります。</target>
        </trans-unit>
        <trans-unit id="ce4b8eeb28d94d8e7c6254b4d94c9ba94f5eaa06" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to,</source>
          <target state="translated">一般的な &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 構造の場合、これは意味的に同じである必要があります。</target>
        </trans-unit>
        <trans-unit id="eb1a2ffe8319962a0d9758d8d5c92f844737e908" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to:</source>
          <target state="translated">一般的な &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 構造の場合、これは意味的に次のようになります。</target>
        </trans-unit>
        <trans-unit id="4ffd351d10bb1cc76d3c976825e9c103713a2402" translate="yes" xml:space="preserve">
          <source>For a given heap size (using the &lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-H [⟨size⟩]&lt;/code&gt;&lt;/a&gt; option), compaction can in fact reduce the GC cost by allowing fewer GCs to be performed. This is more likely when the ratio of live data to heap size is high, say greater than 30%.</source>
          <target state="translated">特定のヒープサイズ（&lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; &lt;/a&gt;オプションを使用）の場合、圧縮により、実行できるGCが少なくなるため、実際にはGCのコストを削減できます。これは、ヒープサイズに対するライブデータの比率が高い場合、たとえば30％を超える場合に発生する可能性が高くなります。</target>
        </trans-unit>
        <trans-unit id="690c81581725977a80c5ea6bb4e5ee9018b2f21a" translate="yes" xml:space="preserve">
          <source>For a given heap size (using the &lt;code&gt;-H ⟨size⟩&lt;/code&gt; option), compaction can in fact reduce the GC cost by allowing fewer GCs to be performed. This is more likely when the ratio of live data to heap size is high, say greater than 30%.</source>
          <target state="translated">特定のヒープサイズ（ &lt;code&gt;-H ⟨size⟩&lt;/code&gt; オプションを使用）の場合、圧縮により、実行するGCの数を減らすことができるため、実際にGCのコストを削減できます。これは、ライブデータとヒープサイズの比率が高く、30％を超える場合などに発生しやすくなります。</target>
        </trans-unit>
        <trans-unit id="dade435c995cd800c773d6e4aa166b67efb6ca38" translate="yes" xml:space="preserve">
          <source>For a handle &lt;code&gt;hdl&lt;/code&gt; which attached to a physical file, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns the size of that file in 8-bit bytes.</source>
          <target state="translated">物理ファイルにアタッチされたハンドル &lt;code&gt;hdl&lt;/code&gt; の場合、 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; はそのファイルのサイズを8ビットバイトで返します。</target>
        </trans-unit>
        <trans-unit id="d3c63f5fcdc6df7421dc6b15f96e58c2cd3eb2d6" translate="yes" xml:space="preserve">
          <source>For a handle &lt;code&gt;hdl&lt;/code&gt; which attached to a physical file, &lt;code&gt;&lt;a href=&quot;system-io#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns the size of that file in 8-bit bytes.</source>
          <target state="translated">物理ファイルにアタッチされたハンドル &lt;code&gt;hdl&lt;/code&gt; の場合、 &lt;code&gt;&lt;a href=&quot;system-io#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; はそのファイルのサイズを8ビットバイトで返します。</target>
        </trans-unit>
        <trans-unit id="346fb7900fc27cffc7ae7ee52aedbaed80128cb6" translate="yes" xml:space="preserve">
          <source>For a lambda-bound or case-bound variable, x, either the programmer provides an explicit polymorphic type for x, or GHC&amp;rsquo;s type inference will assume that x&amp;rsquo;s type has no foralls in it.</source>
          <target state="translated">ラムダにバインドされた変数またはケースにバインドされた変数xの場合、プログラマーはxに明示的なポリモーフィック型を提供するか、GHCの型推論はxの型にforallがないと想定します。</target>
        </trans-unit>
        <trans-unit id="f6acc7fc1a003a7f2eed93e34c1d5012a4db3a7b" translate="yes" xml:space="preserve">
          <source>For a monadic version see &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldForestM_BF&quot;&gt;unfoldForestM_BF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">モナディックバージョンについては、 &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldForestM_BF&quot;&gt;unfoldForestM_BF&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="c7723435d9290343f2201698a48102c4e2963ac9" translate="yes" xml:space="preserve">
          <source>For a monadic version see &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldTreeM_BF&quot;&gt;unfoldTreeM_BF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">モナディックバージョンについては、 &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldTreeM_BF&quot;&gt;unfoldTreeM_BF&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="41fb437ba339dfd70d91e29e645efbb597123e67" translate="yes" xml:space="preserve">
          <source>For a newtype, the rules are the same as they are for a data type unless &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; is enabled. With &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt;, the type constructor only has a CUSK if a kind signature is present. As with a datatype with a top-level &lt;code&gt;::&lt;/code&gt;, all kind variables must introduced after the &lt;code&gt;::&lt;/code&gt; must be explicitly quantified</source>
          <target state="translated">&lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt;場合、UnliftedNewtypesが有効になっていない限り、ルールはデータ型の場合と同じです。&lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt;種類のシグネチャが存在する場合、型コンストラクタのみCUSKを有しています。トップレベルの &lt;code&gt;::&lt;/code&gt; を持つデータ型と同様に、すべての種類の変数は、 &lt;code&gt;::&lt;/code&gt; を明示的に定量化する必要があります。</target>
        </trans-unit>
        <trans-unit id="4d8cf6ad049da3ffe486c394fe0bd5021d502284" translate="yes" xml:space="preserve">
          <source>For a newtype, the rules are the same as they are for a data type unless &lt;a href=&quot;primitives#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; is enabled. With &lt;a href=&quot;primitives#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt;, the type constructor only has a CUSK if a kind signature is present. As with a datatype with a top-level &lt;code&gt;::&lt;/code&gt;, all kind variables introduced after the &lt;code&gt;::&lt;/code&gt; must be explicitly quantified</source>
          <target state="translated">&lt;a href=&quot;primitives#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt;場合、UnliftedNewtypesが有効になっていない限り、ルールはデータ型の場合と同じです。&lt;a href=&quot;primitives#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt;種類のシグネチャが存在する場合、型コンストラクタのみCUSKを有しています。トップレベル &lt;code&gt;::&lt;/code&gt; のデータ型と同様に、 &lt;code&gt;::&lt;/code&gt; の後に導入されるすべての種類の変数は明示的に定量化する必要があります</target>
        </trans-unit>
        <trans-unit id="deb1847901cd6f8ebc084093215bfbec76990b3e" translate="yes" xml:space="preserve">
          <source>For a plain &lt;code&gt;foreign export&lt;/code&gt;, the file &lt;code&gt;M_stub.h&lt;/code&gt; contains a C prototype for the foreign exported function. For example, if we compile the following module:</source>
          <target state="translated">単純な &lt;code&gt;foreign export&lt;/code&gt; 場合、ファイル &lt;code&gt;M_stub.h&lt;/code&gt; には、外部エクスポート関数のCプロトタイプが含まれています。たとえば、次のモジュールをコンパイルするとします。</target>
        </trans-unit>
        <trans-unit id="2010d0ed548d603dcd6e8de87d973f011d76f796" translate="yes" xml:space="preserve">
          <source>For a polykinded type family, the kinds are checked for apartness just like types. For example, the following is accepted:</source>
          <target state="translated">多重結合型ファミリーの場合は、型と同様に種類が離れているかどうかをチェックします。例えば、以下のようなものが受け入れられます。</target>
        </trans-unit>
        <trans-unit id="1ec55d48cfc12f5eb55df6ee4c9fc9967d025743" translate="yes" xml:space="preserve">
          <source>For a read-only state, see &lt;a href=&quot;control-monad-trans-reader&quot;&gt;Control.Monad.Trans.Reader&lt;/a&gt;.</source>
          <target state="translated">読み取り専用の状態については、&lt;a href=&quot;control-monad-trans-reader&quot;&gt;Control.Monad.Trans.Readerを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="89e5871716007219289211d50f9f31d07f96bebe" translate="yes" xml:space="preserve">
          <source>For a readable handle &lt;code&gt;hdl&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if no further input can be taken from &lt;code&gt;hdl&lt;/code&gt; or for a physical file, if the current I/O position is equal to the length of the file. Otherwise, it returns &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">読み取り可能なハンドル &lt;code&gt;hdl&lt;/code&gt; の場合、 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; は、 &lt;code&gt;hdl&lt;/code&gt; からそれ以上入力を取得できない場合、または物理ファイルの場合、現在のI / O位置がファイルの長さに等しい場合、 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; を返します。それ以外の場合は、 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="c2287783eee0e5de776e32c05f70808452f33fbd" translate="yes" xml:space="preserve">
          <source>For a readable handle &lt;code&gt;hdl&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if no further input can be taken from &lt;code&gt;hdl&lt;/code&gt; or for a physical file, if the current I/O position is equal to the length of the file. Otherwise, it returns &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">読み取り可能なハンドル &lt;code&gt;hdl&lt;/code&gt; の場合、 &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; は、 &lt;code&gt;hdl&lt;/code&gt; からそれ以上入力を取得できない場合、または物理ファイルの場合、現在のI / O位置がファイルの長さに等しい場合、 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; を返します。それ以外の場合は、 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="adff34a3466fde4a9da78cc13745c730ac48fbdb" translate="yes" xml:space="preserve">
          <source>For a strict version with the same interface, see &lt;a href=&quot;control-monad-trans-state-strict&quot;&gt;Control.Monad.Trans.State.Strict&lt;/a&gt;.</source>
          <target state="translated">同じインターフェースを持つ厳密なバージョンについては、&lt;a href=&quot;control-monad-trans-state-strict&quot;&gt;Control.Monad.Trans.State.Strictを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7841e1d83167e58d01ed6bbf031eb35a3b28a384" translate="yes" xml:space="preserve">
          <source>For a type synonym, every type variable and the result type must all be annotated with kinds:</source>
          <target state="translated">型の同義語には、すべての型変数と結果の型は、すべて種類でアノテーションされていなければなりません。</target>
        </trans-unit>
        <trans-unit id="8a7dabb4a59eac239d73f8d88adf219f4a141e0a" translate="yes" xml:space="preserve">
          <source>For a unidirectional record pattern synonym we define record selectors but do not allow record updates or construction.</source>
          <target state="translated">一方向レコードパターンの同義語については、レコードセレクタを定義しますが、レコードの更新や構築は許可しません。</target>
        </trans-unit>
        <trans-unit id="ea4172896e3aa016d0abf8c8c8b0c573b135be3c" translate="yes" xml:space="preserve">
          <source>For a variant allowing a range of exception values, see &lt;a href=&quot;control-monad-trans-except&quot;&gt;Control.Monad.Trans.Except&lt;/a&gt;.</source>
          <target state="translated">例外値の範囲を許可するバリアントについては、&lt;a href=&quot;control-monad-trans-except&quot;&gt;Control.Monad.Trans.Exceptを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="348fe1968c9295273d516331a948a6159bdca8cf" translate="yes" xml:space="preserve">
          <source>For a version that ignores the results, see &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">結果を無視するバージョンについては、 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="cd461bef656027f3a267dac7f770cf766ddc2c2e" translate="yes" xml:space="preserve">
          <source>For a walkthrough of the most commonly used functions see the &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/map.html&quot;&gt;maps introduction&lt;/a&gt;.</source>
          <target state="translated">最も一般的に使用される関数のウォークスルーについては、&lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/map.html&quot;&gt;マップの概要を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="93f1a6621ab377cb23e0289b270fa1e8b0fea36d" translate="yes" xml:space="preserve">
          <source>For a walkthrough of the most commonly used functions see the &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;sets introduction&lt;/a&gt;.</source>
          <target state="translated">最も一般的に使用される関数のウォークスルーについては、&lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;セットの&lt;/a&gt;概要を参照してください。</target>
        </trans-unit>
        <trans-unit id="d40c81c0c5fac25219b486dd4532b6661cea779f" translate="yes" xml:space="preserve">
          <source>For a walkthrough of the most commonly used functions see their &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;sets introduction&lt;/a&gt;.</source>
          <target state="translated">最も一般的に使用される関数のウォークスルーについては、それらの&lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;セットの紹介を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0b41a37cf99caafb018a9e5b3dc8989fdb6d5ec4" translate="yes" xml:space="preserve">
          <source>For all types (note these three are done by &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;, not by &lt;code&gt;&lt;a href=&quot;data-time-format-internal#v:formatCharacter&quot;&gt;formatCharacter&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">すべてのタイプ（これら3つは &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ではなくformatTimeによって実行されることに注意して &lt;code&gt;&lt;a href=&quot;data-time-format-internal#v:formatCharacter&quot;&gt;formatCharacter&lt;/a&gt;&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="5679f68c9f6e5d539aa213e495939714c629e80c" translate="yes" xml:space="preserve">
          <source>For almost all sensible programs this will indicate a bug, and you probably intended to write:</source>
          <target state="translated">ほとんどすべての良識的なプログラムでは、これはバグを示すものであり、あなたはおそらく書くつもりだったのでしょう。</target>
        </trans-unit>
        <trans-unit id="63a574ff5f92276a16df15dd4fc8478ad9638408" translate="yes" xml:space="preserve">
          <source>For an &amp;ldquo;unpackable&amp;rdquo; &lt;code&gt;U(...)&lt;/code&gt; argument, the info inside tells the strictness of its components. So, if the argument is a pair, and it says &lt;code&gt;U(AU(LSS))&lt;/code&gt;, that means &amp;ldquo;the first component of the pair isn&amp;rsquo;t used; the second component is itself unpackable, with three components (lazy in the first, strict in the second \&amp;amp; third).&amp;rdquo;</source>
          <target state="translated">「アンパック」について &lt;code&gt;U(...)&lt;/code&gt; 引数、情報の内部には、そのコンポーネントの厳しさを伝えます。したがって、引数がペアであり、 &lt;code&gt;U(AU(LSS))&lt;/code&gt; と表示されている場合と表示されている場合は、「ペアの最初のコンポーネントは使用されていません。 2番目のコンポーネント自体はアンパック可能で、3つのコンポーネントがあります（最初のコンポーネントでは遅延、2番目のコンポーネントでは厳密）。」</target>
        </trans-unit>
        <trans-unit id="d1cb9e82bcd8a245aaf6652f2e48d70c05a6dea5" translate="yes" xml:space="preserve">
          <source>For an &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; functor &lt;strong&gt;&lt;code&gt;f&lt;/code&gt;&lt;/strong&gt; and a Traversable functor &lt;strong&gt;&lt;code&gt;t&lt;/code&gt;&lt;/strong&gt;, the type signatures of &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; are rather similar:</source>
          <target state="translated">ため &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; ファンクタの&lt;strong&gt; &lt;code&gt;f&lt;/code&gt; &lt;/strong&gt;とTraversableのファンクタの&lt;strong&gt; &lt;code&gt;t&lt;/code&gt; &lt;/strong&gt;の型シグネチャ &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; かなり類似しています。</target>
        </trans-unit>
        <trans-unit id="61b4aadcc9e022579cc277ee1163fd8f6a08abf6" translate="yes" xml:space="preserve">
          <source>For an &lt;em&gt;efficient implementation of an encoding&lt;/em&gt;, it is important that (a) little time is spent on converting the Haskell values to the resulting sequence of bytes &lt;em&gt;and&lt;/em&gt; (b) that the representation of the resulting sequence is such that it can be consumed efficiently. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s support (a) by providing an O(1) concatentation operation and efficient implementations of basic encodings for &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s, and other standard Haskell values. They support (b) by providing their result as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, which is internally just a linked list of pointers to &lt;em&gt;chunks&lt;/em&gt; of consecutive raw memory. Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s can be efficiently consumed by functions that write them to a file or send them over a network socket. Note that each chunk boundary incurs expensive extra work (e.g., a system call) that must be amortized over the work spent on consuming the chunk body. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s therefore take special care to ensure that the average chunk size is large enough. The precise meaning of large enough is application dependent. The current implementation is tuned for an average chunk size between 4kb and 32kb, which should suit most applications.</source>
          <target state="translated">ための&lt;em&gt;符号化の効率的な実装&lt;/em&gt;は、（）少し時間が得られたバイトのシーケンスにHaskellの値を変換に費やされることが重要である&lt;em&gt;と&lt;/em&gt;得られた配列の表現は、それが効率的に消費することができるようなものであること（B）。 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; は、（a）O（1）連結演算と &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 、およびその他の標準Haskell値の基本エンコーディングの効率的な実装を提供することでサポートします。それらは（b）結果をレイジーな &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; として提供することでサポートします。これは内部的には連続したrawメモリの&lt;em&gt;チャンク&lt;/em&gt;へのポインタのリンクリストにすぎません。レイジー &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; sは、ファイルに書き込んだり、ネットワークソケットを介して送信したりする関数によって効率的に使用できます。各チャンクの境界は、チャンクボディの消費に費やされた作業に対して償却する必要がある高価な追加の作業（たとえば、システムコール）を発生させることに注意してください。したがって、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; は、平均チャンクサイズが十分に大きくなるように特別な注意を払っています。十分に大きいという正確な意味は、アプリケーションによって異なります。現在の実装は、4 kb〜32 kbの平均チャンクサイズに調整されており、ほとんどのアプリケーションに適しています。</target>
        </trans-unit>
        <trans-unit id="c98483df7da3278fbc5172993ad0a88f8fc1d389" translate="yes" xml:space="preserve">
          <source>For an &lt;em&gt;efficient implementation of an encoding&lt;/em&gt;, it is important that (a) little time is spent on converting the Haskell values to the resulting sequence of bytes &lt;em&gt;and&lt;/em&gt; (b) that the representation of the resulting sequence is such that it can be consumed efficiently. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s support (a) by providing an O(1) concatentation operation and efficient implementations of basic encodings for &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s, and other standard Haskell values. They support (b) by providing their result as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, which is internally just a linked list of pointers to &lt;em&gt;chunks&lt;/em&gt; of consecutive raw memory. Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s can be efficiently consumed by functions that write them to a file or send them over a network socket. Note that each chunk boundary incurs expensive extra work (e.g., a system call) that must be amortized over the work spent on consuming the chunk body. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s therefore take special care to ensure that the average chunk size is large enough. The precise meaning of large enough is application dependent. The current implementation is tuned for an average chunk size between 4kb and 32kb, which should suit most applications.</source>
          <target state="translated">ための&lt;em&gt;符号化の効率的な実装&lt;/em&gt;は、（）少し時間が得られたバイトのシーケンスにHaskellの値を変換に費やされることが重要である&lt;em&gt;と&lt;/em&gt;得られた配列の表現は、それが効率的に消費することができるようなものであること（B）。 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; は、O（1）連結操作と、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 、およびその他の標準Haskell値の基本エンコーディングの効率的な実装を提供することによって（a）をサポートします。それらは、結果を遅延 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; として提供することにより、（b）をサポートします。これは、内部的には、連続するrawメモリの&lt;em&gt;チャンク&lt;/em&gt;へのポインタのリンクリストです。怠惰な &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ■ファイルに書き込んだり、ネットワークソケットを介して送信したりする関数によって効率的に使用できます。各チャンク境界には、チャンク本体の消費に費やされた作業に対して償却する必要がある高価な追加作業（システムコールなど）が発生することに注意してください。したがって、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; は、平均チャンクサイズが十分に大きいことを確認するために特別な注意を払います。十分に大きいという正確な意味は、アプリケーションによって異なります。現在の実装は、4kbから32kbの平均チャンクサイズに調整されており、ほとんどのアプリケーションに適しています。</target>
        </trans-unit>
        <trans-unit id="3496a2b758ef763c20485808c9274b5b6efa235b" translate="yes" xml:space="preserve">
          <source>For an &lt;em&gt;efficient implementation of an encoding&lt;/em&gt;, it is important that (a) little time is spent on converting the Haskell values to the resulting sequence of bytes &lt;em&gt;and&lt;/em&gt; (b) that the representation of the resulting sequence is such that it can be consumed efficiently. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s support (a) by providing an O(1) concatentation operation and efficient implementations of basic encodings for &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s, and other standard Haskell values. They support (b) by providing their result as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, which is internally just a linked list of pointers to &lt;em&gt;chunks&lt;/em&gt; of consecutive raw memory. Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s can be efficiently consumed by functions that write them to a file or send them over a network socket. Note that each chunk boundary incurs expensive extra work (e.g., a system call) that must be amortized over the work spent on consuming the chunk body. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s therefore take special care to ensure that the average chunk size is large enough. The precise meaning of large enough is application dependent. The current implementation is tuned for an average chunk size between 4kb and 32kb, which should suit most applications.</source>
          <target state="translated">ための&lt;em&gt;符号化の効率的な実装&lt;/em&gt;は、（）少し時間が得られたバイトのシーケンスにHaskellの値を変換に費やされることが重要である&lt;em&gt;と&lt;/em&gt;得られた配列の表現は、それが効率的に消費することができるようなものであること（B）。 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; は、O（1）連結操作と、 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 、およびその他の標準Haskell値の基本的なエンコーディングの効率的な実装を提供することによって（a）をサポートします。それらは、結果を遅延 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; として提供することにより、（b）をサポートします。これは、内部的には、連続するrawメモリの&lt;em&gt;チャンク&lt;/em&gt;へのポインタのリンクリストにすぎません。怠惰な &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ■ファイルに書き込んだり、ネットワークソケットを介して送信したりする関数によって効率的に使用できます。各チャンク境界には、チャンク本体の消費に費やされた作業に対して償却する必要がある高価な追加作業（システムコールなど）が発生することに注意してください。したがって、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; は、平均チャンクサイズが十分に大きいことを確認するために特別な注意を払います。十分に大きいという正確な意味は、アプリケーションによって異なります。現在の実装は、4kbから32kbの平均チャンクサイズに調整されており、ほとんどのアプリケーションに適しています。</target>
        </trans-unit>
        <trans-unit id="85427d3349c7624ec90481011c2c435a5c350f38" translate="yes" xml:space="preserve">
          <source>For an enumeration, the nullary constructors are assumed to be numbered left-to-right with the indices being 0 to n-1 inclusive. This is the same numbering defined by the &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class. For example, given the datatype:</source>
          <target state="translated">列挙の場合、nullaryコンストラクターは左から右に番号が付けられ、0からn-1までのインデックスであると想定されます。これは、 &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; クラスで定義されているのと同じ番号付けです。たとえば、次のデータ型があるとします。</target>
        </trans-unit>
        <trans-unit id="2317d704439c0e816415f233729962e630340d1c" translate="yes" xml:space="preserve">
          <source>For an example demonstrating why this is unsafe, see &lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&quot;&gt;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&lt;/a&gt;</source>
          <target state="translated">これが安全でない理由を示す例については、&lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&quot;&gt;https：&lt;/a&gt; //mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.htmlを参照してください。</target>
        </trans-unit>
        <trans-unit id="b5f98c16b96cd9f3dba7b2312cfd924a11d7ac8d" translate="yes" xml:space="preserve">
          <source>For an example we have a program, called &lt;code&gt;Recip.hs&lt;/code&gt;, which computes exact decimal representations of reciprocals, with recurring parts indicated in brackets.</source>
          <target state="translated">例として、 &lt;code&gt;Recip.hs&lt;/code&gt; と呼ばれるプログラムがあり、逆数の正確な10進数表現を計算します。繰り返し部分は角括弧で示されています。</target>
        </trans-unit>
        <trans-unit id="6f3c284585c0a604bb804752c3dde88c28f43321" translate="yes" xml:space="preserve">
          <source>For an interactive application, it is probably a good idea to use the idle GC, because this will allow finalizers to run and deadlocked threads to be detected in the idle time when no Haskell computation is happening. Also, it will mean that a GC is less likely to happen when the application is busy, and so responsiveness may be improved. However, if the amount of live data in the heap is particularly large, then the idle GC can cause a significant delay, and too small an interval could adversely affect interactive responsiveness.</source>
          <target state="translated">インタラクティブなアプリケーションでは、アイドル GC を使用するのは良いアイデアかもしれません。また、アプリケーションがビジー状態のときにGCが発生する可能性が低くなるため、応答性が改善される可能性があるということになります。しかし、ヒープ内のライブデータの量が特に大きい場合、アイドルGCは大幅な遅延を引き起こす可能性があり、間隔が小さすぎるとインタラクティブな応答性に悪影響を及ぼす可能性があります。</target>
        </trans-unit>
        <trans-unit id="945a445d8ac893cd2e10d46914fbf37b660fe8b4" translate="yes" xml:space="preserve">
          <source>For any module that is imported, GHC requires that the name of the module in the import statement exactly matches the name of the module in the interface file (or source file) found using the strategy specified in &lt;a href=&quot;#search-path&quot;&gt;The search path&lt;/a&gt;. This means that for most modules, the source file name should match the module name.</source>
          <target state="translated">インポートされるすべてのモジュールについて、GHCはimportステートメント内のモジュールの名前が、&lt;a href=&quot;#search-path&quot;&gt;「検索パス」で&lt;/a&gt;指定された戦略を使用して見つかったインターフェースファイル（またはソースファイル）内のモジュールの名前と正確に一致する必要があります。つまり、ほとんどのモジュールでは、ソースファイル名がモジュール名と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="c4fde380f1c057e17c4834c04b581f9f36e12710" translate="yes" xml:space="preserve">
          <source>For any type that is an instance of class &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; as well as &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, the following should hold:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; と同様に &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; クラスのインスタンスであるすべての型について、以下が保持されます。</target>
        </trans-unit>
        <trans-unit id="2668d63ce3c1412ab95942782c64db8a803782a5" translate="yes" xml:space="preserve">
          <source>For any type that is an instance of class &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; as well as &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, the following should hold:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; と同様に &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; クラスのインスタンスであるすべての型について、以下が保持されます。</target>
        </trans-unit>
        <trans-unit id="f5b0590b7a86a642764875b6c543da9446390b3c" translate="yes" xml:space="preserve">
          <source>For applications with large numbers of string literals, &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; can be a bottleneck. In such cases, consider using &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackAddress&quot;&gt;unsafePackAddress&lt;/a&gt;&lt;/code&gt; (GHC only).</source>
          <target state="translated">多数の文字列リテラルを持つアプリケーションでは、 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; がボトルネックになる可能性があります。そのような場合は、 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackAddress&quot;&gt;unsafePackAddress&lt;/a&gt;&lt;/code&gt; （GHCのみ）の使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="157ede2fd9143a8b3502fbb97415660d94e7cb64" translate="yes" xml:space="preserve">
          <source>For applications with large numbers of string literals, pack can be a bottleneck.</source>
          <target state="translated">文字列リテラルが多いアプリケーションでは、packがボトルネックになることがあります。</target>
        </trans-unit>
        <trans-unit id="56b658eb8fe6b5f04e699bc25917bb161ec51372" translate="yes" xml:space="preserve">
          <source>For backward compatibility with existing make scripts, when used in combination with &lt;a href=&quot;#ghc-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt;, the linking phase is omitted (same as &lt;code&gt;--make -no-link&lt;/code&gt;).</source>
          <target state="translated">既存のmakeスクリプトとの下位互換性のために、&lt;a href=&quot;#ghc-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt;と組み合わせて使用​​すると、リンクフェーズが省略されます（ &lt;code&gt;--make -no-link&lt;/code&gt; と同じ）。</target>
        </trans-unit>
        <trans-unit id="a0f746a46394a3d26c67f678278e9c3f5556799d" translate="yes" xml:space="preserve">
          <source>For backward compatibility, kind variables &lt;em&gt;do not&lt;/em&gt; need to be bound explicitly, even if the type starts with &lt;code&gt;forall&lt;/code&gt;.</source>
          <target state="translated">下位互換性のために、型が &lt;code&gt;forall&lt;/code&gt; で始まる場合でも、kind変数を明示的にバインドする必要&lt;em&gt;は&lt;/em&gt;あり&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="1eb9aa8c4991a1b62e3c275f5d3018b0177bfba7" translate="yes" xml:space="preserve">
          <source>For backwards compatibility</source>
          <target state="translated">下位互換性のために</target>
        </trans-unit>
        <trans-unit id="27a3fb60d0c46913898e711aaa2f8bee288627da" translate="yes" xml:space="preserve">
          <source>For binary constructors</source>
          <target state="translated">バイナリ構成子の場合</target>
        </trans-unit>
        <trans-unit id="113ecb566c4518b38725ad5c1d8eb800bb73f6cc" translate="yes" xml:space="preserve">
          <source>For both &lt;a href=&quot;#pragma-INLINE&quot;&gt;&lt;code&gt;INLINE&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt;, the phase number says when inlining is allowed at all.</source>
          <target state="translated">&lt;a href=&quot;#pragma-INLINE&quot;&gt; &lt;code&gt;INLINE&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; の&lt;/a&gt;両方について、フェーズ番号は、いつインライン化が許可されるかを示します。</target>
        </trans-unit>
        <trans-unit id="62d66553e100d412ce77e1fe48bae79aaea2144a" translate="yes" xml:space="preserve">
          <source>For both pattern and expression wildcards, the &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo; expands to the missing &lt;em&gt;in-scope&lt;/em&gt; record fields. Specifically the expansion of &amp;ldquo;&lt;code&gt;C {..}&lt;/code&gt;&amp;rdquo; includes &lt;code&gt;f&lt;/code&gt; if and only if:</source>
          <target state="translated">パターンと式の両方のワイルドカードで、「 &lt;code&gt;..&lt;/code&gt; 」は、不足&lt;em&gt;しているスコープ内の&lt;/em&gt;レコードフィールドに展開されます。特に、「 &lt;code&gt;C {..}&lt;/code&gt; 」の展開には、 &lt;code&gt;f&lt;/code&gt; 場合に限りfが含まれます。</target>
        </trans-unit>
        <trans-unit id="c79b50d69800a59416d8d5cf9c81be241c6cfd46" translate="yes" xml:space="preserve">
          <source>For boxed values (that is, values that are represented by a pointer), a further distinction is made, between lifted types (that contain &amp;perp;), and unlifted ones (that don't).</source>
          <target state="translated">ボックス化された値（つまり、ポインターで表される値）の場合、リフトされたタイプ（&amp;perp;を含む）とリフトされていないタイプ（それを含まないタイプ）がさらに区別されます。</target>
        </trans-unit>
        <trans-unit id="5ac3a49892d34dca6a91a788fcd33beaec7c04fe" translate="yes" xml:space="preserve">
          <source>For capabilities which may contain variable-length padding, use &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput&quot;&gt;tiGetOutput&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">可変長のパディングを含む可能性のある機能については、代わりに &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput&quot;&gt;tiGetOutput&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="6a6e2851e87788aba1413fa210db4c6f6c972b19" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">純粋な（非 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ）式での例外のキャッチについては、関数 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="347db935aa14d91363ea82db49f93c38e6d9eb78" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">純粋な（非 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ）式で例外をキャッチする方法については、関数 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="a9a7a9bf985a5fc7968bcd7963a4107803bb41d4" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">純粋な（非 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ）式で例外をキャッチする方法については、関数 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="1b49217666ee344468a322492b5c79e209e32151" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">純粋な（非 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ）式での例外のキャッチについては、関数 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="ec5a20c491f4c7cf4edd8064f53d84a0223202bb" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">純粋な（非 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ）式での例外のキャッチについては、関数 &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="ad72b8f09f320f536c51fd5fb47c559cb7126920" translate="yes" xml:space="preserve">
          <source>For coercing between any two integer types, use &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt;, which is specialized for all the common cases so should be fast enough. Coercing word types (see &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;) to and from integer types preserves representation, not sign.</source>
          <target state="translated">2つの整数型間の強制型 &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt; 、fromIntegralを使用します。これは、すべての一般的なケースに特化しているため、十分に高速でなければなりません。整数型との間でワード型（&lt;a href=&quot;data-word&quot;&gt;Data.Wordを&lt;/a&gt;参照）を強制すると、符号ではなく表現が保持されます。</target>
        </trans-unit>
        <trans-unit id="6af5be5e40fc3970696dd7cb02cedeef47e8ddad" translate="yes" xml:space="preserve">
          <source>For coercing between any two integer types, use &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt;, which is specialized for all the common cases so should be fast enough. Coercing word types to and from integer types preserves representation, not sign.</source>
          <target state="translated">2つの整数型間の強制型 &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt; 、fromIntegralを使用します。これは、すべての一般的なケースに特化しているため、十分に高速でなければなりません。ワード型と整数型の間の強制変換では、符号ではなく表現が保持されます。</target>
        </trans-unit>
        <trans-unit id="d569e185ce7fabcffce84351a9be98fa6e429e2d" translate="yes" xml:space="preserve">
          <source>For configuration files. It uses the &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;/etc/xdg&lt;/code&gt;. On Windows, the default is &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; or &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (e.g. &lt;code&gt;C:/ProgramData&lt;/code&gt;).</source>
          <target state="translated">構成ファイル用。 &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt; 環境変数を使用します。Windows以外のシステムでは、デフォルトは &lt;code&gt;/etc/xdg&lt;/code&gt; です。Windowsでは、デフォルトは &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; または &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; です（例： &lt;code&gt;C:/ProgramData&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ecc757e7efb65d0598236167a0b25a6cc54dc8ed" translate="yes" xml:space="preserve">
          <source>For configuration files. It uses the &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;~/.config&lt;/code&gt;. On Windows, the default is &lt;code&gt;%APPDATA%&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt;). Can be considered as the user-specific equivalent of &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">構成ファイル用。 &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; 環境変数を使用します。Windows以外のシステムでは、デフォルトは &lt;code&gt;~/.config&lt;/code&gt; です。Windowsでは、デフォルトは &lt;code&gt;%APPDATA%&lt;/code&gt; です（例： &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt; ）。 &lt;code&gt;/etc&lt;/code&gt; のユーザー固有の同等物と見なすことができます。</target>
        </trans-unit>
        <trans-unit id="c8bbf2f4e0dcd53b9576e5192a8bbd3f2edac0bb" translate="yes" xml:space="preserve">
          <source>For data files (e.g. images). It uses the &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;/usr/local/share/&lt;/code&gt; and &lt;code&gt;/usr/share/&lt;/code&gt;. On Windows, the default is &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; or &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (e.g. &lt;code&gt;C:/ProgramData&lt;/code&gt;).</source>
          <target state="translated">データファイル（画像など）の場合。 &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; 環境変数を使用します。Windows以外のシステムでは、デフォルトは &lt;code&gt;/usr/local/share/&lt;/code&gt; および &lt;code&gt;/usr/share/&lt;/code&gt; です。Windowsでは、デフォルトは &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; または &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; です（例： &lt;code&gt;C:/ProgramData&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f2c0b2306c8d3878f085903482b9a90782cfe6b1" translate="yes" xml:space="preserve">
          <source>For data files (e.g. images). It uses the &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;~/.local/share&lt;/code&gt;. On Windows, the default is &lt;code&gt;%APPDATA%&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt;). Can be considered as the user-specific equivalent of &lt;code&gt;/usr/share&lt;/code&gt;.</source>
          <target state="translated">データファイル（画像など）の場合。 &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; 環境変数を使用します。Windows以外のシステムでは、デフォルトは &lt;code&gt;~/.local/share&lt;/code&gt; です。Windowsでは、デフォルトは &lt;code&gt;%APPDATA%&lt;/code&gt; です（例： &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt; ）。 &lt;code&gt;/usr/share&lt;/code&gt; のユーザー固有の同等物と見なすことができます。</target>
        </trans-unit>
        <trans-unit id="fae8b417bf3bf5318948c8b0b508758745adb6f5" translate="yes" xml:space="preserve">
          <source>For decoding and generating simple external binary formats (e.g. C structures), Binary may be used, but in general is not suitable for complex protocols. Instead use the &lt;code&gt;&lt;a href=&quot;data-binary#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; primitives directly.</source>
          <target state="translated">単純な外部バイナリ形式（C構造など）のデコードと生成には、Binaryを使用できますが、一般的には複雑なプロトコルには適していません。代わりに、 &lt;code&gt;&lt;a href=&quot;data-binary#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;data-binary#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; プリミティブを直接使用してください。</target>
        </trans-unit>
        <trans-unit id="af244705c99bde3579744323c9a3a740b23bae24" translate="yes" xml:space="preserve">
          <source>For details on Remote GHCi, see Note [Remote GHCi] in compiler&lt;em&gt;GHC&lt;/em&gt;Runtime/Interpreter.hs.</source>
          <target state="translated">リモートGHCiの詳細については、コンパイラ&lt;em&gt;GHC&lt;/em&gt; Runtime /Interpreter.hsの注[リモートGHCi]を参照してください。</target>
        </trans-unit>
        <trans-unit id="7e906ad780906310d51f386651923755220b051e" translate="yes" xml:space="preserve">
          <source>For details on Remote GHCi, see Note [Remote GHCi] in compiler&lt;em&gt;ghci&lt;/em&gt;GHCi.hs.</source>
          <target state="translated">リモートGHCiの詳細については、コンパイラ&lt;em&gt;ghci&lt;/em&gt; GHCi.hsの注[リモートGHCi]を参照してください。</target>
        </trans-unit>
        <trans-unit id="e1ce5f8e660c7a1a97eb8290bd06346fb0073e69" translate="yes" xml:space="preserve">
          <source>For each alternative of the sum type, a layout that consists of these fields is generated. For example, if an alternative has &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Float#&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; fields, the layout will have an 32bit word, 32bit float and pointer fields.</source>
          <target state="translated">合計タイプの代替案ごとに、これらのフィールドで構成されるレイアウトが生成されます。たとえば、代替に &lt;code&gt;Int&lt;/code&gt; 、 &lt;code&gt;Float#&lt;/code&gt; 、および &lt;code&gt;String&lt;/code&gt; フィールドがある場合、レイアウトには32ビットワード、32ビットfloatおよびポインタフィールドがあります。</target>
        </trans-unit>
        <trans-unit id="757a36cc9fb80bb745216ef2b4ffc5c6499465dc" translate="yes" xml:space="preserve">
          <source>For each garbage collection, we print:</source>
          <target state="translated">ゴミの回収ごとに印刷しています。</target>
        </trans-unit>
        <trans-unit id="482f5994f6e216e0ba86b514f2ee819b9680d690" translate="yes" xml:space="preserve">
          <source>For each import declaration &lt;code&gt;import X&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;, a line recording the dependence of &lt;code&gt;M&lt;/code&gt; on &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">各インポート宣言のための &lt;code&gt;import X&lt;/code&gt; において &lt;code&gt;M&lt;/code&gt; の依存記録線 &lt;code&gt;M&lt;/code&gt; に &lt;code&gt;X&lt;/code&gt; を：</target>
        </trans-unit>
        <trans-unit id="c02e72408897c523f9a6c45e14bb555eade7491d" translate="yes" xml:space="preserve">
          <source>For each import declaration &lt;code&gt;import {-# SOURCE #-} X&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;, a line recording the dependence of &lt;code&gt;M&lt;/code&gt; on &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">各インポート宣言のために &lt;code&gt;import {-# SOURCE #-} X&lt;/code&gt; において &lt;code&gt;M&lt;/code&gt; の依存記録線 &lt;code&gt;M&lt;/code&gt; に &lt;code&gt;X&lt;/code&gt; を：</target>
        </trans-unit>
        <trans-unit id="2200dfec6b12718042bc1df9e4ba8ac51a77f634" translate="yes" xml:space="preserve">
          <source>For each node in the tree, apply &lt;code&gt;f&lt;/code&gt; to the &lt;code&gt;rootLabel&lt;/code&gt; and the result of applying &lt;code&gt;f&lt;/code&gt; to each &lt;code&gt;subForest&lt;/code&gt;.</source>
          <target state="translated">ツリーのノードごとに、 &lt;code&gt;f&lt;/code&gt; を &lt;code&gt;rootLabel&lt;/code&gt; に適用し、 &lt;code&gt;f&lt;/code&gt; を各 &lt;code&gt;subForest&lt;/code&gt; に適用した結果を適用します。</target>
        </trans-unit>
        <trans-unit id="3057e0dd6d54e41f208fa76fa96588cff9717be1" translate="yes" xml:space="preserve">
          <source>For empty datatypes, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; is used as a representation. For example,</source>
          <target state="translated">空のデータ型の場合、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; が表現として使用されます。例えば、</target>
        </trans-unit>
        <trans-unit id="367e92ce36a947e0da868cc6cdcfc2f796641103" translate="yes" xml:space="preserve">
          <source>For even more detail on this topic, see &lt;a href=&quot;http://www.cons.org/cracauer/sigint.html&quot;&gt;&quot;Proper handling of SIGINT/SIGQUIT&quot;&lt;/a&gt;.</source>
          <target state="translated">このトピックの詳細については、&lt;a href=&quot;http://www.cons.org/cracauer/sigint.html&quot;&gt;「SIGINT / SIGQUITの適切な処理」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="bdb8867f7ccd15d71a69ed939e98d09ad4ef1b15" translate="yes" xml:space="preserve">
          <source>For every module &lt;code&gt;A.hs&lt;/code&gt; that is &lt;code&gt;{-# SOURCE #-}&lt;/code&gt;-imported in this way there must exist a source file &lt;code&gt;A.hs-boot&lt;/code&gt;. This file contains an abbreviated version of &lt;code&gt;A.hs&lt;/code&gt;, thus:</source>
          <target state="translated">すべてのモジュールのため &lt;code&gt;A.hs&lt;/code&gt; ある &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; このように-importedソースファイルが存在しなければならない &lt;code&gt;A.hs-boot&lt;/code&gt; 。このファイルには &lt;code&gt;A.hs&lt;/code&gt; の省略バージョンが含まれているため、次のようになります。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="b0f621e891e9171328261480a78acacdfb576180" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;-l-ag&lt;/code&gt; would disable all event classes (&lt;code&gt;-a&lt;/code&gt;) except for GC events (&lt;code&gt;g&lt;/code&gt;).</source>
          <target state="translated">たとえば、 &lt;code&gt;-l-ag&lt;/code&gt; は、GCイベント（ &lt;code&gt;g&lt;/code&gt; ）を除くすべてのイベントクラス（ &lt;code&gt;-a&lt;/code&gt; ）を無効にします。</target>
        </trans-unit>
        <trans-unit id="e539a440aea70f6c1e340e284061ee3f7564fb32" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">たとえば、 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; を2つのリストに適用して、対応する合計のリストを作成します。</target>
        </trans-unit>
        <trans-unit id="0faa4a03eb1b621e96ddafa75b4d631885ce8235" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">たとえば、 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; を2つのリストに適用して、対応する合計のリストを作成します。</target>
        </trans-unit>
        <trans-unit id="54977218cb67963281b7e0eb298f559214d3d420" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">たとえば、 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; を2つのリストに適用して、対応する合計のリストを作成します。</target>
        </trans-unit>
        <trans-unit id="a8c5988831e8e7e699f73f0c98007bcd1ce68a11" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">たとえば、 &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; を2つのリストに適用して、対応する合計のリストを作成します。</target>
        </trans-unit>
        <trans-unit id="a52ed97184e92138a6e73030c8150e134f0bb680" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;Fixed 1000&lt;/code&gt; will give you a &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; with a resolution of 1000.</source>
          <target state="translated">たとえば、 &lt;code&gt;Fixed 1000&lt;/code&gt; は、解像度が1000の &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; を提供します。</target>
        </trans-unit>
        <trans-unit id="7adc62b058c0496c81ae2687046d64f2c845f5f6" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;IO&lt;/code&gt; or &lt;code&gt;Either&lt;/code&gt; would be invalid base monads, but &lt;code&gt;Reader&lt;/code&gt; or &lt;code&gt;State&lt;/code&gt; would be acceptable.</source>
          <target state="translated">たとえば、 &lt;code&gt;IO&lt;/code&gt; または &lt;code&gt;Either&lt;/code&gt; は無効なベースモナドですが、 &lt;code&gt;Reader&lt;/code&gt; または &lt;code&gt;State&lt;/code&gt; は許容されます。</target>
        </trans-unit>
        <trans-unit id="9a47ad65e0c2a3d400457a0b11356459b95bcb1d" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;byteStringThreshold 1024&lt;/code&gt; copies strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s whose size is less or equal to 1kb, and inserts them directly otherwise. This implies that the average chunk-size of the generated lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; may be as low as 513 bytes, as there could always be just a single byte between the directly inserted 1025 byte, strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">たとえば、 &lt;code&gt;byteStringThreshold 1024&lt;/code&gt; は、サイズが1kb以下の厳格な &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; をコピーし、それ以外の場合は直接挿入します。これは、直接挿入された1025バイトの厳密な &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; の間に常に1バイト &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ない可能性があるため、生成された遅延ByteStringの平均チャンクサイズは513バイトと低くなる可能性があることを意味します。</target>
        </trans-unit>
        <trans-unit id="6fde4b70734a8fac9093ea2a07235b341112181d" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;f \a -&amp;gt; a b&lt;/code&gt; will be parsed as &lt;code&gt;f (\a -&amp;gt; a b)&lt;/code&gt;, not as &lt;code&gt;f
(\a -&amp;gt; a) b&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;f \a -&amp;gt; a b&lt;/code&gt; は &lt;code&gt;f (\a -&amp;gt; a b)&lt;/code&gt; &lt;code&gt;f (\a -&amp;gt; a) b&lt;/code&gt; ではなくf（\ a-&amp;gt; ab）として解析されます。</target>
        </trans-unit>
        <trans-unit id="d68c2abf3bd572e6b394677caea8c74a91c6ffaa" translate="yes" xml:space="preserve">
          <source>For example, UTF-8 is an encoding of Unicode characters into a sequence of bytes. The &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; for UTF-8 is &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">たとえば、UTF-8はUnicode文字を一連のバイトにエンコードしたものです。UTF-8 の &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a131281d0c878473b424da7f5958a8ee1d5ccf4b" translate="yes" xml:space="preserve">
          <source>For example, UTF-8 is an encoding of Unicode characters into a sequence of bytes. The &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; for UTF-8 is &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">たとえば、UTF-8はUnicode文字を一連のバイトにエンコードしたものです。UTF-8 の &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="025997d25e9ad541ddb4bccc051a89bbfefa2c23" translate="yes" xml:space="preserve">
          <source>For example, a program might have several distinct phases with different performance or resource behaviour in each phase. To properly interpret the profile graph we really want to see when each phase starts and ends.</source>
          <target state="translated">例えば、プログラムにはいくつかの異なるフェーズがあり、それぞれのフェーズで異なるパフォーマンスやリソースの振る舞いをしているかもしれません。プロファイル・グラフを適切に解釈するためには、各フェーズがいつ開始し、いつ終了するのかを知りたいものです。</target>
        </trans-unit>
        <trans-unit id="2d40901ab3bf757ac476fdd101797decf03e3512" translate="yes" xml:space="preserve">
          <source>For example, a program to print the first 20 integers and their powers of 2 could be written as:</source>
          <target state="translated">例えば、最初の20個の整数とその2の累乗を表示するプログラムは、次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="a9ef3024ea8891eb534acb48c1b294262c997e19" translate="yes" xml:space="preserve">
          <source>For example, a user-defined datatype of trees</source>
          <target state="translated">例えば、ユーザ定義の木のデータ型</target>
        </trans-unit>
        <trans-unit id="744409e78bf68170b982ca29c657867bee8ffa37" translate="yes" xml:space="preserve">
          <source>For example, compiling the following module with GHC:</source>
          <target state="translated">例えば、以下のようなモジュールをGHCでコンパイルします。</target>
        </trans-unit>
        <trans-unit id="e6d6e2ba2b5ca72099050bc51954934eb60bffb4" translate="yes" xml:space="preserve">
          <source>For example, consider</source>
          <target state="translated">例えば、次のようなことを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="7bb345fb3af895621bd1d63c6e6ef0f332232c9b" translate="yes" xml:space="preserve">
          <source>For example, consider a program &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">たとえば、プログラム &lt;code&gt;foo&lt;/code&gt; を考えます。</target>
        </trans-unit>
        <trans-unit id="c25100ceaa78174d12c46a1aeb9aca894d0c3090" translate="yes" xml:space="preserve">
          <source>For example, consider a type class that is not intended to be used with functions, but the user accidentally used it at a function type, perhaps because they missed an argument to some function. Then, instead of getting the standard GHC message about a missing instance, it would be nicer to emit a more friendly message specific to the EDSL. Similarly, the reduction of a type-level function may get stuck due to an error, at which point it would be nice to report an EDSL specific error, rather than a generic error about an ambiguous type.</source>
          <target state="translated">例えば、関数での使用を意図していない型クラスを考えてみましょう。しかし、ユーザが関数型で誤って使用してしまったとします。その場合、欠落したインスタンスについての標準的なGHCメッセージを取得する代わりに、EDSLに特有のより親切なメッセージを出す方が良いでしょう。同様に、型レベルの関数のリダクションがエラーのためにスタックすることがありますが、その場合、曖昧な型に関する一般的なエラーではなく、EDSL固有のエラーを報告するのが良いでしょう。</target>
        </trans-unit>
        <trans-unit id="d37882239b62f8f60c67248b5ef090444ecd46a4" translate="yes" xml:space="preserve">
          <source>For example, consider if you had a macro named &lt;code&gt;:time&lt;/code&gt; and in the shell, typed &lt;code&gt;:t 3&lt;/code&gt; &amp;mdash; what should happen? The current algorithm we use for completing commands is:</source>
          <target state="translated">たとえば、 &lt;code&gt;:time&lt;/code&gt; という名前のマクロがあり、シェルに &lt;code&gt;:t 3&lt;/code&gt; と入力した場合を考えてみます。どうなるでしょうか。コマンドを完了するために使用する現在のアルゴリズムは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="65686db81caecd61279e7eeb51586e09d8ed9938" translate="yes" xml:space="preserve">
          <source>For example, consider the following parallel version of our old nemesis, &lt;code&gt;nfib&lt;/code&gt;:</source>
          <target state="translated">たとえば、古い宿敵 &lt;code&gt;nfib&lt;/code&gt; の次の並列バージョンを考えてみます。</target>
        </trans-unit>
        <trans-unit id="93bbe6300a112cc074a95237a2b5bafd43171b4b" translate="yes" xml:space="preserve">
          <source>For example, consider these definitions (with &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">たとえば、次の定義について考えます（&lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; を使用&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1e3fcef7520fd5f38bbab6908aface3e182c9e1f" translate="yes" xml:space="preserve">
          <source>For example, consider these definitions (with &lt;a href=&quot;scoped_type_variables#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">たとえば、次の定義を検討してください（&lt;a href=&quot;scoped_type_variables#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; を使用&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d42fd5e5b201e8c6886f2c95796540ee28c71bc6" translate="yes" xml:space="preserve">
          <source>For example, given a data type</source>
          <target state="translated">例えば、データ型が</target>
        </trans-unit>
        <trans-unit id="4bdc75c67cb68db483ee29ec3c932f3c07d61e7e" translate="yes" xml:space="preserve">
          <source>For example, given a list of values of some index type, &lt;code&gt;hist&lt;/code&gt; produces a histogram of the number of occurrences of each index within a specified range:</source>
          <target state="translated">たとえば、あるインデックスタイプの値のリストを指定すると、 &lt;code&gt;hist&lt;/code&gt; は指定された範囲内の各インデックスの発生数のヒストグラムを生成します。</target>
        </trans-unit>
        <trans-unit id="c355f67c4b8d78811097c4401689f016752e1ba0" translate="yes" xml:space="preserve">
          <source>For example, given a list of values of some index type, hist produces a histogram of the number of occurrences of each index within a specified range:</source>
          <target state="translated">例えば、あるインデックス型の値のリストが与えられると、histは、指定された範囲内での各インデックスの出現回数のヒストグラムを生成します。</target>
        </trans-unit>
        <trans-unit id="1eab4f69e1d74fb57993a017da4c8e140181fdb5" translate="yes" xml:space="preserve">
          <source>For example, given the declarations</source>
          <target state="translated">例えば、次のような宣言があるとします。</target>
        </trans-unit>
        <trans-unit id="092e743ba03cbd9f10aa95f011412e94dc868f41" translate="yes" xml:space="preserve">
          <source>For example, here is a heap profile produced for the &lt;code&gt;sphere&lt;/code&gt; program from GHC&amp;rsquo;s &lt;code&gt;nofib&lt;/code&gt; benchmark suite,</source>
          <target state="translated">たとえば、これはGHCの &lt;code&gt;nofib&lt;/code&gt; ベンチマークスイートから &lt;code&gt;sphere&lt;/code&gt; プログラム用に作成されたヒーププロファイルです。</target>
        </trans-unit>
        <trans-unit id="7a34f8af22ee4347fe8ec5e1224bf70e5de3ef73" translate="yes" xml:space="preserve">
          <source>For example, here is how we might implement an &lt;a href=&quot;https://en.wikipedia.org/wiki/Echo_Protocol&quot;&gt;echo server&lt;/a&gt;, using &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt;&lt;/code&gt; both to listen for client connections on a network socket and to echo client input on client connection handles:</source>
          <target state="translated">たとえば、&lt;a href=&quot;https://en.wikipedia.org/wiki/Echo_Protocol&quot;&gt;エコーサーバーを&lt;/a&gt;実装する方法を次に示します。ネットワークソケットでのクライアント接続のリッスンとクライアント接続ハンドルでのクライアント入力のエコーの両方に &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="ee6da42913659645d60841805c91275892b69538" translate="yes" xml:space="preserve">
          <source>For example, if GHC compiles the module &lt;code&gt;A.B.C&lt;/code&gt; in the file &lt;code&gt;src/A/B/C.hs&lt;/code&gt;, with no &lt;code&gt;-odir&lt;/code&gt; or &lt;code&gt;-hidir&lt;/code&gt; flags, the interface file will be put in &lt;code&gt;src/A/B/C.hi&lt;/code&gt; and the object file in &lt;code&gt;src/A/B/C.o&lt;/code&gt;.</source>
          <target state="translated">たとえば、GHCがモジュール &lt;code&gt;A.B.C&lt;/code&gt; をファイル &lt;code&gt;src/A/B/C.hs&lt;/code&gt; でコンパイルし、 &lt;code&gt;-odir&lt;/code&gt; または &lt;code&gt;-hidir&lt;/code&gt; フラグを指定しない場合、インターフェースファイルは &lt;code&gt;src/A/B/C.hi&lt;/code&gt; に配置され、オブジェクトは &lt;code&gt;src/A/B/C.o&lt;/code&gt; 内のファイル。</target>
        </trans-unit>
        <trans-unit id="b4fd5a35e83d4d92107628f0b0a526842c88f6f3" translate="yes" xml:space="preserve">
          <source>For example, if an interface is lying about the type of an imported value then GHC may well generate duff code for the importing module. &lt;em&gt;This applies to pragmas inside interfaces too!&lt;/em&gt; If the pragma is lying (e.g., about the &amp;ldquo;arity&amp;rdquo; of a value), then duff code may result. Furthermore, arities may change even if types do not.</source>
          <target state="translated">たとえば、インターフェースがインポートされた値のタイプについて嘘をついている場合、GHCはインポートするモジュールのダフコードを生成するでしょう。&lt;em&gt;これは、インターフェース内部のプラグマにも適用されます。&lt;/em&gt;プラグマが嘘をついている場合（たとえば、値の「アリティ」について）、ダフコードが発生する可能性があります。さらに、タイプが変わらなくても、アリティは変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="01897242c453eafb4b01262fb63540cca636483f" translate="yes" xml:space="preserve">
          <source>For example, if the following datatype is in scope</source>
          <target state="translated">例えば、以下のデータ型がスコープ内にある場合</target>
        </trans-unit>
        <trans-unit id="feecbb8b0e63385c2814e7a6c80293daa6efef5d" translate="yes" xml:space="preserve">
          <source>For example, if we specify a Haskell library as &lt;code&gt;HSfoo&lt;/code&gt; in the package spec, then the various flavours of library that GHC actually uses will be called:</source>
          <target state="translated">たとえば、パッケージ仕様でHaskellライブラリを &lt;code&gt;HSfoo&lt;/code&gt; として指定すると、GHCが実際に使用するさまざまな種類のライブラリが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="5aac58398382b1dc4e6fa1f8a176b54c3c8f6891" translate="yes" xml:space="preserve">
          <source>For example, if you are inspecting the core of your program and you observe that &lt;code&gt;foo&lt;/code&gt; is not being inlined. You can pass &lt;code&gt;-dinline-check foo&lt;/code&gt; and you will see a report about why &lt;code&gt;foo&lt;/code&gt; is not inlined.</source>
          <target state="translated">たとえば、プログラムのコアを検査しているときに、 &lt;code&gt;foo&lt;/code&gt; がインライン化されていないことがわかります。 &lt;code&gt;-dinline-check foo&lt;/code&gt; を渡すと、 &lt;code&gt;foo&lt;/code&gt; がインライン化されない理由に関するレポートが表示されます。</target>
        </trans-unit>
        <trans-unit id="b110bc690a93e5b10bf8e0914df1a07ee1433b91" translate="yes" xml:space="preserve">
          <source>For example, in an 80-column terminal with this behavior, the following will print single-spaced instead of double-spaced:</source>
          <target state="translated">例えば、この動作を持つ80列のターミナルでは、次のようにすると、ダブルスペースではなくシングルスペースで印刷されます。</target>
        </trans-unit>
        <trans-unit id="6ed162bad590f5003d7d426fd5ae42fa4f804a10" translate="yes" xml:space="preserve">
          <source>For example, in the following program, &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;f'&lt;/code&gt; are equivalent:</source>
          <target state="translated">たとえば、次のプログラムでは、 &lt;code&gt;f&lt;/code&gt; と &lt;code&gt;f'&lt;/code&gt; は同等です。</target>
        </trans-unit>
        <trans-unit id="f4f0daf85ba8e99d49b00ae49cc0b4883f326a6b" translate="yes" xml:space="preserve">
          <source>For example, item can be written as:</source>
          <target state="translated">例えば、itemは次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="23d438828de5a37dbac482cecf3993a3fb389e7b" translate="yes" xml:space="preserve">
          <source>For example, multiple calls to &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; using the same &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt; will share the same input history. In constrast, multiple calls to &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputT&quot;&gt;runInputT&lt;/a&gt;&lt;/code&gt; will use distinct histories unless they share the same history file.</source>
          <target state="translated">たとえば、同じ &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt; を使用して &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; を複数回呼び出すと、同じ入力履歴が共有されます。constrastでは、複数の呼び出しに &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputT&quot;&gt;runInputT&lt;/a&gt;&lt;/code&gt; は、彼らが同じ履歴ファイルを共有しない限り、個別の履歴を使用します。</target>
        </trans-unit>
        <trans-unit id="cccb8365a356d9204a1e3e6be4d959bd5de7a6a9" translate="yes" xml:space="preserve">
          <source>For example, one possible application is to reify dictionaries:</source>
          <target state="translated">例えば、一つの可能性のある応用として、辞書を再統合することが挙げられます。</target>
        </trans-unit>
        <trans-unit id="f442cf832dad88fc0e7646f66ee10e0363b7080d" translate="yes" xml:space="preserve">
          <source>For example, remembering that &lt;code&gt;putStrLn :: String -&amp;gt; IO ()&lt;/code&gt;:</source>
          <target state="translated">たとえば、 &lt;code&gt;putStrLn :: String -&amp;gt; IO ()&lt;/code&gt; 覚えています。</target>
        </trans-unit>
        <trans-unit id="d9a2c926ccbb0f9d553917af57bd1f41d6413ed1" translate="yes" xml:space="preserve">
          <source>For example, sometimes you might want to use the following to get the effect of a &amp;ldquo;class synonym&amp;rdquo;:</source>
          <target state="translated">たとえば、「クラスシノニム」の効果を得るために、以下を使用したい場合があります。</target>
        </trans-unit>
        <trans-unit id="e5b7402fa6acb4a815984441e87927a1f6479149" translate="yes" xml:space="preserve">
          <source>For example, suppose the search path contains directories &lt;code&gt;d1&lt;/code&gt;, &lt;code&gt;d2&lt;/code&gt;, and &lt;code&gt;d3&lt;/code&gt;, and we are in &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode looking for the source file for a module &lt;code&gt;A.B.C&lt;/code&gt;. GHC will look in &lt;code&gt;d1/A/B/C.hs&lt;/code&gt;, &lt;code&gt;d1/A/B/C.lhs&lt;/code&gt;, &lt;code&gt;d2/A/B/C.hs&lt;/code&gt;, and so on.</source>
          <target state="translated">たとえば、検索パスはディレクトリ含まれているとし &lt;code&gt;d1&lt;/code&gt; 、 &lt;code&gt;d2&lt;/code&gt; 、および &lt;code&gt;d3&lt;/code&gt; 、私たちはしている&lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;モジュールのソースファイルを探しモード &lt;code&gt;A.B.C&lt;/code&gt; 。GHCは &lt;code&gt;d1/A/B/C.hs&lt;/code&gt; 、 &lt;code&gt;d1/A/B/C.lhs&lt;/code&gt; 、 &lt;code&gt;d2/A/B/C.hs&lt;/code&gt; などを調べます。</target>
        </trans-unit>
        <trans-unit id="bdd681ea0a0383fa82b3cb4fd238264b1f0a0e95" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a string that you want to split on the substring &lt;code&gt;&quot;::&quot;&lt;/code&gt;, such as &lt;code&gt;&quot;foo::bar::quux&quot;&lt;/code&gt;. Instead of searching for the index of &lt;code&gt;&quot;::&quot;&lt;/code&gt; and taking the substrings before and after that index, you would instead use &lt;code&gt;breakOnAll &quot;::&quot;&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;&quot;foo::bar::quux&quot;&lt;/code&gt; ように、部分文字列 &lt;code&gt;&quot;::&quot;&lt;/code&gt; で分割する文字列があるとします。 &lt;code&gt;&quot;::&quot;&lt;/code&gt; のインデックスを検索してそのインデックスの前後の部分文字列を取得する代わりに、代わりに &lt;code&gt;breakOnAll &quot;::&quot;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="ac114f663d8e987abd5e387676a684751e04a820" translate="yes" xml:space="preserve">
          <source>For example, suppose you want to read a file, but if it doesn't exist then continue as if it contained &quot;&quot;. You might be tempted to just catch all exceptions and return &quot;&quot; in the handler. However, this has all sorts of undesirable consequences. For example, if the user presses control-C at just the right moment then the &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; exception will be caught, and the program will continue running under the belief that the file contains &quot;&quot;. Similarly, if another thread tries to kill the thread reading the file then the &lt;code&gt;&lt;a href=&quot;control-exception#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; exception will be ignored.</source>
          <target state="translated">たとえば、ファイルを読み取りたいが、そのファイルが存在しない場合は、 &quot;&quot;が含まれているかのように続行するとします。すべての例外をキャッチしてハンドラーで &quot;&quot;を返すようにしたくなるかもしれません。ただし、これにはあらゆる種類の望ましくない結果があります。たとえば、ユーザーが適切な瞬間にcontrol-Cを押すと、 &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; 例外がキャッチされ、ファイルに &quot;&quot;が含まれているという信念の下でプログラムが実行を継続します。同様に、別のスレッドがファイルを読み取るスレッドを &lt;code&gt;&lt;a href=&quot;control-exception#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; しようとした場合、ThreadKilled例外は無視されます。</target>
        </trans-unit>
        <trans-unit id="2b47a77367f051fe58214e2454bd4b98b948cadb" translate="yes" xml:space="preserve">
          <source>For example, the constructor fields in the following data types</source>
          <target state="translated">例えば、以下のデータ型のコンストラクタフィールドは</target>
        </trans-unit>
        <trans-unit id="7651edd96e5c58d56d08d8f8dadcaee786526668" translate="yes" xml:space="preserve">
          <source>For example, the data types &lt;code&gt;2 * A&lt;/code&gt; and &lt;code&gt;A + A&lt;/code&gt; are isomorphic but some computations are more naturally expressed in terms of one or the other. To get the best of both worlds, we can choose one as our implementation and then provide a set of pattern synonyms so that users can use the other representation if they desire. We can then specify a &lt;code&gt;COMPLETE&lt;/code&gt; pragma in order to inform the pattern match checker that a function which matches on both &lt;code&gt;LeftChoice&lt;/code&gt; and &lt;code&gt;RightChoice&lt;/code&gt; is total.</source>
          <target state="translated">たとえば、データ型 &lt;code&gt;2 * A&lt;/code&gt; と &lt;code&gt;A + A&lt;/code&gt; は同型ですが、一部の計算はどちらか一方としてより自然に表現されます。両方の世界を最大限に活用するために、実装として1つを選択し、パターン同義語のセットを提供して、ユーザーが必要に応じて他の表現を使用できるようにすることができます。次に、 &lt;code&gt;LeftChoice&lt;/code&gt; と &lt;code&gt;RightChoice&lt;/code&gt; の両方で一致する関数が合計であることをパターンマッチチェッカーに通知するために、 &lt;code&gt;COMPLETE&lt;/code&gt; プラグマを指定できます。</target>
        </trans-unit>
        <trans-unit id="ee57ef376af738c0cc39be9b8a3aeffd655a9804" translate="yes" xml:space="preserve">
          <source>For example, the following code is accepted by GHC:</source>
          <target state="translated">例えば、GHCでは以下のようなコードを受け付けています。</target>
        </trans-unit>
        <trans-unit id="ed55721fe5eca931044c06dd74e928c1a9366863" translate="yes" xml:space="preserve">
          <source>For example, the following options will generate a retainer profile restricted to &lt;code&gt;Branch&lt;/code&gt; and &lt;code&gt;Leaf&lt;/code&gt; constructors:</source>
          <target state="translated">たとえば、次のオプションは、 &lt;code&gt;Branch&lt;/code&gt; および &lt;code&gt;Leaf&lt;/code&gt; コンストラクターに制限された保持プロファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="e24297250355b4a78eb62d1dc56e97787e232bfc" translate="yes" xml:space="preserve">
          <source>For example, these are okay:</source>
          <target state="translated">例えば、これらは大丈夫です。</target>
        </trans-unit>
        <trans-unit id="15e69e99eeb37907f6273e21ee4ff58bdd61a0ee" translate="yes" xml:space="preserve">
          <source>For example, this code will require a &lt;code&gt;Monad&lt;/code&gt; constraint:</source>
          <target state="translated">たとえば、次のコードには &lt;code&gt;Monad&lt;/code&gt; 制約が必要です。</target>
        </trans-unit>
        <trans-unit id="900e1e6015412435fcee921be92977f023f6a57e" translate="yes" xml:space="preserve">
          <source>For example, this instance would make the &lt;code&gt;name&lt;/code&gt; field of &lt;code&gt;Person&lt;/code&gt; accessible using &lt;code&gt;#fullname&lt;/code&gt; as well:</source>
          <target state="translated">たとえば、このインスタンスは、 &lt;code&gt;#fullname&lt;/code&gt; を使用して &lt;code&gt;Person&lt;/code&gt; の &lt;code&gt;name&lt;/code&gt; フィールドにもアクセスできるようにします。</target>
        </trans-unit>
        <trans-unit id="47bbb9c1056126a12b9da3b641c5bfc651a0ba80" translate="yes" xml:space="preserve">
          <source>For example, this returns the value of &lt;code&gt;f x&lt;/code&gt; but first outputs the message.</source>
          <target state="translated">たとえば、これは &lt;code&gt;f x&lt;/code&gt; の値を返しますが、最初にメッセージを出力します。</target>
        </trans-unit>
        <trans-unit id="225929f65a69a76a61aa35be9e43fc3fd618afeb" translate="yes" xml:space="preserve">
          <source>For example, this:</source>
          <target state="translated">例えば、これ。</target>
        </trans-unit>
        <trans-unit id="9016b1102f311501fac46c1e7eecc35288f12dcc" translate="yes" xml:space="preserve">
          <source>For example, to enable the FFI and preprocessing with CPP:</source>
          <target state="translated">例えば、CPPでFFIと前処理を有効にする。</target>
        </trans-unit>
        <trans-unit id="26497d08a388e4d2412b7f1fab7c57d63571afa3" translate="yes" xml:space="preserve">
          <source>For example, to execute a simple &lt;code&gt;ls&lt;/code&gt; command:</source>
          <target state="translated">たとえば、簡単な &lt;code&gt;ls&lt;/code&gt; コマンドを実行するには：</target>
        </trans-unit>
        <trans-unit id="a3311a9da6750dc8b9fba90d3be35024a5d05bc0" translate="yes" xml:space="preserve">
          <source>For example, to link a program consisting of objects &lt;code&gt;Foo.o&lt;/code&gt; and &lt;code&gt;Main.o&lt;/code&gt;, where we made use of the &lt;code&gt;network&lt;/code&gt; package, we need to give GHC the &lt;code&gt;-package&lt;/code&gt; flag thus:</source>
          <target state="translated">たとえば、 &lt;code&gt;network&lt;/code&gt; パッケージを使用したオブジェクト &lt;code&gt;Foo.o&lt;/code&gt; と &lt;code&gt;Main.o&lt;/code&gt; で構成されるプログラムをリンクするには、GHCに &lt;code&gt;-package&lt;/code&gt; フラグを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="275c801d323aafd23c71b3f1fd4a2ba975854334" translate="yes" xml:space="preserve">
          <source>For example, to load and run a Haskell program containing a module &lt;code&gt;Main&lt;/code&gt;, we might say:</source>
          <target state="translated">たとえば、モジュール &lt;code&gt;Main&lt;/code&gt; を含むHaskellプログラムをロードして実行するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="24c8dec48e12a5f61c3e7a6ffbc6374c90c7019e" translate="yes" xml:space="preserve">
          <source>For example, to parse a date in YYYY-MM-DD format, while allowing the month and date to have optional leading zeros (notice the &lt;code&gt;-&lt;/code&gt; modifier used for &lt;code&gt;%m&lt;/code&gt; and &lt;code&gt;%d&lt;/code&gt;):</source>
          <target state="translated">たとえば、日付をYYYY-MM-DD形式で解析し、月と日付にオプションの先行ゼロを付けることができます（ &lt;code&gt;%m&lt;/code&gt; と &lt;code&gt;%d&lt;/code&gt; に &lt;code&gt;-&lt;/code&gt; 修飾子が使用されていることに注意してください）。</target>
        </trans-unit>
        <trans-unit id="76f9ac11e3675b26b9adf85da24c93afef2ec32c" translate="yes" xml:space="preserve">
          <source>For example, to start a process and feed a string to its stdin:</source>
          <target state="translated">例えば、プロセスを開始し、その標準入力に文字列を送ります。</target>
        </trans-unit>
        <trans-unit id="5fcd1945807a0dc794011bc0d68f612088c3c98d" translate="yes" xml:space="preserve">
          <source>For example, to tokenise a string, dropping delimiters:</source>
          <target state="translated">例えば、文字列をトークン化するには、デリミタを削除します。</target>
        </trans-unit>
        <trans-unit id="e8a9d355c1624f157a17b017f14330568fefc5e8" translate="yes" xml:space="preserve">
          <source>For example, we can write the factorial function using direct recursion as</source>
          <target state="translated">例えば、直接再帰を用いた階乗関数は次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="c57a91fc90c21d96ad621001af54d878ab863159" translate="yes" xml:space="preserve">
          <source>For example, when &lt;code&gt;f&lt;/code&gt; is &lt;code&gt;(:)&lt;/code&gt;, all three cases return an immediate value, respectively &lt;code&gt;z&lt;/code&gt; or a &lt;em&gt;cons cell&lt;/em&gt; holding &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;l&lt;/code&gt;, with the remainder the structure, if any, encapsulated in a lazy thunk. This meets the expected efficient &lt;a href=&quot;#corec&quot;&gt;corecursive&lt;/a&gt; behaviour of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;f&lt;/code&gt; が &lt;code&gt;(:)&lt;/code&gt; の場合、3つのケースはすべて、それぞれ &lt;code&gt;z&lt;/code&gt; または &lt;code&gt;x&lt;/code&gt; または &lt;code&gt;l&lt;/code&gt; を保持する&lt;em&gt;consセルの&lt;/em&gt;即値を返し、残りの構造は、レイジーサンクにカプセル化されます。これは、 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; の期待される効率的な&lt;a href=&quot;#corec&quot;&gt;コアカーシブ&lt;/a&gt;動作を満たしています。</target>
        </trans-unit>
        <trans-unit id="dd38bf999f51a8e6ab980a4cc02677fcbb4c986c" translate="yes" xml:space="preserve">
          <source>For example, when compiling module A, you can only run Template Haskell functions imported from B if B does not import A (directly or indirectly). The reason should be clear: to run B we must compile and run A, but we are currently type-checking A.</source>
          <target state="translated">例えば、モジュールAをコンパイルするとき、BがAを(直接または間接的に)インポートしていない場合、BからインポートされたHaskellテンプレート関数のみを実行することができます。理由は明確であるべきです:Bを実行するためにはAをコンパイルして実行する必要がありますが、現在はAの型チェックを行っています。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="17c57644c0265103527c3af40403358dc202cd31" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;&amp;hellip;warning: \`Foo' declared \`static' but never
defined.&lt;/code&gt; Unsightly, but shouldn&amp;rsquo;t be a problem.</source>
          <target state="translated">例： &lt;code&gt;&amp;hellip;warning: \`Foo' declared \`static' but never defined.&lt;/code&gt; 見苦しいですが、問題にはなりません。</target>
        </trans-unit>
        <trans-unit id="476b28066e3c89df50c21f73368a0e01098fb0aa" translate="yes" xml:space="preserve">
          <source>For four-part GHC version numbers &lt;code&gt;x.y.z.z'&lt;/code&gt;, the value of &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; is the integer ⟨z⟩ while the value of &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL2__&lt;/code&gt; is set to the integer ⟨z&amp;rsquo;⟩.</source>
          <target state="translated">4つの部分のためのGHCのバージョン番号が &lt;code&gt;x.y.z.z'&lt;/code&gt; の値 &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; は、の値つつ整数⟨z⟩ある &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL2__&lt;/code&gt; は整数⟨z'⟩に設定されています。</target>
        </trans-unit>
        <trans-unit id="ebd87276392f86aa606645575def965bf344530d" translate="yes" xml:space="preserve">
          <source>For full details on injective type families refer to Haskell Symposium 2015 paper &lt;a href=&quot;http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf&quot;&gt;Injective type families for Haskell&lt;/a&gt;.</source>
          <target state="translated">単射タイプファミリの詳細についてはHaskellシンポジウム2015論文を参照してください&lt;a href=&quot;http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf&quot;&gt;Haskellのための単射型家族&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01178e47382bdc6446961872841b23fc4c45fd85" translate="yes" xml:space="preserve">
          <source>For hidden packages, however, you need to request the package be loaded by using the &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; flag:</source>
          <target state="translated">ただし、非表示のパッケージの場合は、 &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; フラグを使用してパッケージのロードを要求する必要があります。</target>
        </trans-unit>
        <trans-unit id="b3a5c6fd42825560c95317b78e19114644f5b7ff" translate="yes" xml:space="preserve">
          <source>For historical reasons, the preserved values are /&lt;em&gt;not&lt;/em&gt;/ forced. To force them, use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:preserveMissing-39-&quot;&gt;preserveMissing'&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">歴史的な理由により、保存された値は強制されたもので&lt;em&gt;はありません&lt;/em&gt;。それらを強制するには、 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:preserveMissing-39-&quot;&gt;preserveMissing'&lt;/a&gt;&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="75f8792d57e48a774641d9734879dcb766f223ec" translate="yes" xml:space="preserve">
          <source>For infinite structures, &lt;code&gt;&lt;a href=&quot;data-foldable#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; terminates if the value exists at a finite distance from the left side of the structure:</source>
          <target state="translated">無限構造の場合、値が構造の左側から有限距離に存在すると、 &lt;code&gt;&lt;a href=&quot;data-foldable#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; は終了します。</target>
        </trans-unit>
        <trans-unit id="462ce6044e470f38fd8877b9aec9d317b89c01cb" translate="yes" xml:space="preserve">
          <source>For infinite structures, &lt;code&gt;&lt;a href=&quot;data-list#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; terminates if the value exists at a finite distance from the left side of the structure:</source>
          <target state="translated">無限構造の場合、値が構造の左側から有限距離に存在すると、 &lt;code&gt;&lt;a href=&quot;data-list#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; は終了します。</target>
        </trans-unit>
        <trans-unit id="1265e702058729814c9070a553091ab6668e71f9" translate="yes" xml:space="preserve">
          <source>For infinite structures, &lt;code&gt;&lt;a href=&quot;prelude#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; terminates if the value exists at a finite distance from the left side of the structure:</source>
          <target state="translated">無限構造の場合、値が構造の左側から有限距離に存在すると、 &lt;code&gt;&lt;a href=&quot;prelude#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; は終了します。</target>
        </trans-unit>
        <trans-unit id="e2b4e1b52d9313f4a64b67c682815f36e8dd1565" translate="yes" xml:space="preserve">
          <source>For infinite structures, the default implementation of &lt;code&gt;&lt;a href=&quot;data-foldable#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; terminates if the sought-after value exists at a finite distance from the left side of the structure:</source>
          <target state="translated">無限構造の場合、 &lt;code&gt;&lt;a href=&quot;data-foldable#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; のデフォルトの実装は、求められている値が構造の左側から有限の距離に存在する場合に終了します。</target>
        </trans-unit>
        <trans-unit id="4930b164ff12550352bb2ae49b0f3eafab2481e2" translate="yes" xml:space="preserve">
          <source>For infinite structures, the default implementation of &lt;code&gt;&lt;a href=&quot;data-list#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; terminates if the sought-after value exists at a finite distance from the left side of the structure:</source>
          <target state="translated">無限構造の場合、 &lt;code&gt;&lt;a href=&quot;data-list#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; のデフォルトの実装は、求められている値が構造の左側から有限の距離に存在する場合に終了します。</target>
        </trans-unit>
        <trans-unit id="8ce546ec8413f6538f8a26e19ca0ec25047ae9e5" translate="yes" xml:space="preserve">
          <source>For infinite structures, the default implementation of &lt;code&gt;&lt;a href=&quot;prelude#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; terminates if the sought-after value exists at a finite distance from the left side of the structure:</source>
          <target state="translated">無限構造の場合、 &lt;code&gt;&lt;a href=&quot;prelude#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; のデフォルトの実装は、求められている値が構造の左側から有限の距離に存在する場合に終了します。</target>
        </trans-unit>
        <trans-unit id="c30b64ae65331781837d75efd9f6decbae446e0c" translate="yes" xml:space="preserve">
          <source>For information on what bound threads are, see the documentation for the &lt;a href=&quot;../../libraries/base-4.15.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;.</source>
          <target state="translated">バインドされたスレッドとは何かについては、&lt;a href=&quot;../../libraries/base-4.15.0.0/control-concurrent&quot;&gt;Control.Concurrentの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="2937ae469e44a6da2ea2b9c7c56013ccc4d03ea5" translate="yes" xml:space="preserve">
          <source>For instance, a simple profile might look like this,</source>
          <target state="translated">例えば、シンプルなプロフィールは次のようになります。</target>
        </trans-unit>
        <trans-unit id="2df4182fc612ce7805e7516eb9a2b62d1493ffae" translate="yes" xml:space="preserve">
          <source>For instance, if you had the following type family:</source>
          <target state="translated">例えば、以下のようなタイプのファミリーがいたとします。</target>
        </trans-unit>
        <trans-unit id="ce40606b41f00effc4c8dc141b9ea10bdc0fc070" translate="yes" xml:space="preserve">
          <source>For instance, running a program with &lt;code&gt;+RTS -h -p -pohello-world&lt;/code&gt; would produce a heap profile named &lt;code&gt;hello-world.hp&lt;/code&gt; and a cost-centre profile named &lt;code&gt;hello-world.prof&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;+RTS -h -p -pohello-world&lt;/code&gt; でプログラムを実行すると、 &lt;code&gt;hello-world.hp&lt;/code&gt; という名前のヒーププロファイルとhello-world.profという名前のコストセンタープロファイルが &lt;code&gt;hello-world.prof&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="dea0253ba024112a72eb14c4873c0ade6c78487c" translate="yes" xml:space="preserve">
          <source>For instance, take the example of &lt;code&gt;-fno-specialise -O1&lt;/code&gt;. Despite the &lt;code&gt;-fno-specialise&lt;/code&gt; appearing in the command line, specialisation will still be enabled. This is the case as &lt;code&gt;-O1&lt;/code&gt; implies &lt;code&gt;-fspecialise&lt;/code&gt;, overriding the previous flag. By contrast, &lt;code&gt;-O1 -fno-specialise&lt;/code&gt; will compile without specialisation, as one would expect.</source>
          <target state="translated">たとえば、 &lt;code&gt;-fno-specialise -O1&lt;/code&gt; の例を見てみましょう。関わらず &lt;code&gt;-fno-specialise&lt;/code&gt; コマンドラインに登場する、特殊化はまだ有効になります。これは、 &lt;code&gt;-O1&lt;/code&gt; が &lt;code&gt;-fspecialise&lt;/code&gt; を意味し、以前のフラグを上書きするためです。対照的に、 &lt;code&gt;-O1 -fno-specialise&lt;/code&gt; は、予想どおり、特殊化なしでコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="a6868e1fb2efeb3425d8a627bfc9d0ba2d117c39" translate="yes" xml:space="preserve">
          <source>For instance, the first wildcard in the type signature &lt;code&gt;not'&lt;/code&gt; would produce the following error message:</source>
          <target state="translated">たとえば、型シグネチャ &lt;code&gt;not'&lt;/code&gt; の最初のワイルドカードは、次のエラーメッセージを生成します。</target>
        </trans-unit>
        <trans-unit id="958aeaf1ba8d61f0734b35c84475403f19531d00" translate="yes" xml:space="preserve">
          <source>For instance, we might use this interface to provide a more useful error message for applications of &lt;code&gt;show&lt;/code&gt; on unsaturated functions like this,</source>
          <target state="translated">たとえば、このインターフェイスを使用して、このような不飽和関数での &lt;code&gt;show&lt;/code&gt; のアプリケーションに、より有用なエラーメッセージを提供できます。</target>
        </trans-unit>
        <trans-unit id="be75888101f27133692a26f5d016cfc15af97616" translate="yes" xml:space="preserve">
          <source>For lists we get the natural order of effects by using &lt;strong&gt;&lt;code&gt;(prepend &amp;lt;$&amp;gt; f a)&lt;/code&gt;&lt;/strong&gt; as the operator and &lt;strong&gt;&lt;code&gt;(traverse f as)&lt;/code&gt;&lt;/strong&gt; as the operand (the actual definition is written as an equivalent right fold in order to enable &lt;em&gt;fusion&lt;/em&gt; rules):</source>
          <target state="translated">リストの場合、演算子として&lt;strong&gt; &lt;code&gt;(prepend &amp;lt;$&amp;gt; f a)&lt;/code&gt; &lt;/strong&gt;を使用し、オペランド&lt;strong&gt; &lt;code&gt;(traverse f as)&lt;/code&gt; &lt;/strong&gt;を使用することで、効果の自然な順序を取得します（実際の定義は、&lt;em&gt;融合&lt;/em&gt;ルールを有効にするために同等の右折りとして記述されます）。</target>
        </trans-unit>
        <trans-unit id="e819cf0fe0a721d8aa2edb789360b689a7c6df8a" translate="yes" xml:space="preserve">
          <source>For lists, &lt;code&gt;&lt;a href=&quot;data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; is the identity:</source>
          <target state="translated">リストの場合、 &lt;code&gt;&lt;a href=&quot;data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; はIDです。</target>
        </trans-unit>
        <trans-unit id="cd75721614a832379340eb5515b1192ef0f86e97" translate="yes" xml:space="preserve">
          <source>For many structures reasonably efficient &lt;code&gt;Foldable&lt;/code&gt; instances can be derived automatically, by enabling the &lt;code&gt;DeriveFoldable&lt;/code&gt; GHC extension. When this works, it is generally not necessary to define a custom instance by hand. Though in some cases one may be able to get slightly faster hand-tuned code, care is required to avoid producing slower code, or code that is not sufficiently lazy, strict or &lt;em&gt;lawful&lt;/em&gt;.</source>
          <target state="translated">多くの構造のために合理的に効率的な &lt;code&gt;Foldable&lt;/code&gt; インスタンスが有効にすることによって、自動的に導出することができ &lt;code&gt;DeriveFoldable&lt;/code&gt; GHC拡張を。これが機能する場合、通常、カスタムインスタンスを手動で定義する必要はありません。場合によっては、わずかに高速な手動調整コードを取得できる場合もありますが、低速のコードや、十分に怠惰、厳密、または&lt;em&gt;合法&lt;/em&gt;ではないコードを生成しないように注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="2512d10fb7fc1b9dbc0084916fcb3b49c0227bdb" translate="yes" xml:space="preserve">
          <source>For many years the type of a quotation was fixed to be `Q Exp` but by more precisely specifying the minimal interface it enables the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Exp&quot;&gt;Exp&lt;/a&gt;&lt;/code&gt; to be extracted purely from the quotation without interacting with &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">長年にわたり、見積もりの​​タイプは「Q Exp」に固定されていましたが、最小限のインターフェースをより正確に指定することで、 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; と対話せずに見積もりから純粋に &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Exp&quot;&gt;Exp&lt;/a&gt;&lt;/code&gt; を抽出できます。</target>
        </trans-unit>
        <trans-unit id="15ee88f85580b5f1cfacfb67956f3e66087a0c8d" translate="yes" xml:space="preserve">
          <source>For many years the type of a quotation was fixed to be `Q Exp` but by more precisely specifying the minimal interface it enables the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Exp&quot;&gt;Exp&lt;/a&gt;&lt;/code&gt; to be extracted purely from the quotation without interacting with &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">長年にわたり、見積もりの​​タイプは「Q Exp」に固定されていましたが、最小限のインターフェースをより正確に指定することで、 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; と対話せずに見積もりから純粋に &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Exp&quot;&gt;Exp&lt;/a&gt;&lt;/code&gt; を抽出できます。</target>
        </trans-unit>
        <trans-unit id="529b0aa96caf3e90c0267b32ba2bc9db119509d3" translate="yes" xml:space="preserve">
          <source>For monads that do belong to the &lt;code&gt;MonadFix&lt;/code&gt; class, GHC provides an extended version of the do-notation that allows recursive bindings. The &lt;a href=&quot;#extension-RecursiveDo&quot;&gt;&lt;code&gt;RecursiveDo&lt;/code&gt;&lt;/a&gt; (language pragma: &lt;code&gt;RecursiveDo&lt;/code&gt;) provides the necessary syntactic support, introducing the keywords &lt;code&gt;mdo&lt;/code&gt; and &lt;code&gt;rec&lt;/code&gt; for higher and lower levels of the notation respectively. Unlike bindings in a &lt;code&gt;do&lt;/code&gt; expression, those introduced by &lt;code&gt;mdo&lt;/code&gt; and &lt;code&gt;rec&lt;/code&gt; are recursively defined, much like in an ordinary let-expression. Due to the new keyword &lt;code&gt;mdo&lt;/code&gt;, we also call this notation the &lt;em&gt;mdo-notation&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;MonadFix&lt;/code&gt; クラスに属していないモナドの場合、GHCは再帰的なバインディングを可能にするdo表記の拡張バージョンを提供します。&lt;a href=&quot;#extension-RecursiveDo&quot;&gt; &lt;code&gt;RecursiveDo&lt;/code&gt; &lt;/a&gt;（言語プラグマ： &lt;code&gt;RecursiveDo&lt;/code&gt; の）キーワードが導入、必要な構文サポートを提供 &lt;code&gt;mdo&lt;/code&gt; と &lt;code&gt;rec&lt;/code&gt; それぞれ表記のより高い及びより低いレベルのために。 &lt;code&gt;do&lt;/code&gt; 式のバインディングとは異なり、 &lt;code&gt;mdo&lt;/code&gt; と &lt;code&gt;rec&lt;/code&gt; によって導入されるバインディングは、通常のlet式のように再帰的に定義されます。新しいキーワード &lt;code&gt;mdo&lt;/code&gt; により、この表記を&lt;em&gt;mdo-notation&lt;/em&gt;とも呼びます。</target>
        </trans-unit>
        <trans-unit id="aadaa664cff3605a3ecf9e7a3dabf2341d6ea100" translate="yes" xml:space="preserve">
          <source>For more details about this feature, please refer to &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/coercible.pdf&quot;&gt;Safe Coercions&lt;/a&gt; by Joachim Breitner, Richard A. Eisenberg, Simon Peyton Jones and Stephanie Weirich.</source>
          <target state="translated">この機能の詳細については、Joachim Breitner、Richard A. Eisenberg、Simon Peyton Jones、Stephanie Weirichによる&lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/coercible.pdf&quot;&gt;Safe Coercions&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="8f223131e45f78084be7dce3cc5c1c0ae03a548a" translate="yes" xml:space="preserve">
          <source>For more details on the implementation see the Paper: &amp;ldquo;Extending the Haskell Foreign Function Interface with Concurrency&amp;rdquo;. Last known to be accessible &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2004/09/conc-ffi.pdf&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">実装の詳細については、ペーパー「同時実行によるHaskell外部関数インターフェースの拡張」を参照してください。&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2004/09/conc-ffi.pdf&quot;&gt;ここ&lt;/a&gt;でアクセスできることが最後に知られています。</target>
        </trans-unit>
        <trans-unit id="94a68e78d61b7ecc371a39ec450b9f0dee51b088" translate="yes" xml:space="preserve">
          <source>For more details please refer to the &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki page&lt;/a&gt; or the original paper &lt;a href=&quot;#generics2010&quot; id=&quot;id100&quot;&gt;[Generics2010]&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;HaskellWikiページ&lt;/a&gt;または元の論文&lt;a href=&quot;#generics2010&quot; id=&quot;id100&quot;&gt;[Generics2010]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ddd7518e52d21c45b5c0164d5371d0d7f78e6094" translate="yes" xml:space="preserve">
          <source>For more details please refer to the &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki page&lt;/a&gt; or the original paper &lt;a href=&quot;#generics2010&quot; id=&quot;id98&quot;&gt;[Generics2010]&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wikiページ&lt;/a&gt;または元の論文&lt;a href=&quot;#generics2010&quot; id=&quot;id98&quot;&gt;[Generics2010]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b72896971c07169fb5840e32ce47aee311c5c705" translate="yes" xml:space="preserve">
          <source>For more details please refer to the &lt;a href=&quot;https://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki page&lt;/a&gt; or the original paper &lt;a href=&quot;#generics2010&quot; id=&quot;id2&quot;&gt;[Generics2010]&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;HaskellWikiページ&lt;/a&gt;または元の論文&lt;a href=&quot;#generics2010&quot; id=&quot;id2&quot;&gt;[Generics2010]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="68f5a6bc7d7f62ba632eabd939ff41eed834fc73" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;http://www.soi.city.ac.uk/~ross/papers/Applicative.html&quot;&gt;Applicative Programming with Effects&lt;/a&gt;, by Conor McBride and Ross Paterson.</source>
          <target state="translated">詳細については、Conor McBrideおよびRoss Patersonによる「&lt;a href=&quot;http://www.soi.city.ac.uk/~ross/papers/Applicative.html&quot;&gt;Applicative Programming with Effects」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="60fb5a666c6a0eaff8450effcf1a6d5878676b82" translate="yes" xml:space="preserve">
          <source>For more details, see documentation of &lt;code&gt;posix_fadvise(2)&lt;/code&gt;.</source>
          <target state="translated">詳細については、 &lt;code&gt;posix_fadvise(2)&lt;/code&gt; のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="0f151a8de0b0ae047ee77db2f883d4d612f14350" translate="yes" xml:space="preserve">
          <source>For more information about the debug information produced by GHC see Peter Wortmann&amp;rsquo;s PhD thesis, &lt;a href=&quot;http://etheses.whiterose.ac.uk/8321/&quot;&gt;*Profiling Optimized Haskell: Causal Analysis and Implementation*&lt;/a&gt;.</source>
          <target state="translated">GHCが生成するデバッグ情報の詳細については、Peter Wortmannの博士論文、&lt;a href=&quot;http://etheses.whiterose.ac.uk/8321/&quot;&gt;*プロファイリング最適化Haskell：因果分析と実装*を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da91b931841e7893478b07acb85bd4ccd0928c7e" translate="yes" xml:space="preserve">
          <source>For more information about this type's representation, see the comments in its implementation.</source>
          <target state="translated">この型の表現の詳細については、実装のコメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="8560ce11100cb4fa01d3828472236f160a993060" translate="yes" xml:space="preserve">
          <source>For more information on ticky-ticky profiling, see &lt;a href=&quot;profiling#ticky-ticky&quot;&gt;Using &amp;ldquo;ticky-ticky&amp;rdquo; profiling (for implementors)&lt;/a&gt;.</source>
          <target state="translated">ticky-tickyプロファイリングの詳細については、&lt;a href=&quot;profiling#ticky-ticky&quot;&gt;「ticky-ticky」プロファイリングの使用（実装者向け）を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="90f12f7b9c44042f6fe71df1a74617adb00702bb" translate="yes" xml:space="preserve">
          <source>For more information on using the API, as well as more samples and references, please see &lt;a href=&quot;http://haskell.org/haskellwiki/GHC/As_a_library&quot;&gt;this Haskell.org wiki page&lt;/a&gt;.</source>
          <target state="translated">APIの使用の詳細、およびその他のサンプルとリファレンスについては、&lt;a href=&quot;http://haskell.org/haskellwiki/GHC/As_a_library&quot;&gt;こちらのHaskell.org wikiページを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="586a78695eb0609dc531b936f637d0814cfd2fee" translate="yes" xml:space="preserve">
          <source>For more information on using the API, as well as more samples and references, please see &lt;a href=&quot;https://haskell.org/haskellwiki/GHC/As_a_library&quot;&gt;this Haskell.org wiki page&lt;/a&gt;.</source>
          <target state="translated">APIの使用の詳細、およびその他のサンプルとリファレンスについては、&lt;a href=&quot;https://haskell.org/haskellwiki/GHC/As_a_library&quot;&gt;このHaskell.orgwikiページを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90ef63ab6766f7302158ada5c6e4dcb9f048e311" translate="yes" xml:space="preserve">
          <source>For more information you can refer to the &lt;a href=&quot;http://belle.sourceforge.net/doc/hughes95design.pdf&quot;&gt;original paper&lt;/a&gt; that serves as the basis for this libraries design: /The Design of a Pretty-printing Library/ by John Hughes, in Advanced Functional Programming, 1995.</source>
          <target state="translated">詳細については、このライブラリの設計の基礎となった&lt;a href=&quot;http://belle.sourceforge.net/doc/hughes95design.pdf&quot;&gt;元の論文&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c0bed00e62b5493248939b4aa33a94f717129c1a" translate="yes" xml:space="preserve">
          <source>For more information, please visit the new SYB wiki: &lt;a href=&quot;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&quot;&gt;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&lt;/a&gt;.</source>
          <target state="translated">詳細については、新しいSYB wikiに&lt;a href=&quot;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&quot;&gt;アクセスしてください&lt;/a&gt;：http ://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB 。</target>
        </trans-unit>
        <trans-unit id="11f58187631ea148f4d89e652dfc9bc68f732d9a" translate="yes" xml:space="preserve">
          <source>For more information, refer to the documentation for the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">詳細については、 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; クラスのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="d3bff78a356bfb09cb0493c71dac3667a53fc420" translate="yes" xml:space="preserve">
          <source>For more information, refer to the documentation for the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class. @since 4.9.0.0</source>
          <target state="translated">詳細については、 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; クラスのドキュメントを参照してください。@ 4.9.0.0以降</target>
        </trans-unit>
        <trans-unit id="8573bf99480b0bd0d6d5a2fda62633bf25a04224" translate="yes" xml:space="preserve">
          <source>For more motivation and details please refer to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/DeferErrorsToRuntime&quot;&gt;Wiki&lt;/a&gt; page or the &lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;original paper&lt;/a&gt;.</source>
          <target state="translated">動機と詳細については、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/DeferErrorsToRuntime&quot;&gt;Wiki&lt;/a&gt;ページまたは&lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;元の論文&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="53c2c97747aa9fe39ba73a8b92072d90e3a4f755" translate="yes" xml:space="preserve">
          <source>For more motivation and details please refer to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/defer-errors-to-runtime&quot;&gt;Wiki&lt;/a&gt; page or the &lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;original paper&lt;/a&gt;.</source>
          <target state="translated">動機と詳細については、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/defer-errors-to-runtime&quot;&gt;Wiki&lt;/a&gt;ページまたは&lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;元の論文&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b784e8618e297958090335defe46f4624f38965b" translate="yes" xml:space="preserve">
          <source>For most application, it should suffice to instead use the following &lt;code&gt;Settings&lt;/code&gt; flags:</source>
          <target state="translated">ほとんどのアプリケーションでは、代わりに次の &lt;code&gt;Settings&lt;/code&gt; フラグを使用するだけで十分です。</target>
        </trans-unit>
        <trans-unit id="ff5273016b7cb616c8b49961a6a41e99d096cb1a" translate="yes" xml:space="preserve">
          <source>For most applications (e.g., a REPL), &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt; should have the correct effect.</source>
          <target state="translated">ほとんどのアプリケーション（REPLなど）では、 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt; が適切な効果をもたらすはずです。</target>
        </trans-unit>
        <trans-unit id="311f2e122e6dc16e2237dcd6b98b5829a7cc728a" translate="yes" xml:space="preserve">
          <source>For most array types, this operation is O(&lt;em&gt;n&lt;/em&gt;) where &lt;em&gt;n&lt;/em&gt; is the size of the array. However, the diffarray package provides an array type for which this operation has complexity linear in the number of updates.</source>
          <target state="translated">ほとんどの配列タイプでは、この操作はO（&lt;em&gt;n&lt;/em&gt;）です。ここで、&lt;em&gt;n&lt;/em&gt;は配列のサイズです。ただし、diffarrayパッケージは、この操作が更新の数において線形の複雑さを持つ配列型を提供します。</target>
        </trans-unit>
        <trans-unit id="4b9cb8cf6aa6594114627e9c8f2d2cd6fbe2360a" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">ほとんどのタイプでは、 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; のデフォルト定義が使用されますが、関数はクラス定義に含まれているため、特定のタイプに最適化されたバージョンを提供できます。</target>
        </trans-unit>
        <trans-unit id="25d34b5c0599445985c48feed3e52ab547a8c854" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;ghc-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">ほとんどのタイプでは、 &lt;code&gt;&lt;a href=&quot;ghc-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; のデフォルト定義が使用されますが、関数はクラス定義に含まれているため、特定のタイプに最適化されたバージョンを提供できます。</target>
        </trans-unit>
        <trans-unit id="afe02a91645487a5cca5e4dc2b2da47de7589838" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">ほとんどのタイプでは、 &lt;code&gt;&lt;a href=&quot;prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; のデフォルト定義が使用されますが、関数はクラス定義に含まれているため、特定のタイプに最適化されたバージョンを提供できます。</target>
        </trans-unit>
        <trans-unit id="6484245051d629100f2583ede948c431b601c733" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">ほとんどのタイプでは、 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; のデフォルト定義が使用されますが、関数はクラス定義に含まれているため、特定のタイプに最適化されたバージョンを提供できます。</target>
        </trans-unit>
        <trans-unit id="fe6e0410468523c927a0d7a9f8ddef7668228bfb" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">ほとんどのタイプでは、 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; のデフォルト定義が使用されますが、関数はクラス定義に含まれているため、特定のタイプに最適化されたバージョンを提供できます。</target>
        </trans-unit>
        <trans-unit id="aa070a0116630a05d217085a9df4b403160dd6f8" translate="yes" xml:space="preserve">
          <source>For nested &lt;code&gt;foralls&lt;/code&gt;, e.g.</source>
          <target state="translated">ネストされた &lt;code&gt;foralls&lt;/code&gt; の場合、例えば</target>
        </trans-unit>
        <trans-unit id="458047bcd2a4d374f9800d54638670eed4df239c" translate="yes" xml:space="preserve">
          <source>For newtypes, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt; and &lt;code&gt;Bounded&lt;/code&gt; are always derived using the &lt;code&gt;newtype&lt;/code&gt; strategy, even without &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; enabled. (There should be no observable difference to instances derived using the stock strategy.)</source>
          <target state="translated">&lt;code&gt;newtype&lt;/code&gt; の場合、 &lt;code&gt;Eq&lt;/code&gt; 、 &lt;code&gt;Ord&lt;/code&gt; 、 &lt;code&gt;Ix&lt;/code&gt; 、および &lt;code&gt;Bounded&lt;/code&gt; は、 &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; が有効になっていない場合でも、常にnewtype戦略を使用して導出されます。（ストック戦略を使用して導出されたインスタンスに観察可能な違いはないはずです。）</target>
        </trans-unit>
        <trans-unit id="4694f0c96ed1c1078475be69652119149e496dc9" translate="yes" xml:space="preserve">
          <source>For non-essential files (e.g. cache). It uses the &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;~/.cache&lt;/code&gt;. On Windows, the default is &lt;code&gt;%LOCALAPPDATA%&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Local&lt;/code&gt;). Can be considered as the user-specific equivalent of &lt;code&gt;/var/cache&lt;/code&gt;.</source>
          <target state="translated">重要でないファイル（キャッシュなど）の場合。 &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; 環境変数を使用します。Windows以外のシステムでは、デフォルトは &lt;code&gt;~/.cache&lt;/code&gt; です。Windowsでは、デフォルトは &lt;code&gt;%LOCALAPPDATA%&lt;/code&gt; です（例： &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Local&lt;/code&gt; ）。 &lt;code&gt;/var/cache&lt;/code&gt; のユーザー固有の同等物と考えることができます。</target>
        </trans-unit>
        <trans-unit id="6bb8c51cac0d107dff7666d44f386ca6ef354c70" translate="yes" xml:space="preserve">
          <source>For non-portable support of Haskell finalizers, see the &lt;a href=&quot;foreign-concurrent&quot;&gt;Foreign.Concurrent&lt;/a&gt; module.</source>
          <target state="translated">Haskellファイナライザの移植性のないサポートについては、&lt;a href=&quot;foreign-concurrent&quot;&gt;Foreign.Concurrent&lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="3383003efe56493c3ba8ee51d572a1bd3e32533a" translate="yes" xml:space="preserve">
          <source>For now, this module is the API for working with type-level literals. However, please note that it is a work in progress and is subject to change. Once the design of the &lt;code&gt;DataKinds&lt;/code&gt; feature is more stable, this will be considered only an internal GHC module, and the programmer interface for working with type-level data will be defined in a separate library.</source>
          <target state="translated">今のところ、このモジュールはタイプレベルのリテラルを操作するためのAPIです。ただし、これは進行中の作業であり、変更される可能性があることに注意してください。 &lt;code&gt;DataKinds&lt;/code&gt; 機能の設計がより安定すると、これは内部GHCモジュールのみと見なされ、タイプレベルのデータを操作するためのプログラマーインターフェイスは別のライブラリで定義されます。</target>
        </trans-unit>
        <trans-unit id="33b56c18b23f9ecb1cf4345cdf08508ff77d0dd4" translate="yes" xml:space="preserve">
          <source>For open and closed type families it is OK to name the result but skip the injectivity annotation. This is not the case for associated type synonyms, where the named result without injectivity annotation will be interpreted as associated type synonym default.</source>
          <target state="translated">オープン型とクローズド型のファミリーでは、結果に名前を付けても構いませんが、注入アノテーションを省略しても構いません。これは、関連付けられた型の同義語の場合はそうではありません。</target>
        </trans-unit>
        <trans-unit id="37dc725ee9dc508be5d616956f4278bb5bbb1e54" translate="yes" xml:space="preserve">
          <source>For other any type class:</source>
          <target state="translated">その他の任意のタイプのクラスに対応しています。</target>
        </trans-unit>
        <trans-unit id="8992b141ebf84616833ad66b803c7e3a3842868f" translate="yes" xml:space="preserve">
          <source>For other documentation, refer to: &lt;a href=&quot;http://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;http://www.haskell.org/haskellwiki/Template_Haskell&lt;/a&gt;</source>
          <target state="translated">その他のドキュメントについては、&lt;a href=&quot;http://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;http&lt;/a&gt;：//www.haskell.org/haskellwiki/Template_Haskellを参照してください。</target>
        </trans-unit>
        <trans-unit id="91b1fc2b5558fcebb47a9cb90615ec89658550a4" translate="yes" xml:space="preserve">
          <source>For other documentation, refer to: &lt;a href=&quot;https://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;http://www.haskell.org/haskellwiki/Template_Haskell&lt;/a&gt;</source>
          <target state="translated">その他のドキュメントについては、&lt;a href=&quot;https://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;http&lt;/a&gt;：//www.haskell.org/haskellwiki/Template_Haskellを参照してください。</target>
        </trans-unit>
        <trans-unit id="0f140c5422fa14edb971c7e4308e840e46380100" translate="yes" xml:space="preserve">
          <source>For part 1, we define a class &lt;code&gt;Encode'&lt;/code&gt;. Perhaps surprisingly, this class is parameterized over a type constructor &lt;code&gt;f&lt;/code&gt; of kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt;. This is a technicality: all the representation type constructors operate with kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt; as base kind. But the type argument is never being used. This may be changed at some point in the future. The class has a single method, and we use the type we want our final function to have, but we replace the occurrences of the generic type argument &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;f p&lt;/code&gt; (where the &lt;code&gt;p&lt;/code&gt; is any argument; it will not be used).</source>
          <target state="translated">パート1では、クラス &lt;code&gt;Encode'&lt;/code&gt; を定義します。おそらく、驚くべきことに、このクラスは、型コンストラクタの上にパラメータ化された &lt;code&gt;f&lt;/code&gt; 種類の &lt;code&gt;* -&amp;gt; *&lt;/code&gt; 。これは技術的です。すべての表現型コンストラクタは、種類 &lt;code&gt;* -&amp;gt; *&lt;/code&gt; を基本種類として動作します。ただし、type引数は使用されません。これは将来変更される可能性があります。クラスには単一のメソッドがあり、最終的な関数に必要な型を使用しますが、ジェネリック型引数 &lt;code&gt;a&lt;/code&gt; の出現を &lt;code&gt;f p&lt;/code&gt; に置き換えます（ &lt;code&gt;p&lt;/code&gt; は任意の引数です。これは使用されません）。</target>
        </trans-unit>
        <trans-unit id="f87b5de1b3b5f32164f5ee5dc4fb8f8f96f8dc64" translate="yes" xml:space="preserve">
          <source>For real numbers, the &lt;code&gt;&lt;a href=&quot;ghc-num#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; is either &lt;code&gt;-1&lt;/code&gt; (negative), &lt;code&gt;0&lt;/code&gt; (zero) or &lt;code&gt;1&lt;/code&gt; (positive).</source>
          <target state="translated">実数の場合、 &lt;code&gt;&lt;a href=&quot;ghc-num#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;-1&lt;/code&gt; （負）、 &lt;code&gt;0&lt;/code&gt; （ゼロ）、または &lt;code&gt;1&lt;/code&gt; （正）のいずれかです。</target>
        </trans-unit>
        <trans-unit id="9e94d05b9e837b15d27a9fea860bba07c986003d" translate="yes" xml:space="preserve">
          <source>For real numbers, the &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; is either &lt;code&gt;-1&lt;/code&gt; (negative), &lt;code&gt;0&lt;/code&gt; (zero) or &lt;code&gt;1&lt;/code&gt; (positive).</source>
          <target state="translated">実数の場合、 &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;-1&lt;/code&gt; （負）、 &lt;code&gt;0&lt;/code&gt; （ゼロ）、または &lt;code&gt;1&lt;/code&gt; （正）のいずれかです。</target>
        </trans-unit>
        <trans-unit id="378724e14b1bb63abfcba6089e6f23a18b0dbb9a" translate="yes" xml:space="preserve">
          <source>For records with many fields, it can be tiresome to write out each field individually in a record pattern, as in</source>
          <target state="translated">のように、多くのフィールドを持つレコードの場合、レコードパターンで各フィールドを個別に書き出すのは面倒な場合があります。</target>
        </trans-unit>
        <trans-unit id="7aac7c40c3604036ed41bcd7832a5e3d3aad7a7a" translate="yes" xml:space="preserve">
          <source>For single-constructor datatypes, the derived instance declarations are as shown for tuples in chapter 19, section 2 of the Haskell 2010 report: &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&lt;/a&gt;.</source>
          <target state="translated">単一コンストラクターのデータ型の場合、派生インスタンスの宣言は、Haskell 2010レポートの第19章、セクション2にあるタプルの&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch19.htmlに&lt;/a&gt;示されているとおりです。</target>
        </trans-unit>
        <trans-unit id="bd08981965b6a477e0c93e10e8a2c46079dd7254" translate="yes" xml:space="preserve">
          <source>For some reason, Mingw ships with the &lt;code&gt;readline&lt;/code&gt; library, but not with the &lt;code&gt;readline&lt;/code&gt; headers. As a result, GHC (like Hugs) does not use &lt;code&gt;readline&lt;/code&gt; for interactive input on Windows. You can get a close simulation by using an emacs shell buffer!</source>
          <target state="translated">何らかの理由で、Mingwには &lt;code&gt;readline&lt;/code&gt; ライブラリが付属していますが、 &lt;code&gt;readline&lt;/code&gt; ヘッダーは付属していません。その結果、GHC（Hugsなど）は、Windowsでの対話型入力に &lt;code&gt;readline&lt;/code&gt; を使用しません。emacsシェルバッファーを使用することで、詳細なシミュレーションを取得できます。</target>
        </trans-unit>
        <trans-unit id="c3d65c0e9a2a6354ca7a3aa3f79014b97e396ace" translate="yes" xml:space="preserve">
          <source>For some special use cases you may want more control over which events are included. The ⟨flags⟩ is a sequence of zero or more characters indicating which classes of events to log. Currently these the classes of events that can be enabled/disabled:</source>
          <target state="translated">いくつかの特別な使用例では、どのイベントを含めるかをより制御したい場合があります。⟨flags⟩ は、ログに記録するイベントのクラスを示す 0 文字以上の文字列です。現在、これらは有効/無効にできるイベントのクラスです。</target>
        </trans-unit>
        <trans-unit id="6c52999f5dadb28c826189af8598c10c0d62c8c4" translate="yes" xml:space="preserve">
          <source>For some values, we only care about the lists contents, not their order,</source>
          <target state="translated">いくつかの値については、リストの内容だけを気にしていて、その順番は気にしていません。</target>
        </trans-unit>
        <trans-unit id="5a30fff547bbac81b4549d50a582f44afe1ea5d2" translate="yes" xml:space="preserve">
          <source>For spark events there are two modes: sampled and fully accurate. There are various events in the life cycle of each spark, usually just creating and running, but there are some more exceptional possibilities. In the sampled mode the number of occurrences of each kind of spark event is sampled at frequent intervals. In the fully accurate mode every spark event is logged individually. The latter has a higher runtime overhead and is not enabled by default.</source>
          <target state="translated">スパークイベントには、サンプリングモードと完全アキュレートモードの2つのモードがあります。各スパークのライフサイクルには様々なイベントがあり、通常は単に作成して実行するだけですが、もっと例外的な可能性もあります。サンプリングモードでは、各種類のスパークイベントの発生数が頻繁にサンプリングされます。完全に正確なモードでは、すべてのスパークイベントが個別に記録されます。後者の方が実行時のオーバーヘッドが高く、デフォルトでは有効になっていません。</target>
        </trans-unit>
        <trans-unit id="8e967e8009285dc0e4dfe1b3126affb641d4d480" translate="yes" xml:space="preserve">
          <source>For technical reasons, GHCi can only support the &lt;code&gt;*&lt;/code&gt;-form for modules that are interpreted. Compiled modules and package modules can only contribute their exports to the current scope. To ensure that GHCi loads the interpreted version of a module, add the &lt;code&gt;*&lt;/code&gt; when loading the module, e.g. &lt;code&gt;:load *M&lt;/code&gt;.</source>
          <target state="translated">技術的な理由により、GHCi は解釈されるモジュールの &lt;code&gt;*&lt;/code&gt; フォームのみをサポートできます。コンパイルされたモジュールとパッケージモジュールは、現在のスコープへのエクスポートにのみ貢献できます。GHCiがモジュールの解釈済みバージョンを確実にロードするようにするには、モジュールをロードするときに &lt;code&gt;*&lt;/code&gt; を追加します（例 &lt;code&gt;:load *M&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0829deec59e025f397584544c425b37ed5413ca9" translate="yes" xml:space="preserve">
          <source>For technical reasons, the bytecode compiler doesn&amp;rsquo;t interact well with one of the optimisation passes, so we have disabled optimisation when using the interpreter. This isn&amp;rsquo;t a great loss: you&amp;rsquo;ll get a much bigger win by compiling the bits of your code that need to go fast, rather than interpreting them with optimisation turned on.</source>
          <target state="translated">技術的な理由により、バイトコードコンパイラーは最適化パスの1つとうまく連携しないため、インタープリターを使用するときは最適化を無効にしました。これは大きな損失ではありません。最適化をオンにして解釈するのではなく、高速にする必要があるコードのビットをコンパイルすることで、はるかに大きな利益を得ることができます。</target>
        </trans-unit>
        <trans-unit id="f3841d95008ee269104a63c61bf0120449a66e76" translate="yes" xml:space="preserve">
          <source>For the derived &lt;code&gt;Bad Int&lt;/code&gt; instance, GHC would need to generate something like this:</source>
          <target state="translated">派生した &lt;code&gt;Bad Int&lt;/code&gt; インスタンスの場合、GHCは次のようなものを生成する必要があります。</target>
        </trans-unit>
        <trans-unit id="4eaf58a3a8ca8af861b90aa91e9b822949a939a3" translate="yes" xml:space="preserve">
          <source>For the derived &lt;code&gt;Ex&lt;/code&gt; instance, GHC would need to generate something like this:</source>
          <target state="translated">派生した &lt;code&gt;Ex&lt;/code&gt; インスタンスの場合、GHCは次のようなものを生成する必要があります。</target>
        </trans-unit>
        <trans-unit id="ffa588946311197a1b2c4ff685a498c96580d6ce" translate="yes" xml:space="preserve">
          <source>For the first trust definition the trust guarantee is provided by GHC through the restrictions imposed by the safe language. For the second definition of trust, the guarantee is provided initially by the module author. The client C then establishes that they trust the module author by indicating they trust the package the module resides in. This trust chain is required as GHC provides no guarantee for &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; compiled modules.</source>
          <target state="translated">最初の信頼の定義では、信頼の保証は、安全な言語によって課された制限を通じてGHCによって提供されます。信頼の2番目の定義では、保証は最初にモジュールの作成者によって提供されます。クライアントCは、モジュールが存在するパッケージを信頼することを示すことにより、モジュール作成者を信頼することを確立します&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;は、信頼できるコンパイル済みモジュールを保証しないため、この信頼チェーンが必要です。</target>
        </trans-unit>
        <trans-unit id="060c8275f3511e9a847d9b963216480ea97ce2de" translate="yes" xml:space="preserve">
          <source>For the first two examples we show sequenceA fully evaluating a a structure and collecting the results.</source>
          <target state="translated">最初の2つの例では、sequenceAがa構造を完全に評価し、その結果を収集しています。</target>
        </trans-unit>
        <trans-unit id="d323edf5bc66a27abef8680a58a3a1cdc8c8ab90" translate="yes" xml:space="preserve">
          <source>For the string data itself, both &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;b#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; use one byte per element, rounded up to the nearest word. For example, including the overheads, a length 10 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; would take &lt;code&gt;16 + 12 = 28&lt;/code&gt; bytes on a 32bit platform and &lt;code&gt;32 + 16 = 48&lt;/code&gt; bytes on a 64bit platform.</source>
          <target state="translated">文字列データ自体については、 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;b#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; の両方が要素ごとに1バイトを使用し、最も近い単語に切り上げられます。たとえば、オーバーヘッドを含めると、長さ10の &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; は、32ビットプラットフォームでは &lt;code&gt;16 + 12 = 28&lt;/code&gt; バイト、64ビットプラットフォームでは &lt;code&gt;32 + 16 = 48&lt;/code&gt; バイトになります。</target>
        </trans-unit>
        <trans-unit id="32cc9253b78847faffaa8325c66bc83a4331016c" translate="yes" xml:space="preserve">
          <source>For the string data itself, both &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;ByteString&lt;/code&gt; use one byte per element, rounded up to the nearest word. For example, including the overheads, a length 10 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; would take &lt;code&gt;16 + 12 = 28&lt;/code&gt; bytes on a 32bit platform and &lt;code&gt;32 + 16 = 48&lt;/code&gt; bytes on a 64bit platform.</source>
          <target state="translated">文字列データ自体の場合、 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;ByteString&lt;/code&gt; はどちらも要素ごとに1バイトを使用し、最も近い単語に切り上げられます。たとえば、オーバーヘッドを含めて、長さ10の &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; は、32ビットプラットフォームでは &lt;code&gt;16 + 12 = 28&lt;/code&gt; バイト、64 ビットプラットフォームでは &lt;code&gt;32 + 16 = 48&lt;/code&gt; バイトになります。</target>
        </trans-unit>
        <trans-unit id="2dfb67f7f13b2578a8003b1f16579b450e09d029" translate="yes" xml:space="preserve">
          <source>For these monad transformers, &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; is a natural transformation in the category of monads, i.e. for any monad transformation &lt;code&gt;t :: M a -&amp;gt; N a&lt;/code&gt;,</source>
          <target state="translated">これらのモナド変換子の場合、 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; はモナドのカテゴリの自然な変換です。つまり、モナド変換の場合は &lt;code&gt;t :: M a -&amp;gt; N a&lt;/code&gt; a- &amp;gt; N a、</target>
        </trans-unit>
        <trans-unit id="67e40ed20b98dd2eb671037144a5a29659a48929" translate="yes" xml:space="preserve">
          <source>For these reasons GHC provides an external API to &lt;code&gt;tryPutMVar&lt;/code&gt;, &lt;code&gt;hs_try_putmvar&lt;/code&gt;, which you can use to cheaply and asynchronously wake up a Haskell thread from C/C++.</source>
          <target state="translated">これらの理由により、GHCは &lt;code&gt;tryPutMVar&lt;/code&gt; 、 &lt;code&gt;hs_try_putmvar&lt;/code&gt; に外部APIを提供します。これを使用すると、C / C ++からHaskellスレッドを安価かつ非同期に起動できます。</target>
        </trans-unit>
        <trans-unit id="5539b287ec186ea0d65a4fd7ea031c83904aceb1" translate="yes" xml:space="preserve">
          <source>For this reason we should be cautious when interpreting the source locations provided by GDB. While these locations will usually be in some sense &amp;ldquo;correct&amp;rdquo;, they aren&amp;rsquo;t always useful. This is why profiling tools targeting Haskell should supplement the standard source location information with GHC-specific annotations (emitted with &lt;code&gt;-g2&lt;/code&gt;) when assigning costs.</source>
          <target state="translated">このため、GDBによって提供されるソースの場所を解釈する際には注意が必要です。これらの場所は通常、ある意味で「正しい」ものですが、常に役立つとは限りません。これが、Haskellを対象とするプロファイリングツールが、コストを割り当てるときに、標準のソースロケーション情報をGHC固有の注釈（ &lt;code&gt;-g2&lt;/code&gt; で出力）で補足する必要がある理由です。</target>
        </trans-unit>
        <trans-unit id="3771cc36c2c4040313b7547f14f2698b45ba9921" translate="yes" xml:space="preserve">
          <source>For this reason we should be cautious when interpreting the source locations provided by GDB. While these locations will usually be in some sense &amp;ldquo;correct&amp;rdquo;, they aren&amp;rsquo;t always useful. This is why profiling tools targetting Haskell should supplement the standard source location information with GHC-specific annotations (emitted with &lt;code&gt;-g2&lt;/code&gt;) when assigning costs.</source>
          <target state="translated">このため、GDBによって提供されるソースの場所を解釈する際には注意が必要です。これらの場所は通常、ある意味で「正しい」ものですが、常に役立つとは限りません。これが、Haskellを対象とするプロファイリングツールが、コストを割り当てるときに、標準のソースロケーション情報をGHC固有のアノテーション（ &lt;code&gt;-g2&lt;/code&gt; で出力）で補足する必要がある理由です。</target>
        </trans-unit>
        <trans-unit id="9b01d6140708791731ce8e176317b02d04ed594b" translate="yes" xml:space="preserve">
          <source>For this reason we should be cautious when interpretting the source locations provided by GDB. While these locations will usually be in some sense &amp;ldquo;correct&amp;rdquo;, they aren&amp;rsquo;t always useful. This is why profiling tools targetting Haskell should supplement the standard source location information with GHC-specific annotations (emitted with &lt;code&gt;-g2&lt;/code&gt;) when assigning costs.</source>
          <target state="translated">このため、GDBが提供するソースの場所を解釈するときは注意が必要です。これらの場所は通常、ある意味で「正しい」ものですが、常に役立つとは限りません。これが、Haskellをターゲットとするプロファイリングツールが、コストを割り当てるときに、標準のソースの場所情報にGHC固有の注釈（ &lt;code&gt;-g2&lt;/code&gt; で出力される）を追加する必要がある理由です。</target>
        </trans-unit>
        <trans-unit id="cacc0718d7e72594c1a05f793c384e9988e904e4" translate="yes" xml:space="preserve">
          <source>For three-part GHC version numbers &lt;code&gt;x.y.z&lt;/code&gt;, the value of &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; is the integer ⟨z⟩.</source>
          <target state="translated">三部GHCバージョン番号のための &lt;code&gt;x.y.z&lt;/code&gt; の値 &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; は整数⟨z⟩あります。</target>
        </trans-unit>
        <trans-unit id="188a9697d8960ecca4fddfef544f2b460160723f" translate="yes" xml:space="preserve">
          <source>For tuples, the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; constraint on &lt;code&gt;a&lt;/code&gt; determines how the first values merge. For example, &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s concatenate:</source>
          <target state="translated">タプルの場合、 &lt;code&gt;a&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 制約により、最初の値のマージ方法が決まります。たとえば、 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; は連結します：</target>
        </trans-unit>
        <trans-unit id="3ada1c90cd5232324681478bf68909f9821cd1f0" translate="yes" xml:space="preserve">
          <source>For tuples, the &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; constraint on &lt;code&gt;a&lt;/code&gt; determines how the first values merge. For example, &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s concatenate:</source>
          <target state="translated">タプルの場合、 &lt;code&gt;a&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 制約により、最初の値のマージ方法が決まります。たとえば、 &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; は連結します：</target>
        </trans-unit>
        <trans-unit id="477f18a8cee4f79bac4ee3f97a03e846b9653542" translate="yes" xml:space="preserve">
          <source>For tuples, the &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; constraint on &lt;code&gt;a&lt;/code&gt; determines how the first values merge. For example, &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s concatenate:</source>
          <target state="translated">タプルの場合、 &lt;code&gt;a&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 制約により、最初の値のマージ方法が決まります。たとえば、 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; は連結します：</target>
        </trans-unit>
        <trans-unit id="7016d35532abd78914b16b8e9e5320cbf10c3da6" translate="yes" xml:space="preserve">
          <source>For type-level lists of &lt;em&gt;two or more elements&lt;/em&gt;, such as the signature of &lt;code&gt;foo2&lt;/code&gt; above, the quote may be omitted because the meaning is unambiguous. But for lists of one or zero elements (as in &lt;code&gt;foo0&lt;/code&gt; and &lt;code&gt;foo1&lt;/code&gt;), the quote is required, because the types &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;[Int]&lt;/code&gt; have existing meanings in Haskell.</source>
          <target state="translated">上記の &lt;code&gt;foo2&lt;/code&gt; のシグネチャなど、&lt;em&gt;2つ以上の要素の&lt;/em&gt;型レベルのリストの場合、意味が明確であるため、引用符を省略できます。ただし、要素が1つまたはゼロのリストの場合（ &lt;code&gt;foo0&lt;/code&gt; および &lt;code&gt;foo1&lt;/code&gt; のように）、型 &lt;code&gt;[]&lt;/code&gt; および &lt;code&gt;[Int]&lt;/code&gt; はHaskellで既存の意味を持つため、引用符が必要です。</target>
        </trans-unit>
        <trans-unit id="f9d5f6ee9e1d0773bd91e69a976df850879bd39d" translate="yes" xml:space="preserve">
          <source>For types and classes, GHCi also summarises instances that mention them. To avoid showing irrelevant information, an instance is shown only if (a) its head mentions ⟨name⟩, and (b) all the other things mentioned in the instance are in scope (either qualified or otherwise) as a result of a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; commands.</source>
          <target state="translated">タイプとクラスの場合、GHCiはそれらを言及するインスタンスも要約します。関連性のない情報が表示されないようにするために、インスタンスは、（a）ヘッドが「名前」について言及している場合にのみ表示され、（b）インスタンスで言及されている他のすべてのものは、&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; の&lt;/a&gt;結果として（修飾されているかどうかにかかわらず）スコープ内にありますまたは&lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt;コマンド。</target>
        </trans-unit>
        <trans-unit id="47016a9c155d56e31c98a5182e288d8d66335bae" translate="yes" xml:space="preserve">
          <source>For unary constructors</source>
          <target state="translated">単項コンストラクタの場合</target>
        </trans-unit>
        <trans-unit id="3804078f78b2c6305b48a6307a75661e75a4d323" translate="yes" xml:space="preserve">
          <source>For unbounded types like &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; のような制限のない型の場合、 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="4299789099cbf566592e41318a28abf099452da3" translate="yes" xml:space="preserve">
          <source>For use with GHCi, each library should have an object file too. The name of the object file does &lt;em&gt;not&lt;/em&gt; have a &lt;code&gt;lib&lt;/code&gt; prefix, and has the normal object suffix for your platform.</source>
          <target state="translated">GHCiで使用するには、各ライブラリにオブジェクトファイルも必要です。オブジェクトファイルの名前がない&lt;em&gt;ではない&lt;/em&gt;持っている &lt;code&gt;lib&lt;/code&gt; 接頭辞を、およびお使いのプラットフォームの通常のオブジェクトのサフィックスを持っています。</target>
        </trans-unit>
        <trans-unit id="2630e9cec4ca5b11b5ae4aa835141d30d2fd8d21" translate="yes" xml:space="preserve">
          <source>For values of &lt;code&gt;n&lt;/code&gt; greater than 1, we use &lt;code&gt;par&lt;/code&gt; to spark a thread to evaluate &lt;code&gt;nfib (n-1)&lt;/code&gt;, and then we use &lt;code&gt;pseq&lt;/code&gt; to force the parent thread to evaluate &lt;code&gt;nfib (n-2)&lt;/code&gt; before going on to add together these two subexpressions. In this divide-and-conquer approach, we only spark a new thread for one branch of the computation (leaving the parent to evaluate the other branch). Also, we must use &lt;code&gt;pseq&lt;/code&gt; to ensure that the parent will evaluate &lt;code&gt;n2&lt;/code&gt;&lt;em&gt;before&lt;/em&gt;&lt;code&gt;n1&lt;/code&gt; in the expression &lt;code&gt;(n1 + n2 + 1)&lt;/code&gt;. It is not sufficient to reorder the expression as &lt;code&gt;(n2 + n1 + 1)&lt;/code&gt;, because the compiler may not generate code to evaluate the addends from left to right.</source>
          <target state="translated">値について &lt;code&gt;n&lt;/code&gt; は 1より大きい、我々が使用する &lt;code&gt;par&lt;/code&gt; 評価するスレッド火花 &lt;code&gt;nfib (n-1)&lt;/code&gt; 、そして私たちは、使用 &lt;code&gt;pseq&lt;/code&gt; 評価するために、親スレッドを強制的に &lt;code&gt;nfib (n-2)&lt;/code&gt; 一緒にこれら二つを追加するに行く前に部分式。この分割統治アプローチでは、計算の1つのブランチに対してのみ新しいスレッドをスパークします（親に他のブランチを評価させる）。また、式 &lt;code&gt;(n1 + n2 + 1)&lt;/code&gt; 親が &lt;code&gt;n1&lt;/code&gt; の&lt;em&gt;前に&lt;/em&gt; &lt;code&gt;n2&lt;/code&gt; を評価するように、 &lt;code&gt;pseq&lt;/code&gt; を使用する必要があります。式を &lt;code&gt;(n2 + n1 + 1)&lt;/code&gt; に並べ替えるだけでは不十分です。&lt;em&gt;&lt;/em&gt;なぜなら、コンパイラは加数を左から右に評価するコードを生成しない場合があるからです。</target>
        </trans-unit>
        <trans-unit id="833cc29e3ca3cd40dea4e5990721a0c2c0e6e2a7" translate="yes" xml:space="preserve">
          <source>For version &lt;code&gt;x.y.z&lt;/code&gt; of GHC, the value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example in version 6.2 of GHC, &lt;code&gt;__GLASGOW_HASKELL__==602&lt;/code&gt;). More information in &lt;a href=&quot;intro#version-numbering&quot;&gt;GHC version numbering policy&lt;/a&gt;.</source>
          <target state="translated">バージョンのための &lt;code&gt;x.y.z&lt;/code&gt; GHCの、の値 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; は（⟨y⟩そうGHCのバージョン6.2において、例えば、その先頭にゼロが付加された単一の数字である場合、整数⟨xyy⟩は &lt;code&gt;__GLASGOW_HASKELL__==602&lt;/code&gt; ）。で詳しい情報&lt;a href=&quot;intro#version-numbering&quot;&gt;GHCのバージョン番号ポリシー&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="930d459a31fb0c473c8d3d450ef14232e956aa5e" translate="yes" xml:space="preserve">
          <source>ForallInvis</source>
          <target state="translated">ForallInvis</target>
        </trans-unit>
        <trans-unit id="fc5f64a4d6f12d0fb09adaae4cd55424315fc13f" translate="yes" xml:space="preserve">
          <source>ForallVis</source>
          <target state="translated">ForallVis</target>
        </trans-unit>
        <trans-unit id="9f28be70ee0e5b943be20d61fc496445d3c212bd" translate="yes" xml:space="preserve">
          <source>Force GHC to inline a value.</source>
          <target state="translated">GHCで強制的に値をインライン化します。</target>
        </trans-unit>
        <trans-unit id="a7d87bafad299b2161dda9a58e63b3f96665d77f" translate="yes" xml:space="preserve">
          <source>Force a &lt;code&gt;&lt;a href=&quot;data-typeable#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; to normal form.</source>
          <target state="translated">強制 &lt;code&gt;&lt;a href=&quot;data-typeable#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 正規形にします。</target>
        </trans-unit>
        <trans-unit id="b3e1df0f2bdfd332765ff5812d39df923d34d2d6" translate="yes" xml:space="preserve">
          <source>Force the entries whose keys are missing from the other map and otherwise preserve them unchanged.</source>
          <target state="translated">他のマップからキーが失われているエントリを強制的に削除し、それ以外の場合は変更せずに保持します。</target>
        </trans-unit>
        <trans-unit id="50ca9997d86f8ded3e64badd3d8a285f7f58295a" translate="yes" xml:space="preserve">
          <source>ForceSpecConstr</source>
          <target state="translated">ForceSpecConstr</target>
        </trans-unit>
        <trans-unit id="316d9703cf033d39685405519176248df170f94f" translate="yes" xml:space="preserve">
          <source>Foreign</source>
          <target state="translated">Foreign</target>
        </trans-unit>
        <trans-unit id="c0146d93cdce22c9be8cd3f9cab8d08969353dc4" translate="yes" xml:space="preserve">
          <source>Foreign formats supported by GHC via TH</source>
          <target state="translated">TH経由でGHCがサポートする海外フォーマット</target>
        </trans-unit>
        <trans-unit id="7f40d160ba2387e27fcd81cc062ef6d270959462" translate="yes" xml:space="preserve">
          <source>Foreign functions that use UTF-16 internally may return indices in units of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; instead of characters. These functions may safely be used with such indices, as they will adjust offsets if necessary to preserve the validity of a Unicode string.</source>
          <target state="translated">内部でUTF-16を使用する外部関数は、文字ではなく &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; の単位でインデックスを返す場合があります。これらの関数は、Unicode文字列の有効性を維持するために必要に応じてオフセットを調整するため、このようなインデックスで安全に使用できます。</target>
        </trans-unit>
        <trans-unit id="f235bf33c8f99af06dcf27d617dccc24437bf4f1" translate="yes" xml:space="preserve">
          <source>Foreign functions that use UTF-16 internally may return indices in units of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; instead of characters. These functions may safely be used with such indices, as they will adjust offsets if necessary to preserve the validity of a Unicode string.</source>
          <target state="translated">内部でUTF-16を使用する外部関数は、文字ではなく &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 単位でインデックスを返す場合があります。これらの関数は、Unicode文字列の有効性を維持するために必要に応じてオフセットを調整するため、このようなインデックスで安全に使用できます。</target>
        </trans-unit>
        <trans-unit id="06f04f5e4c57ead75bb6944301f5d150eaeca514" translate="yes" xml:space="preserve">
          <source>Foreign functions that use UTF-16 internally may return indices in units of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; instead of characters. These functions may safely be used with such indices, as they will adjust offsets if necessary to preserve the validity of a Unicode string.</source>
          <target state="translated">内部でUTF-16を使用する外部関数は、文字ではなく &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 単位でインデックスを返す場合があります。これらの関数は、Unicode文字列の有効性を維持するために必要に応じてオフセットを調整するため、このようなインデックスで安全に使用できます。</target>
        </trans-unit>
        <trans-unit id="1286675988bccc3af5f10d1742d504ae15e29428" translate="yes" xml:space="preserve">
          <source>Foreign marshalling support for CStrings with configurable encodings</source>
          <target state="translated">設定可能なエンコーディングを持つCStringsの外部マーシャリングサポート</target>
        </trans-unit>
        <trans-unit id="0859bd97836968ae374d07116e3dc9cd1c792332" translate="yes" xml:space="preserve">
          <source>Foreign.C.Error</source>
          <target state="translated">Foreign.C.Error</target>
        </trans-unit>
        <trans-unit id="690f9c43315bf0f53c59f0ead7261289984f80cc" translate="yes" xml:space="preserve">
          <source>Foreign.C.String</source>
          <target state="translated">Foreign.C.String</target>
        </trans-unit>
        <trans-unit id="0d8c0c0c869725d3e5a290ea1bd0154f90329b54" translate="yes" xml:space="preserve">
          <source>Foreign.C.Types</source>
          <target state="translated">Foreign.C.Types</target>
        </trans-unit>
        <trans-unit id="7d97c94339d1338677ead19d873092b037a681ee" translate="yes" xml:space="preserve">
          <source>Foreign.Concurrent</source>
          <target state="translated">Foreign.Concurrent</target>
        </trans-unit>
        <trans-unit id="ca33d0224eada8a62673063ebb4beeb1d5c364b8" translate="yes" xml:space="preserve">
          <source>Foreign.ForeignPtr</source>
          <target state="translated">Foreign.ForeignPtr</target>
        </trans-unit>
        <trans-unit id="fec1ff9f155f7aecb8a9c9afbbd7c199f0ad0a4d" translate="yes" xml:space="preserve">
          <source>Foreign.ForeignPtr.Safe</source>
          <target state="translated">Foreign.ForeignPtr.Safe</target>
        </trans-unit>
        <trans-unit id="f69294eb7e08c8d22462d5d33a8ed6a7e1d095e1" translate="yes" xml:space="preserve">
          <source>Foreign.ForeignPtr.Unsafe</source>
          <target state="translated">Foreign.ForeignPtr.Unsafe</target>
        </trans-unit>
        <trans-unit id="25bc28e29c71c1f9e77e3144861913407d39a05a" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal</source>
          <target state="translated">Foreign.Marshal</target>
        </trans-unit>
        <trans-unit id="7d1de99ecec974a4cc06846997a5642ce7e5207e" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Alloc</source>
          <target state="translated">Foreign.Marshal.Alloc</target>
        </trans-unit>
        <trans-unit id="34878c43ce6c0c1af86d41cd9921a4ee5f245a03" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Array</source>
          <target state="translated">Foreign.Marshal.Array</target>
        </trans-unit>
        <trans-unit id="92e3167a907bdc1222dc2d026cf2ba11246d8dc3" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Error</source>
          <target state="translated">Foreign.Marshal.Error</target>
        </trans-unit>
        <trans-unit id="8a7a411fa1f5af48f3df4c5bc1f61cb7696fe119" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Pool</source>
          <target state="translated">Foreign.Marshal.Pool</target>
        </trans-unit>
        <trans-unit id="7b25d01718919e3ce39586acacb255d2ed0d2a1f" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Safe</source>
          <target state="translated">Foreign.Marshal.Safe</target>
        </trans-unit>
        <trans-unit id="7c7103fd359ba066b392b41f8f6b0763350b3734" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Unsafe</source>
          <target state="translated">Foreign.Marshal.Unsafe</target>
        </trans-unit>
        <trans-unit id="af4a982e3ee46919384a0fa17fa230e3fcff9621" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Utils</source>
          <target state="translated">Foreign.Marshal.Utils</target>
        </trans-unit>
        <trans-unit id="3223be426d0cdd1356fd2286241936ef6d3776c4" translate="yes" xml:space="preserve">
          <source>Foreign.Ptr</source>
          <target state="translated">Foreign.Ptr</target>
        </trans-unit>
        <trans-unit id="5027f6a00f24a331a0a2c00858c48833746f143a" translate="yes" xml:space="preserve">
          <source>Foreign.StablePtr</source>
          <target state="translated">Foreign.StablePtr</target>
        </trans-unit>
        <trans-unit id="819868f38d58136fcaa5d12146fb0f0c1e93f966" translate="yes" xml:space="preserve">
          <source>Foreign.Storable</source>
          <target state="translated">Foreign.Storable</target>
        </trans-unit>
        <trans-unit id="f2e5ff4797622913221ace3c0f488aecb6763737" translate="yes" xml:space="preserve">
          <source>ForeignFunctionInterface</source>
          <target state="translated">ForeignFunctionInterface</target>
        </trans-unit>
        <trans-unit id="c2ad3b41dcfdfcb4cdc30a8b1047888336b299be" translate="yes" xml:space="preserve">
          <source>ForeignHANDLE</source>
          <target state="translated">ForeignHANDLE</target>
        </trans-unit>
        <trans-unit id="15867b934b9041f19d00947d6efc59ac6319cf3c" translate="yes" xml:space="preserve">
          <source>ForeignHValue</source>
          <target state="translated">ForeignHValue</target>
        </trans-unit>
        <trans-unit id="4c81499005daf21faf5cf91d16a0534956f2909d" translate="yes" xml:space="preserve">
          <source>ForeignPtr</source>
          <target state="translated">ForeignPtr</target>
        </trans-unit>
        <trans-unit id="c624eaa10676fb999d8a5b6feb05f3b52f934560" translate="yes" xml:space="preserve">
          <source>ForeignPtrContents</source>
          <target state="translated">ForeignPtrContents</target>
        </trans-unit>
        <trans-unit id="6f2e78934322ebeb373ed863a4f0571cb731dad3" translate="yes" xml:space="preserve">
          <source>ForeignRef</source>
          <target state="translated">ForeignRef</target>
        </trans-unit>
        <trans-unit id="625b683a019ce7ae97d5cf12c7b91734ec7d1897" translate="yes" xml:space="preserve">
          <source>ForeignSrcLang</source>
          <target state="translated">ForeignSrcLang</target>
        </trans-unit>
        <trans-unit id="f41c4e4dab0b44d75dad0c04a0156d326c95b774" translate="yes" xml:space="preserve">
          <source>Forest</source>
          <target state="translated">Forest</target>
        </trans-unit>
        <trans-unit id="210c313feac20bb8ddb1dd7cbec2b356b3072a0a" translate="yes" xml:space="preserve">
          <source>Fork a thread and call the supplied function when the thread is about to terminate, with an exception or a returned value. The function is called with asynchronous exceptions masked.</source>
          <target state="translated">スレッドをフォークし、スレッドが終了しようとしているときに、例外または戻り値を指定して、指定された関数を呼び出します。この関数は、非同期の例外がマスクされた状態で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="b1cbaa12a8b3d860d7a7e72293e672a2ff7acd71" translate="yes" xml:space="preserve">
          <source>Forking and executing</source>
          <target state="translated">フォークと実行</target>
        </trans-unit>
        <trans-unit id="4017d24e3f2f76b82ff8d264b0bfa897d184d50d" translate="yes" xml:space="preserve">
          <source>Forking and killing threads.</source>
          <target state="translated">糸をフォークして殺す。</target>
        </trans-unit>
        <trans-unit id="062c8f7ca75a391f115434ac85e20074eaf4a4b6" translate="yes" xml:space="preserve">
          <source>Forking and suchlike</source>
          <target state="translated">フォークなどの</target>
        </trans-unit>
        <trans-unit id="142946f950e6a3c69461157ecd922afefd29abfb" translate="yes" xml:space="preserve">
          <source>Form a complex number from polar components of magnitude and phase.</source>
          <target state="translated">マグニチュードと位相の極性成分から複素数を形成する。</target>
        </trans-unit>
        <trans-unit id="a60392868ec861fd3b4efe2f9b78306da95d0a07" translate="yes" xml:space="preserve">
          <source>Formally speaking, in Haskell 98, an entity (function, type or class) in a program is uniquely identified by the pair of the module name in which it is defined and its name. In GHC, an entity is uniquely defined by a triple: package, module, and name.</source>
          <target state="translated">形式的に言えば、Haskell 98では、プログラム内のエンティティ(関数、型、クラス)は、定義されているモジュール名とその名前のペアによって一意に識別されます。GHCでは、エンティティはパッケージ、モジュール、名前のトリプルで一意に定義されます。</target>
        </trans-unit>
        <trans-unit id="f76337fdd96b77e407773d674b30b0bcd18c1c85" translate="yes" xml:space="preserve">
          <source>Formally, the class &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; represents a bifunctor from &lt;code&gt;Hask&lt;/code&gt; -&amp;gt; &lt;code&gt;Hask&lt;/code&gt;.</source>
          <target state="translated">正式には、クラス &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; はからbifunctor表し &lt;code&gt;Hask&lt;/code&gt; &amp;gt; - &lt;code&gt;Hask&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="817d72cb0e35af2d4da048907c1e9f5d6dc84fe4" translate="yes" xml:space="preserve">
          <source>Format a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; as a list of lines.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; を行のリストとしてフォーマットします。</target>
        </trans-unit>
        <trans-unit id="9b3c1914896872682c2c5207b9848f7bd13b8136" translate="yes" xml:space="preserve">
          <source>Format a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; as a list of lines.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; を行のリストとしてフォーマットします。</target>
        </trans-unit>
        <trans-unit id="64f559e1932e1e1e55a815f201bd5318c25248c5" translate="yes" xml:space="preserve">
          <source>Format a variable number of arguments with the C-style formatting string.</source>
          <target state="translated">可変数の引数を C スタイルの書式設定文字列でフォーマットします。</target>
        </trans-unit>
        <trans-unit id="6c1b349cc09f134d48d7a222aba9e73980432c3a" translate="yes" xml:space="preserve">
          <source>Format picture translation</source>
          <target state="translated">フォーマットの画像変換</target>
        </trans-unit>
        <trans-unit id="f544ee1a7acc5ea325b43ab1bc03f12126274ad5" translate="yes" xml:space="preserve">
          <source>Format string</source>
          <target state="translated">フォーマット文字列</target>
        </trans-unit>
        <trans-unit id="15a38fe668d67202702d0adb7731f3ab46da832d" translate="yes" xml:space="preserve">
          <source>Format string according to &lt;a href=&quot;http://tools.ietf.org/html/rfc822#section-5&quot;&gt;RFC822&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://tools.ietf.org/html/rfc822#section-5&quot;&gt;RFC822&lt;/a&gt;に従ってフォーマット文字列。</target>
        </trans-unit>
        <trans-unit id="9e7448bd68705edd6cbfa67e98ce2811cf8f693f" translate="yes" xml:space="preserve">
          <source>Format string according to &lt;a href=&quot;https://tools.ietf.org/html/rfc822#section-5&quot;&gt;RFC822&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc822#section-5&quot;&gt;RFC822&lt;/a&gt;に従って文字列をフォーマットします。</target>
        </trans-unit>
        <trans-unit id="c69b10975ea22ae776aa724f607ec9f6aa5721da" translate="yes" xml:space="preserve">
          <source>Format string.</source>
          <target state="translated">フォーマット文字列。</target>
        </trans-unit>
        <trans-unit id="c49ce58749cd62ae589b86a35e201efa147e3749" translate="yes" xml:space="preserve">
          <source>FormatAdjustment</source>
          <target state="translated">FormatAdjustment</target>
        </trans-unit>
        <trans-unit id="70e56ae13abeac549bcfdb5f59450b6d50c08e51" translate="yes" xml:space="preserve">
          <source>FormatExtension</source>
          <target state="translated">FormatExtension</target>
        </trans-unit>
        <trans-unit id="5d785a947d237d49fab80da22e92f51d9955949e" translate="yes" xml:space="preserve">
          <source>FormatParse</source>
          <target state="translated">FormatParse</target>
        </trans-unit>
        <trans-unit id="b72b753c33b18ecb90ec05cd82bed66f783d6a0c" translate="yes" xml:space="preserve">
          <source>FormatSign</source>
          <target state="translated">FormatSign</target>
        </trans-unit>
        <trans-unit id="7e09c6d5d576e97515cc176e731476beaa374961" translate="yes" xml:space="preserve">
          <source>FormatTime</source>
          <target state="translated">FormatTime</target>
        </trans-unit>
        <trans-unit id="2a8d33f179c3fdae21d8031b20bfc9d0ae643b20" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 値のフォーマッター。</target>
        </trans-unit>
        <trans-unit id="0565c40664395019883a78394d3992cdd6a29f2a" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 値のフォーマッタ。</target>
        </trans-unit>
        <trans-unit id="7e70e56ba2ac14918e7e20dbc0ecdc4f08e831a7" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 値のフォーマッタ。</target>
        </trans-unit>
        <trans-unit id="f4f8c93e825cbbd257bef8a02316190482d9eebc" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 値のフォーマッター。</target>
        </trans-unit>
        <trans-unit id="99b405a8b0c3cbb2780273aefe5ba19eb6dfc98f" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 値のフォーマッター。</target>
        </trans-unit>
        <trans-unit id="1fb27c72113587f58e32eab2d4c73f0ebb454ce4" translate="yes" xml:space="preserve">
          <source>Formatting dumps</source>
          <target state="translated">ダンプのフォーマット</target>
        </trans-unit>
        <trans-unit id="052cfbf508f19822df3fa5723c6e45d70e424a82" translate="yes" xml:space="preserve">
          <source>Formatting numbers as text</source>
          <target state="translated">数字をテキストとしてフォーマットする</target>
        </trans-unit>
        <trans-unit id="9756f760957e76b727a94e2c4ebba6cd0fc0c583" translate="yes" xml:space="preserve">
          <source>Formatting of numbers as ASCII text.</source>
          <target state="translated">数値をASCIIテキストとしてフォーマットする</target>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="deab3e00883d05a243bf5b0e77d440ef22fdfed1" translate="yes" xml:space="preserve">
          <source>Forms the ratio of two integral numbers.</source>
          <target state="translated">2つの整数の比を表します。</target>
        </trans-unit>
        <trans-unit id="63d9155e692b47f7489ea16b510f66604795ffc2" translate="yes" xml:space="preserve">
          <source>Fortunately GHC provides two workarounds.</source>
          <target state="translated">幸いなことにGHCは2つの回避策を提供しています。</target>
        </trans-unit>
        <trans-unit id="3285674b1fed9c0d76a5d4be734aa793887b9b9c" translate="yes" xml:space="preserve">
          <source>Fortunately, the debugger includes a generic printing command, &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;, which can inspect the actual runtime value of a variable and attempt to reconstruct its type. If we try it on &lt;code&gt;left&lt;/code&gt;:</source>
          <target state="translated">幸い、デバッガーには、変数の実際の実行時の値を検査してその型の再構築を試みることができる汎用印刷コマンド&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; が&lt;/a&gt;含まれています。 &lt;code&gt;left&lt;/code&gt; 試してみると：</target>
        </trans-unit>
        <trans-unit id="5de5f3adc837b664b0c550c9600b073ca7c029bb" translate="yes" xml:space="preserve">
          <source>Fractional</source>
          <target state="translated">Fractional</target>
        </trans-unit>
        <trans-unit id="4ee506c817db93cddd17a9bfc7e90e7929ba9ac1" translate="yes" xml:space="preserve">
          <source>Fractional division.</source>
          <target state="translated">端数の分割。</target>
        </trans-unit>
        <trans-unit id="b7f4445862e6ae9531f4b6c20b5111d59a0f6376" translate="yes" xml:space="preserve">
          <source>Fractional literals are handled in just the same way, except that the translation is &lt;code&gt;fromRational (3.68::Rational)&lt;/code&gt;.</source>
          <target state="translated">分数リテラルは、翻訳が &lt;code&gt;fromRational (3.68::Rational)&lt;/code&gt; ことを除いて、まったく同じ方法で処理されます。</target>
        </trans-unit>
        <trans-unit id="5c28c0e5aed14aa92c66ee9d85b73c91926a063b" translate="yes" xml:space="preserve">
          <source>Fractional numbers, supporting real division.</source>
          <target state="translated">実数分割をサポートする分数。</target>
        </trans-unit>
        <trans-unit id="82bc6ab69601270775fa67172582c91fb0a4a8cd" translate="yes" xml:space="preserve">
          <source>Free a block of memory that was allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt; or any of the &lt;code&gt;new&lt;/code&gt;&lt;em&gt;X&lt;/em&gt; functions in &lt;a href=&quot;foreign-marshal-array&quot;&gt;Foreign.Marshal.Array&lt;/a&gt; or &lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt; または&lt;a href=&quot;foreign-marshal-array&quot;&gt;Foreign.Marshal.Array&lt;/a&gt;または&lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.Stringの&lt;/a&gt; &lt;code&gt;new&lt;/code&gt; &lt;em&gt;X&lt;/em&gt;関数のいずれかで割り当てられたメモリブロックを解放します。</target>
        </trans-unit>
        <trans-unit id="99ee535db19c7fed33ade7d6567514f1b90cbd2f" translate="yes" xml:space="preserve">
          <source>Free data previously created by &lt;code&gt;&lt;a href=&quot;ghci-message#v:PrepFFI&quot;&gt;PrepFFI&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-message#v:PrepFFI&quot;&gt;PrepFFI&lt;/a&gt;&lt;/code&gt; によって以前に作成された無料データ</target>
        </trans-unit>
        <trans-unit id="4149e5ff6e145e457b073182334b5e7994374fef" translate="yes" xml:space="preserve">
          <source>Free the cached debug data.</source>
          <target state="translated">キャッシュされたデバッグデータを解放します。</target>
        </trans-unit>
        <trans-unit id="11a51d8a12071a090bc68657f6d6227b831062a8" translate="yes" xml:space="preserve">
          <source>Frees a function pointer to the window closure which has been set directly by &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:setWindowClosure&quot;&gt;setWindowClosure&lt;/a&gt;&lt;/code&gt; or indirectly by &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:createWindowEx&quot;&gt;createWindowEx&lt;/a&gt;&lt;/code&gt;. You should call this function in your window closure's &lt;code&gt;&lt;a href=&quot;graphics-win32-message#v:wM_NCDESTROY&quot;&gt;wM_NCDESTROY&lt;/a&gt;&lt;/code&gt; case unless you delegate that case to &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:defWindowProc&quot;&gt;defWindowProc&lt;/a&gt;&lt;/code&gt; (e.g. as part of the default).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:setWindowClosure&quot;&gt;setWindowClosure&lt;/a&gt;&lt;/code&gt; によって直接、または &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:createWindowEx&quot;&gt;createWindowEx&lt;/a&gt;&lt;/code&gt; によって間接的に設定されたウィンドウクロージャへの関数ポインタを解放します。この関数は、ウィンドウクロージャーの &lt;code&gt;&lt;a href=&quot;graphics-win32-message#v:wM_NCDESTROY&quot;&gt;wM_NCDESTROY&lt;/a&gt;&lt;/code&gt; ケースで、そのケースを &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:defWindowProc&quot;&gt;defWindowProc&lt;/a&gt;&lt;/code&gt; に委任しない限り（たとえば、デフォルトの一部として）呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="835a9413b3500f88ebd65d3f3a099585661ce5a1" translate="yes" xml:space="preserve">
          <source>Freeze a call-stack, preventing any further call-sites from being appended.</source>
          <target state="translated">コールスタックをフリーズして、それ以上のコールサイトが追加されないようにします。</target>
        </trans-unit>
        <trans-unit id="d77d8d6f00b87c26b8cacf7082e9df15e70c77ad" translate="yes" xml:space="preserve">
          <source>Freeze a mutable array. Do not mutate the &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; afterwards!</source>
          <target state="translated">可変配列を凍結します。 &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; しないでください！</target>
        </trans-unit>
        <trans-unit id="3cbf8b26c0873962d81de4914650cb76bb9b807d" translate="yes" xml:space="preserve">
          <source>Freeze the stack at the given &lt;code&gt;CallStack&lt;/code&gt;, preventing any further call-sites from being pushed onto it.</source>
          <target state="translated">指定された &lt;code&gt;CallStack&lt;/code&gt; でスタックをフリーズし、それ以上の呼び出しサイトがスタックにプッシュされないようにします。</target>
        </trans-unit>
        <trans-unit id="b9fc39f5344fe15184815d93e0ed318d916cfe42" translate="yes" xml:space="preserve">
          <source>Fresh names</source>
          <target state="translated">フレッシュネーム</target>
        </trans-unit>
        <trans-unit id="d166e844a3f3f87149cc4f866eb998e9a751c72a" translate="yes" xml:space="preserve">
          <source>Friday</source>
          <target state="translated">Friday</target>
        </trans-unit>
        <trans-unit id="37dda3a9ea66f14ada71778600674c8b446efe85" translate="yes" xml:space="preserve">
          <source>From Ascending Lists</source>
          <target state="translated">昇順リストから</target>
        </trans-unit>
        <trans-unit id="dde237215ea6fcfcb47d350794652f262577482d" translate="yes" xml:space="preserve">
          <source>From Descending Lists</source>
          <target state="translated">降順リストから</target>
        </trans-unit>
        <trans-unit id="ea889b16fbe49283cc535ae8005c5b414dd907d0" translate="yes" xml:space="preserve">
          <source>From Unordered Lists</source>
          <target state="translated">順不同のリストから</target>
        </trans-unit>
        <trans-unit id="ec5ec9c6f6fb9b3f12cb867846a71ac3385b451b" translate="yes" xml:space="preserve">
          <source>From a different module than &lt;code&gt;Ix&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Ix&lt;/code&gt; とは異なるモジュールから</target>
        </trans-unit>
        <trans-unit id="773618ef2831cbf23002ae5536fc39efbf8e5287" translate="yes" xml:space="preserve">
          <source>From a semantic point of view:</source>
          <target state="translated">意味論的には</target>
        </trans-unit>
        <trans-unit id="2fc93a684c9bf3e71ee51e44f522a8a42caa44d2" translate="yes" xml:space="preserve">
          <source>From a syntactic point of view:</source>
          <target state="translated">構文的には</target>
        </trans-unit>
        <trans-unit id="9c95c79505f22121b4295dc89b0deedb0cd62bb1" translate="yes" xml:space="preserve">
          <source>From here, we can apply f to any argument of type Integer and observe the results.</source>
          <target state="translated">ここからは、整数型の任意の引数にfを適用して結果を観察することができます。</target>
        </trans-unit>
        <trans-unit id="65237fa5c41874136927b1dd87c188874f9356a5" translate="yes" xml:space="preserve">
          <source>From strings to constructors and vice versa: all data types</source>
          <target state="translated">文字列からコンストラクタへ、そしてその逆へ:すべてのデータ型</target>
        </trans-unit>
        <trans-unit id="3b2239783ff3d9519a980e73646e0d065f0b5416" translate="yes" xml:space="preserve">
          <source>From the &lt;code&gt;x1==x2&lt;/code&gt; we need &lt;code&gt;Eq a&lt;/code&gt;, which is fine. From &lt;code&gt;c1==c2&lt;/code&gt; we need &lt;code&gt;Eq (f (Rose f a))&lt;/code&gt; which is &lt;em&gt;not&lt;/em&gt; fine in Haskell today; we have no way to solve such a constraint.</source>
          <target state="translated">&lt;code&gt;x1==x2&lt;/code&gt; から、 &lt;code&gt;Eq a&lt;/code&gt; が必要ですが、これは問題ありません。 &lt;code&gt;c1==c2&lt;/code&gt; から、今日のHaskell &lt;em&gt;では&lt;/em&gt;うまく&lt;em&gt;いかない&lt;/em&gt; &lt;code&gt;Eq (f (Rose f a))&lt;/code&gt; が必要です。そのような制約を解決する方法はありません。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fe6c0223120c23453cd68ad8351310715d567d44" translate="yes" xml:space="preserve">
          <source>From the &lt;code&gt;x==x&lt;/code&gt; we need an &lt;code&gt;Eq (m Int)&lt;/code&gt; constraint, but the context only gives us a way to figure out &lt;code&gt;Ord (m a)&lt;/code&gt; constraints. But from the given constraint &lt;code&gt;forall a. Ord a =&amp;gt; Ord (m a)&lt;/code&gt; we derive a second given constraint &lt;code&gt;forall a. Ord a =&amp;gt; Eq (m a)&lt;/code&gt;, and from that we can readily solve &lt;code&gt;Eq (m Int)&lt;/code&gt;. This process is very similar to the way that superclasses already work: given an &lt;code&gt;Ord a&lt;/code&gt; constraint we derive a second given &lt;code&gt;Eq a&lt;/code&gt; constraint.</source>
          <target state="translated">&lt;code&gt;x==x&lt;/code&gt; から &lt;code&gt;Eq (m Int)&lt;/code&gt; 制約が必要ですが、コンテキストは &lt;code&gt;Ord (m a)&lt;/code&gt; 制約を理解する方法を提供するだけです。しかし、与えられた制約 &lt;code&gt;forall a. Ord a =&amp;gt; Ord (m a)&lt;/code&gt; すべてのaに対して2番目に与えられた制約を導出 &lt;code&gt;forall a. Ord a =&amp;gt; Eq (m a)&lt;/code&gt; であり、それから &lt;code&gt;Eq (m Int)&lt;/code&gt; 簡単に解くことができます。このプロセスは、スーパークラスがすでに機能している方法と非常に似ています &lt;code&gt;Ord a&lt;/code&gt; 制約が指定されている場合、 &lt;code&gt;Eq a&lt;/code&gt; 制約が指定されていれば、2番目に派生します。</target>
        </trans-unit>
        <trans-unit id="f3ccd46c83ed0ec15b20ac59a4d1d0cd9e4d0387" translate="yes" xml:space="preserve">
          <source>From the abstract:</source>
          <target state="translated">抄録から。</target>
        </trans-unit>
        <trans-unit id="8f586d4299cff81ec9f4dbb22fee7f8864d5b6b4" translate="yes" xml:space="preserve">
          <source>From the type signatures involved, this looks like it should allocate one &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; value, and two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values. However, when a module is compiled with optimisation enabled under GHC, the two intermediate &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values will be optimised away, and the function will be compiled down to a single loop over the source &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">関係する型シグネチャから、これは1つの &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 値と2つの &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 値を割り当てる必要があるように見えます。ただし、GHCで最適化を有効にしてモジュールをコンパイルすると、中間の2つの &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 値が最適化され、関数はソース &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; で単一のループにコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="694096b3017c32a2a22ef4b2a40ca9ccd292d59e" translate="yes" xml:space="preserve">
          <source>From the type signatures involved, this looks like it should allocate one &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; value, and two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values. However, when a module is compiled with optimisation enabled under GHC, the two intermediate &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values will be optimised away, and the function will be compiled down to a single loop over the source &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">関連する型シグネチャから、これは1つの &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 値と2つの &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 値を割り当てる必要があるように見えます。ただし、GHCで最適化を有効にしてモジュールをコンパイルすると、2つの中間 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 値が最適化され、関数はソース &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 上の単一ループにコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="da1b74e67991ce47776d51a891d2ebaba67a4de6" translate="yes" xml:space="preserve">
          <source>From the type signatures involved, this looks like it should allocate one &lt;code&gt;ByteString&lt;/code&gt; value, and two &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values. However, when a module is compiled with optimisation enabled under GHC, the two intermediate &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values will be optimised away, and the function will be compiled down to a single loop over the source &lt;code&gt;ByteString&lt;/code&gt;.</source>
          <target state="translated">関係する型シグネチャから、これは1つの &lt;code&gt;ByteString&lt;/code&gt; 値と2つの &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 値を割り当てる必要があるように見えます。ただし、GHCで最適化を有効にしてモジュールをコンパイルすると、中間の2つの &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 値が最適化され、関数はソース &lt;code&gt;ByteString&lt;/code&gt; で単一のループにコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="6319621270065df2076d59ecc28d7681834cf630" translate="yes" xml:space="preserve">
          <source>Front-end</source>
          <target state="translated">Front-end</target>
        </trans-unit>
        <trans-unit id="9cba7ac0176caf9e0fd3fa137920b3f27031c36f" translate="yes" xml:space="preserve">
          <source>Frontend plugins, like compiler plugins, are exported by registered plugins. However, unlike compiler modules, frontend plugins are modules that export at least a single identifier &lt;code&gt;frontendPlugin&lt;/code&gt; of type &lt;code&gt;GHC.Plugins.FrontendPlugin&lt;/code&gt;.</source>
          <target state="translated">コンパイラプラグインのようなフロントエンドプラグインは、登録されたプラグインによってエクスポートされます。ただし、コンパイラモジュールとは異なり、フロントエンドプラグインは、タイプ &lt;code&gt;GHC.Plugins.FrontendPlugin&lt;/code&gt; の少なくとも1つの識別子 &lt;code&gt;frontendPlugin&lt;/code&gt; をエクスポートするモジュールです。</target>
        </trans-unit>
        <trans-unit id="d62d9c8956bde0556d61352d45bccf3852eca058" translate="yes" xml:space="preserve">
          <source>Frontend plugins, like compiler plugins, are exported by registered plugins. However, unlike compiler modules, frontend plugins are modules that export at least a single identifier &lt;code&gt;frontendPlugin&lt;/code&gt; of type &lt;code&gt;GhcPlugins.FrontendPlugin&lt;/code&gt;.</source>
          <target state="translated">コンパイラプラグインのようなフロントエンドプラグインは、登録済みプラグインによってエクスポートされます。ただし、コンパイラモジュールとは異なり、フロントエンドプラグインは &lt;code&gt;GhcPlugins.FrontendPlugin&lt;/code&gt; タイプの少なくとも1つの識別子 &lt;code&gt;frontendPlugin&lt;/code&gt; をエクスポートするモジュールです。</target>
        </trans-unit>
        <trans-unit id="276f7c7cbfb0b8260fdd7e80f21f3c6030a9846c" translate="yes" xml:space="preserve">
          <source>FsModifier</source>
          <target state="translated">FsModifier</target>
        </trans-unit>
        <trans-unit id="18e66a137332691b1ae47570995daffc16926de1" translate="yes" xml:space="preserve">
          <source>FsModifiers</source>
          <target state="translated">FsModifiers</target>
        </trans-unit>
        <trans-unit id="ba860eaf95bc28dd3ebf66d6ea432e5dcf5bfbfd" translate="yes" xml:space="preserve">
          <source>Full list of currently supported flags:</source>
          <target state="translated">現在サポートされているフラグの完全なリスト。</target>
        </trans-unit>
        <trans-unit id="5f941ab65fbabe87f41cd73c9136f5a4c97087e8" translate="yes" xml:space="preserve">
          <source>Fun</source>
          <target state="translated">Fun</target>
        </trans-unit>
        <trans-unit id="a49f394638f73a008e2a6ab49d4b6e70abd398cc" translate="yes" xml:space="preserve">
          <source>FunDep</source>
          <target state="translated">FunDep</target>
        </trans-unit>
        <trans-unit id="92c04eeff3f0a42e14b1ae0e114869df39b965bc" translate="yes" xml:space="preserve">
          <source>FunLike</source>
          <target state="translated">FunLike</target>
        </trans-unit>
        <trans-unit id="5c9b47aa1445e6cb4d1617a035b8bafcb7684dca" translate="yes" xml:space="preserve">
          <source>FunPtr</source>
          <target state="translated">FunPtr</target>
        </trans-unit>
        <trans-unit id="a86870628cb20261d52821b6306ebd7581fdea16" translate="yes" xml:space="preserve">
          <source>Function composition.</source>
          <target state="translated">関数の構成。</target>
        </trans-unit>
        <trans-unit id="d6054df2c54398efbf27ace21713f95c0a24cb59" translate="yes" xml:space="preserve">
          <source>Function pointers</source>
          <target state="translated">関数ポインタ</target>
        </trans-unit>
        <trans-unit id="aa8776b9cbbee9db87d3477fe33414619d326897" translate="yes" xml:space="preserve">
          <source>Function to produce a list of possible completions</source>
          <target state="translated">補完可能なリストを生成する関数</target>
        </trans-unit>
        <trans-unit id="4ddcb5893b8b93e1794a989e859abc36b85a0805" translate="yes" xml:space="preserve">
          <source>Function to produce a list of possible completions. The first argument is the line contents to the left of the word, reversed. The second argument is the word to be completed.</source>
          <target state="translated">補完可能なリストを生成する関数です。第一引数は、単語の左にある行の内容を反転させたものです。第二引数は、補完する単語です。</target>
        </trans-unit>
        <trans-unit id="04d492d7d7dbe814e8a3fb4f74d794a0b412f642" translate="yes" xml:space="preserve">
          <source>Function type for handling a coding error. It is supplied with two inputs:</source>
          <target state="translated">コーディングエラーを処理するための関数型。2つの入力で供給される。</target>
        </trans-unit>
        <trans-unit id="ebada3a4561582f6522218c04a731fcb04129871" translate="yes" xml:space="preserve">
          <source>Function types. The last type parameter can appear anywhere in a function type as long as it occurs in a &lt;em&gt;covariant&lt;/em&gt; position. To illustrate what this means, consider the following three examples:</source>
          <target state="translated">関数タイプ。最後の型パラメーターは、&lt;em&gt;共変&lt;/em&gt;位置にある限り、関数型のどこにでも出現できます。これが何を意味するかを説明するために、次の3つの例を検討してください。</target>
        </trans-unit>
        <trans-unit id="a1f17265bebe4b2d092da403bdca66fa2464fc46" translate="yes" xml:space="preserve">
          <source>Functional dependencies are implemented as described by Mark Jones in &lt;a href=&quot;#jones2000&quot; id=&quot;id2&quot;&gt;[Jones2000]&lt;/a&gt;.</source>
          <target state="translated">関数従属性は、&lt;a href=&quot;#jones2000&quot; id=&quot;id2&quot;&gt;[Jones2000]のMarkJones&lt;/a&gt;によって説明されているように実装されます。</target>
        </trans-unit>
        <trans-unit id="22db9b73edaf2bfe5c3f6cffd0e6f0cc95517cd8" translate="yes" xml:space="preserve">
          <source>Functional dependencies are implemented as described by Mark Jones in &lt;a href=&quot;#jones2000&quot; id=&quot;id30&quot;&gt;[Jones2000]&lt;/a&gt;.</source>
          <target state="translated">機能的な依存関係は、&lt;a href=&quot;#jones2000&quot; id=&quot;id30&quot;&gt;[Jones2000]の&lt;/a&gt; Mark Jonesによって説明されているように実装されています。</target>
        </trans-unit>
        <trans-unit id="7435c5d7a8b15c59a912dbfd0c1a6479554619cb" translate="yes" xml:space="preserve">
          <source>Functional dependencies are implemented as described by Mark Jones in &lt;a href=&quot;#jones2000&quot; id=&quot;id31&quot;&gt;[Jones2000]&lt;/a&gt;.</source>
          <target state="translated">関数従属性は、&lt;a href=&quot;#jones2000&quot; id=&quot;id31&quot;&gt;[Jones2000]のMarkJones&lt;/a&gt;によって説明されているように実装されます。</target>
        </trans-unit>
        <trans-unit id="ac158651392c4f27c972abe1cd7fb99ffc1d8e40" translate="yes" xml:space="preserve">
          <source>Functional dependencies are introduced by a vertical bar in the syntax of a class declaration; e.g.</source>
          <target state="translated">機能的な依存関係は、クラス宣言の構文の中で縦棒によって導入されます。</target>
        </trans-unit>
        <trans-unit id="d1cf447b9d82509bd034707bd67b6d2cd8a410e7" translate="yes" xml:space="preserve">
          <source>Functional dependencies complicate matters. Suppose we have:</source>
          <target state="translated">機能的な依存関係は問題を複雑にします。あるとしましょう。</target>
        </trans-unit>
        <trans-unit id="a36463ef34fd5c22a3ab6a871cfc8a4acae515ba" translate="yes" xml:space="preserve">
          <source>FunctionalDependencies</source>
          <target state="translated">FunctionalDependencies</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="45b91122a610c434ec9ea5fb0448a65fa46cc4f4" translate="yes" xml:space="preserve">
          <source>Functions associated with the tuple data types.</source>
          <target state="translated">タプルデータ型に関連付けられた関数。</target>
        </trans-unit>
        <trans-unit id="654ea9aec402ec9bb954f259abf37b24e92ef692" translate="yes" xml:space="preserve">
          <source>Functions called when a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is finalized. Note that C finalizers and Haskell finalizers cannot be mixed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; がファイナライズされたときに呼び出される関数。CファイナライザーとHaskellファイナライザーを混在させることはできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="e2bc2aa5709cf3957c4e61f48d1f5ceec2be3360" translate="yes" xml:space="preserve">
          <source>Functions defined by the POSIX standards for manipulating and querying the file system. Names of underlying POSIX functions are indicated whenever possible. A more complete documentation of the POSIX functions together with a more detailed description of different error conditions are usually available in the system's manual pages or from &lt;a href=&quot;http://www.unix.org/version3/online.html&quot;&gt;http://www.unix.org/version3/online.html&lt;/a&gt; (free registration required).</source>
          <target state="translated">ファイルシステムの操作とクエリのためにPOSIX標準で定義された関数。基本となるPOSIX関数の名前は、可能な限り示されています。POSIX関数のより完全なドキュメントと、さまざまなエラー条件の詳細な説明は、通常、システムのマニュアルページまたは&lt;a href=&quot;http://www.unix.org/version3/online.html&quot;&gt;http://www.unix.org/version3/online.html&lt;/a&gt;（無料登録が必要）から入手できます。</target>
        </trans-unit>
        <trans-unit id="ef2638ff979efc064c3b114a029ccd9016977415" translate="yes" xml:space="preserve">
          <source>Functions for converting &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values to and from &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, using several standard encodings.</source>
          <target state="translated">いくつかの標準エンコーディングを使用して、 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 値を &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; との間で変換するための関数。</target>
        </trans-unit>
        <trans-unit id="db91a2c7ff023def688156c0f6c192f7664fb169" translate="yes" xml:space="preserve">
          <source>Functions for converting &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values to and from &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, using several standard encodings.</source>
          <target state="translated">いくつかの標準エンコーディングを使用して、 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 値を &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; との間で変換するための関数。</target>
        </trans-unit>
        <trans-unit id="8073ea9327a4d7c6639e6bad896a175b4a67c6eb" translate="yes" xml:space="preserve">
          <source>Functions for converting lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values to and from lazy &lt;code&gt;ByteString&lt;/code&gt;, using several standard encodings.</source>
          <target state="translated">いくつかの標準エンコーディングを使用して、遅延 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 値を遅延 &lt;code&gt;ByteString&lt;/code&gt; との間で変換するための関数。</target>
        </trans-unit>
        <trans-unit id="1cbb4c1f2e7daa321ba6fcea8db0876732346830" translate="yes" xml:space="preserve">
          <source>Functions for tracing and monitoring execution.</source>
          <target state="translated">実行をトレースしたり、監視したりするための機能</target>
        </trans-unit>
        <trans-unit id="16479fdb416d456904dff714b27125ccc720f7ec" translate="yes" xml:space="preserve">
          <source>Functions in the module &lt;code&gt;GHC.Stack&lt;/code&gt; can be used to get the current stack and render it.</source>
          <target state="translated">モジュール &lt;code&gt;GHC.Stack&lt;/code&gt; の関数を使用して、現在のスタックを取得してレンダリングできます。</target>
        </trans-unit>
        <trans-unit id="4b4538c6823abddd718b4a67c6f47e9707112536" translate="yes" xml:space="preserve">
          <source>Functions loaded from MAPI DLL</source>
          <target state="translated">MAPI DLLから読み込まれた関数</target>
        </trans-unit>
        <trans-unit id="991363ecbdab5aa793ffe2963ab2340e55ed7869" translate="yes" xml:space="preserve">
          <source>Functions on strings</source>
          <target state="translated">文字列の関数</target>
        </trans-unit>
        <trans-unit id="acd1d73a01569b4597b066ffad662bac0febbd6d" translate="yes" xml:space="preserve">
          <source>Functions on type literals</source>
          <target state="translated">型リテラルに関する関数</target>
        </trans-unit>
        <trans-unit id="eae4e0d01438335e190495d84c53f36a1091da41" translate="yes" xml:space="preserve">
          <source>Functions that can be fused by the compiler are documented with the phrase &quot;Subject to fusion&quot;.</source>
          <target state="translated">コンパイラでフュージョンできる関数は「Subject to fusion」というフレーズで文書化されています。</target>
        </trans-unit>
        <trans-unit id="bf76ba3ead8b51a76bd5375c7610a24216c56497" translate="yes" xml:space="preserve">
          <source>Functions used frequently when reading textual data.</source>
          <target state="translated">テキストデータを読み込むときによく使う関数</target>
        </trans-unit>
        <trans-unit id="bf5a0c8672a8cfdd38dd0c49de54779584af909e" translate="yes" xml:space="preserve">
          <source>Functor</source>
          <target state="translated">Functor</target>
        </trans-unit>
        <trans-unit id="4e092e6221592052ff27de9c36b604a94b3b2bfa" translate="yes" xml:space="preserve">
          <source>Functor and monad classes</source>
          <target state="translated">ファンクタとモナドクラス</target>
        </trans-unit>
        <trans-unit id="5d9b79097d152d34620f656052ce7bc908e4adee" translate="yes" xml:space="preserve">
          <source>Functors representing data structures that can be traversed from left to right, performing an action on each element.</source>
          <target state="translated">各要素に対してアクションを実行しながら、左から右へとトラバースすることができるデータ構造を表すファンクタ。</target>
        </trans-unit>
        <trans-unit id="de3a870c86fad9ae631a01eb1c00a47d95865fc9" translate="yes" xml:space="preserve">
          <source>Functors representing data structures that can be traversed from left to right.</source>
          <target state="translated">左から右へトラバースできるデータ構造を表す関数です。</target>
        </trans-unit>
        <trans-unit id="bbce868c145bac81161a114f3f858a43df4b009e" translate="yes" xml:space="preserve">
          <source>Further bindings can be added to this &lt;code&gt;let&lt;/code&gt; statement, so GHCi indicates that the next line continues the previous one by changing the prompt. Note that layout is in effect, so to add more bindings to this &lt;code&gt;let&lt;/code&gt; we have to line them up:</source>
          <target state="translated">この &lt;code&gt;let&lt;/code&gt; ステートメントにさらにバインディングを追加できるため、GHCiはプロンプトを変更することにより、次の行が前の行を継続することを示します。レイアウトが有効になっていることに注意してください。これにさらにバインディングを追加するには、それらを整列さ &lt;code&gt;let&lt;/code&gt; 必要があります。</target>
        </trans-unit>
        <trans-unit id="49fac13714bb93079e42783f2bb2ccb3989a542a" translate="yes" xml:space="preserve">
          <source>Further, any definition must satisfy the following:</source>
          <target state="translated">さらに、どのような定義であっても、以下の条件を満たさなければなりません。</target>
        </trans-unit>
        <trans-unit id="2d13054939bf42393691d74b91312a9380f6750a" translate="yes" xml:space="preserve">
          <source>Furthermore GHC lets you specify the way event log data (see &lt;a href=&quot;#rts-flag--l%20%E2%9F%A8flags%E2%9F%A9&quot;&gt;&lt;code&gt;-l
⟨flags⟩&lt;/code&gt;&lt;/a&gt;) is written through a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">さらに、GHCでは、カスタム&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; を&lt;/a&gt;介してイベントログデータ（&lt;a href=&quot;#rts-flag--l%20%E2%9F%A8flags%E2%9F%A9&quot;&gt; &lt;code&gt;-l ⟨flags⟩&lt;/code&gt; &lt;/a&gt;参照）を書き込む方法を指定できます。</target>
        </trans-unit>
        <trans-unit id="08da0d9c9c42c5828b70fcadcfc0cc2b4842f426" translate="yes" xml:space="preserve">
          <source>Furthermore GHC lets you specify the way event log data (see &lt;a href=&quot;profiling#rts-flag--l&quot;&gt;&lt;code&gt;-l&lt;/code&gt;&lt;/a&gt;) is written through a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">さらに、GHCでは、カスタム&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; を&lt;/a&gt;使用してイベントログデータ（&lt;a href=&quot;profiling#rts-flag--l&quot;&gt; &lt;code&gt;-l&lt;/code&gt; を&lt;/a&gt;参照）を書き込む方法を指定できます。</target>
        </trans-unit>
        <trans-unit id="66b3cc6f1053b257141eef62d3c7cec2ae3a9542" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt; do not obey the &lt;code&gt;forall&lt;/code&gt;-or-nothing rule when their type variables are not explicitly quantified:</source>
          <target state="translated">さらに、型変数が明示的に定量化されていない場合、&lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;書き換えルール&lt;/a&gt;は &lt;code&gt;forall&lt;/code&gt; -or-nothingルールに従いません。</target>
        </trans-unit>
        <trans-unit id="ec453e68989fa3914f8826d8c0c518b544aaa06f" translate="yes" xml:space="preserve">
          <source>Furthermore, GADT constructors do not permit outermost parentheses that surround the &lt;code&gt;opt_forall&lt;/code&gt; or &lt;code&gt;opt_ctxt&lt;/code&gt;, if at least one of them are used. For example, &lt;code&gt;MkU :: (forall a. a -&amp;gt; U)&lt;/code&gt; would be rejected, since it would treat the &lt;code&gt;forall&lt;/code&gt; as being nested.</source>
          <target state="translated">さらに、GADTコンストラクターは、 &lt;code&gt;opt_forall&lt;/code&gt; または &lt;code&gt;opt_ctxt&lt;/code&gt; の少なくとも1つが使用されている場合、それらを囲む最も外側の括弧を許可しません。たとえば、 &lt;code&gt;MkU :: (forall a. a -&amp;gt; U)&lt;/code&gt; は、 &lt;code&gt;forall&lt;/code&gt; がネストされているものとして扱われるため、拒否されます。</target>
        </trans-unit>
        <trans-unit id="20e7c89627716c573e1aa633f5ad999d25b91e8d" translate="yes" xml:space="preserve">
          <source>Furthermore, GHC offers a lightweight annotation mechanism that you can use to annotate your source code with metadata, which you can later inspect with either the compiler API or a compiler plugin.</source>
          <target state="translated">さらに、GHCは軽量なアノテーション機構を提供しており、ソースコードにメタデータをアノテーションして、後でコンパイラAPIやコンパイラプラグインを使って検査することができます。</target>
        </trans-unit>
        <trans-unit id="82324c0c7e914d3c23571245dd382b3b90349133" translate="yes" xml:space="preserve">
          <source>Furthermore, GHCi will print the result of the I/O action if (and only if):</source>
          <target state="translated">さらに、GHCiはI/Oアクションの結果を表示します。</target>
        </trans-unit>
        <trans-unit id="6db505903547bc2c8bcd995bca119457f6ba82f6" translate="yes" xml:space="preserve">
          <source>Furthermore, as sketched below, you may have big problems running programs compiled using unstable interfaces.</source>
          <target state="translated">さらに、以下にスケッチしたように、不安定なインターフェースを使ってコンパイルされたプログラムを実行すると、大きな問題が発生するかもしれません。</target>
        </trans-unit>
        <trans-unit id="cb2c15d21b992fb8a453c178e3d2d2c870eaaae3" translate="yes" xml:space="preserve">
          <source>Furthermore, distinct lexical type variables stand for distinct type variables. This means that every programmer-written type signature (including one that contains free scoped type variables) denotes a &lt;em&gt;rigid&lt;/em&gt; type; that is, the type is fully known to the type checker, and no inference is involved.</source>
          <target state="translated">さらに、特殊字句型変数は特殊型変数を表します。これは、プログラマーが作成したすべての型シグネチャ（スコープが自由な型変数を含むシグネチャを含む）が&lt;em&gt;厳密な&lt;/em&gt;型を表すことを意味します。つまり、型は型チェッカーに完全に認識されており、推論は行われません。</target>
        </trans-unit>
        <trans-unit id="80b236431e261295b1f5b32062e509044fb85c6f" translate="yes" xml:space="preserve">
          <source>Furthermore, for every type constructor there is an instance that allows to coerce under the type constructor. For example, let &lt;code&gt;D&lt;/code&gt; be a prototypical type constructor (&lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt;) with three type arguments, which have roles &lt;code&gt;nominal&lt;/code&gt;, &lt;code&gt;representational&lt;/code&gt; resp. &lt;code&gt;phantom&lt;/code&gt;. Then there is an instance of the form</source>
          <target state="translated">さらに、すべての型コンストラクターに対して、型コンストラクターの下で強制することを可能にするインスタンスがあります。例えば、聞かせて &lt;code&gt;D&lt;/code&gt; は原型型コンストラクタ（BE &lt;code&gt;data&lt;/code&gt; または &lt;code&gt;newtype&lt;/code&gt; の役割を持っている3種類の引数で） &lt;code&gt;nominal&lt;/code&gt; 、 &lt;code&gt;representational&lt;/code&gt; RESP。 &lt;code&gt;phantom&lt;/code&gt; 。次に、フォームのインスタンスがあります</target>
        </trans-unit>
        <trans-unit id="e69b97115f19d41bf37478c44ac8035f4b89ab99" translate="yes" xml:space="preserve">
          <source>Furthermore, instance declarations types do not permit outermost parentheses that surround the &lt;code&gt;opt_forall&lt;/code&gt; or &lt;code&gt;opt_ctxt&lt;/code&gt;, if at least one of them are used. For example, &lt;code&gt;instance (forall a. C a)&lt;/code&gt; would be rejected, since GHC would treat the &lt;code&gt;forall&lt;/code&gt; as being nested.</source>
          <target state="translated">さらに、インスタンス宣言タイプでは、 &lt;code&gt;opt_forall&lt;/code&gt; または &lt;code&gt;opt_ctxt&lt;/code&gt; の少なくとも1つが使用されている場合、それらを囲む最も外側の括弧は許可されません。たとえば、GHCは &lt;code&gt;forall&lt;/code&gt; をネストされているものとして扱うため、 &lt;code&gt;instance (forall a. C a)&lt;/code&gt; は拒否されます。</target>
        </trans-unit>
        <trans-unit id="406f927a9f4a120e269216ff8cb7178a7f5cb0c5" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">さらに、 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 演算と &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 演算は次のように関連している必要があります。</target>
        </trans-unit>
        <trans-unit id="dad09ada7622a5ff58effb3bd3aac868b8da28f5" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">さらに、 &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 演算と &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 演算は次のように関連している必要があります。</target>
        </trans-unit>
        <trans-unit id="6b37d25bdd8ec825cf9b78ad8552aaf509c01998" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-base#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">さらに、 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 演算と &lt;code&gt;&lt;a href=&quot;ghc-base#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 演算は次のように関連している必要があります。</target>
        </trans-unit>
        <trans-unit id="44ff1800f7634bcf2c0b0c914a264ded817850d3" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">さらに、 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 演算と &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 演算は次のように関連している必要があります。</target>
        </trans-unit>
        <trans-unit id="2cb5d14e799a2d7958a05582a6f9320def2c5536" translate="yes" xml:space="preserve">
          <source>Furthermore, the closing &lt;code&gt;#-}&lt;/code&gt; should start in a column to the right of the opening &lt;code&gt;{-#&lt;/code&gt;.</source>
          <target state="translated">さらに、終了 &lt;code&gt;#-}&lt;/code&gt; は、開始 &lt;code&gt;{-#&lt;/code&gt; の右側の列から開始する必要があります。</target>
        </trans-unit>
        <trans-unit id="fa16c9671ec072c0212b1b51c49a6c158062b0d0" translate="yes" xml:space="preserve">
          <source>Furthermore, type &lt;code&gt;t&lt;/code&gt; is constrained to have a &lt;code&gt;Typeable&lt;/code&gt; instance. The following are therefore illegal:</source>
          <target state="translated">さらに、型 &lt;code&gt;t&lt;/code&gt; は &lt;code&gt;Typeable&lt;/code&gt; インスタンスを持つように制約されています。したがって、以下は違法です。</target>
        </trans-unit>
        <trans-unit id="2081970b86a7491a8d3bcc2579c359ea225ff58b" translate="yes" xml:space="preserve">
          <source>Furthermore, we restrict the following features:</source>
          <target state="translated">さらに、以下のような特徴を制限しています。</target>
        </trans-unit>
        <trans-unit id="db033d11f970572cb3e9cddec9da0ae34cfa380a" translate="yes" xml:space="preserve">
          <source>Fusible &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;-oriented functions for converting between &lt;code&gt;Text&lt;/code&gt; and several common encodings.</source>
          <target state="translated">&lt;code&gt;Text&lt;/code&gt; といくつかの一般的なエンコーディングの間で変換するためのフュージブル &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; 指向の関数。</target>
        </trans-unit>
        <trans-unit id="a475567b5216c28471ecd6c4d8d53d3b335fb9fb" translate="yes" xml:space="preserve">
          <source>Fusible &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;-oriented functions for converting between lazy &lt;code&gt;Text&lt;/code&gt; and several common encodings.</source>
          <target state="translated">レイジー &lt;code&gt;Text&lt;/code&gt; といくつかの一般的なエンコーディングの間で変換するためのフュージブル &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; 指向の関数。</target>
        </trans-unit>
        <trans-unit id="cdf2e5fcd33e60c149dbaeb7315f4ef9de629849" translate="yes" xml:space="preserve">
          <source>Fusion</source>
          <target state="translated">Fusion</target>
        </trans-unit>
        <trans-unit id="159a326f6758bdce7f9997d0ada252499a6c2735" translate="yes" xml:space="preserve">
          <source>Future versions of &lt;code&gt;integer_gmp&lt;/code&gt; may not support negative &lt;code&gt;&lt;em&gt;e&lt;/em&gt;&lt;/code&gt; values anymore.</source>
          <target state="translated">&lt;code&gt;integer_gmp&lt;/code&gt; の将来のバージョンでは、負の &lt;code&gt;&lt;em&gt;e&lt;/em&gt;&lt;/code&gt; 値がサポートされなくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="ce2582f55bf244541fd784a5f9f776bd503eadbf" translate="yes" xml:space="preserve">
          <source>GADT constructor types are currently not permitted to have nested &lt;code&gt;forall&lt;/code&gt;s or &lt;code&gt;=&amp;gt;&lt;/code&gt;s. (e.g., something like &lt;code&gt;MkT :: Int -&amp;gt; forall a. a -&amp;gt; T&lt;/code&gt; would be rejected.) As a result, &lt;code&gt;gadt_sig&lt;/code&gt; puts all of its quantification and constraints up front with &lt;code&gt;opt_forall&lt;/code&gt; and &lt;code&gt;opt_context&lt;/code&gt;. Note that higher-rank &lt;code&gt;forall&lt;/code&gt;s and &lt;code&gt;=&amp;gt;&lt;/code&gt;s are only permitted if they do not appear directly to the right of a function arrow in a &lt;code&gt;prefix_gadt_body&lt;/code&gt;. (e.g., something like &lt;code&gt;MkS :: Int -&amp;gt; (forall a. a) -&amp;gt; S&lt;/code&gt; is allowed, since parentheses separate the &lt;code&gt;forall&lt;/code&gt; from the &lt;code&gt;-&amp;gt;&lt;/code&gt;.)</source>
          <target state="translated">GADTコンストラクタの種類は、現在ネストされていることが許可されていない &lt;code&gt;forall&lt;/code&gt; Sまたは &lt;code&gt;=&amp;gt;&lt;/code&gt; 秒。 （たとえば、 &lt;code&gt;MkT :: Int -&amp;gt; forall a. a -&amp;gt; T&lt;/code&gt; ようなものは拒否されます。）その結果、 &lt;code&gt;gadt_sig&lt;/code&gt; は、すべての数量化と制約を &lt;code&gt;opt_forall&lt;/code&gt; と &lt;code&gt;opt_context&lt;/code&gt; で前もって配置します。上位の &lt;code&gt;forall&lt;/code&gt; と &lt;code&gt;=&amp;gt;&lt;/code&gt; は、 &lt;code&gt;prefix_gadt_body&lt;/code&gt; の関数矢印の右側に直接表示されない場合にのみ許可されることに注意してください。 （たとえば、 &lt;code&gt;MkS :: Int -&amp;gt; (forall a. a) -&amp;gt; S&lt;/code&gt; が許可されます。これは、括弧が &lt;code&gt;forall&lt;/code&gt; を &lt;code&gt;-&amp;gt;&lt;/code&gt; から分離しているためです。）</target>
        </trans-unit>
        <trans-unit id="844bd170f572f4ec24f5e9600fd9f1281aa26e3c" translate="yes" xml:space="preserve">
          <source>GADT constructors are extra particular about their &lt;code&gt;forall&lt;/code&gt;s. In addition to adhering to the &lt;code&gt;forall&lt;/code&gt;-or-nothing rule, GADT constructors also forbid nested &lt;code&gt;forall&lt;/code&gt;s. For example, GHC would reject the following GADT:</source>
          <target state="translated">GADTコンストラクタは、その程度余分に特定されている &lt;code&gt;forall&lt;/code&gt; 秒。 &lt;code&gt;forall&lt;/code&gt; -or-nothingルールに準拠することに加えて、GADTコンストラクターはネストされた &lt;code&gt;forall&lt;/code&gt; を禁止します。たとえば、GHCは次のGADTを拒否します。</target>
        </trans-unit>
        <trans-unit id="5254c66df5fb20f0f8f5d6b6fad2ca033bf6a230" translate="yes" xml:space="preserve">
          <source>GADT-style data declarations may either bind their inputs or use an inline signature in addition to the standalone kind signature:</source>
          <target state="translated">GADTスタイルのデータ宣言は、入力をバインドするか、スタンドアロンの種類署名に加えてインライン署名を使用することができます。</target>
        </trans-unit>
        <trans-unit id="a55c9301ac576415d00c242a35c90cc869774f23" translate="yes" xml:space="preserve">
          <source>GADTSyntax</source>
          <target state="translated">GADTSyntax</target>
        </trans-unit>
        <trans-unit id="b91e38c288753eac615e73903fc03c7c3f13ec52" translate="yes" xml:space="preserve">
          <source>GADTs</source>
          <target state="translated">GADTs</target>
        </trans-unit>
        <trans-unit id="f31ea1a5194f51cb6d88f62e8060b3252067edcb" translate="yes" xml:space="preserve">
          <source>GBinaryGet</source>
          <target state="translated">GBinaryGet</target>
        </trans-unit>
        <trans-unit id="630e224c436c0a989f821b5b56c84b74804fbf46" translate="yes" xml:space="preserve">
          <source>GBinaryPut</source>
          <target state="translated">GBinaryPut</target>
        </trans-unit>
        <trans-unit id="7a52054f44519ad82fe4dc7c2dba3037f7ea46fd" translate="yes" xml:space="preserve">
          <source>GCC style response files.</source>
          <target state="translated">GCC スタイルのレスポンスファイル。</target>
        </trans-unit>
        <trans-unit id="9b8227183b46b7bedd6daac69544744f519a2020" translate="yes" xml:space="preserve">
          <source>GCDetails</source>
          <target state="translated">GCDetails</target>
        </trans-unit>
        <trans-unit id="1fb7f8ebd1ef6f3150ef633cd4b56e250a52dea9" translate="yes" xml:space="preserve">
          <source>GCFlags</source>
          <target state="translated">GCFlags</target>
        </trans-unit>
        <trans-unit id="726e40cb883acbb4ae39a6abc67af0f3d15c0557" translate="yes" xml:space="preserve">
          <source>GET_FILEEX_INFO_LEVELS</source>
          <target state="translated">GET_FILEEX_INFO_LEVELS</target>
        </trans-unit>
        <trans-unit id="4deab4e364b1f9987c532fb9308d3fa747de34eb" translate="yes" xml:space="preserve">
          <source>GHC</source>
          <target state="translated">GHC</target>
        </trans-unit>
        <trans-unit id="71e2fb25bf34a1d6ca4d0e65e2d0d3bee84e64bf" translate="yes" xml:space="preserve">
          <source>GHC (mostly) conforms to the Haskell Foreign Function Interface as specified in the Haskell Report. Refer to the &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch8.html&quot;&gt;relevant chapter&lt;/a&gt; of the Haskell Report for more details.</source>
          <target state="translated">GHCは（ほとんど）Haskellレポートで指定されているHaskell外部関数インターフェースに準拠しています。詳細については、Haskellレポートの&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch8.html&quot;&gt;関連する章&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f8b0fde53dfe6ccde028a6e0d7a726451f64e9f6" translate="yes" xml:space="preserve">
          <source>GHC (mostly) conforms to the Haskell Foreign Function Interface, whose definition is part of the Haskell Report on &lt;a href=&quot;http://www.haskell.org/&quot;&gt;http://www.haskell.org/&lt;/a&gt;.</source>
          <target state="translated">GHCは（主に）Haskell外部関数インターフェースに準拠しており、その定義は&lt;a href=&quot;http://www.haskell.org/&quot;&gt;http://www.haskell.org/の&lt;/a&gt; Haskell Reportの一部です。</target>
        </trans-unit>
        <trans-unit id="0064178248eb2eacd8d3ac6bab315de2aca56d04" translate="yes" xml:space="preserve">
          <source>GHC (with &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, as always) tries to inline (or &amp;ldquo;unfold&amp;rdquo;) functions/values that are &amp;ldquo;small enough,&amp;rdquo; thus avoiding the call overhead and possibly exposing other more-wonderful optimisations. GHC has a set of heuristics, tuned over a long period of time using many benchmarks, that decide when it is beneficial to inline a function at its call site. The heuristics are designed to inline functions when it appears to be beneficial to do so, but without incurring excessive code bloat. If a function looks too big, it won&amp;rsquo;t be inlined, and functions larger than a certain size will not even have their definition exported in the interface file. Some of the thresholds that govern these heuristic decisions can be changed using flags, see &lt;a href=&quot;../using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;.</source>
          <target state="translated">GHC（いつものように&lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;を使用）は、「十分に小さい」関数/値をインライン化（​​または「展開」）しようとするため、呼び出しのオーバーヘッドを回避し、他のよりすばらしい最適化を公開する可能性があります。 GHCには、多くのベンチマークを使用して長期間にわたって調整された一連のヒューリスティックがあり、呼び出しサイトで関数をインライン化することが有益な場合を決定します。ヒューリスティックは、インライン化することが有益であると思われる場合に関数をインライン化するように設計されていますが、過度のコード膨張を招くことはありません。関数が大きすぎるように見える場合、インライン化されず、特定のサイズを超える関数の定義はインターフェイスファイルにエクスポートされません。これらのヒューリスティックな決定を管理するしきい値のいくつかは、フラグを使用して変更できます。&lt;a href=&quot;../using-optimisation#options-f&quot;&gt;-f*：プラットフォームに依存しないフラグを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="71a795962bc4f20caecc626cc98073806d56af3d" translate="yes" xml:space="preserve">
          <source>GHC (with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, as always) tries to inline (or &amp;ldquo;unfold&amp;rdquo;) functions/values that are &amp;ldquo;small enough,&amp;rdquo; thus avoiding the call overhead and possibly exposing other more-wonderful optimisations. GHC has a set of heuristics, tuned over a long period of time using many benchmarks, that decide when it is beneficial to inline a function at its call site. The heuristics are designed to inline functions when it appears to be beneficial to do so, but without incurring excessive code bloat. If a function looks too big, it won&amp;rsquo;t be inlined, and functions larger than a certain size will not even have their definition exported in the interface file. Some of the thresholds that govern these heuristic decisions can be changed using flags, see &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;.</source>
          <target state="translated">GHC（いつものように&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;を使用）は、「十分に小さい」関数/値をインライン化（​​または「展開」）しようとするため、呼び出しのオーバーヘッドを回避し、おそらく他のより素晴らしい最適化を公開します。 GHCには、多くのベンチマークを使用して長期間にわたって調整された一連のヒューリスティックがあり、呼び出しサイトで関数をインライン化することが有益な場合を決定します。ヒューリスティックは、それが有益であると思われる場合に関数をインライン化するように設計されていますが、過度のコード膨張を招くことはありません。関数が大きすぎるように見える場合、関数はインライン化されず、特定のサイズよりも大きい関数は、その定義がインターフェイスファイルにエクスポートされません。これらのヒューリスティックな決定を管理するしきい値の一部は、フラグを使用して変更できます。&lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f *：プラットフォームに依存しないフラグを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="bd5aeb70f3062d7e5273699b9f6ad00fc86027b7" translate="yes" xml:space="preserve">
          <source>GHC 7.8 can evaluate arithmetic expressions involving type-level natural numbers. Such expressions may be constructed using the type-families &lt;code&gt;(+), (*), (^)&lt;/code&gt; for addition, multiplication, and exponentiation. Numbers may be compared using &lt;code&gt;(&amp;lt;=?)&lt;/code&gt;, which returns a promoted boolean value, or &lt;code&gt;(&amp;lt;=)&lt;/code&gt;, which compares numbers as a constraint. For example:</source>
          <target state="translated">GHC 7.8は、型レベルの自然数を含む算術式を評価できます。そのような式は、加算、乗算、および累乗のタイプファミリー &lt;code&gt;(+), (*), (^)&lt;/code&gt; を使用して構築できます。数値は、昇格されたブール値を返す &lt;code&gt;(&amp;lt;=?)&lt;/code&gt; または &lt;code&gt;(&amp;lt;=)&lt;/code&gt; を使用して比較できます。これは、数値を制約として比較します。例えば：</target>
        </trans-unit>
        <trans-unit id="93d695e035decd28303f08218eaa7d61529f41ac" translate="yes" xml:space="preserve">
          <source>GHC 8 extends the idea of kind polymorphism by declaring that types and kinds are indeed one and the same. Nothing within GHC distinguishes between types and kinds. Another way of thinking about this is that the type &lt;code&gt;Bool&lt;/code&gt; and the &amp;ldquo;promoted kind&amp;rdquo; &lt;code&gt;Bool&lt;/code&gt; are actually identical. (Note that term &lt;code&gt;True&lt;/code&gt; and the type &lt;code&gt;'True&lt;/code&gt; are still distinct, because the former can be used in expressions and the latter in types.) This lack of distinction between types and kinds is a hallmark of dependently typed languages. Full dependently typed languages also remove the difference between expressions and types, but doing that in GHC is a story for another day.</source>
          <target state="translated">GHC 8は、種類と種類が実際にまったく同じであることを宣言することにより、種類ポリモーフィズムの概念を拡張します。 GHC内でタイプと種類を区別するものはありません。これについてのもう1つの考え方は、 &lt;code&gt;Bool&lt;/code&gt; 型と「昇格された種類」 &lt;code&gt;Bool&lt;/code&gt; は実際には同一であるということです。 （前者は式で使用でき、後者はタイプで使用できるため、 &lt;code&gt;True&lt;/code&gt; という用語と &lt;code&gt;'True&lt;/code&gt; というタイプはまだ区別されます。）このタイプと種類の区別がないことは、依存型付け言語の特徴です。完全に依存型付けされた言語も式と型の違いを取り除きますが、GHCでそれを行うことは別の日の話です。</target>
        </trans-unit>
        <trans-unit id="83ef026940faed1f89548023088d18a255245d64" translate="yes" xml:space="preserve">
          <source>GHC 8.2 supports module signatures (&lt;code&gt;hsig&lt;/code&gt; files), which allow you to write a signature in place of a module implementation, deferring the choice of implementation until a later point in time. This feature is not intended to be used without &lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;; this manual entry will focus on the syntax and semantics of signatures.</source>
          <target state="translated">GHC 8.2はモジュール署名（ &lt;code&gt;hsig&lt;/code&gt; ファイル）をサポートします。これにより、モジュール実装の代わりに署名を記述して、実装の選択を後の時点まで延期することができます。この機能は&lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;なしで使用するためのものではありません。この手動エントリは、署名の構文とセマンティクスに焦点を当てています。</target>
        </trans-unit>
        <trans-unit id="078f9d9639e0226176f8bd445a4da3cf27270446" translate="yes" xml:space="preserve">
          <source>GHC 8.2 supports module signatures (&lt;code&gt;hsig&lt;/code&gt; files), which allow you to write a signature in place of a module implementation, deferring the choice of implementation until a later point in time. This feature is not intended to be used without &lt;a href=&quot;https://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;; this manual entry will focus on the syntax and semantics of signatures.</source>
          <target state="translated">GHC 8.2は、モジュール署名（ &lt;code&gt;hsig&lt;/code&gt; ファイル）をサポートしています。これにより、モジュール実装の代わりに署名を記述して、実装の選択を後の時点まで延期することができます。この機能は、&lt;a href=&quot;https://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;なしで使用することを目的としたものではありません。この手動エントリでは、署名の構文とセマンティクスに焦点を当てます。</target>
        </trans-unit>
        <trans-unit id="6a35186132a8c1a5f44b29b9623541079c426c64" translate="yes" xml:space="preserve">
          <source>GHC Extensions: this is the Approved Way to get at GHC-specific extensions.</source>
          <target state="translated">GHCエクステンション:これがGHC固有のエクステンションを手に入れるための承認済みの方法です。</target>
        </trans-unit>
        <trans-unit id="abcf3ed735387a1fc13551630355fd6051450c51" translate="yes" xml:space="preserve">
          <source>GHC Note: in order to call &lt;code&gt;waitForProcess&lt;/code&gt; without blocking all the other threads in the system, you must compile the program with &lt;code&gt;-threaded&lt;/code&gt;.</source>
          <target state="translated">GHC注：システム内の他のすべてのスレッドをブロックせずに &lt;code&gt;waitForProcess&lt;/code&gt; を呼び出すには、 &lt;code&gt;-threaded&lt;/code&gt; を使用してプログラムをコンパイルする必要があります。</target>
        </trans-unit>
        <trans-unit id="9ef7fdb5e004e11962f2db47b8f53e696192e47e" translate="yes" xml:space="preserve">
          <source>GHC adopts &lt;strong&gt;Reject if in doubt&lt;/strong&gt; for now. We can see how painful it is in practice, and try something more ambitious if necessary.</source>
          <target state="translated">今のところ&lt;strong&gt;疑わしい場合、&lt;/strong&gt; GHCは&lt;strong&gt;拒否を&lt;/strong&gt;採用します。実際にどれほど苦しいかがわかり、必要に応じてより野心的なことを試すことができます。</target>
        </trans-unit>
        <trans-unit id="41082220042afac899ff2b83b24c9b3630d70113" translate="yes" xml:space="preserve">
          <source>GHC allocates a small amount of thread-local memory when a thread calls a Haskell function via a &lt;code&gt;foreign export&lt;/code&gt;. This memory is not normally freed until &lt;code&gt;hs_exit()&lt;/code&gt;; the memory is cached so that subsequent calls into Haskell are fast. However, if your application is long-running and repeatedly creates new threads that call into Haskell, you probably want to arrange that this memory is freed in those threads that have finished calling Haskell functions. To do this, call &lt;code&gt;hs_thread_done()&lt;/code&gt; from the thread whose memory you want to free.</source>
          <target state="translated">スレッドが &lt;code&gt;foreign export&lt;/code&gt; 介してHaskell関数を呼び出すと、GHCは少量のスレッドローカルメモリを割り当てます。このメモリは通常、 &lt;code&gt;hs_exit()&lt;/code&gt; まで解放されません。メモリはキャッシュされるため、Haskellへの以降の呼び出しは高速になります。ただし、アプリケーションが長時間実行され、Haskellを呼び出す新しいスレッドを繰り返し作成する場合は、Haskell関数の呼び出しを終了したスレッドでこのメモリが解放されるように調整する必要があります。これを行うには、メモリを解放するスレッドから &lt;code&gt;hs_thread_done()&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="1bfd38ebcc64be5e8d02f6d23ecc2c6046c1c0fd" translate="yes" xml:space="preserve">
          <source>GHC allows existentials to be used with records syntax as well. For example:</source>
          <target state="translated">GHCでは、レコード構文でも実存値を使用することができます。例えば</target>
        </trans-unit>
        <trans-unit id="7c1ae7a2aaa5f27ea408c81b882456db054bdf4d" translate="yes" xml:space="preserve">
          <source>GHC allows for numeric literals to be given in decimal, octal, hexadecimal, binary, or float notation.</source>
          <target state="translated">GHCでは、数値リテラルを10進法、8進法、16進法、2進法、またはfloat表記で与えることができます。</target>
        </trans-unit>
        <trans-unit id="b980cf594e963e0e8219b555b4d47dab40b3eb42" translate="yes" xml:space="preserve">
          <source>GHC allows stand-alone &lt;code&gt;deriving&lt;/code&gt; declarations, enabled by &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">GHCは、&lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;StandaloneDeriving&lt;/code&gt; &lt;/a&gt;によって有効化されたスタンドアロンの &lt;code&gt;deriving&lt;/code&gt; 宣言を許可します。</target>
        </trans-unit>
        <trans-unit id="8296b4add8c32598594b426a3d8785f116cea0b4" translate="yes" xml:space="preserve">
          <source>GHC allows type constructors, classes, and type variables to be operators, and to be written infix, very much like expressions. More specifically:</source>
          <target state="translated">GHCでは、型のコンストラクタ、クラス、型変数を演算子にすることができ、式のようにインフィックスで書くことができます。より具体的には</target>
        </trans-unit>
        <trans-unit id="eb4326185e022f2904a00d722e6d3c8a8c919585" translate="yes" xml:space="preserve">
          <source>GHC also permits visible kind application, where users can declare the kind arguments to be instantiated in kind-polymorphic cases. Its usage parallels visible type application in the term level, as specified above.</source>
          <target state="translated">GHCは可視型の適用も許可しており、ユーザは親切ポリモーフィックなケースでインスタンス化される親切引数を宣言することができます。この使用法は、上で指定したように、用語レベルでの可視型アプリケーションと同等です。</target>
        </trans-unit>
        <trans-unit id="e0505316426448a3c6e8360de65d79da12c2648e" translate="yes" xml:space="preserve">
          <source>GHC also supports &lt;em&gt;kind-heterogeneous&lt;/em&gt; equality, which relates two types of potentially different kinds. Heterogeneous equality is spelled &lt;code&gt;~~&lt;/code&gt;. Here are the kinds of &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~~&lt;/code&gt; to better understand their difference:</source>
          <target state="translated">GHCもサポートしています&lt;em&gt;種類、異種&lt;/em&gt;潜在的に異なる種類の2種類に関する平等を、。異種の平等は &lt;code&gt;~~&lt;/code&gt; と綴られます。 &lt;code&gt;~&lt;/code&gt; と &lt;code&gt;~~&lt;/code&gt; の種類を以下に示し、それらの違いをよりよく理解します。</target>
        </trans-unit>
        <trans-unit id="ba76d7ceb7b661bae37e18ce6f07732378f6626a" translate="yes" xml:space="preserve">
          <source>GHC always treats the &lt;em&gt;last&lt;/em&gt; parameter of the instance (&lt;code&gt;Foo&lt;/code&gt; in this example) as the type whose instance is being derived.</source>
          <target state="translated">GHCは常にインスタンスの&lt;em&gt;最後の&lt;/em&gt;パラメーター（この例では &lt;code&gt;Foo&lt;/code&gt; ）を、インスタンスが派生する型として扱います。</target>
        </trans-unit>
        <trans-unit id="3c323be157c96acdab287f807375f9b719b64a63" translate="yes" xml:space="preserve">
          <source>GHC applies the dreaded Monomorphism Restriction (section 4.5.5 of the Haskell Report) to implicit parameters. For example, consider:</source>
          <target state="translated">GHCは、暗黙のパラメータに恐ろしいMonomorphism Restriction(Haskellレポートの4.5.5節)を適用します。例えば、次のように考えてみてください。</target>
        </trans-unit>
        <trans-unit id="085bc7758e841a7674950854ea86b028e0155c10" translate="yes" xml:space="preserve">
          <source>GHC assumes that source files are ASCII or UTF-8 only, other encoding are not recognised. However, invalid UTF-8 sequences will be ignored in comments, so it is possible to use other encodings such as Latin-1, as long as the non-comment source code is ASCII only.</source>
          <target state="translated">GHCはソースファイルがASCIIかUTF-8のみであることを前提としており、他のエンコーディングは認識されません。しかし、無効なUTF-8配列はコメントでは無視されますので、コメントのないソースコードがASCIIのみであれば、Latin-1のような他のエンコーディングを使用することが可能です。</target>
        </trans-unit>
        <trans-unit id="db91b54c27a7f2bcbfa6b8c3b3b4820b8e9289ae" translate="yes" xml:space="preserve">
          <source>GHC attempts to detect when threads are deadlocked using the garbage collector. A thread that is not reachable (cannot be found by following pointers from live objects) must be deadlocked, and in this case the thread is sent an exception. The exception is either &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt;, depending on the way in which the thread is deadlocked.</source>
          <target state="translated">GHCは、ガベージコレクターを使用してスレッドがデッドロックされたことを検出しようとします。到達できないスレッド（ライブオブジェクトからのポインターをたどっても見つからない）はデッドロックする必要があり、この場合、スレッドには例外が送信されます。例外は、スレッドがデッドロックされる方法に応じて、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt; のいずれかです。</target>
        </trans-unit>
        <trans-unit id="3d3ac693ce7ba01fac9e81d67e5485761f5520b6" translate="yes" xml:space="preserve">
          <source>GHC attempts to detect when threads are deadlocked using the garbage collector. A thread that is not reachable (cannot be found by following pointers from live objects) must be deadlocked, and in this case the thread is sent an exception. The exception is either &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt;, depending on the way in which the thread is deadlocked.</source>
          <target state="translated">GHCは、ガベージコレクターを使用してスレッドがデッドロックになったことを検出しようとします。到達不能なスレッド（ライブオブジェクトからのポインタを追跡しても見つからない）はデッドロックする必要があり、この場合、スレッドには例外が送信されます。例外は、スレッドのデッドロックの方法に応じて、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt; のいずれかです。</target>
        </trans-unit>
        <trans-unit id="c272c9b0ad07c2ab3a7ed8c9cf27b583eb6bbea9" translate="yes" xml:space="preserve">
          <source>GHC attempts to detect when threads are deadlocked using the garbage collector. A thread that is not reachable (cannot be found by following pointers from live objects) must be deadlocked, and in this case the thread is sent an exception. The exception is either &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt;, depending on the way in which the thread is deadlocked.</source>
          <target state="translated">GHCは、ガベージコレクターを使用してスレッドがデッドロックされたことを検出しようとします。到達できないスレッド（ライブオブジェクトからのポインターをたどっても見つからない）はデッドロックする必要があり、この場合、スレッドには例外が送信されます。例外は、スレッドがデッドロックされる方法に応じて、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt; のいずれかです。</target>
        </trans-unit>
        <trans-unit id="51e22a881769a40b9be873a2cbaae3065ee10a9c" translate="yes" xml:space="preserve">
          <source>GHC builds up a wealth of information about a Haskell source file as it compiles it. Extended interface files are a way of persisting some of this information to disk so that external tools, such as IDE&amp;rsquo;s, can avoid parsing, typechecking, and renaming all over again. These files contain</source>
          <target state="translated">GHCは、コンパイル時にHaskellソースファイルに関する豊富な情報を蓄積します。拡張インターフェースファイルは、この情報の一部をディスクに永続化する方法であり、IDEなどの外部ツールが解析、タイプチェック、名前変更を何度も回避できるようにします。これらのファイルには</target>
        </trans-unit>
        <trans-unit id="95040b8ff0496443822f0456826fbfe3fd01b8e2" translate="yes" xml:space="preserve">
          <source>GHC calculates a fingerprint (in fact an MD5 hash) of each interface file, and of each declaration within the interface file. It also keeps in every interface file a list of the fingerprints of everything it used when it last compiled the file. If the source file&amp;rsquo;s modification date is earlier than the &lt;code&gt;.o&lt;/code&gt; file&amp;rsquo;s date (i.e. the source hasn&amp;rsquo;t changed since the file was last compiled), and the recompilation checking is on, GHC will be clever. It compares the fingerprints on the things it needs this time with the fingerprints on the things it needed last time (gleaned from the interface file of the module being compiled); if they are all the same it stops compiling early in the process saying &amp;ldquo;Compilation IS NOT required&amp;rdquo;. What a beautiful sight!</source>
          <target state="translated">GHCは、各インターフェースファイル、およびインターフェースファイル内の各宣言のフィンガープリント（実際にはMD5ハッシュ）を計算します。また、最後にファイルをコンパイルしたときに使用したすべてのフィンガープリントのリストをすべてのインターフェイスファイルに保存します。ソースファイルの変更日が &lt;code&gt;.o&lt;/code&gt; ファイルの日付より前（つまり、ファイルが最後にコンパイルされてからソースが変更されていない）で、再コンパイルチェックがオンになっている場合、GHCは賢くなります。今回必要なもののフィンガープリントと前回必要なもののフィンガープリントを比較します（コンパイルされるモジュールのインターフェースファイルから収集）。それらがすべて同じである場合、プロセスの早い段階で「コンパイルは不要」と言ってコンパイルを停止します。なんて美しい光景でしょう！</target>
        </trans-unit>
        <trans-unit id="7db002a47d7a1c542bad6dcda111e3df7de5d2cf" translate="yes" xml:space="preserve">
          <source>GHC can also be configured using environment variables. Currently the only variable it supports is &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt;, which, when set, disables Unicode output regardless of locale settings. &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt; can be set to anything +(event an empty string) to trigger this behaviour.</source>
          <target state="translated">GHCは、環境変数を使用して構成することもできます。現在サポートされている変数は &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt; のみです。これを設定すると、ロケール設定に関係なくUnicode出力が無効になります。 &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt; は、この動作をトリガーするために任意の+（空の文字列のイベント）に設定できます。</target>
        </trans-unit>
        <trans-unit id="6a07d417f72643413044febaee57f46f8892bf38" translate="yes" xml:space="preserve">
          <source>GHC can be quite a bit more aggressive with pieces of code if it knows they are not exported.</source>
          <target state="translated">GHC は、コードがエクスポートされていないことを知っていれば、コードの断片に対してかなり攻撃的になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="20b3fdac58effb1981a662cd5b9d15a2246601cf" translate="yes" xml:space="preserve">
          <source>GHC comes with a number of libraries. These are described in separate documentation.</source>
          <target state="translated">GHCには多くのライブラリが付属しています。これらについては別のドキュメントで説明しています。</target>
        </trans-unit>
        <trans-unit id="e04da29f82d35f8657a7c056280732b0f61a3942" translate="yes" xml:space="preserve">
          <source>GHC comes with a time and space profiling system, so that you can answer questions like &amp;ldquo;why is my program so slow?&amp;rdquo;, or &amp;ldquo;why is my program using so much memory?&amp;rdquo;.</source>
          <target state="translated">GHCには時間と空間のプロファイリングシステムが付属しているため、「プログラムがなぜ遅いのか」や「プログラムがメモリを大量に使用しているのはなぜですか」などの質問に答えることができます。</target>
        </trans-unit>
        <trans-unit id="da055bb0f39bef03c75247c94877951076bed2b9" translate="yes" xml:space="preserve">
          <source>GHC compiles some program constructs slowly:</source>
          <target state="translated">GHCは、いくつかのプログラム構成をゆっくりとコンパイルします。</target>
        </trans-unit>
        <trans-unit id="de2e40df6054756a65674cc009e4351de51b3690" translate="yes" xml:space="preserve">
          <source>GHC completely ignores the floating-point environment, the runtime neither modifies nor reads it.</source>
          <target state="translated">GHCは浮動小数点環境を完全に無視し、ランタイムはそれを修正も読み込みもしません。</target>
        </trans-unit>
        <trans-unit id="549d84269c7b3028d7034e66451015b450c55e63" translate="yes" xml:space="preserve">
          <source>GHC creates a subdirectory &lt;code&gt;.hpc&lt;/code&gt; in the current directory, and puts HPC index (&lt;code&gt;.mix&lt;/code&gt;) files in there, one for each module compiled. You don&amp;rsquo;t need to worry about these files: they contain information needed by the &lt;code&gt;hpc&lt;/code&gt; tool to generate the coverage data for compiled modules after the program is run.</source>
          <target state="translated">GHCは現在のディレクトリにサブディレクトリ &lt;code&gt;.hpc&lt;/code&gt; を作成し、そこにHPCインデックス（ &lt;code&gt;.mix&lt;/code&gt; ）ファイルを、コンパイルされたモジュールごとに1つ配置します。これらのファイルについて心配する必要はありません。これらのファイルには、プログラムの実行後にコンパイルされたモジュールのカバレッジデータを生成するために &lt;code&gt;hpc&lt;/code&gt; ツールが必要とする情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="704d8fd09c4c661d97d55003569a629d6a64a062" translate="yes" xml:space="preserve">
          <source>GHC currently does kind checking before expanding synonyms (though even that could be changed).</source>
          <target state="translated">GHC は現在、同義語を展開する前に kind チェックを行っています (それさえも変更可能ですが)。</target>
        </trans-unit>
        <trans-unit id="d5c2a962ee75e672cc63c1570d298f7423d987d4" translate="yes" xml:space="preserve">
          <source>GHC currently uses a very simple, syntactic, matching algorithm for matching a rule LHS with an expression. It seeks a substitution which makes the LHS and expression syntactically equal modulo alpha conversion. The pattern (rule), but not the expression, is eta-expanded if necessary. (Eta-expanding the expression can lead to laziness bugs.) But not beta conversion (that&amp;rsquo;s called higher-order matching).</source>
          <target state="translated">GHCは現在、ルールLHSを式と照合するために、非常にシンプルで構文的な照合アルゴリズムを使用しています。これは、LHSと式を構文的に等しいモジュロアルファ変換にする置換を求めます。パターン（ルール）は、式ではなく、必要に応じてeta展開されます。（式をイータ展開すると、遅延バグが発生する可能性があります。）ベータ変換（高次マッチングと呼ばれます）ではありません。</target>
        </trans-unit>
        <trans-unit id="ef6d67c2bca6e1b47545829cfc42b1d411dd7f6d" translate="yes" xml:space="preserve">
          <source>GHC disambiguates between multiple &lt;code&gt;COMPLETE&lt;/code&gt; sets based on this rationale. To make things more formal, when the pattern-match checker requests a set of constructors for some data type constructor &lt;code&gt;T&lt;/code&gt;, the checker returns:</source>
          <target state="translated">GHCは、この理論的根拠に基づいて、複数の &lt;code&gt;COMPLETE&lt;/code&gt; セット間を明確にします。より形式的にするために、パターン一致チェッカーがいくつかのデータ型コンストラクタ &lt;code&gt;T&lt;/code&gt; のコンストラクタのセットを要求すると、チェッカーは次を返します。</target>
        </trans-unit>
        <trans-unit id="bd05d936e9882b073172126b6706e5f4c689fb33" translate="yes" xml:space="preserve">
          <source>GHC discharges the constraint as soon as it knows what concrete type-level literal is being used in the program. Note that this works only for &lt;em&gt;literals&lt;/em&gt; and not arbitrary type expressions. For example, a constraint of the form &lt;code&gt;KnownNat (a + b)&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; be simplified to &lt;code&gt;(KnownNat a, KnownNat b)&lt;/code&gt;; instead, GHC will keep the constraint as is, until it can simplify &lt;code&gt;a + b&lt;/code&gt; to a constant value.</source>
          <target state="translated">GHCは、プログラムで使用されている具体的な型レベルのリテラルがわかるとすぐに、制約を解除します。これは&lt;em&gt;リテラル&lt;/em&gt;でのみ機能し、任意の型式では機能しないことに注意してください。例えば、形状の制約は &lt;code&gt;KnownNat (a + b)&lt;/code&gt; だろう&lt;em&gt;ない&lt;/em&gt;ように簡略化すること &lt;code&gt;(KnownNat a, KnownNat b)&lt;/code&gt; 。代わりに、GHCは &lt;code&gt;a + b&lt;/code&gt; を定数値に簡略化できるまで、制約をそのまま保持します。</target>
        </trans-unit>
        <trans-unit id="167343e68b8bf1a9e7ec5d0c5832fa2540cf35a0" translate="yes" xml:space="preserve">
          <source>GHC does not allow you to have a data type with a context that mentions type variables that are not data type parameters. For example:</source>
          <target state="translated">GHCでは、データ型パラメータではない型変数を言及するコンテキストを持つデータ型を持つことはできません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="b579c8b8d2f4a7ab2a00594e0e2267c4041770d7" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t do the fixity resolution in expressions during parsing as required by Haskell 98 (but not by Haskell 2010). For example, according to the Haskell 98 report, the following expression is legal:</source>
          <target state="translated">GHCは、Haskell 98で必要とされる（Haskell 2010では要求されない）構文解析中に式の固定解決を行いません。たとえば、Haskell 98のレポートによると、次の式は有効です。</target>
        </trans-unit>
        <trans-unit id="8769daf9bb42ddf2fdd9c103027d5dea23101781" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t have to be restarted for each compilation, which means it can cache information between compilations. Compiling a multi-module program with &lt;code&gt;ghc --make&lt;/code&gt; can be up to twice as fast as running &lt;code&gt;ghc&lt;/code&gt; individually on each source file.</source>
          <target state="translated">GHCはコンパイルごとに再起動する必要はありません。つまり、コンパイル間で情報をキャッシュできます。 &lt;code&gt;ghc --make&lt;/code&gt; を使用してマルチモジュールプログラムをコンパイルすると、各ソースファイルで個別に &lt;code&gt;ghc&lt;/code&gt; を実行する場合の最大2倍の速度で実行できます。</target>
        </trans-unit>
        <trans-unit id="7fc5be5c4ca5725b6d97a12bfd6fd11cb070f451" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t implement complete full laziness. Although GHC&amp;rsquo;s full-laziness optimisation does enable some transformations which would be performed by a fully lazy implementation (such as extracting repeated computations from loops), these transformations are not applied consistently, so don&amp;rsquo;t rely on them.</source>
          <target state="translated">GHCは完全な完全な怠惰を実装していません。GHCの完全怠惰最適化は、完全怠惰な実装によって実行されるいくつかの変換（ループからの繰り返し計算の抽出など）を可能にしますが、これらの変換は一貫して適用されないため、それらに依存しないでください。</target>
        </trans-unit>
        <trans-unit id="f91f388f5cbc4088b94a5ec84cec7c04e6042e38" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t implement complete full-laziness. When optimisation in on, and &lt;code&gt;-fno-full-laziness&lt;/code&gt; is not given, some transformations that increase sharing are performed, such as extracting repeated computations from a loop. These are the same transformations that a fully lazy implementation would do, the difference is that GHC doesn&amp;rsquo;t consistently apply full-laziness, so don&amp;rsquo;t rely on it.</source>
          <target state="translated">GHCは完全な怠惰を実装していません。onと &lt;code&gt;-fno-full-laziness&lt;/code&gt; の最適化が指定されていない場合、ループから繰り返し計算を抽出するなど、共有を増やすいくつかの変換が実行されます。これらは、完全に遅延した実装が行うのと同じ変換です。違いは、GHCが一貫して完全遅延を適用しないため、それに依存しないことです。</target>
        </trans-unit>
        <trans-unit id="bfe0f580bb15aa44cde9df1fbad436113357809b" translate="yes" xml:space="preserve">
          <source>GHC ensures that inlining cannot go on forever: every mutually-recursive group is cut by one or more &lt;em&gt;loop breakers&lt;/em&gt; that is never inlined (see &lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm&quot;&gt;Secrets of the GHC inliner, JFP 12(4) July 2002&lt;/a&gt;). GHC tries not to select a function with an &lt;code&gt;INLINE&lt;/code&gt; pragma as a loop breaker, but when there is no choice even an INLINE function can be selected, in which case the &lt;code&gt;INLINE&lt;/code&gt; pragma is ignored. For example, for a self-recursive function, the loop breaker can only be the function itself, so an &lt;code&gt;INLINE&lt;/code&gt; pragma is always ignored.</source>
          <target state="translated">GHCはインライン化が永遠に続くことができないことを保証します：相互再帰的なグループはすべて、インライン化されない1つ以上の&lt;em&gt;ループブレーカー&lt;/em&gt;によってカットされ&lt;em&gt;ます&lt;/em&gt;（&lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm&quot;&gt;GHCインラ​​イナーの秘密、JFP 12（4）2002年7月を&lt;/a&gt;参照）。 GHCは、 &lt;code&gt;INLINE&lt;/code&gt; プラグマを含む関数をループブレーカーとして選択しないようにしますが、選択できない場合は、INLINE関数も選択できます。この場合、 &lt;code&gt;INLINE&lt;/code&gt; プラグマは無視されます。たとえば、自己再帰関数の場合、ループブレーカーは関数自体にしかできないため、 &lt;code&gt;INLINE&lt;/code&gt; プラグマは常に無視されます。</target>
        </trans-unit>
        <trans-unit id="d1e987d1c3d82c8013500d719ac2e258ed684a94" translate="yes" xml:space="preserve">
          <source>GHC exposes its internal APIs to users through the built-in ghc package. It allows you to write programs that leverage GHC&amp;rsquo;s entire compilation driver, in order to analyze or compile Haskell code programmatically. Furthermore, GHC gives users the ability to load compiler plugins during compilation - modules which are allowed to view and change GHC&amp;rsquo;s internal intermediate representation, Core. Plugins are suitable for things like experimental optimizations or analysis, and offer a lower barrier of entry to compiler development for many common cases.</source>
          <target state="translated">GHCは、組み込みのghcパッケージを通じてユーザーに内部APIを公開します。これにより、プログラムでHaskellコードを分析またはコンパイルするために、GHCのコンパイルドライバ全体を活用するプログラムを作成できます。さらに、GHCはコンパイル中にコンパイラプラグインをロードする機能をユーザーに提供します-GHCの内部中間表現であるCoreを表示および変更することが許可されているモジュール。プラグインは、実験的な最適化や分析などに適し、多くの一般的なケースでコンパイラ開発への参入障壁を低くします。</target>
        </trans-unit>
        <trans-unit id="7c167fa8597da83d2d6c70ee64cf8fd148a64239" translate="yes" xml:space="preserve">
          <source>GHC extends the FFI with an additional calling convention &lt;code&gt;prim&lt;/code&gt;, e.g.:</source>
          <target state="translated">GHCは追加の呼び出し規約 &lt;code&gt;prim&lt;/code&gt; でFFIを拡張します。例：</target>
        </trans-unit>
        <trans-unit id="2709b25bb09f206c0b1acccbf37562ea657795ca" translate="yes" xml:space="preserve">
          <source>GHC extends this list with several more classes that may be automatically derived:</source>
          <target state="translated">GHCはこのリストをさらにいくつかのクラスで拡張し、自動的に派生させることができます。</target>
        </trans-unit>
        <trans-unit id="b8da89741da234fc1301b6c98edbd981b7cba345" translate="yes" xml:space="preserve">
          <source>GHC generates case expressions without a default alternative in some cases:</source>
          <target state="translated">GHC は、いくつかのケースで、デフォルトの代替手段を持たない case 式を生成します。</target>
        </trans-unit>
        <trans-unit id="2927c8c0dcc59d688d14e863c87024ee56f40a67" translate="yes" xml:space="preserve">
          <source>GHC has a &lt;code&gt;-dynload&lt;/code&gt; linking flag to select the method that is used to find shared libraries at runtime. There are currently two modes:</source>
          <target state="translated">GHCには、実行時に共有ライブラリを見つけるために使用されるメソッドを選択する &lt;code&gt;-dynload&lt;/code&gt; リンクフラグがあります。現在2つのモードがあります。</target>
        </trans-unit>
        <trans-unit id="37868d9918c1e5d3985d0159ec2eb8abe357d679" translate="yes" xml:space="preserve">
          <source>GHC has a comprehensive optimiser, so when you want to Really Go For It (and you&amp;rsquo;ve got time to spare) GHC can produce pretty fast code. Alternatively, the default option is to compile as fast as possible while not making too much effort to optimise the generated code (although GHC probably isn&amp;rsquo;t what you&amp;rsquo;d describe as a fast compiler :-).</source>
          <target state="translated">GHCには包括的なオプティマイザがあるので、本当にやりたいとき（そして時間に余裕があるとき）、GHCはかなり高速なコードを生成できます。あるいは、デフォルトのオプションは、生成されたコードを最適化するためにあまり努力せずに、可能な限り高速にコンパイルすることです（ただし、GHCはおそらく高速コンパイラーとして記述したものではありませんが:-)。</target>
        </trans-unit>
        <trans-unit id="50704903e2fa0767c23ef5592e01c0142e232598" translate="yes" xml:space="preserve">
          <source>GHC has a custom solver for discharging constraints that involve class &lt;code&gt;Typeable&lt;/code&gt;, and handwritten instances are forbidden. This ensures that the programmer cannot subvert the type system by writing bogus instances.</source>
          <target state="translated">GHCには、クラス &lt;code&gt;Typeable&lt;/code&gt; を含む制約を排出するためのカスタムソルバーがあり、手書きのインスタンスは禁止されています。これにより、プログラマーが偽のインスタンスを書き込んで型システムを破壊できないようにします。</target>
        </trans-unit>
        <trans-unit id="dd2651a370808140aecb0389d7da1dfec93f9973" translate="yes" xml:space="preserve">
          <source>GHC has a few built-in functions with special behaviour. In particular:</source>
          <target state="translated">GHCには、特別な振る舞いをするいくつかの組み込み関数があります。特に</target>
        </trans-unit>
        <trans-unit id="8bdd8132100b5a3de15d0bde30890b059463f096" translate="yes" xml:space="preserve">
          <source>GHC has a number of options that select which types of non-fatal error messages, otherwise known as warnings, can be generated during compilation. Some options control individual warnings and others control collections of warnings. To turn off an individual warning &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt;, use &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt;. To reverse &lt;code&gt;-Werror&lt;/code&gt;, which makes all warnings into errors, use &lt;code&gt;-Wwarn&lt;/code&gt;.</source>
          <target state="translated">GHCには、コンパイル中に生成できる致命的でないエラーメッセージ（警告とも呼ばれる）の種類を選択するオプションがいくつかあります。一部のオプションは個々の警告を制御し、他のオプションは警告のコレクションを制御します。個別の警告 &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt; オフにするには、 &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt; を使用します。逆にするに &lt;code&gt;-Werror&lt;/code&gt; エラーにすべての警告を行い、使用 &lt;code&gt;-Wwarn&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="7b5cd4da1d694b042ff22d18106007056b905706" translate="yes" xml:space="preserve">
          <source>GHC has a number of options that select which types of non-fatal error messages, otherwise known as warnings, can be generated during compilation. Some options control individual warnings and others control collections of warnings. To turn off an individual warning &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt;, use &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt;. To reverse``-Werror``, which makes all warnings into errors, use &lt;code&gt;-Wwarn&lt;/code&gt;.</source>
          <target state="translated">GHCには、コンパイル中に生成できる致命的でないエラーメッセージ（警告とも呼ばれます）のタイプを選択するいくつかのオプションがあります。一部のオプションは個別の警告を制御し、他のオプションは警告のコレクションを制御します。個別の警告 &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt; オフにするには、 &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt; を使用します。すべての警告をエラーにする「-Werror」を元に戻すには、 &lt;code&gt;-Wwarn&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="dc26cabb6e31043f801f34ba96fce33c2cd76158" translate="yes" xml:space="preserve">
          <source>GHC has experimental support for &lt;em&gt;signature thinning&lt;/em&gt;, which is used when a signature has an explicit export list without a module export of the signature itself. In this case, the export list applies to the final export list &lt;em&gt;after&lt;/em&gt; merging, in particular, you may refer to entities which are not declared in the body of the local &lt;code&gt;hsig&lt;/code&gt; file.</source>
          <target state="translated">GHCは&lt;em&gt;シグネチャ間引き&lt;/em&gt;を実験的にサポートしてい&lt;em&gt;ます&lt;/em&gt;。これは、シグネチャ自体のモジュールエクスポートなしで、シグネチャに明示的なエクスポートリストがある場合に使用されます。この場合、エクスポートリストはマージ&lt;em&gt;後&lt;/em&gt;の最終的なエクスポートリストに適用されます。特に、ローカル &lt;code&gt;hsig&lt;/code&gt; ファイルの本文で宣言されていないエンティティを参照する場合があります。</target>
        </trans-unit>
        <trans-unit id="ae1857d5e68b869ba0f3a7a41a92f227174acdbb" translate="yes" xml:space="preserve">
          <source>GHC has extremely flaky support for &lt;em&gt;impredicative polymorphism&lt;/em&gt;, enabled with &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt;&lt;code&gt;ImpredicativeTypes&lt;/code&gt;&lt;/a&gt;. If it worked, this would mean that you &lt;em&gt;could&lt;/em&gt; call a polymorphic function at a polymorphic type, and parameterise data structures over polymorphic types. For example:</source>
          <target state="translated">GHCは、&lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt; &lt;code&gt;ImpredicativeTypes&lt;/code&gt; &lt;/a&gt;で有効にされた、予測的&lt;em&gt;多型&lt;/em&gt;に対する極めて不安定なサポートを備えています。機能した場合、これは、多態性型で多態性関数を呼び出し、多態性型に対してデータ構造をパラメーター化&lt;em&gt;できること&lt;/em&gt;を意味します。例えば：</target>
        </trans-unit>
        <trans-unit id="a7863559f9ec9cb2b2a5ec1dc3cee9a5175090f2" translate="yes" xml:space="preserve">
          <source>GHC has the ability to load compiler plugins at compile time. The feature is similar to the one provided by &lt;a href=&quot;http://gcc.gnu.org/wiki/plugins&quot;&gt;GCC&lt;/a&gt;, and allows users to write plugins that can adjust the behaviour of the constraint solver, inspect and modify the compilation pipeline, as well as transform and inspect GHC&amp;rsquo;s intermediate language, Core. Plugins are suitable for experimental analysis or optimization, and require no changes to GHC&amp;rsquo;s source code to use.</source>
          <target state="translated">GHCには、コンパイル時にコンパイラプラグインをロードする機能があります。この機能は&lt;a href=&quot;http://gcc.gnu.org/wiki/plugins&quot;&gt;GCCが&lt;/a&gt;提供する機能に似ており、ユーザーは制約ソルバーの動作を調整したり、コンパイルパイプラインを検査および変更したり、GHCの中間言語であるCoreを変換および検査したりできるプラグインを作成できます。プラグインは実験的な分析や最適化に適しており、GHCのソースコードを変更する必要はありません。</target>
        </trans-unit>
        <trans-unit id="22a7c64e218b3312ad9be925711deec4357a32a4" translate="yes" xml:space="preserve">
          <source>GHC has the ability to load compiler plugins at compile time. The feature is similar to the one provided by &lt;a href=&quot;https://gcc.gnu.org/wiki/plugins&quot;&gt;GCC&lt;/a&gt;, and allows users to write plugins that can adjust the behaviour of the constraint solver, inspect and modify the compilation pipeline, as well as transform and inspect GHC&amp;rsquo;s intermediate language, Core. Plugins are suitable for experimental analysis or optimization, and require no changes to GHC&amp;rsquo;s source code to use.</source>
          <target state="translated">GHCには、コンパイル時にコンパイラプラグインをロードする機能があります。この機能は&lt;a href=&quot;https://gcc.gnu.org/wiki/plugins&quot;&gt;GCCが&lt;/a&gt;提供するものと似ており、ユーザーは、制約ソルバーの動作を調整したり、コンパイルパイプラインを検査および変更したり、GHCの中間言語であるCoreを変換および検査したりできるプラグインを作成できます。プラグインは実験的な分析や最適化に適しており、GHCのソースコードを変更する必要はありません。</target>
        </trans-unit>
        <trans-unit id="3a2700135014d3391d235e2779538d1dbae6f7d0" translate="yes" xml:space="preserve">
          <source>GHC has to link your code with various libraries, possibly including: user-supplied, GHC-supplied, and system-supplied (&lt;code&gt;-lm&lt;/code&gt; math library, for example).</source>
          <target state="translated">GHCは、ユーザー提供、GHC提供、システム提供（例： &lt;code&gt;-lm&lt;/code&gt; math library）を含むさまざまなライブラリとコードをリンクする必要があります。</target>
        </trans-unit>
        <trans-unit id="6fb872fe440b0daf385b4b8ff21367d65f6f7fa0" translate="yes" xml:space="preserve">
          <source>GHC has two main components: an interactive Haskell interpreter (also known as GHCi), described in &lt;a href=&quot;ghci#ghci&quot;&gt;Using GHCi&lt;/a&gt;, and a batch compiler, described throughout &lt;a href=&quot;using#using-ghc&quot;&gt;Using GHC&lt;/a&gt;. In fact, GHC consists of a single program which is just run with different options to provide either the interactive or the batch system.</source>
          <target state="translated">GHCには2つの主要なコンポーネントがあります。GHCiの&lt;a href=&quot;ghci#ghci&quot;&gt;使用&lt;/a&gt;で説明されているインタラクティブなHaskellインタープリター（GHCiとも呼ばれます）と、&lt;a href=&quot;using#using-ghc&quot;&gt;GHCの使用&lt;/a&gt;で説明されているバッチコンパイラーです。実際、GHCは単一のプログラムで構成されており、対話型またはバッチシステムを提供するために、さまざまなオプションで実行されます。</target>
        </trans-unit>
        <trans-unit id="2dfd60f79ee4ba2079225942cc8483b2227556fc" translate="yes" xml:space="preserve">
          <source>GHC home page</source>
          <target state="translated">GHCホームページ</target>
        </trans-unit>
        <trans-unit id="7b51be1ff5f1ddedfd931ac8c672d1058c111c02" translate="yes" xml:space="preserve">
          <source>GHC ignores assertions when optimisation is turned on with the &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; flag. That is, expressions of the form &lt;code&gt;assert pred e&lt;/code&gt; will be rewritten to &lt;code&gt;e&lt;/code&gt;. You can also disable assertions using the &lt;a href=&quot;../using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fignore-asserts&lt;/code&gt;&lt;/a&gt; option. The option &lt;a href=&quot;../using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fno-ignore-asserts&lt;/code&gt;&lt;/a&gt; allows enabling assertions even when optimisation is turned on.</source>
          <target state="translated">&lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;フラグを使用して最適化をオンにすると、GHCはアサーションを無視します。つまり、フォームの表現 &lt;code&gt;assert pred e&lt;/code&gt; に書き換えられます &lt;code&gt;e&lt;/code&gt; 。&lt;a href=&quot;../using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fignore-asserts&lt;/code&gt; &lt;/a&gt;オプションを使用してアサーションを無効にすることもできます。オプション&lt;a href=&quot;../using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fno-ignore-asserts&lt;/code&gt; を&lt;/a&gt;使用すると、最適化がオンになっている場合でもアサーションを有効にできます。</target>
        </trans-unit>
        <trans-unit id="f354abc94fdf02ee4cd7aec76ce15252272ca1c5" translate="yes" xml:space="preserve">
          <source>GHC ignores assertions when optimisation is turned on with the &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; flag. That is, expressions of the form &lt;code&gt;assert pred e&lt;/code&gt; will be rewritten to &lt;code&gt;e&lt;/code&gt;. You can also disable assertions using the &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fignore-asserts&lt;/code&gt;&lt;/a&gt; option. The option &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fno-ignore-asserts&lt;/code&gt;&lt;/a&gt; allows enabling assertions even when optimisation is turned on.</source>
          <target state="translated">&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;フラグで最適化がオンになっている場合、GHCはアサーションを無視します。つまり、フォームの表現 &lt;code&gt;assert pred e&lt;/code&gt; に書き換えられます &lt;code&gt;e&lt;/code&gt; 。&lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fignore-asserts&lt;/code&gt; &lt;/a&gt;オプションを使用してアサーションを無効にすることもできます。オプション&lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fno-ignore-asserts&lt;/code&gt; を&lt;/a&gt;使用すると、最適化がオンになっている場合でもアサーションを有効にできます。</target>
        </trans-unit>
        <trans-unit id="d193c3b9ee9bd64a2c40a91ed8f0f72fd80e9a86" translate="yes" xml:space="preserve">
          <source>GHC implements a number of GHC-specific extensions to the FFI Chapter of the Haskell 2010 Report. These extensions are described in &lt;a href=&quot;#ffi-ghcexts&quot;&gt;GHC extensions to the FFI Chapter&lt;/a&gt;, but please note that programs using these features are not portable. Hence, these features should be avoided where possible.</source>
          <target state="translated">GHCは、Haskell 2010レポートのFFI章にGHC固有の拡張機能をいくつか実装しています。これらの拡張機能は&lt;a href=&quot;#ffi-ghcexts&quot;&gt;FFIの章のGHC拡張機能で&lt;/a&gt;説明されていますが、これらの機能を使用するプログラムは移植できません。したがって、これらの機能は可能な限り回避する必要があります。</target>
        </trans-unit>
        <trans-unit id="1383e2906207b123b97681b2a7fc069bbcc74f65" translate="yes" xml:space="preserve">
          <source>GHC implements an &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; extension as specified in &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0013-unlifted-newtypes.rst&quot;&gt;this GHC proposal&lt;/a&gt;. &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; relaxes the restrictions around what types can appear inside of a &lt;code&gt;newtype&lt;/code&gt;. For example, the type</source>
          <target state="translated">GHCは、&lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0013-unlifted-newtypes.rst&quot;&gt;このGHC提案で&lt;/a&gt;指定されているように&lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt;拡張機能を実装します。&lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt;は、 &lt;code&gt;newtype&lt;/code&gt; 内に表示できるタイプに関する制限を緩和します。たとえば、タイプ</target>
        </trans-unit>
        <trans-unit id="b01529699aab62d7c26cc7ea486b2bf3a314d4cc" translate="yes" xml:space="preserve">
          <source>GHC implements pre-emptive multitasking: the execution of threads are interleaved in a random fashion. More specifically, a thread may be pre-empted whenever it allocates some memory, which unfortunately means that tight loops which do no allocation tend to lock out other threads (this only seems to happen with pathological benchmark-style code, however).</source>
          <target state="translated">GHC はプリエンプティブマルチタスクを実装しています:スレッドの実行はランダムにインターリーブされます。より具体的には、あるスレッドがメモリを確保するときはいつでもプリエンプティブなマルチタスクを行うことができますが、これは残念ながら、割り当てを行わないタイトループが他のスレッドをロックアウトする傾向があることを意味します (ただし、これは病的なベンチマークスタイルのコードでのみ起こるようです)。</target>
        </trans-unit>
        <trans-unit id="784ab21057de1abbfb56e2df7ec894a968e45b8e" translate="yes" xml:space="preserve">
          <source>GHC implements some major extensions to Haskell to support concurrent and parallel programming. Let us first establish terminology:</source>
          <target state="translated">GHCはHaskellの主要な拡張機能を実装しており、並行・並列プログラミングをサポートしています。まず、用語を確立しましょう。</target>
        </trans-unit>
        <trans-unit id="384027abc0c0211dec27023d54430b773e937baf" translate="yes" xml:space="preserve">
          <source>GHC implements this test conservatively when type functions, or type variables, are involved. For example</source>
          <target state="translated">GHCでは、型関数や型変数が関与している場合には、このテストを保守的に実装しています。例えば</target>
        </trans-unit>
        <trans-unit id="0fc31183c1e70f82a9bdd1edfbb35d0be9ae0a6c" translate="yes" xml:space="preserve">
          <source>GHC includes a variety of flags that allow arbitrary processes to be run at compilation time. One such example is the &lt;a href=&quot;../phases#pre-processor&quot;&gt;custom pre-processor&lt;/a&gt; flag. Another is the ability of Template Haskell to execute Haskell code at compilation time, including IO actions. Safe Haskell &lt;em&gt;does not address this danger&lt;/em&gt; (although, Template Haskell is a disallowed feature).</source>
          <target state="translated">GHCには、コンパイル時に任意のプロセスを実行できるようにするさまざまなフラグが含まれています。そのような例の1つは、&lt;a href=&quot;../phases#pre-processor&quot;&gt;カスタムプリプロセッサ&lt;/a&gt;フラグです。もう1つは、IOアクションを含むコンパイル時にHaskellコードを実行するTemplateHaskellの機能です。Safe Haskell&lt;em&gt;はこの危険に対処していません&lt;/em&gt;（ただし、Template Haskellは許可されていない機能です）。</target>
        </trans-unit>
        <trans-unit id="ac0d768afcace80925944278709c9070e93b287f" translate="yes" xml:space="preserve">
          <source>GHC includes a variety of flags that allow arbitrary processes to be run at compilation time. One such example is the &lt;a href=&quot;phases#pre-processor&quot;&gt;custom pre-processor&lt;/a&gt; flag. Another is the ability of Template Haskell to execute Haskell code at compilation time, including IO actions. Safe Haskell &lt;em&gt;does not address this danger&lt;/em&gt; (although, Template Haskell is a disallowed feature).</source>
          <target state="translated">GHCには、コンパイル時に任意のプロセスを実行できるようにするさまざまなフラグが含まれています。そのような例の1つは、&lt;a href=&quot;phases#pre-processor&quot;&gt;カスタムプリプロセッサ&lt;/a&gt;フラグです。もう1つは、IOアクションを含む、コンパイル時にHaskellコードを実行するテンプレートHaskellの機能です。Safe Haskell &lt;em&gt;はこの危険に対処していません&lt;/em&gt;（ただし、テンプレートHaskellは許可されていない機能です）。</target>
        </trans-unit>
        <trans-unit id="d09bb52c1f872e95bf9ee5c47a2b96510a0df672" translate="yes" xml:space="preserve">
          <source>GHC includes support for running Haskell programs in parallel on symmetric, shared-memory multi-processor (SMP). By default GHC runs your program on one processor; if you want it to run in parallel you must link your program with the &lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, and run it with the RTS &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option; see &lt;a href=&quot;../using-concurrent#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;). The runtime will schedule the running Haskell threads among the available OS threads, running as many in parallel as you specified with the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS option.</source>
          <target state="translated">GHCには、対称共有メモリマルチプロセッサ（SMP）でHaskellプログラムを並列実行するためのサポートが含まれています。デフォルトでは、GHCはプログラムを1つのプロセッサで実行します。並行して実行したい場合は、プログラムを&lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; に&lt;/a&gt;リンクし、RTS &lt;code&gt;-N ⟨x⟩&lt;/code&gt; オプションを使用して実行する必要があります。&lt;a href=&quot;../using-concurrent#using-smp&quot;&gt;SMP並列処理の使用を&lt;/a&gt;参照してください）。ランタイムは、使用可能なOSスレッド間で実行中のHaskellスレッドをスケジュールし、 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; オプションで指定した数だけ並行して実行します。</target>
        </trans-unit>
        <trans-unit id="5a501e79a5be96c764587e4f4a538a164615c592" translate="yes" xml:space="preserve">
          <source>GHC includes support for running Haskell programs in parallel on symmetric, shared-memory multi-processor (SMP). By default GHC runs your program on one processor; if you want it to run in parallel you must link your program with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, and run it with the RTS &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option; see &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;). The runtime will schedule the running Haskell threads among the available OS threads, running as many in parallel as you specified with the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS option.</source>
          <target state="translated">GHCには、対称的な共有メモリマルチプロセッサ（SMP）で並列にHaskellプログラムを実行するためのサポートが含まれています。デフォルトでは、GHCは1つのプロセッサーでプログラムを実行します。並列で実行したい場合は、プログラムを&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;でリンクし、RTS &lt;code&gt;-N ⟨x⟩&lt;/code&gt; オプションで実行する必要があります。&lt;a href=&quot;using-concurrent#using-smp&quot;&gt;SMP並列処理の使用を&lt;/a&gt;参照してください）。ランタイムは、利用可能なOSスレッドの中で実行中のHaskellスレッドをスケジュールし、 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; オプションで指定した数だけ並行して実行します。</target>
        </trans-unit>
        <trans-unit id="8a61ad13cc654370f6a14c4d7207d6379e372d1d" translate="yes" xml:space="preserve">
          <source>GHC is a large program consisting of a number of stages. You can tell GHC to dump information from various stages of compilation using the &lt;code&gt;-ddump-⟨pass⟩&lt;/code&gt; flags listed below. Note that some of these tend to produce a lot of output. You can prevent them from clogging up your standard output by passing &lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHCはいくつかの段階からなる大きなプログラムです。下記の &lt;code&gt;-ddump-⟨pass⟩&lt;/code&gt; フラグを使用して、コンパイルのさまざまな段階から情報をダンプするようにGHCに指示できます。これらのいくつかは多くの出力を生成する傾向があることに注意してください。&lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt;を渡すことで、標準出力が詰まるのを防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="0e827b1ebcca328b1f8fef7330a8dfc0af882c0d" translate="yes" xml:space="preserve">
          <source>GHC is built on a raft of primitive data types and operations; &amp;ldquo;primitive&amp;rdquo; in the sense that they cannot be defined in Haskell itself. While you really can use this stuff to write fast code, we generally find it a lot less painful, and more satisfying in the long run, to use higher-level language features and libraries. With any luck, the code you write will be optimised to the efficient unboxed version in any case. And if it isn&amp;rsquo;t, we&amp;rsquo;d like to know about it.</source>
          <target state="translated">GHCは多くの基本的なデータ型と操作に基づいて構築されています。Haskell自体では定義できないという意味での「プリミティブ」。あなたは本当にこのようなものを使って高速なコードを書くことができますが、一般的に、より高水準の言語機能とライブラリを使用するほうが、それほど苦痛が少なく、長い目で見ると満足度が高くなります。運が良ければ、あなたが書いたコードは、どんな場合でも効率的なボックス化されていないバージョンに最適化されます。そうでない場合は、それについて知りたいのですが。</target>
        </trans-unit>
        <trans-unit id="036d822f43fafc704cccf229faeb8f39d429451c" translate="yes" xml:space="preserve">
          <source>GHC is itself a Haskell program, so if you need to pass options directly to GHC&amp;rsquo;s runtime system you can enclose them in &lt;code&gt;+RTS ... -RTS&lt;/code&gt; (see &lt;a href=&quot;runtime_control#runtime-control&quot;&gt;Running a compiled program&lt;/a&gt;).</source>
          <target state="translated">GHC自体はHaskellプログラムなので、GHCのランタイムシステムにオプションを直接渡す必要がある場合は、それらを &lt;code&gt;+RTS ... -RTS&lt;/code&gt; で囲むことができます（&lt;a href=&quot;runtime_control#runtime-control&quot;&gt;コンパイル済みプログラムの実行を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="5f1fbb021ad6ec77459e40f9cdfa738fe516428c" translate="yes" xml:space="preserve">
          <source>GHC is surprisingly zippy for normal compilations without &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;!</source>
          <target state="translated">GHCは、驚くべきことに、&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;なしの通常のコンパイルでは抜群です。</target>
        </trans-unit>
        <trans-unit id="e1b0068bc94f72b8b3701c6252a51b85e66a7b86" translate="yes" xml:space="preserve">
          <source>GHC is very cautious about duplicating work. For example, consider</source>
          <target state="translated">GHCは重複作業には非常に慎重です。例えば、以下のようなことを考えてみてください。</target>
        </trans-unit>
        <trans-unit id="1e880a64634c393c137ab909ff23b9fa67d62722" translate="yes" xml:space="preserve">
          <source>GHC is very sensitive about interface files. For example, if it picks up a non-standard &lt;code&gt;Prelude.hi&lt;/code&gt; file, pretty terrible things will happen. If you turn on &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt;-XNoImplicitPrelude option, the compiler will almost surely die, unless you know what you are doing.</source>
          <target state="translated">GHCはインターフェースファイルに非常に敏感です。たとえば、非標準の &lt;code&gt;Prelude.hi&lt;/code&gt; ファイルを取得すると、かなりひどいことが起こります。 &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; -XNoImplicitPreludeオプションをオンにすると、何をしているのかわからない限り、コンパイラはほぼ確実に終了します。</target>
        </trans-unit>
        <trans-unit id="8f98bd19130c85af22543d9122fb6b893c3ab021" translate="yes" xml:space="preserve">
          <source>GHC keeps trying to apply the rules as it optimises the program. For example, consider:</source>
          <target state="translated">GHCは、プログラムを最適化する際にルールを適用しようとし続けます。例えば、考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="c971ed60f0f8cac8a9dfb32c0fc05213d73e4927" translate="yes" xml:space="preserve">
          <source>GHC knows about two package databases in particular:</source>
          <target state="translated">GHCは特に2つのパッケージデータベースを知っています。</target>
        </trans-unit>
        <trans-unit id="ee518910a69d6b3ec07ce5ab8b5533533d1b86a4" translate="yes" xml:space="preserve">
          <source>GHC lets you change the default RTS options for a program at compile time, using the &lt;code&gt;-with-rtsopts&lt;/code&gt; flag (&lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;). A common use for this is to give your program a default heap and/or stack size that is greater than the default. For example, to set &lt;code&gt;-H128m -K64m&lt;/code&gt;, link with &lt;code&gt;-with-rtsopts=&quot;-H128m -K64m&quot;&lt;/code&gt;.</source>
          <target state="translated">GHCでは、 &lt;code&gt;-with-rtsopts&lt;/code&gt; フラグを使用して、コンパイル時にプログラムのデフォルトのRTSオプションを変更できます（&lt;a href=&quot;phases#options-linker&quot;&gt;リンクに影響するオプション&lt;/a&gt;）。これの一般的な用途は、プログラムにデフォルトより大きいヒープまたはスタックサイズ、あるいはその両方を与えることです。たとえば、 &lt;code&gt;-H128m -K64m&lt;/code&gt; を設定するには、 &lt;code&gt;-with-rtsopts=&quot;-H128m -K64m&quot;&lt;/code&gt; でリンクします。</target>
        </trans-unit>
        <trans-unit id="fb99e557b948da3d443c3d321414623817fdd5f6" translate="yes" xml:space="preserve">
          <source>GHC lets you exercise rudimentary control over certain RTS settings for any given program, by compiling in a &amp;ldquo;hook&amp;rdquo; that is called by the run-time system. The RTS contains stub definitions for these hooks, but by writing your own version and linking it on the GHC command line, you can override the defaults.</source>
          <target state="translated">GHCを使用すると、ランタイムシステムによって呼び出される「フック」でコンパイルすることにより、特定のプログラムの特定のRTS設定を基本的に制御できます。RTSにはこれらのフックのスタブ定義が含まれていますが、独自のバージョンを記述してGHCコマンドラインでリンクすることにより、デフォルトを上書きできます。</target>
        </trans-unit>
        <trans-unit id="cad9041737a68aff4c044f186cb6f1f6cdc933e2" translate="yes" xml:space="preserve">
          <source>GHC lifts this restriction with language extension &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt;. The restriction is a pretty stupid one in the first place, so &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHCは、言語拡張&lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; で&lt;/a&gt;この制限を解除します。そもそもこの制限はかなり愚かなものなので、&lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; &lt;/a&gt;によって暗示されます。</target>
        </trans-unit>
        <trans-unit id="026e2f888db92431c91e24d1a0558f32b93663ed" translate="yes" xml:space="preserve">
          <source>GHC lifts this restriction with language extension &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt;. The restriction is a pretty stupid one in the first place, so &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;multi_param_type_classes#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHCは、言語拡張&lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; を&lt;/a&gt;使用してこの制限を解除します。そもそも制限はかなりばかげているので、&lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;multi_param_type_classes#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; &lt;/a&gt;によって暗示されます。</target>
        </trans-unit>
        <trans-unit id="b8ba60a7f4df257517ab7d5d783f3cc489a09b60" translate="yes" xml:space="preserve">
          <source>GHC loves single-constructor data-types:</source>
          <target state="translated">GHCはシングルコンストラクタのデータ型が大好きです。</target>
        </trans-unit>
        <trans-unit id="7fe0475e3ee29056ea60e7039fdeca427dd3ce9a" translate="yes" xml:space="preserve">
          <source>GHC maintains a property that the kind of all inhabited types (as distinct from type constructors or type-level data) tells us the runtime representation of values of that type. This datatype encodes the choice of runtime value. Note that &lt;code&gt;&lt;a href=&quot;ghc-exts#t:TYPE&quot;&gt;TYPE&lt;/a&gt;&lt;/code&gt; is parameterised by &lt;code&gt;&lt;a href=&quot;ghc-exts#t:RuntimeRep&quot;&gt;RuntimeRep&lt;/a&gt;&lt;/code&gt;; this is precisely what we mean by the fact that a type's kind encodes the runtime representation.</source>
          <target state="translated">GHCは、存在するすべてのタイプの種類（タイプコンストラクターまたはタイプレベルのデータとは異なり）が、そのタイプの値の実行時表現を示すプロパティを維持します。このデータ型は、ランタイム値の選択をエンコードします。 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:TYPE&quot;&gt;TYPE&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ghc-exts#t:RuntimeRep&quot;&gt;RuntimeRep&lt;/a&gt;&lt;/code&gt; によってパラメーター化されることに注意してください。これはまさに、型の種類が実行時表現をエンコードするということです。</target>
        </trans-unit>
        <trans-unit id="1ff86cb3c00be570a738bdb82648ae498fe4fba6" translate="yes" xml:space="preserve">
          <source>GHC makes absolutely no attempt to verify that the LHS and RHS of a rule have the same meaning. That is undecidable in general, and infeasible in most interesting cases. The responsibility is entirely the programmer&amp;rsquo;s!</source>
          <target state="translated">GHCは、ルールのLHSとRHSが同じ意味を持つことを確認することを絶対に試みません。それは一般に決定不可能であり、最も興味深いケースでは実行不可能です。責任は完全にプログラマーの責任です！</target>
        </trans-unit>
        <trans-unit id="b7463d030f30e5fbf0ea5c1acd7285f721a4849a" translate="yes" xml:space="preserve">
          <source>GHC makes no attempt to make sure that the rules are confluent or terminating. For example:</source>
          <target state="translated">GHCは、ルールがコンフルエントなものであること、または終了していることを確認しようとはしません。例えば</target>
        </trans-unit>
        <trans-unit id="37534f2a655b7b54b3a6e0e503e96b3a7186887d" translate="yes" xml:space="preserve">
          <source>GHC may produce the following standard DIEs in the &lt;code&gt;.debug_info&lt;/code&gt; section,</source>
          <target state="translated">GHCは、 &lt;code&gt;.debug_info&lt;/code&gt; セクションで次の標準DIEを生成する場合があります。</target>
        </trans-unit>
        <trans-unit id="093f5ff97cdf917305aab74e98feadff3bea2477" translate="yes" xml:space="preserve">
          <source>GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;../codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;../phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fasm&lt;/code&gt;&lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</source>
          <target state="translated">GHCは、Cを介してコンパイルするときに外部ヘッダーファイルをインクルードしなくなったため、このチェックは実行されません。この変更は、&lt;a href=&quot;../codegens#native-code-gen&quot;&gt;ネイティブコードジェネレーター&lt;/a&gt;（&lt;a href=&quot;../phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fasm&lt;/code&gt; &lt;/a&gt;）との互換性と、FFI仕様に厳密に準拠するために行われました。これにより、FFI呼び出しは、Cヘッダーファイルの使用時に適用される可能性のあるマクロ展開やその他のCPP変換の対象になりません。このアプローチにより、モジュールとパッケージの境界を越えた外部呼び出しのインライン化も簡素化されます。外部呼び出しのインライン化バージョンをコンパイルするときにヘッダーファイルを使用できる必要がないため、コンパイラーは任意のコンテキストで外部呼び出しを自由にインライン化できます。</target>
        </trans-unit>
        <trans-unit id="421a7300b70d01de5b5db3b095ba0095f1fbdbfa" translate="yes" xml:space="preserve">
          <source>GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;phases#ghc-flag--fasm&quot;&gt;&lt;code&gt;-fasm&lt;/code&gt;&lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</source>
          <target state="translated">Cを介してコンパイルする場合、GHCは外部ヘッダーファイルを含まないため、このチェックは実行されません。この変更は、&lt;a href=&quot;codegens#native-code-gen&quot;&gt;ネイティブコードジェネレーター&lt;/a&gt;（&lt;a href=&quot;phases#ghc-flag--fasm&quot;&gt; &lt;code&gt;-fasm&lt;/code&gt; &lt;/a&gt;）との互換性のため、およびFFI仕様に厳密に準拠するために行われました。これにより、FFI呼び出しは、Cヘッダーファイルの使用時に適用される可能性のあるマクロ展開やその他のCPP変換の対象にならないことが要求されます。このアプローチは、モジュールとパッケージの境界を越えた外部呼び出しのインライン化も簡素化します。外部呼び出しのインラインバージョンをコンパイルするときにヘッダーファイルを使用する必要がないため、コンパイラーはどのようなコンテキストでも外部呼び出しを自由にインライン化できます。</target>
        </trans-unit>
        <trans-unit id="9a9906447d97115265712315061f7cad299f0951" translate="yes" xml:space="preserve">
          <source>GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fasm&lt;/code&gt;&lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</source>
          <target state="translated">GHCは、Cを介してコンパイルするときに外部ヘッダーファイルをインクルードしなくなったため、このチェックは実行されません。この変更は、&lt;a href=&quot;codegens#native-code-gen&quot;&gt;ネイティブコードジェネレーター&lt;/a&gt;（&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fasm&lt;/code&gt; &lt;/a&gt;）との互換性と、FFI仕様に厳密に準拠するために行われました。これにより、FFI呼び出しは、Cヘッダーファイルの使用時に適用される可能性のあるマクロ展開やその他のCPP変換の対象になりません。このアプローチにより、モジュールとパッケージの境界を越えた外部呼び出しのインライン化も簡素化されます。外部呼び出しのインライン化バージョンをコンパイルするときにヘッダーファイルを使用できる必要がないため、コンパイラーは任意のコンテキストで外部呼び出しを自由にインライン化できます。</target>
        </trans-unit>
        <trans-unit id="2b8ae90a6a33abf2e10b63d4f5e2fffb42594017" translate="yes" xml:space="preserve">
          <source>GHC normally imports &lt;code&gt;Prelude.hi&lt;/code&gt; files for you. If you&amp;rsquo;d rather it didn&amp;rsquo;t, then give it a &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; option. The idea is that you can then import a Prelude of your own. (But don&amp;rsquo;t call it &lt;code&gt;Prelude&lt;/code&gt;; the Haskell module namespace is flat, and you must not conflict with any Prelude module.)</source>
          <target state="translated">GHCは通常 &lt;code&gt;Prelude.hi&lt;/code&gt; ファイルをインポートします。望まない場合は、 &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; オプションを指定してください。これにより、独自のPreludeをインポートできるようになります。 （ただし、これを &lt;code&gt;Prelude&lt;/code&gt; と呼ばないでください。Haskellモジュールの名前空間はフラットであり、Preludeモジュールと競合してはいけません。）</target>
        </trans-unit>
        <trans-unit id="51a9a8d7dba56ae1e5e3495d0ce96e9d8abfbf97" translate="yes" xml:space="preserve">
          <source>GHC note: a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; will be automatically closed when the garbage collector detects that it has become unreferenced by the program. However, relying on this behaviour is not generally recommended: the garbage collector is unpredictable. If possible, use an explicit &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt; to close &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s when they are no longer required. GHC does not currently attempt to free up file descriptors when they have run out, it is your responsibility to ensure that this doesn't happen.</source>
          <target state="translated">GHC注： &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; は、ガベージコレクターがプログラムによって参照されなくなったことを検出すると、自動的に閉じられます。ただし、この動作に依存することは一般的にはお勧めできません。ガベージコレクターは予測不可能です。可能であれば、明示的な &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt; を使用して、不要になった &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; を閉じます。 GHCは現在、ファイル記述子が不足してもファイル記述子を解放しようとはしていません。これが起こらないようにするのはユーザーの責任です。</target>
        </trans-unit>
        <trans-unit id="40c291d3bf2780069335f412ddeb31f3318572c7" translate="yes" xml:space="preserve">
          <source>GHC note: the number of capabilities is specified by the &lt;code&gt;+RTS -N&lt;/code&gt; option when the program is started. Capabilities can be fixed to actual processor cores with &lt;code&gt;+RTS -qa&lt;/code&gt; if the underlying operating system supports that, although in practice this is usually unnecessary (and may actually degrade performance in some cases - experimentation is recommended).</source>
          <target state="translated">GHC注：機能の数は、プログラムの起動時に &lt;code&gt;+RTS -N&lt;/code&gt; オプションによって指定されます。基盤となるオペレーティングシステムがサポートしている場合、 &lt;code&gt;+RTS -qa&lt;/code&gt; を使用して機能を実際のプロセッサコアに固定できますが、実際にはこれは通常は不要です（場合によっては実際にパフォーマンスを低下させる可能性があります-実験をお勧めします）。</target>
        </trans-unit>
        <trans-unit id="115bd9cb4711dab5b627ce7841a7aee928c90c42" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; does not require a finalizer to free the memory. Use of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; and associated functions is strongly recommended in preference to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; with a finalizer.</source>
          <target state="translated">GHCノート： &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; はGHCで大幅に最適化された実装を持っています。ガベージコレクションされたヒープ内の固定されたメモリを使用するため、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; はメモリを解放するファイナライザを必要としません。使用 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; と関連する機能は強力に優先して推奨され &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; ファイナライザで。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
