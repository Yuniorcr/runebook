<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="c694cfeb74e8c5c7ea7a993e0762b168e17f097b" translate="yes" xml:space="preserve">
          <source>GeneralizedNewtypeDeriving</source>
          <target state="translated">GeneralizedNewtypeDeriving</target>
        </trans-unit>
        <trans-unit id="8bba990109118772a7f157201f4852b56a93e1e4" translate="yes" xml:space="preserve">
          <source>Generally speaking, when &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; is on, GHC tries to infer the most general kind for a declaration. In many cases (for example, in a datatype declaration) the definition has a right-hand side to inform kind inference. But that is not always the case. Consider</source>
          <target state="translated">一般的に言って、&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;がオンの場合、GHCは宣言の最も一般的な種類を推測しようとします。多くの場合（たとえば、データ型宣言の場合）、定義には親切な推論を通知する右側があります。しかし、常にそうであるとは限りません。検討する</target>
        </trans-unit>
        <trans-unit id="6d38b600df6d5f10e2c48ed50d09c245ecf3d220" translate="yes" xml:space="preserve">
          <source>Generally, you can only give a &lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt;&lt;code&gt;SPECIALIZE&lt;/code&gt;&lt;/a&gt; pragma for a function defined in the same module. However if a function &lt;code&gt;f&lt;/code&gt; is given an &lt;a href=&quot;#pragma-INLINABLE&quot;&gt;&lt;code&gt;INLINABLE&lt;/code&gt;&lt;/a&gt; pragma at its definition site, then it can subsequently be specialised by importing modules (see &lt;a href=&quot;#inlinable-pragma&quot;&gt;INLINABLE pragma&lt;/a&gt;). For example</source>
          <target state="translated">通常、&lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt; &lt;code&gt;SPECIALIZE&lt;/code&gt; &lt;/a&gt;プラグマを指定できるのは、同じモジュールで定義された関数のみです。ただし、関数 &lt;code&gt;f&lt;/code&gt; にその定義サイトで&lt;a href=&quot;#pragma-INLINABLE&quot;&gt; &lt;code&gt;INLINABLE&lt;/code&gt; &lt;/a&gt;プラグマが指定されている場合は、その後、モジュールをインポートすることによって特殊化できます（&lt;a href=&quot;#inlinable-pragma&quot;&gt;INLINABLEプラグマを&lt;/a&gt;参照）。例えば</target>
        </trans-unit>
        <trans-unit id="d08cc5e55e4bb93f6a515a38b1f75c093fe6e0b3" translate="yes" xml:space="preserve">
          <source>Generate a capturable name. Occurrences of such names will be resolved according to the Haskell scoping rules at the occurrence site.</source>
          <target state="translated">キャプチャ可能な名前を生成します。このような名前の出現は、出現場所でのHaskellのスコープルールに従って解決されます。</target>
        </trans-unit>
        <trans-unit id="aeed47864f8a7339cdf8be33e82f7d412fe366b8" translate="yes" xml:space="preserve">
          <source>Generate a fresh name, which cannot be captured.</source>
          <target state="translated">キャプチャできない新鮮な名前を生成します。</target>
        </trans-unit>
        <trans-unit id="745ffd8ce042664827fc6bde881b37f864469beb" translate="yes" xml:space="preserve">
          <source>Generate a graph of the package dependencies in a form suitable for input for the &lt;a href=&quot;http://www.graphviz.org/&quot;&gt;graphviz&lt;/a&gt; tools. For example, to generate a PDF of the dependency graph:</source>
          <target state="translated">&lt;a href=&quot;http://www.graphviz.org/&quot;&gt;graphviz&lt;/a&gt;ツールへの入力に適した形式で、パッケージの依存関係のグラフを生成します。たとえば、依存関係グラフのPDFを生成するには：</target>
        </trans-unit>
        <trans-unit id="4920f76f167528645c1fe9c22d2dcaa6a089bd0a" translate="yes" xml:space="preserve">
          <source>Generate a shared library (as opposed to an executable)</source>
          <target state="translated">共有ライブラリの生成 (実行ファイルではなく)</target>
        </trans-unit>
        <trans-unit id="0e4ae4a96f85bdbccc43169fe49910079cdbd8ff" translate="yes" xml:space="preserve">
          <source>Generate a standalone static library (as opposed to an executable). This is useful when cross compiling. The library together with all its dependencies ends up in in a single static library that can be linked against.</source>
          <target state="translated">スタンドアロンのスタティックライブラリを生成します(実行ファイルではなく)。これは、クロスコンパイルするときに便利です。ライブラリは、すべての依存関係と一緒に単一のスタティック・ライブラリになり、それに対してリンクすることができます。</target>
        </trans-unit>
        <trans-unit id="48fa807100bcd28bd53cce9c992b8ed46f5f86ef" translate="yes" xml:space="preserve">
          <source>Generate byte-code</source>
          <target state="translated">バイトコードの生成</target>
        </trans-unit>
        <trans-unit id="545a23517098db1358fda76a5894abc504c8e13a" translate="yes" xml:space="preserve">
          <source>Generate byte-code instead of object-code. This is the default in GHCi. Byte-code can currently only be used in the interactive interpreter, not saved to disk. This option is only useful for reversing the effect of &lt;a href=&quot;#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">オブジェクトコードの代わりにバイトコードを生成します。これはGHCiのデフォルトです。バイトコードは現在、対話型インタープリターでのみ使用でき、ディスクには保存できません。このオプションは、&lt;a href=&quot;#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; の&lt;/a&gt;効果を元に戻す場合にのみ役立ちます。</target>
        </trans-unit>
        <trans-unit id="3e361635a833ea10d7f04f532a6187549e8cd183" translate="yes" xml:space="preserve">
          <source>Generate code for a position-independent executable (where available)</source>
          <target state="translated">位置に依存しない実行ファイルのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="4be18defb8001300394d722f2553ae2882459ebd" translate="yes" xml:space="preserve">
          <source>Generate code for linking against dynamic libraries</source>
          <target state="translated">動的ライブラリに対してリンクするためのコードを生成</target>
        </trans-unit>
        <trans-unit id="d7e41ba37b4936caed0d16b2edacb4f90c82806d" translate="yes" xml:space="preserve">
          <source>Generate code in such a way to be linkable into a position-independent executable This currently works on Linux x86 and x86-64. On Windows, position-independent code is never used so the flag is a no-op on that platform. To link the final executable use &lt;a href=&quot;#ghc-flag--pie&quot;&gt;&lt;code&gt;-pie&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">位置に依存しない実行可能ファイルにリンクできるようにコードを生成するこれは現在、Linux x86およびx86-64で動作します。 Windowsでは、位置に依存しないコードは使用されないため、フラグはそのプラットフォームでは何もしません。最終的な実行可能ファイルをリンクするには、&lt;a href=&quot;#ghc-flag--pie&quot;&gt; &lt;code&gt;-pie&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="ce6b34021a0cac78d62ed0e9e10bda04e18b425e" translate="yes" xml:space="preserve">
          <source>Generate colour output.</source>
          <target state="translated">カラー出力を生成します。</target>
        </trans-unit>
        <trans-unit id="0951be6b0579ecfa709ec3e3d4e23d98d9697421" translate="yes" xml:space="preserve">
          <source>Generate encapsulated PostScript suitable for inclusion in LaTeX documents. Usually, the PostScript graph is drawn in landscape mode in an area 9 inches wide by 6 inches high, and &lt;code&gt;hp2ps&lt;/code&gt; arranges for this area to be approximately centred on a sheet of a4 paper. This format is convenient of studying the graph in detail, but it is unsuitable for inclusion in LaTeX documents. The &lt;code&gt;-e&lt;/code&gt; option causes the graph to be drawn in portrait mode, with float specifying the width in inches, millimetres or points (the default). The resulting PostScript file conforms to the Encapsulated PostScript (EPS) convention, and it can be included in a LaTeX document using Rokicki&amp;rsquo;s dvi-to-PostScript converter &lt;code&gt;dvips&lt;/code&gt;.</source>
          <target state="translated">LaTeXドキュメントに含めるのに適したカプセル化されたPostScriptを生成します。通常、PostScriptグラフは横9インチ &lt;code&gt;hp2ps&lt;/code&gt; 高さ6インチの領域に横長モードで描画され、hp2psはこの領域がa4用紙のほぼ中央に配置されるように調整します。この形式はグラフを詳細に調べるのに便利ですが、LaTeXドキュメントに含めるには適していません。 &lt;code&gt;-e&lt;/code&gt; オプションは、フロートはインチ、ミリメートルまたはポイントの幅（デフォルト）を指定して、ポートレートモードで描画するグラフの原因となります。結果のPostScriptファイルは、Encapsulated PostScript（EPS）規則に準拠しており、Rokickiのdvi-to-PostScriptコンバーター &lt;code&gt;dvips&lt;/code&gt; を使用してLaTeXドキュメントに含めることができます。</target>
        </trans-unit>
        <trans-unit id="2af2316bd5693a2c95e9b58e4d09197236c735b7" translate="yes" xml:space="preserve">
          <source>Generate object code</source>
          <target state="translated">オブジェクトコードの生成</target>
        </trans-unit>
        <trans-unit id="a0c3e54eb051234ea1cd507d92e6426c516da62b" translate="yes" xml:space="preserve">
          <source>Generate object code. This is the default outside of GHCi, and can be used with GHCi to cause object code to be generated in preference to bytecode.</source>
          <target state="translated">オブジェクトコードを生成します。これはGHCiの外ではデフォルトであり、GHCiを使ってバイトコードではなくオブジェクトコードを生成させることができます。</target>
        </trans-unit>
        <trans-unit id="9b5f95dcb03ea38c6a355f6b7e37726ccf839b63" translate="yes" xml:space="preserve">
          <source>Generate position-independent code (code that can be put into shared libraries). This currently works on Linux x86 and x86-64. On Windows, position-independent code is never used so the flag is a no-op on that platform.</source>
          <target state="translated">位置に依存しないコード(共有ライブラリに入れられるコード)を生成します。これは現在 Linux x86 と x86-64 で動作します。Windowsでは、位置に依存しないコードは使用されないので、そのプラットフォームではこのフラグは使用されません。</target>
        </trans-unit>
        <trans-unit id="6cf6f42463945c51e0a71346f97c9c182c3bb40d" translate="yes" xml:space="preserve">
          <source>Generate position-independent code (where available)</source>
          <target state="translated">位置に依存しないコードを生成する(利用可能な場合</target>
        </trans-unit>
        <trans-unit id="7b85081d19a7d760ce6025f60cc20a50bec6fa8f" translate="yes" xml:space="preserve">
          <source>Generate warnings for Template Haskell splices</source>
          <target state="translated">テンプレートHaskellスプライスの警告を生成する</target>
        </trans-unit>
        <trans-unit id="e379c504cb4385507060a36357b57f5b6a5617c5" translate="yes" xml:space="preserve">
          <source>Generated by preprocessors to convey source line numbers of the original source.</source>
          <target state="translated">元のソースのソース行番号を伝えるためにプリプロセッサによって生成されます。</target>
        </trans-unit>
        <trans-unit id="0ab5544c727327bbc41b60d8a2cb8ebc8ae7d766" translate="yes" xml:space="preserve">
          <source>Generates a &amp;ldquo;tags&amp;rdquo; file for Vi-style editors (&lt;a href=&quot;#ghci-cmd-:ctags&quot;&gt;&lt;code&gt;:ctags&lt;/code&gt;&lt;/a&gt;) or Emacs-style editors (&lt;a href=&quot;#ghci-cmd-:etags&quot;&gt;&lt;code&gt;:etags&lt;/code&gt;&lt;/a&gt;). If no filename is specified, the default &lt;code&gt;tags&lt;/code&gt; or &lt;code&gt;TAGS&lt;/code&gt; is used, respectively. Tags for all the functions, constructors and types in the currently loaded modules are created. All modules must be interpreted for these commands to work.</source>
          <target state="translated">Viスタイルエディター（&lt;a href=&quot;#ghci-cmd-:ctags&quot;&gt; &lt;code&gt;:ctags&lt;/code&gt; &lt;/a&gt;）またはEmacsスタイルエディター（&lt;a href=&quot;#ghci-cmd-:etags&quot;&gt; &lt;code&gt;:etags&lt;/code&gt; &lt;/a&gt;）用の「タグ」ファイルを生成します。ファイル名が指定されていない場合、デフォルトの &lt;code&gt;tags&lt;/code&gt; または &lt;code&gt;TAGS&lt;/code&gt; がそれぞれ使用されます。現在ロードされているモジュール内のすべての関数、コンストラクター、およびタイプのタグが作成されます。これらのコマンドを機能させるには、すべてのモジュールを解釈する必要があります。</target>
        </trans-unit>
        <trans-unit id="a1bd17d2e723ab01d0f385c562085a77dec9c6bb" translate="yes" xml:space="preserve">
          <source>Generates a basic heap profile, in the file &lt;code&gt;prog.hp&lt;/code&gt;. To produce the heap profile graph, use &lt;strong&gt;hp2ps&lt;/strong&gt; (see &lt;a href=&quot;profiling#hp2ps&quot;&gt;hp2ps &amp;ndash; Rendering heap profiles to PostScript&lt;/a&gt;). The basic heap profile is broken down by data constructor, with other types of closures (functions, thunks, etc.) grouped into broad categories (e.g. &lt;code&gt;FUN&lt;/code&gt;, &lt;code&gt;THUNK&lt;/code&gt;). To get a more detailed profile, use the full profiling support (&lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;). Can be shortened to &lt;a href=&quot;#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ファイル &lt;code&gt;prog.hp&lt;/code&gt; に基本的なヒーププロファイルを生成します。ヒーププロファイルグラフを作成するには、&lt;strong&gt;hp2psを&lt;/strong&gt;使用し&lt;strong&gt;ます&lt;/strong&gt;（&lt;a href=&quot;profiling#hp2ps&quot;&gt;hp2ps &amp;ndash;ヒーププロファイルをPostScriptにレンダリングするを&lt;/a&gt;参照）。基本的なヒーププロファイルは、データコンストラクターによって分解されます。他の種類のクロージャー（関数、 &lt;code&gt;THUNK&lt;/code&gt; など）は、幅広いカテゴリ（例： &lt;code&gt;FUN&lt;/code&gt; 、THUNK）にグループ化されています。より詳細なプロファイルを取得するには、完全なプロファイリングサポート（&lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;）を使用してください。&lt;a href=&quot;#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt;に短縮できます。</target>
        </trans-unit>
        <trans-unit id="0f0c21738d6aa19fd6331a752c61d756e4c5d1e2" translate="yes" xml:space="preserve">
          <source>Generates both dynamic and static object files in a single run of GHC. This option is functionally equivalent to running GHC twice, the second time adding &lt;code&gt;-dynamic -osuf dyn_o -hisuf dyn_hi&lt;/code&gt;.</source>
          <target state="translated">GHCの1回の実行で動的オブジェクトファイルと静的オブジェクトファイルの両方を生成します。このオプションは、GHCを2回実行することと機能的に同等 &lt;code&gt;-dynamic -osuf dyn_o -hisuf dyn_hi&lt;/code&gt; 回目は-dynamic -osuf dyn_o -hisuf dyn_hiを追加します。</target>
        </trans-unit>
        <trans-unit id="e8bac696a293ef57322d908f3d774edadb0d2504" translate="yes" xml:space="preserve">
          <source>Generates the following instance</source>
          <target state="translated">以下のインスタンスを生成します。</target>
        </trans-unit>
        <trans-unit id="b291fccbb185f31ef661a2c06451e129d98c552c" translate="yes" xml:space="preserve">
          <source>Generating and unfolding ByteStrings</source>
          <target state="translated">ByteStringsの生成と展開</target>
        </trans-unit>
        <trans-unit id="09707d339d82aeb457a3844716013ddd13f46175" translate="yes" xml:space="preserve">
          <source>Generation and unfolding</source>
          <target state="translated">世代と展開</target>
        </trans-unit>
        <trans-unit id="ff7613e54fc90271b8a71da3dfd9a50e5acd96c2" translate="yes" xml:space="preserve">
          <source>Generic</source>
          <target state="translated">Generic</target>
        </trans-unit>
        <trans-unit id="8bf59fb56a7fbc2509919ea5d6c04c72c7dbee3a" translate="yes" xml:space="preserve">
          <source>Generic constructor classes</source>
          <target state="translated">汎用コンストラクタクラス</target>
        </trans-unit>
        <trans-unit id="7d2bc27114c5d7ad7c30dc9b313f1b4d989a4929" translate="yes" xml:space="preserve">
          <source>Generic instances</source>
          <target state="translated">ジェネリック インスタンス</target>
        </trans-unit>
        <trans-unit id="edd1e9ecd70c1b3bcef6a000b5ca8391176387c6" translate="yes" xml:space="preserve">
          <source>Generic operations defined in terms of &lt;code&gt;gunfold&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;gunfold&lt;/code&gt; 観点から定義された一般的な操作</target>
        </trans-unit>
        <trans-unit id="62cabccddee103de78ef3b1f3cad602975680931" translate="yes" xml:space="preserve">
          <source>Generic programming support in GHC allows defining classes with methods that do not need a user specification when instantiating: the method body is automatically derived by GHC. This is similar to what happens for standard classes such as &lt;code&gt;Read&lt;/code&gt; and &lt;code&gt;Show&lt;/code&gt;, for instance, but now for user-defined classes.</source>
          <target state="translated">GHCのジェネリックプログラミングサポートにより、インスタンス化するときにユーザー指定を必要としないメソッドでクラスを定義できます。メソッド本体はGHCによって自動的に派生します。これは、たとえば &lt;code&gt;Read&lt;/code&gt; や &lt;code&gt;Show&lt;/code&gt; などの標準クラスで何が起こるかと似ていますが、現在はユーザー定義クラスでも行われています。</target>
        </trans-unit>
        <trans-unit id="e9bcfe34f539771b337b3c156114a2353174cdfa" translate="yes" xml:space="preserve">
          <source>Generic representation type</source>
          <target state="translated">汎用表現型</target>
        </trans-unit>
        <trans-unit id="f4695d8314afc3c9511e416fc10b8ff8fb7380b0" translate="yes" xml:space="preserve">
          <source>Generic representation types</source>
          <target state="translated">一般的な表現タイプ</target>
        </trans-unit>
        <trans-unit id="f51bcf3a7bcfa796b47cb80453f8bc18c1267d2f" translate="yes" xml:space="preserve">
          <source>Generic support</source>
          <target state="translated">ジェネリックサポート</target>
        </trans-unit>
        <trans-unit id="0331b125fb4cfaa359feb76babfc239c8fc6a530" translate="yes" xml:space="preserve">
          <source>Generic type classes</source>
          <target state="translated">汎用型クラス</target>
        </trans-unit>
        <trans-unit id="5cbb5c3303885c08bc437203ebbbcd41ffc5bbf1" translate="yes" xml:space="preserve">
          <source>Generic1</source>
          <target state="translated">Generic1</target>
        </trans-unit>
        <trans-unit id="bfffd736cddd08a4eee689949c3399cb61da773b" translate="yes" xml:space="preserve">
          <source>Get</source>
          <target state="translated">Get</target>
        </trans-unit>
        <trans-unit id="6f167df17b817244e8d92e3121badbef21fa27f9" translate="yes" xml:space="preserve">
          <source>Get a lazy ByteString that is terminated with a NUL byte. The returned string does not contain the NUL byte. Fails if it reaches the end of input without finding a NUL.</source>
          <target state="translated">NULバイトで終了する遅延ByteStringを取得します。返される文字列には NUL バイトは含まれていません。NUL を見つけられずに入力の最後に到達した場合は失敗します。</target>
        </trans-unit>
        <trans-unit id="c239d3b622f7fd565781d4f4dcab4e09927edb9e" translate="yes" xml:space="preserve">
          <source>Get a list of &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;s in the $PATH variable.</source>
          <target state="translated">$ PATH変数内の &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; のリストを取得します。</target>
        </trans-unit>
        <trans-unit id="1f1899930b9569e10c6cfc88a4f4b7498dee068a" translate="yes" xml:space="preserve">
          <source>Get a list of &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;s in the $PATH variable.</source>
          <target state="translated">$ PATH変数内の &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; のリストを取得します。</target>
        </trans-unit>
        <trans-unit id="af251c391320051e268fa05c67fd1aedca208ee5" translate="yes" xml:space="preserve">
          <source>Get a reference to a free variable at a breakpoint</source>
          <target state="translated">ブレークポイントで自由変数への参照を取得する</target>
        </trans-unit>
        <trans-unit id="57078d0a3c8b109b1f4379a4aa38d26dc7512eab" translate="yes" xml:space="preserve">
          <source>Get a specific component of the state, using a projection function supplied.</source>
          <target state="translated">与えられた投影関数を使用して、状態の特定のコンポーネントを取得します。</target>
        </trans-unit>
        <trans-unit id="2662cd1869f4ae3db82467978d3f7b0019412bbe" translate="yes" xml:space="preserve">
          <source>Get a string representation of the current execution stack state.</source>
          <target state="translated">現在の実行スタックの状態を文字列で表現したものを取得します。</target>
        </trans-unit>
        <trans-unit id="6c31e11b823050ba2cea2c8460aec3b4022e12b5" translate="yes" xml:space="preserve">
          <source>Get a trace of the current execution stack state.</source>
          <target state="translated">現在の実行スタックの状態のトレースを取得します。</target>
        </trans-unit>
        <trans-unit id="c2e76620f050a66a8250541fdce2ec4f919515c5" translate="yes" xml:space="preserve">
          <source>Get all extensions.</source>
          <target state="translated">すべての拡張子を取得します。</target>
        </trans-unit>
        <trans-unit id="42372be9103fc691ad731746a614a19b7f331cb5" translate="yes" xml:space="preserve">
          <source>Get an environment value or a default value.</source>
          <target state="translated">環境値またはデフォルト値を取得します。</target>
        </trans-unit>
        <trans-unit id="dbb6b436eb32ee410eebe762e1c62025718fa179" translate="yes" xml:space="preserve">
          <source>Get an execution stack.</source>
          <target state="translated">実行スタックを取得します。</target>
        </trans-unit>
        <trans-unit id="a8196f1a388937eb3c1622a100e017f856c9eea6" translate="yes" xml:space="preserve">
          <source>Get current runtime system statistics.</source>
          <target state="translated">現在のランタイムシステムの統計情報を取得します。</target>
        </trans-unit>
        <trans-unit id="4e715c7dae3e98783c9bdf9c4e4ab64aac77cb14" translate="yes" xml:space="preserve">
          <source>Get state from the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Note that the state is local to the Haskell module in which the Template Haskell expression is executed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; モナドから状態を取得します。状態は、テンプレートHaskell式が実行されるHaskellモジュールに対してローカルであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="3aeb2eca8a488b50abdc7a58183f5262c45f8bd7" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; at the head of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">取得 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; をの先頭に &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e515f15bea5855df5eb0cbb2b2918fe8e0d835d" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; associated with the given value.</source>
          <target state="translated">指定された値に関連付けられている &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; を取得します。</target>
        </trans-unit>
        <trans-unit id="add5e999e95e74780d3f395fb32f6bda146264c9" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; at the head of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">取得 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; をの先頭に &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4cb72e96eed05217967ca7009b90c06b60dd3df" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; associated with the given value.</source>
          <target state="translated">指定された値に関連付けられている &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; を取得します。</target>
        </trans-unit>
        <trans-unit id="6be4742313ddbe2b9ab325b82b61b955b5264d92" translate="yes" xml:space="preserve">
          <source>Get the UT1 time of a local time on a particular meridian (in degrees, positive is East).</source>
          <target state="translated">特定の子午線上のローカルタイムのUT1時間を取得します。</target>
        </trans-unit>
        <trans-unit id="72efa4e3276ea481268ea1bf73cc2a94fbd81a20" translate="yes" xml:space="preserve">
          <source>Get the UTC time of a local time in a time zone.</source>
          <target state="translated">タイムゾーン内の現地時間のUTC時刻を取得します。</target>
        </trans-unit>
        <trans-unit id="7f011efdea73fd8590a82ad76b2135b1a44dfcb1" translate="yes" xml:space="preserve">
          <source>Get the base name, without an extension or path.</source>
          <target state="translated">拡張子やパスを指定せずに、ベースとなる名前を取得します。</target>
        </trans-unit>
        <trans-unit id="98b9a6f135af51d0129f1689a0b25dbe177eead3" translate="yes" xml:space="preserve">
          <source>Get the contents of the &lt;code&gt;PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;PATH&lt;/code&gt; 環境変数の内容を取得します。</target>
        </trans-unit>
        <trans-unit id="0b700626a66522b75396b422eaadb24213066b7c" translate="yes" xml:space="preserve">
          <source>Get the current &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; from the system clock.</source>
          <target state="translated">システムクロックから現在の &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; を取得します。</target>
        </trans-unit>
        <trans-unit id="0270de0567bc90a30e367bf358f647b2ce50ddaa" translate="yes" xml:space="preserve">
          <source>Get the current POSIX time from the system clock.</source>
          <target state="translated">システムクロックから現在のPOSIX時刻を取得します。</target>
        </trans-unit>
        <trans-unit id="cfadd67e7a7e19604994f22e158522395dbaf06e" translate="yes" xml:space="preserve">
          <source>Get the current line input history.</source>
          <target state="translated">現在の行入力履歴を取得します。</target>
        </trans-unit>
        <trans-unit id="66262b55256050223b751d7abe957f7eec02fd90" translate="yes" xml:space="preserve">
          <source>Get the current time-zone.</source>
          <target state="translated">現在のタイムゾーンを取得します。</target>
        </trans-unit>
        <trans-unit id="e7163ecf6dc60dacacf312a4e68e048ac45e8b8b" translate="yes" xml:space="preserve">
          <source>Get the current value of &lt;code&gt;errno&lt;/code&gt; in the current thread.</source>
          <target state="translated">現在のスレッドの &lt;code&gt;errno&lt;/code&gt; の現在の値を取得します。</target>
        </trans-unit>
        <trans-unit id="d1d2b0b9bd8a9db6da9a73ad6ce4498757df48e6" translate="yes" xml:space="preserve">
          <source>Get the default size of the terminal. For resizeable terminals (e.g., &lt;code&gt;xterm&lt;/code&gt;), these may not correspond to the actual dimensions.</source>
          <target state="translated">端末のデフォルトサイズを取得します。サイズ変更可能な端末（たとえば、 &lt;code&gt;xterm&lt;/code&gt; ）の場合、これらは実際の寸法と一致しない場合があります。</target>
        </trans-unit>
        <trans-unit id="229fedca2524f6589d1fa7505416425ee29197a8" translate="yes" xml:space="preserve">
          <source>Get the directory name, move up one level.</source>
          <target state="translated">ディレクトリ名を取得し、1つ上のレベルに移動します。</target>
        </trans-unit>
        <trans-unit id="8db9a8dd60cf3b1a36fa15f815b60c5ad67c15ec" translate="yes" xml:space="preserve">
          <source>Get the drive from a filepath.</source>
          <target state="translated">ファイルパスからドライブを取得します。</target>
        </trans-unit>
        <trans-unit id="61a15789e89a9c4b730cbee22dba43d0dca29efe" translate="yes" xml:space="preserve">
          <source>Get the echoing status of a handle connected to a terminal.</source>
          <target state="translated">ターミナルに接続されているハンドルのエコー状態を取得します。</target>
        </trans-unit>
        <trans-unit id="e4b0de19671fd4212da0915b4b88fb238c175abf" translate="yes" xml:space="preserve">
          <source>Get the extension of a file, returns &lt;code&gt;&quot;&quot;&lt;/code&gt; for no extension, &lt;code&gt;.ext&lt;/code&gt; otherwise.</source>
          <target state="translated">ファイルの拡張子を取得し、拡張子がない場合は &lt;code&gt;&quot;&quot;&lt;/code&gt; 、それ以外の場合は &lt;code&gt;.ext&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="b728f0791284fd67656c0aa4feb4d641406bdcd3" translate="yes" xml:space="preserve">
          <source>Get the file name.</source>
          <target state="translated">ファイル名を取得します。</target>
        </trans-unit>
        <trans-unit id="49ee7152dd7f669fc2d1e6f53b094147b3cae76a" translate="yes" xml:space="preserve">
          <source>Get the first index of a substring in another string, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the string is not found. &lt;code&gt;findSubstring p s&lt;/code&gt; is equivalent to &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt;.</source>
          <target state="translated">別の文字列の部分文字列の最初のインデックスを取得します。文字列が見つからない場合は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を取得します。 &lt;code&gt;findSubstring p s&lt;/code&gt; は &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="f14dd66fb1e3670e1835aac5f144235035b8e6b1" translate="yes" xml:space="preserve">
          <source>Get the first index of a substring in another string, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the string is not found. &lt;code&gt;findSubstring p s&lt;/code&gt; is equivalent to &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt;.</source>
          <target state="translated">別の文字列の部分文字列の最初のインデックスを取得します。文字列が見つからない場合は &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を取得します。 &lt;code&gt;findSubstring p s&lt;/code&gt; は、 &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="ee775ce9d7b994986c62951bb94f01d85eb44d2c" translate="yes" xml:space="preserve">
          <source>Get the fraction of a day since midnight given a time of day.</source>
          <target state="translated">一日の時間を指定された真夜中からの一日の端数を取得します。</target>
        </trans-unit>
        <trans-unit id="a2a3573464388922e250a7eb45275992553e7757" translate="yes" xml:space="preserve">
          <source>Get the handle of the current console window by using window's title. See: &lt;a href=&quot;http://support.microsoft.com/kb/124103&quot;&gt;http://support.microsoft.com/kb/124103&lt;/a&gt;</source>
          <target state="translated">ウィンドウのタイトルを使用して、現在のコンソールウィンドウのハンドルを取得します。参照：&lt;a href=&quot;http://support.microsoft.com/kb/124103&quot;&gt;http&lt;/a&gt; : //support.microsoft.com/kb/124103</target>
        </trans-unit>
        <trans-unit id="8c5f2319e438a4baa014695b30ce229379a38b83" translate="yes" xml:space="preserve">
          <source>Get the handle of the current console window.</source>
          <target state="translated">現在のコンソールウィンドウのハンドルを取得します。</target>
        </trans-unit>
        <trans-unit id="0a7f4400d930923897bb54c841a6213ed68644f4" translate="yes" xml:space="preserve">
          <source>Get the label for a given key.</source>
          <target state="translated">指定されたキーのラベルを取得します。</target>
        </trans-unit>
        <trans-unit id="5aeda20685c51fc6abcd2b337403dbbcd7923a16" translate="yes" xml:space="preserve">
          <source>Get the label of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; のラベルを取得します。</target>
        </trans-unit>
        <trans-unit id="fa9be9ab91ef24c2b81729a5316d49813c0c3129" translate="yes" xml:space="preserve">
          <source>Get the label of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; のラベルを取得します。</target>
        </trans-unit>
        <trans-unit id="9e900e82bce3a84192ef0492d0d7a7d7cc15cf88" translate="yes" xml:space="preserve">
          <source>Get the local time of a UT1 time on a particular meridian (in degrees, positive is East).</source>
          <target state="translated">特定の子午線上のUT1時間の現地時間を取得します。</target>
        </trans-unit>
        <trans-unit id="a833157a0c1508bf9bcfd2a53e5dcc6026df288f" translate="yes" xml:space="preserve">
          <source>Get the local time of a UTC time in a time zone.</source>
          <target state="translated">タイムゾーン内のUTC時間の現地時間を取得します。</target>
        </trans-unit>
        <trans-unit id="d2cb2c2ac1383013616533e9898eff073620487a" translate="yes" xml:space="preserve">
          <source>Get the local time-zone for a given time (varying as per summertime adjustments).</source>
          <target state="translated">指定された時間のローカルタイムゾーンを取得します(夏時間の調整に応じて変化します)。</target>
        </trans-unit>
        <trans-unit id="6114c6996f47966af81f9bc3720926a914d7721e" translate="yes" xml:space="preserve">
          <source>Get the module of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; のモジュールを取得します。</target>
        </trans-unit>
        <trans-unit id="195b1279f51510a869c9ae7e93ef77f8d07cfcaf" translate="yes" xml:space="preserve">
          <source>Get the module of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; のモジュールを取得します。</target>
        </trans-unit>
        <trans-unit id="dfd8ea5bc6022f728ddbfd7c123fbf615d9688aa" translate="yes" xml:space="preserve">
          <source>Get the next value from the &lt;code&gt;TBQueue&lt;/code&gt; without removing it, retrying if the channel is empty.</source>
          <target state="translated">削除せずに &lt;code&gt;TBQueue&lt;/code&gt; から次の値を取得し、チャネルが空の場合は再試行します。</target>
        </trans-unit>
        <trans-unit id="ea4da6389ff2053f72d8e6ce3d12629df113a35f" translate="yes" xml:space="preserve">
          <source>Get the next value from the &lt;code&gt;TChan&lt;/code&gt; without removing it, retrying if the channel is empty.</source>
          <target state="translated">削除せずに &lt;code&gt;TChan&lt;/code&gt; から次の値を取得し、チャネルが空の場合は再試行します。</target>
        </trans-unit>
        <trans-unit id="12978c3ca4699ea4b74cf23abc51101451dfa99c" translate="yes" xml:space="preserve">
          <source>Get the next value from the &lt;code&gt;TQueue&lt;/code&gt; without removing it, retrying if the channel is empty.</source>
          <target state="translated">削除せずに &lt;code&gt;TQueue&lt;/code&gt; から次の値を取得し、チャネルが空の場合は再試行します。</target>
        </trans-unit>
        <trans-unit id="bf9180c869cf2ed71dc13f9fcb1eb1c6e3205b73" translate="yes" xml:space="preserve">
          <source>Get the number of picoseconds in a &lt;code&gt;&lt;a href=&quot;data-time-clock#t:DiffTime&quot;&gt;DiffTime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-clock#t:DiffTime&quot;&gt;DiffTime&lt;/a&gt;&lt;/code&gt; のピコ秒数を取得します。</target>
        </trans-unit>
        <trans-unit id="c41d9abbda9d142fc31fefd829bb6067eeb4ce90" translate="yes" xml:space="preserve">
          <source>Get the number of the Monday-starting week in the year and the day of the week. The first Monday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%W&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;). Monday is 1, Sunday is 7 (as &lt;code&gt;%u&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">年の月曜始まりの週の番号と曜日を取得します。最初の月曜日は週1の最初の日で、年のいずれかの早い日は週0です（として &lt;code&gt;%W&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ）。月曜日は日曜日（7ようで、1 &lt;code&gt;%u&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0df1f5547dc8aa7816f6fad31fb426c23b895b69" translate="yes" xml:space="preserve">
          <source>Get the number of the Sunday-starting week in the year and the day of the week. The first Sunday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%U&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;). Sunday is 0, Saturday is 6 (as &lt;code&gt;%w&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">その年の日曜日から始まる週数と曜日を取得します。最初の日曜日は、年のいずれかの早い日（として週0で週1の最初の日である &lt;code&gt;%U&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ）。日曜日は0で、土曜日は（として6 &lt;code&gt;%w&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="121d46ceb7a963cb07f940143c37c6199a392894" translate="yes" xml:space="preserve">
          <source>Get the permissions of a file or directory.</source>
          <target state="translated">ファイルやディレクトリのパーミッションを取得します。</target>
        </trans-unit>
        <trans-unit id="0b02102ad5781ec349c4ebacac0f7e53440d1227" translate="yes" xml:space="preserve">
          <source>Get the precedence of a fixity value.</source>
          <target state="translated">固定値の優先順位を取得します。</target>
        </trans-unit>
        <trans-unit id="e7143c5b76253904c07ab35abe499b891a12912e" translate="yes" xml:space="preserve">
          <source>Get the remaining bytes as a lazy ByteString. Note that this can be an expensive function to use as it forces reading all input and keeping the string in-memory.</source>
          <target state="translated">残りのバイトを遅延ByteStringとして取得します。これは、すべての入力を読み込んで文字列をメモリに保持しなければならないため、使用するには高価な関数になることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1304ab12c0cdd21150623c6715f63616fbbb4e78" translate="yes" xml:space="preserve">
          <source>Get the seconds in a &lt;code&gt;&lt;a href=&quot;data-time-clock#t:NominalDiffTime&quot;&gt;NominalDiffTime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-clock#t:NominalDiffTime&quot;&gt;NominalDiffTime&lt;/a&gt;&lt;/code&gt; の秒を取得します。</target>
        </trans-unit>
        <trans-unit id="934367e164393d0463e93c43a0ab568d78bce4aa" translate="yes" xml:space="preserve">
          <source>Get the source span of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; のソーススパンを取得します。</target>
        </trans-unit>
        <trans-unit id="3c3cbce66b5c2a88daa26c2b44a8fd7660727935" translate="yes" xml:space="preserve">
          <source>Get the source span of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; のソーススパンを取得します。</target>
        </trans-unit>
        <trans-unit id="d92d0722c9103f5297ca98c8e8cc4cdf409d235d" translate="yes" xml:space="preserve">
          <source>Get the stack trace attached to an object.</source>
          <target state="translated">オブジェクトにアタッチされたスタックトレースを取得します。</target>
        </trans-unit>
        <trans-unit id="ef4ec76b2d57cdc855102b78c7d2aacd5eb5df5f" translate="yes" xml:space="preserve">
          <source>Get the string corresponding to the given format specifier.</source>
          <target state="translated">指定されたフォーマット指定子に対応する文字列を取得します。</target>
        </trans-unit>
        <trans-unit id="87aef325e766ce9f4d00515df7046505bd4518cc" translate="yes" xml:space="preserve">
          <source>Get the system time, epoch start of 1970 UTC, leap-seconds ignored. &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; is typically much faster than &lt;code&gt;getCurrentTime&lt;/code&gt;.</source>
          <target state="translated">システム時刻、1970 UTCのエポックスタートを取得し、うるう秒は無視されます。 &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; は通常、 &lt;code&gt;getCurrentTime&lt;/code&gt; よりもはるかに高速です。</target>
        </trans-unit>
        <trans-unit id="7079387e20d5a7e77408141907d7b3e57605a870" translate="yes" xml:space="preserve">
          <source>Get the tail of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; の末尾を取得します。</target>
        </trans-unit>
        <trans-unit id="0d673419acfa57ddfd2386504b1ce9ad7e3752ee" translate="yes" xml:space="preserve">
          <source>Get the tail of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; の末尾を取得します。</target>
        </trans-unit>
        <trans-unit id="9fd6f0d6fca981e6ab4e6521490eddb2c5712dc5" translate="yes" xml:space="preserve">
          <source>Get the time of day given a time since midnight. Time more than 24h will be converted to leap-seconds.</source>
          <target state="translated">深夜0時からの時間を与えられた時刻を取得します。24時間以上の時間は閏秒に変換されます。</target>
        </trans-unit>
        <trans-unit id="8502401c97ea5b01798883d629ca915252c4bb4a" translate="yes" xml:space="preserve">
          <source>Get the time of day given the fraction of a day since midnight.</source>
          <target state="translated">深夜からの一日の端数を与えられた時間を取得します。</target>
        </trans-unit>
        <trans-unit id="87868e820d0672f58ddcfe614c42c8b0983a793a" translate="yes" xml:space="preserve">
          <source>Get the time since midnight for a given time of day.</source>
          <target state="translated">指定された時間帯の午前0時からの時間を取得します。</target>
        </trans-unit>
        <trans-unit id="1b78fe6cc806943f6f8e66a65db6ae9cfdb7e198" translate="yes" xml:space="preserve">
          <source>Get the total number of bytes read to this point.</source>
          <target state="translated">この時点までに読み込まれた総バイト数を取得します。</target>
        </trans-unit>
        <trans-unit id="b2759c7b05c76b086373cf3cd5862282e5c13612" translate="yes" xml:space="preserve">
          <source>Get user name. See: &lt;a href=&quot;https://github.com/haskell/win32/issues/8&quot;&gt;https://github.com/haskell/win32/issues/8&lt;/a&gt;, &lt;a href=&quot;http://lpaste.net/41521&quot;&gt;http://lpaste.net/41521&lt;/a&gt;</source>
          <target state="translated">ユーザー名を取得します。参照：&lt;a href=&quot;https://github.com/haskell/win32/issues/8&quot;&gt;https://github.com/haskell/win32/issues/8&lt;/a&gt;、&lt;a href=&quot;http://lpaste.net/41521&quot;&gt;http://lpaste.net/41521&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5c8a83eb7ab72a3dc65bc027d0f4aa047843fc7" translate="yes" xml:space="preserve">
          <source>Get/Set Foreground Window.</source>
          <target state="translated">前景ウィンドウを取得/設定します。</target>
        </trans-unit>
        <trans-unit id="903bf1d323eabebea6c98315f978de0785ae607a" translate="yes" xml:space="preserve">
          <source>GetDCExFlags</source>
          <target state="translated">GetDCExFlags</target>
        </trans-unit>
        <trans-unit id="89693458149c776750a29304631c344bbe585ec6" translate="yes" xml:space="preserve">
          <source>GetOpt</source>
          <target state="translated">GetOpt</target>
        </trans-unit>
        <trans-unit id="bebb9ee2bec563ef922802bc58d46f783e690375" translate="yes" xml:space="preserve">
          <source>Gets a GHC Handle File description from the given OS Handle or POSIX fd.</source>
          <target state="translated">与えられたOSハンドルまたはPOSIX fdからGHCハンドルファイルの記述を取得します。</target>
        </trans-unit>
        <trans-unit id="391454aac39ac02e0b6599b94000d8e1ad34b74e" translate="yes" xml:space="preserve">
          <source>Gets specific component of the state, using a projection function supplied.</source>
          <target state="translated">指定された投影関数を用いて、状態の特定の要素を取得します。</target>
        </trans-unit>
        <trans-unit id="6061427a31c5db7d197b3782356bc17d6f9846c4" translate="yes" xml:space="preserve">
          <source>Gets the constructor for an index (algebraic datatypes only)</source>
          <target state="translated">インデックスのコンストラクタを取得する (代数的なデータ型のみ)</target>
        </trans-unit>
        <trans-unit id="d48574aaa6a44f8bb266db4ad641f32e96c244ee" translate="yes" xml:space="preserve">
          <source>Gets the constructors of an algebraic datatype</source>
          <target state="translated">代数データ型のコンストラクタを取得する.</target>
        </trans-unit>
        <trans-unit id="30d18e2f7f8f2762c44e631f431574183f3d5e0a" translate="yes" xml:space="preserve">
          <source>Gets the datatype of a constructor</source>
          <target state="translated">コンストラクタのデータ型を取得します。</target>
        </trans-unit>
        <trans-unit id="d4dc76f4469b81893c0ae2bc88486f930017fb3d" translate="yes" xml:space="preserve">
          <source>Gets the field labels of a constructor. The list of labels is returned in the same order as they were given in the original constructor declaration.</source>
          <target state="translated">コンストラクタのフィールドラベルを取得します。ラベルのリストは、元のコンストラクタ宣言で与えられたものと同じ順番で返されます。</target>
        </trans-unit>
        <trans-unit id="e7a5b1389209d807faab0ae733fe92f6a6a0918a" translate="yes" xml:space="preserve">
          <source>Gets the fixity of a constructor</source>
          <target state="translated">コンストラクタの固定性を取得します。</target>
        </trans-unit>
        <trans-unit id="2aeda0e99dcc18340bc33ab99d623627ed797ffd" translate="yes" xml:space="preserve">
          <source>Gets the index of a constructor (algebraic datatypes only)</source>
          <target state="translated">コンストラクタのインデックスを取得します(代数的なデータ型のみ)。</target>
        </trans-unit>
        <trans-unit id="24b5a11d77af890b85eeec066f5550cfcba9c2d2" translate="yes" xml:space="preserve">
          <source>Gets the maximum constructor index of an algebraic datatype</source>
          <target state="translated">代数データ型の最大コンストラクタインデックスを取得する。</target>
        </trans-unit>
        <trans-unit id="63208cbec1942c64c7945f85554d64b17e167933" translate="yes" xml:space="preserve">
          <source>Gets the module of a type constructor: take *.*.*... before name</source>
          <target state="translated">コンストラクタ型のモジュールを取得します:take *.*.*.*...before name</target>
        </trans-unit>
        <trans-unit id="a14644b47cefa2fe7b14baa4f1e18f50cba475e7" translate="yes" xml:space="preserve">
          <source>Gets the public presentation of a datatype</source>
          <target state="translated">データ型の公開プレゼンテーションを取得します。</target>
        </trans-unit>
        <trans-unit id="aa6153842db5ae726fc9aeb6bbb6b9011dfbc619" translate="yes" xml:space="preserve">
          <source>Gets the public presentation of constructors</source>
          <target state="translated">コンストラクタの公開プレゼンテーションを取得します。</target>
        </trans-unit>
        <trans-unit id="703cb827ba9bdd1f867b291abff6c22c30e6a5e1" translate="yes" xml:space="preserve">
          <source>Gets the string for a constructor</source>
          <target state="translated">コンストラクタの文字列を取得します。</target>
        </trans-unit>
        <trans-unit id="073e5a617058affe4e3dd60346b258d7e3ada99f" translate="yes" xml:space="preserve">
          <source>Gets the type constructor including the module</source>
          <target state="translated">モジュールを含む型のコンストラクタを取得します。</target>
        </trans-unit>
        <trans-unit id="878dc6c0dba59b9499bd6c7cb41176237f1830f2" translate="yes" xml:space="preserve">
          <source>Gets the unqualified type constructor: drop *.*.*... before name</source>
          <target state="translated">非限定型のコンストラクタを取得します:drop *.*.*.*...before name</target>
        </trans-unit>
        <trans-unit id="eae1640c76d18f7f4e0493ecb26f076efc1608f6" translate="yes" xml:space="preserve">
          <source>Give arguments to a plugin module; module must be specified with &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">プラグインモジュールに引数を与えます。moduleは&lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt; &lt;/a&gt;指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="e2007c872e45e146dace044ab7de7d8433373895" translate="yes" xml:space="preserve">
          <source>Give arguments to a plugin module; module must be specified with &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;</source>
          <target state="translated">プラグインモジュールに引数を与えます。モジュールは &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt; 指定する必要があります</target>
        </trans-unit>
        <trans-unit id="df37476f32c9a34e20351ac98761daee0a7c8824" translate="yes" xml:space="preserve">
          <source>Give explicit type signatures:</source>
          <target state="translated">明示的な型署名を与えます。</target>
        </trans-unit>
        <trans-unit id="b1486578eb7ad0f6181dbd9aee1d050053d73d85" translate="yes" xml:space="preserve">
          <source>GiveGCStats</source>
          <target state="translated">GiveGCStats</target>
        </trans-unit>
        <trans-unit id="94191c500f1483bd7efa1a2a99e51782da6743c9" translate="yes" xml:space="preserve">
          <source>Given a compact and the address of one its blocks, returns the next block and its size, or #nullAddr if the argument was the last block in the compact.</source>
          <target state="translated">コンパクトとそのブロックの1つのアドレスが与えられると、次のブロックとそのサイズを、引数がコンパクトの最後のブロックの場合は#nullAddrを返します。</target>
        </trans-unit>
        <trans-unit id="3a80b2cab78c4d18e4e971d00e535e51ca962e1e" translate="yes" xml:space="preserve">
          <source>Given a list of path segments, expand &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt;. The path segments must not contain path separators.</source>
          <target state="translated">パスセグメントのリストを指定して、を展開し &lt;code&gt;.&lt;/code&gt; そして &lt;code&gt;..&lt;/code&gt; .。パスセグメントにパスセパレータを含めることはできません。</target>
        </trans-unit>
        <trans-unit id="c3c7188c588c63ac10069c82a4b6f332a946f2d2" translate="yes" xml:space="preserve">
          <source>Given a list of strings, concatenate them into a single string with escaping of certain characters, and the addition of a newline between each string. The escaping is done by adding a single backslash character before any whitespace, single quote, double quote, or backslash character, so this escaping character must be removed. Unescaped whitespace (in this case, newline) is part of this &quot;transport&quot; format to indicate the end of the previous string and the start of a new string.</source>
          <target state="translated">文字列のリストが与えられたら、それらを連結して、特定の文字をエスケープし、各文字列の間に改行を追加して1つの文字列にします。エスケープは、空白文字、単一引用符、二重引用符、バックスラッシュ文字の前に一文字のバックスラッシュを追加することで行われるので、このエスケープ文字は削除しなければなりません。エスケープされていない空白(この場合、改行)は、前の文字列の終わりと新しい文字列の始まりを示すために、この &quot;トランスポート &quot;フォーマットの一部となっています。</target>
        </trans-unit>
        <trans-unit id="16da4c70b81333f0df3ff68a48df5f83b45f827d" translate="yes" xml:space="preserve">
          <source>Given a means of mapping the elements of a structure to lists, computes the concatenation of all such lists in order.</source>
          <target state="translated">構造体の要素をリストにマッピングする手段が与えられると,そのようなすべてのリストの連結を順番に計算します.</target>
        </trans-unit>
        <trans-unit id="3a801cbb38fd452cebffd80bbe0ff104534670f0" translate="yes" xml:space="preserve">
          <source>Given a name or path, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; appends the &lt;code&gt;&lt;a href=&quot;system-directory#v:exeExtension&quot;&gt;exeExtension&lt;/a&gt;&lt;/code&gt; to the query and searches for executable files in the list of given search directories and returns all occurrences.</source>
          <target state="translated">名前またはパスを指定すると、 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; はクエリに &lt;code&gt;&lt;a href=&quot;system-directory#v:exeExtension&quot;&gt;exeExtension&lt;/a&gt;&lt;/code&gt; を追加し、指定された検索ディレクトリのリストで実行可能ファイルを検索して、すべての出現箇所を返します。</target>
        </trans-unit>
        <trans-unit id="f60a5850abfa409415094c2e4639245bcd5e4453" translate="yes" xml:space="preserve">
          <source>Given a parallel comprehension of the form:</source>
          <target state="translated">形の平行理解を与えられる。</target>
        </trans-unit>
        <trans-unit id="7f7b64d5937cb8bf270b46af60debea6611cd0d2" translate="yes" xml:space="preserve">
          <source>Given a pattern synonym definition of the form</source>
          <target state="translated">フォームのパターン同義語の定義を与えられた</target>
        </trans-unit>
        <trans-unit id="965f2d8e8f9362b4a99f9e5b536b6cb970cf61ea" translate="yes" xml:space="preserve">
          <source>Given a program &lt;code&gt;&lt;em&gt;p&lt;/em&gt;&lt;/code&gt; and arguments &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt;, &lt;code&gt;showCommandForUser &lt;em&gt;p&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; returns a string suitable for pasting into &lt;code&gt;/bin/sh&lt;/code&gt; (on Unix systems) or &lt;code&gt;CMD.EXE&lt;/code&gt; (on Windows).</source>
          <target state="translated">プログラム &lt;code&gt;&lt;em&gt;p&lt;/em&gt;&lt;/code&gt; と引数 &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; を指定すると、 &lt;code&gt;showCommandForUser &lt;em&gt;p&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; は、 &lt;code&gt;/bin/sh&lt;/code&gt; （UNIXシステムの場合）または &lt;code&gt;CMD.EXE&lt;/code&gt; （Windowsの場合）に貼り付けるのに適した文字列を返します。</target>
        </trans-unit>
        <trans-unit id="3eb5e163812056919d8a8728f088bc84becbf489" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, a destination array, an offset into the destination array, and a number of elements to copy, copy the elements from the source array to the destination array. Both arrays must fully contain the specified ranges, but this is not checked. In the case where the source and destination are the same array the source and destination regions may overlap.</source>
          <target state="translated">コピー元の配列,コピー元の配列へのオフセット,コピー先の配列,コピー先の配列へのオフセット,コピーする要素の数が指定されている場合,コピー元の配列からコピー先の配列に要素をコピーします.両方の配列が指定された範囲を完全に含む必要がありますが,これはチェックされません.コピー元とコピー先が同じ配列の場合,コピー元の領域とコピー先の領域が重なることがあります.</target>
        </trans-unit>
        <trans-unit id="397134dbcf199297b7dfe8e0847122e69780ab05" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, a destination array, an offset into the destination array, and a number of elements to copy, copy the elements from the source array to the destination array. Both arrays must fully contain the specified ranges, but this is not checked. The two arrays must not be the same array in different states, but this is not checked either.</source>
          <target state="translated">コピー元の配列,コピー元の配列へのオフセット,コピー先の配列,コピー先の配列へのオフセット,コピーする要素の数が指定されている場合,コピー元の配列からコピー先の配列に要素をコピーします.両方の配列は,指定された範囲を完全に含んでいなければなりませんが,これはチェックされません.2 つの配列は,異なる状態の同じ配列であってはいけませんが,これもチェックされません.</target>
        </trans-unit>
        <trans-unit id="7b650bc9b9dd959ede9c56caf5b27fbb08e9b7a5" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, a destination array, an offset into the destination array, and a number of elements to copy, copy the elements from the source array to the destination array. The source and destination arrays can refer to the same array. Both arrays must fully contain the specified ranges, but this is not checked. The regions are allowed to overlap, although this is only possible when the same array is provided as both the source and the destination.</source>
          <target state="translated">コピー元の配列,コピー元の配列へのオフセット,コピー先の配列,コピー先の配列へのオフセット,コピーする要素の数が与えられたとき,コピー元の配列からコピー先の配列に要素をコピーします.コピー元配列とコピー先配列は,同じ配列を参照することができます.両方の配列は,指定された範囲を完全に含む必要がありますが,これはチェックされません.領域は重複しても構いませんが,これは送信元と送信先の両方に同じ配列が提供されている場合にのみ可能です.</target>
        </trans-unit>
        <trans-unit id="e9806083ebd16a3822ef2b68e8b1fdca151f0e70" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, and a number of elements to copy, create a new array with the elements from the source array. The provided array must fully contain the specified range, but this is not checked.</source>
          <target state="translated">元の配列,元の配列へのオフセット,コピーする要素の数が与えられた場合,元の配列の要素を用いて新しい配列を作成します.指定された配列は、指定された範囲を完全に含む必要がありますが、これはチェックされません。</target>
        </trans-unit>
        <trans-unit id="969049b655813db2b900482374a384fed3209666" translate="yes" xml:space="preserve">
          <source>Given a string of concatenated strings, separate each by removing a layer of &lt;em&gt;quoting&lt;/em&gt; and/or &lt;em&gt;escaping&lt;/em&gt; of certain characters.</source>
          <target state="translated">連結された文字列の文字列が与えられた場合、特定の文字の&lt;em&gt;引用&lt;/em&gt;および/または&lt;em&gt;エスケープ&lt;/em&gt;の層を削除することにより、それぞれを区切ります。</target>
        </trans-unit>
        <trans-unit id="03e6b879d2b54e40963864600799d0ff4945f213" translate="yes" xml:space="preserve">
          <source>Given a value of type &lt;code&gt;Right a&lt;/code&gt;, GHC must produce a value of type &lt;code&gt;Right b&lt;/code&gt;. Since the argument to the &lt;code&gt;Right&lt;/code&gt; constructor has type &lt;code&gt;Either Int a&lt;/code&gt;, the code recursively calls &lt;code&gt;fmap&lt;/code&gt; on it to produce a value of type &lt;code&gt;Either Int b&lt;/code&gt;, which is used in turn to construct a final value of type &lt;code&gt;Right b&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;Right a&lt;/code&gt; 値が与えられると、GHCはタイプ &lt;code&gt;Right b&lt;/code&gt; の値を生成する必要があります。 &lt;code&gt;Right&lt;/code&gt; コンストラクターの引数は &lt;code&gt;Either Int a&lt;/code&gt; 型であるため、コードはその上で &lt;code&gt;fmap&lt;/code&gt; を再帰的に呼び出し、 &lt;code&gt;Either Int b&lt;/code&gt; 型の値を生成します。これは、 &lt;code&gt;Right b&lt;/code&gt; 型の最終値を構築するために使用されます。</target>
        </trans-unit>
        <trans-unit id="7aaad46966fd2f7a4a7364b632ff8275c3c05bbf" translate="yes" xml:space="preserve">
          <source>Given a year, find Easter according to Orthodox Christian tradition</source>
          <target state="translated">年を考えると、正統派キリスト教の伝統に基づいてイースターを見つける</target>
        </trans-unit>
        <trans-unit id="4140020fabc63460d4c747a4e5f0b417d3732e7f" translate="yes" xml:space="preserve">
          <source>Given a year, find Easter according to the Gregorian method</source>
          <target state="translated">年が与えられた場合、グレゴリオ暦の方法でイースターを見つけてください。</target>
        </trans-unit>
        <trans-unit id="a90b9b7c80eb2a84b94bea4951e31b81448a4a8d" translate="yes" xml:space="preserve">
          <source>Given a year, find the Paschal full moon according to Orthodox Christian tradition</source>
          <target state="translated">1年を与えられたとき、正統派キリスト教の伝統に基づいて、大祭の満月を見つけてください。</target>
        </trans-unit>
        <trans-unit id="db828b10c64e473910ca6113376ab95106d563c4" translate="yes" xml:space="preserve">
          <source>Given a year, find the Paschal full moon according to the Gregorian method</source>
          <target state="translated">年が与えられたとき、グレゴリオ式の方法で大祭の満月を見つけてください。</target>
        </trans-unit>
        <trans-unit id="230679363978006fa3682de32adc84e8302aac8e" translate="yes" xml:space="preserve">
          <source>Given an arbitrary address and an alignment constraint, &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; yields the next higher address that fulfills the alignment constraint. An alignment constraint &lt;code&gt;x&lt;/code&gt; is fulfilled by any address divisible by &lt;code&gt;x&lt;/code&gt;. This operation is idempotent.</source>
          <target state="translated">任意のアドレスとアライメント制約が与えられた場合、 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; は、アライメント制約を満たす次に高いアドレスを生成します。アラインメント制約 &lt;code&gt;x&lt;/code&gt; は、 &lt;code&gt;x&lt;/code&gt; で割り切れるアドレスによって満たされます。この操作はべき等です。</target>
        </trans-unit>
        <trans-unit id="273674e552deb353cd1f1485d7f784e9fb5ab934" translate="yes" xml:space="preserve">
          <source>Given an arbitrary address and an alignment constraint, &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; yields the next higher address that fulfills the alignment constraint. An alignment constraint &lt;code&gt;x&lt;/code&gt; is fulfilled by any address divisible by &lt;code&gt;x&lt;/code&gt;. This operation is idempotent.</source>
          <target state="translated">任意のアドレスとアライメント制約が与えられた場合、 &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; は、アライメント制約を満たす次に高いアドレスを生成します。アラインメント制約 &lt;code&gt;x&lt;/code&gt; は、 &lt;code&gt;x&lt;/code&gt; で割り切れるアドレスによって満たされます。この操作はべき等です。</target>
        </trans-unit>
        <trans-unit id="94a3648c0f213883825b8c965009fc57ba6053ee" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in Int units, read an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="translated">配列とオフセットが Int 単位で与えられているとき、要素を読み込みます。インデックスは範囲内にあるものとします。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="c8a17c8b3ab79de903cc8400da257eb8e7123d8d" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in Int units, write an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="translated">配列とオフセットが Int 単位で与えられたとき、要素を書きます。インデックスは境界内にあるものとします。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="5d1f573275c2dbc9e7b212c54458e83eb9b94330" translate="yes" xml:space="preserve">
          <source>Given an array, an offset in Int units, the expected old value, and the new value, perform an atomic compare and swap i.e. write the new value if the current value matches the provided old value. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列と Int 単位のオフセット、期待される古い値と新しい値が与えられた場合、アトミックな比較とスワップ、つまり現在の値が与えられた古い値と一致する場合に新しい値を書き込みます。つまり、現在の値が指定された古い値と一致した場合に新しい値を書き込みます。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="146fbb7f3f09edd6ae4d6b2a239b5ce5de075b01" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to AND, atomically AND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列とオフセットをInt単位で指定し、ANDに値を指定すると、その要素に原子的にANDを行います。演算前の要素の値を返します。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="49755d03cb750cc282b1378fdb97b26101b9cc3a" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to NAND, atomically NAND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列とInt単位でのオフセット、NANDへの値が与えられた場合、その値を要素に原子的にNANDします。演算前の要素の値を返します。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="ea6fdeeb52e6775a8f40a257cda009b7a5a4220c" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to OR, atomically OR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列とオフセットをInt単位で指定し、ORする値を与えられた場合、その値を要素に原子的にORします。演算前の要素の値を返します。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="4777b0fe2da60d417590241fa61d0ccc6e0bb4b4" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to XOR, atomically XOR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列とオフセットをInt単位で指定し、XORする値が与えられた場合、その値を要素に原子的にXORします。演算前の要素の値を返します。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="29c06c151d779aa5995efae3b3901f99e551b9c5" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to add, atomically add the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列とオフセットをInt単位で指定し、加算する値を指定すると、その値を要素に原子的に加算します。操作前の要素の値を返します。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="20a058f6323b50073951b1b5f3f5e171eb991d2b" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to subtract, atomically substract the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列と、Int単位でのオフセットと、減算する値が与えられたとき、その値を要素に原子的に減算します。演算前の要素の値を返します。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="1133d340ebaabdb6f3a72cccae83fbf1b0c933cc" translate="yes" xml:space="preserve">
          <source>Given that &lt;code&gt;Int#&lt;/code&gt;&amp;lsquo;s kind is not &lt;code&gt;Type&lt;/code&gt;, it then it follows that &lt;code&gt;Maybe
Int#&lt;/code&gt; is disallowed. Similarly, because type variables tend to be of kind &lt;code&gt;Type&lt;/code&gt; (for example, in &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt;, all the type variables have kind &lt;code&gt;Type&lt;/code&gt;), polymorphism tends not to work over primitive types. Stepping back, this makes some sense, because a polymorphic function needs to manipulate the pointers to its data, and most primitive types are unboxed.</source>
          <target state="translated">ことを考える &lt;code&gt;Int#&lt;/code&gt; のようなものではない &lt;code&gt;Type&lt;/code&gt; 、それはということになる &lt;code&gt;Maybe Int#&lt;/code&gt; 許可されていません。同様に、型変数は種類が &lt;code&gt;Type&lt;/code&gt; になる傾向があるため（たとえば、 &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt; 、すべての型変数は種類 &lt;code&gt;Type&lt;/code&gt; を持ちます） 、ポリモーフィズムはプリミティブ型では機能しない傾向があります。これは、多態性関数がそのデータへのポインターを操作する必要があり、ほとんどのプリミティブ型がボックス化されていないため、少し前に戻ります。</target>
        </trans-unit>
        <trans-unit id="997d69bcb3242b4498d781fc27199701d0a45530" translate="yes" xml:space="preserve">
          <source>Given that &lt;code&gt;Int#&lt;/code&gt;&amp;rsquo;s kind is not &lt;code&gt;Type&lt;/code&gt;, it then it follows that &lt;code&gt;Maybe
Int#&lt;/code&gt; is disallowed. Similarly, because type variables tend to be of kind &lt;code&gt;Type&lt;/code&gt; (for example, in &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt;, all the type variables have kind &lt;code&gt;Type&lt;/code&gt;), polymorphism tends not to work over primitive types. Stepping back, this makes some sense, because a polymorphic function needs to manipulate the pointers to its data, and most primitive types are unboxed.</source>
          <target state="translated">ことを考える &lt;code&gt;Int#&lt;/code&gt; のようなものではない &lt;code&gt;Type&lt;/code&gt; 、それはということになる &lt;code&gt;Maybe Int#&lt;/code&gt; 許可されていません。同様に、型変数は種類 &lt;code&gt;Type&lt;/code&gt; である傾向があるため（たとえば、 &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt; 、すべての型変数は種類 &lt;code&gt;Type&lt;/code&gt; を持ちます） 、ポリモーフィズムはプリミティブ型では機能しない傾向があります。多態的な関数はそのデータへのポインターを操作する必要があり、ほとんどのプリミティブ型はボックス化されていないため、一歩下がると、これはある程度意味があります。</target>
        </trans-unit>
        <trans-unit id="83affa710671002c026d340422ac4f2dacd5da78" translate="yes" xml:space="preserve">
          <source>Given that this works on a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; it is allowed to fail if you request 0 or fewer repetitions, and the default definition will do so.</source>
          <target state="translated">これが &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; で機能する場合、0回以下の繰り返しを要求すると失敗することが許可され、デフォルトの定義でそれが行われます。</target>
        </trans-unit>
        <trans-unit id="5eaccc9b609fc135977a1c7db325f9c1b56135cd" translate="yes" xml:space="preserve">
          <source>Given that this works on a &lt;code&gt;&lt;a href=&quot;ghc-base#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; it is allowed to fail if you request 0 or fewer repetitions, and the default definition will do so.</source>
          <target state="translated">これが &lt;code&gt;&lt;a href=&quot;ghc-base#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; で機能する場合、0回以下の繰り返しを要求すると失敗することが許可され、デフォルトの定義でそれが行われます。</target>
        </trans-unit>
        <trans-unit id="3f88a1db5338e0d53c15325042511dce1cff7e31" translate="yes" xml:space="preserve">
          <source>Given the dependency information that we have for &lt;code&gt;Collects&lt;/code&gt;, however, we can deduce that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; must be equal because they both appear as the second parameter in a &lt;code&gt;Collects&lt;/code&gt; constraint with the same first parameter &lt;code&gt;c&lt;/code&gt;. Hence we can infer a shorter and more accurate type for &lt;code&gt;f&lt;/code&gt;:</source>
          <target state="translated">ただし、 &lt;code&gt;Collects&lt;/code&gt; の依存関係情報を考慮すると &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; は同じ最初のパラメーター &lt;code&gt;c&lt;/code&gt; を持つ &lt;code&gt;Collects&lt;/code&gt; 制約の2番目のパラメーターとして表示されるため、これらは等しい必要があると推定できます。したがって、 &lt;code&gt;f&lt;/code&gt; のより短くて正確な型を推測できます。</target>
        </trans-unit>
        <trans-unit id="ac01c957b2153efeefd66d648f6d151ec2182d8f" translate="yes" xml:space="preserve">
          <source>Given the example &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;/directory/file.ext&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; の例を &lt;code&gt;/directory/file.ext&lt;/code&gt; ます：/directory/file.ext</target>
        </trans-unit>
        <trans-unit id="18d2d272bdc4a0484a15d052c32887610cf8fa0a" translate="yes" xml:space="preserve">
          <source>Given the example &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;/directory/file.ext&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; の例を &lt;code&gt;/directory/file.ext&lt;/code&gt; ます：/directory/file.ext</target>
        </trans-unit>
        <trans-unit id="2cab47cf0c2da762f2cc7ef137cb437446a0f551" translate="yes" xml:space="preserve">
          <source>Given the functionality provided by GADTs (Generalised Algebraic Data Types), it might seem as if a definition, such as the above, should be feasible. However, type families - in contrast to GADTs - are &lt;em&gt;open;&lt;/em&gt; i.e., new instances can always be added, possibly in other modules. Supporting pattern matching across different data instances would require a form of extensible case construct.</source>
          <target state="translated">GADT（一般化代数データ型）によって提供される機能を考えると、上記のような定義が実現可能であるかのように見える場合があります。ただし、GADTとは対照的に、タイプファミリーは&lt;em&gt;オープンです。&lt;/em&gt;つまり、新しいインスタンスは常に、おそらく他のモジュールに追加できます。異なるデータインスタンス間のパターンマッチングをサポートするには、拡張可能なケースコンストラクトの形式が必要です。</target>
        </trans-unit>
        <trans-unit id="a67b69f19a4f3217074f6e6525e405d47da97d1b" translate="yes" xml:space="preserve">
          <source>Given the maximum size needed and a function to make the contents of a ByteString, createAndTrim makes the &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The generating function is required to return the actual final size (&amp;lt;= the maximum size), and the resulting byte array is realloced to this size.</source>
          <target state="translated">必要な最大サイズとByteStringのコンテンツを作成する関数を指定すると、createAndTrimは &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; を作成します。生成関数は実際の最終サイズ（&amp;lt;=最大サイズ）を返す必要があり、結果のバイト配列はこのサイズに再割り当てされます。</target>
        </trans-unit>
        <trans-unit id="c2632edc2edf21e0a0a8e5fc487c9aa010583290" translate="yes" xml:space="preserve">
          <source>Given the name or path of an executable file, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; searches for such a file in a list of system-defined locations, which generally includes &lt;code&gt;PATH&lt;/code&gt; and possibly more. The full path to the executable is returned if found. For example, &lt;code&gt;(findExecutable &quot;ghc&quot;)&lt;/code&gt; would normally give you the path to GHC.</source>
          <target state="translated">実行可能ファイルの名前またはパスが指定されると、 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; は、システム定義の場所のリストでそのようなファイルを検索します。これには、通常、 &lt;code&gt;PATH&lt;/code&gt; とそれ以上が含まれます。見つかった場合、実行可能ファイルへのフルパスが返されます。たとえば、 &lt;code&gt;(findExecutable &quot;ghc&quot;)&lt;/code&gt; は通常、GHCへのパスを提供します。</target>
        </trans-unit>
        <trans-unit id="2966883e0811760b82984a872c8146237c738512" translate="yes" xml:space="preserve">
          <source>Given the pointer to the first block of a compact, and the address of the root object in the old address space, fix up the internal pointers inside the compact to account for a different position in memory than when it was serialized. This method must be called exactly once after importing a serialized compact, and returns the new compact and the new adjusted root address.</source>
          <target state="translated">コンパクトの最初のブロックへのポインタと、古いアドレス空間のルートオブジェクトのアドレスが与えられたら、コンパクトの内部ポインタを修正して、シリアル化された時とは異なるメモリ上の位置を考慮します。このメソッドは、シリアル化されたコンパクトをインポートした後に一度だけ呼び出す必要があり、新しいコンパクトと調整された新しいルートアドレスを返します。</target>
        </trans-unit>
        <trans-unit id="137079684701bb7548bd7c488c5563dff2fd8425" translate="yes" xml:space="preserve">
          <source>Given this declaration the following are examples of well-formed and malformed types:</source>
          <target state="translated">この宣言を考えると、以下は整形型と不正型の例です。</target>
        </trans-unit>
        <trans-unit id="873940b25d330c24756f020ef03429c4416f9796" translate="yes" xml:space="preserve">
          <source>Giving a &lt;code&gt;+RTS -?&lt;/code&gt; RTS option option will print out the RTS options actually available in your program (which vary, depending on how you compiled).</source>
          <target state="translated">&lt;code&gt;+RTS -?&lt;/code&gt; 与える-？RTSオプションオプションは、プログラムで実際に使用可能なRTSオプションを出力します（コンパイル方法によって異なります）。</target>
        </trans-unit>
        <trans-unit id="be7adce77c3e4198098a2e71503600194529aaa3" translate="yes" xml:space="preserve">
          <source>Giving a RULE for a class method is a bad idea:</source>
          <target state="translated">クラスメソッドにルールを与えるのはよくないことです。</target>
        </trans-unit>
        <trans-unit id="8d25ca6db124879efd114f19378aa116f6113a87" translate="yes" xml:space="preserve">
          <source>Glasgow Haskell is a changing system so there are sure to be bugs in it. If you find one, please see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ReportABug&quot;&gt;this wiki page&lt;/a&gt; for information on how to report it.</source>
          <target state="translated">Glasgow Haskellはシステムを変更しているので、バグが確実にあります。見つけた場合は、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ReportABug&quot;&gt;このWikiページ&lt;/a&gt;で報告方法を確認してください。</target>
        </trans-unit>
        <trans-unit id="9429e6f82d8b0009815227447cf86510d9540831" translate="yes" xml:space="preserve">
          <source>Glasgow Haskell is a changing system so there are sure to be bugs in it. If you find one, please see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/report-a-bug&quot;&gt;this wiki page&lt;/a&gt; for information on how to report it.</source>
          <target state="translated">Glasgow Haskellは変化するシステムなので、バグがあるはずです。見つけた場合は、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/report-a-bug&quot;&gt;このwikiページ&lt;/a&gt;で報告方法を確認してください。</target>
        </trans-unit>
        <trans-unit id="49faa083913d16c0e2a54c17a0448d08510853d6" translate="yes" xml:space="preserve">
          <source>Global name bound outside of the TH AST: An original name (occurrences only, not binders) Need the namespace too to be sure which thing we are naming</source>
          <target state="translated">TH ASTの外側にバインドされたグローバルな名前。オリジナルの名前 (バインダーではなく、出現のみ)どの名前を付けているかを確認するために名前空間も必要です。</target>
        </trans-unit>
        <trans-unit id="01f513a4447d5115abfb616f7ec10f25746d29b6" translate="yes" xml:space="preserve">
          <source>GmpLimb</source>
          <target state="translated">GmpLimb</target>
        </trans-unit>
        <trans-unit id="aa3cc86bd45eeace37c215b8088bc77246462145" translate="yes" xml:space="preserve">
          <source>GmpLimb#</source>
          <target state="translated">GmpLimb#</target>
        </trans-unit>
        <trans-unit id="e3f4ca0fa20ec8fe55958aea64bc1f20ad3d5908" translate="yes" xml:space="preserve">
          <source>GmpSize</source>
          <target state="translated">GmpSize</target>
        </trans-unit>
        <trans-unit id="f9096f37d45d4b60dbfdaece3f6a53686498ed20" translate="yes" xml:space="preserve">
          <source>GmpSize#</source>
          <target state="translated">GmpSize#</target>
        </trans-unit>
        <trans-unit id="047ca4adf26df35e0e106b392ff26750f40b42ad" translate="yes" xml:space="preserve">
          <source>Go to the &lt;a href=&quot;http://www.haskell.org/ghc/&quot;&gt;GHC home page&lt;/a&gt; and follow the &amp;ldquo;download&amp;rdquo; link to download GHC for your platform.</source>
          <target state="translated">行く&lt;a href=&quot;http://www.haskell.org/ghc/&quot;&gt;GHCのホームページ&lt;/a&gt;やお使いのプラットフォーム用のGHCをダウンロードするには、「ダウンロード」のリンクをたどります。</target>
        </trans-unit>
        <trans-unit id="33a4ab0ac66bca29f2e473fa3c763622fc606b83" translate="yes" xml:space="preserve">
          <source>Going beyond &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#disambiguate-fields&quot;&gt;Record field disambiguation&lt;/a&gt;), the &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt; extension allows multiple datatypes to be declared using the same field names in a single module. For example, it allows this:</source>
          <target state="translated">&lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;#disambiguate-fields&quot;&gt;レコードフィールドの明確化を&lt;/a&gt;参照）を超えて、&lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; &lt;/a&gt;拡張機能を使用すると、単一のモジュールで同じフィールド名を使用して複数のデータ型を宣言できます。たとえば、次のことが可能です。</target>
        </trans-unit>
        <trans-unit id="000eb225364983805facb15a740de1dfd422fd39" translate="yes" xml:space="preserve">
          <source>Gotchas</source>
          <target state="translated">Gotchas</target>
        </trans-unit>
        <trans-unit id="83c45b6127df9cef6499283275e95f71b0480b90" translate="yes" xml:space="preserve">
          <source>Governs the maximum size that GHC will allow a function unfolding to be. (An unfolding has a &amp;ldquo;size&amp;rdquo; that reflects the cost in terms of &amp;ldquo;code bloat&amp;rdquo; of expanding (aka inlining) that unfolding at a call site. A bigger function would be assigned a bigger cost.)</source>
          <target state="translated">GHCが機能の展開を許可する最大サイズを管理します。（展開には、呼び出しサイトで展開（つまりインライン化）を展開する「コードの膨張」という観点からのコストを反映する「サイズ」があります。より大きな関数にはより大きなコストが割り当てられます。）</target>
        </trans-unit>
        <trans-unit id="9a7405ebcedde5be8d095a986ea8794e19ee84e2" translate="yes" xml:space="preserve">
          <source>Graph</source>
          <target state="translated">Graph</target>
        </trans-unit>
        <trans-unit id="6e7c6bbc4315ba0876f76436ec1b10c7c4900224" translate="yes" xml:space="preserve">
          <source>Graph Algorithms</source>
          <target state="translated">グラフアルゴリズム</target>
        </trans-unit>
        <trans-unit id="13a49a7899b38d84a4d5a0dc4d03c8c74c885e97" translate="yes" xml:space="preserve">
          <source>Graph Construction</source>
          <target state="translated">グラフ構築</target>
        </trans-unit>
        <trans-unit id="49a0417afd89473041a3a240cc4fdf45ab515a14" translate="yes" xml:space="preserve">
          <source>Graph Properties</source>
          <target state="translated">グラフのプロパティ</target>
        </trans-unit>
        <trans-unit id="56cffb9f02e2f33c7ba6c576362663ee3a363685" translate="yes" xml:space="preserve">
          <source>Graph Transformations</source>
          <target state="translated">グラフの変換</target>
        </trans-unit>
        <trans-unit id="ab255c27aec8dfb7cbe347babe25d68cec1ce7a6" translate="yes" xml:space="preserve">
          <source>Graphics</source>
          <target state="translated">Graphics</target>
        </trans-unit>
        <trans-unit id="97dd933a2545d2eb99d8307684e2d9b87677156f" translate="yes" xml:space="preserve">
          <source>Graphics.Win32.Window</source>
          <target state="translated">Graphics.Win32.Window</target>
        </trans-unit>
        <trans-unit id="ee1004fcc1994df1683067a7bfd7341361dfb44a" translate="yes" xml:space="preserve">
          <source>Graphics.Win32.Window.ForegroundWindow</source>
          <target state="translated">Graphics.Win32.Window.ForegroundWindow</target>
        </trans-unit>
        <trans-unit id="d1bc1481fd09f7ee3129f3e57f9838dbb896968f" translate="yes" xml:space="preserve">
          <source>Graphics.Win32.Window.HotKey</source>
          <target state="translated">Graphics.Win32.Window.HotKey</target>
        </trans-unit>
        <trans-unit id="78399476ef1665a7b5a92cf906aaca4e5a94e9a0" translate="yes" xml:space="preserve">
          <source>Graphs</source>
          <target state="translated">Graphs</target>
        </trans-unit>
        <trans-unit id="933bf21afdd55a0d2283845fed0e7bbdd1f5db49" translate="yes" xml:space="preserve">
          <source>Green</source>
          <target state="translated">Green</target>
        </trans-unit>
        <trans-unit id="b48836bd60f1a3a7305ae4aec52e094503f42798" translate="yes" xml:space="preserve">
          <source>Gregorian calendar</source>
          <target state="translated">グレゴリオ暦</target>
        </trans-unit>
        <trans-unit id="f6735a5ee92cee7bdb9905cfbf3933c275bf1379" translate="yes" xml:space="preserve">
          <source>Group has execute permission.</source>
          <target state="translated">グループには実行権限があります。</target>
        </trans-unit>
        <trans-unit id="8475ab1269f38d6db9942d6f399693e2156d4e54" translate="yes" xml:space="preserve">
          <source>Group has read permission.</source>
          <target state="translated">グループは許可を読み取っています。</target>
        </trans-unit>
        <trans-unit id="79d8e1e9bb326b307875f64fd38768b5f6c5819e" translate="yes" xml:space="preserve">
          <source>Group has read, write and execute permission.</source>
          <target state="translated">グループは読み取り、書き込み、実行の権限を持っています。</target>
        </trans-unit>
        <trans-unit id="c53ff78e371c1a2b8d488e2fc1d060ea6dec5848" translate="yes" xml:space="preserve">
          <source>Group has write permission.</source>
          <target state="translated">グループは書き込み許可を得ています。</target>
        </trans-unit>
        <trans-unit id="2eee03f5a54518b4c420cc3f8e3597ce16394ed9" translate="yes" xml:space="preserve">
          <source>Group statements (as with &lt;a href=&quot;#extension-TransformListComp&quot;&gt;&lt;code&gt;TransformListComp&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">グループステートメント（&lt;a href=&quot;#extension-TransformListComp&quot;&gt; &lt;code&gt;TransformListComp&lt;/code&gt; と&lt;/a&gt;同様）：</target>
        </trans-unit>
        <trans-unit id="8c256d9ea28df636c9ea97e0bd7bc8b310405f3a" translate="yes" xml:space="preserve">
          <source>GroupEntry</source>
          <target state="translated">GroupEntry</target>
        </trans-unit>
        <trans-unit id="db7b9205a31d4756e235da565a7056d8dfe9976e" translate="yes" xml:space="preserve">
          <source>GroupID</source>
          <target state="translated">GroupID</target>
        </trans-unit>
        <trans-unit id="0fa12c8aef8520289b3fda84e17c7ecf08c5916b" translate="yes" xml:space="preserve">
          <source>GroupLimit</source>
          <target state="translated">GroupLimit</target>
        </trans-unit>
        <trans-unit id="6e66568583d15b8f37bae367b73bca77f4f263a2" translate="yes" xml:space="preserve">
          <source>Guard</source>
          <target state="translated">Guard</target>
        </trans-unit>
        <trans-unit id="a34b607e9430e338b04442f386b47b4fa716604d" translate="yes" xml:space="preserve">
          <source>GuardBinBox</source>
          <target state="translated">GuardBinBox</target>
        </trans-unit>
        <trans-unit id="ffe2108ae6d15e93e23a98471348ba5a1ca19ad1" translate="yes" xml:space="preserve">
          <source>GuardQ</source>
          <target state="translated">GuardQ</target>
        </trans-unit>
        <trans-unit id="9d4e8921b3246a85e29c8e15986569808f47530a" translate="yes" xml:space="preserve">
          <source>Guards against negative result values</source>
          <target state="translated">負の結果値をガード</target>
        </trans-unit>
        <trans-unit id="2c496671c5aeaa700e44bad718187d2166004827" translate="yes" xml:space="preserve">
          <source>Guards against null pointers</source>
          <target state="translated">ヌルポインタに対するガード</target>
        </trans-unit>
        <trans-unit id="164f197e970b9a4693e48dec5f9fde7a61f1e29f" translate="yes" xml:space="preserve">
          <source>Guards are translated with the &lt;code&gt;guard&lt;/code&gt; function, which requires a &lt;code&gt;MonadPlus&lt;/code&gt; instance:</source>
          <target state="translated">ガードは、 &lt;code&gt;MonadPlus&lt;/code&gt; インスタンスを必要とする &lt;code&gt;guard&lt;/code&gt; 機能で変換されます。</target>
        </trans-unit>
        <trans-unit id="e62fe40c3c7f3f2deb0de6c6043dabd4db714129" translate="yes" xml:space="preserve">
          <source>Guards for IO operations that may fail</source>
          <target state="translated">失敗する可能性のあるIO操作のためのガード</target>
        </trans-unit>
        <trans-unit id="a43bb729fa241f8f31f96c2a898f1cc684df64fc" translate="yes" xml:space="preserve">
          <source>Guards:</source>
          <target state="translated">Guards:</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="1903ce5d09493a6a7499083e60f2b56bf4b0c409" translate="yes" xml:space="preserve">
          <source>Guy Blelloch, Daniel Ferizovic, and Yihan Sun, &quot;&lt;em&gt;Just Join for Parallel Ordered Sets&lt;/em&gt;&quot;, &lt;a href=&quot;https://arxiv.org/abs/1602.02120v3&quot;&gt;https://arxiv.org/abs/1602.02120v3&lt;/a&gt;.</source>
          <target state="translated">Guy Blelloch、Daniel Ferizovic、およびYihan Sun、「&lt;em&gt;Just Join for Parallel Ordered Sets&lt;/em&gt;」、&lt;a href=&quot;https://arxiv.org/abs/1602.02120v3&quot;&gt;https：&lt;/a&gt; //arxiv.org/abs/1602.02120v3 。</target>
        </trans-unit>
        <trans-unit id="6e55b9d60fb7a6cf6f7ce67a80dbe3d9177b3561" translate="yes" xml:space="preserve">
          <source>HACKER TERRITORY. HACKER TERRITORY. (You were warned.)</source>
          <target state="translated">HACKER TERRITORY.ハッカー・テリトリー (あなたは警告された)</target>
        </trans-unit>
        <trans-unit id="acd811416f69270a003e4a499661392fc925bc40" translate="yes" xml:space="preserve">
          <source>HALF_PTR</source>
          <target state="translated">HALF_PTR</target>
        </trans-unit>
        <trans-unit id="0b19d1e1b8a5918571f9c9d135638b9f04547d8f" translate="yes" xml:space="preserve">
          <source>HANDLE</source>
          <target state="translated">HANDLE</target>
        </trans-unit>
        <trans-unit id="6ed004a7b7a1c11f9e4775140206605dc080f051" translate="yes" xml:space="preserve">
          <source>HARDWAREINPUT</source>
          <target state="translated">HARDWAREINPUT</target>
        </trans-unit>
        <trans-unit id="f5cfba667f7d2beb3b73c3b20abeade23152bb66" translate="yes" xml:space="preserve">
          <source>HINSTANCE</source>
          <target state="translated">HINSTANCE</target>
        </trans-unit>
        <trans-unit id="8a62310d9f9283fd8fa6380ec446bd6f54f73354" translate="yes" xml:space="preserve">
          <source>HKEY</source>
          <target state="translated">HKEY</target>
        </trans-unit>
        <trans-unit id="5791388c5a16d4f31ae65db03aaa4f3178f401a8" translate="yes" xml:space="preserve">
          <source>HMODULE</source>
          <target state="translated">HMODULE</target>
        </trans-unit>
        <trans-unit id="2fcf51d2569194bb43ab5be7b0476126449060b3" translate="yes" xml:space="preserve">
          <source>HOWEVER, this is normally not what you want to do!</source>
          <target state="translated">HOWEVER、これは普通はやりたくないことですよね!</target>
        </trans-unit>
        <trans-unit id="7b153a8b1b4a64b4d58ebc99748e1fdb8bb2ce66" translate="yes" xml:space="preserve">
          <source>HPC displays both kinds of information in two primary ways: textual reports with summary statistics (&lt;code&gt;hpc report&lt;/code&gt;) and sources with color mark-up (&lt;code&gt;hpc markup&lt;/code&gt;). For boolean coverage, there are four possible outcomes for each guard, condition or qualifier: both True and False values occur; only True; only False; never evaluated. In hpc-markup output, highlighting with a yellow background indicates a part of the program that was never evaluated; a green background indicates an always-True expression and a red background indicates an always-False one.</source>
          <target state="translated">HPCは、2種類の主要な方法で両方の種類の情報を表示します。要約統計付きのテキストレポート（ &lt;code&gt;hpc report&lt;/code&gt; ）とカラーマークアップ付きのソース（ &lt;code&gt;hpc markup&lt;/code&gt; ）です。ブールカバレッジの場合、ガード、条件、または修飾子ごとに4つの結果が考えられます。TrueとFalseの両方の値が発生します。 Trueのみ。 Falseのみ。評価されることはありません。 hpc-markupの出力で、黄色の背景で強調表示されている場合は、評価されなかったプログラムの一部を示しています。緑の背景はalways-True式を示し、赤い背景はalways-False式を示します。</target>
        </trans-unit>
        <trans-unit id="47ed5ab5211983547bd7d8aabed6ed2c5abe106e" translate="yes" xml:space="preserve">
          <source>HPC does not attempt to lock the &lt;code&gt;.tix&lt;/code&gt; file, so multiple concurrently running binaries in the same directory will exhibit a race condition. At compile time, there is no way to change the name of the &lt;code&gt;.tix&lt;/code&gt; file generated; at runtime, the name of the generated &lt;code&gt;.tix&lt;/code&gt; file can be changed using &lt;a href=&quot;#envvar-HPCTIXFILE&quot; id=&quot;index-10&quot;&gt;&lt;code&gt;HPCTIXFILE&lt;/code&gt;&lt;/a&gt;; the name of the &lt;code&gt;.tix&lt;/code&gt; file will also change if you rename the binary. HPC does not work with GHCi.</source>
          <target state="translated">HPCは &lt;code&gt;.tix&lt;/code&gt; ファイルをロックしようとしないため、同じディレクトリで同時に実行されている複数のバイナリが競合状態を示します。コンパイル時に、生成された &lt;code&gt;.tix&lt;/code&gt; ファイルの名前を変更する方法はありません。実行時に、生成されたの名前 &lt;code&gt;.tix&lt;/code&gt; のファイルを使用して変更することができます&lt;a href=&quot;#envvar-HPCTIXFILE&quot; id=&quot;index-10&quot;&gt; &lt;code&gt;HPCTIXFILE&lt;/code&gt; を&lt;/a&gt;。バイナリの名前を変更すると、 &lt;code&gt;.tix&lt;/code&gt; ファイルの名前も変更されます。HPCはGHCiでは機能しません。</target>
        </trans-unit>
        <trans-unit id="febecd78643af3bbe821cd38f1706523b419bad4" translate="yes" xml:space="preserve">
          <source>HPC instrumentation is enabled with the &lt;a href=&quot;#ghc-flag--fhpc&quot;&gt;&lt;code&gt;-fhpc&lt;/code&gt;&lt;/a&gt; flag:</source>
          <target state="translated">HPCインスツルメンテーションは、&lt;a href=&quot;#ghc-flag--fhpc&quot;&gt; &lt;code&gt;-fhpc&lt;/code&gt; &lt;/a&gt;フラグで有効になります。</target>
        </trans-unit>
        <trans-unit id="1ad412bd3c8b51f7888829d92fba476811cbd227" translate="yes" xml:space="preserve">
          <source>HPrintfType</source>
          <target state="translated">HPrintfType</target>
        </trans-unit>
        <trans-unit id="968ef45f0adcb52b1756f92401b8ae3c14068ab8" translate="yes" xml:space="preserve">
          <source>HRESULT</source>
          <target state="translated">HRESULT</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="24c886a7fc41f29ab0b6c49144b140aa92eedda1" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTMLは、HTMLタグ内に有効に配置できるもののクラスです。たとえば、これは1つ以上の &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 要素、または &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; にすることができます。</target>
        </trans-unit>
        <trans-unit id="bac1ac628be09ebd8c6adfbc13285eba17cc52c5" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTMLは、HTMLタグ内に有効に配置できるもののクラスです。したがって、これは、たとえば1つ以上の &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 要素または &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; にすることができます。</target>
        </trans-unit>
        <trans-unit id="1e7921313c83d0f9960cb8d909e3d6ec7f554cae" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTMLは、HTMLタグ内に有効に配置できるもののクラスです。たとえば、これは1つ以上の &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 要素、または &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; にすることができます。</target>
        </trans-unit>
        <trans-unit id="845da765199169e6dfadc88839ff4b7a816e8285" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTMLは、HTMLタグ内に有効に配置できるもののクラスです。したがって、これは、たとえば1つ以上の &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 要素または &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; にすることができます。</target>
        </trans-unit>
        <trans-unit id="a6d5fa3003a8ccf9ca70c73c5cd9675cec2a1610" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTMLは、HTMLタグ内に有効に配置できるもののクラスです。たとえば、これは1つ以上の &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 要素、または &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; にすることができます。</target>
        </trans-unit>
        <trans-unit id="a95c580c1b1d21bdccf222c58c09aa34cf85bae5" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTMLは、HTMLタグ内に有効に配置できるもののクラスです。したがって、これは、たとえば1つ以上の &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 要素または &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; にすることができます。</target>
        </trans-unit>
        <trans-unit id="3f9cd56b1730d21793c75a28009298dbbbcdaebf" translate="yes" xml:space="preserve">
          <source>HTMLTABLE</source>
          <target state="translated">HTMLTABLE</target>
        </trans-unit>
        <trans-unit id="5d9e357312135edfa3b6c194ceac1b283c40f259" translate="yes" xml:space="preserve">
          <source>HValue</source>
          <target state="translated">HValue</target>
        </trans-unit>
        <trans-unit id="2f065fef793ed1d56fb008208ad8eb240a319915" translate="yes" xml:space="preserve">
          <source>HValueRef</source>
          <target state="translated">HValueRef</target>
        </trans-unit>
        <trans-unit id="c0392b2b1c472815ba8d1a1e3b20f4a279bf6c50" translate="yes" xml:space="preserve">
          <source>Handle</source>
          <target state="translated">Handle</target>
        </trans-unit>
        <trans-unit id="393fb1d92f907d4faa4bc03c878b793a3ae03095" translate="yes" xml:space="preserve">
          <source>Handle an error.</source>
          <target state="translated">エラーを処理します。</target>
        </trans-unit>
        <trans-unit id="9adc28e5d73e222c9d3f7a1f421808c2f422d355" translate="yes" xml:space="preserve">
          <source>Handle an exception.</source>
          <target state="translated">例外を処理します。</target>
        </trans-unit>
        <trans-unit id="a865e149a9130ddafd312446888b46b4743e1256" translate="yes" xml:space="preserve">
          <source>Handle operations implemented by file descriptors (FDs)</source>
          <target state="translated">ファイルディスクリプタ(FD)で実装された操作を扱う</target>
        </trans-unit>
        <trans-unit id="e01aaadb8e09dac1ef68d5f980b78d216f59db96" translate="yes" xml:space="preserve">
          <source>Handle properties</source>
          <target state="translated">ハンドルのプロパティ</target>
        </trans-unit>
        <trans-unit id="4e5478f1470187011e4c429f38a2f668e2221916" translate="yes" xml:space="preserve">
          <source>Handle to read from</source>
          <target state="translated">読み取りハンドル</target>
        </trans-unit>
        <trans-unit id="cfa84d65d44fe1cfe4fde201cc224ca2ba61ea4b" translate="yes" xml:space="preserve">
          <source>Handle to use for &lt;code&gt;stderr&lt;/code&gt; (Nothing =&amp;gt; use existing &lt;code&gt;stderr&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;stderr&lt;/code&gt; に使用するハンドル（なし=&amp;gt;既存の &lt;code&gt;stderr&lt;/code&gt; を使用）</target>
        </trans-unit>
        <trans-unit id="0c0b0ea87bc2047414b75a0418c93c0c73335c5f" translate="yes" xml:space="preserve">
          <source>Handle to use for &lt;code&gt;stdin&lt;/code&gt; (Nothing =&amp;gt; use existing &lt;code&gt;stdin&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; に使用するハンドル（なし=&amp;gt;既存の &lt;code&gt;stdin&lt;/code&gt; を使用）</target>
        </trans-unit>
        <trans-unit id="f3660bc26cde8292b8f071aaeac565d95442b6df" translate="yes" xml:space="preserve">
          <source>Handle to use for &lt;code&gt;stdout&lt;/code&gt; (Nothing =&amp;gt; use existing &lt;code&gt;stdout&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;stdout&lt;/code&gt; に使用するハンドル（なし=&amp;gt;既存の &lt;code&gt;stdout&lt;/code&gt; を使用）</target>
        </trans-unit>
        <trans-unit id="91dfd9b7d2ac9eea27abf91b17116f0a194d5836" translate="yes" xml:space="preserve">
          <source>Handle to write to</source>
          <target state="translated">書き込み先のハンドル</target>
        </trans-unit>
        <trans-unit id="4fc8f4ac4ee90b96880236742e3ee6972ce929c5" translate="yes" xml:space="preserve">
          <source>HandleFinalizer</source>
          <target state="translated">HandleFinalizer</target>
        </trans-unit>
        <trans-unit id="2f9893d29577c61dae5b7756f8892a181b356a13" translate="yes" xml:space="preserve">
          <source>HandlePosition</source>
          <target state="translated">HandlePosition</target>
        </trans-unit>
        <trans-unit id="02cd2075a6637789c42ae7bd6b7089a7e6d77028" translate="yes" xml:space="preserve">
          <source>HandlePosn</source>
          <target state="translated">HandlePosn</target>
        </trans-unit>
        <trans-unit id="8669a86e97e301f504a17c89995da4d28985c624" translate="yes" xml:space="preserve">
          <source>HandleType</source>
          <target state="translated">HandleType</target>
        </trans-unit>
        <trans-unit id="4af10b83952cbc0eefb09be94c848941cb2f60f3" translate="yes" xml:space="preserve">
          <source>Handle__</source>
          <target state="translated">Handle__</target>
        </trans-unit>
        <trans-unit id="be0212bf33313087973171061ef96d564becfb55" translate="yes" xml:space="preserve">
          <source>Handler</source>
          <target state="translated">Handler</target>
        </trans-unit>
        <trans-unit id="5286415fae901d21b38c1d749f8ab46e4728bc6e" translate="yes" xml:space="preserve">
          <source>Handler to invoke if an exception is raised</source>
          <target state="translated">例外が発生した場合に呼び出されるハンドラ</target>
        </trans-unit>
        <trans-unit id="14535b564a9d5d580a5ef44e0cc03f73609cf431" translate="yes" xml:space="preserve">
          <source>HandlerFun</source>
          <target state="translated">HandlerFun</target>
        </trans-unit>
        <trans-unit id="fc9575096055be030a95175a15be095262410643" translate="yes" xml:space="preserve">
          <source>Handling Type-specific Modifiers</source>
          <target state="translated">タイプ固有の修飾子の取り扱い</target>
        </trans-unit>
        <trans-unit id="3b82b9585c9008b66d22e6f407dfa6cdeb89a2db" translate="yes" xml:space="preserve">
          <source>Handling hard link using Win32 API. [NTFS only]</source>
          <target state="translated">Win32 APIを使用したハードリンクの取り扱いについて NTFSのみ</target>
        </trans-unit>
        <trans-unit id="0721f48d368df7f5160916c0069bca6f821d3701" translate="yes" xml:space="preserve">
          <source>Handling signals</source>
          <target state="translated">信号の取り扱い</target>
        </trans-unit>
        <trans-unit id="824156b97fa215b3e57f4c35b718839b27b32f4a" translate="yes" xml:space="preserve">
          <source>Handling symbolic link using Win32 API. [Vista of later and desktop app only]</source>
          <target state="translated">Win32 APIを使用したシンボリックリンクの取り扱いについて。Vista以降のVistaとデスクトップアプリのみ</target>
        </trans-unit>
        <trans-unit id="89aab9f219783f5483f9c8a2f555018716574e03" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt; signal</source>
          <target state="translated">取り扱い &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt; 信号を</target>
        </trans-unit>
        <trans-unit id="3ad2b4d3875aa4ad0be9d5cb9d1098c6ae4770cb" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; signal</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; 信号を処理する</target>
        </trans-unit>
        <trans-unit id="993d612407c57078184116f64cae6bcafc5ebc5a" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt; signal</source>
          <target state="translated">取り扱い &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt; 信号を</target>
        </trans-unit>
        <trans-unit id="048292f565b5b22828fa076edbb58a73e8cfd5b8" translate="yes" xml:space="preserve">
          <source>Hands buffered event log data to your event log writer. Required for a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">バッファリングされたイベントログデータをイベントログライターに渡します。カスタム&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; に&lt;/a&gt;必要です。</target>
        </trans-unit>
        <trans-unit id="a2180742f74260bd275e7151aa4ebb625f061aec" translate="yes" xml:space="preserve">
          <source>Hands buffered event log data to your event log writer. Return true on success. Required for a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">バッファリングされたイベントログデータをイベントログライターに渡します。成功するとtrueを返します。カスタム&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; に&lt;/a&gt;必要です。</target>
        </trans-unit>
        <trans-unit id="3affea459771f35ab73628ef32521d013f015828" translate="yes" xml:space="preserve">
          <source>HangupOnClose</source>
          <target state="translated">HangupOnClose</target>
        </trans-unit>
        <trans-unit id="6bfec95216610c8923fdb3b58c6820e2638d7012" translate="yes" xml:space="preserve">
          <source>Hard link name</source>
          <target state="translated">ハードリンク名</target>
        </trans-unit>
        <trans-unit id="151f3938abe034f9943c5ceef0c5082df3ebe59c" translate="yes" xml:space="preserve">
          <source>Hard links</source>
          <target state="translated">ハードリンク</target>
        </trans-unit>
        <trans-unit id="cfda26ce9011e1d31a770fb6f43ec4f97f72200e" translate="yes" xml:space="preserve">
          <source>HardwareFault</source>
          <target state="translated">HardwareFault</target>
        </trans-unit>
        <trans-unit id="a40e006669de268a9bb2acc2447224d0f6c74cbc" translate="yes" xml:space="preserve">
          <source>HasCallStack</source>
          <target state="translated">HasCallStack</target>
        </trans-unit>
        <trans-unit id="d5a8afb8c704edab0aaea5d1e5ddc323a689f7a5" translate="yes" xml:space="preserve">
          <source>HasCallStack call stacks</source>
          <target state="translated">HasCallStack コールスタック</target>
        </trans-unit>
        <trans-unit id="d56fbf4c5db38163d687f59e194a828baa7c9bd2" translate="yes" xml:space="preserve">
          <source>HasField</source>
          <target state="translated">HasField</target>
        </trans-unit>
        <trans-unit id="20dd461a479f96766729c9d640324e99a0d215cb" translate="yes" xml:space="preserve">
          <source>HasJobControl</source>
          <target state="translated">HasJobControl</target>
        </trans-unit>
        <trans-unit id="4932242cd8f456e18307629642a2aa4a2f8e249e" translate="yes" xml:space="preserve">
          <source>HasResolution</source>
          <target state="translated">HasResolution</target>
        </trans-unit>
        <trans-unit id="19eda78b3bcf5dc9a7065d2ad4cee793b2e7eef4" translate="yes" xml:space="preserve">
          <source>HasSavedIDs</source>
          <target state="translated">HasSavedIDs</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="0229c5fae78a9965d4f45ca37d03dc1236ff8fa7" translate="yes" xml:space="preserve">
          <source>Hashes a &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; into an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Two &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt;s may hash to the same value, although in practice this is unlikely. The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; returned makes a good hash key.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; にハッシュします。2つの &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; が同じ値にハッシュされる場合がありますが、実際にはこれはありそうにありません。 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; が良いハッシュキーを作る返さ。</target>
        </trans-unit>
        <trans-unit id="53e49a69fb315c4f51afc9825055d4858a064cdc" translate="yes" xml:space="preserve">
          <source>Hashing</source>
          <target state="translated">Hashing</target>
        </trans-unit>
        <trans-unit id="5901d3877bf9e737aa3e94d79bb4ea0286df3607" translate="yes" xml:space="preserve">
          <source>Haskeline has two ways of interacting with the user:</source>
          <target state="translated">Haskelineには、ユーザーとの対話の方法が2つあります。</target>
        </trans-unit>
        <trans-unit id="c0c271c8f62efa33d3ac8edbe0fea6e52fc84150" translate="yes" xml:space="preserve">
          <source>Haskell</source>
          <target state="translated">Haskell</target>
        </trans-unit>
        <trans-unit id="065908ba2e214305b72d700a33ff216d049eb661" translate="yes" xml:space="preserve">
          <source>Haskell 2010 and Haskell 98 allows for integer literals to be given in decimal, octal (prefixed by &lt;code&gt;0o&lt;/code&gt; or &lt;code&gt;0O&lt;/code&gt;), or hexadecimal notation (prefixed by &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;).</source>
          <target state="translated">Haskell 2010およびHaskell 98では、整数リテラルを10進数、8進数（接頭辞 &lt;code&gt;0o&lt;/code&gt; または &lt;code&gt;0O&lt;/code&gt; ）、または16進表記（接頭辞 &lt;code&gt;0x&lt;/code&gt; または &lt;code&gt;0X&lt;/code&gt; ）で指定できます。</target>
        </trans-unit>
        <trans-unit id="6da42c988c0cf83b43592a40a36bf805281eb533" translate="yes" xml:space="preserve">
          <source>Haskell 2010 and Haskell 98 define floating literals with the syntax &lt;code&gt;1.2e6&lt;/code&gt;. These literals have the type &lt;code&gt;Fractional a =&amp;gt; a&lt;/code&gt;.</source>
          <target state="translated">Haskell 2010およびHaskell 98は、 &lt;code&gt;1.2e6&lt;/code&gt; という構文で浮動リテラルを定義します。これらのリテラルの型は、 &lt;code&gt;Fractional a =&amp;gt; a&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0aef0b7881ddce0846355a38d3d56808bc487369" translate="yes" xml:space="preserve">
          <source>Haskell 2010 functions</source>
          <target state="translated">Haskell 2010 の機能</target>
        </trans-unit>
        <trans-unit id="c2dfdff50d43589a65e10f3de801e5cd1f3481ad" translate="yes" xml:space="preserve">
          <source>Haskell 98 allows the programmer to add &amp;ldquo;&lt;code&gt;deriving( Eq, Ord )&lt;/code&gt;&amp;rdquo; to a data type declaration, to generate a standard instance declaration for classes specified in the &lt;code&gt;deriving&lt;/code&gt; clause. In Haskell 98, the only classes that may appear in the &lt;code&gt;deriving&lt;/code&gt; clause are the standard classes &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">Haskell 98では、プログラマがデータ型宣言に「 &lt;code&gt;deriving( Eq, Ord )&lt;/code&gt; 」を追加して、 &lt;code&gt;deriving&lt;/code&gt; 句で指定されたクラスの標準インスタンス宣言を生成できます。 Haskell 98では、 &lt;code&gt;deriving&lt;/code&gt; 句に現れる可能性のあるクラスは、標準クラスの &lt;code&gt;Eq&lt;/code&gt; 、 &lt;code&gt;Ord&lt;/code&gt; 、 &lt;code&gt;Enum&lt;/code&gt; 、 &lt;code&gt;Ix&lt;/code&gt; 、 &lt;code&gt;Bounded&lt;/code&gt; 、 &lt;code&gt;Read&lt;/code&gt; 、および &lt;code&gt;Show&lt;/code&gt; だけです。</target>
        </trans-unit>
        <trans-unit id="c13a83f3c36a18ef798acce46700a669fd2d9a2f" translate="yes" xml:space="preserve">
          <source>Haskell 98 allows the programmer to add a deriving clause to a data type declaration, to generate a standard instance declaration for specified class. GHC extends this mechanism along several axes:</source>
          <target state="translated">Haskell 98 では、プログラマはデータ型宣言に派生節を追加して、指定されたクラスの標準インスタンス宣言を生成することができます。GHCはこのメカニズムをいくつかの軸に沿って拡張しています。</target>
        </trans-unit>
        <trans-unit id="9fc350c1e6daa1d0a99b5e176fd6627f03f073af" translate="yes" xml:space="preserve">
          <source>Haskell 98 allows you to define a default implementation when declaring a class:</source>
          <target state="translated">Haskell 98では、クラスを宣言する際にデフォルトの実装を定義することができます。</target>
        </trans-unit>
        <trans-unit id="bdbe3cc69c9d59fa9c998d2ffb90eaf9b74ed7ed" translate="yes" xml:space="preserve">
          <source>Haskell 98 prohibits class method types to mention constraints on the class type variable, thus:</source>
          <target state="translated">Haskell 98では、クラスメソッド型がクラス型変数に対する制約について言及することを禁止しています。</target>
        </trans-unit>
        <trans-unit id="1da9fcbc717e278cc072c704bc0fb1543efb67d0" translate="yes" xml:space="preserve">
          <source>Haskell 98 regards all four as ambiguous, but with the &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; extension, GHC will accept the former two. The rules are precisely the same as those for instance declarations in Haskell 98, where the method names on the left-hand side of the method bindings in an instance declaration refer unambiguously to the method of that class (provided they are in scope at all), even if there are other variables in scope with the same name. This reduces the clutter of qualified names when you import two records from different modules that use the same field name.</source>
          <target state="translated">Haskell 98は4つすべてをあいまいと見なしますが、&lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt;拡張により、GHCは前者2つを受け入れます。ルールは、Haskell 98のインスタンス宣言のルールとまったく同じです。インスタンス宣言のメソッドバインディングの左側にあるメソッド名は、そのクラスのメソッドを明確に指します（スコープ内にある場合）。 、同じ名前のスコープ内に他の変数がある場合でも。これにより、同じフィールド名を使用する異なるモジュールから2つのレコードをインポートするときの修飾名の乱雑さが減少します。</target>
        </trans-unit>
        <trans-unit id="3e37b99ac7bc7b32576c5a86ef921f839207b134" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; never uses the default &quot;6-digit&quot; precision used by C printf.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; は、C printfで使用されるデフォルトの「6桁」の精度を決して使用しません。</target>
        </trans-unit>
        <trans-unit id="803931392d9e7f7a42786baf24bd3acbb21d2297" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; prints the exponent of e-format numbers without a gratuitous plus sign, and with the minimum possible number of digits.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; は、不要なプラス記号なしで、可能な最小桁数でe形式の数値の指数を出力します。</target>
        </trans-unit>
        <trans-unit id="5a988b88b57fc6a5015c3bdce6eced1db2e93fb3" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; treats the &quot;precision&quot; specifier as indicating the number of digits after the decimal point.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; は、「精度」指定子を小数点以下の桁数を示すものとして扱います。</target>
        </trans-unit>
        <trans-unit id="de5a761278ad7995ae6ea10eb54d7d46a18911b2" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; will place a zero after a decimal point when possible.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; は、可能な場合、小数点の後にゼロを配置します。</target>
        </trans-unit>
        <trans-unit id="5db5bb3ecf93ed4bf68c234dce9b122cc069d4fc" translate="yes" xml:space="preserve">
          <source>Haskell allows datatypes to be given contexts, e.g.</source>
          <target state="translated">Haskell では、データ型にコンテキストを与えることができます。</target>
        </trans-unit>
        <trans-unit id="3ba63f358f6ed0e157b0d31998c471fd73b1c809" translate="yes" xml:space="preserve">
          <source>Haskell compiler</source>
          <target state="translated">ハスケルコンパイラ</target>
        </trans-unit>
        <trans-unit id="c96570b066116767adb53a9bedbb0995cb0718ff" translate="yes" xml:space="preserve">
          <source>Haskell defines operations to read and write characters from and to files, represented by values of type &lt;code&gt;Handle&lt;/code&gt;. Each value of this type is a &lt;em&gt;handle&lt;/em&gt;: a record used by the Haskell run-time system to &lt;em&gt;manage&lt;/em&gt; I/O with file system objects. A handle has at least the following properties:</source>
          <target state="translated">Haskellは、タイプ &lt;code&gt;Handle&lt;/code&gt; の値によって表される、ファイルから文字を読み書きする操作を定義します。このタイプの各値は&lt;em&gt;ハンドル&lt;/em&gt;です。HaskellランタイムシステムがファイルシステムオブジェクトとのI / O を&lt;em&gt;管理するため&lt;/em&gt;に使用するレコードです。ハンドルには少なくとも次のプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="57185b2c62d4c8656c31d0f4760835255a021285" translate="yes" xml:space="preserve">
          <source>Haskell expressions can be typed at the prompt:</source>
          <target state="translated">プロンプトでHaskell式を入力することができます。</target>
        </trans-unit>
        <trans-unit id="36b350cda5fbb367cf839d60b51cc0cd72d5f14c" translate="yes" xml:space="preserve">
          <source>Haskell file</source>
          <target state="translated">ハスケルファイル</target>
        </trans-unit>
        <trans-unit id="c9588bea707a1b459133b5d157a94371293bfcc8" translate="yes" xml:space="preserve">
          <source>Haskell identifier, e.g. &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;Baz&lt;/code&gt;</source>
          <target state="translated">Haskell識別子、たとえば &lt;code&gt;foo&lt;/code&gt; 、 &lt;code&gt;Baz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8864d7903427f164a617a184e73202acec74086a" translate="yes" xml:space="preserve">
          <source>Haskell infers the kind of each type variable. Sometimes it is nice to be able to give the kind explicitly as (machine-checked) documentation, just as it is nice to give a type signature for a function. On some occasions, it is essential to do so. For example, in his paper &amp;ldquo;Restricted Data Types in Haskell&amp;rdquo; (Haskell Workshop 1999) John Hughes had to define the data type:</source>
          <target state="translated">Haskellは各型変数の種類を推測します。関数に型シグネチャを付けるのと同じように、（マシンチェック済みの）ドキュメントとして明示的に種類を指定できると便利な場合があります。場合によっては、そうすることが不可欠です。たとえば、彼の論文「Haskellの制限付きデータ型」（Haskell Workshop 1999）では、John Hughesがデータ型を定義する必要がありました。</target>
        </trans-unit>
        <trans-unit id="03044d4dffb5ba6961d6c201b79e6123773d3291" translate="yes" xml:space="preserve">
          <source>Haskell lexer: returns the lexed string, rather than the lexeme</source>
          <target state="translated">Haskell lexer:lexemeではなくlexed文字列を返します。</target>
        </trans-unit>
        <trans-unit id="3a6fb7995adcbbff55a20ec28fb0709de06184c0" translate="yes" xml:space="preserve">
          <source>Haskell library authors have a choice. Most should just use Safe inference. Assuming you avoid any unsafe features of the language then your modules will be marked safe. Inferred vs. Explicit has the following trade-offs:</source>
          <target state="translated">Haskellライブラリの作者には選択の余地があります。ほとんどの人は安全な推論を使うべきです。言語の安全でない機能を回避したと仮定すると、あなたのモジュールは安全とマークされます。推論と明示的推論には次のようなトレードオフがあります。</target>
        </trans-unit>
        <trans-unit id="cc3010148ab07280017396fcfee70d4ee8ced651" translate="yes" xml:space="preserve">
          <source>Haskell offers a powerful type system and separation of pure and effectual functions through the &lt;code&gt;IO&lt;/code&gt; monad. However, there are several loop holes in the type system, the most obvious being the &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; function. The safe language dialect of Safe Haskell disallows the use of such functions. This can be useful restriction as it makes Haskell code easier to analyse and reason about. It also codifies the existing culture in the Haskell community of trying to avoid unsafe functions unless absolutely necessary. As such, using the safe language (through the &lt;code&gt;-XSafe&lt;/code&gt; flag) can be thought of as a way of enforcing good style, similar to the function of &lt;code&gt;-Wall&lt;/code&gt;.</source>
          <target state="translated">Haskellは、強力な型システムと、 &lt;code&gt;IO&lt;/code&gt; モナドによる純粋な機能と効果的な機能の分離を提供します。ただし、型システムにはいくつかのループホールがあります。最も明らかなのは、 &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; functionです。 Safe Haskellの安全な言語方言は、そのような関数の使用を許可していません。これは、Haskellコードの分析と推論を容易にするため、便利な制限になる場合があります。また、絶対に必要でない限り、危険な機能を回避しようとするHaskellコミュニティの既存の文化を体系化します。したがって、（- &lt;code&gt;-XSafe&lt;/code&gt; フラグを介して）安全な言語を使用することは、 &lt;code&gt;-Wall&lt;/code&gt; の機能と同様に、優れたスタイルを適用する方法と考えることができます。</target>
        </trans-unit>
        <trans-unit id="3bc620cd7bebfbd449c887c8393ef71a9cb0048a" translate="yes" xml:space="preserve">
          <source>Haskell provides indexable &lt;em&gt;arrays&lt;/em&gt;, which may be thought of as functions whose domains are isomorphic to contiguous subsets of the integers. Functions restricted in this way can be implemented efficiently; in particular, a programmer may reasonably expect rapid access to the components. To ensure the possibility of such an implementation, arrays are treated as data, not as general functions.</source>
          <target state="translated">Haskellは、インデックス可能な&lt;em&gt;配列を&lt;/em&gt;提供し&lt;em&gt;ます&lt;/em&gt;。これは、ドメインが整数の連続したサブセットに同型である関数と考えることができます。このように制限された機能は効率的に実装できます。特に、プログラマーはコンポーネントへの迅速なアクセスを合理的に期待できます。このような実装の可能性を保証するために、配列は一般的な関数としてではなく、データとして扱われます。</target>
        </trans-unit>
        <trans-unit id="7368b5caa5272a65112545054af26ecf77386013" translate="yes" xml:space="preserve">
          <source>Haskell representation for &lt;code&gt;errno&lt;/code&gt; values. The implementation is deliberately exposed, to allow users to add their own definitions of &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;errno&lt;/code&gt; 値のHaskell表現。実装は意図的に公開されており、ユーザーは &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; 値の独自の定義を追加できます。</target>
        </trans-unit>
        <trans-unit id="ccc207680c476b314f16992dfd19a9a9a258a751" translate="yes" xml:space="preserve">
          <source>Haskell representations of &lt;code&gt;errno&lt;/code&gt; values</source>
          <target state="translated">&lt;code&gt;errno&lt;/code&gt; 値のHaskell表現</target>
        </trans-unit>
        <trans-unit id="5341eea214941c8fa9b89302f00f8e694f12278b" translate="yes" xml:space="preserve">
          <source>Haskell source files may be named on the command line, and they will be loaded exactly as in interactive mode. The expression is evaluated in the context of the loaded modules.</source>
          <target state="translated">Haskellのソースファイルはコマンドラインで名前を指定することができ、対話型モードとまったく同じようにロードされます。式はロードされたモジュールのコンテキストで評価されます。</target>
        </trans-unit>
        <trans-unit id="ae2da82a38cbe99fd9ff682badbaaec111364bd4" translate="yes" xml:space="preserve">
          <source>Haskell specifies that when compiling module &lt;code&gt;M&lt;/code&gt;, any instance declaration in any module &amp;ldquo;below&amp;rdquo; &lt;code&gt;M&lt;/code&gt; is visible. (Module &lt;code&gt;A&lt;/code&gt; is &amp;ldquo;below&amp;rdquo; &lt;code&gt;M&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is imported directly by &lt;code&gt;M&lt;/code&gt;, or if &lt;code&gt;A&lt;/code&gt; is below a module that &lt;code&gt;M&lt;/code&gt; imports directly.) In principle, GHC must therefore read the interface files of every module below &lt;code&gt;M&lt;/code&gt;, just in case they contain an instance declaration that matters to &lt;code&gt;M&lt;/code&gt;. This would be a disaster in practice, so GHC tries to be clever.</source>
          <target state="translated">Haskellは、モジュール &lt;code&gt;M&lt;/code&gt; をコンパイルするときに、 &lt;code&gt;M&lt;/code&gt; の「下」にあるモジュールのインスタンス宣言がすべて表示されるように指定しています。（モジュール &lt;code&gt;A&lt;/code&gt; は、「下」である &lt;code&gt;M&lt;/code&gt; あれば &lt;code&gt;A&lt;/code&gt; はによって直接輸入された &lt;code&gt;M&lt;/code&gt; 場合、または &lt;code&gt;A&lt;/code&gt; がモジュールを下回っていると &lt;code&gt;M&lt;/code&gt; の直接輸入。）原則的には、GHCは、したがって、以下のすべてのモジュールのインタフェースファイル読まなければなら &lt;code&gt;M&lt;/code&gt; をそれらに含ま念のために、 &lt;code&gt;M&lt;/code&gt; にとって重要なインスタンス宣言。これは実際には災害になるので、GHCは賢くなろうとします。</target>
        </trans-unit>
        <trans-unit id="78504a490dcd1a405c09c255b59b6c836880bb83" translate="yes" xml:space="preserve">
          <source>Haskell symbol, e.g. &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;:%&lt;/code&gt;</source>
          <target state="translated">Haskellシンボル、例えば &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;:%&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df367f209bd79c811db4b993c1f851b5f670ca59" translate="yes" xml:space="preserve">
          <source>Haskell threads and Operating System threads</source>
          <target state="translated">Haskellスレッドとオペレーティングシステムスレッド</target>
        </trans-unit>
        <trans-unit id="b5e4d1115a8c2e36e70d3db1df85b3ba04c82997" translate="yes" xml:space="preserve">
          <source>Haskell threads can communicate via &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s, a kind of synchronised mutable variable (see &lt;a href=&quot;control-concurrent-mvar&quot;&gt;Control.Concurrent.MVar&lt;/a&gt;). Several common concurrency abstractions can be built from &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s, and these are provided by the &lt;a href=&quot;control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; library. In GHC, threads may also communicate via exceptions.</source>
          <target state="translated">Haskellスレッドは、同期可能な可変変数の一種である &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; を介して通信できます（&lt;a href=&quot;control-concurrent-mvar&quot;&gt;Control.Concurrent.MVarを&lt;/a&gt;参照）。 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; からいくつかの一般的な同時実行抽象化を構築でき、これらは&lt;a href=&quot;control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;ライブラリによって提供されます。GHCでは、スレッドは例外を介して通信することもできます。</target>
        </trans-unit>
        <trans-unit id="eb1152cd8067628adcb5244f0c52d2f1ebdecd3c" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;FILE&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;FILE&lt;/code&gt; タイプを表すHaskellタイプ。</target>
        </trans-unit>
        <trans-unit id="419c0d47d2c63155c445b3a35a04cad638377266" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;bool&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;bool&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="054a037a3aeec17395419134ad5d32666e879988" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;char&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;char&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="fdab6efef7ff3df329d3bbc78a8616b4cb3989a6" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;clock_t&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;clock_t&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="e86270c6c52b37291a4f83ecf2067e3d22c57c6e" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;double&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;double&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="a0598f733099fb128ae47c1c3166b704c545480c" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;float&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;float&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="9783270eb36d4323f4eecfe9fe711bc1dd549c60" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;fpos_t&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;fpos_t&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="3828a73b928783c1ab6b138f30ed4a7fd77963fd" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;int&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;int&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="0c7bc99c01a214a0469bc841c3db1a8545153961" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;int&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">HaskellはCの表現型 &lt;code&gt;int&lt;/code&gt; 型。&lt;em&gt;（&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="123f078eb33cc5f8ac71fcc1a58b2e7c9744c67a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;jmp_buf&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;jmp_buf&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="6a09db76fc4cf39e52e96e84ca7eceffcb2dc6cb" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long long&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;long long&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="8bc0cd5923376a1c5f20498ef35d8c0014b53573" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;long&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="050743a39470101ce4c3aaee27cdf563c19fb3e4" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">C &lt;code&gt;long&lt;/code&gt; タイプを表すHaskellタイプ。&lt;em&gt;（&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e280e77ea88a2a6aea1fcccbe66210a18677d7c4" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;ptrdiff_t&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;ptrdiff_t&lt;/code&gt; タイプを表すHaskellタイプ。</target>
        </trans-unit>
        <trans-unit id="2c33de586ddf7a29484efc41926b3029b29a9d4f" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;short&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;short&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="b6814ce0babdcf6409207c9d5c62a5d21549d670" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;sig_atomic_t&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;sig_atomic_t&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="dc79efb4536a8d15f8e47bcacf02aad5c789afda" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;signed char&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;signed char&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="d1e53c7ba3862ff8361e9698b99ceeef6ee695ac" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;size_t&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;size_t&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="34b7b2f84ee34dce910b692ae6d7694070d1eec8" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;suseconds_t&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;suseconds_t&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="da77000fdb42bf1ac5567a3f5f38306a7b9ce31a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;time_t&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;time_t&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="47fddfc3c7f8cfce68e214eb884c6dbf75a02426" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;time_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cの &lt;code&gt;time_t&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="51aa5d4ba2ad63bf1d5b193a1d5d1d64e9d7c6d8" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned char&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;unsigned char&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="ba250403e40dc5a5fe395ae550e60698ea8a63db" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cの &lt;code&gt;unsigned char&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fa56d97929c4f9c0dd6851175b77e5a237a45c9f" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned int&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;unsigned int&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="e7478eb320307f22ab3f106029e32684ea1826e3" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long long&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;unsigned long long&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="095152341382e5cc99a0893c334b897d9021c542" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;unsigned long&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="8e9fa8fbdf77f67a6bcf25da092f95906229af86" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cの &lt;code&gt;unsigned long&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="482e4215906c2a0c84b2e998c4bb04b882601162" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned short&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;unsigned short&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="0a6c68ad3241c76347c98ebc10b0631bbe19f4b1" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned short&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cの &lt;code&gt;unsigned short&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="26c48c6e42125f2dcb7f39d4c8e9601abc37dca1" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;useconds_t&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;useconds_t&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="c47e3f97a5805a43b017fd566e8e3a0455b50952" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;wchar_t&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;wchar_t&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="1342a24a0d486add6662622e572d9396963bb62c" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;wchar_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cを表すHaskellのタイプ &lt;code&gt;wchar_t&lt;/code&gt; タイプ。&lt;em&gt;（&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="40d7a20dd1cef70b191b1919721181f45bec4aa1" translate="yes" xml:space="preserve">
          <source>Haskell type signatures are implicitly quantified. When the language option &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is used, the keyword &lt;code&gt;forall&lt;/code&gt; allows us to say exactly what this means. For example:</source>
          <target state="translated">Haskellの型シグネチャは暗黙的に数量化されます。言語オプション&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;を使用する場合、キーワード &lt;code&gt;forall&lt;/code&gt; を使用すると、これが何を意味するかを正確に言うことができます。例えば：</target>
        </trans-unit>
        <trans-unit id="312958a763351ecbecd34417b742da475b01a5b7" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s &lt;code&gt;Maybe&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt; (list), &lt;code&gt;ST&lt;/code&gt; (both strict and lazy versions), &lt;code&gt;IO&lt;/code&gt;, and many other monads have &lt;code&gt;MonadFix&lt;/code&gt; instances. On the negative side, the continuation monad, with the signature &lt;code&gt;(a -&amp;gt; r) -&amp;gt; r&lt;/code&gt;, does not.</source>
          <target state="translated">Haskellの &lt;code&gt;Maybe&lt;/code&gt; 、 &lt;code&gt;[]&lt;/code&gt; （リスト）、 &lt;code&gt;ST&lt;/code&gt; （厳密バージョンと遅延バージョンの両方）、 &lt;code&gt;IO&lt;/code&gt; 、および他の多くのモナドには、 &lt;code&gt;MonadFix&lt;/code&gt; インスタンスがあります。否定的な側面では、署名 &lt;code&gt;(a -&amp;gt; r) -&amp;gt; r&lt;/code&gt; a- &amp;gt; r）-&amp;gt; rをもつ継続モナドはそうではありません。</target>
        </trans-unit>
        <trans-unit id="286ac067159c9b8667979c69f2ab39f042776595" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s defaulting mechanism (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.3.4&quot;&gt;Haskell Report, Section 4.3.4&lt;/a&gt;) is extended to cover string literals, when &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt; is specified. Specifically:</source>
          <target state="translated">Hasloadedのデフォルトメカニズム（&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.3.4&quot;&gt;Haskellレポート、セクション4.3.4&lt;/a&gt;）は、&lt;a href=&quot;#extension-OverloadedStrings&quot;&gt; &lt;code&gt;OverloadedStrings&lt;/code&gt; &lt;/a&gt;が指定されている場合、文字列リテラルをカバーするように拡張されています。具体的には：</target>
        </trans-unit>
        <trans-unit id="5c360d83894c7aaa51597c83bb2ca4c5910f6876" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s monomorphism restriction (see &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.5&quot;&gt;Section 4.5.5&lt;/a&gt; of the Haskell Report) can be completely switched off by &lt;a href=&quot;#extension-NoMonomorphismRestriction&quot;&gt;&lt;code&gt;NoMonomorphismRestriction&lt;/code&gt;&lt;/a&gt;. Since GHC 7.8.1, the monomorphism restriction is switched off by default in GHCi&amp;rsquo;s interactive options (see &lt;a href=&quot;ghci#ghci-interactive-options&quot;&gt;Setting options for interactive evaluation only&lt;/a&gt;).</source>
          <target state="translated">Haskellのモノモーフィズム制限（Haskellレポートの&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.5&quot;&gt;セクション4.5.5&lt;/a&gt;を参照）は、&lt;a href=&quot;#extension-NoMonomorphismRestriction&quot;&gt; &lt;code&gt;NoMonomorphismRestriction&lt;/code&gt; &lt;/a&gt;によって完全にオフにすることができます。GHC 7.8.1以降、GHCiの対話型オプションでは、単相性制限がデフォルトでオフになっています（&lt;a href=&quot;ghci#ghci-interactive-options&quot;&gt;対話型評価のみのオプションの設定を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="1a141ab08d985dedb9f98957467226e86a2237bf" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s overloading (using type classes) is elegant, neat, etc., etc., but it is death to performance if left to linger in an inner loop. How can you squash it?</source>
          <target state="translated">Haskellの（型クラスを使用した）オーバーロードは、エレガントで端正なものなどですが、内側のループに残っているとパフォーマンスが低下します。どうやってそれをつぶすことができますか？</target>
        </trans-unit>
        <trans-unit id="6dcc270971fff7841b459ba1100736aab53d82ce" translate="yes" xml:space="preserve">
          <source>Haskell2010</source>
          <target state="translated">Haskell2010</target>
        </trans-unit>
        <trans-unit id="8611224d67199ccb4a7a8d4b25bc635c1cfc3a48" translate="yes" xml:space="preserve">
          <source>Haskell98</source>
          <target state="translated">Haskell98</target>
        </trans-unit>
        <trans-unit id="b3c55f7ef7d356d7c9a7ac63331871b50a302e38" translate="yes" xml:space="preserve">
          <source>Haskellish interface to memcpy and memmove</source>
          <target state="translated">memcpy と memmove のための Haskellish インターフェイス</target>
        </trans-unit>
        <trans-unit id="b408395f7a6c9ad5cc0948fe6c746bdc2863b6c4" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about duplicate constraints in a type signature. For example</source>
          <target state="translated">コンパイラが型署名の重複制約について警告するようにします。例えば、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="bb44315e3933ae78ec7b2d4c76e749754a530e44" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about duplicate entries in export lists. This is useful information if you maintain large export lists, and want to avoid the continued export of a definition after you&amp;rsquo;ve deleted (one) mention of it in the export list.</source>
          <target state="translated">エクスポートリストの重複エントリについてコンパイラに警告させます。これは、大きなエクスポートリストを維持していて、エクスポートリストでその定義についての（1つの）言及を削除した後で、定義のエクスポートが続行されないようにする場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="fc7ae11dc5a0a8877bcb29fcbae185b9eb38ee9a" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about redundant constraints in a type signature. In particular:</source>
          <target state="translated">型署名の冗長な制約についてコンパイラが警告するようにします。特に</target>
        </trans-unit>
        <trans-unit id="83f4f4e6d95b4c6cd8400d7a4c53dd54d2cb85e3" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about redundant constraints in type signatures.</source>
          <target state="translated">型署名の冗長な制約についてコンパイラが警告するようにしました。</target>
        </trans-unit>
        <trans-unit id="624af9c99c0374959007cf34d186babd80bc825f" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if a kind variable is not explicitly quantified over. For instance, the following would produce a warning:</source>
          <target state="translated">kind変数が明示的に定量化されていない場合にコンパイラが警告を出すようにしました。例えば、以下のようにすると警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="9ba1acc7c9ce9a9b091d8587b0cb7dcc3c4e1695" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if the Prelude is implicitly imported. This happens unless either the Prelude module is explicitly imported with an &lt;code&gt;import
... Prelude ...&lt;/code&gt; line, or this implicit import is disabled (either by &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;-XNoImplicitPrelude&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; pragma).</source>
          <target state="translated">Preludeが暗黙的にインポートされた場合にコンパイラーに警告させます。これは、Preludeモジュールが &lt;code&gt;import ... Prelude ...&lt;/code&gt; 行で明示的にインポートされるか、この暗黙のインポートが（&lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt; &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; &lt;/a&gt;または &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; プラグマによって）無効にされない限り発生します。</target>
        </trans-unit>
        <trans-unit id="27968fc346539074eff95309c304b2956773d765" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if the Prelude is implicitly imported. This happens unless either the Prelude module is explicitly imported with an &lt;code&gt;import
... Prelude ...&lt;/code&gt; line, or this implicit import is disabled (either by &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;NoImplicitPrelude&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; pragma).</source>
          <target state="translated">プレリュードが暗黙的にインポートされた場合、コンパイラーに警告させます。これは、Preludeモジュールが &lt;code&gt;import ... Prelude ...&lt;/code&gt; 行で明示的にインポートされるか、この暗黙的なインポートが無効にされていない限り発生します（&lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt; &lt;code&gt;NoImplicitPrelude&lt;/code&gt; &lt;/a&gt;または &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; プラグマのいずれかによって）。</target>
        </trans-unit>
        <trans-unit id="9b28e1b8588f425f51c4575626ab47cf2ecc0796" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if there are tabs in your source file.</source>
          <target state="translated">ソースファイルにタブがある場合は、コンパイラが警告するようにします。</target>
        </trans-unit>
        <trans-unit id="70054c2390d77cf46a86a1147ea85118a1ef3f99" translate="yes" xml:space="preserve">
          <source>Have the compiler warn/inform you where in your source the Haskell Monomorphism Restriction is applied. If applied silently the MR can give rise to unexpected behaviour, so it can be helpful to have an explicit warning that it is being applied.</source>
          <target state="translated">Haskell 単相性制限が適用されているソースのどこで適用されているかをコンパイラが警告/通知するようにしてください。静かに適用された場合、MRは予期せぬ動作をする可能性があるので、適用されていることを明示的に警告しておくと便利です。</target>
        </trans-unit>
        <trans-unit id="d2afe399bfaedad9702ee7fd70b7b7244f971386" translate="yes" xml:space="preserve">
          <source>Have the compiler warn/inform you where in your source the Haskell defaulting mechanism for numeric types kicks in. This is useful information when converting code from a context that assumed one default into one with another, e.g., the &amp;lsquo;default default&amp;rsquo; for Haskell 1.4 caused the otherwise unconstrained value &lt;code&gt;1&lt;/code&gt; to be given the type &lt;code&gt;Int&lt;/code&gt;, whereas Haskell 98 and later defaults it to &lt;code&gt;Integer&lt;/code&gt;. This may lead to differences in performance and behaviour, hence the usefulness of being non-silent about this.</source>
          <target state="translated">ソースのどこで数値型のHaskellデフォルトメカニズムが作動するかをコンパイラに警告/通知させます。これは、あるデフォルトを想定するコンテキストから別のデフォルトに変換するときの有用な情報です。たとえば、Haskell 1.4の「デフォルトデフォルト」それ以外の場合は制約されていない値 &lt;code&gt;1&lt;/code&gt; に型 &lt;code&gt;Int&lt;/code&gt; が指定されたのに対し、Haskell 98以降ではデフォルトで &lt;code&gt;Integer&lt;/code&gt; に設定されていました。これは、パフォーマンスと動作の違いにつながる可能性があります。そのため、これについて沈黙しないことが有用です。</target>
        </trans-unit>
        <trans-unit id="5498abf9bbeb2f58bbb844fe2ccb526cf856d105" translate="yes" xml:space="preserve">
          <source>Having compiled the program for profiling, you now need to run it to generate the profile. For example, a simple time profile can be generated by running the program with &lt;code&gt;+RTS -p&lt;/code&gt; (see &lt;a href=&quot;#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt;), which generates a file named &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.prof&lt;/code&gt; where ⟨prog⟩ is the name of your program (without the &lt;code&gt;.exe&lt;/code&gt; extension, if you are on Windows).</source>
          <target state="translated">プロファイリング用のプログラムをコンパイルしたら、それを実行してプロファイルを生成する必要があります。たとえば、 &lt;code&gt;+RTS -p&lt;/code&gt; （&lt;a href=&quot;#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; を&lt;/a&gt;参照）を指定してプログラムを実行することにより、単純な時間プロファイルを生成できます。これにより、 &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.prof&lt;/code&gt; という名前のファイルが生成されます。ここで、「&lt;em&gt;prog&lt;/em&gt;」は&lt;em&gt;プログラム&lt;/em&gt;の名前です（拡張子 &lt;code&gt;.exe&lt;/code&gt; なし）。 Windowsを使用している場合）。</target>
        </trans-unit>
        <trans-unit id="9c5b0196dfa158a640e0507548062ffac1c9509d" translate="yes" xml:space="preserve">
          <source>Having run the program, we can generate a textual summary of coverage:</source>
          <target state="translated">プログラムを実行すると、カバレッジのテキストサマリーを作成することができます。</target>
        </trans-unit>
        <trans-unit id="8e7c42bd3113b21fb94871ff334499b878d14a0e" translate="yes" xml:space="preserve">
          <source>Having said that, we &lt;em&gt;can&lt;/em&gt; document exactly what GHC does with respect to the floating point state, so that if you really need to use &lt;code&gt;fenv.h&lt;/code&gt; then you can do so with full knowledge of the pitfalls:</source>
          <target state="translated">そうは言っても、浮動小数点の状態に関してGHCが&lt;em&gt;行うことを&lt;/em&gt;正確に文書化&lt;em&gt;できる&lt;/em&gt;ので、実際に &lt;code&gt;fenv.h&lt;/code&gt; を使用する必要がある場合は、落とし穴を完全に理解した上で行うことができます。</target>
        </trans-unit>
        <trans-unit id="3bf4aec16734a9e97669c90f0df9d922bc22aee2" translate="yes" xml:space="preserve">
          <source>Head and tail of string broken at substring</source>
          <target state="translated">文字列の先頭と末尾が substring で壊れている</target>
        </trans-unit>
        <trans-unit id="d1d7ca754b0a092c3e57740e0999c3698d86bf13" translate="yes" xml:space="preserve">
          <source>Heap fragmentation</source>
          <target state="translated">ヒープの断片化</target>
        </trans-unit>
        <trans-unit id="572f0f8bd257503295a21f9d80fde910db01c38c" translate="yes" xml:space="preserve">
          <source>HeapByCCS</source>
          <target state="translated">HeapByCCS</target>
        </trans-unit>
        <trans-unit id="8c6ad9c60a037be60f4d12e9727ec1dd6fb58d15" translate="yes" xml:space="preserve">
          <source>HeapByClosureType</source>
          <target state="translated">HeapByClosureType</target>
        </trans-unit>
        <trans-unit id="67189d744bb418e35b57f2c375c2f70ffcda9c38" translate="yes" xml:space="preserve">
          <source>HeapByDescr</source>
          <target state="translated">HeapByDescr</target>
        </trans-unit>
        <trans-unit id="ac2ddc42c46684b8a60b44d593d3341dc156883c" translate="yes" xml:space="preserve">
          <source>HeapByLDV</source>
          <target state="translated">HeapByLDV</target>
        </trans-unit>
        <trans-unit id="ab2990dbf6d95e591ed5d567962d304a62d73db5" translate="yes" xml:space="preserve">
          <source>HeapByMod</source>
          <target state="translated">HeapByMod</target>
        </trans-unit>
        <trans-unit id="c5860308e2043941209f92548c297cda091fbd26" translate="yes" xml:space="preserve">
          <source>HeapByRetainer</source>
          <target state="translated">HeapByRetainer</target>
        </trans-unit>
        <trans-unit id="449a4bf1c2c9b0156bb827447b1b70399b9a2bbe" translate="yes" xml:space="preserve">
          <source>HeapByType</source>
          <target state="translated">HeapByType</target>
        </trans-unit>
        <trans-unit id="0a4f1a75f10d18da48ca6030d1af26f2b38bc7d5" translate="yes" xml:space="preserve">
          <source>HeapOverflow</source>
          <target state="translated">HeapOverflow</target>
        </trans-unit>
        <trans-unit id="fba6d5e717ea526f849b6efdaf8193417b738a9d" translate="yes" xml:space="preserve">
          <source>Heaps</source>
          <target state="translated">Heaps</target>
        </trans-unit>
        <trans-unit id="934835a36e88b263f02948e4dbd8c5dd04401bc0" translate="yes" xml:space="preserve">
          <source>Helper functions</source>
          <target state="translated">ヘルパー機能</target>
        </trans-unit>
        <trans-unit id="5b912a2c5bb90bae872b79adf45f16133c4fd255" translate="yes" xml:space="preserve">
          <source>Helper to fully evaluate &lt;code&gt;&lt;a href=&quot;type-reflection#t:SomeTypeRep&quot;&gt;SomeTypeRep&lt;/a&gt;&lt;/code&gt; for use as &lt;code&gt;NFData(rnf)&lt;/code&gt; implementation</source>
          <target state="translated">&lt;code&gt;NFData(rnf)&lt;/code&gt; 実装として使用するために &lt;code&gt;&lt;a href=&quot;type-reflection#t:SomeTypeRep&quot;&gt;SomeTypeRep&lt;/a&gt;&lt;/code&gt; を完全に評価するヘルパー</target>
        </trans-unit>
        <trans-unit id="aa871229f3037dd5b17c54f9bd6a24abf6b10e89" translate="yes" xml:space="preserve">
          <source>Helper to fully evaluate &lt;code&gt;&lt;a href=&quot;type-reflection#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; for use as &lt;code&gt;NFData(rnf)&lt;/code&gt; implementation</source>
          <target state="translated">&lt;code&gt;NFData(rnf)&lt;/code&gt; 実装として使用するために &lt;code&gt;&lt;a href=&quot;type-reflection#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; を完全に評価するヘルパー</target>
        </trans-unit>
        <trans-unit id="01aa287a9e6ccd271de097c45912c21c3a884f7b" translate="yes" xml:space="preserve">
          <source>Helper to fully evaluate &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; for use as &lt;code&gt;NFData(rnf)&lt;/code&gt; implementation</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;NFData(rnf)&lt;/code&gt; 実装として使用するために完全に評価するヘルパー</target>
        </trans-unit>
        <trans-unit id="42aad862bc90fff6991f6294f9c9fa7c57b05312" translate="yes" xml:space="preserve">
          <source>Helpers for &lt;code&gt;RealFloat&lt;/code&gt; type-class operations</source>
          <target state="translated">&lt;code&gt;RealFloat&lt;/code&gt; タイプクラス操作のヘルパー</target>
        </trans-unit>
        <trans-unit id="96b3626fe3abd6dd061729bf2a8d1e0b63df13e7" translate="yes" xml:space="preserve">
          <source>Helpers for defining &quot;wrapper&quot; functions</source>
          <target state="translated">ラッパー」関数を定義するためのヘルパー</target>
        </trans-unit>
        <trans-unit id="9b312d08020a7a266d812110fde12a2a83862f68" translate="yes" xml:space="preserve">
          <source>Hence, the original expression must have a type which is an instance of the &lt;code&gt;Show&lt;/code&gt; class, or GHCi will complain:</source>
          <target state="translated">したがって、元の式には &lt;code&gt;Show&lt;/code&gt; クラスのインスタンスである型が必要です。そうでない場合、GHCiは文句を言います。</target>
        </trans-unit>
        <trans-unit id="ecbcb0e424c40d9931c2c7c8b44c33c5f4e12465" translate="yes" xml:space="preserve">
          <source>Here</source>
          <target state="translated">Here</target>
        </trans-unit>
        <trans-unit id="fbb03ee11c282574e4295542c0218f98b1aad7d8" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;A&lt;/code&gt; imports &lt;code&gt;B&lt;/code&gt;, but &lt;code&gt;B&lt;/code&gt; imports &lt;code&gt;A&lt;/code&gt; with a &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; pragma, which breaks the circular dependency. Every loop in the module import graph must be broken by a &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; import; or, equivalently, the module import graph must be acyclic if &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; imports are ignored.</source>
          <target state="translated">ここで、 &lt;code&gt;A&lt;/code&gt; は &lt;code&gt;B&lt;/code&gt; をインポートしますが、 &lt;code&gt;B&lt;/code&gt; は &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; プラグマを使用して &lt;code&gt;A&lt;/code&gt; をインポートします。これにより、循環依存が解除されます。モジュールインポートグラフのすべてのループは、 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; インポートによって中断する必要があります。または、 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; インポートが無視される場合、同等に、モジュールインポートグラフは非循環的である必要があります。</target>
        </trans-unit>
        <trans-unit id="f8399ef26432f55f6e29dace236362d3bda6f8aa" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;a&lt;/code&gt; is ambiguous in the definition of &lt;code&gt;D&lt;/code&gt; but later specified to be &lt;code&gt;Int&lt;/code&gt; using type applications.</source>
          <target state="translated">ここで &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;D&lt;/code&gt; の定義があいまいですが、後で型アプリケーションを使用して &lt;code&gt;Int&lt;/code&gt; と指定されています。</target>
        </trans-unit>
        <trans-unit id="84d964c9cfca665c8adcbfb18e361180bdc190f2" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; are class parameters, but the type is also indexed on a third parameter &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">ここで &lt;code&gt;c&lt;/code&gt; と &lt;code&gt;a&lt;/code&gt; はクラスパラメーターですが、型には3番目のパラメーター &lt;code&gt;x&lt;/code&gt; でもインデックスが付けられます。</target>
        </trans-unit>
        <trans-unit id="a83c105689c8fd61a7dfc1566a878cd9f0c4ca65" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f1&lt;/code&gt; does not use pattern synonyms. To match against the numeric pattern &lt;code&gt;42&lt;/code&gt;&lt;em&gt;requires&lt;/em&gt; the caller to satisfy the constraints &lt;code&gt;(Num a, Eq a)&lt;/code&gt;, so they appear in &lt;code&gt;f1&lt;/code&gt;&amp;lsquo;s type. The call to &lt;code&gt;show&lt;/code&gt; generates a &lt;code&gt;(Show b)&lt;/code&gt; constraint, where &lt;code&gt;b&lt;/code&gt; is an existentially type variable bound by the pattern match on &lt;code&gt;MkT&lt;/code&gt;. But the same pattern match also &lt;em&gt;provides&lt;/em&gt; the constraint &lt;code&gt;(Show b)&lt;/code&gt; (see &lt;code&gt;MkT&lt;/code&gt;&amp;lsquo;s type), and so all is well.</source>
          <target state="translated">ここで、 &lt;code&gt;f1&lt;/code&gt; はパターン同義語を使用しません。数値パターン &lt;code&gt;42&lt;/code&gt; &lt;em&gt;と&lt;/em&gt;照合&lt;em&gt;するには&lt;/em&gt;、呼び出し元が制約 &lt;code&gt;(Num a, Eq a)&lt;/code&gt; を満たす&lt;em&gt;必要が&lt;/em&gt;あるため、これらは &lt;code&gt;f1&lt;/code&gt; の型に表示されます。 &lt;code&gt;show&lt;/code&gt; を呼び出すと、 &lt;code&gt;(Show b)&lt;/code&gt; 制約が生成されます。ここで、 &lt;code&gt;b&lt;/code&gt; は &lt;code&gt;MkT&lt;/code&gt; のパターンマッチによってバインドされた実存型の変数です。しかし、同じパターンマッチは制約 &lt;code&gt;(Show b)&lt;/code&gt; （ &lt;code&gt;MkT&lt;/code&gt; のタイプを参照）も&lt;em&gt;提供&lt;/em&gt;するため、すべて順調です。</target>
        </trans-unit>
        <trans-unit id="4b59b8aee2721ff8de102981e018fa8f69756fd0" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f1&lt;/code&gt; does not use pattern synonyms. To match against the numeric pattern &lt;code&gt;42&lt;/code&gt;&lt;em&gt;requires&lt;/em&gt; the caller to satisfy the constraints &lt;code&gt;(Num a, Eq a)&lt;/code&gt;, so they appear in &lt;code&gt;f1&lt;/code&gt;&amp;rsquo;s type. The call to &lt;code&gt;show&lt;/code&gt; generates a &lt;code&gt;(Show b)&lt;/code&gt; constraint, where &lt;code&gt;b&lt;/code&gt; is an existentially type variable bound by the pattern match on &lt;code&gt;MkT&lt;/code&gt;. But the same pattern match also &lt;em&gt;provides&lt;/em&gt; the constraint &lt;code&gt;(Show b)&lt;/code&gt; (see &lt;code&gt;MkT&lt;/code&gt;&amp;rsquo;s type), and so all is well.</source>
          <target state="translated">ここで、 &lt;code&gt;f1&lt;/code&gt; はパターンシノニムを使用しません。数値パターン &lt;code&gt;42&lt;/code&gt; &lt;em&gt;と&lt;/em&gt;照合&lt;em&gt;するには&lt;/em&gt;、呼び出し元が制約 &lt;code&gt;(Num a, Eq a)&lt;/code&gt; を満たす&lt;em&gt;必要が&lt;/em&gt;あるため、 &lt;code&gt;f1&lt;/code&gt; の型で表示されます。 &lt;code&gt;show&lt;/code&gt; を呼び出すと、 &lt;code&gt;(Show b)&lt;/code&gt; 制約が生成されます。ここで、 &lt;code&gt;b&lt;/code&gt; は、 &lt;code&gt;MkT&lt;/code&gt; のパターンマッチによってバインドされた既存の型変数です。ただし、同じパターンマッチでも制約が&lt;em&gt;提供さ&lt;/em&gt;れるため &lt;code&gt;(Show b)&lt;/code&gt; （ &lt;code&gt;MkT&lt;/code&gt; のタイプを参照）、すべて問題ありません。</target>
        </trans-unit>
        <trans-unit id="c6ef93a85414044a6743aade675856cb8b2404a3" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f&lt;/code&gt; is generalised because it has no free variables; and its binding group is unaffected by the monomorphism restriction; and hence &lt;code&gt;f&lt;/code&gt; is closed. The same reasoning applies to &lt;code&gt;g&lt;/code&gt;, except that it has one closed free variable, namely &lt;code&gt;f&lt;/code&gt;. Similarly &lt;code&gt;h&lt;/code&gt; is closed, &lt;em&gt;even though it is not bound at top level&lt;/em&gt;, because its only free variable &lt;code&gt;f&lt;/code&gt; is closed. But &lt;code&gt;k&lt;/code&gt; is not closed, because it mentions &lt;code&gt;x&lt;/code&gt; which is not closed (because it is not let-bound).</source>
          <target state="translated">ここで、 &lt;code&gt;f&lt;/code&gt; には自由変数がないため一般化されています。そして、その結合グループは、単形性制限の影響を受けません。したがって、 &lt;code&gt;f&lt;/code&gt; は閉じています。同じ理由が &lt;code&gt;g&lt;/code&gt; にも当てはまりますが、1つの閉じた自由変数、つまり &lt;code&gt;f&lt;/code&gt; がある点が異なります。同様に、 &lt;code&gt;h&lt;/code&gt; は&lt;em&gt;、最上位でバインドされていなくても&lt;/em&gt;閉じられ&lt;em&gt;ています。これは&lt;/em&gt;、自由変数 &lt;code&gt;f&lt;/code&gt; だけが閉じているためです。しかし、 &lt;code&gt;k&lt;/code&gt; は閉じられていません。閉じられていない &lt;code&gt;x&lt;/code&gt; について言及しているからです（これは束縛されないためです）。</target>
        </trans-unit>
        <trans-unit id="6b823e1758b1c0ce3297af5a6572a41579e18c99" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f&lt;/code&gt; must be updating &lt;code&gt;T&lt;/code&gt; because neither &lt;code&gt;S&lt;/code&gt; nor &lt;code&gt;U&lt;/code&gt; have both fields.</source>
          <target state="translated">&lt;code&gt;S&lt;/code&gt; も &lt;code&gt;U&lt;/code&gt; も両方のフィールドを持たないため、ここで &lt;code&gt;f&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; を更新している必要があります。</target>
        </trans-unit>
        <trans-unit id="b44e1be2ff74797a08ba2e1197bb693a802bcebd" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;h&lt;/code&gt;&amp;lsquo;s type looks ambiguous in &lt;code&gt;b&lt;/code&gt;, but here&amp;rsquo;s a legal call:</source>
          <target state="translated">ここで &lt;code&gt;h&lt;/code&gt; の型は &lt;code&gt;b&lt;/code&gt; で曖昧に見えますが、これは正当な呼び出しです：</target>
        </trans-unit>
        <trans-unit id="b246caf870407f889ea8871b1250446e1716fa4c" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;h&lt;/code&gt;&amp;rsquo;s type looks ambiguous in &lt;code&gt;b&lt;/code&gt;, but here&amp;rsquo;s a legal call:</source>
          <target state="translated">ここで、 &lt;code&gt;h&lt;/code&gt; のタイプは &lt;code&gt;b&lt;/code&gt; であいまいに見えますが、これが合法的な呼び出しです。</target>
        </trans-unit>
        <trans-unit id="5580273dadf2edf4e8b3e5d2e96253462581e863" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;strange&lt;/code&gt;&amp;lsquo;s type is ambiguous, but the call in &lt;code&gt;foo&lt;/code&gt; is OK because it gives rise to a constraint &lt;code&gt;(D Bool beta)&lt;/code&gt;, which is soluble by the &lt;code&gt;(D Bool b)&lt;/code&gt; instance.</source>
          <target state="translated">ここでは &lt;code&gt;strange&lt;/code&gt; の型があいまいですが、 &lt;code&gt;(D Bool b)&lt;/code&gt; インスタンスによって可溶化される制約 &lt;code&gt;(D Bool beta)&lt;/code&gt; が発生するため、 &lt;code&gt;foo&lt;/code&gt; での呼び出しはOKです。</target>
        </trans-unit>
        <trans-unit id="49cd73f3d29efb220092644a24b1f6c41bca4225" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;strange&lt;/code&gt;&amp;rsquo;s type is ambiguous, but the call in &lt;code&gt;foo&lt;/code&gt; is OK because it gives rise to a constraint &lt;code&gt;(D Bool beta)&lt;/code&gt;, which is soluble by the &lt;code&gt;(D Bool b)&lt;/code&gt; instance.</source>
          <target state="translated">ここでは、 &lt;code&gt;strange&lt;/code&gt; の型はあいまいですが、 &lt;code&gt;foo&lt;/code&gt; での呼び出しは、 &lt;code&gt;(D Bool b)&lt;/code&gt; インスタンスによって解決可能な制約 &lt;code&gt;(D Bool beta)&lt;/code&gt; を発生させるため、問題ありません。</target>
        </trans-unit>
        <trans-unit id="c7e74f35f734a03f3bce931bb0f5d5375f57de25" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;tag&lt;/code&gt; is a public field, with a well-typed selector function &lt;code&gt;tag :: Counter a -&amp;gt; a&lt;/code&gt;. The &lt;code&gt;self&lt;/code&gt; type is hidden from the outside; any attempt to apply &lt;code&gt;_this&lt;/code&gt;, &lt;code&gt;_inc&lt;/code&gt; or &lt;code&gt;_display&lt;/code&gt; as functions will raise a compile-time error. In other words, &lt;em&gt;GHC defines a record selector function only for fields whose type does not mention the existentially-quantified variables&lt;/em&gt;. (This example used an underscore in the fields for which record selectors will not be defined, but that is only programming style; GHC ignores them.)</source>
          <target state="translated">ここで、 &lt;code&gt;tag&lt;/code&gt; はパブリックフィールドであり、適切に型指定されたセレクター関数 &lt;code&gt;tag :: Counter a -&amp;gt; a&lt;/code&gt; ます。 &lt;code&gt;self&lt;/code&gt; タイプは外部から隠されています。関数として &lt;code&gt;_this&lt;/code&gt; 、 &lt;code&gt;_inc&lt;/code&gt; または &lt;code&gt;_display&lt;/code&gt; を適用しようとすると、コンパイル時エラーが発生します。言い換えると、&lt;em&gt;GHCは、型が実存的に定量化された変数に言及していないフィールドに対してのみ、レコードセレクター関数を定義します&lt;/em&gt;。（この例では、レコードセレクターが定義されないフィールドにアンダースコアを使用しましたが、これはプログラミングスタイルにすぎません。GHCはそれらを無視します。）</target>
        </trans-unit>
        <trans-unit id="de5848d57cf456303e6aaae0111187f76226179d" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;x&lt;/code&gt; and the pattern binding &lt;code&gt;(y,z)&lt;/code&gt; remain lazy. Reason: there is no good moment to force them, until first use.</source>
          <target state="translated">ここで、 &lt;code&gt;x&lt;/code&gt; とパターンバインディング &lt;code&gt;(y,z)&lt;/code&gt; は遅延したままです。理由：最初に使用するまで、強制する良い瞬間はありません。</target>
        </trans-unit>
        <trans-unit id="98c889417053878657fe2e9a8e21f6e33d087297" translate="yes" xml:space="preserve">
          <source>Here GHC has translated the expression into</source>
          <target state="translated">ここで、GHCは、その発現を</target>
        </trans-unit>
        <trans-unit id="4200822fb94b0bfc0d0b0fd94e6cf82c6d349ff5" translate="yes" xml:space="preserve">
          <source>Here GHC will not solve the constraint &lt;code&gt;(C c Int)&lt;/code&gt; from the top-level instance, because a particular call of &lt;code&gt;g&lt;/code&gt; might instantiate both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; to the same type, which would allow the constraint to be solved in a different way. This latter restriction is principally to make the constraint-solver complete. (Interested folk can read &lt;code&gt;Note [Instance and Given overlap]&lt;/code&gt; in &lt;code&gt;TcInteract&lt;/code&gt;.) It is easy to avoid: in a type signature avoid a constraint that matches a top-level instance. The flag &lt;a href=&quot;using-warnings#ghc-flag--Wsimplifiable-class-constraints&quot;&gt;&lt;code&gt;-Wsimplifiable-class-constraints&lt;/code&gt;&lt;/a&gt; warns about such signatures.</source>
          <target state="translated">ここでGHCは最上位のインスタンスからの制約 &lt;code&gt;(C c Int)&lt;/code&gt; を解決しません。これは、 &lt;code&gt;g&lt;/code&gt; の特定の呼び出しが &lt;code&gt;b&lt;/code&gt; と &lt;code&gt;c&lt;/code&gt; の両方を同じタイプにインスタンス化し、異なる方法で制約を解決できるためです。この後者の制限は、主に制約ソルバーを完全にすることです。（興味のある人は &lt;code&gt;TcInteract&lt;/code&gt; の &lt;code&gt;Note [Instance and Given overlap]&lt;/code&gt; を読むことができます。）簡単に回避できます。型シグネチャでは、最上位のインスタンスに一致する制約を回避します。フラグ&lt;a href=&quot;using-warnings#ghc-flag--Wsimplifiable-class-constraints&quot;&gt; &lt;code&gt;-Wsimplifiable-class-constraints&lt;/code&gt; は&lt;/a&gt;、このような署名について警告します。</target>
        </trans-unit>
        <trans-unit id="c0cb08091788d9276ad005df64a62df2471916ac" translate="yes" xml:space="preserve">
          <source>Here are a few examples of using the &lt;code&gt;filepath&lt;/code&gt; functions together:</source>
          <target state="translated">次に、 &lt;code&gt;filepath&lt;/code&gt; 関数を一緒に使用するいくつかの例を示します。</target>
        </trans-unit>
        <trans-unit id="8a79e773a9d37344cccecd1e6b27389b6ae9d630" translate="yes" xml:space="preserve">
          <source>Here are some examples of admissible and illegal type instances:</source>
          <target state="translated">ここでは、許容可能なタイプと違法なタイプの例を紹介します。</target>
        </trans-unit>
        <trans-unit id="25023bd7f5466b38299a82f7530be3c8c581e9e8" translate="yes" xml:space="preserve">
          <source>Here are some examples of how this translation works. The first expression of each sequence is Haskell source; the subsequent ones are Core.</source>
          <target state="translated">この翻訳がどのように機能するか、いくつかの例を紹介します。各シーケンスの最初の式はHaskellソースで、それ以降の式はCoreです。</target>
        </trans-unit>
        <trans-unit id="a53d0f1e137d9d27c69f2dc138fdd7c31d405ef3" translate="yes" xml:space="preserve">
          <source>Here are some examples of using said representation. Consider a few types of the &lt;code&gt;Type&lt;/code&gt; universe encoded like this:</source>
          <target state="translated">上記の表現の使用例をいくつか示します。次のようにエンコードされた &lt;code&gt;Type&lt;/code&gt; ユニバースのいくつかのタイプを考えます。</target>
        </trans-unit>
        <trans-unit id="1938696280e6b5bf3660612c2408006d76611c9a" translate="yes" xml:space="preserve">
          <source>Here are some examples that illustrate the property:</source>
          <target state="translated">ここでは、その性質を説明する例をいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">ここでは、いくつかの例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="7e3cfeff552447efcf37ae18b5959e5301027734" translate="yes" xml:space="preserve">
          <source>Here are some export lists and their meaning:</source>
          <target state="translated">ここでは、いくつかのエクスポートリストとその意味を紹介します。</target>
        </trans-unit>
        <trans-unit id="757e98b8dc27b605d3ba22a718bc090780c91f60" translate="yes" xml:space="preserve">
          <source>Here are some more details:</source>
          <target state="translated">以下、詳細をご紹介します。</target>
        </trans-unit>
        <trans-unit id="fef4a6f74860fdc9aa02bdcc17602e952e06fa44" translate="yes" xml:space="preserve">
          <source>Here are some other important points in using the recursive-do notation:</source>
          <target state="translated">ここでは、再帰的do記法を使用する際の他の重要なポイントをいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="7acccdf9bd48aabe31c92ed0d7e8b5709c940249" translate="yes" xml:space="preserve">
          <source>Here are the differences between the generated code for &lt;code&gt;Functor&lt;/code&gt; and &lt;code&gt;Foldable&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Functor&lt;/code&gt; と &lt;code&gt;Foldable&lt;/code&gt; 用に生成されたコードの違いは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="17ba5c6ad5fee6c15536c72e587bdaba386e2b34" translate="yes" xml:space="preserve">
          <source>Here are the differences between the generated code in each extension:</source>
          <target state="translated">それぞれの拡張機能で生成されたコードの違いをご紹介します。</target>
        </trans-unit>
        <trans-unit id="75d0fd5666cf351f1559a1cb0f0f5ec8ec9e925e" translate="yes" xml:space="preserve">
          <source>Here are the key definitions, all available from &lt;code&gt;GHC.Exts&lt;/code&gt;:</source>
          <target state="translated">主な定義は &lt;code&gt;GHC.Exts&lt;/code&gt; とおりです。すべてGHC.Extsから入手できます。</target>
        </trans-unit>
        <trans-unit id="06158caf9a087d2325d1d35545027e3560435152" translate="yes" xml:space="preserve">
          <source>Here are the salient features</source>
          <target state="translated">顕著な特徴は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="5858cb273a5f386866d01967e86562b0221422f8" translate="yes" xml:space="preserve">
          <source>Here follow the properties:</source>
          <target state="translated">ここでは、プロパティに従ってください。</target>
        </trans-unit>
        <trans-unit id="06ba49b7a3494e39c5e9ac6930fb642d56cb237a" translate="yes" xml:space="preserve">
          <source>Here is a brief description of the syntax of this file:</source>
          <target state="translated">このファイルの構文を簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="5105a9eca2c2d760c9113cca77cea941a304a915" translate="yes" xml:space="preserve">
          <source>Here is a recursive case</source>
          <target state="translated">再帰的な場合は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="18950c0f655cc85f7d1a80526879f141a4d6d368" translate="yes" xml:space="preserve">
          <source>Here is a reduced representation for &lt;code&gt;Tree&lt;/code&gt; with nearly all meta-information removed, for now keeping only the most essential aspects:</source>
          <target state="translated">以下は、ほとんどすべてのメタ情報が削除された &lt;code&gt;Tree&lt;/code&gt; の縮小表現です。ここでは、最も重要な側面のみを保持しています。</target>
        </trans-unit>
        <trans-unit id="28fb01aed2be37a9164cef272d31b4a46e6c1038" translate="yes" xml:space="preserve">
          <source>Here is a simple (albeit contrived) example:</source>
          <target state="translated">ここでは、簡単な(といっても、工夫された)例を挙げてみましょう。</target>
        </trans-unit>
        <trans-unit id="d4e51f8f8c6252d41c390512eb60cd71252079ee" translate="yes" xml:space="preserve">
          <source>Here is a simple non-recursive case:</source>
          <target state="translated">ここでは、単純な非再帰的なケースを紹介します。</target>
        </trans-unit>
        <trans-unit id="f5d55f3cbfa08c1d6611de1d00732137a0861eda" translate="yes" xml:space="preserve">
          <source>Here is an example &lt;code&gt;mdo&lt;/code&gt;-expression, and its translation to &lt;code&gt;rec&lt;/code&gt; blocks:</source>
          <target state="translated">次に &lt;code&gt;mdo&lt;/code&gt; 式の例と、 &lt;code&gt;rec&lt;/code&gt; ブロックへの変換を示します。</target>
        </trans-unit>
        <trans-unit id="0b2a7e6f45cd62f2ccce2503e6f62a2ed13efd54" translate="yes" xml:space="preserve">
          <source>Here is an example of a constrained kind:</source>
          <target state="translated">制約のある種類の例です。</target>
        </trans-unit>
        <trans-unit id="2a3922bbc09781ebd37624e0cd064a9ad42e44e9" translate="yes" xml:space="preserve">
          <source>Here is an example of a program with a couple of SCCs:</source>
          <target state="translated">ここでは、SCCをいくつか導入したプログラムの例を紹介します。</target>
        </trans-unit>
        <trans-unit id="afe44385b028eb6afad10373c4fd9bacc89b3246" translate="yes" xml:space="preserve">
          <source>Here is an example of how one can derive &lt;code&gt;Lift&lt;/code&gt;:</source>
          <target state="translated">以下は、 &lt;code&gt;Lift&lt;/code&gt; を導出する方法の例です。</target>
        </trans-unit>
        <trans-unit id="c1c0fbe0a0af6bebfb37d12467531a81c8a76ffa" translate="yes" xml:space="preserve">
          <source>Here is an example of this in action:</source>
          <target state="translated">これを実際に行った例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="5870318040b4cbc35ef0a6a189cf2b6b2009b5dc" translate="yes" xml:space="preserve">
          <source>Here is an example of using type-level numeric literals to provide a safe interface to a low-level function:</source>
          <target state="translated">ここでは、型レベルの数値リテラルを使用して、低レベル関数への安全なインタフェースを提供する例を示します。</target>
        </trans-unit>
        <trans-unit id="cae619abf546c35dc2c1fbfcf0f55d35804f8535" translate="yes" xml:space="preserve">
          <source>Here is an example of using type-level string literals to simulate simple record operations:</source>
          <target state="translated">ここでは、型レベルの文字列リテラルを使用して単純なレコード操作をシミュレートする例を示します。</target>
        </trans-unit>
        <trans-unit id="0ff9206b7ffb5ba70efe3f04ba78d877b18348c4" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates the use of a custom &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; data type with the &lt;code&gt;&lt;a href=&quot;control-monad-error#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-error#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; exception mechanism from &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt;. The example throws an exception if the user enters an empty string or a string longer than 5 characters. Otherwise it prints length of the string.</source>
          <target state="translated">ここでは、カスタムの使用を示す例である &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; とデータ型 &lt;code&gt;&lt;a href=&quot;control-monad-error#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-monad-error#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; から例外メカニズム &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; は。この例では、ユーザーが空の文字列または5文字を超える文字列を入力した場合に例外がスローされます。それ以外の場合は、文字列の長さを出力します。</target>
        </trans-unit>
        <trans-unit id="43b381c025413f1d67c38ee5f2502e185d0fb7d3" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates the use of a custom error data type with the &lt;code&gt;&lt;a href=&quot;control-monad-except#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-except#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; exception mechanism from &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt;. The example throws an exception if the user enters an empty string or a string longer than 5 characters. Otherwise it prints length of the string.</source>
          <target state="translated">ここでカスタムエラーデータ型の使用を示す例である &lt;code&gt;&lt;a href=&quot;control-monad-except#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-monad-except#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; から例外メカニズム &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; は。この例では、ユーザーが空の文字列または5文字を超える文字列を入力した場合に例外がスローされます。それ以外の場合は、文字列の長さを出力します。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">ここでは一例を紹介します。</target>
        </trans-unit>
        <trans-unit id="535dae368fdcd63238ee3ab417dc08f09f956a7e" translate="yes" xml:space="preserve">
          <source>Here is an extension of the record access example in &lt;a href=&quot;#type-level-literals&quot;&gt;Type-Level Literals&lt;/a&gt; showing how an overloaded label can be used as a record selector:</source>
          <target state="translated">&lt;a href=&quot;#type-level-literals&quot;&gt;タイプレベルリテラル&lt;/a&gt;のレコードアクセスの例の拡張は、オーバーロードされたラベルをレコードセレクターとして使用する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="784d5081f398d0ca7b17da03a0bb36a22a2ccb4a" translate="yes" xml:space="preserve">
          <source>Here is what this example does:</source>
          <target state="translated">この例では、このようなことをしています。</target>
        </trans-unit>
        <trans-unit id="578112844f2ecfeb7d7b37c0671697fae621d8a3" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;Eq [a]&lt;/code&gt; in the signature overlaps with the top-level instance for &lt;code&gt;Eq [a]&lt;/code&gt;. GHC goes to some efforts to use the former, but if it should use the latter, it would then have an insoluble &lt;code&gt;Eq a&lt;/code&gt; constraint. Best avoided by instead writing:</source>
          <target state="translated">ここで &lt;code&gt;Eq [a]&lt;/code&gt; の最上位インスタンスと署名重複に &lt;code&gt;Eq [a]&lt;/code&gt; 。GHCは前者を使用するためにいくつかの努力をしますが、後者を使用する必要がある場合、それは不溶性の &lt;code&gt;Eq a&lt;/code&gt; 制約を持ちます。代わりに次のように書くことで回避するのが最善です。</target>
        </trans-unit>
        <trans-unit id="c371834414978339130daf2ead6f2a828c5e1113" translate="yes" xml:space="preserve">
          <source>Here the call to &lt;code&gt;(==)&lt;/code&gt; makes GHC think that the &lt;code&gt;(Eq a)&lt;/code&gt; constraint is needed, so no warning is issued.</source>
          <target state="translated">ここで &lt;code&gt;(==)&lt;/code&gt; を呼び出すと、GHCは &lt;code&gt;(Eq a)&lt;/code&gt; 制約が必要であると判断し、警告は発行されません。</target>
        </trans-unit>
        <trans-unit id="0780d7d3b68e7e37a7a3d46a9b887e1652449c4c" translate="yes" xml:space="preserve">
          <source>Here the definition of &lt;code&gt;id&lt;/code&gt; will be rejected because type variable &lt;code&gt;t&lt;/code&gt; appears only under type family applications and is thus ambiguous. But this code will be accepted if we tell GHC that &lt;code&gt;Id&lt;/code&gt; is injective, which means it will be possible to infer &lt;code&gt;t&lt;/code&gt; at call sites from the type of the argument:</source>
          <target state="translated">ここでは、タイプ変数 &lt;code&gt;t&lt;/code&gt; がタイプファミリーアプリケーションの下にのみ表示され、あいまいであるため、 &lt;code&gt;id&lt;/code&gt; の定義は拒否されます。しかし、 &lt;code&gt;Id&lt;/code&gt; が単射であることをGHCに伝えれば、このコードは受け入れられます。つまり、引数のタイプから呼び出しサイトで &lt;code&gt;t&lt;/code&gt; を推測することが可能になります。</target>
        </trans-unit>
        <trans-unit id="eb28975e9efa83a5c3e0e5ff9c5c0721160939d1" translate="yes" xml:space="preserve">
          <source>Here the signature in the instance declaration is more polymorphic than that required by the instantiated class method.</source>
          <target state="translated">ここでは、インスタンス宣言のシグネチャは、インスタンス化されたクラス・メソッドで必要とされるシグネチャよりも多相性が高いです。</target>
        </trans-unit>
        <trans-unit id="a63289520236e8e709917ef260fdeb154c06ebad" translate="yes" xml:space="preserve">
          <source>Here the superclass cycle does terminate but it&amp;rsquo;s not entirely straightforward to see that it does.</source>
          <target state="translated">ここでスーパークラスサイクルは終了しますが、終了することを確認することは完全に簡単ではありません。</target>
        </trans-unit>
        <trans-unit id="4b4dc560bdf4032142e8540022e116649150a8cf" translate="yes" xml:space="preserve">
          <source>Here the type signature on the expression can be pushed inwards to give a type signature for f. Similarly, and more commonly, one can give a type signature for the function itself:</source>
          <target state="translated">ここでは、式の型署名を内側に押し込んで、fの型署名を与えることができます。同様に、より一般的には、関数自体の型署名を与えることができます。</target>
        </trans-unit>
        <trans-unit id="b36ee31bac07794278327e4cd5b5ef2a73c1d649" translate="yes" xml:space="preserve">
          <source>Here the type variable &lt;code&gt;a&lt;/code&gt; does not appear in the result type of either constructor. Although it is universally quantified in the type of the constructor, such a type variable is often called &amp;ldquo;existential&amp;rdquo;. Indeed, the above declaration declares precisely the same type as the &lt;code&gt;data Foo&lt;/code&gt; in &lt;a href=&quot;#existential-quantification&quot;&gt;Existentially quantified data constructors&lt;/a&gt;.</source>
          <target state="translated">ここで、型変数 &lt;code&gt;a&lt;/code&gt; はどちらのコンストラクタの結果型にも現れません。それはコンストラクタの型で普遍的に数量化されますが、そのような型変数はしばしば「存在」と呼ばれます。実際、上記の宣言は、&lt;a href=&quot;#existential-quantification&quot;&gt;実存的に定量化されたデータコンストラクターの&lt;/a&gt; &lt;code&gt;data Foo&lt;/code&gt; とまったく同じ型を宣言しています。</target>
        </trans-unit>
        <trans-unit id="7055c1ade07b4400baffd8a9bc31bf6ec6a1358e" translate="yes" xml:space="preserve">
          <source>Here the universal type variable &lt;code&gt;a&lt;/code&gt; scopes over the definition of &lt;code&gt;P&lt;/code&gt;, but the existential &lt;code&gt;b&lt;/code&gt; does not. (c.f. discussion on #14998.)</source>
          <target state="translated">ここで、ユニバーサル型変数 &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;P&lt;/code&gt; の定義を対象としていますが、実存的 &lt;code&gt;b&lt;/code&gt; は対象外です。（＃14998の議論を参照。）</target>
        </trans-unit>
        <trans-unit id="871671537306449b461ce4b0a7359a84ae8901b9" translate="yes" xml:space="preserve">
          <source>Here the universal type variable &lt;code&gt;a&lt;/code&gt; scopes over the definition of &lt;code&gt;P&lt;/code&gt;, but the existential &lt;code&gt;b&lt;/code&gt; does not. (c.f. discussion on Trac #14998.)</source>
          <target state="translated">ここで、汎用型変数 &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;P&lt;/code&gt; の定義にスコープしますが、存在 &lt;code&gt;b&lt;/code&gt; はスコープしません。（Trac＃14998に関する議論を参照してください。）</target>
        </trans-unit>
        <trans-unit id="2389ab12d149719f8b2ae9fd37c6e9f5221e6a85" translate="yes" xml:space="preserve">
          <source>Here we cannot derive the instance</source>
          <target state="translated">ここでは、インスタンス</target>
        </trans-unit>
        <trans-unit id="62ae36999c62764581c349a16fd30283eb606e25" translate="yes" xml:space="preserve">
          <source>Here we do not need to give a type signature to &lt;code&gt;w&lt;/code&gt;, because it is an argument of constructor &lt;code&gt;T1&lt;/code&gt; and that tells GHC all it needs to know.</source>
          <target state="translated">ここでは &lt;code&gt;w&lt;/code&gt; に型シグネチャを与える必要はありません。これはコンストラクター &lt;code&gt;T1&lt;/code&gt; の引数であり、GHCに知る必要があるすべてのことを伝えるためです。</target>
        </trans-unit>
        <trans-unit id="ec7e465fc20c2c4537d95dc677ec8ee61bfb8cc2" translate="yes" xml:space="preserve">
          <source>Here we give two data instance declarations, one in which the last parameter is &lt;code&gt;[v]&lt;/code&gt;, and one for which it is &lt;code&gt;Int&lt;/code&gt;. Since you cannot give any &lt;em&gt;subsequent&lt;/em&gt; instances for &lt;code&gt;(GMap Flob ...)&lt;/code&gt;, this facility is most useful when the free indexed parameter is of a kind with a finite number of alternatives (unlike &lt;code&gt;Type&lt;/code&gt;).</source>
          <target state="translated">ここでは、2つのデータインスタンス宣言を示しています。1つは最後のパラメーターが &lt;code&gt;[v]&lt;/code&gt; で、もう1つは &lt;code&gt;Int&lt;/code&gt; です。 &lt;code&gt;(GMap Flob ...)&lt;/code&gt; の&lt;em&gt;後続の&lt;/em&gt;インスタンスを与えることはできないため、この機能は、空きインデックス付きパラメーターが（ &lt;code&gt;Type&lt;/code&gt; とは異なり）有限数の選択肢を持つ種類である場合に最も役立ちます。</target>
        </trans-unit>
        <trans-unit id="3bb8ea8d6762e5ffea3bc702011bc02d989b8554" translate="yes" xml:space="preserve">
          <source>Here we have used the runtime system&amp;rsquo;s &lt;code&gt;-V0&lt;/code&gt; option to disable the RTS&amp;rsquo;s periodic timer which may interfere with our debugging session. Upon breaking into the program &lt;code&gt;gdb&lt;/code&gt; shows us a location in our source program corresponding to the current point of execution.</source>
          <target state="translated">ここでは、ランタイムシステムの &lt;code&gt;-V0&lt;/code&gt; オプションを使用して、デバッグセッションに干渉する可能性のあるRTSの定期タイマーを無効にしています。プログラムに侵入すると、 &lt;code&gt;gdb&lt;/code&gt; は、現在の実行ポイントに対応するソースプログラム内の場所を示します。</target>
        </trans-unit>
        <trans-unit id="a3afdf03ab0d6bca83111ae2999d98d94e34ee27" translate="yes" xml:space="preserve">
          <source>Here we make use of the &lt;code&gt;Monoid ((-&amp;gt;) a)&lt;/code&gt; instance.</source>
          <target state="translated">ここでは、 &lt;code&gt;Monoid ((-&amp;gt;) a)&lt;/code&gt; インスタンスを使用します。</target>
        </trans-unit>
        <trans-unit id="1a886cd62bbad757f26446c67a18256a063af6b3" translate="yes" xml:space="preserve">
          <source>Here we notice the first bit of the stack trace has many unidentified stack frames at address &lt;code&gt;0x006eb0c0&lt;/code&gt;. If we ask &lt;code&gt;gdb&lt;/code&gt; about this location, we find that these frames are actually STG update closures,</source>
          <target state="translated">ここで、スタックトレースの最初のビットに、アドレス &lt;code&gt;0x006eb0c0&lt;/code&gt; にある不明なスタックフレームが多数あることがわかります。この場所について &lt;code&gt;gdb&lt;/code&gt; に尋ねると、これらのフレームは実際にはSTG更新クロージャであることがわかります。</target>
        </trans-unit>
        <trans-unit id="488b44824899a32a3b4c8c755fe86357e03b142e" translate="yes" xml:space="preserve">
          <source>Here we use &lt;code&gt;calculateLength&lt;/code&gt; by making it to pass its result to &lt;code&gt;print&lt;/code&gt;:</source>
          <target state="translated">ここでは、 &lt;code&gt;calculateLength&lt;/code&gt; を使用して、結果を &lt;code&gt;print&lt;/code&gt; に渡します。</target>
        </trans-unit>
        <trans-unit id="05ec54bf728aec9e4101e212b40848364c009d88" translate="yes" xml:space="preserve">
          <source>Here we use a &lt;a href=&quot;#class-default-signatures&quot;&gt;default signature&lt;/a&gt; to specify that the user does not have to provide an implementation for &lt;code&gt;put&lt;/code&gt;, as long as there is a &lt;code&gt;Generic&lt;/code&gt; instance for the type to instantiate. For the &lt;code&gt;UserTree&lt;/code&gt; type, for instance, the user can just write:</source>
          <target state="translated">ここでは、&lt;a href=&quot;#class-default-signatures&quot;&gt;デフォルトの署名&lt;/a&gt;を使用して、インスタンス化する型の &lt;code&gt;Generic&lt;/code&gt; インスタンスがある限り、ユーザーが &lt;code&gt;put&lt;/code&gt; の実装を提供する必要がないことを指定します。たとえば、 &lt;code&gt;UserTree&lt;/code&gt; タイプの場合、ユーザーは次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="bbee547f7180c83e7a6749bef178b8c2b89e5ea0" translate="yes" xml:space="preserve">
          <source>Here we used the &lt;code&gt;-g&lt;/code&gt; option to inform GHC that it should add debugging information in the produced binary. There are three levels of debugging output: &lt;code&gt;-g0&lt;/code&gt; (no debugging information, the default), &lt;code&gt;-g1&lt;/code&gt; (sufficient for basic backtraces), &lt;code&gt;-g2&lt;/code&gt; (or just &lt;code&gt;-g&lt;/code&gt; for short; emitting everything GHC knows). Note that this debugging information does not affect the optimizations performed by GHC.</source>
          <target state="translated">ここでは、生成されたバイナリにデバッグ情報を追加する必要があることをGHCに通知するために &lt;code&gt;-g&lt;/code&gt; オプションを使用しました。デバッグ出力には3つのレベルがあります。 &lt;code&gt;-g0&lt;/code&gt; （デバッグ情報なし、デフォルト）、- &lt;code&gt;-g1&lt;/code&gt; （基本的なバックトレースには十分）、- &lt;code&gt;-g2&lt;/code&gt; （または単に &lt;code&gt;-g&lt;/code&gt; だけ、GHCが知っているすべてを出力）。このデバッグ情報は、GHCによって実行される最適化には影響しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="01e42929be7de1f61c123076ae26c4541b6debae" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a command that takes an argument. It&amp;rsquo;s a re-implementation of &lt;a href=&quot;#ghci-cmd-:cd&quot;&gt;&lt;code&gt;:cd&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">引数を取るコマンドの例を次に示します。&lt;a href=&quot;#ghci-cmd-:cd&quot;&gt; &lt;code&gt;:cd&lt;/code&gt; の&lt;/a&gt;再実装です：</target>
        </trans-unit>
        <trans-unit id="4acf1f68d1ec65b2583dd0678b0010301a2d55c6" translate="yes" xml:space="preserve">
          <source>Here's a rule of thumb for deciding which catch-style function to use:</source>
          <target state="translated">ここでは、どのキャッチスタイルの機能を使うかを決めるための経験則をご紹介します。</target>
        </trans-unit>
        <trans-unit id="95a4a684360c29ba16a972e43ea2e7da727acaed" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(!:)&lt;/code&gt; is a recursive function that indexes arrays of type &lt;code&gt;Arr e&lt;/code&gt;. Consider a call to &lt;code&gt;(!:)&lt;/code&gt; at type &lt;code&gt;(Int,Int)&lt;/code&gt;. The second specialisation will fire, and the specialised function will be inlined. It has two calls to &lt;code&gt;(!:)&lt;/code&gt;, both at type &lt;code&gt;Int&lt;/code&gt;. Both these calls fire the first specialisation, whose body is also inlined. The result is a type-based unrolling of the indexing function.</source>
          <target state="translated">ここで、 &lt;code&gt;(!:)&lt;/code&gt; はタイプ &lt;code&gt;Arr e&lt;/code&gt; の配列にインデックスを付ける再帰関数です。タイプ &lt;code&gt;(Int,Int)&lt;/code&gt; での &lt;code&gt;(!:)&lt;/code&gt; の呼び出しを考えます。 2番目の特殊化が実行され、特殊化された関数がインライン化されます。 &lt;code&gt;(!:)&lt;/code&gt; への2つの呼び出しがあり、どちらも &lt;code&gt;Int&lt;/code&gt; 型です。これらの呼び出しは両方とも、本体もインライン化された最初のスペシャライゼーションを起動します。結果は、型に基づいたインデックス関数の展開です。</target>
        </trans-unit>
        <trans-unit id="2d758383a9a92043fe5183bea22cf4899f5af4a1" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(MkFoo 3 even)&lt;/code&gt; packages an integer with a function &lt;code&gt;even&lt;/code&gt; that maps an integer to &lt;code&gt;Bool&lt;/code&gt;; and &lt;code&gt;MkFoo 'c'
isUpper&lt;/code&gt; packages a character with a compatible function. These two things are each of type &lt;code&gt;Foo&lt;/code&gt; and can be put in a list.</source>
          <target state="translated">ここで、 &lt;code&gt;(MkFoo 3 even)&lt;/code&gt; は、整数を &lt;code&gt;Bool&lt;/code&gt; にマップする関数 &lt;code&gt;even&lt;/code&gt; で整数をパッケージ化します。そして &lt;code&gt;MkFoo 'c' isUpper&lt;/code&gt; 互換性のある機能を持つキャラクターをパッケージ化します。これら2つはそれぞれ &lt;code&gt;Foo&lt;/code&gt; タイプであり、リストに入れることができます。</target>
        </trans-unit>
        <trans-unit id="5517fa5111843903c7c77f59041df2d9a2ca820f" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:R&quot;&gt;R&lt;/a&gt;&lt;/code&gt; is a type-level proxy that does not have any associated values.</source>
          <target state="translated">ここで、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:R&quot;&gt;R&lt;/a&gt;&lt;/code&gt; は値が関連付けられていないタイプレベルのプロキシです。</target>
        </trans-unit>
        <trans-unit id="8f15a44a2381b42f996544079219567c930d6553" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Adder&lt;/code&gt; is the name of the root module in the module tree (as mentioned above, there must be a single root module, and hence a single module tree in the DLL). Compile everything up:</source>
          <target state="translated">ここで、 &lt;code&gt;Adder&lt;/code&gt; はモジュールツリー内のルートモジュールの名前です（上記のように、単一のルートモジュールが存在する必要があるため、DLLには単一のモジュールツリーが必要です）。すべてをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="b53104e9ecb02cbdb4ecf1e67b8e325444d3f1eb" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;C&lt;/code&gt; is a superclass of &lt;code&gt;D&lt;/code&gt;, but it&amp;rsquo;s OK for a class operation &lt;code&gt;op&lt;/code&gt; of &lt;code&gt;C&lt;/code&gt; to mention &lt;code&gt;D&lt;/code&gt;. (It would not be OK for &lt;code&gt;D&lt;/code&gt; to be a superclass of &lt;code&gt;C&lt;/code&gt;.)</source>
          <target state="translated">ここで、 &lt;code&gt;C&lt;/code&gt; はのスーパークラスである &lt;code&gt;D&lt;/code&gt; が、それは、クラスの操作のためにOKです &lt;code&gt;op&lt;/code&gt; の &lt;code&gt;C&lt;/code&gt; に言及する &lt;code&gt;D&lt;/code&gt; を。（ &lt;code&gt;D&lt;/code&gt; が &lt;code&gt;C&lt;/code&gt; のスーパークラスであっても問題ありません。）</target>
        </trans-unit>
        <trans-unit id="525ca7533aa751d8d94cbfeb12f8015edba62f9e" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;a&lt;/code&gt; is imported, and &lt;code&gt;c&lt;/code&gt; is bound at top level, so neither contribute to the expansion of the &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo;. The motivation here is that it should be easy for the reader to figure out what the &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo; expands to.</source>
          <target state="translated">ここでは、 &lt;code&gt;a&lt;/code&gt; がインポートされ、 &lt;code&gt;c&lt;/code&gt; が最上位にバインドされているため、「 &lt;code&gt;..&lt;/code&gt; 」の拡張には寄与しません。ここでの動機は、「 &lt;code&gt;..&lt;/code&gt; 」が何に展開されるかを読者が簡単に理解できるようにすることです。</target>
        </trans-unit>
        <trans-unit id="822db033e370efbb31959c405529a4c4c05b2667" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;g1&lt;/code&gt; are rank-1 types, and can be written in standard Haskell (e.g. &lt;code&gt;f1 :: a-&amp;gt;b-&amp;gt;a&lt;/code&gt;). The &lt;code&gt;forall&lt;/code&gt; makes explicit the universal quantification that is implicitly added by Haskell.</source>
          <target state="translated">ここで、 &lt;code&gt;f1&lt;/code&gt; と &lt;code&gt;g1&lt;/code&gt; はランク1の型であり、標準のHaskellで記述できます（例： &lt;code&gt;f1 :: a-&amp;gt;b-&amp;gt;a&lt;/code&gt; ）。 &lt;code&gt;forall&lt;/code&gt; 暗黙のうちにハスケルによって追加された明示的な普遍的な定量化を行います。</target>
        </trans-unit>
        <trans-unit id="d071a90d49169c0a3e8d456b4967a92a718fd1e4" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;f2&lt;/code&gt; is strict in &lt;code&gt;x&lt;/code&gt; but not in &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;f2&lt;/code&gt; は &lt;code&gt;x&lt;/code&gt; では厳密ですが、 &lt;code&gt;y&lt;/code&gt; では厳密ではありません。</target>
        </trans-unit>
        <trans-unit id="86a370b87ed8c118346ca1a94d53f0f726f6b04d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;f3&lt;/code&gt; and &lt;code&gt;f4&lt;/code&gt; are identical; putting a bang before a pattern that forces evaluation anyway does nothing.</source>
          <target state="translated">ここで、 &lt;code&gt;f3&lt;/code&gt; と &lt;code&gt;f4&lt;/code&gt; は同じです。とにかく評価を強制するパターンの前に強打を置いても何も起こりません。</target>
        </trans-unit>
        <trans-unit id="c65a0ece61fefd2d00d0da0d24e0dfd8498a8191" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;g&lt;/code&gt; has an ambiguous type, and is rejected, but &lt;code&gt;f&lt;/code&gt; is fine. The binding for &lt;code&gt;?x&lt;/code&gt; at &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s call site is quite unambiguous, and fixes the type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">ここでは、 &lt;code&gt;g&lt;/code&gt; にはあいまいな型があり、拒否されますが、 &lt;code&gt;f&lt;/code&gt; は問題ありません。 &lt;code&gt;f&lt;/code&gt; の呼び出しサイトでの &lt;code&gt;?x&lt;/code&gt; のバインディングは非常に明確であり、タイプ &lt;code&gt;a&lt;/code&gt; を修正します。</target>
        </trans-unit>
        <trans-unit id="1bce2925ca8d4f31f00ac8bdae65f0eb431772ec" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;g&lt;/code&gt; has an ambiguous type, and is rejected, but &lt;code&gt;f&lt;/code&gt; is fine. The binding for &lt;code&gt;?x&lt;/code&gt; at &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s call site is quite unambiguous, and fixes the type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;g&lt;/code&gt; はあいまいな型であり、拒否されますが、 &lt;code&gt;f&lt;/code&gt; は問題ありません。 &lt;code&gt;f&lt;/code&gt; の呼び出しサイトでの &lt;code&gt;?x&lt;/code&gt; のバインドは非常に明確であり、タイプ &lt;code&gt;a&lt;/code&gt; を修正します。</target>
        </trans-unit>
        <trans-unit id="18c00320ffe8585a72819af79238d88877a38e42" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;k&lt;/code&gt; is brought into scope by &lt;code&gt;:: Maybe (Maybe k)&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;k&lt;/code&gt; は &lt;code&gt;:: Maybe (Maybe k)&lt;/code&gt; によってスコープに入れられます。</target>
        </trans-unit>
        <trans-unit id="2d9559bc1d51eb924585ebc31815ff13fbf5ec88" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;lookup&lt;/code&gt; is declared &lt;a href=&quot;#pragma-INLINABLE&quot;&gt;&lt;code&gt;INLINABLE&lt;/code&gt;&lt;/a&gt;, but it cannot be specialised for type &lt;code&gt;T&lt;/code&gt; at its definition site, because that type does not exist yet. Instead a client module can define &lt;code&gt;T&lt;/code&gt; and then specialise &lt;code&gt;lookup&lt;/code&gt; at that type.</source>
          <target state="translated">ここでは、 &lt;code&gt;lookup&lt;/code&gt; は&lt;a href=&quot;#pragma-INLINABLE&quot;&gt; &lt;code&gt;INLINABLE&lt;/code&gt; &lt;/a&gt;と宣言されていますが、その定義サイトではタイプ &lt;code&gt;T&lt;/code&gt; に特化できません。そのタイプがまだ存在しないためです。代わりに、クライアントモジュールは &lt;code&gt;T&lt;/code&gt; を定義して、その型での &lt;code&gt;lookup&lt;/code&gt; を専門化できます。</target>
        </trans-unit>
        <trans-unit id="34766b2e0766ed22f1c9cb7f203525612e940b47" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;m x&lt;/code&gt; depends on the value of &lt;code&gt;x&lt;/code&gt; produced by the first statement, so the expression cannot be translated using &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;m x&lt;/code&gt; は最初のステートメントによって生成された &lt;code&gt;x&lt;/code&gt; の値に依存するため、式は &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; を使用して変換できません。</target>
        </trans-unit>
        <trans-unit id="34b4a2ef77ba3c50370d37583f31a5be57b46894" translate="yes" xml:space="preserve">
          <source>Here, a value of type &lt;code&gt;NumInst a&lt;/code&gt; is equivalent to an explicit &lt;code&gt;(Num a)&lt;/code&gt; dictionary.</source>
          <target state="translated">ここで、タイプ &lt;code&gt;NumInst a&lt;/code&gt; aの値は、明示的な &lt;code&gt;(Num a)&lt;/code&gt; 辞書と同等です。</target>
        </trans-unit>
        <trans-unit id="1fb49fc1ba82e874567baa5a0ecc23830d8c61be" translate="yes" xml:space="preserve">
          <source>Here, after GHC inlines the body of &lt;code&gt;foldl&lt;/code&gt; to a call site, it will perform call-pattern specialisation very aggressively on &lt;code&gt;foldl_loop&lt;/code&gt; due to the use of &lt;code&gt;SPEC&lt;/code&gt; in the argument of the loop body. &lt;code&gt;SPEC&lt;/code&gt; from &lt;code&gt;GHC.Types&lt;/code&gt; is specifically recognised by the compiler.</source>
          <target state="translated">GHCは、身体のインライン後にここで、 &lt;code&gt;foldl&lt;/code&gt; のを呼び出し場所に、それは非常に積極的にコールパターン特殊化を実行します &lt;code&gt;foldl_loop&lt;/code&gt; によるの使用に &lt;code&gt;SPEC&lt;/code&gt; ループ本体の引数インチ &lt;code&gt;SPEC&lt;/code&gt; から &lt;code&gt;GHC.Types&lt;/code&gt; は、具体的コンパイラによって認識されています。</target>
        </trans-unit>
        <trans-unit id="16a46da6469aa7d877a4dc019b4026c861a1827c" translate="yes" xml:space="preserve">
          <source>Here, although the right-hand side &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; mentions a kind variable &lt;code&gt;a&lt;/code&gt; which does not occur on the left-hand side, this is acceptable, because &lt;code&gt;a&lt;/code&gt; is &lt;em&gt;implicitly&lt;/em&gt; bound by &lt;code&gt;T&lt;/code&gt;&amp;lsquo;s kind pattern.</source>
          <target state="translated">ここで、右側 &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; は左側では発生しない種類変数 &lt;code&gt;a&lt;/code&gt; について言及していますが、 &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; の種類パターンによって&lt;em&gt;暗黙的に&lt;/em&gt;バインドされているため、これは許容されます。</target>
        </trans-unit>
        <trans-unit id="3f03837283c8b527b9aef380941c96008f2bd16a" translate="yes" xml:space="preserve">
          <source>Here, although the right-hand side &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; mentions a kind variable &lt;code&gt;a&lt;/code&gt; which does not occur on the left-hand side, this is acceptable, because &lt;code&gt;a&lt;/code&gt; is &lt;em&gt;implicitly&lt;/em&gt; bound by &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s kind pattern.</source>
          <target state="translated">ここで、右側 &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; は、左側では発生しない種類変数 &lt;code&gt;a&lt;/code&gt; について言及していますが、 &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; の種類パターンによって&lt;em&gt;暗黙的に&lt;/em&gt;バインドされているため、これは許容されます。</target>
        </trans-unit>
        <trans-unit id="7c488bb6442c8bfe3891b456a0f20d4c493678b2" translate="yes" xml:space="preserve">
          <source>Here, it is evident that attempting to use the type &lt;code&gt;T Loop&lt;/code&gt; will throw the typechecker into an infinite loop, as its definition recurses endlessly. In other cases, you might need to enable &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; even if the generated code won&amp;rsquo;t put the typechecker into a loop. For example:</source>
          <target state="translated">ここでは、 &lt;code&gt;T Loop&lt;/code&gt; 型のループを使用しようとすると、その定義が無限に再帰するため、型チェッカーが無限ループにスローされることは明らかです。他の場合では、生成されたコードが&lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt;ループに入れなくても、UndecidableInstancesを有効にする必要があるかもしれません。例えば：</target>
        </trans-unit>
        <trans-unit id="c5c4e32b86bb284d5a60b6c3cdd6f27f34dd9bca" translate="yes" xml:space="preserve">
          <source>Here, neither &lt;code&gt;D&lt;/code&gt; nor &lt;code&gt;T&lt;/code&gt; is declared in module &lt;code&gt;Orphan&lt;/code&gt;. We call such modules &amp;ldquo;orphan modules&amp;rdquo;. GHC identifies orphan modules, and visits the interface file of every orphan module below the module being compiled. This is usually wasted work, but there is no avoiding it. You should therefore do your best to have as few orphan modules as possible.</source>
          <target state="translated">ここでは、 &lt;code&gt;D&lt;/code&gt; も &lt;code&gt;T&lt;/code&gt; も &lt;code&gt;Orphan&lt;/code&gt; モジュールで宣言されていません。このようなモジュールを「孤立モジュール」と呼びます。GHCは孤立モジュールを識別し、コンパイルされているモジュールの下のすべての孤立モジュールのインターフェースファイルにアクセスします。これは通常無駄な作業ですが、回避することはできません。したがって、孤立したモジュールをできるだけ少なくするように最善を尽くす必要があります。</target>
        </trans-unit>
        <trans-unit id="8e284f329aaa0b1d6c1613a8401892863365a886" translate="yes" xml:space="preserve">
          <source>Here, only &lt;code&gt;b&lt;/code&gt; is levity polymorphic. There are no variables with a levity-polymorphic type. And the code generator has no trouble with this. Indeed, this is the true type of GHC&amp;rsquo;s &lt;code&gt;$&lt;/code&gt; operator, slightly more general than the Haskell 98 version.</source>
          <target state="translated">ここでは、 &lt;code&gt;b&lt;/code&gt; のみがレビティ多態性です。levity-polymorphic型の変数はありません。そしてコードジェネレーターはこれで問題ありません。実際、これはGHCの &lt;code&gt;$&lt;/code&gt; 演算子の真のタイプであり、Haskell 98バージョンよりも少し一般的です。</target>
        </trans-unit>
        <trans-unit id="e4fa6e7e82de32b187a53fa81558ae736ecfa4c2" translate="yes" xml:space="preserve">
          <source>Here, the kind signature is hidden inside &lt;code&gt;'Just&lt;/code&gt;, and there is no outermost kind signature. We can fix this example by providing an outermost kind signature:</source>
          <target state="translated">ここでは、種類の署名は &lt;code&gt;'Just&lt;/code&gt; の内部に隠されており、最も外側の種類の署名はありません。この例は、最も外側の種類の署名を提供することで修正できます。</target>
        </trans-unit>
        <trans-unit id="a6b5d58882f8e59923897d88bfc5d873faefaaa3" translate="yes" xml:space="preserve">
          <source>Here, the pattern signatures for &lt;code&gt;ys&lt;/code&gt; and &lt;code&gt;zs&lt;/code&gt; are fine, but the one for &lt;code&gt;v&lt;/code&gt; is not because &lt;code&gt;b&lt;/code&gt; is not in scope.</source>
          <target state="translated">ここでは、 &lt;code&gt;ys&lt;/code&gt; と &lt;code&gt;zs&lt;/code&gt; のパターンシグネチャは問題ありませんが、 &lt;code&gt;b&lt;/code&gt; はスコープ内にないため、 &lt;code&gt;v&lt;/code&gt; のパターンシグネチャはそうではありません。</target>
        </trans-unit>
        <trans-unit id="f4fd0ff1134c3450c4876a8a1789e7f8711d1446" translate="yes" xml:space="preserve">
          <source>Here, the pattern type signature &lt;code&gt;[t::a]&lt;/code&gt; mentions a lexical type variable that is not already in scope. Indeed, it &lt;em&gt;must not&lt;/em&gt; already be in scope, because it is bound by the pattern match. The effect is to bring it into scope, standing for the existentially-bound type variable.</source>
          <target state="translated">ここで、パターンタイプシグネチャ &lt;code&gt;[t::a]&lt;/code&gt; は、まだスコープ内にないレキシカルタイプ変数について言及しています。実際、パターンマッチによってバインドされているため、スコープに含まれていては&lt;em&gt;なりません&lt;/em&gt;。その効果は、実在的にバインドされた型変数を表す、スコープにそれをもたらすことです。</target>
        </trans-unit>
        <trans-unit id="8bdce5ce5dbc2679c8b93240f55e76cb9b685ca9" translate="yes" xml:space="preserve">
          <source>Here, the quantified constraint &lt;code&gt;forall b. (Eq b) =&amp;gt; Eq (f b)&lt;/code&gt; behaves a bit like a local instance declaration, and makes the instance typeable.</source>
          <target state="translated">ここでは、 &lt;code&gt;forall b. (Eq b) =&amp;gt; Eq (f b)&lt;/code&gt; の定量化された制約です。（Eq b）=&amp;gt; Eq（fb）はローカルインスタンス宣言のように動作し、インスタンスを型指定可能にします。</target>
        </trans-unit>
        <trans-unit id="c090bb2c03f8b4d1d81b664c6c433e2433be0999" translate="yes" xml:space="preserve">
          <source>Here, the right-hand side of the data instance mentions the type variable &lt;code&gt;d&lt;/code&gt; that does not occur in its left-hand side. We cannot admit such data instances as they would compromise type safety.</source>
          <target state="translated">ここで、データインスタンスの右側は、左側では発生しない型変数 &lt;code&gt;d&lt;/code&gt; について言及しています。型の安全性を損なう可能性があるため、そのようなデータインスタンスは認められません。</target>
        </trans-unit>
        <trans-unit id="b4418932eacd33c51523f80d662c6aae5a1a8913" translate="yes" xml:space="preserve">
          <source>Here, the type bound by &lt;code&gt;MkFoo&lt;/code&gt; &amp;ldquo;escapes&amp;rdquo;, because &lt;code&gt;a&lt;/code&gt; is the result of &lt;code&gt;f1&lt;/code&gt;. One way to see why this is wrong is to ask what type &lt;code&gt;f1&lt;/code&gt; has:</source>
          <target state="translated">ここでは、 &lt;code&gt;a&lt;/code&gt; が &lt;code&gt;f1&lt;/code&gt; の結果であるため、 &lt;code&gt;MkFoo&lt;/code&gt; によってバインドされた型は「エスケープ」します。これが間違っている理由を確認する1つの方法は、 &lt;code&gt;f1&lt;/code&gt; のタイプを尋ねることです。</target>
        </trans-unit>
        <trans-unit id="d4ced41f435896f3835e3f3db385a593236b5ec7" translate="yes" xml:space="preserve">
          <source>Here, the type signature &lt;code&gt;forall s. ST s Bool&lt;/code&gt; brings the type variable &lt;code&gt;s&lt;/code&gt; into scope, in the annotated expression &lt;code&gt;(op &amp;gt;&amp;gt;= \(x :: STRef s Int) -&amp;gt; g x)&lt;/code&gt;.</source>
          <target state="translated">ここでは、 &lt;code&gt;forall s. ST s Bool&lt;/code&gt; 型のシグネチャです。ST s Boolは、注釈付き式 &lt;code&gt;(op &amp;gt;&amp;gt;= \(x :: STRef s Int) -&amp;gt; g x)&lt;/code&gt; 型変数 &lt;code&gt;s&lt;/code&gt; をスコープに入れます。</target>
        </trans-unit>
        <trans-unit id="1f4651a64ece58d66fdaa4f04e3c286eafc03da8" translate="yes" xml:space="preserve">
          <source>HexFloatLiterals</source>
          <target state="translated">HexFloatLiterals</target>
        </trans-unit>
        <trans-unit id="11a841be90249e5ae1849d3a9dba8043e7e8343e" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; の 16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="a09789d874bf0321af31ee0c488ee82ce979a4fc" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; の 16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="676e2bd2392778df9648ce9b835686f2ab072c23" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; の 16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="f3393a2a683412902536f7d98b83a3d288d91c93" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; の 16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="accee792a95e9e1c8fe72eb8b06937ee9369fa1e" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; の 16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="2f2e79d74e1610058532c363754e327e415fd68b" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="bd739f1c73011a1d448318bcfa789ba656618089" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; の16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="91d7f9927e5a55d877174d8d404732deead30952" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; の16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="807a40d7e8f0a1f48786149c90e1e7c0cd76acce" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; の16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="b74ea0e4e3ddeac5ecbd3ecbed85a2f70045728a" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; の16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="25ad5ace69a8a8ba3fb3a937ad28617759385a28" translate="yes" xml:space="preserve">
          <source>Hexadecimal numbers</source>
          <target state="translated">十六進数</target>
        </trans-unit>
        <trans-unit id="03b3e0f65de320839723c279978dd47f65d6150a" translate="yes" xml:space="preserve">
          <source>Hidden packages (those for which the &lt;code&gt;exposed&lt;/code&gt; flag is &lt;code&gt;False&lt;/code&gt;) are shown in parentheses in the list of packages.</source>
          <target state="translated">非表示のパッケージ（ &lt;code&gt;exposed&lt;/code&gt; フラグが &lt;code&gt;False&lt;/code&gt; のパッケージ）は、パッケージのリストの括弧内に表示されます。</target>
        </trans-unit>
        <trans-unit id="2c6062001c6bab0163b0a4b2529719b8bde4b508" translate="yes" xml:space="preserve">
          <source>Hide all packages by default</source>
          <target state="translated">デフォルトですべてのパッケージを非表示にする</target>
        </trans-unit>
        <trans-unit id="feef4327e8cde9c994f26b136ddb595802f03d1c" translate="yes" xml:space="preserve">
          <source>Hide all packages for plugins by default</source>
          <target state="translated">デフォルトでプラグインのすべてのパッケージを非表示にする</target>
        </trans-unit>
        <trans-unit id="ec916c3e8ddb513e159b7a5e33949a183f39cac6" translate="yes" xml:space="preserve">
          <source>Hide package ⟨pkg⟩</source>
          <target state="translated">パッケージを隠す ⟨pkg⟩</target>
        </trans-unit>
        <trans-unit id="7bd735044c33670955e5379d6a592895b1193122" translate="yes" xml:space="preserve">
          <source>Highest allowed operator precedence for &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; constructor (answer: 9)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; コンストラクターで許可されている最高の演算子の優先順位（答え：9）</target>
        </trans-unit>
        <trans-unit id="7f2e4337cf1098bf05ffcad5c2206b7483c99a77" translate="yes" xml:space="preserve">
          <source>Highest allowed operator precedence for &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; constructor (answer: 9)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; コンストラクターで許可されている最高の演算子の優先順位（答え：9）</target>
        </trans-unit>
        <trans-unit id="2284d040f5091f510de37a154536196310f9c02d" translate="yes" xml:space="preserve">
          <source>Hint</source>
          <target state="translated">Hint</target>
        </trans-unit>
        <trans-unit id="2d84546cb2321a589250e0442876d448b09183af" translate="yes" xml:space="preserve">
          <source>Historically, &lt;code&gt;&lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; is a safer alternative to the &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; idiom.</source>
          <target state="translated">歴史的には、 &lt;code&gt;&lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; イディオムの安全な代替手段です。</target>
        </trans-unit>
        <trans-unit id="a7e46fa97c09f5c0c83b2e88f3881c7a3e4f4f7c" translate="yes" xml:space="preserve">
          <source>Historically, &lt;code&gt;&lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; is a safer alternative to the &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; idiom.</source>
          <target state="translated">歴史的には、 &lt;code&gt;&lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; イディオムの安全な代替手段です。</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="807422feeeae1e65868373709a1281920ada2d92" translate="yes" xml:space="preserve">
          <source>Holding a &lt;code&gt;Weak ThreadId&lt;/code&gt;, on the other hand, will not prevent the thread from receiving &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions. It is still possible to throw an exception to a &lt;code&gt;Weak ThreadId&lt;/code&gt;, but the caller must use &lt;code&gt;deRefWeak&lt;/code&gt; first to determine whether the thread still exists.</source>
          <target state="translated">一方、 &lt;code&gt;Weak ThreadId&lt;/code&gt; 保持しても、スレッドが &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 例外を受信することは妨げられません。それでも &lt;code&gt;Weak ThreadId&lt;/code&gt; に例外をスローすることは可能ですが、呼び出し側はまず &lt;code&gt;deRefWeak&lt;/code&gt; を使用して、スレッドがまだ存在するかどうかを判断する必要があります。</target>
        </trans-unit>
        <trans-unit id="3a0d96a8a98d1e4dce5ef0782487ab394c743475" translate="yes" xml:space="preserve">
          <source>Hole-fit plugins are plugins that are called when a typed-hole error message is being generated, and allows you to access information about the typed-hole at compile time, and allows you to customize valid hole fit suggestions.</source>
          <target state="translated">Hole-fitプラグインは、タイプされた穴のエラーメッセージが生成されているときに呼び出されるプラグインで、コンパイル時にタイプされた穴に関する情報にアクセスすることができ、有効な穴フィットの提案をカスタマイズすることができます。</target>
        </trans-unit>
        <trans-unit id="d098c08c4ae6f34d5c4821e087cb66e14f878118" translate="yes" xml:space="preserve">
          <source>Home directory (pw_dir)</source>
          <target state="translated">ホームディレクトリ (pw_dir)</target>
        </trans-unit>
        <trans-unit id="aca79641b581fd367113ced98f70f47d0abeb2c8" translate="yes" xml:space="preserve">
          <source>Homomorphism</source>
          <target state="translated">Homomorphism</target>
        </trans-unit>
        <trans-unit id="78abe60fa7d802d62efa64043a705bae7407a631" translate="yes" xml:space="preserve">
          <source>Host-endian, unaligned decoding</source>
          <target state="translated">ホストエンディアン、非整列デコーディング</target>
        </trans-unit>
        <trans-unit id="c639806398d26813e0fb48c1ebdba5cd82bf177b" translate="yes" xml:space="preserve">
          <source>Host-endian, unaligned writes</source>
          <target state="translated">ホストエンディアン、アラインメントされていない書き込み</target>
        </trans-unit>
        <trans-unit id="72a0f916e4e9bfcfeeae189f694538c5874f3603" translate="yes" xml:space="preserve">
          <source>Host-specific binary encodings</source>
          <target state="translated">ホスト固有のバイナリエンコーディング</target>
        </trans-unit>
        <trans-unit id="6c7fcd531348b3bb6fd008f425ab3f45a52aad77" translate="yes" xml:space="preserve">
          <source>HotLink</source>
          <target state="translated">HotLink</target>
        </trans-unit>
        <trans-unit id="f9cb8d909445ac44cd2fd5ac585df15ae8f92ebf" translate="yes" xml:space="preserve">
          <source>Hotlinks</source>
          <target state="translated">Hotlinks</target>
        </trans-unit>
        <trans-unit id="24af6649766c375876b6b100497556d3aa591028" translate="yes" xml:space="preserve">
          <source>Hour twelve</source>
          <target state="translated">12時間目</target>
        </trans-unit>
        <trans-unit id="08b758819da040d3f055ca34119b72fa2b2d6747" translate="yes" xml:space="preserve">
          <source>Hour zero</source>
          <target state="translated">時間ゼロ</target>
        </trans-unit>
        <trans-unit id="e21e7b28bb4ec8bce45d51234ba921345ac168b2" translate="yes" xml:space="preserve">
          <source>How does the heap residency reported by the heap profiler relate to the actual memory residency of your program when you run it? You might see a large discrepancy between the residency reported by the heap profiler, and the residency reported by tools on your system (eg. &lt;code&gt;ps&lt;/code&gt; or &lt;code&gt;top&lt;/code&gt; on Unix, or the Task Manager on Windows). There are several reasons for this:</source>
          <target state="translated">ヒーププロファイラーによって報告されたヒープ常駐は、プログラムを実行したときのプログラムの実際のメモリ常駐とどのように関連していますか？ヒーププロファイラによって報告された常駐と、システムのツールによって報告された常駐（たとえば、UNIXでは &lt;code&gt;ps&lt;/code&gt; または &lt;code&gt;top&lt;/code&gt; 、Windowsではタスクマネージャ）の間に大きな不一致が見られる場合があります。これにはいくつかの理由があります。</target>
        </trans-unit>
        <trans-unit id="1927f75bb049c830748f2729f0038bde12efc0c1" translate="yes" xml:space="preserve">
          <source>How eager should the compiler be to inline dictionaries?</source>
          <target state="translated">コンパイラはどれだけインライン辞書に熱心になればいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="e0a1c6fc2034630838e97a64d94b3af46c9319cd" translate="yes" xml:space="preserve">
          <source>How eager should the compiler be to inline functions?</source>
          <target state="translated">コンパイラはどれだけインライン関数に熱心になればいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="a4fb79d40430db562ab3ac45f29bc78e66d5fe1c" translate="yes" xml:space="preserve">
          <source>How long the program has been running (CPU time and elapsed wall clock time).</source>
          <target state="translated">プログラムの実行時間(CPU時間と経過したウォールクロック時間)。</target>
        </trans-unit>
        <trans-unit id="917d1059c1e62cf270bb88e3227c70dfbd432932" translate="yes" xml:space="preserve">
          <source>How long this garbage collection took (CPU time and elapsed wall clock time).</source>
          <target state="translated">このゴミ収集にかかった時間(CPU時間と経過した壁のクロック時間)。</target>
        </trans-unit>
        <trans-unit id="36c6b03bfc8f9cb787a541e4b6548f8ac93d5025" translate="yes" xml:space="preserve">
          <source>How many bytes are currently live.</source>
          <target state="translated">現在何バイトが生きているか。</target>
        </trans-unit>
        <trans-unit id="01af7076602466fb2dd0d00c85e7ba87a68dda6f" translate="yes" xml:space="preserve">
          <source>How many bytes did the program allocate while inside of this cost-centre? This does not include allocations while in child cost-centres.</source>
          <target state="translated">このコスト・センター内でプログラムは何バイトを割り当てましたか?これには、子コストセンター内での割り当ては含まれていません。</target>
        </trans-unit>
        <trans-unit id="b7ee2b37aca604bce9e3efa4a6ecb13d165e0be0" translate="yes" xml:space="preserve">
          <source>How many bytes to read</source>
          <target state="translated">読み出すバイト数</target>
        </trans-unit>
        <trans-unit id="4ce115a90f4bba549deae5cc5d88db46fb3644d7" translate="yes" xml:space="preserve">
          <source>How many bytes we allocated this garbage collection.</source>
          <target state="translated">このガベージコレクションに何バイト割り当てたか。</target>
        </trans-unit>
        <trans-unit id="8b589f57e5f67f3a65c8a115f4df2b5dfeb110e4" translate="yes" xml:space="preserve">
          <source>How many bytes we copied this garbage collection.</source>
          <target state="translated">このガベージコレクションを何バイトコピーしたか</target>
        </trans-unit>
        <trans-unit id="ff3e1b1a1b256a5e6dd2b8ae3a5665856b88bb55" translate="yes" xml:space="preserve">
          <source>How many capabilities the program was started with (e.g. using the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option). Note that the number of capabilities may change during execution due to the &lt;code&gt;setNumCapabilities&lt;/code&gt; function.</source>
          <target state="translated">プログラムが開始された機能の数（たとえば、 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; オプションを使用）。機能の数は、 &lt;code&gt;setNumCapabilities&lt;/code&gt; 関数が原因で、実行中に変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="dd9b9ae41e95b919cfc203a74328458cee852026" translate="yes" xml:space="preserve">
          <source>How many page faults occurred since the end of the last garbage collection.</source>
          <target state="translated">最後のガベージコレクションの終了後、何件のページフォルトが発生したか。</target>
        </trans-unit>
        <trans-unit id="7e0ec711a7a2aca8bf80c57d5b99771cc152f07c" translate="yes" xml:space="preserve">
          <source>How many page faults occurred this garbage collection.</source>
          <target state="translated">このガベージコレクションで発生したページフォルトの数。</target>
        </trans-unit>
        <trans-unit id="ee49e11e7b07eb02b05621505c38a7360c70468d" translate="yes" xml:space="preserve">
          <source>How many profiler &amp;ldquo;ticks&amp;rdquo; elapsed over the course of the program&amp;rsquo;s execution.</source>
          <target state="translated">プログラムの実行中に経過したプロファイラーの「ティック」の数。</target>
        </trans-unit>
        <trans-unit id="9d0f356fd0d39a80e2dc0473264e53a3f5be1255" translate="yes" xml:space="preserve">
          <source>How many stack frames in the given &lt;code&gt;&lt;a href=&quot;ghc-executionstack-internal#t:StackTrace&quot;&gt;StackTrace&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">指定された &lt;code&gt;&lt;a href=&quot;ghc-executionstack-internal#t:StackTrace&quot;&gt;StackTrace&lt;/a&gt;&lt;/code&gt; 内のスタックフレームの数</target>
        </trans-unit>
        <trans-unit id="4ff13443abfdd5f6196035361c4d9c8b1b84e9e8" translate="yes" xml:space="preserve">
          <source>How many ticks was the program&amp;rsquo;s execution inside of this cost-centre? This does not include child cost-centres.</source>
          <target state="translated">このコストセンター内でのプログラムの実行は何ティックですか。これには、児童経費は含まれません。</target>
        </trans-unit>
        <trans-unit id="ab8938746f1911b57d597b21fb5c265320965f8d" translate="yes" xml:space="preserve">
          <source>How many times was this cost-centre entered?</source>
          <target state="translated">このコストセンターは何回目に入ったのでしょうか?</target>
        </trans-unit>
        <trans-unit id="6758180b138745f6df61fe36255468b563201977" translate="yes" xml:space="preserve">
          <source>How much time between profiler ticks.</source>
          <target state="translated">プロファイラーの刻みの間の時間。</target>
        </trans-unit>
        <trans-unit id="fc67db788a397c6ce747c2f5326f08e707314b58" translate="yes" xml:space="preserve">
          <source>How to determine stderr</source>
          <target state="translated">標準エラーの判定方法</target>
        </trans-unit>
        <trans-unit id="6dec927eb4441c4b466135f3fe2523a9b41513ff" translate="yes" xml:space="preserve">
          <source>How to determine stdin</source>
          <target state="translated">標準入力を決定する方法</target>
        </trans-unit>
        <trans-unit id="83c69a711aceee10fc43cfaec8ddc771d114f1fc" translate="yes" xml:space="preserve">
          <source>How to determine stdout</source>
          <target state="translated">標準出力の決定方法</target>
        </trans-unit>
        <trans-unit id="12e3b28c9f66467f3782a09db7380eb03a095bea" translate="yes" xml:space="preserve">
          <source>How to handle the sign of a numeric field. These are mutually exclusive, with &lt;code&gt;&lt;a href=&quot;text-printf#v:SignPlus&quot;&gt;SignPlus&lt;/a&gt;&lt;/code&gt; taking precedence.</source>
          <target state="translated">数値フィールドの符号を処理する方法。これらは相互に排他的であり、 &lt;code&gt;&lt;a href=&quot;text-printf#v:SignPlus&quot;&gt;SignPlus&lt;/a&gt;&lt;/code&gt; が優先されます。</target>
        </trans-unit>
        <trans-unit id="b5d91c4a03978824020eb2d8b5470646f57802ab" translate="yes" xml:space="preserve">
          <source>However if you use &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt;, then GHC instead uses whatever is in scope with the names of &lt;code&gt;toList&lt;/code&gt;, &lt;code&gt;fromList&lt;/code&gt; and &lt;code&gt;fromListN&lt;/code&gt;. That is, these functions are rebindable; c.f. &lt;a href=&quot;#rebindable-syntax&quot;&gt;Rebindable syntax and the implicit Prelude import&lt;/a&gt;.</source>
          <target state="translated">ただし、&lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt;を使用する場合、GHCは &lt;code&gt;toList&lt;/code&gt; 、 &lt;code&gt;fromList&lt;/code&gt; 、 &lt;code&gt;fromListN&lt;/code&gt; の名前を持つスコープ内のものを代わりに使用します。つまり、これらの関数は再バインド可能です。cf &lt;a href=&quot;#rebindable-syntax&quot;&gt;Rebindable構文と暗黙のPreludeインポート&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6040c9b47e1b3417452306269aaf1ff946d1bdd0" translate="yes" xml:space="preserve">
          <source>However see &lt;a href=&quot;ghci#ghci-decls&quot;&gt;Type, class and other declarations&lt;/a&gt; for the overlap rules in GHCi.</source>
          <target state="translated">ただし、GHCiの重複ルールについては、&lt;a href=&quot;ghci#ghci-decls&quot;&gt;タイプ、クラス、およびその他の宣言&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="27d3f3db18b261148fadac31985fc664c11dd948" translate="yes" xml:space="preserve">
          <source>However take care that the generated definitions are still in the input of &lt;code&gt;typeCheckResultAction&lt;/code&gt;. If your don&amp;rsquo;t take care to filter the typechecked input, the behavior of your tool might be inconsistent.</source>
          <target state="translated">ただし、生成された定義が &lt;code&gt;typeCheckResultAction&lt;/code&gt; の入力に含まれていることに注意してください。タイプチェックされた入力のフィルタリングに注意を払わないと、ツールの動作に一貫性がなくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="d170d05fd2a443fae748aa5bc3ef7be0adca547e" translate="yes" xml:space="preserve">
          <source>However the monad &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; is not:</source>
          <target state="translated">ただし、モナド &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; は次のとおりではありません。</target>
        </trans-unit>
        <trans-unit id="75d85dddd307adff786f4e64b0c8bb94a7e37fed" translate="yes" xml:space="preserve">
          <source>However the monad &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; is not:</source>
          <target state="translated">ただし、モナド &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; は次のとおりではありません。</target>
        </trans-unit>
        <trans-unit id="fc54057c2f535150522eb952fec80397f100d689" translate="yes" xml:space="preserve">
          <source>However using Debug.Trace.trace is alright because it uses Windows debugging output support rather than &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;stderr&lt;/code&gt; ではなくWindowsデバッグ出力サポートを使用するため、Debug.Trace.traceを使用しても問題ありません。</target>
        </trans-unit>
        <trans-unit id="f8025ea24ecfecdd0f3e045637833ba460a0d7ea" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; creates a &lt;em&gt;bound&lt;/em&gt; thread, which is necessary if you need to call foreign (non-Haskell) libraries that make use of thread-local state, such as OpenGL (see &lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt;).</source>
          <target state="translated">ただし、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; は&lt;em&gt;バインドされた&lt;/em&gt;スレッドを作成します。これは、OpenGLなどのスレッドローカル状態を利用する外部（非Haskell）ライブラリを呼び出す必要がある場合に必要です（&lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrentを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="e98e07fdef4dfe8b0cb3689c59c1f96f6cc38a2e" translate="yes" xml:space="preserve">
          <source>However, &lt;em&gt;nested&lt;/em&gt; bangs in a let/where pattern binding behave uniformly with all other forms of pattern matching. For example</source>
          <target state="translated">ただし、let / whereパターンバインディングの&lt;em&gt;ネストされた&lt;/em&gt;前髪は、他のすべてのパターンマッチングと同じように動作します。例えば</target>
        </trans-unit>
        <trans-unit id="e5f527eafccf9b322040b38f8d30b103c69e2e35" translate="yes" xml:space="preserve">
          <source>However, apart from these restrictions, many things are allowed, including expressions which are not fully evaluated! Annotation expressions will be evaluated by the compiler just like Template Haskell splices are. So, this annotation is fine:</source>
          <target state="translated">しかし、これらの制限とは別に、完全に評価されない式を含む多くのことが許可されています! アノテーション式は、テンプレートHaskellのスプライスがそうであるように、コンパイラによって評価されます。なので、このアノテーションは問題ありません。</target>
        </trans-unit>
        <trans-unit id="8194ed59efdaf1498fbfe96f3c1af7f347e02a51" translate="yes" xml:space="preserve">
          <source>However, because GHC must &lt;em&gt;infer&lt;/em&gt; the type when part of a type is left out, it is unable to use polymorphic recursion. The same restriction takes place when the type signature is omitted completely.</source>
          <target state="translated">ただし、GHC は型の一部が&lt;em&gt;省略され&lt;/em&gt;た場合に型を&lt;em&gt;推測する&lt;/em&gt;必要がある&lt;em&gt;ため&lt;/em&gt;、ポリモーフィックな再帰を使用することはできません。型シグネチャが完全に省略されている場合も、同じ制限が発生します。</target>
        </trans-unit>
        <trans-unit id="5fc0cb9f7adb2ad4d1a50c3ef7d1d89e881714f8" translate="yes" xml:space="preserve">
          <source>However, by a simple extension to the type class system of Haskell, we can support dynamic binding. Basically, we express the use of a dynamically bound variable as a constraint on the type. These constraints lead to types of the form &lt;code&gt;(?x::t') =&amp;gt; t&lt;/code&gt;, which says &amp;ldquo;this function uses a dynamically-bound variable &lt;code&gt;?x&lt;/code&gt; of type &lt;code&gt;t'&lt;/code&gt;&amp;rdquo;. For example, the following expresses the type of a sort function, implicitly parameterised by a comparison function named &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="translated">ただし、Haskellの型クラスシステムを単純に拡張することで、動的バインディングをサポートできます。基本的に、動的にバインドされた変数の使用を型の制約として表現します。これらの制約により、 &lt;code&gt;(?x::t') =&amp;gt; t&lt;/code&gt; という形式の型が生じます。これは、「この関数は、型が &lt;code&gt;t'&lt;/code&gt; の動的にバインドされた変数 &lt;code&gt;?x&lt;/code&gt; を使用する」ことを示しています。たとえば、以下はソート関数のタイプを表しており、 &lt;code&gt;cmp&lt;/code&gt; という名前の比較関数によって暗黙的にパラメーター化されています。</target>
        </trans-unit>
        <trans-unit id="a905a90165b9acad9dcb4130ba63d5758f8a8d3c" translate="yes" xml:space="preserve">
          <source>However, consider the following example:</source>
          <target state="translated">しかし、次のような例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="e08e1079e26d8ee5d64f16ab7646e745157e03bd" translate="yes" xml:space="preserve">
          <source>However, enabling the &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; extension allows the module to compile. Similar errors may occur with a variety of extensions, including:</source>
          <target state="translated">ただし、&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;拡張機能を有効にすると、モジュールをコンパイルできます。同様のエラーは、次のようなさまざまな拡張機能で発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="0b8273c78a4e8dc99cc6fb13390e41af1c9b00ab" translate="yes" xml:space="preserve">
          <source>However, for GADTs there is the following additional constraint: every constructor that has a field &lt;code&gt;f&lt;/code&gt; must have the same result type (modulo alpha conversion) Hence, in the above example, we cannot merge the &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt; fields above into a single name. Although their field types are both &lt;code&gt;Term Int&lt;/code&gt;, their selector functions actually have different types:</source>
          <target state="translated">ただし、GADTには次の追加の制約があります。フィールド &lt;code&gt;f&lt;/code&gt; を持つすべてのコンストラクターは同じ結果タイプ（モジュロアルファ変換）でなければなりません。したがって、上記の例では、上記の &lt;code&gt;num&lt;/code&gt; フィールドと &lt;code&gt;arg&lt;/code&gt; フィールドを単一の名前にマージできません。フィールドタイプはどちらも &lt;code&gt;Term Int&lt;/code&gt; ですが、セレクター関数には実際には異なるタイプがあります。</target>
        </trans-unit>
        <trans-unit id="bda4519b4ae553699a88736ad05de49408b09efc" translate="yes" xml:space="preserve">
          <source>However, for most applications, it should suffice to just use the &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:historyFile&quot;&gt;historyFile&lt;/a&gt;&lt;/code&gt; flags.</source>
          <target state="translated">ただし、ほとんどのアプリケーションでは、 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt;&lt;/code&gt; フラグと &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:historyFile&quot;&gt;historyFile&lt;/a&gt;&lt;/code&gt; フラグを使用するだけで十分です。</target>
        </trans-unit>
        <trans-unit id="ad986013ad68059837a38c8bd173d49d68173827" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;CProv&lt;/code&gt; is non-empty, while &lt;code&gt;CReq&lt;/code&gt; is, the above pattern type signature for &lt;code&gt;P&lt;/code&gt; must be specified as</source>
          <target state="translated">ただし、 &lt;code&gt;CProv&lt;/code&gt; が空でない場合、CReqは空 &lt;code&gt;CReq&lt;/code&gt; が、上記の &lt;code&gt;P&lt;/code&gt; のパターン型シグネチャは次のように指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="d463e6d4a25197f32ed78eb56a6036ea10aebfec" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; ends in a separator, the default databases (i.e. the user and global package databases, in that order) are appended to the path. For example, to augment the usual set of packages with a database of your own, you could say (on Unix):</source>
          <target state="translated">ただし、 &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; が区切り文字で終わる場合、デフォルトのデータベース（つまり、ユーザーパッケージデータベースとグローバルパッケージデータベースがこの順序で）がパスに追加されます。たとえば、通常のパッケージセットに独自のデータベースを追加するには、次のようにします（UNIXの場合）。</target>
        </trans-unit>
        <trans-unit id="967aa81a898dabc9a0655eae4604ccf80453bdf1" translate="yes" xml:space="preserve">
          <source>However, if you want to interact with a foreign library that expects your program to use the operating system-supplied thread package, you can do so by using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ただし、プログラムがオペレーティングシステム提供のスレッドパッケージを使用することを期待する外部ライブラリとやり取りしたい場合は、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 代わりに &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; を使用して行うことができます。</target>
        </trans-unit>
        <trans-unit id="48f6dfd00eff21ddfaf5b9214e0d18073ac349d6" translate="yes" xml:space="preserve">
          <source>However, in all patterns &lt;em&gt;other&lt;/em&gt; than pattern bindings, a pattern type signature may mention a type variable that is not in scope; in this case, &lt;em&gt;the signature brings that type variable into scope&lt;/em&gt;. For example:</source>
          <target state="translated">しかし、全てのパターンに&lt;em&gt;他の&lt;/em&gt;パターンバインディングよりも、パターン型シグネチャは、スコープ内にないタイプの変数を挙げることができます。この場合、&lt;em&gt;シグネチャはその型変数をスコープに入れます&lt;/em&gt;。例えば：</target>
        </trans-unit>
        <trans-unit id="84c24910fabe3813ad18d23c698dd48a88899c66" translate="yes" xml:space="preserve">
          <source>However, it appears that if you add a space at the end of the line, then &lt;code&gt;cpp&lt;/code&gt; (at least GNU &lt;code&gt;cpp&lt;/code&gt; and possibly other &lt;code&gt;cpp&lt;/code&gt;s) leaves the backslash-space pairs alone and the string gap works as expected.</source>
          <target state="translated">ただし、行の最後にスペースを追加すると、 &lt;code&gt;cpp&lt;/code&gt; （少なくともGNU &lt;code&gt;cpp&lt;/code&gt; と他の &lt;code&gt;cpp&lt;/code&gt; s）はバックスラッシュとスペースのペアをそのままにし、文字列のギャップは期待どおりに機能するようです。</target>
        </trans-unit>
        <trans-unit id="28c91a74d73602f60fc3e23aaa16816234c03e5d" translate="yes" xml:space="preserve">
          <source>However, it is possible to perform a bit of &amp;ldquo;backwards&amp;rdquo; evaluation. For example, here is how we could get GHC to compute arbitrary logarithms at the type level:</source>
          <target state="translated">ただし、少し「後方」評価を実行することは可能です。たとえば、これはGHCに型レベルで任意の対数を計算させる方法です。</target>
        </trans-unit>
        <trans-unit id="1f3a4b89e8199e4d733ca299842a306ab859485c" translate="yes" xml:space="preserve">
          <source>However, it is tiresome for the user to have to specify the type, so GHCi extends Haskell&amp;rsquo;s type-defaulting rules (Section 4.3.4 of the Haskell 2010 Report) as follows. The standard rules take each group of constraints &lt;code&gt;(C1 a, C2 a, ..., Cn a)&lt;/code&gt; for each type variable &lt;code&gt;a&lt;/code&gt;, and defaults the type variable if</source>
          <target state="translated">ただし、ユーザーがタイプを指定する必要があるのは面倒なので、GHCiはHaskellのタイプデフォルトルール（Haskell 2010レポートのセクション4.3.4）を次のように拡張します。標準規則 &lt;code&gt;(C1 a, C2 a, ..., Cn a)&lt;/code&gt; 型変数 &lt;code&gt;a&lt;/code&gt; ごとに制約の各グループ（C1 a、C2 a、...、Cn a）を取得し、次の場合に型変数をデフォルト設定します。</target>
        </trans-unit>
        <trans-unit id="4a41cd61107bf2e5acee8876cf3ea899f304dcd8" translate="yes" xml:space="preserve">
          <source>However, not all is lost. We can still do this:</source>
          <target state="translated">しかし、すべてが失われたわけではありません。私たちにはまだできることがあります。</target>
        </trans-unit>
        <trans-unit id="7187323d3950a28b28f87b9f4c602a2796f69d8b" translate="yes" xml:space="preserve">
          <source>However, note that it is reasonable to have a module &lt;code&gt;Main&lt;/code&gt; in a file named &lt;code&gt;foo.hs&lt;/code&gt;, but this only works because GHC never needs to search for the interface for module &lt;code&gt;Main&lt;/code&gt; (because it is never imported). It is therefore possible to have several &lt;code&gt;Main&lt;/code&gt; modules in separate source files in the same directory, and GHC will not get confused.</source>
          <target state="translated">ただし、モジュール &lt;code&gt;Main&lt;/code&gt; を &lt;code&gt;foo.hs&lt;/code&gt; という名前のファイルに含めることは妥当ですが、これはGHCがモジュール &lt;code&gt;Main&lt;/code&gt; のインターフェースを検索する必要がないためにのみ機能することに注意してください（インポートされないため）。したがって、同じディレクトリの別々のソースファイルに複数の &lt;code&gt;Main&lt;/code&gt; モジュールを置くことが可能であり、GHCは混乱しません。</target>
        </trans-unit>
        <trans-unit id="fcbd4b2fd1492cb8e585fb78fb46502a8ccda050" translate="yes" xml:space="preserve">
          <source>However, regardless of the flag setting, the quantifiers are printed under these circumstances:</source>
          <target state="translated">ただし、フラグの設定に関わらず、このような状況下では定量器が印刷されます。</target>
        </trans-unit>
        <trans-unit id="35326ee19484ea5250a5955bf9162649c5ce6743" translate="yes" xml:space="preserve">
          <source>However, since version 8.4 this is no longer the case: GHC &lt;strong&gt;guarantees&lt;/strong&gt; that garbage collection will never occur during an &lt;code&gt;unsafe&lt;/code&gt; call, even in the bytecode interpreter, and further guarantees that &lt;code&gt;unsafe&lt;/code&gt; calls will be performed in the calling thread.</source>
          <target state="translated">ただし、バージョン8.4以降これはもはやケースではありません：GHCは&lt;strong&gt;保証&lt;/strong&gt;そのガベージコレクションが中に発生することはありません &lt;code&gt;unsafe&lt;/code&gt; ことを呼び出し、でも、バイトコードインタプリタで、さらに保証 &lt;code&gt;unsafe&lt;/code&gt; 呼び出しは呼び出し元のスレッドで実行されます。</target>
        </trans-unit>
        <trans-unit id="3168a5cfff35597637af368edcde71624cd723d0" translate="yes" xml:space="preserve">
          <source>However, sometimes there are no such calls, in which case the pragma can be useful.</source>
          <target state="translated">しかし、そのような呼び出しがない場合もあります。</target>
        </trans-unit>
        <trans-unit id="5f1896001a515ea20b3107b6872d509be571c338" translate="yes" xml:space="preserve">
          <source>However, standalone deriving differs from a &lt;code&gt;deriving&lt;/code&gt; clause in a number of important ways:</source>
          <target state="translated">ただし、スタンドアロンの派生は、いくつかの重要な点で &lt;code&gt;deriving&lt;/code&gt; 句とは異なります。</target>
        </trans-unit>
        <trans-unit id="d2ba9a199527bbadec33a09879e817a0f6de5758" translate="yes" xml:space="preserve">
          <source>However, starting with &lt;code&gt;deepseq-1.4.0.0&lt;/code&gt;, the default implementation is based on &lt;code&gt;DefaultSignatures&lt;/code&gt; allowing for more accurate auto-derived &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; instances. If you need the previously used exact default &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; method implementation semantics, use</source>
          <target state="translated">ただし、 &lt;code&gt;deepseq-1.4.0.0&lt;/code&gt; 以降、デフォルトの実装は &lt;code&gt;DefaultSignatures&lt;/code&gt; に基づいており、より正確な自動派生 &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; インスタンスを可能にします。以前に使用した正確なデフォルトの &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; メソッド実装セマンティクスが必要な場合は、</target>
        </trans-unit>
        <trans-unit id="7024ade898249c07bcf841caece72369d63586b1" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; and &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt; axioms both match the wanted constraint &lt;code&gt;C a&lt;/code&gt;. There are several possible approaches for handling these overlapping local axioms:</source>
          <target state="translated">ただし、 &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; および &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt; 公理はどちらも必要な制約 &lt;code&gt;C a&lt;/code&gt; に一致します。これらの重複するローカル公理を処理するには、いくつかの可能なアプローチがあります。</target>
        </trans-unit>
        <trans-unit id="cf8981ad8f62f6891902d31a96ee844f6c284310" translate="yes" xml:space="preserve">
          <source>However, the instance declaration must still conform to the rules for instance termination: see &lt;a href=&quot;#instance-termination&quot;&gt;Instance termination rules&lt;/a&gt;.</source>
          <target state="translated">ただし、インスタンス宣言はインスタンス終了のルールに準拠している必要があり&lt;a href=&quot;#instance-termination&quot;&gt;ます&lt;/a&gt;。インスタンス終了ルールを参照してください。</target>
        </trans-unit>
        <trans-unit id="f0881e26d84cd12d8c7fd2b522507d9075fd4696" translate="yes" xml:space="preserve">
          <source>However, the real implemenation uses memcmp to compare the end of the string only, with no reverse required..</source>
          <target state="translated">しかし、実際の実装では memcmp を使用して文字列の末尾のみを比較し、逆引きは必要ありません。</target>
        </trans-unit>
        <trans-unit id="06134ece72c951c7d7c727c39885e4d66b957bb6" translate="yes" xml:space="preserve">
          <source>However, the second law is violated in the presence of undefined operators,</source>
          <target state="translated">しかし、未定義の演算子の存在下では、第2法則に違反する。</target>
        </trans-unit>
        <trans-unit id="a72bbc3e10475e3349a7633255fe25a94534717f" translate="yes" xml:space="preserve">
          <source>However, the two terms are certainly related. By making use of multiple CPUs it is possible to run concurrent threads in parallel, and this is exactly what GHC&amp;rsquo;s SMP parallelism support does. But it is also possible to obtain performance improvements with parallelism on programs that do not use concurrency. This section describes how to use GHC to compile and run parallel programs, in &lt;a href=&quot;parallel#lang-parallel&quot;&gt;Concurrent and Parallel Haskell&lt;/a&gt; we describe the language features that affect parallelism.</source>
          <target state="translated">ただし、2つの用語は確かに関連しています。複数のCPUを利用することにより、並行スレッドを並列に実行することが可能であり、これはまさにGHCのSMP並列処理サポートが行うことです。ただし、並行性を使用しないプログラムで並列処理を行うと、パフォーマンスが向上する場合もあります。このセクションでは、GHCを使用して並列プログラムをコンパイルおよび実行する方法について説明します。&lt;a href=&quot;parallel#lang-parallel&quot;&gt;並行および並列Haskell&lt;/a&gt;では、並列処理に影響を与える言語機能について説明します。</target>
        </trans-unit>
        <trans-unit id="d0d7fb9afd1affd6fb2291bb8b2736b5c57061fb" translate="yes" xml:space="preserve">
          <source>However, the unrestricted use of &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; is a problem as an arbitrary module can use it to mark themselves as trusted, yet &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t offer any guarantees about the module, unlike &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;. To control the use of trustworthy modules it is recommended to use the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag. This flag adds an extra requirement to the trust check for trustworthy modules. It requires that for a trustworthy modules to be considered trusted, and allowed to be used in &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; compiled code, the client C compiling the code must tell GHC that they trust the package the trustworthy module resides in. This is essentially a way of for C to say, while this package contains trustworthy modules that can be used by untrusted modules compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, I trust the author(s) of this package and trust the modules only expose a safe API. The trust of a package can be changed at any time, so if a vulnerability found in a package, C can declare that package untrusted so that any future compilation against that package would fail. For a more detailed overview of this mechanism see &lt;a href=&quot;#safe-trust&quot;&gt;Trust and Safe Haskell Modes&lt;/a&gt;.</source>
          <target state="translated">しかし、無制限の使用&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;、任意のモジュールとして問題が信頼できるとして自分自身をマークするために使用することができ、まだある&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;異なり、モジュールに関するすべての保証を提供していない&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;。信頼できるモジュールの使用を制御するには、&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;フラグを使用することをお勧めします。このフラグは、信頼できるモジュールの信頼チェックに追加の要件を追加します。信頼できるモジュールを信頼できると見なし、&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;で使用できるようにする必要があります。コンパイルされたコード、コードをコンパイルするクライアントCは、信頼できるモジュールが存在するパッケージを信頼することをGHCに通知する必要があります。これは基本的にCが言う方法ですが、このパッケージには、&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; で&lt;/a&gt;コンパイルされた信頼できないモジュールが使用できる信頼できるモジュールが含まれています、このパッケージの作成者を信頼し、モジュールが安全なAPIのみを公開することを信頼します。パッケージの信頼はいつでも変更できるため、パッケージに脆弱性が見つかった場合、Cはそのパッケージを信頼できないと宣言して、そのパッケージに対する今後のコンパイルが失敗するようにすることができます。このメカニズムのより詳細な概要については、&lt;a href=&quot;#safe-trust&quot;&gt;Trust and Safe Haskell Modesを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b532bdc7013089e7dc2ea095365363430246167b" translate="yes" xml:space="preserve">
          <source>However, there are a couple of problems with this approach. The first is that having two exception handlers is inefficient. However, the more serious issue is that the second exception handler will catch exceptions in the first, e.g. in the example above, if &lt;code&gt;handleArith&lt;/code&gt; throws an &lt;code&gt;IOException&lt;/code&gt; then the second exception handler will catch it.</source>
          <target state="translated">ただし、このアプローチにはいくつかの問題があります。1つ目は、2つの例外ハンドラーを持つことは非効率的です。ただし、より深刻な問題は、 &lt;code&gt;handleArith&lt;/code&gt; が &lt;code&gt;IOException&lt;/code&gt; 例外をキャッチすることです。 IOExceptionを、2番目の例外ハンドラーがそれをキャッチします。</target>
        </trans-unit>
        <trans-unit id="d9ee23f1fd11c8d62aeb9eeee086197709f0be7d" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; で常に安全に呼び出すことができるトランザクション変数を作成するための関数があります。参照： &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c22293f9f5fdf9be0f89ee2fe6ac2c9f85e6c4fa" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; で常に安全に呼び出すことができるトランザクション変数を作成するための関数があります。 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="0c11995af9963ba10b5fec5e359b15b835f98697" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;ghc-conc#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; で常に安全に呼び出すことができるトランザクション変数を作成するための関数があります。参照： &lt;code&gt;&lt;a href=&quot;ghc-conc#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef09da657ffc9d4af89d0f416150551e096de936" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; で常に安全に呼び出すことができるトランザクション変数を作成するための関数があります。参照： &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36debdedc3fc8b9fe245012b3b2d0f8a8b3e2720" translate="yes" xml:space="preserve">
          <source>However, this is hard-to-impossible to implement on some non-Unix OSes, so instead, for maximum portability, we just return the leafname of the program as invoked. Even then there are some differences between platforms: on Windows, for example, a program invoked as foo is probably really &lt;code&gt;FOO.EXE&lt;/code&gt;, and that is what &lt;code&gt;&lt;a href=&quot;system-environment#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; will return.</source>
          <target state="translated">ただし、これを一部の非UNIX OSに実装することは不可能ではないため、代わりに、最大限の移植性のために、呼び出されたプログラムのリーフ名を返すだけです。それでも、プラットフォーム間にはいくつかの違いがあります。たとえば、Windowsでは、fooとして呼び出されたプログラムはおそらく実際には &lt;code&gt;FOO.EXE&lt;/code&gt; であり、それが &lt;code&gt;&lt;a href=&quot;system-environment#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; によって返されます。</target>
        </trans-unit>
        <trans-unit id="04e5a60e9a91ca4a5044b3e556c3f51ba02637a2" translate="yes" xml:space="preserve">
          <source>However, this is hard-to-impossible to implement on some non-Unix OSes, so instead, for maximum portability, we just return the leafname of the program as invoked. Even then there are some differences between platforms: on Windows, for example, a program invoked as foo is probably really &lt;code&gt;FOO.EXE&lt;/code&gt;, and that is what &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; will return.</source>
          <target state="translated">ただし、これを一部の非UNIX OSに実装することは不可能ではないため、代わりに、最大限の移植性のために、呼び出されたプログラムのリーフ名を返すだけです。それでも、プラットフォーム間にはいくつかの違いがあります。たとえば、Windowsでは、fooとして呼び出されたプログラムはおそらく実際には &lt;code&gt;FOO.EXE&lt;/code&gt; であり、それが &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; によって返されます。</target>
        </trans-unit>
        <trans-unit id="cd5fe8ac3752b514477ab6da6483511ccc949a4e" translate="yes" xml:space="preserve">
          <source>However, this quickly gets tedious when defining functions with multiple clauses, or groups of mutually recursive functions, because the complete definition has to be given on a single line, using explicit semicolons instead of layout:</source>
          <target state="translated">しかし、複数の節を持つ関数や、相互に再帰的な関数のグループを定義する場合は、レイアウトの代わりに明示的なセミコロンを使用して、完全な定義を1行で記述しなければならないため、これはすぐに面倒になってしまいます。</target>
        </trans-unit>
        <trans-unit id="321449b209a4a3d9b8a213d15a63e5983b737e5b" translate="yes" xml:space="preserve">
          <source>However, this restriction can be relaxed by enabling &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#unlifted-newtypes&quot;&gt;section on unlifted newtypes&lt;/a&gt; details the behavior of such types.</source>
          <target state="translated">ただし、&lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt;を有効にすることで、この制限を緩和できます。&lt;a href=&quot;#unlifted-newtypes&quot;&gt;unlifted newtypes上のセクションでは&lt;/a&gt;、このような種類の行動を詳細に説明します。</target>
        </trans-unit>
        <trans-unit id="8c072dae816d58a4bbbf3253aaac2ff2d7bee49e" translate="yes" xml:space="preserve">
          <source>However, this would not be permitted, because &lt;code&gt;x&lt;/code&gt; is ambiguous:</source>
          <target state="translated">ただし、 &lt;code&gt;x&lt;/code&gt; はあいまいであるため、これは許可されません。</target>
        </trans-unit>
        <trans-unit id="cc6a6176295d69c876f06979d7fd1959a45e1552" translate="yes" xml:space="preserve">
          <source>However, type class instances of instances of data families can be defined much like any other data type. For example, we can say</source>
          <target state="translated">しかし、データファミリーのインスタンスの型クラスインスタンスは、他のデータ型と同じように定義することができます。例えば、次のようなことができます。</target>
        </trans-unit>
        <trans-unit id="67eb60c225421062cda3e126bd114e249c145db9" translate="yes" xml:space="preserve">
          <source>However, we do not infer the type of the argument to determine the datatype, or have any way of deferring the choice to the constraint solver. Thus the following is ambiguous:</source>
          <target state="translated">しかし、データ型を決定するために引数の型を推論したり、制約ソルバーに選択を委ねる方法はありません。したがって、以下は曖昧です。</target>
        </trans-unit>
        <trans-unit id="2d46b3249f71b533cad63e9708c9fb1563db8ccc" translate="yes" xml:space="preserve">
          <source>However, with &lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt;&lt;/a&gt; set to e.g. &lt;code&gt;1&lt;/code&gt;, it will additionally offer up a list of refinement hole fits, in this case:</source>
          <target state="translated">ただし、&lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt; &lt;/a&gt;を例えば &lt;code&gt;1&lt;/code&gt; に設定すると、この場合、さらに、リファインメントホールフィットのリストが表示されます。</target>
        </trans-unit>
        <trans-unit id="2c1c33bc1108d9b6ddb6ca92ba69a2740518cc11" translate="yes" xml:space="preserve">
          <source>HpcHash</source>
          <target state="translated">HpcHash</target>
        </trans-unit>
        <trans-unit id="a360e1a8abea3420612de3ead3619643eba9cb5b" translate="yes" xml:space="preserve">
          <source>HpcPos</source>
          <target state="translated">HpcPos</target>
        </trans-unit>
        <trans-unit id="e4d5ebe01dfadab7c70f17122ef7cd34dd84d2c8" translate="yes" xml:space="preserve">
          <source>Html</source>
          <target state="translated">Html</target>
        </trans-unit>
        <trans-unit id="124fd6e6c83b9f6fb819bac633416da6be7be061" translate="yes" xml:space="preserve">
          <source>Html abbreviations</source>
          <target state="translated">Html の略語</target>
        </trans-unit>
        <trans-unit id="e52dad2394901ae9e2d9331b3f2acf8d98f94c3d" translate="yes" xml:space="preserve">
          <source>Html colors</source>
          <target state="translated">Html の色</target>
        </trans-unit>
        <trans-unit id="61902ef6ccfb44a18ca2dc1621601009523e9eaa" translate="yes" xml:space="preserve">
          <source>HtmlAttr</source>
          <target state="translated">HtmlAttr</target>
        </trans-unit>
        <trans-unit id="1a8747bf93f58314ba9284567291634cad2df306" translate="yes" xml:space="preserve">
          <source>HtmlTable</source>
          <target state="translated">HtmlTable</target>
        </trans-unit>
        <trans-unit id="869a30d95c70a8d903e6df744e122731cf7e1681" translate="yes" xml:space="preserve">
          <source>HtmlTree</source>
          <target state="translated">HtmlTree</target>
        </trans-unit>
        <trans-unit id="2f70612bc16437d395e71287782bb6fd9cb7cf34" translate="yes" xml:space="preserve">
          <source>I can&amp;rsquo;t use</source>
          <target state="translated">使えない</target>
        </trans-unit>
        <trans-unit id="67e7f16393df9e1a3f34effee9614b452216e036" translate="yes" xml:space="preserve">
          <source>I/O error that is programmer-defined.</source>
          <target state="translated">プログラマ定義のI/Oエラー。</target>
        </trans-unit>
        <trans-unit id="be281ef8dae874dacda5f49b4225eb1d24483701" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because one of its arguments already exists.</source>
          <target state="translated">引数の 1 つが既に存在するために操作が失敗した I/O エラー。</target>
        </trans-unit>
        <trans-unit id="aa1a6c7e94bc5323e2b6ac2224ee418279aeb634" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because one of its arguments does not exist.</source>
          <target state="translated">引数の1つが存在しないために操作が失敗したI/Oエラー。</target>
        </trans-unit>
        <trans-unit id="cf116efd8157c9a3bd761c2360aee94f0bc67d1a" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because one of its arguments is a single-use resource, which is already being used.</source>
          <target state="translated">引数の 1 つが既に使用中の単一使用リソースであるため、操作が失敗した I/O エラー。</target>
        </trans-unit>
        <trans-unit id="cc128e1a7374671fae3700b7cd3ca03b1ae3b58e" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the device is full.</source>
          <target state="translated">デバイスが満杯のため、操作に失敗したI/Oエラー。</target>
        </trans-unit>
        <trans-unit id="d8f8e3fdaff7cb3366cae3acc6a3cd527d98dbd3" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the end of file has been reached.</source>
          <target state="translated">ファイルの終端に達したため、操作に失敗したI/Oエラー。</target>
        </trans-unit>
        <trans-unit id="23225f523b6fe0da8418987860224d2674cecc83" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the user does not have sufficient operating system privilege to perform that operation.</source>
          <target state="translated">ユーザーがその操作を実行するのに十分なオペレーティングシステムの特権を持っていないために操作が失敗したI/Oエラー。</target>
        </trans-unit>
        <trans-unit id="4923b264f73fffadc5e3e140e95a5e90f4234f9e" translate="yes" xml:space="preserve">
          <source>I/O error where the operation is not possible.</source>
          <target state="translated">操作ができないI/Oエラー。</target>
        </trans-unit>
        <trans-unit id="9f2341b3a2667883fa17fd8660410d5080e25605" translate="yes" xml:space="preserve">
          <source>I/O errors</source>
          <target state="translated">入出力エラー</target>
        </trans-unit>
        <trans-unit id="893f42dbf3b6c3880cae0f711ab5e68ed55c84da" translate="yes" xml:space="preserve">
          <source>I/O operations required for implementing a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; の実装に必要なI / O操作。</target>
        </trans-unit>
        <trans-unit id="010704f655d5ffc0ec746349b6abc0e90227f6a7" translate="yes" xml:space="preserve">
          <source>I/O with &lt;code&gt;ByteString&lt;/code&gt;s</source>
          <target state="translated">I / Oとの &lt;code&gt;ByteString&lt;/code&gt; S</target>
        </trans-unit>
        <trans-unit id="ad04b3f0bd847573f914feec3f998fe1fbf5895a" translate="yes" xml:space="preserve">
          <source>I/O with Handles</source>
          <target state="translated">ハンドル付きI/O</target>
        </trans-unit>
        <trans-unit id="acc124dc3f9258dc88e844ea4ab0c049f8122496" translate="yes" xml:space="preserve">
          <source>I16</source>
          <target state="translated">I16</target>
        </trans-unit>
        <trans-unit id="eee5fb69722aeae0ef4402237b3281ea912a11ad" translate="yes" xml:space="preserve">
          <source>ID of group.</source>
          <target state="translated">グループのIDです。</target>
        </trans-unit>
        <trans-unit id="34a94d7992e803328c642d1ab3fa274462915c38" translate="yes" xml:space="preserve">
          <source>ID of owner.</source>
          <target state="translated">所有者のIDです。</target>
        </trans-unit>
        <trans-unit id="6fb496c44e36ef77af848cbdb3f2ef6feaf4502e" translate="yes" xml:space="preserve">
          <source>ID of the device on which this file resides.</source>
          <target state="translated">このファイルが存在するデバイスのID。</target>
        </trans-unit>
        <trans-unit id="bb2fe63e5a32cb2596d9f60d2ae271ae4d1c1787" translate="yes" xml:space="preserve">
          <source>INPUT</source>
          <target state="translated">INPUT</target>
        </trans-unit>
        <trans-unit id="793985cddb68d46ef51b688aecf85864c9e06813" translate="yes" xml:space="preserve">
          <source>INT</source>
          <target state="translated">INT</target>
        </trans-unit>
        <trans-unit id="556d134b3ad4c3f832238864ee9ed1a9fff795e3" translate="yes" xml:space="preserve">
          <source>INT32</source>
          <target state="translated">INT32</target>
        </trans-unit>
        <trans-unit id="c35391cc7b82f6ccca4793a8e8e896ee6abb21d2" translate="yes" xml:space="preserve">
          <source>INT64</source>
          <target state="translated">INT64</target>
        </trans-unit>
        <trans-unit id="68e53a5693c9fc9b9b1250288b7552cd0ff0e2f9" translate="yes" xml:space="preserve">
          <source>INT_PTR</source>
          <target state="translated">INT_PTR</target>
        </trans-unit>
        <trans-unit id="9d8fb39373007c2c84580d473e2a6e10a1f4c15d" translate="yes" xml:space="preserve">
          <source>IO</source>
          <target state="translated">IO</target>
        </trans-unit>
        <trans-unit id="221a35a7e847cc97cca77325d3f3ad369c03402f" translate="yes" xml:space="preserve">
          <source>IO functions for serialisation</source>
          <target state="translated">シリアル化のためのIO関数</target>
        </trans-unit>
        <trans-unit id="cc004908b1b2245fb78beda6015345ffd34734b1" translate="yes" xml:space="preserve">
          <source>IO-related Exception types and functions</source>
          <target state="translated">IO関連の例外の種類と関数</target>
        </trans-unit>
        <trans-unit id="39e51b2fc5f7179682d0416f025521af63af3bff" translate="yes" xml:space="preserve">
          <source>IOArray</source>
          <target state="translated">IOArray</target>
        </trans-unit>
        <trans-unit id="c6a99f18754ec17dc03dabc42173c7669bade008" translate="yes" xml:space="preserve">
          <source>IOCallback</source>
          <target state="translated">IOCallback</target>
        </trans-unit>
        <trans-unit id="e37f3b10503e6237389797302777a6702097cc50" translate="yes" xml:space="preserve">
          <source>IODevice</source>
          <target state="translated">IODevice</target>
        </trans-unit>
        <trans-unit id="de20e3fa4c9228ace3c0f6bf748ad0bbf5c271d9" translate="yes" xml:space="preserve">
          <source>IODeviceType</source>
          <target state="translated">IODeviceType</target>
        </trans-unit>
        <trans-unit id="a7aaaf8103e147f7508e66b5f7be824742d34faa" translate="yes" xml:space="preserve">
          <source>IOError</source>
          <target state="translated">IOError</target>
        </trans-unit>
        <trans-unit id="08d5912d3126b1dfb78f32fc53ee4cb092bb66d6" translate="yes" xml:space="preserve">
          <source>IOErrorType</source>
          <target state="translated">IOErrorType</target>
        </trans-unit>
        <trans-unit id="319a21ad8b671794467e4935946062d4d1e04338" translate="yes" xml:space="preserve">
          <source>IOException</source>
          <target state="translated">IOException</target>
        </trans-unit>
        <trans-unit id="6eeb7a443b8d1cc8717295647ffb6fceb48316d4" translate="yes" xml:space="preserve">
          <source>IOMode</source>
          <target state="translated">IOMode</target>
        </trans-unit>
        <trans-unit id="b772fdda8de2d1e1a2fcd9af43fda137f1082681" translate="yes" xml:space="preserve">
          <source>IORef</source>
          <target state="translated">IORef</target>
        </trans-unit>
        <trans-unit id="268db2ac8f4f524b89d42b5ab6cac600af62f822" translate="yes" xml:space="preserve">
          <source>IORefs</source>
          <target state="translated">IORefs</target>
        </trans-unit>
        <trans-unit id="4c3aab79c94196e8852e03490d73a55b7f5049e7" translate="yes" xml:space="preserve">
          <source>IOUArray</source>
          <target state="translated">IOUArray</target>
        </trans-unit>
        <trans-unit id="e10a87d05825ac01e14764ed94abba63697418fb" translate="yes" xml:space="preserve">
          <source>IQList</source>
          <target state="translated">IQList</target>
        </trans-unit>
        <trans-unit id="820a25194dff0d9c02f82ba8b6ba428cf8fc6422" translate="yes" xml:space="preserve">
          <source>IQNil</source>
          <target state="translated">IQNil</target>
        </trans-unit>
        <trans-unit id="7567d31e648220ce233abc256ecdab6241e5ddca" translate="yes" xml:space="preserve">
          <source>ISO 8601 Ordinal Date format</source>
          <target state="translated">ISO 8601 序数日付形式</target>
        </trans-unit>
        <trans-unit id="f822119fe2f0a8362181618c06cbbe9eb1102060" translate="yes" xml:space="preserve">
          <source>ISO 8601 Week Date format</source>
          <target state="translated">ISO 8601 週の日付のフォーマット</target>
        </trans-unit>
        <trans-unit id="ce553dbefd4b35500c8adfaf562f347bd1cffaf1" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 2.3.3. Omit hyphens and colons. &quot;The basic format should be avoided in plain text.&quot;</source>
          <target state="translated">ISO 8601:2004(E)sec.2.3.3.ハイフン及びコロンを省略する。&quot;平文では基本的な書式は避けることが望ましい&quot;</target>
        </trans-unit>
        <trans-unit id="5b73e3fe248bf6961ea567329e7f53034196b781" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 2.3.4. Use hyphens and colons.</source>
          <target state="translated">ISO 8601:2004(E)sec.2.3.4.ハイフンとコロンを使用する。</target>
        </trans-unit>
        <trans-unit id="ea6af556d4876a2b89f040fff7abb59f4dd0f4c1" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.2</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.2</target>
        </trans-unit>
        <trans-unit id="65fa90d60515a8ea4b8b6bba5111ddac2a89a577" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.3(a)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.3(a)</target>
        </trans-unit>
        <trans-unit id="b8e6c45635e6a6c7b99751a00199842c95a39f56" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.3(b)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.3(b)</target>
        </trans-unit>
        <trans-unit id="9b6b8fd39d751d5c0fc381e79557a67b538bd22a" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.3(c)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.3(c)</target>
        </trans-unit>
        <trans-unit id="c7d58b1b77840944ae450aa457ab0e6e3c750344" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(a)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.4(a)</target>
        </trans-unit>
        <trans-unit id="50049f60c0a8e8cd5b1d15d9787aba4c4ae639f0" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(b)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.4(b)</target>
        </trans-unit>
        <trans-unit id="d06f9cca67b57ce453f249d30d73e9c7f581681a" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(c)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.4(c)</target>
        </trans-unit>
        <trans-unit id="813aaac22f2045f777c991dc639bff2d89abd533" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(d)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.4(d)</target>
        </trans-unit>
        <trans-unit id="72acd19bfc93f68e206e6c0d34917114a1fccd3e" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.3.2</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.3.2</target>
        </trans-unit>
        <trans-unit id="3f13144d5ece5d74d8b6f96aa24edc61eeacd8ad" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.3.3</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.3.3</target>
        </trans-unit>
        <trans-unit id="9b6b94afc9edd9404ea266217015cf416121eae0" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.4.2</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.4.2</target>
        </trans-unit>
        <trans-unit id="a87736cb0c925b16cdeae6f6fe9b3e015c30590f" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.4.3</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.4.3</target>
        </trans-unit>
        <trans-unit id="bbcf342f586bebce46006d4c12d16ad8863024f4" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.2, 4.2.2.4(a)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.2.2.2,4.2.2.4(a)</target>
        </trans-unit>
        <trans-unit id="b6b37624da200ed73cebb71eb0a89339f3a4fba3" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.3(a), 4.2.2.4(b)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.2.2.2.3(a)、4.2.2.2.4(b)</target>
        </trans-unit>
        <trans-unit id="c55ad86d1327285d355a307898cd0bcedc64b2e7" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.3(b), 4.2.2.4(c)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.2.2.2.3(b)、4.2.2.2.4(c)</target>
        </trans-unit>
        <trans-unit id="8f67d771cf395b85785ef48de67f6dffa701c036" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.5</source>
          <target state="translated">ISO 8601:2004(E)sec.4.2.2.5</target>
        </trans-unit>
        <trans-unit id="07b435b23d42540df0b1bc985f1fa5204e769f0b" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.4</source>
          <target state="translated">ISO 8601:2004(E)sec.4.2.4</target>
        </trans-unit>
        <trans-unit id="4fcc52df4b38af082287f6513b315a63598a3982" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.5.1</source>
          <target state="translated">ISO 8601:2004(E)sec.4.2.5.1</target>
        </trans-unit>
        <trans-unit id="5787fbc9eed85c23b6ba6c14fc91c92443851aa7" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.5.2</source>
          <target state="translated">ISO 8601:2004(E)sec.4.2.5.2</target>
        </trans-unit>
        <trans-unit id="12305998507260debe9c8d6034797acfcba06193" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.3.2</source>
          <target state="translated">ISO 8601:2004(E)sec.4.3.2</target>
        </trans-unit>
        <trans-unit id="c5f903f7dfa61fd47c40e96852ca4df55e2a3b30" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.3.3</source>
          <target state="translated">ISO 8601:2004(E)sec.4.3.3</target>
        </trans-unit>
        <trans-unit id="9bfa7627b1b505b0fc50fefcc1d485389c084e49" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.4.3.2</source>
          <target state="translated">ISO 8601:2004(E)sec.4.4.3.2</target>
        </trans-unit>
        <trans-unit id="2f0c4ca61d383b42003623a59e3a979e5caa4b98" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.4.3.3</source>
          <target state="translated">ISO 8601:2004(E)sec.4.4.3.3</target>
        </trans-unit>
        <trans-unit id="fafc36b5bb91f4fa0ee5d27ebce4e786ca51d48d" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.4.4.1</source>
          <target state="translated">ISO 8601:2004(E)sec.4.4.4.1</target>
        </trans-unit>
        <trans-unit id="bbb017422d2f8d4d41f4efb11d499f43cec2368e" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.5</source>
          <target state="translated">ISO 8601:2004(E)sec.4.5</target>
        </trans-unit>
        <trans-unit id="0844a2bf2289652fa3443d5285683e93680df727" translate="yes" xml:space="preserve">
          <source>ISO/IEC 8859-1 (Char8)</source>
          <target state="translated">ISO/IEC 8859-1 (Char8)</target>
        </trans-unit>
        <trans-unit id="58ee37c4c15383ecc1c4a02446d911520642fcf8" translate="yes" xml:space="preserve">
          <source>ISO8601</source>
          <target state="translated">ISO8601</target>
        </trans-unit>
        <trans-unit id="c9cf1dd8147dc5d22c7365bdaa07b0903f6de420" translate="yes" xml:space="preserve">
          <source>ITQList</source>
          <target state="translated">ITQList</target>
        </trans-unit>
        <trans-unit id="45da9c6dee9536772c435a75e794212cc011b4e4" translate="yes" xml:space="preserve">
          <source>ITQNil</source>
          <target state="translated">ITQNil</target>
        </trans-unit>
        <trans-unit id="9a1703cf287a1d482c0b2abbe3bb64675ffdbe02" translate="yes" xml:space="preserve">
          <source>Ideally, this type would not exist at all and we would just fix the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">理想的には、このタイプはまったく存在せず、 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; インスタンスを修正するだけです。 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; のです。</target>
        </trans-unit>
        <trans-unit id="ce1ef819f32725331a936d8af228a9ef343e2ecc" translate="yes" xml:space="preserve">
          <source>Identical to &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt;, except that the return value does not include the function which maps keys to vertices. This version of &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt; is for backwards compatibility.</source>
          <target state="translated">戻り値にキーを頂点にマップする関数が含まれていないことを除いて、 &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt; と同じです。このバージョンの &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt; は、下位互換性のためのものです。</target>
        </trans-unit>
        <trans-unit id="7e5a975b6add84fd53e3710a9ceac15eb06663b7" translate="yes" xml:space="preserve">
          <source>Identity</source>
          <target state="translated">Identity</target>
        </trans-unit>
        <trans-unit id="111e795804fa7bde03948ba63ec2cb3f6f402b39" translate="yes" xml:space="preserve">
          <source>Identity function.</source>
          <target state="translated">アイデンティティ機能。</target>
        </trans-unit>
        <trans-unit id="45ddee8d84b61e8e7c17a3d7431270c5b54e7630" translate="yes" xml:space="preserve">
          <source>Identity functor and monad. (a non-strict monad)</source>
          <target state="translated">同一ファンクタとモナド。(非厳格なモナド)</target>
        </trans-unit>
        <trans-unit id="d40415a7e74878f91a4dde01d55fe29e70b542f1" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; の ID</target>
        </trans-unit>
        <trans-unit id="d7ecdcc9a073254188d013838ea2cd05cfb232fd" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; のアイデンティティ</target>
        </trans-unit>
        <trans-unit id="ff5736ff9442788a1bd6a07a6f1942f21ee0e0ff" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; の ID</target>
        </trans-unit>
        <trans-unit id="7460eb65d03a49632f7e5ea228f3d10021c309c4" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;ghc-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; の ID</target>
        </trans-unit>
        <trans-unit id="036d1bdfa0b3334e329d5335dac94c3cade01124" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;prelude#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; の ID</target>
        </trans-unit>
        <trans-unit id="e9a8044f8b5708bc7d69f87f32e2d6115a58e170" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; の ID</target>
        </trans-unit>
        <trans-unit id="de31daa9296519446ec20ea71e05cfd2b2ffa509" translate="yes" xml:space="preserve">
          <source>IdentityT</source>
          <target state="translated">IdentityT</target>
        </trans-unit>
        <trans-unit id="d55cb59cae5c6bdaf9dd412febcf10b5197dca0f" translate="yes" xml:space="preserve">
          <source>Ids with special behaviour</source>
          <target state="translated">特殊な動作を持つID</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="7165d0bd8b8d1acf3a7959ac10d5a5fbeb953852" translate="yes" xml:space="preserve">
          <source>If (D) did not exist then (A) and (C) would still be matched, but neither is most specific. In that case, the program would be rejected, unless &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt; is enabled, in which case it would be accepted and (A) or (C) would be chosen arbitrarily.</source>
          <target state="translated">（D）が存在しなかった場合でも、（A）と（C）は一致しますが、どちらも最も具体的ではありません。その場合、&lt;a href=&quot;#extension-IncoherentInstances&quot;&gt; &lt;code&gt;IncoherentInstances&lt;/code&gt; &lt;/a&gt;が有効になっていない限り、プログラムは拒否されます。その場合、プログラムは受け入れられ、（A）または（C）が任意に選択されます。</target>
        </trans-unit>
        <trans-unit id="ddb8e98916bf04f77cda2ecb54ffffb8aeaffeca" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type/kind variables can also be explicitly bound. For example:</source>
          <target state="translated">もし &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;が有効な、タイプ/種類の変数も明示的にバインドできます。例えば：</target>
        </trans-unit>
        <trans-unit id="da9178d1cdaa41cf10a914fbfe9e3f1cc2e99f91" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; is enabled, overloaded labels will be desugared using whatever &lt;code&gt;fromLabel&lt;/code&gt; function is in scope, rather than always using &lt;code&gt;GHC.OverloadedLabels.fromLabel&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt;が有効になっている場合、オーバーロードされたラベルは、fromLabelを使用して &lt;code&gt;fromLabel&lt;/code&gt; は、常に &lt;code&gt;GHC.OverloadedLabels.fromLabel&lt;/code&gt; を使用するのではなく、スコープ内の関数を使用してdesugaredされます。</target>
        </trans-unit>
        <trans-unit id="e7f41696d0e1b366335f05f546f0074d2d8f5534" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#ghc-flag--fprint-bind-result&quot;&gt;&lt;code&gt;-fprint-bind-result&lt;/code&gt;&lt;/a&gt; is set then GHCi will print the result of a statement if and only if:</source>
          <target state="translated">もし &lt;a href=&quot;#ghc-flag--fprint-bind-result&quot;&gt; &lt;code&gt;-fprint-bind-result&lt;/code&gt; &lt;/a&gt;設定されている場合に限り、その後、GHCiのは、文の結果を出力します：</target>
        </trans-unit>
        <trans-unit id="a12298741a44a56544916fcc3d1eeb39ec79ce67" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(&amp;gt;&amp;gt;)&lt;/code&gt; is defined it must be canonical (i.e. &lt;code&gt;(&amp;gt;&amp;gt;) = (*&amp;gt;)&lt;/code&gt;).</source>
          <target state="translated">もし &lt;code&gt;(&amp;gt;&amp;gt;)&lt;/code&gt; それは（つまり、正規のでなければならない定義されている &lt;code&gt;(&amp;gt;&amp;gt;) = (*&amp;gt;)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="37d0b772579ed80acd95d06e7921caed2a9f0731" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-odir ⟨dir⟩&lt;/code&gt; has been specified, then the object filename is ⟨dir⟩/⟨mod⟩.⟨osuf⟩, where ⟨mod⟩ is the module name with dots replaced by slashes. GHC will silently create the necessary directory structure underneath ⟨dir⟩, if it does not already exist.</source>
          <target state="translated">&lt;code&gt;-odir ⟨dir⟩&lt;/code&gt; が指定されている場合、オブジェクトのファイル名は⟨dir⟩/⟨mod⟩.⟨osuf⟩です。ここで、「mod」は、ドットがスラッシュに置き換えられたモジュール名です。GHCは、「dir」の下に必要なディレクトリ構造が存在しない場合、それをサイレントに作成します。</target>
        </trans-unit>
        <trans-unit id="6bec439461a8c0d2127d1c99af2a5820ee3a9cf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, each nonblank line returned by &lt;code&gt;getInputLine&lt;/code&gt; will be automatically added to the history.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; の場合、 &lt;code&gt;getInputLine&lt;/code&gt; によって返される空白以外の各行が自動的に履歴に追加されます。</target>
        </trans-unit>
        <trans-unit id="d72c7fde1442e5a18545f8980ce1eaec5905c5e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f a b&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f b c&lt;/code&gt; are both &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; then so is &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f a c&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f a b&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f b c&lt;/code&gt; 両方とも &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 、その後そうです &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f a c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e94e59d7cf4d9cb8563c18691722ce11c38c079d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; is uninhabited then any &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; that holds only values of type &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; is holding no values.</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; その後、任意の無人のさ &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 型の値のみを保持 &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; 何の値を保持されません。</target>
        </trans-unit>
        <trans-unit id="326c4fe588e95cc1235b78af1086ddc7bd85c512" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; were not lazy, &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt; would look strict in &lt;code&gt;y&lt;/code&gt; which would defeat the whole purpose of &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; 怠け者ではなかった、 &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt; に厳密になり &lt;code&gt;y&lt;/code&gt; の全体の目的台無しにしてしまう &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="610f1b238432a44cf8ce8bbb88c3bf824a5dd237" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; is used wrongly, then it may be that computations whose result that would otherwise be shared are re-evaluated every time they are used. Otherwise, the use of &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; is safe.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; が誤って使用された場合、他の方法では共有されるはずの計算結果が使用されるたびに再評価される可能性があります。それ以外の場合、 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; の使用は安全です。</target>
        </trans-unit>
        <trans-unit id="7c58158c9223c0688808fab7017305ac888c0083" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; encounters end-of-file at any other point while reading in a line, it is treated as a line terminator and the (partial) line is returned.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; の場合が行の読み取り中に他のポイントでファイルの終わりに遭遇した、それは行ターミネーターとして扱われ、（部分的な）行が返されます。</target>
        </trans-unit>
        <trans-unit id="21b4b2460fe3194b5c1e8e3d5532ed22dd7586f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; encounters end-of-file at any other point while reading in a line, it is treated as a line terminator and the (partial) line is returned.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; の場合が行の読み取り中に他のポイントでファイルの終わりに遭遇した、それは行ターミネーターとして扱われ、（部分的な）行が返されます。</target>
        </trans-unit>
        <trans-unit id="e320f20c42c7605270530cbc8962daed664fbb9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; and the line input is nonblank (i.e., is not all spaces), it will be automatically added to the history.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; == &lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;Trueの&lt;/a&gt;場合とライン入力（すなわち、すべてのスペースではない）空白でないで、それは自動的に履歴に追加されます。</target>
        </trans-unit>
        <trans-unit id="ef2cf8b46ce5b4adfb311cafcd49d769949e020c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;system-io#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; encounters end-of-file at any other point while reading in a line, it is treated as a line terminator and the (partial) line is returned.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; の場合が行の読み取り中に他のポイントでファイルの終わりに遭遇した、それは行ターミネーターとして扱われ、（部分的な）行が返されます。</target>
        </trans-unit>
        <trans-unit id="54c8bbd7c753a8e36c3603f2de4d4cd2a62cd77c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;em&gt;base&lt;/em&gt;&lt;/code&gt; is a power of 2, the result will be exact. In other cases (e.g. for &lt;code&gt;&lt;em&gt;base&lt;/em&gt; = 10#&lt;/code&gt;), the result &lt;em&gt;may&lt;/em&gt; be 1 digit too large sometimes.</source>
          <target state="translated">&lt;code&gt;&lt;em&gt;base&lt;/em&gt;&lt;/code&gt; が2の累乗である場合、結果は正確になります。その他の場合（例： &lt;code&gt;&lt;em&gt;base&lt;/em&gt; = 10#&lt;/code&gt; ）、結果&lt;em&gt;は&lt;/em&gt; 1桁が大きすぎる場合があります。</target>
        </trans-unit>
        <trans-unit id="8a13e850c195084652095c4cca81184cca1bc111" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;M&lt;/code&gt; imports multiple modules, then there will be multiple lines with &lt;code&gt;M.o&lt;/code&gt; as the target.</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; が複数のモジュールをインポートする場合、 &lt;code&gt;M.o&lt;/code&gt; で複数の行が存在しますをターゲット。</target>
        </trans-unit>
        <trans-unit id="c1c19c1db68e46617d35c0326dd5168514a0df2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is empty, block until it becomes full. Then read its contents without modifying the MVar, without possibility of intervention from other threads.</source>
          <target state="translated">&lt;code&gt;MVar#&lt;/code&gt; の場合が空のは、満杯になるまでブロックします。次に、MVarを変更せずに、他のスレッドからの介入の可能性なしに、その内容を読み取ります。</target>
        </trans-unit>
        <trans-unit id="83f91e64cabad1b57cc078065479e2f730107802" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is empty, block until it becomes full. Then remove and return its contents, and set it empty.</source>
          <target state="translated">&lt;code&gt;MVar#&lt;/code&gt; が空の場合は、満杯になるまでブロックします。次に、その内容を削除して返し、空に設定します。</target>
        </trans-unit>
        <trans-unit id="00f25de3697afd87eb6d27164088e4e76d5903b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is empty, immediately return with integer 0 and value undefined. Otherwise, return with integer 1 and contents of &lt;code&gt;MVar#&lt;/code&gt;, and set &lt;code&gt;MVar#&lt;/code&gt; empty.</source>
          <target state="translated">&lt;code&gt;MVar#&lt;/code&gt; が空の場合、整数0と値undefinedですぐに戻ります。それ以外の場合は、整数1と &lt;code&gt;MVar#&lt;/code&gt; の内容で戻り、 &lt;code&gt;MVar#&lt;/code&gt; を空に設定します。</target>
        </trans-unit>
        <trans-unit id="ebfef89b340df038e270ba036f34b0519cbc0ac6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is empty, immediately return with integer 0 and value undefined. Otherwise, return with integer 1 and contents of &lt;code&gt;MVar#&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MVar#&lt;/code&gt; が空の場合、整数0と値undefinedですぐに戻ります。それ以外の場合は、整数1と &lt;code&gt;MVar#&lt;/code&gt; の内容を返します。ます。</target>
        </trans-unit>
        <trans-unit id="de738ce23865dd45047c99b18298df90a9c1de7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is full, block until it becomes empty. Then store value arg as its new contents.</source>
          <target state="translated">&lt;code&gt;MVar#&lt;/code&gt; の場合がいっぱいのは、空になるまでブロックします。次に、値argを新しいコンテンツとして格納します。</target>
        </trans-unit>
        <trans-unit id="f0ea9c86d00bfb75f1a61c6b64453776a80bc752" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is full, immediately return with integer 0. Otherwise, store value arg as &lt;code&gt;MVar#&lt;/code&gt;'s new contents, and return with integer 1.</source>
          <target state="translated">&lt;code&gt;MVar#&lt;/code&gt; がいっぱいの場合は、すぐに整数0を返します。それ以外の場合は、値の引数を &lt;code&gt;MVar#&lt;/code&gt; として保存します。の新しいコンテンツし、整数1を返します。</target>
        </trans-unit>
        <trans-unit id="2b9bf43f23f5bb273c3cc1f6ac0c3d420ae5cb5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RTLD_DEFAULT&lt;/code&gt; がプラットフォームで定義されていない場合、 &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; に減少します。</target>
        </trans-unit>
        <trans-unit id="06453765ecd11a2317b668a85556dad5d95cee4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; は、ご使用のプラットフォーム上で定義されていない、 &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; に減少し &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c87e13d090df879361d15dfa79e405cd9085828" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RTLD_DEFAULT&lt;/code&gt; がプラットフォームで定義されていない場合、 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; に減少します。</target>
        </trans-unit>
        <trans-unit id="206bdce74c7401df8dd34a4eb0c73875661f2142" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; は、ご使用のプラットフォーム上で定義されていない、 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; に減少し &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3c2aadabafad2cf8c71f374eecfaa7c9542d06d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RTLD_DEFAULT&lt;/code&gt; がプラットフォームで定義されていない場合、 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; に減少します。</target>
        </trans-unit>
        <trans-unit id="83d5752a7d1aceda6754825ba636c32044c8b3bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; は、ご使用のプラットフォーム上で定義されていない、 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; に減少し &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5275bc4d51e6899e6fad22c83eb521ad2006efe4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blk&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;WNOHANG&lt;/code&gt; is set in the options for &lt;code&gt;waitpid&lt;/code&gt;, otherwise not. If &lt;code&gt;stopped&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;WUNTRACED&lt;/code&gt; is set in the options for &lt;code&gt;waitpid&lt;/code&gt;, otherwise not.</source>
          <target state="translated">場合は &lt;code&gt;blk&lt;/code&gt; ある &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; の場合、 &lt;code&gt;WNOHANG&lt;/code&gt; がするためのオプションに設定されている &lt;code&gt;waitpid&lt;/code&gt; をそれ以外の場合は、ありません。場合は &lt;code&gt;stopped&lt;/code&gt; ている &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 、その後、 &lt;code&gt;WUNTRACED&lt;/code&gt; をするためのオプションに設定されている &lt;code&gt;waitpid&lt;/code&gt; をそれ以外の場合は、ありません。</target>
        </trans-unit>
        <trans-unit id="947ea7c1dfd7ce4b41e18914f4032b10928d1f59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blk&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;WNOHANG&lt;/code&gt; is set in the options for &lt;code&gt;waitpid&lt;/code&gt;, otherwise not. If &lt;code&gt;stopped&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;WUNTRACED&lt;/code&gt; is set in the options for &lt;code&gt;waitpid&lt;/code&gt;, otherwise not.</source>
          <target state="translated">場合は &lt;code&gt;blk&lt;/code&gt; ある &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; の場合、 &lt;code&gt;WNOHANG&lt;/code&gt; がするためのオプションに設定されている &lt;code&gt;waitpid&lt;/code&gt; をそれ以外の場合は、ありません。場合は &lt;code&gt;stopped&lt;/code&gt; ている &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 、その後、 &lt;code&gt;WUNTRACED&lt;/code&gt; をするためのオプションに設定されている &lt;code&gt;waitpid&lt;/code&gt; をそれ以外の場合は、ありません。</target>
        </trans-unit>
        <trans-unit id="a08b722470ddafe8fb8c09c93deed2c332b705cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is also a &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;, it should satisfy</source>
          <target state="translated">場合 &lt;code&gt;f&lt;/code&gt; がまたある &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 、それが満たすべき</target>
        </trans-unit>
        <trans-unit id="c98343bbca185d60c1ee11e55600855a284be984" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is also a &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;, it should satisfy</source>
          <target state="translated">場合 &lt;code&gt;f&lt;/code&gt; がまたある &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 、それが満たすべき</target>
        </trans-unit>
        <trans-unit id="a539250d2be5c33120a88a56e298e7c403b47812" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is also a &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;, it should satisfy</source>
          <target state="translated">場合 &lt;code&gt;f&lt;/code&gt; がまたある &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 、それが満たすべき</target>
        </trans-unit>
        <trans-unit id="5eac9f125314dfa3f7885b5b45714df2e1cf5559" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is both &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt; then by the time you factor in the laws of each of those classes, it can't actually use its argument in any meaningful capacity.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt; の両方である場合、これらの各クラスの法則を考慮に入れるまでに、意味のある容量でその引数を実際に使用することはできません。</target>
        </trans-unit>
        <trans-unit id="6f7d12845339fe8cd3cb3ac36c2fb96a946b74fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が非常に安価な場合（たとえば、レコードセレクターや &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; など）、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; と比較）はsortOn fよりも高速になります。</target>
        </trans-unit>
        <trans-unit id="931888dcad242b41a99c52e3454ca1021c558949" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が非常に安価な場合（たとえば、レコードセレクターや &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; など）、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; よりも高速になります。</target>
        </trans-unit>
        <trans-unit id="906096b1295440d05beb1594c0fb7469bf723e57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が非常に安価な場合（たとえば、レコードセレクターや &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; など）、 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; と比較）はsortOn fよりも高速になります。</target>
        </trans-unit>
        <trans-unit id="805ac8206a6b088f57d9c958aae524c515330e81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が非常に安価な場合（たとえば、レコードセレクターや &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; など）、 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; よりも高速になります。</target>
        </trans-unit>
        <trans-unit id="5b40996ba5b36b066518d58ee4318ccc60ee6eaa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が非常に安い場合（たとえば、レコードセレクターや &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; ）、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; と比較）はsortOnfよりも高速になります。</target>
        </trans-unit>
        <trans-unit id="bdd33339e864a1994b487c054b99bec9522d7f84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;f&lt;/code&gt; は（例えばレコードセレクタ、または非常に安価である &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; ）、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; より速くよりなり &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb76c568526f84f6e23c00ea7ec6b9359af0d64e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が非常に安い場合（たとえば、レコードセレクターや &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; ）、 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; と比較）はsortOnfよりも高速になります。</target>
        </trans-unit>
        <trans-unit id="f2f6815c2e1b653f81af4e4ff845f99b11b6b06d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;f&lt;/code&gt; は（例えばレコードセレクタ、または非常に安価である &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; ）、 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; より速くよりなり &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9adf0f8908e10c9f90956ffd3ed4fc92f31eb5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fail&lt;/code&gt; is defined it must be canonical (i.e. &lt;code&gt;fail = Control.Monad.Fail.fail&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;fail&lt;/code&gt; が定義されている場合、それは標準的でなければなりません（つまり、 &lt;code&gt;fail = Control.Monad.Fail.fail&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="15cf615fdb6b04b2196b63a29a9332d038e92d17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hdl&lt;/code&gt; is block- or line-buffered, then seeking to a position which is not in the current buffer will first cause any items in the output buffer to be written to the device, and then cause the input buffer to be discarded. Some handles may not be seekable (see &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt;), or only support a subset of the possible positioning operations (for instance, it may only be possible to seek to the end of a tape, or to a positive offset from the beginning or current position). It is not possible to set a negative I/O position, or for a physical file, an I/O position beyond the current end-of-file.</source>
          <target state="translated">場合 &lt;code&gt;hdl&lt;/code&gt; ブロック-またはラインバッファリングされ、その後、現在のバッファにない位置までシークする最初のデバイスに書き込まれる、出力バッファ内の任意のアイテム原因、及び、入力バッファが破棄されます。一部のハンドルはシークできない（ &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt; を参照）か、可能な位置決め操作のサブセットのみをサポートする場合があります（たとえば、テープの最後まで、または最初または現在の位置からの正のオフセットまでしかシークできない場合があります） ）。負のI / O位置、または物理ファイルの場合、現在のファイルの終わりを超えるI / O位置を設定することはできません。</target>
        </trans-unit>
        <trans-unit id="5c8a6eee3327c93a8398e06086b0787394abd668" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hdl&lt;/code&gt; is block- or line-buffered, then seeking to a position which is not in the current buffer will first cause any items in the output buffer to be written to the device, and then cause the input buffer to be discarded. Some handles may not be seekable (see &lt;code&gt;&lt;a href=&quot;system-io#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt;), or only support a subset of the possible positioning operations (for instance, it may only be possible to seek to the end of a tape, or to a positive offset from the beginning or current position). It is not possible to set a negative I/O position, or for a physical file, an I/O position beyond the current end-of-file.</source>
          <target state="translated">場合 &lt;code&gt;hdl&lt;/code&gt; ブロック-またはラインバッファリングされ、その後、現在のバッファにない位置までシークする最初のデバイスに書き込まれる、出力バッファ内の任意のアイテム原因、及び、入力バッファが破棄されます。一部のハンドルはシークできない（ &lt;code&gt;&lt;a href=&quot;system-io#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt; を参照）か、可能な位置決め操作のサブセットのみをサポートする場合があります（たとえば、テープの最後まで、または最初または現在の位置からの正のオフセットまでしかシークできない場合があります） ）。負のI / O位置、または物理ファイルの場合、現在のファイルの終わりを超えるI / O位置を設定することはできません。</target>
        </trans-unit>
        <trans-unit id="6ef3f214074b587d958bb04dc92f38b70020c8f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ignore&lt;/code&gt;, &lt;code&gt;./.ghci&lt;/code&gt; files will be ignored (sourcing untrusted local scripts is a security risk). The default is &lt;code&gt;source&lt;/code&gt;. Set this directive in your user &lt;code&gt;.ghci&lt;/code&gt; script, i.e. before the local script would be sourced.</source>
          <target state="translated">場合は &lt;code&gt;ignore&lt;/code&gt; 、 &lt;code&gt;./.ghci&lt;/code&gt; ファイルは無視されます（信頼できないローカルスクリプトを調達することは、セキュリティ上のリスクです）。デフォルトは &lt;code&gt;source&lt;/code&gt; です。このディレクティブは、ユーザーの &lt;code&gt;.ghci&lt;/code&gt; スクリプトで、つまりローカルスクリプトがソースされる前に設定します。</target>
        </trans-unit>
        <trans-unit id="0345953305b2b9f4ea94ff39c9fed5b790ac50f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mappend&lt;/code&gt; is defined it must be canonical (i.e. &lt;code&gt;mappend = (Data.Semigroup.&amp;lt;&amp;gt;)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;mappend&lt;/code&gt; が定義されている場合、それは正準である必要があります（すなわち &lt;code&gt;mappend = (Data.Semigroup.&amp;lt;&amp;gt;)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fb896d3d56035749898d473a3ff0398ee85a2441" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; would cause the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to begin inside a surrogate pair, the beginning of the suffix will be advanced by one additional &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; unit to maintain its validity.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; をサロゲートペアの内側で開始する場合、サフィックスの先頭は、その有効性を維持するために1つの追加の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 単位だけ進められます。</target>
        </trans-unit>
        <trans-unit id="860162bde8907826a2c5a3fcdedbfb920738c4b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; would cause the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to end inside a surrogate pair, the end of the prefix will be advanced by one additional &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; unit to maintain its validity.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; をサロゲートペアの内部で終了させる場合、プレフィックスの末尾は、その有効性を維持するために1つの追加の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 単位だけ進められます。</target>
        </trans-unit>
        <trans-unit id="226e4123ccd5bdaffb4ec80558af633a764b0837" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nel&lt;/code&gt; is not defined, this may be built out of other capabilities.</source>
          <target state="translated">&lt;code&gt;nel&lt;/code&gt; が定義されていない場合、これは他の機能から構築されている可能性があります。</target>
        </trans-unit>
        <trans-unit id="64d4d1d892b2f78b4eac4a90be4fe3562658fe6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; fails and consumes some input, so does &lt;code&gt;lookAhead&lt;/code&gt;. Combine with &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; if this is undesirable.</source>
          <target state="translated">場合は &lt;code&gt;p&lt;/code&gt; 失敗し、いくつかの入力を消費し、そう &lt;code&gt;lookAhead&lt;/code&gt; 。これが望ましくない場合は、 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; と組み合わせてください。</target>
        </trans-unit>
        <trans-unit id="3537d71db5bdf66b5e84e584bddb563361f13d18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; fails and consumes some input, so does &lt;code&gt;lookAhead&lt;/code&gt;. Combine with &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; if this is undesirable.</source>
          <target state="translated">場合は &lt;code&gt;p&lt;/code&gt; 失敗し、いくつかの入力を消費し、そう &lt;code&gt;lookAhead&lt;/code&gt; 。これが望ましくない場合は、 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; と組み合わせてください。</target>
        </trans-unit>
        <trans-unit id="13ee3fdf69deef0295af859365ce7e178691bbfc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return&lt;/code&gt; is defined it must be canonical (i.e. &lt;code&gt;return = pure&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; が定義されている場合、それは標準的である必要があります（つまり &lt;code&gt;return = pure&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="df692bac65da2783906b8b3e140d687e86cb3e84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sn1 :: StableName&lt;/code&gt; and &lt;code&gt;sn2 :: StableName&lt;/code&gt; and &lt;code&gt;sn1 == sn2&lt;/code&gt; then &lt;code&gt;sn1&lt;/code&gt; and &lt;code&gt;sn2&lt;/code&gt; were created by calls to &lt;code&gt;makeStableName&lt;/code&gt; on the same object.</source>
          <target state="translated">場合 &lt;code&gt;sn1 :: StableName&lt;/code&gt; と &lt;code&gt;sn2 :: StableName&lt;/code&gt; と &lt;code&gt;sn1 == sn2&lt;/code&gt; その後、 &lt;code&gt;sn1&lt;/code&gt; と &lt;code&gt;sn2&lt;/code&gt; への呼び出しによって作成された &lt;code&gt;makeStableName&lt;/code&gt; 同じオブジェクト上。</target>
        </trans-unit>
        <trans-unit id="e2ad7372f58041f5b2d3a204387a830ce9ae4dd8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t&lt;/code&gt; is less than zero, then &lt;code&gt;hWaitForInput&lt;/code&gt; waits indefinitely.</source>
          <target state="translated">場合 &lt;code&gt;t&lt;/code&gt; がゼロ未満である場合、 &lt;code&gt;hWaitForInput&lt;/code&gt; は無期限に待ちます。</target>
        </trans-unit>
        <trans-unit id="6557dd6d42d307abdecff79045e463256f2df340" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;uid&lt;/code&gt; or &lt;code&gt;gid&lt;/code&gt; is specified as -1, then that ID is not changed.</source>
          <target state="translated">場合は &lt;code&gt;uid&lt;/code&gt; または &lt;code&gt;gid&lt;/code&gt; -1として指定され、その後、IDは変更されないこと。</target>
        </trans-unit>
        <trans-unit id="8c23a4167afefd24de1f72d0b1f0f0c9e3f11603" translate="yes" xml:space="preserve">
          <source>If Ctrl-C is pressed during the given action, throw an exception of type &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">指定されたアクション中にCtrl-Cが押された場合、 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt; タイプの例外をスローします。例えば：</target>
        </trans-unit>
        <trans-unit id="821902f7f945f9df9b4c26649b68c4f807408798" translate="yes" xml:space="preserve">
          <source>If GHC didn&amp;rsquo;t have to compile programs that run in the real world, that would be the end of the story. But representation polymorphism can cause quite a bit of trouble for GHC&amp;rsquo;s code generator. Consider</source>
          <target state="translated">GHCが現実の世界で実行されるプログラムをコンパイルする必要がなければ、話はこれで終わりです。しかし、表現ポリモーフィズムはGHCのコードジェネレーターにかなりのトラブルを引き起こす可能性があります。検討する</target>
        </trans-unit>
        <trans-unit id="20ef5d466c86ecef8e8961310c403330cf2b508d" translate="yes" xml:space="preserve">
          <source>If GHC persists in being a bad memory citizen, please report it as a bug.</source>
          <target state="translated">GHCが記憶力の悪い市民であることが続く場合は、バグとして報告してください。</target>
        </trans-unit>
        <trans-unit id="220d5b83850f635db8c322690e19f967385f577b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; references a file descriptor, attempt to lock contents of the underlying file in appropriate mode. If the file is already locked in incompatible mode, this function blocks until the lock is established. The lock is automatically released upon closing a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; がファイル記述子を参照する場合は、適切なモードで基本となるファイルの内容をロックしてみてください。ファイルが互換性のないモードですでにロックされている場合、この関数はロックが確立されるまでブロックします。 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; を閉じると、ロックは自動的に解除されます。</target>
        </trans-unit>
        <trans-unit id="378447cdb747f861c2af8b9d9aa5411c32ef8aca" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; surrounds a constructor with GADT syntax, then the &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;em&gt;all&lt;/em&gt; type variables used in the constructor. For example:</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; が GADT構文を持つコンストラクタを取り囲み、そして &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; は定量化されます&lt;em&gt;すべて&lt;/em&gt;コンストラクタで使用される型変数を。例えば：</target>
        </trans-unit>
        <trans-unit id="fc4cc18d4c1e7b851b50db0a714da14e3509176a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; surrounds a constructor with vanilla syntax, then the &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will only quantify &lt;em&gt;existential&lt;/em&gt; type variables. For example:</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; はバニラの構文を使用してコンストラクタを取り囲み、そして &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; は唯一の定量化します&lt;em&gt;実存&lt;/em&gt;型変数を。例えば：</target>
        </trans-unit>
        <trans-unit id="044539454a09356f28e0ae13ed4c626569d75f51" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; surrounds a constructor with GADT syntax, then the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;em&gt;all&lt;/em&gt; type variables used in the constructor. For example:</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; が GADT構文を持つコンストラクタを取り囲み、そして &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; は定量化されます&lt;em&gt;、すべての&lt;/em&gt;コンストラクタで使用される型変数を。例えば：</target>
        </trans-unit>
        <trans-unit id="722ab6109c5e8f9f7714e4e2a9d91f17d7a90602" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; surrounds a constructor with vanilla syntax, then the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will only quantify &lt;em&gt;existential&lt;/em&gt; type variables. For example:</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; はバニラの構文を使用してコンストラクタを包囲し、その後、 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 意志だけ定量化&lt;em&gt;実存&lt;/em&gt;型変数を。例えば：</target>
        </trans-unit>
        <trans-unit id="b34d5c83b4ecf116da3871cc1a290a189d5d74ad" translate="yes" xml:space="preserve">
          <source>If a C function prototype has &lt;code&gt;t&lt;/code&gt; as an argument or result type, the use of &lt;code&gt;CT&lt;/code&gt; in the corresponding position in a foreign declaration permits the Haskell program to access the full range of values encoded by the C type; and conversely, any Haskell value for &lt;code&gt;CT&lt;/code&gt; has a valid representation in C.</source>
          <target state="translated">C関数プロトタイプに引数または結果の型として &lt;code&gt;t&lt;/code&gt; がある場合、外部宣言の対応する位置で &lt;code&gt;CT&lt;/code&gt; を使用すると、HaskellプログラムはC型によってエンコードされた値の全範囲にアクセスできます。逆に、 &lt;code&gt;CT&lt;/code&gt; の Haskell値、Cで有効な表現を持っています。</target>
        </trans-unit>
        <trans-unit id="f2c29459b71d15ab93a1c9fd6e056294e61bdf3d" translate="yes" xml:space="preserve">
          <source>If a LHS type variable that is declared as injective is not mentioned on injective position in the RHS GHC reports that the type family is not injective. Injective position means either argument to a type constructor or injective argument to a type family.</source>
          <target state="translated">injectiveと宣言されているLHS型変数がRHSのinjective positionに言及されていない場合、GHCは型ファミリがinjectiveではないことを報告します。注入位置とは、型コンストラクタへの引数、または型ファミリへの注入位置のいずれかを意味します。</target>
        </trans-unit>
        <trans-unit id="b02289337799e172c6434a2959c4692b153f59ab" translate="yes" xml:space="preserve">
          <source>If a LHS type variable that is declared as injective is not mentioned on injective position in the RHS GHC reports that the type family is not injective. Injective position means either argument to a type constructor or injective argument to a type family. Type inference can potentially loop when looking under injective type families in the RHS, so this requires &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt;; GHC suggests enabling the flag when it is necessary.</source>
          <target state="translated">単射として宣言されたLHSタイプ変数が、RHS GHCの単射位置に記載されていない場合、タイプファミリーは単射ではないと報告されます。単射位置とは、型コンストラクターへの引数または型族への単射引数のいずれかを意味します。RHSで単射型族を調べると、型推論がループする可能性があるため、これには&lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt;が必要です。GHCは、必要に応じてフラグを有効にすることを提案しています。</target>
        </trans-unit>
        <trans-unit id="df1c26c5e5d7b0e6a433e2ce679bce2faf2ee71c" translate="yes" xml:space="preserve">
          <source>If a RHS of a type family equation is a bare type variable we require that all LHS variables (including implicit kind variables) are also bare. In other words, this has to be a sole equation of that type family and it has to cover all possible patterns. If the patterns are not covering GHC reports that the type family is not injective.</source>
          <target state="translated">型族方程式のRHSが裸の型変数である場合、すべてのLHS変数(暗黙の型変数を含む)も裸であることを要求します。言い換えれば、これはその型族の唯一の方程式であり、すべての可能なパターンをカバーしていなければなりません。パターンがカバーされていない場合、GHCはその型ファミリーが注入的ではないことを報告します。</target>
        </trans-unit>
        <trans-unit id="aae1bcb9b1cecea16f3e3634cf7f4ebbfdfb031c" translate="yes" xml:space="preserve">
          <source>If a RHS of a type family equation is a type family application GHC reports that the type family is not injective.</source>
          <target state="translated">タイプファミリ式のRHSがタイプファミリ応用の場合、GHCはタイプファミリが注入されていないことを報告する。</target>
        </trans-unit>
        <trans-unit id="db25b8f3188747af958388f20acf6bd09afc1781" translate="yes" xml:space="preserve">
          <source>If a call is annotated as &lt;code&gt;interruptible&lt;/code&gt; and the program was multithreaded, the call may be interrupted in the event that the Haskell thread receives an exception. The mechanism by which the interrupt occurs is platform dependent, but is intended to cause blocking system calls to return immediately with an interrupted error code. The underlying operating system thread is not to be destroyed. See &lt;a href=&quot;#ffi-interruptible&quot;&gt;Interruptible foreign calls&lt;/a&gt; for more details.</source>
          <target state="translated">呼び出しに &lt;code&gt;interruptible&lt;/code&gt; 注釈が付けられていて、プログラムがマルチスレッド化されている場合、Haskellスレッドが例外を受け取った場合、呼び出しは中断される可能性があります。割り込みが発生するメカニズムはプラットフォームに依存しますが、ブロックされたシステムコールが割り込みエラーコードですぐに戻るようにすることを目的としています。基盤となるオペレーティングシステムスレッドは破棄されません。詳細については、&lt;a href=&quot;#ffi-interruptible&quot;&gt;割り込み可能な外部呼び出し&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1c05c3def7562a739048b872d41b6d6eb05d7a90" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns a position &lt;code&gt;p&lt;/code&gt;, then computation &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetPosn&quot;&gt;hSetPosn&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt; sets the position of &lt;code&gt;hdl&lt;/code&gt; to the position it held at the time of the call to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; の呼び出しが位置 &lt;code&gt;p&lt;/code&gt; を返す場合、計算 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetPosn&quot;&gt;hSetPosn&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; は &lt;code&gt;hdl&lt;/code&gt; の位置を &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt; の呼び出し時に保持していた位置に設定します。</target>
        </trans-unit>
        <trans-unit id="ba018d0d62ee53ce6b9db280035b85aedadefa2f" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;&lt;a href=&quot;system-io#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns a position &lt;code&gt;p&lt;/code&gt;, then computation &lt;code&gt;&lt;a href=&quot;system-io#v:hSetPosn&quot;&gt;hSetPosn&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt; sets the position of &lt;code&gt;hdl&lt;/code&gt; to the position it held at the time of the call to &lt;code&gt;&lt;a href=&quot;system-io#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; の呼び出しが位置 &lt;code&gt;p&lt;/code&gt; を返す場合、計算 &lt;code&gt;&lt;a href=&quot;system-io#v:hSetPosn&quot;&gt;hSetPosn&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; は &lt;code&gt;hdl&lt;/code&gt; の位置を &lt;code&gt;&lt;a href=&quot;system-io#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt; の呼び出し時に保持していた位置に設定します。</target>
        </trans-unit>
        <trans-unit id="b6f98223cfb0eee3633d62b814584044de61b78c" translate="yes" xml:space="preserve">
          <source>If a constructor has no arguments, then &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; is used as its representation. For example the representation of &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; is</source>
          <target state="translated">コンストラクターに引数がない場合、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; がその表現として使用されます。たとえば &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; の表現は</target>
        </trans-unit>
        <trans-unit id="a9f3d133e06321809c86bac4a4d58b06416b36bf" translate="yes" xml:space="preserve">
          <source>If a declaration occurs in multiple inherited signatures, they will be &lt;em&gt;merged&lt;/em&gt; together. For values, we require that the types from both signatures match exactly; however, other declarations may merge in more interesting ways. The merging operation in these cases has the effect of textually replacing all occurrences of the old name with a reference to the new, merged declaration. For example, if we have the following two signatures:</source>
          <target state="translated">宣言が継承された複数の署名で発生した場合、それらは&lt;em&gt;マージ&lt;/em&gt;されます&lt;em&gt;&lt;/em&gt;一緒されます。値については、両方のシグネチャの型が完全に一致する必要があります。ただし、他の宣言はより興味深い方法でマージされる場合があります。これらの場合のマージ操作には、古い名前のすべての出現箇所を、新しくマージされた宣言への参照にテキストで置き換える効果があります。たとえば、次の2つの署名があるとします。</target>
        </trans-unit>
        <trans-unit id="8cb4f4cbaa3cf83a5c5f2e268c4fafffea33710e" translate="yes" xml:space="preserve">
          <source>If a field has a higher-rank or existential type, the corresponding &lt;code&gt;HasField&lt;/code&gt; constraint will not be solved automatically (as described above), but in the interests of simplicity we do not permit users to define their own instances either. If a field is not in scope, the corresponding instance is still prohibited, to avoid conflicts in downstream modules.</source>
          <target state="translated">フィールドのランクが上位または存在する場合、対応する &lt;code&gt;HasField&lt;/code&gt; 制約は（上記のように）自動的に解決されませんが、簡単にするために、ユーザーが独自のインスタンスを定義することを許可していません。フィールドがスコープ内にない場合、ダウンストリームモジュールでの競合を回避するために、対応するインスタンスは引き続き禁止されます。</target>
        </trans-unit>
        <trans-unit id="a8eaf7aebcd40fba7a5385d613e9ae5cec1a85c4" translate="yes" xml:space="preserve">
          <source>If a finalizer throws an exception, subsequent finalizers that had been queued to run after it do not get run. This behavior may change in a future release. See issue &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/ticket/13167&quot;&gt;13167&lt;/a&gt; on the issue tracker. Writing a finalizer that throws exceptions is discouraged.</source>
          <target state="translated">ファイナライザが例外をスローした場合、その後に実行するためにキューに入れられていた後続のファイナライザは実行されません。この動作は、将来のリリースで変更される可能性があります。課題トラッカーの課題&lt;a href=&quot;https://ghc.haskell.org/trac/ghc/ticket/13167&quot;&gt;13167&lt;/a&gt;を参照してください。例外をスローするファイナライザを作成することはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="e1b752cff9e74d6e08fc8898cd07eefb082da1bf" translate="yes" xml:space="preserve">
          <source>If a module was then to import &lt;code&gt;MyNum&lt;/code&gt; from &lt;code&gt;Example&lt;/code&gt;, it would also import the pattern synonym &lt;code&gt;Zero&lt;/code&gt;.</source>
          <target state="translated">モジュールが &lt;code&gt;Example&lt;/code&gt; から &lt;code&gt;MyNum&lt;/code&gt; をインポートする場合、パターンの同義語 &lt;code&gt;Zero&lt;/code&gt; もインポートします。</target>
        </trans-unit>
        <trans-unit id="893611b3da8b13dca82bbde8d7e30b09c03ec327" translate="yes" xml:space="preserve">
          <source>If a number is given before the command, then the commands are run when the specified breakpoint (only) is hit. This can be quite useful: for example, &lt;code&gt;:set stop 1 :continue&lt;/code&gt; effectively disables breakpoint 1, by running &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt;&lt;code&gt;:continue&lt;/code&gt;&lt;/a&gt; whenever it is hit (although GHCi will still emit a message to say the breakpoint was hit). What&amp;rsquo;s more, with cunning use of &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt;&lt;code&gt;:cmd&lt;/code&gt;&lt;/a&gt; you can use &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt;&lt;code&gt;:set stop&lt;/code&gt;&lt;/a&gt; to implement conditional breakpoints:</source>
          <target state="translated">コマンドの前に数値が指定されている場合、指定されたブレークポイント（のみ）に到達するとコマンドが実行されます。これは非常に便利です。たとえば、 &lt;code&gt;:set stop 1 :continue&lt;/code&gt; は、ヒットするたびに&lt;a href=&quot;#ghci-cmd-:continue&quot;&gt; &lt;code&gt;:continue&lt;/code&gt; を&lt;/a&gt;実行することにより、ブレークポイント1を効果的に無効にします（ただし、GHCiはブレークポイントがヒットしたことを示すメッセージを引き続き出力します）。さらに、&lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt; &lt;code&gt;:cmd&lt;/code&gt; の巧妙&lt;/a&gt;な使用により、&lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt; &lt;code&gt;:set stop&lt;/code&gt; &lt;/a&gt;を使用して条件付きブレークポイントを実装できます。</target>
        </trans-unit>
        <trans-unit id="d7c3aca378dedbdc91ecccb72c921e9d9ef55af4" translate="yes" xml:space="preserve">
          <source>If a number is given before the command, then the commands are run when the specified breakpoint (only) is hit. This can be quite useful: for example, &lt;code&gt;:set stop 1 :continue&lt;/code&gt; effectively disables breakpoint 1, by running &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt;&lt;code&gt;:continue&lt;/code&gt;&lt;/a&gt; whenever it is hit In this case GHCi will still emit a message to say the breakpoint was hit. If you don&amp;rsquo;t want such a message, you can use the &lt;a href=&quot;#ghci-cmd-:disable&quot;&gt;&lt;code&gt;:disable&lt;/code&gt;&lt;/a&gt; command. What&amp;rsquo;s more, with cunning use of &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt;&lt;code&gt;:cmd&lt;/code&gt;&lt;/a&gt; you can use &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt;&lt;code&gt;:set stop&lt;/code&gt;&lt;/a&gt; to implement conditional breakpoints:</source>
          <target state="translated">コマンドの前に番号が指定されている場合、指定されたブレークポイント（のみ）がヒットしたときにコマンドが実行されます。これは非常に便利です。たとえば、 &lt;code&gt;:set stop 1 :continue&lt;/code&gt; は、ブレークポイント1がヒットするたびに&lt;a href=&quot;#ghci-cmd-:continue&quot;&gt; &lt;code&gt;:continue&lt;/code&gt; を&lt;/a&gt;実行することにより、ブレークポイント1を効果的に無効にします。この場合、GHCiはブレークポイントがヒットしたことを示すメッセージを出力します。このようなメッセージが必要ない場合は、&lt;a href=&quot;#ghci-cmd-:disable&quot;&gt; &lt;code&gt;:disable&lt;/code&gt; &lt;/a&gt;コマンドを使用できます。使用を狡猾で、より多くの何&lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt; &lt;code&gt;:cmd&lt;/code&gt; を&lt;/a&gt;使用できる&lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt; &lt;code&gt;:set stop&lt;/code&gt; &lt;/a&gt;条件付きブレークポイントを実装します：</target>
        </trans-unit>
        <trans-unit id="1469d9b993c79ed9fd15d1a5a0d6060aaa153a72" translate="yes" xml:space="preserve">
          <source>If a record field does not have a selector function because its type would allow an existential variable to escape, the corresponding &lt;code&gt;HasField&lt;/code&gt; constraint will not be solved. For example,</source>
          <target state="translated">レコードフィールドにセレクター関数がない場合、そのタイプによって実存変数をエスケープできるため、対応する &lt;code&gt;HasField&lt;/code&gt; 制約は解決されません。例えば、</target>
        </trans-unit>
        <trans-unit id="164c3702f74e30bae3bcb4e2249a8dd0868593c2" translate="yes" xml:space="preserve">
          <source>If a record field has a polymorphic type (and hence the selector function is higher-rank), the corresponding &lt;code&gt;HasField&lt;/code&gt; constraint will not be solved, because doing so would violate the functional dependency on &lt;code&gt;HasField&lt;/code&gt; and/or require impredicativity. For example,</source>
          <target state="translated">レコードフィールドにポリモーフィックタイプがある（したがって、セレクター関数のランクが高い）場合、対応する &lt;code&gt;HasField&lt;/code&gt; 制約は解決されません。これを行うと、 &lt;code&gt;HasField&lt;/code&gt; への機能依存性に違反したり、予測性が要求されたりするためです。例えば、</target>
        </trans-unit>
        <trans-unit id="afc8e267ccbb00ce682890bda99554fbfc2f7a86" translate="yes" xml:space="preserve">
          <source>If a record type has an old-fashioned datatype context, the &lt;code&gt;HasField&lt;/code&gt; constraint will be reduced to solving the constraints from the context. For example,</source>
          <target state="translated">レコード型に旧式のデータ型コンテキストがある場合、 &lt;code&gt;HasField&lt;/code&gt; 制約はコンテキストからの制約の解決に削減されます。例えば、</target>
        </trans-unit>
        <trans-unit id="608bb4b5a475db6a4953e34347efc01b12ab3dbd" translate="yes" xml:space="preserve">
          <source>If a thread makes a foreign call (and the call is not marked &lt;code&gt;unsafe&lt;/code&gt;), then other Haskell threads in the program will continue to run while the foreign call is in progress. Additionally, &lt;code&gt;foreign export&lt;/code&gt;ed Haskell functions may be called from multiple OS threads simultaneously. See &lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;Multi-threading and the FFI&lt;/a&gt;.</source>
          <target state="translated">スレッドが外部呼び出しを行った場合（その呼び出しが &lt;code&gt;unsafe&lt;/code&gt; とマークされていない場合）、プログラム内の他のHaskellスレッドは、外部呼び出しの進行中も引き続き実行されます。さらに、 &lt;code&gt;foreign export&lt;/code&gt; Haskell関数は、複数のOSスレッドから同時に呼び出すことができます。&lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;マルチスレッドとFFIを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9afb526f4bf8bfbbfbd29f142d6a0d74ef8a8864" translate="yes" xml:space="preserve">
          <source>If a type variable &lt;code&gt;a&lt;/code&gt; in a datatype, class, or type family declaration depends on another such variable &lt;code&gt;k&lt;/code&gt; in the same declaration, two properties must hold:</source>
          <target state="translated">データ型、クラス、または型ファミリー宣言の型変数 &lt;code&gt;a&lt;/code&gt; が、同じ宣言の別のそのような変数 &lt;code&gt;k&lt;/code&gt; に依存している場合、2つのプロパティが保持されている必要があります。</target>
        </trans-unit>
        <trans-unit id="1fa7a794644c3b1936544c749803bfa930ad77e9" translate="yes" xml:space="preserve">
          <source>If a user does not provide a manual implementation for &lt;code&gt;sPpr&lt;/code&gt;, then it will default to &lt;code&gt;show&lt;/code&gt;. Now we can leverage the &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; extension to easily implement a &lt;code&gt;SPretty&lt;/code&gt; instance for a new data type:</source>
          <target state="translated">ユーザーが &lt;code&gt;sPpr&lt;/code&gt; の手動実装を提供しない場合、デフォルトで &lt;code&gt;show&lt;/code&gt; ます。これで、&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;拡張機能を利用して、新しいデータ型の &lt;code&gt;SPretty&lt;/code&gt; インスタンスを簡単に実装できます。</target>
        </trans-unit>
        <trans-unit id="ae7120c3db21432a6f1b3610362bef769bc13113" translate="yes" xml:space="preserve">
          <source>If a weak pointer (object) refers to an &lt;em&gt;unreachable&lt;/em&gt; key, it may be finalized.</source>
          <target state="translated">ウィークポインタ（オブジェクト）が&lt;em&gt;到達できない&lt;/em&gt;キーを参照している場合、それはファイナライズされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="102c2b7d4713d61cdf925ffde90969e0cf8621ec" translate="yes" xml:space="preserve">
          <source>If a worker has that many arguments, none will be unpacked anymore.</source>
          <target state="translated">ワーカーがそれだけ多くの引数を持っている場合、どれももうアンパックされません。</target>
        </trans-unit>
        <trans-unit id="b93932446c468ada97c37e6d1c9ba23f662e6eb7" translate="yes" xml:space="preserve">
          <source>If all else fails, then you need to resort to &lt;code&gt;Foreign.malloc&lt;/code&gt; and &lt;code&gt;Foreign.free&lt;/code&gt;. These are just wrappers around the C functions of the same name, and their efficiency will depend ultimately on the implementations of these functions in your platform&amp;rsquo;s C library. We usually find &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; to be significantly slower than the other forms of allocation above.</source>
          <target state="translated">他のすべてが失敗した場合は、 &lt;code&gt;Foreign.malloc&lt;/code&gt; および &lt;code&gt;Foreign.free&lt;/code&gt; に頼る必要があります。これらは同じ名前のC関数のラッパーにすぎず、その効率は最終的にはプラットフォームのCライブラリでのこれらの関数の実装に依存します。通常、 &lt;code&gt;malloc&lt;/code&gt; と &lt;code&gt;free&lt;/code&gt; は、上記の他の形式の割り当てよりもかなり遅いことがわかります。</target>
        </trans-unit>
        <trans-unit id="58a9c3c0b52a8eea92099f68faa2621ba66a2174" translate="yes" xml:space="preserve">
          <source>If all the matches against the &lt;code&gt;pi&lt;/code&gt; succeed, the match succeeds, binding the variables bound by the &lt;code&gt;pi&lt;/code&gt; . (The &lt;code&gt;xi&lt;/code&gt; are not bound; they remain local to the pattern synonym declaration.)</source>
          <target state="translated">&lt;code&gt;pi&lt;/code&gt; に対するすべての一致が成功すると、一致が成功し、 &lt;code&gt;pi&lt;/code&gt; によってバインドされた変数がバインドされます。（ &lt;code&gt;xi&lt;/code&gt; はバインドされていません。パターン同義語宣言に対してローカルのままです。）</target>
        </trans-unit>
        <trans-unit id="eed9f549e1682b63a8806713ee685fb3c9adfb3a" translate="yes" xml:space="preserve">
          <source>If all the remaining candidates are incoherent, the search suceeds, returning an arbitrary surviving candidate.</source>
          <target state="translated">残ったすべての候補が支離滅裂な場合、検索は成功し、任意の生存候補を返します。</target>
        </trans-unit>
        <trans-unit id="bb88aceb390c3de7d3ec513d599b8826a7a3104e" translate="yes" xml:space="preserve">
          <source>If all values stored in all maps in the arguments are in WHNF, then all values stored in all maps in the results will be in WHNF once those maps are evaluated.</source>
          <target state="translated">引数にあるすべてのマップに格納されているすべての値がWHNFにある場合、結果にあるすべてのマップに格納されているすべての値は、それらのマップが評価されるとWHNFになります。</target>
        </trans-unit>
        <trans-unit id="e9f53d1f0ff24c6a37e378e5ebd89c1567f62d05" translate="yes" xml:space="preserve">
          <source>If an asynchronous exception is thrown to the thread executing &lt;code&gt;callCommand&lt;/code&gt;, the forked process will be terminated and &lt;code&gt;callCommand&lt;/code&gt; will wait (block) until the process has been terminated.</source>
          <target state="translated">&lt;code&gt;callCommand&lt;/code&gt; を実行しているスレッドに非同期例外がスローされると、フォークされたプロセスは終了し、 &lt;code&gt;callCommand&lt;/code&gt; はプロセスが終了するまで待機（ブロック）します。</target>
        </trans-unit>
        <trans-unit id="fa75dc761964532aaa328fd35153a5453bcd7b2e" translate="yes" xml:space="preserve">
          <source>If an asynchronous exception is thrown to the thread executing &lt;code&gt;callProcess&lt;/code&gt;, the forked process will be terminated and &lt;code&gt;callProcess&lt;/code&gt; will wait (block) until the process has been terminated.</source>
          <target state="translated">&lt;code&gt;callProcess&lt;/code&gt; を実行しているスレッドに非同期例外がスローされると、フォークされたプロセスは終了し、プロセスが終了するまで &lt;code&gt;callProcess&lt;/code&gt; は待機（ブロック）します。</target>
        </trans-unit>
        <trans-unit id="d1293622c4845776f0f7f46e69be43df4b5fb632" translate="yes" xml:space="preserve">
          <source>If an asynchronous exception is thrown to the thread executing &lt;code&gt;readProcess&lt;/code&gt;, the forked process will be terminated and &lt;code&gt;readProcess&lt;/code&gt; will wait (block) until the process has been terminated.</source>
          <target state="translated">&lt;code&gt;readProcess&lt;/code&gt; を実行しているスレッドに非同期例外がスローされると、フォークされたプロセスが終了し、プロセスが終了するまで &lt;code&gt;readProcess&lt;/code&gt; は待機（ブロック）します。</target>
        </trans-unit>
        <trans-unit id="ac09f8306bc4c40a9a80bb592e856f9697dfc58b" translate="yes" xml:space="preserve">
          <source>If an entry within the directory vanishes while &lt;code&gt;removePathForcibly&lt;/code&gt; is running, it is silently ignored.</source>
          <target state="translated">&lt;code&gt;removePathForcibly&lt;/code&gt; の実行中にディレクトリ内のエントリが消失した場合、それは通知なく無視されます。</target>
        </trans-unit>
        <trans-unit id="1f47696dc0606508335264b40a8a2bc81264cf0b" translate="yes" xml:space="preserve">
          <source>If an environment entry does not contain an &lt;code&gt;'='&lt;/code&gt; character, the &lt;code&gt;key&lt;/code&gt; is the whole entry and the &lt;code&gt;value&lt;/code&gt; is the empty string.</source>
          <target state="translated">環境エントリに &lt;code&gt;'='&lt;/code&gt; 文字が含まれていない場合、 &lt;code&gt;key&lt;/code&gt; はエントリ全体であり、 &lt;code&gt;value&lt;/code&gt; は空の文字列です。</target>
        </trans-unit>
        <trans-unit id="588c20098b5c4c736fc7038d90ea284118f71b07" translate="yes" xml:space="preserve">
          <source>If an exception occurs while removing an entry, &lt;code&gt;removePathForcibly&lt;/code&gt; will still try to remove as many entries as it can before failing with an exception. The first exception that it encountered is re-thrown.</source>
          <target state="translated">エントリの削除中に例外が発生した場合でも、 &lt;code&gt;removePathForcibly&lt;/code&gt; は、例外で失敗する前に、できるだけ多くのエントリを削除しようとします。発生した最初の例外は再スローされます。</target>
        </trans-unit>
        <trans-unit id="6f43e9ffc752b9a35ea582ecc7ec760456f3ea2c" translate="yes" xml:space="preserve">
          <source>If an explicit deriving strategy is not given, multiple strategies may apply. In that case, GHC chooses the strategy as follows:</source>
          <target state="translated">明示的な導出戦略が与えられていない場合、複数の戦略が適用される可能性がある。その場合、GHCは以下のように戦略を選択します。</target>
        </trans-unit>
        <trans-unit id="ff8ac1961b2d3e86583dd04eda895ba3b29064e6" translate="yes" xml:space="preserve">
          <source>If an identifier&amp;rsquo;s type has a &lt;code&gt;forall&lt;/code&gt;, then the order of type variables as written in the &lt;code&gt;forall&lt;/code&gt; is retained.</source>
          <target state="translated">識別子のタイプがある場合は &lt;code&gt;forall&lt;/code&gt; 、その後に書かれたようなタイプの変数の順序 &lt;code&gt;forall&lt;/code&gt; 保持されます。</target>
        </trans-unit>
        <trans-unit id="6f039989be66fcac53da059edc720fe7f2a41936" translate="yes" xml:space="preserve">
          <source>If an optional package identifier ⟨P⟩ is given, then only packages matching that identifier are shown.</source>
          <target state="translated">オプションのパッケージ識別子 ⟨P⟩ が指定された場合、その識別子に一致するパッケージのみが表示されます。</target>
        </trans-unit>
        <trans-unit id="9480ee90d261f8569a157de91547e584915aaf32" translate="yes" xml:space="preserve">
          <source>If any of the allocation functions fails, an exception is thrown. In some cases, memory exhaustion may mean the process is terminated. If &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; is applied to a memory area that has been allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:allocaBytes&quot;&gt;allocaBytes&lt;/a&gt;&lt;/code&gt;, the behaviour is undefined. Any further access to memory areas allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:allocaBytes&quot;&gt;allocaBytes&lt;/a&gt;&lt;/code&gt;, after the computation that was passed to the allocation function has terminated, leads to undefined behaviour. Any further access to the memory area referenced by a pointer passed to &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; entails undefined behaviour.</source>
          <target state="translated">割り当て関数のいずれかが失敗すると、例外がスローされます。場合によっては、メモリ不足が原因でプロセスが終了することがあります。場合は &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; がで割り当てられたメモリ領域に適用される &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:allocaBytes&quot;&gt;allocaBytes&lt;/a&gt;&lt;/code&gt; 、動作は未定義です。割り当て関数に渡された計算が終了した後、 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:allocaBytes&quot;&gt;allocaBytes&lt;/a&gt;&lt;/code&gt; で割り当てられたメモリ領域にさらにアクセスすると、未定義の動作が発生します。任意の更なるに渡されたポインタが参照するメモリ領域へのアクセス &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; 伴う動作は未定義。</target>
        </trans-unit>
        <trans-unit id="0e7fd42d0300203e3af493856477c90e7ae13199" translate="yes" xml:space="preserve">
          <source>If any of the quantified type variables has a kind that mentions a kind variable, e.g.</source>
          <target state="translated">量化された型変数のいずれかが kind 変数を言及する kind を持っている場合、例えば</target>
        </trans-unit>
        <trans-unit id="73e0a573c5bd37919b95c361fc7a30bc02d831c3" translate="yes" xml:space="preserve">
          <source>If any of the variables depend on other variables (that is, if some of the variables are &lt;em&gt;kind&lt;/em&gt; variables), the variables are reordered so that kind variables come before type variables, preserving the left-to-right order as much as possible. That is, GHC performs a stable topological sort on the variables. Example:</source>
          <target state="translated">変数のいずれかが他の変数に依存している場合（つまり、一部の変数が&lt;em&gt;種類&lt;/em&gt;変数である場合）、変数は並べ替えられて、種類変数の前に種類変数が配置され、可能な限り左から右への順序が維持されます。つまり、GHCは変数に対して安定したトポロジカルソートを実行します。例：</target>
        </trans-unit>
        <trans-unit id="f0557de3fe76952756c65625bbfb3066796d428b" translate="yes" xml:space="preserve">
          <source>If both of these conditions are met, GHC will generate this instance:</source>
          <target state="translated">これらの条件の両方が満たされた場合、GHCはこのインスタンスを生成します。</target>
        </trans-unit>
        <trans-unit id="7ce69b4f84d82a5182cf85076110c0eb025eac55" translate="yes" xml:space="preserve">
          <source>If both rules apply to a deriving clause, then &lt;code&gt;anyclass&lt;/code&gt; is used and the user is warned about the ambiguity. The warning can be avoided by explicitly stating the desired deriving strategy.</source>
          <target state="translated">両方のルールが派生句に適用される場合、 &lt;code&gt;anyclass&lt;/code&gt; が使用され、あいまいさについてユーザーに警告されます。警告は、必要な派生戦略を明示的に示すことで回避できます。</target>
        </trans-unit>
        <trans-unit id="1fa898721e2cf3e2c6fc02511763040c586b29a5" translate="yes" xml:space="preserve">
          <source>If compatibility with Haskell compilers (including GHC prior to version 7.10.1) which do not define &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; is required, the presence of the &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; macro needs to be ensured before it is called, e.g.:</source>
          <target state="translated">&lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; を定義していないHaskellコンパイラ（バージョン7.10.1より前のGHCを含む）との互換性が必要な場合は、 &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; マクロの存在を確認してから、それを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="08f60c7543719f4b0441de2debed7ccff9b057ee" translate="yes" xml:space="preserve">
          <source>If compiled against a version of &lt;code&gt;unix&lt;/code&gt; prior to &lt;code&gt;2.7.0.0&lt;/code&gt;, the function would not be able to set timestamps with sub-second resolution. In this case, there would also be loss of precision in the access time.</source>
          <target state="translated">&lt;code&gt;2.7.0.0&lt;/code&gt; より前のバージョンの &lt;code&gt;unix&lt;/code&gt; に対してコンパイルした場合、この関数は1 秒未満の解像度でタイムスタンプを設定できません。この場合、アクセス時間の精度も失われます。</target>
        </trans-unit>
        <trans-unit id="2ca0ce3ddba01a79e74af5c98436169275d83f0d" translate="yes" xml:space="preserve">
          <source>If compiled against a version of &lt;code&gt;unix&lt;/code&gt; prior to &lt;code&gt;2.7.0.0&lt;/code&gt;, the function would not be able to set timestamps with sub-second resolution. In this case, there would also be loss of precision in the modification time.</source>
          <target state="translated">&lt;code&gt;2.7.0.0&lt;/code&gt; より前のバージョンの &lt;code&gt;unix&lt;/code&gt; に対してコンパイルした場合、この関数は1 秒未満の解像度でタイムスタンプを設定できません。この場合、修正時間の精度も失われます。</target>
        </trans-unit>
        <trans-unit id="76a5f02902c36d5e634fb160347312d3187dcbaf" translate="yes" xml:space="preserve">
          <source>If compiled with &lt;code&gt;-O2&lt;/code&gt; enabled, then the fields will have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedUnpack&quot;&gt;DecidedUnpack&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedLazy&quot;&gt;DecidedLazy&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;-O2&lt;/code&gt; を有効にしてコンパイルした場合、フィールドにはそれぞれ &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedUnpack&quot;&gt;DecidedUnpack&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedLazy&quot;&gt;DecidedLazy&lt;/a&gt;&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="36b6e9b0f077c5045ff320f1e46e64bdc9093838" translate="yes" xml:space="preserve">
          <source>If compiled with &lt;code&gt;-XStrictData&lt;/code&gt; enabled, then the fields will have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;-XStrictData&lt;/code&gt; を有効にしてコンパイルした場合、フィールドにはそれぞれ &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="894b0f94836181331c4facb44019c7354d1c68db" translate="yes" xml:space="preserve">
          <source>If compiled without optimization or other language extensions, then the fields of &lt;code&gt;ExampleConstructor&lt;/code&gt; will have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedLazy&quot;&gt;DecidedLazy&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">最適化または他の言語拡張なしでコンパイルした場合、フィールドの &lt;code&gt;ExampleConstructor&lt;/code&gt; があります &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedLazy&quot;&gt;DecidedLazy&lt;/a&gt;&lt;/code&gt; をそれぞれ。</target>
        </trans-unit>
        <trans-unit id="94f0a56741935b56d9657b26b078c93129516f82" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;&lt;a href=&quot;control-applicative#v:some&quot;&gt;some&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt; should be the least solutions of the equations:</source>
          <target state="translated">定義されている場合、 &lt;code&gt;&lt;a href=&quot;control-applicative#v:some&quot;&gt;some&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;control-applicative#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt; が方程式の最小解になるはずです。</target>
        </trans-unit>
        <trans-unit id="702c4c7f59fbddacdb90bd27f31c03920aeed35e" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;&lt;a href=&quot;ghc-base#v:some&quot;&gt;some&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-base#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt; should be the least solutions of the equations:</source>
          <target state="translated">定義されている場合、 &lt;code&gt;&lt;a href=&quot;ghc-base#v:some&quot;&gt;some&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;ghc-base#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt; が方程式の最小解になるはずです。</target>
        </trans-unit>
        <trans-unit id="13447cdcf1a935f05011fe0f50982abf26334ad9" translate="yes" xml:space="preserve">
          <source>If divisor is zero, &lt;code&gt;(# &lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt;, &lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt; #)&lt;/code&gt; is returned</source>
          <target state="translated">除数がゼロの場合、 &lt;code&gt;(# &lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt;, &lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt; #)&lt;/code&gt; が返されます</target>
        </trans-unit>
        <trans-unit id="079e039a9d9a2492d984ad6955aa2d617c670ae6" translate="yes" xml:space="preserve">
          <source>If given an explicit &amp;lt;mask&amp;gt;, the &amp;lt;mask&amp;gt; is interpreted as a bitmap that indicates the NUMA nodes on which to run the program. For example, &lt;code&gt;--numa=3&lt;/code&gt; would run the program on NUMA nodes 0 and 1.</source>
          <target state="translated">明示的な&amp;lt;mask&amp;gt;が指定されている場合、&amp;lt;mask&amp;gt;は、プログラムを実行するNUMAノードを示すビットマップとして解釈されます。たとえば、 &lt;code&gt;--numa=3&lt;/code&gt; は、NUMAノード0および1でプログラムを実行します。</target>
        </trans-unit>
        <trans-unit id="5fc002cc69c30cbd42ee3fdd97604037215dd998" translate="yes" xml:space="preserve">
          <source>If given invalid input, an exception will be thrown by the function or continuation where it is encountered.</source>
          <target state="translated">無効な入力が与えられた場合は、それに遭遇した関数または継続によって例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="560a8ee2e174396c52afe392206d8b4e1b326878" translate="yes" xml:space="preserve">
          <source>If given, uses &lt;code&gt;MADV_DONTNEED&lt;/code&gt; instead of &lt;code&gt;MADV_FREE&lt;/code&gt; on platforms where this results in more accurate resident memory usage of the program as shown in memory usage reporting tools (e.g. the &lt;code&gt;RSS&lt;/code&gt; column in &lt;code&gt;top&lt;/code&gt; and &lt;code&gt;htop&lt;/code&gt;).</source>
          <target state="translated">与えられた場合には、用途は &lt;code&gt;MADV_DONTNEED&lt;/code&gt; 代わりに &lt;code&gt;MADV_FREE&lt;/code&gt; プログラムのより正確な常駐メモリ使用量のこの結果は、メモリ使用量のレポートツールに示すように、プラットフォーム上で（例えば &lt;code&gt;RSS&lt;/code&gt; の中欄 &lt;code&gt;top&lt;/code&gt; と &lt;code&gt;htop&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6b94f294f89264115630dd884435117d7704777a" translate="yes" xml:space="preserve">
          <source>If hs-boot files are considered distinct from their parent source files, and if a &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; import is considered to refer to the hs-boot file, then the module import graph must have no cycles. The command &lt;code&gt;ghc -M&lt;/code&gt; will report an error if a cycle is found.</source>
          <target state="translated">hs-bootファイルがそれらの親ソースファイルとは異なると見なされ、 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; インポートがhs-bootファイルを参照すると見なされる場合、モジュールインポートグラフにサイクルがあってはなりません。 &lt;code&gt;ghc -M&lt;/code&gt; コマンドは、サイクルが見つかった場合にエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="cd1bdd645b7861dcf3835e2124b49ce612dfa503" translate="yes" xml:space="preserve">
          <source>If in doubt, don't use this function.</source>
          <target state="translated">疑わしい場合は、この機能を使用しないでください。</target>
        </trans-unit>
        <trans-unit id="d098bda271cdeda0c89226b1f9334177dda1ff17" translate="yes" xml:space="preserve">
          <source>If in doubt, return non-zero, but do make an effort to create the correct answer for small args, since otherwise the performance of &lt;code&gt;(*) :: Integer -&amp;gt; Integer -&amp;gt; Integer&lt;/code&gt; will be poor.</source>
          <target state="translated">疑わしい場合はゼロ以外を返しますが、小さい引数の場合は正しい答えを作成するようにしてください。そうしないと、 &lt;code&gt;(*) :: Integer -&amp;gt; Integer -&amp;gt; Integer&lt;/code&gt; のパフォーマンスが低下します。</target>
        </trans-unit>
        <trans-unit id="901bbb7f5d809f3c6e6b017688b99e54b9c8c79f" translate="yes" xml:space="preserve">
          <source>If it cannot open the user's terminal, use file-style interaction, reading input from &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ユーザーの端末を開けない場合は、ファイル形式の操作を使用して、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; から入力を読み取ります。</target>
        </trans-unit>
        <trans-unit id="49674ddcca37568931ac6e297642bf137c06f0fb" translate="yes" xml:space="preserve">
          <source>If it is heavily used on lists with &lt;code&gt;Widget&lt;/code&gt; keys, you could specialise it as follows:</source>
          <target state="translated">&lt;code&gt;Widget&lt;/code&gt; キーのリストで頻繁に使用される場合は、次のように特殊化できます。</target>
        </trans-unit>
        <trans-unit id="f0edddfba80ac6a09b6665c39b1ef9f0ebf6fbab" translate="yes" xml:space="preserve">
          <source>If it says you&amp;rsquo;re using more than 20% of total time in garbage collecting, then more memory might help: use the &lt;code&gt;-H⟨size⟩&lt;/code&gt; (see &lt;code&gt;-H [⟨size⟩]&lt;/code&gt;) option. Increasing the default allocation area size used by the compiler&amp;rsquo;s RTS might also help: use the &lt;code&gt;+RTS -A⟨size⟩
-RTS&lt;/code&gt; option (see &lt;code&gt;-A ⟨size⟩&lt;/code&gt;).</source>
          <target state="translated">総時間の20％以上をガベージコレクションで使用していると &lt;code&gt;-H⟨size⟩&lt;/code&gt; 場合は、メモリを増やすとよいでしょう。-H⟨size⟩（ &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; 参照）オプションを使用します。コンパイラのRTSで使用されるデフォルトの割り当て領域サイズを増やすと、 &lt;code&gt;+RTS -A⟨size⟩ -RTS&lt;/code&gt; オプションを使用することもできます（ &lt;code&gt;-A ⟨size⟩&lt;/code&gt; 参照）。</target>
        </trans-unit>
        <trans-unit id="205fa22c0cf21d40cd9db8045e7c70a4db4f3ae2" translate="yes" xml:space="preserve">
          <source>If it uses terminal-style interaction, &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; will be read from the user's &lt;code&gt;~/.haskeline&lt;/code&gt; file (if present). If it uses file-style interaction, &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; are not relevant and will not be read.</source>
          <target state="translated">それは、端末スタイルの相互作用を使用している場合、 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; 、ユーザーのから読み込まれます &lt;code&gt;~/.haskeline&lt;/code&gt; ファイル（存在する場合）。それはファイル形式の相互作用を使用している場合、 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; 関係ありませんと読まれることはありません。</target>
        </trans-unit>
        <trans-unit id="48a69ac0f3095acb072ddfcfb9a6bdffd564f050" translate="yes" xml:space="preserve">
          <source>If more than one non-incoherent candidate remains, the search fails.</source>
          <target state="translated">非一貫性のある候補が複数残っている場合は、検索に失敗します。</target>
        </trans-unit>
        <trans-unit id="092903c3946d9ebf1026389c3dca1af41e4be180" translate="yes" xml:space="preserve">
          <source>If more than one rule matches a call, GHC will choose one arbitrarily to apply.</source>
          <target state="translated">複数のルールが呼にマッチした場合、GHCは任意に1つのルールを選択して適用します。</target>
        </trans-unit>
        <trans-unit id="46c551abf7dfa66ea7e6819fd50f9537ead8ac62" translate="yes" xml:space="preserve">
          <source>If multiple CodingProgress returns are possible, OutputUnderflow must be preferred to InvalidSequence. This allows GHC's IO library to assume that if we observe InvalidSequence there is at least a single element available in the output buffer.</source>
          <target state="translated">複数の CodingProgress が返される可能性がある場合、OutputUnderflow は InvalidSequence よりも優先されなければなりません。これにより、GHC の IO ライブラリは、もし InvalidSequence を観測した場合、出力バッファには少なくとも 1 つの要素が利用可能であると仮定することができます。</target>
        </trans-unit>
        <trans-unit id="7c993cec0b4151ad1b0f5562c270a5895e49c59e" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for datatypes where each constructor has just zero or one field, in particular for enumeration types.</source>
          <target state="translated">いいえの場合 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 列挙型のための特定の各コンストラクタは単に、ゼロまたは1つのフィールドを持つデータ型、のインスタンスが指定されていない、機能があり、まだ仕事。</target>
        </trans-unit>
        <trans-unit id="777411d8c4bf9b9216adcc59bd1260d805fb12f9" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for empty datatypes or datatypes that have a single constructor, but will fail on datatypes with more than one constructor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; インスタンスが指定されていない場合、関数は空のデータ型または単一のコンストラクターを持つデータ型に対して機能しますが、複数のコンストラクターを持つデータ型では失敗します。</target>
        </trans-unit>
        <trans-unit id="076b26677e1e9d94d1e31f006635bd3641fcc733" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for enumeration types, where no constructor has any fields.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; インスタンスが指定されていない場合でも、コンストラクターがフィールドを持たない列挙型に対して関数は機能します。</target>
        </trans-unit>
        <trans-unit id="db076b7e62e1c825a47aaaf3a5ab3a6b5fbdafa9" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for any datatype where each constructor has at least one field.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; インスタンスが指定されていない場合でも、関数は、各コンストラクターに少なくとも1つのフィールドがある任意のデータ型で機能します。</target>
        </trans-unit>
        <trans-unit id="1606eb80e1c8dfc4c88130f2d2acd1efbbfc995e" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for any datatype that is not empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; インスタンスが指定されていない場合、関数は空でないデータ型に対して機能する可能性があります。</target>
        </trans-unit>
        <trans-unit id="c4b3a7948164a4bece210a1698cfedabc51fc766" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;MINIMAL&lt;/code&gt; pragma is given in the class declaration, it is just as if a pragma &lt;code&gt;{-# MINIMAL op1, op2, ..., opn #-}&lt;/code&gt; was given, where the &lt;code&gt;opi&lt;/code&gt; are the methods that lack a default method in the class declaration (c.f. &lt;a href=&quot;using-warnings#ghc-flag--Wmissing-methods&quot;&gt;&lt;code&gt;-Wmissing-methods&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;).</source>
          <target state="translated">クラス宣言で &lt;code&gt;MINIMAL&lt;/code&gt; プラグマが指定されていない場合、それはプラグマ &lt;code&gt;{-# MINIMAL op1, op2, ..., opn #-}&lt;/code&gt; が指定された場合と同じです。ここで、 &lt;code&gt;opi&lt;/code&gt; は、クラス宣言（&lt;a href=&quot;using-warnings#ghc-flag--Wmissing-methods&quot;&gt; &lt;code&gt;-Wmissing-methods&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;using-warnings#options-sanity&quot;&gt;警告および&lt;/a&gt;正常性チェックを参照）。</target>
        </trans-unit>
        <trans-unit id="6558b92d136aeb7b89c5f372133e67b42639edb6" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;default&lt;/code&gt; declaration is given, then it is just as if the module contained the declaration &lt;code&gt;default( Integer, Double, String)&lt;/code&gt;.</source>
          <target state="translated">いいえの場合 &lt;code&gt;default&lt;/code&gt; 宣言が指定されていない、それはモジュールが宣言含まれているかのようである &lt;code&gt;default( Integer, Double, String)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="784b5f99e839f7b12ec2093256b70c6cad4b74c2" translate="yes" xml:space="preserve">
          <source>If no candidates remain, the search failes</source>
          <target state="translated">候補者が残っていない場合、検索は失敗します。</target>
        </trans-unit>
        <trans-unit id="9192657645342fee69fd524510551ad47221178f" translate="yes" xml:space="preserve">
          <source>If no export list is provided for a signature, the exports of a signature are all of its defined entities merged with the exports of all inherited signatures.</source>
          <target state="translated">署名のエクスポートリストが提供されていない場合、署名のエクスポートは、定義されているすべてのエンティティを、継承されているすべての署名のエクスポートとマージしたものになります。</target>
        </trans-unit>
        <trans-unit id="e6ff16fc0e935cafc45afe04c519a876483f5dcb" translate="yes" xml:space="preserve">
          <source>If no inlining takes place, the &lt;code&gt;&lt;a href=&quot;ghc-exts#v:inline&quot;&gt;inline&lt;/a&gt;&lt;/code&gt; function expands to the identity function in Phase zero, so its use imposes no overhead.</source>
          <target state="translated">何のインライン化が行われない場合は、 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:inline&quot;&gt;inline&lt;/a&gt;&lt;/code&gt; 関数は、オーバーヘッドその使用課して、フェーズ0のID機能に展開されていません。</target>
        </trans-unit>
        <trans-unit id="09340baa4f1fe5048c9542d16a391d2e3eb6f959" translate="yes" xml:space="preserve">
          <source>If no mode flag is present, then GHC will enter &lt;a href=&quot;#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode (&lt;a href=&quot;#make-mode&quot;&gt;Using ghc &amp;ndash;make&lt;/a&gt;) if there are any Haskell source files given on the command line, or else it will link the objects named on the command line to produce an executable.</source>
          <target state="translated">モードフラグが存在しない場合、コマンドラインで指定されたHaskellソースファイルがある場合、GHCは&lt;a href=&quot;#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;モードに入り（&lt;a href=&quot;#make-mode&quot;&gt;ghc &amp;ndash;makeを使用&lt;/a&gt;）、そうでない場合、コマンドラインで指定されたオブジェクトをリンクして実行可能ファイルを生成します。 。</target>
        </trans-unit>
        <trans-unit id="2c70bd69294b761a98eab2c97c782c7a594740e3" translate="yes" xml:space="preserve">
          <source>If no mode flag is present, then GHC will enter &lt;a href=&quot;#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode (&lt;a href=&quot;#make-mode&quot;&gt;Using ghc --make&lt;/a&gt;) if there are any Haskell source files given on the command line, or else it will link the objects named on the command line to produce an executable.</source>
          <target state="translated">モードフラグが存在しない場合、コマンドラインで指定されたHaskellソースファイルがある場合、GHCは&lt;a href=&quot;#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;モード（&lt;a href=&quot;#make-mode&quot;&gt;ghc --makeを使用&lt;/a&gt;）に入ります。そうでない場合は、コマンドラインで指定されたオブジェクトをリンクして、実行可能。</target>
        </trans-unit>
        <trans-unit id="545b39aee7ff9dd8868144c774e3a1c54c9f14dd" translate="yes" xml:space="preserve">
          <source>If no quantified constraints match, look up in the global instances, as described in &lt;a href=&quot;#instance-resolution&quot;&gt;Instance resolution&lt;/a&gt; and &lt;a href=&quot;#instance-overlap&quot;&gt;Overlapping instances&lt;/a&gt;.</source>
          <target state="translated">定量化された制約が一致しない場合は、&lt;a href=&quot;#instance-resolution&quot;&gt;インスタンスの解決&lt;/a&gt;と&lt;a href=&quot;#instance-overlap&quot;&gt;インスタンスの重複で&lt;/a&gt;説明されているように、グローバルインスタンスを検索します。</target>
        </trans-unit>
        <trans-unit id="8910a1e7567042e5831890a8c1459a75e51e378b" translate="yes" xml:space="preserve">
          <source>If not, look at all the available given quantified constraints; if exactly one one matches &lt;code&gt;C t&lt;/code&gt;, choose it; if more than one matches, report an error.</source>
          <target state="translated">そうでない場合は、利用可能なすべての定量化された制約を調べます。1つだけが &lt;code&gt;C t&lt;/code&gt; と一致する場合は、それを選択します。一致するものが複数ある場合は、エラーを報告します。</target>
        </trans-unit>
        <trans-unit id="0c47246abbeffab64ebd4d936953fd4c7c077f74" translate="yes" xml:space="preserve">
          <source>If omitted, ⟨n⟩ and ⟨m⟩ default to the first or last available completion candidate respectively. If there are less candidates than requested via the range argument, ⟨n⟩ and ⟨m⟩ are implicitly capped to the number of available completion candidates.</source>
          <target state="translated">省略した場合、⟨n⟩ および ⟨m⟩ は、それぞれ最初または最後に利用可能な完了候補にデフォルトで設定されます。範囲引数で要求された数よりも少ない候補がある場合、⟨n⟩と⟨m⟩は、利用可能な補完候補の数に暗黙的に上限が設定されます。</target>
        </trans-unit>
        <trans-unit id="43110c483674fe00877c4157e9200eb8ff216c7b" translate="yes" xml:space="preserve">
          <source>If one input list is short, excess elements of the longer list are discarded:</source>
          <target state="translated">1つの入力リストが短い場合、長い方のリストの余分な要素は破棄されます。</target>
        </trans-unit>
        <trans-unit id="bae8b4e0fe43800691134bf9658ff55ae4812650" translate="yes" xml:space="preserve">
          <source>If one were to attempt to derive a Generic instance for a datatype with an unlifted argument (for example, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;), one might expect the occurrence of the &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; argument to be marked with &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;. This won't work, though, since &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; is of an unlifted kind, and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; expects a type of kind &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">リフトされていない引数（たとえば、 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; ）を使用してデータ型のGenericインスタンスを導出しようとした場合、 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; 引数の発生が &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; でマークされることが予想されます。ただし、 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; は持ち上げられていない種類であり、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; は種類 &lt;code&gt;*&lt;/code&gt; の種類を想定しているため、これは機能しません。</target>
        </trans-unit>
        <trans-unit id="ff1ad15ce25abb2710fa65ecce3a62a8bb2f9029" translate="yes" xml:space="preserve">
          <source>If platform does not provide &lt;code&gt;posix_fadvise(2)&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-fcntl#v:fileAdvise&quot;&gt;fileAdvise&lt;/a&gt;&lt;/code&gt; becomes a no-op.</source>
          <target state="translated">プラットフォームが提供されていない場合は &lt;code&gt;posix_fadvise(2)&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-posix-fcntl#v:fileAdvise&quot;&gt;fileAdvise&lt;/a&gt;&lt;/code&gt; は無操作になりません。</target>
        </trans-unit>
        <trans-unit id="e2fd0fc4ca5ca1f4279bebce52029854ce0a49ff" translate="yes" xml:space="preserve">
          <source>If possible &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt;, will be used directly (i.e. shared &lt;em&gt;without&lt;/em&gt; cloning the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; into a newly allocated one)</source>
          <target state="translated">可能な場合は &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; が直接使用されます（つまり、新しく割り当てられた &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; にByteArray＃を複製&lt;em&gt;せずに&lt;/em&gt;共有されます）</target>
        </trans-unit>
        <trans-unit id="a02a08bcb120a182f93778d549b78999be975134" translate="yes" xml:space="preserve">
          <source>If profiling has pointed the finger at particular functions, look at their Core code. &lt;code&gt;lets&lt;/code&gt; are bad, &lt;code&gt;cases&lt;/code&gt; are good, dictionaries (&lt;code&gt;d.⟨Class⟩.⟨Unique⟩&lt;/code&gt;) [or anything overloading-ish] are bad, nested lambdas are bad, explicit data constructors are good, primitive operations (e.g., &lt;code&gt;eqInt#&lt;/code&gt;) are good, &amp;hellip;</source>
          <target state="translated">プロファイリングが特定の機能に指を向けている場合は、それらのコアコードを確認してください。 &lt;code&gt;lets&lt;/code&gt; 悪いです、 &lt;code&gt;cases&lt;/code&gt; 良い、辞書（ある &lt;code&gt;d.⟨Class⟩.⟨Unique⟩&lt;/code&gt; ）か何かの過負荷っぽい]悪いです、ネストされたラムダが悪い、明示的なデータコンストラクタは良いですが、基本操作（例えば、 &lt;code&gt;eqInt#&lt;/code&gt; ）です良い、 &amp;hellip;</target>
        </trans-unit>
        <trans-unit id="52cc4cf0d03d5edea947b7488d65fce86a4331f7" translate="yes" xml:space="preserve">
          <source>If profiling has pointed the finger at particular functions, look at their Core code. &lt;code&gt;lets&lt;/code&gt; are bad, &lt;code&gt;cases&lt;/code&gt; are good, dictionaries (&lt;code&gt;d.⟨Class⟩.⟨Unique⟩&lt;/code&gt;) [or anything overloading-ish] are bad, nested lambdas are bad, explicit data constructors are good, primitive operations (e.g., &lt;code&gt;eqInt#&lt;/code&gt;) are good, ...</source>
          <target state="translated">プロファイリングによって特定の関数が特定された場合は、それらのコアコードを確認してください。 &lt;code&gt;lets&lt;/code&gt; 、悪い &lt;code&gt;cases&lt;/code&gt; 良い、辞書（ある &lt;code&gt;d.⟨Class⟩.⟨Unique⟩&lt;/code&gt; 悪い、ネストされたラムダが悪いです）か何かの過負荷っぽい]、明示的なデータ構成子は良い、基本操作（例えば、ある &lt;code&gt;eqInt#&lt;/code&gt; です）良い、 ...</target>
        </trans-unit>
        <trans-unit id="a9f317cd94e7a84b9481c4cd3410991be028a616" translate="yes" xml:space="preserve">
          <source>If recursive bindings are required for a monad, then that monad must be declared an instance of the &lt;code&gt;MonadFix&lt;/code&gt; class.</source>
          <target state="translated">モナドに再帰的バインディングが必要な場合、そのモナドは &lt;code&gt;MonadFix&lt;/code&gt; クラスのインスタンスとして宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="65bff50aaf133e46c4c389202fbe2fead3ced4d7" translate="yes" xml:space="preserve">
          <source>If right-to-left evaluation is required, the input list should be reversed.</source>
          <target state="translated">右から左への評価が必要な場合は、入力リストを逆にする必要があります。</target>
        </trans-unit>
        <trans-unit id="edfe3ca7d56d7c40b077f20b07320acbb2603c62" translate="yes" xml:space="preserve">
          <source>If some of the rows are shorter than the following rows, their elements are skipped:</source>
          <target state="translated">一部の行が次の行より短い場合、その要素はスキップされます。</target>
        </trans-unit>
        <trans-unit id="a471137408c37fe4b26bd411d1c9b91c60232b56" translate="yes" xml:space="preserve">
          <source>If such a package environment is found, it is equivalent to passing these command line arguments to &lt;code&gt;ghc&lt;/code&gt;:</source>
          <target state="translated">そのようなパッケージ環境が見つかった場合、これらのコマンドライン引数を &lt;code&gt;ghc&lt;/code&gt; に渡すことと同じです。</target>
        </trans-unit>
        <trans-unit id="100bc4626b0efab2c2dfa95a3d57f85130c6e4b0" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;event log&lt;/a&gt; is enabled (with the &lt;a href=&quot;#rts-flag--l&quot;&gt;&lt;code&gt;-l&lt;/code&gt;&lt;/a&gt; runtime system flag) heap samples will additionally be emitted to the GHC event log (see &lt;a href=&quot;eventlog-formats#heap-profiler-events&quot;&gt;Heap profiler event log output&lt;/a&gt; for details about event format).</source>
          <target state="translated">&lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;イベントログ&lt;/a&gt;が有効になっている場合（&lt;a href=&quot;#rts-flag--l&quot;&gt; &lt;code&gt;-l&lt;/code&gt; &lt;/a&gt;ランタイムシステムフラグを使用）、ヒープサンプルがGHCイベントログに追加で&lt;a href=&quot;eventlog-formats#heap-profiler-events&quot;&gt;出力さ&lt;/a&gt;れます（イベント形式の詳細については、ヒーププロファイラーのイベントログ出力を参照してください）。</target>
        </trans-unit>
        <trans-unit id="4364a4035c9b8cd510cf366346a071ecc7512c6e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;event log&lt;/a&gt; is enabled (with the &lt;code&gt;-l ⟨flags⟩&lt;/code&gt; runtime system flag) heap samples will additionally be emitted to the GHC event log (see &lt;a href=&quot;eventlog-formats#heap-profiler-events&quot;&gt;Heap profiler event log output&lt;/a&gt; for details about event format).</source>
          <target state="translated">&lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;イベントログ&lt;/a&gt;が有効になっている場合（ &lt;code&gt;-l ⟨flags⟩&lt;/code&gt; ランタイムシステムフラグを使用）、ヒープサンプルがGHCイベントログに追加で発行されます（イベント形式の詳細については、&lt;a href=&quot;eventlog-formats#heap-profiler-events&quot;&gt;ヒーププロファイラーイベントログの出力&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="984396ef6b346f6f5a141f1b3cc9c98c57b40449" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;using-warnings#ghc-flag--Wunused-foralls&quot;&gt;&lt;code&gt;-Wunused-foralls&lt;/code&gt;&lt;/a&gt; flag is enabled, a warning will be emitted when you write a type variable in an explicit &lt;code&gt;forall&lt;/code&gt; statement that is otherwise unused. For instance:</source>
          <target state="translated">場合&lt;a href=&quot;using-warnings#ghc-flag--Wunused-foralls&quot;&gt; &lt;code&gt;-Wunused-foralls&lt;/code&gt; の&lt;/a&gt;フラグが有効になっているあなたは、明示的に型変数を記述する際に、警告が発せられることになる &lt;code&gt;forall&lt;/code&gt; はそうでない場合は未使用である声明。例えば：</target>
        </trans-unit>
        <trans-unit id="67067af8a67e4c0ac00744d32ff51787c4c23ceb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;*&lt;/code&gt; symbol is placed before the module name, then &lt;em&gt;all&lt;/em&gt; the identifiers in scope in ⟨module⟩ (rather that just its exports) are shown.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 記号がモジュール名の前に配置されている場合は、「エクスポート」ではなく、「モジュール」のスコープ内の&lt;em&gt;すべて&lt;/em&gt;の識別子が表示されます。</target>
        </trans-unit>
        <trans-unit id="6c7426ed03e0cc31e14922c9ce2a60b1c4a4d18a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-rtsopts&lt;/code&gt; flag is set to something other than &lt;code&gt;none&lt;/code&gt; or &lt;code&gt;ignoreAll&lt;/code&gt; when linking, RTS options are also taken from the environment variable &lt;a href=&quot;#envvar-GHCRTS&quot; id=&quot;index-5&quot;&gt;&lt;code&gt;GHCRTS&lt;/code&gt;&lt;/a&gt;. For example, to set the maximum heap size to 2G for all GHC-compiled programs (using an &lt;code&gt;sh&lt;/code&gt;-like shell):</source>
          <target state="translated">場合 &lt;code&gt;-rtsopts&lt;/code&gt; フラグが以外に設定されて &lt;code&gt;none&lt;/code&gt; か &lt;code&gt;ignoreAll&lt;/code&gt; リンクする際に、RTSオプションも環境変数から取得され&lt;a href=&quot;#envvar-GHCRTS&quot; id=&quot;index-5&quot;&gt; &lt;code&gt;GHCRTS&lt;/code&gt; &lt;/a&gt;。たとえば、GHでコンパイルされたすべてのプログラムの最大ヒープサイズを2Gに設定するには（ &lt;code&gt;sh&lt;/code&gt; のようなシェルを使用）：</target>
        </trans-unit>
        <trans-unit id="ee47e204ad25ad75b90f894519d743cd373d5ec1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; is not found returns &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; が見つからない場合は &lt;code&gt;Nothing&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="1eecdf1765fe1b5c7a149e43f46aee92b76c9e9d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; is a relative path, then for every search directory &lt;code&gt;dir&lt;/code&gt;, the function checks whether &lt;code&gt;dir &lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt; name&lt;/code&gt; exists and satisfies the predicate. If so, &lt;code&gt;dir &lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt; name&lt;/code&gt; is returned as one of the results. In other words, the returned paths can be either relative or absolute depending on the search directories were used. If there are no search directories, no results are ever returned.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; が相対パスの場合、すべての検索ディレクトリ &lt;code&gt;dir&lt;/code&gt; について、関数は &lt;code&gt;dir &lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt; name&lt;/code&gt; が存在するかどうかをチェックし、述語を満たします。その場合、結果の1つとして &lt;code&gt;dir &lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt; name&lt;/code&gt; が返されます。つまり、返されたパスは、使用された検索ディレクトリに応じて、相対パスまたは絶対パスになります。検索ディレクトリがない場合、結果は返されません。</target>
        </trans-unit>
        <trans-unit id="7e66c7a66ac7c32b8ef7f9ce828408309a2951cf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; is an absolute path, then the function will return a single result if the file exists and satisfies the predicate and no results otherwise. This is irrespective of what search directories were given.</source>
          <target state="translated">場合 &lt;code&gt;name&lt;/code&gt; 絶対パスであるファイルが他の述語とない結果が存在すると満たしている場合、この関数は、単一の結果を返します。これは、指定された検索ディレクトリとは無関係です。</target>
        </trans-unit>
        <trans-unit id="95e84cba36edfb057e05285c58d1b651c2f290d8" translate="yes" xml:space="preserve">
          <source>If the I/O computation wrapped in &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; performs side effects, then the relative order in which those side effects take place (relative to the main I/O trunk, or other calls to &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;) is indeterminate. Furthermore, when using &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to cause side-effects, you should take the following precautions to ensure the side effects are performed as many times as you expect them to be. Note that these precautions are necessary for GHC, but may not be sufficient, and other compilers may require different precautions:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; にラップされたI / O計算が副作用を実行する場合、それらの副作用が発生する相対的な順序（メインI / Oトランク、または &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; への他の呼び出しに対して）は不確定です。さらに、 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; を使用して副作用を引き起こす場合は、次の予防策を講じて、副作用が期待どおりの回数だけ実行されるようにする必要があります。これらの予防策はGHCに必要ですが、十分ではない場合があり、他のコンパイラーは異なる予防策を必要とする場合があることに注意してください：</target>
        </trans-unit>
        <trans-unit id="95557e9796ad5018f234723793eebbd659062bdd" translate="yes" xml:space="preserve">
          <source>If the I/O computation wrapped in &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; performs side effects, then the relative order in which those side effects take place (relative to the main I/O trunk, or other calls to &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;) is indeterminate. Furthermore, when using &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to cause side-effects, you should take the following precautions to ensure the side effects are performed as many times as you expect them to be. Note that these precautions are necessary for GHC, but may not be sufficient, and other compilers may require different precautions:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; にラップされたI / O計算が副作用を実行する場合、それらの副作用が発生する相対的な順序（メインI / Oトランク、または &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; への他の呼び出しに対して）は不確定です。さらに、 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; を使用して副作用を引き起こす場合は、次の予防策を講じて、副作用が期待どおりの回数だけ実行されるようにする必要があります。これらの予防策はGHCに必要ですが、十分ではない場合があり、他のコンパイラーは異なる予防策を必要とする場合があることに注意してください：</target>
        </trans-unit>
        <trans-unit id="f37fb4ee444bede274c669b4d448a3acdb65fb55" translate="yes" xml:space="preserve">
          <source>If the I/O computation wrapped in &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; performs side effects, then the relative order in which those side effects take place (relative to the main I/O trunk, or other calls to &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;) is indeterminate. Furthermore, when using &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to cause side-effects, you should take the following precautions to ensure the side effects are performed as many times as you expect them to be. Note that these precautions are necessary for GHC, but may not be sufficient, and other compilers may require different precautions:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; にラップされたI / O計算が副作用を実行する場合、それらの副作用が発生する相対的な順序（メインI / Oトランク、または &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; への他の呼び出しに対して）は不確定です。さらに、 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; を使用して副作用を引き起こす場合は、次の予防策を講じて、副作用が期待どおりの回数だけ実行されるようにする必要があります。これらの予防策はGHCに必要ですが、十分ではない場合があり、他のコンパイラーは異なる予防策を必要とする場合があることに注意してください：</target>
        </trans-unit>
        <trans-unit id="916aaf70159a57842ced3963dcd6e37575d65a6b" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; behaves like &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; の引数が &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; の場合、 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; のように動作します。</target>
        </trans-unit>
        <trans-unit id="c74b7c9262440ab8eb34e0a6d3d1e23753614271" translate="yes" xml:space="preserve">
          <source>If the buffer mode is changed from &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:LineBuffering&quot;&gt;LineBuffering&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:NoBuffering&quot;&gt;NoBuffering&lt;/a&gt;&lt;/code&gt;, then</source>
          <target state="translated">バッファモードから変更された場合 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:LineBuffering&quot;&gt;LineBuffering&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:NoBuffering&quot;&gt;NoBuffering&lt;/a&gt;&lt;/code&gt; 、その後、</target>
        </trans-unit>
        <trans-unit id="eb44311b2b43303ecd2e4401810f83b01105af2e" translate="yes" xml:space="preserve">
          <source>If the buffer mode is changed from &lt;code&gt;&lt;a href=&quot;system-io#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io#v:LineBuffering&quot;&gt;LineBuffering&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;system-io#v:NoBuffering&quot;&gt;NoBuffering&lt;/a&gt;&lt;/code&gt;, then</source>
          <target state="translated">バッファモードから変更された場合 &lt;code&gt;&lt;a href=&quot;system-io#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-io#v:LineBuffering&quot;&gt;LineBuffering&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;system-io#v:NoBuffering&quot;&gt;NoBuffering&lt;/a&gt;&lt;/code&gt; 、その後、</target>
        </trans-unit>
        <trans-unit id="340506b1fc7cfecd1cc706b1ed0b444cb860cf41" translate="yes" xml:space="preserve">
          <source>If the computation is to modify the stored information, use &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt; instead.</source>
          <target state="translated">格納された情報を変更するための計算の場合は、代わりに&lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="4c240367cda084253143432ddcf60bf0b03fa3e5" translate="yes" xml:space="preserve">
          <source>If the constraint solver encounters a constraint &lt;code&gt;HasField x r a&lt;/code&gt; where &lt;code&gt;r&lt;/code&gt; is a concrete datatype with a field &lt;code&gt;x&lt;/code&gt; in scope, it will automatically solve the constraint using the field selector as the dictionary, unifying &lt;code&gt;a&lt;/code&gt; with the type of the field if necessary. This happens irrespective of which extensions are enabled.</source>
          <target state="translated">制約ソルバ遭遇A制約場合 &lt;code&gt;HasField x r a&lt;/code&gt; ここで &lt;code&gt;r&lt;/code&gt; はフィールドコンクリートデータ型である &lt;code&gt;x&lt;/code&gt; の範囲で、それは自動的に統一、辞書としてフィールドセレクタを使用して、制約を解決する必要に応じてフィールドのタイプと。これは、有効になっている拡張機能に関係なく発生します。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ac5d0fe1d7acda30fb0ec5a56697651c36a28ef" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; will produce infix applications of the constructor.</source>
          <target state="translated">コンストラクタが中置演算子として定義されている場合、 &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; はコンストラクタの中置アプリケーションを生成します。</target>
        </trans-unit>
        <trans-unit id="bc73951c5c10ca78ae5366f259e7017f69544b8f" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; will produce infix applications of the constructor.</source>
          <target state="translated">コンストラクタが中置演算子として定義されている場合、 &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; はコンストラクタの中置アプリケーションを生成します。</target>
        </trans-unit>
        <trans-unit id="9a11dfd9c83245d6ba417f9310e69a934f255b67" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; will produce infix applications of the constructor.</source>
          <target state="translated">コンストラクタが中置演算子として定義されている場合、 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; はコンストラクタの中置アプリケーションを生成します。</target>
        </trans-unit>
        <trans-unit id="7340551eb65b17d80f26730fb4f3289da8692a48" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then the derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance will parse only infix applications of the constructor (not the prefix form).</source>
          <target state="translated">コンストラクタが中置演算子として定義されている場合、派生した &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスは、コンストラクタの中置アプリケーションのみを解析します（プレフィックス形式ではありません）。</target>
        </trans-unit>
        <trans-unit id="a7834f177091806c3787fe742b48954a28d269ce" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then the derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance will parse only infix applications of the constructor (not the prefix form).</source>
          <target state="translated">コンストラクタが中置演算子として定義されている場合、派生した &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスは、コンストラクタの中置アプリケーションのみを解析します（プレフィックス形式ではありません）。</target>
        </trans-unit>
        <trans-unit id="fff881ab5c74b90094d3fe1033075847bf7fe644" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then the derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance will parse only infix applications of the constructor (not the prefix form).</source>
          <target state="translated">コンストラクタが中置演算子として定義されている場合、派生した &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスは、コンストラクタの中置アプリケーションのみを解析します（プレフィックス形式ではありません）。</target>
        </trans-unit>
        <trans-unit id="a24a3dfbd521f865d8c41e8577fde1211e1662ee" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, the derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; will parse only the record-syntax form, and furthermore, the fields must be given in the same order as the original declaration.</source>
          <target state="translated">コンストラクタがレコード構文を使用して定義されている場合、派生した &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; はレコード構文形式のみを解析し、さらに、フィールドは元の宣言と同じ順序で指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="d9cae460cd107a842e94f70119834c39ecbdb71b" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, the derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; will parse only the record-syntax form, and furthermore, the fields must be given in the same order as the original declaration.</source>
          <target state="translated">コンストラクタがレコード構文を使用して定義されている場合、派生した &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; はレコード構文形式のみを解析し、さらに、フィールドは元の宣言と同じ順序で指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="b45481ebece8ce7cdca4efa8d7e24867db92404c" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, the derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; will parse only the record-syntax form, and furthermore, the fields must be given in the same order as the original declaration.</source>
          <target state="translated">コンストラクタがレコード構文を使用して定義されている場合、派生した &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; はレコード構文形式のみを解析し、さらに、フィールドは元の宣言と同じ順序で指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="7dfb1a85a710e73bec4ed69a3c877abb78023f39" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, then &lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; will produce the record-syntax form, with the fields given in the same order as the original declaration.</source>
          <target state="translated">コンストラクターがレコード構文を使用して定義されている場合、 &lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; はフィールドが元の宣言と同じ順序で指定されたレコード構文形式を生成します。</target>
        </trans-unit>
        <trans-unit id="b1a05487843b471ffa877f4ad69c2c7e4d703688" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, then &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; will produce the record-syntax form, with the fields given in the same order as the original declaration.</source>
          <target state="translated">コンストラクターがレコード構文を使用して定義されている場合、 &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; はフィールドが元の宣言と同じ順序で指定されたレコード構文形式を生成します。</target>
        </trans-unit>
        <trans-unit id="0b96127742ffe03893d0e4f936b677e699812df7" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, then &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; will produce the record-syntax form, with the fields given in the same order as the original declaration.</source>
          <target state="translated">コンストラクターがレコード構文を使用して定義されている場合、 &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; はフィールドが元の宣言と同じ順序で指定されたレコード構文形式を生成します。</target>
        </trans-unit>
        <trans-unit id="915369447c441596818ea47cd1848a5ce0c1bbc6" translate="yes" xml:space="preserve">
          <source>If the derived instance were allowed, what would the type of its method &lt;code&gt;bad&lt;/code&gt; be? It would seem to be &lt;code&gt;Age -&amp;gt; Inspect Age&lt;/code&gt;, which is equivalent to &lt;code&gt;Age -&amp;gt; Int&lt;/code&gt;, according to the type family &lt;code&gt;Inspect&lt;/code&gt;. Yet, if we simply adapt the implementation from the instance for &lt;code&gt;Int&lt;/code&gt;, the implementation for &lt;code&gt;bad&lt;/code&gt; produces a &lt;code&gt;Bool&lt;/code&gt;, and we have trouble.</source>
          <target state="translated">派生したインスタンスが許可された場合は、そのメソッドの種類何を考え &lt;code&gt;bad&lt;/code&gt; こと？それはあるように見えるでしょう &lt;code&gt;Age -&amp;gt; Inspect Age&lt;/code&gt; に相当し、 &lt;code&gt;Age -&amp;gt; Int&lt;/code&gt; 、種類に応じて家族 &lt;code&gt;Inspect&lt;/code&gt; 。しかし、 &lt;code&gt;Int&lt;/code&gt; のインスタンスの実装を単純に適合させると、 &lt;code&gt;bad&lt;/code&gt; の実装は &lt;code&gt;Bool&lt;/code&gt; を生成し、問題が発生します。</target>
        </trans-unit>
        <trans-unit id="99dd79a68e6ace7bc36818530a36dff1b61996fd" translate="yes" xml:space="preserve">
          <source>If the elements are ordered, a linear-time implementation is used, with the performance equal to &lt;code&gt;&lt;a href=&quot;data-set#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要素が順序付けられている場合は、線形時間の実装が使用され、パフォーマンスは &lt;code&gt;&lt;a href=&quot;data-set#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="7ffe9c900b23c1f743c980afb39a54b09a15873e" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-11&quot;&gt;&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;&lt;/a&gt; is set, and its value does not end in a separator (&lt;code&gt;:&lt;/code&gt; on Unix, &lt;code&gt;;&lt;/code&gt; on Windows), then the last database is considered to be the global database, and will be modified by default by &lt;code&gt;ghc-pkg&lt;/code&gt;. The intention here is that &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; can be used to create a virtual package environment into which Cabal packages can be installed without setting anything other than &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;.</source>
          <target state="translated">環境変数の場合は&lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-11&quot;&gt; &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; が&lt;/a&gt;設定され、その値は、セパレータには終わらない（ &lt;code&gt;:&lt;/code&gt; Unix上で、 &lt;code&gt;;&lt;/code&gt; Windowsの場合）、そして最後のデータベースは、グローバル・データベースであると考えられ、およびにより、デフォルトでは変更される &lt;code&gt;ghc-pkg&lt;/code&gt; 。ここでの意図は、 &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; を使用して、 &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; 以外を設定せずにCabalパッケージをインストールできる仮想パッケージ環境を作成できることです。</target>
        </trans-unit>
        <trans-unit id="55d64c16a458e52bfe82101c17b8bb95dd2a0fb1" translate="yes" xml:space="preserve">
          <source>If the exception is not caught inside of the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt;, it is re-thrown by &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt;, and the entire &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; is rolled back.</source>
          <target state="translated">例外が &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; の内部でキャッチされない場合、例外は &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; によって再スローされ、 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 全体がロールバックされます。</target>
        </trans-unit>
        <trans-unit id="0f96e8b63db707eb0457ade29de32d3c2df84734" translate="yes" xml:space="preserve">
          <source>If the exception is not caught inside of the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt;, it is re-thrown by &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt;, and the entire &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; is rolled back.</source>
          <target state="translated">例外が &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; の内部でキャッチされない場合、例外は &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; によって再スローされ、 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 全体がロールバックされます。</target>
        </trans-unit>
        <trans-unit id="c2dff9269612b6f615c400bd3a6c96cd41d71ec5" translate="yes" xml:space="preserve">
          <source>If the exception is not caught inside of the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt;, it is re-thrown by &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt;, and the entire &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; is rolled back.</source>
          <target state="translated">例外が &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; の内部でキャッチされない場合、例外は &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; によって再スローされ、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 全体がロールバックされます。</target>
        </trans-unit>
        <trans-unit id="1b31e706b20ca1dd226c814726e8413042889a0f" translate="yes" xml:space="preserve">
          <source>If the expression was instead of type &lt;code&gt;IO a&lt;/code&gt; for some &lt;code&gt;a&lt;/code&gt;, then &lt;code&gt;it&lt;/code&gt; will be bound to the result of the &lt;code&gt;IO&lt;/code&gt; computation, which is of type &lt;code&gt;a&lt;/code&gt;. eg.:</source>
          <target state="translated">表現ではなくタイプであった場合は &lt;code&gt;IO a&lt;/code&gt; いくつかのために &lt;code&gt;a&lt;/code&gt; 、そして &lt;code&gt;it&lt;/code&gt; 結果にバインドされる &lt;code&gt;IO&lt;/code&gt; のタイプのものであり、計算、 &lt;code&gt;a&lt;/code&gt; 。例えば。：</target>
        </trans-unit>
        <trans-unit id="557b536a62aea491508b3f277f7c66ebafe8f737" translate="yes" xml:space="preserve">
          <source>If the file does not exist and it is opened for output, it should be created as a new file. If &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; and the file already exists, then it should be truncated to zero length. Some operating systems delete empty files, so there is no guarantee that the file will exist following an &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;mode&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; unless it is subsequently written to successfully. The handle is positioned at the end of the file if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:AppendMode&quot;&gt;AppendMode&lt;/a&gt;&lt;/code&gt;, and otherwise at the beginning (in which case its internal position is 0). The initial buffer mode is implementation-dependent.</source>
          <target state="translated">ファイルが存在せず、出力用に開かれている場合は、新しいファイルとして作成する必要があります。場合 &lt;code&gt;mode&lt;/code&gt; あり &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; 、ファイルがすでに存在している、それはゼロの長さに切り詰めする必要があります。一部のオペレーティング・システムでは、ので、ファイルには、以下の存在するという保証はありません、空のファイルを削除する &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;mode&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; それが無事に書き込まれていない限りは。 &lt;code&gt;mode&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;system-io#v:AppendMode&quot;&gt;AppendMode&lt;/a&gt;&lt;/code&gt; の場合、ハンドルはファイルの末尾に配置されます。それ以外の場合、先頭に配置されます（この場合、内部位置は0です）。初期バッファモードは実装に依存します。</target>
        </trans-unit>
        <trans-unit id="8bdafef8b919def741e21f11e5c61515c31e3d40" translate="yes" xml:space="preserve">
          <source>If the file does not exist and it is opened for output, it should be created as a new file. If &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; and the file already exists, then it should be truncated to zero length. Some operating systems delete empty files, so there is no guarantee that the file will exist following an &lt;code&gt;&lt;a href=&quot;system-io#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;mode&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; unless it is subsequently written to successfully. The handle is positioned at the end of the file if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:AppendMode&quot;&gt;AppendMode&lt;/a&gt;&lt;/code&gt;, and otherwise at the beginning (in which case its internal position is 0). The initial buffer mode is implementation-dependent.</source>
          <target state="translated">ファイルが存在せず、出力用に開かれている場合は、新しいファイルとして作成する必要があります。場合 &lt;code&gt;mode&lt;/code&gt; あり &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; 、ファイルがすでに存在している、それはゼロの長さに切り詰めする必要があります。一部のオペレーティング・システムでは、ので、ファイルには、以下の存在するという保証はありません、空のファイルを削除する &lt;code&gt;&lt;a href=&quot;system-io#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;mode&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; それが無事に書き込まれていない限りは。 &lt;code&gt;mode&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;system-io#v:AppendMode&quot;&gt;AppendMode&lt;/a&gt;&lt;/code&gt; の場合、ハンドルはファイルの末尾に配置されます。それ以外の場合、先頭に配置されます（この場合、内部位置は0です）。初期バッファモードは実装に依存します。</target>
        </trans-unit>
        <trans-unit id="8848ff01b8a32afcddff36cec08d4b6728717d85" translate="yes" xml:space="preserve">
          <source>If the final statement is not of one of these forms, GHC falls back to standard &lt;code&gt;do&lt;/code&gt; desugaring, and the expression will require a &lt;code&gt;Monad&lt;/code&gt; constraint.</source>
          <target state="translated">最後の文は、これらのいずれかの形式でない場合は、GHCはバック標準にフォール &lt;code&gt;do&lt;/code&gt; 脱糖、および式が必要になります &lt;code&gt;Monad&lt;/code&gt; 制約を。</target>
        </trans-unit>
        <trans-unit id="99750cf8581988661447b877b8a2ef2af75d98f8" translate="yes" xml:space="preserve">
          <source>If the first action completes without retrying then it forms the result of the &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt;. Otherwise, if the first action retries, then the second action is tried in its place. If both actions retry then the &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; as a whole retries.</source>
          <target state="translated">最初のアクションが再試行なしで完了すると、 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; の結果が形成されます。そうでない場合、最初のアクションが再試行すると、代わりに2番目のアクションが試行されます。両方のアクションが再試行する場合、 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; は全体として再試行します。</target>
        </trans-unit>
        <trans-unit id="c3b9d8e821fceed6649d1fb75df70e0b3ecb6ca6" translate="yes" xml:space="preserve">
          <source>If the first action completes without retrying then it forms the result of the &lt;code&gt;&lt;a href=&quot;ghc-conc#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt;. Otherwise, if the first action retries, then the second action is tried in its place. If both actions retry then the &lt;code&gt;&lt;a href=&quot;ghc-conc#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; as a whole retries.</source>
          <target state="translated">最初のアクションが再試行なしで完了すると、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; の結果が形成されます。そうでない場合、最初のアクションが再試行すると、代わりに2番目のアクションが試行されます。両方のアクションが再試行する場合、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; は全体として再試行します。</target>
        </trans-unit>
        <trans-unit id="29e53de7a23bc55e53e1793d6fcc64937e975381" translate="yes" xml:space="preserve">
          <source>If the first action completes without retrying then it forms the result of the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt;. Otherwise, if the first action retries, then the second action is tried in its place. If both actions retry then the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; as a whole retries.</source>
          <target state="translated">最初のアクションが再試行なしで完了すると、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; の結果が形成されます。そうでない場合、最初のアクションが再試行すると、代わりに2番目のアクションが試行されます。両方のアクションが再試行する場合、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; は全体として再試行します。</target>
        </trans-unit>
        <trans-unit id="0a17c36982066985bf53c44ca7e61aeacd02ae41" translate="yes" xml:space="preserve">
          <source>If the first argument evaluates to &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, then the result is the second argument. Otherwise an &lt;code&gt;&lt;a href=&quot;control-exception#v:AssertionFailed&quot;&gt;AssertionFailed&lt;/a&gt;&lt;/code&gt; exception is raised, containing a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; with the source file and line number of the call to &lt;code&gt;&lt;a href=&quot;control-exception#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">最初の引数が &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; に評価される場合、結果は2番目の引数になります。それ以外の場合、 &lt;code&gt;&lt;a href=&quot;control-exception#v:AssertionFailed&quot;&gt;AssertionFailed&lt;/a&gt;&lt;/code&gt; 例外が発生し、ソースファイルと &lt;code&gt;&lt;a href=&quot;control-exception#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; を呼び出す行番号を含む &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="feb4f24ce87f487be05ef1c288b600a60dcbf5bb" translate="yes" xml:space="preserve">
          <source>If the first argument evaluates to &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, then the result is the second argument. Otherwise an &lt;code&gt;&lt;a href=&quot;control-exception#v:AssertionFailed&quot;&gt;AssertionFailed&lt;/a&gt;&lt;/code&gt; exception is raised, containing a &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; with the source file and line number of the call to &lt;code&gt;&lt;a href=&quot;ghc-base#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">最初の引数が &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; に評価される場合、結果は2番目の引数になります。それ以外の場合、 &lt;code&gt;&lt;a href=&quot;control-exception#v:AssertionFailed&quot;&gt;AssertionFailed&lt;/a&gt;&lt;/code&gt; 例外が発生し、ソースファイルと &lt;code&gt;&lt;a href=&quot;ghc-base#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; を呼び出す行番号を含む &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="d0054b769e95e245513b766b41dc0a78a5fa0e67" translate="yes" xml:space="preserve">
          <source>If the first completer produces no suggestions, fallback to the second completer's output.</source>
          <target state="translated">最初のコンプリタが提案を生成しない場合は、2 番目のコンプリタの出力にフォールバックします。</target>
        </trans-unit>
        <trans-unit id="7d227d6371173673bc113bcadb48246870a816fc" translate="yes" xml:space="preserve">
          <source>If the first list contains duplicates, so will the result.</source>
          <target state="translated">最初のリストに重複が含まれている場合は、その結果も同様になります。</target>
        </trans-unit>
        <trans-unit id="8f303f44f15d67e9e20a0ff01c05b8e471995e19" translate="yes" xml:space="preserve">
          <source>If the first list is not finite, the result is the first list.</source>
          <target state="translated">最初のリストが有限でない場合、結果は最初のリストになります。</target>
        </trans-unit>
        <trans-unit id="fabb69bed587314beb9edec19efed156d82f6d0c" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;f&lt;/code&gt; takes more than one parameter, the type variable &lt;code&gt;b&lt;/code&gt; is instantiated to a functional type which combines nicely with the adds parser &lt;code&gt;p&lt;/code&gt; to the (&lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator. This results in stylized code where a permutation parser starts with a combining function &lt;code&gt;f&lt;/code&gt; followed by the parsers. The function &lt;code&gt;f&lt;/code&gt; gets its parameters in the order in which the parsers are specified, but actual input can be in any order.</source>
          <target state="translated">関数 &lt;code&gt;f&lt;/code&gt; が複数のパラメーターをとる場合、型変数 &lt;code&gt;b&lt;/code&gt; は、（ &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt; ）コンビネーターへの追加パーサー &lt;code&gt;p&lt;/code&gt; とうまく結合する関数型にインスタンス化されます。これにより、置換パーサーが結合関数 &lt;code&gt;f&lt;/code&gt; で始まり、その後にパーサーが続く、様式化されたコードが生成されます。関数 &lt;code&gt;f&lt;/code&gt; は、パーサーが指定された順序でパラメーターを取得しますが、実際の入力は任意の順序にすることができます。</target>
        </trans-unit>
        <trans-unit id="5eb94185e7818eb4718538187db5c7b4cbfd254a" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;f&lt;/code&gt; takes more than one parameter, the type variable &lt;code&gt;b&lt;/code&gt; is instantiated to a functional type which combines nicely with the adds parser &lt;code&gt;p&lt;/code&gt; to the (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator. This results in stylized code where a permutation parser starts with a combining function &lt;code&gt;f&lt;/code&gt; followed by the parsers. The function &lt;code&gt;f&lt;/code&gt; gets its parameters in the order in which the parsers are specified, but actual input can be in any order.</source>
          <target state="translated">関数 &lt;code&gt;f&lt;/code&gt; が複数のパラメーターをとる場合、型変数 &lt;code&gt;b&lt;/code&gt; は、（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt; ）コンビネーターへの追加パーサー &lt;code&gt;p&lt;/code&gt; とうまく結合する関数型にインスタンス化されます。これにより、置換パーサーが結合関数 &lt;code&gt;f&lt;/code&gt; で始まり、その後にパーサーが続く、様式化されたコードが生成されます。関数 &lt;code&gt;f&lt;/code&gt; は、パーサーが指定された順序でパラメーターを取得しますが、実際の入力は任意の順序にすることができます。</target>
        </trans-unit>
        <trans-unit id="c0bf34eec193f2a121ba6f174b48d6e08e32c420" translate="yes" xml:space="preserve">
          <source>If the function isn&amp;rsquo;t exported, just compile with the extra flag &lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt;&lt;code&gt;-ddump-simpl&lt;/code&gt;&lt;/a&gt;; next to the signature for any binder, it will print the self-same pragmatic information as would be put in an interface file. (Besides, Core syntax is fun to look at!)</source>
          <target state="translated">関数がエクスポートされない場合は、追加のフラグ&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt; &lt;code&gt;-ddump-simpl&lt;/code&gt; を使用&lt;/a&gt;してコンパイルしてください。バインダーの署名の横に、インターフェースファイルに入力されるのと同じ実用的な情報が出力されます。（さらに、コア構文は見るのが楽しいです！）</target>
        </trans-unit>
        <trans-unit id="79369b89e6cd5dd14719075c040fa3bcd79b2c7d" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="96d21b1729033749751e04b2041b55e92dac94b3" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="733eefc07bf9e51bd55cbb49b0874fcb5f17d31b" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="75a38fbd33678c8e1ac4ad25b0d95cd894290536" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="eb6e0e76a190f2043a8bd3777daebaebf1def2ab" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="ac14468e0ab875750716201383acedb0f1aa59a2" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="4758d777c012362f6479362e01995e935a7b09ed" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBufSome&quot;&gt;hGetBufSome&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBufSome&quot;&gt;hGetBufSome&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="43a808de4e438b2cac191975ec1178b82376b0eb" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="695c3d916d62f2ea55cdb779edc67a44a1f3c788" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="c9752d59da062f75442fd0c45b415851963415b0" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="c2f82e3a8d0be8d48a4f40713cb2d9fb06f2e221" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBufSome&quot;&gt;hGetBufSome&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBufSome&quot;&gt;hGetBufSome&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="2eb52b41e41c616d22190f5e23f9b5d53c5c8fa6" translate="yes" xml:space="preserve">
          <source>If the handler returns a value wrapped with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;, that value will be used in the output as the replacement for the invalid input. If it returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, no value will be used in the output.</source>
          <target state="translated">ハンドラーが &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; でラップされた値を返す場合、その値は無効な入力の代わりとして出力で使用されます。 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を返す場合、出力では値は使用されません。</target>
        </trans-unit>
        <trans-unit id="fe922e3d119fe0f1cc74a44c92d349bcf461e892" translate="yes" xml:space="preserve">
          <source>If the initial buffer is too small to hold all data, subsequent buffers will be the default buffer size.</source>
          <target state="translated">初期バッファが小さすぎてすべてのデータを保持できない場合、それ以降のバッファはデフォルトのバッファサイズになります。</target>
        </trans-unit>
        <trans-unit id="1a8e4480bef91d631c461344a2de2236d4cfee75" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid UTF-8 data, an exception will be thrown (either by this function or a continuation) that cannot be caught in pure code. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なUTF-8データが含まれている場合、純粋なコードではキャッチできない例外が（この関数または継続によって）スローされます。無効なデータの処理をさらに制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="bd132895bcb29067d5281e312732641ade69617a" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid UTF-8 data, an exception will be thrown that cannot be caught in pure code. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf8-39-&quot;&gt;decodeUtf8'&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf8With&quot;&gt;decodeUtf8With&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なUTF-8データが含まれている場合、純粋なコードでキャッチできない例外がスローされます。無効なデータの処理をさらに制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf8-39-&quot;&gt;decodeUtf8'&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf8With&quot;&gt;decodeUtf8With&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="f6f85b42e97d38521695bc5719fab602af715f74" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid UTF-8 data, an exception will be thrown that cannot be caught in pure code. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf8-39-&quot;&gt;decodeUtf8'&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf8With&quot;&gt;decodeUtf8With&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なUTF-8データが含まれている場合、純粋なコードでキャッチできない例外がスローされます。無効なデータの処理をさらに制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf8-39-&quot;&gt;decodeUtf8'&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf8With&quot;&gt;decodeUtf8With&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="09b23031b09a6ace4ba4f6ac224b740e40f02c57" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid UTF-8 data, the relevant exception will be returned, otherwise the decoded text.</source>
          <target state="translated">入力に無効な UTF-8 データが含まれている場合は、該当する例外が返され、そうでない場合は復号化されたテキストが返されます。</target>
        </trans-unit>
        <trans-unit id="754415b1a59c2ab620f6ecdfc36468a832eed47d" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid big endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf16BEWith&quot;&gt;decodeUtf16BEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なビッグエンディアンUTF-16データが含まれている場合、例外がスローされます。無効なデータの処理をより詳細に制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf16BEWith&quot;&gt;decodeUtf16BEWith&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="24a4190d0c5a617251a227f4e4ffc0dc4c3ec80e" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid big endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf16BEWith&quot;&gt;decodeUtf16BEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なビッグエンディアンUTF-16データが含まれている場合、例外がスローされます。無効なデータの処理をより詳細に制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf16BEWith&quot;&gt;decodeUtf16BEWith&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="a938f8cb41602c2e37ba21b2b1d159bacbe79e60" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid big endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf32BEWith&quot;&gt;decodeUtf32BEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なビッグエンディアンUTF-32データが含まれている場合、例外がスローされます。無効なデータの処理をさらに制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf32BEWith&quot;&gt;decodeUtf32BEWith&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="e0a0fd29f327678893fbe7d2c540d1bfc2f81f6e" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid big endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf32BEWith&quot;&gt;decodeUtf32BEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なビッグエンディアンUTF-32データが含まれている場合、例外がスローされます。無効なデータの処理をさらに制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf32BEWith&quot;&gt;decodeUtf32BEWith&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="64bf7ac928bb9d8d34aaf3441fc5265800b5a9d5" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid little endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf16LEWith&quot;&gt;decodeUtf16LEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なリトルエンディアンUTF-16データが含まれている場合、例外がスローされます。無効なデータの処理をより詳細に制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf16LEWith&quot;&gt;decodeUtf16LEWith&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="de1b7df55ab6d8158aa8cf994eaac1e0b9224b7e" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid little endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf16LEWith&quot;&gt;decodeUtf16LEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なリトルエンディアンUTF-16データが含まれている場合、例外がスローされます。無効なデータの処理をより詳細に制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf16LEWith&quot;&gt;decodeUtf16LEWith&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="70c2f670f171baeb0231536712051cb1c8aaf33a" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid little endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf32LEWith&quot;&gt;decodeUtf32LEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なリトルエンディアンUTF-32データが含まれている場合、例外がスローされます。無効なデータの処理をより詳細に制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf32LEWith&quot;&gt;decodeUtf32LEWith&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="c26edc2ab81f9a20a2fa34e0b70f9dd71e74d9ab" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid little endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf32LEWith&quot;&gt;decodeUtf32LEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なリトルエンディアンUTF-32データが含まれている場合、例外がスローされます。無効なデータの処理をより詳細に制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf32LEWith&quot;&gt;decodeUtf32LEWith&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="5d43fcf632f6993095dae2aeab0f213b43767b8e" translate="yes" xml:space="preserve">
          <source>If the key exists in the map, this function is lazy in &lt;code&gt;value&lt;/code&gt; but strict in the result of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">キーがマップに存在する場合、この関数の &lt;code&gt;value&lt;/code&gt; は遅延しますが、 &lt;code&gt;f&lt;/code&gt; の結果は厳密です。</target>
        </trans-unit>
        <trans-unit id="625b4beded575a88ac5daec835ba706a687d2bcb" translate="yes" xml:space="preserve">
          <source>If the keys of the list are ordered, linear-time implementation is used, with the performance equal to &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">リストのキーが順序付けられている場合、線形時間の実装が使用され、パフォーマンスは &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="b1448f4c78b74e05628456296d2ae49ddecc501e" translate="yes" xml:space="preserve">
          <source>If the keys of the list are ordered, linear-time implementation is used, with the performance equal to &lt;code&gt;&lt;a href=&quot;data-map-strict#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">リストのキーが順序付けられている場合、線形時間の実装が使用され、パフォーマンスは &lt;code&gt;&lt;a href=&quot;data-map-strict#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="749dbe9f6d5460db51b381f2ed3cc45b62922708" translate="yes" xml:space="preserve">
          <source>If the linker complains about not finding &lt;code&gt;_&amp;lt;something&amp;gt;_fast&lt;/code&gt;, then something is inconsistent: you probably didn&amp;rsquo;t compile modules in the proper dependency order.</source>
          <target state="translated">リンカが &lt;code&gt;_&amp;lt;something&amp;gt;_fast&lt;/code&gt; を見つけられないと不平を言った場合、何かが一貫していません。おそらく、適切な依存関係の順序でモジュールをコンパイルしていません。</target>
        </trans-unit>
        <trans-unit id="17ce2aaa6f885fafff129a1f5c7f288b0246cde9" translate="yes" xml:space="preserve">
          <source>If the module is omitted, then the most recently-loaded module is used.</source>
          <target state="translated">モジュールが省略された場合は、最も最近ロードされたモジュールが使用されます。</target>
        </trans-unit>
        <trans-unit id="06465b1683dc6997624e8cf98f88a5ffebfed678" translate="yes" xml:space="preserve">
          <source>If the object becomes unreachable right before the program exits, then GC may not be performed. Finalizers run during GC, so finalizers associated with the object do not run if GC does not happen.</source>
          <target state="translated">プログラムが終了する直前にオブジェクトが到達不可能になった場合、GC が実行されないことがあります。ファイナライザは GC 2011 の間に実行されるので、GC 2011 が起こらない場合、オブジェクトに関連付けられたファイナライザは実行されません。</target>
        </trans-unit>
        <trans-unit id="1118a0190298be9b79dcb8130235e2ed75e7ad6d" translate="yes" xml:space="preserve">
          <source>If the operations needed are available in &lt;a href=&quot;ghc-list&quot;&gt;GHC.List&lt;/a&gt;, it's recommended to avoid importing this module and use &lt;a href=&quot;ghc-list&quot;&gt;GHC.List&lt;/a&gt; instead for now.</source>
          <target state="translated">必要な操作が&lt;a href=&quot;ghc-list&quot;&gt;GHC.List&lt;/a&gt;で利用できる場合は、このモジュールのインポートを回避し、代わりに今の&lt;a href=&quot;ghc-list&quot;&gt;ところGHC.List&lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d002b03429965487a13f5d84e867b7a6ca60210f" translate="yes" xml:space="preserve">
          <source>If the option &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; is passed to the compiler, the above restrictions are not enforced and it is on the programmer to ensure termination of the normalisation of type families during type inference.</source>
          <target state="translated">オプション&lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt;がコンパイラーに渡される場合、上記の制限は適用されず、型推論中に型ファミリーの正規化を確実に終了するのはプログラマーの責任です。</target>
        </trans-unit>
        <trans-unit id="a071a26aa48a39d43d14f16a87c253716cb792f4" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;--simple-output&lt;/code&gt; is given, then the packages are listed on a single line separated by spaces, and the database names are not included. This is intended to make it easier to parse the output of &lt;code&gt;ghc-pkg list&lt;/code&gt; using a script.</source>
          <target state="translated">オプション &lt;code&gt;--simple-output&lt;/code&gt; が指定されている場合、パッケージはスペースで区切られた1行でリストされ、データベース名は含まれません。これは、スクリプトを使用して &lt;code&gt;ghc-pkg list&lt;/code&gt; 出力を簡単に解析できるようにすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="a2972ccb36c0dde44e00d9bbf8a450ab2fdf58ed" translate="yes" xml:space="preserve">
          <source>If the package contains profiling libraries, then the interface files for those library modules should have the suffix &lt;code&gt;.p_hi&lt;/code&gt;. So the package can contain both normal and profiling versions of the same library without conflict (see also &lt;code&gt;library_dirs&lt;/code&gt; below).</source>
          <target state="translated">パッケージにプロファイリングライブラリが含まれている場合、それらのライブラリモジュールのインターフェイスファイルには、サフィックス &lt;code&gt;.p_hi&lt;/code&gt; が必要です。したがって、パッケージには、同じライブラリの通常バージョンとプロファイリングバージョンの両方を競合なしで含めることができます（以下の &lt;code&gt;library_dirs&lt;/code&gt; も参照）。</target>
        </trans-unit>
        <trans-unit id="8ccd8f5434504821c2b94076a11f8715fe0b84ba" translate="yes" xml:space="preserve">
          <source>If the parameter &lt;code&gt;a&lt;/code&gt; appears underneath a composition of other type constructors, then the representation involves composition, too:</source>
          <target state="translated">パラメータ &lt;code&gt;a&lt;/code&gt; が他の型コンストラクタの構成の下にある場合、表現にも構成が含まれます。</target>
        </trans-unit>
        <trans-unit id="32cab9cb10b6c38303476943187addc7db896eb0" translate="yes" xml:space="preserve">
          <source>If the path is already absolute, the operation never fails. Otherwise, the operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">パスがすでに絶対パスである場合、操作が失敗することはありません。それ以外の場合、操作は &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; と同じ例外で失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="00b17cb9d8e7bb5e296d3da780f46cf2d367124c" translate="yes" xml:space="preserve">
          <source>If the path is already absolute, the operation never fails. Otherwise, the operation may throw exceptions.</source>
          <target state="translated">パスがすでに絶対パスである場合、操作が失敗することはありません。それ以外の場合は例外が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="2cd818a895dd0680e5558fe6703f03edd2d2230d" translate="yes" xml:space="preserve">
          <source>If the path points to an existing file or directory, then the output path shall also point to the same file or directory, subject to the condition that the relevant parts of the file system do not change while the function is still running. In other words, the function is definitively not atomic. The results can be utterly wrong if the portions of the path change while this function is running.</source>
          <target state="translated">パスが既存のファイルやディレクトリを指している場合,関数の実行中にファイルシステムの関連部分が変更されないことを条件に,出力パスも同じファイルやディレクトリを指しているものとする。言い換えれば,この関数は決定的にアトミックではありません.この関数の実行中にパスの一部が変更された場合,結果は全く間違ったものになる可能性がある。</target>
        </trans-unit>
        <trans-unit id="17dcdf1f1aa0a2191303abce0bb5187d7f7a9885" translate="yes" xml:space="preserve">
          <source>If the pattern is a constructor pattern &lt;code&gt;(P p1 ... pn)&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern synonym defined by &lt;code&gt;P x1 ... xn = p&lt;/code&gt; or &lt;code&gt;P x1 ... xn &amp;lt;- p&lt;/code&gt;, then:</source>
          <target state="translated">パターンがコンストラクターパターン &lt;code&gt;(P p1 ... pn)&lt;/code&gt; である場合、 &lt;code&gt;P&lt;/code&gt; は &lt;code&gt;P x1 ... xn = p&lt;/code&gt; または &lt;code&gt;P x1 ... xn &amp;lt;- p&lt;/code&gt; -pによって定義されるパターン同義語であり、次のようになります。</target>
        </trans-unit>
        <trans-unit id="3ba484df09e44ad6151f620767b5567f42c57031" translate="yes" xml:space="preserve">
          <source>If the pattern matches multiple packages, the description for each package is emitted, separated by the string &lt;code&gt;---&lt;/code&gt; on a line by itself.</source>
          <target state="translated">パターンが複数のパッケージに一致する場合、各パッケージの説明が文字列 &lt;code&gt;---&lt;/code&gt; で区切られて、1行に出力されます。</target>
        </trans-unit>
        <trans-unit id="eddedbc84892409431bb5cd9dff6d864c792acc8" translate="yes" xml:space="preserve">
          <source>If the plugin cannot make any progress, it should return &lt;code&gt;TcPluginOk [] []&lt;/code&gt;. Otherwise, if there were any new constraints, the main constraint solver will be re-invoked to simplify them, then the plugin will be invoked again. The plugin is responsible for making sure that this process eventually terminates.</source>
          <target state="translated">プラグインが何も進行できない場合は、 &lt;code&gt;TcPluginOk [] []&lt;/code&gt; 返す必要があります。そうでない場合、新しい制約があった場合、それらを簡略化するためにメインの制約ソルバーが再度呼び出され、プラグインが再度呼び出されます。プラグインは、このプロセスが最終的に終了することを確認する責任があります。</target>
        </trans-unit>
        <trans-unit id="f4dd01b74a08371cbefaa339741c2f2bf732cc33" translate="yes" xml:space="preserve">
          <source>If the pointer argument to &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; behaves like &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;. If the requested size is 0, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; behaves like &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ポインタ引数場合 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; がある &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; のように振る舞う &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 。要求されたサイズが0の場合、 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; のように動作します。</target>
        </trans-unit>
        <trans-unit id="94a8bff9ac670099a84c99ae99166a8b13917470" translate="yes" xml:space="preserve">
          <source>If the program needs to be linked with additional objects (say, some auxiliary C code), then the object files can be given on the command line and GHC will include them when linking the executable.</source>
          <target state="translated">プログラムを追加のオブジェクト(例えば、補助的なCコード)とリンクする必要がある場合は、コマンドラインでオブジェクトファイルを指定することができ、実行ファイルをリンクする際にGHCがそれらを含めます。</target>
        </trans-unit>
        <trans-unit id="cf0e55f0ed3aeca48a639cdc97cfce430926d732" translate="yes" xml:space="preserve">
          <source>If the program&amp;rsquo;s heap exceeds the value set by &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-M ⟨size⟩&lt;/code&gt;&lt;/a&gt;, the RTS throws an exception to the program, and the program gets an additional quota of allocation before the exception is raised again, the idea being so that the program can execute its exception handlers. &lt;code&gt;-Mgrace=&lt;/code&gt; controls the size of this additional quota.</source>
          <target state="translated">プログラムのヒープが&lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-M ⟨size⟩&lt;/code&gt; &lt;/a&gt;によって設定された値を超えると、RTSはプログラムに例外をスローし、プログラムは例外が再度発生する前に割り当ての追加割り当てを取得します。例外ハンドラ。 &lt;code&gt;-Mgrace=&lt;/code&gt; は、この追加のクォータのサイズを制御します。</target>
        </trans-unit>
        <trans-unit id="a05bad59c9ffd07726909b6b71df24cb1faeae56" translate="yes" xml:space="preserve">
          <source>If the quotes are left off in the above command, &lt;code&gt;ghci&lt;/code&gt; will interpret the filename as two, &lt;code&gt;c:\\\\Program&lt;/code&gt; and &lt;code&gt;Files\\\\Haskell\\\\Project.hs&lt;/code&gt;.</source>
          <target state="translated">上記のコマンドで引用符が &lt;code&gt;ghci&lt;/code&gt; されている場合、ghciはファイル名を &lt;code&gt;c:\\\\Program&lt;/code&gt; および &lt;code&gt;Files\\\\Haskell\\\\Project.hs&lt;/code&gt; 2つとして解釈します。</target>
        </trans-unit>
        <trans-unit id="2999a971417548d37995328ba747557f94ced1e4" translate="yes" xml:space="preserve">
          <source>If the specifics of the data format is not important to you, for example, you are more interested in serializing and deserializing values than in which format will be used, it is possible to derive &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; instances using the generic support. See &lt;code&gt;&lt;a href=&quot;data-binary#t:GBinaryGet&quot;&gt;GBinaryGet&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#t:GBinaryPut&quot;&gt;GBinaryPut&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">データ形式の詳細が重要ではない場合、たとえば、使用される形式よりも値のシリアル化と逆シリアル化に関心がある場合は、汎用サポートを使用して &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; インスタンスを派生させることができます。 &lt;code&gt;&lt;a href=&quot;data-binary#t:GBinaryGet&quot;&gt;GBinaryGet&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;data-binary#t:GBinaryPut&quot;&gt;GBinaryPut&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="3bff18fc6fb06d1186c47eea05dc08be6efd2b10" translate="yes" xml:space="preserve">
          <source>If the strings do not have a common prefix or either one is empty, this function returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">文字列に共通の接頭辞がないか、どちらかが空の場合、この関数は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="a96483a865258b93f60fbe9c7b1b6209ab588de4" translate="yes" xml:space="preserve">
          <source>If the system call is successfully interrupted, it will return to Haskell whereupon the exception can be raised. Be especially careful when using &lt;code&gt;interruptible&lt;/code&gt; that the caller of the foreign function is prepared to deal with the consequences of the call being interrupted; on Unix it is good practice to check for &lt;code&gt;EINTR&lt;/code&gt; always, but on Windows it is not typically necessary to handle &lt;code&gt;ERROR_OPERATION_ABORTED&lt;/code&gt;.</source>
          <target state="translated">システムコールが正常に中断された場合、Haskellに戻り、例外が発生します。 &lt;code&gt;interruptible&lt;/code&gt; を使用する場合は、外部関数の呼び出し元が、中断された呼び出しの結果に対処する準備ができていることに特に注意してください。 Unixでは常に &lt;code&gt;EINTR&lt;/code&gt; をチェックすることをお &lt;code&gt;ERROR_OPERATION_ABORTED&lt;/code&gt; しますが、Windowsでは通常、ERROR_OPERATION_ABORTEDを処理する必要はありません。</target>
        </trans-unit>
        <trans-unit id="b0ea0825d60f59ed95619566d152ac3af5d1dc48" translate="yes" xml:space="preserve">
          <source>If the target of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is the calling thread, then the behaviour is the same as &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; のターゲットが呼び出し側のスレッドである場合、例外が非同期例外としてスローされることを除いて、動作は &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; と同じです。つまり、現在のIO操作が &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; の内部にある場合など、囲んでいる純粋な計算がある場合、その計算は例外によって永続的に置き換えられるのではなく、非同期例外を受け取ったかのように中断されます。</target>
        </trans-unit>
        <trans-unit id="ef565fe58fa8cc5e2adb616fefe14b2fe53e3eb9" translate="yes" xml:space="preserve">
          <source>If the target of &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is the calling thread, then the behaviour is the same as &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; のターゲットが呼び出し側のスレッドである場合、例外が非同期例外としてスローされることを除いて、動作は &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; と同じです。つまり、現在のIO操作が &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; の内部にある場合など、囲んでいる純粋な計算がある場合、その計算は例外によって永続的に置き換えられるのではなく、非同期例外を受け取ったかのように中断されます。</target>
        </trans-unit>
        <trans-unit id="29ed533e57740cc52561c9e0778a3939079b1869" translate="yes" xml:space="preserve">
          <source>If the target of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is the calling thread, then the behaviour is the same as &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; のターゲットが呼び出し側のスレッドである場合、例外が非同期例外としてスローされることを除いて、動作は &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; と同じです。つまり、現在のIO操作が &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; の内部にある場合など、囲んでいる純粋な計算がある場合、その計算は例外によって永続的に置き換えられるのではなく、非同期例外を受け取ったかのように中断されます。</target>
        </trans-unit>
        <trans-unit id="3b5423771ba3f07d0d121d4047b87be07039385d" translate="yes" xml:space="preserve">
          <source>If the target of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is the calling thread, then the behaviour is the same as &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; のターゲットが呼び出し側のスレッドである場合、例外が非同期例外としてスローされることを除いて、動作は &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; と同じです。つまり、現在のIO操作が &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; の内部にある場合など、囲んでいる純粋な計算がある場合、その計算は例外によって永続的に置き換えられるのではなく、非同期例外を受け取ったかのように中断されます。</target>
        </trans-unit>
        <trans-unit id="f635604a794f0509d229ca0450224e3801f13960" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="translated">ターゲットスレッドが現在外部呼び出しを行っている場合、呼び出しが完了するまで例外は発生しません（したがって、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は戻りません）。これは、呼び出しが &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 内にあるかどうかに関係なく当てはまります。しかし、GHCで外国呼び出しは次のように注釈を付けることができる &lt;code&gt;interruptible&lt;/code&gt; 、その場合には、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は RTSが復帰への呼び出しを引き起こすことを試みることになります。詳細については、GHCのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="cb32a1414cef013e5d3c55de2b52fcec36dfcc67" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="translated">ターゲットスレッドが現在外部呼び出しを行っている場合、呼び出しが完了するまで例外は発生しません（したがって、 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は戻りません）。これは、呼び出しが &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 内にあるかどうかに関係なく当てはまります。しかし、GHCで外国呼び出しは次のように注釈を付けることができる &lt;code&gt;interruptible&lt;/code&gt; 、その場合には、 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は RTSが復帰への呼び出しを引き起こすことを試みることになります。詳細については、GHCのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="410b774382afae43c015c978d6a4c05a23286a81" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="translated">ターゲットスレッドが現在外部呼び出しを行っている場合、呼び出しが完了するまで例外は発生しません（したがって、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は戻りません）。これは、呼び出しが &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 内にあるかどうかに関係なく当てはまります。しかし、GHCで外国呼び出しは次のように注釈を付けることができる &lt;code&gt;interruptible&lt;/code&gt; 、その場合には、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は RTSが復帰への呼び出しを引き起こすことを試みることになります。詳細については、GHCのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="6aae4a4891882f9616442e3ab4e703d074ae744f" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="translated">ターゲットスレッドが現在外部呼び出しを行っている場合、呼び出しが完了するまで例外は発生しません（したがって、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は戻りません）。これは、呼び出しが &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 内にあるかどうかに関係なく当てはまります。しかし、GHCで外国呼び出しは次のように注釈を付けることができる &lt;code&gt;interruptible&lt;/code&gt; 、その場合には、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は RTSが復帰への呼び出しを引き起こすことを試みることになります。詳細については、GHCのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="0efe330fe5a7f319c74a83698c2016b7024d2870" translate="yes" xml:space="preserve">
          <source>If the tick-count expires, GHC summarises what simplifier steps it has done; you can use &lt;code&gt;-fddump-simpl-stats&lt;/code&gt; to generate a much more detailed list. Usually that identifies the loop quite accurately, because some numbers are very large.</source>
          <target state="translated">ティックカウントが期限切れになると、GHCはそれが行った単純化ステップを要約します。 &lt;code&gt;-fddump-simpl-stats&lt;/code&gt; を使用して、より詳細なリストを生成できます。一部の数値が非常に大きいため、通常はループを非常に正確に識別します。</target>
        </trans-unit>
        <trans-unit id="f834f3278901f9fdfc11689ba5008e3d53a52f10" translate="yes" xml:space="preserve">
          <source>If the type is also a &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; instance, it should satisfy:</source>
          <target state="translated">型が &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; インスタンスでもある場合、次の条件を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="27c720209a65937fe0295731a0ddd0e77cf4c007" translate="yes" xml:space="preserve">
          <source>If the type is also a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, it should satisfy</source>
          <target state="translated">タイプが &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; インスタンスでもある場合、それは満たす必要があります</target>
        </trans-unit>
        <trans-unit id="c31cbe33b88501dc1cab64cc221110f7cc955564" translate="yes" xml:space="preserve">
          <source>If the type is also a &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, it should satisfy</source>
          <target state="translated">タイプが &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; インスタンスでもある場合、それは満たす必要があります</target>
        </trans-unit>
        <trans-unit id="b1a3cb38f79f019c8eefd564552c10ef09d46fb9" translate="yes" xml:space="preserve">
          <source>If the type signature includes any kind annotations (either on variable binders or as annotations on types), any variables used in kind annotations come before any variables never used in kind annotations. This rule is not recursive: if there is an annotation within an annotation, then the variables used therein are on equal footing. Examples:</source>
          <target state="translated">タイプシグネチャに何らかの種類の注釈が含まれている場合(変数のバインダー上または型の注釈として)、種類の注釈で使用される変数は、種類の注釈では使用されない変数の前に置かれます。このルールは再帰的ではありません:もしアノテーションの中にアノテーションがある場合、その中で使われる変数は等しくなります。例を示します。</target>
        </trans-unit>
        <trans-unit id="8c4ea0e44780d77e1880898106ce1bbf9df2c555" translate="yes" xml:space="preserve">
          <source>If the types of &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; are not unboxed, the resulting binding is lazy like any other Haskell pattern binding. The above example desugars like this:</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; と &lt;code&gt;q&lt;/code&gt; のタイプがボックス化されていない場合、結果のバインディングは他のHaskellパターンバインディングと同様に遅延になります。上記の例は、次のようなものです。</target>
        </trans-unit>
        <trans-unit id="b6f18250f43f2740e1195441a25da60c594f32dd" translate="yes" xml:space="preserve">
          <source>If the underlying encoding is not itself roundtrippable, this mechanism can fail. Roundtrippable encodings are those which have an injective mapping into Unicode. Almost all encodings meet this criteria, but some do not. Notably, Shift-JIS (CP932) and Big5 contain several different encodings of the same Unicode codepoint.</source>
          <target state="translated">基礎となるエンコーディングがそれ自体がラウンドトリップ可能でない場合、このメカニズムは失敗する可能性があります。ラウンドトリップ可能なエンコーディングとは、 Unicode へのマッピングが有効なエンコーディングのことです。ほとんどすべてのエンコーディングはこの基準を満たしていますが、中には満たしていないものもあります。特筆すべきは、Shift-JIS (CP932)と Big5 には、同じ Unicode コードポイントの複数の異なるエンコーディングが含まれていることです。</target>
        </trans-unit>
        <trans-unit id="f18d7f0b53d60c67a0f0044ea31055a7a2c5370e" translate="yes" xml:space="preserve">
          <source>If the user has supplied a type signature, as in &lt;code&gt;f&lt;/code&gt;, then this is easy: we just take the ordering from the type signature, going left to right and using the first occurrence of a variable to choose its position within the ordering. Thus, the variables in &lt;code&gt;f&lt;/code&gt; will be &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">ユーザーが &lt;code&gt;f&lt;/code&gt; のように型シグネチャを指定した場合、これは簡単です。型シグネチャの順序を左から右に取り、最初に出現する変数を使用して順序内での位置を選択するだけです。このように、の変数 &lt;code&gt;f&lt;/code&gt; がされます &lt;code&gt;b&lt;/code&gt; は、それから。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="153127ffa367d83e2cf43ec8214e9672b8320af2" translate="yes" xml:space="preserve">
          <source>If the user writes &quot;lexical&quot;, the parser fails with: &lt;code&gt;unexpected
 'x', expecting 't' in &quot;let&quot;&lt;/code&gt;. Indeed, since the (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator only tries alternatives when the first alternative hasn't consumed input, the &lt;code&gt;identifier&lt;/code&gt; parser is never tried (because the prefix &quot;le&quot; of the &lt;code&gt;string &quot;let&quot;&lt;/code&gt; parser is already consumed). The right behaviour can be obtained by adding the &lt;code&gt;try&lt;/code&gt; combinator:</source>
          <target state="translated">ユーザーが「字句」を書き込むと、パーサーは次のエラーで失敗します。 &lt;code&gt;unexpected 'x', expecting 't' in &quot;let&quot;&lt;/code&gt; です。実際、（ &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）コンビネータは、最初の代替が入力を消費していない場合にのみ代替を試行するため、 &lt;code&gt;identifier&lt;/code&gt; パーサーは試行されません（ &lt;code&gt;string &quot;let&quot;&lt;/code&gt; パーサーのプレフィックス &quot;le&quot; がすでに消費されているため）。正しい動作は、 &lt;code&gt;try&lt;/code&gt; コンビネーターを追加することで取得できます。</target>
        </trans-unit>
        <trans-unit id="077149390f83f66f25123eacbd59fbfc008ad8c0" translate="yes" xml:space="preserve">
          <source>If the user writes &quot;lexical&quot;, the parser fails with: &lt;code&gt;unexpected
 'x', expecting 't' in &quot;let&quot;&lt;/code&gt;. Indeed, since the (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator only tries alternatives when the first alternative hasn't consumed input, the &lt;code&gt;identifier&lt;/code&gt; parser is never tried (because the prefix &quot;le&quot; of the &lt;code&gt;string &quot;let&quot;&lt;/code&gt; parser is already consumed). The right behaviour can be obtained by adding the &lt;code&gt;try&lt;/code&gt; combinator:</source>
          <target state="translated">ユーザーが「字句」を書き込むと、パーサーは次のエラーで失敗します。 &lt;code&gt;unexpected 'x', expecting 't' in &quot;let&quot;&lt;/code&gt; です。実際、（ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）コンビネータは、最初の代替が入力を消費していない場合にのみ代替を試行するため、 &lt;code&gt;identifier&lt;/code&gt; パーサーは試行されません（ &lt;code&gt;string &quot;let&quot;&lt;/code&gt; パーサーのプレフィックス &quot;le&quot; がすでに消費されているため）。正しい動作は、 &lt;code&gt;try&lt;/code&gt; コンビネーターを追加することで取得できます。</target>
        </trans-unit>
        <trans-unit id="627396045def6a2b30cfb67918ea7b827134e0dc" translate="yes" xml:space="preserve">
          <source>If the value of the error is not required, the variant in &lt;a href=&quot;control-monad-trans-maybe&quot;&gt;Control.Monad.Trans.Maybe&lt;/a&gt; may be used instead.</source>
          <target state="translated">エラーの値が不要な場合は、代わりに&lt;a href=&quot;control-monad-trans-maybe&quot;&gt;Control.Monad.Trans.Maybe&lt;/a&gt;のバリアントを使用できます。</target>
        </trans-unit>
        <trans-unit id="9cbcf45c8589b25e6b77fbe3fd739a89f107ae36" translate="yes" xml:space="preserve">
          <source>If the value of the exception is not required, the variant in &lt;a href=&quot;control-monad-trans-maybe&quot;&gt;Control.Monad.Trans.Maybe&lt;/a&gt; may be used instead.</source>
          <target state="translated">例外の値が不要な場合は、代わりに&lt;a href=&quot;control-monad-trans-maybe&quot;&gt;Control.Monad.Trans.Maybe&lt;/a&gt;のバリアントを使用できます。</target>
        </trans-unit>
        <trans-unit id="9596c4f417cd0a2eeda3532c57a9759b3148d2e2" translate="yes" xml:space="preserve">
          <source>If there are multiple exposed versions of a package, GHC will prefer the latest one. Additionally, some packages may be broken: that is, they are missing from the package database, or one of their dependencies are broken; in this case; these packages are excluded from the default set of packages.</source>
          <target state="translated">パッケージの複数のバージョンが公開されている場合、GHC は最新のものを優先します。さらに、いくつかのパッケージが壊れているかもしれません:パッケージデータベースから消えていたり、依存関係が壊れていたりしています;この場合、これらのパッケージはデフォルトのパッケージセットから除外されます。</target>
        </trans-unit>
        <trans-unit id="2744f509c20d0d226472161d7c5e0d680881c742" translate="yes" xml:space="preserve">
          <source>If there are no other threads to run, the runtime system will check for runnable finalizers before declaring the system to be deadlocked.</source>
          <target state="translated">他に実行するスレッドがない場合、ランタイムシステムはデッドロックを宣言する前に実行可能なファイナライザをチェックします。</target>
        </trans-unit>
        <trans-unit id="2754d33a517265ae953ce70490f5a33b97494617" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- i.e. the enclosing function has a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint -- GHC will append the new call-site to the existing &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">スコープに &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; がある場合、つまり、囲んでいる関数に &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 制約がある場合、GHCは既存の &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; に新しい呼び出しサイトを追加します。</target>
        </trans-unit>
        <trans-unit id="f4b72501bc991c36ff4bffdeb5e90240c549826c" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- i.e. the enclosing function has a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint -- GHC will append the new call-site to the existing &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">スコープに &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; がある場合、つまり、囲んでいる関数に &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 制約がある場合、GHCは既存の &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; に新しい呼び出しサイトを追加します。</target>
        </trans-unit>
        <trans-unit id="786b9b7efbfcf460816260b5fc3891ba66319ff4" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- i.e. the enclosing function has a &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint -- GHC will append the new call-site to the existing &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">スコープに &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; がある場合、つまり、囲んでいる関数に &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 制約がある場合、GHCは既存の &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; に新しい呼び出しサイトを追加します。</target>
        </trans-unit>
        <trans-unit id="fdb2173b7203347d640f077ccdf8f741ab650cd9" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;CallStack&lt;/code&gt; in scope &amp;ndash; i.e. the enclosing definition has a &lt;code&gt;HasCallStack&lt;/code&gt; constraint &amp;ndash; GHC will push the new call-site onto the existing &lt;code&gt;CallStack&lt;/code&gt;.</source>
          <target state="translated">スコープに &lt;code&gt;CallStack&lt;/code&gt; がある場合、つまり、包含定義に &lt;code&gt;HasCallStack&lt;/code&gt; 制約がある場合、GHCは新しい呼び出しサイトを既存の &lt;code&gt;CallStack&lt;/code&gt; にプッシュします。</target>
        </trans-unit>
        <trans-unit id="9751e595298ec0b63212d3d3e3da71e206e9047f" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;-odir&lt;/code&gt; option (the default), then the object filename is derived from the source filename (ignoring the module name) by replacing the suffix with ⟨osuf⟩.</source>
          <target state="translated">&lt;code&gt;-odir&lt;/code&gt; オプションがない場合（デフォルト）、オブジェクトのファイル名は、サフィックスを「osuf」で置き換えることにより、ソースファイル名（モジュール名は無視）から派生します。</target>
        </trans-unit>
        <trans-unit id="0459b16b546d66c267a51da320d328d26755c8cb" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- e.g. in the GHCi session above -- and the enclosing definition does not have an explicit type signature, GHC will infer a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the enclosing definition (subject to the monomorphism restriction).</source>
          <target state="translated">スコープに &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; がない場合（上記のGHCiセッションなど）、外側の定義に明示的な型シグネチャがない場合、GHCは &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 定義のHasCallStack制約を推測します（単相性の制限に従います）。</target>
        </trans-unit>
        <trans-unit id="51b3dd98e9cfee97be33be76a5f1ce7dc9f8f5e6" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope and the enclosing definition has an explicit type signature, GHC will solve the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the singleton &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; containing just the current call-site.</source>
          <target state="translated">スコープに &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; がなく、それを含む定義に明示的な型シグニチャーがある場合、GHCは現在の呼び出しサイトのみを含むシングルトン &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 制約を解決します。</target>
        </trans-unit>
        <trans-unit id="1471f8828c2379e165ca2717ec8725b325f74acd" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- e.g. in the GHCi session above -- and the enclosing definition does not have an explicit type signature, GHC will infer a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the enclosing definition (subject to the monomorphism restriction).</source>
          <target state="translated">スコープに &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; がない場合（上記のGHCiセッションなど）、外側の定義に明示的な型シグネチャがない場合、GHCは &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 定義のHasCallStack制約を推測します（単相性の制限に従います）。</target>
        </trans-unit>
        <trans-unit id="af5dadc898713c4d1ac69f3e2c4c1c3cd662c85a" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope and the enclosing definition has an explicit type signature, GHC will solve the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the singleton &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; containing just the current call-site.</source>
          <target state="translated">スコープに &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; がなく、それを含む定義に明示的な型シグニチャーがある場合、GHCは現在の呼び出しサイトのみを含むシングルトン &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 制約を解決します。</target>
        </trans-unit>
        <trans-unit id="c0a2154090a11c56205c916716db23e3aaf5e97a" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- e.g. in the GHCi session above -- and the enclosing definition does not have an explicit type signature, GHC will infer a &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the enclosing definition (subject to the monomorphism restriction).</source>
          <target state="translated">スコープに &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; がない場合（上記のGHCiセッションなど）、外側の定義に明示的な型シグネチャがない場合、GHCは &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 定義のHasCallStack制約を推測します（単相性の制限に従います）。</target>
        </trans-unit>
        <trans-unit id="ebb76c92af062244a4e188e2b7f8ad3c706df8fb" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope and the enclosing definition has an explicit type signature, GHC will solve the &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the singleton &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; containing just the current call-site.</source>
          <target state="translated">スコープに &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; がなく、それを含む定義に明示的な型シグニチャーがある場合、GHCは現在の呼び出しサイトのみを含むシングルトン &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 制約を解決します。</target>
        </trans-unit>
        <trans-unit id="c41b4ceb40ee7df7d2779d08c19440a00fd4dee9" translate="yes" xml:space="preserve">
          <source>If these instances can be defined, defining instances of the base classes is mechanical:</source>
          <target state="translated">これらのインスタンスを定義できるのであれば、基底クラスのインスタンスを定義することは機械的である。</target>
        </trans-unit>
        <trans-unit id="7a9d1a25b60758f4043441274ee9783e99a3d47e" translate="yes" xml:space="preserve">
          <source>If this flag is on, call-pattern specialisation will specialise a call &lt;code&gt;(f (Just x))&lt;/code&gt; with an explicit constructor argument, even if the argument is not scrutinised in the body of the function. This is sometimes beneficial; e.g. the argument might be given to some other function that can itself be specialised.</source>
          <target state="translated">このフラグがオンの場合、呼び出しパターン特殊化は、明示的なコンストラクター引数を使用して呼び出し &lt;code&gt;(f (Just x))&lt;/code&gt; を特殊化します（引数が関数の本体で精査されていない場合でも）。これは時々有益です。たとえば、引数はそれ自体が特殊化できる他の関数に与えられるかもしれません。</target>
        </trans-unit>
        <trans-unit id="615c1d104b752d5fbf04f2f7bfaa64a63695c34b" translate="yes" xml:space="preserve">
          <source>If true, create the semaphore if it does not yet exist.</source>
          <target state="translated">真の場合、まだ存在しない場合はセマフォを作成します。</target>
        </trans-unit>
        <trans-unit id="5726894dc0e940e30aa84621008b693bdc032ec8" translate="yes" xml:space="preserve">
          <source>If true, create the shm object if it does not exist.</source>
          <target state="translated">true の場合、存在しない場合は shm オブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="61a6257ede23921542c050cc42cf5a60299cc751" translate="yes" xml:space="preserve">
          <source>If true, open the shm object read-write rather than read-only.</source>
          <target state="translated">trueの場合、shmオブジェクトをリードオンリーではなくリードライトで開きます。</target>
        </trans-unit>
        <trans-unit id="4c1c0f18f18624f27614c4ffe42965205a397757" translate="yes" xml:space="preserve">
          <source>If true, throw an exception if the semaphore already exists.</source>
          <target state="translated">true の場合、セマフォが既に存在する場合は例外をスローします。</target>
        </trans-unit>
        <trans-unit id="fa803c6c609db6b79b17d1491838007497e1d827" translate="yes" xml:space="preserve">
          <source>If true, throw an exception if the shm object already exists.</source>
          <target state="translated">true の場合、shm オブジェクトが既に存在する場合に例外をスローします。</target>
        </trans-unit>
        <trans-unit id="ed093df6f14d931fa3c4c256a6b87b3891dc67ba" translate="yes" xml:space="preserve">
          <source>If true, wipe the contents of the shm object after opening it.</source>
          <target state="translated">true の場合、shm オブジェクトを開いた後に内容をワイプします。</target>
        </trans-unit>
        <trans-unit id="aa3d7aa2ca27566724560024376f27197b54c353" translate="yes" xml:space="preserve">
          <source>If used in conjunction with &lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt;, writes dump output from main C-- pipeline stages to files (each stage per file).</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt;と組み合わせて使用​​すると、メインのC--パイプラインステージからのダンプ出力をファイルに書き込みます（ファイルごとの各ステージ）。</target>
        </trans-unit>
        <trans-unit id="b399c89393340f06d26617e02a5d2db971dcd55d" translate="yes" xml:space="preserve">
          <source>If variable &lt;code&gt;v&lt;/code&gt; at the cursor is depended on by any earlier variable &lt;code&gt;w&lt;/code&gt;, move &lt;code&gt;v&lt;/code&gt; immediately before the leftmost such &lt;code&gt;w&lt;/code&gt;.</source>
          <target state="translated">カーソル位置の変数 &lt;code&gt;v&lt;/code&gt; が以前の変数 &lt;code&gt;w&lt;/code&gt; に依存している場合は、そのような左端の &lt;code&gt;w&lt;/code&gt; の直前に &lt;code&gt;v&lt;/code&gt; を移動します。</target>
        </trans-unit>
        <trans-unit id="05f59d5d88acf30508b2934ebb596d83dcf81d86" translate="yes" xml:space="preserve">
          <source>If we aren&amp;rsquo;t concerned about preserving the evaluatedness of a variable, we can use &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt; command behaves exactly like &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;, except that it forces the evaluation of any thunks it encounters:</source>
          <target state="translated">変数の評価を保持する必要がない場合は、&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; の&lt;/a&gt;代わりに：&lt;a href=&quot;#ghci-cmd-:force&quot;&gt; &lt;code&gt;:force&lt;/code&gt; &lt;/a&gt;を使用できます。&lt;a href=&quot;#ghci-cmd-:force&quot;&gt; &lt;code&gt;:force&lt;/code&gt; &lt;/a&gt;コマンドは正確に同じように動作し&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;それが遭遇するあらゆるサンクの評価を強制することを除いて、：</target>
        </trans-unit>
        <trans-unit id="46aacca2dc2b515359c3629f8b545b4072e9cb10" translate="yes" xml:space="preserve">
          <source>If we expanded the superclasses of &lt;code&gt;C Id&lt;/code&gt; we&amp;rsquo;d get first &lt;code&gt;Id (C Id)&lt;/code&gt; and thence &lt;code&gt;C Id&lt;/code&gt; again.</source>
          <target state="translated">私たちはスーパーの拡大場合は &lt;code&gt;C Id&lt;/code&gt; 我々は最初取得したい &lt;code&gt;Id (C Id)&lt;/code&gt; 、そこから &lt;code&gt;C Id&lt;/code&gt; もう一度。</target>
        </trans-unit>
        <trans-unit id="ab06f8bed3c50d147e0f34ef14e2a2bfe485f229" translate="yes" xml:space="preserve">
          <source>If we map the &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; constructor, the entire list should be returned:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; コンストラクターをマップすると、リスト全体が返されます。</target>
        </trans-unit>
        <trans-unit id="f7cadd59d96946a92a3e4e327a5bdc6e946f758a" translate="yes" xml:space="preserve">
          <source>If we need to combine multiple values we can use the &lt;code&gt;&lt;a href=&quot;data-semigroup#v:sconcat&quot;&gt;sconcat&lt;/a&gt;&lt;/code&gt; function to do so. We need to ensure however that we have at least one value to operate on, since otherwise our result would be undefined. It is for this reason that &lt;code&gt;&lt;a href=&quot;data-semigroup#v:sconcat&quot;&gt;sconcat&lt;/a&gt;&lt;/code&gt; uses &lt;a href=&quot;data-list-nonempty-nonempty&quot;&gt;Data.List.NonEmpty.NonEmpty&lt;/a&gt; - a list that can never be empty:</source>
          <target state="translated">複数の値を組み合わせる必要がある場合は、 &lt;code&gt;&lt;a href=&quot;data-semigroup#v:sconcat&quot;&gt;sconcat&lt;/a&gt;&lt;/code&gt; 関数を使用してこれを行うことができます。ただし、操作する値が少なくとも1つあることを確認する必要があります。そうしないと、結果が未定義になるためです。 &lt;code&gt;&lt;a href=&quot;data-semigroup#v:sconcat&quot;&gt;sconcat&lt;/a&gt;&lt;/code&gt; が&lt;a href=&quot;data-list-nonempty-nonempty&quot;&gt;Data.List.NonEmpty.NonEmpty-&lt;/a&gt;決して空にできないリストを使用するのはこのためです：</target>
        </trans-unit>
        <trans-unit id="3467969828fd41de06ba2ada1d51483a9746f64f" translate="yes" xml:space="preserve">
          <source>If we now load a file into GHCi, the prompt will change:</source>
          <target state="translated">今、GHCiにファイルを読み込むとプロンプトが変わります。</target>
        </trans-unit>
        <trans-unit id="63f9b336b3695cb29c6493fac4402515a8e4d030" translate="yes" xml:space="preserve">
          <source>If we now modify the source of &lt;code&gt;D&lt;/code&gt; (or pretend to: using the Unix command &lt;code&gt;touch&lt;/code&gt; on the source file is handy for this), the compiler will no longer be able to use the object file, because it might be out of date:</source>
          <target state="translated">ここで &lt;code&gt;D&lt;/code&gt; のソースを変更すると（またはそのふりをすると、ソースファイルでUnixコマンド &lt;code&gt;touch&lt;/code&gt; を使用すると便利です）、オブジェクトファイルが古くなっている可能性があるため、コンパイラーはオブジェクトファイルを使用できなくなります。</target>
        </trans-unit>
        <trans-unit id="56aef672862bfcd7939d7f244a055f2611b773c3" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS installs signal handlers to catch things like</source>
          <target state="translated">yes(デフォルト)の場合、RTSは以下のようなものをキャッチするためのシグナルハンドラをインストールします。</target>
        </trans-unit>
        <trans-unit id="b556699afcea8a3861c7bd49d57539e01604beee" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS installs signal handlers to catch things like &lt;code&gt;Ctrl-C&lt;/code&gt;. This option is primarily useful for when you are using the Haskell code as a DLL, and want to set your own signal handlers.</source>
          <target state="translated">はい（デフォルト）の場合、RTSは &lt;code&gt;Ctrl-C&lt;/code&gt; などをキャッチするシグナルハンドラーをインストールします。このオプションは、HaskellコードをDLLとして使用していて、独自のシグナルハンドラーを設定する場合に主に役立ちます。</target>
        </trans-unit>
        <trans-unit id="1824a09e94a9e0974a32536579d942e06a534b49" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows installs exception handlers to catch unhandled exceptions using the Windows exception handling mechanism. This option is primarily useful for when you are using the Haskell code as a DLL, and don&amp;rsquo;t want the RTS to ungracefully terminate your application on errors such as segfaults.</source>
          <target state="translated">はい（デフォルト）の場合、WindowsのRTSは例外ハンドラーをインストールして、Windowsの例外処理メカニズムを使用して未処理の例外をキャッチします。このオプションは主に、HaskellコードをDLLとして使用していて、RTSがセグメンテーション違反などのエラーでアプリケーションを正常に終了させたくない場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="f47cebe51b03f623c16d891f461a3756b2773fce" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows installs exception handlers to catch unhandled exceptions using the Windows exception handling mechanism. This option is primarily useful for when you are using the Haskell code as a DLL, and don&amp;rsquo;t want the RTS to ungracefully terminate your application on erros such as segfaults.</source>
          <target state="translated">はい（デフォルト）の場合、WindowsのRTSは例外ハンドラーをインストールして、Windows例外処理メカニズムを使用して未処理の例外をキャッチします。このオプションは主に、HaskellコードをDLLとして使用していて、RTSがsegfaultsなどのエラーでアプリケーションを異常終了させたくない場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="862def3a23c265087b17b9a922955600a2924ede" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows will generate a core dump on any crash. These dumps can be inspected using debuggers such as WinDBG. The dumps record all code, registers and threading information at the time of the crash. Note that this implies &lt;code&gt;&amp;ndash;install-seh-handlers=yes&lt;/code&gt;.</source>
          <target state="translated">はい（デフォルト）の場合、WindowsのRTSは、クラッシュ時にコアダンプを生成します。これらのダンプは、WinDBGなどのデバッガーを使用して検査できます。ダンプには、クラッシュ時のすべてのコード、レジスタ、およびスレッド情報が記録されます。これは &lt;code&gt;&amp;ndash;install-seh-handlers=yes&lt;/code&gt; を意味することに注意してください。</target>
        </trans-unit>
        <trans-unit id="3e635d9c8063789e49ab24dcfcbdf9f3659eb237" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows will generate a core dump on any crash. These dumps can be inspected using debuggers such as WinDBG. The dumps record all code, registers and threading information at the time of the crash. Note that this implies &lt;code&gt;--install-seh-handlers=yes&lt;/code&gt;.</source>
          <target state="translated">はい（デフォルト）の場合、Windows上のRTSはクラッシュ時にコアダンプを生成します。これらのダンプは、WinDBGなどのデバッガーを使用して検査できます。ダンプは、クラッシュ時のすべてのコード、レジスタ、およびスレッド情報を記録します。これは &lt;code&gt;--install-seh-handlers=yes&lt;/code&gt; を意味することに注意してください。</target>
        </trans-unit>
        <trans-unit id="babf43c52d9b937cdcace43cdc2f276acdb87956" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows will generate a stack trace on crashes if exception handling are enabled. In order to get more information in compiled executables, C code or DLLs symbols need to be available.</source>
          <target state="translated">はい(デフォルト)に設定すると、例外処理が有効になっている場合、Windows の RTS はクラッシュ時にスタックトレースを生成します。コンパイルされた実行ファイルでより多くの情報を得るためには、C コードや DLL のシンボルが利用可能である必要があります。</target>
        </trans-unit>
        <trans-unit id="75dc4a8f44681567411c7cc8c3553fb7e90b3d1c" translate="yes" xml:space="preserve">
          <source>If you absolutely positively want all the rest of the options in a command line to go to the program (and not the RTS), use a &lt;code&gt;--RTS&lt;/code&gt;.</source>
          <target state="translated">コマンドラインの残りのすべてのオプションを（RTSではなく）プログラムに確実に移動させたい場合は、--RTSを使用し &lt;code&gt;--RTS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5eb60052601f4a3531e65c7d5067016decf78928" translate="yes" xml:space="preserve">
          <source>If you also use &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt;, you can write an unboxed tuple in a type synonym:</source>
          <target state="translated">&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;も使用する場合は、ボックス化されていないタプルを型の同義語で記述できます。</target>
        </trans-unit>
        <trans-unit id="705b934efdf6451c14bd14b83d658533f8914cf9" translate="yes" xml:space="preserve">
          <source>If you are building GHC from source, you need at least a stage-2 bootstrap compiler to run Template Haskell splices and quasi-quotes. A stage-1 compiler will only accept regular quotes of Haskell. Reason: TH splices and quasi-quotes compile and run a program, and then looks at the result. So it&amp;rsquo;s important that the program it compiles produces results whose representations are identical to those of the compiler itself.</source>
          <target state="translated">ソースからGHCをビルドする場合、テンプレートHaskellスプライスと準引用符を実行するには、少なくともステージ2のブートストラップコンパイラが必要です。ステージ1コンパイラは、Haskellの通常の引用のみを受け入れます。理由：THスプライスと準引用符がプログラムをコンパイルして実行し、その結果を調べます。したがって、コンパイルするプログラムが、コンパイラ自体の表現と同じ表現を持つ結果を生成することが重要です。</target>
        </trans-unit>
        <trans-unit id="969473549eb7eda775de0bbd5b7e1c35fe2a3fe0" translate="yes" xml:space="preserve">
          <source>If you are down to your last-compile-before-a-bug-report, we would recommend that you add a &lt;code&gt;-dcore-lint&lt;/code&gt; option (for extra checking) to your compilation options.</source>
          <target state="translated">last-compile-before-a-bug-reportに &lt;code&gt;-dcore-lint&lt;/code&gt; ている場合は、コンパイルオプションに-dcore-lintオプション（追加のチェック用）を追加することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="8db781218acb5f2994b23e09a56675a86f2ceeb8" translate="yes" xml:space="preserve">
          <source>If you are hit by this, you may want to compile the affected module with &lt;a href=&quot;using-optimisation#ghc-flag--fomit-yields&quot;&gt;&lt;code&gt;-fno-omit-yields&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;). This flag ensures that yield points are inserted at every function entrypoint (at the expense of a bit of performance).</source>
          <target state="translated">これに遭遇した場合は、影響を受けるモジュールを&lt;a href=&quot;using-optimisation#ghc-flag--fomit-yields&quot;&gt; &lt;code&gt;-fno-omit-yields&lt;/code&gt; &lt;/a&gt;でコンパイルすることができます（&lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f *：プラットフォームに依存しないフラグを&lt;/a&gt;参照）。このフラグにより​​、すべての関数エントリポイントに降伏点が確実に挿入されます（少しパフォーマンスが低下します）。</target>
        </trans-unit>
        <trans-unit id="ee2cd5fd786322ce97e57aaf58e15a0f10e358b1" translate="yes" xml:space="preserve">
          <source>If you are making foreign calls from multiple Haskell threads and using &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, make sure that the foreign code you are calling is thread-safe. In particularly, some GUI libraries are not thread-safe and require that the caller only invokes GUI methods from a single thread. If this is the case, you may need to restrict your GUI operations to a single Haskell thread, and possibly also use a bound thread (see &lt;a href=&quot;#haskell-threads-and-os-threads&quot;&gt;The relationship between Haskell threads and OS threads&lt;/a&gt;).</source>
          <target state="translated">複数のHaskellスレッドから外部呼び出しを&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;、-threadedを使用する場合は、呼び出す外部コードがスレッドセーフであることを確認してください。特に、一部のGUIライブラリはスレッドセーフではなく、呼び出し側が単一のスレッドからのみGUIメソッドを呼び出す必要があります。この場合、GUI操作を単一のHaskellスレッドに制限し、バインドされたスレッドも使用する必要がある場合があります（&lt;a href=&quot;#haskell-threads-and-os-threads&quot;&gt;HaskellスレッドとOSスレッドの関係を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="a3cb86bb37d550f99fb107d358e09f2ff4997d45" translate="yes" xml:space="preserve">
          <source>If you are setting language options in your &lt;code&gt;.ghci&lt;/code&gt; file, it is good practice to use &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt;, unless you really do want them to apply to all modules you load in GHCi.</source>
          <target state="translated">&lt;code&gt;.ghci&lt;/code&gt; ファイルで言語オプションを設定する場合は、GHCiにロードするすべてのモジュールに適用したい場合を除いて、&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt;ではなく&lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; &lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="2780984904c2d880871374ff9ccab143b480b0b2" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; keys, you will get much better performance for most operations using &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; キーを使用している場合、&lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;を使用するほとんどの操作でパフォーマンスが大幅に向上します。</target>
        </trans-unit>
        <trans-unit id="b97f8aaadda196835b4af2ea1886f79e9ad8ac0e" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; keys, you will get much better performance for most operations using &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; キーを使用している場合、&lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;を使用するほとんどの操作でパフォーマンスが大幅に向上します。</target>
        </trans-unit>
        <trans-unit id="3f1f508d47e724e488b898fb6b5424ab4c2ea295" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; keys, you will get much better performance for most operations using &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; キーを使用している場合は、&lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;を使用したほとんどの操作でパフォーマンスが大幅に向上します。</target>
        </trans-unit>
        <trans-unit id="f14f369071627bc2e08352734351733171bc0451" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; keys, you will get much better performance for most operations using &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; キーを使用している場合は、&lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;を使用したほとんどの操作でパフォーマンスが大幅に向上します。</target>
        </trans-unit>
        <trans-unit id="f294dc39561bb7510ab182cdc6070d0d208bd977" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;make&lt;/code&gt;, GHC can automatically generate the dependencies required in order to make sure that every module &lt;em&gt;is&lt;/em&gt; up-to-date with respect to its imported interfaces. Please see &lt;a href=&quot;separate_compilation#makefile-dependencies&quot;&gt;Dependency generation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;make&lt;/code&gt; を使用している場合、GHCはすべてのモジュール&lt;em&gt;が&lt;/em&gt;インポートされたインターフェースに関して最新であることを確認するために必要な依存関係を自動的に生成できます。&lt;a href=&quot;separate_compilation#makefile-dependencies&quot;&gt;依存関係の生成を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="64df0960b34991e4d85de84eb1668ccd834d0e6f" translate="yes" xml:space="preserve">
          <source>If you are using a Haskell &amp;ldquo;package&amp;rdquo; (see &lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;), don&amp;rsquo;t forget to add the relevant &lt;code&gt;-package&lt;/code&gt; option when linking the program too: it will cause the appropriate libraries to be linked in with the program. Forgetting the &lt;code&gt;-package&lt;/code&gt; option will likely result in several pages of link errors.</source>
          <target state="translated">あなたはHaskellの「パッケージ」（参照を使用している場合は&lt;a href=&quot;packages#packages&quot;&gt;パッケージ&lt;/a&gt;）、関連する追加することを忘れないでください &lt;code&gt;-package&lt;/code&gt; あまりにもプログラムをリンクオプションを：それは適切なライブラリがプログラムとリンクされるようになります。 &lt;code&gt;-package&lt;/code&gt; オプションを忘れると、数ページのリンクエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="7b7cc346da82320cb12d47cf0a63adf255287f4d" translate="yes" xml:space="preserve">
          <source>If you are using as system that doesn't support the mkdtemp glibc function (supported in glibc &amp;gt; 2.1.91) then this function uses mktemp and so shouldn't be considered safe.</source>
          <target state="translated">mkdtemp glibc関数（glibc&amp;gt; 2.1.91でサポート）をサポートしないシステムとして使用している場合、この関数はmktempを使用するため、安全とは見なされません。</target>
        </trans-unit>
        <trans-unit id="755c446ad00dee715ae6a725a7e54ef9a2b3bb98" translate="yes" xml:space="preserve">
          <source>If you are using as system that doesn't support the mkstemps glibc function (supported in glibc &amp;gt; 2.11) then this function simply throws an error.</source>
          <target state="translated">mkstemps glibc関数（glibc&amp;gt; 2.11でサポート）をサポートしないシステムとして使用している場合、この関数は単にエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="40ce0801a711815e8a0985a07d3d4a08fee712a7" translate="yes" xml:space="preserve">
          <source>If you are using external packages with &lt;strong&gt;cabal&lt;/strong&gt;, you may need to reinstall these packages with profiling support; typically this is done with &lt;code&gt;cabal install -p package --reinstall&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;cabal&lt;/strong&gt;で外部パッケージを使用している場合、これらのパッケージをプロファイリングサポートとともに再インストールする必要がある場合があります。通常、これは &lt;code&gt;cabal install -p package --reinstall&lt;/code&gt; で行われます。</target>
        </trans-unit>
        <trans-unit id="449e0cceb9882f742ae4ba71b581c42c65c1bc09" translate="yes" xml:space="preserve">
          <source>If you aren't using GHC or Hugs then this function simply wraps mktemp and so shouldn't be considered safe.</source>
          <target state="translated">GHC や Hugs を使っていない場合は、この関数は単に mktemp をラップしているだけなので、安全とは考えられません。</target>
        </trans-unit>
        <trans-unit id="c57e71626bccca627c9de3e0d23513402fbfad64" translate="yes" xml:space="preserve">
          <source>If you can't be bothered with the above, then you can build simple tables with simpleTable. Just provide the attributes for the whole table, attributes for the cells (same for every cell), and a list of lists of cell contents, and this function will build the table for you. It does presume that all the lists are non-empty, and there is at least one list.</source>
          <target state="translated">上記のようなことに煩わされないのであれば、simpleTableを使ってシンプルなテーブルを作成することができます。テーブル全体の属性、セルの属性(セルごとに同じ)、セル内容のリストを指定するだけで、この関数が代わりにテーブルを作成してくれます。この関数は、すべてのリストが空ではなく、少なくとも1つのリストがあることを前提としています。</target>
        </trans-unit>
        <trans-unit id="7c1274d2d2a7e0ba4a2c783c4ef67e9c677accd2" translate="yes" xml:space="preserve">
          <source>If you do not have an explicit export list in a module, GHC must assume that everything in that module will be exported. This has various pessimising effects. For example, if a bit of code is actually &lt;em&gt;unused&lt;/em&gt; (perhaps because of unfolding effects), GHC will not be able to throw it away, because it is exported and some other module may be relying on its existence.</source>
          <target state="translated">モジュールに明示的なエクスポートリストがない場合、GHCはそのモジュールのすべてがエクスポートされると想定する必要があります。これにはさまざまな悲観的な効果があります。たとえば、コードの一部が実際に&lt;em&gt;使用されていない場合&lt;/em&gt;（おそらく展開の影響のため）、GHCはそれを破棄できません。これは、コードがエクスポートされ、他のモジュールがその存在に依存している可能性があるためです。</target>
        </trans-unit>
        <trans-unit id="7a1ecd7c0b5ed67d9ee213cf7d0666e703994546" translate="yes" xml:space="preserve">
          <source>If you do not need the offset parameter then you do should be using &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackCStringLen&quot;&gt;unsafePackCStringLen&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackCStringFinalizer&quot;&gt;unsafePackCStringFinalizer&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">offsetパラメータが必要ない場合は、代わりに &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackCStringLen&quot;&gt;unsafePackCStringLen&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackCStringFinalizer&quot;&gt;unsafePackCStringFinalizer&lt;/a&gt;&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="dacf0556d43b3d2afe433d11b8b9c360f1380a6b" translate="yes" xml:space="preserve">
          <source>If you do not write out the constructors, you may need to give a kind annotation (&lt;a href=&quot;glasgow_exts#kinding&quot;&gt;Explicitly-kinded quantification&lt;/a&gt;), to tell GHC the kind of the type variable, if it is not &amp;ldquo;*&amp;rdquo;. (In source files, this is worked out from the way the type variable is used in the constructors.) For example:</source>
          <target state="translated">コンストラクターを&lt;a href=&quot;glasgow_exts#kinding&quot;&gt;書き出さ&lt;/a&gt;ない場合は、種類の注釈（明示的な種類の数量化）を指定して、型変数の種類が「*」でない場合にGHCに通知する必要があります。（ソースファイルでは、これはコンストラクターで型変数が使用される方法から算出されます。）例：</target>
        </trans-unit>
        <trans-unit id="4308cfa9bfacb8d98d2c6bb15e1dd09df45e6181" translate="yes" xml:space="preserve">
          <source>If you do not write out the constructors, you may need to give a kind to tell GHC what the kinds of the type variables are, if they are not the default &lt;code&gt;*&lt;/code&gt;. Unlike regular data type declarations, the return kind of an abstract data declaration can be anything (in which case it probably will be implemented using a type synonym.) This can be used to allow compile-time representation polymorphism (as opposed to &lt;a href=&quot;#runtime-rep&quot;&gt;run-time representation polymorphism&lt;/a&gt;), as in this example:</source>
          <target state="translated">コンストラクターを書き出さない場合、タイプ変数の種類がデフォルトの &lt;code&gt;*&lt;/code&gt; ではない場合、GHCにタイプ変数の種類を伝えるために種類を指定する必要がある場合があります。通常のデータ型宣言とは異なり、抽象データ宣言の戻り値の種類は何でもかまいません（この場合、型の同義語を使用して実装される可能性があります）。これは、（&lt;a href=&quot;#runtime-rep&quot;&gt;実行&lt;/a&gt;時ではなく）コンパイル時の表現の多態性を可能にするために使用できます。この例のように、表現ポリモーフィズム）：</target>
        </trans-unit>
        <trans-unit id="00d8e4e35d4f313452afad0626c5a13b4457d20a" translate="yes" xml:space="preserve">
          <source>If you do want custom history behavior, you may need to disable the above default setting(s).</source>
          <target state="translated">カスタム履歴の動作を希望する場合は、上記のデフォルト設定を無効にする必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="c92f00276e7b4844202319651693a66141bcfc09" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have &lt;code&gt;cygpath&lt;/code&gt;, you probably don&amp;rsquo;t have cygwin and hence no problems with it&amp;hellip; unless you want to write one build process for several platforms. Again, relative paths are your friend, but if you have to use absolute paths, and don&amp;rsquo;t want to use different tools on different platforms, you can simply write a short Haskell program to print the current directory (thanks to George Russell for this idea): compiled with GHC, this will give you the view of the file system that GHC depends on (which will differ depending on whether GHC is compiled with cygwin&amp;rsquo;s gcc or mingw&amp;rsquo;s gcc or on a real Unix system..) - that little program can also deal with escaping &lt;code&gt;\\&lt;/code&gt; in paths. Apart from the banner and the startup time, something like this would also do:</source>
          <target state="translated">&lt;code&gt;cygpath&lt;/code&gt; がない場合は、おそらくcygwinがないので、問題はありません&amp;hellip;複数のプラットフォーム用に1つのビルドプロセスを作成する場合を除きます。繰り返しになりますが、相対パスは友だちですが、絶対パスを使用する必要があり、異なるプラットフォームで異なるツールを使用したくない場合は、短いHaskellプログラムを記述して、現在のディレクトリを出力できます（George Russellに感謝します）。アイデア）：GHCでコンパイルすると、GHCが依存するファイルシステムのビューが表示されます（GHCがcygwinのgccまたはmingwのgccでコンパイルされているか、実際のUnixシステムでコンパイルされているかによって異なります）-その小さなプログラムパス内の &lt;code&gt;\\&lt;/code&gt; のエスケープも処理できます。バナーと起動時間とは別に、次のようなこともできます。</target>
        </trans-unit>
        <trans-unit id="dbfd1c6f422cd2cb2dbbb7fda57624d1324776cf" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have &lt;code&gt;cygpath&lt;/code&gt;, you probably don&amp;rsquo;t have cygwin and hence no problems with it... unless you want to write one build process for several platforms. Again, relative paths are your friend, but if you have to use absolute paths, and don&amp;rsquo;t want to use different tools on different platforms, you can simply write a short Haskell program to print the current directory (thanks to George Russell for this idea): compiled with GHC, this will give you the view of the file system that GHC depends on (which will differ depending on whether GHC is compiled with cygwin&amp;rsquo;s gcc or mingw&amp;rsquo;s gcc or on a real Unix system..) - that little program can also deal with escaping &lt;code&gt;\\&lt;/code&gt; in paths. Apart from the banner and the startup time, something like this would also do:</source>
          <target state="translated">&lt;code&gt;cygpath&lt;/code&gt; がない場合は、おそらくcygwinがないので問題はありません...複数のプラットフォーム用に1つのビルドプロセスを作成する場合を除きます。繰り返しになりますが、相対パスはあなたの友人ですが、絶対パスを使用する必要があり、異なるプラットフォームで異なるツールを使用したくない場合は、現在のディレクトリを印刷する短いHaskellプログラムを作成するだけです（これについてはGeorge Russellに感謝します） idea）：GHCでコンパイルすると、GHCが依存するファイルシステムのビューが表示されます（これは、GHCがcygwinのgccまたはmingwのgccでコンパイルされているか、実際のUnixシステムでコンパイルされているかによって異なります。）-その小さなプログラムパス内の &lt;code&gt;\\&lt;/code&gt; のエスケープも処理できます。バナーと起動時間は別として、次のようなこともできます。</target>
        </trans-unit>
        <trans-unit id="a6ca8436639b62f991d1a8bca7a44877f0eba7f3" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t know what virtual memory, thrashing, and page faults are, or you don&amp;rsquo;t know the memory configuration of your machine, &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; try to be clever about memory use: you&amp;rsquo;ll just make your life a misery (and for other people, too, probably).</source>
          <target state="translated">仮想メモリ、スラッシング、ページフォールトがわからない場合、またはマシンのメモリ構成が&lt;em&gt;わからない&lt;/em&gt;場合は、メモリの使用について賢く&lt;em&gt;考えないで&lt;/em&gt;ください。人生を悲惨なものにするだけです。 （そしておそらく他の人々にとっても）。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
